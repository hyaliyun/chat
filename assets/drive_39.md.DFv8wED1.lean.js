import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-83ea647c"]]),S=JSON.parse('[{"question":"# Reverse a Linked List using Recursion In this exercise, you will implement the `reverse_linked_list` function, which uses recursion to reverse a singly linked list. The function takes as input the head node of a linked list and returns the new head of the list after reversing it. Function Signature ```python def reverse_linked_list(head: ListNode) -> ListNode: ``` Input: - `head`: The head node of a singly linked list. Output: - A `ListNode` representing the new head of the reversed linked list. Constraints: 1. The linked list can be empty (i.e., `head` can be `None`). 2. The function should handle lists with a single node correctly. 3. Ensure the recursion depth does not exceed the maximum recursion limit of the programming environment. # Example Usage: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1: Reverse a list with multiple elements node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node1.next = node2 node2.next = node3 new_head = reverse_linked_list(node1) # The new_head should represent the reversed list: 3 -> 2 -> 1 -> None # Example 2: Single element list single_node = ListNode(1) new_head_single = reverse_linked_list(single_node) # The new_head_single should be the same single_node, as the list is already reversed # Example 3: Empty list empty_list = None new_head_empty = reverse_linked_list(empty_list) # The new_head_empty should be None, as there\'s nothing to reverse ``` # Implementation Notes: Your function should recursively reverse the linked list by following these steps: - If the list is empty or contains only one node, return the head as is. - Otherwise, recursively reverse the rest of the list. - Then adjust the next pointers to complete the reversal. - Ensure clear and readable code with comments explaining the key steps. Here is the implementation outline to guide you: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: # Base case: If the list is empty or has reached the last node if head is None or head.next is None: return head # Recurse on the next node new_head = reverse_linked_list(head.next) # Adjust the pointers head.next.next = head head.next = None return new_head ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list using recursion. Args: head (ListNode): The head node of the linked list. Returns: ListNode: The new head of the reversed linked list. # Base case: If the list is empty or has reached the last node if head is None or head.next is None: return head # Recurse on the next node new_head = reverse_linked_list(head.next) # Adjust the pointers head.next.next = head head.next = None return new_head"},{"question":"# Question: Hexadecimal and String Conversion Functions You are tasked with implementing two functions for converting hexadecimal strings to their ASCII string representations and vice versa. Function 1: `hex_to_ascii(hex_string: str) -> str` Implement a function that takes a hexadecimal string and converts it to its ASCII string representation. **Inputs:** * `hex_string (str)`: A string representing a sequence of hexadecimal values, e.g., \\"48656c6c6f\\". **Outputs:** * `str`: The ASCII string representation of the hexadecimal input. **Constraints:** * The input string must be a valid hexadecimal string with an even number of characters. * Each pair of hexadecimal digits (one byte) must form a valid ASCII character. Input Examples: - `\\"48656c6c6f\\"` - `\\"576f726c64\\"` Output Examples: - `\\"Hello\\"` - `\\"World\\"` Function 2: `ascii_to_hex(ascii_string: str) -> str` Implement a function that takes an ASCII string and converts it to its hexadecimal string representation. **Inputs:** * `ascii_string (str)`: A string representing an ASCII text, e.g., \\"Hello\\". **Outputs:** * `str`: The hexadecimal string representation of the ASCII input. **Constraints:** * The input string must be a valid ASCII string. Input Examples: - `\\"Hello\\"` - `\\"World\\"` Output Examples: - `\\"48656c6c6f\\"` - `\\"576f726c64\\"` # Requirements 1. You must handle edge cases such as invalid hexadecimal formats or non-ASCII characters. 2. Efficiently convert between the two representations with minimal use of memory and time. 3. Implement proper error conditions where inputs do not meet expected formats or constraints. Examples Example 1: ```python >>> hex_to_ascii(\\"48656c6c6f\\") \'Hello\' >>> hex_to_ascii(\\"576f726c64\\") \'World\' ``` Example 2: ```python >>> ascii_to_hex(\'Hello\') \'48656c6c6f\' >>> ascii_to_hex(\'World\') \'576f726c64\' ``` Write the implementations for both functions ensuring they fulfill the requirements and handle all edge cases appropriately.","solution":"def hex_to_ascii(hex_string: str) -> str: Converts a hexadecimal string to its ASCII string representation. if len(hex_string) % 2 != 0: raise ValueError(\\"Hexadecimal string must have an even number of characters\\") try: ascii_string = bytes.fromhex(hex_string).decode(\'ascii\') except ValueError: raise ValueError(\\"Invalid hexadecimal string or non-ASCII characters encountered\\") return ascii_string def ascii_to_hex(ascii_string: str) -> str: Converts an ASCII string to its hexadecimal string representation. try: hex_string = ascii_string.encode(\'ascii\').hex() except UnicodeEncodeError: raise ValueError(\\"Non-ASCII characters found in input string\\") return hex_string"},{"question":"# Problem Statement Create a class `MatrixUtils` that provides various utilities for matrix operations. The methods should be designed to handle square matrices of integers efficiently, considering all edge cases and constraints. # Method Specifications: 1. **transpose(matrix: list) -> list**: - Calculates and returns the transpose of a given square matrix. - **Input**: A list of lists representing a square matrix of integers. - **Output**: A list of lists representing the transpose of the input matrix. - **Constraints**: Raise a ValueError if the input is not a square matrix. 2. **is_symmetric(matrix: list) -> bool**: - Checks whether a given square matrix is symmetric. - **Input**: A list of lists representing a square matrix of integers. - **Output**: A boolean value, `True` if the matrix is symmetric, otherwise `False`. - **Constraints**: Raise a ValueError if the input is not a square matrix. 3. **matrix_multiplication(matrix1: list, matrix2: list) -> list**: - Multiplies two given square matrices and returns the resultant matrix. - **Input**: Two lists of lists representing square matrices of integers. - **Output**: A list of lists representing the product of the two input matrices. - **Constraints**: Raise a ValueError if the input matrices are not of the same dimensions or not square matrices. 4. **determinant(matrix: list) -> int**: - Computes and returns the determinant of a given square matrix. - **Input**: A list of lists representing a square matrix of integers. - **Output**: An integer representing the determinant of the input matrix. - **Constraints**: Raise a ValueError if the input is not a square matrix. # Implementation Details - Ensure the methods can handle edge cases and constraints efficiently. - All methods should handle worst-case scenarios within reasonable time limits. - You may use any internal helper functions if necessary, but they should be encapsulated within the class. - Proper error handling for edge cases and invalid inputs should be implemented. Here is an initial structure of the class for reference: ```python class MatrixUtils: def transpose(self, matrix: list) -> list: # Your code here pass def is_symmetric(self, matrix: list) -> bool: # Your code here pass def matrix_multiplication(self, matrix1: list, matrix2: list) -> list: # Your code here pass def determinant(self, matrix: list) -> int: # Your code here pass ``` **Note** - Ensure to adhere to the method signatures. - Standard Python libraries can be used for auxiliary computations. - Raise a `ValueError` for invalid inputs according to the constraints mentioned for each method. # Example Usage ```python mu = MatrixUtils() matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix2 = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] print(mu.transpose(matrix1)) # Output: [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(mu.is_symmetric(matrix1)) # Output: False print(mu.matrix_multiplication(matrix1, matrix2)) # Output: [ # [30, 24, 18], # [84, 69, 54], # [138, 114, 90] # ] print(mu.determinant(matrix1)) # Output: 0 ```","solution":"class MatrixUtils: def transpose(self, matrix: list) -> list: if not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input is not a square matrix.\\") return [list(row) for row in zip(*matrix)] def is_symmetric(self, matrix: list) -> bool: if not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input is not a square matrix.\\") for i in range(len(matrix)): for j in range(len(matrix)): if matrix[i][j] != matrix[j][i]: return False return True def matrix_multiplication(self, matrix1: list, matrix2: list) -> list: if not (all(len(row) == len(matrix1) for row in matrix1) and all(len(row) == len(matrix2) for row in matrix2) and len(matrix1) == len(matrix2)): raise ValueError(\\"Input matrices are not of the same dimensions or not square matrices.\\") size = len(matrix1) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += matrix1[i][k] * matrix2[k][j] return result def determinant(self, matrix: list) -> int: if not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input is not a square matrix.\\") size = len(matrix) if size == 1: return matrix[0][0] if size == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(size): submatrix = [row[:c] + row[c+1:] for row in matrix[1:]] det += ((-1) ** c) * matrix[0][c] * self.determinant(submatrix) return det"},{"question":"# Problem Statement: You are given a matrix of integers where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. Your task is to implement a function that returns an element\'s position (row, column) in the matrix if it exists, otherwise returns (-1, -1). # Function Signature: ```python def search_matrix(matrix: list[list[int]], target: int) -> tuple[int, int]: ``` # Input: * `matrix`: A list of lists of integers (0 ≤ len(matrix) ≤ 300, 0 ≤ len(matrix[0]) ≤ 300, -10^9 ≤ matrix[i][j] ≤ 10^9) * `target`: An integer, the number to search for in the matrix. # Output: * A tuple `(row, column)` representing the position of the target number in the matrix, or `(-1, -1)` if the target is not found. # Constraints: * The function should be efficient with an upper bound time complexity of O(M + N) where `M` is the number of rows and `N` is the number of columns. * Each element in the matrix provides information relevant to sorting, and the function should take advantage of this layout to optimize the search. * You can use helper functions and additional data structures if needed. # Examples: ```python assert search_matrix([[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], 5) == (1, 1) assert search_matrix([[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], 20) == (-1, -1) assert search_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 9) == (2, 2) assert search_matrix([[1]], 1) == (0, 0) assert search_matrix([[]], 1) == (-1, -1) ``` # Scenario: Imagine you are a botanist who maintains a large spreadsheet of plant growth data, organized such that each row represents a day and each column a different plant species. You want to determine where a certain growth milestone (target) first appears in this matrix. Your function will assist in efficiently locating this milestone or confirming its absence.","solution":"def search_matrix(matrix: list[list[int]], target: int) -> tuple[int, int]: Returns the position (row, column) of target in the matrix if it exists, otherwise returns (-1, -1). The matrix is sorted in ascending order both row-wise and column-wise. if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Question You are assigned to implement a priority queue using a binary heap structure to manage tasks based on their priority. The priority queue should be able to handle enqueueing tasks with varying priority levels and dequeueing the task with the highest priority efficiently. # Requirements Write a class `PriorityQueue` that supports the following operations: 1. **enqueue**: Adds a task with a specific priority to the queue. 2. **dequeue**: Removes and returns the task with the highest priority from the queue. 3. **peek**: Returns the task with the highest priority without removing it from the queue. 4. **is_empty**: Returns `True` if the queue is empty, otherwise `False`. # Class Definition ```python class PriorityQueue: def __init__(self): self.heap = [] def enqueue(self, task: str, priority: int) -> None: Add a task with a specified priority to the priority queue. Args: task: The task to be added to the queue. priority: The priority level of the task (integer). Example: >>> pq = PriorityQueue() >>> pq.enqueue(\\"task1\\", 2) >>> pq.enqueue(\\"task2\\", 5) >>> pq.enqueue(\\"task3\\", 1) # Implementation here pass def dequeue(self) -> str: Remove and return the task with the highest priority. Returns: The task with the highest priority. Example: >>> pq = PriorityQueue() >>> pq.enqueue(\\"task1\\", 2) >>> pq.enqueue(\\"task2\\", 5) >>> pq.enqueue(\\"task3\\", 1) >>> pq.dequeue() \'task2\' # Implementation here pass def peek(self) -> str: Return the task with the highest priority without removing it from the queue. Returns: The task with the highest priority. Example: >>> pq = PriorityQueue() >>> pq.enqueue(\\"task1\\", 2) >>> pq.enqueue(\\"task2\\", 5) >>> pq.enqueue(\\"task3\\", 1) >>> pq.peek() \'task2\' # Implementation here pass def is_empty(self) -> bool: Check if the priority queue is empty. Returns: True if the queue is empty, otherwise False. Example: >>> pq = PriorityQueue() >>> pq.is_empty() True # Implementation here pass ``` # Constraints 1. The `enqueue` operation should maintain the heap property efficiently. 2. The `dequeue` operation should remove the task with the highest priority and maintain the heap property. 3. The `peek` operation should return the task with the highest priority without modifying the queue. 4. Assume priority values are integers where higher values represent higher priorities. # Assumptions 1. Tasks are represented as strings. 2. Priority values are unique and positive integers. 3. The priority queue uses a binary max-heap for implementation. # Example Usage ```python pq = PriorityQueue() pq.enqueue(\\"task1\\", 2) pq.enqueue(\\"task2\\", 5) pq.enqueue(\\"task3\\", 1) print(pq.peek()) # Output: \'task2\' print(pq.dequeue()) # Output: \'task2\' print(pq.dequeue()) # Output: \'task1\' print(pq.is_empty()) # Output: False print(pq.dequeue()) # Output: \'task3\' print(pq.is_empty()) # Output: True ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def enqueue(self, task: str, priority: int) -> None: Add a task with a specified priority to the priority queue. # We use a negative priority because heapq is a min-heap by default in Python, # but we need a max-heap behavior. heapq.heappush(self.heap, (-priority, task)) def dequeue(self) -> str: Remove and return the task with the highest priority. if self.is_empty(): raise IndexError(\\"dequeue from an empty priority queue\\") _, task = heapq.heappop(self.heap) return task def peek(self) -> str: Return the task with the highest priority without removing it from the queue. if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") _, task = self.heap[0] return task def is_empty(self) -> bool: Check if the priority queue is empty. return len(self.heap) == 0"},{"question":"# Palindromic Sum **Overview**: A number is said to be a palindromic number if it reads the same backward as forward. Sometimes, a non-palindromic number can be converted to a palindromic number by repeatedly reversing its digits and adding the result to the original number. This process is repeated until a palindromic sum is achieved. **Task**: Write a function `palindromic_sum(num: int) -> int` that performs the following steps: 1. Validate the input to ensure `num` is a positive integer. 2. Continuously reverse the digits of the number and add the result to the original number until a palindromic number is obtained. 3. Return the palindromic number that is achieved through this process. **Function Signature**: ```python def palindromic_sum(num: int) -> int: ``` **Input**: - `num` (integer): The initial number to start the process. **Output**: - Integer: The palindromic sum achieved from the initial number. **Example**: ```python >>> palindromic_sum(56) 121 >>> palindromic_sum(87) 4884 ``` **Constraints**: - `1 <= num <= 10^4` **Requirements**: 1. Your function should include proper validation to handle invalid input and raise appropriate errors. 2. The solution should efficiently check for palindromic properties at each step. **Hints**: - Use a helper function to check if a number is palindromic. - Be mindful of the integer size during the iterative process, as sums might grow large. **Scenario/Context**: Imagine you are developing a puzzle-solving app that challenges users with number games. One game involves converting numbers to palindromic sums through a specific method. Your task is to implement the core function that computes this transformation.","solution":"def is_palindrome(num: int) -> bool: return str(num) == str(num)[::-1] def palindromic_sum(num: int) -> int: if not isinstance(num, int) or num <= 0: raise ValueError(\\"Input must be a positive integer\\") while not is_palindrome(num): num += int(str(num)[::-1]) return num"},{"question":"# Problem Description You are to create a function that finds the shortest path in a maze represented by a 2D grid. The grid consists of cells with values \'S\' for the start point, \'E\' for the end point, \'1\' for walls, and \'0\' for open paths. Your function should return the minimum number of steps required to reach the end point from the start point using valid moves (up, down, left, right), or -1 if there is no path. The maze will always have one \'S\' and one \'E\'. # Function Specifications Function Name ```python def shortest_path_in_maze(maze: List[List[str]]) -> int ``` Input - `maze` (List[List[str]]): A 2D grid of strings representing the maze. Each cell can be \'S\', \'E\', \'0\', or \'1\'. Constraints: 2 ≤ len(maze), len(maze[0]) ≤ 1000. Output - Returns the minimum number of steps to reach the end point \'E\' from the start point \'S\'. If no path exists, return -1. Error Handling - If the input is not a 2D grid or is malformed, raise an appropriate exception. # Constraints 1. The grid will always contain exactly one \'S\' and one \'E\'. 2. The grid\'s size does not exceed 1000 x 1000. # Example ```python # Example of a maze and calling shortest_path_in_maze(maze) maze = [ [\'S\', \'0\', \'1\', \'0\'], [\'1\', \'0\', \'1\', \'0\'], [\'0\', \'0\', \'0\', \'E\'], [\'0\', \'1\', \'1\', \'1\'] ] assert shortest_path_in_maze(maze) == 5 # Example of no path: maze_no_path = [ [\'S\', \'1\', \'1\', \'1\'], [\'1\', \'1\', \'1\', \'1\'], [\'1\', \'1\', \'1\', \'E\'], [\'1\', \'1\', \'1\', \'1\'] ] assert shortest_path_in_maze(maze_no_path) == -1 # Example of handling invalid inputs: try: shortest_path_in_maze([[\'S\', \'E\']]) except ValueError as e: print(str(e)) # should output something akin to \\"Input maze should be a 2D grid with valid dimensions and characters\\" ``` # Notes 1. Use an efficient algorithm such as Breadth-First Search (BFS) to handle searching for paths in the grid. 2. Handle edge cases where either the start or end is blocked immediately. 3. Ensure proper validation of the input grid to cater to malformed cases (e.g., invalid grid dimensions, missing \'S\' or \'E\').","solution":"from typing import List, Tuple from collections import deque def shortest_path_in_maze(maze: List[List[str]]) -> int: if not maze or not all(isinstance(row, list) for row in maze): raise ValueError(\\"Input maze should be a 2D grid with valid dimensions and characters\\") def find_start_end(maze: List[List[str]]) -> Tuple[Tuple[int, int], Tuple[int, int]]: start, end = None, None for i in range(len(maze)): for j in range(len(maze[i])): if maze[i][j] == \'S\': start = (i, j) elif maze[i][j] == \'E\': end = (i, j) if start is None or end is None: raise ValueError(\\"Both start \'S\' and end \'E\' points must be present in the maze\\") return start, end start, end = find_start_end(maze) rows, cols = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up def is_valid(x: int, y: int) -> bool: return 0 <= x < rows and 0 <= y < cols and maze[x][y] != \'1\' queue = deque([(start, 0)]) # (current_position, current_steps) visited = set() visited.add(start) while queue: (current_x, current_y), steps = queue.popleft() for dx, dy in directions: new_x, new_y = current_x + dx, current_y + dy if (new_x, new_y) == end: return steps + 1 if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append(((new_x, new_y), steps + 1)) return -1"},{"question":"# Coding Assessment Question Context You are tasked with enhancing a text-based notes management system by creating a feature that can search and retrieve notes based on specific keywords. Task Create a class `NotesManager` which should have the following methods: 1. `add_note` - Adds a new note to the system. 2. `search_notes` - Searches for notes containing a specific keyword and returns the matches. Requirements 1. Implement the `NotesManager` class. 2. The class should store notes in a dictionary where the keys are unique note IDs and values are strings representing the notes. 3. Implement the following methods: * `add_note` - Takes a string `note` as input, stores the note in the dictionary, and returns the unique note ID. * `search_notes` - Takes a string `keyword` as input and returns a list of note IDs whose corresponding notes contain the keyword (case-insensitive). Input and Output * **Input** for `add_note`: A string `note` representing the content of the note. * **Output** for `add_note`: An integer representing the unique note ID assigned to the note. * **Input** for `search_notes`: A string `keyword` representing the keyword to search for within the notes. * **Output** for `search_notes`: A list of integers representing the note IDs that contain the `keyword`. Constraints * The `NotesManager` should handle up to 1000 notes. * Keywords searched are not case-sensitive. Example: ```python notes = NotesManager() id1 = notes.add_note(\\"Learn Python programming\\") id2 = notes.add_note(\\"Python syntax is readable and easy to learn\\") id3 = notes.add_note(\\"Using Python for web development\\") search_result = notes.search_notes(\\"python\\") print(search_result) # Output: [1, 2, 3] search_result = notes.search_notes(\\"web\\") print(search_result) # Output: [3] ```","solution":"class NotesManager: def __init__(self): self.notes = {} self.next_id = 1 def add_note(self, note): note_id = self.next_id self.notes[note_id] = note self.next_id += 1 return note_id def search_notes(self, keyword): keyword_lower = keyword.lower() return [note_id for note_id, note in self.notes.items() if keyword_lower in note.lower()]"},{"question":"# Stock Price Analyzer **Context**: You are working on a financial analysis tool that helps in examining and predicting stock prices based on historical data. A key part of this tool requires identifying specific patterns and metrics in stock price movements. **Task**: Write a function `find_high_low_days` that given a list of daily closing prices for a stock, will compute and return the days (indices) on which the price was the highest and the lowest within that period. * **Input**: - A list of daily closing prices (List of floats). * **Output**: - A dictionary `{ \\"highest\\": int, \\"lowest\\": int }` where the values are the indices of the highest and lowest prices in the list, respectively. * **Constraints**: - The list of prices is guaranteed to have at least one element. - In case of ties (multiple highest or lowest values), choose the first occurrence. * **Performance Requirements**: Ensure that your solution runs efficiently, even for large input lists. ```python def find_high_low_days(prices: list[float]) -> dict[str, int]: # Implement your solution here pass # Example: prices = [120.5, 121.0, 120.0, 122.0, 119.5, 120.0] # The highest price is 122.0 at index 3, and the lowest price is 119.5 at index 4. # Expected Output: # { # \\"highest\\": 3, # \\"lowest\\": 4 # } ``` **Note**: Ensure to handle edge cases and document the behavior of your function, such as what happens if the list has all identical prices.","solution":"def find_high_low_days(prices: list[float]) -> dict[str, int]: highest_index = 0 lowest_index = 0 for i in range(1, len(prices)): if prices[i] > prices[highest_index]: highest_index = i if prices[i] < prices[lowest_index]: lowest_index = i return {\\"highest\\": highest_index, \\"lowest\\": lowest_index}"},{"question":"**Problem Statement:** You are tasked with developing a function that finds the minimum number of coins needed to make up a given amount with a provided set of coin denominations. Each coin can be used an unlimited number of times. Write a function `min_coin_count(coins: list[int], amount: int) -> int` that: - Receives an array of distinct integers `coins` representing coin denominations and an integer `amount` representing the total amount of money. - Returns the minimal number of coins needed to make up the given amount. - If it is not possible to make up that amount, return -1. # Constraints: - All elements in `coins` are positive integers. - Elements in `coins` are distinct. - 1 ≤ length of `coins` ≤ 50 - 1 ≤ `amount` ≤ 10^4 # Input: - `coins`: List of distinct positive integers representing coin denominations. - `amount`: A positive integer representing the target amount of money. # Output: - An integer denoting the minimal number of coins needed to make up the amount, or -1 if it\'s not possible. # Example: Example 1: ``` Input: coins = [1, 2, 5] amount = 11 Output: 3 Explanation: The minimum number of coins needed: 11 = 5 + 5 + 1, using 3 coins. ``` Example 2: ``` Input: coins = [2] amount = 3 Output: -1 Explanation: It is not possible to make up the amount 3 with only the coin denomination 2. ``` Example 3: ``` Input: coins = [1, 2, 5, 10] amount = 18 Output: 4 Explanation: The minimum number of coins needed: 18 = 10 + 5 + 2 + 1, using 4 coins. ``` Implement the most efficient solution you can devise using dynamic programming.","solution":"def min_coin_count(coins, amount): Function to find the minimum number of coins needed to make up a given amount. # Initialize the dp array with inf. # dp[i] will be storing the minimum number of coins required for amount i dp = [float(\'inf\')] * (amount + 1) # Base case: No coins are needed to make up 0 amount dp[0] = 0 # Iterate through all amounts from 1 to \'amount\' for i in range(1, amount + 1): for coin in coins: # If the coin value is less than or equal to the amount, # only then we can use it to form the given amount if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"# Graph Data Structure and Search Algorithm Create a class `Graph` that represents an undirected, unweighted graph and supports the following operations: 1. Adding nodes. 2. Adding edges between nodes. 3. Performing a Breadth-First Search (BFS) starting from a given node. In addition, implement a function `bfs_connected_components` that takes an instance of `Graph` and returns a dictionary where keys are node names and values are lists of nodes that are in the same connected component as the key node, determined via BFS. # Requirements: Class: * **Graph** * `add_node(self, node: str) -> None`: Adds a node to the graph. * `add_edge(self, node1: str, node2: str) -> None`: Adds an undirected edge between two nodes. * `bfs(self, start: str) -> List[str]`: Performs BFS and returns the list of nodes visited from the starting node. Function: * **bfs_connected_components** * **Input**: * `graph`: Graph - an instance of the Graph class. * **Output**: * Dictionary where each key is a node and the value is a list of nodes in its connected component. # Scenario: You are tasked with identifying connected components of an undirected graph using BFS. Given a graph with some disconnected parts, determine which nodes are reachable from each other. # Example: ```python g = Graph() g.add_node(\'A\') g.add_node(\'B\') g.add_node(\'C\') g.add_node(\'D\') g.add_node(\'E\') g.add_edge(\'A\', \'B\') g.add_edge(\'A\', \'C\') g.add_edge(\'B\', \'C\') g.add_edge(\'D\', \'E\') # Performing BFS from \'A\' print(g.bfs(\'A\')) # Output: [\'A\', \'B\', \'C\'] components = bfs_connected_components(g) # Output should indicate that \'A\', \'B\', \'C\' are in one connected component # and \'D\', \'E\' are in another. print(components) # Output: { # \'A\': [\'A\', \'B\', \'C\'], # \'B\': [\'A\', \'B\', \'C\'], # \'C\': [\'A\', \'B\', \'C\'], # \'D\': [\'D\', \'E\'], # \'E\': [\'D\', \'E\'] # } ``` Ensure your implementation handles cases where nodes are isolated or where the graph is fully connected. Also, ensure that BFS does not revisit nodes unnecessarily.","solution":"from collections import deque, defaultdict class Graph: def __init__(self): self.nodes = set() self.edges = defaultdict(list) def add_node(self, node: str) -> None: self.nodes.add(node) def add_edge(self, node1: str, node2: str) -> None: self.edges[node1].append(node2) self.edges[node2].append(node1) def bfs(self, start: str): visited = set() queue = deque([start]) order = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) order.append(node) for neighbor in self.edges[node]: if neighbor not in visited: queue.append(neighbor) return order def bfs_connected_components(graph): visited = set() components = {} for node in graph.nodes: if node not in visited: connected_component = graph.bfs(node) for component_node in connected_component: components[component_node] = connected_component visited.add(component_node) return components # Example usage: g = Graph() g.add_node(\'A\') g.add_node(\'B\') g.add_node(\'C\') g.add_node(\'D\') g.add_node(\'E\') g.add_edge(\'A\', \'B\') g.add_edge(\'A\', \'C\') g.add_edge(\'B\', \'C\') g.add_edge(\'D\', \'E\') print(g.bfs(\'A\')) # Output: [\'A\', \'B\', \'C\'] components = bfs_connected_components(g) print(components) # Output: { # \'A\': [\'A\', \'B\', \'C\'], # \'B\': [\'A\', \'B\', \'C\'], # \'C\': [\'A\', \'B\', \'C\'], # \'D\': [\'D\', \'E\'], # \'E\': [\'D\', \'E\'] # }"},{"question":"# Scenario You are developing a software for a digital music library. To manage the playlists, you need to write a function to calculate the total duration of songs in a playlist and determine if the playlist exceeds a certain maximum allowed duration. # Task Write a function `check_playlist_duration(playlist, max_duration)` that: 1. Calculates the total duration of the playlist. 2. Checks if the total duration exceeds the `max_duration`. 3. Returns a tuple containing a boolean indicating whether the playlist exceeds the maximum duration, and the total duration of the playlist. # Input and Output Formats Input * `playlist` (list of tuples): Each tuple contains two elements: - The first element is the name of the song (string). - The second element is the duration of the song in seconds (integer). * `max_duration` (integer): The maximum allowed duration of the playlist in seconds. Output * A tuple containing: - A boolean indicating whether the total duration of the playlist exceeds `max_duration`. - The total duration of the playlist in seconds. # Function Signature ```python def check_playlist_duration(playlist: list[tuple[str, int]], max_duration: int) -> tuple[bool, int]: ``` # Example ```python # Example 1 # Playlist has songs with durations summing to 180 seconds. print(check_playlist_duration([(\\"Song1\\", 120), (\\"Song2\\", 60)], max_duration=200)) # Output: (False, 180) # Example 2 # Playlist has songs with durations summing to 200 seconds. print(check_playlist_duration([(\\"Song1\\", 150), (\\"Song2\\", 50), (\\"Song3\\", 10)], max_duration=200)) # Output: (True, 210) # Example 3 # Empty playlist print(check_playlist_duration([], max_duration=100)) # Output: (False, 0) ``` # Constraints * The `playlist` list will contain between 0 and 1000 songs. * Each song duration will be a positive integer not exceeding 6000 seconds. * `max_duration` will be a positive integer not exceeding 36000 seconds (10 hours). # Notes * Assume that the input playlist is always a valid list of tuples containing song names and durations.","solution":"def check_playlist_duration(playlist, max_duration): Returns a tuple indicating if the total duration of songs in the playlist exceeds the max_duration, and the total duration of the playlist. Parameters: playlist (list of tuples): Each tuple contains the name of the song (string) and its duration in seconds (int). max_duration (int): The maximum allowed duration of the playlist in seconds. Returns: tuple: (boolean, int) where the boolean indicates if the total duration exceeds max_duration, and the int is the total duration of the playlist. total_duration = sum(duration for _, duration in playlist) exceeds_max = total_duration > max_duration return (exceeds_max, total_duration)"},{"question":"# Question Your task is to create a function to determine if a given integer is a perfect square using a binary search approach. A perfect square is an integer that is the square of an integer; in other words, it can be expressed as the product of an integer with itself. Implement a function named `is_perfect_square` that determines if a given number is a perfect square without using any built-in exponentiation or square root functions. # Requirements * **Function Signature**: `def is_perfect_square(num: int) -> bool:` * **Parameters**: - `num`: An integer to check if it is a perfect square. * **Returns**: A boolean value indicating whether the input number is a perfect square or not. # Constraints 1. The input `num` will be a non-negative integer. 2. Think about the edge cases such as 0 or very large numbers. # Example ```python print(is_perfect_square(16)) # Output should be True (4*4) print(is_perfect_square(14)) # Output should be False print(is_perfect_square(1)) # Output should be True (1*1) print(is_perfect_square(0)) # Output should be True (0*0) ``` # Implementation Guidelines * Use a binary search approach to efficiently determine if the number is a perfect square. * Initialize two pointers, `low` and `high`, and repeatedly adjust them based on comparisons. * Avoid overflow issues by carefully handling the multiplication in the binary search condition. Your solution should be implemented efficiently and handle large input values within a reasonable time frame.","solution":"def is_perfect_square(num): if num < 0: return False if num == 0: return True low, high = 1, num while low <= high: mid = (low + high) // 2 square = mid * mid if square == num: return True elif square < num: low = mid + 1 else: high = mid - 1 return False"},{"question":"Euclidean Distance Calculation Euclidean distance is a measure of the straight-line distance between two points in Euclidean space. In this task, you will implement a function that calculates the Euclidean distance between two points in a given n-dimensional space. The Euclidean distance ( d ) between two points ( p ) and ( q ) in an n-dimensional space is defined as: [ d(p, q) = sqrt{sum_{i=1}^{n} (p_i - q_i)^2} ] Function Signature ```python def calculate_euclidean_distance(point1: np.ndarray, point2: np.ndarray) -> float: pass ``` # Input * `point1` and `point2`: Two numpy arrays of the same length representing the coordinates of the points in n-dimensional space. # Output * A float representing the Euclidean distance between the two points. # Constraints * The coordinates will be real numbers. * Both points will be non-empty and contain between 1 and 1000 dimensions. # Performance Requirements * Your implementation should handle the maximum number of dimensions efficiently. # Example ```python import numpy as np point1 = np.array([1, 2, 3]) point2 = np.array([4, 5, 6]) # Expected output: 5.196152422706632 print(calculate_euclidean_distance(point1, point2)) ```","solution":"import numpy as np def calculate_euclidean_distance(point1: np.ndarray, point2: np.ndarray) -> float: Calculate the Euclidean distance between two points in an n-dimensional space. Parameters: point1 (np.ndarray): Coordinates of the first point. point2 (np.ndarray): Coordinates of the second point. Returns: float: Euclidean distance between point1 and point2. # Calculate the difference between the two points difference = point1 - point2 # Calculate the square of the differences squared_difference = difference ** 2 # Sum all the squared differences sum_squared_difference = np.sum(squared_difference) # Take the square root of the sum to get the Euclidean distance distance = np.sqrt(sum_squared_difference) return distance"},{"question":"Problem Statement # Common Elements in Sorted Arrays You are given two lists of integers, `list1` and `list2`, each of which is sorted in non-decreasing order. Your task is to implement a function `common_elements(list1: List[int], list2: List[int]) -> List[int]` that returns a list of integers that are common to both `list1` and `list2`. # Input - **list1**: A list of integers sorted in non-decreasing order. - **list2**: A list of integers sorted in non-decreasing order. # Output A list of integers sorted in non-decreasing order that are common to both `list1` and `list2`. If there are no common elements, return an empty list. # Example ```python >>> common_elements([1, 3, 4, 6, 7, 9], [3, 5, 7, 8, 9, 10]) [3, 7, 9] >>> common_elements([1, 2, 2, 3], [2, 2, 3, 3]) [2, 3] >>> common_elements([1, 2, 3], [4, 5, 6]) [] ``` # Constraints - Both `list1` and `list2` can contain up to (10^5) elements. - Each integer in the lists will be within the range ([-10^6, 10^6]). # Requirements - Your implementation should be optimized to ensure efficiency, particularly for larger inputs. - Pay attention to edge cases, such as when there are no common elements or when the lists are empty. # Implementation Notes - Given that both lists are already sorted, consider using a two-pointer technique to efficiently find the common elements. This approach minimizes the number of comparisons between elements.","solution":"from typing import List def common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a list of integers that are common to both list1 and list2. Both lists are assumed to be sorted in non-decreasing order. common = [] i, j = 0, 0 n, m = len(list1), len(list2) while i < n and j < m: if list1[i] == list2[j]: if not common or common[-1] != list1[i]: common.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return common"},{"question":"# Lexical Sort Implementation Challenge You are required to implement a function that sorts a list of strings based on their lexicographical order. Additionally, the sorting order can be specified to be either ascending or descending. Description: Implement a function `lexical_sort(words, order=\'asc\')` which returns the sorted list of `words` in the specified lexicographical order. Input: - `words`: A list of strings to be sorted. - `order`: A string, either `\'asc\'` for ascending order or `\'desc\'` for descending order. Default is `\'asc\'`. Output: - Returns a list of strings sorted based on the specified order. Constraints: - The list `words` contains at least one string and not more than 100,000 strings. - Each string in the list has a length of at least 1 and at most 100 characters. - The `order` parameter will always be either `\'asc\'` or `\'desc\'`. Requirements: - Your implementation must efficiently handle sorting for the input size constraints. - Ensure proper handling of case sensitivity, considering lowercase and uppercase letters should be treated equivalently for sorting purposes. - Optimize for performance to handle large datasets within acceptable time limits. Additional Details: 1. Use appropriate Python sorting utilities and consider custom key functions to meet the requirements. 2. Assume the input list `words` does not contain any duplicate entries. You are provided with a sample input and expected output below for reference: Sample Input: ```python words = [\\"apple\\", \\"Banana\\", \\"grape\\", \\"Apricot\\"] order = \\"asc\\" ``` Sample Output: ```python [\\"apple\\", \\"Apricot\\", \\"Banana\\", \\"grape\\"] ``` Implement the `lexical_sort` function accordingly. Starter Code: ```python def lexical_sort(words, order=\'asc\'): # Your code here pass ``` # Additional Example: Sample Input: ```python words = [\\"zebra\\", \\"apple\\", \\"Orange\\", \\"banana\\", \\"Lemon\\"] order = \\"desc\\" ``` Sample Output: ```python [\\"zebra\\", \\"Orange\\", \\"Lemon\\", \\"banana\\", \\"apple\\"] ```","solution":"def lexical_sort(words, order=\'asc\'): Sorts a list of strings based on their lexicographical order. Case-insensitive and supports ascending and descending sorting order. Args: - words: List of strings to be sorted. - order: \'asc\' for ascending order or \'desc\' for descending order. Default is \'asc\'. Returns: - A list of strings sorted based on the specified order. words_sorted = sorted(words, key=lambda word: word.lower()) if order == \'desc\': return words_sorted[::-1] return words_sorted"},{"question":"# Problem Statement: You are designing a reservation system for a conference room. Each reservation has a start time and an end time, both given as integers representing hours of the day in a 24-hour format (e.g., 9 represents 9:00 AM, and 17 represents 5:00 PM). Implement a class and a function to manage the reservations to ensure that there are no overlapping bookings. # Requirements: 1. **Input**: - A list of reservations, each represented by a tuple: (start_time, end_time). - A new reservation represented by a tuple: (start_time, end_time). 2. **Output**: - `True` if the new reservation can be added without any conflict. - `False` otherwise. # Constraints: - The list of existing reservations will have a length between 0 and 1000. - Each reservation\'s start_time and end_time will be between 0 and 23. - The start_time of a reservation will always be less than the end_time. # Instructions: 1. Implement a `Reservation` class to encapsulate the attributes and behaviors of a reservation. 2. Create a function `can_add_reservation` that determines if a new reservation can be added without conflicting with the existing reservations. - This function should accept a list of `Reservation` objects and the new reservation as input. # Function Signatures: ```python class Reservation: def __init__(self, start_time, end_time): pass def can_add_reservation(existing_reservations, new_reservation): pass ``` # Example: ```python if __name__ == \\"__main__\\": existing_reservations = [(9, 11), (13, 15), (16, 18)] new_reservation = (12, 14) reservations = [Reservation(start, end) for start, end in existing_reservations] new_res = Reservation(new_reservation[0], new_reservation[1]) can_be_added = can_add_reservation(reservations, new_reservation) print(can_be_added) # True because there is no conflict ``` Implement the `Reservation` class and the `can_add_reservation` function to manage conference room reservations effectively.","solution":"class Reservation: def __init__(self, start_time, end_time): self.start_time = start_time self.end_time = end_time def can_add_reservation(existing_reservations, new_reservation): new_start, new_end = new_reservation.start_time, new_reservation.end_time for reservation in existing_reservations: if not (new_end <= reservation.start_time or new_start >= reservation.end_time): return False return True"},{"question":"# Scenario: You are developing a software system for an online bookstore. The system needs to handle discounts applied to books based on various promotional strategies. To ensure proper accounting and flexibility in the discounting process, you need to implement a function that applies different types of discounts to a given book price. # Task: Implement a function `apply_discount` that can manage multiple discount strategies and compute the final price of a book after all applicable discounts have been applied. # Specifications: 1. The function signature is: ```python def apply_discount( original_price: float, discounts: List[Tuple[str, float]] ) -> float: ``` 2. The function should: * Accept the original price of the book as a `float`. * Accept a list of discounts, where each discount is a tuple consisting of the discount type (as a `str`) and the discount value (as a `float`). * Apply the discount strategies in the order they are provided in the list. # Discount Types: - `\\"percentage\\"`: A percentage discount to be applied to the current price. For example, a 10% discount on 100 would result in a new price of 90. - `\\"fixed\\"`: A fixed amount to be subtracted from the current price. For example, a 5 discount on 100 would result in a new price of 95. # Input: * `original_price`: A `float` representing the original price of the book. * `discounts`: A list of tuples where each tuple contains: * A `str` indicating the type of discount. * A `float` representing the value of the discount. # Output: * A `float` representing the final price of the book after applying all the discounts. # Constraints: * The `original_price` will always be a positive float. * Each discount value will be a positive float. * The function should raise a `ValueError` with an appropriate message if the discount type is invalid. # Examples: 1. `apply_discount(100, [(\\"percentage\\", 10)])` should return `90.0`. 2. `apply_discount(100, [(\\"fixed\\", 5), (\\"percentage\\", 10)])` should return `85.5`. 3. `apply_discount(100, [(\\"percentage\\", 20), (\\"fixed\\", 10)])` should return `70.0`. # Notes: * Ensure that the application of percentage discounts is as intended (i.e., multiplicative rather than subtractive). * Thoroughly handle any potential errors or invalid discount types to avoid incorrect calculations.","solution":"from typing import List, Tuple def apply_discount( original_price: float, discounts: List[Tuple[str, float]] ) -> float: Apply a series of discounts to an original price and return the final price. :param original_price: The starting price of the book. :param discounts: A list of tuple containing the discount type and discount value. :return: The final price after applying all discounts. final_price = original_price for discount_type, discount_value in discounts: if discount_type == \\"percentage\\": final_price -= final_price * (discount_value / 100) elif discount_type == \\"fixed\\": final_price -= discount_value else: raise ValueError(f\\"Invalid discount type: {discount_type}\\") if final_price < 0: final_price = 0 return final_price"},{"question":"# Question: Roman Numeral Conversion You are familiar with Roman numerals, an ancient number system that uses combinations of letters from the Latin alphabet to represent values. For this task, you will implement two functions to convert between Roman numerals and integers. Steps to Follow: 1. Write a function `int_to_roman(num: int) -> str` that converts an integer to its corresponding Roman numeral representation. The function should: * Handle integer inputs from 1 to 3999 inclusive. * Use additive and subtractive notation as per standard Roman numeral rules. 2. Write a function `roman_to_int(s: str) -> int` that converts a given Roman numeral string back into its integer representation. The function should: * Validate that the input string is a valid Roman numeral. * Return the integer equivalent of the Roman numeral. Roman Numeral Reference: | Symbol | Value | |--------|-------| | I | 1 | | V | 5 | | X | 10 | | L | 50 | | C | 100 | | D | 500 | | M | 1000 | Rules: * Roman numerals are typically written largest to smallest from left to right. * However, when a smaller numeral appears before a larger numeral, it indicates subtraction (e.g., IV = 4). Input & Output: * **Input**: * `int_to_roman` takes a single integer `num` (1 <= num <= 3999). * `roman_to_int` takes a single string containing a valid Roman numeral. * **Output**: * `int_to_roman` returns a string representing the Roman numeral. * `roman_to_int` returns an integer. Constraints: * Input integers for `int_to_roman` are within the range 1 to 3999. * Roman numeral strings for `roman_to_int` consist only of valid Roman numeral characters. Examples: ```python >>> int_to_roman(1994) \'MCMXCIV\' >>> int_to_roman(58) \'LVIII\' >>> roman_to_int(\'MCMXCIV\') 1994 >>> roman_to_int(\'LVIII\') 58 >>> roman_to_int(\'MMMDCCCLXXXVIII\') 3888 ``` Implement the Roman numeral conversion functions meeting the above specifications.","solution":"def int_to_roman(num: int) -> str: Converts an integer to its corresponding Roman numeral representation. value_map = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] roman = [] for value, symbol in value_map: while num >= value: roman.append(symbol) num -= value return \'\'.join(roman) def roman_to_int(s: str) -> int: Converts a given Roman numeral string back into its integer representation. value_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = value_map[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Telephone Number Formatting: Advanced Assessment Objective Design and implement an advanced telephone number formatting function for various international formats. This function will test your understanding of string manipulation, validation, and complex formatting requirements. Function Signature ```python def format_telephone_number(country_code: str, local_number: str) -> str: ... ``` Instructions 1. **Functionality**: - The function must convert a local telephone number to the international format based on the provided country code. - Your function should take two parameters: - `country_code`: The country code as a string (e.g., \\"US\\", \\"FR\\", \\"IN\\"). - `local_number`: The local telephone number as a string of digits. 2. **Formatting Rules**: - **US (United States)**: Format as `+1 (XXX) XXX-XXXX` - **FR (France)**: Format as `+33 X XX XX XX XX` - **IN (India)**: Format as `+91 XXXXX-XXXXX` - **Default**: If the country code is not recognized, return the number in the format `+X-XXXX-XXXX-XXXX` where `X` is the country code and the rest follows in block division of four digits. 3. **Considerations**: - Ensure appropriate error handling for invalid input (e.g., non-numeric characters in local_number, unsupported or missing country codes). - The function should handle different lengths of local numbers efficiently and correctly. - The function must manage large phone numbers up to 15 digits and very small inputs (down to 4 digits for to default formatting properly). 4. **Examples**: - ```python format_telephone_number(\\"US\\", \\"1234567890\\") # Output: \\"+1 (123) 456-7890\\" ``` - ```python format_telephone_number(\\"FR\\", \\"612345678\\") # Output: \\"+33 6 12 34 56 78\\" ``` - ```python format_telephone_number(\\"IN\\", \\"9876543210\\") # Output: \\"+91 98765-43210\\" ``` - ```python format_telephone_number(\\"UK\\", \\"2079460123\\") # Output: \\"+44-2079-4601-23\\" ``` 5. **Constraints**: - The `country_code` parameter must be a valid string of the recognized country codes. - The `local_number` must only contain numeric characters (digits). Notes - Assume inputs are generally valid strings compliant with common telephone number formatting requirements. - Emphasize clear error messaging and documentation in the solution to guide future code maintenance and enhancement. - Code efficiency and clarity are critical, alongside thorough validation and comprehensive documentation.","solution":"def format_telephone_number(country_code: str, local_number: str) -> str: Formats a local telephone number based on the provided country code. Parameters: country_code (str): The country code (e.g., \\"US\\", \\"FR\\", \\"IN\\"). local_number (str): The local telephone number as a string of digits. Returns: str: The formatted telephone number. # Validate input if not country_code or not local_number.isdigit(): raise ValueError(\\"Invalid input: country_code must be a non-empty string and local_number must contain only digits.\\") formatted_number = \\"\\" if country_code == \\"US\\": if len(local_number) != 10: raise ValueError(\\"Invalid local number length for country \'US\'. Must be 10 digits.\\") formatted_number = f\\"+1 ({local_number[:3]}) {local_number[3:6]}-{local_number[6:]}\\" elif country_code == \\"FR\\": if len(local_number) != 9: raise ValueError(\\"Invalid local number length for country \'FR\'. Must be 9 digits.\\") formatted_number = f\\"+33 {local_number[0]} {local_number[1:3]} {local_number[3:5]} {local_number[5:7]} {local_number[7:]}\\" elif country_code == \\"IN\\": if len(local_number) != 10: raise ValueError(\\"Invalid local number length for country \'IN\'. Must be 10 digits.\\") formatted_number = f\\"+91 {local_number[:5]}-{local_number[5:]}\\" else: # Default format for unknown country code formatted_number = f\\"+{country_code}-\\" for i in range(0, len(local_number), 4): formatted_number += f\\"{local_number[i:i+4]}-\\" formatted_number = formatted_number.rstrip(\\"-\\") return formatted_number"},{"question":"**Scenario**: You are working on a security system for a company that monitors logins from various users. Part of the task is to implement a feature that tracks unsuccessful login attempts. The purpose of this feature is to identify when there have been three consecutive failed login attempts for a particular user, after which further login attempts should be denied and the account should be flagged for review. To achieve this, you need to implement a class method that records login attempts and checks if there have been three consecutive failed attempts. # Function Signature ```python class LoginMonitor: def __init__(self): pass def record_attempt(self, user_id: str, success: bool) -> bool: pass ``` # Class and Method Descriptions - `LoginMonitor`: A class to track and monitor login attempts. - `record_attempt(user_id, success)`: - Records the login attempt for the given user. - - `user_id` (str): The unique identifier for the user. - - `success` (bool): A boolean indicating whether the login attempt was successful (`True`) or not (`False`). - Returns: `True` if the user has been flagged due to three consecutive failed login attempts; otherwise, `False`. # Constraints - The class should efficiently handle multiple users and track their login attempts. - Ensure the method works with a large number of users and login attempts. # Example Usage ```python monitor = LoginMonitor() monitor.record_attempt(\\"user123\\", False) # Returns False monitor.record_attempt(\\"user123\\", False) # Returns False monitor.record_attempt(\\"user123\\", False) # Returns True monitor.record_attempt(\\"user456\\", True) # Returns False monitor.record_attempt(\\"user123\\", True) # Returns False monitor.record_attempt(\\"user456\\", False) # Returns False ``` # Additional Notes - The `record_attempt` method should maintain and update the state of login attempts for each user efficiently. - Upon three consecutive failed attempts, any subsequent calls to `record_attempt` for that user should always return `True` until a successful login occurs (if applicable).","solution":"class LoginMonitor: def __init__(self): self.attempts = {} def record_attempt(self, user_id: str, success: bool) -> bool: if user_id not in self.attempts: self.attempts[user_id] = [0, False] # [count_of_failed_attempts, flagged] if success: self.attempts[user_id] = [0, False] return False else: self.attempts[user_id][0] += 1 if self.attempts[user_id][0] >= 3: self.attempts[user_id][1] = True return True return False"},{"question":"# Matrix Rotation Checker Given two square matrices `matrix1` and `matrix2` of size `n x n`, determine if `matrix2` can be obtained by rotating `matrix1` by 90, 180, or 270 degrees. If `matrix2` can be obtained by any such rotation, return the rotation degree. Otherwise, return -1. # Function Signature ```python def check_rotation(matrix1: list[list[int]], matrix2: list[list[int]]) -> int: Returns the degree of rotation needed to obtain matrix2 from matrix1, or -1 if such rotation is not possible. ``` # Input * `matrix1` and `matrix2`: Lists of lists of integers, each representing square matrices of equal size `n x n`. # Output * An integer representing the degree of rotation (90, 180, or 270) required to align `matrix1` with `matrix2`, or -1 if no such rotation exists. # Constraints * Both `matrix1` and `matrix2` have the same dimensions and are non-empty. * Rotations are restricted to multiples of 90 degrees. # Example ```python >>> check_rotation( [[1, 2], [3, 4]], [[3, 1], [4, 2]] ) 90 >>> check_rotation( [[1, 2], [3, 4]], [[4, 3], [2, 1]] ) 180 >>> check_rotation( [[1, 2], [3, 4]], [[2, 4], [1, 3]] ) -1 >>> check_rotation( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ) 90 ``` # Scenario In image processing, you might need to know if two images are rotations of each other. Given the pixel values of two images represented as matrices, the task is to determine if one of the images is a rotated version of the other and by what degree.","solution":"def rotate_90(matrix): Rotate the given n x n matrix by 90 degrees. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def check_rotation(matrix1, matrix2): Returns the degree of rotation needed to obtain matrix2 from matrix1, or -1 if such rotation is not possible. # Generate rotations of matrix1 rotation_90 = rotate_90(matrix1) rotation_180 = rotate_90(rotation_90) rotation_270 = rotate_90(rotation_180) if matrix2 == rotation_90: return 90 elif matrix2 == rotation_180: return 180 elif matrix2 == rotation_270: return 270 else: return -1"},{"question":"# Coding Assessment Question Problem Statement **Context**: Jack is a computer scientist focusing on data structures and algorithms. He\'s currently working on optimizing a search algorithm using balanced trees. One of his tasks is to validate if a given binary search tree remains balanced after a series of insertions. A balanced binary tree, by definition, is one in which the height of the two subtrees of any node does not differ by more than one. Jack has a binary search tree\'s node structure and a series of operations where each operation is an insertion of a node. He wants to determine if the binary search tree remains balanced after each insertion. **Task**: Implement a function `validate_balanced_bst(root: Optional[TreeNode], operations: List[int]) -> List[bool]` that validates the balance of a binary search tree after each insertion operation. **Function Signature**: ```python def validate_balanced_bst(root: Optional[TreeNode], operations: List[int]) -> List[bool]: ``` **Parameters**: - `root` (Optional[TreeNode]): The initial root of the binary search tree. The `TreeNode` class is predefined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - `operations` (List[int]): A list of integers representing the values to be inserted into the binary search tree in sequence. **Returns**: - (List[bool]): A list of boolean values where each value indicates whether the binary search tree remains balanced after the corresponding insertion. **Examples**: ```python # Example Tree Structure # root = TreeNode(10) # Insertions: [5, 15, 3, 7, 18] root = TreeNode(10) assert validate_balanced_bst(root, [5, 15, 3, 7, 18]) == [True, True, True, True, True] # root = TreeNode(10) # Insertions: [20, 30, 40] root = TreeNode(10) assert validate_balanced_bst(root, [20, 30, 40]) == [True, False, False] ``` **Notes**: - The TreeNode class is already defined. Your task is only to implement the function `validate_balanced_bst`. - After each insertion, the function should validate the balance of the tree and append the result (True/False) to the result list. - Ensure the tree remains a valid binary search tree after each insertion. - Focus on ensuring the algorithm handles the balance validation efficiently. **Constraints**: - `1 <= len(operations) <= 1000` - `-10^4 <= val <= 10^4` for each TreeNode value. **Scenario**: Jack has a deadline to present his optimized tree structures and their validations at a tech conference. Your expertise in validating the balance efficiently is crucial to help him meet his presentation\'s standards.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_bst(root, val): if not root: return TreeNode(val) if val < root.val: root.left = insert_bst(root.left, val) else: root.right = insert_bst(root.right, val) return root def height(root): if not root: return 0 return 1 + max(height(root.left), height(root.right)) def is_balanced(root): if not root: return True left_height = height(root.left) right_height = height(root.right) if abs(left_height - right_height) > 1: return False return is_balanced(root.left) and is_balanced(root.right) def validate_balanced_bst(root, operations): result = [] for val in operations: root = insert_bst(root, val) result.append(is_balanced(root)) return result"},{"question":"# Difference Between Two Strings You are given two strings, `s1` and `s2`, of equal length. Your task is to write a function `difference_between_strings(s1: str, s2: str) -> int` that returns the number of positions at which the corresponding characters are different. Input * Two strings `s1` and `s2` both containing only lowercase English letters. * Both strings have the same length, which is guaranteed to be between 1 and 100, inclusive. Output * A single integer representing the count of positions where the characters in `s1` and `s2` differ. # Constraints * The function should handle strings of up to 100 characters efficiently. * Ensure that the comparison is case-sensitive since the input strings contain only lowercase letters. # Example ```python s1 = \\"abcdef\\" s2 = \\"azcedf\\" assert difference_between_strings(s1, s2) == 2 ``` # Additional Guidelines * Explain the approach and any edge cases you considered. * Aim for simplicity and clarity in your solution to ensure it is easy to understand.","solution":"def difference_between_strings(s1, s2): Returns the number of positions at which the corresponding characters are different in two strings s1 and s2. return sum(1 for a, b in zip(s1, s2) if a != b)"},{"question":"# Problem Statement You are required to create a custom calendar with the ability to schedule, cancel, and reschedule events. Each event has a unique identifier and is associated with a specific time. The calendar should maintain the chronological order of events and allow queries about the current state of the calendar. # Requirements 1. **Initialization:** - Initialize the calendar. 2. **Operations:** - **Add event (add_event(event_id, time))**: Schedule an event at the specified time. If an event with the same `event_id` already exists, update its time. - **Cancel event (cancel_event(event_id))**: Remove the event with the specified `event_id` from the calendar. - **Reschedule event (reschedule_event(event_id, new_time))**: Change the time of the specified event to the new time. If no such event exists, add it with the new time. - **Get events**: Return a list of all events in chronological order of their times. # Input Format - A sequence of operations and their values. # Output Format - For an **get events** operation, output the current state of the calendar as a list of `(event_id, time)` tuples in chronological order of their times. # Constraints - The `event_id` is a string. - The `time` is an integer representing the timestamp (e.g., in seconds). - Operations are provided in the form of a list of tuples, where each tuple contains the operation name and necessary parameters. # Example ```python # Sequence of operations operations = [ (\\"add_event\\", \\"event1\\", 10), (\\"add_event\\", \\"event2\\", 5), (\\"add_event\\", \\"event3\\", 20), (\\"cancel_event\\", \\"event2\\"), (\\"reschedule_event\\", \\"event3\\", 15), (\\"get_events\\",), # Output: [(\'event1\', 10), (\'event3\', 15)] ] my_calendar = CustomCalendar() for operation in operations: if operation[0] == \\"add_event\\": my_calendar.add_event(operation[1], operation[2]) elif operation[0] == \\"cancel_event\\": my_calendar.cancel_event(operation[1]) elif operation[0] == \\"reschedule_event\\": my_calendar.reschedule_event(operation[1], operation[2]) elif operation[0] == \\"get_events\\": print(my_calendar.get_events()) ``` # Boilerplate Code: Implement the required methods in the provided class: ```python class CustomCalendar: def __init__(self) -> None: # Initialize the event storage self.events = {} def add_event(self, event_id: str, time: int) -> None: # Add or update the event with its time self.events[event_id] = time def cancel_event(self, event_id: str) -> None: # Remove the event if it exists if event_id in self.events: del self.events[event_id] def reschedule_event(self, event_id: str, new_time: int) -> None: # Change the time of the event or add if not existing self.events[event_id] = new_time def get_events(self) -> list: # Return all events in chronological order return sorted(self.events.items(), key=lambda x: x[1]) ```","solution":"class CustomCalendar: def __init__(self) -> None: # Initialize the event storage self.events = {} def add_event(self, event_id: str, time: int) -> None: # Add or update the event with its time self.events[event_id] = time def cancel_event(self, event_id: str) -> None: # Remove the event if it exists if event_id in self.events: del self.events[event_id] def reschedule_event(self, event_id: str, new_time: int) -> None: # Change the time of the event or add if not existing self.events[event_id] = new_time def get_events(self) -> list: # Return all events in chronological order return sorted(self.events.items(), key=lambda x: x[1])"},{"question":"# Coding Assessment Question: Implement the Breadth-First Search (BFS) Algorithm for a Graph **Context**: You are part of a team developing a new navigation system that calculates the shortest path in an unweighted graph. To achieve this, you need to implement the Breadth-First Search (BFS) algorithm, which is commonly used for this purpose due to its efficiency in traversing graphs level by level. **Task**: Write a function `bfs` that performs a breadth-first search on an unweighted graph. The function should take the graph as an adjacency list and a starting vertex, and it should return the list of vertices visited in the order they were discovered. **Function Signature**: ```python def bfs(graph: dict[str, list[str]], start: str) -> list[str]: pass ``` **Requirements**: 1. **Input**: - `graph` is a dictionary where keys are vertex identifiers (strings) and values are lists of adjacent vertices (also strings). - `start` is a string representing the starting vertex. 2. **Output**: - A list of strings representing the vertices in the order they were visited. 3. **Constraints**: - The graph is connected and unweighted. - Vertex identifiers are unique strings. - The graph can have up to 1000 vertices and 5000 edges. 4. **Performance**: - The function should run efficiently for the given constraints. **Example**: ```python >>> graph = { ... \\"A\\": [\\"B\\", \\"C\\"], ... \\"B\\": [\\"A\\", \\"D\\", \\"E\\"], ... \\"C\\": [\\"A\\", \\"F\\"], ... \\"D\\": [\\"B\\"], ... \\"E\\": [\\"B\\", \\"F\\"], ... \\"F\\": [\\"C\\", \\"E\\"] ... } >>> bfs(graph, \\"A\\") [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] ``` **Notes**: - Start the search from the given `start` vertex. - Use a queue to keep track of the vertices to visit next. - Ensure each vertex is visited only once. - If multiple vertices are found at the same level, visit them in alphabetical order. **Edge Cases**: - Handle graphs with a single vertex. - Ensure that cycles in the graph do not cause infinite loops.","solution":"from collections import deque def bfs(graph: dict[str, list[str]], start: str) -> list[str]: Performs a breadth-first search on the given graph starting from the start vertex. :param graph: A dictionary where keys are vertex identifiers and values are lists of adjacent vertices. :param start: The starting vertex for the BFS traversal. :return: A list of vertices in the order they were visited. visited = [] queue = deque([start]) visited_set = set([start]) while queue: vertex = queue.popleft() visited.append(vertex) for neighbor in sorted(graph[vertex]): if neighbor not in visited_set: queue.append(neighbor) visited_set.add(neighbor) return visited"},{"question":"# Problem Statement You are to design a program that emulates a simple file system structure and supports creating, deleting, and listing files in directories. The file system should be navigable, with the ability to switch between directories, and handle basic file operations. # Requirements 1. **Class Implementation**: Implement a class `FileSystem` with the following methods: - `__init__(self) -> None`: Initialize an empty file system. - `create_directory(self, path: str) -> None`: Creates a new directory at the given path. - `create_file(self, path: str) -> None`: Creates a new file at the given path. - `delete_path(self, path: str) -> None`: Deletes a file or directory at the given path. - `list_directory(self, path: str) -> list[str]`: Lists the contents of the directory at the given path. - `change_directory(self, path: str) -> None`: Changes the current directory to the given path. 2. **Constraints**: - The file system starts with a root directory denoted by `/`. - Directories can only be created inside existing directories. - Files can only be created inside existing directories. - Deleting a directory should also delete its contents. - List the contents of a directory in alphabetical order. - Paths are always given as absolute paths. - Raise appropriate exceptions for invalid operations like deleting a non-existing path or creating a directory/file in a non-existing path. 3. **Example**: ```python fs = FileSystem() fs.create_directory(\'/a\') fs.create_directory(\'/a/b\') fs.create_file(\'/a/b/file1.txt\') fs.create_file(\'/a/b/file2.txt\') print(fs.list_directory(\'/a/b\')) # Output: [\'file1.txt\', \'file2.txt\'] fs.delete_path(\'/a/b/file1.txt\') print(fs.list_directory(\'/a/b\')) # Output: [\'file2.txt\'] fs.change_directory(\'/a\') print(fs.list_directory(\'/\')) # Output: [\'a\'] ``` 4. **Edge Cases**: - Deleting a non-existing file or directory. - Creating a file or directory in a path that doesn\'t exist. - Listing a directory that is currently empty. # Hints - Use a nested dictionary structure to represent directories and files. - Handle path parsing carefully to navigate through the nested dictionary. - Ensure to maintain the state of the current directory for navigation purposes.","solution":"class FileNotFoundError(Exception): pass class DirectoryNotFoundError(Exception): pass class FileSystem: def __init__(self) -> None: self.fs = {\'/\': {}} self.current_path = \'/\' def create_directory(self, path: str) -> None: parts = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for part in parts: if part not in current: current[part] = {} if not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Cannot create directory, because a file exists at {path}\\") current = current[part] def create_file(self, path: str) -> None: *dir_parts, file_name = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for part in dir_parts: if part not in current or not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Directory \'{\'/\'.join(dir_parts)}\' not found.\\") current = current[part] current[file_name] = None def delete_path(self, path: str) -> None: *dir_parts, last_part = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for part in dir_parts: if part not in current or not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Directory \'{\'/\'.join(dir_parts)}\' not found.\\") current = current[part] if last_part not in current: raise FileNotFoundError(f\\"Path \'{path}\' not found.\\") del current[last_part] def list_directory(self, path: str) -> list: parts = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for part in parts: if part: if part not in current or not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Directory \'{path}\' not found.\\") current = current[part] return sorted(current.keys()) def change_directory(self, path: str) -> None: parts = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for part in parts: if part: if part not in current or not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Directory \'{path}\' not found.\\") current = current[part] self.current_path = path"},{"question":"# Tower of Hanoi with Limited Moves Objective: You are required to solve the Tower of Hanoi problem for `n` disks, with an additional twist: you can make a maximum of `m` moves. Implement functions to return the sequence of moves for a given number of disks and the limited number of moves. Input: - An integer `n`, the number of disks. - An integer `m`, the maximum allowed moves to solve the problem. Output: - A list of tuples representing the moves (from_rod, to_rod) to transfer all the disks from the source rod `A` to the target rod `C`. If the problem cannot be solved within `m` moves, return an empty list. Constraints: - `1 <= n <= 10` - `1 <= m <= 1024` - The rods are named as `A`, `B`, and `C`. Example Scenarios: ```python def hanoi_with_limited_moves(n: int, m: int) -> list: >>> hanoi_with_limited_moves(2, 3) [(\'A\', \'B\'), (\'A\', \'C\'), (\'B\', \'C\')] >>> hanoi_with_limited_moves(3, 7) [(\'A\', \'C\'), (\'A\', \'B\'), (\'C\', \'B\'), (\'A\', \'C\'), (\'B\', \'A\'), (\'B\', \'C\'), (\'A\', \'C\')] >>> hanoi_with_limited_moves(3, 6) [] def hanoi_recursive(n, source, target, auxiliary, moves, result): if n == 1: if len(result) < moves: result.append((source, target)) return hanoi_recursive(n - 1, source, auxiliary, target, moves, result) if len(result) < moves: result.append((source, target)) hanoi_recursive(n - 1, auxiliary, target, source, moves, result) max_possible_moves = 2**n - 1 if m < max_possible_moves: return [] result = [] hanoi_recursive(n, \'A\', \'C\', \'B\', m, result) return result ``` You should implement the `hanoi_with_limited_moves` function and ensure its correct operation using the provided examples, considering the twist that the sequence should not exceed the given maximum number of moves.","solution":"def hanoi_with_limited_moves(n: int, m: int) -> list: Solve the Tower of Hanoi problem for `n` disks and maximum `m` moves. Parameters: n (int): The number of disks. m (int): The maximum number of allowed moves. Returns: list: A list of tuples representing the moves, or an empty list if it cannot be solved within `m` moves. def hanoi_recursive(n, source, target, auxiliary, moves, result): if n == 0: return if len(result) < moves: hanoi_recursive(n - 1, source, auxiliary, target, moves, result) if len(result) < moves: result.append((source, target)) if len(result) < moves: hanoi_recursive(n - 1, auxiliary, target, source, moves, result) max_possible_moves = 2**n - 1 if m < max_possible_moves: return [] result = [] hanoi_recursive(n, \'A\', \'C\', \'B\', m, result) return result"},{"question":"**Context:** Radix Sort is a non-comparative integer sorting algorithm that sorts numbers by processing individual digits. It works well with data that has a fixed length of integer representations and is often implemented for sorting large numbers efficiently. Your task will be to sort an array of integers using Radix Sort. However, you will need to manage arrays with mixed positive and negative integers. **Question:** Write a function `custom_radix_sort(arr: List[int]) -> List[int]` that sorts an array of integers `arr` using the Radix Sort algorithm. Since Radix Sort traditionally works with non-negative integers, you need to: 1. Implement a preprocessing step to separate negative and positive integers. 2. Apply Radix Sort individually to both the negative and positive parts. 3. Combine the sorted negative and positive parts appropriately to produce the final sorted array. **Expected Input and Output:** * **Input:** A list of integers `arr`. For example `[-15, 3, 0, -23, 5, 7, -1]` * **Output:** A sorted list of integers in ascending order. For instance, the input `[-15, 3, 0, -23, 5, 7, -1]` should return `[-23, -15, -1, 0, 3, 5, 7]`. **Function Signature:** ```python from typing import List def custom_radix_sort(arr: List[int]) -> List[int]: pass ``` **Constraints:** - The array may contain up to (10^5) elements. - Array size can be any positive or negative integer, including zero.","solution":"from typing import List from math import log10 def counting_sort_for_radix(arr, exp, base): n = len(arr) output = [0] * n count = [0] * base for i in range(n): index = abs(arr[i]) // exp count[index % base] += 1 for i in range(1, base): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = abs(arr[i]) // exp output[count[index % base] - 1] = arr[i] count[index % base] -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr, base=10): if len(arr) == 0: return arr max_num = max(abs(num) for num in arr) exp = 1 while max_num // exp > 0: counting_sort_for_radix(arr, exp, base) exp *= base def custom_radix_sort(arr: List[int]) -> List[int]: if not arr: return [] # Separate positive and negative numbers neg = [-num for num in arr if num < 0] pos = [num for num in arr if num >= 0] # Sort positive and negative numbers separately radix_sort(neg) radix_sort(pos) # Combine them: negatives are reversed and negated, followed by positives neg = [-num for num in reversed(neg)] return neg + pos"},{"question":"# Pathfinding in a Grid with Obstacles Problem Statement: You are given a 2D grid of size `m x n` representing a map where `0` represents open space and `1` represents an obstacle. Your task is to find if there is a path from the top-left corner (`grid[0][0]`) to the bottom-right corner (`grid[m-1][n-1]`). You can only move: - Right (to the cell directly to the right) - Down (to the cell directly below) - Left (to the cell directly to the left) - Up (to the cell directly above) Write a function to determine if such a path exists. If a path exists, return True, otherwise return False. Function Signature ```python def is_path_exist(grid: List[List[int]]) -> bool: pass ``` # Input - `grid`: a 2D list of integers where `0`≤`grid[i][j]`≤`1` and `1 ≤ m, n ≤ 100`. # Output - Returns a boolean value indicating if there is a path from the top-left corner to the bottom-right corner. # Constraints - The top-left corner (`grid[0][0]`) and the bottom-right corner (`grid[m-1][n-1]`) are always `0` (i.e., guaranteed to be open spaces). - The function should handle the constraints efficiently. # Example ```python grid1 = [ [0, 0, 1], [0, 1, 0], [0, 0, 0] ] grid2 = [ [0, 1, 1], [1, 0, 1], [1, 0, 0] ] assert is_path_exist(grid1) == True assert is_path_exist(grid2) == False ``` Note: Implement a search algorithm such as Breadth-First Search (BFS) or Depth-First Search (DFS) to explore possible paths while avoiding obstacles.","solution":"def is_path_exist(grid): from collections import deque # Dimensions of the grid m, n = len(grid), len(grid[0]) # To store visited cells visited = [[False for _ in range(n)] for _ in range(m)] # Directions for moving Right, Down, Left, Up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS queue queue = deque([(0, 0)]) visited[0][0] = True # BFS Loop while queue: x, y = queue.popleft() # Check if we\'ve reached the bottom-right corner if x == m - 1 and y == n - 1: return True # Explore all possible movements for dx, dy in directions: nx, ny = x + dx, y + dy # Check if new position is within bounds and not visited and not an obstacle if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: visited[nx][ny] = True queue.append((nx, ny)) # If queue is empty and we never reached the end return False"},{"question":"# Problem Statement You are provided with a list of integers. The task is to find the second largest distinct number in the list. Implement the function `second_largest(numbers: List[int]) -> int` that performs this task. Input * `numbers` (List[int]): a list of integers. The list can contain positive, negative, and zero values. The list is guaranteed to have at least two distinct integers. Output * The function should return an integer representing the second largest distinct number in the list. Example ```python >>> second_largest([4, 1, -3, 4, 2]) 2 >>> second_largest([10, 5, 10]) 5 >>> second_largest([-2, -1, -2, -3]) -2 >>> second_largest([3, 1, 2, 3, 2, 4]) 3 ``` # Constraints * The length of the list `numbers` can range from 2 to (10^6). * The list will always contain at least two distinct numbers. # Requirements * The function should execute in linear time, i.e., O(n). * Aim to minimize the use of additional space to achieve the solution. * Ensure the solution handles different integer ranges effectively.","solution":"from typing import List def second_largest(numbers: List[int]) -> int: Returns the second largest distinct number in the list of integers. first, second = float(\'-inf\'), float(\'-inf\') for number in numbers: if number > first: second = first first = number elif first > number > second: second = number return second"},{"question":"# Fibonacci Word Sequence Objective: Implement a function to find the nth term in the Fibonacci Word sequence. # Background: The Fibonacci Word sequence is a series of strings constructed similarly to the Fibonacci sequence: * `F(0) = \\"A\\"` * `F(1) = \\"B\\"` * For `n >= 2`, `F(n) = F(n-1) + F(n-2)` Where `+` denotes string concatenation. Function Signature: ```python def fibonacci_word(n: int) -> str: pass ``` Expected Input and Output: * **Input**: A single integer `n`. * **Output**: The nth term in the Fibonacci Word sequence as a string. Constraints and Assumptions: * `n` will be in the range `0 <= n <= 30`. * Handle non-integer and out-of-range inputs by raising a ValueError. Guiding Points: 1. **Edge Handling**: Ensure non-integer and invalid or out-of-range inputs result in appropriate errors. 2. **String Concatenation**: Be mindful of the efficiency implications of string concatenation in Python. 3. **Recursive vs. Iterative Approach**: Consider using an iterative approach to avoid the overhead of recursive calls. Example Implementation ```python def fibonacci_word(n: int) -> str: if not isinstance(n, int) or n < 0 or n > 30: raise ValueError(f\\"Input {n} must be an integer in the range 0 to 30\\") a, b = \\"A\\", \\"B\\" if n == 0: return a elif n == 1: return b for _ in range(2, n + 1): a, b = b, b + a return b # Example Usage: # fibonacci_word(0) should return \\"A\\" # fibonacci_word(1) should return \\"B\\" # fibonacci_word(2) should return \\"BA\\" # fibonacci_word(3) should return \\"BAB\\" # fibonacci_word(4) should return \\"BABBA\\" ``` Submit your solution with test cases to confirm the implementation is correct.","solution":"def fibonacci_word(n: int) -> str: if not isinstance(n, int) or n < 0 or n > 30: raise ValueError(f\\"Input {n} must be an integer in the range 0 to 30\\") a, b = \\"A\\", \\"B\\" if n == 0: return a elif n == 1: return b for _ in range(2, n + 1): a, b = b, b + a return b"},{"question":"**Context**: You are working on a system that requires efficient retrieval of top-k most frequent elements from a large dataset. K represents the number of most frequent elements needed. To implement this, you decide to use a heap-based approach to ensure efficiency. **Problem**: Write a function `top_k_frequent` that takes a list of integers and an integer k, and returns the k most frequent elements in the list. **Function Signature**: ```python def top_k_frequent(nums: list, k: int) -> list: ``` **Input**: * `nums`: A list of integers representing the dataset. * `k`: An integer representing the number of top frequent elements to retrieve. **Output**: * A list of integers representing the k most frequent elements. **Constraints**: * The length of `nums` can be up to 10^5. * All integers in `nums` are within the range of -10^4 to 10^4. * k is guaranteed to be a positive integer and k ≤ number of unique elements in `nums`. **Performance Requirements**: * The implementation should achieve a time complexity of O(n log k). **Example**: ```python nums = [1, 1, 1, 2, 2, 3] k = 2 output = top_k_frequent(nums, k) print(output) # Expected: [1, 2] ``` **Clarification**: If there are multiple solutions with the same frequency, the order of elements in the result may vary.","solution":"from collections import Counter import heapq def top_k_frequent(nums: list, k: int) -> list: Returns the k most frequent elements from the list nums. # Counting the frequency of elements in nums count = Counter(nums) # Using a heap to find the top k elements # heapq.nlargest uses a max heap to get the k elements with the highest frequency return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"Coding Assessment: Implement and Enhance User Authentication System # Context You are tasked with developing an enhancement to a basic user authentication system in a web application. The system includes functions for user registration and login. Your goal is to improve the login function to handle edge cases and provide robust input validation. # Problem Statement Enhance the function `login_user` to handle various edge cases, improve input validation, and ensure error messages are meaningful and helpful to the user. # Function to Be Enhanced ```python users_db = { \\"user1\\": {\\"password\\": \\"password123\\", \\"active\\": True}, \\"user2\\": {\\"password\\": \\"pass456\\", \\"active\\": False} } def login_user(username: str, password: str) -> str: Authenticate user based on username and password. This function checks if the user exists, if the password matches, and if the user account is active. >>> login_user(\\"user1\\", \\"password123\\") \'Login successful!\' >>> login_user(\\"user1\\", \\"wrongpassword\\") \'Invalid password.\' >>> login_user(\\"user3\\", \\"password123\\") \'User does not exist.\' >>> login_user(\\"user2\\", \\"pass456\\") \'User account is inactive.\' if username not in users_db: return \'User does not exist.\' if users_db[username][\'password\'] != password: return \'Invalid password.\' if not users_db[username][\'active\']: return \'User account is inactive.\' return \'Login successful!\' ``` # Requirements 1. **Input Validation**: - Ensure `username` and `password` are both non-empty strings. - Raise a `ValueError` with an appropriate message for invalid inputs. 2. **Edge Case Handling**: - Handle the case of inactive accounts distinctly and provide a specific message for such accounts. 3. **Enhanced Error Messages**: - Provide clear and concise error messages for different failure scenarios (non-existent user, incorrect password, inactive account). # Input/Output Format * **Input**: - `username`: A string representing the username (must be non-empty). - `password`: A string representing the password (must be non-empty). * **Output**: - A string message indicating the result of the login attempt. # Constraints 1. The username and password must be non-empty strings. 2. The system should handle inactive accounts distinctly and return a meaningful message. # Example ```python try: print(login_user(\\"user1\\", \\"password123\\")) # Outputs: \'Login successful!\' print(login_user(\\"user1\\", \\"wrongpassword\\")) # Outputs: \'Invalid password.\' print(login_user(\\"user3\\", \\"password123\\")) # Outputs: \'User does not exist.\' print(login_user(\\"user2\\", \\"pass456\\")) # Outputs: \'User account is inactive.\' except ValueError as ve: print(f\\"ValueError: {ve}\\") ``` This new question aligns with the original set by focusing on enhancing a function, adding input validation, and handling edge cases. The complexity and scope are comparable, ensuring consistency in the assessment`s overall challenge.","solution":"users_db = { \\"user1\\": {\\"password\\": \\"password123\\", \\"active\\": True}, \\"user2\\": {\\"password\\": \\"pass456\\", \\"active\\": False} } def login_user(username: str, password: str) -> str: Authenticate user based on username and password. This function checks if the user exists, if the password matches, and if the user account is active. Raises ValueError if inputs are invalid. >>> login_user(\\"user1\\", \\"password123\\") \'Login successful!\' >>> login_user(\\"user1\\", \\"wrongpassword\\") \'Invalid password.\' >>> login_user(\\"user3\\", \\"password123\\") \'User does not exist.\' >>> login_user(\\"user2\\", \\"pass456\\") \'User account is inactive.\' if not isinstance(username, str) or not username: raise ValueError(\'Username must be a non-empty string.\') if not isinstance(password, str) or not password: raise ValueError(\'Password must be a non-empty string.\') if username not in users_db: return \'User does not exist.\' if users_db[username][\'password\'] != password: return \'Invalid password.\' if not users_db[username][\'active\']: return \'User account is inactive.\' return \'Login successful!\'"},{"question":"# Problem Statement You are given a matrix representing heights of a terrain where `heights[i][j]` is the height of the cell at coordinate `(i, j)`. The Pacific Ocean touches the left and top edges of the matrix and the Atlantic Ocean touches the right and bottom edges. Water can flow from a point to another point if and only if the height of the latter point is less than or equal to the height of the original point. Your task is to find all coordinates where water can flow to both the Pacific and Atlantic oceans. # Function Signature ```python def pacific_atlantic(heights: list[list[int]]) -> list[list[int]]: Args: heights: A list of lists of integers representing the height of each cell. Returns: A list of lists where each inner list contains the coordinates [r, c] of a cell that can flow to both oceans. ``` # Input * `heights`: A matrix of integers where `heights[i][j]` is the height of cell (i, j), with dimensions `heights.length, heights[0].length` satisfying `1 <= heights.length, heights[0].length <= 200` and `1 <= heights[i][j] <= 10^6`. # Output * A list of lists, where each list comprises the coordinates `[r, c]` that can flow to both the Pacific and Atlantic oceans. # Constraints * The matrix `heights` will have at most 200 rows and 200 columns. * Heights are positive integers. # Example ```python heights_1 = [ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ] print(pacific_atlantic(heights_1)) # Expected output: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] heights_2 = [ [1] ] print(pacific_atlantic(heights_2)) # Expected output: [[0, 0]] ``` # Notes 1. Water can only flow from higher height to lower height. 2. Ensure to handle edge cases where the matrix has the minimum or maximum dimensions. 3. Avoid redundant calculations by reusing flow information where possible. 4. Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) for traversal.","solution":"def pacific_atlantic(heights): if not heights or not heights[0]: return [] rows, cols = len(heights), len(heights[0]) pacific_reachable = [[False for _ in range(cols)] for _ in range(rows)] atlantic_reachable = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c, visited, prev_height): if (r < 0 or c < 0 or r == rows or c == cols or visited[r][c] or heights[r][c] < prev_height): return visited[r][c] = True for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)): dfs(r + dr, c + dc, visited, heights[r][c]) # Perform DFS from borders touching the Pacific Ocean for r in range(rows): dfs(r, 0, pacific_reachable, heights[r][0]) dfs(r, cols - 1, atlantic_reachable, heights[r][cols - 1]) for c in range(cols): dfs(0, c, pacific_reachable, heights[0][c]) dfs(rows - 1, c, atlantic_reachable, heights[rows - 1][c]) result = [] for r in range(rows): for c in range(cols): if pacific_reachable[r][c] and atlantic_reachable[r][c]: result.append([r, c]) return result"},{"question":"**Scenario**: You have been contracted by an online retailer to develop an inventory management tool. This tool needs to ensure that the retailer can track the various products stored in their warehouse efficiently and determine when a product needs to be reordered. The inventory consists of unique items, each identified by a string (the product\'s name) and having an associated integer (the quantity in stock). Your task is to help the retailer by creating a system that can add new products, update the stock of existing products, and check which products need reordering. A product needs to be reordered if its stock falls below a specified threshold. **Task**: Write a class `InventoryManager` with the following methods: 1. `add_product(name: str, quantity: int) -> None` 2. `update_stock(name: str, quantity: int) -> None` 3. `needs_reordering(name: str, threshold: int) -> bool` 4. `get_stock(name: str) -> int` Implement the `InventoryManager` class so it maintains an internal record of products and their quantities. # Constraints 1. The `name` of a product will be a non-empty string with a maximum length of 50 characters. 2. The `quantity` will be a non-negative integer. 3. The `threshold` will be a non-negative integer. # Requirements 1. Ensure that the implementation can handle the following scenarios efficiently: - Adding a new product. - Updating the quantity of an existing product. - Checking if a product needs reordering based on the current stock and the provided threshold. - Retrieving the current stock of a specified product. 2. Provide error handling for potential issues (e.g., querying a product that does not exist). # Expected Input and Output Format * **add_product(name: str, quantity: int) -> None** - **Input**: `name = \\"Apple\\"`, `quantity = 50` - **Output**: `None` * **update_stock(name: str, quantity: int) -> None** - **Input**: `name = \\"Apple\\"`, `quantity = 20` - **Output**: `None` * **needs_reordering(name: str, threshold: int) -> bool** - **Input**: `name = \\"Apple\\"`, `threshold = 30` - **Output**: `False` * **get_stock(name: str) -> int** - **Input**: `name = \\"Apple\\"` - **Output**: `70`","solution":"class InventoryManager: def __init__(self): self.inventory = {} def add_product(self, name: str, quantity: int) -> None: if name not in self.inventory: self.inventory[name] = quantity else: raise ValueError(f\\"Product \'{name}\' already exists.\\") def update_stock(self, name: str, quantity: int) -> None: if name in self.inventory: self.inventory[name] += quantity else: raise ValueError(f\\"Product \'{name}\' does not exist.\\") def needs_reordering(self, name: str, threshold: int) -> bool: if name in self.inventory: return self.inventory[name] < threshold else: raise ValueError(f\\"Product \'{name}\' does not exist.\\") def get_stock(self, name: str) -> int: if name in self.inventory: return self.inventory[name] else: raise ValueError(f\\"Product \'{name}\' does not exist.\\")"},{"question":"# Depth-First Search (DFS) Enhancement for Cycle Detection Context: Depth-First Search (DFS) is a fundamental graph traversal algorithm widely used in various applications. One significant application of DFS is cycle detection in directed graphs. You are tasked to implement an enhanced DFS function to detect cycles within a directed graph. Task: Improve the `dfs_cycle_detection` function to perform the following: 1. Implement DFS to traverse the graph. 2. Detect if there is a cycle in the graph during the traversal. 3. Return a boolean indicating if a cycle is present and a list of nodes that form the cycle (if any). If there are multiple cycles, return any one of them. Requirements: 1. **Input**: A directed graph represented as an adjacency list (a dictionary where keys are node labels and values are lists of adjacent nodes). 2. **Output**: A tuple `(has_cycle, cycle_nodes)`: * `has_cycle`: Boolean indicating if a cycle is detected. * `cycle_nodes`: List of nodes forming the detected cycle, or an empty list if no cycle is found. Input and Output Constraints: * The graph is represented by a dictionary where keys are integers (node labels) and values are lists of integers (adjacent nodes). * Nodes will be labeled with unique integers. Implementation: Your solution should: 1. Use recursion to implement the DFS traversal. 2. Utilize tracking structures to keep track of visited nodes and nodes in the current path. 3. Detect cycles and construct the list of nodes forming the cycle if any cycle is found. Function Signature: ```python def dfs_cycle_detection(graph: dict) -> tuple: pass ``` Example: ```python >>> graph1 = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [] } >>> dfs_cycle_detection(graph1) (True, [0, 1, 2, 0]) # Output could be any cycle, like [2, 0, 1, 2] >>> graph2 = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } >>> dfs_cycle_detection(graph2) (True, [3]) # Output could be any cycle like [3, 3] >>> graph3 = { 0: [1], 1: [2], 2: [], 3: [4], 4: [] } >>> dfs_cycle_detection(graph3) (False, []) ```","solution":"def dfs_cycle_detection(graph: dict) -> tuple: def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): cycle_path.append(neighbor) return True elif neighbor in rec_stack: cycle_path.append(neighbor) return True rec_stack.remove(node) return False visited = set() rec_stack = set() cycle_path = [] for node in graph: if node not in visited: if dfs(node, visited, rec_stack): cycle_path.append(cycle_path[0]) return (True, cycle_path[::-1]) return (False, [])"},{"question":"# Coding Assessment Question Implement a `binary_search` function for a sorted array and enhance it by adding two new operations: 1. `first_occurrence(arr: List[int], target: int) -> int` - Finds the first occurrence of the target in the array. 2. `last_occurrence(arr: List[int], target: int) -> int` - Finds the last occurrence of the target in the array. Ensure the methods follow the constraints and have the signatures as described. Expected Input and Output Formats: ```python from typing import List def binary_search(arr: List[int], target: int) -> int: Returns the index of the target element in a sorted array, or -1 if the target is not found. >>> binary_search([1, 2, 4, 5, 6, 8, 9], 5) 3 >>> binary_search([1, 2, 4, 5, 6, 8, 9], 7) -1 ... def first_occurrence(arr: List[int], target: int) -> int: Returns the index of the first occurrence of the target element in a sorted array, or -1 if the target is not found. >>> first_occurrence([2, 4, 4, 4, 6, 8, 10], 4) 1 >>> first_occurrence([2, 4, 4, 4, 6, 8, 10], 5) -1 ... def last_occurrence(arr: List[int], target: int) -> int: Returns the index of the last occurrence of the target element in a sorted array, or -1 if the target is not found. >>> last_occurrence([2, 4, 4, 4, 6, 8, 10], 4) 3 >>> last_occurrence([2, 4, 4, 4, 6, 8, 10], 5) -1 ... ``` Constraints: - The array is sorted in non-decreasing order. - The operations should leverage binary search and maintain O(log N) time complexity. - Handle edge cases gracefully (e.g., empty array, target not present). - Avoid using additional memory aside from input array and fixed amount of extra variables. **Scenario/Context**: You are tasked with efficient searching in large sorted datasets for data analysis tasks. The ability to locate both the first and last occurrences of a target value is crucial for understanding frequency and patterns in the data. Implement these functionalities to support performant query operations.","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: Returns the index of the target element in a sorted array, or -1 if the target is not found. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def first_occurrence(arr: List[int], target: int) -> int: Returns the index of the first occurrence of the target element in a sorted array, or -1 if the target is not found. low, high = 0, len(arr) - 1 result = -1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: result = mid high = mid - 1 elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return result def last_occurrence(arr: List[int], target: int) -> int: Returns the index of the last occurrence of the target element in a sorted array, or -1 if the target is not found. low, high = 0, len(arr) - 1 result = -1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: result = mid low = mid + 1 elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return result"},{"question":"# Question: Implementing a Recursive Function to Generate All Subsets of a Set You are tasked with implementing a recursive function that generates all possible subsets of a given set, including the empty set and the set itself. This is a common problem in combinatorics with applications in various fields, including computer science. # Scenario You are developing a software feature that needs to generate all potential combinations (subsets) of items for a given set. Implement a function that will tackle this problem using recursion. # Function Signature ```python def generate_subsets(lst: list) -> list: pass ``` # Input - `lst` (list): A list of distinct elements for which you need to find all subsets. # Output - Returns a list of lists, where each inner list is a subset of the input list. # Constraints - The input list `lst` contains distinct elements. - Each element in the list can be any hashable type but will be distinct. - Optimize for readability and efficiency using recursion. # Example ```python assert sorted(generate_subsets([1, 2])) == sorted([[], [1], [2], [1, 2]]) assert sorted(generate_subsets([\'a\', \'b\', \'c\'])) == sorted([[], [\'a\'], [\'b\'], [\'c\'], [\'a\', \'b\'], [\'a\', \'c\'], [\'b\', \'c\'], [\'a\', \'b\', \'c\']]) assert sorted(generate_subsets([])) == sorted([[]]) assert sorted(generate_subsets([42])) == sorted([[], [42]]) ``` # Requirements - Implement the function using a recursive approach. - Ensure your solution generates all subsets, including the empty set and the set itself. - The order in which subsets appear in the output list does not matter but ensure to return all possible subsets for given input. - Provide a solution that effectively handles lists of varying sizes, including the edge case of an empty list.","solution":"def generate_subsets(lst): Generates all subsets of a given list using recursion. Parameters: lst (list): A list of distinct elements. Returns: list: A list of lists, where each inner list is a subset of the input list. if len(lst) == 0: return [[]] # Recursively find subsets of the remaining elements rest_subsets = generate_subsets(lst[1:]) # Add the current element to each subset new_subsets = [] for subset in rest_subsets: new_subsets.append([lst[0]] + subset) # Combine the subsets including and excluding the current element all_subsets = rest_subsets + new_subsets return all_subsets"},{"question":"# Problem Statement **Implement a Breadth-First Search (BFS) Algorithm for a Graph** Given a graph represented as an adjacency list and a starting vertex, implement the Breadth-First Search (BFS) algorithm to traverse the graph. Your implementation should return the order in which vertices are visited starting from the given vertex. # Requirements 1. **Function Signature**: ```python def bfs(graph, start): Arguments: graph -- A dictionary where keys are vertices and values are lists of adjacent vertices. start -- The starting vertex for BFS traversal. Returns: A list of vertices in the order they are visited. ``` 2. **Input Format**: - `graph`: A dictionary of adjacency lists where keys are vertices (could be integers, strings, etc.) and values are lists of adjacent vertices. - `start`: The vertex from which BFS traversal starts. 3. **Output Format**: - Return a list of vertices in the order they are visited during BFS traversal. 4. **Constraints**: - The graph represents a connected, unweighted, undirected graph. - The start vertex is guaranteed to be in the graph. - Assume all vertices are unique and non-null. 5. **Performance Requirements**: - Aim for an efficient traversal with a time complexity of O(V + E) where V is the number of vertices and E is the number of edges. - Ensure your implementation handles cyclic graphs properly to avoid infinite loops. # Example ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1, 5], 5: [2, 4] } start_vertex = 0 order = bfs(graph, start_vertex) print(order) # Output should be [0, 1, 2, 3, 4, 5] ``` # Notes * Ensure your solution includes handling of cycles properly without repeating vertices. * Your implementation should be robust and handle edge cases such as graphs with single vertices or no edges. * Provide appropriate test cases to validate correctness and efficiency of your solution.","solution":"from collections import deque def bfs(graph, start): Perform a breadth-first search on the graph starting from the start vertex. Arguments: graph -- A dictionary where keys are vertices and values are lists of adjacent vertices. start -- The starting vertex for BFS traversal. Returns: A list of vertices in the order they are visited. visited = set() queue = deque([start]) order = [] while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) order.append(vertex) queue.extend(neighbor for neighbor in graph[vertex] if neighbor not in visited) return order"},{"question":"# Problem Statement Consider a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` that rotates a given NxN matrix of integers by 90 degrees clockwise. Implement an efficient version of this function that performs the rotation in-place if possible. # Objective Your task is to create an optimized implementation for rotating the matrix by 90 degrees clockwise, considering the following constraints: 1. The function should handle matrices with sizes up to 1000x1000. 2. Aim for an in-place algorithm where no additional matrix is used for the transformation, if possible. 3. Ensure the rotation maintains the integrity of the input matrix\'s values and structure. # Input and Output * **Input**: A list of lists `matrix` representing an NxN matrix of integers, where 1 ≤ N ≤ 1000. * **Output**: A list of lists representing the rotated matrix by 90 degrees clockwise. # Constraints - Use mathematical properties and index manipulations to achieve the rotation. - Ensure the function handles edge cases like single-element and empty matrices. - Optimize the process to keep the time complexity reasonable for the given constraint. # Example ```python >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] ``` # Notes - Study in-place matrix rotation techniques to optimize space complexity. - Consider edge cases such as very small or very large matrices. - The function\'s performance should be efficient enough to handle the upper matrix size limits quickly. Good luck, and ensure correctness and efficiency in your solution!","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotate the given NxN matrix by 90 degrees clockwise. if not matrix or not matrix[0]: return matrix N = len(matrix) # First, transpose the matrix for i in range(N): for j in range(i + 1, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(N): matrix[i].reverse() return matrix"},{"question":"New Question Creation for Coding Assessment # Question Style After analyzing the provided example, the questions aim to assess fundamental programming skills and knowledge of algorithms. The existing question falls within the problem-solving and algorithmic thinking domain, with a clear function signature, input/output specifications, constraints, and example usage to guide the user. # New Question Given the focus on mathematical computations with factorials and large integers, I\'ll design a new problem that involves another computational challenge, such as finding the greatest common divisor (GCD) of factorial numbers, ensuring it aligns in style, length, complexity, and topic. --- New Question # Problem Statement: You are tasked with writing a function to compute the greatest common divisor (GCD) of the factorial of two given numbers. **Function Signature**: ```python def gcd_of_factorials(a: int, b: int) -> int: pass ``` # Input: - Two integers `a` and `b` (0 <= a, b <= 100). # Output: - An integer representing the GCD of the factorials of `a` and `b`. # Constraints: - Factorials grow very large very quickly. - The function should be optimized to handle the constraints efficiently, making use of mathematical properties where possible. # Example: ```python >>> gcd_of_factorials(5, 3) 6 >>> gcd_of_factorials(6, 9) 720 >>> gcd_of_factorials(0, 7) 1 ``` # Description: Write a function `gcd_of_factorials` that takes two integers `a` and `b` and returns the GCD of `a!` and `b!`. Utilize any possible mathematical optimizations to keep the computation efficient. --- This question seamlessly integrates with the original set by offering a similar scope and complexity that revolves around factorial computation and leverages Python’s capabilities to handle large integers. The problem requires understanding of factorial growth, optimization, and GCD calculation, thus providing a well-rounded assessment of the candidate\'s programming abilities.","solution":"import math def gcd_of_factorials(a: int, b: int) -> int: Returns the GCD of the factorials of two given numbers a and b. # The GCD of two factorials a! and b! is (min(a, b))! return math.factorial(min(a, b))"},{"question":"# Longest Consecutive Subsequence in an Array Given an unsorted array of integers, write a function to find the length of the longest consecutive elements sequence. The sequence must be consecutive and increasing, but the elements do not need to be sequentially adjacent in the array. Function Signature ```python def longest_consecutive_sequence(nums: list[int]) -> int: Returns the length of the longest consecutive elements sequence in the array. :param nums: A list of integers representing the array. :return: An integer length of the longest consecutive elements sequence. ``` Input * `nums`: A list of integers representing the array. Output * An integer representing the length of the longest consecutive elements sequence. Constraints * The length of the array will not exceed 10^5. * The values in the array will be between -10^9 and 10^9. Example ```python nums = [100, 4, 200, 1, 3, 2] # Expected output: 4 print(longest_consecutive_sequence(nums)) nums = [0, 1, -1] # Expected output: 3 print(longest_consecutive_sequence(nums)) nums = [10, 5, 15, 20] # Expected output: 1 print(longest_consecutive_sequence(nums)) ``` Explanation * In the first example, the longest consecutive sequence is `[1, 2, 3, 4]`, so the function should return `4`. * In the second example, the longest consecutive sequence is `[0, 1, -1]`, so the function should return `3`. * In the third example, no elements form a consecutive sequence longer than 1, so the function should return `1`.","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in the array. :param nums: A list of integers representing the array. :return: An integer length of the longest consecutive elements sequence. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums_set: # Only check for the beginning of sequences current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Subarray Sum Equals K **Context**: Given an array of integers and an integer `k`, you need to find the total number of continuous subarrays whose sum equals to `k`. This problem tests your understanding of cumulative sum concepts and efficient use of data structures to handle subarray problems. **Prompt**: Create a function that finds the total number of continuous subarrays that sum up to a given integer `k`. Leverage a hash map to optimize performance and demonstrate your understanding of cumulative sum approaches in solving array-based problems. **Function Signature**: ```python def subarray_sum_equals_k(nums: list[int], k: int) -> int: Finds the total number of continuous subarrays that sum to k. :param nums: List of integers :param k: Target sum for the subarrays :return: Number of continuous subarrays whose sums equal to k ``` # Requirements: 1. **Input**: A list of integers `nums` and an integer `k`. 2. **Output**: The total number of continuous subarrays whose sum equals `k`. 3. Implement an efficient algorithm using a hash map to track cumulative sums. 4. Handle large inputs efficiently. # Examples: ```python >>> subarray_sum_equals_k([1,1,1], 2) 2 >>> subarray_sum_equals_k([1,2,3], 3) 2 >>> subarray_sum_equals_k([0,0,0,0,0], 0) 15 >>> subarray_sum_equals_k([-1,1,2,3], 3) 2 ``` # Constraints: 1. All elements in the array and `k` are integers. 2. The length of `nums` can be up to 10^5. 3. The solution should prioritize time complexity (aiming for O(n) operations). # Hints: 1. Use a cumulative sum to track the sum of elements up to the current index. 2. Utilize a hash map to count occurrences of each cumulative sum. 3. For a given cumulative sum, the number of subarrays that sum up to `k` can be found by checking if (cumulative_sum - k) has appeared before and how many times.","solution":"def subarray_sum_equals_k(nums: list[int], k: int) -> int: Finds the total number of continuous subarrays that sum to k. :param nums: List of integers :param k: Target sum for the subarrays :return: Number of continuous subarrays whose sums equal to k count = 0 cumulative_sum = 0 sum_dict = {0: 1} # To handle the case when cumulative_sum itself is k for num in nums: cumulative_sum += num if cumulative_sum - k in sum_dict: count += sum_dict[cumulative_sum - k] if cumulative_sum in sum_dict: sum_dict[cumulative_sum] += 1 else: sum_dict[cumulative_sum] = 1 return count"},{"question":"# Coding Question Implement a function that computes the nth Tribonacci number. The Tribonacci sequence is a generalization of the Fibonacci sequence where each term is the sum of the three preceding ones. The sequence starts as follows: 0, 1, 1, 2, 4, 7, 13, etc. # Function Signature ```python def tribonacci(n: int) -> int: pass ``` # Input Format - `n`: A non-negative integer. # Output Format - Returns the nth Tribonacci number as an integer. # Constraints - `0 <= n <= 37` # Examples ```python >>> tribonacci(0) 0 >>> tribonacci(4) 4 >>> tribonacci(10) 149 ``` # Note The first three Tribonacci numbers T0, T1, and T2 are traditionally 0, 1, and 1, respectively: - T0 = 0 - T1 = 1 - T2 = 1 - T3 = T0 + T1 + T2 = 0 + 1 + 1 = 2 - T4 = T1 + T2 + T3 = 1 + 1 + 2 = 4 - T5 = T2 + T3 + T4 = 1 + 2 + 4 = 7 - and so on...","solution":"def tribonacci(n: int) -> int: Returns the nth Tribonacci number. :param n: A non-negative integer indicating the position in the Tribonacci sequence. :return: The nth Tribonacci number. if n == 0: return 0 elif n == 1 or n == 2: return 1 t0, t1, t2 = 0, 1, 1 for i in range(3, n + 1): t3 = t0 + t1 + t2 t0, t1, t2 = t1, t2, t3 return t2"},{"question":"# Problem Statement You are given a matrix `grid` representing the number of times elements appear in rows and columns. The matrix has `m` rows and `n` columns, where each cell `grid[i][j]` contains an integer denoting the number of times a particular element appears at that position. Your task is to write a function that returns the number of times the most frequent integer appears in the matrix. Function Signature ```python from typing import List def most_frequent_element_count(grid: List[List[int]]) -> int: pass ``` Input * `grid`: A 2D list of integers where `grid[i][j]` represents the count of a specific element at that position. Output * Returns an integer indicating the highest frequency of any element within the matrix. Constraints * The matrix `grid` has dimensions `mxn`, where `1 <= m, n <= 100`. * Each `grid[i][j]` will be a non-negative integer within the range `[0, 100]`. Example ```python # Example 1 grid = [ [1, 2, 3], [3, 2, 1], [0, 3, 2] ] assert most_frequent_element_count(grid) == 3 # Example 2 grid = [ [7, 0, 5, 5], [0, 5, 3, 5], [2, 6, 1, 5] ] assert most_frequent_element_count(grid) == 5 # Example 3 grid = [ [4] ] assert most_frequent_element_count(grid) == 4 # Example 4 grid = [ [1, 2], [2, 2] ] assert most_frequent_element_count(grid) == 3 ``` Notes * Traverse the entire matrix to count the frequency of each element appearing. * Consider optimized ways to handle large matrices to avoid significant computational overhead. * Edge cases include matrices of size `1x1` and rows or columns with uniform values.","solution":"from typing import List def most_frequent_element_count(grid: List[List[int]]) -> int: Finds the highest frequency of any element in a matrix. max_frequency = 0 for row in grid: for element in row: if element > max_frequency: max_frequency = element return max_frequency"},{"question":"Word Frequency Counter Objective: Design a Python function to count the frequency of each word in a given text string, emphasizing string manipulation, dictionary usage, and basic text processing strategies. Problem Description: You are tasked with writing a function `word_frequencies(text: str) -> dict` that takes a string of text and returns a dictionary where the keys are the unique words from the text, and the values are their respective frequencies. Words are case-insensitive, and punctuation should be ignored. Input: - `text`: a string representing the input text to analyze. Output: - Dictionary with words as keys and their frequency counts as values. Constraints: - The text string is assumed to contain words separated by spaces. - Words should be considered case-insensitively (`\\"Word\\"` and `\\"word\\"` should be counted as the same word). - Basic punctuation (`.`, `,`, `!`, `?`, `;`, `:`) should be stripped from words. - The function should efficiently handle strings that are large, but keep performance within reasonable limits. Requirements: 1. The function should handle and normalize text case insensitively. 2. Punctuation marks should be removed from the words. 3. The output dictionary should only include valid words (non-empty after processing). 4. Optimize for both time and space, particularly for large inputs. Example Usage: ```python text = \\"Hello, world! Hello...\\" frequencies = word_frequencies(text) print(frequencies) # Output: {\'hello\': 2, \'world\': 1} ``` Implementation Strategy: 1. Normalize the text to lowercase. 2. Remove punctuation using a predefined set of characters. 3. Split the text by spaces and filter out any empty results. 4. Count the frequency of each word using a dictionary. 5. Return the dictionary with word frequencies. ```python def word_frequencies(text: str) -> dict: Count word frequencies in the given text. :param text: The input text string to analyze. :return: Dictionary of word frequencies. # Implementation of the function import re from collections import defaultdict # Convert text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r\'[,.!?;:]\', \'\', text) # Split the text into words words = text.split() # Initialize a defaultdict to store word frequencies freq_dict = defaultdict(int) # Count each word\'s frequency for word in words: if word: freq_dict[word] += 1 return dict(freq_dict) ``` Implement the function while ensuring proper handling of edge cases, large input sizes, and including detailed documentation/comments.","solution":"def word_frequencies(text: str) -> dict: Count word frequencies in the given text. :param text: The input text string to analyze. :return: Dictionary of word frequencies. # Implementation of the function import re from collections import defaultdict # Convert text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r\'[,.!?;:]\', \'\', text) # Split the text into words words = text.split() # Initialize a defaultdict to store word frequencies freq_dict = defaultdict(int) # Count each word\'s frequency for word in words: if word: freq_dict[word] += 1 return dict(freq_dict)"},{"question":"# Problem Statement You are given a string consisting of lowercase English letters. You need to implement a Suffix Array for this string to support the following operations efficiently: 1. **Lexicographical Order Search**: Find the smallest suffix starting with a given prefix. 2. **Count Occurrences**: Count all occurrences of a given substring in the string. The Suffix Array should be able to handle multiple operations efficiently on the given string. # Class Specifications 1. **`__init__(self, text: str) -> None`**: Initialize the Suffix Array for the given string `text`. 2. **`build_suffix_array(self) -> None`**: Build the Suffix Array for the string. 3. **`find_smallest_suffix(self, prefix: str) -> str`**: Find and return the smallest suffix starting with the given prefix. 4. **`count_occurrences(self, substring: str) -> int`**: Count and return the number of occurrences of the given substring in the string. # Input/Output Specifications - Input: - A string `text` consisting of lowercase English letters. - Multiple operations. - Output: - For the lexicographical order search operation, return the smallest suffix starting with the given prefix. - For the count occurrences operation, return the count of occurrences of the given substring. # Constraints - ( 1 leq text{len(text)} leq 10^5 ) - The string contains only lowercase English letters. - Queries and operations can be of the order ( 10^4 ). # Example ```python text = \\"banana\\" suffix_array = SuffixArray(text) suffix_array.build_suffix_array() print(suffix_array.find_smallest_suffix(\\"ban\\")) # Output: \\"banana\\" print(suffix_array.find_smallest_suffix(\\"nan\\")) # Output: \\"nana\\" print(suffix_array.count_occurrences(\\"ana\\")) # Output: 2 print(suffix_array.count_occurrences(\\"bn\\")) # Output: 0 ``` # Task Your task is to implement the above Suffix Array with functionality for both lexicographical order search and efficient substring occurrence counting.","solution":"class SuffixArray: def __init__(self, text: str) -> None: self.text = text self.suffix_array = [] def build_suffix_array(self) -> None: self.suffix_array = sorted((self.text[i:], i) for i in range(len(self.text))) def find_smallest_suffix(self, prefix: str) -> str: left, right = 0, len(self.suffix_array) while left < right: mid = (left + right) // 2 if self.suffix_array[mid][0].startswith(prefix): if mid == 0 or not self.suffix_array[mid-1][0].startswith(prefix): return self.suffix_array[mid][0] right = mid elif self.suffix_array[mid][0] < prefix: left = mid + 1 else: right = mid return \\"\\" def count_occurrences(self, substring: str) -> int: def lower_bound(prefix): left, right = 0, len(self.suffix_array) while left < right: mid = (left + right) // 2 if self.suffix_array[mid][0] < prefix: left = mid + 1 else: right = mid return left def upper_bound(prefix): left, right = 0, len(self.suffix_array) while left < right: mid = (left + right) // 2 if self.suffix_array[mid][0] <= prefix: left = mid + 1 else: right = mid return left lower = lower_bound(substring) upper = upper_bound(substring + \\"{\\") return upper - lower"},{"question":"Sales Promotion Analysis You are managing a sales promotion for a range of products, and you need to analyze the sales data to determine the maximum profit that can be achieved from a limited number of sales slots. The sales data is given as a list of profits for each product. You can only promote a certain number of products within a given range of days. The aim is to find the contiguous subarray with the maximum total profit that does not exceed the allowed number of sales slots. # Function Signature: ```python def max_profit( profits: list[int], max_slots: int ) -> int: ``` # Input: 1. `profits`: A list of integers where each element represents the profit for each product. 2. `max_slots`: An integer representing the maximum number of sales slots available. # Output: * An integer representing the maximum total profit that can be achieved without exceeding the allowed number of sales slots. # Constraints: * The number of products, `n`, is such that `1 <= n <= 10^5`. * The profit values for each product can be negative, zero, or positive. * `1 <= max_slots <= n`. # Example: ```python profits = [2, 1, -3, 4, -1, 2, 1, -5, 4] max_slots = 4 print(max_profit(profits, max_slots)) ``` Output: ```python 6 ``` # Notes: * In the above example, the contiguous subarray `[4, -1, 2, 1]` provides the maximum profit of `6` within `4` slots. * Implement an efficient solution with an appropriate algorithm to handle the given constraints. * Consider edge cases such as all negative numbers, all positive numbers, and a mix of both.","solution":"def max_profit(profits, max_slots): Returns the maximum total profit obtained from a contiguous subarray of size at most max_slots. n = len(profits) if max_slots > n: max_slots = n max_profit = float(\'-inf\') current_sum = 0 # Initial window for i in range(max_slots): current_sum += profits[i] max_profit = current_sum # Sliding the window for i in range(max_slots, n): current_sum += profits[i] current_sum -= profits[i - max_slots] max_profit = max(max_profit, current_sum) return max_profit"},{"question":"# Problem Statement # Scenario You are developing a feature for a social networking platform to help users organize a list of their friends based on mutual interests. Each friend has a certain number of common interests with the user. You want to prioritize friends who have the most shared interests to sort the friends list. # Task Implement a function `organize_friends` that sorts a list of friends by the number of mutual interests in descending order. If two friends have the same number of mutual interests, they should be sorted alphabetically by their name. # Requirements 1. Write a class `Friend` that captures the following attributes: name, mutual_interests. 2. Implement the utility function `build_friend_list(names, mutual_interests)` which constructs a list of `Friend` objects. 3. Implement the function `organize_friends(friend_list)` which should return the sorted list of friends. # Input * `friend_list`: List of `Friend` objects. # Output * A list of `Friend` objects sorted by the number of mutual interests in descending order. If two friends have the same number of mutual interests, sort them alphabetically by name. **Function Signatures** ```python class Friend: def __init__(self, name, mutual_interests): self.name = name self.mutual_interests = mutual_interests def get_mutual_interests(self): return self.mutual_interests def __repr__(self): return f\\"{self.__class__.__name__}({self.name}, {self.mutual_interests})\\" def build_friend_list(names, mutual_interests): pass def organize_friends(friend_list): pass ``` # Constraints * `1 <= len(friend_list) <= 10^5` * `1 <= mutual_interests <= 10^3` for each friend. * Friend names consist of alphabetic characters only. # Performance * The implementation should aim for a time complexity of O(n log n) due to sorting. # Example ```python def test_organize_friends(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] mutual_interests = [5, 3, 5, 2] friend_list = build_friend_list(names, mutual_interests) sorted_friends = organize_friends(friend_list) expected_result = [ Friend(\\"Alice\\", 5), Friend(\\"Charlie\\", 5), Friend(\\"Bob\\", 3), Friend(\\"David\\", 2) ] assert sorted_friends == expected_result, f\\"Expected {expected_result} but got {sorted_friends}\\" print(sorted_friends) # Calling the test function test_organize_friends() ```","solution":"class Friend: def __init__(self, name, mutual_interests): self.name = name self.mutual_interests = mutual_interests def get_mutual_interests(self): return self.mutual_interests def __repr__(self): return f\\"Friend({self.name}, {self.mutual_interests})\\" def __eq__(self, other): return (self.name, self.mutual_interests) == (other.name, other.mutual_interests) def build_friend_list(names, mutual_interests): Constructs a list of Friend objects from the given names and mutual interests. return [Friend(name, interests) for name, interests in zip(names, mutual_interests)] def organize_friends(friend_list): Sorts a list of Friend objects by the number of mutual interests in descending order. If two friends have the same number of mutual interests, sort them alphabetically by name. return sorted(friend_list, key=lambda friend: (-friend.get_mutual_interests(), friend.name))"},{"question":"# Question You are given a list of integers `arr` and an integer `k`. Implement a Python function `find_kth_largest(arr, k)` that returns the k-th largest element in the list using a max-heap. * **Input**: - `arr`: a list of integers. - `k`: an integer representing the k-th order statistic. * **Output**: - Returns the k-th largest element in the list. * **Constraints**: - `1 <= len(arr) <= 10^5` - `1 <= k <= len(arr)` - Elements of `arr` can be any integer, including negative values. * **Additional Specifications**: - Do not use any built-in sorting functions. - You are allowed to use heapq (the heap queue algorithm) library from the Python standard library. * **Example**: ```python arr = [3, 2, 1, 5, 6, 4] k = 2 print(find_kth_largest(arr, k)) # Output: 5 arr = [3, 2, 3, 1, 2, 4, 5, 5, 6] k = 4 print(find_kth_largest(arr, k)) # Output: 4 ``` Note: The function should be efficient with respect to both time and space complexity, leveraging heap operations optimally given the constraints.","solution":"import heapq def find_kth_largest(arr, k): if not arr or k <= 0 or k > len(arr): raise ValueError(\\"Invalid input\\") # Create a min heap with the first k elements from arr heap = arr[:k] heapq.heapify(heap) # Process the remaining elements in the array for num in arr[k:]: if num > heap[0]: heapq.heapreplace(heap, num) return heap[0]"},{"question":"# Coding Question **Perfect Numbers in Range** A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. In this exercise, you will implement a function that finds all the perfect numbers in a given range. **Function Signature**: ```python def find_perfect_numbers(start: int, end: int) -> List[int]: Find and return a list of all perfect numbers between `start` and `end` (inclusive). Parameters: - start (int): The starting integer of the range. - end (int): The ending integer of the range. Returns: - List[int]: A list of perfect numbers between `start` and `end`. Example: >>> find_perfect_numbers(1, 10000) [6, 28, 496, 8128] ``` # Constraints * `1 <= start <= end <= 10**6` * The function should be able to handle up to `10^6` in a reasonable time frame. # Input and Output * **Input**: Two integers `start` and `end`. * **Output**: A list of integers that are perfect numbers within the given range. # Evaluation Criteria * Correctness: The function must accurately identify perfect numbers within the specified range. * Efficiency: The solution should be optimized for large ranges. * Readability: The code should be well-structured and easy to read.","solution":"from typing import List def find_perfect_numbers(start: int, end: int) -> List[int]: Find and return a list of all perfect numbers between `start` and `end` (inclusive). def is_perfect(number: int) -> bool: if number < 2: return False sum_of_divisors = 1 # 1 is a proper divisor of every number. for i in range(2, int(number**0.5) + 1): if number % i == 0: sum_of_divisors += i if i != number // i: sum_of_divisors += number // i return sum_of_divisors == number perfect_numbers = [] for num in range(start, end + 1): if is_perfect(num): perfect_numbers.append(num) return perfect_numbers"},{"question":"# Problem Statement A matrix transposition task is among one of the common operations in linear algebra and computer science. You are required to transcribe a transposition function to commonly transpose a 2D matrix—that is, interchange its rows and columns. Your task is to complete the implementation of the `Matrix` class. This class is designed to efficiently store a matrix of integers and support the following operations: * **Initialization**: Create a matrix with given dimensions and initialize all elements to zero. * **`set_value(row: int, column: int, value: int) -> None`**: Set the value at the specific cell. * **`get_value(row: int, column: int) -> int`**: Get the value at the specific cell. * **`transpose() -> \'Matrix\'`**: Return the transposed matrix without modifying the original matrix. # Function Signature Here\'s the function signature you should implement: ```python class Matrix: def __init__(self, rows: int, columns: int) -> None: pass def set_value(self, row: int, column: int, value: int) -> None: pass def get_value(self, row: int, column: int) -> int: pass def transpose(self) -> \'Matrix\': pass ``` # Input/Output Format * The constructor takes two integers `rows` and `columns` representing the number of rows and columns of the matrix respectively. * The `set_value` method takes three integers `row`, `column`, and `value`, to set the element at `row`, `column` to `value`. * The `get_value` method takes two integers `row` and `column`, returning the value at that cell. * The `transpose` method returns a new `Matrix` object which is the transpose of the original matrix. # Constraints * `1 <= rows, columns <= 1000` * `0 <= row < rows` * `0 <= column < columns` * `-10^9 <= value <= 10^9` # Examples ```python # Example 1 m = Matrix(2, 3) m.set_value(0, 0, 1) m.set_value(0, 1, 2) m.set_value(0, 2, 3) m.set_value(1, 0, 4) m.set_value(1, 1, 5) m.set_value(1, 2, 6) t = m.transpose() print(t.get_value(0, 0)) # Output: 1 print(t.get_value(1, 0)) # Output: 2 print(t.get_value(2, 0)) # Output: 3 print(t.get_value(0, 1)) # Output: 4 print(t.get_value(1, 1)) # Output: 5 print(t.get_value(2, 1)) # Output: 6 # Example 2 m = Matrix(3, 1) m.set_value(0, 0, 7) m.set_value(1, 0, 8) m.set_value(2, 0, 9) t = m.transpose() print(t.get_value(0, 0)) # Output: 7 print(t.get_value(0, 1)) # Output: 8 print(t.get_value(0, 2)) # Output: 9 ```","solution":"class Matrix: def __init__(self, rows: int, columns: int) -> None: self.rows = rows self.columns = columns self.data = [[0] * columns for _ in range(rows)] def set_value(self, row: int, column: int, value: int) -> None: self.data[row][column] = value def get_value(self, row: int, column: int) -> int: return self.data[row][column] def transpose(self) -> \'Matrix\': transposed = Matrix(self.columns, self.rows) # Transpose matrix will have swapped rows and columns for i in range(self.rows): for j in range(self.columns): transposed.set_value(j, i, self.get_value(i, j)) return transposed"},{"question":"# Coding Assessment Question **Problem Statement:** You are working with matrices and have been tasked to write a set of functions to perform two specific operations. Your goal is to implement a function for rotating a matrix 90 degrees clockwise and another function for reflecting the matrix vertically. Requirements: 1. **Rotate 90 Degrees Clockwise**: Create a function `rotate_90_clockwise` that takes a square matrix as input and returns a new matrix which is the result of rotating the original matrix 90 degrees clockwise. 2. **Reflect Vertically**: Create a function `reflect_vertically` that takes a square matrix as input and returns a new matrix which represents the vertical reflection of the original matrix. Input: - A 2D list (square matrix) of integers. Output: - For `rotate_90_clockwise`: A 2D list (square matrix) of integers representing the matrix rotated 90 degrees clockwise. - For `reflect_vertically`: A 2D list (square matrix) of integers representing the vertically reflected matrix. Constraints: - The matrix will be of size `N x N`, where `1 <= N <= 100`. - The integers in the matrix will fall within the range `-10^3` to `10^3`. Function Signature: ```python def rotate_90_clockwise(matrix: list[list[int]]) -> list[list[int]]: ... def reflect_vertically(matrix: list[list[int]]) -> list[list[int]]: ... # Example Usage: # matrix = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # rotated_matrix = rotate_90_clockwise(matrix) # reflected_matrix = reflect_vertically(matrix) # print(rotated_matrix) # Expected rotated output # print(reflected_matrix) # Expected reflected output ``` --- **Example:** ```python def rotate_90_clockwise(matrix: list[list[int]]) -> list[list[int]]: N = len(matrix) new_matrix = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): new_matrix[j][N-i-1] = matrix[i][j] return new_matrix def reflect_vertically(matrix: list[list[int]]) -> list[list[int]]: N = len(matrix) for i in range(N // 2): for j in range(N): matrix[i][j], matrix[N-1-i][j] = matrix[N-1-i][j], matrix[i][j] return matrix # Test matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_90_clockwise(matrix) reflected_matrix = reflect_vertically(matrix) print(rotated_matrix) # Expected output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] print(reflected_matrix) # Expected output: [[7, 8, 9], [4, 5, 6], [1, 2, 3]] ``` You are to implement the `rotate_90_clockwise` and `reflect_vertically` methods to transform the given square matrix accordingly. Make sure to maintain an optimal approach for matrix manipulation.","solution":"def rotate_90_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotates the given square matrix by 90 degrees clockwise. N = len(matrix) # Initialize the new matrix to store the rotated result new_matrix = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): new_matrix[j][N-1-i] = matrix[i][j] return new_matrix def reflect_vertically(matrix: list[list[int]]) -> list[list[int]]: Reflects the given square matrix vertically. N = len(matrix) # Perform vertical reflection by swapping rows new_matrix = matrix[:] for i in range(N // 2): new_matrix[i], new_matrix[N-1-i] = new_matrix[N-1-i], new_matrix[i] return new_matrix"},{"question":"# Query Factorial of Large Numbers Objective You are required to implement a feature to calculate and query the factorial of large numbers. Given a number, you will compute its factorial and be able to handle multiple queries efficiently. # Task Description 1. **Class Implementation**: - Implement a `FactorialCalculator` class to handle the computation and querying of factorials. 2. **Methods**: - `__init__(self)`: Initializes the class and prepares any necessary pre-computation. - `compute_factorial(self, n: int) -> int`: Computes the factorial of `n`. - `query_factorial(self, n: int) -> int`: Returns the factorial of `n` with efficient querying using memoization or precomputation techniques. 3. **Functions**: - `factorial_range(start: int, end: int) -> List[int]`: Computes factorials for all integers in the range `[start, end]`. # Constraints - The input number `n` can be as large as `5000`. - Factorials can be very large and should be handled using appropriate data types to store large integers. # Input Format - The input will be provided as a list of commands: ```python commands = [ (\\"compute\\", 5), (\\"compute\\", 10), (\\"query\\", 5), (\\"range\\", 3, 7) ] ``` Each command is a tuple, where: * `\\"compute\\"` command is followed by an integer `n` to compute its factorial. * `\\"query\\"` command is followed by an integer `n` to query the precomputed factorial. * `\\"range\\"` command is followed by two integers `start` and `end` to compute factorials for all numbers in the range. # Output Format - Output should be a list of results for each `\\"query\\"` and `\\"range\\"` operation: ```python results = [ 120, # Result of query operation. [6, 24, 120, 720, 5040] # Result of range operation. ] ``` # Example ```python commands = [ (\\"compute\\", 5), (\\"compute\\", 10), (\\"query\\", 5), (\\"range\\", 3, 7) ] # Expected Output: # [ # 120, # Result of query operation for 5!. # [6, 24, 120, 720, 5040] # Result of range operation from 3! to 7!. # ] ``` Implement the `FactorialCalculator` class and accompanying functions to execute the provided commands and produce the expected results.","solution":"from math import factorial from typing import List, Union class FactorialCalculator: def __init__(self): self.memo = {} def compute_factorial(self, n: int) -> int: if n in self.memo: return self.memo[n] self.memo[n] = factorial(n) return self.memo[n] def query_factorial(self, n: int) -> int: if n in self.memo: return self.memo[n] else: raise ValueError(f\\"Factorial for {n} has not been computed yet.\\") def factorial_range(start: int, end: int) -> List[int]: calculator = FactorialCalculator() return [calculator.compute_factorial(i) for i in range(start, end + 1)]"},{"question":"# Question: Implement Efficient Fibonacci Sequence Generator Context You are developing a module for a financial analytics tool that needs to calculate large Fibonacci numbers efficiently. The naive recursive implementation is too slow for your needs, especially for large inputs. Task Implement an efficient **Fibonacci Sequence Generator** using iterative or matrix exponentiation techniques to handle large inputs. # Requirements 1. **Function Signature**: `def efficient_fibonacci(n: int) -> int:` 2. **Input**: - A single integer, `n`, which represents the position in the Fibonacci sequence. - Example: `10`, `50`, `100` 3. **Output**: - The `nth` Fibonacci number. 4. **Constraints**: - `n` will be a non-negative integer. - The solution should be able to handle values of `n` up to 10,000. # Performance Expectations - The solution should aim for **O(log n)** time complexity using matrix exponentiation or other efficient algorithms. - Use **O(1)** or **O(log n)** space complexity depending on the approach. Example ```python >>> efficient_fibonacci(10) 55 >>> efficient_fibonacci(50) 12586269025 >>> efficient_fibonacci(100) 354224848179261915075 >>> efficient_fibonacci(0) 0 >>> efficient_fibonacci(1) 1 ```","solution":"def efficient_fibonacci(n: int) -> int: Returns the nth Fibonacci number efficiently using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 def matrix_multiply(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_power(M, power): result = [[1, 0], [0, 1]] while power > 0: if power % 2 == 1: result = matrix_multiply(result, M) M = matrix_multiply(M, M) power //= 2 return result F = [[1, 1], [1, 0]] result = matrix_power(F, n-1) return result[0][0]"},{"question":"Question Sorting algorithms are fundamental in computer science due to their wide application in various domains. Implement the Merge Sort algorithm to sort a list of integers in non-decreasing order. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers `arr` (0 ≤ len(arr) ≤ 10^6) where each integer is within the range of -10^9 to 10^9. # Output * A list of integers sorted in non-decreasing order. # Examples ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([1, -3, 2, 0, -4, 5]) [-4, -3, 0, 1, 2, 5] >>> merge_sort([]) [] ``` # Scenario Suppose you are working on a large dataset where the standard sort methods are not efficient enough. Implementing a classic merge sort will help in performance-critical scenarios where there are significant constraints on time complexity and scalability. # Notes The merge sort algorithm should be implemented recursively. Ensure that the algorithm handles edge cases such as empty lists and single-element lists efficiently. The function should be tested for both small and large inputs, demonstrating optimal performance adhering to a time complexity of (O(n log n)).","solution":"def merge_sort(arr): Performs the merge sort algorithm on a list of integers. Parameters: arr (list): A list of integers to be sorted. Returns: list: A new list containing the elements of the input list in non-decreasing order. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. Parameters: left (list): The first sorted list. right (list): The second sorted list. Returns: list: A merged sorted list containing all elements from both input lists. sorted_list = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] <= right[right_idx]: sorted_list.append(left[left_idx]) left_idx += 1 else: sorted_list.append(right[right_idx]) right_idx += 1 # Append any remaining elements from the left list while left_idx < len(left): sorted_list.append(left[left_idx]) left_idx += 1 # Append any remaining elements from the right list while right_idx < len(right): sorted_list.append(right[right_idx]) right_idx += 1 return sorted_list"},{"question":"# Problem Description: Design and implement a `SparseVector` class to efficiently represent and manipulate sparse vectors. A sparse vector is a vector in which most of the elements are zero. Your class should support the following operations: 1. **Initialization**: Initialize the sparse vector with a given list of integers. 2. **Dot Product**: Compute the dot product of the current sparse vector with another sparse vector. 3. **Addition**: Compute and return a new sparse vector that is the result of adding another sparse vector to the current sparse vector. 4. **Size**: Return the size (number of elements) of the sparse vector. # Requirements: - **Input Format**: - For initialization, the method signature should be: ```python def __init__(self, values: list[int]) -> None ``` - For dot product, the method signature should be: ```python def dot_product(self, other: \'SparseVector\') -> int ``` - For addition, the method signature should be: ```python def add(self, other: \'SparseVector\') -> \'SparseVector\' ``` - For size, the method signature should be: ```python def size(self) -> int ``` - **Performance Constraints**: - Your implementation should take advantage of the sparsity of the vector to minimize the time complexity of operations. - **Assumptions**: - The input vectors for the dot product and addition have the same size. # Example Usage: ```python vec1 = SparseVector([1, 0, 0, 2, 0, 0]) vec2 = SparseVector([0, 3, 0, 4, 0, 0]) print(vec1.dot_product(vec2)) # Output: 8 (1*0 + 0*3 + 0*0 + 2*4 + 0*0 + 0*0) result = vec1.add(vec2) print(result.size()) # Output: 6 print(result.values) # Output: [1, 3, 0, 6, 0, 0] ``` # Notes: - Use dictionaries to store non-zero elements for efficient computations. - Ensure the size method returns the correct size of the original vector. - Handle edge cases, such as adding empty vectors or computing the dot product with vectors of different sizes. - Follow proper coding conventions and structure your code to be clear and maintainable.","solution":"class SparseVector: def __init__(self, values: list[int]) -> None: self.size_value = len(values) self.values = {i: values[i] for i in range(len(values)) if values[i] != 0} def dot_product(self, other: \'SparseVector\') -> int: result = 0 for key in self.values: if key in other.values: result += self.values[key] * other.values[key] return result def add(self, other: \'SparseVector\') -> \'SparseVector\': result = [0] * self.size() for key in self.values: result[key] = self.values[key] for key in other.values: result[key] += other.values[key] return SparseVector(result) def size(self) -> int: return self.size_value"},{"question":"# Problem Statement Context You need to design a function that generates a series of prime numbers up to the `n`-th prime. The prime numbers series begins with the number 2. The function should be able to handle various edge cases and return the prime numbers accurately as strings in a specified format. Function Signature ```python def prime_series(n: int) -> list[str]: ``` Input 1. `n (int)`: The number of prime numbers to generate. Output * Returns a `list[str]` where each element is a string representation of a prime number, in the format \\"Prime: value\\". If the input is invalid or less than 1, return an empty list. Constraints * Ensure that `n` is a positive integer. * Efficiently compute the prime numbers up to the `n`-th prime. * Handle edge cases where `n` is invalid or less than 1. Examples ```python >>> prime_series(5) [\'Prime: 2\', \'Prime: 3\', \'Prime: 5\', \'Prime: 7\', \'Prime: 11\'] >>> prime_series(1) [\'Prime: 2\'] >>> prime_series(0) [] >>> prime_series(-3) [] >>> prime_series(10) [\'Prime: 2\', \'Prime: 3\', \'Prime: 5\', \'Prime: 7\', \'Prime: 11\', \'Prime: 13\', \'Prime: 17\', \'Prime: 19\', \'Prime: 23\', \'Prime: 29\'] ``` Additional Requirements: 1. Validate `n` to ensure it is a positive integer before computing primes. 2. Implement an efficient algorithm for prime number generation, such as the Sieve of Eratosthenes or trial division. 3. Ensure the function handles and returns correctly for edge cases such as `n = 0` or negative values for `n`. This problem tests your ability to handle number sequences, validate inputs, and ensure efficient computation, consistent with the complexity and style of the provided sample questions.","solution":"def prime_series(n: int) -> list[str]: if not isinstance(n, int) or n < 1: return [] primes = [] candidate = 2 while len(primes) < n: for p in primes: if candidate % p == 0: break else: primes.append(candidate) candidate += 1 return [f\\"Prime: {prime}\\" for prime in primes]"},{"question":"# Question: Find Duplicates in a List In this task, you need to write a Python function that takes a list of integers and returns a list of duplicates in the order they first appear in the list. Each duplicate should only appear once in the output list. Function Signature ```python def find_duplicates(nums: List[int]) -> List[int]: pass ``` Input * `nums` (List[int]): A list of integers (both positive and negative). The list is guaranteed to have at least one element. Output * A list of integers that are duplicates from the input list, in the order they first appear. Each duplicate should only appear once in the output list. Constraints * 1 <= len(nums) <= 10^4 * -10^5 <= nums[i] <= 10^5 Example ```python # Test Case 1 assert find_duplicates([1, 2, 3, 1, 2, 4, 5, 6, 1]) == [1, 2] # Test Case 2 assert find_duplicates([-1, -2, -3, -1, -2, -3, -4, -5]) == [-1, -2, -3] # Test Case 3 assert find_duplicates([10, 20, 30, 40, 50, 30, 20, 60, 10]) == [10, 20, 30] # Test Case 4 assert find_duplicates([7]) == [] ``` Implementation Requirements * Use efficient data structures to track duplicates and already seen elements. * Ensure proper handling of edge cases and invalid inputs. Tips * Utilize sets to track seen elements and duplicates. * Ensure the function has a linear time complexity for optimal performance. * Validate your solution with edge cases and large input lists.","solution":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: seen = set() duplicates = set() result = [] for num in nums: if num in seen: if num not in duplicates: duplicates.add(num) result.append(num) else: seen.add(num) return result"},{"question":"# Question: Python Module Version Comparison In software development, it\'s often necessary to compare version numbers to determine which is newer. Version numbers are typically written in a format that consists of integers separated by dots, for example `1.2.3`. Each part of the version number represents a different level of the hierarchy (major.minor.patch). Your task is to implement a function that takes in two version strings and determines which one is newer. The function should return `1` if the first version is newer, `-1` if the second version is newer, and `0` if both versions are the same. # Function Signature ```python def compare_versions(version1: str, version2: str) -> int: Compares two version numbers and returns: - 1 if version1 is newer - -1 if version2 is newer - 0 if both versions are the same :param version1: str - The first version number as a string. :param version2: str - The second version number as a string. :return: int - The comparison result. >>> compare_versions(\\"1.2.3\\", \\"1.2.3\\") 0 >>> compare_versions(\\"1.2.4\\", \\"1.2.3\\") 1 >>> compare_versions(\\"1.2.3\\", \\"1.2.4\\") -1 >>> compare_versions(\\"1.2\\", \\"1.2.1\\") -1 >>> compare_versions(\\"1.2.3.4\\", \\"1.2.3\\") 1 ``` # Input - `version1`: A string representing the first version number (e.g., \\"1.2.3\\"). - `version2`: A string representing the second version number (e.g., \\"1.2.3\\"). # Output - An integer `1` if `version1` is newer. - An integer `-1` if `version2` is newer. - An integer `0` if both versions are the same. # Constraints - The version strings will only contain digits and dots. - Each segment in version strings will represent non-negative integers (e.g., \\"0\\", \\"1\\", \\"202\\"). # Example ```python version1 = \\"1.2.3\\" version2 = \\"1.2.4\\" output = compare_versions(version1, version2) # Expected output: -1 version1 = \\"1.2.4\\" version2 = \\"1.2.3\\" output = compare_versions(version1, version2) # Expected output: 1 version1 = \\"1.0\\" version2 = \\"1.0.0\\" output = compare_versions(version1, version2) # Expected output: 0 ``` # Notes: - Split the version numbers by the dot (`.`) character and compare each corresponding segment. - If one version number has more segments than the other, treat missing segments as 0 during the comparison. - The function should handle leading zeros in version segments appropriately. ```python def compare_versions(version1: str, version2: str) -> int: v1_segments = list(map(int, version1.split(\'.\'))) v2_segments = list(map(int, version2.split(\'.\'))) # Pad the shorter list with zeros (considering missing segments as 0) length = max(len(v1_segments), len(v2_segments)) v1_segments.extend([0] * (length - len(v1_segments))) v2_segments.extend([0] * (length - len(v2_segments))) for v1, v2 in zip(v1_segments, v2_segments): if v1 > v2: return 1 elif v1 < v2: return -1 return 0 ``` This question introduces students to string manipulation, list extension methods, and iteration techniques in Python, ensuring they practice vital skills required for technical roles.","solution":"def compare_versions(version1: str, version2: str) -> int: v1_segments = list(map(int, version1.split(\'.\'))) v2_segments = list(map(int, version2.split(\'.\'))) # Pad the shorter list with zeros (considering missing segments as 0) length = max(len(v1_segments), len(v2_segments)) v1_segments.extend([0] * (length - len(v1_segments))) v2_segments.extend([0] * (length - len(v2_segments))) for v1, v2 in zip(v1_segments, v2_segments): if v1 > v2: return 1 elif v1 < v2: return -1 return 0"},{"question":"Scenario: You are developing a system to analyze the performance metrics of an application over time. Specifically, you need to compute rolling averages over a series of time-stamped data points. This is crucial for identifying trends and fluctuations in the application\'s performance metrics. # Question: Implement a function that calculates the rolling average of an application\'s metric performance from the given time-series data. The function should take into account a specified window size to compute the average over the latest subset of data points. # Function Signature: * **function name:** `rolling_average` * **inputs**: - `data` (List[Tuple[int, float]]): A list of tuples where each tuple consists of a timestamp (int) and the corresponding metric value (float). The list is sorted by timestamp in ascending order. - `window_size` (int): An integer specifying the number of latest data points to include in each rolling average calculation. * **outputs**: - `averages` (List[Tuple[int, float]]): A list of tuples where each tuple consists of a timestamp (int) and the computed rolling average (float) at that timestamp. # Constraints: 1. The length of `data` will be between 1 and 10,000 inclusive. 2. The `window_size` will be between 1 and the length of `data` inclusive. 3. Ensure precision in floating-point calculations. # Example: ```python # Example usage: data = [ (1, 2.0), (2, 4.0), (3, 6.0), (4, 8.0), (5, 10.0) ] window_size = 3 averages = rolling_average(data, window_size) print(averages) # Expected Output: # [(3, 4.0), # (4, 6.0), # (5, 8.0)] ``` # Additional Notes: - Ensure the output list only contains tuples starting from the point where the rolling window can be fully applied. - The function should handle edge cases such as an empty list of data points or a window size of 1. - Optimize for performance given the potential size of the input list.","solution":"from typing import List, Tuple def rolling_average(data: List[Tuple[int, float]], window_size: int) -> List[Tuple[int, float]]: Calculates the rolling average of an application\'s metric performance from the given time-series data. Parameters: data (List[Tuple[int, float]]): A list of tuples where each tuple consists of a timestamp (int) and the corresponding metric value (float). window_size (int): The number of latest data points to include in each rolling average calculation. Returns: List[Tuple[int, float]]: A list of tuples where each tuple consists of a timestamp (int) and the computed rolling average (float) at that timestamp. if not data or window_size <= 0: return [] averages = [] n = len(data) window_sum = sum(data[i][1] for i in range(window_size)) averages.append((data[window_size-1][0], window_sum / window_size)) for i in range(window_size, n): window_sum += data[i][1] - data[i-window_size][1] avg = window_sum / window_size averages.append((data[i][0], avg)) return averages"},{"question":"# Coding Question Objective Your task is to implement a function that calculates the area of a right-angled triangle given the lengths of its two perpendicular sides. Function Signature ```python def calculate_area(base: float, height: float) -> float: ``` Inputs - `base (float)`: The length of one of the perpendicular sides of the triangle in meters. (0 ≤ base ≤ 10^5) - `height (float)`: The length of the other perpendicular side of the triangle in meters. (0 ≤ height ≤ 10^5) Outputs - Returns `area (float)`: The area of the right-angled triangle in square meters. Assumptions - The base and height values given are valid numbers. - Area should be zero if either base or height is zero. Requirements - Ensure the calculations handle floating-point operations correctly. - Handle the case when either `base` or `height` is zero by returning `0`. Example ```python >>> calculate_area(10, 5) 25.0 >>> calculate_area(0, 5) 0.0 >>> calculate_area(3.3, 4.4) 7.26 ``` Constraints 1. You must write the implementation from scratch. Built-in functions that solve the entire problem are not allowed. 2. Ensure your solution handles edge cases properly.","solution":"def calculate_area(base: float, height: float) -> float: Calculates the area of a right-angled triangle given the lengths of its two perpendicular sides. Parameters: base (float): The length of one of the perpendicular sides of the triangle in meters. height (float): The length of the other perpendicular side of the triangle in meters. Returns: float: The area of the right-angled triangle in square meters. return 0.5 * base * height"},{"question":"**Scenario**: You are required to implement a system to manage a library\'s collection of books. The system should be able to add new books, lend books to members, and return books. Each book has a unique identifier (ID), title, author, and a flag indicating whether it is currently available. Each member has a unique identifier (ID) and a name. When a book is lent, it should be marked as unavailable until it is returned. **Task**: 1. **Add Book**: Implement functionality to add a new book to the library\'s collection. 2. **Lend Book**: Implement functionality to lend a book to a member. The book should be marked as unavailable. 3. **Return Book**: Implement functionality to return a book. The book should be marked as available. 4. **View Library**: Implement functionality to view the current list of books, indicating whether they are available or on loan. **Constraints**: * The library should prevent lending a book that is already on loan. * The library should prevent adding a book with a duplicate ID. * Members should have valid IDs and names. **Function Specifications**: ```python class Library: def __init__(self): self.books = {} self.members = {} def add_book(self, book_id: int, title: str, author: str) -> None: - book_id <type: int>: Unique identifier for the book - title <type: str>: Title of the book - author <type: str>: Author of the book Returns: None def lend_book(self, book_id: int, member_id: int) -> bool: - book_id <type: int>: Unique identifier for the book to be lent - member_id <type: int>: Unique identifier for the member who wants to borrow the book Returns <type: bool>: - True if the book is successfully lent - False if the book is not available or member ID is invalid def return_book(self, book_id: int) -> bool: - book_id <type: int>: Unique identifier for the book to be returned Returns <type: bool>: - True if the book is successfully returned - False if the book ID is invalid or the book was not on loan def view_library(self) -> None: Displays the current list of books with their status (available/loaned). Returns: None ``` **Input Format**: * Book details for adding a book (book ID, title, author). * Book ID and member ID for lending a book. * Book ID for returning a book. **Output Format**: * Confirmation of book addition. * Success or failure indication for lending and returning books. * Display of the current library inventory with availability status. **Example**: ```python lib = Library() # Add some books to the library lib.add_book(1, \\"1984\\", \\"George Orwell\\") lib.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") # View library status lib.view_library() # Lend a book to a member if lib.lend_book(1, 101): print(\\"Book lent successfully\\") else: print(\\"Book lending failed\\") # Attempt to lend an already lent book if lib.lend_book(1, 102): print(\\"Book lent successfully\\") else: print(\\"Book lending failed\\") # Return a book if lib.return_book(1): print(\\"Book returned successfully\\") else: print(\\"Book return failed\\") # View library status after lending and returning lib.view_library() ``` Expected behavior for the above example: 1. Adding books \\"1984\\" and \\"To Kill a Mockingbird\\" should succeed. 2. The library\'s inventory should display both books as available initially. 3. Lending the book \\"1984\\" to a member should succeed the first time but fail the second time. 4. Returning the book \\"1984\\" should succeed. 5. The library\'s inventory should reflect these changes in availability status.","solution":"class Library: def __init__(self): self.books = {} self.members = {} def add_book(self, book_id: int, title: str, author: str) -> None: - book_id <type: int>: Unique identifier for the book - title <type: str>: Title of the book - author <type: str>: Author of the book Returns: None if book_id in self.books: raise ValueError(\\"A book with this ID already exists.\\") self.books[book_id] = { \\"title\\": title, \\"author\\": author, \\"is_available\\": True } def lend_book(self, book_id: int, member_id: int) -> bool: - book_id <type: int>: Unique identifier for the book to be lent - member_id <type: int>: Unique identifier for the member who wants to borrow the book Returns <type: bool>: - True if the book is successfully lent - False if the book is not available or member ID is invalid if book_id not in self.books or not self.books[book_id][\\"is_available\\"]: return False self.books[book_id][\\"is_available\\"] = False self.members[member_id] = book_id return True def return_book(self, book_id: int) -> bool: - book_id <type: int>: Unique identifier for the book to be returned Returns <type: bool>: - True if the book is successfully returned - False if the book ID is invalid or the book was not on loan if book_id not in self.books or self.books[book_id][\\"is_available\\"]: return False self.books[book_id][\\"is_available\\"] = True member_id = [k for k, v in self.members.items() if v == book_id] if member_id: del self.members[member_id[0]] return True def view_library(self) -> None: Displays the current list of books with their status (available/loaned). Returns: None for book_id, details in self.books.items(): status = \\"available\\" if details[\\"is_available\\"] else \\"on loan\\" print(f\\"ID: {book_id}, Title: {details[\'title\']}, Author: {details[\'author\']}, Status: {status}\\")"},{"question":"# Evaluate Arithmetic Expressions **Problem Statement**: You are to implement a function that evaluates an arithmetic expression given as a string and returns the result. The expression can contain integers, operators (`+`, `-`, `*`, `/`), and parentheses `()`. The function should correctly handle the operator precedence and parentheses to return the accurate result of the expression. **Function Signature**: ```python def evaluate_expression(expression: str) -> float: pass ``` # Input Description: - **expression**: A string representing a valid arithmetic expression. # Output Description: - Returns a floating-point number representing the result of the evaluated expression. # Constraints: - The input expression will always be a valid expression containing only integers, operators (`+`, `-`, `*`, `/`), and parentheses `()`. - Division by zero will not occur in the provided expression. - The length of the input expression will not exceed 1000 characters. # Examples: ```python assert evaluate_expression(\\"3+5\\") == 8.0 assert evaluate_expression(\\"10 + 2 * 6\\") == 22.0 assert evaluate_expression(\\"100 * 2 + 12\\") == 212.0 assert evaluate_expression(\\"100 * (2 + 12)\\") == 1400.0 assert evaluate_expression(\\"100 * (2 + 12) / 14\\") == 100.0 ``` # Scenario: You are providing functionality for a simple programming language that includes arithmetic expression evaluation. This feature is needed to validate and compute the result of mathematical expressions that users input into scripts. **Implementation Advice**: 1. **Precedence Handling**: Ensure the correct order of operations by implementing an appropriate algorithm (e.g., shunting yard algorithm) or using stack-based parsing. 2. **Parentheses**: Correctly manage nested parentheses in the expression. 3. **Operators and Integers**: Identify and handle different operators and operands efficiently. 4. **Edge Cases**: Consider edge cases such as negative numbers and spacing within the expression, making sure to parse them correctly.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a given arithmetic expression and returns the result as a floating-point number. def compute(ops, values): right = values.pop() left = values.pop() op = ops.pop() if op == \'+\': values.append(left + right) elif op == \'-\': values.append(left - right) elif op == \'*\': values.append(left * right) elif op == \'/\': values.append(left / right) def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def is_digit(ch): return ch.isdigit() or ch == \'.\' ops = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': ops.append(expression[i]) elif is_digit(expression[i]): num = 0 while i < len(expression) and (is_digit(expression[i]) or expression[i] == \'.\'): num = num * 10 + float(expression[i]) if expression[i].isdigit() else num + float(expression[i]) i += 1 values.append(num) i -= 1 elif expression[i] == \')\': while ops and ops[-1] != \'(\': compute(ops, values) ops.pop() else: while ops and precedence(ops[-1]) >= precedence(expression[i]): compute(ops, values) ops.append(expression[i]) i += 1 while ops: compute(ops, values) return values[0]"},{"question":"# Matrix Path Sum Calculation **Scenario**: You are working on a navigation system that helps find the optimal path in a grid-based world. Your task is to compute the maximum sum of numbers collected on a path from the top-left to the bottom-right of a given matrix. **Task**: Implement the `MatrixPath` class with methods to compute the maximum path sum: **Function Signatures**: ```python class MatrixPath: @staticmethod def max_path_sum(matrix: list[list[int]]) -> int: pass ``` **Requirements**: 1. **Maximum Path Sum Function (`max_path_sum`)**: - Takes a 2D list `matrix` as input. - Returns an integer representing the maximum sum collected along any path from the top-left corner to the bottom-right corner of the matrix. - You can only move either right or down at any point in time. - Ensure edge cases like empty matrices or single element matrices are handled gracefully. **Constraints**: - The matrix dimensions will be between 1×1 and 100×100. - Elements of the matrix will be integers ranging between -1,000 and 1,000. **Example**: ```python >>> matrix = [ [5, 3, 2], [1, 9, 1], [4, 2, 8] ] >>> MatrixPath().max_path_sum(matrix) 25 # Path: 5 -> 3 -> 9 -> 2 -> 8 >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> MatrixPath().max_path_sum(matrix) 29 # Path: 1 -> 2 -> 3 -> 6 -> 9 ``` Implement an efficient algorithm to determine the maximum path sum. Test your solution with multiple test cases covering different edge cases like matrices with negative values or large-sized matrices.","solution":"class MatrixPath: @staticmethod def max_path_sum(matrix: list[list[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # DP table initialization with the same size as matrix dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] # Initialize first column of dp table for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Initialize first row of dp table for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[rows-1][cols-1]"},{"question":"# Summing Digits of Alphabetic Equivalent You are given a string containing lowercase alphabetic characters and digits. Your task is to write a function that calculates the sum of the digits obtained by converting each letter in the string to its corresponding position in the alphabet (a=1, b=2, ..., z=26) and then summing these values for each alphabetic character in the string. # Function Signature ```python def sum_alphabetic_digits(s: str) -> int: pass ``` # Input and Output * **Input**: - `s` (type: `str`): The string containing lowercase alphabetic characters and digits. * **Output**: - (type: `int`): The sum of positions of the alphabetic characters. # Constraints * `s` may contain lowercase alphabetic characters (\'a\'-\'z\'), digits (\'0\'-\'9\'), spaces, punctuation marks, and special characters. * The function should sum only the positions of the alphabetic characters and ignore other characters. # Example ```python # Test case 1: s = \\"abc 123\\" # \'a\' + \'b\' + \'c\' = 1 + 2 + 3 = 6 # Expected output: 6 print(sum_alphabetic_digits(s)) # Test case 2: s = \\"hello1world!\\" # \'h\' + \'e\' + \'l\' + \'l\' + \'o\' + \'w\' + \'o\' + \'r\' + \'l\' + \'d\' = 8 + 5 + 12 + 12 + 15 + 23 + 15 + 18 + 12 + 4 = 124 # Expected output: 124 print(sum_alphabetic_digits(s)) # Test case 3: s = \\"a1b2c3\\" # \'a\' + \'b\' + \'c\' = 1 + 2 + 3 = 6 # Expected output: 6 print(sum_alphabetic_digits(s)) ``` # Note - Be careful to handle non-alphabetic characters effectively by ignoring them during the summation. - Consider using ASCII values to determine the alphabetic position, where \'a\' is 97 in ASCII, so subtracting 96 from the ASCII value of any character will yield its position in the alphabet.","solution":"def sum_alphabetic_digits(s: str) -> int: Calculate the sum of positions of the alphabetic characters in the string. Parameters: s (str): The input string containing lowercase alphabetic characters, digits, and other characters. Returns: int: The sum of positions of the alphabetic characters. total = 0 for char in s: if \'a\' <= char <= \'z\': total += ord(char) - ord(\'a\') + 1 return total"},{"question":"# Problem Statement You are tasked with developing a function that finds the longest contiguous subarray where the absolute difference between any two elements is less than or equal to a given integer `k`. This function is a critical feature for a data analysis tool that needs to quickly identify stable periods in a sequence of measurements. Write a function `longest_subarray` that returns the length of the longest subarray meeting the aforementioned criteria. # Function Signature ```python def longest_subarray(nums: List[int], k: int) -> int: ``` # Input * `nums` (List[int]): A list of integers representing the sequence of measurements. * `k` (int): An integer defining the maximum allowed absolute difference between any two elements in the subarray. (0 <= k <= 10^9) # Output * Returns an integer representing the length of the longest contiguous subarray within `nums` where the absolute difference between any two elements is less than or equal to `k`. # Constraints * The function must raise a `ValueError` with the message \\"Invalid input\\" for: * Empty input list `nums` * Non-integer values in the list `nums` # Examples ```python >>> longest_subarray([1, 3, 2, 1, 7], 2) 4 >>> longest_subarray([4, 6, 5, 5, 7, 10], 1) 3 >>> longest_subarray([1, 5, 9, 13], 3) 1 >>> longest_subarray([1, 2, 3, 4], 3) 4 >>> longest_subarray([], 2) Traceback (most recent call last): ... ValueError: Invalid input >>> longest_subarray([1, \'a\', 3], 2) Traceback (most recent call last): ... ValueError: Invalid input ``` # Hints * Consider using a sliding window technique to efficiently find the longest subarray. * Pay attention to edge cases involving very large or very small values, or inputs with only one element.","solution":"from typing import List def longest_subarray(nums: List[int], k: int) -> int: if not nums or any(not isinstance(num, int) for num in nums): raise ValueError(\\"Invalid input\\") left = 0 max_length = 0 max_num = min_num = nums[0] for right in range(len(nums)): max_num = max(max_num, nums[right]) min_num = min(min_num, nums[right]) while max_num - min_num > k: left += 1 max_num = max(nums[left:right + 1]) min_num = min(nums[left:right + 1]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Problem Statement: You are working on a file processing system that reads large files line-by-line and performs a transformation on each line before saving the results to a new file. Extend the provided `process_files` function to handle multiple files simultaneously, implement logging for success and failure messages per line, and ensure resource management to prevent memory leaks. # Function Signature: ```python def process_files(input_files: List[str], output_files: List[str], transform: Callable[[str], str]) -> None: pass ``` # Requirements: 1. **Inputs**: - `input_files`: A list of input filenames to process. (1 ≤ len(input_files) ≤ 50) - `output_files`: A list of corresponding output filenames. (len(output_files) = len(input_files)) - `transform`: A function that takes a string as input and returns a transformed string. 2. **Outputs**: - No return value. The function should handle file writing internally and log success or failure of each line. 3. **Constraints**: - Each input file should match the corresponding output file by index. - Implement robust error handling to log any read/write errors per line. - Ensure that files are correctly closed after processing to prevent resource leaks. 4. **Performance Consideration**: - Aim to process files efficiently by reading and writing line-by-line with proper resource management. - Support concurrent processing of files to reduce overall execution time. # Example: ```python def upper_case_transform(line: str) -> str: return line.upper() input_files = [\\"input1.txt\\", \\"input2.txt\\"] output_files = [\\"output1.txt\\", \\"output2.txt\\"] process_files(input_files, output_files, upper_case_transform) ``` **Note**: - `process_files` should handle logging for each line transformation, indicating success or detailing any issues encountered during processing. - Ensure that the function uses appropriate concurrency mechanisms to handle multiple files without consuming excessive system resources.","solution":"import concurrent.futures import logging from typing import List, Callable import os # Set up logging configuration logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\') def process_file(input_file: str, output_file: str, transform: Callable[[str], str]) -> None: try: with open(input_file, \'r\') as infile, open(output_file, \'w\') as outfile: for line in infile: try: transformed_line = transform(line) outfile.write(transformed_line) logging.info(f\\"Successfully processed line in file: {input_file}\\") except Exception as e: logging.error(f\\"Error transforming line in file: {input_file} - {e}\\") except Exception as e: logging.error(f\\"Error processing file: {input_file} - {e}\\") def process_files(input_files: List[str], output_files: List[str], transform: Callable[[str], str]) -> None: if len(input_files) != len(output_files): raise ValueError(\\"The number of input files must match the number of output files.\\") with concurrent.futures.ThreadPoolExecutor() as executor: futures = [] for input_file, output_file in zip(input_files, output_files): futures.append(executor.submit(process_file, input_file, output_file, transform)) for future in concurrent.futures.as_completed(futures): future.result() # we don\'t need the result, but it will raise any exceptions here # Example transform function def upper_case_transform(line: str) -> str: return line.upper()"},{"question":"# Problem Statement: You are tasked with implementing a function that finds the k largest elements in a list and returns them in sorted order. The function should efficiently handle large datasets by utilizing appropriate data structures as needed. # Function Signature: ```python def find_k_largest_elements(arr: List[int], k: int) -> List[int]: pass ``` # Input: - `arr`: A list of integers. - `k`: An integer representing the number of largest elements to return. # Output: - Returns a list of integers containing the k largest elements from the input list, sorted in ascending order. # Constraints: - 1 <= len(arr) <= 100000 - 1 <= k <= len(arr) - Each element in the list can be anywhere in the range of -10^6 to 10^6. # Performance Requirements: - The function should be efficient and optimized to handle the maximum input size within a reasonable time. # Example: ```python arr = [3, 1, 5, 12, 2, 11, 7] k = 3 result = find_k_largest_elements(arr, k) # Expected output: # [7, 11, 12] arr = [1, 23, 12, 9, 30, 2, 50] k = 4 result = find_k_largest_elements(arr, k) # Expected output: # [23, 30, 50] ``` # Notes: - Your implementation should consider the trade-offs between time complexity and space complexity. - Utilizing heap-based data structures could help achieve optimal performance. - Ensure your function handles edge cases, such as when `k` equals the length of the list, gracefully.","solution":"from typing import List import heapq def find_k_largest_elements(arr: List[int], k: int) -> List[int]: Finds the k largest elements in a list and returns them in sorted order. Parameters: arr (List[int]): The input list of integers. k (int): The number of largest elements to return. Returns: List[int]: A list containing the k largest elements sorted in ascending order. if k == 0: return [] # Use a min-heap to efficiently find the k largest elements min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) return sorted(min_heap)"},{"question":"Library Book Availability Checker You are working for an online library system that keeps track of book availability. In this system, books can be in different states such as \\"available\\", \\"checked out\\", \\"reserved\\", etc. The system allows users to check out books, return books, or reserve books if the book is currently checked out. **Your task** is to implement a class `Library` that manages the states of books and supports the following operations: 1. **Check out a book**: A book can only be checked out if it is \\"available\\". 2. **Return a book**: A book can be returned if it is currently \\"checked out\\". 3. **Reserve a book**: A book can only be reserved if it is currently \\"checked out\\" and will transition to \\"reserved\\" status when returned. 4. **Check book status**: Check the current status of a book. # Class Definition: ```python class Library: def __init__(self): Initializes the library with an empty set of books. Uses a dictionary to track the status of each book by its title. self.book_status = {} def add_book(self, title: str): Adds a new book to the library and sets its status to \\"available\\". :param title: The title of the book. self.book_status[title] = \\"available\\" def checkout_book(self, title: str) -> bool: Checks out a book if it is available. :param title: The title of the book. :return: True if the book was successfully checked out, False otherwise. pass def return_book(self, title: str) -> bool: Returns a book if it is currently checked out. :param title: The title of the book. :return: True if the book was successfully returned, False otherwise. pass def reserve_book(self, title: str) -> bool: Reserves a book if it is currently checked out. :param title: The title of the book. :return: True if the book was successfully reserved, False otherwise. pass def check_status(self, title: str) -> str: Checks the current status of a book. :param title: The title of the book. :return: The current status of the book, or \\"not found\\" if the book is not in the library. return self.book_status.get(title, \\"not found\\") ``` # Constraints: - Books are uniquely identified by their title. - Operations are case-sensitive based on book titles. - Assume the library is initially empty. - The `add_book` method will only be used to add new books to the library. # Example Usage: ```python library = Library() library.add_book(\\"To Kill a Mockingbird\\") # Check out a book print(library.checkout_book(\\"To Kill a Mockingbird\\")) # True print(library.check_status(\\"To Kill a Mockingbird\\")) # \\"checked out\\" # Return a book print(library.return_book(\\"To Kill a Mockingbird\\")) # True print(library.check_status(\\"To Kill a Mockingbird\\")) # \\"available\\" # Reserve a book library.checkout_book(\\"To Kill a Mockingbird\\") print(library.reserve_book(\\"To Kill a Mockingbird\\")) # True print(library.return_book(\\"To Kill a Mockingbird\\")) # True print(library.check_status(\\"To Kill a Mockingbird\\")) # \\"reserved\\" ```","solution":"class Library: def __init__(self): Initializes the library with an empty set of books. Uses a dictionary to track the status of each book by its title. self.book_status = {} def add_book(self, title: str): Adds a new book to the library and sets its status to \\"available\\". :param title: The title of the book. self.book_status[title] = \\"available\\" def checkout_book(self, title: str) -> bool: Checks out a book if it is available. :param title: The title of the book. :return: True if the book was successfully checked out, False otherwise. if title in self.book_status and self.book_status[title] == \\"available\\": self.book_status[title] = \\"checked out\\" return True return False def return_book(self, title: str) -> bool: Returns a book if it is currently checked out. :param title: The title of the book. :return: True if the book was successfully returned, False otherwise. if title in self.book_status and self.book_status[title] == \\"checked out\\": if \\"reserved\\" not in self.book_status: self.book_status[title] = \\"available\\" else: self.book_status[title] = \\"reserved\\" self.book_status.pop(\\"reserved\\") return True return False def reserve_book(self, title: str) -> bool: Reserves a book if it is currently checked out. :param title: The title of the book. :return: True if the book was successfully reserved, False otherwise. if title in self.book_status and self.book_status[title] == \\"checked out\\": self.book_status[\\"reserved\\"] = title return True return False def check_status(self, title: str) -> str: Checks the current status of a book. :param title: The title of the book. :return: The current status of the book, or \\"not found\\" if the book is not in the library. return self.book_status.get(title, \\"not found\\")"},{"question":"You are tasked with writing a Python function that simulates a 3-bit binary counter. A 3-bit binary counter has three output bits and counts from 0 to 7 in binary. Your function should initialize a counter to 0 and then increment it each time the function is called, wrapping around to 0 after reaching 7. Additionally, you should be able to reset the counter to 0 with a reset flag. # Function Signature ```python def binary_counter(reset: bool = False) -> str: Simulate a 3-bit binary counter. :param reset: If True, reset the counter to 0. :return: A 3-bit binary string representing the current counter value. Examples: >>> binary_counter() \'000\' >>> binary_counter() \'001\' >>> binary_counter() \'010\' >>> binary_counter(reset=True) \'000\' >>> binary_counter() \'001\' ``` # Constraints 1. The counter starts at 0 by default. 2. Each call to the function without reset increments the counter by 1, wrapping around to 0 after reaching 7. 3. If the reset flag is set to True, the counter resets to 0 regardless of its current value. 4. The function returns a string representing the 3-bit binary value of the counter. # Task Implement the `binary_counter` function to simulate a 3-bit binary counter that correctly increments and can be reset with proper handling of the reset flag. Ensure the counter output is always a 3-bit binary string. # Important Note Use a global variable for the counter within the function to keep track of its state between calls. The string format of the counter should always ensure it is 3 bits long, even when the count is less than three digits (e.g., \'0\' should be \'000\').","solution":"counter = 0 def binary_counter(reset: bool = False) -> str: Simulate a 3-bit binary counter. :param reset: If True, reset the counter to 0. :return: A 3-bit binary string representing the current counter value. global counter if reset: counter = 0 else: counter = (counter + 1) % 8 return f\'{counter:03b}\'"},{"question":"# Coding Assessment Question Problem Statement **Context**: Sophia is developing a script to clean up and standardize strings collected from different sources. Each string contains alphanumeric characters and a variety of special characters. She wants to ensure that the strings follow a consistent, readable format by: 1. Removing all special characters except spaces. 2. Converting all letters to lowercase. 3. Ensuring there are no extra spaces at the beginning or end of the string, and no more than one space between words. **Task**: Implement a function `clean_string(s: str) -> str` that takes a string `s` as input and processes it according to Sophia\'s specifications. **Function Signature**: ```python def clean_string(s: str) -> str: ``` **Parameters**: - `s` (str): The string to be cleaned (0 <= len(s) <= 1000). **Returns**: - (str): The cleaned and standardized string. **Examples**: ```python assert clean_string(\\" HeLLo, WORld!! \\") == \\"hello world\\" assert clean_string(\\"Python@# is -+- awesome...\\") == \\"python is awesome\\" assert clean_string(\\"123 ABC...def^^^ ghi!!@@\\") == \\"123 abcdef ghi\\" assert clean_string(\\"\\") == \\"\\" assert clean_string(\\"!!!\\") == \\"\\" ``` **Notes**: * Be sure to handle strings that may initially be empty or consist solely of special characters. * Elements like numbers should remain unchanged during the cleanup process (except for special character removal). * Strive to implement the function with a balance of clarity and efficiency. **Constraints**: * `0 <= len(s) <= 1000` **Scenario**: Sophia is curating a dataset for her company\'s text-processing application and needs to be confident in the consistency of the incoming data. Your task is to create a function that meets her cleanup requirements.","solution":"import re def clean_string(s: str) -> str: Cleans the input string as per the conditions provided: 1. Removes all special characters except spaces. 2. Converts all letters to lowercase. 3. Ensures no extra spaces at the beginning or end, and no more than one space between words. Parameters: s (str): The string to be cleaned (0 <= len(s) <= 1000). Returns: str: The cleaned and standardized string. # Use regular expression to remove all special characters except spaces cleaned = re.sub(r\'[^a-zA-Z0-9s]\', \'\', s) # Remove extra spaces, convert letters to lowercase, and strip leading/trailing spaces cleaned = re.sub(r\'s+\', \' \', cleaned).strip().lower() return cleaned"},{"question":"Question: Implement a Majority Voting Circuit # Scenario In digital circuits, a majority voting logic gate outputs true (or 1) if the majority of its inputs are true (or 1). This type of logic can help improve the reliability of decision-making processes in fault-tolerant systems by requiring a consensus among inputs. # Task Write a function `majority_vote` that accepts three binary inputs and returns the majority value according to the given truth table: ``` --------------------------------- | Input 1 | Input 2 | Input 3 | Output | --------------------------------- | 0 | 0 | 0 | 0 | | 0 | 0 | 1 | 0 | | 0 | 1 | 0 | 0 | | 0 | 1 | 1 | 1 | | 1 | 0 | 0 | 0 | | 1 | 0 | 1 | 1 | | 1 | 1 | 0 | 1 | | 1 | 1 | 1 | 1 | --------------------------------- ``` # Function Signature ```python def majority_vote(input_1: int, input_2: int, input_3: int) -> int: ``` # Input * `input_1` (int): A binary integer (0 or 1). * `input_2` (int): A binary integer (0 or 1). * `input_3` (int): A binary integer (0 or 1). # Output * Returns `1` if the majority of the inputs are `1`, otherwise returns `0`. # Constraints * All inputs (`input_1`, `input_2`, `input_3`) are guaranteed to be 0 or 1. # Example ```python print(majority_vote(0, 0, 0)) # Output: 0 print(majority_vote(0, 0, 1)) # Output: 0 print(majority_vote(0, 1, 1)) # Output: 1 print(majority_vote(1, 1, 0)) # Output: 1 print(majority_vote(1, 1, 1)) # Output: 1 ``` # Notes * Ensure to consider all edge cases and provide a solution that strictly adheres to the provided truth table. * Your function should work efficiently even though the constraints are simple.","solution":"def majority_vote(input_1: int, input_2: int, input_3: int) -> int: Returns 1 if the majority of the three inputs are 1, otherwise returns 0. :param input_1: A binary integer (0 or 1). :param input_2: A binary integer (0 or 1). :param input_3: A binary integer (0 or 1). :return: Majority value (0 or 1). return 1 if (input_1 + input_2 + input_3) > 1 else 0"},{"question":"# Stock Price Prediction Using Simple Moving Average As a programmer, you are tasked with predicting stock prices based on historical data using a simple moving average (SMA). # Task Write a function `predict_stock_prices` that takes two parameters: 1. `prices` (a list of integers): The list of historical stock prices. 2. `window_size` (an integer): The size of the window over which to calculate the moving average. The function should return a list of floats representing the predicted stock prices using the SMA. The first `window_size-1` values should be `None` as they don\'t have enough data to compute the SMA. Constraints * 1 ≤ len(prices) ≤ 10^5 * 1 ≤ prices[i] ≤ 10^4, where `i` is the index in the prices list. * 1 ≤ window_size ≤ len(prices) Function Signature ```python def predict_stock_prices(prices: list[int], window_size: int) -> list[float]: ``` # Example ```python assert predict_stock_prices([1, 2, 3, 4, 5], 3) == [None, None, 2.0, 3.0, 4.0] assert predict_stock_prices([10, 20, 30, 40, 50], 2) == [None, 15.0, 25.0, 35.0, 45.0] assert predict_stock_prices([5, 3, 8, 10, 2], 4) == [None, None, None, 6.5, 5.75] ``` # Performance Requirements * Ensure the function executes in O(N) time complexity, where N is the length of the `prices` list. # Notes * Return `None` for the positions where there is not enough data to compute the moving average. * Consider edge cases such as very small window sizes relative to the length of prices, and ensure your function handles both small and large inputs gracefully.","solution":"def predict_stock_prices(prices: list[int], window_size: int) -> list[float]: Predicts stock prices using simple moving average (SMA). Parameters: prices (list): A list of historical stock prices. window_size (int): The size of the window over which to calculate the moving average. Returns: list: A list of predicted stock prices using the SMA. The first `window_size-1` values are `None`. n = len(prices) result = [None] * (window_size - 1) current_sum = sum(prices[:window_size]) result.append(current_sum / window_size) for i in range(window_size, n): current_sum += prices[i] - prices[i - window_size] result.append(current_sum / window_size) return result"},{"question":"# Linked List Operations You are required to implement a class that represents a singly linked list with several critical operations including insertion, deletion, search, reversal, and detection of cycles. Specifically, you will be designing the methods to handle these operations efficiently, and ensure the following constraints are met: 1. **Node Insertions** - Insert the given values at the end or at a specified position in the list. 2. **Element Search** - Implement an efficient search to determine if an element exists in the list. 3. **Node Deletion** - Handle the deletion of nodes by value. 4. **Reverse the Linked List** - Reverse the entire linked list. 5. **Detect Cycle** - Determine if there is a cycle in the linked list. Implementation Details: 1. Create a `Node` class to represent each node in the linked list. 2. Implement a `LinkedList` class that should support: - `insert(value: int, position: Optional[int] = None) -> None`: Insert a value at the end of the list or at a specified position. - `search(value: int) -> Optional[Node]`: Search for a value in the linked list. - `remove(value: int) -> None`: Remove a value from the linked list. - `reverse() -> None`: Reverse the entire linked list. - `has_cycle() -> bool`: Return True if there\'s a cycle in the list, otherwise False. - `is_empty() -> bool`: Check if the list is empty. - `display() -> List[int]`: Return the values of the nodes in the linked list as a list. Example Usage: ```python >>> ll = LinkedList() >>> ll.insert(3) >>> ll.insert(1) >>> ll.insert(2, 1) >>> assert ll.display() == [3, 2, 1] >>> assert ll.search(2) is not None >>> ll.remove(2) >>> assert ll.search(2) is None >>> assert not ll.is_empty() >>> ll.reverse() >>> assert ll.display() == [1, 3] >>> assert not ll.has_cycle() ``` Submit your implementation with the following function and class signatures: ```python from typing import Optional, List, Any class Node: def __init__(self, value: int, next: \'Optional[Node]\' = None) -> None: self.value: int = value self.next: Optional[Node] = next class LinkedList: def __init__(self) -> None: self.head: Optional[Node] = None def insert(self, value: int, position: Optional[int] = None) -> None: pass def search(self, value: int) -> Optional[Node]: pass def remove(self, value: int) -> None: pass def reverse(self) -> None: pass def has_cycle(self) -> bool: pass def is_empty(self) -> bool: pass def display(self) -> List[int]: pass ```","solution":"from typing import Optional, List class Node: def __init__(self, value: int, next: \'Optional[Node]\' = None) -> None: self.value: int = value self.next: Optional[Node] = next class LinkedList: def __init__(self) -> None: self.head: Optional[Node] = None def insert(self, value: int, position: Optional[int] = None) -> None: new_node = Node(value) if self.head is None or position == 0: new_node.next = self.head self.head = new_node return current = self.head previous = None current_position = 0 while current and (position is None or current_position < position): previous = current current = current.next current_position += 1 new_node.next = current if previous: previous.next = new_node def search(self, value: int) -> Optional[Node]: current = self.head while current is not None: if current.value == value: return current current = current.next return None def remove(self, value: int) -> None: if self.head is None: return if self.head.value == value: self.head = self.head.next return current = self.head previous = None while current and current.value != value: previous = current current = current.next if current is not None: previous.next = current.next def reverse(self) -> None: prev_node = None current_node = self.head while current_node is not None: next_node = current_node.next current_node.next = prev_node prev_node = current_node current_node = next_node self.head = prev_node def has_cycle(self) -> bool: slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def is_empty(self) -> bool: return self.head is None def display(self) -> List[int]: nodes = [] current = self.head while current is not None: nodes.append(current.value) current = current.next return nodes"},{"question":"# Question: Create a Custom Map Function Context: You are working on a project that requires applying a certain operation to every element of a list. Instead of using a typical `map` function, you decide to create a custom mapping function that can handle various types of operations, including those with multiple arguments. Task: Implement a function `custom_map` that: 1. Takes a function `func` and a variable number of iterables as arguments (at least one iterable is always provided). 2. Applies the provided function `func` to the elements of the iterables in a mapped manner, similar to Python\'s built-in `map` function. 3. Returns a list of results after applying the function. Input: 1. A function `func` that takes one or more arguments. 2. One or more iterables (e.g., lists, tuples) of the same length. Output: A list containing the results of applying `func` to the corresponding elements of the provided iterables. Constraints: - The iterables provided will always be of the same length. - The number of elements in each iterable will not exceed `1000`. - The `func` will always be a valid function capable of processing the provided elements. Example: ```python from typing import Any, Callable def custom_map(func: Callable[..., Any], *iterables: list) -> list: # Your implementation # Example usage: def add(a, b): return a + b def subtract(a, b): return a - b result1 = custom_map(add, [1, 2, 3], [10, 20, 30]) result2 = custom_map(subtract, [10, 20, 30], [1, 2, 3]) assert result1 == [11, 22, 33] assert result2 == [9, 18, 27] ``` Performance Requirement: Ensure that your solution handles the maximum number of elements efficiently.","solution":"from typing import Any, Callable, List def custom_map(func: Callable[..., Any], *iterables: List) -> List: Applies a function to corresponding elements of the given iterables. return [func(*args) for args in zip(*iterables)]"},{"question":"# Question: Implement a Job Scheduling Algorithm with Maximum Profit Background: In a job scheduling problem, each job has a deadline and an associated profit. The objective is to select jobs that maximize the total profit if they are completed within their respective deadlines. Each job takes unit time to complete, and only one job can be executed at any given time. Task: Implement an algorithm to select a subset of jobs to maximize the total profit based on their deadlines. Function Signature: ```python def max_profit_job_scheduling(jobs: List[Tuple[int, int]], n: int) -> int: This function computes the maximum profit achievable by scheduling jobs optimally. Parameters: * jobs (List[Tuple[int, int]]): List of tuples where each tuple contains two integers, the first integer being the profit and the second the deadline. * n (int): Total number of jobs. Returns: * int: The maximum profit that can be achieved. ``` Input: * `jobs`: List of tuples, where each tuple includes two integers - profit and deadline of a job. * `n`: Integer representing the total number of jobs. Output: * Returns an integer representing the maximum profit achievable by scheduling the jobs within given deadlines. Constraints: * `1 ≤ len(jobs) = n ≤ 10^5` * `1 ≤ profit, deadline ≤ 10^5` * Deadlines are positive integers. Example: ```python jobs = [(20, 2), (15, 2), (10, 1), (5, 3), (1, 3)] n = 5 max_profit = max_profit_job_scheduling(jobs, n) print(max_profit) # Output: 40 ``` Notes: * Ensure to account for deadlines, meaning no job should be scheduled after its deadline. * The scheduling should be done in a way that maximizes the profit. * If there are multiple solutions with the same profit, any one will be accepted. * Handle edge cases like high number of jobs and large deadlines efficiently.","solution":"from typing import List, Tuple def max_profit_job_scheduling(jobs: List[Tuple[int, int]], n: int) -> int: This function computes the maximum profit achievable by scheduling jobs optimally. Parameters: * jobs (List[Tuple[int, int]]): List of tuples where each tuple contains two integers, the first integer being the profit and the second the deadline. * n (int): Total number of jobs. Returns: * int: The maximum profit that can be achieved. # Step 1: Sort the jobs based on the profit in descending order jobs.sort(key=lambda x: x[0], reverse=True) # Step 2: Find the maximum deadline to size the result array max_deadline = max(job[1] for job in jobs) # Step 3: Initialize time slots time_slots = [False] * (max_deadline + 1) # Step 4: Initialize total profit total_profit = 0 # Step 5: Iterate over each job in descending order of profit for profit, deadline in jobs: # Find a time slot from `deadline` to `1` for t in range(deadline, 0, -1): if not time_slots[t]: time_slots[t] = True total_profit += profit break return total_profit"},{"question":"# Circle and Point Position Problem You are given a circle defined by its center and radius, and a point\'s coordinates. Determine whether the point lies inside, on the circumference, or outside the circle. Implement the function `point_circle_position` according to the provided specifications. Function Signature ```python def point_circle_position(circle_center: tuple, radius: float, point: tuple) -> str: ``` Input - `circle_center` (tuple): A tuple of two floats representing the x and y coordinates of the circle\'s center. - `radius` (float): The radius of the circle. (0 ≤ radius). - `point` (tuple): A tuple of two floats representing the x and y coordinates of the point in question. Output - Returns a string that indicates the position of the point relative to the circle. The output should be one of the following: - `\\"inside\\"`: If the point lies inside the circle. - `\\"on\\"`: If the point lies on the circumference of the circle. - `\\"outside\\"`: If the point lies outside the circle. Constraints - If `radius` is negative, raise a `ValueError` with the message \\"The radius cannot be negative\\". Examples ```python # Example 1 assert point_circle_position((0, 0), 5, (3, 4)) == \\"on\\" # Example 2 assert point_circle_position((1, 1), 2, (1, 3)) == \\"inside\\" # Example 3 assert point_circle_position((-1, -1), 4, (3, 3)) == \\"outside\\" # Example 4 assert point_circle_position((0, 0), 3, (0, 0)) == \\"inside\\" # Example 5 try: point_circle_position((0, 0), -5, (1, 1)) except ValueError as e: assert str(e) == \\"The radius cannot be negative\\" ``` Detailed Explanation 1. **Validation**: - Check whether `radius` is non-negative. 2. **Calculation**: - Calculate the distance between the point and the circle\'s center using the distance formula: (text{distance} = sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}). - Compare the calculated distance to the radius of the circle. 3. **Return**: - If the distance is less than the radius, return `\\"inside\\"`. - If the distance is equal to the radius, return `\\"on\\"`. - If the distance is greater than the radius, return `\\"outside\\"`. Provide a robust implementation of the function `point_circle_position` following these guidelines and ensuring that all edge cases are handled correctly.","solution":"import math def point_circle_position(circle_center: tuple, radius: float, point: tuple) -> str: Determines if a point is inside, on, or outside a circle. Parameters: circle_center (tuple): A tuple (x, y) representing the center of the circle. radius (float): The radius of the circle. point (tuple): A tuple (x, y) representing the point to check. Returns: str: \\"inside\\", \\"on\\", or \\"outside\\" based on the position of the point relative to the circle. Raises: ValueError: If the radius is negative. if radius < 0: raise ValueError(\\"The radius cannot be negative\\") # Calculate the distance between the circle\'s center and the point distance = math.sqrt((circle_center[0] - point[0]) ** 2 + (circle_center[1] - point[1]) ** 2) if distance < radius: return \\"inside\\" elif distance == radius: return \\"on\\" else: return \\"outside\\""},{"question":"# Problem Statement You are given the task of developing a function to calculate the median of a continuously growing list of integers. The function should be capable of adding new numbers to the list and computing the median efficiently after each insertion. Function Signature ```python class RunningMedian: def __init__(self): pass def add_number(self, num: int) -> None: pass def get_median(self) -> float: pass ``` Input - `num` (int): The integer to be added to the list. Output - The `get_median` method returns the median of the numbers in the list as a float. Constraints - Optimize the add_number and get_median methods to handle up to 105 insertions efficiently. - The list can contain both positive and negative integers. - Ensure the computational time per insertion and retrieval of the median is minimized. Requirements - Use a data structure that supports efficient insertion and median retrieval. Consider using two heaps for managing the lower and upper halves of the list. - Handle the scenarios where the list has an even or odd number of elements correctly. - Ensure the solution can handle large sequences of operations in a performant manner. # Example ```python median_tracker = RunningMedian() median_tracker.add_number(1) print(median_tracker.get_median()) # Output: 1.0 median_tracker.add_number(5) print(median_tracker.get_median()) # Output: 3.0 median_tracker.add_number(3) print(median_tracker.get_median()) # Output: 3.0 median_tracker.add_number(4) print(median_tracker.get_median()) # Output: 3.5 ``` # Testing - Test with sequences containing positive and negative numbers. - Ensure the functionality works for both small and large numbers of insertions. - Verify the median is computed accurately after each insertion.","solution":"import heapq class RunningMedian: def __init__(self): self.lower_half = [] # Max heap (invert values to use min heap) self.upper_half = [] # Min heap def add_number(self, num: int) -> None: # Add to max heap (lower half) heapq.heappush(self.lower_half, -num) # Balance heaps: make sure every element in lower_half is <= elements in upper_half if self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0]): val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) # Balance sizes: the size of lower_half can only exceed upper_half by at most 1 if len(self.lower_half) > len(self.upper_half) + 1: val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) if len(self.upper_half) > len(self.lower_half): val = heapq.heappop(self.upper_half) heapq.heappush(self.lower_half, -val) def get_median(self) -> float: if len(self.lower_half) == len(self.upper_half): return (-self.lower_half[0] + self.upper_half[0]) / 2.0 else: return float(-self.lower_half[0])"},{"question":"# Neural Network-based Handwriting Recognition Background A neural network can be used to recognize handwritten digits by training on a dataset of labeled images. The network then predicts the label of new, unseen images by processing the pixel data and classifying it into one of the predefined digit categories (0-9). In this task, you will implement and demonstrate a simple feedforward neural network (FFNN) for handwriting recognition using the sigmoid activation function. Task You need to implement two methods in a class `SimpleNeuralNetwork`: 1. `feedforward`: This method computes the output of the network for a given input by applying the weights and biases and passing through the activation function. 2. `train`: This method updates the weights and biases based on the difference between the predicted and actual labels using gradient descent. You also need to create a main function to demonstrate the training and prediction process. Implementation 1. **feedforward**: - **Input**: A 2D list `weights`, a list `biases`, and a list `input_vector` representing the input. - **Output**: A list of floats representing the output probabilities for each digit. - **Example**: ```python nn = SimpleNeuralNetwork() print(nn.feedforward([[0.5, -0.2], [0.3, 0.8]], [0.1, -0.1], [1, 0])) # Output: [0.475, 0.549] ``` 2. **train**: - **Input**: A 2D list `weights`, a list `biases`, a list `training_samples` (each sample is a tuple of input and corresponding label), an integer `epochs`, and a float `learning_rate`. - **Output**: Updated lists `weights` and `biases`. - **Example**: ```python nn = SimpleNeuralNetwork() weights, biases = nn.train([[0.5, -0.2], [0.3, 0.8]], [0.1, -0.1], [( [1, 0], [1, 0] ), ( [0, 1], [0, 1] )], 3, 0.01) print(weights, biases) # Output should show updated weights and biases ``` 3. **main**: - Demonstrate training with provided weights, biases, and samples. - Classify a test sample and output the predicted digit probabilities. Constraints - Use the sigmoid activation function. - The network has only one hidden layer. - Assume there are always two neurons in the hidden layer. - Consider up to `1000` samples each of dimension `2`. Performance - Ensure the function efficiently handles the constraints. - Optimize the gradient descent calculations wherever possible. Example Implement the following: ```python import math class SimpleNeuralNetwork: def sigmoid(self, x): return 1 / (1 + math.exp(-x)) def feedforward(self, weights, biases, input_vector): hidden_layer_input = [sum(i*w + b for i, w, b in zip(input_vector, layer, biases)) for layer in weights] hidden_layer_output = [self.sigmoid(x) for x in hidden_layer_input] return hidden_layer_output def train(self, weights, biases, training_samples, epochs, learning_rate): for epoch in range(epochs): for input_vector, true_output in training_samples: hidden_layer_output = self.feedforward(weights, biases, input_vector) output_error = [true - pred for true, pred in zip(true_output, hidden_layer_output)] # Backpropagation and weight update simplifying for the example for i in range(len(weights)): for j in range(len(weights[0])): weights[i][j] += learning_rate * output_error[i] * input_vector[j] biases[i] += learning_rate * output_error[i] return weights, biases def main(): # Training Examples (input vector and corresponding labels) training_samples = [([1, 0], [1, 0]), ([0, 1], [0, 1]), ([1, 1], [1, 1]), ([0, 0], [0, 0])] # Weight and bias initialization weights = [[0.5, -0.2], [0.3, 0.8]] biases = [0.1, -0.1] nn = SimpleNeuralNetwork() epochs = 3 learning_rate = 0.01 weights, biases = nn.train(weights, biases, training_samples, epochs, learning_rate) test_sample = [1, 0] output = nn.feedforward(weights, biases, test_sample) print(f\\"Output probabilities for the test sample: {output}\\") print(f\\"Weights that have been trained: {weights}\\") print(f\\"Biases that have been trained: {biases}\\") if __name__ == \\"__main__\\": main() ```","solution":"import math class SimpleNeuralNetwork: def sigmoid(self, x): return 1 / (1 + math.exp(-x)) def sigmoid_derivative(self, x): return x * (1 - x) def feedforward(self, weights, biases, input_vector): hidden_layer_input = [sum(i*w + b for i, w, b in zip(input_vector, layer, biases)) for layer in weights] hidden_layer_output = [self.sigmoid(x) for x in hidden_layer_input] return hidden_layer_output def train(self, weights, biases, training_samples, epochs, learning_rate): for epoch in range(epochs): for input_vector, true_output in training_samples: hidden_layer_output = self.feedforward(weights, biases, input_vector) output_error = [true - pred for true, pred in zip(true_output, hidden_layer_output)] output_delta = [error * self.sigmoid_derivative(out) for error, out in zip(output_error, hidden_layer_output)] for i in range(len(weights)): for j in range(len(weights[0])): weights[i][j] += learning_rate * output_delta[i] * input_vector[j] biases[i] += learning_rate * output_delta[i] return weights, biases def main(): training_samples = [([1, 0], [1, 0]), ([0, 1], [0, 1]), ([1, 1], [1, 1]), ([0, 0], [0, 0])] weights = [[0.5, -0.2], [0.3, 0.8]] biases = [0.1, -0.1] nn = SimpleNeuralNetwork() epochs = 3 learning_rate = 0.01 weights, biases = nn.train(weights, biases, training_samples, epochs, learning_rate) test_sample = [1, 0] output = nn.feedforward(weights, biases, test_sample) print(f\\"Output probabilities for the test sample: {output}\\") print(f\\"Weights that have been trained: {weights}\\") print(f\\"Biases that have been trained: {biases}\\") if __name__ == \\"__main__\\": main()"},{"question":"# Question: Implement a Function to Count Set Bits within a Range Context In computer science, bitwise operations are often used to directly manipulate individual bits of binary numbers, which is useful in a variety of low-level tasks. Counting the number of \'1\' bits in the binary representation of numbers is a frequent operation in scenarios like error detection, compression algorithms, and cryptography. Task Write a function `count_set_bits_in_range(start: int, end: int) -> int` that takes two non-negative integers representing a range (inclusive). The function should count the total number of set bits (bits that are \'1\') in the binary representations of all the integers within the range [start, end]. Function Signature ```python def count_set_bits_in_range(start: int, end: int) -> int: ``` Inputs - `start`: A non-negative integer representing the start of the range. - `end`: A non-negative integer representing the end of the range. Outputs - An integer representing the total number of set bits in the binary representations of all integers from `start` to `end` (inclusive). Constraints 1. Both `start` and `end` are non-negative integers. 2. The function should validate the input values and raise appropriate exceptions: * `ValueError` if `start` is greater than `end`. * `ValueError` if any input is negative. * `TypeError` if any input is not an integer. Performance Requirements - The function should efficiently handle ranges where `end` can be up to 10,000. Examples ```python >>> count_set_bits_in_range(5, 7) 9 # Binary: 5 -> 101, 6 -> 110, 7 -> 111, Total set bits = 2 + 2 + 3 = 7 >>> count_set_bits_in_range(0, 8) 13 # Binary: 0 -> 0, 1 -> 1, 2 -> 10, 3 -> 11, 4 -> 100, 5 -> 101, 6 -> 110, 7 -> 111, 8 -> 1000 # Total set bits = 0 + 1 + 1 + 2 + 1 + 2 + 2 + 3 + 1 = 13 >>> count_set_bits_in_range(10, 15) 17 # Binary: 10 -> 1010, 11 -> 1011, 12 -> 1100, 13 -> 1101, 14 -> 1110, 15 -> 1111 # Total set bits = 2 + 3 + 2 + 3 + 3 + 4 = 17 >>> count_set_bits_in_range(0, 0) 0 # Binary: 0 -> 0, Total set bits = 0 >>> count_set_bits_in_range(2, 2) 1 # Binary: 2 -> 10, Total set bits = 1 ``` Error Handling Examples ```python >>> count_set_bits_in_range(7, 5) Traceback (most recent call last): ... ValueError: start should be less than or equal to end >>> count_set_bits_in_range(-1, 5) Traceback (most recent call last): ... ValueError: start and end must be non-negative integers >>> count_set_bits_in_range(0, 1.5) Traceback (most recent call last): ... TypeError: \'float\' object cannot be interpreted as an integer >>> count_set_bits_in_range(\\"0\\", \\"5\\") Traceback (most recent call last): ... TypeError: \'<\' not supported between instances of \'str\' and \'int\' ```","solution":"def count_set_bits_in_range(start: int, end: int) -> int: Counts the total number of set bits in the binary representations of all integers within the range [start, end] inclusive. # Validate input types if not isinstance(start, int) or not isinstance(end, int): raise TypeError(\\"Both start and end must be integers\\") # Validate input values if start < 0 or end < 0: raise ValueError(\\"start and end must be non-negative integers\\") if start > end: raise ValueError(\\"start should be less than or equal to end\\") # Count set bits in the given range total_set_bits = 0 for number in range(start, end + 1): total_set_bits += bin(number).count(\'1\') return total_set_bits"},{"question":"# Image Resizer You are tasked with developing a script that resizes a batch of images to a specified width while maintaining their aspect ratios. The script should be efficient and capable of handling large images without excessive memory usage. Requirements: 1. **Function `resize_images_in_directory`**: - Takes a directory path and a target width as input. - Resizes all the images in the directory to the target width while preserving their aspect ratio. - Saves the resized images in a new directory named `resized_images` within the given directory. 2. **Constraints**: - You must use the `PIL` (Pillow) library for image processing. - Handle common image formats such as JPEG, PNG, and BMP. - Handle potential errors gracefully, such as file access issues, unsupported image formats, etc. Input & Output Formats: * The `resize_images_in_directory` function should return the number of images successfully resized and saved. * Print any errors encountered during the process. Example: Given a directory path `\\"/path/to/images\\"` and a target width of `800` pixels, the script should: 1. Resize all images in the directory to the specified width. 2. Handle any potential errors gracefully. 3. Save the resized images in a new directory named `resized_images`. ```python from PIL import Image import os def resize_images_in_directory(directory_path: str, target_width: int) -> int: if not os.path.isdir(directory_path): print(\\"Invalid directory path\\") return 0 resized_images_dir = os.path.join(directory_path, \'resized_images\') if not os.path.exists(resized_images_dir): os.makedirs(resized_images_dir) count = 0 for filename in os.listdir(directory_path): file_path = os.path.join(directory_path, filename) if os.path.isfile(file_path): try: with Image.open(file_path) as img: aspect_ratio = img.height / img.width target_height = int(target_width * aspect_ratio) resized_img = img.resize((target_width, target_height), Image.ANTIALIAS) resized_img.save(os.path.join(resized_images_dir, filename)) count += 1 except Exception as e: print(f\\"Error processing file {filename}: {e}\\") return count if __name__ == \\"__main__\\": directory_path = \\"/path/to/your/images\\" target_width = 800 resized_count = resize_images_in_directory(directory_path, target_width) print(f\\"Resized {resized_count} images\\") ```","solution":"from PIL import Image import os def resize_images_in_directory(directory_path: str, target_width: int) -> int: if not os.path.isdir(directory_path): print(\\"Invalid directory path\\") return 0 resized_images_dir = os.path.join(directory_path, \'resized_images\') if not os.path.exists(resized_images_dir): os.makedirs(resized_images_dir) count = 0 for filename in os.listdir(directory_path): file_path = os.path.join(directory_path, filename) if os.path.isfile(file_path): try: with Image.open(file_path) as img: aspect_ratio = img.height / img.width target_height = int(target_width * aspect_ratio) resized_img = img.resize((target_width, target_height), Image.LANCZOS) resized_img.save(os.path.join(resized_images_dir, filename)) count += 1 except Exception as e: print(f\\"Error processing file {filename}: {e}\\") return count"},{"question":"# Context In this task, you need to implement a search function using the binary search algorithm but with a twist in the problem specification. Your understanding of search algorithms, recursion, and control flow will be crucial for solving this problem effectively. # Problem Statement Design a function `recursive_binary_search_rotated` that searches for a target value in a rotated sorted array using a recursive binary search approach. # Function Signature ```python def recursive_binary_search_rotated(arr: list[int], target: int, left: int, right: int) -> int: ``` # Input * A list of integers `arr` representing a rotated sorted array. * An integer `target` representing the value to search for. * Two integers `left` and `right` representing the current bounds of the search interval within the array. # Output * The function should return the index of the target value in the array if it is present. If the target value is not found, return `-1`. # Constraints * You must use a recursive approach. * The input array will not contain any duplicate values. * The integer values in the array can range from -10^4 to 10^4. * The length of the array will be between 1 and 1000. # Example ```python # Example 1 arr = [4, 5, 6, 7, 0, 1, 2] target = 0 print(recursive_binary_search_rotated(arr, target, 0, len(arr) - 1)) # Output: 4 # Example 2 arr = [4, 5, 6, 7, 0, 1, 2] target = 3 print(recursive_binary_search_rotated(arr, target, 0, len(arr) - 1)) # Output: -1 # Example 3 arr = [1] target = 1 print(recursive_binary_search_rotated(arr, target, 0, len(arr) - 1)) # Output: 0 ``` # Hints * Consider how the rotation affects the mid-point calculation and the partitioning logic. * Think about the properties of the sorted segments and how to identify the target in an altered array structure using recursion.","solution":"def recursive_binary_search_rotated(arr, target, left, right): Searches for the target value in a rotated sorted array using a recursive binary search approach. :param arr: List[int] - Rotated sorted array to search :param target: int - Value to search for :param left: int - Left boundary of the search interval :param right: int - Right boundary of the search interval :return: int - Index of the target if found, else -1 if left > right: return -1 mid = (left + right) // 2 if arr[mid] == target: return mid # Determine which part is properly sorted if arr[left] <= arr[mid]: # Left part is sorted if arr[left] <= target < arr[mid]: return recursive_binary_search_rotated(arr, target, left, mid - 1) else: return recursive_binary_search_rotated(arr, target, mid + 1, right) else: # Right part is sorted if arr[mid] < target <= arr[right]: return recursive_binary_search_rotated(arr, target, mid + 1, right) else: return recursive_binary_search_rotated(arr, target, left, mid - 1)"},{"question":"# Fibonacci Index Finder Context The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. That is, Fibonacci(0) = 0, Fibonacci(1) = 1, Fibonacci(n) = Fibonacci(n - 1) + Fibonacci(n - 2) for n > 1. Task You need to implement the function `find_fibonacci_index(value: int) -> int` that finds the smallest index `n` such that the `n`-th Fibonacci number is greater than or equal to the given `value`. Function Signature ```python def find_fibonacci_index(value: int) -> int ``` Input * `value` (int): A non-negative integer. Output * Returns an integer representing the index `n` such that the `n`-th Fibonacci number is greater than or equal to the input `value`. Constraints * Ensure the performance is feasible for values up to at least `10^18`. * The function should handle large Fibonacci numbers without causing integer overflow. * The algorithm should not solely rely on direct recursive Fibonacci calculation due to performance constraints. Examples ```python find_fibonacci_index(13) -> 7 # Fibonacci(7) = 13 find_fibonacci_index(144) -> 12 # Fibonacci(11) = 89, Fibonacci(12) = 144 find_fibonacci_index(1) -> 1 # Fibonacci(1) = 1 find_fibonacci_index(100) -> 12 # Fibonacci(12) = 144 find_fibonacci_index(2178309) -> 32 # Fibonacci(32) = 2178309 ``` Note * Ensure to handle edge cases like value being 0 or 1 appropriately. Hints 1. Consider using an iterative approach for efficient Fibonacci number computation. 2. Handle the base cases (value being 0 or 1) explicitly to avoid unnecessary computations.","solution":"def find_fibonacci_index(value: int) -> int: Returns the smallest index n such that the n-th Fibonacci number is greater than or equal to the given value. if value == 0: return 0 if value == 1: return 1 a, b = 0, 1 index = 1 while b < value: a, b = b, a + b index += 1 return index"},{"question":"# Task Scheduler for Dependent Jobs Context In computing, scheduling tasks with dependencies is a common problem that ensures tasks are executed in the correct order. It appears in operating systems, distributed systems, and project planning, among other applications. Problem Statement Create a function `find_task_execution_order` which determines the order in which tasks should be executed given their dependencies. If it is impossible to complete all tasks (due to circular dependencies), the function should return an empty list. Function Signature ```python def find_task_execution_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: ``` Input - `tasks`: (List[str]) A list of unique task identifiers. - `dependencies`: (List[Tuple[str, str]]) A list of pairs representing the dependencies between tasks, where each tuple (a, b) means task `b` depends on task `a`. Output - Returns a list of tasks in the order they should be executed. Constraints - Tasks have unique identifiers. - A task identifier can appear in the dependencies list even if it is not in the tasks list, signifying that it must be included as a precondition but has no subsequent dependent tasks. - Handle up to 1000 tasks and 2000 dependencies. Error Handling - Return an empty list if there is a cyclic dependency and the tasks cannot be completed. Examples ```python >>> find_task_execution_order( tasks=[\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"], dependencies=[(\\"a\\", \\"d\\"), (\\"f\\", \\"b\\"), (\\"b\\", \\"d\\"), (\\"f\\", \\"a\\"), (\\"d\\", \\"c\\")] ) [\'f\', \'e\', \'a\', \'b\', \'d\', \'c\'] >>> find_task_execution_order( tasks=[\\"a\\", \\"b\\"], dependencies=[(\\"a\\", \\"b\\"), (\\"b\\", \\"a\\")] ) [] >>> find_task_execution_order( tasks=[\\"a\\", \\"b\\", \\"c\\", \\"d\\"], dependencies=[(\\"a\\", \\"b\\"), (\\"a\\", \\"c\\"), (\\"b\\", \\"d\\"), (\\"c\\", \\"d\\")] ) [\'a\', \'b\', \'c\', \'d\'] ``` Explanation: 1. **Topological Sort**: The problem can be solved using topological sorting. 2. **Graph Representation**: Represent tasks and dependencies as a directed graph. 3. **Cycle Detection**: If there is a cycle detected in the tasks order, return an empty list indicating that the schedule is not feasible. 4. **Correct Order**: Return the correct sequence of tasks by following the dependencies, indicating prerequisites before dependent tasks. This question will assess the candidate\'s ability to understand and implement graph traversal algorithms, specifically topological sorting, and their ability to handle edge cases in graph-based problems.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_task_execution_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: # Building the adjacency list and in-degree of each task. adjacency_list = defaultdict(list) in_degree = defaultdict(int) for a, b in dependencies: adjacency_list[a].append(b) in_degree[b] += 1 # Initialize the in_degree of tasks without prerequisites. for task in tasks: if task not in in_degree: in_degree[task] = 0 # Using a deque (double-ended queue) for the tasks with in_degree 0. zero_in_degree_queue = deque([task for task in tasks if in_degree[task] == 0]) task_order = [] while zero_in_degree_queue: current_task = zero_in_degree_queue.popleft() task_order.append(current_task) # Decrease the in-degree of neighbors. for neighbor in adjacency_list[current_task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Check if we have added all tasks to the task_order if len(task_order) == len(tasks): return task_order else: # If there\'s a cycle and not all tasks are added to task_order return []"},{"question":"# Coding Assessment Question You are tasked with implementing a function that takes a list of integers and returns a new list with the squares of the even numbers sorted in descending order, while ignoring odd numbers. Ensure the function handles input validation for non-list inputs and invalid elements within the list (i.e., non-integer elements). **Function Signature**: ```python def sorted_even_squares(data: list) -> list: Return a list of squares of the even numbers sorted in descending order. Parameters: data (list): A list containing integers. Returns: list: A list of squared even numbers sorted in descending order. Raises: TypeError: If input is not a list or contains non-integer elements. Sample Input/Output: >>> sorted_even_squares([1, 2, 3, 4]) [16, 4] >>> sorted_even_squares([5, 3, -2, -4]) [16, 4] >>> sorted_even_squares([2, 2, 2]) [4, 4, 4] >>> sorted_even_squares([\\"a\\", 2]) Traceback (most recent call last): ... TypeError: All elements of the input list must be integers >>> sorted_even_squares(123) Traceback (most recent call last): ... TypeError: Input must be a list ``` **Constraints**: * The function must handle the following input validation: * Should raise a `TypeError` if the input is not a list. * Should raise a `TypeError` if the list contains non-integer elements. * The input list is guaranteed not to be `None`. **Scenarios**: 1. Inputs with both even and odd integers, verifying only even numbers are squared and sorted. 2. Edge cases involving lists with repeated even integers, negative even integers, and all-odd integers. 3. Input types validation for non-list inputs and lists with mixed data types. *Assumption*: The function does not need to handle extremely large lists optimally but should function correctly within typical constraints.","solution":"def sorted_even_squares(data): Return a list of squares of the even numbers sorted in descending order. Parameters: data (list): A list containing integers. Returns: list: A list of squared even numbers sorted in descending order. Raises: TypeError: If input is not a list or contains non-integer elements. if not isinstance(data, list): raise TypeError(\\"Input must be a list\\") for element in data: if not isinstance(element, int): raise TypeError(\\"All elements of the input list must be integers\\") even_squares = [num ** 2 for num in data if num % 2 == 0] even_squares.sort(reverse=True) return even_squares"},{"question":"# **Coding Assessment Question** **Objective**: You are required to implement an efficient simulation of Conway\'s Game of Life. The goal is to improve performance, as the given implementation encounters performance issues with larger grids. **Problem Statement**: Implement a modified version of the `GameOfLife` class to handle extremely large grids efficiently. Add functionality to handle sparse populations more effectively and optimize the simulation updates to minimize redundant computations. **Function Signature**: ```python class GameOfLife: def __init__(self, width: int, height: int, initial_live_cells: List[Tuple[int, int]]) -> None def next_generation(self) -> None def display(self, generations: int = 100) -> None ``` **Input Format**: - Initialize `GameOfLife` with the width and height of the grid and a list of coordinates for initially live cells. - No direct input as the grid updates are self-managed within class functions. **Output Format**: - No direct output. The grid state is updated internally and visualization displayed using a plotting library such as `matplotlib`. **Constraints**: - width, height ≤ 10^4. - Initial live cells are provided as a list of tuples. **Performance Requirements**: - Optimize for both time and space. Use appropriate data structures to handle large grids efficiently. - Focus on optimizing updates to minimize redundant checks and calculations. **Example Usage**: ```python initial_live_cells = [(1, 2), (2, 2), (3, 2)] gol = GameOfLife(10_000, 10_000, initial_live_cells) gol.display(generations=100) ``` **Additional Notes**: - Utilize sparse matrix representations if necessary to handle large grids efficiently. - Ensure that edge handling is done correctly, assuming a finite grid area. Do not use toroidal (wrap-around) behavior. - Implement strategies to minimize the update area, focusing only on regions with changes. --- Compose one additional question that conforms to these instructions, ensuring it matches the style, complexity, scope, and topic alignment with the provided sample questions. The new question should be unique and seamlessly integrate with the existing set.","solution":"class SparseMatrix: def __init__(self, default_value: int = 0) -> None: self.default_value = default_value self.data = {} def set(self, row: int, col: int, value: int) -> None: if row not in self.data: self.data[row] = {} self.data[row][col] = value def get(self, row: int, col: int) -> int: return self.data.get(row, {}).get(col, self.default_value) def add(self, other: \'SparseMatrix\') -> \'SparseMatrix\': result = SparseMatrix(self.default_value) # Add self matrix values to result for row, cols in self.data.items(): for col, value in cols.items(): result.set(row, col, value) # Add other matrix values to result for row, cols in other.data.items(): for col, value in cols.items(): current = result.get(row, col) result.set(row, col, current + value) return result"},{"question":"# Email Domain Extraction You are tasked with creating a function that extracts the domain part of email addresses from a list of email strings. Additionally, provide functionality to handle and filter out invalid email addresses from the list. # Requirements: 1. **Function Signature**: ```python def extract_domains(emails: list[str]) -> list[str]: ``` 2. **Inputs**: - `emails`: A list of email address strings. 3. **Outputs**: - Return a list of domain parts extracted from valid email addresses provided in the input list. # Constraints: 1. Each email string should contain exactly one \'@\' character. 2. The local part (before \'@\') should contain only alphanumeric characters and optionally dots (\'.\') and underscores (\'_\'). 3. The domain part (after \'@\') should contain at least one dot (\'.\') with alphanumeric characters, allowing hyphens (\'-\'). 4. Disregard email strings that do not meet the above criteria. # Example: ```python >>> emails = [\\"user@example.com\\", \\"info@domain.co.uk\\", \\"invalid@domain\\", \\"user@invalid_domain.com\\"] >>> extract_domains(emails) [\'example.com\', \'domain.co.uk\'] ``` # Detailed Steps: 1. **Validation**: - Check if the email contains exactly one \'@\'. - Ensure the local part adheres to the allowed character set. - Verify the domain part contains at least one dot (\'.\') and valid alphanumeric/hyphen characters. 2. **Extraction**: - Split valid email addresses at the \'@\' symbol. - Append the domain part to the output list. 3. **Edge Cases**: - Handle emails with special characters or multiple \'@\' symbols as invalid. - Handle leading or trailing dots in the local or domain parts as invalid. # Implementation Tips: - Use String methods and regular expressions (`re` module) for efficient validation. - Loop through the list, perform validation, and parse the domain part for valid emails.","solution":"import re def extract_domains(emails: list[str]) -> list[str]: Extracts the domain part of valid email addresses from the provided list of email strings. Invalid emails are filtered out based on the specified validation criteria. domains = [] email_pattern = re.compile(r\'^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,}\') for email in emails: if email_pattern.match(email): domain = email.split(\'@\')[1] domains.append(domain) return domains"},{"question":"# Data Processing and File Export Task You have been given a dataset of global earthquake events and are required to process and analyze the data. Your task is to write a function named `analyze_earthquake_data` that performs the following operations: 1. **Read the Dataset**: Read the earthquake dataset from a CSV file. 2. **Filter Data**: Filter the dataset to include only earthquakes with a magnitude of 5.0 or higher. 3. **Calculate Statistics**: Calculate the average depth and average magnitude of the filtered earthquakes. 4. **Save Processed Data**: Save the filtered dataset to a new CSV file. # Function Signature ```python def analyze_earthquake_data(input_csv: str, output_csv: str) -> dict: Processes earthquake data, filters it, calculates statistics, and saves it to a new CSV file. Parameters: - input_csv (str): The path to the input CSV file containing the earthquake dataset. - output_csv (str): The path where the filtered dataset should be saved. Returns: - dict: A dictionary containing the average depth and average magnitude of the filtered earthquakes. ``` # Requirements 1. Read the input CSV file using pandas: - The CSV file will have columns such as `id`, `time`, `latitude`, `longitude`, `depth`, `magnitude`. 2. Filter the dataset: - Include only rows where the `magnitude` column has values of 5.0 or higher. 3. Calculate statistics: - Compute the average depth and the average magnitude of the filtered dataset. - The dictionary returned should have the format `{\'average_depth\': avg_depth, \'average_magnitude\': avg_magnitude}`. 4. Save the filtered dataset: - Save the filtered rows to a new CSV file specified by `output_csv`. - Ensure the saved file retains the original column headers. # Constraints - Handle file read/write errors gracefully, providing meaningful error messages. - Ensure the input CSV file exists and has the correct format. - Handle cases where no data matches the filter criteria, returning appropriate output. # Example ```python result = analyze_earthquake_data(\\"earthquakes.csv\\", \\"filtered_earthquakes.csv\\") print(result) # Expected output: {\'average_depth\': <calculated_average_depth>, \'average_magnitude\': <calculated_average_magnitude>} ```","solution":"import pandas as pd def analyze_earthquake_data(input_csv: str, output_csv: str) -> dict: Processes earthquake data, filters it, calculates statistics, and saves it to a new CSV file. Parameters: - input_csv (str): The path to the input CSV file containing the earthquake dataset. - output_csv (str): The path where the filtered dataset should be saved. Returns: - dict: A dictionary containing the average depth and average magnitude of the filtered earthquakes. try: # Read the dataset df = pd.read_csv(input_csv) # Filter data to include only earthquakes with a magnitude of 5.0 or higher filtered_df = df[df[\'magnitude\'] >= 5.0] # Check if any data left after filtering if filtered_df.empty: raise ValueError(\\"No earthquake events with magnitude 5.0 or higher found in the dataset.\\") # Calculate average depth and average magnitude avg_depth = filtered_df[\'depth\'].mean() avg_magnitude = filtered_df[\'magnitude\'].mean() # Save the filtered dataset to a new CSV file filtered_df.to_csv(output_csv, index=False) return {\'average_depth\': avg_depth, \'average_magnitude\': avg_magnitude} except FileNotFoundError: raise FileNotFoundError(\\"Input CSV file not found.\\") except pd.errors.EmptyDataError: raise ValueError(\\"Input CSV file is empty.\\") except KeyError as e: raise KeyError(f\\"Missing expected column in the CSV file: {e}\\")"},{"question":"# Temperature Conversion Utility **Problem Statement**: In scientific and daily life, temperature conversion between different units is a common task. The most commonly used temperature scales are Celsius, Fahrenheit, and Kelvin. You are required to implement a temperature conversion utility that can convert a given temperature from one scale to another. Provide a function `convert_temperature` that converts a temperature from one given scale to another. The function should be capable of converting: - Celsius to Fahrenheit - Celsius to Kelvin - Fahrenheit to Celsius - Fahrenheit to Kelvin - Kelvin to Celsius - Kelvin to Fahrenheit Function Signature ```python def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: pass ``` Input - `value`: A float representing the temperature to be converted. - `from_scale`: A string indicating the scale of the input temperature. It can be `\\"Celsius\\"`, `\\"Fahrenheit\\"`, or `\\"Kelvin\\"`. - `to_scale`: A string indicating the scale to which the input temperature should be converted. It can be `\\"Celsius\\"`, `\\"Fahrenheit\\"`, or `\\"Kelvin\\"`. Output - Returns a float representing the converted temperature in the requested scale. Constraints - The input `value` will always be a valid float. - The `from_scale` and `to_scale` are guaranteed to be valid strings among `\\"Celsius\\"`, `\\"Fahrenheit\\"`, and `\\"Kelvin\\"`. Example ```python >>> convert_temperature(100, \'Celsius\', \'Fahrenheit\') 212.0 >>> convert_temperature(0, \'Celsius\', \'Kelvin\') 273.15 >>> convert_temperature(32, \'Fahrenheit\', \'Celsius\') 0.0 >>> convert_temperature(0, \'Kelvin\', \'Celsius\') -273.15 ``` Additional Requirements - Handle the special case where the input temperature in Kelvin is less than 0 by raising an exception with the message \\"Temperature in Kelvin cannot be less than 0\\".","solution":"def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: if from_scale == \'Kelvin\' and value < 0: raise ValueError(\\"Temperature in Kelvin cannot be less than 0\\") if from_scale == \\"Celsius\\": if to_scale == \\"Fahrenheit\\": return value * 9/5 + 32 elif to_scale == \\"Kelvin\\": return value + 273.15 elif from_scale == \\"Fahrenheit\\": if to_scale == \\"Celsius\\": return (value - 32) * 5/9 elif to_scale == \\"Kelvin\\": return (value - 32) * 5/9 + 273.15 elif from_scale == \\"Kelvin\\": if to_scale == \\"Celsius\\": return value - 273.15 elif to_scale == \\"Fahrenheit\\": return (value - 273.15) * 9/5 + 32 return value # If from_scale equals to_scale"},{"question":"# Problem Statement You are tasked with designing a software module that will simulate the allocation of tasks among a group of workers, such that the total load is balanced as evenly as possible. Each worker can perform one or more tasks, but the order in which tasks are assigned follows a specific list. # Function Signature ```python def balance_tasks(tasks: list[int], num_workers: int) -> int: pass ``` # Input - `tasks`: A list of n positive integers, where each integer represents the time required to complete a task. - `num_workers`: An integer representing the number of workers available to complete the tasks. # Output - Return an integer representing the minimum possible maximum load any worker will have. # Constraints - `1 <= len(tasks) <= 10^5` - `1 <= num_workers <= len(tasks)` - Each element in `tasks` is a positive integer. # Example - Input: `([10, 20, 30, 40, 50], 2)` - Output: `90` # Scenario Consider a scenario where a construction company wants to allocate a series of jobs to their workers in such a way that no worker is overburdened more than the others. This planning helps in efficient workforce management. # Performance Requirements - The solution should be optimized for both time and space complexities. - Ensure to handle edge cases such as the minimum and maximum number of workers and tasks. # Requirements - Do not use in-built Python functions that explicitly solve the problem (e.g., `itertools`). - Handle all edge cases, including when there are more workers than tasks. - Ensure your solution works within the given constraints and efficiently balances the task loads.","solution":"def balance_tasks(tasks: list[int], num_workers: int) -> int: def canBalance(maxLoad): current_worker_load = 0 workers_needed = 1 for task in tasks: if current_worker_load + task <= maxLoad: current_worker_load += task else: workers_needed += 1 current_worker_load = task if workers_needed > num_workers: return False return True left, right = max(tasks), sum(tasks) min_possible_max_load = right while left <= right: mid = (left + right) // 2 if canBalance(mid): min_possible_max_load = mid right = mid - 1 else: left = mid + 1 return min_possible_max_load"},{"question":"# Coding Question: Multi-Tier Inventory Tracker You are part of a development team at a warehouse logistics company. Your task is to implement a multi-tier inventory tracking system that: 1. Allows for tracking the quantities of various items in different locations (warehouses, sections within warehouses, etc.). 2. Supports adding and removing items and their quantities across different locations. 3. Provides summaries and detailed reports of item quantities. Implement a class `InventoryTracker` that maintains a tiered inventory system. Class Definition ```python class InventoryTracker: def __init__(self): pass def add_item(self, location: Tuple[str, ...], item: str, quantity: int) -> None: pass def remove_item(self, location: Tuple[str, ...], item: str, quantity: int) -> None: pass def get_quantity(self, location: Tuple[str, ...], item: str) -> int: pass def get_summary(self) -> Dict[str, Dict[str, int]]: pass def get_detailed_report(self) -> Dict[Tuple[str, ...], Dict[str, int]]: pass ``` Methods - **`__init__`**: - Initializes an empty inventory. - **`add_item(location, item, quantity)`**: - Adds the specified quantity of the given item to the specified location. - **Parameters**: - *location*: A tuple representing the tiered location (e.g., (\'Warehouse1\', \'Aisle2\', \'Shelf3\')). - *item*: (string) Name of the item. - *quantity*: (int) Number of items to add. - **`remove_item(location, item, quantity)`**: - Removes the specified quantity of the given item from the specified location. - Raises a ValueError if there are not enough items to remove. - **Parameters**: - *location*: A tuple representing the tiered location (e.g., (\'Warehouse1\', \'Aisle2\', \'Shelf3\')). - *item*: (string) Name of the item. - *quantity*: (int) Number of items to remove. - **`get_quantity(location, item)`**: - Retrieves the quantity of the specified item at the given location. - **Parameters**: - *location*: A tuple representing the tiered location (e.g., (\'Warehouse1\', \'Aisle2\', \'Shelf3\')). - *item*: (string) Name of the item. - **Returns**: - (int) Number of the specified items in the location. - **`get_summary()`**: - Provides a summary report of total quantities of each item across all locations. - **Returns**: - (Dictionary) A dictionary summary such that each key is an item name and the value is another dictionary. This inner dictionary keys are the location names as strings concatenated with an underscore (e.g. \'Warehouse1_Aisle2_Shelf3\') and values are the quantities of the item at that location. - **`get_detailed_report()`**: - Provides a detailed report of item quantities organized by location. - **Returns**: - (Dictionary) A dictionary where keys are locations (as tuples) and values are dictionaries. This inner dictionary\'s keys are item names and values are quantities of those items in the specified location. Constraints - Quantity values will be integers and always be non-negative. - Locations are distinct and represent a hierarchical structure for inventory storage. - Ensure all operations handle dynamic entries of locations and items. Example Usage ```python tracker = InventoryTracker() # Add items tracker.add_item((\'Warehouse1\', \'SectionA\'), \'widget\', 100) tracker.add_item((\'Warehouse1\', \'SectionB\'), \'widget\', 150) tracker.add_item((\'Warehouse2\',), \'widget\', 200) tracker.add_item((\'Warehouse2\', \'SectionC\', \'Shelf1\'), \'gizmo\', 50) # Remove items tracker.remove_item((\'Warehouse1\', \'SectionA\'), \'widget\', 30) # Get quantities print(tracker.get_quantity((\'Warehouse1\', \'SectionA\'), \'widget\')) # Returns: 70 # Get summary print(tracker.get_summary()) # Example summary output: # {\'widget\': {\'Warehouse1_SectionA\': 70, \'Warehouse1_SectionB\': 150, \'Warehouse2\': 200}, # \'gizmo\': {\'Warehouse2_SectionC_Shelf1\': 50}} # Get detailed report print(tracker.get_detailed_report()) # Example detailed report: # {(\'Warehouse1\', \'SectionA\'): {\'widget\': 70}, # (\'Warehouse1\', \'SectionB\'): {\'widget\': 150}, # (\'Warehouse2\',): {\'widget\': 200}, # (\'Warehouse2\', \'SectionC\', \'Shelf1\'): {\'gizmo\': 50}} ``` Notes - Handle cases where operations are attempted on non-existent locations or items gracefully. - Ensure the implementation efficiently manages and updates the inventory structure.","solution":"from collections import defaultdict from typing import Tuple, Dict class InventoryTracker: def __init__(self): self.inventory = defaultdict(lambda: defaultdict(int)) def add_item(self, location: Tuple[str, ...], item: str, quantity: int) -> None: self.inventory[location][item] += quantity def remove_item(self, location: Tuple[str, ...], item: str, quantity: int) -> None: if self.inventory[location][item] < quantity: raise ValueError(\\"Not enough items to remove\\") self.inventory[location][item] -= quantity if self.inventory[location][item] == 0: del self.inventory[location][item] def get_quantity(self, location: Tuple[str, ...], item: str) -> int: return self.inventory[location].get(item, 0) def get_summary(self) -> Dict[str, Dict[str, int]]: summary = defaultdict(lambda: defaultdict(int)) for loc, items in self.inventory.items(): loc_str = \\"_\\".join(loc) for item, quantity in items.items(): summary[item][loc_str] = quantity return summary def get_detailed_report(self) -> Dict[Tuple[str, ...], Dict[str, int]]: return {loc: dict(items) for loc, items in self.inventory.items()}"},{"question":"# String Pattern Replacement Function As a software engineer working on a text processing tool, you are tasked with creating a function that can replace patterns in a given string based on a set of replacement rules. This tool will be helpful in various applications, including data cleaning and formatting tasks, so it\'s essential to handle the replacement efficiently. Write a Python function `replace_patterns` that accepts two parameters: 1. `text` (str): The input string in which patterns will be replaced. 2. `replacements` (dict[str, str]): A dictionary where keys are the patterns to be replaced, and values are their corresponding replacement strings. The function should return the modified string after performing all the specified replacements. The replacements should be done in the order provided in the dictionary. # Example Usage ```python # Example replacements dictionary replacements = { \\"hello\\": \\"hi\\", \\"world\\": \\"earth\\", \\"Python\\": \\"programming language\\", } # Replace patterns in the text replace_patterns(\\"hello world, welcome to the Python course!\\", replacements) => \\"hi earth, welcome to the programming language course!\\" # Replace patterns in another text replace_patterns(\\"Python is great!\\", replacements) => \\"programming language is great!\\" ``` # Constraints - The order of replacements should respect the order of the keys in the dictionary. - If a pattern appears multiple times in the text, all occurrences should be replaced. - The replacement should be case-sensitive. # Implementation ```python def replace_patterns(text: str, replacements: dict[str, str]) -> str: # Your implementation here. pass ``` Your task is to complete the `replace_patterns` function, ensuring it correctly replaces all specified patterns in the given text according to the provided replacements dictionary.","solution":"def replace_patterns(text: str, replacements: dict[str, str]) -> str: Replaces patterns in the given text based on the replacements dictionary. Params: - text (str): The input string in which patterns will be replaced. - replacements (dict[str, str]): A dictionary with patterns as keys and their replacements as values. Returns: - str: The modified string after performing all the replacements. for pattern, replacement in replacements.items(): text = text.replace(pattern, replacement) return text"},{"question":"Problem Statement **Cache Miss Calculator** In computer architecture, cache memory plays a crucial role in speeding up access to data. Calculating the number of cache misses can help in optimizing the performance of algorithms. Given certain parameters related to a cache, calculate the number of cache misses during a sequence of memory accesses. # Background Cache miss occurs when the data requested by the CPU is not found in the cache memory, leading to a fetch from the main memory. The number of cache misses can be calculated using the following formula, where **N** is the number of memory accesses and **H** is the hit rate: [ text{Cache_misses} = N times (1 - H) ] # Input Your function should take three arguments: 1. **accesses** (`int`): Number of memory accesses during program execution (set to zero if unknown). 2. **hit_rate** (`float`): Cache hit rate, a value between 0 and 1 (set to zero if unknown). 3. **misses** (`int`): Number of cache misses (set to zero if unknown). # Output A dictionary containing the missing parameter, with a key-value pair. # Constraints * Exactly one of the accesses, hit_rate, or misses must be set to zero to compute its value based on the others. * All provided values must be non-negative, except for the parameter to be calculated, which must be zero. * The `hit_rate` must be between 0 and 1 (inclusive). * If more than one or none of the parameter values are zero, raise a ValueError with the message \\"One and only one argument must be 0\\". * If any provided value is invalid (negative or hit_rate out of range), raise a ValueError with an appropriate message indicating the invalid parameter. # Examples ```python # Example 1: print(cache_miss_calculator(accesses=1000, hit_rate=0.95, misses=0)) # Output: {\'misses\': 50} # Example 2: print(cache_miss_calculator(accesses=2000, hit_rate=0, misses=300)) # Output: {\'hit_rate\': 0.85} # Example 3: print(cache_miss_calculator(accesses=0, hit_rate=0.9, misses=100)) # Output: {\'accesses\': 1000} # Error cases: # More than one zero argument print(cache_miss_calculator(accesses=1000, hit_rate=0, misses=0)) # Output: ValueError: One and only one argument must be 0 # Hit rate out of range print(cache_miss_calculator(accesses=1000, hit_rate=1.5, misses=50)) # Output: ValueError: Hit rate must be between 0 and 1 # Negative number of accesses print(cache_miss_calculator(accesses=-100, hit_rate=0.9, misses=10)) # Output: ValueError: Number of accesses cannot be negative ``` # Submission Implement your solution in the function `cache_miss_calculator`. Ensure it handles the given constraints and edge cases effectively.","solution":"def cache_miss_calculator(accesses, hit_rate, misses): Calculate the number of cache misses given the number of memory accesses and the cache hit rate or vice versa. Returns a dictionary identifying the calculated parameter. if not (0 <= hit_rate <= 1) and hit_rate != 0: raise ValueError(\\"Hit rate must be between 0 and 1\\") if accesses < 0: raise ValueError(\\"Number of accesses cannot be negative\\") if misses < 0: raise ValueError(\\"Number of misses cannot be negative\\") zero_count = sum([accesses == 0, hit_rate == 0, misses == 0]) if zero_count != 1: raise ValueError(\\"One and only one argument must be 0\\") if accesses == 0: accesses = misses / (1 - hit_rate) return {\'accesses\': int(accesses)} elif hit_rate == 0: hit_rate = 1 - (misses / accesses) return {\'hit_rate\': hit_rate} elif misses == 0: misses = accesses * (1 - hit_rate) return {\'misses\': int(misses)}"},{"question":"# Problem Statement Implement a class `CustomQueue` that mimics the behaviors of a regular queue but with an added twist. In addition to the usual enqueue and dequeue operations, your queue should support an increment operation. The increment operation allows you to increment the first `k` elements of the queue by a given value. # Input The `CustomQueue` class should support the following methods: * `enqueue(self, value: int) -> None`: Adds an item to the back of the queue. * `dequeue(self) -> int`: Removes and returns the item at the front of the queue. If the queue is empty, return `-1`. * `increment(self, k: int, value: int) -> None`: Increments the first `k` elements of the queue by the given value. If `k` exceeds the current size of the queue, increment all elements. # Output / Example ```python cq = CustomQueue() cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.increment(2, 5) # Queue is now [6, 7, 3] print(cq.dequeue()) # Returns and removes 6, queue is now [7, 3] cq.increment(2, 10) # Queue is now [17, 13] print(cq.dequeue()) # Returns and removes 17, queue is now [13] print(cq.dequeue()) # Returns and removes 13, queue is now empty print(cq.dequeue()) # Returns -1 as the queue is empty ``` # Constraints - You may assume that all elements to be enqueued are `int` numbers within the range [-10^3, 10^3]. - The `increment` method will be called with `k` as a non-negative integer and `value` within the range [-10^3, 10^3]. - Ensure that each method runs efficiently given possible large sequences of operations. # Hints 1. Use a list to represent the queue internally. 2. When implementing the `increment` method, ensure you avoid unnecessary traversal of the queue for optimal performance.","solution":"class CustomQueue: def __init__(self): self.queue = [] def enqueue(self, value: int) -> None: self.queue.append(value) def dequeue(self) -> int: if not self.queue: return -1 return self.queue.pop(0) def increment(self, k: int, value: int) -> None: num_elements = min(k, len(self.queue)) for i in range(num_elements): self.queue[i] += value"},{"question":"# Question: Implement a Logger with Log Level Filtering Context: You need to build a simple logging system that can record different types of log messages (INFO, WARNING, ERROR) and allow querying of messages by their log levels. Each log message should be stored with its type and a timestamp, which can be text inputs representing the timestamp. The system should support adding new log messages and retrieving logs based on their level. Requirements: 1. **Class Definition**: - `class Logger` 2. **Methods**: - `def log_info(self, message: str, timestamp: str) -> None` - `def log_warning(self, message: str, timestamp: str) -> None` - `def log_error(self, message: str, timestamp: str) -> None` - `def get_messages(self, level: str) -> List[str]` 3. **Input and Output Formats**: - The `log_info`, `log_warning`, and `log_error` methods accept two string parameters: `message` and `timestamp`. - The `get_messages` method accepts one string parameter: `level` (which can be \\"INFO\\", \\"WARNING\\", or \\"ERROR\\"), and returns a list of strings representing the log messages of that level. 4. **Constraints**: - The `level` in `get_messages` should be case-insensitive and always return the messages in the order they were added. - All input messages and timestamps are non-empty strings. - If the `get_messages` method is called with an invalid log level, it should raise a `ValueError`. 5. **Performance Requirements**: - The operations of adding and retrieving logs should be efficient, with average time complexity close to O(1) for adding log entries and O(n) for retrieving logs, where `n` is the number of log entries. - Use space efficiently to store the log entries. Example Usage: ```python logger = Logger() logger.log_info(\\"System started\\", \\"2023-01-01 00:00:00\\") logger.log_warning(\\"Low disk space\\", \\"2023-01-01 01:00:00\\") logger.log_error(\\"System crash\\", \\"2023-01-01 02:00:00\\") assert logger.get_messages(\\"INFO\\") == [\\"2023-01-01 00:00:00 - INFO - System started\\"] assert logger.get_messages(\\"WARNING\\") == [\\"2023-01-01 01:00:00 - WARNING - Low disk space\\"] assert logger.get_messages(\\"ERROR\\") == [\\"2023-01-01 02:00:00 - ERROR - System crash\\"] assert logger.get_messages(\\"info\\") == [\\"2023-01-01 00:00:00 - INFO - System started\\"] import pytest with pytest.raises(ValueError): logger.get_messages(\\"INVALID\\") ``` Instructions: 1. Define the `Logger` class with the specified methods. 2. Implement the `log_info`, `log_warning`, and `log_error` methods to store messages with respective log levels. 3. Implement the `get_messages` method to retrieve messages based on the log level provided, in a case-insensitive manner. 4. Ensure your solution is tested using the provided assertions and handles all specified constraints and edge cases gracefully.","solution":"from typing import List class Logger: def __init__(self): self.logs = [] def log_info(self, message: str, timestamp: str) -> None: self.logs.append((timestamp, \\"INFO\\", message)) def log_warning(self, message: str, timestamp: str) -> None: self.logs.append((timestamp, \\"WARNING\\", message)) def log_error(self, message: str, timestamp: str) -> None: self.logs.append((timestamp, \\"ERROR\\", message)) def get_messages(self, level: str) -> List[str]: level = level.upper() if level not in {\\"INFO\\", \\"WARNING\\", \\"ERROR\\"}: raise ValueError(f\\"Invalid log level: {level}\\") return [f\\"{timestamp} - {level} - {message}\\" for timestamp, log_level, message in self.logs if log_level == level]"},{"question":"# Hotel Booking Management System: In this task, you need to implement a small part of a booking management system for a hotel. This involves managing room reservations where each room can be booked for different time slots. Scenario: You are writing software for a hotel that needs to manage reservations for its rooms. Each room can be identified by its number, and each reservation has a start and end time. Objective: Implement a function `book_room` that books a room for a specified time period. The system should handle overlapping reservations correctly by not allowing double bookings for the same room at the same time. Specifications: 1. Functions: * `book_room` - Takes a dictionary representing the hotel bookings, a room number, a start time, and an end time, books the room if the time slot is available, and returns `True`. If the time slot is not available, it should return `False`. 2. Input/Output Formats: * **Input**: * `bookings`: A dictionary where keys are room numbers (integers) and values are lists of tuples, each tuple containing two integers representing the start and end times of a booking. * `room_number`: An integer representing the room to be booked. * `start_time`: An integer representing the starting hour of booking (24-hour format). * `end_time`: An integer representing the ending hour of booking (24-hour format). * **Output**: * For `book_room`: Returns `True` if the room was successfully booked, else `False`. Function Signature: ```python def book_room(bookings: dict, room_number: int, start_time: int, end_time: int) -> bool: pass ``` Example Usage: ```python bookings = {} # Booking room 101 from 10 to 12 assert book_room(bookings, 101, 10, 12) == True # Trying to book room 101 from 11 to 13 (should overlap with the previous booking) assert book_room(bookings, 101, 11, 13) == False # Booking room 102 from 15 to 18 assert book_room(bookings, 102, 15, 18) == True ``` Constraints: * Room numbers are positive integers. * Start and end times are integers in the range `[0, 23]`. * End time has to be greater than start time. * The system should handle multiple bookings and multiple rooms efficiently.","solution":"def book_room(bookings: dict, room_number: int, start_time: int, end_time: int) -> bool: Function to book a room for a specified time period. The room should not be booked if the time slot overlaps with any existing booking. :param bookings: Dictionary with room numbers as keys and lists of (start_time, end_time) tuples as values. :param room_number: Integer representing the room to be booked. :param start_time: Integer representing the starting hour of the booking (24-hour format). :param end_time: Integer representing the ending hour of the booking (24-hour format). :return: True if the room was successfully booked, otherwise False. if start_time >= end_time: return False # Invalid time range # Initialize room booking list if it doesn\'t exist if room_number not in bookings: bookings[room_number] = [] # Check for overlapping bookings for (existing_start, existing_end) in bookings[room_number]: if not (end_time <= existing_start or start_time >= existing_end): return False # No overlapping bookings, so we can book the room bookings[room_number].append((start_time, end_time)) return True"},{"question":"# Coding Assessment Question Optimizing a Polynomial Chain You are tasked with evaluating a polynomial given its coefficients and a specific value for the variable. However, to minimize computational overhead, your goal is to optimize the evaluation using Horner\'s method. # Problem Statement Function: horner_evaluation Write a function `horner_evaluation` that: - Takes as input a list of coefficients `coeffs` representing the polynomial in descending order of powers, and a float `x` representing the value for which the polynomial needs to be evaluated. - Returns a float which is the resultant value of the polynomial evaluated at `x`. - Implements Horner\'s method to perform the evaluation efficiently. Constraints: 1. The list `coeffs` has at least one element, representing the polynomial coefficients. 2. The variable `x` is a float. Specifications: - Input: List `coeffs` of floats and a float `x`. - Output: Float representing the polynomial evaluated at `x`. Example Scenario Given the polynomial (P(x) = 3x^3 - 6x^2 + 4x - 5) (which corresponds to `coeffs = [3, -6, 4, -5]`): ```python coeffs = [3, -6, 4, -5] x = 2 result = horner_evaluation(coeffs, x) print(result) # Output should be -3 ``` This demonstrates an example where the polynomial (P(2)) is evaluated using Horner\'s method, yielding a result of `-3`. # Note: Your implementation should efficiently handle large polynomials and values of `x` while ensuring numerical stability. Write your implementation in a function `horner_evaluation` based on the above specifications and constraints.","solution":"def horner_evaluation(coeffs, x): Evaluate a polynomial at a given point x using Horner\'s method. Parameters: coeffs (list of floats): Coefficients of the polynomial in descending order of powers. x (float): The value at which to evaluate the polynomial. Returns: float: The value of the polynomial evaluated at x. result = 0 for coefficient in coeffs: result = result * x + coefficient return result"},{"question":"# Problem Statement You are given a list of integers and a target integer. Implement the binary search algorithm to determine whether the target integer is present in the list. If the target is found, return True; otherwise, return False. # Input Format * **arr**: A list of integers (1 ≤ len(arr) ≤ 10^6) * **x**: An integer to search within the array (0 ≤ |x| ≤ 10^9) # Output Format * Return True if the target integer is found in the list, otherwise return False. # Example ```python >>> binary_search([1, 3, 5, 7, 9], 3) True >>> binary_search([2, 4, 6, 8], 5) False >>> binary_search([0, 2, 2, 3, 4, 5, 6, 7], 6) True >>> binary_search([10, 20, 30, 40, 50], 25) False >>> binary_search([-10, -5, 0, 5, 10], -5) True ``` # Constraints * The given array may not be sorted. * You should not use any built-in search functions like `list.index`. * Expected time complexity is O(log n) for searching, which means you must sort the array first if it is not sorted. # Performance Requirements Your implementation should be efficient, handling large arrays with up to 10^6 elements. # Hints 1. If the array is not sorted, sort it first. 2. Use the binary search algorithm: repeatedly divide the search interval in half. 3. If the target value is equal to the middle element, return True. 4. If the target value is less than the middle element, search the left half. 5. If the target value is greater than the middle element, search the right half. If the interval becomes empty, return False.","solution":"def binary_search(arr, x): Performs binary search on a sorted list to find the target integer. Parameters: arr (list): A list of integers. x (int): The target integer to search for. Returns: bool: True if x is found, False otherwise. arr.sort() # Sorting the array first to ensure binary search works correctly low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == x: return True elif arr[mid] < x: low = mid + 1 else: high = mid - 1 return False"},{"question":"# Question: Product of Array Except Self Context: In a coding interview, you are presented with a classic array problem that tests your understanding of linear time algorithms and space efficiency. This problem requires a clever approach to avoid division and utilize extra space optimally. Problem Statement: Write a function `product_except_self(nums: List[int]) -> List[int]` that takes a list of integers and returns a list of products such that each element at index `i` contains the product of all elements of the input list except `nums[i]`. Function Signature: ```python def product_except_self(nums: List[int]) -> List[int]: ``` Input: - A list of integers `nums` (2 <= len(nums) <= 10^5, -30 <= nums[i] <= 30) Output: - A list of integers representing the product of array elements except for the element at index `i`. Constraints: - The function should run in O(n) time complexity. - Do not use the division operation. - The output array should not be located in the input array. Allocate new array for the result. Example: ```python print(product_except_self([1,2,3,4])) # Output: [24, 12, 8, 6] print(product_except_self([5,6,7,8])) # Output: [336, 280, 240, 210] print(product_except_self([0,1,2,3])) # Output: [6, 0, 0, 0] ``` Explanation: For `nums = [1,2,3,4]`: - The product of all array elements: (1 * 2 * 3 * 4 = 24) - Result array: - For index 0: (2 * 3 * 4 = 24) - For index 1: (1 * 3 * 4 = 12) - For index 2: (1 * 2 * 4 = 8) - For index 3: (1 * 2 * 3 = 6) For each index, you need to calculate the product of all other elements without using division. **Your task** is to implement the function `product_except_self` following the guidelines provided.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) result = [1] * n # Initialize the result array with 1s # Step 1: Calculate prefix products prefix = 1 for i in range(n): result[i] = prefix prefix *= nums[i] # Step 2: Calculate suffix products and multiply them with prefix products suffix = 1 for i in range(n-1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"# Additional Question Implement a Python function called `find_smallest_window` that finds the smallest substring of a given string `s` which contains all the characters of another string `t`. Function Signature ```python def find_smallest_window(s: str, t: str) -> str: pass ``` Input * `s`: A string representing the main text (1 ≤ length of `s` ≤ 10^5). * `t`: A string representing the set of characters to be found in a substring of `s` (1 ≤ length of `t` ≤ 10^4). Output * Returns the smallest substring of `s` that contains all the characters in `t`. If no such window exists, return an empty string. Constraints * Both input strings `s` and `t` consist of printable ASCII characters. Example ```python >>> find_smallest_window(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> find_smallest_window(\\"a\\", \\"a\\") \\"a\\" >>> find_smallest_window(\\"a\\", \\"aa\\") \\"\\" >>> find_smallest_window(\\"a\\", \\"b\\") \\"\\" >>> find_smallest_window(\\"aa\\", \\"aa\\") \\"aa\\" >>> find_smallest_window(\\"abcdefgh\\", \\"efg\\") \\"efg\\" ``` Notes * The function should be optimized for both time and space, considering the constraints on input sizes. * If multiple substrings of the same minimal length exist, return the first occurring one from left to right in `s`. * Make sure to handle edge cases: when `t` is longer than `s` or when `s` is an empty string.","solution":"from collections import Counter def find_smallest_window(s: str, t: str) -> str: if not s or not t or len(t) > len(s): return \\"\\" t_count = Counter(t) current_count = Counter() start = 0 min_length = float(\\"inf\\") min_window_start = 0 num_chars_to_match = len(t_count) matched_chars = 0 for end in range(len(s)): end_char = s[end] current_count[end_char] += 1 if end_char in t_count and current_count[end_char] == t_count[end_char]: matched_chars += 1 while matched_chars == num_chars_to_match: window_length = end - start + 1 if window_length < min_length: min_length = window_length min_window_start = start start_char = s[start] current_count[start_char] -= 1 if start_char in t_count and current_count[start_char] < t_count[start_char]: matched_chars -= 1 start += 1 if min_length == float(\\"inf\\"): return \\"\\" return s[min_window_start:min_window_start + min_length]"},{"question":"# Scenario: You are part of a team developing a data processing module for an e-commerce platform. One of the features needed is to analyze customer purchase patterns. For this feature, you need to implement a function that identifies the longest consecutive sequence of repeated purchases. Given a list of customer purchase amounts, the goal is to find the length of the largest contiguous subarray where all the purchase amounts are the same. # Task: Implement the function `longest_consecutive_purchases` that takes a list of integers as input and returns the length of the longest contiguous subarray where all elements are the same. # Function Signature: ```python def longest_consecutive_purchases(purchases: list) -> int: ``` # Input/Output: * **Input**: * `purchases` (list of int): A list of purchase amounts (1 ≤ len(purchases) ≤ 10^5). * **Output**: * (int): The length of the longest contiguous subarray with identical purchase amounts. # Constraints: * The list `purchases` can contain any integer values. * The function should run efficiently for length `n` where `1 ≤ n ≤ 100,000`. # Performance Requirements: The function is expected to run in linear time, O(n). # Example: ```python >>> longest_consecutive_purchases([100, 200, 200, 200, 300, 300, 100]) 3 >>> longest_consecutive_purchases([500, 500, 500, 500, 500]) 5 >>> longest_consecutive_purchases([10, 20, 30, 40, 50]) 1 >>> longest_consecutive_purchases([]) 0 ``` # Notes: - If the input list is empty, the function should return 0. - Make sure to handle edge cases appropriately such as an empty list or a list with all unique values.","solution":"def longest_consecutive_purchases(purchases): if not purchases: return 0 max_length = 1 current_length = 1 for i in range(1, len(purchases)): if purchases[i] == purchases[i - 1]: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 1 return max_length"},{"question":"# Problem Statement Write a Python function `bitwise_xor` that simulates the XOR (Exclusive OR) operation using bitwise operators. The function should take two integer inputs and return the result of the XOR operation. Additionally, write a `xor_truth_table` function that generates the truth table for the `bitwise_xor`. # Input and Output Input * `bitwise_xor(input_1: int, input_2: int) -> int` * Takes two integer inputs - `input_1` and `input_2` which will be either `0` or `1`. * `xor_truth_table(func: Callable) -> str` * Takes a callable (function) which accepts two integer inputs and returns an integer (result of the XOR logic gate). Output * `bitwise_xor` returns `1` if exactly one of the inputs is `1`, otherwise returns `0`. * `xor_truth_table` returns the truth table of the `bitwise_xor` function as a formatted string. Constraints - The inputs provided to the `bitwise_xor` function will be `0` or `1`. # Example For `bitwise_xor`: ```python >>> bitwise_xor(0, 0) 0 >>> bitwise_xor(0, 1) 1 >>> bitwise_xor(1, 0) 1 >>> bitwise_xor(1, 1) 0 ``` For `xor_truth_table`: ```python >>> print(xor_truth_table(bitwise_xor)) Truth Table of XOR Gate: | Input 1 | Input 2 | Output | | 0 | 0 | 0 | | 0 | 1 | 1 | | 1 | 0 | 1 | | 1 | 1 | 0 | ``` # Implement the functions below: ```python def bitwise_xor(input_1: int, input_2: int) -> int: # Implement the XOR gate logic using bitwise operators return input_1 ^ input_2 def xor_truth_table(func: Callable) -> str: # Implement the truth table generation for XOR gate table = \\"Truth Table of XOR Gate:n\\" table += \\"| Input 1 | Input 2 | Output |n\\" for i in range(2): for j in range(2): output = func(i, j) table += f\\"| {i} | {j} | {output} |n\\" return table ```","solution":"def bitwise_xor(input_1: int, input_2: int) -> int: Simulates the XOR (Exclusive OR) operation using bitwise operators. Returns 1 if exactly one of the input is 1, otherwise returns 0. Parameters: - input_1 (int) : First input (0 or 1) - input_2 (int) : Second input (0 or 1) Returns: - int : Result of the XOR operation return input_1 ^ input_2 def xor_truth_table(func) -> str: Generates the truth table for the provided XOR function. Parameters: - func (Callable) : A function that takes two integer inputs and returns the XOR result Returns: - str : Truth table of the XOR gate as a formatted string table = \\"Truth Table of XOR Gate:n\\" table += \\"| Input 1 | Input 2 | Output |n\\" for i in range(2): for j in range(2): output = func(i, j) table += f\\"| {i} | {j} | {output} |n\\" return table"},{"question":"# Sudoku Solver Objective Design a `SudokuSolver` application that takes a partially completed Sudoku puzzle as input and returns the completed puzzle if a solution exists. Instructions 1. **Class Definition**: Write a class `SudokuSolver` that can: - Load a Sudoku puzzle from a given 9x9 grid. - Provide methods to solve the Sudoku puzzle using backtracking. - Return the completed puzzle grid if a solution is found or indicate no solution exists. 2. **Class Methods**: - `load_puzzle(puzzle: list[list[int]]) -> None`: Loads the Sudoku puzzle where `0` represents an empty cell. - `solve() -> bool`: Solves the Sudoku puzzle using backtracking and returns `True` if a solution is found, otherwise `False`. - `get_solution() -> list[list[int]]`: Returns the solved Sudoku grid. 3. **Validation**: - Ensure that the input grid is a 9x9 matrix with integers ranging from 0 to 9. - Check that no row, column, or 3x3 subgrid contains duplicated numbers from 1 to 9. # Example Here\'s an example of how your `SudokuSolver` can be used: ```python puzzle = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solver = SudokuSolver() solver.load_puzzle(puzzle) if solver.solve(): print(\\"Sudoku Solved!\\") solution = solver.get_solution() for row in solution: print(row) else: print(\\"No solution exists.\\") ``` Constraints - Assume the input grid will always be a valid 9x9 grid. - The puzzle will have at least one solvable solution. - When printing, ensure the digits in each row are space-separated for readability.","solution":"class SudokuSolver: def __init__(self): self.grid = None def load_puzzle(self, puzzle): if len(puzzle) != 9 or any(len(row) != 9 for row in puzzle): raise ValueError(\\"Puzzle must be a 9x9 grid.\\") self.grid = puzzle def solve(self): empty_pos = self.find_empty_location() if not empty_pos: return True # No empty position, puzzle is solved row, col = empty_pos for num in range(1, 10): if self.is_safe(row, col, num): self.grid[row][col] = num if self.solve(): return True self.grid[row][col] = 0 # Backtrack return False def find_empty_location(self): for i in range(9): for j in range(9): if self.grid[i][j] == 0: return (i, j) return None def is_safe(self, row, col, num): # Check row if any(self.grid[row][x] == num for x in range(9)): return False # Check column if any(self.grid[x][col] == num for x in range(9)): return False # Check 3x3 subgrid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if self.grid[i + start_row][j + start_col] == num: return False return True def get_solution(self): if not self.grid: raise ValueError(\\"No puzzle is loaded.\\") return self.grid"},{"question":"# Problem Statement You need to create a program that helps generate a username based on a user\'s full name and some additional constraints. Write a function `generate_username(full_name: str) -> str` that constructs a username from the user\'s full name by applying the following rules: 1. The username should be composed of: - The lowercase of the first letter of the first name. - The full last name in lowercase. - A random 3-digit number, which ensures that the username is unique for that session. 2. The function should handle names with multiple parts (e.g., middle names or compound last names) by only considering the first and the last parts of the name. E.g., \\"John Jacob Jingleheimer Schmidt\\" should produce a username based on \\"John Schmidt\\". 3. If the input is an empty string or does not contain a valid full name (at least a first and last name), the function should return `None`. # Function Signature ```python def generate_username(full_name: str) -> str: pass ``` # Input - **full_name**: A string representing the user\'s full name. This should be in the format \\"First Last\\" or \\"First Middle Last\\". # Output - Returns a string representing the generated username. # Constraints - The full name string should not be empty and must contain at least two parts (first and last names). - The random 3-digit number should range from 100 to 999. # Example ```python >>> generate_username(\\"Alice Smith\\") \'alicesmith453\' >>> generate_username(\\"John Jacob Jingleheimer Schmidt\\") \'johnschmidt211\' >>> generate_username(\\"\\") None >>> generate_username(\\"JustFirst\\") None ``` # Notes - The generated username should always follow the rules specified and ensure uniqueness within the constraints of a single function call. - Use Python\'s `random` module to generate the 3-digit random number.","solution":"import random def generate_username(full_name: str) -> str: Generates a username from the user\'s full name. Parameters: full_name (str): The user\'s full name. Returns: str: The generated username or None if input is invalid. if not full_name.strip(): return None name_parts = full_name.strip().split() if len(name_parts) < 2: return None first_name = name_parts[0].lower() last_name = name_parts[-1].lower() random_number = random.randint(100, 999) username = f\\"{first_name[0]}{last_name}{random_number}\\" return username"},{"question":"# Problem You are developing a simplified version of a text editor that includes a basic autocomplete feature. Your task is to implement a function that analyzes a given list of words and supports autocomplete suggestions based on a given prefix. # Function Signature ```python def autocomplete(dictionary: list[str], prefix: str) -> list[str]: ... ``` # Input * `dictionary`: A list of unique strings where each string\'s length is between 1 and 100 characters, and the list\'s length ( n ) is between 1 and ( 10^5 ). * `prefix`: A non-empty string with a length of up to 100 characters. # Output * Returns a list of all strings from the dictionary that start with the given prefix, sorted in lexicographical order. If no such strings exist, return an empty list. # Requirements/Constraints 1. Ensure the function efficiently handles large input sizes. 2. The solution should have an average-case time complexity better than ( O(n cdot m) ), where ( n ) is the number of words in the dictionary and ( m ) is the average length of the words. 3. Handle case sensitivity in a consistent manner, such as treating all words as lowercase or uppercase when performing comparisons. 4. Make sure the solution can handle edge cases like an empty dictionary or prefixes that are longer than any word in the dictionary. # Example ```python assert autocomplete([\\"apple\\", \\"ape\\", \\"april\\", \\"banana\\", \\"bat\\", \\"battle\\", \\"batman\\"], \\"ap\\") == [\\"ape\\", \\"apple\\", \\"april\\"] assert autocomplete([\\"flower\\", \\"flow\\", \\"flock\\", \\"fly\\"], \\"flo\\") == [\\"flock\\", \\"flow\\"] assert autocomplete([\\"dog\\", \\"cat\\", \\"car\\", \\"cart\\", \\"cap\\"], \\"car\\") == [\\"car\\", \\"cart\\"] assert autocomplete([\\"book\\", \\"boot\\", \\"boon\\", \\"board\\"], \\"boo\\") == [\\"boon\\", \\"boot\\"] assert autocomplete([], \\"pre\\") == [] ``` # Detailed Explanation 1. **Filter Words by Prefix**: Traverse through the dictionary and collect words that begin with the specified prefix. 2. **Ensure Case Insensitivity**: Optionally convert all words and the prefix to the same case before performing any operations. 3. **Sort the Results**: Sort the filtered list of words in lexicographical order to maintain a consistent output. By following this approach, you will implement an autocomplete feature that can efficiently handle large datasets and provide quick and accurate suggestions based on the given prefix.","solution":"def autocomplete(dictionary: list[str], prefix: str) -> list[str]: Returns a list of words from the dictionary that start with the given prefix. Parameters: dictionary (list of str): The list of words to search in. prefix (str): The prefix to search for. Returns: list of str: A sorted list of words that start with the given prefix. prefix = prefix.lower() result = [word for word in dictionary if word.lower().startswith(prefix)] return sorted(result)"},{"question":"# Question: Implement a Function for Finding Mode in a Data Stream Given a stream of integers, your task is to design a function that calculates and returns the mode (the most frequently occurring element) efficiently. The function should continuously update the mode as new integers are added to the stream. Objective Create a function that processes an incoming stream of integers and returns the mode of the numbers seen so far. Expected Input and Output * **Input (for each call to the function)**: An integer value. ```python int ``` * **Output**: The current mode as an integer. ```python int ``` Constraints * The integers in the stream will fit within the 32-bit signed integer range: [−2³¹, 2³¹ − 1]. * The stream can contain up to 100,000 integers over its lifetime. * If there is more than one mode, return the one that appeared first. * The function should be designed to handle up to 10,000 calls efficiently. Scenario Imagine you are working on a real-time data processing application where incoming data must be monitored for the most frequent values. Your function will be continuously called as new data comes in, making it essential to keep track of the mode dynamically. # Your Task: Write a Python class `ModeFinder` with the following methods: 1. `add_num(self, num: int) -> None`: This method will be called to insert a new number from the stream. 2. `find_mode(self) -> int`: This method will return the current mode of the stream. ```python class ModeFinder: def __init__(self): Initialize your data structure here. def add_num(self, num: int) -> None: Add a number into the data structure. :param num: The number to be added from the stream def find_mode(self) -> int: Return the mode of all numbers added so far. :return: The current mode ``` **Example**: ```python >>> mode_finder = ModeFinder() >>> mode_finder.add_num(1) >>> mode_finder.find_mode() 1 >>> mode_finder.add_num(2) >>> mode_finder.find_mode() 1 >>> mode_finder.add_num(2) >>> mode_finder.find_mode() 2 >>> mode_finder.add_num(3) >>> mode_finder.find_mode() 2 >>> mode_finder.add_num(3) >>> mode_finder.add_num(3) >>> mode_finder.find_mode() 3 ``` Note: - Efficiently track and update the mode to handle real-time data streams. - Avoid using extensive memory or inefficient computation methods to ensure performance.","solution":"from collections import defaultdict class ModeFinder: def __init__(self): self.num_count = defaultdict(int) self.max_frequency = 0 self.curr_mode = None def add_num(self, num: int) -> None: self.num_count[num] += 1 if self.num_count[num] > self.max_frequency: self.max_frequency = self.num_count[num] self.curr_mode = num elif self.num_count[num] == self.max_frequency: if self.curr_mode is None or num < self.curr_mode: self.curr_mode = num def find_mode(self) -> int: return self.curr_mode"},{"question":"# Save contact details to a Database **Context**: You are tasked with creating a function that saves a list of contact details to a database using Structured Query Language (SQL). Each contact contains essential information such as the name, phone number, email, and address. **Task**: Implement a function that takes a list of contacts and inserts each contact into a database. The database table named `Contacts` has the following schema: - `id` (INTEGER, Primary Key, Auto Increment) - `name` (TEXT, Not Null) - `phone` (TEXT, Not Null) - `email` (TEXT, Not Null) - `address` (TEXT, Not Null) **Function Signature**: ```python def save_contacts_to_db(db_connection: sqlite3.Connection, contacts: List[Dict[str, str]]) -> None: Save a list of contact details to the database. :param db_connection: An active connection object to the SQLite database. :param contacts: A list of dictionaries, each containing \'name\', \'phone\', \'email\', and \'address\' keys. :return: None ``` **Input**: * `db_connection` (sqlite3.Connection): An active SQLite database connection object. * `contacts` (list): A list of dictionaries where each dictionary contains the following keys: - \'name\' (str): The contact\'s name. - \'phone\' (str): The contact\'s phone number. - \'email\' (str): The contact\'s email address. - \'address\' (str): The contact\'s address. **Output**: * None **Constraints**: * The `db_connection` should be valid and connected to an SQLite database. * The `contacts` list can contain up to 10,000 contacts. * Each dictionary within the `contacts` list should have all the required keys (\'name\', \'phone\', \'email\', \'address\'). * Handle any SQLite exceptions appropriately. **Example**: ```python import sqlite3 # Example usage: # Initialize the database connection and create the table conn = sqlite3.connect(\':memory:\') cursor = conn.cursor() cursor.execute(\'\'\' CREATE TABLE Contacts ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, phone TEXT NOT NULL, email TEXT NOT NULL, address TEXT NOT NULL ) \'\'\') conn.commit() contacts_list = [ {\\"name\\": \\"John Doe\\", \\"phone\\": \\"123-456-7890\\", \\"email\\": \\"john.doe@example.com\\", \\"address\\": \\"123 Main St\\"}, {\\"name\\": \\"Jane Smith\\", \\"phone\\": \\"098-765-4321\\", \\"email\\": \\"jane.smith@example.com\\", \\"address\\": \\"456 Elm St\\"} ] save_contacts_to_db(conn, contacts_list) # Verifying the records cursor.execute(\\"SELECT id, name, phone, email, address FROM Contacts\\") for row in cursor.fetchall(): print(row) ``` Ensure to handle transactions effectively to maintain data integrity and roll back in case of errors.","solution":"import sqlite3 from typing import List, Dict def save_contacts_to_db(db_connection: sqlite3.Connection, contacts: List[Dict[str, str]]) -> None: Save a list of contact details to the database. :param db_connection: An active connection object to the SQLite database. :param contacts: A list of dictionaries, each containing \'name\', \'phone\', \'email\', and \'address\' keys. :return: None try: cursor = db_connection.cursor() for contact in contacts: cursor.execute(\'\'\' INSERT INTO Contacts (name, phone, email, address) VALUES (?, ?, ?, ?) \'\'\', (contact[\'name\'], contact[\'phone\'], contact[\'email\'], contact[\'address\'])) db_connection.commit() except sqlite3.DatabaseError as e: db_connection.rollback() raise e"},{"question":"# Coding Assessment Question Context You are given an m x n grid initialized with all zeros. You have to perform a sequence of operations on this grid. Each operation increments all values within a given subrectangle by 1. You are required to return the number of the largest integers in the grid after performing all operations. Objective Implement the function `max_count(m: int, n: int, operations: list[tuple[int, int]]) -> int` that returns the count of the largest integers in the grid after performing all given operations. Input/Output Format - **Input**: - An integer `m` representing the number of rows of the grid. - An integer `n` representing the number of columns of the grid. - A list of tuples, `operations`, where each tuple contains two integers `a` and `b` representing the top-left corner (0,0) to the (a-1, b-1) subrectangle to be incremented for each operation. - **Output**: - An integer representing the count of the largest integers in the grid after all operations are completed. Constraints - `1 <= m, n <= 4 * 10^4` - `0 <= len(operations) <= 10^4` - `1 <= a <= m` - `1 <= b <= n` Example ```python >>> max_count(3, 3, [(2, 2), (3, 3)]) 4 # The largest number in the grid appears in the four cells forming the 2x2 top-left subrectangle >>> max_count(3, 3, [(2, 2), (2, 2)]) 4 # Repeating the same operation doesn\'t affect, top-left 2x2 has the largest numbers >>> max_count(3, 3, []) 9 # With no operations, all values are the same zeroes throughout the grid >>> max_count(4, 4, [(1, 1)]) 1 # Only the top-left cell is incremented resulting to be the largest >>> max_count(5, 5, [(1, 2), (3, 3), (2, 2)]) 4 # The largest number appears in the four cells from subrectangle 2x2 within the top-left corner ``` Requirements 1. The function should handle edge cases such as repeated operations, no operations, and the maximum allowed size of inputs efficiently. 2. Ensure the solution executes optimally considering the grid size and the number of operations.","solution":"def max_count(m: int, n: int, operations: list[tuple[int, int]]) -> int: if not operations: return m * n min_a = m min_b = n for a, b in operations: if a < min_a: min_a = a if b < min_b: min_b = b return min_a * min_b"},{"question":"# Coding Question: Implement the Knapsack Problem with Memoization Given the classic 0/1 knapsack problem, write a function that utilizes memoization to determine the maximum value that can be achieved within a given weight limit. Implement the `knapsack` function. Function Signature ```python def knapsack(weights: list[int], values: list[int], W: int) -> int: pass ``` Inputs - `weights (list[int])`: A list of integers where `weights[i]` represents the weight of the i-th item. - `values (list[int])`: A list of integers where `values[i]` represents the value of the i-th item. - `W (int)`: An integer representing the maximum weight capacity of the knapsack. Outputs - Returns an integer representing the maximum value attainable with the given weight limit. Constraints - The length of `weights` and `values` is the same and is between 1 and 100 inclusive. - The elements in `weights` and `values` are between 1 and 1000 inclusive. - `W` is between 1 and 1000 inclusive. Implementation Details 1. Use dynamic programming with memoization to remember the subproblems and avoid redundant computations. 2. Consider each item to either include it in the knapsack or exclude it, and use a recursive approach to explore all possibilities. 3. Store the results of subproblems to optimize the calculation. Example ```python def knapsack(weights: list[int], values: list[int], W: int) -> int: # Implement the knapsack problem with memoization pass # Example Test Case weights = [2, 3, 4, 5] values = [3, 4, 5, 6] W = 5 print(knapsack(weights, values, W)) # Output: 7 ``` Hints 1. Use a dictionary to memoize the results of subproblems. 2. Create a recursive helper function within `knapsack` to handle the logic of including or excluding items. 3. Remember that for item `i` with weight `w_i` and value `v_i`, the decision is to either take `i` (if `i` fits into the remaining capacity) or to skip `i`. This question matches the complexity and scope of the given example, exploring dynamic programming techniques and ensuring a clear understanding of recursion and memoization in solving combinatorial problems like the knapsack problem.","solution":"def knapsack(weights, values, W): Determine the maximum value that fits into the knapsack with capacity W using memoization. :param weights: List of weights of items. :param values: List of values of items. :param W: Maximum weight capacity. :return: Maximum value achievable. memo = {} def helper(i, remaining_weight): # Base case: no items left or no remaining capacity if i == len(weights) or remaining_weight == 0: return 0 # Check if result already computed if (i, remaining_weight) in memo: return memo[(i, remaining_weight)] # Option 1: Exclude the current item max_value = helper(i + 1, remaining_weight) # Option 2: Include the current item (if it does not exceed the remaining capacity) if weights[i] <= remaining_weight: max_value = max(max_value, values[i] + helper(i + 1, remaining_weight - weights[i])) # Save the result in memo dictionary memo[(i, remaining_weight)] = max_value return max_value return helper(0, W)"},{"question":"Data Normalization for Machine Learning Data normalization is a crucial step in preparing data for machine learning models. One common method is Min-Max normalization, which scales the data to a specified range [0, 1]. Your task is to write a Python function that normalizes a given 1-D numpy array using Min-Max normalization. # Function Specifications 1. **Function Name**: `min_max_normalize` 2. **Parameters**: - `input_vector` (np.ndarray): A 1-D numpy array of real numbers. 3. **Returns**: - A 1-D numpy array with the same shape as `input_vector` where each element is normalized to the range [0, 1]. 4. **Constraints**: - All elements of `input_vector` will be real numbers. - The function should handle large vectors (up to size 10^6) efficiently in both time and space. 5. **Performance Requirement**: - The implementation should run in linear time relative to the size of the input vector. - Handle edge cases where the input vector has constant values, to avoid division by zero error. # Examples ```python import numpy as np example_vector = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) result = min_max_normalize(example_vector) print(result) # Expected Output: array([0.0, 0.25, 0.5, 0.75, 1.0]) ``` # Implementation Details Include the necessary imports and define the `min_max_normalize` function. Make sure to handle any potential edge cases such as an input vector with a single unique value. ```python import numpy as np def min_max_normalize(input_vector: np.ndarray) -> np.ndarray: Parameters: input_vector (np.ndarray): A numpy array consisting of real values Returns: norm_vector (np.ndarray): The input numpy array, normalized to the range [0, 1] min_val = np.min(input_vector) max_val = np.max(input_vector) # Edge case: if all values are the same, return a vector of zeros if min_val == max_val: return np.zeros_like(input_vector) norm_vector = (input_vector - min_val) / (max_val - min_val) return norm_vector # Example usage example_vector = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) print(min_max_normalize(example_vector)) # Output: array([0.0, 0.25, 0.5, 0.75, 1.0]) ``` Implement and test your function thoroughly to ensure it handles large inputs efficiently and correctly normalizes the input vector.","solution":"import numpy as np def min_max_normalize(input_vector: np.ndarray) -> np.ndarray: Parameters: input_vector (np.ndarray): A numpy array consisting of real values Returns: norm_vector (np.ndarray): The input numpy array, normalized to the range [0, 1] min_val = np.min(input_vector) max_val = np.max(input_vector) # Edge case: if all values are the same, return a vector of zeros if min_val == max_val: return np.zeros_like(input_vector) norm_vector = (input_vector - min_val) / (max_val - min_val) return norm_vector"},{"question":"# Task: You are asked to create a function to validate a Complex Password based on given criteria. Your task is to implement a function that determines if a given password meets all the specified requirements. # Function Specification: ```python def is_valid_password(password: str) -> bool: Validates the given password to check if it meets the specified complexity requirements. Parameters: password (str): The password to validate. Returns: bool: True if the password is valid, False otherwise. Examples: >>> is_valid_password(\'P@ssw0rd!\') True >>> is_valid_password(\'password\') False >>> is_valid_password(\'P@ssw0rd\') True >>> is_valid_password(\'P@ss!\') False >>> is_valid_password(\'P0ro!\') False # Your code here ``` # Requirements: 1. **Input**: - A non-empty password string. 2. **Output**: - A boolean indicating whether the password is valid. 3. **Constraints**: - The password must be at least 8 characters long. - The password must contain at least one uppercase letter. - The password must contain at least one lowercase letter. - The password must contain at least one digit. - The password must contain at least one special character (e.g., !, @, #, , %, etc.). 4. **Error Handling**: - Raise an appropriate error if the password does not meet the minimum requirements. # Scenario: In today\'s digital age, ensuring secure authentication through strong passwords has become a fundamental necessity. Your function will be used in a user registration system to validate that user passwords are complex enough to resist common attack vectors such as brute force or dictionary attacks. # Hint: Utilize Python\'s built-in string methods and regular expressions to check the complexity of the password efficiently.","solution":"import re def is_valid_password(password: str) -> bool: Validates the given password to check if it meets the specified complexity requirements. Parameters: password (str): The password to validate. Returns: bool: True if the password is valid, False otherwise. if len(password) < 8: return False if not re.search(r\'[A-Z]\', password): return False if not re.search(r\'[a-z]\', password): return False if not re.search(r\'d\', password): return False if not re.search(r\'[!@#%^&*(),.?\\":{}|<>]\', password): return False return True"},{"question":"# Scenario You are developing a weather prediction application, and one of its core features is to analyze temperature data. Specifically, you need to compute the average temperature for specific ranges of days. Your task is to write a function that can quickly compute these average temperatures given an array of daily temperatures and multiple range queries. # Task Implement a function `average_temperature` that calculates the average temperature for each given range of days. # Function Signature ```python def average_temperature(temperatures: List[float], queries: List[Tuple[int, int]]) -> List[float]: Computes the average temperature for given ranges of days. :param temperatures: List of floats, each representing the temperature on a specific day. :param queries: List of tuples, each containing two integers indicating the start and end day of the range (inclusive). :return: List of floats, each being the average temperature for the corresponding range. pass ``` # Input - A list of floats, `temperatures`, where each element represents the temperature on a specific day. - A list of tuples, `queries`, where each tuple contains two integers `start` and `end` (inclusive), representing the range of days for which the average temperature needs to be calculated. # Output - A list of floats, each representing the average temperature for the corresponding range of days in the queries. # Constraints - The length of the `temperatures` list will be at most (10^5). - There will be at most (10^4) queries. - Each value in the `temperatures` list is a valid float. - The start and end values in each query will be valid indices within the `temperatures` list. - The average temperature should be rounded to two decimal places. # Examples Example 1: ```python temperatures = [32.0, 31.5, 30.0, 29.5, 28.0, 27.5] queries = [(0, 2), (1, 4), (3, 5)] print(average_temperature(temperatures, queries)) # Output: [31.17, 29.75, 28.33] ``` Example 2: ```python temperatures = [22.5, 23.0, 24.0, 25.0, 26.5] queries = [(0, 4), (1, 2)] print(average_temperature(temperatures, queries)) # Output: [24.2, 23.5] ``` # Additional Requirements - Your solution should handle up to (10^4) queries efficiently. - Preprocessing the temperature data to facilitate quick query responses is encouraged.","solution":"from typing import List, Tuple def average_temperature(temperatures: List[float], queries: List[Tuple[int, int]]) -> List[float]: Computes the average temperature for given ranges of days. :param temperatures: List of floats, each representing the temperature on a specific day. :param queries: List of tuples, each containing two integers indicating the start and end day of the range (inclusive). :return: List of floats, each being the average temperature for the corresponding range. # Precompute prefix sums for quick range sum calculations prefix_sums = [0] * (len(temperatures) + 1) for i, temp in enumerate(temperatures): prefix_sums[i + 1] = prefix_sums[i] + temp # Compute the average temperature for each query result = [] for start, end in queries: total_sum = prefix_sums[end + 1] - prefix_sums[start] count = end - start + 1 average = total_sum / count result.append(round(average, 2)) return result"},{"question":"# Integer to Roman Numerals and Vice Versa You are required to write two functions to handle conversions between integers and Roman numerals. The first function should convert a given integer (within a specific range) to its corresponding Roman numeral. The second function should perform the inverse operation, converting a given Roman numeral back to its integer form. Roman numerals are represented by the following symbols: - `I` -> 1 - `V` -> 5 - `X` -> 10 - `L` -> 50 - `C` -> 100 - `D` -> 500 - `M` -> 1000 The rules for forming Roman numerals are as follows: 1. **Basic symbols**: The basic symbols are written as many times as necessary (usually up to three). For example, `III` represents 3. 2. **Subtractive notation**: Smaller symbols placed before larger ones indicate subtraction. For example, `IV` represents 4. 3. **Additive notation**: Symbols placed after larger or equal symbols indicate addition. For example, `VI` represents 6. # Function Signatures ```python def int_to_roman(num: int) -> str: pass def roman_to_int(roman: str) -> int: pass ``` # Input for `int_to_roman` - `num` (integer): The integer to convert to a Roman numeral. Valid range is from 1 to 3999. # Output for `int_to_roman` - Returns a string representing the Roman numeral. # Input for `roman_to_int` - `roman` (string): The Roman numeral to convert to an integer. The input Roman numeral is guaranteed to be a valid representation and within the range of 1 to 3999. # Output for `roman_to_int` - Returns an integer representing the value of the Roman numeral. # Constraints - Assume inputs will always be within the valid range. - Roman numerals will always be in upper-case and valid format. # Example ```python print(int_to_roman(58)) # Output: \\"LVIII\\" print(roman_to_int(\\"MCMXCIV\\")) # Output: 1994 ``` # Notes - Handle edge cases such as the extremes of the range (1 and 3999). - Ensure your solution is efficient and handles conversions correctly without unnecessary complexity. # Implementation Implement the functions so that they correctly convert integers to Roman numerals and vice versa, adhering to the rules and constraints specified.","solution":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. value_map = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] roman_numeral = [] for value, symbol in value_map: while num >= value: roman_numeral.append(symbol) num -= value return \'\'.join(roman_numeral) def roman_to_int(roman: str) -> int: Convert a Roman numeral to an integer. roman_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } integer_value = 0 prev_value = 0 for char in reversed(roman): value = roman_map[char] if value < prev_value: integer_value -= value else: integer_value += value prev_value = value return integer_value"},{"question":"# Question Develop an automated report generator for a student grading system. The system should process a file containing student names and their respective grades, compute the overall average grade, and categorize students based on their performance. Your task is to implement the function `generate_grade_report` that processes the input file and generates a report with the students categorized into \\"Excellent\\", \\"Good\\", \\"Average\\", and \\"Poor\\" performance bands based on their grades. **Function Signature:** ```python def generate_grade_report(file_path: str) -> dict: pass ``` # Input: - `file_path` (str): A string representing the path to a comma-separated value (CSV) file. Each line contains a student\'s name and grade, separated by a comma. Grades are integers between 0 and 100. # Output: - Returns a dictionary with four keys: \\"Excellent\\", \\"Good\\", \\"Average\\", and \\"Poor\\". Each key maps to a list of student names who fall into that performance category. # Performance Categories: - \\"Excellent\\": 90 <= grade <= 100 - \\"Good\\": 75 <= grade < 90 - \\"Average\\": 50 <= grade < 75 - \\"Poor\\": grade < 50 # Example: Given the following CSV file content: **grades.csv**: ``` John Doe,82 Jane Smith,95 Sam Brown,67 Emily Davis,43 ``` ```python # Example Usage: file_path = \'grades.csv\' report = generate_grade_report(file_path) print(report) # Output: # { # \\"Excellent\\": [\\"Jane Smith\\"], # \\"Good\\": [\\"John Doe\\"], # \\"Average\\": [\\"Sam Brown\\"], # \\"Poor\\": [\\"Emily Davis\\"] # } ```","solution":"import csv def generate_grade_report(file_path: str) -> dict: # Initialize the report dictionary with empty lists for each category report = { \\"Excellent\\": [], \\"Good\\": [], \\"Average\\": [], \\"Poor\\": [] } # Open and read the CSV file with open(file_path, mode=\'r\') as file: reader = csv.reader(file) # Iterate over each row in the CSV file for row in reader: name, grade = row[0], int(row[1]) # Categorize based on the grade if 90 <= grade <= 100: report[\\"Excellent\\"].append(name) elif 75 <= grade < 90: report[\\"Good\\"].append(name) elif 50 <= grade < 75: report[\\"Average\\"].append(name) else: report[\\"Poor\\"].append(name) return report"},{"question":"# Data Transformation with Pandas You are given a CSV file of sales data containing columns: `Date`, `Product`, `Quantity`, and `Price`. Your task is to write a function that reads this CSV file and performs the following transformations: 1. Convert the `Date` column to datetime format. 2. Add a new column `Total` which is the product of `Quantity` and `Price`. 3. Group the data by `Product` and aggregate the total sales and total quantity sold per product. 4. Sort the resulting DataFrame by the total sales in descending order. # Function Signature ```python def transform_sales_data(csv_file_path: str) -> pd.DataFrame: Transform the sales data from the given CSV file. Args: csv_file_path (str): The file path of the CSV containing the sales data. Returns: pd.DataFrame: A DataFrame with aggregated sales data after transformations. ``` # Requirements 1. **Input**: - `csv_file_path` (str): The file path to the CSV file with sales data. 2. **Output**: - A Pandas DataFrame containing the aggregated and sorted sales data with columns: * `Product` (str): The product name. * `Total_Sales` (float): The total sales for the product. * `Total_Quantity` (int): The total quantity sold for the product. # Instructions 1. Use the `pandas` library to read the CSV file. 2. Convert the `Date` column to datetime format. 3. Create a new column `Total` which is `Quantity` * `Price`. 4. Group the DataFrame by `Product`, and get the sum of `Total` and `Quantity` columns. 5. Rename the aggregated columns to `Total_Sales` and `Total_Quantity` respectively. 6. Sort the DataFrame by `Total_Sales` in descending order. 7. Return the resulting DataFrame. # Constraints - Assume the CSV file is well-formed with no missing values. - Everyone understands basic data manipulation with Pandas. # Example ```python # Sample sales data # Date,Product,Quantity,Price # 2022-01-01,Widget,10,2.50 # 2022-01-02,Gadget,5,3.00 # 2022-01-03,Widget,7,2.50 # 2022-01-04,Gadget,3,3.00 # 2022-01-05,Widget,5,2.50 # 2022-01-06,Gizmo,8,4.00 >>> transform_sales_data(\\"sales_data.csv\\") Product Total_Sales Total_Quantity 0 Widget 55.0 22 1 Gizmo 32.0 8 2 Gadget 24.0 8 ``` Ensure your solution handles standard edge cases and performs necessary error handling. # Performance Considerations - Optimize memory usage when reading large files. - Ensure the function executes efficiently for datasets up to 100,000 rows.","solution":"import pandas as pd def transform_sales_data(csv_file_path: str) -> pd.DataFrame: Transform the sales data from the given CSV file. Args: csv_file_path (str): The file path of the CSV containing the sales data. Returns: pd.DataFrame: A DataFrame with aggregated sales data after transformations. # Read the CSV file df = pd.read_csv(csv_file_path) # Convert the `Date` column to datetime format df[\'Date\'] = pd.to_datetime(df[\'Date\']) # Add a new column `Total` which is the product of `Quantity` and `Price` df[\'Total\'] = df[\'Quantity\'] * df[\'Price\'] # Group the data by `Product` and aggregate total sales and quantity sold per product aggregated_df = df.groupby(\'Product\').agg({ \'Total\': \'sum\', \'Quantity\': \'sum\' }).reset_index() # Rename the columns appropriately aggregated_df.columns = [\'Product\', \'Total_Sales\', \'Total_Quantity\'] # Sort the resulting DataFrame by the total sales in descending order sorted_df = aggregated_df.sort_values(by=\'Total_Sales\', ascending=False).reset_index(drop=True) return sorted_df"},{"question":"# Scenario You have been hired by a tech company to develop a utility that helps synchronize two lists by removing elements that do not appear in both lists. The purpose of this utility is to ensure that both lists contain only the common elements, ultimately leading to better data consistency across various modules. # Task Implement the function `synchronize_lists`, which removes elements that are not found in both input lists and retains those that are common to both. # Requirements 1. **Function Signature**: ```python def synchronize_lists(list_a: list, list_b: list) -> tuple[list, list]: pass ``` 2. **Parameters**: - `list_a` (list): The first list of elements. - `list_b` (list): The second list of elements. 3. **Returns**: - (tuple[list, list]): A tuple containing two lists, each containing only the elements common to both `list_a` and `list_b`, and in the same order as they were in the original lists. 4. **Constraints**: - The lists `list_a` and `list_b` can contain elements of any data type. - The order of elements within each list’s result should reflect the original order as much as possible, retaining their first occurrence. - The function should handle cases with empty lists gracefully. - Avoid using set operations to retain the order of elements as per requirements. # Examples ```python >>> synchronize_lists([1, 2, 3, 4], [3, 4, 5, 6]) ([3, 4], [3, 4]) >>> synchronize_lists([\'apple\', \'banana\', \'grape\'], [\'banana\', \'orange\', \'grape\']) ([\'banana\', \'grape\'], [\'banana\', \'grape\']) >>> synchronize_lists([], [1, 2, 3]) ([], []) ``` # Additional Notes Consider edge cases such as: - Lists containing no common elements. - One or both lists being empty. - Duplicates within the same list. - Lists containing elements of different data types.","solution":"def synchronize_lists(list_a: list, list_b: list) -> tuple[list, list]: Returns a tuple of two lists, each containing only the elements common to both list_a and list_b, and in the same order as they were in the original lists. common_set = set(list_a).intersection(set(list_b)) common_a = [item for item in list_a if item in common_set] common_b = [item for item in list_b if item in common_set] return common_a, common_b"},{"question":"# Task Implement a function that rotates the elements of an array to the right by a given number of steps. # Requirements Write a function `rotate_array` that takes an array of integers and a non-negative integer k, and returns the array after rotating it to the right by k steps. # Inputs: - An array of integers `arr`. - A non-negative integer `k` representing the number of steps to rotate the array. # Outputs: - The array after rotating it to the right by `k` steps. # Constraints: 1. The array can contain up to 10^5 elements. 2. Each element in the array is a 32-bit signed integer. 3. The non-negative integer `k` can be as large as 10^5. # Example ```python def rotate_array(arr, k): Rotate the elements of the array to the right by k steps. Parameters: arr (List[int]): The array of integers to be rotated. k (int): The number of steps to rotate the array by. Returns: List[int]: The array after rotation. Examples: >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([10, 20, 30, 40, 50], 3) [30, 40, 50, 10, 20] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 7) [1, 2, 3, 4, 5, 6, 7] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] pass # Test cases assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3], \\"Test case 1 failed\\" assert rotate_array([10, 20, 30, 40, 50], 3) == [30, 40, 50, 10, 20], \\"Test case 2 failed\\" assert rotate_array([1, 2, 3, 4, 5, 6, 7], 7) == [1, 2, 3, 4, 5, 6, 7], \\"Test case 3 failed\\" assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5], \\"Test case 4 failed\\" assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5], \\"Test case 5 failed\\" print(\\"All test cases pass!\\") ``` Write the function `rotate_array` based on the above description and make sure it passes the provided test cases.","solution":"def rotate_array(arr, k): Rotate the elements of the array to the right by k steps. Parameters: arr (List[int]): The array of integers to be rotated. k (int): The number of steps to rotate the array by. Returns: List[int]: The array after rotation. n = len(arr) if n == 0: return arr k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"# Question: Implement Efficient Fibonacci Sequence Calculation Context You are tasked with enhancing the given Fibonacci sequence generation function to support efficiency improvements and edge case handling. The original function generates the nth Fibonacci number using a straightforward recursive approach, which is inefficient for large values of n. Problem Statement Implement an enhanced version of the `fibonacci` function that ensures better efficiency, particularly for larger input sizes. Your function should optimize the calculation to handle higher values without significant performance degradation. # Function Signature ```python def optimized_fibonacci(n: int) -> int: Calculate the nth Fibonacci number efficiently. Parameters: - n (int): The position in the Fibonacci sequence (≥ 0). Returns: - int: The nth Fibonacci number. Raises: - ValueError: If the input `n` is negative. ``` # Constraints - `n ≥ 0` - Your solution should handle up to 50 efficiently. # Requirements 1. Validate all inputs as per specified constraints. 2. Implement an optimized approach to compute the nth Fibonacci number. 3. Ensure the solution works within reasonable time and space limits, particularly for larger values of n. # Examples ```python >>> optimized_fibonacci(5) 5 >>> optimized_fibonacci(10) 55 >>> optimized_fibonacci(0) 0 >>> optimized_fibonacci(1) 1 ```","solution":"def optimized_fibonacci(n: int) -> int: Calculate the nth Fibonacci number efficiently. Parameters: - n (int): The position in the Fibonacci sequence (≥ 0). Returns: - int: The nth Fibonacci number. Raises: - ValueError: If the input `n` is negative. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Coding Assessment Question: You are tasked with implementing a `FutureQueue` - a specialized queue where each element is associated with a timestamp and can only be dequeued when its timestamp has elapsed based on the current system time. **Requirements**: - Your solution should ensure that elements can only be dequeued in the order of their timestamps. - The enqueue operation should add an element along with its timestamp. - The `dequeue` and `peek` operations should return the element only if its timestamp is less than or equal to the current time. **Function Specifications**: - **enqueue(item: int, timestamp: float) -> None**: Adds an element to the queue with the associated timestamp. - **dequeue(current_time: float) -> int**: Removes and returns the front element of the queue if its timestamp is less than or equal to `current_time`. Raises an `IndexError` if the queue is empty or no elements\' timestamps have elapsed. - **peek(current_time: float) -> int | None**: Returns the front element of the queue without removing it if its timestamp is less than or equal to `current_time`. Returns `None` if the queue is empty or no elements\' timestamps have elapsed. **Constraints**: - The maximum number of elements `n` in the queue won\'t exceed (10^5). - The timestamps will be floats representing seconds since the epoch. - Ensure that all operations handle edge scenarios gracefully, such as attempting to dequeue from an empty queue or when no elements\' timestamps match the criteria. **Example**: ```python >>> queue = FutureQueue() >>> queue.enqueue(10, 1633036800.0) >>> queue.enqueue(20, 1633123200.0) >>> queue.peek(1633036799.0) is None True >>> queue.peek(1633036800.0) 10 >>> queue.dequeue(1633036800.0) 10 >>> queue.peek(1633036800.0) is None True >>> queue.peek(1633123200.0) 20 >>> queue.dequeue(1633123200.0) 20 >>> queue.peek(1633123200.0) is None True >>> queue.dequeue(1633123200.0) Traceback (most recent call last): ... IndexError: dequeue from the FutureQueue with no elapsed elements ``` You are encouraged to consider edge cases and ensure that your implementation is both correct and efficient, adhering to the functional constraints outlined.","solution":"import heapq from typing import List, Tuple class FutureQueue: def __init__(self): self.queue: List[Tuple[float, int]] = [] def enqueue(self, item: int, timestamp: float) -> None: Adds an element to the queue with the associated timestamp. heapq.heappush(self.queue, (timestamp, item)) def dequeue(self, current_time: float) -> int: Removes and returns the front element of the queue if its timestamp is less than or equal to current_time. Raises an IndexError if the queue is empty or no elements\' timestamps have elapsed. if not self.queue or self.queue[0][0] > current_time: raise IndexError(\\"dequeue from the FutureQueue with no elapsed elements\\") return heapq.heappop(self.queue)[1] def peek(self, current_time: float) -> int: Returns the front element of the queue without removing it if its timestamp is less than or equal to current_time. Returns None if the queue is empty or no elements\' timestamps have elapsed. if self.queue and self.queue[0][0] <= current_time: return self.queue[0][1] return None"},{"question":"# Coding Assessment Question **Problem Statement:** Implement a basic version of the QuickSort algorithm to sort an array of floats in ascending order. You need to partition the array based on a pivot element and recursively sort the subarrays. **Function Signature:** ```python def quick_sort(arr: List[float]) -> List[float]: pass ``` **Input:** * `arr`: A list of floats representing the array to be sorted. **Output:** * A list of floats sorted in ascending order. **Constraints:** * The input list will have a length up to (10^3). * The floats can be both positive and negative. **Example:** ```python arr = [3.1, 2.4, -1.5, 0.2, 5.2, -3.7] print(quick_sort(arr)) # Expected Output: [-3.7, -1.5, 0.2, 2.4, 3.1, 5.2] ``` **Explanation:** The function should implement the QuickSort algorithm and return the sorted version of the input list. **Notes:** * Select the pivot element from the end of the array for simplicity. * Ensure the function handles an empty list appropriately. * Use a helper function if necessary to manage the recursion and partitioning. * Aim for an average-case time complexity of (O(n log n)).","solution":"from typing import List def quick_sort(arr: List[float]) -> List[float]: Sorts the list of floats using QuickSort algorithm and returns the sorted list. if len(arr) <= 1: return arr pivot = arr[-1] less_than_pivot = [x for x in arr[:-1] if x <= pivot] greater_than_pivot = [x for x in arr[:-1] if x > pivot] return quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot)"},{"question":"# Algorithmic Tweet Classification **Scenario**: You are developing a social media analytics tool that classifies tweets into different categories such as \\"Sports\\", \\"Politics\\", \\"Entertainment\\", and \\"Technology\\". To automate this process, you decide to create a Naive Bayes Classifier using term frequency-inverse document frequency (TF-IDF) features extracted from the tweets. Implement a function in Python that fits a Naive Bayes Classifier using TF-IDF features and then classifies a new tweet into one of the predefined categories. # Function Signature ```python def tweet_classifier(train_tweets: List[str], train_labels: List[str], new_tweet: str) -> str: pass ``` # Input 1. `train_tweets` (List[str]): A list of M training tweets. 2. `train_labels` (List[str]): A list of M training labels corresponding to each tweet. The labels will be one of [\\"Sports\\", \\"Politics\\", \\"Entertainment\\", \\"Technology\\"]. 3. `new_tweet` (str): A single tweet that needs to be classified. # Output - `str`: The predicted category for the new tweet, which is one of [\\"Sports\\", \\"Politics\\", \\"Entertainment\\", \\"Technology\\"]. # Constraints - The function should handle a reasonable number of tweets (e.g., M up to 10,000). - Ensure robust handling of cases where tweets may contain special characters, links, or hashtags. # Performance Requirements - The classifier should train and classify efficiently, using TF-IDF features to transform the text data. - The classification should provide results within a reasonable time frame for real-time applications. # Examples ```python train_tweets = [ \\"The football match was exciting and full of surprises!\\", \\"New policies in healthcare discussed by the governor.\\", \\"Check out the latest movie, it is a blockbuster hit!\\", \\"Advancements in AI technology are revolutionizing industries.\\" ] train_labels = [\\"Sports\\", \\"Politics\\", \\"Entertainment\\", \\"Technology\\"] new_tweet = \\"The basketball season is in full swing with intense games every night.\\" predicted_category = tweet_classifier(train_tweets, train_labels, new_tweet) # Expected Output: \\"Sports\\" new_tweet = \\"The election results are being announced tonight.\\" predicted_category = tweet_classifier(train_tweets, train_labels, new_tweet) # Expected Output: \\"Politics\\" ``` Write a function `tweet_classifier` following the provided function signature and satisfy the requirements outlined.","solution":"from typing import List from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB def tweet_classifier(train_tweets: List[str], train_labels: List[str], new_tweet: str) -> str: Fits a Naive Bayes Classifier using TF-IDF features from training tweets and classifies a new tweet into one of the predefined categories: \\"Sports\\", \\"Politics\\", \\"Entertainment\\", \\"Technology\\". Args: train_tweets (List[str]): A list of M training tweets. train_labels (List[str]): A list of M training labels corresponding to each tweet. new_tweet (str): A single tweet that needs to be classified. Returns: str: The predicted category for the new tweet. # Create the TF-IDF vectorizer vectorizer = TfidfVectorizer() # Transform the training tweets into TF-IDF features X_train_tfidf = vectorizer.fit_transform(train_tweets) # Initialize the Naive Bayes classifier classifier = MultinomialNB() # Fit the classifier with the training data classifier.fit(X_train_tfidf, train_labels) # Transform the new tweet into TF-IDF features X_new_tweet_tfidf = vectorizer.transform([new_tweet]) # Predict the category of the new tweet predicted_category = classifier.predict(X_new_tweet_tfidf)[0] return predicted_category"},{"question":"Task: Implement a Cache Lookup System Context In many real-world applications, you often have to lookup values from a cache to improve performance. To simulate this, you are going to implement a simple Least Recently Used (LRU) cache system. Task Write a Python class `LRUCache` that simulates a cache with a fixed capacity and uses the Least Recently Used (LRU) eviction policy. The cache should store key-value pairs and support the following operations: - `get(key)`: Retrieve the value associated with `key`. If the `key` is not found, return `-1`. - `put(key, value)`: Insert or update the value associated with `key`. If the cache reaches its capacity, it should invalidate the least recently used item before inserting the new item. Requirements 1. **Input**: * `capacity` (int): The maximum number of items the cache can hold. 2. **Methods**: * `get(key: int) -> int`: Returns the value associated with the key, or `-1` if the key is not in the cache. * `put(key: int, value: int) -> None`: Inserts the value if the key doesn\'t exist; if it exists, update the value. 3. **Constraints**: * The `get` and `put` operations must run in O(1) time complexity. * The cache must be implemented using a combination of a dictionary (for fast lookups) and a doubly linked list (for efficient update of usage order). **Class Signature**: ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` Example ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Outputs: 1 cache.put(3, 3) # Evicts key 2 print(cache.get(2)) # Outputs: -1 cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Outputs: -1 print(cache.get(3)) # Outputs: 3 print(cache.get(4)) # Outputs: 4 ``` Notes * Use a doubly linked list to keep track of the LRU order efficiently. * The dictionary should map keys to nodes in the doubly linked list for O(1) access. * Handle edge cases such as tries to get or put when the cache is empty or full. * Ensure the `get` operation moves the accessed item to the front of the LRU list to maintain its status as the most recently used item. This problem tests your understanding of data structures, particularly how to achieve efficient lookup and update operations using a combination of data structures.","solution":"class Node: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node() # Dummy head self.tail = Node() # Dummy tail self.head.next = self.tail self.tail.prev = self.head def _add_node(self, node): Add new node right after head. node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _remove_node(self, node): Remove an existing node from the linked list. prev = node.prev new = node.next prev.next = new new.prev = prev def _move_to_head(self, node): Move certain node to the head (most recent). self._remove_node(node) self._add_node(node) def _pop_tail(self): Pop the current tail node (least recent). res = self.tail.prev self._remove_node(res) return res def get(self, key: int) -> int: node = self.cache.get(key) if not node: return -1 # Move the accessed node to the head self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if not node: new_node = Node(key, value) self.cache[key] = new_node self._add_node(new_node) if len(self.cache) > self.capacity: # Pop the tail tail = self._pop_tail() del self.cache[tail.key] else: node.value = value self._move_to_head(node)"},{"question":"Coding Assessment Question **Scenario**: Your organization is developing a software solution that involves working with a large set of records. To optimize data storage and ensure quick retrieval, it is essential to identify the longest subsequence that appears in at least two sets of ordered records. # Task Implement a function `longest_common_subsequence` that takes two strings representing ordered sets of records and returns the longest common subsequence (LCS) of characters. Both input strings may consist of uppercase letters and digits only. # Specifications 1. **longest_common_subsequence**: * **Input**: - `record1` (str): The first string of records. - `record2` (str): The second string of records. * **Output**: - The longest common subsequence as a string. * **Constraints**: - The length of `record1` and `record2` will not exceed 1000 characters. # Implementation Write your solution in Python. The overall time complexity should be O(n * m), where `n` is the length of `record1` and `m` is the length of `record2`. # Example Usage ```python print(longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABA\\")) # Output: \\"BCBA\\" print(longest_common_subsequence(\\"12345\\", \\"54321\\")) # Output: \\"5\\" print(longest_common_subsequence(\\"XMJYAUZ\\", \\"MZJAWXU\\")) # Output: \\"MJAU\\" ``` **Note**: If there are multiple possible longest common subsequences, return any one of them. # Explanation - The function `longest_common_subsequence` computes the longest common subsequence of characters that appears in both input strings. - For instance, in the example `\\"ABCBDAB\\"` and `\\"BDCABA\\"`, the longest common subsequence is `\\"BCBA\\"`. The implementation of the dynamic programming approach to solve for the longest common subsequence should be efficient and able to handle the given constraints.","solution":"def longest_common_subsequence(record1, record2): Returns the longest common subsequence of characters between two strings. n = len(record1) m = len(record2) # Create a 2D array to store lengths of longest common subsequence. lcs = [[0] * (m + 1) for _ in range(n + 1)] # Build the lcs array in a bottom-up fashion. for i in range(1, n + 1): for j in range(1, m + 1): if record1[i - 1] == record2[j - 1]: lcs[i][j] = lcs[i - 1][j - 1] + 1 else: lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1]) # Following code is used to print LCS index = lcs[n][m] # Create a character array to store the lcs string lcs_string = [\\"\\"] * index # Start from the right-most-bottom-most corner and # one by one store characters in lcs_string i = n j = m while i > 0 and j > 0: # If current character in record1 and record2 are same, then # current character is part of LCS if record1[i - 1] == record2[j - 1]: lcs_string[index - 1] = record1[i - 1] i -= 1 j -= 1 index -= 1 # If not same, then find the larger of two and move in # the direction of larger value elif lcs[i - 1][j] > lcs[i][j - 1]: i -= 1 else: j -= 1 return \'\'.join(lcs_string)"},{"question":"# Coding Challenge: Task Manager Implementation Objective Develop a simple Task Manager that supports the following functionalities: 1. **Add Task**: Allow adding a new task with a unique identifier, description, and due date. 2. **Delete Task**: Enable deleting a task by its unique identifier. 3. **Update Task**: Provide the ability to update the description and due date of an existing task. 4. **List All Tasks**: List all tasks showing their identifiers, descriptions, and due dates. 5. **Sort Tasks by Due Date**: Implement sorting of tasks based on their due dates in ascending order. Function Signatures 1. **Add Task**: ```python def add_task(task_id: int, description: str, due_date: str) -> None: Adds a new task to the task manager. Parameters: task_id: int - The unique identifier for the task. description: str - The description of the task. due_date: str - The due date of the task in \'YYYY-MM-DD\' format. Returns: None ``` 2. **Delete Task**: ```python def delete_task(task_id: int) -> None: Deletes a task from the task manager. Parameters: task_id: int - The unique identifier for the task to be deleted. Returns: None Raises: ValueError - If the task_id does not exist. ``` 3. **Update Task**: ```python def update_task(task_id: int, description: str, due_date: str) -> None: Updates an existing task\'s description and due date. Parameters: task_id: int - The unique identifier for the task to be updated. description: str - The new description of the task. due_date: str - The new due date of the task in \'YYYY-MM-DD\' format. Returns: None Raises: ValueError - If the task_id does not exist. ``` 4. **List All Tasks**: ```python def list_all_tasks() -> List[Dict[str, Union[int, str]]]: Lists all tasks in the task manager. Returns: List[Dict[str, Union[int, str]]] - A list of dictionaries with task details (task_id, description, due_date). ``` 5. **Sort Tasks by Due Date**: ```python def sort_tasks_by_due_date() -> List[Dict[str, Union[int, str]]]: Sorts tasks by their due date in ascending order. Returns: List[Dict[str, Union[int, str]]] - A sorted list of dictionaries with task details (task_id, description, due_date). ``` Constraints * **Input Format**: * **add_task/update_task**: `task_id` as an integer, `description` as a string, `due_date` as a string in \'YYYY-MM-DD\' format. * **delete_task**: `task_id` as an integer. * **Output Format**: * **list_all_tasks/sort_tasks_by_due_date**: List of dictionaries with keys \'task_id\', \'description\', and \'due_date\'. # Example ``` python >>> # Adding tasks >>> add_task(1, \'Complete coding challenge\', \'2023-10-05\') >>> add_task(2, \'Prepare project presentation\', \'2023-10-15\') >>> add_task(3, \'Buy groceries\', \'2023-10-03\') >>> # Listing all tasks >>> list_all_tasks() [ {\'task_id\': 1, \'description\': \'Complete coding challenge\', \'due_date\': \'2023-10-05\'}, {\'task_id\': 2, \'description\': \'Prepare project presentation\', \'due_date\': \'2023-10-15\'}, {\'task_id\': 3, \'description\': \'Buy groceries\', \'due_date\': \'2023-10-03\'} ] >>> # Sorting tasks by due date >>> sort_tasks_by_due_date() [ {\'task_id\': 3, \'description\': \'Buy groceries\', \'due_date\': \'2023-10-03\'}, {\'task_id\': 1, \'description\': \'Complete coding challenge\', \'due_date\': \'2023-10-05\'}, {\'task_id\': 2, \'description\': \'Prepare project presentation\', \'due_date\': \'2023-10-15\'} ] >>> # Updating a task >>> update_task(1, \'Complete coding challenge with test cases\', \'2023-10-07\') >>> # Deleting a task >>> delete_task(3) ``` Additional Notes * Ensure all functions have proper docstrings and error handling capabilities. * Input validation should include checking for valid date formats and uniqueness of task IDs. * Tests for various edge cases must be included along with the main implementation.","solution":"from typing import List, Dict, Union from datetime import datetime tasks = {} def add_task(task_id: int, description: str, due_date: str) -> None: Adds a new task to the task manager. Parameters: task_id: int - The unique identifier for the task. description: str - The description of the task. due_date: str - The due date of the task in \'YYYY-MM-DD\' format. Returns: None if task_id in tasks: raise ValueError(\\"Task ID already exists\\") try: datetime.strptime(due_date, \'%Y-%m-%d\') except ValueError: raise ValueError(\\"Incorrect date format, should be YYYY-MM-DD\\") tasks[task_id] = {\'task_id\': task_id, \'description\': description, \'due_date\': due_date} def delete_task(task_id: int) -> None: Deletes a task from the task manager. Parameters: task_id: int - The unique identifier for the task to be deleted. Returns: None Raises: ValueError - If the task_id does not exist. if task_id not in tasks: raise ValueError(\\"Task ID does not exist\\") del tasks[task_id] def update_task(task_id: int, description: str, due_date: str) -> None: Updates an existing task\'s description and due date. Parameters: task_id: int - The unique identifier for the task to be updated. description: str - The new description of the task. due_date: str - The new due date of the task in \'YYYY-MM-DD\' format. Returns: None Raises: ValueError - If the task_id does not exist. if task_id not in tasks: raise ValueError(\\"Task ID does not exist\\") try: datetime.strptime(due_date, \'%Y-%m-%d\') except ValueError: raise ValueError(\\"Incorrect date format, should be YYYY-MM-DD\\") tasks[task_id][\'description\'] = description tasks[task_id][\'due_date\'] = due_date def list_all_tasks() -> List[Dict[str, Union[int, str]]]: Lists all tasks in the task manager. Returns: List[Dict[str, Union[int, str]]] - A list of dictionaries with task details (task_id, description, due_date). return list(tasks.values()) def sort_tasks_by_due_date() -> List[Dict[str, Union[int, str]]]: Sorts tasks by their due date in ascending order. Returns: List[Dict[str, Union[int, str]]] - A sorted list of dictionaries with task details (task_id, description, due_date). return sorted(tasks.values(), key=lambda x: x[\'due_date\'])"},{"question":"# Tree Symmetry Check Write a function to determine if a given binary tree is symmetric around its center. A binary tree is symmetric if it is a mirror of itself. **Function Signature**: ```python def is_symmetric(root: Optional[TreeNode]) -> bool: pass ``` # Description: - **Input**: - `root` (Optional[TreeNode]): The root of the binary tree. It can be `None`. - **Output**: - Return `True` if the binary tree is symmetric, and `False` otherwise. # Constraints: - The number of nodes in the tree is in the range `[0, 1000]`. - The value of each node is an integer within the range `[-100, 100]`. # Examples: 1. Given the tree: ``` 1 / 2 2 / / 3 4 4 3 ``` `is_symmetric(root)` returns `True`. 2. Given the tree: ``` 1 / 2 2 3 3 ``` `is_symmetric(root)` returns `False`. # Notes: - Consider developing a helper function that checks if two trees are mirrors of each other. - Use an iterative approach or recursion to verify symmetry effectively. Implement the function `is_symmetric` that meets these requirements. Create any helper functions as needed and validate your implementation with adequate test cases.","solution":"from typing import Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_symmetric(root: Optional[TreeNode]) -> bool: if not root: return True def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.value == t2.value and is_mirror(t1.left, t2.right) and is_mirror(t1.right, t2.left)) return is_mirror(root.left, root.right)"},{"question":"# Word Ladder Problem You are given a start word, an end word, and a dictionary containing a list of valid words. Transform the start word into the end word, changing only one letter at a time while ensuring that each transformed word exists in the dictionary. Determine the minimum number of transformations required or return 0 if it is not possible to transform the start word to the end word. Task: Write the function `word_ladder_length(start: str, end: str, word_dict: list[str]) -> int` that: - Accepts a start word, an end word, and a list of valid words (the dictionary). - Returns the minimum number of transformations required to transform the start word to the end word, or 0 if the transformation is not possible. Inputs: - `start`: A string representing the start word. - `end`: A string representing the end word. - `word_dict`: A list of strings representing the dictionary of valid words. - `1 <= len(start), len(end) <= 100`: The length of each word. - `10 <= len(word_dict) <= 5000`: The length of the dictionary. Output: - An integer representing the minimum number of transformations required to transform the start word to the end word or 0 if the transformation is not possible. Constraints: - The dictionary does not contain duplicates. - All words in the dictionary, including the start and end words, have the same length. - Only one letter can be changed at a time. - Each intermediate word must exist in the dictionary. Example Scenario: ```python start = \\"hit\\" end = \\"cog\\" word_dict = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] # The shortest transformation sequence is: # hit -> hot -> dot -> dog -> cog # So, the minimum number of transformations required is 5. word_ladder_length(start, end, word_dict) # should return 5 ``` Ensure to handle edge cases and test your implementation for correctness and efficiency.","solution":"from collections import deque def word_ladder_length(start: str, end: str, word_dict: list[str]) -> int: if end not in word_dict or not start or not end or not word_dict: return 0 # All words including start, end should be in the word_dict word_dict = set(word_dict) word_dict.add(start) word_dict.add(end) queue = deque([(start, 1)]) while queue: current_word, steps = queue.popleft() # Generate all possible transformations for i in range(len(current_word)): for char in \'abcdefghijklmnopqrstuvwxyz\': if char != current_word[i]: transformed_word = current_word[:i] + char + current_word[i+1:] if transformed_word == end: return steps + 1 if transformed_word in word_dict: queue.append((transformed_word, steps + 1)) word_dict.remove(transformed_word) return 0"},{"question":"# Problem Statement: In this task, you have to implement a basic text editor with the ability to perform undo and redo operations on text input. The text editor will support three main operations: appending new text, undoing the last operation, and redoing the last undone operation. # Requirements: 1. **Class Name**: `TextEditor` - **Methods**: 1. **Method Name**: `append_text` - **Input**: A single string representing the text to be appended. - **Output**: None (modifies the internal state of the text editor). 2. **Method Name**: `undo` - **Input**: None. - **Output**: None (reverts the internal state to the previous change, if any). 3. **Method Name**: `redo` - **Input**: None. - **Output**: None (re-applies the last undone change, if any). 4. **Method Name**: `get_text` - **Input**: None. - **Output**: A string representing the current state of the text. # Constraints: - You can assume that the total number of operations (append, undo, redo) will not exceed 10,000. - The length of the text to be appended in a single operation will not exceed 1,000 characters. # Details: - The text editor maintains a history of changes to support undo and redo operations. - After an `append_text` operation, the `redo` history should be cleared. - When `undo` is called, the last change should be undone, and the state before that change should be restored. - When `redo` is called, the last undone change should be reapplied to the current state. - If there is no operation to undo, calling `undo` should do nothing. - If there is no operation to redo, calling `redo` should do nothing. # Example Usage: ```python editor = TextEditor() editor.append_text(\\"Hello\\") print(editor.get_text()) # Output: \\"Hello\\" editor.append_text(\\" World\\") print(editor.get_text()) # Output: \\"Hello World\\" editor.undo() print(editor.get_text()) # Output: \\"Hello\\" editor.redo() print(editor.get_text()) # Output: \\"Hello World\\" editor.undo() editor.append_text(\\" Everyone\\") print(editor.get_text()) # Output: \\"Hello Everyone\\" editor.redo() # No effect since the redo history is cleared print(editor.get_text()) # Output: \\"Hello Everyone\\" ``` # Implementation: Your task is to implement the `TextEditor` class with the specified methods to handle text editing operations along with undo and redo functionality.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] self.undo_stack = [] def append_text(self, new_text): self.history.append(self.text) self.text += new_text self.undo_stack.clear() def undo(self): if self.history: last_state = self.history.pop() self.undo_stack.append(self.text) self.text = last_state def redo(self): if self.undo_stack: next_state = self.undo_stack.pop() self.history.append(self.text) self.text = next_state def get_text(self): return self.text"},{"question":"# Problem: Implement Priority Queue using Binary Heap **Context**: You are provided with a class `PriorityQueue` that simulates the behavior of a priority queue using an underlying array. To efficiently manage the queue operations, we need to implement this class using a binary heap. **Problem Statement**: Create a class `BinaryHeapPriorityQueue` to represent a priority queue where the element with the highest priority is dequeued first. Implement the binary heap data structure (min-heap or max-heap) to support the following operations: 1. **Insert an element into the priority queue.** 2. **Extract the highest priority element from the priority queue.** 3. **Peek the highest priority element without extracting it.** # Requirements * **Class Implementation**: * `BinaryHeapPriorityQueue` should be initialized and manage elements based on priority. * Support the following operations: - `insert(element: Any, priority: int) -> None` * Insert an element with the given priority into the priority queue. - `extract_max() -> Any` * Extract and return the element with the highest priority. - `peek() -> Any` * Return the element with the highest priority without removing it. # Example ```python queue = BinaryHeapPriorityQueue() queue.insert(\'task1\', 3) queue.insert(\'task2\', 1) queue.insert(\'task3\', 4) queue.insert(\'task4\', 2) max_el = queue.extract_max() # should return \'task3\', as it has the highest priority 4 queue.peek() # should return \'task1\', as it now has the highest remaining priority 3 ``` # Constraints * All priorities will be integers. * If `extract_max` or `peek` are called on an empty priority queue, raise an `IndexError`. **Note**: Ensure the operations (insert, extract_max, peek) maintain the expected time complexities relative to heap operations, specifically O(log n) for insert and extract_max, and O(1) for peek.","solution":"import heapq class BinaryHeapPriorityQueue: def __init__(self): self.heap = [] self.count = 0 # Unique sequence count def insert(self, element, priority): # Since heapq in Python implements a min-heap, we store negative priorities for max-heap behavior heapq.heappush(self.heap, (-priority, self.count, element)) self.count += 1 def extract_max(self): if not self.heap: raise IndexError(\\"extract_max from an empty priority queue\\") return heapq.heappop(self.heap)[2] def peek(self): if not self.heap: raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0][2]"},{"question":"# Question: Write a function that simulates the operations of a circular queue. Your function should implement the enqueue and dequeue operations, ensuring that they wrap around the end of the array when necessary. Additionally, provide a method to return the current state of the queue as a list. Function Signature ```python class CircularQueue: def __init__(self, size: int): pass def enqueue(self, value: int) -> None: pass def dequeue(self) -> int: pass def get_queue(self) -> list: pass ``` Input The following methods should handle these inputs: - `__init__(size: int)`: Initializes the circular queue with a specified size. - `enqueue(value: int)`: Adds a new integer `value` to the end of the queue. - `dequeue()`: Removes and returns the integer from the front of the queue. Output The methods should return the following: - `enqueue(value: int)`: Does not return anything. - `dequeue()`: Returns the integer from the front of the queue, raises an exception if the queue is empty. - `get_queue()`: Returns a list representing the current state of the queue (in order), ignoring empty slots. Constraints - The size of the circular queue is a positive integer. - Enqueue operations will raise an exception if the queue is full. - Dequeue operations will raise an exception if the queue is empty. Example ```python cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) assert cq.get_queue() == [1, 2] cq.enqueue(3) assert cq.get_queue() == [1, 2, 3] assert cq.dequeue() == 1 assert cq.get_queue() == [2, 3] cq.enqueue(4) assert cq.get_queue() == [2, 3, 4] assert cq.dequeue() == 2 assert cq.dequeue() == 3 assert cq.get_queue() == [4] ``` Notes - Make sure to handle the circular nature of the queue efficiently. - Properly manage the state of the queue to avoid overflow or underflow conditions.","solution":"class CircularQueue: def __init__(self, size: int): self.size = size self.queue = [None] * size self.head = -1 self.tail = -1 def enqueue(self, value: int) -> None: if (self.tail + 1) % self.size == self.head: raise Exception(\\"Queue is full\\") if self.head == -1: self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value def dequeue(self) -> int: if self.head == -1: raise Exception(\\"Queue is empty\\") value = self.queue[self.head] if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.size return value def get_queue(self) -> list: if self.head == -1: return [] if self.tail >= self.head: return self.queue[self.head:self.tail + 1] else: return self.queue[self.head:self.size] + self.queue[0:self.tail + 1]"},{"question":"# Problem Statement You are tasked with implementing the function `merge_binary_trees` that takes the roots of two binary trees. The function should return the root of a new binary tree where each node is the sum of the corresponding nodes from the two input binary trees. If a node exists in only one of the trees, use that node\'s value directly in the new tree. Implement the following function: 1. `merge_binary_trees(root1: TreeNode, root2: TreeNode) -> TreeNode` * **Input**: Two `TreeNode` objects representing the roots of the two binary trees. * **Output**: A `TreeNode` object representing the root of the new merged binary tree. # Constraints: * The number of nodes in each binary tree is in the range `[0, 1000]`. * `-1000 <= Node.val <= 1000` * Either or both input trees may be null which should return the non-null tree or null if both are null. # Examples **Example 1:** For the following binary trees: ``` Tree 1 Tree 2 1 2 / / 3 2 1 3 / 5 4 7 ``` `merge_binary_trees(root1, root2)` should return the following binary tree: ``` 3 / 4 5 / 5 4 7 ``` **Example 2:** For the following binary trees: ``` Tree 1 Tree 2 1 1 ``` `merge_binary_trees(root1, root2)` should return the following binary tree: ``` 2 ``` # Directions: * Implement the function as described. * Aim for optimal time and space complexity. * Consider edge cases like totally disjoint trees or trees of different structures.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_binary_trees(root1, root2): if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged_root = TreeNode(root1.val + root2.val) merged_root.left = merge_binary_trees(root1.left, root2.left) merged_root.right = merge_binary_trees(root1.right, root2.right) return merged_root"},{"question":"# Context You are writing a tool for text analysis and one of the features needed is a function to find the most frequent word in a given text. The function should ignore case and punctuation and return the word in lowercase. # Task Write a function that finds the most frequent word in a given text string. If there is a tie, return the word that appears first in the text. # Function Specification **Function Name**: `most_frequent_word` Input * `text`: str - A string containing the text to be analyzed. Output * `str` - The most frequent word in lowercase. **Constraints** * The input string can contain any printable characters including letters, digits, and punctuation. * You may assume that the text will have at least one word. # Example Example 1 ```python text = \\"Hello world! This is a test. Hello again, hello world.\\" result = most_frequent_word(text) print(result) # Output: \\"hello\\" ``` Example 2 ```python text = \\"In the beginning the Universe was created. This has made a lot of people very angry and has been widely regarded as a bad move.\\" result = most_frequent_word(text) print(result) # Output: \\"a\\" ```","solution":"import re from collections import defaultdict def most_frequent_word(text): Returns the most frequent word in the given text, ignoring case and punctuation. # Remove punctuation and convert to lowercase words = re.findall(r\'bw+b\', text.lower()) # Frequency dictionary word_count = defaultdict(int) for word in words: word_count[word] += 1 # Find the most frequent word max_count = -1 most_frequent = None for word in words: if word_count[word] > max_count: max_count = word_count[word] most_frequent = word return most_frequent"},{"question":"# Merge K Sorted Linked Lists In this task, you need to merge `k` sorted linked lists into one sorted linked list. Given an array of `k` head nodes of the linked lists, return the head of the merged and sorted linked list. # Input * `lists`: A list of ListNode objects representing the head nodes of `k` sorted linked lists. # Output * The head ListNode of the merged sorted linked list. # Constraints * The number of linked lists `k` is in the range `[0, 10^4]`. * Each linked list\'s length is not more than `500`. * The values in each linked list are in the range `[-10^4, 10^4]`. # Example ```python class ListNode: def __init__(self, x): self.val = x self.next = None def to_list(node): result = [] while node: result.append(node.val) node = node.next return result # Example 1: # Input: lists = [[1,4,5], [1,3,4], [2,6]] # Output: [1,1,2,3,4,4,5,6] # Convert input arrays to ListNode objects def array_to_listnodes(arrays): lists = [] for array in arrays: if not array: lists.append(None) continue head = ListNode(array[0]) tail = head for val in array[1:]: tail.next = ListNode(val) tail = tail.next lists.append(head) return lists lists = array_to_listnodes([[1, 4, 5], [1, 3, 4], [2, 6]]) merged_head = mergeKLists(lists) print(to_list(merged_head)) # Output: [1, 1, 2, 3, 4, 4, 5, 6] ``` # Task Implement the `mergeKLists` function as described above. ```python from typing import List, Optional class ListNode: def __init__(self, x): self.val = x self.next = None def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: # Your implementation here pass ``` # Additional Information To create better solutions, consider using a priority queue (min-heap) to keep track of the smallest current head of the `k` lists and efficiently merge them.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, x): self.val = x self.next = None def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next node = node.next if node: heapq.heappush(min_heap, (node.val, i, node)) return dummy.next"},{"question":"# Graph Traversal and Shortest Path Challenge **Context**: You are tasked with implementing a graph traversal and shortest path finding algorithm. Given a directed graph, your task is to find the shortest path from a starting vertex to all other vertices using Dijkstra\'s algorithm. # Task: Implement the following methods in a `Graph` class: 1. **Add Vertex** 2. **Add Edge** 3. **Dijkstra\'s Shortest Path** # Requirements: 1. **Add Vertex**: - Add a new vertex to the graph. - **Input**: Vertex identifier (string) - **Output**: None 2. **Add Edge**: - Add a directed edge with a weight between two vertices in the graph. - **Input**: Start vertex, end vertex, and weight (integers for vertices and weight) - **Output**: None 3. **Dijkstra\'s Shortest Path**: - Find the shortest path from a given starting vertex to all other vertices in the graph. - **Input**: Starting vertex identifier (string) - **Output**: Dictionary with vertex identifiers as keys and shortest path distances as values # Constraints: 1. The graph does not contain negative weight edges. 2. All vertices are identified uniquely by strings. 3. The `Add Edge` method should handle the case where either of the vertices does not exist by ignoring the operation. # Example: * Add Vertex: \\"A\\", \\"B\\", \\"C\\", \\"D\\" * Add Edge: (\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"A\\", \\"C\\", 4), (\\"C\\", \\"D\\", 1) * Dijkstra\'s Shortest Path from \\"A\\": {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} # Guidelines: 1. Use a priority queue to efficiently fetch the next vertex with the smallest tentative distance. 2. Initialize distances for all vertices as infinity except for the starting vertex which should be zero. 3. Update the shortest path estimates iteratively until all vertices have been processed. 4. Ensure your implementation handles edge cases such as disconnected graphs and isolated vertices. # Implementation: ```python import heapq class Graph: def __init__(self): self.vertices = {} def add_vertex(self, identifier): if identifier not in self.vertices: self.vertices[identifier] = {} def add_edge(self, start, end, weight): if start in self.vertices and end in self.vertices: self.vertices[start][end] = weight def dijkstra(self, start): distances = {vertex: float(\'inf\') for vertex in self.vertices} distances[start] = 0 priority_queue = [(0, start)] heapq.heapify(priority_queue) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.vertices[current_vertex].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Example Usage: g = Graph() vertices = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] for vertex in vertices: g.add_vertex(vertex) edges = [(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"A\\", \\"C\\", 4), (\\"C\\", \\"D\\", 1)] for start, end, weight in edges: g.add_edge(start, end, weight) print(g.dijkstra(\\"A\\")) ``` In the provided example code, upon performing the given operations, the shortest path distances from the starting vertex \\"A\\" should correspond to the example scenario provided. Ensure your code meets the outlined requirements and handles all the mentioned constraints effectively.","solution":"import heapq class Graph: def __init__(self): self.vertices = {} def add_vertex(self, identifier): if identifier not in self.vertices: self.vertices[identifier] = {} def add_edge(self, start, end, weight): if start in self.vertices and end in self.vertices: self.vertices[start][end] = weight def dijkstra(self, start): distances = {vertex: float(\'inf\') for vertex in self.vertices} distances[start] = 0 priority_queue = [(0, start)] heapq.heapify(priority_queue) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.vertices[current_vertex].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Question: Calculate Electrical Power Dissipation in a Resistor Given the current through a resistor and the resistance, you are asked to implement two functions to calculate the power dissipation using two different forms of the power equation. Function 1: `power_dissipation_by_current` ```python def power_dissipation_by_current(current: float, resistance: float) -> float: Calculate power dissipation in a resistor using current and resistance. Parameters: current (float) : The current flowing through the resistor (I), in amperes. resistance (float) : The resistance of the resistor (R), in ohms. Returns: float : The power dissipation (P), in watts. ``` Function 2: `power_dissipation_by_voltage` ```python def power_dissipation_by_voltage(voltage: float, resistance: float) -> float: Calculate power dissipation in a resistor using voltage and resistance. Parameters: voltage (float) : The voltage across the resistor (V), in volts. resistance (float) : The resistance of the resistor (R), in ohms. Returns: float : The power dissipation (P), in watts. ``` # Constraints: 1. Both `current` and `voltage` will be non-negative floats. 2. The `resistance` will be a positive float. 3. If `resistance` is less than or equal to zero, raise a `ValueError` with the message: \\"resistance must be a positive float value.\\" # Example: ```python >>> power_dissipation_by_current(2, 5) # Expected output 20.0 >>> power_dissipation_by_voltage(10, 5) # Expected output 20.0 >>> power_dissipation_by_current(0, 10) # Expected output 0.0 >>> power_dissipation_by_voltage(0, 10) # Expected output 0.0 >>> power_dissipation_by_current(3, 2) # Expected output 18.0 >>> power_dissipation_by_voltage(12, 8) # Expected output 18.0 ``` # Additional Requirements: 1. Ensure the functions handle edge cases effectively, such as when the current or voltage is zero. 2. Adhere to O(1) time and space complexity constraints.","solution":"def power_dissipation_by_current(current: float, resistance: float) -> float: Calculate power dissipation in a resistor using current and resistance. Parameters: current (float) : The current flowing through the resistor (I), in amperes. resistance (float) : The resistance of the resistor (R), in ohms. Returns: float : The power dissipation (P), in watts. if resistance <= 0: raise ValueError(\\"resistance must be a positive float value\\") return current ** 2 * resistance def power_dissipation_by_voltage(voltage: float, resistance: float) -> float: Calculate power dissipation in a resistor using voltage and resistance. Parameters: voltage (float) : The voltage across the resistor (V), in volts. resistance (float) : The resistance of the resistor (R), in ohms. Returns: float : The power dissipation (P), in watts. if resistance <= 0: raise ValueError(\\"resistance must be a positive float value\\") return voltage ** 2 / resistance"},{"question":"# Bit Manipulation: Single Number II **Scenario**: In a collection of integers, every integer appears exactly three times except for one, which appears exactly once. You are tasked with finding and returning the single integer that appears only once. **Problem**: Design a function `single_number` that identifies the integer in a list which appears exactly one time, while every other integer appears exactly three times. Your solution should efficiently handle large lists. **Input/Output**: - **Input**: A list of integers `nums`. - **Output**: An integer representing the single number that appears only once. **Constraints**: - The length of the list will be between 1 and 10^4 elements. - Each integer in the list will be between -2^31 and 2^31 - 1. **Function Signature**: ```python def single_number(nums: list[int]) -> int: pass ``` **Example**: ```python assert single_number([2, 2, 3, 2]) == 3 assert single_number([0, 1, 0, 1, 0, 1, 99]) == 99 assert single_number([-2, -2, 1, -2]) == 1 assert single_number([30000, 500, 100, 30000, 100, 30000, 100]) == 500 ```","solution":"def single_number(nums: list[int]) -> int: Identify the integer in a list which appears exactly one time, while every other integer appears exactly three times. seen_once = seen_twice = 0 for num in nums: # first appearance: add num to seen_once # second appearance: remove num from seen_once and add to seen_twice # third appearance: remove num from seen_twice seen_once = ~seen_twice & (seen_once ^ num) seen_twice = ~seen_once & (seen_twice ^ num) return seen_once"},{"question":"# Coding Assessment Question **Problem Statement:** You need to implement a function that assembles the largest possible integer from a list of non-negative integers by concatenating their string representations. The result should be returned as a string. Your function should handle various edge cases such as lists with single elements, multiple zeros, etc. **Function Signature:** ```python def largest_number(nums: List[int]) -> str: pass ``` **Input:** - `nums`: A list of non-negative integers. **Output:** - Returns a string representing the largest possible integer. **Constraints:** 1. All integers in `nums` are non-negative. 2. The length of `nums` is at least 1 and does not exceed 100. 3. Each integer in `nums` is in the range of 0 to 10^9. **Examples:** ```python assert largest_number([10, 2]) == \\"210\\" assert largest_number([3, 30, 34, 5, 9]) == \\"9534330\\" assert largest_number([1]) == \\"1\\" assert largest_number([10]) == \\"10\\" assert largest_number([830, 8308]) == \\"8308830\\" assert largest_number([0, 0]) == \\"0\\" assert largest_number([121, 12]) == \\"12121\\" ``` **Additional Notes:** - Implement and thoroughly test your solution in Python. - Consider all possible edge cases such as when the result is zero (e.g., `[0, 0]`). - Use efficient and appropriate sorting mechanisms to achieve the desired result. **Hint:** One way to achieve the correct ordering is to sort the array with a custom comparator that decides the order based on which concatenation of any two numbers (as strings) results in a larger number.","solution":"from typing import List from functools import cmp_to_key def largest_number(nums: List[int]) -> str: # Convert the integers to strings for comparison strs = list(map(str, nums)) # Define a custom comparator function def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort the list with the custom comparator strs.sort(key=cmp_to_key(compare)) # Join the sorted strings into the largest number largest_num = \'\'.join(strs) # Special case: when the list consists of only \'0\'s if largest_num[0] == \'0\': return \'0\' return largest_num"},{"question":"# Problem: Efficient Subarray Sum Calculation Context: You are managing a financial system that processes a large number of transactions. You need to analyze the transaction data to identify significant transaction patterns. One of the tasks is to determine the sum of subarrays within the transaction data. Given the size of the transactions list and the frequency of queries, an efficient solution is required. Objective: Implement a function `subarray_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]` that efficiently calculates the sum of elements for multiple subarrays. # Constraints: - The length of the array `arr` can be up to 100,000. - You will receive up to 50,000 queries, each containing two integers, representing the starting and ending indices of the subarray. - The values of elements in the array can be any integer within the range -10^5 to 10^5. - Indices are 0-based. # Input: - `arr`: A list of integers representing the transactions. - `queries`: A list of tuples, each containing two integers `(start, end)` indicating the subarray indices for which the sum needs to be calculated. # Output: - Return a list of integers where each integer is the sum of the subarray specified by the corresponding query. # Performance Requirements: - The solution should be optimized to handle a large number of queries efficiently. Example: ```python def subarray_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: pass # your implementation here # Example usage arr = [1, 2, 3, 4, 5] queries = [(0, 2), (1, 3), (0, 4), (2, 4)] print(subarray_sum(arr, queries)) # [6, 9, 15, 12] arr = [-1, 3, -2, 7, -3, 2] queries = [(0, 1), (1, 4), (2, 5)] print(subarray_sum(arr, queries)) # [2, 5, 4] ``` # Hint: To efficiently calculate the sum of elements in any subarray, consider using a prefix sum array to preprocess the cumulative sum of elements in `arr`.","solution":"from typing import List, Tuple def subarray_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: n = len(arr) # Create a prefix sum array prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] # Calculate the sum for each query results = [] for start, end in queries: subarray_sum = prefix_sum[end + 1] - prefix_sum[start] results.append(subarray_sum) return results"},{"question":"# Objective Implement a function to find the longest consecutive sequence path in a binary tree. # Problem Description Given the root of a binary tree, write a function `longest_consecutive(root: TreeNode | None) -> int` to find the length of the longest consecutive sequence path in the binary tree. The path must be parent-child connections (either parent to child or child to parent). # Input and Output Formats * **Input**: A reference to the root of a binary tree. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: An integer representing the length of the longest consecutive sequence path. # Constraints 1. The number of nodes in the tree is in the range `[0, 2000]`. 2. `0 <= Node.val <= 100000` 3. A consecutive sequence means that in the path from ancestor to descendant (or vice versa), the values of the nodes are in increasing or decreasing order by exactly 1. 4. Use efficient traversal methods to explore all paths from the root node. # Performance Requirements * The function should perform in O(n) time complexity. # Function Signature Example ```python def longest_consecutive(root: TreeNode | None) -> int: # Your code here pass ``` # Edge Cases 1. The tree is null. 2. The tree has only one node. 3. All nodes have the same value. 4. The longest consecutive sequence path is a single node due to non-consecutive values. # Testing Use the provided example to test different scenarios and edge cases. # Example ``` Input: root = [1, null, 3, 2, 4, null, null, null, 5] Output: 3 Explanation: Longest consecutive sequence path is [3, 4, 5] with length 3. ``` ```python def longest_consecutive(root: TreeNode | None) -> int: def dfs(node, parent_val, current_length): if not node: return current_length if node.val == parent_val + 1: current_length += 1 else: current_length = 1 left = dfs(node.left, node.val, current_length) right = dfs(node.right, node.val, current_length) return max(current_length, left, right) if not root: return 0 return dfs(root, root.val-1, 0) ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_consecutive(root: TreeNode | None) -> int: def dfs(node, parent_val, current_length): if not node: return current_length if node.val == parent_val + 1: current_length += 1 else: current_length = 1 left = dfs(node.left, node.val, current_length) right = dfs(node.right, node.val, current_length) return max(current_length, left, right) if not root: return 0 return dfs(root, root.val-1, 0)"},{"question":"# Array Rotation Challenges **Context**: Array rotations are common operations in many programming problems, where elements of the array are shifted either to the left or right. Your task is to implement functions that handle left and right rotations on arrays efficiently. **Tasks**: 1. `left_rotate(arr: list, k: int) -> list`: Rotates elements of the array to the left by `k` positions. 2. `right_rotate(arr: list, k: int) -> list`: Rotates elements of the array to the right by `k` positions. **Input and Output**: - **Input**: - Each function takes a list of integers `arr` and an integer `k` representing the number of positions to rotate. - **Output**: - Both functions return a new list with elements rotated accordingly. **Constraints**: - `1 <= len(arr) <= 10^5` - `0 <= k <= 10^5` - The elements in the array can be integers ranging from `-10^9` to `10^9`. **Performance Requirements**: - The solution should run in O(n) time complexity. - The solution should use O(1) extra space for rotating the array (i.e., it should be done in-place if possible). **Examples**: ```python assert left_rotate([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] assert right_rotate([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert left_rotate([1, 2, 3], 3) == [1, 2, 3] assert right_rotate([1, 2, 3], 0) == [1, 2, 3] ``` **Note**: Implement the following functions in a single file named `array_rotations.py`:","solution":"def reverse_array_partition(arr, start, end): Helper function to reverse a portion of the array from start index to end index. while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 def left_rotate(arr, k): Rotates elements of the array to the left by k positions. n = len(arr) k = k % n # In case k is larger than the array length. # Reverse the first part reverse_array_partition(arr, 0, k - 1) # Reverse the second part reverse_array_partition(arr, k, n - 1) # Reverse the whole array reverse_array_partition(arr, 0, n - 1) return arr def right_rotate(arr, k): Rotates elements of the array to the right by k positions. n = len(arr) k = k % n # In case k is larger than the array length. # Reverse the whole array reverse_array_partition(arr, 0, n - 1) # Reverse the first part reverse_array_partition(arr, 0, k - 1) # Reverse the second part reverse_array_partition(arr, k, n - 1) return arr"},{"question":"# Objective Implement a function to calculate the effective annual rate (EAR) based on a given nominal interest rate and the number of compounding periods per year. # Question You are required to implement the function `effective_annual_rate`, which calculates the effective annual rate based on the nominal interest rate and the number of compounding periods per year. `effective_annual_rate` This function computes the effective annual rate (EAR) for a given nominal annual interest rate compounded over a specified number of periods per year. **Function Signature:** ```python def effective_annual_rate(nominal_rate: float, periods_per_year: float) -> float: ``` **Input:** * `nominal_rate` (float): the nominal annual interest rate expressed as a decimal (e.g., 0.05 for 5%), non-negative. * `periods_per_year` (float): the number of compounding periods per year, positive. **Output:** * Returns the effective annual rate as a float. * Raises `ValueError` if nominal_rate < 0 or periods_per_year <= 0. # Example ```python # Example function calls and expected results: print(effective_annual_rate(0.05, 12)) # Expected output: 0.05116189788173302 print(effective_annual_rate(0.04, 4)) # Expected output: 0.040604010000000086 ``` # Constraints 1. You must validate the input parameters as described. 2. Ensure precision and accuracy in your floating-point arithmetic calculations. 3. Aim to make your implementation efficient. 4. Use proper exception handling where specified. # Implementation Notes: The formula to calculate the effective annual rate (EAR) is: [ text{EAR} = left(1 + frac{text{nominal rate}}{text{periods per year}}right)^{text{periods per year}} - 1 ]","solution":"def effective_annual_rate(nominal_rate: float, periods_per_year: float) -> float: Computes the effective annual rate (EAR) for a given nominal annual interest rate compounded over a specified number of periods per year. Args: nominal_rate (float): The nominal annual interest rate expressed as a decimal. periods_per_year (float): The number of compounding periods per year. Returns: float: The effective annual rate. Raises: ValueError: If nominal_rate < 0 or periods_per_year <= 0. if nominal_rate < 0: raise ValueError(\\"Nominal rate must be non-negative\\") if periods_per_year <= 0: raise ValueError(\\"Periods per year must be greater than zero\\") ear = (1 + nominal_rate / periods_per_year) ** periods_per_year - 1 return ear"},{"question":"# Scenario: You are responsible for developing a library management system to assist in efficient book management. The core functionality required by the system includes adding new books, searching for a book, removing a book, and updating book details. To achieve this, you decide to use a dictionary data structure for its efficient look-up and update operations. # Task: Implement a class `LibraryManager` that uses a dictionary to manage books. Each book should be identifiable by an ISBN number and should have additional details such as Title, Author, and Year of Publication. Your class should provide functionality to perform the following operations efficiently: 1. **Add a book**: Adds a new book with the specified details. 2. **Get book details**: Retrieves the details of a book given its ISBN. 3. **Remove a book**: Removes a book based on its ISBN. 4. **Update book details**: Updates the details of an existing book given its ISBN. # Requirements: - Each book can be uniquely identified by a non-zero ISBN number. - The Title, Author, and Year of Publication along with the ISBN should be managed in the dictionary. - Assume all provided ISBN numbers, Titles, Authors, and Years of Publication are valid and within reasonable limits. # Function Specifications: 1. **add_book(isbn: int, title: str, author: str, year: int) -> None**: Adds a book with the specified `isbn`, `title`, `author`, and `year`. 2. **get_book_details(isbn: int) -> dict | None**: Returns a dictionary with the details of the book if present, in the format `{\\"title\\": str, \\"author\\": str, \\"year\\": int}`, else `None`. 3. **remove_book(isbn: int) -> dict | None**: Removes and returns the details of the removed book in the format `{\\"title\\": str, \\"author\\": str, \\"year\\": int}` if present, else `None`. 4. **update_book_details(isbn: int, title: str = None, author: str = None, year: int = None) -> None**: Updates the details of the book with the given `isbn` to new values provided (`title`, `author`, `year`). Any details not provided should remain unchanged. # Constraints: - `1 <= isbn <= 10^5` - Title and Author are non-empty strings. - Year is a positive integer. # Example: ```python library = LibraryManager() library.add_book(12345, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) library.add_book(67890, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) print(library.get_book_details(12345)) # Output: {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925} library.update_book_details(12345, year=1926) print(library.get_book_details(12345)) # Output: {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1926} print(library.remove_book(67890)) # Output: {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960} print(library.get_book_details(67890)) # Output: None ``` # Note: - Ensure that attempting to get, remove, or update a book that does not exist handles the scenario gracefully. - Consider edge cases such as updating a book with only partial information. This new question integrates well with the original set, matching the complexity, length, and topic alignment focused on data structures and efficient data handling.","solution":"class LibraryManager: def __init__(self): self.books = {} def add_book(self, isbn, title, author, year): self.books[isbn] = { \\"title\\": title, \\"author\\": author, \\"year\\": year } def get_book_details(self, isbn): return self.books.get(isbn, None) def remove_book(self, isbn): return self.books.pop(isbn, None) def update_book_details(self, isbn, title=None, author=None, year=None): if isbn in self.books: if title is not None: self.books[isbn][\\"title\\"] = title if author is not None: self.books[isbn][\\"author\\"] = author if year is not None: self.books[isbn][\\"year\\"] = year"},{"question":"# Question: Implement a Storm Center Data Aggregator Overview: You are managing the tracking system for a storm center, aggregating various metrics from different storm events. Your task is to implement a function that processes a list of storm data points, consolidates data from the same storm, and calculates the intensity level for each unique storm based on given criteria. Function Signature: ```python def aggregate_storm_data(storm_events: list) -> dict: Aggregates storm data and calculates intensity levels for unique storms. Parameters: storm_events (list): A list of dictionaries, where each dictionary contains data for a storm event. Returns: dict: A dictionary where keys are unique storm IDs and values are another dictionary with aggregated data. pass ``` Input: * `storm_events` - A list of dictionaries, where each dictionary represents a storm event and has the following keys: - `storm_id` (str): A unique identifier for the storm. - `date` (str): The date of the storm event in the format \'YYYY-MM-DD\'. - `wind_speed` (float): The wind speed in mph. - `pressure` (float): The pressure in hPa. - `rainfall` (float): The rainfall in inches. - `category` (int): The categorizations from 1 to 5. Output: * A dictionary where keys are unique `storm_id`s and values are dictionaries containing: - `total_wind_speed` (float): The sum of all wind speeds recorded for the storm. - `average_pressure` (float): The average pressure recorded for the storm. - `total_rainfall` (float): The sum of all rainfall recorded for the storm. - `max_category` (int): The maximum category recorded for the storm. - `intensity_level` (str): Intensity level calculated as: - \'Low\' for storms with max_category 1 or 2. - \'Moderate\' for storms with max_category 3. - \'High\' for storms with max_category 4 or 5. Constraints: * The list `storm_events` can contain up to 10^5 events. * Each dictionary in `storm_events` will conform to the structure described. * The values for `wind_speed`, `pressure`, and `rainfall` are non-negative. Example: ```python storm_events = [ {\\"storm_id\\": \\"S1\\", \\"date\\": \\"2023-08-01\\", \\"wind_speed\\": 80.0, \\"pressure\\": 980.0, \\"rainfall\\": 2.5, \\"category\\": 3}, {\\"storm_id\\": \\"S1\\", \\"date\\": \\"2023-08-02\\", \\"wind_speed\\": 85.0, \\"pressure\\": 975.0, \\"rainfall\\": 3.0, \\"category\\": 4}, {\\"storm_id\\": \\"S2\\", \\"date\\": \\"2023-08-03\\", \\"wind_speed\\": 65.0, \\"pressure\\": 990.0, \\"rainfall\\": 1.0, \\"category\\": 1}, {\\"storm_id\\": \\"S2\\", \\"date\\": \\"2023-08-04\\", \\"wind_speed\\": 70.0, \\"pressure\\": 985.0, \\"rainfall\\": 1.5, \\"category\\": 2}, ] expected_output = { \\"S1\\": { \\"total_wind_speed\\": 165.0, \\"average_pressure\\": 977.5, \\"total_rainfall\\": 5.5, \\"max_category\\": 4, \\"intensity_level\\": \\"High\\", }, \\"S2\\": { \\"total_wind_speed\\": 135.0, \\"average_pressure\\": 987.5, \\"total_rainfall\\": 2.5, \\"max_category\\": 2, \\"intensity_level\\": \\"Low\\", }, } assert aggregate_storm_data(storm_events) == expected_output ```","solution":"def aggregate_storm_data(storm_events): Aggregates storm data and calculates intensity levels for unique storms. Parameters: storm_events (list): A list of dictionaries, where each dictionary contains data for a storm event. Returns: dict: A dictionary where keys are unique storm IDs and values are another dictionary with aggregated data. storm_data = {} for event in storm_events: storm_id = event[\'storm_id\'] if storm_id not in storm_data: storm_data[storm_id] = { \\"total_wind_speed\\": 0.0, \\"total_pressure\\": 0.0, \\"pressure_count\\": 0, \\"total_rainfall\\": 0.0, \\"max_category\\": 0 } storm_data[storm_id][\\"total_wind_speed\\"] += event.get(\\"wind_speed\\", 0) storm_data[storm_id][\\"total_pressure\\"] += event.get(\\"pressure\\", 0) storm_data[storm_id][\\"pressure_count\\"] += 1 storm_data[storm_id][\\"total_rainfall\\"] += event.get(\\"rainfall\\", 0) storm_data[storm_id][\\"max_category\\"] = max(storm_data[storm_id][\\"max_category\\"], event.get(\\"category\\", 0)) # Finalize the aggregation results result = {} for storm_id, data in storm_data.items(): average_pressure = data[\\"total_pressure\\"] / data[\\"pressure_count\\"] if data[\\"pressure_count\\"] != 0 else 0.0 intensity_level = \'\' if data[\\"max_category\\"] <= 2: intensity_level = \'Low\' elif data[\\"max_category\\"] == 3: intensity_level = \'Moderate\' else: intensity_level = \'High\' result[storm_id] = { \\"total_wind_speed\\": data[\\"total_wind_speed\\"], \\"average_pressure\\": average_pressure, \\"total_rainfall\\": data[\\"total_rainfall\\"], \\"max_category\\": data[\\"max_category\\"], \\"intensity_level\\": intensity_level } return result"},{"question":"# Problem Statement You are tasked to implement a `TopologicalSort` class that performs a topological sort on a given Directed Acyclic Graph (DAG). A topological sort of a DAG is a linear ordering of its vertices such that for every directed edge from vertex `u` to vertex `v`, `u` comes before `v` in the ordering. # Function Signature ```python class TopologicalSort: def __init__(self, num_vertices: int, edges: list[tuple[int, int]]): # Initialization of class variables pass def sort(self) -> list[int]: # Method to perform the topological sort pass ``` # Input 1. `num_vertices`: An integer representing the number of vertices in the graph. 2. `edges`: A list of tuples `(u, v)` representing a directed edge from vertex `u` to vertex `v`. # Output * Returns a list of integers representing the vertices in topologically sorted order. # Constraints * `1 <= num_vertices <= 100` * There will be no cycles in the graph (i.e., the input graph is a DAG). # Example ```python num_vertices = 6 edges = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)] top_sort = TopologicalSort(num_vertices, edges) print(top_sort.sort()) # Output: [4, 5, 0, 2, 3, 1] (or any valid topological ordering) ``` # Note * The graph\'s vertices are numbered from `0` to `num_vertices - 1`. * Any valid topological sort of the same graph will be accepted as the correct answer. * You may use any standard algorithm for topological sorting, such as Kahn\'s algorithm or Depth First Search (DFS).","solution":"from collections import deque class TopologicalSort: def __init__(self, num_vertices: int, edges: list[tuple[int, int]]): self.num_vertices = num_vertices self.edges = edges self.graph = [[] for _ in range(num_vertices)] self.in_degree = [0] * num_vertices # Construct the graph for u, v in edges: self.graph[u].append(v) self.in_degree[v] += 1 def sort(self) -> list[int]: # Create a queue to store vertices with no incoming edge queue = deque([i for i in range(self.num_vertices) if self.in_degree[i] == 0]) topo_order = [] while queue: vertex = queue.popleft() topo_order.append(vertex) # Decrease the in-degree of neighboring vertices for neighbor in self.graph[vertex]: self.in_degree[neighbor] -= 1 if self.in_degree[neighbor] == 0: queue.append(neighbor) # Check if there was a cycle if len(topo_order) == self.num_vertices: return topo_order else: raise ValueError(\\"The graph contains a cycle and is not a DAG.\\")"},{"question":"# Question Write a function that sorts a list of integers using the Merge Sort algorithm. Ensure the implementation handles both even and odd length lists, including an empty list and a single-element list. Function Signature ```python def merge_sort(arr: list[int]) -> list[int]: ``` Input * `arr` (list[int]): A list of integers to be sorted. Output * `list[int]`: A new list with elements sorted in non-decreasing order. Constraints * The length of the list can be up to `10^5`. * Each integer in the list will be within the range `-10^6` to `10^6`. Performance Requirements * The solution should run in O(n log n) time complexity and use O(n) space complexity. Example ```python print(merge_sort([38, 27, 43, 3, 9, 82, 10])) # Output: [3, 9, 10, 27, 38, 43, 82] print(merge_sort([])) # Output: [] print(merge_sort([1])) # Output: [1] print(merge_sort([2, 1])) # Output: [1, 2] ``` Note Remember to test your implementation with various edge cases such as an empty list, a single-element list, and lists with both negative and positive integers.","solution":"def merge_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the Merge Sort algorithm. if len(arr) <= 1: # Base case for recursion: an empty list or a single-element list return arr # Split the list into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the two halves in a sorted manner return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: Merges two sorted lists into a single sorted list. result = [] i = j = 0 # Merge the two lists by comparing their elements while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # Add any remaining elements from the left list while i < len(left): result.append(left[i]) i += 1 # Add any remaining elements from the right list while j < len(right): result.append(right[j]) j += 1 return result"},{"question":"Problem Description Given a list of integers representing the amounts of rainfall recorded each day for a week, write a function to determine the maximum amount of water that could be collected between buildings of different heights assuming that the list index represents the height of the buildings. Essentially, your task is to solve the Rain Water Trapping problem. Function Signature ```python def trap_rain_water(heights: List[int]) -> int: Given a list of heights representing the height of buildings, determine the maximum amount of water that can be trapped between the buildings after raining. Parameters: ---------- heights: List[int] - A non-empty list of non-negative integers representing the heights of the buildings. Returns: ------- int - The maximum amount of trapped water. Constraints: ----------- - 1 <= len(heights) <= 100000 - 0 <= heights[i] <= 10000 ``` Example ```python assert trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 assert trap_rain_water([4,2,0,3,2,5]) == 9 assert trap_rain_water([2,0,2]) == 2 assert trap_rain_water([3,2,1,2,3]) == 4 ``` # Constraints * Ensure the heights list contains only non-negative integers. * Handle cases where there are no buildings (i.e., heights list contains zeros). # Performance Requirement * The solution should have a time complexity of O(n) and a space complexity of O(n) or better if possible. # Edge Cases to Handle * If the heights list has all entries as zero (no water trapped). * If the heights list has only one entry (no water trapped). * If the heights list has entries of uniform height (no water trapped).","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: Given a list of heights representing the height of buildings, determine the maximum amount of water that can be trapped between the buildings after raining. Parameters: ---------- heights: List[int] - A non-empty list of non-negative integers representing the heights of the buildings. Returns: ------- int - The maximum amount of trapped water. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Subarray with Sum Zero Given an array of integers, write a function `subarray_with_sum_zero` that returns a boolean indicating whether there exists any subarray (of at least one element) which sums to zero. # Function Definition The function should be defined as follows: ```python def subarray_with_sum_zero(arr: list) -> bool: Determine if there exists a subarray with a sum of zero. Parameters: arr (list): A list of integers Returns: bool: True if there is a subarray with sum zero, False otherwise. ``` # Constraints: - The input array `arr` will have at most 10^5 elements. - Each element of the array will be in the range of `-10^5` to `10^5`. # Example: ```python assert subarray_with_sum_zero([1, 2, -3, 3, 1]) == True assert subarray_with_sum_zero([1, 2, 3, -6, 0]) == True assert subarray_with_sum_zero([4, -1, 2, 1, 6]) == False assert subarray_with_sum_zero([0]) == True assert subarray_with_sum_zero([1, 2, 3, 4, 5]) == False ``` # Requirements: 1. Implement the function with a time complexity better than O(n^2). 2. Make sure that the function handles both positive and negative integers correctly. 3. Ensure that the function performs well on large inputs, and consider edge cases such as empty arrays and arrays with all positive or all negative numbers. # Additional Information: * A subarray is a contiguous part of the array. * You are allowed to use extra space for achieving an efficient solution, but the function should run in linear time where possible.","solution":"def subarray_with_sum_zero(arr: list) -> bool: Determine if there exists a subarray with a sum of zero. Parameters: arr (list): A list of integers Returns: bool: True if there is a subarray with sum zero, False otherwise. prefix_sums = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in prefix_sums: return True prefix_sums.add(current_sum) return False"},{"question":"# Objective Write a function that simulates a basic traffic light controller at a four-way intersection. The traffic light controller should follow rules to ensure safe passage for vehicles from all directions. # Description Implement the function `traffic_light_controller(current_state: str, time_elapsed: int) -> str` that determines the next state for the traffic lights at the intersection. The intersection has four directions: North, South, East, and West, with the following possible traffic light states: - \\"NS_green_EW_red\\" - North-South is green, East-West is red. - \\"NS_yellow_EW_red\\" - North-South is yellow, East-West is red. - \\"NS_red_EW_green\\" - North-South is red, East-West is green. - \\"NS_red_EW_yellow\\" - North-South is red, East-West is yellow. The function transitions between states based on the time elapsed parameter, according to these rules: 1. \\"NS_green_EW_red\\" lasts for 60 seconds. 2. \\"NS_yellow_EW_red\\" lasts for 5 seconds. 3. \\"NS_red_EW_green\\" lasts for 60 seconds. 4. \\"NS_red_EW_yellow\\" lasts for 5 seconds. # Input * `current_state`: A string representing the current state of the traffic lights. It will be one of the valid states: \\"NS_green_EW_red\\", \\"NS_yellow_EW_red\\", \\"NS_red_EW_green\\", \\"NS_red_EW_yellow\\". * `time_elapsed`: An integer representing the time elapsed in seconds since the current state began. # Output * A string representing the next state of the traffic lights. # Constraints * `time_elapsed` will always be a non-negative integer. * The input `current_state` will always be one of the valid states. # Example ```python def traffic_light_controller(current_state: str, time_elapsed: int) -> str: # Write your implementation here pass # Example usage: print(traffic_light_controller(\\"NS_green_EW_red\\", 60)) # Output: \\"NS_yellow_EW_red\\" print(traffic_light_controller(\\"NS_yellow_EW_red\\", 5)) # Output: \\"NS_red_EW_green\\" print(traffic_light_controller(\\"NS_red_EW_green\\", 60)) # Output: \\"NS_red_EW_yellow\\" print(traffic_light_controller(\\"NS_red_EW_yellow\\", 5)) # Output: \\"NS_green_EW_red\\" ``` # Requirements 1. Ensure correct transitions between the traffic light states based on the given rules and time elapsed. 2. The function should not assume perfect input validity beyond the given constraints, and edge cases should be handled appropriately.","solution":"def traffic_light_controller(current_state: str, time_elapsed: int) -> str: Determines the next state of the traffic light based on the current state and time elapsed. # Define the state transition rules states = { \\"NS_green_EW_red\\": (\\"NS_yellow_EW_red\\", 60), \\"NS_yellow_EW_red\\": (\\"NS_red_EW_green\\", 5), \\"NS_red_EW_green\\": (\\"NS_red_EW_yellow\\", 60), \\"NS_red_EW_yellow\\": (\\"NS_green_EW_red\\", 5) } # Determine the next state based on time elapsed next_state, duration = states.get(current_state, (current_state, -1)) if time_elapsed >= duration: return next_state else: return current_state"},{"question":"# Reversible Parentheses Context In programming and computer science, balancing symbols such as parentheses, brackets, and braces is a fundamental concept in syntax. The concept is used in parsing, compilers, and error detection. Balancing parentheses involves matching every opening symbol with a corresponding closing one in the correct sequence. In this problem, we will extend the concept by checking if a given string of parentheses can be reversed to become balanced. Problem Statement You are required to write a function that determines if the parentheses in a given string can be reversed to make the entire string balanced. The string consists of only two types of parentheses: \'(\' and \')\'. Function Signature ```python def can_reverse_to_balance(s: str) -> bool: pass ``` Input - `s` (str): A string containing only parentheses \'(\', and \')\'. Output - `bool`: A boolean value indicating whether the string can be reversed to make a balanced parentheses string where each opening \'(\' has a corresponding closing \')\'. Constraints - The string will contain at least one character. - Length of the string: 1 ≤ |s| ≤ 10^6. - The string only consists of the characters \'(\' and \')\'. Examples ```python s1 = \\")))(((\\" s2 = \\"()())(\\" s3 = \\"((())\\" s4 = \\"(()))\\" assert can_reverse_to_balance(s1) == True assert can_reverse_to_balance(s2) == True assert can_reverse_to_balance(s3) == False assert can_reverse_to_balance(s4) == True ``` Notes - Ensure that your solution is efficient and can handle large input strings up to a length of 10^6. - Consider the possibility of reversing subsequences of the input string to discover if a balanced configuration can be achieved.","solution":"def can_reverse_to_balance(s: str) -> bool: Determines if the parentheses string can be reversed in portions to become balanced. # Count of each type of parenthesis count_open = s.count(\'(\') count_close = s.count(\')\') # For the string to be balanced after reversals, # the number of \'(\' and \')\' must be the same return count_open == count_close"},{"question":"# Context In a given 2D grid of dimensions `n` x `m`, each cell either contains land (`1`) or water (`0`). An island is a group of land cells (1s) connected horizontally or vertically. Additionally, a group is surrounded by water or the grid edges. # Task Write a function `number_of_islands(grid: List[List[int]]) -> int` that counts the number of distinct islands in the input 2D grid. # Input/Output Format * **Input**: A 2D list `grid` of dimensions `n` x `m` where `1` represents land and `0` represents water. * **Output**: An integer representing the number of distinct islands in the grid. # Constraints 1. (1 leq n, m leq 300) 2. The elements in the grid will be either `0` or `1`. # Requirements 1. Implement a BFS or DFS approach to explore each island. 2. Ensure your solution runs efficiently for the maximum input size. # Examples ```python >>> grid = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 1] ... ] >>> number_of_islands(grid) 3 >>> grid = [ ... [1, 0, 0, 0], ... [0, 1, 0, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 1] ... ] >>> number_of_islands(grid) 5 ``` # Performance Expectations The function should be capable of handling the largest inputs within a reasonable time frame, demonstrating efficiency with both DFS and BFS traversal techniques.","solution":"from typing import List def number_of_islands(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # mark as visited dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(grid, i, j) islands += 1 return islands"},{"question":"# Coding Assessment Question: You are tasked with designing a function that will help a logistics company calculate the fuel cost for a delivery vehicle based on the distance traveled and the vehicle\'s fuel efficiency. **Function Details**: * Write a function `calculate_fuel_cost(distance: float, fuel_efficiency: float, fuel_price: float) -> float` that calculates and returns the total fuel cost for the trip. **Input**: * `distance` (float): The total distance traveled in kilometers. Must be greater than 0. * `fuel_efficiency` (float): The vehicle\'s fuel efficiency in kilometers per liter (km/L). Must be greater than 0. * `fuel_price` (float): The price of fuel per liter in the local currency. Must be greater than 0. **Output**: * A single float value representing the total fuel cost for the trip. **Constraints**: * Real-life constraints apply (e.g., precision errors are tolerated within reasonable limits). **Performance Requirements**: * The implementation must process inputs and provide the result in constant time, O(1). **Scenario**: The logistics company operates a fleet of vehicles with varying fuel efficiencies. Accurate calculation of fuel costs is crucial for budgeting and pricing deliveries. This function will aid in providing quick and precise estimates for each journey. **Example Use Cases**: * `calculate_fuel_cost(500, 15, 1.3)` should return approximately `43.33`. * `calculate_fuel_cost(200, 10, 1.5)` should return approximately `30.00`. **Edge Cases**: * Inputs like `calculate_fuel_cost(0, 15, 1.3)` should raise an exception: `\\"Distance traveled must be > 0\\"`. * Inputs like `calculate_fuel_cost(500, 0, 1.3)` should raise an exception: `\\"Fuel efficiency must be > 0\\"`. * Inputs like `calculate_fuel_cost(500, 15, 0)` should raise an exception: `\\"Fuel price must be > 0\\"`. This new question complements the original set by exploring a different practical scenario where basic arithmetic and input validation are crucial, maintaining a similar level of complexity and technical demand.","solution":"def calculate_fuel_cost(distance: float, fuel_efficiency: float, fuel_price: float) -> float: Calculates the total fuel cost for a trip based on the distance traveled, the vehicle\'s fuel efficiency, and the price of fuel. Parameters: distance (float): The total distance traveled in kilometers. Must be greater than 0. fuel_efficiency (float): The vehicle\'s fuel efficiency in kilometers per liter (km/L). Must be greater than 0. fuel_price (float): The price of fuel per liter in the local currency. Must be greater than 0. Returns: float: The total fuel cost for the trip. if distance <= 0: raise ValueError(\\"Distance traveled must be > 0\\") if fuel_efficiency <= 0: raise ValueError(\\"Fuel efficiency must be > 0\\") if fuel_price <= 0: raise ValueError(\\"Fuel price must be > 0\\") fuel_needed = distance / fuel_efficiency total_cost = fuel_needed * fuel_price return total_cost"},{"question":"# API Consumption and Data Analysis Assessment Your task is to implement a Python function that retrieves city weather data from a public API and perform statistical analysis on the temperatures. This assessment will evaluate your understanding of API integration, data manipulation, and basic statistical calculations in Python. Context: You need to fetch weather data for a list of cities. The data includes current temperatures in Celsius. Your goal is to extract these temperatures and compute the average temperature across all cities. Task: 1. Write a function `get_city_temperatures(api_key: str, cities: list[str], timeout: int = 10) -> dict[str, float]` that takes an API key, a list of city names, and a timeout parameter. The function should fetch the current temperature for each city from the API and return a dictionary with city names as keys and their corresponding temperatures as values. 2. Write a second function `calculate_average_temperature(temperatures: dict[str, float]) -> float` that takes the dictionary returned by `get_city_temperatures` and computes the average temperature of all cities. Input: - `api_key`: (str) The API key for accessing the weather service. - `cities`: (list) List of city names for which the temperatures need to be fetched. - `timeout`: (int) The maximum time (seconds) to wait for a response from the API. Default is 10 seconds. - `temperatures`: (dict) Dictionary containing city names and their temperatures. Output: - For `get_city_temperatures`: A dictionary of city names and temperatures, where city names are strings and temperatures are floats. - For `calculate_average_temperature`: The average temperature across all cities as a float. Notes: - Use a public weather API that provides current temperature data (e.g., OpenWeatherMap or WeatherAPI). - Handle potential network errors and API response errors gracefully with appropriate exception handling. - Ensure the temperatures returned are in Celsius. - Ensure that the `calculate_average_temperature` function handles cases where the dictionary may be empty or contain invalid data. Constraints: - The list of cities should be reasonably sized to avoid excessive API calls. - The function must handle cases where the city might not be found or the API returns an error for that city. - Code should be written in a modular and readable manner. Example: Here is an example of expected function usage: ```python api_key = \\"your_api_key_here\\" cities = [\\"London\\", \\"New York\\", \\"Tokyo\\", \\"Sydney\\"] temperatures = get_city_temperatures(api_key, cities) average_temperature = calculate_average_temperature(temperatures) print(f\\"The average temperature is: {average_temperature:.2f}°C\\") ```","solution":"import requests def get_city_temperatures(api_key: str, cities: list[str], timeout: int = 10) -> dict[str, float]: Fetch the current temperature for each city from the weather API. Args: - api_key (str): API key for the weather service. - cities (list): List of city names. - timeout (int): Max time to wait for a response. Returns: - dict: Dictionary with city names as keys and their temperatures as values. base_url = \'http://api.openweathermap.org/data/2.5/weather\' temperatures = {} for city in cities: try: response = requests.get(base_url, params={ \'q\': city, \'appid\': api_key, \'units\': \'metric\' }, timeout=timeout) response.raise_for_status() data = response.json() temperatures[city] = data[\'main\'][\'temp\'] except (requests.RequestException, KeyError): temperatures[city] = None return temperatures def calculate_average_temperature(temperatures: dict[str, float]) -> float: Compute the average temperature across all cities. Args: - temperatures (dict): Dictionary of city names and their temperatures. Returns: - float: The average temperature. valid_temps = [temp for temp in temperatures.values() if temp is not None] if not valid_temps: return 0.0 return sum(valid_temps) / len(valid_temps)"},{"question":"# Task Create a simple text-based tic-tac-toe game where two players can play against each other by taking turns. # Objectives: 1. Write a function `initialize_board() -> List[List[str]]` to create a 3x3 game board initialized with empty spaces. 2. Implement the `print_board(board: List[List[str]]) -> None` function to display the current state of the board. 3. Implement the `make_move(board: List[List[str]], row: int, col: int, player: str) -> bool` function to update the board with the player\'s move. 4. Create a `check_winner(board: List[List[str]]) -> str` function to determine if there\'s a winner, or if the game is a draw. 5. Implement the `play_game()` function to facilitate the game play between two players, switching turns, and checking for win/draw conditions. # Function Definitions: - `initialize_board() -> List[List[str]]` - **Output**: A 3x3 list initialized with empty spaces. - `print_board(board: List[List[str]]) -> None` - **Input**: A 3x3 list representing the board state. - **Output**: None - `make_move(board: List[List[str]], row: int, col: int, player: str) -> bool` - **Input**: - board: A 3x3 list representing the board state. - row: Row index (0-2) where the player wants to make a move. - col: Column index (0-2) where the player wants to make a move. - player: A string representing the player (\'X\' or \'O\'). - **Output**: Boolean indicating whether the move was successful. - `check_winner(board: List[List[str]]) -> str` - **Input**: A 3x3 list representing the board state. - **Output**: A string indicating the winner (\'X\', \'O\', \'Draw\') or empty string if no winner yet. - `play_game() -> None` - **Output**: None # Example Usage: ```python # Example of playing a game: play_game() ``` # Detailed Steps and Constraints: 1. **initialize_board()** - Create a 3x3 list filled with empty spaces (\' \'). 2. **print_board(board)** - Print the board in a readable format, showing rows and columns. 3. **make_move(board, row, col, player)** - Check if the specified position is valid and empty. - Place the player\'s mark (\'X\' or \'O\') in the specified position if valid. - Return True if the move is successful, else False. 4. **check_winner(board)** - Check all rows, columns, and diagonals for a winning condition. - Return the winner (\'X\' or \'O\') or \'Draw\' if the board is full with no winner. - Return an empty string if there is no winner and the game is not a draw yet. 5. **play_game()** - Initialize the board and alternate moves between two players until there is a winner or the game is a draw. - Print the board state after each move and announce the winner/draw at the end. # Example Initialization and Moves ```python # Initializing Board board = initialize_board() print_board(board) # Making Moves make_move(board, 0, 0, \'X\') print_board(board) make_move(board, 1, 1, \'O\') print_board(board) # Checking Winner winner = check_winner(board) print(f\\"Winner: {winner}\\") ``` Implement these functions in Python following the provided specifications and constraints. Ensure the game logic works correctly for various possible scenarios.","solution":"from typing import List def initialize_board() -> List[List[str]]: Initialize the tic-tac-toe board as a 3x3 list filled with empty spaces. return [[\' \' for _ in range(3)] for _ in range(3)] def print_board(board: List[List[str]]) -> None: Print the current state of the board. for row in board: print(\'|\'.join(row)) print(\'-\' * 5) def make_move(board: List[List[str]], row: int, col: int, player: str) -> bool: Place the player\'s mark on the board at the specified row and column. Return True if the move is successful, False otherwise. if 0 <= row < 3 and 0 <= col < 3 and board[row][col] == \' \': board[row][col] = player return True return False def check_winner(board: List[List[str]]) -> str: Check if there is a winner or if the game is a draw. Return \'X\' or \'O\' if there is a winner, \'Draw\' if the board is full with no winner, or an empty string if there is no winner yet. # Check rows and columns for i in range(3): if board[i][0] == board[i][1] == board[i][2] != \' \': return board[i][0] if board[0][i] == board[1][i] == board[2][i] != \' \': return board[0][i] # Check diagonals if board[0][0] == board[1][1] == board[2][2] != \' \': return board[0][0] if board[0][2] == board[1][1] == board[2][0] != \' \': return board[0][2] # Check for draw if all(board[row][col] != \' \' for row in range(3) for col in range(3)): return \'Draw\' return \'\' def play_game() -> None: Facilitate the tic-tac-toe game play between two players, switching turns, and checking for win/draw conditions. board = initialize_board() current_player = \'X\' while True: print_board(board) row = int(input(f\\"Player {current_player}, enter row (0, 1, or 2): \\")) col = int(input(f\\"Player {current_player}, enter column (0, 1, or 2): \\")) if make_move(board, row, col, current_player): winner = check_winner(board) if winner: print_board(board) print(f\\"Winner: {winner}\\") break # Switch the current player current_player = \'O\' if current_player == \'X\' else \'X\' else: print(\\"Invalid move, try again.\\")"},{"question":"Problem Statement: You are given two strings, `str1` and `str2`, and your task is to determine the length of the longest substring that appears in both strings. Write a function `longest_common_substring(str1: str, str2: str) -> int` that performs this task. Function Signature: ```python def longest_common_substring(str1: str, str2: str) -> int: ... ``` Input: * Two strings, `str1` and `str2`, where both have a length between 1 and 1000. Output: * An integer representing the length of the longest common substring between `str1` and `str2`. Constraints: * The characters in both strings are ASCII characters. Example Usage: ```python print(longest_common_substring(\\"abcde\\", \\"abfde\\")) # Output: 2 print(longest_common_substring(\\"GeeksforGeeks\\", \\"GeeksQuiz\\")) # Output: 5 print(longest_common_substring(\\"abcdxyz\\", \\"xyzabcd\\")) # Output: 4 print(longest_common_substring(\\"zxabcdezy\\", \\"yzabcdezx\\")) # Output: 6 ``` Scenario: Imagine you are working on a bioinformatics project to compare DNA sequences. You need to find the longest common substring between two sequences to analyze their similarity. Efficiently calculating the longest common substring helps in multiple sequence alignment tasks, aiding in the identification of conserved regions. Your task is to develop an efficient algorithm to find the length of the longest substring that appears in both given sequences. Notes: Ensure the function handles cases where the strings have no common substring. Also, consider edge cases where one string is a complete subset of the other or where the common substring is at either end. Use dynamic programming to achieve an optimal solution with a time complexity of O(n*m), where n and m are the lengths of `str1` and `str2`, respectively.","solution":"def longest_common_substring(str1: str, str2: str) -> int: Returns the length of the longest common substring between str1 and str2. Uses dynamic programming to achieve this. len1, len2 = len(str1), len(str2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_length = 0 for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"# Checking for Palindromic Substrings You are required to write a function that checks if a given string contains any palindromic substrings of length greater than or equal to 3. The function should return `True` if any such substring exists, and `False` otherwise. Function Signature ```python def has_palindromic_substring(s: str) -> bool: ``` Input - `s` (str): The input string to be checked. Constraints: 0 ≤ len(s) ≤ 10^5 Output - (bool): `True` if the string contains at least one palindromic substring of length 3 or more, `False` otherwise. Constraints - Your function should raise a `TypeError` if the input is not a string. - The function should efficiently handle input strings up to the length constraint. Examples ```python print(has_palindromic_substring(\\"\\")) # Output: False print(has_palindromic_substring(\\"abc\\")) # Output: False print(has_palindromic_substring(\\"aba\\")) # Output: True print(has_palindromic_substring(\\"abba\\")) # Output: True print(has_palindromic_substring(\\"abcdedcba\\")) # Output: True print(has_palindromic_substring(\\"abcdefghij\\")) # Output: False ``` Notes - A palindromic substring is a substring that reads the same forward and backward, such as \\"aba\\" or \\"abba\\". - Consider using a sliding window or a center-expansion technique to check for palindromic substrings efficiently. - The function should be optimized to handle the upper limit of the input size constraint effectively.","solution":"def has_palindromic_substring(s: str) -> bool: Returns True if the input string contains any palindromic substrings of length greater than or equal to 3. Returns False otherwise. if not isinstance(s, str): raise TypeError(\\"The input should be a string\\") def is_palindrome(sub): return sub == sub[::-1] n = len(s) for length in range(3, n+1): for i in range(n - length + 1): if is_palindrome(s[i:i+length]): return True return False"},{"question":"**Problem Statement**: You are given an array of integers, which represents stock prices on consecutive days. Your task is to write a function `maxProfit` that computes the maximum profit you can achieve by buying and selling the stock. You are allowed to complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times), but you must sell the stock before you buy again. **Function Signature**: ```python def maxProfit(prices: List[int]) -> int: pass ``` **Input**: * A list of integers `prices` where each element represents the stock price on that day ( ( 0 leq text{len}(prices) leq 10^5 ) and ( 0 leq text{prices}[i] leq 10^4 ) ). **Output**: * An integer representing the maximum profit you can achieve. **Constraints**: * Your solution should handle the maximum input size efficiently. * The function should handle edge cases such as empty input gracefully. **Example**: ```python >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([7, 1, 5, 3, 6, 4]) 7 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([]) 0 ``` **Implementation Guidance**: 1. **Initialization**: Start by defining the `maxProfit` function with the appropriate input type. Initialize variables to keep track of profit. 2. **Iterative Computation**: Loop through the prices array while maintaining a transaction logic to calculate the profitable transactions. 3. **Cumulative Profit Calculation**: Accumulate the profit for every valid transaction where the selling price is higher than the buying price before it. 4. **Return Result**: Return the total accumulated profit at the end of the loop. **Edge Cases & Optimization**: * Handle the case when `prices` is an empty list by returning a profit of zero. * Consider situations where prices are constantly decreasing, and ensure the function correctly returns zero. * Ensure that the solution is efficient in terms of time complexity (ideally O(n)). **Notes**: * The function should consider TDD (Test Driven Development) to verify various scenarios. * Optimize both time and space complexity to handle large input sizes effectively. * Include inline comments and proper documentation for the function to ensure code clarity and ease of understanding.","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Computes the maximum profit possible with multiple transactions. :param prices: List of stock prices on consecutive days :return: Maximum profit if not prices: return 0 max_profit = 0 # Loop through the list and sum up the profit of all increasing sequences for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"# Coding Assessment Question Problem Statement You are required to write a function that generates Fibonacci numbers up to a given length `n`. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. Your function should handle input validation for the length and return an appropriate list of Fibonacci numbers. Function Specifications - **Function Name**: `generate_fibonacci` - **Input Parameters**: - `n` (int): A non-negative integer representing the number of Fibonacci numbers to generate. - **Output**: - Returns a list containing the first `n` Fibonacci numbers. - **Error Handling**: - Raise a `ValueError` if `n` is negative. - Raise a `TypeError` if `n` is not an integer. Example Usage ```python >>> generate_fibonacci(0) [] >>> generate_fibonacci(1) [0] >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(-1) Traceback (most recent call last): ... ValueError: Length of Fibonacci sequence can\'t be negative. >>> generate_fibonacci(\'five\') Traceback (most recent call last): ... TypeError: The length of the Fibonacci sequence must be an integer. ``` Constraints - You must handle typical input values and ensure that the function performs correctly within these constraints. Solution Template ```python def generate_fibonacci(n: int) -> list: Generate a list of the first n Fibonacci numbers. :param n: The number of Fibonacci numbers to generate (must be non-negative integer) :return: List containing the first n Fibonacci numbers if not isinstance(n, int): raise TypeError(\\"The length of the Fibonacci sequence must be an integer.\\") if n < 0: raise ValueError(\\"Length of Fibonacci sequence can\'t be negative.\\") if n == 0: return [] elif n == 1: return [0] fibonacci_sequence = [0, 1] for i in range(2, n): fibonacci_sequence.append(fibonacci_sequence[-1] + fibonacci_sequence[-2]) return fibonacci_sequence[:n] # Example usage print(generate_fibonacci(5)) # Output: [0, 1, 1, 2, 3] ```","solution":"def generate_fibonacci(n: int) -> list: Generate a list of the first n Fibonacci numbers. :param n: The number of Fibonacci numbers to generate (must be non-negative integer) :return: List containing the first n Fibonacci numbers if not isinstance(n, int): raise TypeError(\\"The length of the Fibonacci sequence must be an integer.\\") if n < 0: raise ValueError(\\"Length of Fibonacci sequence can\'t be negative.\\") if n == 0: return [] elif n == 1: return [0] fibonacci_sequence = [0, 1] for i in range(2, n): fibonacci_sequence.append(fibonacci_sequence[-1] + fibonacci_sequence[-2]) return fibonacci_sequence[:n]"},{"question":"# Implement AVL Tree You are assigned the task to implement an AVL Tree, which is a self-balancing binary search tree. AVL trees maintain their height by ensuring that for any node, the difference in height between its left and right subtrees is at most one. This self-balancing property helps keep various tree operations efficient. Description: Your task is to implement the core functionalities of an AVL Tree which includes insertion, deletion, and searching, while maintaining its self-balancing property. Functions to Implement: 1. **`insert(key: int) -> None`**: - Insert a new node with the given key into the AVL Tree while maintaining the balancing property. 2. **`delete(key: int) -> None`**: - Delete a node with the given key from the AVL Tree while ensuring the tree remains balanced. 3. **`search(key: int) -> bool`**: - Search for a node with the specified key and return `True` if found, otherwise return `False`. 4. **`inorder_traversal() -> List[int]`**: - Perform an in-order traversal of the tree and return the list of keys. Additional requirements: * Implement the rotations (left rotation and right rotation) needed for balancing the AVL Tree. * Handle edge cases such as inserting into an empty tree, deleting a leaf node, etc. * Ensure the implementation is efficient in terms of both time and space complexities. Example: Given an initial empty AVL Tree: 1. `insert(10)`: Tree now has one node with key `10`. 2. `insert(20)`: Balancing might be required. 3. `insert(30)`: Additional balancing to maintain the AVL properties. 4. `inorder_traversal()`: Should return `[10, 20, 30]`. 5. `search(20)`: Should return `True`. 6. `delete(20)`: Balancing might be necessary after deletion. 7. `inorder_traversal()`: Should now return `[10, 30]`. Input: - Keys to be inserted, deleted, or searched for, which are positive integers. Output: - Results from `search` and `inorder_traversal` functions. Performance Constraints: - All tree operations (insertion, deletion, and search) should maintain a time complexity of (O(log n)), where (n) is the number of nodes in the tree. - The implementation should optimally handle dynamic updates to the tree.","solution":"class AVLNode: def __init__(self, key, height=1, left=None, right=None): self.key = key self.height = height self.left = left self.right = right class AVLTree: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def update_height(self, node): if node: node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1 def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 self.update_height(y) self.update_height(x) return x def rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 self.update_height(x) self.update_height(y) return y def insert(self, key): def _insert(node, key): if not node: return AVLNode(key) if key < node.key: node.left = _insert(node.left, key) else: node.right = _insert(node.right, key) self.update_height(node) balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.rotate_right(node) if balance < -1 and key > node.right.key: return self.rotate_left(node) if balance > 1 and key > node.left.key: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and key < node.right.key: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node self.root = _insert(self.root, key) def delete(self, key): def _delete(node, key): if not node: return node if key < node.key: node.left = _delete(node.left, key) elif key > node.key: node.right = _delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self.get_min_value_node(node.right) node.key = temp.key node.right = _delete(node.right, temp.key) self.update_height(node) balance = self.get_balance(node) if balance > 1 and self.get_balance(node.left) >= 0: return self.rotate_right(node) if balance < -1 and self.get_balance(node.right) <= 0: return self.rotate_left(node) if balance > 1 and self.get_balance(node.left) < 0: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and self.get_balance(node.right) > 0: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node self.root = _delete(self.root, key) def search(self, key): def _search(node, key): if not node: return False if key == node.key: return True if key < node.key: return _search(node.left, key) else: return _search(node.right, key) return _search(self.root, key) def get_min_value_node(self, node): current = node while current.left: current = current.left return current def inorder_traversal(self): def _inorder(node): if node: return _inorder(node.left) + [node.key] + _inorder(node.right) return [] return _inorder(self.root)"},{"question":"# Prime Factorization Function Background Prime factorization involves expressing a number as a product of its prime numbers. Prime factorization is useful in various areas of number theory and has applications in cryptography and algorithms. Objective You are to write a function that returns the prime factorization of a given integer in the form of a dictionary. Function Signature ```python def prime_factors(n: int) -> dict: ``` Input - `n` (int): An integer which can be positive, negative, or zero. For a negative number, the result should include `-1` as one of the factors. Output - Return a dictionary where the keys are the prime factors and the values are their respective counts in the factorization of `n`. If `n` is zero, return an empty dictionary. Constraints - The input number `n` will be in the range representable by a 64-bit signed integer. - The input number may be positive, negative, or zero. Error Handling - If the input number is zero, return an empty dictionary `{}`. Examples ```python >>> prime_factors(18) {2: 1, 3: 2} >>> prime_factors(-18) {-1: 1, 2: 1, 3: 2} >>> prime_factors(0) {} >>> prime_factors(1) {} >>> prime_factors(29) {29: 1} >>> prime_factors(-1) {-1: 1} ``` # Explanation - For `18`, the prime factorization is `2 * 3 * 3`, so the function returns `{2: 1, 3: 2}`. - For `-18`, the prime factorization is `-1 * 2 * 3 * 3`, so the function returns `{-1: 1, 2: 1, 3: 2}`. - For `0` and `1`, the function should return an empty dictionary `{}`. - For `29`, since 29 is a prime number, the function returns `{29: 1}`. - For `-1`, the function returns `{-1: 1}` because -1 itself is not a positive integer but considered a factor when the number is negative.","solution":"def prime_factors(n: int) -> dict: Returns the prime factorization of a given integer n as a dictionary where the keys are the prime factors and the values are their respective counts. if n == 0: return {} abs_n = abs(n) factorization = {} # Handle negative numbers by including -1 as a factor if n < 0: factorization[-1] = 1 # Check for number of 2s that divide n while abs_n % 2 == 0: if 2 in factorization: factorization[2] += 1 else: factorization[2] = 1 abs_n //= 2 # Check for odd factors from 3 onwards factor = 3 while factor * factor <= abs_n: while abs_n % factor == 0: if factor in factorization: factorization[factor] += 1 else: factorization[factor] = 1 abs_n //= factor factor += 2 # If abs_n becomes a prime number greater than 2 if abs_n > 2: factorization[abs_n] = 1 return factorization"},{"question":"# Problem: Stock Price Fluctuation A stock prices monitoring system tracks the price of a particular stock at multiple timestamps throughout the day. You are required to write a function that calculates the maximum amount of profit that could be made from buying and then selling the stock within a given day. However, there\'s a catch: you can only buy the stock once and sell it once, and you must buy it before you sell it. # Task Implement the function `max_profit(prices: List[int]) -> int` which: - Takes a list of integers `prices` as input, where each integer represents the stock price at a specific timestamp in the order of occurrence through the day. - Returns an integer representing the maximum profit that can be made from one buy-sell transaction. If no profit can be made, return 0. # Input - `prices`: A list of integers (0 ≤ `prices[i]` ≤ 10^4) representing the stock prices at different timestamps. The length of the list will be in the range [1, 10^5]. # Output - An integer representing the maximum profit from one buy-sell transaction. # Constraints - You must buy before you sell stocks to make a valid profit. - The number of prices given in the list could be large, so the solution needs to be efficient regarding both time and space complexity. # Examples - `max_profit([])` should return `0`. - `max_profit([3, 8, 1, 4, 7, 9])` should return `8` (buy at price 1 and sell at price 9). - `max_profit([5, 4, 3, 2, 1])` should return `0` (no profit can be made). # Explanation To maximize profit: 1. Traverse the list while keeping track of the minimum stock price encountered so far. 2. For each price, calculate the potential profit if bought at the minimum price and sold at the current price. 3. Update the maximum profit encountered through the traversal. Here\'s one way to approach the solution: ```python def max_profit(prices: List[int]) -> int: if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit ``` This implementation ensures that we efficiently identify the largest profit by iterating through the list only once.","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Problem Statement: You are designing a feature for a social media platform where users can register with unique usernames. To ensure username availability and prevent duplicates, you need to write a function that checks the validity of a username based on a set of preexisting usernames and predefined rules. The rules for a valid username are: 1. It must start with a letter (either uppercase or lowercase). 2. It can only contain letters, digits, and underscores (`_`). 3. It must be between 4 and 20 characters long. 4. It should not be already taken by another user. Write a function `is_valid_username` that validates a username against these rules. Function Signature ```python def is_valid_username(username: str, existing_usernames: set) -> bool: ``` Input * `username` (str): The username to validate. * `existing_usernames` (set): A set of usernames that are already taken. Output * `is_valid` (bool): Returns `True` if the username is valid, otherwise returns `False`. Constraints * `username` will only contain printable ASCII characters. * The length of `username` will not exceed 100 characters. * `existing_usernames` can contain up to 1000 usernames. * Usernames in `existing_usernames` will be unique and follow the rules stated above. Example ```python existing_usernames = {\\"john_doe\\", \\"janeDoe123\\", \\"alice_99\\"} assert is_valid_username(\\"new_user\\", existing_usernames) == True assert is_valid_username(\\"john_doe\\", existing_usernames) == False assert is_valid_username(\\"123invalid\\", existing_usernames) == False assert is_valid_username(\\"short\\", existing_usernames) == True assert is_valid_username(\\"toooooooooooooooooooooooo_long_username\\", existing_usernames) == False assert is_valid_username(\\"valid_user123\\", existing_usernames) == True ``` # Evaluation Criteria * **Correctness**: The function should correctly validate usernames based on all given rules. * **Efficiency**: The function should handle the constraints efficiently, particularly when checking against a large set of existing usernames. * **Code Quality**: Code should be well-structured, readable, and follow best practices. # Hints 1. Use regular expressions to simplify the validity checks. 2. Ensure that edge cases such as empty strings, very long usernames, and already taken usernames are correctly handled. 3. Carefully handle the conditions where usernames start with non-letter characters or contain invalid characters.","solution":"import re def is_valid_username(username: str, existing_usernames: set) -> bool: Checks if the given username is valid based on predefined rules. Parameters: username (str): The username to validate. existing_usernames (set): A set containing usernames that are already taken. Returns: bool: True if the username is valid, False otherwise. # Rule 1: Username must start with a letter. if not username[0].isalpha(): return False # Rule 2: Username can only contain letters, digits, and underscores. if not re.match(r\'^w+\', username): return False # Rule 3: Username must be between 4 and 20 characters long. if not (4 <= len(username) <= 20): return False # Rule 4: Username must not be already taken. if username in existing_usernames: return False return True"},{"question":"# Coding Question You are given a list of integers where each integer appears exactly twice except for one unique integer that appears only once. Your task is to write a function `find_unique_integer(nums: List[int]) -> int` that takes this list and returns the unique integer that appears only once. Function Signature ```python def find_unique_integer(nums: List[int]) -> int: pass ``` Input * `nums`: A list of integers where every integer except one appears exactly twice. Output * `int`: The unique integer that appears only once in the list. Example ```python find_unique_integer([2, 3, 2, 4, 4, 5, 6, 5, 6]) # Output: 3 ``` Constraints * The list will contain at least three integers and at most 10,000 integers. * The solution should have a linear runtime complexity and use constant space.","solution":"from typing import List def find_unique_integer(nums: List[int]) -> int: Find the unique integer that appears only once in a list where every other integer appears exactly twice. unique = 0 for num in nums: unique ^= num return unique"},{"question":"# Largest Connected Component in a Graph You are given an undirected graph represented by an adjacency list where the nodes are integers. Write a function `largest_connected_component(adj_list: Dict[int, List[int]]) -> int` that returns the size of the largest connected component in the graph. Input * A dictionary `adj_list` where each key is an integer representing a node, and the corresponding value is a list of integers representing the nodes it is directly connected to. * The graph is guaranteed to be non-empty, and each value list in the dictionary will not contain duplicate nodes. Output * A single integer representing the size of the largest connected component in the graph. # Constraints * The function should handle different graph sizes efficiently. * Avoid using excessive memory or deep recursion to prevent stack overflow. # Example ```python adj_list = { 1: [2], 2: [1, 3], 3: [2, 4], 4: [3], 5: [6], 6: [5], 7: [] } assert largest_connected_component(adj_list) == 4 ``` Explanation * The connected components are: {1, 2, 3, 4}, {5, 6}, and {7}. * The largest connected component has size 4. Additional Guidelines * Explain the approach, edge cases, and handle potential errors. * Ensure your code is optimized to handle the constraints.","solution":"def largest_connected_component(adj_list): Returns the size of the largest connected component in the graph. Parameters: adj_list (dict): Adjacency list representation of the graph. Returns: int: The size of the largest connected component. def dfs(node, visited): stack = [node] size = 0 while stack: current = stack.pop() if current not in visited: visited.add(current) size += 1 for neighbor in adj_list[current]: if neighbor not in visited: stack.append(neighbor) return size visited = set() largest_size = 0 for node in adj_list: if node not in visited: component_size = dfs(node, visited) largest_size = max(largest_size, component_size) return largest_size"},{"question":"Imagine you are developing an image processing application that needs to identify and separate the red, green, and blue color channels from an RGB image. You are required to write a function that takes an RGB image and returns three separate images, each corresponding to one of the RGB color channels. # Your Task 1. **Define a function** `split_rgb(image: List[List[Tuple[int, int, int]]]) -> Tuple[List[List[int]], List[List[int]], List[List[int]]]`: - **Input**: A 2D list `image` where each element is a tuple representing an RGB pixel `(R, G, B)` with integer values ranging from 0 to 255. - **Output**: Three 2D lists, each one representing the red, green, and blue channels respectively. # Constraints 1. The input image will have dimensions `m x n`, where `1 <= m, n <= 2000`. 2. Each pixel in the RGB image is represented as a tuple `(R, G, B)`, where each value is an integer in the range [0, 255]. # Example ```python >>> image = [ [(255, 0, 0), (0, 255, 0), (0, 0, 255)], [(123, 123, 123), (76, 89, 90), (12, 34, 56)] ] >>> r_channel, g_channel, b_channel = split_rgb(image) >>> r_channel [ [255, 0, 0], [123, 76, 12] ] >>> g_channel [ [0, 255, 0], [123, 89, 34] ] >>> b_channel [ [0, 0, 255], [123, 90, 56] ] ``` # Hints - Traverse through each pixel of the image and appropriately extract the red, green, and blue channel values. - Make sure to maintain the dimensions of the input image for each of the output channel images. - Consider edge cases such as a single pixel image or images with uniform values across all channels.","solution":"from typing import List, Tuple def split_rgb(image: List[List[Tuple[int, int, int]]]) -> Tuple[List[List[int]], List[List[int]], List[List[int]]]: Splits an RGB image into its respective red, green, and blue channels. :param image: The input RGB image as a 2D list, with each element being a tuple (R, G, B) :return: Three 2D lists representing the red, green, and blue channels respectively m = len(image) n = len(image[0]) r_channel = [[0] * n for _ in range(m)] g_channel = [[0] * n for _ in range(m)] b_channel = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): r, g, b = image[i][j] r_channel[i][j] = r g_channel[i][j] = g b_channel[i][j] = b return r_channel, g_channel, b_channel"},{"question":"# Context You are given a linked list implementation in Python and tasked with augmenting the functionality of this linked list. There is an existing operation `reverse_even_values` that reverses nodes containing even values in the list. # Task Implement a function `merge_sorted_linked_lists(cls, l1: \'LinkedList\', l2: \'LinkedList\') -> \'LinkedList\'`, which merges two sorted linked lists into one sorted linked list. # Function Signature ```python class LinkedList: @classmethod def merge_sorted_linked_lists(cls, l1: \'LinkedList\', l2: \'LinkedList\') -> \'LinkedList\': # Your code here ``` # Input * `l1`: The first sorted linked list. * `l2`: The second sorted linked list. # Output * Returns a new `LinkedList` object which is the result of merging the two input linked lists. # Constraints * The linked lists `l1` and `l2` are sorted in non-decreasing order. * 0 <= `length of l1, length of l2` <= 500. # Example ```python >>> l1 = LinkedList([1, 3, 5]) >>> l2 = LinkedList([2, 4, 6]) >>> result = LinkedList.merge_sorted_linked_lists(l1, l2) >>> tuple(result) (1, 2, 3, 4, 5, 6) >>> str(result) \'1 -> 2 -> 3 -> 4 -> 5 -> 6\' >>> l1 = LinkedList([1, 2, 3]) >>> l2 = LinkedList([4, 5, 6]) >>> result = LinkedList.merge_sorted_linked_lists(l1, l2) >>> tuple(result) (1, 2, 3, 4, 5, 6) >>> str(result) \'1 -> 2 -> 3 -> 4 -> 5 -> 6\' ``` # Notes * The returned linked list should be a new instance and should not modify the input linked lists. * If either linked list is empty, return the non-empty linked list. If both are empty, return an empty linked list.","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self, values=[]): self.head = None for value in values: self.append(value) def append(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def __iter__(self): current = self.head while current: yield current.data current = current.next def __str__(self): return \' -> \'.join(map(str, self)) @classmethod def merge_sorted_linked_lists(cls, l1, l2): dummy = Node() tail = dummy p1, p2 = l1.head, l2.head while p1 and p2: if p1.data < p2.data: tail.next = p1 p1 = p1.next else: tail.next = p2 p2 = p2.next tail = tail.next if p1: tail.next = p1 if p2: tail.next = p2 merged = cls() merged.head = dummy.next return merged"},{"question":"# Problem Statement You are given a task to write a function that takes a string containing a list of integers separated by commas and returns the reversed list of integers. The input string will always be well-formed and will not contain any spaces. # Function Signature ```python def reverse_integer_list(s: str) -> list[int]: pass ``` # Input - A string `s` (1 ≤ len(s) ≤ 10^6) where each element is a digit or a comma. # Output - A list of integers representing the reversed list of integers parsed from the string. # Constraints - Optimize the function for both time and space complexity. # Example ```python assert reverse_integer_list(\\"1,2,3,4,5\\") == [5, 4, 3, 2, 1] assert reverse_integer_list(\\"10,20,30\\") == [30, 20, 10] assert reverse_integer_list(\\"99\\") == [99] assert reverse_integer_list(\\"123,456,789\\") == [789, 456, 123] ``` # Notes - Assume the input string `s` consists solely of digits and commas. - The function should handle the comma-separated values regardless of the number length. - The output list must maintain the integer data type for each element. # Performance Requirements - The solution must be linear in time complexity, O(n), with respect to the length of the input string `s`. - The space complexity should not exceed O(n), where `n` is the length of the input string. Good luck!","solution":"def reverse_integer_list(s: str) -> list[int]: This function takes a string containing a list of integers separated by commas and returns the reversed list of integers. Arguments: s (str): A string of comma-separated integers. Returns: list[int]: A list of integers in reverse order. # Split the string by commas to get individual integer strings str_list = s.split(\',\') # Convert each string to an integer and reverse order of the list int_list = [int(num) for num in str_list][::-1] return int_list"},{"question":"# Task: Implement a Function to Merge Sorted Arrays Using Divide and Conquer Problem Statement: You need to implement a function `merge_sorted_arrays(arrays: List[List[int]]) -> List[int]` that merges multiple sorted arrays into a single sorted array using a divide and conquer approach. Details: - **Input**: - `arrays (List[List[int]])`: A list of sorted arrays to be merged. Each inner array is individually sorted in ascending order. - **Output**: - `List[int]`: A single sorted array that contains all elements from the input arrays in ascending order. Constraints: - The total number of elements in all arrays combined will not exceed 10^6. - Each individual array can be of varying length but will be sorted in ascending order. - The function should ideally have a time complexity of O(N log k) where N is the total number of elements and k is the number of arrays. Performance Requirements: - Efficiently handle merging large numbers of elements. - Utilize a divide and conquer strategy to ensure optimal performance. Scenario: Imagine you are building a large-scale real-time analytics system where multiple data streams (already sorted by timestamp) need to be merged into a single, ordered stream. Your function will be a critical part of ensuring that the final output is correctly sequenced for further processing. Edge Cases: - The input list is empty. - One or more of the input arrays is empty. - All input arrays are empty. - Arrays contain duplicate values. Example: ```python arrays = [[1, 3, 5], [2, 4, 6], [0, 7, 8, 9]] # Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ``` Skeleton Code: ```python from typing import List import heapq def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: def merge_two_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: # Implement helper function to merge two sorted arrays result = [] i, j = 0, 0 while i < arr1.length and j < arr2.length: if arr1[i] < arr2[j]: result.append(arr1[i]) i += 1 else: result.append(arr2[j]) j += 1 result.extend(arr1[i:]) result.extend(arr2[j:]) return result def divide_and_conquer(arrays: List[List[int]], left: int, right: int) -> List[int]: if left == right: return arrays[left] mid = left + (right - left) // 2 left_merged = divide_and_conquer(arrays, left, mid) right_merged = divide_and_conquer(arrays, mid + 1, right) return merge_two_sorted_arrays(left_merged, right_merged) if not arrays: return [] return divide_and_conquer(arrays, 0, len(arrays) - 1) ``` Hints: 1. Implement a helper function `merge_two_sorted_arrays` to merge two sorted arrays into one. 2. Use a divide and conquer approach to continually split the list of arrays until you are merging only two arrays at a time. 3. Carefully handle edge cases where arrays or elements are empty during the merge process. Implement `merge_sorted_arrays` function and write corresponding test cases to verify its correctness.","solution":"from typing import List def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: def merge_two_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: result = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: result.append(arr1[i]) i += 1 else: result.append(arr2[j]) j += 1 result.extend(arr1[i:]) result.extend(arr2[j:]) return result def divide_and_conquer(arrays: List[List[int]], left: int, right: int) -> List[int]: if left == right: return arrays[left] mid = left + (right - left) // 2 left_merged = divide_and_conquer(arrays, left, mid) right_merged = divide_and_conquer(arrays, mid + 1, right) return merge_two_sorted_arrays(left_merged, right_merged) if not arrays: return [] return divide_and_conquer(arrays, 0, len(arrays) - 1)"},{"question":"# Path Navigation in a Grid You are required to implement a function that finds the fastest (shortest time) path from the top-left corner to the bottom-right corner of a grid. Function Specifications Write a function `shortest_path` with the following signature: ```python def shortest_path(grid: list[list[int]]) -> int: ``` Input - `grid`: A list of lists containing integers representing the time required to traverse each cell. The list is guaranteed to be non-empty, and the grid is guaranteed to be rectangular. Output The function should return an integer representing the minimum time required to reach the bottom-right corner of the grid from the top-left corner. Constraints - (1 leq m, n leq 100) where (m) is the number of rows and (n) is the number of columns in the grid. - The time required to traverse any cell will be a non-negative integer. - Movements are allowed in four directions: up, down, left, and right. - The top-left cell is always accessible (non-negative time). Example ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(shortest_path(grid)) # Output: 7 ``` Notes 1. The function should apply a pathfinding algorithm such as Dijkstra\'s algorithm or A* to ensure the shortest path is found efficiently. 2. Ensure to handle the edge cases, such as when there is only one cell in the grid.","solution":"import heapq def shortest_path(grid: list[list[int]]) -> int: Finds the shortest path from the top-left corner to the bottom-right corner of the grid. Args: grid (list[list[int]]): A 2D list representing the time required to traverse each cell. Returns: int: The minimum time required to reach the bottom-right corner. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] pq = [(grid[0][0], 0, 0)] # (time, row, col) visited = set() heapq.heappush(pq, (grid[0][0], 0, 0)) while pq: time, r, c = heapq.heappop(pq) if (r, c) in visited: continue visited.add((r, c)) if r == rows - 1 and c == cols - 1: return time for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited: heapq.heappush(pq, (grid[nr][nc] + time, nr, nc)) return float(\'inf\') # this line is never reached with the given constraints"},{"question":"# Palindrome Permutation - Efficient Verification A string is said to be a permutation of a palindrome if it can be rearranged to form a palindrome. For instance, \\"civic\\" and \\"ivicc\\" are permutations of a palindrome, while \\"hello\\" is not. Your Task 1. **Optimize Verification**: Given the input string, optimize the verification process to determine if a permutation can form a palindrome. 2. **Function Implementation**: Implement a function to leverage efficient counting or bit manipulation techniques for this purpose. Requirements - Implement the function `can_form_palindrome(sequence: str) -> bool` to check if any permutation of the given string can form a palindrome. - Incorporate efficient methods to reduce the time complexity of the verification process. Input - A string `sequence` that may contain upper and lowercase letters as well as non-alphabetic characters. Output - Return `True` if any permutation of the input string can form a palindrome, otherwise return `False`. Constraints - The input string length will be ≤ 10^5. Performance - Aim to reduce the execution time and handle large input sizes effectively using appropriate data structures or algorithms. Example ```python >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> can_form_palindrome(\\"Was it a car or a cat I saw?\\") True ```","solution":"def can_form_palindrome(sequence: str) -> bool: Determines if any permutation of the input string can form a palindrome. # Using a set to track characters with odd counts char_count = set() # Iterate through each character in the input string for char in sequence: if char.isalnum(): # Ignore non-alphanumeric characters char = char.lower() # Treat upper and lower case letters as same if char in char_count: char_count.remove(char) else: char_count.add(char) # A permutation can form a palindrome if there\'s at most one character with an odd count. return len(char_count) <= 1"},{"question":"# Task: Implement Function to Simulate Backoff Retry Mechanism for Network Requests Problem Statement: You are tasked with implementing a function `fetch_with_backoff(url: str, max_retries: int, initial_delay: float) -> bool` that attempts to make an HTTP GET request to a given URL. In case of a failure, the function should employ an exponential backoff strategy, retrying the request up to `max_retries` times before giving up. If the request is successfully completed within the allowed retries, the function should return `True`, otherwise `False`. Details: - **Input**: - `url (str)` : The URL to make the GET request to. - `max_retries (int)` : The maximum number of retry attempts in case of failure. - `initial_delay (float)` : The initial delay in seconds before the first retry. - **Output**: - `bool` : Returns `True` if the request is successfully completed within the retry limit, otherwise `False`. Constraints: - Network failures may include timeouts, connection errors, or server-side errors (status codes other than 2xx). - The backoff delay should double with each retry (`initial_delay, 2 * initial_delay, 4 * initial_delay`, etc.). - The function should handle and properly log exceptions to aid in debugging. - The library `requests` should be used for HTTP requests, and `time` for implementing the delay. Performance Requirements: - The function should minimize waiting time by efficiently handling backoff mechanisms. - Proper management of retries to ensure the application does not become unresponsive. Scenario: Consider a service that queries an external API to fetch critical data for processing. Implementing a backoff retry mechanism ensures that transient network issues do not disrupt the service, improving robustness and reliability. Edge Cases: - The URL is invalid or unreachable. - There is a consistent network outage. - The API server returns a high rate of server errors (500-series status codes). Skeleton Code: ```python import requests import time def fetch_with_backoff(url: str, max_retries: int, initial_delay: float) -> bool: delay = initial_delay for attempt in range(max_retries + 1): try: response = requests.get(url) if response.status_code == 200: return True else: print(f\\"Attempt {attempt + 1} failed with status code: {response.status_code}\\") except requests.RequestException as e: print(f\\"Attempt {attempt + 1} failed with exception: {e}\\") if attempt < max_retries: time.sleep(delay) delay *= 2 return False ``` Hints: 1. Use `requests.get()` to make the HTTP GET request. 2. Handle specific exceptions to log only on certain failures. 3. Print out the reasons for failure to assist in debugging and monitoring. Implement `fetch_with_backoff` function and write corresponding test cases to verify its correctness using mock objects to simulate various request responses and network conditions.","solution":"import requests import time def fetch_with_backoff(url: str, max_retries: int, initial_delay: float) -> bool: Attempts to make an HTTP GET request to the given URL with an exponential backoff retry mechanism. Parameters: url (str): The URL to make the GET request to. max_retries (int): The maximum number of retry attempts in case of failure. initial_delay (float): The initial delay in seconds before the first retry. Returns: bool: True if the request is successfully completed within the retry limit, otherwise False. delay = initial_delay for attempt in range(max_retries + 1): try: response = requests.get(url) if response.status_code == 200: return True else: print(f\\"Attempt {attempt + 1} failed with status code: {response.status_code}\\") except requests.RequestException as e: print(f\\"Attempt {attempt + 1} failed with exception: {e}\\") if attempt < max_retries: time.sleep(delay) delay *= 2 return False"},{"question":"# Question Scenario: You are developing a utility tool that analyzes the content of text files. One of the features needed is to identify and count the number of words in a given string. A \\"word\\" is defined as a sequence of characters separated by whitespace characters such as spaces, tabs, or newlines. Task: Implement the function `count_words` that takes a single string input and returns the total number of words in that string. For this task, consider a word to be any sequence of characters separated by whitespace. Implementation: 1. Define the function `count_words(s: str) -> int`. 2. Ensure the function handles the following: * Input validation to ensure the input is a string. * Count words separated by any whitespace characters. 3. Optimize for performance (O(n) time complexity). Input: * A single string `s`. Output: * An integer representing the number of words in the input string. Constraints: * The input length does not exceed 10^6 characters. * The input string may include multiple whitespace characters, including tabs and newlines. Examples: ```python >>> count_words(\\"hello world\\") 2 >>> count_words(\\"hello world\\") 2 >>> count_words(\\"hellonworld\\") 2 >>> count_words(\\" \\") 0 >>> count_words(\\"Count thesenwords\\") 3 >>> count_words(\\"Python programming is fun\\") 4 ``` Performance Requirements: The function should run efficiently with a linear time complexity with respect to the input string\'s length, ensuring it can handle large inputs up to 10^6 characters.","solution":"def count_words(s: str) -> int: Returns the number of words in the input string. A word is defined as any sequence of characters separated by whitespace characters. Parameters: s (str): The input string. Returns: int: The number of words in the input string. # Split the input string by whitespace words = s.split() # Return the number of words return len(words)"},{"question":"# Coding Question: **Scenario:** You are developing an e-commerce platform, and you need to implement a feature that suggests a list of products based on categories and user preferences. Each product is associated with a category, and each user has a list of preferred categories. Your task is to create a function that filters and ranks products based on a given user\'s preferred categories. **Task:** Write a function `suggest_products` that takes a list of products, each represented as a dictionary with keys \\"name\\" and \\"category\\", and a list of user\'s preferred categories. The function should return a list of suggested products sorted by their preference ranking. **Function Signature:** ```python def suggest_products(products: List[Dict[str, str]], preferred_categories: List[str]) -> List[Dict[str, str]]: pass ``` **Parameters:** * `products` (List[Dict[str, str]]): A list of dictionaries where each dictionary represents a product with keys \\"name\\" and \\"category\\". * `preferred_categories` (List[str]): A list of category names that the user prefers in order of preference. **Returns:** * List[Dict[str, str]]: A list of dictionaries representing the suggested products sorted by the user\'s preference ranking. **Example:** ```python products = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\"}, {\\"name\\": \\"Shirt\\", \\"category\\": \\"Clothing\\"}, {\\"name\\": \\"Phone Case\\", \\"category\\": \\"Electronics\\"}, {\\"name\\": \\"Jeans\\", \\"category\\": \\"Clothing\\"}, {\\"name\\": \\"Coffee Mug\\", \\"category\\": \\"Home\\"}, {\\"name\\": \\"Notebook\\", \\"category\\": \\"Stationery\\"} ] preferred_categories = [\\"Electronics\\", \\"Clothing\\"] assert suggest_products(products, preferred_categories) == [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\"}, {\\"name\\": \\"Phone Case\\", \\"category\\": \\"Electronics\\"}, {\\"name\\": \\"Shirt\\", \\"category\\": \\"Clothing\\"}, {\\"name\\": \\"Jeans\\", \\"category\\": \\"Clothing\\"} ] ``` **Constraints:** * The function should handle an empty list of products or preferred categories gracefully (return an empty list). * If a product\'s category does not match any preferred category, it should be excluded from the results. * Products should be sorted in the order of the preferred categories. **Performance Requirements:** Your solution should efficiently handle lists of up to 10,000 products and categories without significant performance degradation. Ensure that the output order strictly adheres to the order of the `preferred_categories` list.","solution":"from typing import List, Dict def suggest_products(products: List[Dict[str, str]], preferred_categories: List[str]) -> List[Dict[str, str]]: Suggests a list of products based on categories and user preferences. Parameters: - products (List[Dict[str, str]]): A list of products each represented with a name and category. - preferred_categories (List[str]): A list of preferred category names in order of preference. Returns: - List[Dict[str, str]]: A list of suggested products sorted by the user\'s preference ranking. # Creating an empty list to store the suggested products suggested_products = [] # Iterate through each preferred category for category in preferred_categories: # Filter products that match the current preferred category category_products = [product for product in products if product[\\"category\\"] == category] # Append these filtered category products to the suggested products list suggested_products.extend(category_products) return suggested_products"},{"question":"# Sum of Subset Combinations Scenario You are developing a feature for a financial application that needs to analyze potential investment portfolios by evaluating all possible subsets of a given set of financial assets. For each subset, you want to compute the sum of their values. This will help in assessing different possible portfolio values efficiently. Task Implement the `sum_of_subsets` function that computes the sum of all possible subsets of a given list of integers. Function Signature ```python def sum_of_subsets(nums: List[int]) -> List[int]: ``` Input * `nums`: A list of `n` integers (`0 <= n <= 15`), representing the values of different financial assets. Output A list of integers representing the sum of all subsets, ordered by the number of elements in the subsets (subsets with fewer elements first). Constraints * The list `nums` may contain negative integers. * The subsets should be considered in non-decreasing order of their sizes. Example Consider the following input: ```python # Input List nums = [1, 2, 3] # Expected Output # Sums of subsets: [0, 1, 2, 3, 3, 4, 5, 6] ``` - Explanation: - Subsets are: [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] - Their sums are: 0, 1, 2, 3, 3, 4, 5, 6, respectively. Performance Requirements Ensure the algorithm can handle the constraint of up to (2^n) possible subsets efficiently for a maximum ( n ) of 15. This question is designed to evaluate the ability to handle combinatorial logic and familiarity with subsets and their manipulation in programming.","solution":"from itertools import combinations from typing import List def sum_of_subsets(nums: List[int]) -> List[int]: Computes the sum of all possible subsets of a given list of integers. Args: nums (List[int]): A list of integers representing the values of different financial assets. Returns: List[int]: A list of integers representing the sum of all subsets, ordered by the number of elements in the subsets. result = [] n = len(nums) # Iterate over all possible subset sizes from 0 to n for size in range(n + 1): # Generate all combinations of a given size for comb in combinations(nums, size): result.append(sum(comb)) return result"},{"question":"# Question: Calculating Factorial of Large Numbers Objective Implement a function to compute the factorial of a given non-negative integer. The function should be able to handle very large numbers and should also be optimized for performance. Function Signature ```python def large_factorial(num: int) -> str: Calculates the factorial of a non-negative integer. Parameters: num (int): The non-negative integer for which the factorial is to be computed. Returns: str: The factorial of the number as a string to accommodate large values. ``` Input - **num**: A non-negative integer representing the number for which the factorial is to be computed. Output - Returns the factorial of the given number as a string to handle very large outputs. Constraints - The function should correctly handle large numbers (e.g., 100!). - Ensure that the function does not use external libraries except for basic built-ins. - Raise a `ValueError` if the input is a negative integer or not an integer at all. Example Usage ```python print(large_factorial(5)) # Output: \\"120\\" print(large_factorial(10)) # Output: \\"3628800\\" print(large_factorial(20)) # Output: \\"2432902008176640000\\" ``` Explanation For the number 5: - Factorial of 5: 5! = 5 * 4 * 3 * 2 * 1 = 120 - Hence, the function returns \\"120\\". Tips 1. Use an iterative approach to determine factorial to avoid recursion limits with large input values. 2. Consider edge cases such as `0!` which is `1`. 3. Ensure the function outputs string representation of numbers to accommodate very large integer results that cannot be handled as standard integers in Python. This question reinforces concepts of iteration, handling large integers, exception handling, and efficient computation, aligning well with the original set.","solution":"def large_factorial(num: int) -> str: Calculates the factorial of a non-negative integer. Parameters: num (int): The non-negative integer for which the factorial is to be computed. Returns: str: The factorial of the number as a string to accommodate large values. if not isinstance(num, int) or num < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if num == 0: return \\"1\\" result = 1 for i in range(2, num + 1): result *= i return str(result)"},{"question":"# Coding Assessment Task: Context: You are a software developer working on a project that involves manipulating sequences of integers. One particular task requires you to compute the \\"snake\\" sum of an integer list. The \\"snake\\" sum is defined as the sum of an alternating sequence of integers, where you start by adding the first integer, subtract the second, add the third, subtract the fourth, and so on. Problem Statement: Given a list of integers, write a function `snake_sum` that calculates the \\"snake\\" sum of the list. Function Signature: ```python def snake_sum(nums: list) -> int: pass ``` Input/Output: * **Input**: A list `nums` of integers. * **Output**: An integer representing the \\"snake\\" sum of the list. Constraints: - The list `nums` can contain up to 1000 integers. - Each integer in the list is between -1000 and 1000, inclusive. - The list can be empty. Examples: ```python >>> snake_sum([1, 2, 3, 4, 5]) 3 >>> snake_sum([10, -10, 10, -10]) 40 >>> snake_sum([-1, -2, -3, -4]) 2 >>> snake_sum([]) 0 ``` Notes: 1. Ensure that your solution efficiently handles the given constraints. 2. Validate any edge cases and handle an empty list appropriately by returning 0.","solution":"def snake_sum(nums: list) -> int: Calculate the \\"snake\\" sum of a list of integers. The snake sum is defined as the sum of an alternating sequence of integers, starting by adding the first integer, subtracting the second, adding the third, and so on. :param nums: List of integers. :return: The snake sum of the list. # Initialize the snake sum snake_sum_result = 0 # Iterate through the list with index to apply alternation for index, num in enumerate(nums): # Add the number if index is even, subtract if index is odd if index % 2 == 0: snake_sum_result += num else: snake_sum_result -= num return snake_sum_result"},{"question":"# Coding Challenge **Context**: You are given a collection of words. Your task is to determine the number of anagrams in the list. Two words are considered to be anagrams if they are made up of the same letters with the same frequencies. Function Signature: ```python def count_anagrams(words: List[str]) -> int: ``` Parameters: - `words`: a list of `n` strings. Each string represents a word. Output: - Return an integer representing the total number of pairs of anagrams in the list. Constraints: * All words are made up of lowercase English letters. * 1 ≤ len(words[i]) ≤ 100 for each word. * 1 ≤ n ≤ 10^5, the number of words in the list. Instructions: 1. Implement a function `is_anagram(word1, word2)` that returns `True` if `word1` is an anagram of `word2`, otherwise `returns False`. 2. Use this helper function in the function `count_anagrams(words)` to count and return the number of anagram pairs. 3. Optimize for performance to handle large lists. Example: ```python words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"golego\\", \\"evil\\", \\"vile\\", \\"live\\"] output = count_anagrams(words) print(output) ``` Expected Output: ``` 3 ``` Note: * This problem is designed to assess your understanding of string manipulation, hashing techniques, and your ability to implement efficient algorithms handling large data sets. * The three anagram pairs in the example are: (\\"listen\\", \\"silent\\"), (\\"silent\\", \\"enlist\\"), (\\"google\\", \\"golego\\"), (\\"evil\\", \\"vile\\"), (\\"vile\\", \\"live\\"), and (\\"live\\", \\"evil\\").","solution":"from collections import defaultdict from typing import List def count_anagrams(words: List[str]) -> int: This function counts the number of anagram pairs in the list of words. Args: words: List of strings where each string represents a word. Returns: Integer count of anagram pairs. anagram_map = defaultdict(int) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_map[sorted_word] += 1 anagram_pairs = 0 for count in anagram_map.values(): if count > 1: anagram_pairs += (count * (count - 1)) // 2 return anagram_pairs"},{"question":"# Scenario Sorting algorithms are fundamental in computer science and are frequently tested in coding assessments. One efficient sorting algorithm is QuickSort, which selects a \'pivot\' element from the array and partitions the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. # Task Write a Python function `quick_sort(arr: List[int]) -> List[int]` that sorts an array of integers in ascending order using the QuickSort algorithm. You are required to implement the partitioning and recursive sorting parts of the algorithm. # Input Specifications * `arr`: A list of integers. # Output Specifications * Returns a list of integers sorted in ascending order. # Constraints * The input list may contain up to 1000 integers. * Integers in the list can range from -10000 to 10000. # Example ```python >>> quick_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> quick_sort([3, -1, 2, 5, 4]) [-1, 2, 3, 4, 5] >>> quick_sort([1]) [1] >>> quick_sort([]) [] ``` # Requirements * Ensure the function handles both empty and non-empty lists. * Optimize the partition function to avoid worst-case scenarios (e.g., when the list is already sorted).","solution":"def quick_sort(arr): Sorts an array of integers in ascending order using the QuickSort algorithm. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: The list of integers sorted in ascending order. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Array Digits Sum Checker **Context**: The Tech-Mind organization performs various operations on arrays of integers for their digital processing systems. One frequent operation is to check if the sum of the digits of each element in an array equals a given target number. They need an efficient solution to automate this process for large datasets. **Objective**: Implement a function that checks if there exists an element in the array whose sum of digits is equal to a given target number. The solution needs to be scalable and handle large arrays efficiently. **Task**: Write a function, `has_digit_sum(arr: list[int], target: int) -> bool`, that determines if any element in the array has a digit sum equal to the target number. # Input and Output Specifications: * **arr**: A list of integers. * **target**: An integer representing the target digit sum. * **Return**: A boolean value - `True` if an element with the target digit sum exists, `False` otherwise. * **Constraints**: * Each element in `arr` will be a non-negative integer. * `arr` can be very large with up to 10^6 elements. * `target` will be a non-negative integer. # Function Signature: ```python def has_digit_sum(arr: list[int], target: int) -> bool: pass ``` # Examples: ```python >>> has_digit_sum([123, 456, 789], 6) True >>> has_digit_sum([234, 567, 890], 10) False >>> has_digit_sum([111, 222, 333], 3) True >>> has_digit_sum([444, 555, 666], 15) True >>> has_digit_sum([987, 876, 765], 12) False ``` # Details to Note: 1. If `arr` is empty, return `False`. 2. Ensure the solution operates efficiently for large input sizes. 3. If `target` is negative, it\'s not a valid input. In such a case, raise a `ValueError` stating \\"Target must be a non-negative integer\\". # Performance Requirements: 1. The digit sum calculation for each element should be optimized to O(log(n)) where n is the value of the element. 2. Overall solution should aim for linear time complexity O(m), where m is the number of elements in the array.","solution":"def has_digit_sum(arr: list[int], target: int) -> bool: if target < 0: raise ValueError(\\"Target must be a non-negative integer\\") def digit_sum(n: int) -> int: total = 0 while n > 0: total += n % 10 n //= 10 return total for number in arr: if digit_sum(number) == target: return True return False"},{"question":"# Image Resizing Function **Objective:** Implement an image resizing function that increases or decreases the size of a grayscale image using the nearest neighbor interpolation method. # Function Description ```python def resize_image(image: List[List[int]], new_height: int, new_width: int) -> List[List[int]]: Resizes a grayscale image to the provided dimensions using nearest neighbor interpolation. Parameters ---------- image: List[List[int]] The grayscale input image represented as a 2D list of integers. new_height: int The desired height of the resized image. new_width: int The desired width of the resized image. Returns ------- List[List[int]] The resized image represented as a 2D list of integers. pass ``` # Input Format * `image`: A 2D list where each element is an integer representing the pixel intensity (0 to 255) of the grayscale image. * `new_height`: An integer representing the height of the resized image. * `new_width`: An integer representing the width of the resized image. # Output Format * A 2D list of integers representing the resized image. # Constraints * `1 <= len(image), len(image[0]) <= 1000` * `1 <= new_height, new_width <= 1000` * The dimensions of `image` and the resized image can be different but should always be a valid 2D list. # Example Input ```python image = [ [0, 1, 2], [3, 4, 5], [6, 7, 8] ] new_height = 2 new_width = 2 ``` Output ```python [ [0, 2], [6, 8] ] ``` # Explanation To resize the image to the given dimensions using nearest neighbor interpolation: 1. Each pixel in the new image is mapped to the closest pixel in the original image. 2. The pixel value from the original image is assigned to the corresponding position in the new image. # Notes Focus on implementing an efficient solution that handles different image sizes and properly maps the pixel coordinates. Pay attention to both time and space efficiency when designing your solution and ensure that the resizing logic correctly interpolates based on nearest neighbors. Your task is to write a function that accurately resizes the given image while maintaining the integrity of the visual content.","solution":"def resize_image(image, new_height, new_width): Resizes a grayscale image to the provided dimensions using nearest neighbor interpolation. Parameters ---------- image: List[List[int]] The grayscale input image represented as a 2D list of integers. new_height: int The desired height of the resized image. new_width: int The desired width of the resized image. Returns ------- List[List[int]] The resized image represented as a 2D list of integers. old_height = len(image) old_width = len(image[0]) resized_image = [[0 for _ in range(new_width)] for _ in range(new_height)] for i in range(new_height): for j in range(new_width): # Map the pixel (i, j) from the new image to the old image old_i = round(i * (old_height / new_height)) old_j = round(j * (old_width / new_width)) # Ensure the indices are within bounds old_i = min(old_i, old_height - 1) old_j = min(old_j, old_width - 1) resized_image[i][j] = image[old_i][old_j] return resized_image"},{"question":"**Objective**: Create a function to determine if a series of delivery routes in a logistics company can be completed without encountering a dead-end or infinite loop. You are required to use depth-first search (DFS) to identify cycles within the route graph. # Input/Output Specifications * **Input**: A list of tuples where each tuple represents a delivery route between two locations `(start, end)`. The locations are represented by integers. * **Output**: Return `True` if the routes can be followed without an infinite loop; otherwise, return `False`. # Requirements 1. Implement the function `can_complete_routes`. 2. The function should: * Formulate a directed graph from the list of routes. * Use depth-first search (DFS) to detect cycles in the graph. * Return `True` if there are no cycles; otherwise, return `False`. # Context The logistics company wants to ensure their delivery schedules are feasible and that trucks can complete their routes without being stuck in an infinite cycle, rendering the routes unworkable. # Constraints * The graph represented by the routes can have up to 10^5 nodes. * The number of routes will not exceed the node count. # Example ```python # List of routes routes = [(0, 1), (1, 2), (2, 3), (3, 1)] # Calling the function to check if the routes can be completed print(can_complete_routes(routes)) # Output should be `False`, as there\'s a cycle routes = [(0, 1), (1, 2), (2, 3), (3, 4)] print(can_complete_routes(routes)) # Output should be `True`, as there\'s no cycle ``` # Implementation Complete the following function: ```python def can_complete_routes(routes): Checks if the given delivery routes can be completed without an infinite loop. :param routes: List of tuples representing directed edges in the graph. :return: Bool indicating if the routes can be completed without a cycle. def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False # Building the graph as an adjacency list graph = {} for start, end in routes: if start not in graph: graph[start] = [] graph[start].append(end) # initializing visited and recursion stack visited = {node: False for node in graph} rec_stack = {node: False for node in graph} for node in graph: if not visited[node]: if dfs(node, visited, rec_stack): return False return True ``` # Performance Requirements * Ensure that the solution does not exceed O(V + E) time complexity, where V is the number of vertices (nodes) and E is the number of edges (routes) in the graph. * Aim to limit additional space consumption to what is necessary for the DFS traversal.","solution":"def can_complete_routes(routes): Checks if the given delivery routes can be completed without an infinite loop. :param routes: List of tuples representing directed edges in the graph. :return: Bool indicating if the routes can be completed without a cycle. def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False # Building the graph as an adjacency list graph = {} for start, end in routes: if start not in graph: graph[start] = [] graph[start].append(end) visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return False return True"},{"question":"# Question: Prime Number Generation Using the Sieve of Eratosthenes You are tasked with implementing a function that generates all prime numbers up to a given integer `n` using the Sieve of Eratosthenes algorithm. This classic algorithm efficiently finds all primes smaller than or equal to a specified integer. Function Signature ```python def sieve_of_eratosthenes(n: int) -> list[int]: ``` Input * `n`: A positive integer. (2 ≤ n ≤ 10^6) Output * Returns a list of integers representing all prime numbers less than or equal to `n`. Constraints * The function should handle the smallest input (n = 2) and the largest input (n = 10^6) efficiently. * The function should raise a `ValueError` if the input `n` is less than 2. Example ```python # Expected to return the list [2, 3, 5, 7] as these are the primes less than or equal to 10 print(sieve_of_eratosthenes(10)) # Expected to return the list [2, 3, 5, 7, 11, 13, 17, 19] as these are the primes less than or equal to 20 print(sieve_of_eratosthenes(20)) # Expected to return [2] for the minimal input print(sieve_of_eratosthenes(2)) # Expected to raise ValueError as input is less than 2 print(sieve_of_eratosthenes(1)) ``` Note * Make sure to handle possible edge cases such as the smallest possible value of `n` and invalid inputs gracefully. * The Sieve of Eratosthenes algorithm involves iteratively marking the multiples of each prime starting from 2. Utilize this approach for optimal performance.","solution":"def sieve_of_eratosthenes(n: int) -> list[int]: if n < 2: raise ValueError(\\"n must be greater than or equal to 2\\") sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes p = 2 while p * p <= n: if sieve[p]: for multiple in range(p * p, n + 1, p): sieve[multiple] = False p += 1 return [p for p, is_prime in enumerate(sieve) if is_prime]"},{"question":"# Palindromic Substring Check You need to implement a function that checks if a given string contains a palindromic substring of length greater than 1. A palindromic substring is a contiguous sequence of characters within a string that reads the same forward and backward. # Function Signature ```python def contains_palindromic_substring(s: str) -> bool: pass ``` # Input and Output * **Input**: - `s` (type: `str`): The input string to be checked. * **Output**: - (type: `bool`): Returns `True` if the input string contains a palindromic substring of length greater than 1, otherwise `False`. # Constraints * The length of `s` is between 1 and 10^4. * The string `s` consists of only lowercase English letters. # Example ```python # Test case 1: s = \\"abac\\" # Expected output: True print(contains_palindromic_substring(s)) # Test case 2: s = \\"abcdef\\" # Expected output: False print(contains_palindromic_substring(s)) # Test case 3: s = \\"aabbcc\\" # Expected output: True print(contains_palindromic_substring(s)) ``` # Note - The function should efficiently check for any palindromic substring of length greater than 1. - The solution needs to be optimized to handle the maximum input size within a reasonable time frame.","solution":"def contains_palindromic_substring(s: str) -> bool: Check if the given string contains a palindromic substring of length greater than 1. Params: s (str): The input string to be checked. Returns: bool: Returns True if the input string contains a palindromic substring of length greater than 1, otherwise False. # Check if there is any palindrome longer than 1 n = len(s) for i in range(n-1): # Check for even length palindromes if s[i] == s[i + 1]: return True # Check for odd length palindromes l, r = i, i + 2 while l >= 0 and r < n and s[l] == s[r]: return True l -= 1 r += 1 return False"},{"question":"# Coding Assessment Question: Scenario: You are developing a feature for an online bookstore that suggests books to users based on their past reading habits. The suggestion algorithm needs to identify books that share the highest number of common genres with the books a user has already read. For this task, you will implement a function to find the book with the maximum number of matching genres from a given list of books. # Function Signature: ```python def suggest_book(read_books: List[Dict[str, List[str]]], available_books: List[Dict[str, List[str]]]) -> str: pass ``` # Input: * `read_books` (List[Dict[str, List[str]]]): A list of dictionaries, where each dictionary represents a book the user has read. Each dictionary has a \'title\' key and a \'genres\' key. - \'title\': (str) The title of the book. - \'genres\': (List[str]) A list of genres associated with the book. * `available_books` (List[Dict[str, List[str]]]): A list of dictionaries, where each dictionary represents a book available for recommendation. Each dictionary has a \'title\' key and a \'genres\' key. - \'title\': (str) The title of the book. - \'genres\': (List[str]) A list of genres associated with the book. # Output: * A string representing the title of the book with the highest number of matching genres with the user\'s read books. If there is a tie, return the title of the book that appears first in `available_books`. # Example: ```python read_books = [ {\\"title\\": \\"Book A\\", \\"genres\\": [\\"Fantasy\\", \\"Adventure\\"]}, {\\"title\\": \\"Book B\\", \\"genres\\": [\\"Science Fiction\\", \\"Drama\\"]}, {\\"title\\": \\"Book C\\", \\"genres\\": [\\"Fantasy\\", \\"Drama\\"]} ] available_books = [ {\\"title\\": \\"Book X\\", \\"genres\\": [\\"Fantasy\\", \\"Adventure\\", \\"Drama\\"]}, {\\"title\\": \\"Book Y\\", \\"genres\\": [\\"Science Fiction\\", \\"Fantasy\\"]}, {\\"title\\": \\"Book Z\\", \\"genres\\": [\\"Drama\\"]} ] assert suggest_book(read_books, available_books) == \\"Book X\\" ``` # Constraints: * The genres list for each book contains between 1 and 10 genres. * The title of each book is a non-empty string. * The total number of books in both `read_books` and `available_books` combined will not exceed 100. * Each genre in the genres list is unique and is between 1 and 20 characters long. # Performance Requirements: * Ensure your solution is efficient in terms of both time and space complexity to handle the given constraints. Implementation: Write the function `suggest_book` to identify and return the title of the book from `available_books` that has the highest number of common genres with the books in `read_books`. In case of tie, return the title of the book that appears first in the `available_books` list.","solution":"from typing import List, Dict def suggest_book(read_books: List[Dict[str, List[str]]], available_books: List[Dict[str, List[str]]]) -> str: read_genres = set() for book in read_books: read_genres.update(book[\'genres\']) max_common_genres = -1 suggested_book = \\"\\" for book in available_books: common_genres = len(set(book[\'genres\']).intersection(read_genres)) if common_genres > max_common_genres: max_common_genres = common_genres suggested_book = book[\'title\'] return suggested_book"},{"question":"Circular Prime Number Detection Description A circular prime is a prime number that remains prime when its digits are cyclically permuted in any order. For example, 197 is a circular prime because all rotations of its digits (197, 971, and 719) are prime. You need to determine whether a given integer is a circular prime. Task Implement the `is_circular_prime` function which checks if an integer is a circular prime. The function should generate all the cyclic permutations of the input number\'s digits and verify that all of these permutations are prime numbers. Function Signature ```python def is_circular_prime(n: int) -> bool: pass ``` Input - `n (int)`: An integer to check circular primality. (1 ≤ n ≤ 10^6) Output - `bool`: Returns `True` if the number is a circular prime, otherwise returns `False`. Constraints - You may assume that the number is positive and has no leading zeros. - Consider all numbers from 1 to 10^6 for the prime checking. Example ```python # Example 1 n = 197 result = is_circular_prime(n) # result should be True because 197, 971, and 719 are all primes. # Example 2 n = 23 result = is_circular_prime(n) # result should be False because 23 is prime, but 32 is not. ``` Hint - To generate all cyclic permutations of the digits of a number, consider treating the number as a circular list of its digits. - Utilize an efficient prime-checking mechanism like the Sieve of Eratosthenes to check for prime numbers up to the maximum possible value. You need to implement the logic to create all cyclic permutations of the given number\'s digits and check if each resulting number is prime. If all permutations are prime, return `True`; otherwise, return `False`.","solution":"def sieve_of_eratosthenes(limit): Generate a list of booleans where the index is marked True if it\'s a prime number. Uses Sieve of Eratosthenes method. is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return is_prime def is_prime(n, prime_check): Check if the number n is prime using the precomputed prime_check array return prime_check[n] def rotate_number(n): Generate all rotations of the digits of the number n rotations = [] s = str(n) for i in range(len(s)): rotated = s[i:] + s[:i] rotations.append(int(rotated)) return rotations def is_circular_prime(n): Check if the number n is a circular prime upper_limit = 1000000 primes_sieve = sieve_of_eratosthenes(upper_limit) # Generate all rotations of the number rotations = rotate_number(n) # Check if all rotations are prime for rota in rotations: if not is_prime(rota, primes_sieve): return False return True"},{"question":"# Summing Values at Specific Tree Levels Context: You are working as a software developer, tasked with processing data represented in a binary tree structure. One typical requirement is to calculate the sum of node values at a specific level of the tree. Understanding tree traversal and level-specific operations is crucial for this task. Task: Write a function `sum_at_level(root: Optional[TreeNode], level: int) -> int` that returns the sum of the node values at a given level in a binary tree. The `root` node is the starting point of the tree, and `level` is the tree level (with the root considered level 0). The tree nodes contain integer values. Input: * `root`: The root node of the binary tree, which may be `None` if the tree is empty. * `level`: An integer representing the target level whose node values need to be summed. Output: * An integer representing the sum of the node values at the specified level. Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_at_level(root: Optional[TreeNode], level: int) -> int: Example usage: >>> root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) >>> sum_at_level(root, 2) 9 >>> sum_at_level(root, 0) 1 >>> sum_at_level(None, 1) 0 ``` Constraints: * The tree has at most 1000 nodes. * Node values are integers, and can be negative or positive. * The target `level` will always be a non-negative integer. **Edge Cases to consider**: * An empty tree should result in a sum of 0. * Levels that exceed the height of the tree should also return 0. * Ensure invalid inputs (e.g., negative levels) are handled appropriately by your function.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_at_level(root: Optional[TreeNode], level: int) -> int: if root is None: return 0 if level < 0: return 0 current_level = 0 queue = [(root, current_level)] level_sum = 0 while queue: node, current_level = queue.pop(0) if current_level == level: level_sum += node.val elif current_level > level: break if node.left: queue.append((node.left, current_level + 1)) if node.right: queue.append((node.right, current_level + 1)) return level_sum"},{"question":"Problem Statement You have been asked to implement a simplified version of a text editor with the ability to find and replace words. More specifically, this editor will support the find-replace operation in such a way that the replacement word is inserted only if it does not break existing word boundaries. # Function Signature ```python def find_and_replace(text: str, original: str, replacement: str) -> str: ``` # Input * `text` (str): The original text to be modified (1 ≤ len(text) ≤ 1000). * `original` (str): The word to be found in the text (1 ≤ len(original) ≤ 50). * `replacement` (str): The word to replace the found instances (1 ≤ len(replacement) ≤ 50). # Output * Returns a modified string where all valid instances of `original` are replaced with `replacement`. # Constraints * The text and the input words (`original` and `replacement`) contain only lowercase English letters and spaces. * The replacement should only occur for whole words that match the `original` word and not for substrings of other words. # Example ```python find_and_replace(\\"the quick brown fox jumps over the lazy dog\\", \\"the\\", \\"a\\") # Returns: \\"a quick brown fox jumps over a lazy dog\\" find_and_replace(\\"a man a plan a canal panama\\", \\"a\\", \\"the\\") # Returns: \\"the man the plan the canal panama\\" find_and_replace(\\"this is a test\\", \\"is\\", \\"was\\") # Returns: \\"this was a test\\" find_and_replace(\\"misprint issue\\", \\"is\\", \\"was\\") # Returns: \\"misprint issue\\" ``` # Detailed Description Write the `find_and_replace` function which scans the input text and replaces all valid occurrences of the `original` word with the `replacement` word. A valid occurrence is defined strictly as a word match, not a substring within another word. Use spaces to determine word boundaries in the text. # Hints * Consider splitting the text into words and then performing replacements. * Ensure to handle cases where the `original` word appears at the start or end of the text. * Ensure that the replacement word does not affect portions of other words containing the `original` word as a substring. # Edge Cases * The `original` word might not be present in the `text` at all. * The `original` word might be the entire `text`. * The `text` could contain multiple occurrences of the `original` word.","solution":"def find_and_replace(text: str, original: str, replacement: str) -> str: This function finds all instances of the original word in the text and replaces them with the replacement word, such that only whole word matches are replaced and not substrings within other words. words = text.split() for i in range(len(words)): if words[i] == original: words[i] = replacement return \' \'.join(words)"},{"question":"Identifying Maximum Reward Path in a Grid **Objective**: Implement a function to identify the maximum reward that can be collected while traversing from the top-left to the bottom-right of a grid. **Scenario**: Given a 2D grid of integers representing rewards, identify the maximum reward path from the top-left to the bottom-right corner. You can only move right or down at any point in time. Function Signature ```python def max_reward_path(grid: List[List[int]]) -> int: pass ``` Input * `grid`: A 2D list of integers where each element represents the reward at that cell. Output * An integer representing the maximum reward collected following the best path. Constraints 1. The `grid` can have a size of up to 100x100. 2. Each cell in the grid contains an integer reward, with values ranging from -1000 to 1000. Performance Requirements * Efficiently compute the best path to handle maximum sizes within practical time limits. **Example** ```python grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # The function should return 21 for this case # The path: 1 -> 4 -> 7 -> 8 -> 9 ``` Write the function `max_reward_path` implementing the above logic. Ensure comprehensive tests with various grid sizes and reward values to accurately determine the maximum reward path.","solution":"from typing import List def max_reward_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a dp array to store the maximum reward collected up to each cell dp = [[0] * cols for _ in range(rows)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only get here from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only get here from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum reward path return dp[rows-1][cols-1]"},{"question":"# Problem Statement A rectangle is defined by its width `w` and height `h`. Your task is to compute the total number of rectangles of all possible sizes that can be formed within a given rectangle. A rectangle includes both horizontal and vertical alignments. For instance, within a 3x2 rectangle, there are several smaller rectangles (including the full rectangle itself). # Your Task Implement the function `count_rectangles(w: int, h: int) -> int` which computes and returns the total number of rectangles that can be formed within a rectangle of width `w` and height `h`. # Input Format - Two integers `w` and `h` representing the width and height of the rectangle. (1 <= w, h <= 1000) # Output Format - An integer representing the total number of rectangles that can be formed within the given rectangle. # Constraints - The dimensions of the rectangles are positive integers. - The complexity of your solution should handle the upper constraint efficiently. # Example ```python def count_rectangles(w: int, h: int) -> int: total_rectangles = 0 for width in range(1, w+1): for height in range(1, h+1): total_rectangles += (w - width + 1) * (h - height + 1) return total_rectangles if __name__ == \\"__main__\\": w = 3 h = 2 print(f\\"Total number of rectangles: {count_rectangles(w, h)}\\") # Expected Output: 18 ``` In the above example, `count_rectangles(3, 2)` should output `18`. # Notes - Consider geometric patterns and sum combinations to devise an efficient method of counting the sub-rectangles. - Ensure the function implementation is optimized for performance. - Appropriately handle edge cases (e.g., smallest possible rectangle).","solution":"def count_rectangles(w: int, h: int) -> int: Compute the total number of rectangles of all possible sizes that can be formed within a rectangle of width `w` and height `h`. total_rectangles = 0 for width in range(1, w + 1): for height in range(1, h + 1): total_rectangles += (w - width + 1) * (h - height + 1) return total_rectangles"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the optimal storage of items in a warehouse, ensuring minimal unused space. Your function should determine the maximum storage utilization given a list of `items_weights` and a `capacity` of the warehouse storage unit. # Requirements: Implement the function `optimal_storage` with the following signature: ```python def optimal_storage(items_weights: List[int], capacity: int) -> int: ``` # Parameters: - `items_weights` (List[int]): A list of integers representing the weights of different items to be stored. - `capacity` (int): An integer representing the maximum capacity of the warehouse storage unit. # Returns: - An integer representing the maximum combined weight of items that can be stored without exceeding the capacity. # Constraints: - The length of `items_weights` will not exceed 1000. - Each weight in `items_weights` and the `capacity` will be a non-negative integer. - The capacity will be a positive integer. # Example Usage: ```python >>> optimal_storage([1, 3, 4, 5], 7) 7 >>> optimal_storage([2, 2, 4, 6], 9) 9 >>> optimal_storage([5, 5, 5, 5], 10) 10 >>> optimal_storage([1, 2, 3, 8, 7, 4], 15) 15 ``` # Additional Instructions: Implement the function using dynamic programming to ensure efficiency. Your solution should handle edge cases and adhere to the provided constraints. # Explanation: In the first example, the optimal choice is to select the items with weights `3` and `4`, which sum to `7`, the maximum capacity allowed. In the second example, the choices are items with weights `2`, `2`, and `5`. Ensure that your solution is optimized for performance and handles the edge cases effectively. --- Feel free to test the final solution with the provided examples to verify its correctness and efficiency.","solution":"from typing import List def optimal_storage(items_weights: List[int], capacity: int) -> int: Determine the maximum combined weight of items that can be stored without exceeding the capacity. :param items_weights: List[int] - A list of weights of items. :param capacity: int - The maximum capacity of the warehouse storage unit. :return: int - The maximum combined weight of items that can be stored. # Initialize a list to store the maximum weight for each capacity from 0 to capacity dp = [0] * (capacity + 1) # Iterate through each item weight for weight in items_weights: # Traverse the capacities backwards from the given capacity to the weight of the current item for cap in range(capacity, weight - 1, -1): # Update the dp array with the maximum value by including the current item dp[cap] = max(dp[cap], dp[cap - weight] + weight) return dp[capacity]"},{"question":"# Median Finder **Context**: Finding the median of a list of numbers is a common task in data analysis. The median is the middle value in a list when the values are sorted in ascending order. If the list has an odd number of elements, the median is the middle one. If it has an even number of elements, the median is the average of the two middle numbers. **Objective**: Implement the `find_median` function that takes a list of numbers and returns the median. Additionally, design a comprehensive set of test cases to ensure the function works correctly for lists of varying lengths and values. **Function Signature**: ```python def find_median(numbers: list) -> float: pass ``` **Expected Input and Output**: * Input: A single list of floating-point or integer numbers (`list` of `float` or `int`). * Output: A single floating-point number (`float`), which is the median of the input list. **Performance Requirements**: * The function must have a time complexity of `O(n log n)` due to sorting the input list, where `n` is the length of the list. * The space complexity should be `O(n)`. **Constraints**: * The input list may contain any number of elements, including zero (which should return `None`). * Ensure the code raises `TypeError` if any element in the input list is not a number. **Example Cases**: * Odd Number of Elements: * Input: `[3, 1, 2]` * Output: `2.0` * Even Number of Elements: * Input: `[4, 1, 2, 3]` * Output: `2.5` * Single Element: * Input: `[5]` * Output: `5.0` * Empty List: * Input: `[]` * Output: `None` * Mixed Integers and Floats: * Input: `[1.5, 3, 2.5, 1]` * Output: `2.0` **Test Cases**: Provide a comprehensive set of tests ensuring that the function handles all typical and edge cases, including: * Lists of various lengths (even, odd, single element, no elements). * Handling lists with mixed numeric types (integers and floats). * Handling invalid non-numeric inputs within the list. **Implementation Example**: ```python def find_median(numbers: list) -> float: if not all(isinstance(x, (int, float)) for x in numbers): raise TypeError(\\"All elements in the list must be numbers\\") if not numbers: return None numbers.sort() mid = len(numbers) // 2 if len(numbers) % 2 == 0: return (numbers[mid - 1] + numbers[mid]) / 2 else: return float(numbers[mid]) def test_find_median() -> None: assert find_median([3, 1, 2]) == 2.0 assert find_median([4, 1, 2, 3]) == 2.5 assert find_median([5]) == 5.0 assert find_median([]) == None assert find_median([1.5, 3, 2.5, 1]) == 2.0 assert find_median([7, 4, 5, -2, 0, 6]) == 3.0 try: find_median([1, \\"2\\", 3]) except TypeError as e: assert str(e) == \\"All elements in the list must be numbers\\" if __name__ == \\"__main__\\": print(find_median([3, 1, 2])) # Expected output: 2.0 print(find_median([1, 2, 3, 4])) # Expected output: 2.5 print(find_median([7, 8, 9])) # Expected output: 8.0 ```","solution":"def find_median(numbers: list) -> float: if not all(isinstance(x, (int, float)) for x in numbers): raise TypeError(\\"All elements in the list must be numbers\\") if not numbers: return None numbers.sort() mid = len(numbers) // 2 if len(numbers) % 2 == 0: return (numbers[mid - 1] + numbers[mid]) / 2 else: return float(numbers[mid])"},{"question":"# Scenario: You are tasked with implementing a custom sorting algorithm for a collection of records in a library system. Each record contains a unique `id`, a `title`, and a `publication_year`. Your goal is to sort the records primarily by `publication_year` in ascending order. In cases where two records have the same `publication_year`, sort them by `title` in alphabetical order. If both `publication_year` and `title` are the same, maintain the original order (i.e., the sort should be stable). # Task: Write a function that sorts the list of records according to the specified criteria. Your function should take in a list of dictionaries, where each dictionary represents a record, and return a list of dictionaries sorted as described. # Function Signature: ```python def sort_library_records(records: List[Dict[str, Union[int, str]]]) -> List[Dict[str, Union[int, str]]]: pass ``` # Input: - `records`: A list of dictionaries where each dictionary represents a record with the following keys: - `id` (int): The unique identifier for the record. - `title` (str): The title of the record. - `publication_year` (int): The year the record was published. # Output: - A list of dictionaries representing the sorted records. # Example: ```python >>> records = [ {\\"id\\": 1, \\"title\\": \\"The Great Gatsby\\", \\"publication_year\\": 1925}, {\\"id\\": 2, \\"title\\": \\"1984\\", \\"publication_year\\": 1949}, {\\"id\\": 3, \\"title\\": \\"To Kill a Mockingbird\\", \\"publication_year\\": 1960}, {\\"id\\": 4, \\"title\\": \\"The Catcher in the Rye\\", \\"publication_year\\": 1951}, {\\"id\\": 5, \\"title\\": \\"Brave New World\\", \\"publication_year\\": 1932} ] >>> sort_library_records(records) [ {\\"id\\": 1, \\"title\\": \\"The Great Gatsby\\", \\"publication_year\\": 1925}, {\\"id\\": 5, \\"title\\": \\"Brave New World\\", \\"publication_year\\": 1932}, {\\"id\\": 2, \\"title\\": \\"1984\\", \\"publication_year\\": 1949}, {\\"id\\": 4, \\"title\\": \\"The Catcher in the Rye\\", \\"publication_year\\": 1951}, {\\"id\\": 3, \\"title\\": \\"To Kill a Mockingbird\\", \\"publication_year\\": 1960} ] ``` # Notes: - Use Python\'s built-in sorting functionality, ensuring the sort is stable. - The list of records can be large, so efficiency should be considered. - Assume all records are valid and contain the required fields (`id`, `title`, `publication_year`).","solution":"from typing import List, Dict, Union def sort_library_records(records: List[Dict[str, Union[int, str]]]) -> List[Dict[str, Union[int, str]]]: Sorts a list of library records first by publication year, and then by title alphabetically. :param records: List of dictionaries, where each dictionary has \'id\', \'title\', and \'publication_year\'. :return: Sorted list of dictionaries by \'publication_year\' and \'title\'. return sorted(records, key=lambda record: (record[\'publication_year\'], record[\'title\']))"},{"question":"# Context You are developing a software system where you need to track the status of various tasks. Each task can have one of three statuses: \\"todo\\", \\"in progress\\", or \\"done\\". To organize these tasks effectively and provide quick access, you decide to use a dictionary where keys are the task names and values are the statuses. # Task Create a class `TaskManager` that provides functionality to manage these tasks and their statuses. # Requirements * Implement the class `TaskManager` with the following methods: - `add_task(name: str, status: str) -> None`: Adds a task with the given name and status. If the task already exists, it should update the status. - `remove_task(name: str) -> None`: Removes the task with the given name. If the task does not exist, raise a `KeyError` with an appropriate message. - `get_status(name: str) -> str`: Returns the current status of the task with the given name. If the task does not exist, raise a `KeyError` with an appropriate message. - `list_tasks() -> List[str]`: Returns a list of all task names sorted in alphabetical order. - `tasks_by_status(status: str) -> List[str]`: Returns a list of task names that have the given status, sorted in alphabetical order. * Ensure input validation and raise appropriate exceptions for invalid inputs where necessary. * Add docstrings and appropriate error handling as seen in the provided code snippets. # Class Signature ```python class TaskManager: def __init__(self): pass def add_task(self, name: str, status: str) -> None: pass def remove_task(self, name: str) -> None: pass def get_status(self, name: str) -> str: pass def list_tasks(self) -> List[str]: pass def tasks_by_status(self, status: str) -> List[str]: pass ``` # Example Usage ```python >>> manager = TaskManager() >>> manager.add_task(\\"Task1\\", \\"todo\\") >>> manager.add_task(\\"Task2\\", \\"in progress\\") >>> manager.add_task(\\"Task3\\", \\"done\\") >>> manager.get_status(\\"Task1\\") \'todo\' >>> manager.list_tasks() [\'Task1\', \'Task2\', \'Task3\'] >>> manager.tasks_by_status(\\"todo\\") [\'Task1\'] >>> manager.remove_task(\\"Task2\\") >>> manager.list_tasks() [\'Task1\', \'Task3\'] >>> manager.get_status(\\"Task2\\") Traceback (most recent call last): ... KeyError: \'Task2 not found\' ``` # Constraints and Considerations * You should ensure that the status is one of the allowed statuses (\\"todo\\", \\"in progress\\", \\"done\\"). If not, raise a `ValueError` with an appropriate message. * Consider edge cases such as removing a task that does not exist or accessing the status of a task that is not in the dictionary.","solution":"from typing import List class TaskManager: VALID_STATUSES = {\\"todo\\", \\"in progress\\", \\"done\\"} def __init__(self): self.tasks = {} def add_task(self, name: str, status: str) -> None: Adds a task with the given name and status. If the task already exists, it updates the status. Raises ValueError if the status is not valid. if status not in self.VALID_STATUSES: raise ValueError(f\\"Invalid status \'{status}\'. Valid statuses are: {\', \'.join(self.VALID_STATUSES)}\\") self.tasks[name] = status def remove_task(self, name: str) -> None: Removes the task with the given name. If the task does not exist, raises KeyError. if name not in self.tasks: raise KeyError(f\\"Task \'{name}\' not found\\") del self.tasks[name] def get_status(self, name: str) -> str: Returns the current status of the task with the given name. If the task does not exist, raises KeyError. if name not in self.tasks: raise KeyError(f\\"Task \'{name}\' not found\\") return self.tasks[name] def list_tasks(self) -> List[str]: Returns a list of all task names sorted in alphabetical order. return sorted(self.tasks.keys()) def tasks_by_status(self, status: str) -> List[str]: Returns a list of task names that have the given status, sorted in alphabetical order. if status not in self.VALID_STATUSES: raise ValueError(f\\"Invalid status \'{status}\'. Valid statuses are: {\', \'.join(self.VALID_STATUSES)}\\") return sorted([name for name, current_status in self.tasks.items() if current_status == status])"},{"question":"# Question Scenario: You are developing an application that requires handling and processing a sequence of mathematical expressions involving common arithmetic operations. To ensure the expressions are evaluated correctly and efficiently, you decide to implement a stack-based approach to evaluate postfix (Reverse Polish Notation) expressions. Task: Implement the following functions: 1. **evaluate_postfix(expression: str) -> int**: - Given a postfix expression as a string, evaluates the expression and returns the result as an integer. 2. **is_operator(char: str) -> bool**: - Given a character `char`, returns `True` if the character is one of the arithmetic operators (+, -, *, /), otherwise returns `False`. 3. **perform_operation(op1: int, op2: int, operator: str) -> int**: - Given two operands `op1` and `op2` and an arithmetic operator `operator` as a character, performs the operation and returns the result as an integer. Function Definitions: ```python def evaluate_postfix(expression: str) -> int: pass def is_operator(char: str) -> bool: pass def perform_operation(op1: int, op2: int, operator: str) -> int: pass ``` Constraints: - Assume the postfix expression is a valid expression containing non-negative integers and the operators (+, -, *, /). - The expression is given as a single whitespace-separated string. - Division is integer division, discarding the fractional part. Example: ```python assert evaluate_postfix(\\"2 3 + 5 *\\") == 25 assert evaluate_postfix(\\"10 2 / 5 +\\") == 10 assert evaluate_postfix(\\"7 8 + 3 2 + /\\") == 3 ``` Performance Requirements: - Ensure the evaluation of the postfix expression is efficient, ideally O(n), where n is the number of tokens in the expression.","solution":"def evaluate_postfix(expression: str) -> int: stack = [] tokens = expression.split() for token in tokens: if is_operator(token): op2 = stack.pop() op1 = stack.pop() result = perform_operation(op1, op2, token) stack.append(result) else: stack.append(int(token)) return stack[0] def is_operator(char: str) -> bool: return char in \\"+-*/\\" def perform_operation(op1: int, op2: int, operator: str) -> int: if operator == \'+\': return op1 + op2 elif operator == \'-\': return op1 - op2 elif operator == \'*\': return op1 * op2 elif operator == \'/\': return op1 // op2"},{"question":"# Task: Find if a Path Exists in a 2D Grid **Scenario**: In this task, you\'ll determine if there exists a path from the top-left corner to the bottom-right corner of a 2D grid filled with 0s and 1s. You can only move horizontally or vertically to another 0. A path exists only if you can traverse through 0s. **Function Details**: * **Function Name**: `is_path_exist` * **Input Parameters**: - `grid` (List[List[int]]): A 2D list representing the grid where each element is either 0 (passable) or 1 (impassable). * **Output**: - A boolean value, `True` if there exists a path from the top-left corner to the bottom-right corner, `False` otherwise. * **Example Usage**: ```python >>> is_path_exist([ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 0], ... [1, 1, 1, 0] ... ]) True >>> is_path_exist([ ... [0, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 0] ... ]) False >>> is_path_exist([ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ... ]) False >>> is_path_exist([ ... [0] ... ]) True ``` # Constraints: - The size of the grid (n x m) will be in the range of 1 ≤ n, m ≤ 500. - Each element in the grid will be either 0 or 1. Consider using a breadth-first search (BFS) or depth-first search (DFS) algorithm to verify if a path exists while ensuring your solution is efficient for the given constraints.","solution":"from typing import List from collections import deque def is_path_exist(grid: List[List[int]]) -> bool: Determines if a path exists from the top-left corner to the bottom-right corner in a 2D grid. Traversal can only happen on 0s and moves can be made horizontally or vertically. :param grid: A 2D list representation of the grid where each element is either 0 (passable) or 1 (impassable). :return: True if a path exists, False otherwise. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set([(0, 0)]) while queue: x, y = queue.popleft() if x == rows - 1 and y == cols - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"# Matrix Path Finder Objective: You are tasked with implementing the `find_path` function, which determines if there exists a path from the top-left corner to the bottom-right corner of a given grid. The path can only move right or down at any step and must pass through cells with the value `1`. Function Signature: ```python def find_path(grid: list[list[int]]) -> bool: ``` Input: - `grid` (a list of lists of integers): A binary grid where cells contain either `0` or `1`. Constraints: (1 leq text{len(grid)}, text{len(grid[0])} leq 100). Output: - A boolean value `True` if there exists a path from the top-left to the bottom-right of the grid, and `False` otherwise. Requirements: 1. The function should handle special cases such as a single cell grid. 2. The function should efficiently check for the existence of the path. 3. If the starting or ending cell is `0`, the function should return `False`. Example: ```python >>> find_path([[1, 0, 1], [1, 1, 0], [0, 1, 1]]) True >>> find_path([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) False >>> find_path([[1]]) True >>> find_path([[0, 1], [1, 1]]) False ``` Hint: - Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) to explore possible paths. --- Implementation Notes: Implement the `find_path` function by considering the following steps: 1. Check if the starting or ending cell is `0`, and return `False` in such cases. 2. Use a queue or stack to explore the grid starting from the top-left corner. 3. Mark visited cells to avoid reprocessing. 4. If you reach the bottom-right corner, return `True`. ```python def find_path(grid): if grid[0][0] == 0 or grid[-1][-1] == 0: return False rows, cols = len(grid), len(grid[0]) visited = set() stack = [(0, 0)] while stack: x, y = stack.pop() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in ((0, 1), (1, 0)): nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) stack.append((nx, ny)) return False ```","solution":"def find_path(grid): if grid[0][0] == 0 or grid[-1][-1] == 0: return False rows, cols = len(grid), len(grid[0]) visited = set() stack = [(0, 0)] while stack: x, y = stack.pop() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in ((0, 1), (1, 0)): nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) stack.append((nx, ny)) return False"},{"question":"# Coding Assessment Question You have been provided with the implementation of the ReLU (Rectified Linear Unit) function, a widely used activation function in neural networks. To further evaluate your understanding of activation functions and their applications, you are tasked with implementing a custom activation function called the Leaky ReLU. # Scenario Your task is to implement an activation function called Leaky ReLU (Leaky Rectified Linear Unit). Unlike the standard ReLU, which outputs 0 for any input less than 0, Leaky ReLU allows a small, non-zero gradient α multiplied by the input for negative inputs. This characteristic helps to address the \\"dying ReLU\\" problem. # Function Definition Implement the function `leaky_rectified_linear_unit` that takes a vector of K real numbers and a real number α, and applies the Leaky ReLU function to each element of the vector. # Mathematical Definition For an input element x, the Leaky ReLU function f(x) is defined as follows: ``` f(x) = x if x >= 0 f(x) = α * x if x < 0 ``` where α is a predefined small positive real number. # Function Signature ```python def leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray: pass ``` # Input * `vector` (np.ndarray): An array containing K real numbers. * `alpha` (float): The small positive real number used for scaling negative inputs. # Output * Returns (np.ndarray): An array in which the Leaky ReLU function has been applied to each element. # Constraints * The input vector must be a NumPy array of real numbers. * The value of alpha will be a small positive real number (e.g., 0.01). # Performance Requirements Your implementation must perform the calculation efficiently in O(K) time and use O(K) auxiliary space. # Examples ```python >>> leaky_rectified_linear_unit(vector=np.array([3.2, -1.5, 0.0, -0.7]), alpha=0.01) array([ 3.2 , -0.015, 0. , -0.007]) >>> leaky_rectified_linear_unit(vector=np.array([-4.3, 0.0, 0.9, -0.2]), alpha=0.05) array([-0.215, 0. , 0.9 , -0.01 ]) ```","solution":"import numpy as np def leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray: Applies the Leaky ReLU function to each element of the vector. Parameters: - vector (np.ndarray): An array containing K real numbers. - alpha (float): The small positive real number used for scaling negative inputs. Returns: - np.ndarray: An array in which the Leaky ReLU function has been applied to each element. return np.where(vector >= 0, vector, alpha * vector)"},{"question":"# Problem Statement You are developing a software module to calculate the surface area of various geometrical shapes. The initial goal is to provide accurate surface area calculations for a sphere and a cylinder based on given dimensions. Your task is to implement a function that computes the surface area of a specified shape, either \\"sphere\\" or \\"cylinder\\", given appropriate parameters. # Function Signature ```python def surface_area(shape: str, **kwargs) -> float: Args: shape: the type of shape (\\"sphere\\" or \\"cylinder\\") **kwargs: - For \\"sphere\\": radius (float) - For \\"cylinder\\": radius (float), height (float) Returns: The surface area of the specified shape in square units Raises: ValueError: If invalid parameters or shapes are passed ``` # Input Format * `shape` (str): A string indicating the type of shape (\\"sphere\\" or \\"cylinder\\"). * `**kwargs`: Keyword arguments as follows: * For a sphere: `radius` (float) indicating the radius of the sphere (must be > 0). * For a cylinder: `radius` (float) indicating the radius of the cylinder base (must be > 0). `height` (float) indicating the height of the cylinder (must be > 0). # Output Format * A float representing the surface area of the specified shape in square units. # Constraints * `shape` must be either \\"sphere\\" or \\"cylinder\\". * `0 < radius <= 1e3` (maximum realistic radius for shapes) * `0 < height <= 1e3` (maximum realistic height for shapes) # Examples ```python >>> surface_area(shape=\\"sphere\\", radius=3) 113.09733552923255 >>> surface_area(shape=\\"cylinder\\", radius=3, height=5) 150.79644737231007 >>> surface_area(shape=\\"sphere\\", radius=-3) Traceback (most recent call last): ... ValueError: Invalid radius for sphere >>> surface_area(shape=\\"cylinder\\", radius=3, height=-5) Traceback (most recent call last): ... ValueError: Invalid height for cylinder >>> surface_area(shape=\\"cone\\", radius=3, height=5) Traceback (most recent call last): ... ValueError: Invalid shape ``` # Requirement * Perform input validation to handle edge cases. * Ensure that the function throws appropriate exceptions for invalid inputs.","solution":"import math def surface_area(shape: str, **kwargs) -> float: if shape == \\"sphere\\": radius = kwargs.get(\\"radius\\") if radius is None or radius <= 0 or radius > 1e3: raise ValueError(\\"Invalid radius for sphere\\") return 4 * math.pi * radius ** 2 elif shape == \\"cylinder\\": radius = kwargs.get(\\"radius\\") height = kwargs.get(\\"height\\") if radius is None or radius <= 0 or radius > 1e3: raise ValueError(\\"Invalid radius for cylinder\\") if height is None or height <= 0 or height > 1e3: raise ValueError(\\"Invalid height for cylinder\\") return 2 * math.pi * radius * (radius + height) else: raise ValueError(\\"Invalid shape\\")"},{"question":"# Problem Statement You are given a list of integers `arr` of size `n`. Your task is to write a function `find_strongest_product_subarray(arr: List[int]) -> int` that finds the highest product of any contiguous subarray within the given array `arr`. # Context This problem involves finding the maximum product of a subarray, which is related to the classic \\"maximum subarray problem\\" but focuses on products instead of sums. The challenge lies in handling negative numbers and zeros within the array. # Input * `arr` - A list of integers representing the array. (1 <= n <= 2 * 10^4), where elements can range from -100 to 100. # Output * An integer representing the highest product of any contiguous subarray within `arr`. # Constraints * The solution should aim for a time complexity better than O(n^2). # Example ```python assert find_strongest_product_subarray([2, 3, -2, 4]) == 6 assert find_strongest_product_subarray([-2, 0, -1]) == 0 assert find_strongest_product_subarray([-2, -3, 0, -2, -40]) == 80 assert find_strongest_product_subarray([6, -3, -10, 0, 2]) == 180 ``` # Hints 1. Track both the maximum and minimum products up to the current position since a large negative number might become the maximum product if multiplied by another negative number. 2. Consider resetting the product to 1 if a zero is encountered, as subarrays cannot productively span zeros.","solution":"from typing import List def find_strongest_product_subarray(arr: List[int]) -> int: This function finds the maximum product of any contiguous subarray within the given array `arr`. :param arr: List[int] : A list of integers representing the array. :return: int : The highest product of any contiguous subarray. if not arr: return 0 max_product = arr[0] min_product = arr[0] result = arr[0] for i in range(1, len(arr)): if arr[i] < 0: max_product, min_product = min_product, max_product max_product = max(arr[i], max_product * arr[i]) min_product = min(arr[i], min_product * arr[i]) result = max(result, max_product) return result"},{"question":"# Question: Implement Dynamic Load Balancer for Server Requests You are required to develop a dynamic load balancing algorithm for server requests. The algorithm should distribute incoming requests across a set of servers, ensuring that the load remains balanced while minimizing the overall response time. Task Write a function `dynamic_load_balancer` that simulates the distribution of incoming requests to servers. The number of servers is fixed, and the load on each server should be dynamically adjusted based on the incoming requests. Expected Input and Output Your function should have the following signature: ```python def dynamic_load_balancer(requests: list[int], num_servers: int) -> list[list[int]]: pass ``` **Input**: - A list of integers `requests`, where each integer represents the load of a single incoming request. - An integer `num_servers`, representing the number of servers available to handle the requests. **Output**: - A list of `num_servers` lists, where each inner list contains the loads of requests assigned to that server. Constraints * `1 <= len(requests) <= 10^4` * `1 <= request_load <= 10^3` * `1 <= num_servers <= 100` Performance Requirements Your solution should efficiently distribute the load to minimize response time and ensure no single server becomes a bottleneck. # Example ```python requests = [10, 20, 15, 30, 25, 5, 10] num_servers = 3 # Expected Output: # Server 1: [10, 30] # Server 2: [20, 25] # Server 3: [15, 5, 10] # Or any other distribution minimizing the balance difference between servers. ``` Context In a real-world scenario where servers handle varying volumes of requests, an efficient load balancing algorithm ensures optimal performance and resource utilization. This problem tests the ability to devise a strategy that evenly distributes load while minimizing latency and ensuring fair resource usage.","solution":"def dynamic_load_balancer(requests, num_servers): servers = [[] for _ in range(num_servers)] server_loads = [0] * num_servers for request in requests: # Find the server with the minimum load min_server_index = server_loads.index(min(server_loads)) # Assign the request to that server servers[min_server_index].append(request) # Update the load of the chosen server server_loads[min_server_index] += request return servers"},{"question":"# Question: Write a Python function `longest_annotation_sequence` that takes a list of strings representing annotations and returns the longest sequence of annotations that all have the same initial letter. Function Signature ```python def longest_annotation_sequence(annotations: list[str]) -> str: ``` # Input - `annotations`: A list of strings where each string represents an annotation. Each annotation will contain only alphabetical characters and will be non-empty. # Output - Returns a string which is the longest sequence of annotations (separated by spaces) that all start with the same letter. If there are multiple sequences with the same length, return the one that appears first in the list. # Constraints - All strings in the list `annotations` contain only uppercase and lowercase alphabetical characters. # Examples ```python assert longest_annotation_sequence([\\"apple\\", \\"avocado\\", \\"banana\\", \\"apricot\\", \\"blueberry\\", \\"aardvark\\"]) == \\"apple avocado apricot aardvark\\" assert longest_annotation_sequence([\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\"]) == \\"apple\\" assert longest_annotation_sequence([\\"banana\\", \\"avocado\\", \\"blueberry\\", \\"apple\\", \\"blackberry\\", \\"bluefish\\"]) == \\"banana blueberry blackberry bluefish\\" assert longest_annotation_sequence([]) == \\"\\" assert longest_annotation_sequence([\\"aa\\", \\"ab\\", \\"bc\\", \\"cd\\", \\"ba\\", \\"cc\\"]) == \\"aa ab\\" ``` # Requirements 1. The function must handle an empty list gracefully and return an empty string. 2. Handle input validation to ensure that each string contains only alphabetical characters. Raise a `ValueError` for invalid inputs. 3. Ensure the function performs efficiently for larger lists of annotations. # Scenario Consider you are building a system that processes annotations from various sources, and you need to identify patterns in these annotations. This function will help you find the longest sequences of annotations starting with the same letter, which may reveal some underlying categorization or tagging patterns in the data.","solution":"def longest_annotation_sequence(annotations: list[str]) -> str: if not all(annotation.isalpha() for annotation in annotations): raise ValueError(\\"All annotations must contain only alphabetical characters.\\") sequences = {} for annotation in annotations: key = annotation[0].lower() if key in sequences: sequences[key].append(annotation) else: sequences[key] = [annotation] longest_seqs = sorted(sequences.values(), key=lambda seq: (-len(seq), annotations.index(seq[0]))) if not longest_seqs: return \\"\\" return \\" \\".join(longest_seqs[0]) # Test cases to validate the implementation assert longest_annotation_sequence([\\"apple\\", \\"avocado\\", \\"banana\\", \\"apricot\\", \\"blueberry\\", \\"aardvark\\"]) == \\"apple avocado apricot aardvark\\" assert longest_annotation_sequence([\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\"]) == \\"apple\\" assert longest_annotation_sequence([\\"banana\\", \\"avocado\\", \\"blueberry\\", \\"apple\\", \\"blackberry\\", \\"bluefish\\"]) == \\"banana blueberry blackberry bluefish\\" assert longest_annotation_sequence([]) == \\"\\" assert longest_annotation_sequence([\\"aa\\", \\"ab\\", \\"bc\\", \\"cd\\", \\"ba\\", \\"cc\\"]) == \\"aa ab\\""},{"question":"# Scenario You are developing a feature for a text editor that automatically corrects basic spelling mistakes using a predefined dictionary. The feature should replace each misspelled word with the closest matching word from the dictionary in terms of Levenshtein distance. # Task Implement the function `auto_correct` that takes a list of sentences (where each sentence is a list of words) and a dictionary of correct words. The function replaces each misspelled word in the sentences with the closest word from the dictionary using the Levenshtein distance. If there are multiple words with the same minimal distance, choose the lexicographically smallest one. # Function Signature ```python def auto_correct(sentences: List[List[str]], dictionary: List[str]) -> List[List[str]]: pass ``` # Input * `sentences`: A list of sentences, where each sentence is represented as a list of words (strings). Here, words consist of lowercase letters only. * `dictionary`: A list of correct words (strings) consisting of lowercase letters only. # Output * Returns the list of sentences with corrected words. # Constraints * The `sentences` list will contain between 1 and 1000 sentences. * Each sentence will contain between 1 and 100 words. * Each word in `sentences` will have a length between 1 and 20. * The `dictionary` will contain between 1 and 5000 words. * Each word in the dictionary will have a length between 1 and 20. # Example ```python sentences = [[\'speling\', \'mistake\', \'in\', \'thes\', \'sentense\'], [\'orrect\', \'this\', \'plea\']] dictionary = [\'spelling\', \'mistake\', \'in\', \'the\', \'sentence\', \'correct\', \'this\', \'please\'] result = auto_correct(sentences, dictionary) # Output: [[\'spelling\', \'mistake\', \'in\', \'the\', \'sentence\'], [\'correct\', \'this\', \'please\']] ``` # Notes * Levenshtein distance is defined as the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into the other. * Ensure your implementation is efficient given the constraints. * You may assume that the dictionary does not contain duplicate words.","solution":"from typing import List from functools import lru_cache def levenshtein_distance(word1: str, word2: str) -> int: Calculate the Levenshtein distance between two words. @lru_cache(None) def distance(i, j): if i == 0: return j if j == 0: return i if word1[i - 1] == word2[j - 1]: return distance(i - 1, j - 1) return min(distance(i - 1, j) + 1, distance(i, j - 1) + 1, distance(i - 1, j - 1) + 1) return distance(len(word1), len(word2)) def auto_correct(sentences: List[List[str]], dictionary: List[str]) -> List[List[str]]: Replace misspelled words in sentences with the closest matching word from the dictionary using Levenshtein distance. If multiple words have the same minimal distance, replace with the lexicographically smallest one. corrected_sentences = [] for sentence in sentences: corrected_sentence = [] for word in sentence: min_distance = float(\'inf\') correction = \\"\\" for dict_word in dictionary: dist = levenshtein_distance(word, dict_word) if dist < min_distance or (dist == min_distance and dict_word < correction): min_distance = dist correction = dict_word corrected_sentence.append(correction) corrected_sentences.append(corrected_sentence) return corrected_sentences"},{"question":"# Matrix Path Sum: Find the Minimum Path Problem Statement You are given an `m x n` grid filled with non-negative numbers, representing a matrix. Your task is to find a path from the top-left corner to the bottom-right corner which minimizes the sum of all numbers along the path. You can only move either down or right at any point in time. Write a function `min_path_sum(matrix: List[List[int]]) -> int` to solve this problem. Input * `matrix` (List[List[int]]): A non-empty 2D grid filled with non-negative integer values. Output * Return the minimum path sum from the top-left to the bottom-right corner. Constraints * The dimensions of the grid, `m` (number of rows) and `n` (number of columns), will not exceed 100. Examples ```python min_path_sum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) -> 7 # Explanation: The path 1 → 3 → 1 → 1 → 1 minimizes the sum to 7. min_path_sum([ [1, 2, 3], [4, 5, 6] ]) -> 12 # Explanation: The path 1 → 2 → 3 → 6 minimizes the sum to 12. ``` Additional Information You should utilize dynamic programming to efficiently solve this problem. Create a 2D DP table where `dp[i][j]` represents the minimum path sum to reach cell `(i, j)`. Initialize the table and iteratively compute the minimum path sum by either moving from the left or from above. Test your implementation thoroughly against various grid configurations.","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"# Generate All Permutations of a List of Integers You are required to implement a function that generates all possible permutations of a given list of integers. Function Signature ```python def generate_permutations(collection: list[int]) -> list[list[int]]: pass ``` # Requirements 1. Implement the function `generate_permutations` which takes a list of integers as input and returns a list of lists containing all possible permutations of the input list in lexicographic order. 2. Ensure that each permutation is a unique combination of the original list elements in different orders. # Input Format * A list of integers `collection`. # Output Format * A list of lists, where each inner list is a permutation of the input list. # Constraints * The input list `collection` will have 0 to 8 integers. * The integers in the list can range from (-10^6) to (10^6). # Performance Requirements * Your solution should generate all possible permutations efficiently and handle the upper constraint within a reasonable execution time. # Example ```python col = [1, 2, 3] print(generate_permutations(col)) # Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] col = [] print(generate_permutations(col)) # Output: [[]] col = [0, -1, 1] print(generate_permutations(col)) # Output: [[0, -1, 1], [0, 1, -1], [-1, 0, 1], [-1, 1, 0], [1, 0, -1], [1, -1, 0]] col = [1, 1, 2] print(generate_permutations(col)) # Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]] col = [1] print(generate_permutations(col)) # Output: [[1]] ``` **Note**: Ensure to handle edge cases such as empty input lists and lists with duplicate elements. Your implementation should return results in lexicographic order.","solution":"from itertools import permutations def generate_permutations(collection: list[int]) -> list[list[int]]: Generates all possible permutations of a list of integers in lexicographic order. if not collection: return [[]] # Generating permutations using itertools.permutations and converting to list perms = list(permutations(collection)) # Sorting permutations to ensure lexicographic order and removing duplicate permutations with set() and sorted() result = sorted(set(perms)) return [list(perm) for perm in result]"},{"question":"# Context You are given a string that may contain multiple sentences separated by periods. The goal is to find the top N most frequent words in the text along with their frequencies, ignoring case and punctuation (excluding periods which are sentence delimiters). Words are considered as sequences of alphabetic characters. # Task You need to implement a function `find_top_n_frequent_words` that: 1. Takes a string of text and an integer N as input. 2. Processes the text to split it into words, disregarding periods and converting everything to lower case. 3. Identifies the top N most frequent words and their respective frequencies. # Function Signature ```python def find_top_n_frequent_words(text: str, N: int) -> list[tuple[str, int]]: Finds the top N most frequent words in the given text. Args: text (str): The input text containing sentences. N (int): The number of top frequent words to find. Returns: list[tuple[str, int]]: A list of tuples where each tuple contains a word and its frequency. ``` # Input - `text`: A string of text containing sentences separated by periods. Words contain only alphabetic characters, and text may contain any standard punctuation marks. - `N`: An integer representing the number of top frequent words to find. # Output - Returns a list of tuples where each tuple contains a word (string) and its frequency (integer). The list is sorted by frequency in descending order; if frequencies are the same, words are sorted lexicographically in ascending order. # Constraints - The input text will contain at least one word and will be no longer than 10,000 characters. - The value of N will be at least 1 and will not exceed the number of distinct words in the text. # Example ```python text = \\"Hello, world! The world is big. The big, blue world.\\" N = 3 expected_output = [ (\\"world\\", 3), (\\"big\\", 2), (\\"the\\", 2), ] output = find_top_n_frequent_words(text, N) assert output == expected_output ``` # Notes - Convert all text to lower case before processing. - Ignore all punctuation marks, except for periods which are sentence delimiters and should be treated as spaces. - Focus on an efficient and clear implementation using standard Python libraries.","solution":"import re from collections import Counter def find_top_n_frequent_words(text: str, N: int) -> list[tuple[str, int]]: Finds the top N most frequent words in the given text. Args: text (str): The input text containing sentences. N (int): The number of top frequent words to find. Returns: list[tuple[str, int]]: A list of tuples where each tuple contains a word and its frequency. # Convert text to lowercase text = text.lower() # Replace punctuation with spaces, excluding periods text = re.sub(r\'[^ws.]\', \' \', text) # Replace periods with spaces text = text.replace(\'.\', \' \') # Split the text into words words = text.split() # Count the frequency of each word word_count = Counter(words) # Get the top N words sorted by frequency and lexicographically for ties most_common = word_count.most_common() most_common.sort(key=lambda x: (-x[1], x[0])) return most_common[:N]"},{"question":"# Question: Generate All Possible Combinations of a String **Scenario**: You are developing a feature in a text processing tool that allows users to generate all possible combinations of a given string, including substrings and character permutations. This feature is particularly useful for generating potential passwords or for linguistic analysis. Your task is to write a function that generates these combinations. **Function to Implement**: Implement the function `generate_combinations(s: str) -> List[str]` that takes a single string and returns a list of all possible combinations of its characters (including all substrings and permutations, ensuring no duplicates). **Requirements**: 1. Handle edge cases where the string is empty or contains a single character. 2. Ensure the combinations are unique and sorted in lexicographical order. **Input**: - A single string, `s`. **Output**: - A list of strings representing all unique combinations of characters of `s`, sorted lexicographically. **Constraints**: - The input string length will be (0 leq |s| leq 10). **Example Cases**: ```python >>> generate_combinations(\\"abc\\") [\'a\', \'ab\', \'abc\', \'ac\', \'b\', \'bc\', \'c\'] >>> generate_combinations(\\"a\\") [\'a\'] >>> generate_combinations(\\"\\") [] >>> generate_combinations(\\"bac\\") [\'a\', \'ab\', \'abc\', \'ac\', \'b\', \'bc\', \'c\'] >>> generate_combinations(\\"aab\\") [\'a\', \'aa\', \'aab\', \'ab\', \'b\'] ``` **Function Template**: ```python from typing import List def generate_combinations(s: str) -> List[str]: Generates all unique combinations of a given string\'s characters. :param s: Input string :return: List of all unique combinations sorted lexicographically # Your implementation goes here if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Guidance**: 1. Consider using recursive or iterative approaches for generating substrings and permutations. 2. Ensure no duplicates by using sets where appropriate before converting to sorted lists. 3. Focus on handling different types of input, such as empty strings and strings with repeating characters. This new question complements the original set by focusing on string manipulation and combinatorial algorithms, matching the style, complexity, and scope of the provided example.","solution":"from typing import List from itertools import combinations def generate_combinations(s: str) -> List[str]: Generates all unique combinations of a given string\'s characters. :param s: Input string :return: List of all unique combinations sorted lexicographically unique_subsets = set() # Sort the string to ensure lexicographical order sorted_s = \'\'.join(sorted(s)) for i in range(1, len(sorted_s) + 1): for comb in combinations(sorted_s, i): unique_subsets.add(\'\'.join(comb)) return sorted(list(unique_subsets))"},{"question":"# Sum and Group Integers Context: You are developing a feature for an accounting software that processes a large list of financial transactions. Each transaction is simply an integer representing either income (positive value) or expense (negative value). The goal is to summarize these transactions by grouping consecutive items with the same sign and calculating their sums for a more concise financial report. Objective: Write a function `sum_and_group_transactions` that takes a list of integers and returns a new list where consecutive numbers with the same sign are summed together. Specifications: - **Function Name**: `sum_and_group_transactions` - **Input**: A list of integers where each integer is a transaction (either positive or negative). - **Output**: A new list of integers where consecutive integers with the same sign are summed together. Details: - Consecutive numbers are grouped based on their sign (positive or negative). - The order of the transaction sums in the resulting list should correspond to the order in which they appear in the input. - If the input list is empty, return an empty list. - The function needs to handle edge cases such as a single-element list or lists that have alternating signs. Examples: - `sum_and_group_transactions([100, 200, -50, -300, 400, 700, -200])` should return `[300, -350, 1100, -200]` - `sum_and_group_transactions([1, 2, 3, -4, -5, -6, 7, -8])` should return `[6, -15, 7, -8]` - `sum_and_group_transactions([5, -5, 5, -5])` should return `[5, -5, 5, -5]` - `sum_and_group_transactions([-3, -2, -1])` should return `[-6]` - `sum_and_group_transactions([])` should return `[]` Tasks: 1. Implement the function `sum_and_group_transactions(transactions: list[int]) -> list[int]`. 2. Ensure the function passes the provided examples and also handles edge cases correctly. 3. Test the function for performance on large lists to ensure it handles large input efficiently. Implementation: ```python def sum_and_group_transactions(transactions: list[int]) -> list[int]: if not transactions: return [] grouped_transactions = [] current_sum = transactions[0] for i in range(1, len(transactions)): if (transactions[i] >= 0 and current_sum >= 0) or (transactions[i] < 0 and current_sum < 0): current_sum += transactions[i] else: grouped_transactions.append(current_sum) current_sum = transactions[i] grouped_transactions.append(current_sum) return grouped_transactions # Sample testing if __name__ == \\"__main__\\": assert sum_and_group_transactions([100, 200, -50, -300, 400, 700, -200]) == [300, -350, 1100, -200] assert sum_and_group_transactions([1, 2, 3, -4, -5, -6, 7, -8]) == [6, -15, 7, -8] assert sum_and_group_transactions([5, -5, 5, -5]) == [5, -5, 5, -5] assert sum_and_group_transactions([-3, -2, -1]) == [-6] assert sum_and_group_transactions([]) == [] print(\\"All tests passed.\\") ``` Test your implementation thoroughly to ensure it provides the correct output in all cases.","solution":"def sum_and_group_transactions(transactions: list[int]) -> list[int]: if not transactions: return [] grouped_transactions = [] current_sum = transactions[0] for i in range(1, len(transactions)): if (transactions[i] >= 0 and current_sum >= 0) or (transactions[i] < 0 and current_sum < 0): current_sum += transactions[i] else: grouped_transactions.append(current_sum) current_sum = transactions[i] grouped_transactions.append(current_sum) return grouped_transactions"},{"question":"# Scenario You are a backend developer working on a contact management system for a CRM application. Your task involves managing and querying contact information efficiently. The system stores contacts with their names, phone numbers, and email addresses. One of the functionalities is to search for contacts by their name using a case-insensitive search. # Task Write a function that searches for contacts by name, ignoring case sensitivity, and returns the contact details. Assume you have a list of contact dictionaries where each contact has the keys `\'name\'`, `\'phone\'`, and `\'email\'`. # Function Signature ```python def search_contacts(name: str, contacts: list) -> list: pass ``` # Input and Output * **Input**: * `name`: A string representing the name or part of the name to search for. * `contacts`: A list of dictionaries, where each dictionary represents a contact with the following structure: ```python { \'name\': \'Full Contact Name\', \'phone\': \'PhoneNumber\', \'email\': \'EmailAddress\' } ``` * **Output**: * Returns a list of dictionaries representing contacts whose names match the search criteria in a case-insensitive manner. If no contacts match, return an empty list. # Constraints * The search should be case-insensitive. * If `name` is an empty string, return all contacts. * The `contacts` list can be arbitrarily large, so the search function should be efficient. # Example ```python contacts = [ {\'name\': \'John Doe\', \'phone\': \'123-456-7890\', \'email\': \'john@example.com\'}, {\'name\': \'Jane Smith\', \'phone\': \'234-567-8901\', \'email\': \'jane@example.com\'}, {\'name\': \'Johnathan Doe\', \'phone\': \'345-678-9012\', \'email\': \'johnathan@example.com\'}, ] result = search_contacts(\'john\', contacts) # Expected to return: # [ # {\'name\': \'John Doe\', \'phone\': \'123-456-7890\', \'email\': \'john@example.com\'}, # {\'name\': \'Johnathan Doe\', \'phone\': \'345-678-9012\', \'email\': \'johnathan@example.com\'} # ] print(result) ``` # Performance Requirements Ensure the function executes efficiently even with a large list of contacts. Consider optimizations for string comparisons and searching.","solution":"def search_contacts(name: str, contacts: list) -> list: Searches for contacts by name, ignoring case sensitivity, and returns the contact details. :param name: A string representing the name or part of the name to search for. :param contacts: A list of dictionaries, where each dictionary represents a contact. :return: A list of dictionaries representing contacts whose names match the search criteria. if not name: return contacts lower_name = name.lower() result = [contact for contact in contacts if lower_name in contact[\'name\'].lower()] return result"},{"question":"# Question: Calculate the Factorial of a Number Statement: You are required to implement a function that calculates the factorial of a non-negative integer. The factorial of a number ( n ) is the product of all positive integers less than or equal to ( n ). Function Signature: ```python def calculate_factorial(n: int) -> int: ``` Input: - ( n ) (int): A non-negative integer representing the number whose factorial is to be calculated. Output: - An integer representing the factorial of ( n ). Constraints: - ( 0 leq n leq 20 ) (since factorials grow rapidly, we limit ( n ) to 20 to avoid overflow issues in some programming environments) Example: ```python >>> calculate_factorial(5) 120 >>> calculate_factorial(0) 1 >>> calculate_factorial(10) 3628800 >>> calculate_factorial(20) 2432902008176640000 ``` Notes: - The factorial of 0 is defined as 1. - Ensure the function handles edge cases such as when ( n ) is 0.","solution":"def calculate_factorial(n: int) -> int: Calculates the factorial of a non-negative integer n. if n == 0: return 1 factorial = 1 for i in range(1, n + 1): factorial *= i return factorial"},{"question":"# Scenario You are developing a feature to process activity log data from a software application. Each log entry contains a timestamp and a message indicating an action taken by a user. The logs need to be filtered to extract only those entries that fall within a specific time range and contain a specified keyword in the message. Your task is to implement the function to perform this filtering and write corresponding unit tests to verify its correctness. # Task 1. Implement a function `filter_logs` that takes a list of log entries, a start time, an end time, and a keyword as arguments, and returns a list of log entries that meet the specified criteria. 2. Write unit tests for your function to ensure it correctly filters the log entries based on the given time range and keyword. # Requirements **Function Signature**: ```python def filter_logs(logs: list, start_time: str, end_time: str, keyword: str) -> list: # Your implementation here ``` # Example ```python # Example of log entries logs = [ {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, {\\"timestamp\\": \\"2023-01-01T10:05:00\\", \\"message\\": \\"User updated profile\\"}, {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} ] # Call to filter_logs function filtered_logs = filter_logs(logs, \\"2023-01-01T10:00:00\\", \\"2023-01-01T10:10:00\\", \\"logged\\") # Expected output: # [ # {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, # {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} # ] ``` # Constraints - Timestamps are in ISO 8601 format. - The start time is inclusive, and the end time is inclusive. - The function should raise a ValueError if the start time is after the end time. # Testing - Write unit tests to check the function with various edge cases: - Empty log list - Logs with no entries within the time range - Logs with no entries containing the keyword - Valid filtering within a range # Additional Information - Utilize the `datetime` module to compare timestamps. - Use assertions in your unit tests to ensure that the function filters logs correctly based on both time range and keyword presence. # Sample Unit Test Code ```python def test_filter_logs(): logs = [ {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, {\\"timestamp\\": \\"2023-01-01T10:05:00\\", \\"message\\": \\"User updated profile\\"}, {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} ] # Test case: logs within time range and containing keyword assert filter_logs(logs, \\"2023-01-01T10:00:00\\", \\"2023-01-01T10:10:00\\", \\"logged\\") == [ {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} ] # Additional test cases to cover edge cases # ... ```","solution":"from datetime import datetime def filter_logs(logs: list, start_time: str, end_time: str, keyword: str) -> list: Filters the log entries based on the given time range and keyword. Parameters: logs (list): A list of log entries where each log entry is a dictionary with \'timestamp\' and \'message\'. start_time (str): The start time in ISO 8601 format (inclusive). end_time (str): The end time in ISO 8601 format (inclusive). keyword (str): The keyword to search for in the messages. Returns: list: A list of log entries that meet the specified criteria. Raises: ValueError: If the start time is after the end time. start_dt = datetime.fromisoformat(start_time) end_dt = datetime.fromisoformat(end_time) if start_dt > end_dt: raise ValueError(\\"start time must be before or equal to end time\\") filtered_logs = [] for log in logs: log_time = datetime.fromisoformat(log[\'timestamp\']) if start_dt <= log_time <= end_dt and keyword in log[\'message\']: filtered_logs.append(log) return filtered_logs"},{"question":"# Question: You are contributing to an open-source project that involves processing and analyzing text data. You need to write two functions to calculate word frequencies and find the most common word in a given list of sentences. Task: 1. **Function 1: `word_frequencies(sentences: list) -> dict`** - Input: - `sentences`: A list of sentences (strings) where each sentence may contain multiple words. - Output: - A dictionary where the keys are words (strings) and the values are their respective frequencies (integers). - Words should be counted in a case-insensitive manner (e.g., \\"Word\\" and \\"word\\" should be considered the same). - Implementation details: - Include only words consisting of alphabetic characters. - Ignore any punctuation or special characters. - Handle empty input gracefully by returning an empty dictionary. 2. **Function 2: `most_common_word(frequencies: dict) -> str`** - Input: - `frequencies`: A dictionary containing word frequencies (the output of `word_frequencies`). - Output: - A string representing the most common word in the dictionary. - Implementation details: - In case of a tie (multiple words with the same highest frequency), return the word that appears first alphabetically. Examples: - Word Frequencies: ```python word_frequencies([\\"Hello world\\", \\"Hello again, world!\\"]) # Output: {\'hello\': 2, \'world\': 2, \'again\': 1} word_frequencies([\\"The quick brown fox\\", \\"jumps over the lazy dog\\"]) # Output: {\'the\': 2, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 1} ``` - Most Common Word: ```python most_common_word({\'hello\': 2, \'world\': 2, \'again\': 1}) # Output: \'hello\' most_common_word({\'the\': 2, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 1}) # Output: \'the\' ``` Ensure your solution is efficient, correctly handles edge cases, and processes text data accurately, while maintaining the expected output format for both functions.","solution":"import re from collections import defaultdict def word_frequencies(sentences): Calculate the frequency of words in a list of sentences. Args: sentences (list): A list of sentences (strings). Returns: dict: A dictionary where keys are words (case-insensitive) and values are word counts. frequency = defaultdict(int) for sentence in sentences: words = re.findall(r\'b[a-zA-Z]+b\', sentence.lower()) for word in words: frequency[word] += 1 return frequency def most_common_word(frequencies): Finds the most common word in a dictionary of word frequencies. Args: frequencies (dict): A dictionary of word frequencies. Returns: str: The most common word. If there\'s a tie, the lexicographically smallest word is returned. if not frequencies: return \'\' most_common = max(frequencies.items(), key=lambda item: (item[1], -ord(item[0][0]))) return most_common[0]"},{"question":"# Problem Statement: Rotating a Matrix Clockwise You are tasked with implementing a Python function that rotates a given `n x n` matrix 90 degrees clockwise in-place, conserving the original structure and data. Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> None: pass ``` Input - `matrix` (List[List[int]]): A square matrix to be rotated, where `matrix[i][j]` is an integer. Output - The function modifies the input matrix in-place and does not return any value. Constraints - The size of the matrix, `n`, is an integer such that `1 <= n <= 1000`. - The matrix contains integer elements: `-1000 <= matrix[i][j] <= 1000`. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix) print(matrix) # Output: [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ``` Instructions 1. You should first transpose the matrix, by swapping `matrix[i][j]` with `matrix[j][i]` for all `i` and `j`. 2. After transposing, reverse each row to achieve the 90-degree rotation. 3. Do not use additional matrices; operate directly on the input matrix. 4. Ensure that the original structure of the matrix is maintained after rotation. Note - Consider edge cases like the smallest matrix possible and matrices with negative numbers. - Optimize for both time and space complexity.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question: Validate Password Strength You are tasked with implementing a function to validate the strength of a given password based on certain criteria. Function: `is_strong_password(password: str) -> bool` Implement a function that checks whether a given password is strong based on the following rules: 1. It should be at least 8 characters long. 2. It should contain at least one uppercase letter. 3. It should contain at least one lowercase letter. 4. It should contain at least one digit. 5. It should contain at least one special character from the set `!@#%^&*()-_+`. **Inputs:** * `password (str)`: A string representing the password to be validated. **Outputs:** * `bool`: `True` if the password meets all the criteria, else `False`. **Constraints:** * The input string can contain any printable ASCII character. Examples Example 1: ```python >>> is_strong_password(\\"Passw0rd!\\") True ``` Example 2: ```python >>> is_strong_password(\\"password\\") False ``` Example 3: ```python >>> is_strong_password(\\"P@ssw0\\") False ``` Example 4: ```python >>> is_strong_password(\\"StrongPass1!\\") True ``` # Requirements 1. Ensure the function checks each of the criteria for a strong password efficiently. 2. Implement proper error handling for non-string inputs if necessary. 3. The function should return `False` if any of the criteria are not met. Write the implementation for the function ensuring it verifies password strength against all the given criteria and handles different edge cases appropriately.","solution":"def is_strong_password(password: str) -> bool: if len(password) < 8: return False has_upper = False has_lower = False has_digit = False has_special = False special_characters = \\"!@#%^&*()-_+\\" for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True return has_upper and has_lower and has_digit and has_special"},{"question":"# Maze Path Finder Objective You are required to implement a function that determines if there is a valid path from the top-left corner to the bottom-right corner in a given maze. The maze is represented as a 2D grid where walkable paths are marked with 1s and walls are marked with 0s. Function Signature ```python def is_path_in_maze(maze: list[list[int]]) -> bool: ``` Input - `maze`: A 2D list representing the maze grid with each cell containing either 0 or 1. - Dimensions of the maze M by M (1≤ M ≤ 1000). Output - The function should return `True` if there exists a valid path from the top-left to the bottom-right corner of the maze, otherwise, return `False`. Example ```python maze = [ [1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 1, 1] ] is_path_in_maze(maze) # Returns: True ``` ```python maze = [ [1, 0, 0, 0], [0, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1] ] is_path_in_maze(maze) # Returns: False ``` Constraints - You can move in 4 directions: up, down, left, and right. - The path must be continuous and cannot travel through walls (0s). Additional Context The function should employ appropriate search algorithms like BFS (Breadth-First Search) or DFS (Depth-First Search) to explore feasible paths from the starting point to the endpoint, ensuring both correctness and efficiency.","solution":"def is_path_in_maze(maze: list[list[int]]) -> bool: Determines if there is a valid path from the top-left corner to the bottom-right corner in the maze. if not maze or not maze[0] or maze[0][0] == 0 or maze[-1][-1] == 0: return False from collections import deque M = len(maze) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (M - 1, M - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < M and (nx, ny) not in visited and maze[nx][ny] == 1: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"# Graph Traversal on Hexagonal Grid You are given a hexagonal grid where each hexagon is identified using axial coordinates in a two-component system (q, r). Implement a class `HexGrid` that supports the traversal and pathfinding operation on the grid using the A* algorithm. Part 1: Implement the HexGrid Class Implement the `HexGrid` class with the following methods: 1. `__init__(self, grid_size: int)`: Initialize the hexagonal grid with a specified size. 2. `distance(self, start: tuple[int, int], end: tuple[int, int]) -> int`: Compute the distance between two hexagons on the grid using axial coordinates. Part 2: Extend the HexGrid Class with A* Algorithm Extend the class to include a method to find the shortest path between two hexagons using the A* algorithm: 1. `a_star_path(self, start: tuple[int, int], goal: tuple[int, int]) -> list[tuple[int, int]]`: Calculate the shortest path from start to goal using the A* algorithm. # Input and Output Formats Input * `grid_size`: An integer representing the size of the hexagonal grid (radius of the largest ring of the hexagons). * `start`: A tuple representing the axial coordinates (q, r) of the starting hexagon. * `goal`: A tuple representing the axial coordinates (q, r) of the target hexagon. Output * `a_star_path(start, goal)`: A list of tuples representing the sequence of hexagons from start to goal. # Constraints 1. The grid size determines how far out the grid extends from the center; it\'s a hexagonal shape expanding radially. 2. Both `start` and `goal` will always be within the boundaries of the hexagonal grid. 3. The grid should handle up to a grid size of 50 efficiently. # Examples ```python grid = HexGrid(10) print(grid.distance((0, 0), (3, -3))) # Expected output: The distance between the hexagons at (0,0) and (3,-3). path = grid.a_star_path((0, 0), (3, -3)) print(path) # Expected output: A list of tuples representing the shortest path from (0, 0) to (3, -3). ``` # Notes * The A* algorithm should utilize an appropriate heuristic for hexagonal grids. * Ensure that the distance function correctly calculates the hexagonal distance. * Validate your implementation using examples and edge cases. Consider the unique movement rules and adjacency properties of hexagonal grids when designing your solution.","solution":"from typing import List, Tuple import heapq class HexGrid: def __init__(self, grid_size: int): self.grid_size = grid_size def distance(self, start: Tuple[int, int], end: Tuple[int, int]) -> int: Compute the distance between two hexagons on the grid using axial coordinates. return max(abs(start[0] - end[0]), abs(start[1] - end[1]), abs(start[0] + start[1] - end[0] - end[1])) def a_star_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Calculate the shortest path from start to goal using the A* algorithm for hexagonal grids. def heuristic(a, b): return self.distance(a, b) directions = [ (1, 0), (1, -1), (0, -1), (-1, 0), (-1, 1), (0, 1) ] open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: current = heapq.heappop(open_set)[1] if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) tentative_g_score = g_score[current] + 1 if 0 <= abs(neighbor[0]) <= self.grid_size and 0 <= abs(neighbor[1]) <= self.grid_size and abs(neighbor[0] + neighbor[1]) <= self.grid_size: if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return [] # return an empty path if no path is found"},{"question":"You are tasked with extending a geometry library by implementing a new class `RegularPolygon` that represents a regular polygon (a polygon with all sides of equal length and all interior angles equal). Specifically, this class should handle any number of sides, with special methods to calculate the interior angle and the perimeter of the polygon. # Constraints: - The number of sides should be a positive integer greater than or equal to 3. - The length of each side should be a positive float. # Input and Output: - Expected input: An integer representing the number of sides, and a float representing the length of each side. - Expected output: A `RegularPolygon` instance which can compute its interior angle and perimeter. # Example Scenario: Your task in developing this geometric library is to create tools for automatic design generation. This entails needing to compute properties of regular polygons, such as drawing patterns and calculating symmetry. The `RegularPolygon` class will facilitate these computations. # Class Specifications: Class Name: `RegularPolygon` **Initialization**: ```python def __init__(self, num_sides: int, side_length: float) -> None: # Initialize the regular polygon ``` Raises a `ValueError` if the `num_sides` is less than 3 or any `side_length` is non-positive. **Interior Angle Calculation**: ```python def interior_angle(self) -> float: # Return the interior angle of the regular polygon ``` **Perimeter Calculation**: ```python def perimeter(self) -> float: # Return the perimeter of the regular polygon ``` # Interior Angle Formula: [ text{Interior Angle} = frac{(n - 2) times 180}{n} ] Where ( n ) is the number of sides of the polygon. # Perimeter Calculation: [ text{Perimeter} = n times text{side length} ] Where ( n ) is the number of sides of the polygon, and the side length is the given length for each side. # Usage Example: ```python polygon = RegularPolygon(5, 4.0) # Creates a regular polygon with 5 sides, each of length 4.0 angle = polygon.interior_angle() # Returns the interior angle of the polygon perimeter = polygon.perimeter() # Returns the perimeter of the polygon ``` Implement the class with these methods to integrate it into your geometric library for creating a variety of regular polygons and utilizing their symmetrical properties in design generation.","solution":"class RegularPolygon: def __init__(self, num_sides: int, side_length: float) -> None: if num_sides < 3: raise ValueError(\\"Number of sides must be at least 3.\\") if side_length <= 0: raise ValueError(\\"Side length must be a positive number.\\") self.num_sides = num_sides self.side_length = side_length def interior_angle(self) -> float: return ((self.num_sides - 2) * 180) / self.num_sides def perimeter(self) -> float: return self.num_sides * self.side_length"},{"question":"# Advanced Log Analysis You have been brought on board to enhance the log analysis process for a cybersecurity system. The goal is to develop a script that processes log files and generates a concise report summarizing potential security incidents. # Requirements: 1. **Function Definition**: Implement a function `analyze_logs(log_files: list) -> dict` that: - **Parameters**: - `log_files`: List of log file paths. - **Returns**: - A dictionary summarizing potential security incidents. The dictionary should include: - `total_logs`: Total number of log entries processed. - `total_incidents`: Total number of potential security incidents detected. - `incident_summary`: A nested dictionary where keys are incident types, and values are counts of each type. - `unique_sources`: A list of unique source IP addresses involved in incidents. 2. **Input**: - Log files are in plain text format. - Each log entry is a single line, following the format: `[timestamp] [source IP] [destination IP] [description]` - `description` contains predefined keywords indicating potential incidents (e.g., \\"FAILED LOGIN\\", \\"UNAUTHORIZED ACCESS\\", \\"SQL INJECTION ATTEMPT\\"). 3. **Output**: - A dictionary with a comprehensive summary of the processed logs, reflecting total incidents and their breakdown by type, and all unique source IP addresses involved in incidents. 4. **Constraints**: - The script should be capable of processing large log files efficiently. - Ensure the solution handles edge cases like empty log files, corrupted entries, or entries without incident keywords gracefully. - Only entries explicitly mentioning incidents should be counted. 5. **Performance**: - Handle the logs in a time-efficient manner to ensure scalability. - Optimize memory usage to handle logs spanning multiple gigabytes. ```python # Define your function here def analyze_logs(log_files: list) -> dict: Analyze log files to detect potential security incidents. Parameters: - log_files <type: list>: list of log file paths. Return: - summary <type: dict>: Dictionary summarizing potential security incidents. { \\"total_logs\\": int, \\"total_incidents\\": int, \\"incident_summary\\": { \\"FAILED LOGIN\\": int, \\"UNAUTHORIZED ACCESS\\": int, ... }, \\"unique_sources\\": [list of unique source IP addresses] } pass # Implementation here ``` # Scenario: You are a cybersecurity analyst tasked with analyzing server logs to detect and count potential security incidents. Given thousands of log files from various servers, you need to ensure that all incidents are accurately captured and summarized to enhance the organization\'s security posture. Incidents include failed login attempts, unauthorized access, and specific attack vectors like SQL injection attempts. Use the provided function template to implement the solution. Your function will integrate into a larger system that continuously monitors and analyzes security logs in real time.","solution":"import re def analyze_logs(log_files): Analyze log files to detect potential security incidents. Parameters: - log_files <type: list>: list of log file paths. Return: - summary <type: dict>: Dictionary summarizing potential security incidents. { \\"total_logs\\": int, \\"total_incidents\\": int, \\"incident_summary\\": { \\"FAILED LOGIN\\": int, \\"UNAUTHORIZED ACCESS\\": int, ... }, \\"unique_sources\\": [list of unique source IP addresses] } total_logs = 0 total_incidents = 0 incident_summary = {} unique_sources = set() incident_keywords = [\\"FAILED LOGIN\\", \\"UNAUTHORIZED ACCESS\\", \\"SQL INJECTION ATTEMPT\\"] for file_path in log_files: try: with open(file_path, \'r\') as file: for line in file: total_logs += 1 matched = False for keyword in incident_keywords: if keyword in line: total_incidents += 1 if keyword not in incident_summary: incident_summary[keyword] = 0 incident_summary[keyword] += 1 matched = True if matched: match = re.search(r\'[(.*?)] [(.*?)] [(.*?)] [(.*?)]\', line) if match: source_ip = match.group(2) unique_sources.add(source_ip) except Exception as e: # Skip files that can\'t be opened or have read errors print(f\\"Error processing file {file_path}: {e}\\") continue return { \\"total_logs\\": total_logs, \\"total_incidents\\": total_incidents, \\"incident_summary\\": incident_summary, \\"unique_sources\\": list(unique_sources) }"},{"question":"# Longest Common Subsequence As part of your exploration of dynamic programming and optimization problems, you have studied various classic challenges, including finding the Longest Common Subsequence (LCS). The LCS problem involves finding the longest subsequence present in both given sequences, which does not necessarily have to be contiguous. Write a Python function `longest_common_subsequence(s1, s2)` that: 1. Takes two strings `s1` and `s2`. 2. Returns the length of the longest common subsequence of `s1` and `s2`. 3. The function should adhere to O(n * m) time complexity and use O(n * m) space complexity where `n` and `m` are the lengths of `s1` and `s2` respectively. Input - Two strings `s1` and `s2` (1 ≤ len(s1), len(s2) ≤ 1000), composed of lowercase letters. Output - An integer representing the length of the longest common subsequence. Example ```python # Example input s1 = \\"abcde\\" s2 = \\"ace\\" # Example output 3 ``` Explanation The longest common subsequence between \\"abcde\\" and \\"ace\\" is \\"ace\\" with a length of 3. Implementation Notes Consider edge cases such as one string being empty or the strings sharing no characters in common. Implement recursion with memoization or iterative dynamic programming to ensure efficient computation. Constraints - Ensure that both input strings contain only lowercase letters. - Handle large inputs efficiently. ```python def longest_common_subsequence(s1, s2): n, m = len(s1), len(s2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] # Example usage s1 = \\"abcde\\" s2 = \\"ace\\" print(longest_common_subsequence(s1, s2)) # Output: 3 ``` By adhering to the given guidelines, this new question closely matches the style, complexity, and scope of the provided questions, focusing on another significant problem in dynamic programming.","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence of s1 and s2. n, m = len(s1), len(s2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"# Question: Logistic Regression Model Implementation Context You are provided with a dataset containing features and a binary target variable. Your task is to implement a logistic regression model, train it using the provided data, and predict the class labels for new data points. Task Implement a function `fit_logistic_regression(x_train, y_train, learning_rate, num_iterations)`, which fits a logistic regression model to the training data using Gradient Descent. Then, use this model to predict the class labels for new data points using a function `predict_logistic_regression(model, x_test)`. Classes and Methods 1. **LogisticRegression** - **Constructor**: - `__init__(self, learning_rate: float, num_iterations: int) -> None`: Initializes the learning rate and number of iterations for the model. - **Sigmoid Function**: - `_sigmoid(self, z: np.ndarray) -> np.ndarray`: Computes the sigmoid function. - **Fit Model**: - `fit(self, x_train: np.ndarray, y_train: np.ndarray) -> None`: Fits the logistic regression model using Gradient Descent. - **Predict Probabilities**: - `predict_proba(self, data: np.ndarray) -> np.ndarray`: Predicts probabilities based on the fitted model parameters. - **Predict Class Labels**: - `predict(self, data: np.ndarray) -> np.ndarray`: Predicts the class labels based on the probabilities. Input and Output Format - **Function: `fit_logistic_regression`** - **Input**: - `x_train`: 2D `np.ndarray` of predictor values. - `y_train`: 1D `np.ndarray` of binary target values. - `learning_rate`: Float representing the learning rate for Gradient Descent optimization. - `num_iterations`: Integer number of iterations for Gradient Descent optimization. - **Output**: - Returns an instance of `LogisticRegression` class fitted to the training data. - **Function: `predict_logistic_regression`** - **Input**: - `model`: Instance of `LogisticRegression` class. - `x_test`: 2D `np.ndarray` of predictor values for which class labels are to be predicted. - **Output**: - Returns a 1D `np.ndarray` of predicted class labels. Example Usage ```python import numpy as np def fit_logistic_regression(x_train, y_train, learning_rate, num_iterations): model = LogisticRegression(learning_rate, num_iterations) model.fit(x_train, y_train) return model def predict_logistic_regression(model, x_test): return model.predict(x_test) # Example Data x_train = np.array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) y_train = np.array([0, 0, 1, 1, 1]) # Fit model model = fit_logistic_regression(x_train, y_train, learning_rate=0.1, num_iterations=1000) # Predictions x_test = np.array([[1, 2], [2, 3], [3, 4]]) predictions = predict_logistic_regression(model, x_test) print(predictions) # Output should be the predicted class labels ``` Constraints - Ensure input data `x_train`, `y_train`, and `x_test` are numpy arrays. - `learning_rate` should be a positive float. - `num_iterations` should be a positive integer.","solution":"import numpy as np class LogisticRegression: def __init__(self, learning_rate: float, num_iterations: int) -> None: self.learning_rate = learning_rate self.num_iterations = num_iterations self.weights = None self.bias = None def _sigmoid(self, z: np.ndarray) -> np.ndarray: return 1 / (1 + np.exp(-z)) def fit(self, x_train: np.ndarray, y_train: np.ndarray) -> None: num_samples, num_features = x_train.shape self.weights = np.zeros(num_features) self.bias = 0 for _ in range(self.num_iterations): model_output = np.dot(x_train, self.weights) + self.bias predictions = self._sigmoid(model_output) errors = predictions - y_train dw = (1 / num_samples) * np.dot(x_train.T, errors) db = (1 / num_samples) * np.sum(errors) self.weights -= self.learning_rate * dw self.bias -= self.learning_rate * db def predict_proba(self, data: np.ndarray) -> np.ndarray: model_output = np.dot(data, self.weights) + self.bias return self._sigmoid(model_output) def predict(self, data: np.ndarray) -> np.ndarray: probabilities = self.predict_proba(data) return (probabilities >= 0.5).astype(int) def fit_logistic_regression(x_train, y_train, learning_rate, num_iterations): model = LogisticRegression(learning_rate, num_iterations) model.fit(x_train, y_train) return model def predict_logistic_regression(model, x_test): return model.predict(x_test)"},{"question":"# Permutation Checker Write a function to check whether two given strings are permutations of each other. Two strings are said to be permutations of each other if they contain the same characters with the same frequencies. Function Signature ```python def check_permutation(str1: str, str2: str) -> bool: pass ``` Input - `str1`: A string (1 ≤ len(str1) ≤ 1000). - `str2`: A string (1 ≤ len(str2) ≤ 1000). Output - Return `True` if the strings are permutations of each other, `False` otherwise. Constraints - The function should have a time complexity of O(n). Examples ```python # Example 1 str1 = \\"listen\\" str2 = \\"silent\\" # Expected Output: True # Example 2 str1 = \\"triangle\\" str2 = \\"integral\\" # Expected Output: True # Example 3 str1 = \\"apple\\" str2 = \\"papel\\" # Expected Output: True # Example 4 str1 = \\"hello\\" str2 = \\"billion\\" # Expected Output: False ``` Note 1. Consider all characters, including punctuation, as part of the strings. 2. Implement your solution without using any external libraries. 3. Ensure optimal performance for large input sizes, taking into account the time complexity requirement.","solution":"def check_permutation(str1: str, str2: str) -> bool: Checks if two strings are permutations of each other. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if strings are permutations of each other, False otherwise. if len(str1) != len(str2): return False char_count = {} # Count characters in str1 for char in str1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Verify characters with str2 for char in str2: if char in char_count: char_count[char] -= 1 if char_count[char] == 0: del char_count[char] else: return False return len(char_count) == 0"},{"question":"Problem Statement: You are given an `m x n` 2D grid `grid` representing a map of `1`s (land) and `0`s (water). Your task is to write a function `num_islands(grid: List[List[int]]) -> int` to find the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. # Requirements: 1. Implement a Depth-First Search (DFS) approach to traverse and mark the visited islands. 2. Your function should efficiently handle large grids. # Constraints: - The grid is always rectangular. - `m` and `n` are at most `300`. - The land cells are represented by `1` and the water cells are represented by `0`. # Input: - `grid`: A 2D list containing integers `0` or `1`. # Output: - An integer representing the number of islands. # Example: **Input**: ```python grid = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] ``` **Output**: ```python 1 ``` **Input**: ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] ``` **Output**: ```python 3 ``` # Notes: - Perform a depth-first search (DFS) to mark all consecutive land cells for each island. - Ensure your function efficiently manages large grids using proper nesting and recursion limits.","solution":"def num_islands(grid): Returns the number of islands in the given grid. Args: grid: List[List[int]] - A 2D grid of 0s and 1s representing water and land respectively. Returns: int - The number of islands in the grid. if not grid: return 0 def dfs(x, y): # If out of bounds or at a water cell, return if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return # Mark the cell as visited by setting it to 0 (water) grid[x][y] = 0 # Visit all four adjacent cells dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # Found an island, perform DFS to mark all its cells dfs(i, j) num_islands += 1 return num_islands"},{"question":"# Coding Question Context You are developing a simple event scheduler that helps users manage their appointments. Users can add, remove, and list their events based on specific dates. Your task is to enhance the current implementation to handle these features more robustly by considering edge cases and ensuring efficient operations. Task Write a class `EventScheduler` that provides methods to add, remove, and list events for specific dates. Ensure your implementation includes proper error handling and optimizes performance for large lists of events. Class and Method Signatures ```python class EventScheduler: def __init__(self) -> None: pass def add_event(self, date: str, event: str) -> None: pass def remove_event(self, date: str, event: str) -> None: pass def list_events(self, date: str) -> list: pass ``` Requirements 1. **Input**: * `date` (str): The date for the event in `YYYY-MM-DD` format. * `event` (str): A string describing the event. 2. **Output**: * `list_events` method should return a list of event strings scheduled for the specified date. 3. **Constraints**: * The `add_event` method should add an event to the specified date. * The `remove_event` method should remove the specified event from the given date. If the event does not exist, no action should be taken. * The `list_events` method should return all events scheduled for the specified date; if no events are scheduled, return an empty list. * Ensure efficient handling of multiple events on different dates. * Implement proper error handling for malformed dates and other potential issues. 4. **Performance**: * Optimize for minimal latency when adding, removing, or listing events. * Efficiently manage memory usage when handling a large number of events. Example: ```python if __name__ == \\"__main__\\": scheduler = EventScheduler() scheduler.add_event(\\"2023-10-10\\", \\"Doctor\'s appointment\\") scheduler.add_event(\\"2023-10-10\\", \\"Team meeting\\") scheduler.add_event(\\"2023-10-11\\", \\"Lunch with friend\\") scheduler.remove_event(\\"2023-10-10\\", \\"Team meeting\\") print(scheduler.list_events(\\"2023-10-10\\")) # Output: [\\"Doctor\'s appointment\\"] print(scheduler.list_events(\\"2023-10-11\\")) # Output: [\\"Lunch with friend\\"] ``` Notes: * Implement logging for actions like adding, removing, and listing events. * Ensure the code is clean, readable, and well-commented.","solution":"from collections import defaultdict from datetime import datetime class EventScheduler: def __init__(self) -> None: # Initialize a dictionary to hold events for each date self.events = defaultdict(list) def add_event(self, date: str, event: str) -> None: # Validate date format if not self._is_valid_date(date): raise ValueError(f\\"Invalid date format: {date}\\") # Add event to the list for the given date self.events[date].append(event) def remove_event(self, date: str, event: str) -> None: # Check if date is valid and if event exists for the given date if not self._is_valid_date(date): raise ValueError(f\\"Invalid date format: {date}\\") if event in self.events[date]: self.events[date].remove(event) # Clean up date entry if no events left if not self.events[date]: del self.events[date] def list_events(self, date: str) -> list: # Validate date format if not self._is_valid_date(date): raise ValueError(f\\"Invalid date format: {date}\\") # Return the list of events for the given date, or an empty list if none exist return self.events.get(date, []) def _is_valid_date(self, date: str) -> bool: # Helper function to validate date format try: datetime.strptime(date, \\"%Y-%m-%d\\") return True except ValueError: return False"},{"question":"# Coding Assessment Question You are enhancing a library of string manipulation functions. One of the tasks is to implement a function that reformats strings based on specific rules. **Task**: Implement a function that takes a string containing numerical digits and characters and rearranges it such that all digits come before any character, while maintaining the relative order of digits and characters. # Requirements and Constraints: 1. **Input Format**: * A string containing alphanumeric characters (both digits and letters). 2. **Output Format**: * A string with digits at the start, followed by characters. 3. **Constraints**: * The input string will have a length of at most 10^5. 4. **Performance Requirements**: * Ensure the function operates efficiently on large input sizes. # Example: ```python def reformat_string(s: str) -> str: # Your implementation here # Examples assert reformat_string(\'a1b2c3\') == \'123abc\' assert reformat_string(\'abc123\') == \'123abc\' assert reformat_string(\'123abc\') == \'123abc\' assert reformat_string(\'1a2b3c\') == \'123abc\' # Edge Cases assert reformat_string(\'\') == \'\' assert reformat_string(\'abcd\') == \'abcd\' assert reformat_string(\'1234\') == \'1234\' ``` **Additional Task**: Explain the time complexity of your implementation and discuss why it is optimal for the given constraints.","solution":"def reformat_string(s: str) -> str: Reformats the input string such that all digits come before any character, while maintaining the relative order of digits and characters. digits = [] chars = [] for char in s: if char.isdigit(): digits.append(char) else: chars.append(char) return \'\'.join(digits) + \'\'.join(chars)"},{"question":"# Problem Statement - Course Schedule You are given a list of course prerequisites where `prerequisites[i] = [ai, bi]` indicates that you must complete course `bi` before you can take course `ai`. Implement a function called `can_finish_courses` that determines if it is possible to complete all courses given the prerequisites. A cycle in the prerequisites means that it is not possible to complete the courses. Function Signature ```python def can_finish_courses(num_courses: int, prerequisites: list[list[int]]) -> bool: pass ``` # Input Format: - An integer `num_courses` representing the total number of courses you need to take. - A list `prerequisites` where each element is a pair `[ai, bi]` indicating that course `bi` must be completed before course `ai`. # Output Format: - Return `True` if it is possible to complete all the courses, otherwise return `False`. # Constraints: - 1 <= num_courses <= 2000 - 0 <= prerequisites.length <= 5000 - 0 <= ai, bi < num_courses # Example ```python # Example 1 num_courses = 2 prerequisites = [[1, 0]] print(can_finish_courses(num_courses, prerequisites)) # Output: True # Example 2 num_courses = 2 prerequisites = [[1, 0], [0, 1]] print(can_finish_courses(num_courses, prerequisites)) # Output: False # Example 3 num_courses = 4 prerequisites = [[1, 0], [2, 0], [3, 1], [3, 2]] print(can_finish_courses(num_courses, prerequisites)) # Output: True ``` # Notes 1. The given courses are represented as integers ranging from 0 to `num_courses-1`. 2. There might be scenarios with no prerequisites. Consider the implications of detecting cycles in a directed graph. Efficient cycle detection algorithms, such as topological sorting or depth-first search, may be applied to solve this problem effectively.","solution":"from collections import defaultdict, deque def can_finish_courses(num_courses: int, prerequisites: list[list[int]]) -> bool: # Create a graph and calculate in-degrees of each node graph = defaultdict(list) in_degree = [0] * num_courses for course, prereq in prerequisites: graph[prereq].append(course) in_degree[course] += 1 # Initialize the queue with courses having no prerequisites queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) visited_courses = 0 while queue: course = queue.popleft() visited_courses += 1 for next_course in graph[course]: in_degree[next_course] -= 1 if in_degree[next_course] == 0: queue.append(next_course) return visited_courses == num_courses # Example usage # num_courses = 2 # prerequisites = [[1, 0]] # print(can_finish_courses(num_courses, prerequisites)) # Output: True"},{"question":"# Coding Assessment Question You are given a binary tree data structure. Enhance the `BinaryTree` class by adding two new operations: 1. `level_order_traversal()` - Returns the level order traversal of the binary tree as a list. 2. `is_symmetric()` - Determines if the binary tree is symmetric around its center. Implement the following methods with the exact signatures and constraints as shown. Expected Input and Output Formats: ```python class BinaryTree: ... def level_order_traversal(self) -> list: Returns the level order traversal of the binary tree as a list. >>> tree = BinaryTree() >>> tree.insert(3) >>> tree.insert(9) >>> tree.insert(20) >>> tree.insert(None) >>> tree.insert(None) >>> tree.insert(15) >>> tree.insert(7) >>> tree.level_order_traversal() [3, 9, 20, 15, 7] >>> def is_symmetric(self) -> bool: Determines if the binary tree is symmetric around its center. >>> tree = BinaryTree() >>> tree.insert(1) >>> tree.insert(2) >>> tree.insert(2) >>> tree.insert(3) >>> tree.insert(4) >>> tree.insert(4) >>> tree.insert(3) >>> tree.is_symmetric() True >>> ``` Constraints: - The `level_order_traversal` method should return a list of node values in level order. - The `is_symmetric` method should return a boolean indicating whether the tree is symmetric. - These methods should handle edge cases gracefully (e.g., empty tree, single node tree). - Performance targets: - Performing level order traversal in O(N) time complexity and O(N) space complexity for the output list. - Checking symmetry in O(N) time complexity. **Scenario/Context**: You\'re handling graphical representations of hierarchies in an application where it’s crucial to present data in a structured and symmetrical fashion. Implement these functionalities to facilitate efficient manipulation and validation of tree structures for accurate graphical display and analysis.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, x): if x is None: return if self.root is None: self.root = TreeNode(x) else: queue = [self.root] while queue: node = queue.pop(0) if node.left is None: node.left = TreeNode(x) break else: queue.append(node.left) if node.right is None: node.right = TreeNode(x) break else: queue.append(node.right) def level_order_traversal(self): if not self.root: return [] queue = [self.root] result = [] while queue: node = queue.pop(0) result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def is_symmetric(self): def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) if not self.root: return True return is_mirror(self.root.left, self.root.right)"},{"question":"# Coding Question Write a function to implement the Least Recently Used (LRU) page replacement algorithm. Your function should simulate the page replacement process and return the number of page faults that occur when the given sequence of page references is processed by a cache of a specified size. Function Implementation 1. `lru_page_replacement(pages: list, cache_size: int) -> int` # Input - `pages`: A list of integers where each integer represents a page number in the sequence they are referenced by the CPU. - `cache_size`: An integer representing the maximum number of pages that can be held in the cache at once. # Output - Returns an integer representing the total number of page faults that occur during the simulation. # Constraints - Assume the `pages` list and `cache_size` are non-empty. - The `cache_size` will be a positive integer. - The page numbers in the `pages` list are non-negative integers. # Example ```python # Input pages = [0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1] cache_size = 3 # Function Call page_faults = lru_page_replacement(pages, cache_size) # Output print(\\"Total Page Faults: \\", page_faults) # Expected: 9 ``` Your task is to correctly implement the `lru_page_replacement` function to compute the number of page faults incurred when applying the LRU page replacement policy with the given list of page references and cache size. Explanation The LRU page replacement algorithm works on the principle \\"Least Recently Used\\" which means the page that hasn\'t been used for the longest time will be replaced when a new page needs to be brought into the cache. The following steps outline how the algorithm works: 1. If the page is already in the cache (hit), no page fault occurs. 2. If the page is not in the cache (miss), a page fault occurs, and: - If the cache is not full, the page is simply inserted. - If the cache is full, the least recently used page is removed and the new page is inserted. Simulate this process accurately to calculate the total number of page faults.","solution":"def lru_page_replacement(pages, cache_size): Simulates the LRU page replacement algorithm and returns the number of page faults. :param pages: List of integers representing the sequence of page references. :param cache_size: Integer representing the maximum number of pages that can be held in the cache. :return: Integer representing the total number of page faults. cache = [] page_faults = 0 for page in pages: if page in cache: # Move the page to the end to mark it as most recently used cache.remove(page) cache.append(page) else: # Page fault occurs page_faults += 1 if len(cache) == cache_size: # Remove the least recently used page cache.pop(0) # Add the current page to the cache cache.append(page) return page_faults"},{"question":"# Problem Description You are tasked with implementing the Depth-First Search (DFS) algorithm to traverse a given undirected graph and determine connected components within it. The algorithm should efficiently identify all distinct connected subgraphs within the entire graph. # Requirements - Implement the core functionalities of the Depth-First Search. - Implement a method to find all connected components in the graph. - Ensure the entire graph traversal is conducted in an optimal manner. # Constraints - Nodes will be integers or strings. - The graph will contain up to 10<sup>4</sup> nodes. - The edges are given as pairs of connected nodes. - Graph might have isolated nodes and need to handle disconnected subgraphs. # Input The input is a list of tuples where each tuple represents an edge of the graph in the form (node1, node2). For example: ``` [ (1, 2), (2, 3), (4, 5), ... ] ``` # Output The output should be a list of lists, where each inner list represents a connected component in the graph, containing the nodes in that component. If there are multiple components, sort the nodes within each component and list the components in ascending order based on the first node in each component. For example: ``` [ [1, 2, 3], [4, 5] ] ``` # Example Given the input graph edges: ``` [ (1, 2), (2, 3), (4, 5) ] ``` A possible valid output for the connected components could be: ``` [ [1, 2, 3], [4, 5] ] ``` # Implementation Details 1. **Graph Class**: - Implement methods to add edges to the graph and track visited nodes. - Implement DFS traversal method. 2. **Connected Components Method**: - Implement a method to find and return all connected components using DFS. # Code Template ```python from typing import List, Tuple, Dict, Set, DefaultDict from collections import defaultdict class GraphUndirected: def __init__(self): self.graph: DefaultDict[any, List[any]] = defaultdict(list) def add_edge(self, u: any, v: any) -> None: self.graph[u].append(v) self.graph[v].append(u) def dfs(self, node: any, visited: Set[any]) -> List[any]: stack = [node] component = [] while stack: current = stack.pop() if current in visited: continue visited.add(current) component.append(current) for neighbor in self.graph[current]: if neighbor not in visited: stack.append(neighbor) return component def find_connected_components(self) -> List[List[any]]: visited = set() components = [] for node in self.graph: if node not in visited: component = self.dfs(node, visited) components.append(sorted(component)) isolated_nodes = [n for n in range(max(self.graph.keys()) + 1) if n not in self.graph and n not in visited] for node in isolated_nodes: components.append([node]) return sorted(components, key=lambda x: x[0]) def compute_connected_components(graph_edges: List[Tuple[any, any]]) -> List[List[any]]: graph = GraphUndirected() for u, v in graph_edges: graph.add_edge(u, v) return graph.find_connected_components() # Example usage: # graph_edges = [(1, 2), (2, 3), (4, 5)] # assert compute_connected_components(graph_edges) == [[1, 2, 3], [4, 5]] ```","solution":"from typing import List, Tuple, DefaultDict from collections import defaultdict class GraphUndirected: def __init__(self): self.graph: DefaultDict[any, List[any]] = defaultdict(list) def add_edge(self, u: any, v: any) -> None: self.graph[u].append(v) self.graph[v].append(u) def dfs(self, node: any, visited: set) -> List[any]: stack = [node] component = [] while stack: current = stack.pop() if current in visited: continue visited.add(current) component.append(current) for neighbor in self.graph[current]: if neighbor not in visited: stack.append(neighbor) return component def find_connected_components(self) -> List[List[any]]: visited = set() components = [] for node in self.graph: if node not in visited: component = self.dfs(node, visited) components.append(sorted(component)) return sorted(components, key=lambda x: x[0]) def compute_connected_components(graph_edges: List[Tuple[any, any]]) -> List[List[any]]: graph = GraphUndirected() for u, v in graph_edges: graph.add_edge(u, v) return graph.find_connected_components()"},{"question":"# Problem Statement You are required to write a function to determine whether a given non-negative integer is a palindrome. A palindrome is a number that reads the same forward and backward. For example, 121 is a palindrome while 123 is not. Your task is to complete the function `is_palindrome_number(n: int) -> bool` which returns `True` if the integer `n` is a palindrome and `False` otherwise. # Function Signature ```python def is_palindrome_number(n: int) -> bool: ``` # Input * An integer `n` (0 ≤ n ≤ 2^31 - 1). # Output * A boolean value `True` if `n` is a palindrome, otherwise `False`. # Example ```python n = 121 expected_output = True assert is_palindrome_number(n) == expected_output ``` ```python n = 123 expected_output = False assert is_palindrome_number(n) == expected_output ``` # Note - Avoid using extra space for another integer list or array. - Try to come up with a sufficient O(1) space complex solution.","solution":"def is_palindrome_number(n: int) -> bool: Returns True if the integer n is a palindrome, otherwise False. A palindrome number reads the same forward and backward. original = n reversed_num = 0 while n > 0: remainder = n % 10 reversed_num = reversed_num * 10 + remainder n = n // 10 return original == reversed_num"},{"question":"# CODING ASSESSMENT QUESTION Introduction You are a software developer working on a project that involves parsing log files from a web server. These log files contain various entries, each tracking an HTTP request. The logs are in a specific format and your task is to extract meaningful information from them. Problem Description Write a function `parse_log_entry` that takes a single log entry string and returns a dictionary with the following key pieces of information: 1. **IP Address**: - Key: `ip_address` - Description: The IP address from where the request originated. 2. **Timestamp**: - Key: `timestamp` - Description: The time when the request was made in the format `DD/MMM/YYYY:HH:MM:SS`. 3. **Request Method**: - Key: `request_method` - Description: The HTTP method of the request (e.g., GET, POST). 4. **Request Path**: - Key: `request_path` - Description: The path of the requested resource. 5. **Response Status**: - Key: `response_status` - Description: The status code of the response. 6. **Response Size**: - Key: `response_size` - Description: The size of the response in bytes. The log entry will follow this format: ``` <IP_Address> - - [<Timestamp>] \\"<Request_Method> <Request_Path> HTTP/1.1\\" <Response_Status> <Response_Size> ``` For example: ``` 192.168.1.1 - - [10/Oct/2023:13:55:36 -0700] \\"GET /index.html HTTP/1.1\\" 200 1043 ``` Function Signature ```python def parse_log_entry(log_entry: str) -> dict: pass ``` Expected Input and Output ``` >>> parse_log_entry(\'192.168.1.1 - - [10/Oct/2023:13:55:36 -0700] \\"GET /index.html HTTP/1.1\\" 200 1043\') { \'ip_address\': \'192.168.1.1\', \'timestamp\': \'10/Oct/2023:13:55:36\', \'request_method\': \'GET\', \'request_path\': \'/index.html\', \'response_status\': 200, \'response_size\': 1043 } >>> parse_log_entry(\'127.0.0.1 - - [15/Nov/2022:09:20:15 -0700] \\"POST /submit-form HTTP/1.1\\" 404 512\') { \'ip_address\': \'127.0.0.1\', \'timestamp\': \'15/Nov/2022:09:20:15\', \'request_method\': \'POST\', \'request_path\': \'/submit-form\', \'response_status\': 404, \'response_size\': 512 } ``` Constraints 1. The log entries will always be well-formed as per the given format. 2. Ensure that the keys in the output dictionary are named precisely as specified. 3. The fields `response_status` and `response_size` should be integers in the output dictionary.","solution":"def parse_log_entry(log_entry: str) -> dict: split_entry = log_entry.split() ip_address = split_entry[0] timestamp = split_entry[3][1:] + \\" \\" + split_entry[4][:-1] request_method = split_entry[5][1:] request_path = split_entry[6] response_status = int(split_entry[8]) response_size = int(split_entry[9]) # Removing timezone for formatted timestamp timestamp = timestamp.split()[0] return { \'ip_address\': ip_address, \'timestamp\': timestamp, \'request_method\': request_method, \'request_path\': request_path, \'response_status\': response_status, \'response_size\': response_size }"},{"question":"# Problem Statement Create a function that computes the number of rectangles that can be formed using the points provided as vertices. The points are given in a 2D plane and all points lie on integer coordinates. Two points form a diagonal of a rectangle if their x and y coordinates are different. Rectangles should be counted uniquely without considering their rotations or reflected counterparts. # Function Definition `count_rectangles(points: List[Tuple[int, int]]) -> int` - **Input**: - `points`: A list of tuples, where each tuple represents the coordinates (x, y) of a point in the 2D plane. - **Output**: - An integer representing the number of rectangles that can be constructed using the points as vertices. - **Constraints**: - The number of points will be at most 200. - All coordinates will be within the range (-100, 100). # Example ```python points = [ (1, 2), (2, 1), (2, 2), (1, 1), (4, 5), (5, 5), (4, 6), (5, 6) ] assert count_rectangles(points) == 2 ``` # Explanation - The rectangles formed by the given points are: - (1, 1), (1, 2), (2, 1), and (2, 2) - (4, 5), (4, 6), (5, 5), and (5, 6) # Note - Consider all unique rectangles ignoring rotations and symmetrical transformations. - Efficiently check for pairs of points forming diagonals and ensure they can form a valid rectangle by checking remaining corners in the point set. # Example Edge Case ```python points = [ (0, 0), (0, 1), (1, 0), (1, 1), (10, 10), (10, 11), (11, 10), (11, 11) ] assert count_rectangles(points) == 2 ``` - This should return 2, covering two separate sets of points forming rectangles on different areas of the plane. Make sure to handle edge cases where no rectangles can be formed and the provided points are in different areas without forming any rectangles.","solution":"from typing import List, Tuple def count_rectangles(points: List[Tuple[int, int]]) -> int: Computes the number of rectangles that can be formed using the points provided as vertices. point_set = set(points) count = 0 for i in range(len(points)): for j in range(i + 1, len(points)): p1 = points[i] p2 = points[j] # Check if points p1 and p2 can form diagonal of a rectangle if p1[0] != p2[0] and p1[1] != p2[1]: # The other two points that should exist to form a rectangle if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set: count += 1 # Each rectangle is counted twice, so divide by 2 return count // 2"},{"question":"# Coding Assessment Question: Implementing String Compression Algorithm **Scenario**: You are tasked with optimizing the storage of repeated characters in strings for a text editor. To achieve this, you decide to implement a simple string compression algorithm that replaces consecutive repeated characters with a single character followed by the count of repetitions. For instance, the string `\\"aaabb\\"` would be compressed to `\\"a3b2\\"`. **Objective**: You need to implement a function `compress_string` that takes a string as input and returns the compressed version of the string. If the compressed string is not shorter than the original string, the function should return the original string. Input: - `s`: A string to be compressed. Output: - A compressed version of the input string if it is shorter than the original. Otherwise, return the original string. Example: ```python def compress_string(s: str) -> str: Compresses the string such that each group of consecutive repeated characters is represented by the character followed by the number of repetitions. compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 # Add the last group compressed.append(s[-1]) compressed.append(str(count)) compressed_string = \'\'.join(compressed) # Return the compressed string if it\'s shorter, otherwise the original string return compressed_string if len(compressed_string) < len(s) else s # Example usage: if __name__ == \\"__main__\\": assert compress_string(\\"aaabb\\") == \\"a3b2\\" assert compress_string(\\"abcd\\") == \\"abcd\\" assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" ``` Constraints: 1. The input string `s` can contain uppercase and lowercase letters. 2. The length of the input string `s` is at most 1000. Requirements: - Implement the `compress_string` function to achieve the described compression. - Ensure your solution handles various edge cases such as single-character strings and strings with no repeated characters. - The implementation should prioritize efficiency, especially for longer input strings. **Note**: This question evaluates your ability to manipulate strings efficiently and implement algorithms that conditionally modify data based on string length comparison.","solution":"def compress_string(s: str) -> str: Compresses the string such that each group of consecutive repeated characters is represented by the character followed by the number of repetitions. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 # Add the last group compressed.append(s[-1]) compressed.append(str(count)) compressed_string = \'\'.join(compressed) # Return the compressed string if it\'s shorter, otherwise the original string return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Dynamic List Index Sum You are required to implement a function that calculates the sum of elements in a list based on a given series of index pairs. Each pair of indices represents a range, and the sum of elements within this range needs to be computed and added to the total sum. Function Signature ```python def index_sum(lst: list[int], index_pairs: list[tuple[int, int]]) -> int: pass ``` # Instructions 1. **Functionality**: Implement the function `index_sum` which takes in two arguments: - `lst`: A list of integers. - `index_pairs`: A list of tuples, where each tuple contains two integers representing the start and end indices (inclusive) of a sub-list. 2. **Sum Calculation**: For each pair in `index_pairs`, calculate the sum of the elements in `lst` from the start index to the end index, inclusive, and add this to a total sum. 3. **Return Value**: The function should return the total sum of all the sub-lists derived from the index pairs. # Expected Input and Output * **Input**: - `lst`: A list of integers (e.g., `[1, 2, 3, 4, 5]`). - `index_pairs`: A list of tuples where each tuple consists of two ints representing the start and end indices (inclusive) (e.g., `[(0, 1), (2, 4)]`). * **Output**: - An integer representing the total sum of the sub-lists defined by the given index pairs. # Constraints 1. Index values in `index_pairs` will always be valid; you do not need to handle index errors. 2. The list `lst` can have a length between 1 and (10^5). 3. The total number of pairs in `index_pairs` can be up to (10^4). # Example ```python >>> index_sum([1, 2, 3, 4, 5], [(0, 1), (2, 4)]) 15 >>> index_sum([10, 20, 30, 40], [(1, 2), (0, 3)]) 120 >>> index_sum([5, 15, 25, 35, 45], [(0, 0), (3, 3)]) 40 ``` # Note Ensure the function calculates the sums correctly for all sub-lists derived from the given index pairs and returns the cumulative total as specified.","solution":"def index_sum(lst: list[int], index_pairs: list[tuple[int, int]]) -> int: Computes the total sum of elements in the list `lst` based on ranges provided in `index_pairs`. total_sum = 0 for start, end in index_pairs: total_sum += sum(lst[start:end+1]) return total_sum"},{"question":"# Coding Assessment Question Context You are asked to implement a data structure that manages a collection of intervals and supports efficient querying of overlapping intervals. The data structure should allow for adding new intervals, removing existing intervals, and retrieving all intervals that overlap with a given interval. Task Implement the `IntervalCollection` class with the following functionalities: 1. **AddInterval**: Add a new interval to the collection. 2. **RemoveInterval**: Remove an existing interval from the collection. 3. **FindOverlapping**: Retrieve a list of intervals that overlap with a given interval. Requirements - Implement the `IntervalCollection` class with all the specified methods. - Ensure that all operations are efficient. - Handle edge cases such as adding duplicate intervals and removing non-existing intervals (should raise a `ValueError`). Example Usage ```python ic = IntervalCollection() ic.add_interval((1, 5)) ic.add_interval((6, 10)) ic.add_interval((8, 12)) overlaps = ic.find_overlapping((7, 9)) print(overlaps) # Output: [(6, 10), (8, 12)] try: ic.remove_interval((2, 4)) # Should raise ValueError as the interval does not exist except ValueError: print(\\"Interval does not exist\\") ``` Input/Output Format - **AddInterval**: Accepts a tuple representing the interval `(start, end)`, where `start` and `end` are integers and `start <= end`. - **RemoveInterval**: Accepts a tuple representing the interval `(start, end)` and removes it from the collection. - **FindOverlapping**: Accepts a tuple representing interval `(start, end)` and returns a list of intervals that overlap with the given interval. Constraints - Intervals are pairs of integers `(start, end)`. - The collection can contain up to `10^5` intervals. - For overlapping determination, two intervals `(start1, end1)` and `(start2, end2)` overlap if `end1 >= start2` and `end2 >= start1`. Performance - Ensure that all operations are efficient and scalable to large collections.","solution":"class IntervalCollection: def __init__(self): self.intervals = [] def add_interval(self, interval): if interval not in self.intervals: self.intervals.append(interval) self.intervals.sort() def remove_interval(self, interval): if interval in self.intervals: self.intervals.remove(interval) else: raise ValueError(\\"Interval does not exist\\") def find_overlapping(self, interval): start, end = interval overlapping_intervals = [ (s, e) for s, e in self.intervals if not (e < start or s > end) ] return overlapping_intervals"},{"question":"# Coding Assessment Question You are required to implement a function that calculates the longest common subsequence (LCS) of two sequences provided as either a list or a tuple. The function should return the length of this subsequence. **Function Signature**: ```python def longest_common_subsequence( seq_a: list[int] | tuple[int], seq_b: list[int] | tuple[int] ) -> int: ``` **Input**: - `seq_a`: A non-empty `list` or `tuple` of integers. - `seq_b`: A non-empty `list` or `tuple` of integers. **Output**: - An integer representing the length of the longest common subsequence between the two sequences. **Constraints**: - Both inputs must be of the same type (i.e., both lists or both tuples). - The inputs are guaranteed to contain only integers. **Examples**: 1. `longest_common_subsequence([1, 3, 4, 1, 2, 8], [3, 4, 1, 2, 1, 3])` should return `4`. 2. `longest_common_subsequence((2, 7, 5), (2, 5, 7))` should return `2`. 3. `longest_common_subsequence([1, 2, 3], [4, 5, 6])` should return `0`. **Edge Cases**: 1. Comparing sequences with only one element: `[1], [1]` should return `1`. 2. Comparing completely disjoint sequences with no common elements: `[1, 2, 3], [4, 5, 6]` should return `0`. 3. Testing with large sequences. # Testing: 1. Write tests to check if your function handles both lists and tuples. 2. Ensure your function works efficiently with large sequences. **Tasks**: 1. Write the function `longest_common_subsequence` based on the provided signature. 2. Ensure your function efficiently computes the LCS for large inputs.","solution":"def longest_common_subsequence(seq_a, seq_b): Calculates the length of the longest common subsequence (LCS) of two sequences. Args: seq_a: list or tuple of integers. seq_b: list or tuple of integers. Returns: An integer representing the length of the LCS. len_a = len(seq_a) len_b = len(seq_b) # Create a 2D array to store lengths of LCS dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Fill the dp array in a bottom-up manner for i in range(1, len_a + 1): for j in range(1, len_b + 1): if seq_a[i - 1] == seq_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[len_a][len_b]"},{"question":"# Problem Statement You are given a string `s` containing only lowercase English letters and an array `pairs` where each `pairs[i] = [a, b]` indicates that the characters at indices `a` and `b` in the string can be swapped. Write a function `smallest_string_with_swaps(s: str, pairs: list[list[int]]) -> str` that returns the lexicographically smallest string that can be obtained by performing any number of swaps. # Function Signature ```python def smallest_string_with_swaps(s: str, pairs: list[list[int]]) -> str: pass ``` # Input * `s`: A string consisting of lowercase English letters. - `1 <= len(s) <= 10^5` * `pairs`: A list of pairs of integers, where each `pairs[i]` is a pair [a, b]. - `0 <= a, b < len(s)` - `0 <= len(pairs) <= 10^5` # Output * Returns a string representing the lexicographically smallest string possible. # Constraints * All characters in the string are lowercase English letters. * Each pair indicates that the characters at those indices can be swapped. * Pairs can be used in any order and any number of times. # Example ```python s = \\"dcab\\" pairs = [[0, 3], [1, 2]] smallest_string_with_swaps(s, pairs) # Output: \\"bacd\\" s = \\"dcab\\" pairs = [[0, 3], [1, 2], [0, 2]] smallest_string_with_swaps(s, pairs) # Output: \\"abcd\\" ``` # Additional Notes * Consider using Union-Find data structure to efficiently manage and track connected components formed by the exchangeable pairs. * Sort the characters within each connected component and rearrange them to achieve the smallest lexicographical order. * Pay attention to edge cases such as when there are no pairs, or when every character is connected.","solution":"def smallest_string_with_swaps(s, pairs): from collections import defaultdict import heapq # Union-Find (Disjoint Set Union) class class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 n = len(s) uf = UnionFind(n) # Union the pairs for x, y in pairs: uf.union(x, y) # Group all characters according to their component roots components = defaultdict(list) for i in range(n): root = uf.find(i) components[root].append(s[i]) # Sort characters in each component to prepare smallest lexicographical order for key in components.keys(): components[key].sort(reverse=True) # Build the result string with the smallest lexicographical order result = [] for i in range(n): root = uf.find(i) result.append(components[root].pop()) return \'\'.join(result)"},{"question":"# Movie Recommendation System You are required to implement a simple movie recommendation system that suggests movies to users based on their past ratings. The system will maintain a database of users, movies, and ratings, and support querying for the top N movie recommendations for a given user. Scenario: Imagine you are building a movie recommendation system for a streaming platform. Users rate the movies they watch, and you need to recommend new movies they haven\'t rated yet based on the ratings of other users with similar tastes. Requirements: 1. **Class Definition**: Define a class `MovieRecommender` with appropriate methods. 2. **Initialization**: * The class should be initialized with a maximum number of recommendations it can provide. * Raise a `ValueError` if the given maximum number is not a positive integer. 3. **Rating Method**: * Implement a `rate_movie` method to add or update a user\'s rating for a movie. * If a user changes their rating for a movie, the previous rating should be updated. 4. **Recommendation Method**: * Implement a `recommend_movies` method to fetch top N movie recommendations for a user. * Recommendations should be based on the average rating of movies that the user hasn\'t rated yet, coming from users with similar rating patterns. 5. **Displaying Ratings**: Implement a method to print all ratings in the database. 6. **Performance**: Optimize the solution to achieve efficient time complexity for querying recommendations. Input and Output Formats: * **Input**: * `rate_movies` method: Takes three arguments `user_id` (str), `movie_id` (str), and `rating` (float). * `recommend_movies` method: Takes two arguments `user_id` (str) and `n` (int, number of recommendations). * **Output**: * `recommend_movies` method: Returns a list of `n` movie_ids with the highest average ratings among unrated movies for the user. * `display_ratings` method: Prints all user-movie ratings in the database. Constraints: * Ratings should be between 0.0 and 5.0 inclusive. * Maximum number of recommendations should be greater than 0. Example Usage: ```python recommender = MovieRecommender(5) recommender.rate_movie(\'user1\', \'movie1\', 4.5) recommender.rate_movie(\'user1\', \'movie2\', 3.0) recommender.rate_movie(\'user2\', \'movie1\', 5.0) recommender.rate_movie(\'user2\', \'movie3\', 2.5) recommender.rate_movie(\'user3\', \'movie3\', 4.0) recommender.display_ratings() # Output: # user1: {movie1: 4.5, movie2: 3.0} # user2: {movie1: 5.0, movie3: 2.5} # user3: {movie3: 4.0} recommendations = recommender.recommend_movies(\'user1\', 2) print(recommendations) # Output: [\'movie3\'] assuming \'movie3\' has highest average rating for unrated movies. ```","solution":"class MovieRecommender: def __init__(self, max_recommendations): if not isinstance(max_recommendations, int) or max_recommendations <= 0: raise ValueError(\\"Maximum number of recommendations must be a positive integer\\") self.max_recommendations = max_recommendations self.ratings = {} def rate_movie(self, user_id, movie_id, rating): if rating < 0.0 or rating > 5.0: raise ValueError(\\"Rating must be between 0.0 and 5.0\\") if user_id not in self.ratings: self.ratings[user_id] = {} self.ratings[user_id][movie_id] = rating def recommend_movies(self, user_id, n): if n < 1 or n > self.max_recommendations: raise ValueError(\\"Number of recommendations requested is invalid\\") all_movie_ratings = {} for user_ratings in self.ratings.values(): for movie_id, rating in user_ratings.items(): if movie_id not in all_movie_ratings: all_movie_ratings[movie_id] = [] all_movie_ratings[movie_id].append(rating) user_rated_movies = self.ratings.get(user_id, {}) movie_avg_ratings = { movie_id: sum(ratings) / len(ratings) for movie_id, ratings in all_movie_ratings.items() if movie_id not in user_rated_movies } sorted_movie_recommendations = sorted( movie_avg_ratings.items(), key=lambda x: x[1], reverse=True ) return [movie_id for movie_id, _ in sorted_movie_recommendations[:n]] def display_ratings(self): for user_id, user_ratings in self.ratings.items(): print(f\\"{user_id}: {user_ratings}\\")"},{"question":"Question: String Transformation Based on a Custom Rule # Scenario You\'re working on a text processing module where you need to transform input strings based on specific rules. One of the tasks involves implementing a function that manipulates strings according to a pattern dictated by custom rules. # Task Write a function `custom_transform` that takes a string as input and returns a new string transformed according to the following rules: 1. Every vowel (`a`, `e`, `i`, `o`, `u`) should be replaced with the next vowel in the sequence (`a` -> `e`, `e` -> `i`, `i` -> `o`, `o` -> `u`, `u` -> `a`). 2. Consonants remain unchanged. 3. The function should preserve the original case of the characters. # Function Signature ```python def custom_transform(input_string: str) -> str: ``` # Input * `input_string` (str): A string consisting of alphabetic characters (both uppercase and lowercase). # Output * Returns a transformed string according to the specified rules. # Constraints * The input string consists of alphabets only and is non-empty. * The transformation should preserve the case of each character. # Example ```python print(custom_transform(\\"Hello World\\")) # Output: \\"Himmo Wurld\\" print(custom_transform(\\"Python\\")) # Output: \\"Pythun\\" print(custom_transform(\\"AbcE\\")) # Output: \\"EbcI\\" ``` # Notes * Ensure the function handles different cases correctly (both lowercase and uppercase letters). * Consider all edge cases and provide sufficient test examples to validate the functionality of your implementation. # Hint Use a dictionary to map vowels to their replacements for easy transformation and ensure to handle both lowercase and uppercase mappings separately.","solution":"def custom_transform(input_string: str) -> str: Transform the input string based on custom vowel replacement rules: a -> e, e -> i, i -> o, o -> u, u -> a (preserving case). Consonants remain unchanged. # Define the vowel transformation dictionary vowel_transform = { \'a\': \'e\', \'e\': \'i\', \'i\': \'o\', \'o\': \'u\', \'u\': \'a\', \'A\': \'E\', \'E\': \'I\', \'I\': \'O\', \'O\': \'U\', \'U\': \'A\' } # Build the transformed output string transformed_string = \'\'.join(vowel_transform.get(char, char) for char in input_string) return transformed_string"},{"question":"Description You are given an undirected graph represented by its vertices and edges, and you need to implement a function to detect if the graph contains a cycle. A cycle is defined as a path that starts and ends at the same vertex. Function Signature ```python def contains_cycle(vertices: list, edges: list) -> bool: ... ``` Input - `vertices`: A list of vertices in the graph, each represented by an integer or string. - `edges`: A list of edges, where each edge is represented as a tuple (vertex1, vertex2). Output - `has_cycle`: A boolean value `True` if the graph contains at least one cycle, `False` otherwise. Constraints - The graph will have at most 10^3 vertices. - The graph will have at most 10^4 edges. Example ```python vertices = [0, 1, 2, 3] edges = [(0, 1), (1, 2), (2, 0), (1, 3)] has_cycle = contains_cycle(vertices, edges) print(has_cycle) # Expected Output: True vertices = [0, 1, 2, 3] edges = [(0, 1), (1, 2), (2, 3)] has_cycle = contains_cycle(vertices, edges) print(has_cycle) # Expected Output: False ``` Performance Requirements Your solution should consider edge cases effectively, including graphs with: - Multiple components - Self-loops - Very sparse or very dense graphs Implement this with maximum efficiency in terms of both time and space complexity.","solution":"def contains_cycle(vertices: list, edges: list) -> bool: Determines if the undirected graph contains a cycle. from collections import defaultdict # Building the adjacency list from the edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node): return True elif neighbor != parent: return True return False for vertex in vertices: if vertex not in visited: if dfs(vertex, None): return True return False"},{"question":"# Problem Statement You are to design a function `shortest_path_length` to find the shortest path length in an unweighted grid from a start position to an end position. The grid consists of passable cells (\'.\') and walls (\'#\'), and you can only move in four directions (up, down, left, right). Function Signature ```python def shortest_path_length(grid: List[List[str]], start: Tuple[int, int], end: Tuple[int, int]) -> int: pass ``` Input - **Grid**: A 2D list of characters representing the grid (1 ≤ |grid| ≤ 1000, 1 ≤ |grid[0]| ≤ 1000). - **Start**: A tuple (x1, y1) representing the starting position (0 ≤ x1 < |grid|, 0 ≤ y1 < |grid[0]|). - **End**: A tuple (x2, y2) representing the ending position (0 ≤ x2 < |grid|, 0 ≤ y2 < |grid[0]|). Output - Returns the shortest path length as an integer. If no path exists, return `-1`. Constraints - You cannot move into cells marked with a \'#\'. - You may assume the start position is always passable. Examples 1. Example 1 ```python grid = [ [\'.\', \'.\', \'.\', \'#\', \'.\'], [\'.\', \'#\', \'.\', \'#\', \'.\'], [\'.\', \'#\', \'.\', \'.\', \'.\'], [\'#\', \'.\', \'#\', \'.\', \'.\'] ] start = (0, 0) end = (3, 4) assert shortest_path_length(grid, start, end) == 7 ``` Explanation: The shortest path is 7 steps long. 2. Example 2 ```python grid = [ [\'.\', \'#\', \'.\'], [\'#\', \'.\', \'.\'], [\'.\', \'#\', \'.\'] ] start = (0, 0) end = (2, 2) assert shortest_path_length(grid, start, end) == -1 ``` Explanation: There is no path from the start to the end. 3. Example 3 ```python grid = [ [\'.\', \'.\', \'.\'], [\'.\', \'#\', \'.\'], [\'.\', \'.\', \'.\'] ] start = (0, 0) end = (0, 2) assert shortest_path_length(grid, start, end) == 2 ``` Explanation: The shortest path is 2 steps long. # Additional Information You can use the Breadth-First Search (BFS) algorithm to find the shortest path in an unweighted grid. Make sure to handle edge cases like when the start is the same as the end, or when there are no passable cells adjacent to the start.","solution":"from typing import List, Tuple from collections import deque def shortest_path_length(grid: List[List[str]], start: Tuple[int, int], end: Tuple[int, int]) -> int: def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == \'.\' if start == end: return 0 rows, cols = len(grid), len(grid[0]) queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add(start) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == end: return dist + 1 if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Optimizing Search Algorithms Background You are developing an application that requires efficient searching over large datasets. The target environment has constraints such as limited memory and computational power. Thus, you need to choose an appropriate search algorithm and optimize it for both speed and resource usage. Task Implement an optimized search algorithm, specifically a bisected (binary) search, to efficiently find a target value within a sorted list of integers. Your algorithm should minimize the number of comparisons and handle large datasets efficiently. Requirements - Create a class `BinarySearch` with a method `find` that performs a binary search. - The `find` method should take a sorted list of integers `data` and an integer `target` as input parameters. - The method should return the index of the target in the list if found, otherwise return `-1`. Binary Search Description The binary search algorithm works by repeatedly dividing the portion of the list that could contain the target value in half until you\'ve narrowed down the possible locations to just one. Algorithm steps: 1. Start with two pointers, `low` and `high`, pointing to the first and the last elements of the list, respectively. 2. Find the midpoint, `mid`, of the list segment between `low` and `high`. 3. Compare the target with the element at the `mid` index: - If the target is equal to the element at `mid`, return `mid`. - If the target is less than the element at `mid`, search the left half. - If the target is greater than the element at `mid`, search the right half. 4. Repeat steps 2-3 until the `low` pointer is greater than the `high` pointer, indicating that the target is not in the list. Input - A sorted list of integers: `List[int]` - A target integer value: `int` Output - The index of the target in the list if found: `int` - `-1` if the target is not found Example Usage ```python class BinarySearch: @staticmethod def find(data: List[int], target: int) -> int: low, high = 0, len(data) - 1 while low <= high: mid = (low + high) // 2 if data[mid] == target: return mid elif data[mid] < target: low = mid + 1 else: high = mid - 1 return -1 # Example: Using the binary search sorted_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target_value = 7 search_instance = BinarySearch() index = search_instance.find(sorted_list, target_value) print(f\'Target found at index: {index}\') # Output: Target found at index: 6 ``` Constraints - Ensure that the algorithm handles edge cases where the list might be empty. - The search algorithm should operate within `O(log n)` time complexity. - Consider performance optimizations for cases of extremely large datasets to prevent excessive memory usage. Good luck!","solution":"from typing import List class BinarySearch: @staticmethod def find(data: List[int], target: int) -> int: low, high = 0, len(data) - 1 while low <= high: mid = (low + high) // 2 if data[mid] == target: return mid elif data[mid] < target: low = mid + 1 else: high = mid - 1 return -1"},{"question":"# Question **Background**: You are developing a program that works with large numerical datasets. To manage memory efficiently, you\'ve decided to implement a custom cache mechanism that stores the results of repeated function calls. **Task**: Write a function `lru_cache` that implements an LRU (Least Recently Used) cache as a decorator. The decorator should cache the results of a function call with up to `max_size` different arguments. If the cache exceeds `max_size`, it should discard the least recently used cached entry to make room for new ones. **Function Signature**: ```python def lru_cache(max_size: int): pass ``` **Input**: * `max_size` (int): The maximum number of entries the cache can hold before evicting the least recently used entry. **Output**: * A decorator that can be applied to any function to cache its results. **Constraints**: * The cache should only store the results for up to `max_size` different arguments. * The `max_size` will be ( 1 leq text{max_size} leq 10^5 ). * The decorator will be applied to functions whose arguments are hashable. **Requirements**: * Ensure the decorator maintains an efficient access and evicts the least recently used entry as needed. * Utilize Python\'s collections module for implementing the LRU cache. **Examples**: ```python # Example 1 @lru_cache(max_size=3) def add(a, b): return a + b print(add(1, 2)) # Expected: 3 (Calculated and cached) print(add(2, 3)) # Expected: 5 (Calculated and cached) print(add(3, 4)) # Expected: 7 (Calculated and cached) print(add(1, 2)) # Expected: 3 (Cached result) print(add(4, 5)) # Expected: 9 (Calculated and cached, oldest entry (2, 3)->5 evicted) # Example 2 @lru_cache(max_size=2) def multiply(x, y): return x * y print(multiply(3, 3)) # Expected: 9 (Calculated and cached) print(multiply(4, 4)) # Expected: 16 (Calculated and cached) print(multiply(3, 3)) # Expected: 9 (Cached result) print(multiply(5, 5)) # Expected: 25 (Calculated and cached, oldest entry (3, 3)->9 evicted) print(multiply(4, 4)) # Expected: 16 (Cached result) ``` **Notes**: * Use the `collections.OrderedDict` from the `collections` module to maintain the order of the elements and manage the LRU eviction policy. * Ensure the cache is thread-safe if accessed from multiple threads simultaneously.","solution":"from collections import OrderedDict def lru_cache(max_size): def decorator(func): cache = OrderedDict() def wrapper(*args): if args in cache: cache.move_to_end(args) # To mark as recently used return cache[args] result = func(*args) cache[args] = result if len(cache) > max_size: cache.popitem(last=False) # Remove least recently used item return result return wrapper return decorator"},{"question":"**Question**: Create a function named `merge_two_sorted_linked_lists` which merges two sorted singly linked lists into one sorted linked list and returns the head of the resulting list. You may not use additional space (i.e., only constant extra space is allowed). **Function Signature**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: pass ``` **Input**: * Two `ListNode` objects, `l1` and `l2`, representing the heads of two sorted singly linked lists. The values of the nodes in each list are sorted in non-decreasing order. **Output**: * A `ListNode` object representing the head of the merged sorted singly linked list. **Constraints**: * The merged list must be sorted in non-decreasing order. * The function must not use any extra space for merging (i.e., must operate in constant space relative to input lists). **Examples**: ```python # Example 1 l1 = ListNode(1, ListNode(2, ListNode(4))) l2 = ListNode(1, ListNode(3, ListNode(4))) merged_head = merge_two_sorted_linked_lists(l1, l2) # Resulting linked list: 1 -> 1 -> 2 -> 3 -> 4 -> 4 # Example 2 l1 = ListNode(5) l2 = ListNode(1, ListNode(2, ListNode(3))) merged_head = merge_two_sorted_linked_lists(l1, l2) # Resulting linked list: 1 -> 2 -> 3 -> 5 # Example 3 l1 = None l2 = ListNode(0) merged_head = merge_two_sorted_linked_lists(l1, l2) # Resulting linked list: 0 ``` **Implementation Notes**: * Carefully handle edge cases where one or both input linked lists are empty. * Ensure the merged linked list maintains the sorted order without using additional data structures.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 if l2: tail.next = l2 return dummy.next"},{"question":"Question You are given a class `Matrix` representing a 2D matrix with integer values. Your task is to implement the method `transpose` which will transpose the matrix. # Function Signature ```python def transpose(self) -> Matrix: ``` # Parameters None # Returns - The transposed matrix (self) in place without creating a new matrix. # Example Usage ```python m = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) m.transpose() print(m) # Should output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] m = Matrix([[1, 2], [3, 4], [5, 6]]) m.transpose() print(m) # Should output: [[1, 3, 5], [2, 4, 6]] ``` # Constraints - Do not use any additional libraries or helper functions (like `numpy`). - The matrix will always contain at least one element (i.e., it will not be empty). - Handle both square and non-square matrices. # Edge Cases to Consider - Transposing an already square matrix. - Transposing a matrix that has only one row or one column.","solution":"class Matrix: def __init__(self, data): self.data = data def transpose(self): rows, cols = len(self.data), len(self.data[0]) transposed_data = [[self.data[row][col] for row in range(rows)] for col in range(cols)] self.data = transposed_data def __repr__(self): return repr(self.data)"},{"question":"# Coding Assessment Question: Develop a Simplified Neural Network Class Context You are given a simplistic implementation of a Neural Network class used for binary classification that uses one hidden layer. The class should support forward propagation, backpropagation, and model training. In this exercise, your objective is to complete the implementation by adding essential features and functionalities. # Task 1. **Initialization**: Implement the constructor that initializes the network parameters (weights and biases for hidden and output layers) randomly in a range appropriate for a neural network. 2. **Forward Propagation**: Implement the `forward_propagation` method to compute the hidden and output layers\' activations using the sigmoid activation function. 3. **Backpropagation**: Implement the `back_propagation` method to update the weights and biases based on the output error. 4. **Model Training**: Implement the `train` method to optimize the network\'s weights and biases over a given number of iterations. 5. **Prediction**: Implement the `predict` method to make predictions based on input features. # Implementation ```python import numpy as np class SimpleNeuralNetwork: def __init__(self, input_size, hidden_size, output_size, learning_rate=0.1): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.learning_rate = learning_rate # Initialize weights and biases self.weights_input_hidden = np.random.randn(input_size, hidden_size) * 0.01 self.bias_hidden = np.zeros((1, hidden_size)) self.weights_hidden_output = np.random.randn(hidden_size, output_size) * 0.01 self.bias_output = np.zeros((1, output_size)) def sigmoid(self, x): return 1 / (1 + np.exp(-x)) def sigmoid_derivative(self, x): return x * (1 - x) def forward_propagation(self, X): self.hidden_layer_activation = np.dot(X, self.weights_input_hidden) + self.bias_hidden self.hidden_layer_output = self.sigmoid(self.hidden_layer_activation) self.output_layer_activation = np.dot(self.hidden_layer_output, self.weights_hidden_output) + self.bias_output self.output = self.sigmoid(self.output_layer_activation) return self.output def back_propagation(self, X, y): m = y.size output_error = self.output - y output_delta = output_error * self.sigmoid_derivative(self.output) hidden_output_error = np.dot(output_delta, self.weights_hidden_output.T) hidden_output_delta = hidden_output_error * self.sigmoid_derivative(self.hidden_layer_output) self.weights_hidden_output -= self.learning_rate * np.dot(self.hidden_layer_output.T, output_delta) / m self.bias_output -= self.learning_rate * np.sum(output_delta, axis=0, keepdims=True) / m self.weights_input_hidden -= self.learning_rate * np.dot(X.T, hidden_output_delta) / m self.bias_hidden -= self.learning_rate * np.sum(hidden_output_delta, axis=0, keepdims=True) / m def train(self, X, y, iterations=1000): for i in range(iterations): self.forward_propagation(X) self.back_propagation(X, y) def predict(self, X): output = self.forward_propagation(X) predictions = np.round(output) return predictions # Testing the Neural Network with a simple example: if __name__ == \\"__main__\\": # AND logic gate example X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) y = np.array([[0], [0], [0], [1]]) nn = SimpleNeuralNetwork(input_size=2, hidden_size=2, output_size=1, learning_rate=0.1) nn.train(X, y, iterations=10000) predictions = nn.predict(X) print(\\"Predictions:n\\", predictions) ``` Input Format - The constructor takes the following parameters: `input_size` (number of features), `hidden_size` (number of neurons in the hidden layer), `output_size` (number of neurons in the output layer which is 1 in binary classification), and an optional `learning_rate`. - Method `train` takes the feature matrix `X`, the target values `y`, and the number of `iterations` as input. - Method `predict` takes the feature matrix `X` as input. Output Format - Method `predict` returns the predicted values as a numpy array rounded to the nearest integer (0 or 1 in this case). Constraints - Ensure the input data `X` and `y` are in the form of numpy arrays. - The number of iterations in `train` should be a positive integer.","solution":"import numpy as np class SimpleNeuralNetwork: def __init__(self, input_size, hidden_size, output_size, learning_rate=0.1): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.learning_rate = learning_rate # Initialize weights and biases self.weights_input_hidden = np.random.randn(input_size, hidden_size) * 0.01 self.bias_hidden = np.zeros((1, hidden_size)) self.weights_hidden_output = np.random.randn(hidden_size, output_size) * 0.01 self.bias_output = np.zeros((1, output_size)) def sigmoid(self, x): return 1 / (1 + np.exp(-x)) def sigmoid_derivative(self, x): return x * (1 - x) def forward_propagation(self, X): self.hidden_layer_activation = np.dot(X, self.weights_input_hidden) + self.bias_hidden self.hidden_layer_output = self.sigmoid(self.hidden_layer_activation) self.output_layer_activation = np.dot(self.hidden_layer_output, self.weights_hidden_output) + self.bias_output self.output = self.sigmoid(self.output_layer_activation) return self.output def back_propagation(self, X, y): m = y.size output_error = self.output - y output_delta = output_error * self.sigmoid_derivative(self.output) hidden_output_error = np.dot(output_delta, self.weights_hidden_output.T) hidden_output_delta = hidden_output_error * self.sigmoid_derivative(self.hidden_layer_output) self.weights_hidden_output -= self.learning_rate * np.dot(self.hidden_layer_output.T, output_delta) / m self.bias_output -= self.learning_rate * np.sum(output_delta, axis=0, keepdims=True) / m self.weights_input_hidden -= self.learning_rate * np.dot(X.T, hidden_output_delta) / m self.bias_hidden -= self.learning_rate * np.sum(hidden_output_delta, axis=0, keepdims=True) / m def train(self, X, y, iterations=1000): for i in range(iterations): self.forward_propagation(X) self.back_propagation(X, y) def predict(self, X): output = self.forward_propagation(X) predictions = np.round(output) return predictions # This code is not required for the solution but is given here as an example usage # of the SimpleNeuralNetwork class: # if __name__ == \\"__main__\\": # # AND logic gate example # X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) # y = np.array([[0], [0], [0], [1]]) # nn = SimpleNeuralNetwork(input_size=2, hidden_size=2, output_size=1, learning_rate=0.1) # nn.train(X, y, iterations=10000) # predictions = nn.predict(X) # print(\\"Predictions:n\\", predictions)"},{"question":"# Coding Assessment Task: Context: You are a software developer for a traffic management system company. Your team is upgrading the system to handle more complex traffic signal scenarios, including adaptive signal control to optimize traffic flow. Problem Statement: Write a function `optimal_traffic_flow` that determines the optimal cycle length for a series of interconnected traffic lights based on the average arrival rate of vehicles and the desired throughput. The cycle length is defined as the total time (in seconds) taken for the traffic light to complete one full sequence of green, yellow, and red lights. Function Signature: ```python def optimal_traffic_flow(arrival_rate: float, throughput: float) -> float: pass ``` Input/Output: * **Input**: Two floats: - `arrival_rate`: The average rate at which vehicles arrive at the intersection (vehicles per second). - `throughput`: The desired number of vehicles that can pass through the intersection during one cycle (vehicles per cycle). * **Output**: A float representing the optimal cycle length in seconds. Constraints: - `arrival_rate` and `throughput` must be positive floats greater than zero. - Assume that the traffic light can\'t cycle faster than 15 seconds and no slower than 180 seconds. - The function should handle edge cases and invalid inputs gracefully by raising appropriate exceptions, such as `ValueError` for non-positive inputs. Examples: ```python >>> optimal_traffic_flow(0.5, 20) 40.0 >>> optimal_traffic_flow(0.8, 30) 37.5 >>> optimal_traffic_flow(1.2, 40) 33.333333333333336 ``` Notes: 1. The optimal cycle length is calculated by the formula: `throughput / arrival_rate`. If the result is outside the allowed cycle length range (15 seconds to 180 seconds), the function should return the closest boundary value (either 15.0 or 180.0). 2. Validate your inputs and provide meaningful error messages if the inputs do not meet the constraints.","solution":"def optimal_traffic_flow(arrival_rate: float, throughput: float) -> float: Returns the optimal cycle length for a traffic light based on the arrival rate of vehicles and desired throughput. Parameters: arrival_rate (float): The average rate at which vehicles arrive at the intersection (vehicles per second). throughput (float): The number of vehicles that need to pass through the intersection during one cycle (vehicles per cycle). Returns: float: The optimal cycle length in seconds. Raises: ValueError: If arrival_rate or throughput is not a positive float. if arrival_rate <= 0 or throughput <= 0: raise ValueError(\\"arrival_rate and throughput must be positive floats greater than zero\\") optimal_cycle_length = throughput / arrival_rate # Constrain the cycle length to be between 15 and 180 seconds if optimal_cycle_length < 15.0: return 15.0 elif optimal_cycle_length > 180.0: return 180.0 else: return optimal_cycle_length"},{"question":"Binary Search Tree (BST) Operations You are given a simple implementation of a Binary Search Tree (BST). Your task is to extend this functionality by implementing an algorithm to find the `kth` smallest element in the BST. # Requirements 1. **Function**: `find_kth_smallest(bst: BinarySearchTree, k: int) -> Any or None` 2. **Inputs**: - `bst` - An instance of the `BinarySearchTree` class. - `k` - An integer representing the position (1-based) of the smallest element to find. 3. **Output**: - The kth smallest element in the BST. - If k is out of bounds (either less than 1 or greater than the number of elements in the BST), return `None`. 4. **Constraints**: - The BST class is implemented such that each node contains a value and pointers to left and right child nodes. - The tree may be empty. # Examples ```python # Example BST creation and usage bst = BinarySearchTree() bst.insert(5).insert(3).insert(7).insert(2).insert(4).insert(6).insert(8) assert find_kth_smallest(bst, 1) == 2 # The smallest element assert find_kth_smallest(bst, 3) == 4 # The 3rd smallest element assert find_kth_smallest(bst, 7) == 8 # The largest element assert find_kth_smallest(bst, 8) is None # Out of bounds ``` # Notes - You should handle cases where k is less than 1 or greater than the number of elements in the BST. - The algorithm should be optimized to leverage the properties of the BST to efficiently find the kth smallest element. - The `BinarySearchTree` class has been implemented with typical methods like `insert` (for inserting elements) and structured nodes containing `left`, `right`, and `value` attributes.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) return self def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def find_kth_smallest(bst, k): def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right) # Perform inorder traversal of the tree elements = inorder_traversal(bst.root) # Check if k is within bounds if k < 1 or k > len(elements): return None return elements[k-1]"},{"question":"# Coding Challenge: Implement a Dijkstra\'s Shortest Path Algorithm Context Dijkstra\'s algorithm is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge weights, producing a shortest path tree. This algorithm is often used in routing and as a subroutine in other graph problems. Task Write a Python function to implement Dijkstra\'s algorithm. The function should take a graph represented as an adjacency matrix and a starting node, and return the shortest path lengths from the starting node to all other nodes in the graph. Function Signature ```python def dijkstra_shortest_path(graph: list[list[int]], start: int) -> list[int]: Find the shortest paths from the start node to all other nodes using Dijkstra\'s algorithm. Args: - graph: A 2D list where graph[i][j] represents the weight of the edge from node i to node j. If there is no edge, the weight is considered as a large value (float(\'inf\') can be used). - start: The starting node for Dijkstra\'s algorithm. Returns: - distances: A list where distances[i] is the shortest path from the start node to node i. Raises: - ValueError: If the graph is not valid or if the start node is out of bounds. Example: >>> graph = [ [0, 1, 4, float(\'inf\'), float(\'inf\'), float(\'inf\')], [1, 0, 4, 2, 7, float(\'inf\')], [4, 4, 0, 3, 5, float(\'inf\')], [float(\'inf\'), 2, 3, 0, 4, 6], [float(\'inf\'), 7, 5, 4, 0, 7], [float(\'inf\'), float(\'inf\'), float(\'inf\'), 6, 7, 0] ] >>> dijkstra_shortest_path(graph, 0) [0, 1, 4, 3, 7, 9] pass ``` Guidelines 1. **Input Format**: The function will take a list of lists representing the adjacency matrix of the graph and an integer as the start node. 2. **Output Format**: The function should return a list where each element is the shortest distance from the start node to the respective node. 3. **Constraints**: - The adjacency matrix should be of shape (n, n), where n is the number of nodes. - The graph edges have non-negative weights. - The start node is a valid node index in the graph. Example Example input and expected functionality: ```python graph = [ [0, 1, 4, float(\'inf\'), float(\'inf\'), float(\'inf\')], [1, 0, 4, 2, 7, float(\'inf\')], [4, 4, 0, 3, 5, float(\'inf\')], [float(\'inf\'), 2, 3, 0, 4, 6], [float(\'inf\'), 7, 5, 4, 0, 7], [float(\'inf\'), float(\'inf\'), float(\'inf\'), 6, 7, 0] ] distances = dijkstra_shortest_path(graph, 0) assert distances == [0, 1, 4, 3, 7, 9] ``` The function should be able to handle graphs with various configurations, including cases with very large distances (represented by `float(\'inf\')` where no direct edge exists) and ensure the implementation is efficient for typical use cases of Dijkstra\'s algorithm.","solution":"import heapq def dijkstra_shortest_path(graph, start): Find the shortest paths from the start node to all other nodes using Dijkstra\'s algorithm. Args: - graph: A 2D list where graph[i][j] represents the weight of the edge from node i to node j. If there is no edge, the weight is considered as a large value (float(\'inf\') can be used). - start: The starting node for Dijkstra\'s algorithm. Returns: - distances: A list where distances[i] is the shortest path from the start node to node i. Raises: - ValueError: If the graph is not valid or if the start node is out of bounds. n = len(graph) # Validate graph if not all(len(row) == n for row in graph): raise ValueError(\\"Graph is not a valid adjacency matrix.\\") if not (0 <= start < n): raise ValueError(\\"Start node is out of bounds.\\") # Initialize distances array and priority queue distances = [float(\'inf\')] * n distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Skip if we already found a better way if current_distance > distances[current_node]: continue for neighbor in range(n): weight = graph[current_node][neighbor] if weight != float(\'inf\'): distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Question: Find the Missing Integer in an Array Context You are given an array of integers ranging from 0 to `n`, where `n` is the length of the array. Each number in the range appears exactly once in the array except for one number which is missing. Your task is to find and return the missing number. This problem is common in scenarios involving error detection in sequences and data integrity checks. Task Write a function `find_missing_number(arr: list) -> int` that takes a list `arr` of integers as input and returns the missing integer from the range 0 to `n`. Your function must provide an efficient solution using mathematical principles. Expected Input and Output * **Input**: A list of integers `arr` where `0 <= arr[i] <= n` and `len(arr) = n`. The list contains all integers in the range 0 to `n` except one. * **Output**: An integer representing the missing number. Constraints 1. The input list can be of any size from 0 to `10^4`. 2. The elements in the list are guaranteed to be unique. Examples ```python >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 >>> find_missing_number([0]) 1 >>> find_missing_number([]) 0 ``` Hints and Considerations * Use the formula for the sum of the first `n` natural numbers to derive the expected sum. * The difference between the expected sum and the actual sum of the list will give you the missing number. * Consider edge cases such as an empty list or the smallest possible list size (`n=1`). # Example Solution Below is an example of how you could implement this function: ```python def find_missing_number(arr: list) -> int: n = len(arr) expected_sum = n * (n + 1) / 2 actual_sum = sum(arr) return int(expected_sum - actual_sum) ``` # Edge Cases and Performance Expectations * Ensure your solution efficiently handles lists up to the maximum size of `10^4`. * Include comprehensive error checking and validation if necessary. Your implementation should be optimal in terms of both time and space complexity, ideally operating in O(n) time with O(1) extra space.","solution":"def find_missing_number(arr): Returns the missing number from the list arr which contains integers from 0 to n. n = len(arr) expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"# Red-Black Tree Operations You are required to implement a red-black tree in Python, which is a balanced binary search tree with specific properties that ensure logarithmic time complexity for insertions, deletions, and lookups. A red-black tree satisfies the following properties: 1. Each node is either red or black. 2. The root node is black. 3. All leaves (NIL nodes) are black. 4. If a red node has children, then the children are always black (no two red nodes can be adjacent). 5. Every path from a node to its descendants NIL nodes has the same number of black nodes. You have been provided with classes `Node` and `RedBlackTree`. Your task is to implement the following functionality for the RedBlackTree class: 1. **Insert**: Implement a method `insert(self, value)` that inserts a new node with the given value into the red-black tree, maintaining the red-black properties. 2. **Delete**: Implement a method `delete(self, value)` that deletes the node containing the given value from the red-black tree and ensures the tree maintains the red-black properties. 3. **Search**: Implement a method `search(self, value)` that searches for a node with the given value and returns the node. If the value is not found, return `None`. Your implementation must ensure all red-black tree properties are maintained after any insert and delete operations. Handle edge cases such as inserting into an empty tree or deleting the root. **Input Format**: - `insert(self, value)` - an integer. - `delete(self, value)` - an integer. - `search(self, value)` - an integer. **Output Format**: - `insert(self, value)` - `None`. - `delete(self, value)` - `None` (raise a ValueError if the value is not found). - `search(self, value)` - a Node object or `None`. **Constraints**: - All values in the tree are unique. **Example**: ```python # Define the Node class class Node: def __init__(self, data): self.data = data self.color = \'red\' self.left = None self.right = None self.parent = None # Define the RedBlackTree class with the insert, delete, and search methods class RedBlackTree: def __init__(self): self.TNULL = Node(0) self.TNULL.color = \'black\' self.root = self.TNULL def insert(self, value): # Implement insert functionality pass def delete(self, value): # Implement delete functionality pass def search(self, value): # Implement search functionality pass # Create a new Red-Black Tree rbt = RedBlackTree() # Insert elements rbt.insert(5) rbt.insert(3) rbt.insert(7) # Search for an element node = rbt.search(3) # Should return the node containing value 3 # Delete an element rbt.delete(7) ``` Write your solution and perform appropriate tests to ensure all methods work as expected.","solution":"class Node: def __init__(self, data): self.data = data self.color = \'red\' self.left = None self.right = None self.parent = None class RedBlackTree: def __init__(self): self.TNULL = Node(0) self.TNULL.color = \'black\' self.root = self.TNULL def insert(self, value): # Insert code follows the standard BST insert method initially new_node = Node(value) new_node.parent = None new_node.data = value new_node.left = self.TNULL new_node.right = self.TNULL new_node.color = \'red\' # New node must be red parent = None current = self.root while current != self.TNULL: parent = current if new_node.data < current.data: current = current.left else: current = current.right new_node.parent = parent if parent is None: self.root = new_node elif new_node.data < parent.data: parent.left = new_node else: parent.right = new_node if new_node.parent is None: new_node.color = \'black\' return if new_node.parent.parent is None: return self.fix_insert(new_node) def fix_insert(self, k): while k.parent.color == \'red\': if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == \'red\': u.color = \'black\' k.parent.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == \'red\': u.color = \'black\' k.parent.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = \'black\' def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def search(self, value): return self._search_tree_helper(self.root, value) def _search_tree_helper(self, node, key): if node == self.TNULL or key == node.data: if node == self.TNULL: return None return node if key < node.data: return self._search_tree_helper(node.left, key) return self._search_tree_helper(node.right, key) def delete(self, value): self.delete_node_helper(self.root, value) def delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.data == key: z = node if node.data <= key: node = node.right else: node = node.left if z == self.TNULL: raise ValueError(\\"Value not found in the tree\\") y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self.rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == \'black\': self.fix_delete(x) def rb_transplant(self, u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def fix_delete(self, x): while x != self.root and x.color == \'black\': if x == x.parent.left: s = x.parent.right if s.color == \'red\': s.color = \'black\' x.parent.color = \'red\' self.left_rotate(x.parent) s = x.parent.right if s.left.color == \'black\' and s.right.color == \'black\': s.color = \'red\' x = x.parent else: if s.right.color == \'black\': s.left.color = \'black\' s.color = \'red\' self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = \'black\' s.right.color = \'black\' self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == \'red\': s.color = \'black\' x.parent.color = \'red\' self.right_rotate(x.parent) s = x.parent.left if s.left.color == \'black\' and s.right.color == \'black\': s.color = \'red\' x = x.parent else: if s.left.color == \'black\': s.right.color = \'black\' s.color = \'red\' self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = \'black\' s.left.color = \'black\' self.right_rotate(x.parent) x = self.root x.color = \'black\' def minimum(self, node): while node.left != self.TNULL: node = node.left return node"},{"question":"Coding Assessment Question Scenario You are given a string that consists of a series of words separated by spaces. Sometimes, the words in the string may be repeated multiple times. Your goal is to identify the maximum number of identical, consecutive words in the string. Task Write a function `max_consecutive_repeats(s)` that takes a single string `s` as input and returns an integer representing the largest number of consecutive identical words. Input * `s`: A string of words separated by single spaces. Each word consists of only lowercase alphabetic characters (a-z) and will be non-empty. There will be no leading or trailing spaces, and each word will be separated by exactly one space. Output * An integer representing the maximum number of consecutive identical words. Constraints * The length of the string will be between 1 and 1000 words. * Each word will be 1 to 20 characters long. Example Input ```python s = \\"hello hello hello world world hello hello\\" ``` Example Output ```python 3 ``` This output corresponds to the maximum number of consecutive identical words (\\"hello\\" repeated 3 times). Additional Instructions Ensure your code accurately counts consecutive identical word sequences and returns the correct maximum count. Hint To verify the correctness of your solution, you will need to iterate through the words, compare each word with the next, and keep track of the maximum consecutive count. ```python def max_consecutive_repeats(s): words = s.split(\' \') max_count = 1 current_count = 1 for i in range(1, len(words)): if words[i] == words[i-1]: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 1 return max_count ```","solution":"def max_consecutive_repeats(s: str) -> int: Returns the maximum number of consecutive identical words in the string. Parameters: s (str): A string of words separated by single spaces. Returns: int: The maximum number of consecutive identical words. if not s: return 0 words = s.split(\' \') max_count = 1 current_count = 1 for i in range(1, len(words)): if words[i] == words[i-1]: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 1 return max_count"},{"question":"# Scenario A text processing application needs an efficient way to identify and extract unique words from a large text document. The application should ignore punctuation and be case-insensitive, treating \\"Word\\", \\"word\\", and \\"WORD\\" as identical. To showcase your skills in string manipulation and use of data structures, you are tasked with creating a function to handle this requirement. # Task Write a function `extract_unique_words` that reads a string of text, processes it, and returns a list of unique words in lowercase, sorted in alphabetical order. # Function Signature ```python from typing import List def extract_unique_words(text: str) -> List[str]: pass ``` # Input - `text` (str): A string containing the text document, which may include any characters. # Output - Returns a list of unique words in lowercase, sorted alphabetically. # Constraints - The input text may be empty. - The text length does not exceed 10^6 characters. # Performance Requirements - Efficiently handle large strings by using appropriate data structures. # Examples ```python print(extract_unique_words(\\"Hello, world! Hello again.\\")) # Output: [\'again\', \'hello\', \'world\'] print(extract_unique_words(\\"Python is great. PYTHON, python programming.\\")) # Output: [\'great\', \'is\', \'programming\', \'python\'] print(extract_unique_words(\\"\\")) # Output: [] ``` # Hint Use regular expressions to handle punctuation and conversion to lowercase. Utilize a set to store unique words before converting to a sorted list.","solution":"import re from typing import List def extract_unique_words(text: str) -> List[str]: Extracts unique words from a given text, ignoring punctuation and capitalization, and returns them sorted in alphabetical order. # Convert text to lowercase text = text.lower() # Use regex to find words, ignoring punctuation words = re.findall(r\'bw+b\', text) # Use a set to remove duplicates unique_words = set(words) # Return the unique words sorted alphabetically return sorted(unique_words)"},{"question":"# Minimum Jumps to Reach End You are working on a pathfinding algorithm module. Given an array of non-negative integers, where each element represents the maximum number of steps that can be jumped going forward from that element, your task is to find the minimum number of jumps required to reach the end of the array starting from the first element. If it is not possible to reach the end of the array, return -1. Function Signature ```python def min_jumps_to_end(arr: List[int]) -> int: pass ``` Input * A list `arr` of non-negative integers, where (1 leq text{len(arr)} leq 10^6) and (0 leq text{arr}[i] leq 10^3). Output * An integer representing the minimum number of jumps required to reach the end. Example ```python assert min_jumps_to_end([6, 2, 4, 0, 5, 1, 1, 2, 3, 1, 1, 1]) == 3 assert min_jumps_to_end([1, 1, 1, 1, 1]) == 4 assert min_jumps_to_end([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3 assert min_jumps_to_end([0, 1, 2, 3, 4]) == -1 ``` # Constraints * The solution should be optimized to handle the upper constraint efficiently. * Take care of edge cases, especially arrays where the end is unreachable. # Notes 1. Use a greedy algorithm or dynamic programming approach to solve the problem efficiently. 2. Consider scenarios where the next highest jump should be taken to minimize the total jumps. 3. Verify performances with varying lengths and step values within the input array.","solution":"from typing import List def min_jumps_to_end(arr: List[int]) -> int: Finds the minimum number of jumps required to reach the end of the array. if len(arr) <= 1: return 0 if arr[0] == 0: return -1 jumps = 0 max_reach = 0 steps = 0 for i in range(len(arr)): max_reach = max(max_reach, i + arr[i]) if i == steps: jumps += 1 steps = max_reach if steps >= len(arr) - 1: return jumps return -1 # if we never reach the end of the array"},{"question":"# Question You are required to create a password verification tool that aims to validate the strength of user-provided passwords. The tool should provide a comprehensive analysis of the password by checking several criteria and ensure it meets the defined standards for security. Function Specifications: 1. **check_length(password: str) -> bool** * Validates that the `password` length is greater or equal to the minimum length threshold. * Return `True` if the password length is valid, otherwise return `False`. 2. **check_character_types(password: str) -> bool** * Validates that the `password` contains at least: * One uppercase alphabetic character (A-Z) * One lowercase alphabetic character (a-z) * One numeric character (0-9) * One special character (e.g., !, @, #, etc.) * Return `True` if all character type requirements are met, otherwise return `False`. 3. **is_common_password(password: str) -> bool** * Checks the `password` against a list of commonly used passwords, which should be provided within the function. * Return `True` if the password is found in the list of common passwords, otherwise return `False`. 4. **verify_password(password: str) -> str** * Utilizes the aforementioned helper functions to verify the strength of the `password`. * Returns `Valid password` if all criteria are met. * Returns an appropriate error message if any validation check fails. Input/Output Requirements: * The tool should process strings consisting of letters, digits, and special characters. * Password validation should consider common security guidelines. * Length threshold and list of common passwords should be clearly defined within the respective functions. Constraints: * Password minimum length should be 8 characters. * Commonly used passwords should be checked against a pre-defined list. * Maintain O(n) time complexity for the verification where n is the length of the password. * Use only standard libraries; do not import additional packages. Example: ```python def test_password_verification(): passwords = [ (\\"Password123!\\", True), (\\"password\\", False), (\\"PASSWORD123\\", False), (\\"Passw0rd\\", False), (\\"12345678!\\", False), (\\"Password!\\", False) ] for password, expected in passwords: assert (verify_password(password) == \\"Valid password\\") == expected test_password_verification() ``` Additional Context: Assume a scenario where users are required to set strong passwords for their accounts in an online system. This tool will ensure the password complies with the guidelines by validating its length, composition, and uniqueness relative to common passwords. You are expected to implement these functions with attention to detailed validation checks and ensuring each aspect of password strength is thoroughly assessed.","solution":"def check_length(password: str) -> bool: Validates that the password length is greater or equal to 8 characters. return len(password) >= 8 def check_character_types(password: str) -> bool: Validates that the password contains at least: * One uppercase alphabetic character (A-Z) * One lowercase alphabetic character (a-z) * One numeric character (0-9) * One special character (e.g., !, @, #, etc.) has_upper = False has_lower = False has_digit = False has_special = False for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in \\"!@#%^&*()-_=+[{]}|;:\'\\",<.>/?`~\\": has_special = True return has_upper and has_lower and has_digit and has_special def is_common_password(password: str) -> bool: Checks password against a list of commonly used passwords. common_passwords = [ \\"123456\\", \\"password\\", \\"123456789\\", \\"12345678\\", \\"12345\\", \\"1234567\\", \\"1234567890\\", \\"password1\\", \\"123123\\", \\"admin\\" ] return password in common_passwords def verify_password(password: str) -> str: Verifies the password strength using the helper functions. Returns \\"Valid password\\" if all criteria are met, Otherwise returns an appropriate error message. if not check_length(password): return \\"Password must be at least 8 characters long.\\" if not check_character_types(password): return (\\"Password must contain at least one uppercase letter, \\" \\"one lowercase letter, one digit, and one special character.\\") if is_common_password(password): return \\"Password is too common.\\" return \\"Valid password\\""},{"question":"# Coding Assessment Question Context A family of binary strings is defined by two specific properties. Each string in this family must be exactly of length `n` and must not contain a consecutive sequence of \'1\'s of length 2 or more. You are tasked with counting how many unique strings of such a family exist for a given length `n`. Problem Statement Write a function `count_valid_binary_strings(n: int) -> int` that computes the number of valid binary strings of length `n` where: - Each string is composed only of \'0\'s and \'1\'s. - No two consecutive \'1\'s exist in the string. # Input: - An integer `n` representing the length of the binary string (1 ≤ n ≤ 50). # Output: - Return an integer representing the number of different valid binary strings of length `n`. # Example: ```python count_valid_binary_strings(3) # Expected output: 5 ``` # Explanation: The valid binary strings of length 3 are: - \\"000\\" - \\"001\\" - \\"010\\" - \\"100\\" - \\"101\\" # Constraints: - Solve the problem using dynamic programming. - Make sure your solution is efficient and handles the given constraints within acceptable limits.","solution":"def count_valid_binary_strings(n: int) -> int: Returns the number of valid binary strings of length n. if n == 1: return 2 # \\"0\\" and \\"1\\" # DP array where dp[i] represents the number of valid strings of length i dp = [0] * (n + 1) # Initial conditions dp[1] = 2 # \\"0\\", \\"1\\" dp[2] = 3 # \\"00\\", \\"01\\", \\"10\\" for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"# Scenario You are developing an e-commerce platform, and one of the features is to calculate the total price of items in a shopping cart, considering potential discounts. Users can apply discount coupons, which may either take a fixed amount off the cart total or reduce the total price by a percentage. Your task is to implement a function to compute the total price after applying the discount and write relevant unit tests to verify the calculations. # Task 1. Implement a function `calculate_total` that takes a list of item prices and an optional discount dictionary as arguments and returns the final total price. 2. Write unit tests for your function to ensure it handles all possible scenarios. # Requirements **Function Signature**: ```python from typing import List, Optional, Dict def calculate_total(prices: List[float], discount: Optional[Dict[str, float]] = None) -> float: # Your implementation here ``` # Example ```python # Example usage calculate_total([50.0, 20.0, 30.0], {\\"amount\\": 10.0}) # Expected output: 90.0 calculate_total([100.0, 200.0], {\\"percentage\\": 10.0}) # Expected output: 270.0 calculate_total([40.0, 60.0]) # Expected output: 100.0 ``` # Constraints - If the `discount` dictionary is provided, it will only have one key, either `\\"amount\\"` or `\\"percentage\\"`. - The `\\"amount\\"` key directly subtracts a fixed value from the total price. - The `\\"percentage\\"` key applies a percentage reduction to the total price. - The total price should not be less than zero. - Prices are always positive numbers. # Testing - Write unit tests to cover scenarios with and without discounts. - Test with both `\\"amount\\"` and `\\"percentage\\"` discounts. - Ensure to handle edge cases such as empty price lists and discounts larger than the total price gracefully. # Additional Information - Use assertion statements to validate that the function returns the expected results. - Make sure to test the function for both valid and invalid inputs.","solution":"from typing import List, Optional, Dict def calculate_total(prices: List[float], discount: Optional[Dict[str, float]] = None) -> float: Calculate the total price after applying an optional discount. :param prices: List of item prices. :param discount: Optional dict with a single key, either \'amount\' or \'percentage\'. \'amount\' will subtract a fixed value from the total. \'percentage\' will reduce the total by a given percentage. :return: Total price after discount. total = sum(prices) if discount: if \\"amount\\" in discount: total -= discount[\\"amount\\"] elif \\"percentage\\" in discount: total -= (total * discount[\\"percentage\\"] / 100) return max(total, 0) # Ensure the total price is not negative"},{"question":"# Context You are provided with a task to write a function that transforms a given sentence into its Pig Latin equivalent. Pig Latin is a playful form of English where each word in a sentence is altered as follows: - For words that begin with a consonant, move the first letter of the word to the end and add \\"ay\\". For example, \\"hello\\" becomes \\"ellohay\\". - For words that begin with a vowel, add \\"hay\\" to the end without changing the word itself. For example, \\"apple\\" becomes \\"applehay\\". Consider: - Words are separated by a single space. - The input sentence will consist of lowercase alphabetical words and spaces only. # Task Implement a function `convert_to_pig_latin` that takes a sentence and transforms it into the Pig Latin format as described above. # Requirements * **Input**: * `sentence` (string): A sentence consisting of lowercase words separated by a single space. * **Output**: * A string representing the transformed Pig Latin sentence. * **Constraints**: * The input sentence will contain no punctuation. * Words will consist of lowercase alphabetical characters only and will be separated by a single space. # Example ```python def convert_to_pig_latin(sentence: str) -> str: Convert a sentence into Pig Latin format. Parameters: sentence : str: The sentence to be converted. Returns: str: The Pig Latin converted sentence. Example: >>> convert_to_pig_latin(\\"hello world\\") \'ellohay orldway\' >>> convert_to_pig_latin(\\"apple banana orange\\") \'applehay ananabay orangehay\' >>> convert_to_pig_latin(\\"igloo umbrella under oak\\") \'igloohay umbrellahay underhay oakhay\' # Your implementation here pass # Test cases print(convert_to_pig_latin(\\"hello world\\")) # Output: \'ellohay orldway\' print(convert_to_pig_latin(\\"apple banana orange\\")) # Output: \'applehay ananabay orangehay\' print(convert_to_pig_latin(\\"igloo umbrella under oak\\")) # Output: \'igloohay umbrellahay underhay oakhay\' ```","solution":"def convert_to_pig_latin(sentence: str) -> str: Convert a sentence into Pig Latin format. Parameters: sentence : str: The sentence to be converted. Returns: str: The Pig Latin converted sentence. def pig_latin_word(word): vowels = \'aeiou\' if word[0] in vowels: return word + \\"hay\\" else: return word[1:] + word[0] + \\"ay\\" words = sentence.split() pig_latin_words = [pig_latin_word(word) for word in words] return \' \'.join(pig_latin_words)"},{"question":"# Context: Suppose you are working on a project for a financial trading platform. One of the required features is to calculate the moving average of stock prices to help traders make decisions based on historical data. The platform currently supports simple operations but lacks an efficient way to calculate moving averages. # Task: Extend the `StockPrices` class to support calculation of the moving average over a specified window size. Ensure this method works effectively even with large datasets. # Requirements: 1. **Function Implementation:** - Add a method `moving_average` to the `StockPrices` class which takes an integer `window_size` and returns a list of the moving averages. - Utilize an efficient approach to handle large lists of stock prices. 2. **Edge Case Handling:** - Handle edge cases where the `window_size` is greater than the number of stock prices available. - Ensure the method handles empty lists gracefully. 3. **Testing:** - Demonstrate the correctness and efficiency of your implementation with several test cases, including edge cases. **Input and Output formats:** - **Input:** A list of stock prices and a window size. - **Output:** A list of moving averages. **Constraints:** - Assume the `StockPrices` class and any necessary import statements are already defined. - The method should be efficient enough to handle lists with up to 100,000 elements in a reasonable time frame. # Example: ```python prices = StockPrices([1, 2, 3, 4, 5, 6, 7, 8, 9]) window_size = 3 result = prices.moving_average(window_size) # Expected result: [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0] assert result == [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0] ``` **Note:** Ensure that your moving average method does not use any external libraries for the sake of simplicity and self-containment.","solution":"class StockPrices: def __init__(self, prices): self.prices = prices def moving_average(self, window_size): Calculates the moving average over a specified window size. Args: window_size (int): The size of the window to calculate the moving average over. Returns: List[float]: A list containing the moving averages. n = len(self.prices) if window_size <= 0 or not self.prices or window_size > n: return [] result = [] current_sum = sum(self.prices[:window_size]) result.append(current_sum / window_size) for i in range(window_size, n): current_sum += self.prices[i] - self.prices[i - window_size] result.append(current_sum / window_size) return result"},{"question":"# Merge k Sorted Lists You need to write a function that merges `k` sorted linked lists and returns it as one sorted linked list. Analyze the given linked list structure and implement the function to solve the problem efficiently. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: list[ListNode]) -> ListNode: ``` Inputs: - `lists` (list[ListNode]): A list of `k` linked lists, each of which is sorted in ascending order. Outputs: - `ListNode`: The head of the merged linked list which is sorted in ascending order. Constraints: 1. The total number of nodes across all `k` linked lists is within the range `[0, 10^5]`. 2. The value of each node is within the range `[-10^4, 10^4]`. Example: ```python # Example of creating linked lists for the input ln1 = ListNode(1, ListNode(4, ListNode(5))) ln2 = ListNode(1, ListNode(3, ListNode(4))) ln3 = ListNode(2, ListNode(6)) list_of_lists = [ln1, ln2, ln3] merged_head = merge_k_lists(list_of_lists) # Function to print the list def print_list(node): while node: print(node.val, end=\\" -> \\") node = node.next print(\\"None\\") print_list(merged_head) # Output should list 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 -> None ``` Requirements: - Implement the function so that it efficiently handles merging `k` sorted linked lists using appropriate data structures such as heaps or divide and conquer approaches. - Ensure the performance is optimized to handle the upper constraint effectively without causing excessive runtime. The merged linked list should maintain the order and integrity of the elements from the original `k` sorted lists.","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists): if not lists: return None def merge(l1, l2): dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next def merge_k_lists_recursively(lists, left, right): if left == right: return lists[left] mid = (left + right) // 2 l1 = merge_k_lists_recursively(lists, left, mid) l2 = merge_k_lists_recursively(lists, mid + 1, right) return merge(l1, l2) return merge_k_lists_recursively(lists, 0, len(lists) - 1)"},{"question":"# Problem Statement As part of a network security team, you need to build a firewall system that can detect intrusions by monitoring network traffic. One of the ways to detect intrusions is by identifying if a suspicious pattern of data packets appear in the network traffic. You are provided with a sequence of data packets and a list of suspicious patterns. Your task is to implement a function that determines if any of these patterns appear as a contiguous subsequence in the data packets. # Function Signature ```python def detect_intrusion(data_packets: List[int], patterns: List[List[int]]) -> bool: :param data_packets: A list of integers representing the sequence of data packets. :param patterns: A list of lists, where each inner list contains a sequence of integers representing a suspicious pattern. :return: A boolean value indicating whether any of the patterns appear as a contiguous subsequence in the data packets. Example: >>> data_packets = [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> patterns = [[4, 5, 6], [7, 8]] >>> detect_intrusion(data_packets, patterns) True >>> data_packets = [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> patterns = [[10, 11, 12], [13, 14]] >>> detect_intrusion(data_packets, patterns) False ``` # Input * `data_packets`: A list of integers (1 ≤ length of data_packets ≤ 10^5). Represents the sequence of data packets. * `patterns`: A list of lists, where each inner list contains a sequence of suspicious pattern integers (1 ≤ length of each pattern ≤ 100). # Output * A boolean value indicating whether any of the patterns appear as a contiguous subsequence in the data_packets. # Constraints * The patterns need to be detected in the exact order they appear in the inner lists. * The function should be efficient with respect to both time and space constraints. # Example Given `data_packets = [1, 2, 3, 4, 5, 6, 7, 8, 9]` and `patterns = [[4, 5, 6], [7, 8]]`, the function should return `True` since both patterns `[4, 5, 6]` and `[7, 8]` appear as contiguous subsequences in the data_packets. Given `data_packets = [1, 2, 3, 4, 5, 6, 7, 8, 9]` and `patterns = [[10, 11, 12], [13, 14]]`, the function should return `False` since neither of the patterns `[10, 11, 12]` nor `[13, 14]` appear as contiguous subsequences in the data_packets. # Detailed Description 1. Iterate through each pattern in the patterns list. 2. For each pattern, check if it is a contiguous subsequence of the data_packets. 3. If any pattern is found within the data_packets, return `True`. 4. If no pattern is found after checking all patterns, return `False`.","solution":"from typing import List def detect_intrusion(data_packets: List[int], patterns: List[List[int]]) -> bool: :param data_packets: A list of integers representing the sequence of data packets. :param patterns: A list of lists, where each inner list contains a sequence of integers representing a suspicious pattern. :return: A boolean value indicating whether any of the patterns appear as a contiguous subsequence in the data packets. def is_subsequence(data, pattern): n, m = len(data), len(pattern) for i in range(n - m + 1): if data[i:i + m] == pattern: return True return False for pattern in patterns: if is_subsequence(data_packets, pattern): return True return False"},{"question":"# Problem: Implement Simple Cache for Fibonacci Calculation Background The Fibonacci sequence is a series where each number is the sum of the two preceding ones, starting from 0 and 1. The classic approach to calculating Fibonacci numbers recursively is inefficient due to repeated calculations of the same values. Implementing a simple cache mechanism can optimize this process by storing previously calculated results. Objective You will create a class-based implementation of a Fibonacci sequence calculator that utilizes caching to improve performance. The cache should store Fibonacci numbers as they are computed and reuse them in future calculations. Requirements 1. **Create `Fibonacci` Class**: - Implement a method `fib` to calculate the n-th Fibonacci number. - Use a caching mechanism to store and retrieve previously calculated Fibonacci numbers. 2. **Utilize Efficient Caching**: - Ensure that the cache is properly utilized to avoid redundant calculations. - Aim for an optimal time complexity close to O(n). Function Signature ```python class Fibonacci: def __init__(self): # constructor def fib(self, n: int) -> int: # Your implementation ``` Constraints - The input `n` will always be a non-negative integer within the range [0, 1000]. - Your solution should be efficient enough to handle the upper constraint in a reasonable time. Example ```python >>> fib_calculator = Fibonacci() >>> fib_calculator.fib(10) 55 >>> fib_calculator.fib(5) 5 ``` **Note**: For reference: - `fib(0)` should return `0` - `fib(1)` should return `1` - `fib(10)` should return `55` **Hints**: 1. Consider using a dictionary to store the Fibonacci numbers as they are calculated. 2. Remember to handle the base cases (`fib(0)` and `fib(1)`) directly. # Explanation This problem ensures you can manage dynamic programming concepts and efficient resource management using caching techniques. Implementing such solutions can significantly optimize operations that involve repetitive calculations.","solution":"class Fibonacci: def __init__(self): self.cache = {} def fib(self, n: int) -> int: if n == 0: return 0 elif n == 1: return 1 if n in self.cache: return self.cache[n] self.cache[n] = self.fib(n - 1) + self.fib(n - 2) return self.cache[n]"},{"question":"# Maze Path Finding with Breadth-First Search (BFS) Background You\'re developing a robotics pathfinding system that navigates a robot through a maze. The robot needs to find the shortest path from its starting position to the target position within the maze. The maze is represented as a grid where some cells are blocked and others are open. The robot can only move up, down, left, or right through the open cells. Task Implement the `shortest_path` function to determine the shortest path from the starting position to the target position in a maze using the Breadth-First Search (BFS) algorithm. Requirements - Implement the `shortest_path` function that takes a grid (2D list), start position, and target position as input and returns the length of the shortest path. - Use the BFS algorithm to explore the maze and find the shortest path. - Handle edge cases where the start or target positions are blocked or outside the maze boundaries. Input - `maze`: A 2D list of integers where `0` represents an open cell and `1` represents a blocked cell. - `start`: A tuple `(row, col)` representing the starting position in the maze. - `target`: A tuple `(row, col)` representing the target position in the maze. Output - An integer representing the length of the shortest path from the start to the target position. If no path exists, return `-1`. Example Usage ```python def shortest_path(maze, start, target): from collections import deque rows, cols = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if maze[start[0]][start[1]] == 1 or maze[target[0]][target[1]] == 1: return -1 queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: row, col, distance = queue.popleft() if (row, col) == target: return distance for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and maze[new_row][new_col] == 0: queue.append((new_row, new_col, distance + 1)) visited.add((new_row, new_col)) return -1 # Example: Finding the shortest path in a maze maze = [ [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0] ] start = (0, 0) target = (3, 3) print(shortest_path(maze, start, target)) # Output: 6 (if a path exists) ``` Constraints - Ensure the function handles mazes with various sizes efficiently. - Consider edge cases such as start equals target, the target being completely enclosed by blocked cells, and the maze being fully open or fully blocked. Good luck!","solution":"def shortest_path(maze, start, target): from collections import deque rows, cols = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if maze[start[0]][start[1]] == 1 or maze[target[0]][target[1]] == 1: return -1 if start == target: return 0 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: row, col, distance = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and maze[new_row][new_col] == 0: if (new_row, new_col) == target: return distance + 1 queue.append((new_row, new_col, distance + 1)) visited.add((new_row, new_col)) return -1"},{"question":"# Context You are developing a web application that allows users to manage their tasks. As part of this application, you need to implement a feature that identifies all overdue tasks based on the current date. # Task Write a function in Python that takes a list of tasks and the current date, and returns a list of overdue tasks. Each task is represented as a dictionary with keys \\"task_id\\", \\"due_date\\", and \\"task_name\\". # Requirements - Function Name: `get_overdue_tasks` - **Input**: - A list of tasks, where each task is represented by a dictionary containing: - \\"task_id\\": a unique identifier for the task (integer) - \\"due_date\\": the due date of the task (string in \\"YYYY-MM-DD\\" format) - \\"task_name\\": the name of the task (string) - The current date (string in \\"YYYY-MM-DD\\" format) - **Output**: A list of overdue tasks, sorted by due date in ascending order. Each overdue task should be a dictionary with \\"task_id\\" and \\"task_name\\" keys. - **Constraints**: - The maximum number of tasks will be 10^4. - Each date string will be a valid date within the supported range of Python\'s `datetime` module. # Example ```python # Example usage tasks = [ {\\"task_id\\": 1, \\"due_date\\": \\"2023-01-01\\", \\"task_name\\": \\"Task 1\\"}, {\\"task_id\\": 2, \\"due_date\\": \\"2023-05-01\\", \\"task_name\\": \\"Task 2\\"}, {\\"task_id\\": 3, \\"due_date\\": \\"2023-03-15\\", \\"task_name\\": \\"Task 3\\"}, ] current_date = \\"2023-04-01\\" overdue_tasks = get_overdue_tasks(tasks, current_date) print(overdue_tasks) # Output should be: # [ # {\\"task_id\\": 1, \\"task_name\\": \\"Task 1\\"}, # {\\"task_id\\": 3, \\"task_name\\": \\"Task 3\\"} # ] ``` # Notes: - The function should correctly handle edge cases such as an empty list of tasks. - Assume that the \\"due_date\\" for each task will always be in the \\"YYYY-MM-DD\\" format. - It\'s important to sort the overdue tasks by their due date in ascending order for proper listing. **Implement the Function Below:** ```python from datetime import datetime def get_overdue_tasks(tasks, current_date): # your code here ```","solution":"from datetime import datetime def get_overdue_tasks(tasks, current_date): Returns a list of overdue tasks sorted by due date in ascending order. Parameters: tasks (list): A list of task dictionaries. Each dictionary contains \\"task_id\\", \\"due_date\\", and \\"task_name\\". current_date (string): The current date in \\"YYYY-MM-DD\\" format. Returns: list: A list of dictionaries, each containing \\"task_id\\" and \\"task_name\\" for overdue tasks. # Convert current_date to a datetime object current_date = datetime.strptime(current_date, \\"%Y-%m-%d\\") # Filter out the overdue tasks overdue_tasks = [ {\\"task_id\\": task[\\"task_id\\"], \\"task_name\\": task[\\"task_name\\"]} for task in tasks if datetime.strptime(task[\\"due_date\\"], \\"%Y-%m-%d\\") < current_date ] # Sort overdue tasks by due_date overdue_tasks.sort(key=lambda task: datetime.strptime( next(t for t in tasks if t[\\"task_id\\"] == task[\\"task_id\\"])[\\"due_date\\"], \\"%Y-%m-%d\\" )) return overdue_tasks"},{"question":"# Array Rotation Problem Context You\'re given an array of integers and a number `k`. You need to rotate the array `k` times to the right. Rotating the array to the right means that each element of the array will be shifted to its right `k` times, and any elements that are shifted past the last position will appear from the beginning. Your Task Write a function that rotates an array to the right `k` times and returns the rotated array. Function Signature ```python def rotate_array(nums: list, k: int) -> list: # your code here ``` Input - `nums` (list): A list containing integers. - `k` (int): The number of times to rotate the array. Output - Returns a list of integers, which is the list `nums` rotated to the right `k` times. Constraints - The length of the list (`n`) is in the range [1, 1000]. - The integers in the array are in the range `[-10^5, 10^5]`. - `k` is a non-negative integer. Example ```python nums = [1, 2, 3, 4, 5, 6, 7] k = 3 output = [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] nums = [-1, -100, 3, 99] k = 2 output = [3, 99, -1, -100] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100] ``` Edge Cases to Consider - When `k` is greater than the length of the array. - When `k` is 0, the array should remain unchanged. - When all elements in the array are the same. - When the array has only one element.","solution":"def rotate_array(nums: list, k: int) -> list: Rotates an array \'nums\' to the right \'k\' times. n = len(nums) k = k % n # In case k is larger than the length of the array return nums[-k:] + nums[:-k]"},{"question":"# Robot Path Planning: You are given a robot on a grid that can move up, down, left, or right per command. However, some cells in the grid are dangerous, and stepping on such cells would lose the robot. Write a function `robot_path(n: int, m: int, commands: List[str], dangers: List[Tuple[int, int]]) -> Tuple[bool, Tuple[int, int]]` to determine if the robot can safely complete the sequence of commands. **Function Definition:** ```python def robot_path(n: int, m: int, commands: List[str], dangers: List[Tuple[int, int]]) -> Tuple[bool, Tuple[int, int]]: # Your code here ``` **Input:** - `n` (int): Number of rows in the grid. - `m` (int): Number of columns in the grid. - `commands` (List[str]): A list of single-character strings, where each string is one of \'U\', \'D\', \'L\', \'R\'. - `dangers` (List[Tuple[int, int]]): A list of tuples representing the dangerous cells on the grid. **Output:** - Returns a tuple: - The first element is a boolean indicating if the robot can safely complete the commands. - The second element is a tuple indicating the final position of the robot if it completes the commands safely or the position where it first encounters a danger. **Constraints:** - The robot starts from the (0, 0) position. - `1 <= n, m <= 50`. - `1 <= len(commands) <= 1000`. - Each command in `commands` is one of \'U\', \'D\', \'L\', \'R\'. - Dangerous cell coordinates (i.e., elements of `dangers`) are within the grid bounds `0 <= x < n` and `0 <= y < m`. **Example:** ```python commands = [\'R\', \'R\', \'D\', \'L\', \'U\'] dangers = [(0, 2), (1, 1)] print(robot_path(3, 3, commands, dangers)) # Output: # (False, (1, 1)) ``` **Explanation:** - The robot starts at (0, 0). - It follows the commands: Right to (0, 1), Right to (0, 2), and Down to (1, 2). - Upon moving Left to (1, 1), the robot steps onto a dangerous cell, making it lose. Therefore, the function returns (False, (1, 1)).","solution":"def robot_path(n, m, commands, dangers): Determines if the robot can safely complete a sequence of commands in a grid. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param commands: List of single-character strings representing the robot\'s movements. :param dangers: List of tuples representing the dangerous cells on the grid. :return: A tuple: (can_complete_safely, final_position). # Starting position current_position = [0, 0] # Convert dangers list to a set for O(1) lookups danger_set = set(dangers) # Define movements for each command movements = { \'U\': (-1, 0), \'D\': (1, 0), \'L\': (0, -1), \'R\': (0, 1) } # Traverse the commands for command in commands: if command in movements: current_position[0] += movements[command][0] current_position[1] += movements[command][1] # Check if the new position is outside the grid if not (0 <= current_position[0] < n and 0 <= current_position[1] < m): return (False, tuple(current_position)) # Check if the new position is in the danger set if tuple(current_position) in danger_set: return (False, tuple(current_position)) return (True, tuple(current_position))"},{"question":"# Coding Assessment Question **Objective**: Write a function to compute the shortest distance between two words in a list. Given a list of words and two words, determine the shortest distance (number of words) between these two words in the list. # Problem Statement You are given a list of words and two words (`word1` and `word2`). Write a function `word_distance` that calculates the shortest distance between these two words in the list. It is guaranteed that both words exist in the list and they are not the same. # Requirements: - If the list is empty or the words are not found, raise a `ValueError` indicating invalid input. - Return the shortest distance as an integer. # Function Signature ```python def word_distance(words: List[str], word1: str, word2: str) -> int: ``` # Input Format: - `words` (List[str]): A list of strings representing words. - `word1` (str): The first word. - `word2` (str): The second word. # Output Format: - `int`: The shortest distance (number of words) between `word1` and `word2`. # Constraints: - The list of words will have at least one occurrence of `word1` and `word2`. - The words in the list are case-sensitive. # Example ```python # Example Input words = [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"hello\\", \\"world\\"] word1 = \\"hello\\" word2 = \\"world\\" # Function Call print(word_distance(words, word1, word2)) # Expected Output 1 ``` # Additional Examples ```python >>> word_distance([\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"makes\\"], \\"coding\\", \\"practice\\") 3 >>> word_distance([\\"a\\", \\"b\\", \\"a\\", \\"b\\", \\"a\\"], \\"a\\", \\"b\\") 1 >>> word_distance([\\"quick\\", \\"brown\\", \\"fox\\", \\"quick\\"], \\"quick\\", \\"fox\\") 1 >>> word_distance([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"apple\\", \\"grape\\") Traceback (most recent call last): ... ValueError: Invalid input: words must contain both word1 and word2 ``` # Notes: - Edge cases should be handled, such as adjacent words and words separated by multiple other words. - Ensure the function efficiently traverses the list while looking for the shortest distance.","solution":"def word_distance(words, word1, word2): Computes the shortest distance between two words in a list. if not words or word1 not in words or word2 not in words: raise ValueError(\\"Invalid input: words must contain both word1 and word2\\") min_distance = float(\'inf\') index1, index2 = -1, -1 for i, word in enumerate(words): if word == word1: index1 = i if index2 != -1: min_distance = min(min_distance, abs(index1 - index2)) elif word == word2: index2 = i if index1 != -1: min_distance = min(min_distance, abs(index2 - index1)) return min_distance"},{"question":"# Problem: Graph Path Finder **Scenario**: You are developing a simple navigation system for a small town. The town\'s layout can be represented as an undirected graph where intersections are nodes and roads are edges. To assist with navigation, you need to determine the shortest path between two given intersections. # Function to Implement: Implement the `shortest_path` function to find the shortest path in an undirected, unweighted graph using the Breadth-First Search (BFS) algorithm. # Input and Output: 1. **shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]**: * **Input**: A dictionary `graph` where keys are node (intersection) identifiers and values are lists of all directly connected nodes (other intersections). Two integers, `start` and `end`, representing the starting and ending intersections respectively. * **Output**: Returns a list of node identifiers that represents the shortest path from the `start` node to the `end` node. If no path exists, return an empty list. # Constraints: * Assume the graph is connected and undirected. * The graph does not contain self-loops or multiple edges. * Both `start` and `end` intersections are valid nodes in the graph. * The graph can have up to 1000 nodes. ```python from collections import deque def shortest_path(graph: dict, start: int, end: int) -> list: Finds the shortest path from the start node to the end node in the graph using BFS. Args: * graph (dict): A dictionary representing the graph where the keys are node identifiers and values are lists of neighbor node identifiers. * start (int): The starting node identifier. * end (int): The ending node identifier. Returns: * list: A list of node identifiers that represents the shortest path from `start` to `end`. If no path exists, return an empty list. if start == end: return [start] queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: current, path = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: if neighbor == end: return path + [neighbor] visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return [] # Example: graph = { 1: [2, 3], 2: [1, 4], 3: [1, 4, 5], 4: [2, 3, 5], 5: [3, 4] } print(shortest_path(graph, 1, 5)) # Output: [1, 3, 5] or [1, 2, 4, 5] print(shortest_path(graph, 2, 3)) # Output: [2, 1, 3] or [2, 4, 3] print(shortest_path(graph, 5, 1)) # Output: [5, 3, 1] print(shortest_path(graph, 4, 6)) # Output: [] (since node 6 does not exist) ```","solution":"from collections import deque def shortest_path(graph: dict, start: int, end: int) -> list: Finds the shortest path from the start node to the end node in the graph using BFS. Args: * graph (dict): A dictionary representing the graph where the keys are node identifiers and values are lists of neighbor node identifiers. * start (int): The starting node identifier. * end (int): The ending node identifier. Returns: * list: A list of node identifiers that represents the shortest path from `start` to `end`. If no path exists, return an empty list. if start == end: return [start] queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: current, path = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: if neighbor == end: return path + [neighbor] visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Sum of Squares of Even Numbers Context In various programming scenarios, handling lists of numbers and performing mathematical operations on them are common tasks. This question tests your ability to work with lists and apply conditional logic and arithmetic operations to solve a given problem. Task Write a Python function `sum_of_squares_of_even(numbers: list) -> int` that takes a list of integers and returns the sum of squares of all even numbers in the list. If the list is empty or contains no even numbers, the function should return 0. Specifications - **Input**: A list of integers `numbers`. - **Output**: The sum of squares of the even integers in the list. - **Constraints**: - The input list can be empty. - The elements of the list can be both positive and negative integers. Error Handling - Raise a `TypeError` with the message \\"Input should be a list of integers\\" if the input is not a list. - Raise a `TypeError` with the message \\"List elements should be integers\\" if any element of the list is not an integer. Examples ```python >>> sum_of_squares_of_even([2, 3, 4, -6]) 56 >>> sum_of_squares_of_even([1, 3, 5]) 0 >>> sum_of_squares_of_even([]) 0 >>> sum_of_squares_of_even([\\"2\\", 3, 4]) Traceback (most recent call last): ... TypeError: List elements should be integers >>> sum_of_squares_of_even(\\"2, 3, 4\\") Traceback (most recent call last): ... TypeError: Input should be a list of integers ``` Notes - Your solution should be efficient and concise. - Make sure to test your function with various cases, including edge cases such as lists with no even numbers or containing non-integer elements.","solution":"def sum_of_squares_of_even(numbers): Returns the sum of squares of all even numbers in the list. Raises a TypeError if the input is not a list or if the list contains non-integer elements. if not isinstance(numbers, list): raise TypeError(\\"Input should be a list of integers\\") for num in numbers: if not isinstance(num, int): raise TypeError(\\"List elements should be integers\\") return sum(num**2 for num in numbers if num % 2 == 0)"},{"question":"# Question Implement a priority queue structure using a binary heap. This structure should support both min-heap and max-heap configurations through a parameter in the constructor. You need to override the necessary methods to ensure that elements are ordered according to their priority. Specific Requirements: 1. **Class Name**: ConfigurableHeapQueue 2. **Initialization Parameter**: `mode` that takes either \\"min\\" or \\"max\\". 3. **Methods to Implement**: * `__init__(self, mode: str)`: Initialize the heap with the mode. * `__len__(self)`: Return the current number of elements in the heap. * `insert(self, item: Any, priority: int) -> None`: Insert an item with the given priority. * `extract(self) -> Any`: Remove and return the item with the highest priority (for max-heap) or lowest priority (for min-heap). * `peek(self) -> Any`: Return the item with the highest or lowest priority without removing it. * `is_empty(self) -> bool`: Return True if the heap is empty, False otherwise. Constraints: * Your structure should handle attempts to extract from an empty heap by raising an `IndexError`. Performance Requirements: * **Time Complexity**: * Insertion and extraction operations must be O(log n). * Accessing the minimum or maximum priority element must be O(1). # Example Usage: ```python min_heap = ConfigurableHeapQueue(mode=\\"min\\") print(min_heap.is_empty()) # True min_heap.insert(\'a\', 3) min_heap.insert(\'b\', 1) min_heap.insert(\'c\', 2) print(len(min_heap)) # 3 print(min_heap.peek()) # \'b\' print(min_heap.extract()) # \'b\' print(len(min_heap)) # 2 min_heap.insert(\'d\', 0) print(min_heap.peek()) # \'d\' max_heap = ConfigurableHeapQueue(mode=\\"max\\") print(max_heap.is_empty()) # True max_heap.insert(\'x\', 3) max_heap.insert(\'y\', 5) max_heap.insert(\'z\', 4) print(len(max_heap)) # 3 print(max_heap.peek()) # \'y\' print(max_heap.extract()) # \'y\' print(len(max_heap)) # 2 max_heap.insert(\'w\', 6) print(max_heap.peek()) # \'w\' ``` Your implementation should demonstrate the above behavior and performance requirements.","solution":"import heapq class ConfigurableHeapQueue: def __init__(self, mode: str): if mode not in (\\"min\\", \\"max\\"): raise ValueError(\\"mode should be either \'min\' or \'max\'\\") self.mode = mode self.heap = [] def __len__(self): return len(self.heap) def insert(self, item, priority: int): if self.mode == \\"min\\": heapq.heappush(self.heap, (priority, item)) else: # max heap heapq.heappush(self.heap, (-priority, item)) def extract(self): if len(self.heap) == 0: raise IndexError(\\"extract from empty heap\\") priority, item = heapq.heappop(self.heap) if self.mode == \\"max\\": priority = -priority return item def peek(self): if len(self.heap) == 0: raise IndexError(\\"peek from empty heap\\") priority, item = self.heap[0] if self.mode == \\"max\\": priority = -priority return item def is_empty(self): return len(self.heap) == 0"},{"question":"# Advanced Sorting Algorithms Implementation and Application Objective Develop and implement the Merge Sort and Quick Sort algorithms to sort arrays, and write a function that selects the appropriate sorting algorithm based on the input array size. # Task Description 1. **Function Implementations**: - Implement a function to perform **Merge Sort**: - `merge_sort(arr: List[int]) -> List[int]`: Sorts the input array using the Merge Sort algorithm and returns the sorted array. - Implement a function to perform **Quick Sort**: - `quick_sort(arr: List[int]) -> List[int]`: Sorts the input array using the Quick Sort algorithm and returns the sorted array. 2. **Selection Function**: - Implement a function to select the appropriate sorting algorithm based on the size of the input array: - If the array size is less than or equal to `500`, use Quick Sort. - If the array size is greater than `500`, use Merge Sort. - `sort_array(arr: List[int]) -> List[int]`: Sorts the input array using the selected algorithm based on the size criteria and returns the sorted array. # Constraints - Input arrays can have up to `10^5` elements. - Elements of the array can have values in the range of `-10^6` to `10^6`. # Input Format - The input will be a single list of integers: ``` arr = [34, 7, 23, -4, 0, 99, -45, 6, ...] ``` # Output Format - Output should be a single list of sorted integers matching the input list after applying the appropriate sorting algorithm: ``` sorted_arr = [-45, -4, 0, 6, 7, 23, 34, 99, ...] ``` # Example ```python arr = [34, 7, 23, -4, 0, 99, -45, 6] # Expected Output: # [-45, -4, 0, 6, 7, 23, 34, 99] ``` # Implementation Details - **Merge Sort** should be implemented using a divide-and-conquer approach, recursively dividing the array into halves and then merging the sorted halves. - **Quick Sort** should be implemented using the Lomuto partition scheme, with a strategy to handle pivot selection, partitioning, and recursive sorting. - Ensure that both sorting algorithms handle edge cases, such as empty arrays and arrays with a single element. Implement the sorting function carefully to ensure it meets the performance requirements for large inputs. --- # Example Implementation ```python def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): sorted_list = [] while left and right: if left[0] <= right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) if left: sorted_list.extend(left) if right: sorted_list.extend(right) return sorted_list def quick_sort(arr): if len(arr) <= 1: return arr pivot = arr[-1] less_than_pivot = [x for x in arr[:-1] if x <= pivot] greater_than_pivot = [x for x in arr[:-1] if x > pivot] return quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot) def sort_array(arr): if len(arr) <= 500: return quick_sort(arr) else: return merge_sort(arr) # Example Test Case arr = [34, 7, 23, -4, 0, 99, -45, 6] print(sort_array(arr)) # Outputs: [-45, -4, 0, 6, 7, 23, 34, 99] ```","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] while left and right: if left[0] <= right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) sorted_list.extend(left or right) return sorted_list def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[-1] less_than_pivot = [x for x in arr[:-1] if x <= pivot] greater_than_pivot = [x for x in arr[:-1] if x > pivot] return quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot) def sort_array(arr: List[int]) -> List[int]: if len(arr) <= 500: return quick_sort(arr) else: return merge_sort(arr)"},{"question":"# Question You are required to implement a unique encryption algorithm and a corresponding decryption algorithm to secure textual data for message communication. Encryption Algorithm 1. Create a function `encrypt_message` that takes a string as input. 2. The encryption algorithm should substitute each character by moving it forward in the ASCII table by its position index in the string. For example, the character at the first position is replaced with the character that comes next in the ASCII sequence, the character at the second position moves forward by 2 positions in the ASCII sequence, and so on. 3. If the forward move goes past the printable ASCII characters (character code 126), wrap around to the beginning of the printable range (character code 32). Decryption Algorithm 1. Create a function `decrypt_message` that takes the encrypted string as input. 2. Implement the inverse process of the encryption algorithm. Move each character backward in the ASCII table by its original position index, wrapping past the beginning of the printable range if necessary. Requirements - **Input:** A string for encryption and a string for decryption. - **Output:** The encrypted string for the `encrypt_message` function and the decrypted string for the `decrypt_message` function. # Constraints - The input string can contain any printable ASCII character (codes 32 to 126). - Ensure the functions handle edge cases where characters wrap around the ASCII table properly. # Example ```python def encrypt_message(text): encrypted_message = [] for index, char in enumerate(text): new_char = chr((ord(char) + index + 1 - 32) % (126 - 32 + 1) + 32) encrypted_message.append(new_char) return \'\'.join(encrypted_message) def decrypt_message(encrypted_text): decrypted_message = [] for index, char in enumerate(encrypted_text): original_char = chr((ord(char) - index - 1 - 32) % (126 - 32 + 1) + 32) decrypted_message.append(original_char) return \'\'.join(decrypted_message) # Usage original_message = \\"Hello, World!\\" encrypted = encrypt_message(original_message) print(f\\"Encrypted: {encrypted}\\") # Encrypted version of the message decrypted = decrypt_message(encrypted) print(f\\"Decrypted: {decrypted}\\") # Should print \\"Hello, World!\\" ``` # Performance - Verify that the encryption and decryption algorithms are working correctly on various input strings. - Ensure that special characters and wrapping around the ASCII table are properly handled. # Additional Notes - Make sure the algorithms are optimized for performance, considering the input string length. - Test your functions with edge cases, including the empty string and strings with maximum printable characters.","solution":"def encrypt_message(text): Encrypt a message by shifting characters forward in the ASCII table based on their position index. encrypted_message = [] for index, char in enumerate(text): new_char = chr((ord(char) + index + 1 - 32) % (126 - 32 + 1) + 32) encrypted_message.append(new_char) return \'\'.join(encrypted_message) def decrypt_message(encrypted_text): Decrypt a message by shifting characters backward in the ASCII table based on their position index. decrypted_message = [] for index, char in enumerate(encrypted_text): original_char = chr((ord(char) - index - 1 - 32) % (126 - 32 + 1) + 32) decrypted_message.append(original_char) return \'\'.join(decrypted_message)"},{"question":"# Description: You are required to implement a function to determine the minimum number of steps required to transform one word into another. This is known as the edit distance, wherein the possible operations are inserting, deleting, or replacing a character. # Task: Implement a function, `min_edit_distance(word1: str, word2: str) -> int`, which calculates the minimum number of operations needed to convert `word1` into `word2`. # Input: - Two strings `word1` and `word2` (1 <= len(word1), len(word2) <= 1000). # Output: - An integer representing the minimum edit distance between the two given words. # Constraints: - Both words will only consist of lowercase alphabetic characters. # Example: ```python def min_edit_distance(word1: str, word2: str) -> int: # (Your logic here) pass print(min_edit_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 print(min_edit_distance(\\"flaw\\", \\"lawn\\")) # Output: 2 ``` # Instructions: 1. Initialize a 2D list `dp` where `dp[i][j]` represents the edit distance between the first `i` characters of `word1` and the first `j` characters of `word2`. 2. Fill in the base cases in the DP table where either one word is empty. 3. Iterate through each character of `word1` and `word2`, updating the DP table based on whether characters match or not and considering all possible operations (insert, delete, replace). 4. The final edit distance will be stored in `dp[len(word1)][len(word2)]`. 5. Return this value.","solution":"def min_edit_distance(word1: str, word2: str) -> int: m, n = len(word1), len(word2) # Create a 2D array to store the edit distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i # All deletions for j in range(n + 1): dp[0][j] = j # All insertions # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Replacement return dp[m][n]"},{"question":"Task # [Question 2]: # Minimum Path Sum Context: You are required to write a function that finds the minimum path sum from the top-left corner to the bottom-right corner of a 2D grid. Each step you can move either down or right. Requirements: Implement a function `min_path_sum` that computes the minimum sum of a path from the top-left to the bottom-right of the grid. Function Signature: ```python def min_path_sum(grid: list[list[int]]) -> int: pass ``` Input: - `grid` (list of list of int): A 2D grid of non-negative integers (1 <= len(grid) <= 100, 1 <= len(grid[0]) <= 100, 0 <= grid[i][j] <= 1000). Output: - `int`: The minimum sum possible to reach the bottom-right corner of the grid from the top-left corner. Constraints: - At each step, you can only move either right or down. - The dimensions of the grid and the values of the elements are within the specified range. Functionality Requirements: 1. Efficient processing of grid to handle the largest constraints. 2. Consider edge cases like a grid of size 1x1, or grids with uniform values. Example: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(grid)) # Output: 7 ``` Explanation: The minimum path sum from top-left to bottom-right is 7 through the path 1→3→1→1→1. Note: - Utilize dynamic programming to solve this problem and optimize the path selection. - Document the code and provide insightful comments to describe the logic and flow. This question is designed to test the candidate\'s ability to implement dynamic programming solutions, handle multi-dimensional arrays, and optimize pathfinding algorithms within a constrained environment.","solution":"def min_path_sum(grid): Computes the minimum path sum from the top-left corner to the bottom-right corner of a 2D grid. Each step you can move either down or right. :param grid: List of lists of integers representing the 2D grid :return: Integer representing the minimum path sum # If the grid is empty, return 0 if not grid or not grid[0]: return 0 # Get dimensions of the grid m, n = len(grid), len(grid[0]) # Initialize the DP table dp = [[0] * n for _ in range(m)] # Set the value of the top-left corner dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The value at the bottom-right corner is the minimum path sum return dp[m-1][n-1]"},{"question":"# Context As a part of an analytical software tool, you need to develop a function that can compute a team of developers\' average contribution time to a project. Each developer\'s contribution is recorded in minutes, and you must ensure accurate calculation with consideration of potential edge cases. # Task Implement a function `average_contribution_time(contributions: List[int]) -> float` that returns the average time spent by developers. The result should be rounded to two decimal places. # Function Signature ```python def average_contribution_time(contributions: List[int]) -> float: pass ``` # Input - `contributions`: A list of integers representing the time in minutes each developer has contributed to the project. # Output - A float representing the average contribution time, rounded to two decimal places. # Constraints - The input list can contain zero or more contributions. - Contributions are non-negative integers. - If the input list is empty, the function should return `0.00`. # Performance Requirements - The implementation must handle scenarios with large lists up to `10^6` elements efficiently. # Example Example 1: ```python >>> average_contribution_time([120, 140, 160]) 140.00 ``` Example 2: ```python >>> average_contribution_time([45, 30, 50, 80]) 51.25 ``` Example 3: ```python >>> average_contribution_time([]) 0.00 ``` # Notes - Consider using Python\'s built-in functions for summing and averaging lists. - Ensure the function handles edge cases such as an empty list and contributions with zero values. - The runtime complexity should allow you to process the input efficiently, even for larger lists.","solution":"from typing import List def average_contribution_time(contributions: List[int]) -> float: if not contributions: return 0.00 average = sum(contributions) / len(contributions) return round(average, 2)"},{"question":"# Coding Question: 2D Matrix Rotation Context: Matrix rotation is a common operation in image processing, game development, and other computational fields. Rotating a matrix 90 degrees clockwise requires careful manipulation of its rows and columns. Task: Create a function that rotates a given 2D matrix 90 degrees clockwise in place. Requirements: * **Function Signature**: `def rotate_matrix(matrix: List[List[int]]) -> None:` * **Input**: * `matrix`: A 2D list representing a square matrix of integers. The matrix is guaranteed to have equal width and height (n x n), where 1 ≤ n ≤ 100. * **Output**: * The function should not return anything. The input matrix should be modified in place to represent its 90-degree rotated version. * **Constraints**: * The matrix will contain only integers. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # matrix should now be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Challenge: - Do not use any additional matrices. - Perform the rotation in place with O(1) space complexity. Here is a relevant concept for your reference: To rotate a matrix 90 degrees clockwise: 1. Transpose the matrix (swap rows with columns). 2. Reverse each row in the transposed matrix.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Given an n x n 2D matrix, rotate the matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Task Write a function `invert_binary_tree` that inverts a given binary tree. Inverting a binary tree means swapping the left and right children of every node. # Input * The input will be the root node of a binary tree. # Output * The function should return the root node of the new, inverted binary tree. # Constraints * The binary tree can contain an arbitrary number of nodes. * The binary tree will not contain cycles. * The tree nodes may contain integer values. # Function Signature ```python def invert_binary_tree(root: Node) -> Node: # your implementation here ``` # Example Consider the binary tree below: ``` 4 / 2 7 / / 1 3 6 9 ``` With the following Python code to create the tree nodes: ```python root = Node(4) root.left = Node(2) root.right = Node(7) root.left.left = Node(1) root.left.right = Node(3) root.right.left = Node(6) root.right.right = Node(9) ``` Example Function Call ```python invert_binary_tree(root) ``` Expected Output The inverted binary tree will be: ``` 4 / 7 2 / / 9 6 3 1 ``` # Explanation Inverting the binary tree means swapping the left and right children of every node. The given tree structure is transformed such that all nodes switch positions with their respective left/right children. # Notes 1. Ensure that the function handles an empty tree correctly (i.e., returns `None`). 2. Provide thorough testing with many different tree structures, including edge cases such as single-node trees, trees with only left children, or only right children.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_binary_tree(root: Node) -> Node: if root is None: return None # Swap the left and right children root.left, root.right = invert_binary_tree(root.right), invert_binary_tree(root.left) return root"},{"question":"Sum of Neighboring Elements # Scenario You are working on a program that processes an array of integers to compute sums of pairs of neighboring elements. For a given array, generate a list where each element represents the sum of its neighboring elements. Specifically, the first and last elements of the input array are special cases since they only have one neighbor. # Function to Implement You need to write a function, `neighbor_sums`, which takes a list of integers and returns a new list of integers, where each element is the sum of its neighboring elements in the original list. # Function Signature ```python def neighbor_sums(numbers: list) -> list: pass ``` # Input - A list of integers. (1 ≤ len(numbers) ≤ 1000, -10^5 ≤ numbers[i] ≤ 10^5) # Output - A list of integers where each integer is the sum of the neighboring elements in the input list. # Constraints - For the first element of the output list, it should be equal to the second element of the input list. - For the last element of the output list, it should be equal to the second last element of the input list. - For other elements, it should be the sum of the previous and next elements. # Example ```python neighbor_sums([2, 5, 3, 8, 7]) ``` Output: ```python [5, 5, 13, 10, 8] ``` Explanation: - The first element is 5 (since it only has one neighbor). - The second element is 2 + 3 = 5. - The third element is 5 + 8 = 13. - The fourth element is 3 + 7 = 10. - The last element is 8 (since it only has one neighbor). # Notes - Ensure that your code does not modify the input list. - Handle edge cases where the list is of length 1 by returning an empty list, as it has no neighboring elements.","solution":"def neighbor_sums(numbers: list) -> list: Given a list of integers, returns a new list where each element is the sum of its neighboring elements in the original list. # Handle edge case where the list has only one element if len(numbers) == 1: return [] result = [] for i in range(len(numbers)): if i == 0: result.append(numbers[i+1]) elif i == len(numbers) - 1: result.append(numbers[i-1]) else: result.append(numbers[i-1] + numbers[i+1]) return result"},{"question":"# Problem: Lexicographical Rank of a Permutation Given a permutation of a string with unique characters, your task is to compute its lexicographical rank among all the permutations of that string. The lexicographical rank is defined as the position of the permutation in the order of all permutations sorted lexicographically (dictionary order). Input: - A single string, which is a permutation of its characters. Output: - An integer representing the lexicographical rank of the permutation. Example: ```python Input: \\"bac\\" Output: 2 ``` Explanation: The permutations of \\"abc\\" in lexicographical order are [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]. The permutation \\"bac\\" is the 2nd in this order. Write a function `lexicographical_rank` that computes the rank of the given permutation. ```python def lexicographical_rank(s: str) -> int: This function calculates the lexicographical rank of the given permutation. Args: s (str): A permutation of a string with unique characters. Returns: int: The lexicographical rank of the given permutation. from math import factorial # Helper function to calculate the factorial fact = [1] * (len(s) + 1) for i in range(1, len(s) + 1): fact[i] = fact[i - 1] * i rank = 1 n = len(s) for i in range(n): # Calculate the number of permutations that begin with characters less than s[i] count = 0 for j in range(i + 1, n): if s[j] < s[i]: count += 1 rank += count * fact[n - i - 1] return rank # Example of usage if __name__ == \\"__main__\\": permutation = \\"bac\\" print(lexicographical_rank(permutation)) # Output: 2 ``` # Constraints: - The input string will contain only unique characters. - The length of the input string will be between 1 and 15 inclusive. This problem aligns with the original questions\' style, complexity, and scope by requiring an understanding of permutations, factorials, and efficient computation while remaining clear and concise.","solution":"def lexicographical_rank(s: str) -> int: This function calculates the lexicographical rank of the given permutation. Args: s (str): A permutation of a string with unique characters. Returns: int: The lexicographical rank of the given permutation. from math import factorial # Helper function to calculate the factorial fact = [1] * (len(s) + 1) for i in range(1, len(s) + 1): fact[i] = fact[i - 1] * i rank = 1 n = len(s) for i in range(n): # Calculate the number of permutations that begin with characters less than s[i] count = 0 for j in range(i + 1, n): if s[j] < s[i]: count += 1 rank += count * fact[n - i - 1] return rank"},{"question":"**Context**: You are developing a function to help analyze temperature variations over a range of days. The task is to calculate the number of days until a warmer temperature for each day in a list of daily temperatures. **Task**: Write a function `daily_temperatures(temperatures: List[int]) -> List[int]` that calculates the number of days after the current day until a warmer temperature is recorded. If there is no future day for which this is possible, outputs `0` for that day. **Function Specifications**: * **Input**: - `temperatures`: A list of integers (List[int]), representing the daily temperatures. * **Output**: - Returns a list of integers (List[int]), where the output list has the same length as the input list. Each element in the output list represents the number of days until a warmer temperature. If no warmer temperature is found for a given day, that element will be `0`. **Constraints**: * The list `temperatures` will always contain at least one temperature. * Each temperature is a non-negative integer less than or equal to 100. * The length of the `temperatures` list can be as large as 10^5. **Examples**: ```python >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([30, 20, 10]) [0, 0, 0] >>> daily_temperatures([88]) [0] ``` **Additional Considerations**: * Consider using an efficient algorithm to handle the upper constraint limits reasonably well. * Ensure the solution properly handles edge cases such as single-day input and descending temperature sequences.","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Calculate the number of days until a warmer temperature for each day in a list of temperatures. n = len(temperatures) result = [0] * n stack = [] # Stack to store the indices of the temperatures list for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"# Detect Palindromic Substrings You are helping to develop a text-processing application, and one of the features is to detect palindromic substrings within a given string. A palindrome is a word or phrase that reads the same forwards and backwards (ignoring spaces, punctuation, and case). Write the `count_palindromic_substrings` function that takes a single parameter `input_string` and counts how many substrings of it are palindromic. This function should be efficient enough to handle strings up to length 1000. # Implementation Details: - **Input**: - `input_string` (str): The input string containing lowercase and/or uppercase letters. - **Output**: - `int`: The total number of palindromic substrings found in the input string. # Examples ```python >>> count_palindromic_substrings(\\"madam\\") 7 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aabb\\") 6 ``` # Explanation: - For the input \\"madam\\": - The palindromic substrings are: \\"m\\", \\"a\\", \\"d\\", \\"a\\", \\"m\\", \\"ada\\", \\"madam\\", totaling 7. - For the input \\"racecar\\": - The palindromic substrings are: \\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"c\\", \\"a\\", \\"r\\", \\"cec\\", \\"aceca\\", \\"racecar\\", totaling 10. - For the input \\"abc\\": - The palindromic substrings are: \\"a\\", \\"b\\", \\"c\\", totaling 3. - For the input \\"aabb\\": - The palindromic substrings are: \\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"aa\\", \\"bb\\", totaling 6. # Implementation Hints 1. Iterate through each character in the string and consider it as the center of a potential palindrome. 2. Expand around each center to count palindromes of odd and even lengths. 3. Consider edge cases such as single letters and empty strings. Remember to handle the case sensitivity and different lengths during the checks for palindromes.","solution":"def count_palindromic_substrings(input_string): Counts the total number of palindromic substrings in the input_string. n = len(input_string) palindrome_count = 0 # A helper function to count palindromes centered around left and right def count_palindromes_around_center(left, right): count = 0 while left >= 0 and right < n and input_string[left] == input_string[right]: count += 1 left -= 1 right += 1 return count # Iterate through each center and count palindromes for center in range(n): # Odd length palindromes palindrome_count += count_palindromes_around_center(center, center) # Even length palindromes palindrome_count += count_palindromes_around_center(center, center + 1) return palindrome_count"},{"question":"**Scenario**: You have been tasked with developing a scheduling application for a conference. The conference consists of a series of sessions, each with a start time and an end time. In order to make the most efficient use of the time, you need to schedule as many non-overlapping sessions as possible. **Problem Statement**: Write a function `max_sessions(sessions: list[tuple[int, int]]) -> list[tuple[int, int]]` that determines the maximum number of non-overlapping sessions that can be scheduled. # Input: 1. `sessions`: A list of tuples where each tuple represents a session with a start time and an end time. # Output: A list of tuples representing the sessions that can be scheduled to maximize the number of non-overlapping sessions. # Constraints: - The start time and end time in each tuple are non-negative integers. - The end time of a session is always greater than its start time. # Examples: ```python assert max_sessions([(1, 3), (2, 5), (4, 7), (6, 9), (8, 10)]) == [(1, 3), (4, 7), (8, 10)] assert max_sessions([(1, 2), (2, 4), (3, 5)]) == [(1, 2), (2, 4)] assert max_sessions([(1, 10), (2, 3), (4, 5), (6, 7), (8, 9)]) == [(2, 3), (4, 5), (6, 7), (8, 9)] assert max_sessions([]) == [] assert max_sessions([(0, 5)]) == [(0, 5)] ``` # Additional Notes: - Ensure that the function runs efficiently, as it may need to handle a large number of sessions. - When multiple valid solutions exist, any one of them is acceptable as the correct answer. - Edge cases such as an empty list or sessions that do not overlap at all should be handled correctly.","solution":"def max_sessions(sessions): Determines the maximum number of non-overlapping sessions that can be scheduled. Args: sessions (list of tuple): List of tuples where each tuple represents a session with a start and end time. Returns: list of tuple: List of tuples representing the non-overlapping sessions. if not sessions: return [] # Sort sessions based on their end time sorted_sessions = sorted(sessions, key=lambda x: x[1]) max_sessions = [] prev_end_time = -1 for session in sorted_sessions: # If the start time of the current session is after the end time of the last added session, add it if session[0] >= prev_end_time: max_sessions.append(session) prev_end_time = session[1] return max_sessions"},{"question":"# Coding Assessment Question Context You are tasked with creating a tool that can automate the process of converting text documents into summarized versions. This utility will help users quickly extract the main points from large documents. Task Create a function `summarize_document(file_path: str, percentage_reduction: float) -> str` which: 1. Reads in a text document from the specified file path. 2. Summarizes the content by reducing it to the specified percentage of the original length. 3. Returns the summarized text. Requirements 1. Implement the function `summarize_document(file_path: str, percentage_reduction: float) -> str`. 2. The function should maintain the coherence and meaning of the original text. 3. Ensure the function does not produce a summary shorter than 10% or longer than 90% of the original document. 4. Implement error handling for file I/O issues and incorrect input parameters. Input and Output * **Input**: A string `file_path` representing the path to the text document, and a float `percentage_reduction` specifying the percentage by which the document should be reduced. * **Output**: A string containing the summarized text. Constraints * The function should work with plain text (.txt) files. * Assume the environment has necessary permissions to read and write files. * The function should raise appropriate exceptions for invalid file paths or percentage values outside the allowable range (10%-90%). Example: ```python >>> summary = summarize_document(\\"example.txt\\", 50.0) >>> print(summary) \\"The document outlines the critical points...\\" ```","solution":"import os def summarize_document(file_path: str, percentage_reduction: float) -> str: Summarizes the content of a text document by reducing it to a specified percentage of the original length. :param file_path: Path to the text document file. :param percentage_reduction: The percentage by which the document should be reduced. :return: Summarized text as a string. if not (10 <= percentage_reduction <= 90): raise ValueError(\'percentage_reduction must be between 10 and 90\') if not os.path.exists(file_path): raise FileNotFoundError(f\'No file found at {file_path}\') with open(file_path, \'r\') as file: content = file.read() original_length = len(content) target_length = int(original_length * (percentage_reduction / 100.0)) # Dummy summary logic - this should be replaced with a proper summarization algorithm summarized_text = content[:target_length] return summarized_text"},{"question":"# Problem Statement You are required to implement a system for scheduling meeting rooms in an office. The office has a fixed number of rooms, and each room can be booked for a specific time slot. Your task is to develop functions that allow for adding bookings, checking the availability of rooms for a given time slot, and canceling bookings. # Requirements 1. Create a class `MeetingRoomScheduler` with the following methods: - `__init__(self, rooms: int) -> None`: Initializes the scheduler with a given number of rooms. - `book_room(self, start_time: float, end_time: float) -> bool`: Books a room for a given time interval. Returns `True` if the booking is successful, otherwise returns `False`. - `is_available(self, start_time: float, end_time: float) -> bool`: Checks if there is at least one room available for the given time interval. Returns `True` if at least one room is available, otherwise returns `False`. - `cancel_booking(self, start_time: float, end_time: float) -> bool`: Cancels a booking for the given time interval. Returns `True` if any booking was canceled, otherwise returns `False`. # Input - **rooms**: An integer representing the number of available rooms. - **start_time**: A float representing the start time of the booking (in hours, e.g., 14.5 for 2:30 PM). - **end_time**: A float representing the end time of the booking (in hours, e.g., 15.5 for 3:30 PM). # Output - `book_room` method: Returns a boolean indicating if the booking was successful. - `is_available` method: Returns a boolean indicating if there is a room available for the given time slot. - `cancel_booking` method: Returns a boolean indicating if any booking was canceled. # Examples ```python # Example 1 # Initialize the scheduler with 2 rooms scheduler = MeetingRoomScheduler(2) # Book a room from 14.5 to 15.5 print(scheduler.book_room(14.5, 15.5)) # Output: True # Book another room from 14.5 to 15.5 print(scheduler.book_room(14.5, 15.5)) # Output: True # Check room availability from 14.5 to 15.5 (all rooms booked) print(scheduler.is_available(14.5, 15.5)) # Output: False # Cancel a booking from 14.5 to 15.5 print(scheduler.cancel_booking(14.5, 15.5)) # Output: True # Check room availability from 14.5 to 15.5 (one room available) print(scheduler.is_available(14.5, 15.5)) # Output: True # Book a room from 16.0 to 17.0 print(scheduler.book_room(16.0, 17.0)) # Output: True # Cancel a booking from 16.0 to 17.0 print(scheduler.cancel_booking(16.0, 17.0)) # Output: True # Try to cancel a non-existent booking from 18.0 to 19.0 print(scheduler.cancel_booking(18.0, 19.0)) # Output: False ``` # Constraints - `1 <= rooms <= 50` - `0 <= start_time < 24` (representing the time in a 24-hour format) - `start_time < end_time <= 24` - Handle edge cases such as booking conflicts and invalid time slots gracefully. Implement the `MeetingRoomScheduler` class and its methods ensuring robustness and handling of edge cases effectively.","solution":"class MeetingRoomScheduler: def __init__(self, rooms: int) -> None: Initializes the scheduler with a given number of rooms. self.rooms = rooms self.bookings = [] def book_room(self, start_time: float, end_time: float) -> bool: Books a room for a given time interval. Returns True if the booking is successful, otherwise returns False. if self.is_available(start_time, end_time): self.bookings.append((start_time, end_time)) return True return False def is_available(self, start_time: float, end_time: float) -> bool: Checks if there is at least one room available for the given time interval. Returns True if at least one room is available, otherwise returns False. count = 0 for booking in self.bookings: if not (booking[1] <= start_time or booking[0] >= end_time): count += 1 return count < self.rooms def cancel_booking(self, start_time: float, end_time: float) -> bool: Cancels a booking for the given time interval. Returns True if any booking was canceled, otherwise returns False. for booking in self.bookings: if booking[0] == start_time and booking[1] == end_time: self.bookings.remove(booking) return True return False"},{"question":"# Problem Statement You are given a circularly linked list where the last node points to the first node in the list, and each node has a unique integer value. Write a function `insert_into_sorted_circular_linked_list` that inserts a new integer into the list while maintaining the sorted order. # Input * An integer `val`, the value to be inserted into the list. * The head of the circularly linked list, `head`. # Output * Return the head of the new, sorted circularly linked list after inserting `val`. # Function Signature ```python class ListNode: def __init__(self, x): self.val = x self.next = None def insert_into_sorted_circular_linked_list(head: ListNode, val: int) -> ListNode: pass ``` # Constraints * The list will have at least one node and be sorted in non-decreasing order. * The list will contain values with unique nodes and the operation should be done in O(n) time complexity. * If the list is empty (head is None), create a new list with a single node with value `val`. * You cannot use additional data structures to store the nodes of the list. # Example ```python # Example 1 head = ListNode(3) head.next = ListNode(5) head.next.next = ListNode(7) head.next.next.next = head # last node points back to the head val = 4 new_head = insert_into_sorted_circular_linked_list(head, val) # Output should be the circular linked list: # 3 -> 4 -> 5 -> 7 -> 3 # Example 2 head = ListNode(1) head.next = ListNode(1) head.next.next = ListNode(1) head.next.next.next = head # last node points back to the head val = 2 new_head = insert_into_sorted_circular_linked_list(head, val) # Output should be the circular linked list: # 1 -> 1 -> 2 -> 1 -> 1 # Example 3 head = None val = 1 new_head = insert_into_sorted_circular_linked_list(head, val) # Output should be the circular linked list: # 1 -> 1 ``` # Detailed Explanation * Each node in the circular linked list has a unique value. * Given the integer `val`, you need to insert it in the correct place in a sorted circularly linked list. * If the list is empty, create a new list with a single node containing `val`. * Traverse the list to find the appropriate place to insert the new node. * Ensure the list remains circular after insertion by updating the `next` pointers of relevant nodes.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def insert_into_sorted_circular_linked_list(head: ListNode, val: int) -> ListNode: new_node = ListNode(val) if not head: new_node.next = new_node return new_node current = head while True: if current.val <= val <= current.next.val: new_node.next = current.next current.next = new_node return head elif current.val > current.next.val: if val > current.val or val < current.next.val: new_node.next = current.next current.next = new_node return head current = current.next if current == head: break new_node.next = head.next head.next = new_node return head"},{"question":"# Binary Search Tree (BST) Operations The following class definition initiates a node for a binary search tree: ```python class BSTNode: def __init__(self, key: int, left: BSTNode | None = None, right: BSTNode | None = None) -> None: self.key = key self.left = left self.right = right ``` # Function Implementation Using the `BSTNode` class, implement a basic binary search tree with methods to insert elements and find the height of the tree. Requirements 1. **Function Name**: `insert_into_bst` * **Input**: The root node of a BST and an integer key. * **Output**: The root node of the BST after the insertion of the new key. 2. **Function Name**: `find_bst_height` * **Input**: The root node of a BST. * **Output**: An integer representing the height of the tree. # Example: ```python # Sample BST operations root = None keys = [5, 3, 8, 2, 4, 7, 9] for key in keys: root = insert_into_bst(root, key) print(find_bst_height(root)) # Output: 2 ``` # Constraints * The `insert_into_bst` function should maintain the properties of the binary search tree. * The `find_bst_height` function should compute the height efficiently. Implement the `insert_into_bst` and `find_bst_height` functions below.","solution":"class BSTNode: def __init__(self, key: int, left: \\"BSTNode\\" = None, right: \\"BSTNode\\" = None) -> None: self.key = key self.left = left self.right = right def insert_into_bst(root: BSTNode, key: int) -> BSTNode: Inserts a key into the BST and returns the root of the modified BST. if root is None: return BSTNode(key) if key < root.key: root.left = insert_into_bst(root.left, key) elif key > root.key: root.right = insert_into_bst(root.right, key) return root def find_bst_height(root: BSTNode) -> int: Finds the height of the BST. if root is None: return -1 # Empty tree has height -1 by this definition left_height = find_bst_height(root.left) right_height = find_bst_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Scenario: You are engaged in the development of an e-commerce application that offers detailed product information to its users. One of the features requested by the client is a personalized product recommendation engine based on the user\'s past purchase history and wish list. # Task: Implement a Python function `recommend_products(user_id)` that retrieves a user\'s purchase history and wish list from an API, combines the data, and returns a list of recommended products. The recommendation algorithm should prioritize items that appear more frequently in the combined data. # Function Specification: Input: - `user_id`: A string representing the unique identifier of the user. Output: - A list of dictionaries, each containing: * `\'product_id\'`: The unique identifier of the product as a string. * `\'product_name\'`: The name of the product as a string. Constraints: - The function should make HTTP GET requests to `https://api.ecommerce.com/purchase_history/{user_id}` and `https://api.ecommerce.com/wish_list/{user_id}`. - Implement appropriate error handling for time-outs, invalid responses, and network errors. - Handle edge cases like empty or malformed responses gracefully. - Ensure that the function completes its execution in a reasonable time frame (preferably under 3 seconds). # Recommendation Algorithm: 1. Fetch the purchase history and wish list for the specified `user_id`. 2. Combine the data from both sources, prioritizing items that appear in both lists. 3. Return up to 10 recommended products based on frequency of appearance in the combined list, with ties broken by the order they appear in the purchase history. # Example: ```python # Example usage result = recommend_products(\\"user123\\") print(result) ``` Expected Output: ```python [ {\'product_id\': \'prod001\', \'product_name\': \'Wireless Mouse\'}, {\'product_id\': \'prod002\', \'product_name\': \'Mechanical Keyboard\'}, {\'product_id\': \'prod003\', \'product_name\': \'HD Monitor\'}, # ... up to 10 items ] ```","solution":"import requests from collections import Counter from typing import List, Dict def fetch_data(url: str) -> List[Dict[str, str]]: Fetch data from a given URL and return it as a list of dictionaries. Handle errors and return an empty list in case of any issue. try: response = requests.get(url) response.raise_for_status() data = response.json() if isinstance(data, list): return data except (requests.RequestException, ValueError): pass return [] def recommend_products(user_id: str) -> List[Dict[str, str]]: Fetches the user\'s purchase history and wish list, combines the data, and returns a list of recommended products. Args: user_id (str): The unique identifier of the user. Returns: List[Dict[str, str]]: A list of recommended products. purchase_history_url = f\'https://api.ecommerce.com/purchase_history/{user_id}\' wish_list_url = f\'https://api.ecommerce.com/wish_list/{user_id}\' purchase_history = fetch_data(purchase_history_url) wish_list = fetch_data(wish_list_url) combined_products = purchase_history + wish_list product_counter = Counter([product[\'product_id\'] for product in combined_products]) # Sort products by frequency and then by the appearance in purchase history sorted_products = sorted(combined_products, key=lambda x: (-product_counter[x[\'product_id\']], purchase_history.index(x) if x in purchase_history else float(\'inf\'))) # Use an ordered dictionary to keep track of unique recommendations recommended = [] seen = set() for product in sorted_products: product_id = product[\'product_id\'] if product_id not in seen: recommended.append(product) seen.add(product_id) if len(recommended) >= 10: break return recommended"},{"question":"# Fibonacci Sequence Modification Challenge Context You are working on optimizing computational problems that involve mathematical sequences. One commonly used sequence in problem-solving is the Fibonacci sequence. Your task is to modify the traditional Fibonacci sequence such that it accommodates a custom starting pair of numbers while maintaining the traditional properties of the sequence. Task Your task is to implement a function that generates the first `n` terms of a modified Fibonacci sequence. Unlike the traditional Fibonacci sequence which starts with `0` and `1`, this sequence will start with two given numbers `a` and `b`. Requirements 1. **Function Prototype**: Implement the function `custom_fibonacci(n: int, a: int, b: int) -> list[int]`. 2. **Input and Output**: - **Input**: - `n` (integer): The number of terms to generate in the sequence. - `a` (integer): The first term of the custom Fibonacci sequence. - `b` (integer): The second term of the custom Fibonacci sequence. - **Output**: A list containing the first `n` terms of the custom Fibonacci sequence. 3. **Constraints**: - `2 <= n <= 100` - `0 <= a, b <= 10^9` Expectations - The function should handle large values of `a` and `b` efficiently. - The sequence must adhere to the Fibonacci property: every term after the first two is the sum of the two preceding terms. - Proper handling of edge cases, such as the smallest values for `n`, `a`, and `b`. Implementation Example Here is a template to get you started: ```python def custom_fibonacci(n: int, a: int, b: int) -> list[int]: # Early exit for small n values if n == 1: return [a] elif n == 2: return [a, b] sequence = [a, b] for _ in range(2, n): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence ``` - **Example 1**: - **Input**: `n = 5, a = 2, b = 3` - **Output**: `[2, 3, 5, 8, 13]` - **Example 2**: - **Input**: `n = 7, a = 1, b = 1` - **Output**: `[1, 1, 2, 3, 5, 8, 13]` Use the properties of the Fibonacci sequence to generate the series starting with any two specified numbers, ensuring efficiency and correctness in your implementation.","solution":"def custom_fibonacci(n: int, a: int, b: int) -> list[int]: Generates the first n terms of a custom Fibonacci sequence starting with a and b. Args: n (int): The number of terms to generate in the sequence. a (int): The first term of the custom Fibonacci sequence. b (int): The second term of the custom Fibonacci sequence. Returns: list[int]: The first n terms of the custom Fibonacci sequence. if n == 1: return [a] elif n == 2: return [a, b] sequence = [a, b] for _ in range(2, n): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"# Coding Assessment Question Problem Description: You are assigned the task of sorting a list of student records based on their grades. Each student record contains three attributes: `name` (a string), `grade` (an integer), and `id` (an integer). Your objective is to sort the student records primarily by their grades in descending order. If two or more students share the same grade, then sort by their name in alphabetical order. In case the grades and names are identical, sort by their `id` in ascending order. Write a function `sort_students` that takes a list of dictionaries where each dictionary represents a student record, and returns a list of dictionaries sorted based on the described criteria. Function Signature ```python def sort_students(students: list[dict]) -> list[dict]: pass ``` Input: * `students`: A list of dictionaries, where each dictionary represents a student record with the following fields: - `name` (string): The name of the student. - `grade` (integer): The grade of the student. - `id` (integer): The id of the student. Output: * A list of dictionaries sorted as described. Examples: ```python >>> sort_students([ ... {\\"name\\": \\"John\\", \\"grade\\": 90, \\"id\\": 4}, ... {\\"name\\": \\"Alice\\", \\"grade\\": 90, \\"id\\": 2}, ... {\\"name\\": \\"Bob\\", \\"grade\\": 85, \\"id\\": 3}, ... {\\"name\\": \\"Mark\\", \\"grade\\": 90, \\"id\\": 1} ... ]) [ {\'name\': \'Alice\', \'grade\': 90, \'id\': 2}, {\'name\': \'John\', \'grade\': 90, \'id\': 4}, {\'name\': \'Mark\', \'grade\': 90, \'id\': 1}, {\'name\': \'Bob\', \'grade\': 85, \'id\': 3} ] >>> sort_students([ ... {\\"name\\": \\"Charlie\\", \\"grade\\": 75, \\"id\\": 6}, ... {\\"name\\": \\"Dave\\", \\"grade\\": 75, \\"id\\": 5}, ... {\\"name\\": \\"Eve\\", \\"grade\\": 80, \\"id\\": 7} ... ]) [ {\'name\': \'Eve\', \'grade\': 80, \'id\': 7}, {\'name\': \'Dave\', \'grade\': 75, \'id\': 5}, {\'name\': \'Charlie\', \'grade\': 75, \'id\': 6} ] ``` Constraints: * The list will have at most `10^6` student records. * Student names will be non-empty strings and can contain alphabets and spaces. * Grades will be integer values ranging from 0 to 100. * IDs are integer values and unique. Requirements: * Define the function `sort_students(students: list[dict]) -> list[dict]`. * Ensure the function handles the sorting criteria efficiently. * Consider edge cases such as an empty input list or all students having unique grades.","solution":"def sort_students(students): Sorts a list of student records based on their grades in descending order. If grades are the same, sorts by name in alphabetical order. If both grades and names are the same, sorts by ID in ascending order. :param students: list of dictionaries, each dictionary represents a student record. :return: list of dictionaries sorted based on the described criteria. return sorted(students, key=lambda x: (-x[\'grade\'], x[\'name\'], x[\'id\']))"},{"question":"# Scenario You\'re managing a data logging system that tracks temperature readings every hour. Occasionally, sensors malfunction and report erroneous readings, typically indicated by a sudden spike compared to the surrounding values. To maintain data integrity, you need a function that smoothes out these anomalies by replacing any spike with the average of its neighboring values. # Problem Statement Implement a function `smooth_readings(readings: List[int]) -> List[int]` that takes in a list of temperature readings. The function should identify any reading that is more than `100` units different from both its previous and next values, and replace it with the average of its previous and next values. # Input and Output Formats * The function will receive a list of integers representing temperature readings. * The function should return a new list of integers where the spikes have been smoothed out. # Constraints * The list of readings will contain at least three readings and up to (10^5) readings. * Each reading can range from (-10^3) to (10^3). # Performance Requirements * The implementation should have a linear time complexity (O(n)). # Example Cases ```python >>> smooth_readings([10, 200, 12]) [10, 11, 12] >>> smooth_readings([5, 6, 7, 800, 9, 10]) [5, 6, 7, 8, 9, 10] >>> smooth_readings([-10, -5, 900, -6, -8]) [-10, -5, -6, -6, -8] >>> smooth_readings([100, 101, 102, 103]) [100, 101, 102, 103] ``` # Additional Notes * Do not modify the first and last readings, since they do not have two neighbors. * Handle edge cases such as when the list contains negative values or the spike is at extreme values within the valid range.","solution":"def smooth_readings(readings): Replaces any reading in the list that is more than 100 units higher or lower than both its previous and next values, with the average of those two values. Args: readings (List[int]): A list of temperature readings. Returns: List[int]: A new list of temperature readings with spikes smoothed out. n = len(readings) smoothed_readings = readings[:] for i in range(1, n-1): if abs(readings[i] - readings[i-1]) > 100 and abs(readings[i] - readings[i+1]) > 100: smoothed_readings[i] = (readings[i-1] + readings[i+1]) // 2 return smoothed_readings"},{"question":"# Question: Validate and Convert Fractional Strings Context You are developing a utility to process numerical data represented as strings for a financial application. Your task is to validate and convert these strings into their respective fractional and decimal forms. Specifically, you need to differentiate between proper and improper fractions and ensure the validation conforms to the specified criteria. Requirements 1. **Function 1: Validate Fraction** ```python def validate_fraction(fraction: str) -> bool: Takes in a string \'fraction\'. \'fraction\' is expected to be in the form \'numerator/denominator\'. Validate that both the numerator and the denominator are valid integers. The denominator must not be zero. Return True if the fraction is valid, False otherwise. Example: >>> validate_fraction(\\"5/3\\") True >>> validate_fraction(\\"4/0\\") False ``` 2. **Function 2: Convert Fraction to Decimal** ```python def fraction_to_decimal(fraction: str) -> float: Takes in a string \'fraction\'. \'fraction\' is expected to be in the form \'numerator/denominator\'. Convert the valid fraction to its decimal form and return the result. If the fraction is invalid, raise a ValueError. Example: >>> fraction_to_decimal(\\"5/2\\") 2.5 >>> fraction_to_decimal(\\"4/0\\") ValueError: Invalid fraction. ``` 3. **Function 3: Simplify Fraction** ```python def simplify_fraction(fraction: str) -> str: Takes in a string \'fraction\'. \'fraction\' is expected to be in the form \'numerator/denominator\'. Simplify the fraction by dividing the numerator and denominator by their greatest common divisor. If the fraction is invalid, raise a ValueError. Example: >>> simplify_fraction(\\"10/4\\") \\"5/2\\" >>> simplify_fraction(\\"4/0\\") ValueError: Invalid fraction. ``` Constraints - Input fraction strings must be in the form \'numerator/denominator\'. - The numerator and denominator should be valid integers. - The denominator must not be zero. - Handle both positive and negative fraction values. Performance Requirements - Aim for efficient implementations focusing on clear and correct validation methods. - The algorithms should run within linear time complexity relative to the length of the fraction string. Edge Cases - Handle improper fractions where the numerator is larger than the denominator. - Handle edge cases with negative numerators and/or denominators. - Ensure the functions raise appropriate errors for invalid fraction formats and zero denominators.","solution":"def validate_fraction(fraction: str) -> bool: Takes in a string \'fraction\'. \'fraction\' is expected to be in the form \'numerator/denominator\'. Validate that both the numerator and the denominator are valid integers. The denominator must not be zero. Return True if the fraction is valid, False otherwise. parts = fraction.split(\'/\') if len(parts) != 2: return False try: numerator = int(parts[0].strip()) denominator = int(parts[1].strip()) except ValueError: return False return denominator != 0 def fraction_to_decimal(fraction: str) -> float: Takes in a string \'fraction\'. \'fraction\' is expected to be in the form \'numerator/denominator\'. Convert the valid fraction to its decimal form and return the result. If the fraction is invalid, raise a ValueError. if not validate_fraction(fraction): raise ValueError(\\"Invalid fraction.\\") numerator, denominator = map(int, fraction.split(\'/\')) return numerator / denominator from math import gcd def simplify_fraction(fraction: str) -> str: Takes in a string \'fraction\'. \'fraction\' is expected to be in the form \'numerator/denominator\'. Simplify the fraction by dividing the numerator and denominator by their greatest common divisor. If the fraction is invalid, raise a ValueError. if not validate_fraction(fraction): raise ValueError(\\"Invalid fraction.\\") numerator, denominator = map(int, fraction.split(\'/\')) common_divisor = gcd(numerator, denominator) simplified_numerator = numerator // common_divisor simplified_denominator = denominator // common_divisor return f\\"{simplified_numerator}/{simplified_denominator}\\""},{"question":"# CSV Column Sum You are tasked with writing a function that reads a CSV (Comma-Separated Values) string and sums the values of a specified column. The goal is to test your ability to handle CSV data parsing and perform simple numerical operations. Function Signature ```python def sum_csv_column(csv_string: str, column_name: str) -> float: pass ``` Input - `csv_string` (string): A string representing the CSV data, with the first row being the header. - `column_name` (string): The name of the column whose values need to be summed up. Output - Return the sum of the values in the specified column (as a float). Constraints 1. The column values should be treatable as floats. 2. The CSV string contains valid data with well-formed rows and columns. 3. Assume no missing or malformed rows in the provided CSV string. 4. If the column name does not exist, return `0.0`. Context CSV files are common in data exchange and storage. Often, analyzing data begins by parsing it and performing fundamental operations such as summation. Your task is to create a function that extracts and sums column values from a CSV string. # Examples Example 1 **Input**: ```python csv_string = \\"name,age,salarynAlice,30,1000.50nBob,35,2000.75nCharlie,25,1500.00\\" column_name = \\"salary\\" ``` **Output**: ```python 4501.25 ``` Example 2 **Input**: ```python csv_string = \\"product,price,quantitynapple,0.99,10nbanana,0.50,5ncherry,2.00,2\\" column_name = \\"price\\" ``` **Output**: ```python 3.49 ``` Example 3 **Input**: ```python csv_string = \\"a,b,cn1,2,3n4,5,6n7,8,9\\" column_name = \\"d\\" ``` **Output**: ```python 0.0 ``` Instructions - Implement the function `sum_csv_column` as described. - Ensure you correctly handle data parsing. - Validate column name existence and correctly sum up the numerical values in the specified column.","solution":"import csv from io import StringIO def sum_csv_column(csv_string: str, column_name: str) -> float: Sums the values of a specified column in the given CSV string. Parameters: - csv_string: A string representing the CSV data, with the first row being the header. - column_name: The name of the column whose values need to be summed up. Returns: - The sum of the values in the specified column as a float. csv_file = StringIO(csv_string) reader = csv.DictReader(csv_file) column_sum = 0.0 for row in reader: # Ensure the column exists in the CSV if column_name in row: column_sum += float(row[column_name]) return column_sum"},{"question":"Problem Statement Write a function `is_rotated_sorted` that checks if a given list of integers is a rotated version of a sorted list. # Function Signature ```python def is_rotated_sorted(nums: list[int]) -> bool: pass ``` # Input - `nums`: A list of integers which might be a rotated sorted list. # Output - Returns `True` if the list is a rotated version of a sorted list, else returns `False`. # Constraints - `len(nums) <= 10^5` - `-10^9 <= nums[i] <= 10^9` # Requirements - Your implementation should work efficiently with a time complexity of O(n). # Example Example 1: ```python nums = [4, 5, 6, 7, 0, 1, 2] is_rotated_sorted(nums) ``` **Output**: `True` Example 2: ```python nums = [4, 5, 6, 7, 7, 0, 1, 2] is_rotated_sorted(nums) ``` **Output**: `True` Example 3: ```python nums = [3, 4, 5, 1, 2] is_rotated_sorted(nums) ``` **Output**: `True` Example 4: ```python nums = [2, 3, 4, 5, 1] is_rotated_sorted(nums) ``` **Output**: `True` Example 5: ```python nums = [4, 3, 2, 1, 5] is_rotated_sorted(nums) ``` **Output**: `False` # Additional Requirements - Think about the properties of rotated sorted lists and how they differ from unsorted lists. - Your solution should handle edge cases such as an empty list and single-element list efficiently. # Hints - Consider that a list that is a rotated sorted list will have at most one place where `nums[i] > nums[i+1]`. Use this property to determine if the list is a rotated sorted list.","solution":"def is_rotated_sorted(nums: list[int]) -> bool: Checks if a given list of integers is a rotated version of a sorted list. if len(nums) == 0: return True # An empty list is considered sorted and rotated. if len(nums) == 1: return True # A single-element list is considered sorted and rotated. drop_count = 0 for i in range(len(nums)): if nums[i] > nums[(i + 1) % len(nums)]: drop_count += 1 if drop_count > 1: return False return True"},{"question":"# Coding Assessment Question Array Shuffler You are required to write a function that takes an array of integers and rearranges its elements to form a sequence such that the sum of every two consecutive elements is unique. If such an arrangement is not possible, return an empty list. Function Signature ```python def shuffle_array_unique_sums(arr: list[int]) -> list[int]: ``` Input - `arr` (list[int]): A list of integers of length between 1 and 1000. Output - (list[int]): A rearranged list where the sum of every two consecutive elements is unique, or an empty list if no such arrangement exists. Constraints - The elements of `arr` can range from -1000 to 1000. - The length of `arr` is between 1 and 1000. - There are no guarantees on the uniqueness of the elements of `arr`. Requirements - Implement the function efficiently, possibly using heuristics or backtracking. - Ensure the function handles edge cases, such as very large arrays and arrays with repeat elements. Example ```python >>> shuffle_array_unique_sums([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] # Possible output, the actual order may vary >>> shuffle_array_unique_sums([1, 1, 1]) [] # No possible rearrangement >>> shuffle_array_unique_sums([5, -2, -1, 1, 2]) [5, -2, 2, -1, 1] # Possible output, the actual order may vary ``` Use logical reasoning and problem-solving techniques to achieve the required ordering of the array elements. You are encouraged to test your function with various inputs to ensure its correctness and efficiency.","solution":"def shuffle_array_unique_sums(arr: list[int]) -> list[int]: from itertools import permutations n = len(arr) if n == 1: return arr def is_unique_sum(seq): seen_sums = set() for i in range(n - 1): current_sum = seq[i] + seq[i + 1] if current_sum in seen_sums: return False seen_sums.add(current_sum) return True for perm in permutations(arr): if is_unique_sum(perm): return list(perm) return []"},{"question":"# Objective Write a function `letter_frequency` to count the frequency of each letter in a given string, ignoring case. The function should return a dictionary where the keys are letters and the values are the corresponding frequencies. # Input & Output * **Input**: A single string `s`. * **Output**: A dictionary where each key is a letter from the string, converted to lowercase, and its value is the frequency of that letter in the string. # Constraints 1. Ignore non-letter characters in the string (i.e., only consider `a-z` and `A-Z`). 2. Assume the input is always a valid string. 3. Optimize the function for both time and space complexity. # Example ```python # Example 1 # Input: \\"Hello World!\\" # Output: {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} # Example 2 # Input: \\"Programming\\" # Output: {\'p\': 1, \'r\': 2, \'o\': 1, \'g\': 2, \'a\': 1, \'m\': 2, \'i\': 1, \'n\': 1} # Example 3 # Input: \\"123abcABC\\" # Output: {\'a\': 2, \'b\': 2, \'c\': 2} ``` # Scenario You are building a text analysis tool that helps authors and editors to understand the frequency of different letters in their text. Implementing the `letter_frequency` function will help provide insights into letter usage, which could assist in various analytical and editing tasks. # Function Signature ```python def letter_frequency(s: str) -> dict: pass ```","solution":"def letter_frequency(s: str) -> dict: Count the frequency of each letter in a given string, ignoring case. Parameters: s (str): The input string. Returns: dict: A dictionary with lowercase letters as keys and their frequencies as values. frequency = {} for char in s: if char.isalpha(): char = char.lower() if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"Question: Implement Custom Sorting Algorithms You are tasked with implementing several fundamental sorting algorithms. This will test your understanding of sorting mechanisms, recursion, and iterators. Ensure that your implementations are efficient and meet the required sorting properties. # Algorithms to Implement 1. **Bubble Sort**: Sorts an array using the bubble sort algorithm. ```python def bubble_sort(arr: List[int]) -> List[int]: pass ``` 2. **Selection Sort**: Sorts an array using the selection sort algorithm. ```python def selection_sort(arr: List[int]) -> List[int]: pass ``` 3. **Insertion Sort**: Sorts an array using the insertion sort algorithm. ```python def insertion_sort(arr: List[int]) -> List[int]: pass ``` 4. **Merge Sort**: Sorts an array using the merge sort algorithm. ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` 5. **Quick Sort**: Sorts an array using the quick sort algorithm. ```python def quick_sort(arr: List[int]) -> List[int]: pass ``` # Input & Output Specifications: - All elements in the array will be integers. - Return a new sorted array for each algorithm instead of modifying the input array. # Example Usage: ```python arr = [64, 25, 12, 22, 11] print(bubble_sort(arr)) # Output: [11, 12, 22, 25, 64] print(selection_sort(arr)) # Output: [11, 12, 22, 25, 64] print(insertion_sort(arr)) # Output: [11, 12, 22, 25, 64] print(merge_sort(arr)) # Output: [11, 12, 22, 25, 64] print(quick_sort(arr)) # Output: [11, 12, 22, 25, 64] ``` # Constraints: - Assume maximum array length is 10,000. - Optimize for time complexity where appropriate (e.g., use divide and conquer for merge sort and quick sort). # Performance Requirements: Ensure that the implementation handles both small and large arrays efficiently, with a focus on maintaining acceptable performance even at the upper limit of constraints.","solution":"from typing import List def bubble_sort(arr: List[int]) -> List[int]: n = len(arr) sorted_arr = arr[:] for i in range(n): for j in range(0, n-i-1): if sorted_arr[j] > sorted_arr[j+1]: sorted_arr[j], sorted_arr[j+1] = sorted_arr[j+1], sorted_arr[j] return sorted_arr def selection_sort(arr: List[int]) -> List[int]: n = len(arr) sorted_arr = arr[:] for i in range(n): min_idx = i for j in range(i+1, n): if sorted_arr[j] < sorted_arr[min_idx]: min_idx = j sorted_arr[i], sorted_arr[min_idx] = sorted_arr[min_idx], sorted_arr[i] return sorted_arr def insertion_sort(arr: List[int]) -> List[int]: sorted_arr = arr[:] for i in range(1, len(sorted_arr)): key = sorted_arr[i] j = i - 1 while j >= 0 and key < sorted_arr[j]: sorted_arr[j + 1] = sorted_arr[j] j -= 1 sorted_arr[j + 1] = key return sorted_arr def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged middle = len(arr) // 2 left = merge_sort(arr[:middle]) right = merge_sort(arr[middle:]) return merge(left, right) def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Coding Assessment Question Problem Statement You are tasked with enhancing a log processing function that reads log files in a directory, parses the logs, and provides summary statistics based on specific criteria. Your task is to implement additional functionality to filter logs based on a severity level and include specific keywords if provided. Function to Implement ```python def process_logs(log_dir: str, severity_level: str = \\"INFO\\", keywords: Optional[List[str]] = None) -> Dict[str, int]: Extend the log processing function to filter logs by severity level and keywords. Parameters: - log_dir (str): The directory containing log files. - severity_level (str): The minimum severity level to include in the logs (e.g., \\"INFO\\", \\"WARNING\\", \\"ERROR\\"). - keywords (Optional[List[str]]): List of keywords to filter the logs. Include only logs containing any of these keywords. Returns: - Dict[str, int]: A dictionary with keys as severity levels and values as counts of log entries meeting the criteria. pass ``` Expectations 1. **Functionality**: - The function should only consider log entries with a severity level equal to or higher than the specified `severity_level`. - If the `keywords` list is provided, the function should include only the log entries containing any of the keywords. - If the `keywords` list is not provided, all logs meeting the severity requirement should be included. 2. **Input/Output**: - The function takes three parameters: `log_dir` (str), `severity_level` (str), and `keywords` (Optional[List[str]]). - It returns a dictionary where keys are severity levels (e.g., \\"INFO\\", \\"WARNING\\", \\"ERROR\\") and values are the counts of log entries meeting the criteria. 3. **Constraints**: - You should not modify the existing log files or their format. - Consider edge cases like empty logs, logs without a severity level, and logs with multiple keywords. - Ensure efficient processing of large log files and directories with many log files. Example Usage ```python # Example usage when calling your function log_summary = process_logs(\\"logs\\", severity_level=\\"WARNING\\", keywords=[\\"timeout\\", \\"error\\"]) for level, count in log_summary.items(): print(f\\"{level}: {count}\\") ```","solution":"import os import re from typing import List, Optional, Dict def process_logs(log_dir: str, severity_level: str = \\"INFO\\", keywords: Optional[List[str]] = None) -> Dict[str, int]: Extend the log processing function to filter logs by severity level and keywords. Parameters: - log_dir (str): The directory containing log files. - severity_level (str): The minimum severity level to include in the logs (e.g., \\"INFO\\", \\"WARNING\\", \\"ERROR\\"). - keywords (Optional[List[str]]): List of keywords to filter the logs. Include only logs containing any of these keywords. Returns: - Dict[str, int]: A dictionary with keys as severity levels and values as counts of log entries meeting the criteria. severity_levels = [\\"DEBUG\\", \\"INFO\\", \\"WARNING\\", \\"ERROR\\", \\"CRITICAL\\"] severity_index = severity_levels.index(severity_level) log_summary = {level: 0 for level in severity_levels[severity_index:]} for root, _, files in os.walk(log_dir): for file in files: file_path = os.path.join(root, file) with open(file_path, \'r\') as f: for line in f: match = re.search(r\'[(DEBUG|INFO|WARNING|ERROR|CRITICAL)]\', line) if match: level = match.group(1) level_index = severity_levels.index(level) if level_index >= severity_index: if keywords: if any(keyword in line for keyword in keywords): log_summary[level] += 1 else: log_summary[level] += 1 return {k: v for k, v in log_summary.items() if v > 0}"},{"question":"# Sorting Radar Measurements You are given a list of tuples, where each tuple represents a radar measurement. The first element in the tuple is an identifier (a string), and the second element is the measurement value (a float). Your task is to sort this list based on the measurement values in ascending order. If two measurements are identical, sort them by their identifiers in lexicographic order. **Task** Implement the `sort_measurements` function that sorts the list of radar measurements as described. **Function Signature** ```python def sort_measurements(measurements: list[tuple[str, float]]) -> list[tuple[str, float]]: ``` # Input * `measurements` (list[tuple[str, float]]): A list of radar measurements, where each measurement is a tuple containing a string identifier and a float value. # Output * A list of tuples sorted based on the measurement values in ascending order. If two measurement values are equal, sort by the string identifiers in lexicographic order. # Constraints * Each identifier is a non-empty string. * Each measurement value is a float. # Example ```python measurements = [ (\\"A123\\", 23.5), (\\"B234\\", 19.0), (\\"C345\\", 23.5), (\\"D456\\", 18.0) ] result = sort_measurements(measurements) print(result) # Output should be [(\\"D456\\", 18.0), (\\"B234\\", 19.0), (\\"A123\\", 23.5), (\\"C345\\", 23.5)] ``` **Notes** * Ensure that the sorting is stable and efficient. * Consider edge cases such as an empty list, or a list with measurements that have the same value but different identifiers.","solution":"def sort_measurements(measurements: list[tuple[str, float]]) -> list[tuple[str, float]]: Sorts the list of radar measurements based on the measurement values in ascending order. If two measurements are identical, sorts them by their identifiers in lexicographic order. Parameters: measurements (list): A list of tuples containing a string identifier and a float value. Returns: list: A sorted list of radar measurements. return sorted(measurements, key=lambda x: (x[1], x[0]))"},{"question":"# Substring Counter Objective: Implement a function that counts the number of distinct substrings of length `k` in a given string. A substring is any contiguous sequence of characters within the string. Function Signature: ```python def count_distinct_substrings(s: str, k: int) -> int: Counts the number of distinct substrings of length k in the given string. Args: s (str): The input string. k (int): The length of the substrings to consider. Returns: int: The number of distinct substrings of length k. Raises: ValueError: If k is greater than the length of the string or if k is non-positive. ``` Input: * `s`: A string composed of lowercase English letters. * `k`: An integer, the length of the substrings to find. Output: * An integer representing the count of distinct substrings of length `k`. Constraints: * The function should handle edge cases such as `k` being zero or greater than the length of `s`. * The string `s` may be empty. * All characters in the string `s` are lowercase English letters. Example: ```python s = \\"abcabc\\" k = 2 # The distinct substrings of length 2 are: \\"ab\\", \\"bc\\", \\"ca\\". # So, the function should return 3. assert count_distinct_substrings(s, k) == 3 s = \\"aaaa\\" k = 1 # The distinct substrings of length 1 are: \\"a\\". # So, the function should return 1. assert count_distinct_substrings(s, k) == 1 s = \\"abcd\\" k = 5 # Since k (5) is greater than the length of the string (4), a ValueError should be raised. try: count_distinct_substrings(s, k) except ValueError as e: assert str(e) == \\"k is greater than the length of the string or is non-positive.\\" ``` Notes: * Ensure the function handles cases where `k` is 0 or greater than the length of `s` by raising a `ValueError`. * The function should return the count of distinct substrings of length `k` efficiently.","solution":"def count_distinct_substrings(s: str, k: int) -> int: Counts the number of distinct substrings of length k in the given string. Args: s (str): The input string. k (int): The length of the substrings to consider. Returns: int: The number of distinct substrings of length k. Raises: ValueError: If k is greater than the length of the string or if k is non-positive. if k <= 0 or k > len(s): raise ValueError(\\"k is greater than the length of the string or is non-positive.\\") substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i + k]) return len(substrings)"},{"question":"# Coding Assessment Question Problem: You are provided with a dataset containing daily temperature recordings from various cities. Your task is to determine the city with the highest average temperature over a specified range of days. Function Signature: ```python def highest_avg_temperature(city_data: dict, start_day: int, end_day: int) -> str: Determine the city with the highest average temperature between the given days. Input Parameters: ----------------- city_data: A dictionary where keys are city names (strings) and values are lists of daily temperatures (floats). start_day: The starting day (inclusive) for the range (0-based index). end_day: The ending day (inclusive) for the range (0-based index). Returns: -------- The name of the city with the highest average temperature in the given range. pass ``` Input: - `city_data` is a dictionary where the keys are the names of cities (strings) and the values are lists of floating-point numbers representing the daily temperature recordings for each city. - `start_day` and `end_day` are integers representing the start and end days of the range respectively. They are zero-based indices. Output: - Return a string indicating the name of the city with the highest average temperature over the specified range of days. Constraints: - Each temperature list in `city_data` contains at least one element. - `end_day` is greater than or equal to `start_day`. - Both `start_day` and `end_day` are valid indices for all temperature lists. Example: ```python city_data = { \\"CityA\\": [70.0, 72.5, 71.0, 69.0, 68.5], \\"CityB\\": [65.0, 67.5, 70.0, 69.5, 71.0], \\"CityC\\": [75.0, 77.5, 76.0, 78.0, 79.5] } highest_avg_temperature(city_data, 1, 3) # Output: \\"CityC\\" highest_avg_temperature(city_data, 0, 4) # Output: \\"CityC\\" ``` You should handle any errors or unusual edge cases by returning an appropriate message, but well-formed inputs will not include out-of-bound indices or empty temperature lists.","solution":"def highest_avg_temperature(city_data: dict, start_day: int, end_day: int) -> str: Determine the city with the highest average temperature between the given days. Input Parameters: ----------------- city_data: A dictionary where keys are city names (strings) and values are lists of daily temperatures (floats). start_day: The starting day (inclusive) for the range (0-based index). end_day: The ending day (inclusive) for the range (0-based index). Returns: -------- The name of the city with the highest average temperature in the given range. highest_avg = float(\'-inf\') highest_city = \\"\\" for city, temperatures in city_data.items(): # Calculate average temperature for the specified range avg_temp = sum(temperatures[start_day:end_day+1]) / (end_day - start_day + 1) if avg_temp > highest_avg: highest_avg = avg_temp highest_city = city return highest_city"},{"question":"# Email Parsing and Content Analysis You are working on an email classification system in a machine learning project. Your task is to process the emails to extract relevant information and detect specific keywords that may be indicative of the email categories (such as spam, promotional, personal, etc.). This involves parsing raw email content, identifying keywords, and categorizing the emails based on detected keywords. # Requirements: 1. **Function Definition**: Implement a function `process_emails(email_list: list, keywords: dict) -> dict` that: - **Parameters**: - `email_list`: List of email contents in plain text. - `keywords`: Dictionary where keys are email categories (e.g., \'spam\', \'promotional\', \'personal\') and values are lists of keywords associated with each category. - **Returns**: - `email_category_dict`: Dictionary where keys are indexes of emails (starting from 0) from `email_list` and values are lists of categories that match keyword criteria. 2. **Input**: - Email contents should be in plain text format. - Keywords dictionary example: ```python { \'spam\': [\'lottery\', \'claim\', \'winner\'], \'promotional\': [\'sale\', \'discount\', \'offer\'], \'personal\': [\'meeting\', \'schedule\', \'appointment\'] } ``` 3. **Output**: - The email classification result, where each email is mapped to one or more categories based on the presence of the specified keywords. - Emails with no matching keywords can be mapped to an empty list. 4. **Constraints**: - Keywords matching should be case-insensitive. - Efficient processing to handle large lists containing thousands of emails. - Handle edge cases such as empty emails or emails with special characters/significant white space. ```python # Define your function here def process_emails(email_list: list, keywords: dict) -> dict: Process email contents and categorize them based on keywords. Parameters: - email_list <type: list>: list of email contents in plain text. - keywords <type: dict>: dictionary with categories as keys and lists of keywords as values. Return: - email_category_dict <type: dict>: dictionary with email index as keys and list of matching categories as values. pass # Implementation here ``` # Scenario: You are on a team developing a smart email client that helps users filter and organize their incoming emails. One of your responsibilities is to implement a feature that scans through each email, detects specific keywords, and categorizes the emails accordingly. This feature is crucial for enabling the email client to sort and prioritize emails, providing a better user experience. Given a list of emails and a dictionary of keywords corresponding to various categories, you need to ensure accurate and efficient email classification. Use the defined function template to implement the solution. Your function will be integrated into a larger system that processes incoming emails in real-time for multiple users.","solution":"def process_emails(email_list: list, keywords: dict) -> dict: Process email contents and categorize them based on keywords. Parameters: - email_list <type: list>: list of email contents in plain text. - keywords <type: dict>: dictionary with categories as keys and lists of keywords as values. Return: - email_category_dict <type: dict>: dictionary with email index as keys and list of matching categories as values. email_category_dict = {} for email_index, email_content in enumerate(email_list): email_categories = [] email_lower = email_content.lower() for category, keyword_list in keywords.items(): for keyword in keyword_list: if keyword.lower() in email_lower: email_categories.append(category) break email_category_dict[email_index] = email_categories return email_category_dict"},{"question":"# Question Context: Develop a function that finds the nth number in the Fibonacci sequence, where `n` is provided as input. This task will test your grasp of algorithms related to dynamic programming or efficient sequence generation. Problem Statement: Define a function `fibonacci(n: int) -> int` that computes the nth Fibonacci number. Function Signature: ```python def fibonacci(n: int) -> int: pass ``` Input: * An integer `n` (0 ≤ `n` ≤ 10^6) - the position in the Fibonacci sequence to compute. Output: * An integer representing the nth Fibonacci number. Constraints: 1. Ensure your solution handles edge cases like `n` being very small (e.g., n = 0) or very large (e.g., n = 10^6). 2. Optimize your solution to work within reasonable time limits for the upper constraint. Performance Requirements: * Your solution should run efficiently for all values of `n` up to 10^6. Example: ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(50) == 12586269025 ``` Additional Context: Consider using efficient techniques to compute Fibonacci numbers, such as memoization, iterative methods, or matrix exponentiation for higher performance.","solution":"def fibonacci(n: int) -> int: Computes the nth Fibonacci number using an iterative approach. if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Scenario A library management system requires a feature to automatically categorize books based on their ISBN number. An ISBN (International Standard Book Number) is either a 10-digit or 13-digit number that uniquely identifies a book. The 10-digit ISBN has a modulo 11 checksum, while the 13-digit ISBN has a modulo 10 checksum. Your task is to create a function that validates whether an ISBN number is correctly formatted and whether its checksum is accurate. # Task Implement a Python function `validate_isbn(isbn: str) -> bool` to verify the integrity of the ISBN number. The function should handle ISBNs with or without dashes. Input * A string `isbn` representing an ISBN number. * This string can include dashes and spaces. Output * Return `True` if the ISBN is valid. * Raise a `ValueError` with the message \\"Invalid ISBN format\\" for incorrectly formatted ISBNs. * Raise a `TypeError` with a message indicating a wrong input type, e.g., \\"Expected string as input, found <type>\\". Constraints * The function should be able to handle ISBNs in the following formats: - 10-digit ISBN: \\"0-306-40615-2\\" - 13-digit ISBN: \\"978-3-16-148410-0\\" * The function should ignore any dashes or spaces and consider the digits only. * Ensure the length of the cleaned ISBN is either 10 or 13 characters. Example Inputs and their corresponding valid/invalid outputs: ```python validate_isbn(\\"0-306-40615-2\\") # Returns: True validate_isbn(\\"0306406152\\") # Returns: True validate_isbn(\\"978-3-16-148410-0\\") # Returns: True validate_isbn(\\"9783161484100\\") # Returns: True validate_isbn(\\"978-3-16-148410-1\\") # Returns: False validate_isbn(\\"0-306-40615-9\\") # Returns: False validate_isbn(\\"ABC-3-16-148410-0\\") # Raises ValueError validate_isbn(9783161484100) # Raises TypeError ``` **Note**: Make sure to handle both valid and error scenarios in your implementation.","solution":"def validate_isbn(isbn: str) -> bool: Validates the ISBN number for correctness. The function returns True for valid ISBNs and False for invalid ones. if not isinstance(isbn, str): raise TypeError(f\\"Expected string as input, found {type(isbn).__name__}\\") clean_isbn = isbn.replace(\\"-\\", \\"\\").replace(\\" \\", \\"\\") if len(clean_isbn) == 10: return validate_isbn_10(clean_isbn) elif len(clean_isbn) == 13: return validate_isbn_13(clean_isbn) else: raise ValueError(\\"Invalid ISBN format\\") def validate_isbn_10(isbn: str) -> bool: Validates 10-digit ISBN using modulo 11 checksum. if not isbn[:-1].isdigit() or (isbn[-1] not in \'0123456789X\'): raise ValueError(\\"Invalid ISBN format\\") total = 0 for i in range(9): total += (i + 1) * int(isbn[i]) checksum_digit = isbn[-1] if checksum_digit == \'X\': total += 10 * 10 else: total += 10 * int(checksum_digit) return total % 11 == 0 def validate_isbn_13(isbn: str) -> bool: Validates 13-digit ISBN using modulo 10 checksum. if not isbn.isdigit(): raise ValueError(\\"Invalid ISBN format\\") total = 0 for i in range(12): digit = int(isbn[i]) if i % 2 == 0: total += digit else: total += 3 * digit checksum_digit = int(isbn[-1]) result = (10 - (total % 10)) % 10 return result == checksum_digit"},{"question":"# Problem: Implement a Circular Queue You are tasked with creating a Python class that simulates a fixed-size circular queue. A circular queue is a linear data structure which operates like a standard queue but wraps around when the end is reached, effectively making it circular. Your implementation should support enqueue, dequeue, and retrieval of the front and rear items efficiently. # Function Signature ```python class CircularQueue: def __init__(self, k: int): def enqueue(self, value: int) -> bool: def dequeue(self) -> bool: def Front(self) -> int: def Rear(self) -> int: def isEmpty(self) -> bool: def isFull(self) -> bool: ``` # Requirements 1. Implement an initializer that takes the size of the queue and initializes it. 2. Provide an `enqueue` method to add an item to the queue. Return `True` if the operation is successful, `False` if the queue is full. 3. Provide a `dequeue` method to remove an item from the queue. Return `True` if the operation is successful, `False` if the queue is empty. 4. Provide a `Front` method that retrieves (but does not remove) the front item of the queue. Return `-1` if the queue is empty. 5. Provide a `Rear` method that retrieves (but does not remove) the rear item of the queue. Return `-1` if the queue is empty. 6. Provide `isEmpty` and `isFull` methods that check if the queue is empty or full, respectively. # Constraints - All input values are integers. - `k`, the size of the queue, is a positive integer greater than 0. # Example ```python >>> circularQueue = CircularQueue(3) >>> circularQueue.enqueue(1) # returns True >>> circularQueue.enqueue(2) # returns True >>> circularQueue.enqueue(3) # returns True >>> circularQueue.enqueue(4) # returns False, queue is full >>> circularQueue.Rear() # returns 3 >>> circularQueue.isFull() # returns True >>> circularQueue.dequeue() # returns True >>> circularQueue.enqueue(4) # returns True >>> circularQueue.Rear() # returns 4 ```","solution":"class CircularQueue: def __init__(self, k: int): Initialize the queue with a size of k. self.size = k self.queue = [None] * k self.head = -1 self.tail = -1 def enqueue(self, value: int) -> bool: Insert an element into the circular queue. Return True if the operation is successful. if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def dequeue(self) -> bool: Delete an element from the circular queue. Return True if the operation is successful. if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.size return True def Front(self) -> int: Get the front item from the queue. if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: Get the last item from the queue. if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: Checks whether the circular queue is empty or not. return self.head == -1 def isFull(self) -> bool: Checks whether the circular queue is full or not. return (self.tail + 1) % self.size == self.head"},{"question":"# Problem Overview You are given a list of integers representing the heights of students in a single row. Initially, the students are standing in a random order. You need to write a function that rearranges the students such that no two adjacent students have the same height. If it is not possible to rearrange, the function should return a message indicating that it is not possible. # Function Signature ```python def rearrange_students(heights: list[int]) -> str: pass ``` # Input * `heights`: A list of integers representing the heights of students. # Output A string representing the rearranged list of student heights such that no two adjacent students have the same height. If rearranging is not possible, return `\\"Not possible to rearrange\\"`. # Constraints 1. 0 <= len(heights) <= 10^5 2. Each height in `heights` is a non-negative integer within the range of standard integer values. # Examples ```python # Example 1 heights = [1, 2, 2, 3] print(rearrange_students(heights)) # Expected Output: \\"[2, 1, 3, 2]\\" or another valid arrangement # Example 2 heights = [1, 1, 1, 2] print(rearrange_students(heights)) # Expected Output: \\"Not possible to rearrange\\" # Example 3 heights = [4, 5, 5, 5, 6, 6] print(rearrange_students(heights)) # Expected Output: \\"[5, 4, 5, 6, 5, 6]\\" or another valid arrangement # Example 4 heights = [1] print(rearrange_students(heights)) # Expected Output: \\"[1]\\" ``` # Notes Ensure your implementation handles edge cases effectively, such as lists with only one element or lists where rearrangement is not possible due to excessive duplicate heights. The solution should aim for optimal performance to handle the upper constraint efficiently.","solution":"from collections import Counter import heapq def rearrange_students(heights: list[int]) -> str: if not heights: return \\"[]\\" # Get the frequency count of each height height_count = Counter(heights) # Use a max-heap to store heights by their count max_heap = [(-count, height) for height, count in height_count.items()] heapq.heapify(max_heap) prev_count, prev_height = 0, None result = [] while max_heap or prev_count < 0: if max_heap: count, height = heapq.heappop(max_heap) result.append(height) # Since we used one instance of height, we increase count towards zero count += 1 if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_height)) prev_count, prev_height = count, height else: return \\"Not possible to rearrange\\" return str(result)"},{"question":"# Question Problem Statement You are tasked with developing a library system to manage books and loans. Each book in the library has a unique ISBN, title, author, and publication year. Users can borrow books, and the system needs to keep track of books currently on loan. Write a function that verifies the eligibility of borrowing a new book for a user based on their borrowing history and book\'s details. Function Signatures ```python def can_borrow(books: list, loans: dict, user: str, isbn: str, max_loans_per_user: int, publication_year_limit: int) -> bool: # Your code here ``` Definitions - `books`: A list of dictionaries where each dictionary contains details of a book (\'isbn\', \'title\', \'author\', \'year\'). - `loans`: A dictionary where keys are user IDs and values are lists of loaned book ISBNs. - `user`: The user ID for verification. - `isbn`: The ISBN of the book the user wants to borrow. - `max_loans_per_user`: An integer representing the maximum books a user can borrow at once. - `publication_year_limit`: The oldest publication year allowed for borrowing. Output The function should return `True` if the user is eligible to borrow the book, and `False` otherwise. Constraints - A user is only allowed to borrow up to `max_loans_per_user` books at a time. - The book must be published no earlier than the specified `publication_year_limit`. - The book must not be already on loan to another user. Example Usage ```python books = [ {\'isbn\': \'1234567890\', \'title\': \'Python Programming\', \'author\': \'John Smith\', \'year\': 2020}, {\'isbn\': \'0987654321\', \'title\': \'Machine Learning\', \'author\': \'Jane Doe\', \'year\': 2018}, {\'isbn\': \'1122334455\', \'title\': \'Data Science\', \'author\': \'Alice Johnson\', \'year\': 2016} ] loans = { \'user1\': [\'1234567890\'], \'user2\': [] } user = \'user2\' isbn = \'0987654321\' max_loans_per_user = 3 publication_year_limit = 2015 print(can_borrow(books, loans, user, isbn, max_loans_per_user, publication_year_limit)) # Expected output: True ``` Notes - Ensure that your function handles cases where the user has already borrowed the maximum allowed number of books. - Verify that the book\'s publication year meets the specified limit. - Check that the requested book is not already borrowed by another user. - Consider possible edge cases, such as invalid ISBN or user not present in the loans dictionary.","solution":"def can_borrow(books, loans, user, isbn, max_loans_per_user, publication_year_limit): Determine if a user can borrow a specific book given the library rules. Args: books (list): list of dictionaries containing book details. loans (dict): dictionary with user IDs as keys and lists of loaned book ISBNs as values. user (str): user ID to be verified for borrowing. isbn (str): ISBN of the book the user wants to borrow. max_loans_per_user (int): max books a user can borrow at once. publication_year_limit (int): oldest year of publication allowed for borrowing. Returns: bool: True if user can borrow the book, False otherwise. # Check user\'s current loans user_loans = loans.get(user, []) if len(user_loans) >= max_loans_per_user: return False # Check if the book exists and meets the publication year limit book_to_borrow = None for book in books: if book[\'isbn\'] == isbn: book_to_borrow = book break if not book_to_borrow: return False if book_to_borrow[\'year\'] < publication_year_limit: return False # Ensure the book is not already on loan to another user for loaned_isbns in loans.values(): if isbn in loaned_isbns: return False # If all checks pass, the user can borrow the book return True"},{"question":"# Scenario: You are designing a system to manage a collection of files in a directory. Each file has various attributes such as name, size, and creation date. Your goal is to create a class that can manage these files and perform various operations efficiently. # Task: Implement a class `Directory` that manages files and provides efficient operations for adding files, retrieving information about the largest file, removing a file by name, and getting all file names sorted by their creation date. # Requirements: - You should use appropriate data structures to ensure efficient operations. - Each file has a unique name which is a string, a size in bytes which is an integer, and a creation date which you can represent by an integer for simplicity. # Function Specifications: 1. **add_file(name: str, size: int, creation_date: int) -> None**: Adds a file with the specified `name`, `size`, and `creation_date`. 2. **get_largest_file() -> tuple | None**: Returns a tuple `(name, size, creation_date)` of the largest file by size if present, else `None`. 3. **remove_file(name: str) -> bool**: Removes the file with the specified `name`. Returns `True` if the file was successfully removed, otherwise returns `False`. 4. **get_files_sorted_by_date() -> list**: Returns a list of file names sorted by their creation date. # Constraints: - File names are non-empty strings of up to 100 characters. - `1 <= size, creation_date <= 10^9` - The total number of files will not exceed 10^5. # Example: ```python directory = Directory() directory.add_file(\\"file1.txt\\", 500, 20220101) directory.add_file(\\"file2.txt\\", 1500, 20220102) directory.add_file(\\"file3.txt\\", 1000, 20220101) print(directory.get_largest_file()) # Output: (\\"file2.txt\\", 1500, 20220102) print(directory.remove_file(\\"file1.txt\\")) # Output: True print(directory.get_largest_file()) # Output: (\\"file2.txt\\", 1500, 20220102) print(directory.get_files_sorted_by_date()) # Output: [\\"file3.txt\\", \\"file2.txt\\"] ``` # Note: - Ensure you handle edge cases such as attempting to retrieve or remove a file from an empty directory. - You may use simple Python data structures or library functions to implement the required operations efficiently.","solution":"class Directory: def __init__(self): self.files = {} self.sorted_files_by_date = [] def add_file(self, name: str, size: int, creation_date: int) -> None: self.files[name] = (size, creation_date) self.sorted_files_by_date.append((creation_date, name)) self.sorted_files_by_date.sort() def get_largest_file(self) -> tuple | None: if not self.files: return None largest_file = max(self.files.items(), key=lambda file: file[1][0]) return largest_file[0], largest_file[1][0], largest_file[1][1] def remove_file(self, name: str) -> bool: if name not in self.files: return False self.files.pop(name) self.sorted_files_by_date = [entry for entry in self.sorted_files_by_date if entry[1] != name] return True def get_files_sorted_by_date(self) -> list: return [entry[1] for entry in self.sorted_files_by_date]"},{"question":"# Prime Factorization Coding Challenge Scenario Prime factorization is the process of determining the prime numbers that multiply together to give a specified integer. It is commonly used in cryptography, number theory, and various algorithms where decomposing a number into its prime constituents is essential. Function Signature ```python def prime_factorization(n: int) -> list[int]: n is an integer greater than 1. Your function should return a list of prime factors in ascending order. ``` Input * **n**: An integer greater than 1, for which prime factorization is to be performed. Output * A list of integers representing the prime factors of n in ascending order. Constraints 1. The integer **n** will be in the range [2, 10^8]. 2. Ensure efficiency in the factorization process. 3. Handle edge cases such as when **n** is a prime number or a power of a prime number. Example ```python >>> prime_factorization(28) [2, 2, 7] >>> prime_factorization(99) [3, 3, 11] >>> prime_factorization(13) [13] ``` Requirements 1. Implement an efficient algorithm to perform prime factorization. 2. Consider using trial division or an optimized algorithm such as Pollard\'s rho for large numbers. 3. Ensure the function handles large values of **n** within the given constraints. 4. Optimize for minimal computational complexity and memory usage.","solution":"def prime_factorization(n: int) -> list[int]: Returns the prime factors of an integer n in ascending order. factors = [] # Handle factorization of even numbers first while n % 2 == 0: factors.append(2) n //= 2 # Handle factorization of odd numbers starting from 3 factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # If n is still greater than 1, then it is a prime number if n > 1: factors.append(n) return factors"},{"question":"# Question You are tasked with creating a class to manage a dynamic leaderboard for an ongoing game competition. The leaderboard should support adding new players, updating their scores, and retrieving the top N players based on their scores. The leaderboard must efficiently handle the following operations: 1. **Add a new player**: Insert a new player with an initial score. 2. **Update player score**: Update the score of an existing player. 3. **Retrieve top N players**: Get the list of top N players based on their scores. If two players have the same score, they should be ranked by the time they were added to the leaderboard (the earlier player ranks higher). Implement the `Leaderboard` class, including the following methods: 1. `add_player(self, player_id: str, score: int) -> None`: Adds a new player with the specified score to the leaderboard. 2. `update_score(self, player_id: str, score: int) -> None`: Updates the score of the specified player in the leaderboard. 3. `top_n(self, n: int) -> list[tuple[str, int]]`: Retrieves the top N players from the leaderboard in descending order of their scores, with ties resolved by insertion order. # Function Specifications: Leaderboard Class - **Method**: `add_player(self, player_id: str, score: int) -> None` - **Description**: Adds a new player with the specified score to the leaderboard. - **Input**: - `player_id` (a unique string identifier for the player) - `score` (an integer representing the initial score of the player) - **Output**: None - **Method**: `update_score(self, player_id: str, score: int) -> None` - **Description**: Updates the score of the specified player in the leaderboard. - **Input**: - `player_id` (a unique string identifier for the player) - `score` (an integer representing the new score of the player that will replace the old score) - **Output**: None - **Method**: `top_n(self, n: int) -> list[tuple[str, int]]` - **Description**: Retrieves the top N players from the leaderboard. - **Input**: - `n` (an integer representing the number of top players to retrieve) - **Output**: A list of tuples, where each tuple contains a player\'s ID and score, representing the top N players in descending order of scores. # Example Usage ```python class Leaderboard: def __init__(self) -> None: self.board = {} def add_player(self, player_id: str, score: int) -> None: if player_id not in self.board: self.board[player_id] = score def update_score(self, player_id: str, score: int) -> None: if player_id in self.board: self.board[player_id] = score def top_n(self, n: int) -> list[tuple[str, int]]: return sorted(self.board.items(), key=lambda x: (-x[1], list(self.board.keys()).index(x[0])))[:n] # Example Usage leaderboard = Leaderboard() leaderboard.add_player(\\"Alice\\", 50) leaderboard.add_player(\\"Bob\\", 30) leaderboard.add_player(\\"Charlie\\", 40) leaderboard.update_score(\\"Alice\\", 60) print(leaderboard.top_n(2)) # Output: [(\'Alice\', 60), (\'Charlie\', 40)] ``` # Additional Tests 1. Add a player and retrieve the top 1. 2. Update a player\'s score and ensure they move up the leaderboard. 3. Add multiple players with the same score and verify the insertion order ranking. 4. Retrieve more players than are on the leaderboard. # Example Test Cases ```python # Add players and update their scores leaderboard = Leaderboard() leaderboard.add_player(\\"Alice\\", 50) leaderboard.add_player(\\"Bob\\", 30) leaderboard.add_player(\\"Charlie\\", 40) leaderboard.update_score(\\"Alice\\", 60) # Retrieve top players assert leaderboard.top_n(2) == [(\\"Alice\\", 60), (\\"Charlie\\", 40)] # Alice and Charlie should be top 2 assert leaderboard.top_n(1) == [(\\"Alice\\", 60)] # Only Alice should be at the top with updated score # Add players with the same score leaderboard.add_player(\\"David\\", 40) assert leaderboard.top_n(3) == [(\\"Alice\\", 60), (\\"Charlie\\", 40), (\\"David\\", 40)] # Charlie should rank higher than David # Retrieve more players than are present assert leaderboard.top_n(5) == [(\\"Alice\\", 60), (\\"Charlie\\", 40), (\\"David\\", 40), (\\"Bob\\", 30)] # All players should be listed ```","solution":"class Leaderboard: def __init__(self): self.board = {} def add_player(self, player_id: str, score: int) -> None: if player_id not in self.board: self.board[player_id] = score def update_score(self, player_id: str, score: int) -> None: if player_id in self.board: self.board[player_id] = score def top_n(self, n: int) -> list[tuple[str, int]]: return sorted(self.board.items(), key=lambda x: (-x[1], list(self.board.keys()).index(x[0])))[:n]"},{"question":"# Network Packet Routing Problem Description You are tasked with designing a function to simulate packet routing in a simple network. The network is represented by a list of edges where each edge connects two nodes and has a specific data transfer limit (bandwidth). Your goal is to determine if there is a path from a starting node to a destination node that can handle a packet of a given size. Function Signature Write a Python function `can_route_packet(edges: List[Tuple[int, int, int]], start: int, end: int, packet_size: int) -> bool` that takes four parameters: - `edges`: A list of tuples, where each tuple `(u, v, b)` represents an edge with nodes `u` and `v` and bandwidth `b`. - `start`: An integer representing the starting node of the packet. - `end`: An integer representing the destination node of the packet. - `packet_size`: An integer representing the size of the packet to be transmitted. Return The function should return a boolean: - `True` if there exists a path from `start` to `end` where all edges on the path can handle the `packet_size`. - `False` otherwise. Constraints - The number of nodes in the network `N` will be between 2 and 100. - The number of edges `E` will be between 1 and 200. - The packet size `S` will be between 1 and 100. Example ```python def can_route_packet(edges: List[Tuple[int, int, int]], start: int, end: int, packet_size: int) -> bool: # Your code here # Example Test Cases edges1 = [(0, 1, 10), (1, 2, 5), (0, 2, 15), (2, 3, 10)] start1, end1, packet_size1 = 0, 3, 5 print(can_route_packet(edges1, start1, end1, packet_size1)) # Output: True edges2 = [(0, 1, 10), (1, 2, 5), (0, 2, 15), (2, 3, 10)] start2, end2, packet_size2 = 0, 3, 20 print(can_route_packet(edges2, start2, end2, packet_size2)) # Output: False ``` In these examples, the first network can route a packet of size 5 from node 0 to node 3, but it cannot route a packet of size 20. Requirements - Implement the `can_route_packet` function to determine if a path exists that can handle the packet size. - Ensure optimal performance within the given constraints.","solution":"from typing import List, Tuple from collections import deque, defaultdict def can_route_packet(edges: List[Tuple[int, int, int]], start: int, end: int, packet_size: int) -> bool: Determine if there is a path from start to end where all edges on the path can handle the packet_size. graph = defaultdict(list) for u, v, b in edges: if b >= packet_size: graph[u].append(v) graph[v].append(u) queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == end: return True visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"# Coding Challenge: Implementing Priority Aging in Scheduling Algorithm As an operating system developer, you need to maintain process fairness in a priority scheduling system. Specifically, you should implement a mechanism that prevents starvation by increasing the priority of waiting processes over time (Priority Aging). **Objective**: Enhance a priority-based scheduling system by implementing Priority Aging. This method gradually increases the priority of waiting processes to ensure they eventually get CPU time. # Task **Method Signature**: ```python def aging_scheduling( processes: list[dict], aging_rate: int ) -> list[int]: pass ``` **Inputs**: 1. `processes (list[dict])`: A list of dictionaries where each dictionary represents a process with keys \'pid\', \'burst_time\', and \'priority\'. - `pid (int)`: Process ID (unique for each process). - `burst_time (int)`: The time required for the process to complete. - `priority (int)`: The initial priority of the process (lower value means higher priority). 2. `aging_rate (int)`: The rate at which the priority of each waiting process increases per unit of time. **Outputs**: - **Returns**: A list of process IDs (pids) in the order they would be scheduled. **Constraints**: - Each process can only run to completion once it starts. - Priorities are non-negative integers. - No two processes have the same initial priority. - Assume the CPU scheduling starts at time 0. # Example Given a list of processes: ```python processes = [ {\\"pid\\": 1, \\"burst_time\\": 6, \\"priority\\": 10}, {\\"pid\\": 2, \\"burst_time\\": 8, \\"priority\\": 5}, {\\"pid\\": 3, \\"burst_time\\": 7, \\"priority\\": 3}, {\\"pid\\": 4, \\"burst_time\\": 3, \\"priority\\": 1} ] aging_rate = 2 ``` The method should return a list `[4, 2, 3, 1]`, representing the order in which processes are scheduled based on the priority aging mechanism. **Implementation Requirements**: - Prioritize processes based on their initial priority. - Increase the priority of waiting processes at the defined aging rate. - Ensure no process suffers indefinite waiting (i.e., no starvation). - Consider the waiting time for each process before it starts execution to adjust priorities. - Provide comprehensive test cases that cover various initial priority configurations and aging rates. Use the Priority Aging mechanism to ensure fairness in the schedule, accounting for different burst times and initial priorities.","solution":"def aging_scheduling(processes: list, aging_rate: int) -> list[int]: time = 0 schedule_order = [] # Sort processes by initial priority (lower value means higher priority) processes.sort(key=lambda p: p[\'priority\']) while processes: # Sort processes by current priority processes.sort(key=lambda p: p[\'priority\']) # Get the process with the highest priority (lowest value) current_process = processes.pop(0) # Schedule the current process schedule_order.append(current_process[\'pid\']) # Advance time by the burst time of the current process time += current_process[\'burst_time\'] # Update priorities of waiting processes for process in processes: process[\'priority\'] -= aging_rate * current_process[\'burst_time\'] return schedule_order"},{"question":"# Prime Sum Challenge In this challenge, you will be required to find two prime numbers that sum up to a given integer. This problem is rooted in the famous Goldbach Conjecture which states that every even integer greater than 2 can be expressed as the sum of two prime numbers. However, for this challenge, we\'ll consider both even and odd integers. Scenario Imagine you are writing a piece of software for an educational math tool. The tool should help students understand prime numbers and their properties by finding prime pairs that sum up to a given number. Function Signature ```python def prime_pair_sum(num: int) -> tuple: This function receives a single integer and finds two prime numbers that sum up to this integer, returning them as a tuple. Args: num (int): An integer to be expressed as the sum of two prime numbers. Returns: tuple: A tuple of two integers which are the prime numbers summing up to num. Raises: ValueError: if no such pair of prime numbers exists. ``` Input - A single integer `num` which is greater than or equal to 4. Output - A tuple containing two prime numbers that add up to the given integer `num`. Constraints - You may assume that `num` is at least 4. - Handle both even and odd integers correctly. - If there are multiple pairs of prime numbers satisfying the condition, you may return any one pair. - If no valid pair exists, raise a `ValueError`. Examples ```python >>> prime_pair_sum(4) (2, 2) >>> prime_pair_sum(10) (3, 7) >>> prime_pair_sum(7) (2, 5) >>> prime_pair_sum(18) (5, 13) >>> prime_pair_sum(11) (5, 6) # Again, if no pair exists, this should raise ValueError or similar. ``` Requirements - Ensure the function runs efficiently. - Utilize a method to check for prime numbers and possibly a sieve algorithm for efficiency. - Consider edge cases and ensure the function handles them properly. Tips - Create a helper function to check if a number is prime. - Consider using a Sieve of Eratosthenes to generate prime numbers up to `num`. Implement the function `prime_pair_sum` and test it with appropriate inputs.","solution":"import math def is_prime(n: int) -> bool: if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return False return True def prime_pair_sum(num: int) -> tuple: This function receives a single integer and finds two prime numbers that sum up to this integer, returning them as a tuple. Args: num (int): An integer to be expressed as the sum of two prime numbers. Returns: tuple: A tuple of two integers which are the prime numbers summing up to num. Raises: ValueError: if no such pair of prime numbers exists. for i in range(2, num): if is_prime(i) and is_prime(num - i): return (i, num - i) raise ValueError(\\"No prime pair sums to the given number.\\")"},{"question":"# Problem Statement Create a function that identifies whether a given 6x6 grid contains a British flag pattern. A British flag pattern is formed by a cross (\'+\' sign) of \'X\' marks intersecting at the center of the grid, splitting it into four quadrants. In this problem, you will be given a 6x6 grid containing characters \'X\' and \'.\', representing filled and empty cells, respectively. Your task is to check if this grid contains a British flag pattern. # Function Signature ```python def is_british_flag(grid: List[List[str]]) -> bool: pass ``` # Input * `grid (List[List[str]])`: A 6x6 list of lists containing characters \'X\' and \'.\', representing filled and empty cells, respectively. # Output * Returns a boolean indicating whether the grid contains a British flag pattern. # Constraints * The grid will always be a 6x6 matrix. * Each cell in the grid will be either \'X\' or \'.\'. # Example ```python assert is_british_flag([ [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'], [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'], [\'X\', \'X\', \'X\', \'X\', \'X\', \'X\'], [\'X\', \'X\', \'X\', \'X\', \'X\', \'X\'], [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'], [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'] ]) == True assert is_british_flag([ [\'.\', \'.\', \'.\', \'X\', \'.\', \'.\'], [\'.\', \'X\', \'X\', \'X\', \'.\', \'.\'], [\'X\', \'X\', \'X\', \'X\', \'X\', \'X\'], [\'X\', \'X\', \'X\', \'X\', \'X\', \'X\'], [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'], [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'] ]) == False assert is_british_flag([ [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'], [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'], [\'X\', \'X\', \'.\', \'.\', \'X\', \'X\'], [\'X\', \'X\', \'.\', \'.\', \'X\', \'X\'], [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'], [\'.\', \'.\', \'X\', \'X\', \'.\', \'.\'] ]) == False ```","solution":"from typing import List def is_british_flag(grid: List[List[str]]) -> bool: n = 6 # Check the horizontal and vertical lines for i in range(n): if (grid[i][2] != \'X\' or grid[i][3] != \'X\' or grid[2][i] != \'X\' or grid[3][i] != \'X\'): return False # Confirm all other positions are not \'X\' for i in range(n): for j in range(n): if i not in [2, 3] and j not in [2, 3] and grid[i][j] == \'X\': return False return True"},{"question":"# Context: An e-commerce company tracks the sales of its products in a large array. They want to know how many of their products have sold at least a certain number of units. Your task is to write a function that counts the number of products that have met or exceeded a target sale figure. # Problem Statement: Write a function `count_products_meeting_sales_target(sales: List[int], target: int) -> int` that takes a list of integers representing the sales of different products and an integer target. The function should return the number of products that have sold at least the target number of units. Input and Output Formats: * **Input**: * `sales`: A list of non-negative integers where each integer represents the number of units sold for a product. * `target`: A non-negative integer representing the sales target. * **Output**: An integer representing the count of products that have sold equal to or more than the target. Constraints and Limitations: * The sales list can contain up to 100,000 integers. * Each element in the sales list and the target is a non-negative integer. Example: ```python >>> count_products_meeting_sales_target([10, 20, 30, 15, 5, 0, 50], 15) 3 >>> count_products_meeting_sales_target([5, 3, 8, 12, 25], 10) 2 >>> count_products_meeting_sales_target([0, 1, 2, 3], 4) 0 >>> count_products_meeting_sales_target([], 5) 0 >>> count_products_meeting_sales_target([7, 7, 7, 7, 7], 7) 5 ``` # Performance Requirements: * The solution should be efficient with a time complexity of O(n), where n is the number of elements in the sales list.","solution":"from typing import List def count_products_meeting_sales_target(sales: List[int], target: int) -> int: Counts the number of products whose sales are at least the target number of units. Parameters: sales (List[int]): A list of integers where each integer represents units sold for a product. target (int): An integer representing the sales target. Returns: int: The count of products that have sold at least the target number of units. count = 0 for sale in sales: if sale >= target: count += 1 return count"},{"question":"# Coding Assessment Question **Rotate String Left** In this task, you will write a function that rotates a given string to the left by a specified number of characters. The function should be efficient and handle long strings. Function Signature: ```python def rotate_string_left(s: str, k: int) -> str: ``` Input: * `s` (str): The string to be rotated. * `k` (int): The number of characters to rotate the string to the left by. Output: * `str`: The rotated string. Constraints: * 1 <= len(`s`) <= 10^6 * 0 <= `k` < 10^6 Example: ```python >>> rotate_string_left(\\"abcdef\\", 2) \\"cdefab\\" >>> rotate_string_left(\\"hijklmnop\\", 4) \\"lmnophijk\\" >>> rotate_string_left(\\"rotation\\", 8) \\"rotation\\" >>> rotate_string_left(\\"rotation\\", 9) \\"otationr\\" ``` Requirements: 1. Consider edge cases such as when `k` is larger than the length of the string. 2. Ensure that the rotation operation is performed efficiently, even for long strings. 3. Be mindful of how the rotation wraps around, making use of string slicing. Optimal Solution Hint: You can utilize Python\'s slicing capabilities to achieve the required rotation in an optimal manner.","solution":"def rotate_string_left(s: str, k: int) -> str: Rotates the given string \'s\' to the left by \'k\' characters. n = len(s) k = k % n # In case k is larger than the length of the string return s[k:] + s[:k]"},{"question":"# Coding Challenge: Financial Transactions Record You are given a list of bank transactions, where each transaction has attributes: `transaction_id`, `account_id`, `transaction_type`, and `amount`. Your task is to implement a function that processes these transactions and computes the net balance for each account. The transactions can be of two types: `debit` and `credit`. - A `debit` transaction decreases the account balance. - A `credit` transaction increases the account balance. # Function Signature ```python def compute_balances(transactions: list[list[any]]) -> dict: pass ``` # Input - `transactions`: A list of lists, where each sublist represents a transaction\'s attributes `[transaction_id, account_id, transaction_type, amount]`. For example: ```python [ [1, 1001, \'debit\', 20], [2, 1002, \'credit\', 100], [3, 1001, \'credit\', 50], [4, 1003, \'debit\', 60], [5, 1002, \'debit\', 30] ] ``` # Output - A dictionary where the keys are account_ids and the values are the net balances after processing all transactions. For example: ```python { 1001: 30, # 50 (credit) - 20 (debit) = 30 1002: 70, # 100 (credit) - 30 (debit) = 70 1003: -60 # -60 (debit) } ``` # Constraints - 1 ≤ len(transactions) ≤ 10^3 - Each transaction_id is unique. - Each transaction_type is either \'debit\' or \'credit\'. - Each amount is a positive integer. # Requirements - Implement and validate the `compute_balances` function. - Ensure appropriate handling of edge cases (e.g., transactions for new accounts). - The implementation must work within the specified constraints efficiently. # Example ```python transactions = [ [1, 1001, \'debit\', 20], [2, 1002, \'credit\', 100], [3, 1001, \'credit\', 50], [4, 1003, \'debit\', 60], [5, 1002, \'debit\', 30] ] print(compute_balances(transactions)) # Output: { # 1001: 30, # 1002: 70, # 1003: -60 # } ```","solution":"def compute_balances(transactions): Compute the net balance for each account based on the given transactions. :param transactions: List of lists where each sublist contains [transaction_id, account_id, transaction_type, amount]. :return: Dictionary with account_id as keys and net balance as values. balances = {} for transaction in transactions: transaction_id, account_id, transaction_type, amount = transaction if account_id not in balances: balances[account_id] = 0 if transaction_type == \'debit\': balances[account_id] -= amount elif transaction_type == \'credit\': balances[account_id] += amount return balances"},{"question":"# Problem Scenario You are tasked with implementing a basic text editor feature that includes functionality for undo and redo operations. The editor should keep track of a sequence of operations and allow users to revert or reapply those operations as needed. # Task: Implement a class `TextEditor` that supports adding text, undoing the last operation, and redoing the previously undone operation. The editor should also return the current state of the text. # Key Requirements: 1. Support for adding new text to the editor. 2. Support for undoing the last text addition. 3. Support for redoing the previously undone text addition. 4. Retrieving the current state of the text. # Specifications: 1. **Class**: `TextEditor` 2. **Methods**: * `__init__(self)`: Initializes the text editor with an empty text. * `add_text(self, text: str)`: Adds the given text to the editor. * `undo(self)`: Undoes the last text addition. If no operation to undo, do nothing. * `redo(self)`: Redoes the last undone text addition. If no operation to redo, do nothing. * `get_text(self) -> str`: Returns the current state of the text. 3. **Input/Output**: * The `add_text` method takes a single string `text` and appends it to the current text. * The `undo` method reverts the last added text. * The `redo` method re-applies the last undone text addition. * The `get_text` method returns the current text as a string. # Constraints: * Each operation of adding text will be a string of length between `1` and `100`. * Only alphabetic characters and spaces are allowed in the text. # Example: ```python # Example Usage editor = TextEditor() editor.add_text(\\"Hello \\") editor.add_text(\\"World\\") current_text = editor.get_text() # returns \\"Hello World\\" editor.undo() current_text = editor.get_text() # returns \\"Hello \\" editor.redo() current_text = editor.get_text() # returns \\"Hello World\\" ``` # Notes: * Ensure that `undo` and `redo` operations do not affect the original sequence of operations beyond what is logically warranted. * Keep track of a sequence of operations to support undo and redo efficiently. * The `get_text` method should always reflect the current state of the text based on the operations performed.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] # To keep track of added texts self.undo_stack = [] # To keep track of undos def add_text(self, text: str): self.history.append(text) self.undo_stack.clear() # Clear redo stack because new text alters the sequence self.text += text def undo(self): if self.history: last_text = self.history.pop() self.undo_stack.append(last_text) self.text = self.text[:-len(last_text)] def redo(self): if self.undo_stack: text_to_redo = self.undo_stack.pop() self.history.append(text_to_redo) self.text += text_to_redo def get_text(self) -> str: return self.text"},{"question":"# Question: Hash Map Implementations and Operations You are tasked with implementing a simplified version of a hash map (similar to Python\'s dictionary) from scratch. Your hash map should support the following operations: 1. **Put**: Implement a method `put(self, key: Any, value: Any) -> None` to insert a new key-value pair into the hash map. If the key already exists in the hash map, update its value. 2. **Get**: Implement a method `get(self, key: Any) -> Any` to retrieve the value associated with the specified key. If the key does not exist, return None. 3. **Delete**: Implement a method `delete(self, key: Any) -> None` to remove the key-value pair from the hash map if the key exists. If the key does not exist, perform no operation. 4. **Contains**: Implement a method `contains(self, key: Any) -> bool` to check if the key exists in the hash map. Return True if the key exists, otherwise return False. 5. **Size**: Implement a method `size(self) -> int` to return the number of key-value pairs currently stored in the hash map. Input: - The provided `HashMap` class and the following methods to be implemented: - `put(self, key: Any, value: Any) -> None` - `get(self, key: Any) -> Any` - `delete(self, key: Any) -> None` - `contains(self, key: Any) -> bool` - `size(self) -> int` Output: - For `put()`, None. - For `get()`, return the value associated with the key or None if the key does not exist. - For `delete()`, None. - For `contains()`, return True if the key exists, otherwise False. - For `size()`, return the integer count of key-value pairs in the hash map. Constraints: - The keys can be of any data type (integers, strings, etc.). - The values can be of any data type. - Expected average time complexity for all operations should be O(1). Example: ```python # Example usage: hash_map = HashMap() # Put hash_map.put(\\"name\\", \\"Alice\\") hash_map.put(\\"age\\", 30) hash_map.put(\\"city\\", \\"NY\\") # Size print(hash_map.size()) # Output: 3 # Get print(hash_map.get(\\"name\\")) # Output: Alice print(hash_map.get(\\"country\\")) # Output: None # Contains print(hash_map.contains(\\"age\\")) # Output: True print(hash_map.contains(\\"salary\\")) # Output: False # Delete hash_map.delete(\\"city\\") print(hash_map.size()) # Output: 2 print(hash_map.get(\\"city\\")) # Output: None ```","solution":"class HashMap: def __init__(self): self.map = {} def put(self, key, value): self.map[key] = value def get(self, key): return self.map.get(key) def delete(self, key): if key in self.map: del self.map[key] def contains(self, key): return key in self.map def size(self): return len(self.map)"},{"question":"# Coding Question: Intersection Point of Two Lines You are tasked with writing a function to find the intersection point of two lines in a 2D plane. Each line is defined by two points. Implement a function `find_intersection_point(line1: Tuple[Tuple[float, float], Tuple[float, float]], line2: Tuple[Tuple[float, float], Tuple[float, float]]) -> Tuple[float, float]` that calculates the intersection point of the two lines, if it exists. Input/Output Specifications * **Input**: Two tuples, each containing two points. Each point is represented by a tuple of two floating-point numbers, representing the coordinates of the point. * **Output**: A tuple of two floating-point numbers representing the coordinates of the intersection point. If the lines do not intersect or are coincident, return `None`. Constraints and Considerations * The function should handle cases when the lines are parallel or coincident and return `None` in such cases. * Handle numerical precision issues appropriately to avoid false intersection detection due to floating-point arithmetic errors. Example ```python >>> find_intersection_point(((0, 0), (4, 4)), ((0, 4), (4, 0))) (2.0, 2.0) >>> find_intersection_point(((1, 1), (2, 2)), ((3, 3), (4, 4))) None >>> find_intersection_point(((0, 0), (0, 1)), ((1, 0), (1, 1))) None ``` Implementation Hint To find the intersection point (x, y) of two lines defined by points (x1, y1), (x2, y2) and (x3, y3), (x4, y4), you can use the following determinant approach: [ denominator = (x1 - x2) times (y3 - y4) - (y1 - y2) times (x3 - x4) ] If the denominator is zero, the lines are parallel or coincident. Otherwise, the intersection point (x, y) can be found using: [ x = frac{(x1y2 - y1x2)(x3 - x4) - (x1 - x2)(x3y4 - y3x4)}{denominator} ] [ y = frac{(x1y2 - y1x2)(y3 - y4) - (y1 - y2)(x3y4 - y3x4)}{denominator} ]","solution":"def find_intersection_point(line1, line2): Finds the intersection point of two lines in a 2D plane. Args: line1 (tuple[tuple[float, float], tuple[float, float]]): Two points defining the first line. line2 (tuple[tuple[float, float], tuple[float, float]]): Two points defining the second line. Returns: tuple[float, float] or None: The coordinates of the intersection point or None if the lines do not intersect. (x1, y1), (x2, y2) = line1 (x3, y3), (x4, y4) = line2 denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4) if denominator == 0: # Lines are parallel or coincident return None # Calculating the intersection point x = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / denominator y = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / denominator return (x, y)"},{"question":"# Problem: Simplifying Online Course Management Context: You are developing a simple management system for an online course platform. The system allows instructors to create courses and enroll students. Instructors can also compute the average grade of students in a course and find students who have grades below the average. Task: 1. Implement functions to handle course creation, student enrollment, grading, and average grade calculation. 2. Create an additional function to identify students who are performing below the average grade. Requirements: * Ensure that the system can handle multiple courses and students efficiently. * Properly manage the enrollment process to avoid duplicate enrollments. * Implement error handling for scenarios like invalid course or student operations. * The functions should be designed to scale with increasing numbers of courses and students. Function Signatures: ```python class Course: def __init__(self, course_name: str): pass def enroll_student(self, student_name: str): pass def assign_grade(self, student_name: str, grade: float): pass def calculate_average_grade(self) -> float: pass def students_below_average(self) -> List[str]: pass ``` Input/Output: * `Course` - A class that represents a course. It has methods to enroll students (`enroll_student`), assign grades (`assign_grade`), calculate the average grade (`calculate_average_grade`), and find students performing below average (`students_below_average`). * `course_name` - The name of the course, a string. * `student_name` - The name of a student, a string. * `grade` - A floating-point number representing the student\'s grade. * Returns a list of student names who have grades below the average grade. Constraints: * Assume student names are unique within each course. * Grades are non-negative floating-point numbers. * There must be error handling for invalid operations such as enrolling the same student multiple times or assigning a grade to a non-enrolled student. * The system should handle at least 1000 students and 50 courses efficiently. Examples: ```python # Course management example python_course = Course(\\"Advanced Python\\") python_course.enroll_student(\\"Alice\\") python_course.enroll_student(\\"Bob\\") python_course.enroll_student(\\"Charlie\\") python_course.assign_grade(\\"Alice\\", 85.0) python_course.assign_grade(\\"Bob\\", 90.0) python_course.assign_grade(\\"Charlie\\", 70.0) average = python_course.calculate_average_grade() # should return (85.0 + 90.0 + 70.0) / 3 = 81.67 students_below_avg = python_course.students_below_average() # should return [\\"Charlie\\"] ``` Edge Cases: 1. If the course has no students enrolled, calculating the average grade should return 0.0 and no students below average. 2. If the grade for all students is equal, the `students_below_average` should return an empty list. 3. Error messages for invalid operations should be clear and informative.","solution":"from typing import List class Course: def __init__(self, course_name: str): self.course_name = course_name self.students = {} def enroll_student(self, student_name: str): if student_name in self.students: raise ValueError(f\\"Student \'{student_name}\' is already enrolled in the course \'{self.course_name}\'.\\") self.students[student_name] = None def assign_grade(self, student_name: str, grade: float): if student_name not in self.students: raise ValueError(f\\"Student \'{student_name}\' is not enrolled in the course \'{self.course_name}\'.\\") self.students[student_name] = grade def calculate_average_grade(self) -> float: total_grade = 0.0 count = 0 for grade in self.students.values(): if grade is not None: total_grade += grade count += 1 return total_grade / count if count != 0 else 0.0 def students_below_average(self) -> List[str]: average_grade = self.calculate_average_grade() below_average_students = [student for student, grade in self.students.items() if grade is not None and grade < average_grade] return below_average_students"},{"question":"# Question: Implement a Memory-Efficient Dynamic Programming Solution for the Longest Palindromic Subsequence # Objective Develop an algorithm to find the length of the longest palindromic subsequence in a given string. Your implementation should focus on memory efficiency and use dynamic programming techniques. # Requirements 1. **Dynamic Programming Table**: * Use a 2D table to store intermediate results of the subproblems. * Ensure that your implementation uses an optimized approach to minimize memory usage. 2. **Algorithm Efficiency**: * Implement the solution with a time complexity of O(n²) and a space complexity of O(n), where n is the length of the input string. * Avoid redundant computations by storing and reusing intermediate results. 3. **Handling Edge Cases**: * Ensure your solution correctly handles edge cases such as an empty string or a string with a single character. 4. **Subsequence Definition**: * Recall that a subsequence is a sequence derived by deleting some or no elements of another sequence without changing the order of the remaining elements. # Input/Output Specification 1. **Input**: * `s`: A string of length `n` containing lowercase alphabets. 2. **Output**: * An integer representing the length of the longest palindromic subsequence in the input string. # Examples 1. **Example 1**: * Input: `s = \\"bbbab\\"` * Output: `4` * Explanation: The longest palindromic subsequence is \\"bbbb\\". 2. **Example 2**: * Input: `s = \\"cbbd\\"` * Output: `2` * Explanation: The longest palindromic subsequence is \\"bb\\". # Constraints * The length of the input string `s` will not exceed `1000`. # Solution Outline * Initialize a table to store the length of the longest palindromic subsequence for different substrings. * Start by filling in values for substrings of length 1 (which are all palindromes of length 1). * Gradually fill in the table for substrings of increasing lengths by using the results of smaller subproblems. * Use the dynamic programming approach to build up the solution in a space-efficient manner, potentially using a rolling array to optimize space usage. * Finally, return the value in the table that corresponds to the longest palindromic subsequence of the entire string. # Submission * Implement the function `longest_palindromic_subsequence(s: str) -> int`. * Provide complete and functional code to find the length of the longest palindromic subsequence. * Ensure your code is well-documented and includes comments explaining the key steps and logic. ```python def longest_palindromic_subsequence(s: str) -> int: n = len(s) if n == 0: return 0 # Initialize a 2D array to store the lengths of palindromic subsequences dp = [[0] * n for _ in range(n)] # Single character palindromes for i in range(n): dp[i][i] = 1 # Build the table for cl in range(2, n + 1): # cl is the current length of the substring for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The longest palindromic subsequence length for the full string return dp[0][n - 1] # Example usage s = \\"bbbab\\" print(longest_palindromic_subsequence(s)) # Output: 4 s = \\"cbbd\\" print(longest_palindromic_subsequence(s)) # Output: 2 ```","solution":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the string `s`. n = len(s) if n == 0: return 0 # Initialize a 2D array to store the lengths of palindromic subsequences dp = [[0] * n for _ in range(n)] # Single character palindromes for i in range(n): dp[i][i] = 1 # Build the table for cl in range(2, n + 1): # cl is the current length of the substring for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The longest palindromic subsequence length for the full string return dp[0][n - 1]"},{"question":"# File Directory Tree Generator **Context**: You have been tasked with creating a utility that generates a visual representation of a file directory tree. The utility should produce a textual tree that depicts the folder and file structure starting from a given directory path. **Task**: Write a Python function named `generate_directory_tree(path: str) -> str:` that performs the following tasks: 1. Recursively traverse the directory structure starting from the provided `path`. 2. Generate a string representing the directory tree with the following requirements: - Each level of the directory is indented with four spaces. - Directories should be denoted with a trailing slash (e.g., `folder/`). - Files should be listed without any trailing characters. **Input**: - `path` (str): A string representing the starting directory path. **Output**: - `str`: A string representing the directory tree structure. **Example**: Given the directory structure: ```plaintext root_folder/ ├── sub_folder1/ │ ├── file1.txt │ └── file2.txt └── sub_folder2/ └── file3.txt ``` Calling `generate_directory_tree(\\"root_folder/\\")` should return: ```plaintext root_folder/ sub_folder1/ file1.txt file2.txt sub_folder2/ file3.txt ``` # Instructions: 1. Use Python\'s `os` module to handle directory traversal. 2. Ensure the generated tree string maintains the indentation and formatting requirements. 3. Handle common errors such as invalid directory paths gracefully. 4. Your function should return the directory tree string in the specified format, rather than print it directly.","solution":"import os def generate_directory_tree(path: str) -> str: Generates a visual representation of a file directory tree. Args: path (str): The starting directory path. Returns: str: A string representing the directory tree structure. def _generate_tree(current_path, prefix): tree_lines = [] items = sorted(os.listdir(current_path), key=lambda x: (os.path.isfile(os.path.join(current_path, x)), x.lower())) count = len(items) for i, item in enumerate(items): item_path = os.path.join(current_path, item) if os.path.isdir(item_path): tree_lines.append(f\\"{prefix}{item}/\\") if i < count - 1: # Middle item tree_lines.extend(_generate_tree(item_path, prefix + \' \')) else: # Last item tree_lines.extend(_generate_tree(item_path, prefix + \' \')) else: tree_lines.append(f\\"{prefix}{item}\\") return tree_lines if not os.path.exists(path): raise FileNotFoundError(f\\"Path \'{path}\' does not exist\\") if not os.path.isdir(path): raise NotADirectoryError(f\\"Path \'{path}\' is not a directory\\") tree = f\\"{os.path.basename(path)}/n\\" + \\"n\\".join(_generate_tree(path, \\" \\")) return tree"},{"question":"# Coding Question Binary Search Tree (BST) is a fundamental data structure used in many applications. Your task is to implement a solution that can traverse a given Binary Search Tree in various orders and validate if the tree is indeed a BST. Function Implementations 1. `inorder_traversal(root: TreeNode) -> list` 2. `preorder_traversal(root: TreeNode) -> list` 3. `postorder_traversal(root: TreeNode) -> list` 4. `is_bst(root: TreeNode) -> bool` # Class Definition ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Input - `root`: A TreeNode representing the root of the Binary Search Tree (BST). # Output - For `inorder_traversal`: - A list of integers representing the values of the nodes visited in inorder. - For `preorder_traversal`: - A list of integers representing the values of the nodes visited in preorder. - For `postorder_traversal`: - A list of integers representing the values of the nodes visited in postorder. - For `is_bst`: - A boolean value indicating whether the tree is a valid BST. # Constraints - The number of nodes in the BST will be in the range [1, 100]. - The values of the nodes will be unique integers. Example ```python # Example Input # Construct the following BST: # 5 # / # 3 7 # / # 2 4 8 root = TreeNode(5) root.left = TreeNode(3, TreeNode(2), TreeNode(4)) root.right = TreeNode(7, None, TreeNode(8)) # Function Calls inorder = inorder_traversal(root) preorder = preorder_traversal(root) postorder = postorder_traversal(root) is_valid_bst = is_bst(root) # Expected Output print(\\"Inorder Traversal: \\", inorder) # Expected: [2, 3, 4, 5, 7, 8] print(\\"Preorder Traversal: \\", preorder) # Expected: [5, 3, 2, 4, 7, 8] print(\\"Postorder Traversal: \\", postorder) # Expected: [2, 4, 3, 8, 7, 5] print(\\"Is BST: \\", is_valid_bst) # Expected: True ``` Your task is to correctly implement the `inorder_traversal`, `preorder_traversal`, `postorder_traversal`, and `is_bst` functions to return the traversal lists and validate the BST property, respectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result def preorder_traversal(root): result = [] def traverse(node): if node: result.append(node.val) traverse(node.left) traverse(node.right) traverse(root) return result def postorder_traversal(root): result = [] def traverse(node): if node: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result def is_bst(root, low=float(\'-inf\'), high=float(\'inf\')): if not root: return True if not (low < root.val < high): return False return is_bst(root.left, low, root.val) and is_bst(root.right, root.val, high)"},{"question":"# Context You are a software developer working on a data processing pipeline. One significant task is to implement a function that extracts all unique words from a list of sentences, performs case normalization, and sorts them lexicographically. Your function should be efficient with inputs of varying sizes. # Requirements 1. Implement a function that processes a list of sentences. 2. Convert all words to lowercase to ensure case normalization. 3. Identify and include only unique words. 4. Sort the unique words lexicographically and return them as a list. # Input/Output 1. **Function**: `extract_unique_words(sentences)` - **Arguments**: - `sentences`: A list of strings, where each string is a sentence containing multiple words. - **Returns**: A list of unique, sorted words. # Constraints - Words are separated by spaces. - Sentences may contain punctuation, which should be ignored (i.e., stripped out). - Assume the sentences are in English and contain only alphabetic characters and standard punctuation (.,!?). # Example ```python sentences = [ \\"The quick brown fox jumps over the lazy dog.\\", \\"The lazy dog lies in the sun!\\", \\"Quick thinking by the fox led to its escape.\\" ] unique_words = extract_unique_words(sentences) print(unique_words) # Output: # [\'brown\', \'by\', \'dog\', \'escape\', \'fox\', \'in\', \'its\', \'jump\', \'jumps\', \'led\', \'lies\', \'lazy\', \'over\', \'quick\', \'sun\', \'the\', \'thinking\', \'to\'] ``` # Criteria - Solution\'s correctness. - Accurate identification and normalization of unique words. - Proper handling of punctuation. - Efficient sorting of words.","solution":"import re def extract_unique_words(sentences): Extracts all unique words from a list of sentences, performs case normalization, and sorts them lexicographically. Args: - sentences: A list of strings, where each string is a sentence. Returns: - A list of unique, sorted words. # Set to store unique words unique_words = set() # Regular expression to find words word_pattern = re.compile(r\'bw+b\') for sentence in sentences: # Find all words ignoring punctuation words = word_pattern.findall(sentence) # Convert words to lowercase and add to the unique words set unique_words.update(word.lower() for word in words) # Return sorted list of unique words return sorted(unique_words)"},{"question":"# Introduction You are developing a text processing utility that analyzes lines of text for various statistics. One of the requirements is to calculate the frequency of each word in a given line of text, ignoring case sensitivity, and provide the counts in a sorted order of words. # Problem Write a function `word_frequency(text: str) -> dict` that calculates the frequency of each word in a given string `text`. Words are defined as sequences of alphanumeric characters, and punctuation should be ignored. The result should be a dictionary with words as keys and their frequencies as values, sorted by words in ascending order. # Function Signature ```python def word_frequency(text: str) -> dict: ``` # Input The input is a single string `text` that may contain: - Uppercase and lowercase letters - Digits - Punctuation marks (e.g., commas, periods, exclamation points) - Whitespace characters # Output The function should return a dictionary where: - Keys are words in lowercase - Values are the frequencies of those words - The dictionary is sorted by words in ascending order # Constraints 1. The function should handle empty input gracefully and return an empty dictionary. 2. The function should ignore punctuation and consider words as sequences of alphanumeric characters. 3. The function should be case-insensitive. # Examples ```python assert word_frequency(\\"Hello, World!\\") == {\\"hello\\": 1, \\"world\\": 1} assert word_frequency(\\"This is a test. This test is only a test.\\") == {\\"a\\": 2, \\"is\\": 2, \\"only\\": 1, \\"test\\": 3, \\"this\\": 2} assert word_frequency(\\"Python\'s standard library is very rich.\\") == {\\"is\\": 1, \\"library\\": 1, \\"python\\": 1, \\"rich\\": 1, \\"s\\": 1, \\"standard\\": 1, \\"very\\": 1} assert word_frequency(\\"aa bbb aa AA\\") == {\\"aa\\": 3, \\"bbb\\": 1} assert word_frequency(\\"\\") == {} ``` Make sure your solution handles the corner cases and adheres to the constraints provided.","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: # Initialize a default dictionary for word counts word_count = defaultdict(int) # Use regular expression to find all words ignoring case (convert to lowercase) words = re.findall(r\'bw+b\', text.lower()) # Count the frequency of each word for word in words: word_count[word] += 1 # Convert the defaultdict to a normal dict and sort by keys return dict(sorted(word_count.items()))"},{"question":"# Context You are working on a web application that allows users to search for books using the Google Books API. Your task is to create a feature that retrieves book data based on user queries and saves relevant information to a local file. # Problem Statement You need to implement a function that: 1. Interacts with the Google Books API to search for books. 2. Retrieves and saves details of the top 5 books for a given query. 3. Handles errors and edge cases robustly. 4. Logs actions and errors appropriately for debugging purposes. # Requirements - Implement a function `search_and_save_books(query: str, api_key: str, path: str = \\"books.json\\") -> str:` which: * Retrieves the top 5 books from the Google Books API based on the search query. * Saves the book titles, authors, and descriptions to a JSON file at the specified path. * Logs errors such as invalid API responses, network issues, and file write failures. * Returns a message indicating success or the nature of any encountered errors. # Input - `query (str)`: The search query for retrieving books. - `api_key (str)`: The API key needed for authentication with the Google Books API. - `path (str)`: The file path where the book details should be saved (default is `books.json`). # Output - Returns a string indicating either the successful saving of book data or an error message. # Constraints - Ensure API calls timeout after 10 seconds. - Handle HTTP errors and invalid JSON responses appropriately. - Validate file paths before attempting to save data. - Limit the number of retrieved books to a maximum of 5. # Example ```python query = \\"Python programming\\" api_key = \\"YOUR_API_KEY\\" path = \\"./book_search_results.json\\" result = search_and_save_books(query, api_key, path) print(result) ``` Expected output: - On success: \\"Successfully saved book data.\\" - On failure: An error message specifying the problem (e.g., \\"Invalid API key\\", \\"Failed to save file\\").","solution":"import requests import json import logging import os def search_and_save_books(query: str, api_key: str, path: str = \\"books.json\\") -> str: Retrieves the top 5 books from the Google Books API based on the search query and saves details including titles, authors, and descriptions to a JSON file. Args: query (str): The search query for retrieving books. api_key (str): The API key needed for authentication with the Google Books API. path (str): The file path where the book details should be saved. Returns: str: A message indicating success or the nature of any encountered errors. # Setting up logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\') # Get Books from Google Books API url = \\"https://www.googleapis.com/books/v1/volumes\\" params = { \'q\': query, \'maxResults\': 5, \'key\': api_key } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() # Raise an HTTPError for bad responses data = response.json() books = [] for item in data.get(\'items\', []): volume_info = item.get(\'volumeInfo\', {}) book = { \'title\': volume_info.get(\'title\', \'N/A\'), \'authors\': volume_info.get(\'authors\', [\'N/A\']), \'description\': volume_info.get(\'description\', \'N/A\') } books.append(book) # Save to file try: with open(path, \'w\') as file: json.dump(books, file, ensure_ascii=False, indent=4) return \\"Successfully saved book data.\\" except IOError as e: logging.error(f\\"Failed to save file: {e}\\") return f\\"Failed to save file: {e}\\" except requests.exceptions.RequestException as e: logging.error(f\\"Request failed: {e}\\") return f\\"Request failed: {e}\\" except ValueError as e: logging.error(f\\"Invalid JSON response: {e}\\") return f\\"Invalid JSON response: {e}\\""},{"question":"# Problem Description You are required to create a program that can identify palindromic subsequences within a string. A palindromic subsequence reads the same backward as forward and can be derived by deleting some or none of the characters without changing the order of the remaining characters. # Requirements 1. **Function 1: `is_palindrome`** - **Input**: A string `s`. - **Output**: A boolean value indicating whether the input string is a palindrome. - **Behavior**: Check if the input string reads the same backward as forward. 2. **Function 2: `longest_palindromic_subsequence`** - **Input**: A string `s` (1 <= length of s <= 100). - **Output**: An integer representing the length of the longest palindromic subsequence in the input string. - **Behavior**: Calculate the length of the longest subsequence within `s` that is a palindrome. # Input and Output Formats - Input strings will consist only of lowercase alphabetic characters. - The output will be an integer representing the length of the longest palindromic subsequence. # Example ```python >>> is_palindrome(\'racecar\') True >>> is_palindrome(\'hello\') False >>> longest_palindromic_subsequence(\'bbbab\') 4 >>> longest_palindromic_subsequence(\'cbbd\') 2 ``` # Constraints * Input string length should not exceed 100 characters. # Task Implement these functions in Python to solve the problem as described.","solution":"def is_palindrome(s): Returns True if the string `s` is a palindrome, False otherwise. return s == s[::-1] def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in string `s`. n = len(s) # Create a 2D array to store the lengths of palindromic subsequences dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The length of the longest palindromic subsequence will be in dp[0][n-1] return dp[0][n - 1]"},{"question":"# Program Description Data streams are frequently utilized in competitive programming and software development for real-time processing and data management tasks. Your challenge is to create a class that manages a stream of integers and provides functionalities to add numbers to the stream and calculate the mean of the current list of numbers. # Class Signature ```python class DataStream: def __init__(self): # Initialize your data structures here pass def add_number(self, num: int) -> None: # Add a number to the stream pass def get_mean(self) -> float: # Return the mean of all numbers added so far pass ``` # Methods - **add_number(self, num: int) -> None**: Adds the specified integer to the data stream. - **get_mean(self) -> float**: Returns the mean (average) of all the integers added so far in the stream. If no numbers have been added, return `0.0`. # Constraints - The input will always be an integer for the `add_number` method. - The `get_mean` method should return a floating-point number. - The total number of integers added will not exceed (10^7). - The integers can be negative, zero, or positive. # Example ```python >>> ds = DataStream() >>> ds.get_mean() 0.0 >>> ds.add_number(3) >>> ds.add_number(5) >>> ds.get_mean() 4.0 >>> ds.add_number(7) >>> ds.get_mean() 5.0 >>> ds.add_number(-1) >>> ds.get_mean() 3.5 ``` # Implementation Notes - Ensure the operations to add a number and calculate the mean remain efficient even with the maximum input size. - Properly manage the accumulation of numbers to avoid overflow issues. - Consider edge cases such as when no numbers have been added and when negative numbers are included in the stream.","solution":"class DataStream: def __init__(self): self.numbers = [] def add_number(self, num: int) -> None: self.numbers.append(num) def get_mean(self) -> float: if not self.numbers: return 0.0 return sum(self.numbers) / len(self.numbers)"},{"question":"# Problem Statement Develop a function to calculate the shortest path in a directional weighted graph using Dijkstra\'s algorithm. Given a graph represented as an adjacency list and a starting node, your function should return the shortest distances from the starting node to all other nodes. # Function Signature ```python def dijkstra(num_nodes: int, edges: list[tuple[int, int, int]], start_node: int) -> list[int]: Returns the list of shortest distances from the start_node to each node. ``` # Input * `num_nodes` (1 <= num_nodes <= 10^5): An integer representing the number of nodes in the graph. * `edges` (0 <= len(edges) <= 2*num_nodes): A list of tuples `(u, v, weight)` where each tuple represents a directed edge from node `u` to node `v` with a specified `weight` (1 <= u, v <= num_nodes, 0 <= weight <= 10^7). * `start_node` (1 <= start_node <= num_nodes): An integer representing the starting node. # Output * A list of integers where the `i`-th element represents the shortest distance from the `start_node` to node `i`. If a node is unreachable, its distance should be represented as infinity (`float(\'inf\')`). # Example ```python assert dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 7), (2, 5, 5)], 1) == [0, 2, 3, 10, 7] assert dijkstra(3, [(1, 2, 1), (2, 3, 2)], 1) == [0, 1, 3] assert dijkstra(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3)], 2) == [float(\'inf\'), 0, 2, 5] ``` # Constraints * Ensure your implementation is efficient and works within the constraints. Use priority queues (heap) to optimize the selection of the next node with the minimum distance. * Handle cases with disconnected graphs where some nodes may not be reachable from the `start_node`. These nodes should have a distance of `float(\'inf\')` in the output list.","solution":"import heapq def dijkstra(num_nodes: int, edges: list[tuple[int, int, int]], start_node: int) -> list[int]: Returns the list of shortest distances from the start_node to each node. # Initialize adjacency list adj_list = [[] for _ in range(num_nodes + 1)] for u, v, weight in edges: adj_list[u].append((v, weight)) # Initialize distances and priority queue distances = [float(\'inf\')] * (num_nodes + 1) distances[start_node] = 0 priority_queue = [(0, start_node)] # (distance, node) while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > distances[current_node]: continue for neighbor, weight in adj_list[current_node]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Ignore index 0 as nodes are 1 based indexing return distances[1:]"},{"question":"# Question: Optimized Unique Character Identifier You are required to implement a function that identifies the first unique character in a given string. The function should be optimized for performance, considering strings with significant length. **Function Signature**: ```python def first_unique_character(s: str) -> int: ``` **Input**: - `s` (str): A string containing lowercase English letters. The length of the string can be up to 10^5 characters. **Output**: - (int): The index of the first unique character in the string. If no such character exists, return -1. **Constraints**: - The solution must handle large input sizes efficiently. - You should only use linear time complexity (O(n)) for this task. **Example**: ```python assert first_unique_character(\\"leetcode\\") == 0 assert first_unique_character(\\"loveleetcode\\") == 2 assert first_unique_character(\\"aabbcc\\") == -1 assert first_unique_character(\\"abcdef\\") == 0 assert first_unique_character(\\"abba\\") == -1 ``` **Explanation**: 1. The function should scan the string and count the frequency of each character. 2. In the second pass, scan the string again to find the first character with a count of one. 3. The index of this character should be returned as the result. 4. If no unique character exists, return -1. **Notes**: - Use a dictionary or list to store character counts efficiently. - Optimize your algorithm to run in linear time to handle the upper constraint of input size effectively. - Ensure to cover edge cases where all characters are repeated or where all characters are unique.","solution":"def first_unique_character(s: str) -> int: Finds the index of the first unique character in a given string s. If no such character exists, return -1. :param s: str - The input string containing lowercase English letters. :return: int - The index of the first unique character or -1 if none exists. # Step 1: Count the frequency of each character in the string char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Step 2: Find the index of the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"# Problem: Implement a Word Ladder Solver You are tasked with implementing a solver for the Word Ladder problem. A word ladder is a sequence of words where each word is a transformation of the previous one by changing exactly one letter and each intermediate word is a valid word in the given dictionary. Function 1: `find_ladder` Write a method `find_ladder(self, start: str, end: str, word_list: list) -> list` that returns the shortest transformation sequence from `start` to `end`. 1. `start`: A string representing the start word. 2. `end`: A string representing the end word. 3. `word_list`: A list of strings representing the word dictionary. Input * `start`: A string representing the starting word. * `end`: A string representing the ending word. * `word_list`: A list of strings containing the dictionary of valid words. Output * A list of strings representing the shortest transformation sequence. * If no such sequence exists, return an empty list. Example ```python >>> word_ladder = WordLadder() >>> dictionary = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] >>> word_ladder.find_ladder(\\"hit\\", \\"cog\\", dictionary) [\'hit\', \'hot\', \'dot\', \'dog\', \'cog\'] >>> word_ladder.find_ladder(\\"hit\\", \\"hot\\", dictionary) [\'hit\', \'hot\'] >>> word_ladder.find_ladder(\\"hit\\", \\"hug\\", dictionary) [] ``` Constraints * Each word in the dictionary and both the start and end words are of the same length. * All words consist of lowercase letters only. * All dictionary words and the start and end words are unique. # Additional Notes * Optimize for the shortest transformation sequence using an appropriate graph search algorithm. * Handle cases where the start or end word is not in the dictionary. * Ensure the solution is efficient in terms of both time and space complexity.","solution":"from collections import deque class WordLadder: def find_ladder(self, start: str, end: str, word_list: list) -> list: if end not in word_list: return [] word_list = set(word_list) queue = deque([[start]]) visited = set([start]) while queue: path = queue.popleft() current_word = path[-1] if current_word == end: return path for i in range(len(current_word)): for char in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + char + current_word[i+1:] if next_word in word_list and next_word not in visited: visited.add(next_word) queue.append(path + [next_word]) return [] # Example usage word_ladder = WordLadder() dictionary = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] print(word_ladder.find_ladder(\\"hit\\", \\"cog\\", dictionary)) # [\'hit\', \'hot\', \'dot\', \'dog\', \'cog\'] print(word_ladder.find_ladder(\\"hit\\", \\"hot\\", dictionary)) # [\'hit\', \'hot\'] print(word_ladder.find_ladder(\\"hit\\", \\"hug\\", dictionary)) # []"},{"question":"# Scenario Bob is working on reformatting sentences to meet specific styling requirements. He needs to ensure that each word in the sentence starts with a capital letter and that all words are separated by a single space. Help Bob by writing a function that takes a given string and returns it with the correct formatting. # Coding Task Write a function `reformat_sentence(sentence: str) -> str` that capitalizes the first letter of each word in the given string `sentence` and ensures there is exactly one space between each word. # Input and Output Format - **Input**: - `sentence` (a string consisting of alphanumeric characters, \',\', \'.\', \'!\', and space, length 1 ≤ len(sentence) ≤ 1000) - **Output**: - A string where each word\'s first letter is capitalized, with words separated by exactly one space. # Constraints and Assumptions: - The given string `sentence` will contain at least one word. - The string can contain punctuation marks (.,!) which should not affect the capitalization of words. - Multi-space sequences should be reduced to a single space. # Example - Example 1: - `sentence = \\"hello world! how are you?\\"` - Output: `\\"Hello World! How Are You?\\"` - Example 2: - `sentence = \\" This is a sample. \\" - Output: `\\"This Is A Sample.\\"` **Note**: Pay special attention to leading and trailing spaces as well as sequences of multiple spaces.","solution":"def reformat_sentence(sentence: str) -> str: Capitalizes the first letter of each word in the given string `sentence` and ensures there is exactly one space between each word. words = sentence.split() capitalized_words = [word.capitalize() for word in words] return \' \'.join(capitalized_words)"},{"question":"**Sorting and Searching: Finding the Missing Number** You are working on a data integrity algorithm to verify sequences of unique integers. Specifically, you have a sequence of `n - 1` unique integers, where the integers are in the range from 1 to `n` and no duplicates exist within the list. However, one integer from this range is missing. Your task is to determine the missing integer. # Problem Statement You are given a list of integers `nums`, which contains `n - 1` unique integers in the range from `1` to `n`. There are no duplicates in the list and no integer outside the range 1 to `n`. Your goal is to find the integer that is missing from this sequence. # Task Implement the function `find_missing_number(nums: List[int]) -> int` that returns the missing integer. # Expected Input and Output Formats ```python def find_missing_number(nums: List[int]) -> int: pass ``` - `nums`: A list of integers of length `n - 1` representing the sequence of unique integers. **Output**: An integer representing the missing number in the sequence. # Constraints 1. `1 <= len(nums) <= 10^6` 2. `1 <= nums[i] <= n` where `n = len(nums) + 1` # Performance Requirements Your solution should run with a time complexity of O(n) or better and use O(1) additional space for variables. # Scenario Imagine you are verifying a sequence of uniquely numbered packages ready for shipment, but one package is missing. You need to find out which specific package is missing to ensure all intended packages are sent out properly. # Example ```python nums = [3, 7, 1, 2, 8, 4, 5] print(find_missing_number(nums)) # Output: 6 ``` In this example, the integers are in the range from 1 to 8, but the number 6 is missing from the sequence provided. In a sequential order, the range would be [1, 2, 3, 4, 5, 6, 7, 8]. Comparing this with the given list, it is clear that the number 6 is the missing one.","solution":"def find_missing_number(nums): Find the missing number in a sequence of unique integers from 1 to n. n = len(nums) + 1 total_sum = n * (n + 1) // 2 # Sum of the first n natural numbers actual_sum = sum(nums) # Sum of numbers in the given list return total_sum - actual_sum"},{"question":"# Problem Statement You are tasked with implementing a queue data structure suitable for a system that needs to manage a sequence of commands in a first-in, first-out (FIFO) manner. Queues must support typical operations and handle error conditions gracefully. **Specifications**: Implement a `Queue` class with the following methods: 1. `enqueue(data: T)`: Add an element `data` to the end of the queue. 2. `dequeue() -> T`: Remove and return the front element of the queue. 3. `peek_front() -> T`: Return (but do not remove) the front element of the queue. 4. `is_empty() -> bool`: Return `True` if the queue is empty, `False` otherwise. 5. `is_full() -> bool`: Return `True` if the queue is full, `False` otherwise. 6. `size() -> int`: Return the number of elements currently in the queue. **Error Handling**: - *QueueOverflowError*: Raised when attempting to enqueue to a full queue. - *QueueUnderflowError*: Raised when attempting to dequeue from or peek into an empty queue. **Input/Output**: - Ensure that operations handle edge cases properly. - The queue should be limited by a maximum size constraint upon initialization. # Inputs: - Integer `limit`: Defines the maximum number of elements the queue can hold. - Sequence of operation requests including `enqueue`, `dequeue`, `peek_front`, `is_empty`, `is_full`, `size`. # Outputs: - For `enqueue`: None. - For `dequeue` and `peek_front`: The respective element. - For `is_empty`, `is_full`: Boolean value indicating the state of the queue. - For `size`: Integer indicating the queue\'s current size. # Example: ```python Q = Queue(3) Q.enqueue(10) Q.enqueue(20) print(Q.dequeue()) # Output: 10 print(Q.peek_front()) # Output: 20 print(Q.is_empty()) # Output: False Q.enqueue(30) print(Q.is_full()) # Output: False Q.enqueue(40) Q.enqueue(50) # Raises QueueOverflowError: Too many elements in the queue ``` # Constraints: - Queue size `limit` ranges from 1 to 10^4. - Operations on the queue should be optimized for efficiency. # Task: Implement the `Queue` class described above, ensuring proper function and error handling compliance.","solution":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: def __init__(self, limit): self.limit = limit self.queue = [] def enqueue(self, data): if self.is_full(): raise QueueOverflowError(\\"Too many elements in the queue\\") self.queue.append(data) def dequeue(self): if self.is_empty(): raise QueueUnderflowError(\\"No elements in the queue\\") return self.queue.pop(0) def peek_front(self): if self.is_empty(): raise QueueUnderflowError(\\"No elements in the queue\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def is_full(self): return len(self.queue) >= self.limit def size(self): return len(self.queue)"},{"question":"# Question: Building a Simplified Event Scheduler **Context:** You are tasked with creating a Python class to manage a simple scheduling system for events. An event has a name, a start time, and an end time. The scheduler should be able to add, remove, and list events, ensuring no overlapping events are scheduled. **Objective:** Implement a class `EventScheduler` that can manage the scheduling of events. The class should provide methods to add an event, remove an event, and list all scheduled events. **Specifications:** * **Class**: `EventScheduler` * **Methods**: * `add_event(event_name: str, start_time: str, end_time: str) -> bool`: Adds a new event. Returns `True` if the event was added successfully, `False` otherwise. * `remove_event(event_name: str) -> bool`: Removes an event by its name. Returns `True` if the event was successfully removed, `False` if the event was not found. * `list_events() -> List[Tuple[str, str, str]]`: Lists all scheduled events as a list of tuples, each containing the event name, start time, and end time. The events should be listed in the order they were added. * **Constraints**: * The `start_time` and `end_time` should be strings in the format `\\"HH:MM\\"`. * No two events should overlap. If an event overlaps with an existing event, it should not be added. * The `end_time` must be later than the `start_time`. * **Examples**: ```python scheduler = EventScheduler() assert scheduler.add_event(\\"Meeting\\", \\"10:00\\", \\"11:00\\") == True assert scheduler.add_event(\\"Lunch\\", \\"12:00\\", \\"13:00\\") == True assert scheduler.add_event(\\"Conference Call\\", \\"10:30\\", \\"11:30\\") == False # Overlaps with \\"Meeting\\" assert scheduler.list_events() == [(\\"Meeting\\", \\"10:00\\", \\"11:00\\"), (\\"Lunch\\", \\"12:00\\", \\"13:00\\")] assert scheduler.remove_event(\\"Lunch\\") == True assert scheduler.list_events() == [(\\"Meeting\\", \\"10:00\\", \\"11:00\\")] assert scheduler.remove_event(\\"Lunch\\") == False # Already removed ``` # Testing: Ensure to test the `EventScheduler` class with the following scenarios: * Adding events with and without conflicts. * Removing events and verifying the remaining schedule. * Verifying the list of events is in the correct order and correctly reflects additions and removals.","solution":"from typing import List, Tuple class EventScheduler: def __init__(self): self.events = [] def add_event(self, event_name: str, start_time: str, end_time: str) -> bool: new_start_time = self.convert_time_to_minutes(start_time) new_end_time = self.convert_time_to_minutes(end_time) if new_end_time <= new_start_time: return False for _, existing_start, existing_end in self.events: existing_start_time = self.convert_time_to_minutes(existing_start) existing_end_time = self.convert_time_to_minutes(existing_end) if (new_start_time < existing_end_time and new_start_time >= existing_start_time) or (new_end_time > existing_start_time and new_end_time <= existing_end_time) or (new_start_time <= existing_start_time and new_end_time >= existing_end_time): return False self.events.append((event_name, start_time, end_time)) return True def remove_event(self, event_name: str) -> bool: for i, (name, _, _) in enumerate(self.events): if name == event_name: del self.events[i] return True return False def list_events(self) -> List[Tuple[str, str, str]]: return self.events def convert_time_to_minutes(self, time_str: str) -> int: hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes"},{"question":"# Image Processing Matrix Manipulation Background As part of improving the performance of computer vision systems, you need to implement an efficient image filter that adjusts the brightness of an image represented as a matrix of pixels. Each pixel value in the image matrix is an integer in the range [0, 255], with 0 representing black and 255 representing white. Task Implement a function `adjust_brightness` that increases or decreases the brightness of an image by a specified amount. Brightness adjustment must be performed by adding the specified amount to each pixel value in the image. Requirements - Implement the `adjust_brightness` function that takes two parameters: an image matrix (`List[List[int]]`) and an adjustment value (`int`). - The function should add the adjustment value to each pixel in the image. If the resulting pixel value goes above 255, it should be clipped to 255. If it goes below 0, it should be clipped to 0. Input - A 2D list of integers representing the image matrix, where each integer is in the range [0, 255]. - An integer adjustment value which can be positive or negative. Output - The modified 2D list representing the adjusted image matrix. Example Usage ```python def adjust_brightness(image: List[List[int]], adjustment: int) -> List[List[int]]: adjusted_image = [] for row in image: adjusted_row = [min(255, max(0, pixel + adjustment)) for pixel in row] adjusted_image.append(adjusted_row) return adjusted_image # Example image_matrix = [ [50, 100, 150], [200, 250, 255], [0, 50, 100] ] adjustment_value = 20 adjusted_image = adjust_brightness(image_matrix, adjustment_value) # The adjusted_image should be: # [ # [70, 120, 170], # [220, 255, 255], # [20, 70, 120] # ] ``` Constraints - The image matrix can have dimensions up to 1000x1000. - The adjustment value will be between -255 and 255. - Ensure your solution is efficient and scales well with large image matrices. - Handle the edge cases where pixel values might reach the minimum or maximum limits. Good luck!","solution":"from typing import List def adjust_brightness(image: List[List[int]], adjustment: int) -> List[List[int]]: adjusted_image = [] for row in image: adjusted_row = [min(255, max(0, pixel + adjustment)) for pixel in row] adjusted_image.append(adjusted_row) return adjusted_image"},{"question":"**Parking Lot Management** You are managing a small parking lot that can hold a fixed number of cars. The parking lot operates based on two types of events: arrival and departure of cars. Each car has a unique license plate number. You need to implement a function `manage_parking_lot(capacity: int, events: List[Tuple[str, str]]) -> List[Optional[str]]` that helps you manage the parking lot by processing a sequence of events. # Function Signature ```python def manage_parking_lot(capacity: int, events: List[Tuple[str, str]]) -> List[Optional[str]]: ``` # Input * `capacity` (int): The maximum number of cars the parking lot can hold (1 ≤ capacity ≤ 100). * `events` (list of tuples): A list of events, where each event is a tuple consisting of a string representing the type of event (`\\"arrive\\"` or `\\"depart\\"`) and a string representing the car\'s license plate number. The length of `events` can be up to 200. # Output * Returns a list of strings or `None`s. For each `\\"arrive\\"` event, the output should be `\\"Accepted\\"` if the car is parked, or `\\"Rejected\\"` if the lot is full. For each `\\"depart\\"` event, the output should be `\\"Departed\\"` if the car was parked, or `\\"Not found\\"` if the car was not found in the parking lot. The outputs should be in the same order as the events. # Constraints * Ensure the function handles edge cases such as arrivals when the parking lot is full or departures when the lot is empty. # Examples ```python >>> manage_parking_lot(2, [(\\"arrive\\", \\"ABC123\\"), (\\"arrive\\", \\"XYZ789\\"), (\\"arrive\\", \\"DEF456\\"), (\\"depart\\", \\"XYZ789\\"), (\\"depart\\", \\"XYZ789\\")]) [\\"Accepted\\", \\"Accepted\\", \\"Rejected\\", \\"Departed\\", \\"Not found\\"] >>> manage_parking_lot(1, [(\\"arrive\\", \\"ABC123\\"), (\\"depart\\", \\"ABC123\\"), (\\"depart\\", \\"XYZ789\\")]) [\\"Accepted\\", \\"Departed\\", \\"Not found\\"] >>> manage_parking_lot(3, [(\\"arrive\\", \\"ABC123\\"), (\\"arrive\\", \\"XYZ789\\"), (\\"arrive\\", \\"DEF456\\"), (\\"depart\\", \\"ABC123\\"), (\\"arrive\\", \\"GHI012\\")]) [\\"Accepted\\", \\"Accepted\\", \\"Accepted\\", \\"Departed\\", \\"Accepted\\"] >>> manage_parking_lot(0, [(\\"arrive\\", \\"ABC123\\")]) [\\"Rejected\\"] ``` # Scenario Imagine you are developing a software system for a small parking lot to manage the cars coming in and out. The parking lot has limited spaces, and car arrivals and departures need to be processed efficiently to avoid any confusion. # Assessment Criteria * Correctness: The solution should return the correct status of each event. * Efficiency: The solution should handle the maximum number of events within the constraints. * Code Quality: The solution should be readable, organized, and maintainable.","solution":"from typing import List, Tuple, Optional def manage_parking_lot(capacity: int, events: List[Tuple[str, str]]) -> List[Optional[str]]: parked_cars = set() result = [] for event in events: action, license_plate = event if action == \\"arrive\\": if len(parked_cars) < capacity: if license_plate not in parked_cars: parked_cars.add(license_plate) result.append(\\"Accepted\\") else: result.append(\\"Rejected\\") # Car is already in the parking lot else: result.append(\\"Rejected\\") elif action == \\"depart\\": if license_plate in parked_cars: parked_cars.remove(license_plate) result.append(\\"Departed\\") else: result.append(\\"Not found\\") return result"},{"question":"# Coding Assessment Question You are tasked with building a mini inventory management system for a bookstore. Your system will maintain a list of books, each with a title, author, and quantity in stock. Implement functionalities to add new books, update quantities, and retrieve information based on specific queries. # Task Write a class `BookstoreInventory` that: 1. **Initializes an empty inventory.** 2. **Supports adding a new book or updating the stock quantity of an existing book.** 3. **Allows retrieval of all books by a specific author.** 4. **Allows retrieval of books with a stock quantity below a given threshold.** # Methods - `add_book(title: str, author: str, quantity: int) -> None`: Adds a new book to the inventory or updates the quantity if the book already exists. - `list_books_by_author(author: str) -> List[Dict[str, Any]]`: Returns a list of books by the specified author. Each book is represented as a dictionary with keys `title` and `quantity`. - `list_books_below_stock(threshold: int) -> List[Dict[str, Any]]`: Returns a list of books with stock quantity below the specified threshold. Each book is represented as a dictionary with keys `title`, `author`, and `quantity`. # Constraints - Book titles are unique but may be authored by different writers. - The initial stock quantity of a new book must be at least 1. - Stock quantity updates cannot reduce the quantity to below 0. # Input/Output Examples ```python inventory = BookstoreInventory() # Adding books inventory.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 5) inventory.add_book(\\"1984\\", \\"George Orwell\\", 3) inventory.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 2) inventory.add_book(\\"1984\\", \\"George Orwell\\", 7) # Update quantity for an existing book # Listing books by author print(inventory.list_books_by_author(\\"George Orwell\\")) ``` *Output*: ``` [{\'title\': \'1984\', \'quantity\': 10}] ``` ```python # Listing books below stock threshold print(inventory.list_books_below_stock(5)) ``` *Output*: ``` [ {\'title\': \'1984\', \'author\': \'George Orwell\', \'quantity\': 3}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'quantity\': 2} ] ``` # Implementation Notes - Use a dictionary or other suitable data structure to store book information efficiently. - Ensure methods handle edge cases, like adding a book with zero or negative quantity, and gracefully handle trying to fetch information that doesn\'t exist. - Include meaningful error messages or exceptions as needed to guide correct usage of the class. ```python from typing import List, Dict, Any class BookstoreInventory: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, quantity: int) -> None: if quantity <= 0: raise ValueError(\\"Quantity must be positive.\\") if title not in self.inventory: self.inventory[title] = {\'author\': author, \'quantity\': quantity} else: if self.inventory[title][\'author\'] != author: raise ValueError(\\"Author mismatch.\\") self.inventory[title][\'quantity\'] += quantity if self.inventory[title][\'quantity\'] < 0: raise ValueError(\\"Stock quantity cannot be negative.\\") def list_books_by_author(self, author: str) -> List[Dict[str, Any]]: return [{\'title\': title, \'quantity\': data[\'quantity\']} for title, data in self.inventory.items() if data[\'author\'] == author] def list_books_below_stock(self, threshold: int) -> List[Dict[str, Any]]: return [{\'title\': title, \'author\': data[\'author\'], \'quantity\': data[\'quantity\']} for title, data in self.inventory.items() if data[\'quantity\'] < threshold] ```","solution":"from typing import List, Dict, Any class BookstoreInventory: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, quantity: int) -> None: if quantity <= 0: raise ValueError(\\"Quantity must be positive.\\") if title in self.inventory: if self.inventory[title][\'author\'] != author: raise ValueError(\\"Author mismatch.\\") self.inventory[title][\'quantity\'] += quantity else: self.inventory[title] = {\'author\': author, \'quantity\': quantity} def list_books_by_author(self, author: str) -> List[Dict[str, Any]]: return [{\'title\': title, \'quantity\': data[\'quantity\']} for title, data in self.inventory.items() if data[\'author\'] == author] def list_books_below_stock(self, threshold: int) -> List[Dict[str, Any]]: return [{\'title\': title, \'author\': data[\'author\'], \'quantity\': data[\'quantity\']} for title, data in self.inventory.items() if data[\'quantity\'] < threshold]"},{"question":"# Coding Assessment Question **Scenario**: You are working on a project that aims to compress large text files to save disk space. As part of this project, one of the key components you need is to generate Huffman Codes for characters based on their frequencies in the text file. Huffman Coding is a lossless data compression algorithm that assigns variable-length codes to characters, with shorter codes assigned to more frequent characters. **Objective**: Implement a function `generate_huffman_codes(frequencies: Dict[str, int]) -> Dict[str, str]` that computes and returns the Huffman Codes for given characters based on their frequencies. **Function signature:** ```python def generate_huffman_codes(frequencies: Dict[str, int]) -> Dict[str, str]: # Your code here ``` # Inputs: - `frequencies`: A dictionary with characters as keys and their corresponding frequencies as values. # Outputs: - A dictionary with characters as keys and their Huffman Codes as values. # Constraints: 1. Each character has a unique and non-zero frequency. 2. The input dictionary has at least two characters. # Example: ```python frequencies = {\'a\': 5, \'b\': 9, \'c\': 12, \'d\': 13, \'e\': 16, \'f\': 45} # Potential output (the actual codes might differ but will be based on Huffman coding rules) expected_output = {\'f\': \'0\', \'c\': \'100\', \'d\': \'101\', \'a\': \'1100\', \'b\': \'1101\', \'e\': \'111\'} output = generate_huffman_codes(frequencies) for char, code in expected_output.items(): assert output[char] == code ``` # Instructions: - Build a Min-Heap to facilitate the creation of the Huffman Tree. - Traverse the Huffman Tree to assign codes to characters. - Ensure the codes are prefix-free (no code is a prefix of another). # Additional Notes: - Validate correctness through tests with different frequency distributions. - Optimize for clarity and efficiency where appropriate.","solution":"import heapq from collections import defaultdict from typing import Dict class HuffmanNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None # Comparing nodes for the priority queue def __lt__(self, other): return self.freq < other.freq def build_huffman_tree(frequencies: Dict[str, int]) -> HuffmanNode: min_heap = [HuffmanNode(char, freq) for char, freq in frequencies.items()] heapq.heapify(min_heap) while len(min_heap) > 1: left = heapq.heappop(min_heap) right = heapq.heappop(min_heap) merged = HuffmanNode(None, left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(min_heap, merged) return heapq.heappop(min_heap) def generate_codes(node: HuffmanNode, prefix: str, codebook: Dict[str, str]): if node.char is not None: codebook[node.char] = prefix else: if node.left: generate_codes(node.left, prefix + \'0\', codebook) if node.right: generate_codes(node.right, prefix + \'1\', codebook) def generate_huffman_codes(frequencies: Dict[str, int]) -> Dict[str, str]: if not frequencies: return {} root = build_huffman_tree(frequencies) codebook = {} generate_codes(root, \\"\\", codebook) return codebook"},{"question":"# Recursive Directory Print You are given a directory structure represented as a nested dictionary where folders can contain either other folders or a list of files. Write a function that prints the directory structure in a readable format, where each folder and file is displayed on a new line with a specific indentation level to denote its depth. **Problem**: Implement a function `print_directory` that takes a nested dictionary representing a directory structure and prints the files and folders with appropriate indentation. **Function Signature**: ```python def print_directory(directory: dict, indent: int = 0) -> None: ``` **Input**: - `directory`: A dictionary where keys are folder/file names and values are either: - Another dictionary representing a sub-folder. - A list of strings representing files within the folder. - `indent`: An integer representing the indentation level (number of spaces, default is 0). **Output**: - The function should print each folder and file on a new line with the appropriate indentation. **Example**: ```python directory_structure = { \\"folder1\\": { \\"subfolder1\\": [\\"file1.txt\\", \\"file2.txt\\"], \\"subfolder2\\": { \\"subsubfolder1\\": [\\"file3.txt\\"] }, }, \\"folder2\\": [\\"file4.txt\\"], \\"file5.txt\\": [] } print_directory(directory_structure) ``` Expected Output: ``` folder1/ subfolder1/ file1.txt file2.txt subfolder2/ subsubfolder1/ file3.txt folder2/ file4.txt file5.txt ``` **Constraints**: - The directory dictionary can be arbitrarily nested. - Folder names do not contain slashes. - Include edge cases where a folder may be an empty dictionary or files are empty lists. - No folder or file name will be an empty string. **Note**: The function does not need to return anything; just print the directory structure. Implement the function, ensuring that it handles all edge cases, input constraints, and produces the output in the specified format.","solution":"def print_directory(directory: dict, indent: int = 0) -> None: for key, value in directory.items(): if isinstance(value, dict): # Print folder names with a trailing slash and apply indentation print(\\" \\" * indent + key + \\"/\\") # Recursively print the contents of the folder print_directory(value, indent + 2) elif isinstance(value, list): if value: # For folders with files, print folder name with a trailing slash and apply indentation print(\\" \\" * indent + key + \\"/\\") for item in value: # Print each file with increased indentation print(\\" \\" * (indent + 2) + item) else: # For empty folders, just print the folder name with a trailing slash print(\\" \\" * indent + key + \\"/\\")"},{"question":"# Question Title: Weather Data Fetcher with API Rate Limiting and Error Handling # Scenario You have been hired to create a weather information script that retrieves real-time weather data from the OpenWeatherMap API. The script must handle API rate limits and potential error responses effectively to ensure robust data fetching. # Requirements 1. **Data Fetching and Parsing**: - Use the `requests` library to fetch JSON data from the OpenWeatherMap API endpoint `https://api.openweathermap.org/data/2.5/weather`. - Extract essential weather information: city name, temperature (in Celsius), weather description, and humidity. - Organize the extracted data into a named tuple `WeatherData` with fields `city`, `temperature`, `description`, and `humidity`. 2. **API Key Management**: - The API key should be passed as an argument to the function and used for authentication. You can obtain a free API key by signing up on OpenWeatherMap. 3. **Error Handling**: - Handle potential HTTP errors (e.g., 401 Unauthorized, 429 Too Many Requests) and network issues (e.g., timeouts). - Implement a retry mechanism with exponential backoff in case of a rate limit error (HTTP 429), with a maximum of 3 retries. 4. **Edge Case Consideration**: - The program should detect and print an appropriate message if the fetched JSON structure does not match the expected format. - Utilize Python\'s exception handling to manage unexpected errors during the request and parsing process. 5. **Rate Limiting**: - Respect the rate limits imposed by the OpenWeatherMap API by pausing the script for an appropriate amount of time when an HTTP 429 status code is encountered. # Function Signature Implement the following function: ```python def fetch_weather(city: str, api_key: str) -> WeatherData: pass ``` # Input - `city` (str): The name of the city for which the weather information is to be retrieved. - `api_key` (str): Your API key for the OpenWeatherMap API. # Output The function should return a `WeatherData` named tuple containing: - `city`: The name of the city. - `temperature`: The current temperature in Celsius. - `description`: A brief description of the current weather (e.g., \\"clear sky\\"). - `humidity`: The current humidity percentage. # Constraints - Use the `requests` library for fetching data. - Implement error handling and rate limiting as specified. - Ensure the function retries requests as needed in the case of rate limit errors. # Example Usage ```python WeatherData = namedtuple(\'WeatherData\', [\'city\', \'temperature\', \'description\', \'humidity\']) weather_info = fetch_weather(\'London\', \'your_api_key_here\') print(f\\"City: {weather_info.city}\\") print(f\\"Temperature: {weather_info.temperature}°C\\") print(f\\"Weather: {weather_info.description}\\") print(f\\"Humidity: {weather_info.humidity}%\\") ``` Expected output (subject to current weather conditions): ``` City: London Temperature: 15.00°C Weather: clear sky Humidity: 60% ``` Write your implementation of `fetch_weather` and ensure it meets the requirements specified above.","solution":"import requests from collections import namedtuple import time WeatherData = namedtuple(\'WeatherData\', [\'city\', \'temperature\', \'description\', \'humidity\']) def fetch_weather(city: str, api_key: str) -> WeatherData: Fetches weather data for a given city using the OpenWeatherMap API. Args: - city (str): The name of the city. - api_key (str): The API key for OpenWeatherMap API. Returns: - WeatherData: A named tuple containing city, temperature, description, and humidity. url = f\\"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\\" max_retries = 3 retry_delay = 1 # initial delay in seconds for attempt in range(max_retries): try: response = requests.get(url) if response.status_code == 200: data = response.json() return WeatherData( city=data[\'name\'], temperature=data[\'main\'][\'temp\'], description=data[\'weather\'][0][\'description\'], humidity=data[\'main\'][\'humidity\'] ) elif response.status_code == 401: raise ValueError(\\"Invalid API key or unauthorized access.\\") elif response.status_code == 429: if attempt < max_retries - 1: time.sleep(retry_delay) retry_delay *= 2 # exponential backoff continue else: raise RuntimeError(\\"Exceeded maximum retries due to rate limiting.\\") else: response.raise_for_status() except requests.RequestException as e: if attempt < max_retries - 1: time.sleep(retry_delay) retry_delay *= 2 # exponential backoff continue else: raise RuntimeError(f\\"Failed to fetch weather data: {e}\\") raise RuntimeError(\\"Unexpected error encountered during fetching weather data.\\")"},{"question":"# Problem Description You are required to write a function `can_attend_all_meetings` that takes a list of meeting time intervals as input and returns a boolean value indicating whether a person can attend all the meetings without any overlaps. Each meeting time interval is represented as a tuple `(start, end)`, with `start` and `end` being the start and end times of the meeting. # Input Format - A list of tuples `intervals`, where each tuple consists of two integers: - `intervals[i][0]` (0 <= intervals[i][0] < intervals[i][1] <= 10^6) representing the start time of the i-th meeting. - `intervals[i][1]` (0 < intervals[i][1] <= 10^6) representing the end time of the i-th meeting. # Output Format - A boolean value: - `True` if the person can attend all the meetings without overlaps. - `False` otherwise. # Constraints - The input list can be empty. - Ensure the function runs optimally for large inputs. # Performance Requirements - Aim for an O(n log n) time complexity due to sorting the intervals. - Use O(n) additional space if necessary. # Example Scenarios 1. **Example 1:** - Input: intervals = [(0, 30), (5, 10), (15, 20)] - Output: False 2. **Example 2:** - Input: intervals = [(7, 10), (2, 4)] - Output: True # Edge Cases 1. **Empty List:** - Input: intervals = [] - Output: True 2. **Single Meeting:** - Input: intervals = [(5, 10)] - Output: True # Function Signature ```python def can_attend_all_meetings(intervals: list) -> bool: pass ``` # Write the function `can_attend_all_meetings` to solve the problem.","solution":"def can_attend_all_meetings(intervals): Determines if a person can attend all meetings without overlaps. Args: - intervals (list of tuples): A list of tuples (start, end) representing the start and end times of meetings. Returns: - bool: True if the person can attend all meetings without overlaps, False otherwise. # First, sort the intervals by their start times intervals.sort(key=lambda x: x[0]) # Compare each meeting with the next one to check for overlaps for i in range(len(intervals) - 1): if intervals[i][1] > intervals[i + 1][0]: return False return True"},{"question":"# Task Implement a function `find_minimum_rotated_sorted_array(nums: list) -> int` to find the minimum element in a rotated sorted array. The rotation means that the array was initially sorted in ascending order, but then some leading elements were moved to the end. # Input - A list `nums` of integers, representing the rotated sorted array, where ( 1 leq text{len}(nums) leq 10^5 ). - All elements of `nums` are distinct and sorted in ascending order before rotation. # Output - Return an integer representing the minimum element in the array. # Constraints - Aim for O(log n) time complexity where n is the length of `nums`. - Ensure the approach efficiently handles edge cases where the array might not be rotated (still sorted). # Example ```python >>> find_minimum_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2]) 0 >>> find_minimum_rotated_sorted_array([3, 4, 5, 1, 2]) 1 >>> find_minimum_rotated_sorted_array([11, 13, 15, 17]) 11 >>> find_minimum_rotated_sorted_array([1]) 1 ``` # Notes - Your solution should work efficiently for large input sizes within the given constraints. - Consider edge cases like arrays with a single element or arrays where no rotation has occurred.","solution":"def find_minimum_rotated_sorted_array(nums): Finds the minimum element in a rotated sorted array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 # If mid element is greater than the element at right, # it means the minimum is in the right half if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"# Pascal\'s Triangle Row Sum Context: Pascal\'s Triangle is a mathematical array of binomial coefficients arranged in a triangle. Each number is the sum of the two numbers directly above it. One of the interesting properties of Pascal\'s Triangle is that the sum of the numbers in the (n)-th row is (2^n). Your task involves implementing a function to efficiently compute this row sum for very large values of (n). Task: Write a Python function named `pascal_triangle_row_sum` that returns the sum of the numbers in the (n)-th row of Pascal\'s Triangle. * **Input**: An integer `n` where (0 leq n leq 10^6). * **Output**: An integer representing the sum of the elements in the (n)-th row of Pascal\'s Triangle. Constraints: 1. The input (n) will be a non-negative integer not exceeding (10^6). Example: ```python def pascal_triangle_row_sum(n: int) -> int: # Your implementation here # Example usage: print(pascal_triangle_row_sum(0)) # Expected output: 1 print(pascal_triangle_row_sum(1)) # Expected output: 2 print(pascal_triangle_row_sum(4)) # Expected output: 16 print(pascal_triangle_row_sum(10)) # Expected output: 1024 ``` Notes: - The function should efficiently compute the result without constructing Pascal\'s Triangle directly. - You may want to review mathematical properties of binomial coefficients and powers of two for optimization. This task will test your ability to translate mathematical properties into efficient code solutions, and your understanding of combinatorics and exponential growth.","solution":"def pascal_triangle_row_sum(n: int) -> int: Returns the sum of the numbers in the nth row of Pascal\'s Triangle. return 2 ** n"},{"question":"# Scenario You are tasked with developing a scheduling application that arranges user appointments. Each appointment has a start time and end time. The goal is to maximize the number of non-overlapping appointments that can be scheduled. # Problem Statement Implement a function `max_appointments(appointments: List[Tuple[int, int]]) -> List[int]` that takes a list of tuples where each tuple represents an appointment with a start time and end time and returns a list of appointment indices that can be scheduled without overlapping. # Input * `appointments`: A list of `n` tuples where each tuple is of the form `(start, end)` representing an appointment. * `0 <= start < end <= 10^5` # Output * A list of appointment indices that can be scheduled to maximize the number of non-overlapping appointments. The indices should be returned in the order of the original list. # Constraints * If no appointments can be scheduled, return an empty list. * Each appointment can only be scheduled once. # Example * `max_appointments([(1, 3), (2, 4), (3, 5)])` should return `[0, 2]`. * `max_appointments([(1, 2), (3, 4), (0, 6), (5, 7), (8, 9)])` should return `[0, 1, 3, 4]`. * `max_appointments([(5, 9), (1, 3), (4, 6), (2, 7), (8, 10)])` should return `[1, 2, 4]`. **Note**: If there are multiple optimal solutions, returning any one of them is acceptable. # Requirements * Your implementation should strive for efficient time and space complexity, ideally in O(n log n) time.","solution":"from typing import List, Tuple def max_appointments(appointments: List[Tuple[int, int]]) -> List[int]: # Sort the appointments by end time sorted_appointments = sorted(enumerate(appointments), key=lambda x: x[1][1]) selected_indices = [] last_end_time = -1 for index, (start, end) in sorted_appointments: if start >= last_end_time: selected_indices.append(index) last_end_time = end return sorted(selected_indices)"},{"question":"# Problem Statement You are tasked with analyzing a dataset of temperature readings and determining periods of unusual temperature spikes. Specifically, implement an algorithm that identifies all subarrays of a given length where the average temperature exceeds a specified threshold. This is useful for climate monitoring and detecting anomalous weather patterns. # Objectives 1. Develop a method to find all subarrays of a specified length with an average temperature above the given threshold. 2. Ensure that the algorithm is efficient for large datasets. 3. Return the starting indices of these subarrays within the original dataset. # Function Signature ```python def find_unusual_spikes(temperatures: List[float], k: int, threshold: float) -> List[int]: pass ``` # Input * `temperatures` (List[float]): A list of temperature readings as floating-point numbers. * `k` (int): The length of the subarrays to examine. * `threshold` (float): The average temperature threshold. # Output * Returns a list of integers representing the starting indices of the subarrays where the average temperature exceeds the threshold. # Constraints * The length of the `temperatures` list will be between 1 and (10^6). * The value of `k` will be between 1 and the length of the `temperatures` list. * The `threshold` can be any floating-point number. * The temperatures can be any floating-point numbers. # Example ```python >>> find_unusual_spikes([1.0, 2.0, 3.0, 4.0, 5.0], 3, 3.0) [2] >>> find_unusual_spikes([10.0, 20.0, 30.0, 40.0, 50.0], 2, 25.0) [2, 3] >>> find_unusual_spikes([5.0, 5.0, 5.0, 5.0, 5.0], 2, 6.0) [] ``` # Notes * You can assume the input list will be large, so focus on an efficient solution in terms of both time and space complexity. * A sliding window approach can be useful for maintaining the sum of subarrays of length `k`. * Include comments in your code to explain your approach and any optimizations you made.","solution":"from typing import List def find_unusual_spikes(temperatures: List[float], k: int, threshold: float) -> List[int]: Identifies all subarrays of length k that have an average temperature exceeding the threshold. :param temperatures: List of temperature readings. :param k: Length of the subarrays to check. :param threshold: The average temperature threshold. :return: Starting indices of subarrays where the average temperature exceeds the threshold. n = len(temperatures) result = [] # Calculate the sum required to meet the threshold sum_threshold = k * threshold # Calculate the initial window sum current_sum = sum(temperatures[:k]) # Check if the initial window meets the condition if current_sum > sum_threshold: result.append(0) # Slide the window through the list for i in range(1, n - k + 1): current_sum = current_sum - temperatures[i-1] + temperatures[i+k-1] if current_sum > sum_threshold: result.append(i) return result"},{"question":"**Question: Enhanced Merge Sort** **Context:** Bob frequently deals with merging multiple sorted datasets and needs a reliable method to combine them quickly and efficiently while maintaining order. He is already familiar with the Merge Sort algorithm but wants to improve its efficiency by minimizing memory usage and enhancing its performance for large datasets. **Task:** Your task is to implement an enhanced version of the Merge Sort algorithm with the following specifications: 1. Implement a hybrid approach that switches to Insertion Sort for smaller subarrays (size threshold can be 10 elements). 2. Optimize the merge function to work efficiently in-place without requiring additional memory allocation for merging segments. **Function Signature:** ```python def enhanced_merge_sort(collection: list) -> list: pass ``` **Input:** - `collection` (a list of comparable items): A mutable collection of items to be sorted. **Output:** - A list containing the elements from `collection`, sorted in ascending order. **Constraints:** - The list may contain up to (10^6) elements. - Elements within the list are comparable (e.g., integers or floating-point numbers). **Examples:** 1. `enhanced_merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])` should return `[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]`. 2. `enhanced_merge_sort([])` should return `[]`. 3. `enhanced_merge_sort([-5, -1, 0, 3, 2])` should return `[-5, -1, 0, 2, 3]`. 4. `enhanced_merge_sort([7, 2, 9, 4, 3, 8, 1, 6, 5, 0])` should return `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`. **Additional Notes:** 1. Implement the hybrid approach of Merge Sort using Insertion Sort for very small segments. 2. Ensure the merge function operates in-place to save memory. 3. The implementation should handle large datasets efficiently, maintaining the performance benefits of Merge Sort.","solution":"def enhanced_merge_sort(collection: list) -> list: Enhanced merge sort that uses insertion sort for subarrays of size <= 10. def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr, left, middle, right): left_half_size = middle - left + 1 right_half_size = right - middle left_half = arr[left:left + left_half_size] right_half = arr[middle + 1:middle + 1 + right_half_size] i, j, k = 0, 0, left while i < left_half_size and j < right_half_size: if left_half[i] <= right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < left_half_size: arr[k] = left_half[i] i += 1 k += 1 while j < right_half_size: arr[k] = right_half[j] j += 1 k += 1 def merge_sort(arr, left, right): if left < right: if right - left <= 10: insertion_sort(arr, left, right) else: middle = (left + right) // 2 merge_sort(arr, left, middle) merge_sort(arr, middle + 1, right) merge(arr, left, middle, right) if collection: merge_sort(collection, 0, len(collection) - 1) return collection"},{"question":"# Coding Assessment Question Context Consider a company that arranges employee shifts for a week. Each day of the week, multiple employees are assigned to shifts. The company wants to generate a shift summary that indicates how many unique employees worked each day of the week. Write a function to analyze the shift data and produce this summary. Objective Implement the function `shift_summary(shifts: dict[str, list[str]]) -> dict[str, int]` that returns a dictionary summarizing the number of unique employees per day. Input/Output Format - **Input**: A dictionary `shifts` where keys are strings representing days of the week and values are lists of strings representing employee names who worked that day. - **Output**: A dictionary where keys are the same days of the week and values are integers representing the number of unique employees who worked on those days. Constraints - Each day of the week will appear exactly once as a key in the input dictionary. - Employee names are case-sensitive and consist of alphabets only. - There will be at most 1000 employees in total and at most 7 days in the \'shifts\' dictionary. Example ```python >>> shift_summary({ ... \\"Monday\\": [\\"Alice\\", \\"Bob\\", \\"Alice\\"], ... \\"Tuesday\\": [\\"Alice\\", \\"Eve\\"], ... \\"Wednesday\\": [\\"Eve\\", \\"Mallory\\", \\"Mallory\\"], ... \\"Thursday\\": [\\"Alice\\", \\"Bob\\", \\"Mallory\\"], ... \\"Friday\\": [\\"Alice\\", \\"Bob\\", \\"Alice\\"], ... \\"Saturday\\": [], ... \\"Sunday\\": [\\"Alice\\", \\"Eve\\", \\"Trent\\"] ... }) { \\"Monday\\": 2, # Alice and Bob \\"Tuesday\\": 2, # Alice and Eve \\"Wednesday\\": 2, # Eve and Mallory \\"Thursday\\": 3, # Alice, Bob, and Mallory \\"Friday\\": 2, # Alice and Bob \\"Saturday\\": 0, # No employees \\"Sunday\\": 3 # Alice, Eve, and Trent } ``` Requirements 1. Ensure the function accurately counts unique employees for each day. 2. Input days are the standard days of the week (Monday to Sunday) and should not need additional validation. 3. The implementation should handle edge cases such as empty employee lists.","solution":"def shift_summary(shifts: dict[str, list[str]]) -> dict[str, int]: Takes a dictionary of shifts where keys are days of the week and values are lists of employees\' names, and returns a dictionary with the count of unique employees per day. summary = {} for day, employees in shifts.items(): unique_employees = set(employees) summary[day] = len(unique_employees) return summary"},{"question":"# Problem Statement A company has decided to implement a new system for tracking employee hours. Each employee is required to log their entry and exit times each workday. Your task is to determine the total number of hours each employee has worked over a given period. The company provides the data in a list of strings, where each string represents an entry or exit log. Each log has the following format: ``` \\"YYYY-MM-DD HH:MM [entry/exit] EMPLOYEE_ID\\" ``` Your task is to implement a function that calculates the total working hours for each employee and returns the result in a dictionary format, where the keys are employee IDs and the values are the total hours worked. # Input * A list of strings `logs` representing the entry and exit times of employees. # Output * A dictionary where the keys are employee IDs (as strings) and the values are the total hours worked (as floats, rounded to 2 decimal places). # Constraints * The `logs` list will contain an even number of entries. * Each employee will always have matching entry and exit logs. * Time entries are guaranteed to be valid and follow the \\"YYYY-MM-DD HH:MM [entry/exit] EMPLOYEE_ID\\" format. # Function Signature ```python def calculate_worked_hours(logs: List[str]) -> Dict[str, float]: pass ``` # Examples ```python >>> logs = [ \\"2023-03-01 09:00 entry EMP001\\", \\"2023-03-01 17:00 exit EMP001\\", \\"2023-03-02 09:00 entry EMP001\\", \\"2023-03-02 17:00 exit EMP001\\", \\"2023-03-01 08:00 entry EMP002\\", \\"2023-03-01 16:00 exit EMP002\\" ] >>> calculate_worked_hours(logs) { \'EMP001\': 16.0, \'EMP002\': 8.0 } ``` **Note**: This question tests your ability to parse strings, handle date and time calculations, and aggregate results efficiently. Ensure that you accurately handle the conversion between time formats and calculate the intervals correctly.","solution":"from datetime import datetime from typing import List, Dict def calculate_worked_hours(logs: List[str]) -> Dict[str, float]: This function calculates the total hours worked by each employee. Args: logs (List[str]): A list of strings representing the entry and exit logs of employees. Returns: Dict[str, float]: A dictionary where keys are employee IDs and values are total hours worked. work_hours = {} time_format = \\"%Y-%m-%d %H:%M\\" entries = {} for log in logs: parts = log.split() timestamp = f\\"{parts[0]} {parts[1]}\\" action = parts[2] emp_id = parts[3] if action == \\"entry\\": entries[emp_id] = datetime.strptime(timestamp, time_format) elif action == \\"exit\\" and emp_id in entries: entry_time = entries.pop(emp_id) exit_time = datetime.strptime(timestamp, time_format) worked_time = (exit_time - entry_time).total_seconds() / 3600.0 if emp_id in work_hours: work_hours[emp_id] += worked_time else: work_hours[emp_id] = worked_time # Rounding the hours worked to 2 decimal places for emp_id in work_hours: work_hours[emp_id] = round(work_hours[emp_id], 2) return work_hours"},{"question":"# Question: Develop a Basic Version Control System Context: You\'re tasked with creating a basic version control system that can manage and track changes to files in a simplistic text-file-based project. This version control system will support basic operations like adding files, committing changes, and viewing the history of changes. Task: Write a Python class `VersionControlSystem` that provides the following functionalities: 1. **Adding Files**: Method `add_file(file_name, content)` which adds a new file to the system with the given content. If the file already exists, it should overwrite the content. 2. **Committing Changes**: Method `commit(message)` which creates a commit with the given message, capturing the current state of all files. 3. **Viewing History**: Method `history()` that returns a list of tuples, where each tuple contains the commit number, commit message, and the state of all files at the time of that commit. Example: ```python vcs = VersionControlSystem() vcs.add_file(\'file1.txt\', \'Hello, world!\') vcs.commit(\'Added file1.txt\') vcs.add_file(\'file2.txt\', \'Another file\') vcs.commit(\'Added file2.txt\') vcs.add_file(\'file1.txt\', \'Hello, universe!\') vcs.commit(\'Updated file1.txt\') print(vcs.history()) ``` Expected output: ``` [(1, \'Added file1.txt\', {\'file1.txt\': \'Hello, world!\'}), (2, \'Added file2.txt\', {\'file1.txt\': \'Hello, world!\', \'file2.txt\': \'Another file\'}), (3, \'Updated file1.txt\', {\'file1.txt\': \'Hello, universe!\', \'file2.txt\': \'Another file\'})] ``` Constraints: - Commit messages are non-empty strings. - File names are unique and are non-empty strings. - Each commit captures the state of all added files up to that point. - You should not use any external libraries beyond Python\'s standard library. - Aim to implement this in a way that scales well with a reasonable number of files and commits.","solution":"class VersionControlSystem: def __init__(self): self.files = {} self.commit_log = [] self.commit_count = 0 def add_file(self, file_name, content): Adds a file with the given content or updates the content if the file already exists. self.files[file_name] = content def commit(self, message): Creates a commit with the given message and stores the current state of all files with this commit. self.commit_count += 1 snapshot = self.files.copy() self.commit_log.append((self.commit_count, message, snapshot)) def history(self): Returns a list of tuples, each containing the commit number, commit message, and the state of all files at that commit. return self.commit_log"},{"question":"# Coding Assessment Question Context: Linked lists are a fundamental data structure widely used in computer science for their efficiency in insertion and deletion operations. One common problem is finding and removing the nth node from the end of a linked list, a task that illustrates pointer manipulation and traversal techniques. Problem: Given the head of a singly linked list, implement a function `remove_nth_from_end` that removes the nth node from the end of the list and returns the head of the modified list. Function Signature: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: pass ``` Input: * `head`: A ListNode representing the head of a singly linked list. * `n`: An integer representing the position from the end of the list of the node to remove. Output: * A ListNode representing the head of the modified linked list. Constraints: * The number of nodes in the linked list is between 1 and 10^4. * `n` is always valid, so it is guaranteed that 1 ≤ n ≤ number of nodes in the linked list. Example: ```python # Example 1 # Input: # head = [1, 2, 3, 4, 5] # n = 2 # Output: # [1, 2, 3, 5] head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) n = 2 remove_nth_from_end(head, n) # Returns head of linked list: 1 -> 2 -> 3 -> 5 # Example 2 # Input: # head = [1] # n = 1 # Output: # [] head = ListNode(1) n = 1 remove_nth_from_end(head, n) # Returns head of linked list: None # Example 3 # Input: # head = [1, 2] # n = 1 # Output: # [1] head = ListNode(1, ListNode(2)) n = 1 remove_nth_from_end(head, n) # Returns head of linked list: 1 ``` Instructions: 1. Implement the `remove_nth_from_end` function to handle the above cases. 2. Traverse the linked list efficiently to identify and remove the nth node from the end. 3. Consider edge cases such as removing the head node or lists with only one element. 4. Aim for a solution with O(n) time complexity where n is the number of nodes in the list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: def get_length(node): length = 0 while node: length += 1 node = node.next return length dummy = ListNode(0, head) length = get_length(head) current = dummy for _ in range(length - n): current = current.next current.next = current.next.next return dummy.next"},{"question":"# Question You are tasked with developing a simple chat application that supports multiple clients communicating in real-time through a central server. The goal is to create a server that can handle multiple chat clients, manage user sessions, broadcast messages to all connected clients, and include error handling for common issues. # Task Create a chat server that supports concurrent clients and provides basic chat functionalities. Your application should: 1. Handle multiple client connections using threading or async I/O. 2. Maintain user sessions that keep track of who is connected. 3. Broadcast messages from any client to all other connected clients. 4. Include error handling for network issues and client disconnections. 5. Log chat messages and significant events (like connections and disconnections). # Function Signature ```python def chat_server(port: int, testing: bool = False) -> None: # Your implementation here ``` # Explanation 1. **Port**: The port number on which the chat server should listen. 2. **Testing**: A boolean flag to stop the server after one session for testing purposes. 3. **Existing Code**: Utilize and extend a basic socket server implementation to meet the requirements. # Constraints - Use threading or `asyncio` to support multiple clients. - Limit the maximum number of concurrent client connections to 10. - Provide meaningful log messages for server events and errors. - Ensure that the implementation is efficient and does not block on slow clients. # Example ```python # Server chat_server(54321) ``` # Notes - Consider using libraries such as `threading` or `asyncio`, and proper logging facilities. - Ensure that the implementation is compatible with common network conditions and client behaviors. - Implement a protocol for clients to connect, send messages, and disconnect from the server.","solution":"import socket import threading import logging logging.basicConfig(level=logging.DEBUG, format=\'%(asctime)s - %(levelname)s - %(message)s\') clients = [] def handle_client(client_socket, addr): logging.info(f\\"New connection from {addr}\\") clients.append(client_socket) try: while True: message = client_socket.recv(1024).decode(\'utf-8\') if not message: break logging.info(f\\"Received message from {addr}: {message}\\") broadcast_message(client_socket, message) except ConnectionResetError: logging.warning(f\\"Connection reset by client {addr}\\") finally: logging.info(f\\"Client {addr} disconnected\\") clients.remove(client_socket) client_socket.close() broadcast_message(client_socket, f\\"{addr} has left the chat.\\") def broadcast_message(sender_socket, message): for client in clients: if client != sender_socket: try: client.send(message.encode(\'utf-8\')) except Exception as e: logging.error(f\\"Error sending message to client: {e}\\") def chat_server(port: int, testing: bool = False) -> None: server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind((\'0.0.0.0\', port)) server.listen(10) logging.info(f\\"Server is listening on port {port}\\") try: while True: client_socket, addr = server.accept() client_thread = threading.Thread(target=handle_client, args=(client_socket, addr)) client_thread.start() if testing: break except KeyboardInterrupt: logging.info(\\"Server shutting down...\\") finally: server.close() logging.info(\\"Server closed\\") if __name__ == \\"__main__\\": chat_server(54321)"},{"question":"Problem Statement Write a function that simulates a simple version of a digital multiplexer. A multiplexer is a device that selects one of many input signals and forwards the selected input into a single line. For this problem, assume a 4-to-1 multiplexer with 4 input lines and 2 select lines. Design a function `multiplexer(inputs: List[int], select: List[int]) -> int` that: * Takes a list `inputs` of 4 binary integers (0 or 1) representing the input lines. * Takes a list `select` of 2 binary integers (0 or 1) representing the select lines. * Outputs the value of the selected input line based on the select lines. Here is the mapping between select lines and the input line they select: * `select = [0, 0]` selects `inputs[0]` * `select = [0, 1]` selects `inputs[1]` * `select = [1, 0]` selects `inputs[2]` * `select = [1, 1]` selects `inputs[3]` # Input * A list `inputs` of exactly 4 integers, each either 0 or 1. * A list `select` of exactly 2 integers, each either 0 or 1. # Output * An integer, either 0 or 1, representing the selected input value. # Constraints * The `inputs` list will always contain exactly 4 elements. * The `select` list will always contain exactly 2 elements. * The function should be efficient and straightforward, given the fixed size of inputs and select lines. # Example Input: ```python inputs = [0, 1, 1, 0] select = [0, 1] ``` Output: ```python 1 ``` Explanation: The select lines `[0, 1]` direct the multiplexer to choose `inputs[1]`, which is 1. Input: ```python inputs = [1, 0, 1, 0] select = [1, 1] ``` Output: ```python 0 ``` Explanation: The select lines `[1, 1]` direct the multiplexer to choose `inputs[3]`, which is 0. # Additional Requirements * Ensure your function is robust and handles the input constraints appropriately without unnecessary complexity.","solution":"def multiplexer(inputs, select): Returns the selected value from inputs based on the select lines. Parameters: inputs (List[int]): A list of 4 binary integers (0 or 1). select (List[int]): A list of 2 binary integers (0 or 1). Returns: int: The selected input line value, either 0 or 1. # Convert the select lines to a binary index index = select[0] * 2 + select[1] return inputs[index]"},{"question":"# Problem Statement You are tasked with writing a function that finds all words in a dictionary that can be written using letters of the alphabet on only one row of a standard QWERTY keyboard. The keyboard rows are: 1. First row: \\"QWERTYUIOP\\" 2. Second row: \\"ASDFGHJKL\\" 3. Third row: \\"ZXCVBNM\\" # Input - A list of words (each word is a string containing only uppercase alphabetic characters). # Output - A list of words that can be typed using letters from only one row of the QWERTY keyboard. # Constraints - The length of the list of words will be at most 1000. - Each word in the input list will have a maximum length of 100. - Each word contains only uppercase letters \'A\' - \'Z\'. # Function Signature ```python def find_words_in_one_row(words: List[str]) -> List[str]: pass ``` # Example Your implementation should produce the following outputs given the example inputs: ```python print(find_words_in_one_row([\\"HELLO\\", \\"PYTHON\\", \\"TYPEWRITER\\", \\"SAD\\", \\"GAS\\"])) ``` Expected Output: ```python [\\"TYPEWRITER\\", \\"SAD\\", \\"GAS\\"] ``` # Explanation By examining the list of words and checking which words can be fully typed using letters from just one row of the QWERTY keyboard, the function returns a list of such words. For example, \\"TYPEWRITER\\" can be typed using only the first row, \\"SAD\\" can be typed using only the second row, and \\"GAS\\" can be typed using only the second row as well.","solution":"from typing import List def find_words_in_one_row(words: List[str]) -> List[str]: Returns the list of words that can be typed using letters from only one row of the QWERTY keyboard. first_row = set(\\"QWERTYUIOP\\") second_row = set(\\"ASDFGHJKL\\") third_row = set(\\"ZXCVBNM\\") def is_one_row(word): Helper function to determine if a word can be typed using only one row of the QWERTY keyboard. word_set = set(word) return word_set <= first_row or word_set <= second_row or word_set <= third_row result = [word for word in words if is_one_row(word)] return result"},{"question":"# Question: Reverse a Subarray In this task, you will implement a function that reverses a specified subarray within a given list of integers. The subarray is defined by its start and end indices, and the reversal should only affect the elements between, and including, these indices. Function Signature ```python def reverse_subarray(arr: List[int], start: int, end: int) -> List[int]: pass ``` Input - `arr` (List[int]): A list of N integers. - `start` (int): The starting index of the subarray (0-based). - `end` (int): The ending index of the subarray (0-based). Output - A list of N integers where the subarray defined by `start` and `end` has been reversed. Constraints - The length of the array `arr` can be between 1 and (10^5). - The value of each element in the array is an integer between (-10^9) and (10^9) inclusive. - 0 <= `start` <= `end` < N Examples ```python >>> reverse_subarray([1, 2, 3, 4, 5], 1, 3) [1, 4, 3, 2, 5] >>> reverse_subarray([10, 20, 30, 40, 50], 0, 4) [50, 40, 30, 20, 10] >>> reverse_subarray([7, 8, 9], 1, 1) [7, 8, 9] ``` Notes - Ensure that the start and end indices are valid and handle edge cases where `start` is equal to `end`. - Consider the efficiency of your solution, especially for large arrays up to (10^5) elements.","solution":"from typing import List def reverse_subarray(arr: List[int], start: int, end: int) -> List[int]: Reverses the subarray of \'arr\' defined by indices \'start\' and \'end\'. Parameters: arr (List[int]): The input list of integers. start (int): The starting index of the subarray. end (int): The ending index of the subarray. Returns: List[int]: The list after reversing the specified subarray. while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 return arr"},{"question":"# Coding Question Permutations of String in Lexicographical Order **Context** You are required to implement a function that generates all permutations of a given string in lexicographical order. A permutation of a string is another arrangement of its characters. The lexicographical order sorts items dictionary-style, i.e., alphabetically. **Problem Statement** Write a function `lexicographical_permutations(s: str) -> list` that returns all permutations of the input string `s` in lexicographical order. **Function Signature** ```python def lexicographical_permutations(s: str) -> list: pass ``` **Input** - `s` (1 <= len(s) <= 8): A string which may consist of both lowercase and uppercase letters without spaces. **Output** - A list of all permutations of the input string `s` in lexicographical order. **Example** ```python >>> lexicographical_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> lexicographical_permutations(\\"dog\\") [\'dgo\', \'dog\', \'gdo\', \'god\', \'odg\', \'ogd\'] ``` **Constraints** - The input string length will not exceed 8 characters to ensure a manageable number of permutations. - Handle cases where the input string has repeated characters, ensuring no duplicate permutations in the output. **Edge Cases to Consider** 1. Single character string: The output should just be the string itself. 2. All characters are the same: Handle cases like \\"aaa\\" where all permutations are identical. 3. Mixed casing: Permutations should respect the case of each character during sorting and in the output.","solution":"from itertools import permutations def lexicographical_permutations(s: str) -> list: Returns all permutations of the string s in lexicographical order. perm_set = set(permutations(s)) perm_list = sorted([\'\'.join(p) for p in perm_set]) return perm_list"},{"question":"# Array Reversal with Constraints Context: You are working on a data processing application that requires reversing sections of an array. Specifically, you need to handle arrays under certain constraints to improve the performance of your system. Requirements: 1. Implement the `reverse_subarray` function to reverse elements in a given subarray. * The function should reverse the elements between the given start and end indices (inclusive). 2. Ensure the function validates input constraints: * The array should not be empty. * The start and end indices must define a valid subarray in the input array. 3. Preserve the performance by ensuring the time complexity remains O(n), where n is the number of elements in the subarray. Implementation: Implement the `reverse_subarray` function. The function should handle the input validation and perform the subarray reversal in-place to optimize memory usage. # Function Signature: ```python def reverse_subarray(arr: list, start: int, end: int) -> list: pass ``` # Input/Output Specifications: * **Input**: * `arr` (list): The list of elements to be processed. Must be a non-empty list. * `start` (int): The starting index for the subarray to be reversed. * `end` (int): The ending index for the subarray to be reversed. * **Output**: * (list): The array with the specified subarray reversed. # Constraints: * The array should be a non-empty list of elements. * The start and end indices should be within the bounds of the array and must define a valid subarray (i.e., `0 <= start <= end < len(arr)`). # Examples: ```python assert reverse_subarray([1, 2, 3, 4, 5], 1, 3) == [1, 4, 3, 2, 5] assert reverse_subarray([1, 2, 3, 4, 5], 0, 4) == [5, 4, 3, 2, 1] assert reverse_subarray([10, 20, 30, 40], 2, 3) == [10, 20, 40, 30] assert reverse_subarray([1, 2, 3], 0, 0) == [1, 2, 3] # No change as start == end assert reverse_subarray([\'a\', \'b\', \'c\', \'d\'], 1, 2) == [\'a\', \'c\', \'b\', \'d\'] ``` Implement the `reverse_subarray` function and validate it with the given examples.","solution":"def reverse_subarray(arr: list, start: int, end: int) -> list: Reverses the elements of arr between indices start and end inclusive. # Validate input constraints if not arr: raise ValueError(\\"Array must not be empty.\\") if start < 0 or end >= len(arr) or start > end: raise ValueError(\\"Invalid start or end indices for subarray.\\") # Reverse the subarray in-place using two-pointer approach while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 return arr"},{"question":"# Stock Price Trend Analyzer Context Analyzing stock price trends is a common task in financial applications. One basic analysis is to determine whether the stock prices are increasing, decreasing, or remaining consistent over a series of days. Task Write a function `analyze_trend(prices: list[float]) -> str` that determines the trend of stock prices over a given period. The function should follow these guidelines: 1. If the list contains fewer than 2 prices, raise a `ValueError` with the message \\"At least 2 prices are required to determine a trend\\". 2. The function should return: - `\\"increasing\\"` if every price is greater than or equal to the preceding price. - `\\"decreasing\\"` if every price is less than or equal to the preceding price. - `\\"mixed\\"` if the prices do not consistently increase or decrease. Input - `prices`: A list of floating-point numbers representing the stock prices over a period of days. Output - Return a string indicating the trend: `\\"increasing\\"`, `\\"decreasing\\"`, or `\\"mixed\\"`. Constraints - Each price must be a floating-point number. - The list of prices must contain at least 2 elements. Example ```python analyze_trend([100.5, 101.0, 102.0]) # Output: \\"increasing\\" analyze_trend([150.0, 149.5, 149.0]) # Output: \\"decreasing\\" analyze_trend([120.0, 121.0, 119.0]) # Output: \\"mixed\\" ``` Hints - Consider iterating through the list once to determine the trend. - Ensure you handle cases where prices remain constant over consecutive days.","solution":"def analyze_trend(prices): if len(prices) < 2: raise ValueError(\\"At least 2 prices are required to determine a trend\\") increasing = decreasing = True for i in range(1, len(prices)): if prices[i] < prices[i-1]: increasing = False if prices[i] > prices[i-1]: decreasing = False if increasing: return \\"increasing\\" if decreasing: return \\"decreasing\\" return \\"mixed\\""},{"question":"# Problem Statement You are tasked with writing a function that retrieves the nth smallest element from a given unsorted list of integers. The function should handle cases where the list might contain negative numbers and duplicates. Function Signature ```python def find_nth_smallest_element(arr: List[int], n: int) -> int: ``` Input - `arr` (List[int]): A list of integers. The list can be of any length (including empty), and can contain negative numbers and duplicates. - `n` (int): The position of the desired smallest element in 1-indexed form. Output - `int`: The nth smallest element in the list. Constraints - If `n` is greater than the length of the list, raise an appropriate error. - Handle the cases where the list may be empty appropriately. - Ensure the function works optimally for large lists. # Examples ```python # Example 1 arr = [3, 1, 5, 2, 4, 5] n = 3 assert find_nth_smallest_element(arr, n) == 3 # Example 2 arr = [15, 10, 7, 3, 8] n = 1 assert find_nth_smallest_element(arr, n) == 3 # Example 3 arr = [-10, -20, -30, -40] n = 2 assert find_nth_smallest_element(arr, n) == -30 # Example 4 arr = [7] n = 1 assert find_nth_smallest_element(arr, n) == 7 # Example 5 arr = [] n = 1 try: find_nth_smallest_element(arr, n) except ValueError as e: assert str(e) == \\"The list is empty.\\" ``` # Error Cases ```python # If n is greater than the length of the list arr = [1, 2, 3] n = 5 try: find_nth_smallest_element(arr, n) except ValueError as e: assert str(e) == \\"n is greater than the number of elements in the list.\\" # If the list is empty arr = [] n = 1 try: find_nth_smallest_element(arr, n) except ValueError as e: assert str(e) == \\"The list is empty.\\" ``` # Explanation Your task is to implement the given function so that it retrieves the nth smallest element from the given list of integers. The function should correctly handle invalid inputs, such as when `n` is greater than the length of the list or when the list is empty, by raising appropriate errors.","solution":"from typing import List def find_nth_smallest_element(arr: List[int], n: int) -> int: Retrieves the nth smallest element from the given list. if not arr: raise ValueError(\\"The list is empty.\\") if n > len(arr): raise ValueError(\\"n is greater than the number of elements in the list.\\") sorted_arr = sorted(arr) return sorted_arr[n - 1]"},{"question":"# Question: Reverse Rotated Sorted Array Search You are tasked with implementing a function that searches for a target value in a rotated sorted array. The array is sorted in ascending order, but it has been rotated at some unknown pivot such that the original order is disrupted. Your function should return the index of the target value if it is present in the array, or -1 if it is not found. Constraints 1. The input array contains integers. 2. The array may be empty. 3. The target is an integer. Input and Output Format * **Input**: A list of integers representing the rotated sorted array, and an integer as the target value. - Example: `[4, 5, 6, 7, 0, 1, 2], target = 0` * **Output**: An integer representing the index of the target value or -1 if the target is not in the array. - Example: `4` Function Signature ```python def search_in_rotated_sorted_array(arr: list[int], target: int) -> int: ``` Implementation Details 1. If the input array is empty, return -1. 2. Implement a binary search that accounts for the rotation in the sorted array. 3. Optimize the function to run in O(log n) time complexity. Examples ```python >>> search_in_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search_in_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2], 3) -1 >>> search_in_rotated_sorted_array([], 1) -1 >>> search_in_rotated_sorted_array([6, 7, 0, 1, 2, 4, 5], 7) 1 >>> search_in_rotated_sorted_array([6, 7, 0, 1, 2, 4, 5], 8) -1 ``` Notes * Consider edge cases where the array might be fully sorted (no rotation) or rotated such that the smallest element is at the beginning or end of the array. * Ensure the function correctly handles duplicate entries if they appear in the input array.","solution":"def search_in_rotated_sorted_array(arr, target): Searches for the target value in a rotated sorted array. Parameters: arr (list): List of integers in rotated sorted order. target (int): Integer value to search for in the array. Returns: int: The index of the target value if found, otherwise -1. if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Check if left half is sorted if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 # Right half is sorted else: if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement Write a function to implement the sieve of Eratosthenes algorithm to find all prime numbers less than a given integer `n`. The function should return a list of primes in ascending order. Additionally, extend the function to return the time taken to find these primes for performance analysis purposes. # Function Signature ```python from typing import List, Tuple import time def sieve_of_eratosthenes(n: int) -> Tuple[List[int], float]: Find all prime numbers less than the given integer `n` using the sieve of Eratosthenes, and return the list of primes along with the time taken to perform the computation. :param n: The upper limit (exclusive) to find primes below. :returns: A tuple consisting of a list of prime numbers and the time taken to compute them. :raises ValueError: If n is less than 2. ``` # Inputs 1. `n`: An integer greater than or equal to 2, representing the upper limit to find primes below. # Outputs 1. `primes_list`: A list of prime numbers less than `n`. 2. `elapsed_time`: The time taken to execute the sieve algorithm in seconds. # Example ```python # Test case 1: primes, time_taken = sieve_of_eratosthenes(10) assert primes == [2, 3, 5, 7] assert type(time_taken) == float # Test case 2: primes, time_taken = sieve_of_eratosthenes(20) assert primes == [2, 3, 5, 7, 11, 13, 17, 19] assert type(time_taken) == float ``` # Notes - Handle the edge case where `n` is less than 2 by raising a `ValueError`. - Utilize the Sieve of Eratosthenes algorithm for an efficient way to find all primes less than `n`. - Measure the time taken accurately using appropriate timing functions and ensure the returned time is in seconds. - Ensure the function is optimized in terms of time and space complexity where feasible.","solution":"from typing import List, Tuple import time def sieve_of_eratosthenes(n: int) -> Tuple[List[int], float]: if n < 2: raise ValueError(\\"`n` must be greater than or equal to 2.\\") start_time = time.time() sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False primes_list = [num for num, is_prime in enumerate(sieve) if is_prime] elapsed_time = time.time() - start_time return (primes_list, elapsed_time)"},{"question":"# Problem Statement You are tasked with enhancing the functionality of a queue implemented using two stacks. Currently, the queue supports basic enqueue and dequeue operations using two stacks. Your objective is to add two new operations to this queue implementation: 1. **Peek Minimum**: Write a method `peek_minimum` within the `QueueWithTwoStacks` class that returns the minimum element in the queue without removing it. 2. **Sort Queue**: Write a method `sort_queue` within the `QueueWithTwoStacks` class that sorts the elements of the queue in ascending order. # Expected Input and Output 1. **Peek Minimum**: - **Input**: None (invoked on a queue instance) - **Output**: An element (the minimum element in the queue) - **Example**: ```python queue = QueueWithTwoStacks() queue.enqueue(3) queue.enqueue(1) queue.enqueue(4) print(queue.peek_minimum()) # Output: 1 ``` 2. **Sort Queue**: - **Input**: None (invoked on a queue instance) - **Output**: None (modifies the queue in place) - **Example**: ```python queue = QueueWithTwoStacks() queue.enqueue(3) queue.enqueue(1) queue.enqueue(4) queue.sort_queue() print(queue) # Output: 1->3->4 ``` # Constraints * You may use only the two stacks already present in the queue implementation to perform these operations. * The queue may contain any number of elements, including zero. * When implementing `peek_minimum` and `sort_queue`, you may only use basic operations like push, pop, and peek from the stack interface. * All elements in the queue are comparable (implement the `__lt__` method). Implement the `peek_minimum` and `sort_queue` methods in `QueueWithTwoStacks` class based on the already provided queue code.","solution":"class QueueWithTwoStacks: def __init__(self): Initialize the queue with two stacks. self.stack1 = [] self.stack2 = [] def enqueue(self, item): Adds an item to the queue. :param item: Item to add self.stack1.append(item) def dequeue(self): Removes and returns the item at the front of the queue. :return: The front item if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() if self.stack2 else None def peek_minimum(self): Returns the minimum element in the queue without removing it. :return: The minimum element min_elem = float(\'inf\') # Check elements in stack1 and stack2 for the minimum element for elem in self.stack1: min_elem = min(min_elem, elem) for elem in self.stack2: min_elem = min(min_elem, elem) return min_elem if min_elem != float(\'inf\') else None def sort_queue(self): Sorts the elements of the queue in ascending order in place. # Transfer all elements from both stacks to a temporary list temp_list = [] while self.stack1: temp_list.append(self.stack1.pop()) while self.stack2: temp_list.append(self.stack2.pop()) # Sort the list temp_list.sort() # Transfer the sorted elements back to stack1 to maintain queue order for item in temp_list: self.stack1.append(item)"},{"question":"# Question: Happy Number Validation **Context** A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number either equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. For example: - 19 is a happy number, because: - 1<sup>2</sup> + 9<sup>2</sup> = 1 + 81 = 82 - 8<sup>2</sup> + 2<sup>2</sup> = 64 + 4 = 68 - 6<sup>2</sup> + 8<sup>2</sup> = 36 + 64 = 100 - 1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1 **Task** Write a function `is_happy_number(n: int) -> bool` that determines if a given integer `n` is a happy number. **Input** - `n` is a single integer (1 <= n <= 1,000,000) **Output** - Return `True` if `n` is a happy number, otherwise return `False`. **Constraints** - You can assume the input will always be a positive integer within the given range. **Examples** ```python >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(1) True >>> is_happy_number(7) True ``` **Notes** - Use the above examples to test correctness. - Consider the performance implications when `n` is a very large number. - Think through all possible edge cases within the input constraints. - Hint: Use a set to track seen numbers to detect cycles. Write your function below: ```python def is_happy_number(n: int) -> bool: # Your implementation here ```","solution":"def is_happy_number(n: int) -> bool: def get_next(number): return sum(int(ch)**2 for ch in str(number)) seen_numbers = set() while n != 1 and n not in seen_numbers: seen_numbers.add(n) n = get_next(n) return n == 1"},{"question":"# Question: Number Summation in 2D Matrix You are tasked with implementing a function `matrix_range_sum` that computes the sum of elements within specific submatrices of a given 2D matrix. The function will receive a matrix and a list of queries, where each query defines a submatrix by specifying the top-left and bottom-left coordinates. Function Requirements: 1. **Function `matrix_range_sum`**: - **Input**: - A list of lists of integers `matrix`, representing a 2D matrix - A list of tuples `queries`, where each tuple contains four integers `(r1, c1, r2, c2)` defining a submatrix with `(r1, c1)` as the top-left and `(r2, c2)` as the bottom-right coordinates. - **Output**: - A list of integers where each integer is the sum of the elements inside the submatrix defined by the corresponding query in `queries`. Constraints: - The input matrix will have dimensions between 1x1 and 1000x1000. - Each query in `queries` will always define a valid submatrix within the bounds of the matrix. Examples: ```python def matrix_range_sum(matrix: list[list[int]], queries: list[tuple[int, int, int, int]]) -> list[int]: # Your implementation here # Example 1: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 2, 2), # Submatrix: [[5, 6], [8, 9]] (0, 0, 2, 2) # Submatrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ] # Output: [28, 45] Explanation: # Sum of submatrix [[5, 6], [8, 9]] is 5 + 6 + 8 + 9 = 28 # Sum of submatrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]] is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45 # Example 2: matrix = [ [10, 20], [30, 40] ] queries = [ (0, 0, 1, 1), # Submatrix: [[10, 20], [30, 40]] (0, 1, 1, 1) # Submatrix: [[20], [40]] ] # Output: [100, 60] Explanation: # Sum of submatrix [[10, 20], [30, 40]] is 10 + 20 + 30 + 40 = 100 # Sum of submatrix [[20], [40]] is 20 + 40 = 60 ``` Implement the `matrix_range_sum` function to meet the specifications above. Ensure your implementation efficiently handles edge cases and adheres to the constraints.","solution":"def matrix_range_sum(matrix, queries): Compute the sum of elements within specific submatrices of a given 2D matrix. Parameters: matrix (list of lists of int): 2D matrix of integers. queries (list of tuples of int): List of queries, each query defines a submatrix with (r1, c1, r2, c2). Returns: list of int: A list of the sum of the elements inside the submatrix defined by each query. results = [] for (r1, c1, r2, c2) in queries: submatrix_sum = 0 for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): submatrix_sum += matrix[i][j] results.append(submatrix_sum) return results"},{"question":"# Analyzing Stock Market Data for Trend Analysis You are working on a financial software that requires analyzing historical stock market price data to identify trends and make predictions. Your task is to implement a function that computes the Simple Moving Average (SMA) for a given stock price series. The SMA is a commonly used indicator in technical analysis that helps smooth out price data to identify trends over a specified period. Task Description: Implement a function `calculate_sma` that: - Takes as input: * `prices` (List[float]): A list of historical stock prices. * `window_size` (int): The period over which to compute the SMA (default is 5). - Returns: * A list of SMA values. The length of this list should be equal to the length of the input list `prices`. For the initial `window_size - 1` entries where SMA cannot be computed, return `None`. Constraints: - The length of the `prices` list will be between 1 and 10,000 inclusive. - `prices` will contain positive floating-point numbers only. - `window_size` will always be a positive integer less than or equal to the length of `prices`. Notes: - Ensure that the function handles edge cases, such as when the `prices` list is shorter than `window_size`. - The function should efficiently handle the computation to perform well even for the maximum input size. Example Usage: ```python >>> prices = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0] >>> window_size = 3 >>> sma = calculate_sma(prices, window_size) >>> sma [None, None, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] ``` Implement `calculate_sma` that returns the correct Simple Moving Averages for the given list of prices and window_size.","solution":"def calculate_sma(prices, window_size=5): Calculates the Simple Moving Average (SMA) for a given list of stock prices. Args: prices (List[float]): A list of historical stock prices. window_size (int): The period over which to compute the SMA. Returns: List[float]: A list of SMA values. For the initial window_size - 1 entries, return None. if window_size <= 0 or window_size > len(prices): raise ValueError(\\"window_size must be a positive integer less than or equal to the length of prices\\") sma = [None] * (window_size - 1) for i in range(window_size - 1, len(prices)): window = prices[i - window_size + 1:i + 1] sma.append(sum(window) / window_size) return sma"},{"question":"# Problem: Consecutive Character Counter Context: You are developing a text analysis tool that requires identifying sequences of consecutive identical characters in a string. This information can help in various applications like data compression or pattern recognition. Task: Write a function `count_consecutive(s: str) -> List[Tuple[str, int]]` that takes a string `s` and returns a list of tuples. Each tuple contains a character and an integer representing the number of consecutive occurrences of that character. Input: - A string `s` (1 ≤ |s| ≤ 10^5), where `|s|` is the length of the string. Output: - A list of tuples where each tuple consists of a character and an integer. Constraints: - The string `s` will only contain lowercase alphabets. - The function should be efficient with a target time complexity of O(n), where `n` is the length of the string. Examples: ```python assert count_consecutive(\\"aabbbccde\\") == [(\'a\', 2), (\'b\', 3), (\'c\', 2), (\'d\', 1), (\'e\', 1)] assert count_consecutive(\\"aaaaaa\\") == [(\'a\', 6)] assert count_consecutive(\\"abc\\") == [(\'a\', 1), (\'b\', 1), (\'c\', 1)] assert count_consecutive(\\"aabbaa\\") == [(\'a\', 2), (\'b\', 2), (\'a\', 2)] assert count_consecutive(\\"bbaaccdd\\") == [(\'b\', 2), (\'a\', 2), (\'c\', 2), (\'d\', 2)] ``` Hints: - Consider iterating through the string once and counting the consecutive characters. - Use a loop to traverse the string and keep track of the current character and its count.","solution":"from typing import List, Tuple def count_consecutive(s: str) -> List[Tuple[str, int]]: Returns a list of tuples with each character from the string `s` and the count of consecutive occurrences of that character. if not s: return [] result = [] current_char = s[0] count = 1 for i in range(1, len(s)): if s[i] == current_char: count += 1 else: result.append((current_char, count)) current_char = s[i] count = 1 result.append((current_char, count)) return result"},{"question":"# Question: Design a Rate Limiter Class You are required to design a Rate Limiter class to control requests sent to a server based on a specified maximum number of allowed requests per given timeframe. The RateLimiter class should have the following functionalities: 1. **RateLimiter(int maxRequests, int timeframeMillis)**: Constructs a Rate Limiter with a maximum number of allowed requests (`maxRequests`) within a given timeframe in milliseconds (`timeframeMillis`). 2. **bool allowRequest(int timestamp)**: Returns whether a request is allowed based on the given `timestamp` in milliseconds since the epoch (Jan 1, 1970). If the number of requests in the last `timeframeMillis` milliseconds exceeds `maxRequests`, it returns `false`; otherwise, it returns `true`. **Constraints**: - All provided timestamps are 64-bit signed integers. - You can assume that timestamps are provided in a non-decreasing order. **Example**: ```python # Initialize a RateLimiter with a maximum of 2 requests per 1000 milliseconds rateLimiter = RateLimiter(2, 1000) print(rateLimiter.allowRequest(1000)) # Output: True, (1st request in time window) print(rateLimiter.allowRequest(1500)) # Output: True, (2nd request in time window) print(rateLimiter.allowRequest(1800)) # Output: False, (3rd request within the same time window exceeds limit) print(rateLimiter.allowRequest(2500)) # Output: True, (New request in new time window) ``` **Note**: - You should maintain an efficient internal representation to track request timestamps in the given timeframe. - Consider both time and space complexity while implementing the solution.","solution":"from collections import deque class RateLimiter: def __init__(self, maxRequests, timeframeMillis): Initialize the Rate Limiter with the given maxRequests and timeframeMillis. self.maxRequests = maxRequests self.timeframeMillis = timeframeMillis self.requests = deque() def allowRequest(self, timestamp): Determine whether a request at the given timestamp is allowed. # Remove all requests that are outside the timeframe while self.requests and self.requests[0] <= timestamp - self.timeframeMillis: self.requests.popleft() # Check if we can allow this request if len(self.requests) < self.maxRequests: self.requests.append(timestamp) return True else: return False"},{"question":"# Problem Statement You are designing a simple text editor that manages a string of lowercase alphabetical characters with some basic operations. The editor supports the following operations: 1. Append a string to the end of the current text. 2. Delete the last `k` characters from the text. 3. Retrieve and return the character at position `i` in the text. 4. Undo the last append or delete operation. Your task is to implement the text editor with these operations. # Function Signature ```python class TextEditor: def __init__(self): Initializes an empty text editor. pass def append(self, w: str) -> None: Appends the string \'w\' to the end of the current text. Args: w: string to be appended. pass def delete(self, k: int) -> None: Deletes the last \'k\' characters from the current text. Args: k: number of characters to be deleted from the end. pass def get_char_at(self, i: int) -> str: Returns the character at the position \'i\' in the current text. Args: i: index of the character to retrieve. Returns: Character at position \'i\'. pass def undo(self) -> None: Undoes the last append or delete operation. pass ``` # Example Usage ```python # Initializing the text editor editor = TextEditor() # Append \\"hello\\" to the text editor.append(\\"hello\\") # Get character at position 1 (0-indexed) print(editor.get_char_at(1)) # Output: e # Append \\"world\\" to the text editor.append(\\"world\\") # Get character at position 5 print(editor.get_char_at(5)) # Output: w # Delete last 3 characters editor.delete(3) # Get character at position 7 print(editor.get_char_at(7)) # Output: r # Undo last operation (which was a delete) editor.undo() # Get character at position 7 print(editor.get_char_at(7)) # Output: o # Undo last operation (which was an append) editor.undo() # Get character at position 7 print(editor.get_char_at(7)) # Output: IndexError: String index out of range ``` # Constraints * The appended string `w` will only contain lowercase alphabetical characters (`a-z`). * The position `i` provided to `get_char_at` will always be valid within the current text. * The sequence of operations will be such that there will always be a valid state for \'undo\'. # Evaluation * **Correctness**: Ensure that each operation correctly manipulates the text data. * **Efficiency**: Given potentially large texts, efficient handling of operations is required. * **Robustness**: Handle edge cases correctly, particularly around the `undo` functionality.","solution":"class TextEditor: def __init__(self): Initializes an empty text editor. self.text = \\"\\" self.history = [] def append(self, w: str) -> None: Appends the string \'w\' to the end of the current text. Args: w: string to be appended. self.history.append(self.text) self.text += w def delete(self, k: int) -> None: Deletes the last \'k\' characters from the current text. Args: k: number of characters to be deleted from the end. self.history.append(self.text) self.text = self.text[:-k] def get_char_at(self, i: int) -> str: Returns the character at the position \'i\' in the current text. Args: i: index of the character to retrieve. Returns: Character at position \'i\'. return self.text[i] def undo(self) -> None: Undoes the last append or delete operation. if self.history: self.text = self.history.pop()"},{"question":"# Question: Operations on Fibonacci Numbers and Sums **Context:** You are contributing to an algorithm library focused on number sequences. One of the most significant sequences in mathematics and computer science is the Fibonacci sequence. The library will include functions for direct Fibonacci number calculation, sum of Fibonacci numbers, and sums of squares of Fibonacci numbers. **Objective:** Implement the following functions, making sure to handle edge cases, optimize for performance, and provide precise results for all valid input ranges: 1. **Fibonacci Number**: Compute the n-th Fibonacci number. 2. **Sum of Fibonacci Numbers**: Compute the sum of the first n Fibonacci numbers. 3. **Sum of Squares of Fibonacci Numbers**: Compute the sum of the squares of the first n Fibonacci numbers. **Function Signatures:** ```python def fibonacci(n: int) -> int: pass def sum_of_fibonacci(n: int) -> int: pass def sum_of_squares_of_fibonacci(n: int) -> int: pass ``` **Expected Input and Output**: ```python assert fibonacci(10) == 55 assert sum_of_fibonacci(10) == 143 assert sum_of_squares_of_fibonacci(10) == 4895 ``` **Constraints:** - The input will be a non-negative integer (n >= 0). - Ensure the functions are efficient for n up to 10^5. **Detailed Requirements:** 1. **Fibonacci Number**: - **Input:** A non-negative integer n. - **Output:** The n-th Fibonacci number. - Use an efficient iterative approach to avoid the inefficiencies of recursive computation. 2. **Sum of Fibonacci Numbers**: - **Input:** A non-negative integer n. - **Output:** The sum of the first n Fibonacci numbers. - Use the property that the sum of the first n Fibonacci numbers is equal to the (n+2)-th Fibonacci number minus 1 (i.e., `S(n) = F(n+2) - 1`). 3. **Sum of Squares of Fibonacci Numbers**: - **Input:** A non-negative integer n. - **Output:** The sum of the squares of the first n Fibonacci numbers. - Apply the identity that relates the sum of squares of Fibonacci numbers to Fibonacci numbers themselves (i.e., `The sum of squares of the first n Fibonacci numbers S(n) = F(n) * F(n+1)`). **Edge Cases to Consider**: - Minimal Input: Test with n = 0, which should return 0 for sums and squares as well. - Large Values: Test with the maximum value (e.g., n = 10^5) to ensure performance. - Boundary Cases: Ensure correctness for small values like n = 1 or n = 2. **Note:** Efficiency and correctness are crucial for handling large inputs within reasonable execution times.","solution":"def fibonacci(n: int) -> int: Compute the n-th Fibonacci number using an iterative approach. The 0th Fibonacci number is 0, the 1st is 1, and so on. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def sum_of_fibonacci(n: int) -> int: Compute the sum of the first n Fibonacci numbers. Uses the property that the sum of the first n Fibonacci numbers is F(n+2) - 1. if n == 0: return 0 return fibonacci(n + 2) - 1 def sum_of_squares_of_fibonacci(n: int) -> int: Compute the sum of the squares of the first n Fibonacci numbers. Uses the identity S(n) = F(n) * F(n+1). if n == 0: return 0 elif n == 1: return 1 fib_n = fibonacci(n) fib_n_plus_1 = fibonacci(n + 1) return fib_n * fib_n_plus_1"},{"question":"String Compression - Optimize and Implement In this task, you are required to implement an optimized version of a string compression algorithm. The primary objective of the algorithm is to take a string containing repeated characters and return a compressed version by replacing consecutive repetitions with the character followed by the number of repetitions. Your Task 1. **Optimize Compression**: Optimize the given string compression algorithm to minimize the processing time. 2. **Function Implementation**: Implement a function that achieves this optimization. Requirements - Implement the function `compress_string_optimized(s: str) -> str` that compresses the string by replacing groups of repeated characters with the character and the count. - The function should not solely rely on string concatenation within loops, and should make use of efficient data structures where possible. Input - A string `s` of length ≤ 10^6. Output - A compressed string where consecutive repetitions are replaced by the character followed by the number of repetitions. Constraints - The input string length will be ≤ 10^6. - If the compressed string is longer than the original string, return the original string. Example ```python >>> compress_string_optimized(\\"aaabbcc\\") \'a3b2c2\' >>> compress_string_optimized(\\"abcd\\") \'abcd\' >>> compress_string_optimized(\\"aabcccccaaa\\") \'a2b1c5a3\' ```","solution":"def compress_string_optimized(s: str) -> str: Compresses the string by replacing consecutive repetitions with the character followed by the count of repetitions in a row. If the compressed string is longer than the original string, returns the original string. if not s: return \\"\\" compressed = [] count = 1 previous_char = s[0] for i in range(1, len(s)): if s[i] == previous_char: count += 1 else: compressed.append(previous_char + str(count)) previous_char = s[i] count = 1 compressed.append(previous_char + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Coding Assessment Question: **Objective**: Implement a custom data structure `SparseVector` that supports efficient vector operations, specifically optimized for sparse vectors (vectors in which most elements are zero). Provide support for basic operations like vector addition and dot product. **Instructions**: Implement a `SparseVector` class with the following methods: 1. `__init__(self, nums: List[int])`: Initialize the `SparseVector` with a given list of integers. 2. `add(self, other: \'SparseVector\') -> \'SparseVector\'`: Add two `SparseVector` objects and return a new `SparseVector` representing their sum. 3. `dot_product(self, other: \'SparseVector\') -> int`: Compute the dot product of two `SparseVector` objects and return the resulting scalar. **Constraints**: * Assume both input vectors are of the same length. * The length of any vector can be from 1 to 10^5. * Elements of the vectors can range from -10^5 to 10^5. * Optimize space by only storing non-zero elements. * Efficiently handle operations considering the structure is sparse. **Example**: ```python v1 = SparseVector([1, 0, 0, 2, 3]) v2 = SparseVector([0, 3, 0, 4, 0]) v3 = v1.add(v2) print(v3.to_list()) # Expected output: [1, 3, 0, 6, 3] dot_product_result = v1.dot_product(v2) print(dot_product_result) # Expected output: 8 ``` **Detailed Requirements**: * You must ensure that the `SparseVector` class stores only non-zero elements for optimized performance. * The `add` method should return a new `SparseVector` representing the element-wise addition of the two vectors. * The `dot_product` method should compute and return the scalar result of the dot product of the two vectors. Good luck!","solution":"class SparseVector: def __init__(self, nums): Initializes the SparseVector with a given list of integers. Only store non-zero elements for optimal space usage. self.values = {i: val for i, val in enumerate(nums) if val != 0} def add(self, other): Add two SparseVector objects and return a new SparseVector representing their sum. result = {} keys = set(self.values.keys()).union(other.values.keys()) for key in keys: result[key] = self.values.get(key, 0) + other.values.get(key, 0) return SparseVector.from_dict(result) def dot_product(self, other): Compute the dot product of two SparseVector objects and return the resulting scalar. result = 0 for key in self.values: if key in other.values: result += self.values[key] * other.values[key] return result @staticmethod def from_dict(values_dict): Helper method to create a SparseVector from a dictionary of non-zero values. length = max(values_dict.keys()) + 1 if values_dict else 0 nums = [values_dict.get(i, 0) for i in range(length)] return SparseVector(nums) def to_list(self): Convert the SparseVector back to a list representation. length = max(self.values.keys()) + 1 if self.values else 0 return [self.values.get(i, 0) for i in range(length)]"},{"question":"# Mean Calculation of Squares - Function Implementation Problem Statement In data analysis, it is often useful to compute the mean of the squares of a set of numbers. Your task is to implement a Python function that computes the mean of the squares of the given list of integers. You should complete the Python function `mean_of_squares` that follows this signature: ```python def mean_of_squares(numbers: List[int]) -> float: pass ``` - **numbers**: A list of integers. The function should return: - The mean of the squares of the numbers as a float. # Constraints - The input list will contain at least one element and no more than 10,000 elements. - All numbers in the input list will be between -10,000 and 10,000 inclusive. # Examples ```python >>> mean_of_squares([1, 2, 3]) 4.666666666666667 >>> mean_of_squares([-1, -2, 3, 4]) 7.5 >>> mean_of_squares([0, 0, 0]) 0.0 >>> mean_of_squares([10, 10]) 100.0 ``` # Requirements - **Input/output format**: As specified above. - **Performance**: The solution should have a linear time complexity, O(n). - **Errors**: Assume the input list is always non-empty and contains valid integers within the specified range.","solution":"from typing import List def mean_of_squares(numbers: List[int]) -> float: Calculate the mean of the squares of a list of numbers. Parameters: numbers (List[int]): A list of integers Returns: float: The mean of the squares of the numbers square_sum = sum(x**2 for x in numbers) mean_square = square_sum / len(numbers) return mean_square"},{"question":"# Problem Statement: Implement an advanced data processing pipeline that can efficiently handle large datasets. Your task is to create a framework to process data in a memory-efficient manner. This involves implementing a custom data iterator and integrating it with a basic data processing function. # Requirements: 1. **Data Iterator:** - Create a class `DataIterator` that can iterate through a large dataset stored in a file. This class should read the data in chunks (to handle large files that do not fit into memory). 2. **Data Processing Function:** - Implement a function `process_data(chunk: List[str]) -> List[str]` that processes a chunk of data (e.g., performing a transformation such as converting strings to uppercase). 3. **Chunk-Based Processing:** - Integrate the data iterator with the data processing function to process the entire dataset chunk by chunk. 4. **Result Aggregation:** - Ensure that the processed data is collated and written to an output file. # Input/Output Formats: * **Input:** - `input_file`: A string representing the file path of the input data. - `output_file`: A string representing the file path where the processed data should be saved. - `chunk_size`: An integer representing the number of lines to read and process at a time. * **Output:** - None. The function should write the processed data to the `output_file`. # Constraints: - `chunk_size` will be an integer between 1 and 10,000. - The input file may contain up to 1,000,000 lines. - Each line in the input file will be a string of length <= 100 characters. - Ensure the processing is done in a memory-efficient manner. # Sample Code: ```python class DataIterator: def __init__(self, file_path: str, chunk_size: int): self.file_path = file_path self.chunk_size = chunk_size def __iter__(self): with open(self.file_path, \'r\') as file: chunk = [] for line in file: chunk.append(line.strip()) if len(chunk) == self.chunk_size: yield chunk chunk = [] if chunk: yield chunk def process_data(chunk: List[str]) -> List[str]: return [line.upper() for line in chunk] def process_large_file(input_file: str, output_file: str, chunk_size: int) -> None: iterator = DataIterator(input_file, chunk_size) with open(output_file, \'w\') as out_file: for chunk in iterator: processed_chunk = process_data(chunk) for line in processed_chunk: out_file.write(line + \'n\') ``` # Example Usage: ```python input_file = \'large_dataset.txt\' output_file = \'processed_dataset.txt\' chunk_size = 1000 process_large_file(input_file, output_file, chunk_size) print(\\"Data processing complete. Processed data saved to:\\", output_file) ``` **Note:** Ensure the implementation handles large datasets efficiently by processing the data in chunks.","solution":"import os from typing import List class DataIterator: def __init__(self, file_path: str, chunk_size: int): self.file_path = file_path self.chunk_size = chunk_size def __iter__(self): with open(self.file_path, \'r\') as file: chunk = [] for line in file: chunk.append(line.strip()) if len(chunk) == self.chunk_size: yield chunk chunk = [] if chunk: yield chunk def process_data(chunk: List[str]) -> List[str]: return [line.upper() for line in chunk] def process_large_file(input_file: str, output_file: str, chunk_size: int) -> None: iterator = DataIterator(input_file, chunk_size) with open(output_file, \'w\') as out_file: for chunk in iterator: processed_chunk = process_data(chunk) for line in processed_chunk: out_file.write(line + \'n\')"},{"question":"# Sparse Matrix Operations In this exercise, you will implement a class `SparseMatrix` to manage and perform operations on sparse matrices. A sparse matrix is a matrix in which most of the elements are zero. You will represent a sparse matrix using a dictionary where keys are tuples representing the position (i, j) and values are the non-zero entries of the matrix. Task Implement the following methods for the `SparseMatrix` class: 1. **Initialization (`__init__`)**: - Initializes a sparse matrix with given rows, columns, and a dictionary of non-zero entries. 2. **Addition (`__add__`)**: - Adds two sparse matrices and returns the resulting sparse matrix. Ensure the matrices have the same dimensions. 3. **Subtraction (`__sub__`)**: - Subtracts one sparse matrix from another and returns the resulting sparse matrix. Ensure the matrices have the same dimensions. 4. **Multiplication (`__mul__`)**: - Multiplies two sparse matrices and returns the resulting sparse matrix. Ensure the matrices are compatible for multiplication. 5. **Transpose (`transpose`)**: - Returns the transpose of the sparse matrix. 6. **Equality (`__eq__`)**: - Compares two sparse matrices for equality. 7. **Density (`density`)**: - Returns the density of the sparse matrix as the ratio of non-zero elements to the total number of elements in the matrix. 8. **Display (`__str__`)**: - Returns the string representation of the sparse matrix. Input and Output Formats - **Input**: - Initialization: `SparseMatrix(rows: int, cols: int, elements: Dict[Tuple[int, int], float])` - Operations: As per operator overloading for `+`, `-`, `*`, and methods for `transpose`, `__eq__`, `density`, and `__str__`. - **Output**: - Returns new `SparseMatrix` instances or results as specified by the operations. Example ```python # Initialization m1 = SparseMatrix(3, 3, {(0, 0): 1, (1, 2): 3}) m2 = SparseMatrix(3, 3, {(0, 0): 2, (1, 2): 1}) # Addition print(m1 + m2) # Should output the sparse matrix representation: {(0, 0): 3, (1, 2): 4} # Subtraction print(m1 - m2) # Should output the sparse matrix representation: {(0, 0): -1, (1, 2): 2} # Multiplication m3 = SparseMatrix(3, 2, {(0, 1): 4, (2, 0): 5}) m4 = SparseMatrix(2, 3, {(1, 0): 3, (0, 2): 2}) print(m3 * m4) # Should output the sparse matrix representation: {(0, 0): 12, (2, 2): 10} # Transpose print(m1.transpose()) # Should output the sparse matrix representation: {(0, 0): 1, (2, 1): 3} # Equality print(m1 == SparseMatrix(3, 3, {(0, 0): 1, (1, 2): 3})) # Should output: True # Density print(m1.density()) # Should output: 0.2222222222222222 # Display print(m1) # Should output the string representation of SparseMatrix ```","solution":"class SparseMatrix: def __init__(self, rows, cols, elements): self.rows = rows self.cols = cols self.elements = elements def __add__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices dimensions do not match for addition.\\") result = self.elements.copy() for key, value in other.elements.items(): result[key] = result.get(key, 0) + value return SparseMatrix(self.rows, self.cols, result) def __sub__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices dimensions do not match for subtraction.\\") result = self.elements.copy() for key, value in other.elements.items(): result[key] = result.get(key, 0) - value return SparseMatrix(self.rows, self.cols, result) def __mul__(self, other): if self.cols != other.rows: raise ValueError(\\"Matrices dimensions do not match for multiplication.\\") result = {} for (i, k), v in self.elements.items(): for j in range(other.cols): if (k, j) in other.elements: if (i, j) in result: result[(i, j)] += v * other.elements[(k, j)] else: result[(i, j)] = v * other.elements[(k, j)] return SparseMatrix(self.rows, other.cols, result) def transpose(self): result = {} for (i, j), v in self.elements.items(): result[(j, i)] = v return SparseMatrix(self.cols, self.rows, result) def __eq__(self, other): if self.rows != other.rows or self.cols != other.cols: return False return self.elements == other.elements def density(self): return len(self.elements) / (self.rows * self.cols) def __str__(self): result = [] for i in range(self.rows): row = [] for j in range(self.cols): row.append(str(self.elements.get((i, j), 0))) result.append(\\" \\".join(row)) return \\"n\\".join(result)"},{"question":"**Question:** You are tasked with finding the unique positive integer n for which n^2 forms a number that has the digits `123456787654321` at its center. This means you need to find a number whose square, when expressed as a decimal, places the given pattern exactly in its middle digits. To achieve this efficiently, consider the constraints and properties of the number n and its square: 1. Since the pattern is 15 digits long, the square of n must be at least 15 + (an unknown number of leading and trailing zeros) digits, considering the middle digits are the given pattern. 2. The square root of a number with at least 15 digits will have at least 8 digits. 3. Since the number pattern of n^2 is symmetric around its center, if n ends in particular digits, so must n\'s square. You can start with an intelligent guess of n\'s initial digits based on the pattern. # Task: Implement an optimized function `find_pattern_square_number` that efficiently identifies and returns the unique positive integer n that meets the above condition. # Input: None. The function does not require any parameters. # Output: - **Return Type**: Integer - **Description**: The unique positive integer n whose square places the digits `123456787654321` exactly in the middle of its number in the decimal representation. # Constraints and Notes: - The number n will be significant in value, and efficiency in the solution is critical. - Final validation should confirm the pattern\'s exact placement within the square of the identified n. - The solution should manage large integer arithmetic and complete within reasonable time frames on standard computational environments. # Example: If implemented correctly and executed, the function should return the correct unique positive integer `Answer` such that `Answer^2` has the digits `123456787654321` in its middle. ```python def find_pattern_square_number() -> int: # implement the function here pass if __name__ == \\"__main__\\": result = find_pattern_square_number() print(result) # Should print the unique positive integer n such that n^2 has the specified middle pattern ``` You are allowed to implement any helper functions required within `find_pattern_square_number` that ensures the square of the number has `123456787654321` at the exact center.","solution":"def find_pattern_square_number(): Finds the unique positive integer n whose square has the digits \'123456787654321\' in the middle. pattern = \'123456787654321\' pattern_length = len(pattern) # Start searching for n from a reasonable lower bound lower_bound = 10**7 upper_bound = 10**8 # We need to account for numbers whose squares can have the pattern in the middle. for n in range(lower_bound, upper_bound): square_str = str(n * n) if pattern in square_str: center_start = (len(square_str) - pattern_length) // 2 if square_str[center_start:center_start + pattern_length] == pattern: return n return None"},{"question":"Additional Question # [Question 2]: Image Rotation You are required to implement a function that rotates an NxN matrix by 90 degrees in a clockwise direction. The matrix will represent an image, where each element in the matrix is a pixel value. Input: 1. **Matrix**: A 2D list representing an NxN matrix (image), where matrix[i][j] indicates the pixel value at row i and column j. Output: * The rotated matrix after rotating the input matrix by 90 degrees clockwise. Constraints: 1. The size of the matrix N will not exceed 1000. 2. The matrix contains only integer values. Example: **Input**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` **Output**: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Implementation: Using the provided input, you need to implement the following Python function: ```python def rotate_matrix(matrix): # Your code here pass ``` **Requirements**: - Do not use any additional space for another matrix. - Rotate the matrix in place if possible. - Ensure the function handles edge cases such as empty matrices or matrices with uniform values. Provide your implementation of `rotate_matrix(matrix)` function below:","solution":"def rotate_matrix(matrix): Rotate the NxN matrix by 90 degrees clockwise in place. Args: matrix (list of list of int): NxN matrix Returns: list of list of int: Rotated matrix by 90 degrees clockwise n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp return matrix"},{"question":"# Efficient Route Calculation in a Traffic Network In this exercise, you need to implement the Dijkstra algorithm in Python to find the shortest path in a traffic network represented as a directed weighted graph. You are given a class `TrafficNetwork` that encapsulates the graph structure and a `Node` class that denotes the intersections (nodes) of the network. Your task is to write a method `find_shortest_route` that calculates the shortest route between a start and a goal node. Function Signature ```python def find_shortest_route(network: TrafficNetwork, start: Node, goal: Node) -> List[str]: ``` Input * `network`: An instance of `TrafficNetwork` representing the traffic graph. * `start`: An instance of `Node` representing the starting intersection. * `goal`: An instance of `Node` representing the destination intersection. Output * A list of strings representing the sequence of node names from the start to the goal, forming the shortest path. Constraints * The graph represented by `TrafficNetwork` can have up to 10,000 nodes. * Each node name is a unique string. * All weights (representing travel times or distances) are positive integers. * Ensure the implemented function efficiently handles large graphs within a reasonable computational time frame. Example ```python >>> network = TrafficNetwork() >>> network.add_edge(\\"A\\", \\"B\\", 5) >>> network.add_edge(\\"A\\", \\"C\\", 2) >>> network.add_edge(\\"B\\", \\"D\\", 1) >>> network.add_edge(\\"C\\", \\"B\\", 8) >>> network.add_edge(\\"C\\", \\"D\\", 7) >>> network.add_edge(\\"D\\", \\"E\\", 3) >>> start = Node(\\"A\\") >>> goal = Node(\\"E\\") >>> find_shortest_route(network, start, goal) [\\"A\\", \\"B\\", \\"D\\", \\"E\\"] ``` Performance Requirements * The function should handle graphs with up to 10,000 nodes and tens of thousands of edges. * Efficient memory usage is essential to avoid overflow or excessive memory consumption on large graphs. Make sure to handle edge cases such as disconnected nodes or scenarios where no path exists between the start and goal nodes. Implement checks to validate the input nodes and manage cases where nodes may not exist within the network.","solution":"import heapq from typing import List, Dict, Tuple class Node: def __init__(self, name: str): self.name = name class TrafficNetwork: def __init__(self): self.edges: Dict[str, List[Tuple[str, int]]] = {} def add_edge(self, from_node: str, to_node: str, weight: int): if from_node not in self.edges: self.edges[from_node] = [] self.edges[from_node].append((to_node, weight)) def get_neighbors(self, node: str) -> List[Tuple[str, int]]: return self.edges.get(node, []) def find_shortest_route(network: TrafficNetwork, start: Node, goal: Node) -> List[str]: queue = [(0, start.name, [])] seen = set() min_distances = {start.name: 0} while queue: (cost, current_node, path) = heapq.heappop(queue) if current_node in seen: continue path = path + [current_node] seen.add(current_node) if current_node == goal.name: return path for neighbor, weight in network.get_neighbors(current_node): if neighbor in seen: continue prev_cost = min_distances.get(neighbor, float(\'inf\')) new_cost = cost + weight if new_cost < prev_cost: min_distances[neighbor] = new_cost heapq.heappush(queue, (new_cost, neighbor, path)) return []"},{"question":"# Problem Statement Write a function that generates all possible permutations of a given string and returns them as a list of strings. You will also need to write a function to check if a given string is a palindrome and function to benchmark the performance of generating permutations for increasing string lengths. # Function Signatures ```python def generate_permutations(s: str) -> list: Generate all permutations of a given string. def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. def benchmark_permutations() -> None: Benchmark the performance of generating permutations for increasing string lengths. ``` # Input - A string `s` consisting of any printable ASCII characters. # Output - `generate_permutations(s)` returns a list of all permutations of `s`. - `is_palindrome(s)` returns a boolean indicating whether `s` is a palindrome. - `benchmark_permutations()` outputs the performance time of generating permutations for `s`. # Constraints - The input string can be of any length from 1 to 10 due to the factorial growth of permutations. - Ensure that the palindrome function handles edge cases effectively. # Performance Requirements - Ensure the functions are implemented to handle edge cases and typical constraints. - Benchmark the `generate_permutations` function on strings of lengths 4, 6, and 8 to compare their performance. # Example ```python >>> generate_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> generate_permutations(\\"ab\\") [\'ab\', \'ba\'] >>> generate_permutations(\\"a\\") [\'a\'] >>> generate_permutations(\\"\\") [\'\'] >>> is_palindrome(\\"aba\\") True >>> is_palindrome(\\"abc\\") False >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"\\") True ``` # Benchmark Function The `benchmark_permutations` function should compare the execution time of generating permutations for the following string lengths: - String of length 4: \\"abcd\\" - String of length 6: \\"abcdef\\" - String of length 8: \\"abcdefgh\\" Evaluate the execution time and output how the time increases with the length of the string.","solution":"from itertools import permutations import time def generate_permutations(s: str) -> list: Generate all permutations of a given string. if not s: return [\'\'] return [\'\'.join(p) for p in permutations(s)] def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. return s == s[::-1] def benchmark_permutations() -> None: Benchmark the performance of generating permutations for increasing string lengths. test_strings = { \\"Length 4\\": \\"abcd\\", \\"Length 6\\": \\"abcdef\\", \\"Length 8\\": \\"abcdefgh\\" } for description, test_str in test_strings.items(): start_time = time.time() generate_permutations(test_str) end_time = time.time() duration = end_time - start_time print(f\\"{description}: {duration:.6f} seconds\\")"},{"question":"# Unique Ingredient Finder for Recipes Scenario As a chef, you often experiment with various recipes that involve combining different ingredients. Sometimes, you want to know which ingredients are unique to each recipe and do not appear in any other recipes. Objective You need to write a function named `unique_ingredients` that takes a dictionary where keys are recipe names and values are lists of ingredients. The function returns a dictionary where keys are recipe names and values are lists of ingredients that are unique to each respective recipe. Implementation Details - Implement a function: ```python def unique_ingredients(recipes: dict[str, list[str]]) -> dict[str, list[str]]: ``` - **Input**: - `recipes`: A dictionary with recipe names as keys and lists of ingredient names as values. Ingredients and recipe names will be strings of alphabetic characters and spaces. - **Output**: - A dictionary where each key is a recipe name from the input, and the corresponding value is a list of ingredients that are unique to that recipe. - Ensure to handle cases where there are no unique ingredients for a recipe by returning an empty list for that recipe. Constraints 1. Assume all ingredients in the lists are distinct strings. 2. The number of recipes ranges from 1 to 100. 3. The total number of ingredients across all recipes is at most 1000. Example ```python >>> recipes = { ... \'Pasta Alfredo\': [\'pasta\', \'cream\', \'cheese\', \'garlic\'], ... \'Chicken Salad\': [\'chicken\', \'lettuce\', \'cheese\', \'dressing\'], ... \'Garlic Bread\': [\'bread\', \'garlic\', \'butter\'] ... } >>> unique_ingredients(recipes) { \'Pasta Alfredo\': [\'pasta\', \'cream\'], \'Chicken Salad\': [\'chicken\', \'lettuce\', \'dressing\'], \'Garlic Bread\': [\'bread\', \'butter\'] } ``` Write a detailed explanation and the implementation of your solution.","solution":"def unique_ingredients(recipes: dict[str, list[str]]) -> dict[str, list[str]]: Returns a dictionary where each key is a recipe name from the input and the corresponding value is a list of ingredients that are unique to that recipe. from collections import defaultdict # Dictionary to store the frequency of each ingredient across all recipes ingredient_count = defaultdict(int) # Populate the ingredient_count dictionary for ingredients in recipes.values(): for ingredient in ingredients: ingredient_count[ingredient] += 1 # Dictionary to store unique ingredients for each recipe unique_recipes = {} # Identify unique ingredients for each recipe for recipe, ingredients in recipes.items(): unique_recipes[recipe] = [ingredient for ingredient in ingredients if ingredient_count[ingredient] == 1] return unique_recipes"},{"question":"# Question: Reverse Words in a String You are asked to implement a function that reverses the words in a given string. The function should handle multiple spaces between words and trim any leading or trailing spaces. Input: - A single string containing words separated by spaces. The string may also contain leading or trailing spaces and multiple spaces between words. Output: - A string with the words in reverse order and a single space between each word. Constraints: - The input string will only contain printable ASCII characters. - An empty input string should return an empty string. Examples: ```python def reverse_words(sentence: str) -> str: Reverse the words in a string. :param sentence: str: The sentence to reverse. :return: str: The sentence with words in reversed order. Examples: >>> reverse_words(\\" This is a sample sentence. \\") \'sentence. sample a is This\' >>> reverse_words(\\"Multiple spaces between words \\") \'words between spaces Multiple\' >>> reverse_words(\\"\\") \'\' >>> reverse_words(\\"word\\") \'word\' >>> reverse_words(\\" Leading and trailing \\") \'trailing and Leading\' # Strip leading and trailing spaces sentence = sentence.strip() # Split words by spaces and filter out empty strings words = [word for word in sentence.split(\' \') if word] # Reverse the list of words reversed_words = reversed(words) # Join the reversed words with a single space return \' \'.join(reversed_words) if __name__ == \\"__main__\\": from doctest import testmod testmod() ``` Your task is to implement the `reverse_words` function following the specifications above.","solution":"def reverse_words(sentence: str) -> str: Reverse the words in a string. :param sentence: str: The sentence to reverse. :return: str: The sentence with words in reversed order. Examples: >>> reverse_words(\\" This is a sample sentence. \\") \'sentence. sample a is This\' >>> reverse_words(\\"Multiple spaces between words \\") \'words between spaces Multiple\' >>> reverse_words(\\"\\") \'\' >>> reverse_words(\\"word\\") \'word\' >>> reverse_words(\\" Leading and trailing \\") \'trailing and Leading\' # Strip leading and trailing spaces sentence = sentence.strip() # Split words by spaces and filter out empty strings words = [word for word in sentence.split(\' \') if word] # Reverse the list of words reversed_words = reversed(words) # Join the reversed words with a single space return \' \'.join(reversed_words)"},{"question":"# Coding Question **Context**: You are developing a recommendation system for an online bookstore. The system should recommend books based on the genre preferences of the users. Each user provides a list of their favorite genres, and the system fetches books accordingly. The challenge is to handle large datasets efficiently and return the recommendations in a sorted order by ratings. **Task**: Create a function `recommend_books` that takes a dictionary of user preferences, a list of books, and returns a list of recommended books sorted by ratings in descending order. **Function Specification**: ```python def recommend_books(user_preferences: dict, books: list) -> list: Recommend books to the user based on their genre preferences. The function should sort the recommendations by book ratings in descending order. Parameters: - user_preferences (dict): A dictionary where keys are user IDs and values are lists of preferred genres. - books (list): A list of dictionaries, each containing \'title\', \'genre\', and \'rating\'. Returns: - list: Sorted list of book titles recommended to the user (sorted by rating). Constraints: - Each `book` dictionary contains the following keys: - \'title\' (str): The title of the book. - \'genre\' (str): The genre of the book. - \'rating\' (float): The rating of the book (0.0 to 5.0). - The function should handle a large dataset efficiently. pass ``` **Examples**: ```python user_preferences = { \\"user1\\": [\\"Science Fiction\\", \\"Fantasy\\"], \\"user2\\": [\\"Mystery\\", \\"Thriller\\"] } books = [ {\\"title\\": \\"Dune\\", \\"genre\\": \\"Science Fiction\\", \\"rating\\": 4.8}, {\\"title\\": \\"Foundation\\", \\"genre\\": \\"Science Fiction\\", \\"rating\\": 4.6}, {\\"title\\": \\"The Hobbit\\", \\"genre\\": \\"Fantasy\\", \\"rating\\": 4.9}, {\\"title\\": \\"Gone Girl\\", \\"genre\\": \\"Thriller\\", \\"rating\\": 4.2} ] print(recommend_books(user_preferences, books, \\"user1\\")) # Output: [\\"The Hobbit\\", \\"Dune\\", \\"Foundation\\"] print(recommend_books(user_preferences, books, \\"user2\\")) # Output: [\\"Gone Girl\\"] ``` **Expected Output**: A list of book titles for each user, sorted by their rating in descending order. Ensure that the recommendations align with the user\'s respective genre preferences.","solution":"def recommend_books(user_preferences: dict, books: list, user_id: str) -> list: if user_id not in user_preferences: return [] preferred_genres = set(user_preferences[user_id]) recommended_books = [book for book in books if book[\'genre\'] in preferred_genres] recommended_books.sort(key=lambda x: x[\'rating\'], reverse=True) return [book[\'title\'] for book in recommended_books]"},{"question":"# Problem: Efficient Roman Numerals Converter You are required to implement efficient functions to convert integers to Roman numerals and vice versa. These functions should adhere to the traditional rules for Roman numeral representation. Function Specifications: - **Function Name**: `integer_to_roman` - **Input**: - `num`: An integer between 1 and 3999 inclusive. - **Output**: - A string representing the Roman numeral equivalent of the given integer. - **Function Name**: `roman_to_integer` - **Input**: - `s`: A string representing a Roman numeral. - **Output**: - An integer value corresponding to the Roman numeral. Constraints: 1. Ensure both functions handle all input edge cases, including the smallest and largest possible values. 2. Roman numerals should be output in their standard format (e.g., 4 is `IV`, not `IIII`). 3. The Roman numeral input strings will be guaranteed valid as per standard rules. 4. Perform optimally, considering the bounds on input sizes. # Task Description: Implement the `integer_to_roman` and `roman_to_integer` functions according to the provided specifications, ensuring they handle and convert values efficiently and accurately. Example: ```python def integer_to_roman(num: int) -> str: # Implementation here def roman_to_integer(s: str) -> int: # Implementation here ``` Examples of how the functions should behave: ```python assert integer_to_roman(1) == \\"I\\" assert integer_to_roman(58) == \\"LVIII\\" # L = 50, V = 5, III = 3 assert integer_to_roman(1994) == \\"MCMXCIV\\" # M = 1000, CM = 900, XC = 90, IV = 4 assert roman_to_integer(\\"I\\") == 1 assert roman_to_integer(\\"LVIII\\") == 58 # L = 50, V = 5, III = 3 assert roman_to_integer(\\"MCMXCIV\\") == 1994 # M = 1000, CM = 900, XC = 90, IV = 4 ``` # Requirements - Provide a well-documented, efficient implementation of the `integer_to_roman` and `roman_to_integer`. - Ensure your solution correctly handles edge cases and adheres to the Roman numeral standard. Good luck and happy coding!","solution":"def integer_to_roman(num: int) -> str: values = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] result = [] for value, numeral in values: while num >= value: result.append(numeral) num -= value return \'\'.join(result) def roman_to_integer(s: str) -> int: roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000, \'IV\': 4, \'IX\': 9, \'XL\': 40, \'XC\': 90, \'CD\': 400, \'CM\': 900 } i, total = 0, 0 while i < len(s): if i + 1 < len(s) and s[i:i+2] in roman_to_int: total += roman_to_int[s[i:i+2]] i += 2 else: total += roman_to_int[s[i]] i += 1 return total"},{"question":"# Task: Create an event scheduling system using a class `EventScheduler` that allows for adding, deleting, and querying events efficiently. Each event has a start time and an end time. The scheduling system should handle overlapping events and prevent double-booking. # Requirements: - Implement the required methods considering time efficiency. - Use appropriate data structures to manage events and ensure the operations are optimal in terms of time complexity. # Detailed Function Requirements: 1. **`add_event(start: int, end: int) -> bool`**: Adds a new event if it does not overlap with existing events. Returns `True` if the event is successfully added, otherwise returns `False`. * **Input**: `start` - the start time of the event, `end` - the end time of the event. * **Output**: `True` if event is added successfully, `False` otherwise. * **Constraints**: `start` and `end` are integers where `start < end`. 2. **`delete_event(start: int, end: int) -> bool`**: Deletes the event with the specified start and end time. Returns `True` if the event is successfully deleted, otherwise returns `False`. * **Input**: `start` - the start time of the event, `end` - the end time of the event. * **Output**: `True` if event is successfully deleted, `False` otherwise. * **Constraints**: `start` and `end` are integers where `start < end`. 3. **`has_event(start: int, end: int) -> bool`**: Checks if there is an event with the exact start and end time. Returns `True` if such an event exists, otherwise returns `False`. * **Input**: `start` - the start time of the event, `end` - the end time of the event. * **Output**: `True` if event exists, `False` otherwise. * **Constraints**: `start` and `end` are integers where `start < end`. # Constraints: - Events are defined by their start and end times, both being positive integers. - Ensure the integrity of the event schedule without overlaps. - Consider edge cases such as attempts to overlap events or delete non-existent events. # Example Usage: ```python scheduler = EventScheduler() print(scheduler.add_event(10, 20)) # Output: True print(scheduler.add_event(15, 25)) # Output: False print(scheduler.has_event(10, 20)) # Output: True print(scheduler.delete_event(10, 20)) # Output: True print(scheduler.has_event(10, 20)) # Output: False ``` # Note: - Ensure your implementation handles events effectively to maintain schedule integrity and prevent overlaps. - Utilize appropriate data structures and algorithms to balance efficiency with functionality.","solution":"class EventScheduler: def __init__(self): self.events = [] def add_event(self, start: int, end: int) -> bool: for s, e in self.events: if max(s, start) < min(e, end): return False self.events.append((start, end)) return True def delete_event(self, start: int, end: int) -> bool: for event in self.events: if event[0] == start and event[1] == end: self.events.remove(event) return True return False def has_event(self, start: int, end: int) -> bool: return (start, end) in self.events"},{"question":"# Question: Reverse String Recursively You are given a string. Your task is to write a function that reverses the string using recursion. Function Signature: ```python def reverse_string(s: str) -> str: ``` Input: - `s` (str): The string to be reversed. Output: - (str): Returns the reverse of the input string. Constraints: 1. The length of the string will be non-negative. 2. The function should make use of recursion and should not use any loops or Python’s built-in reverse functions. Example Usage: ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"world\\") == \\"dlrow\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"ab\\") == \\"ba\\" ``` Additional Notes: - Consider edge cases such as an empty string or a string with a single character. - Ensure that the function handles strings with both odd and even lengths correctly.","solution":"def reverse_string(s: str) -> str: Reverses the given string using recursion. Args: s (str): The string to be reversed. Returns: str: The reversed string. if len(s) == 0: return s return s[-1] + reverse_string(s[:-1])"},{"question":"# Scenario: You are given a list of student dictionaries where each dictionary contains the `name` of the student and their corresponding `score` in an exam. Your task is to rank the students based on their scores in descending order. In case two students have the same score, rank them alphabetically by their names. # Task: Write a function `rank_students` that takes a list of dictionaries representing students and returns a new list of dictionaries with the students ranked by their scores in descending order. If two or more students have the same score, they should be ranked alphabetically by their names in ascending order. # Expected Function: ```python def rank_students(students: list) -> list: ``` # Input Format: * A list of dictionaries `students` with length `n` where `0 <= n <= 10^5`. * Each dictionary has two keys: `name` (a string) and `score` (an integer). # Output Format: * A list of dictionaries representing students ranked by scores in descending order. # Constraints: * The algorithm should run in O(n log n) time complexity. * The comparison between strings (names) should be case-insensitive. # Example: ```python >>> rank_students([{\\"name\\": \\"Alice\\", \\"score\\": 88}, {\\"name\\": \\"Bob\\", \\"score\\": 75}, {\\"name\\": \\"Charlie\\", \\"score\\": 88}]) [{\'name\': \'Alice\', \'score\': 88}, {\'name\': \'Charlie\', \'score\': 88}, {\'name\': \'Bob\', \'score\': 75}] >>> rank_students([{\\"name\\": \\"Zara\\", \\"score\\": 90}, {\\"name\\": \\"Liam\\", \\"score\\": 92}, {\\"name\\": \\"Olivia\\", \\"score\\": 90}]) [{\'name\': \'Liam\', \'score\': 92}, {\'name\': \'Olivia\', \'score\': 90}, {\'name\': \'Zara\', \'score\': 90}] ``` # Notes: 1. Your implementation should handle all edge cases gracefully. 2. Make sure to test your solution for efficiency and correctness. 3. Consider the case where the list of students may be empty.","solution":"def rank_students(students): Ranks students based on their scores in descending order. In case of tie on scores, rank alphabetically by names (case-insensitive). Args: students (list of dict): List of students with \'name\' and \'score\' keys. Returns: list of dict: New list of students ranked by their scores and names. # Sorting using score descending and name ascending (case-insensitive) sorted_students = sorted(students, key=lambda x: (-x[\'score\'], x[\'name\'].lower())) return sorted_students"},{"question":"Fibonacci Sequence Tester Context The Fibonacci sequence is a well-known series of numbers that starts with 0 and 1, where each subsequent number is the sum of the previous two. Mathematically, the sequence is defined by the recurrence relation: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n > 1 ) Given an integer `x`, the task is to determine whether `x` is a member of the Fibonacci sequence. Task Implement a function to check if an integer is a Fibonacci number. Instead of generating the sequence, use mathematical properties to identify Fibonacci numbers. Function Signature ```python def is_fibonacci(x: int) -> bool: ``` Input - `x` (int): The integer to be tested for Fibonacci membership. Output - Returns `True` if `x` is a Fibonacci number, `False` otherwise. Constraints - Handle integers in the range: (-10^{18} leq x leq 10^{18}). - Non-integer inputs should raise appropriate exceptions. Examples ```python is_fibonacci(8) # Output: True is_fibonacci(10) # Output: False is_fibonacci(13) # Output: True is_fibonacci(21) # Output: True is_fibonacci(-5) # Output: False ``` Performance Requirements Ensure that your implementation efficiently handles the large input constraints. Use mathematical properties to verify Fibonacci membership without explicitly generating long sequences. Edge Cases Be mindful of: - Non-integer inputs like strings or arrays. - Very large positive and negative values. - Edge cases where `x` is negative or zero.","solution":"import math def is_fibonacci(x: int) -> bool: Check if a given integer x is a Fibonacci number. if not isinstance(x, int): raise ValueError(\\"Input must be an integer.\\") if x < 0: return False # A number is a Fibonacci number if and only if one or both of (5*x^2 + 4) or (5*x^2 - 4) # is a perfect square. def is_perfect_square(n): s = int(math.isqrt(n)) return s * s == n val1 = 5 * x * x + 4 val2 = 5 * x * x - 4 return is_perfect_square(val1) or is_perfect_square(val2)"},{"question":"# Problem: Matrix Element-wise Multiplication Context: You are developing a scientific computing application that requires performing element-wise operations on matrices, often required in various fields such as image processing and numerical analysis. Function Signature: ```python def elementwise_multiply(matrix1: list[list[int | float]], matrix2: list[list[int | float]]) -> list[list[int | float]]: ``` Description: Implement a function `elementwise_multiply` that takes two matrices of the same dimensions and returns a new matrix that is the result of element-wise multiplication of the input matrices. The resulting matrix should be constructed such that each element at position (i, j) is the product of the elements at position (i, j) in the input matrices. Input: * `matrix1` and `matrix2`: Two lists of lists of integers or floats representing the matrices with identical dimensions `m x n` (where `m` is the number of rows and `n` is the number of columns). Output: * Returns a list of lists of integers or floats representing the resulting matrix after performing element-wise multiplication. Constraints: * Both input matrices will have the same non-zero dimensions. * The elements within the matrix are integers or floating-point numbers. * Ensure the function is optimized for time and space complexity. Examples: ```python matrix1 = [[1, 2, 3], [4, 5, 6]] matrix2 = [[7, 8, 9], [10, 11, 12]] assert elementwise_multiply(matrix1, matrix2) == [[7, 16, 27], [40, 55, 72]] matrix3 = [[1.5, 2.5], [3.5, 4.5]] matrix4 = [[2, 2], [2, 2]] assert elementwise_multiply(matrix3, matrix4) == [[3.0, 5.0], [7.0, 9.0]] matrix5 = [[0, 1], [2, 3]] matrix6 = [[1, 0], [3, 2]] assert elementwise_multiply(matrix5, matrix6) == [[0, 0], [6, 6]] ``` Requirements: * Handle cases where the input matrices contain zero elements. * Ensure correctness for integer and floating-point arithmetic.","solution":"def elementwise_multiply(matrix1, matrix2): Performs element-wise multiplication of two matrices. Args: matrix1 (list of list of int/float): The first input matrix. matrix2 (list of list of int/float): The second input matrix. Returns: list of list of int/float: The resulting matrix after element-wise multiplication. return [[matrix1[i][j] * matrix2[i][j] for j in range(len(matrix1[0]))] for i in range(len(matrix1))]"},{"question":"# Spiral Matrix Traversal Context: You are a software engineer at a robotics company, tasked with programming a robot to follow a specific path in a factory grid. The factory is represented as a matrix, and the robot must traverse the matrix in a spiral order starting from the top-left corner. Task: Write a function **`spiral_order(matrix: List[List[int]]) -> List[int]`** that takes a 2D list representing the matrix and returns a list of integers representing the elements of the matrix in the order that the robot visits them in a clockwise spiral. Input: * A 2D list `matrix` of dimensions `m x n` (where 1 <= m, n <= 100). Output: * A list of integers representing the elements of the matrix in spiral order. Constraints: * Each element in the matrix will be an integer. Example: ```python # Example to illustrate matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert spiral_order(matrix) == [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Performance Considerations: Your implementation should be efficient to handle matrices of varying dimensions within the given constraints effectively.","solution":"from typing import List def spiral_order(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] result = [] left, right = 0, len(matrix[0]) - 1 top, bottom = 0, len(matrix) - 1 while left <= right and top <= bottom: # Traverse the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"Problem Statement You are given a directed graph represented as an adjacency list and a target value. Your task is to implement a function that checks if there exists a cycle in the graph that includes the target node. # Function Signature ```python def has_cycle_including_target(graph: Dict[int, List[int]], target: int) -> bool: pass ``` # Input - `graph` (Dict[int, List[int]]): The graph represented as an adjacency list. Each key is a node and the corresponding value is a list of nodes that can be visited directly from this node. - `target` (int): The node that should be part of the cycle. # Output - `bool`: `True` if there is a cycle that includes the target node, otherwise `False`. # Constraints - The graph will have no more than 10^4 nodes. - Each node will have no more than 10^3 edges. - The graph might not be fully connected. # Examples ```python assert has_cycle_including_target({0: [1], 1: [2], 2: [0]}, 1) == True assert has_cycle_including_target({0: [1], 1: [2], 2: [3]}, 1) == False assert has_cycle_including_target({0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [3]}, 3) == True assert has_cycle_including_target({}, 0) == False ``` # Explanation 1. In the first example, there is a cycle 1 -> 2 -> 0 -> 1 which includes node 1. 2. In the second example, there is no cycle that includes node 1. 3. In the third example, there is a cycle 3 -> 4 -> 3 which includes node 3. 4. In the fourth example, the graph is empty, so no cycle exists. # Notes - You may use depth-first search (DFS) or other graph traversal methods to detect cycles. - Take care to handle edge cases, such as when the graph is empty or when the target node is isolated. # Additional Test Cases ```python assert has_cycle_including_target({0: [1, 2], 1: [0, 2], 2: [0, 1]}, 2) == True assert has_cycle_including_target({0: [1], 1: [2], 2: []}, 1) == False assert has_cycle_including_target({0: [], 1: [2], 2: [1]}, 1) == True ```","solution":"def has_cycle_including_target(graph, target): def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False if target not in graph: return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): if target in rec_stack: return True return False"},{"question":"# Coding Assessment Question You are required to implement a function that simulates a simple text editor. The editor can perform various operations on a string, including inserting characters, deleting characters, and retrieving a substring. # Task Your function should meet the following requirements: 1. **Function Name**: `text_editor` 2. **Input**: A list of dictionary items where each dictionary represents an operation. The operations have the following keys: * `type` (str): Can be \\"insert\\", \\"delete\\", or \\"substring\\". * `position` (int): Represents the position in the string where the operation is to be applied. * `value` (str or int): Represents the value associated with the operation. For \\"insert\\", it will be a string. For \\"delete\\", it will be an integer indicating the number of characters to delete. For \\"substring\\", it will be a tuple (start, end) indicating the range of the substring to retrieve. 3. **Output**: The function should return a list of outputs for all \\"substring\\" operations. # Example ```python operations = [ {\\"type\\": \\"insert\\", \\"position\\": 0, \\"value\\": \\"hello\\"}, {\\"type\\": \\"insert\\", \\"position\\": 5, \\"value\\": \\" world\\"}, {\\"type\\": \\"substring\\", \\"position\\": 0, \\"value\\": (0, 5)}, {\\"type\\": \\"delete\\", \\"position\\": 5, \\"value\\": 1}, {\\"type\\": \\"substring\\", \\"position\\": 0, \\"value\\": (0, 5)} ] print(text_editor(operations)) # Output: [\\"hello\\", \\"hello\\"] ``` # Constraints * The string manipulated by the text editor will have at most 10^5 characters. * The list of operations will have at most 10^3 operations. * All string positions will be valid and within the current length of the string for any given operation. # Notes * Ensure the function handles edge cases, such as deleting more characters than present, intelligently. * Optimize the operations to work efficiently within the constraints. * Insert and delete operations should be appropriately managed to sustain a responsive editor simulation. Good luck!","solution":"def text_editor(operations): text = \\"\\" results = [] for operation in operations: op_type = operation[\\"type\\"] position = operation[\\"position\\"] value = operation[\\"value\\"] if op_type == \\"insert\\": text = text[:position] + value + text[position:] elif op_type == \\"delete\\": text = text[:position] + text[position + value:] elif op_type == \\"substring\\": start, end = value results.append(text[start:end]) return results"},{"question":"# Question: Implement a Tic-Tac-Toe Winner Checker Write a function `check_winner(board: List[List[str]]) -> str`. This function should determine the winner of a Tic-Tac-Toe game based on the current state of the 3x3 game board. The Tic-Tac-Toe board is represented as a list of lists, where each inner list corresponds to a row on the board. The board contains the following characters: - `\'X\'` for a cell occupied by player \'X\' - `\'O\'` for a cell occupied by player \'O\' - `\' \'` (a space) for an empty cell The function should return: - `\'X\'` if player \'X\' has won - `\'O\'` if player \'O\' has won - `\'Draw\'` if the board is full and there is no winner - `\'Pending\'` if the game is still ongoing # Function Signature: ```python from typing import List def check_winner(board: List[List[str]]) -> str: pass ``` # Input: - `board` - a 3x3 list of lists with `\'X\'`, `\'O\'`, and `\' \'` denoting the current state of the Tic-Tac-Toe board. # Output: - A string representing the result of the game as described above. # Example: ```python board1 = [ [\'X\', \'X\', \'X\'], [\'O\', \'O\', \' \'], [\' \', \' \', \' \'] ] print(check_winner(board1)) # Expected Output: \'X\' board2 = [ [\'O\', \'X\', \'X\'], [\'O\', \'O\', \'X\'], [\'X\', \'O\', \'O\'] ] print(check_winner(board2)) # Expected Output: \'O\' board3 = [ [\'X\', \'O\', \'X\'], [\'X\', \'O\', \'O\'], [\'O\', \'X\', \'X\'] ] print(check_winner(board3)) # Expected Output: \'Draw\' board4 = [ [\'X\', \'O\', \' \'], [\'X\', \' \', \'O\'], [\'O\', \'X\', \' \'] ] print(check_winner(board4)) # Expected Output: \'Pending\' ``` # Constraints: 1. The board will always be a 3x3 list of lists. 2. The board will contain only the characters `\'X\'`, `\'O\'`, and `\' \'`.","solution":"from typing import List def check_winner(board: List[List[str]]) -> str: # Check rows for row in board: if row[0] == row[1] == row[2] and row[0] != \' \': return row[0] # Check columns for col in range(3): if board[0][col] == board[1][col] == board[2][col] and board[0][col] != \' \': return board[0][col] # Check diagonals if board[0][0] == board[1][1] == board[2][2] and board[0][0] != \' \': return board[0][0] if board[0][2] == board[1][1] == board[2][0] and board[0][2] != \' \': return board[0][2] # Check for a draw or pending for row in board: if \' \' in row: return \'Pending\' return \'Draw\'"},{"question":"# Background In computer graphics, the concept of barycentric coordinates is used to express the position of a point within a triangle. Barycentric coordinates are particularly useful in interpolation and shading algorithms. Given a triangle with vertices ( A (x_1, y_1) ), ( B (x_2, y_2) ), and ( C (x_3, y_3) ), and a point ( P (x, y) ), the barycentric coordinates ( (lambda_1, lambda_2, lambda_3) ) of the point ( P ) with respect to the triangle can be calculated using the following formula: [ lambda_1 = frac{(y_2 - y_3)(x - x_3) + (x_3 - x_2)(y - y_3)}{(y_2 - y_3)(x_1 - x_3) + (x_3 - x_2)(y_1 - y_3)} ] [ lambda_2 = frac{(y_3 - y_1)(x - x_3) + (x_1 - x_3)(y - y_3)}{(y_2 - y_3)(x_1 - x_3) + (x_3 - x_2)(y_1 - y_3)} ] [ lambda_3 = 1 - lambda_1 - lambda_2 ] # Problem Statement Write a function `barycentric_coordinates(vertices: List[Tuple[float, float]], point: Tuple[float, float]) -> Tuple[float, float, float]` that calculates the barycentric coordinates of a given point within a triangle defined by three vertices. # Input - `vertices`: A list of three tuples, each containing two floats representing the (x, y) coordinates of the triangle\'s vertices. - `point`: A tuple of two floats representing the (x, y) coordinates of the point inside the triangle. # Output - A tuple of three floats representing the barycentric coordinates (λ1, λ2, λ3) of the point with respect to the triangle. # Constraints - The vertices should form a valid triangle (no three points should be collinear). - The point should be within the triangle. # Example ```python vertices = [(0, 0), (1, 0), (0, 1)] point = (0.25, 0.25) result = barycentric_coordinates(vertices, point) print(result) # Output should be (0.5, 0.25, 0.25) ``` # Notes - Ensure that the input vertices form a valid triangle by checking that no three points are collinear. - The point should be within the bounds defined by the triangle. - Use the given formula to calculate the barycentric coordinates. - Consider edge cases where the point lies exactly on one of the triangle\'s edges. # Hints - You can use a function to calculate the denominator (area-related part) as it is reused in the calculation. - Double-check the arithmetic operations to ensure correct implementation.","solution":"from typing import List, Tuple def barycentric_coordinates(vertices: List[Tuple[float, float]], point: Tuple[float, float]) -> Tuple[float, float, float]: (x1, y1), (x2, y2), (x3, y3) = vertices x, y = point denom = (y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3) lambda1 = ((y2 - y3) * (x - x3) + (x3 - x2) * (y - y3)) / denom lambda2 = ((y3 - y1) * (x - x3) + (x1 - x3) * (y - y3)) / denom lambda3 = 1 - lambda1 - lambda2 return lambda1, lambda2, lambda3"},{"question":"# **Sentence Reversal and Capitalization** # Problem Statement: You need to write a function that takes a sentence as input, reverses the order of the words, capitalizes the first word of the reversed sentence and lowers the rest, then returns the transformed sentence. # Function Definition: Function: `transform_sentence(sentence: str) -> str` - **Input**: A string representing a sentence. The sentence will contain only alphabetic characters and spaces. - **Output**: A string representing the transformed sentence with reversed word order and proper capitalization. - **Constraints**: * The input string should have at least one word, and all words will be separated by a single space. * The function should handle leading and trailing spaces in the input string by trimming them before processing. # Task Instructions: 1. Implement the `transform_sentence` function. 2. Write at least three test cases demonstrating the function with edge cases such as one-word sentences, multi-word sentences, and sentences with mixed case inputs. # Example: Given the following inputs: 1. `sentence = \'Hello World from OpenAI\'` - **Output**: `\'Openai from world hello\'` - **Explanation**: The word order is reversed giving: \'OpenAI from world Hello\', then \'OpenAI\' is converted to \'Openai\' and \'Hello\' to \'hello\'. 2. `sentence = \'this is a test \'` - **Output**: `\'Test a is this\'` - **Explanation**: The input string is trimmed to \'this is a test\', then the word order is reversed giving: \'test a is this\', lastly, \'test\' is capitalized to \'Test\'. 3. `sentence = \' singleWord\'` - **Output**: `\'Singleword\'` - **Explanation**: The input string is trimmed to \'singleWord\', then the word \'singleWord\' is capitalized giving: \'Singleword\'. # Constraints: * Ensure the function is optimized for both performance and readability. * The function should not use any built-in string reversal functions. * Handle edge cases such as empty strings or strings with excessive spaces gracefully.","solution":"def transform_sentence(sentence: str) -> str: Reverses the order of the words in the input sentence, capitalizes the first word of the reversed order sentence, and lowercases the rest. :param sentence: Input sentence as a string :return: Transformed sentence as a string # Trim leading and trailing spaces and split the sentence into words words = sentence.strip().split() if len(words) == 0: return \\"\\" # Reverse the word order words.reverse() # Capitalize the first word and make all others lowercase transformed_words = [words[0].capitalize()] + [word.lower() for word in words[1:]] # Join the words back into a single string transformed_sentence = \' \'.join(transformed_words) return transformed_sentence"},{"question":"# Assignment: Implement a Simple SQL Library in Python You will be creating a Python library that can perform basic SQL operations (Create, Read, Update, and Delete) on a SQLite database. This will involve designing functions to connect to the database, execute queries, and handle data manipulation tasks. # Task: 1. Write a function `connect_db` to establish a connection to the SQLite database. * Input: * `db_name` - A string representing the name of the database file. * Output: * A connection object to the database. 2. Write a function `create_table` to create a new table in the database. * Input: * `conn` - The connection object. * `table_name` - A string representing the name of the table. * `schema` - A dictionary where keys are column names and values are their corresponding data types. * Output: * None. The function should execute the SQL query to create the table. 3. Write a function `insert_data` to insert a record into a table. * Input: * `conn` - The connection object. * `table_name` - A string representing the name of the table. * `data` - A dictionary where keys are column names and values are the corresponding data for the record. * Output: * None. The function should execute the SQL query to insert the data. 4. Write a function `fetch_data` to fetch records from a table based on certain conditions. * Input: * `conn` - The connection object. * `table_name` - A string representing the name of the table. * `columns` - A list of column names to be fetched. If \'None\', fetch all columns. * `conditions` - A dictionary where keys are column names and values are the conditions to be met (e.g., `{\\"age\\": \\">21\\"}`). * Output: * A list of tuples containing the fetched records. 5. Write a function `update_data` to update existing records in a table. * Input: * `conn` - The connection object. * `table_name` - A string representing the name of the table. * `updates` - A dictionary where keys are column names to be updated and values are the new values. * `conditions` - A dictionary where keys are column names and values are the conditions to be met for the update (e.g., `{\\"age\\": \\">21\\"}`). * Output: * None. The function should execute the SQL query to update the records. 6. Write a function `delete_data` to delete records from a table. * Input: * `conn` - The connection object. * `table_name` - A string representing the name of the table. * `conditions` - A dictionary where keys are column names and values are the conditions to be met for the deletion (e.g., `{\\"age\\": \\"<18\\"}`). * Output: * None. The function should execute the SQL query to delete the records. # Constraints: * Use the `sqlite3` library in Python for database operations. * Ensure to handle SQL injection and other security concerns by using parameterized queries. * Implement error handling and close the database connection after each operation. * Assume the table schema and data types align with those supported by SQLite. # Example: ```python # Connecting to the database conn = connect_db(\'test.db\') # Creating a table schema = { \'id\': \'INTEGER PRIMARY KEY\', \'name\': \'TEXT\', \'age\': \'INTEGER\', \'salary\': \'REAL\' } create_table(conn, \'employees\', schema) # Inserting data into the table data = {\'name\': \'John Doe\', \'age\': 30, \'salary\': 60000} insert_data(conn, \'employees\', data) # Fetching data from the table records = fetch_data(conn, \'employees\', [\'name\', \'salary\'], {\'age\': \'>25\'}) print(records) # Output: [(\'John Doe\', 60000.0)] # Updating data in the table update_data(conn, \'employees\', {\'salary\': 65000}, {\'name\': \'John Doe\'}) # Deleting data from the table delete_data(conn, \'employees\', {\'age\': \'<18\'}) # Closing the database connection conn.close() ``` # Notes: * Be mindful of SQL injection and ensure to use parameterized queries. * Handle edge cases such as attempting to create an existing table, inserting data with missing columns, or fetching data with invalid conditions. * Your functions should be modular and reusable across different database operations.","solution":"import sqlite3 def connect_db(db_name): Establish a connection to the SQLite database. :param db_name: Name of the database file. :return: Connection object to the database. return sqlite3.connect(db_name) def create_table(conn, table_name, schema): Create a new table in the database. :param conn: Connection object. :param table_name: Name of the table. :param schema: Dictionary representing the table\'s schema. columns = \', \'.join([f\'{col} {dtype}\' for col, dtype in schema.items()]) query = f\'CREATE TABLE IF NOT EXISTS {table_name} ({columns})\' conn.execute(query) conn.commit() def insert_data(conn, table_name, data): Insert a record into a table. :param conn: Connection object. :param table_name: Name of the table. :param data: Dictionary where keys are column names and values are corresponding data for the record. columns = \', \'.join(data.keys()) placeholders = \', \'.join([\'?\' for _ in data]) values = list(data.values()) query = f\'INSERT INTO {table_name} ({columns}) VALUES ({placeholders})\' conn.execute(query, values) conn.commit() def fetch_data(conn, table_name, columns=None, conditions=None): Fetch records from a table based on certain conditions. :param conn: Connection object. :param table_name: Name of the table. :param columns: List of column names to be fetched. If \'None\', fetch all columns. :param conditions: Dictionary where keys are column names and values are the conditions to be met. :return: List of tuples containing the fetched records. col_list = \', \'.join(columns) if columns else \'*\' query = f\'SELECT {col_list} FROM {table_name}\' if conditions: cond_list = \' AND \'.join([f\'{col} {cond}\' for col, cond in conditions.items()]) query += f\' WHERE {cond_list}\' cursor = conn.cursor() cursor.execute(query) return cursor.fetchall() def update_data(conn, table_name, updates, conditions): Update existing records in a table. :param conn: Connection object. :param table_name: Name of the table. :param updates: Dictionary where keys are column names to be updated and values are the new values. :param conditions: Dictionary where keys are column names and values are the conditions to be met for the update. set_clause = \', \'.join([f\'{col} = ?\' for col in updates]) cond_clause = \' AND \'.join([f\'{col} {cond}\' for col, cond in conditions.items()]) query = f\'UPDATE {table_name} SET {set_clause} WHERE {cond_clause}\' values = list(updates.values()) conn.execute(query, values) conn.commit() def delete_data(conn, table_name, conditions): Delete records from a table. :param conn: Connection object. :param table_name: Name of the table. :param conditions: Dictionary where keys are column names and values are the conditions to be met for the deletion. cond_clause = \' AND \'.join([f\'{col} {cond}\' for col, cond in conditions.items()]) query = f\'DELETE FROM {table_name} WHERE {cond_clause}\' conn.execute(query) conn.commit()"},{"question":"# Context: You are developing a feature for an encryption system that uses prime numbers extensively. One recurring task is to find the greatest common divisor (GCD) of two large numbers. As a part of this system, you need to implement an efficient algorithm for this purpose. # Problem Statement: Write a function `calculate_gcd(a: int, b: int) -> int` that takes two non-negative integers as input and returns their greatest common divisor (GCD). Your implementation should validate the input and raise a `ValueError` if any input is not a non-negative integer. Input and Output Formats: * **Input**: Two arguments `a` and `b` which are non-negative integers. * **Output**: An integer representing the GCD of the given input integers. Constraints and Limitations: * The inputs are guaranteed to be non-negative integers. * You should consider edge cases and validate the input. Example: ```python >>> calculate_gcd(48, 18) 6 >>> calculate_gcd(17, 13) 1 >>> calculate_gcd(0, 5) 5 >>> calculate_gcd(0, 0) 0 >>> calculate_gcd(54, 24) 6 >>> calculate_gcd(48.5, 18) Traceback (most recent call last): ... ValueError: Both inputs must be non-negative integers >>> calculate_gcd(-48, 18) Traceback (most recent call last): ... ValueError: Both inputs must be non-negative integers >>> calculate_gcd(\'12\', 48) Traceback (most recent call last): ... ValueError: Both inputs must be non-negative integers ``` # Performance Requirements: * The solution should ideally run in O(log(min(a, b))) time complexity using the Euclidean algorithm.","solution":"def calculate_gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of two non-negative integers a and b. Raises ValueError if any input is not a non-negative integer. # Input validation if not isinstance(a, int) or not isinstance(b, int) or a < 0 or b < 0: raise ValueError(\\"Both inputs must be non-negative integers\\") # Euclidean algorithm for GCD while b: a, b = b, a % b return a"},{"question":"# Question You are developing an application that deals with financial transactions and need to calculate the annual percentage rate (APR) for a loan. Write a Python function `calculate_apr` that takes in two arguments: `principal` and `interest`, representing the total principal amount of the loan and the yearly interest rate as a percentage, respectively. The function should return the annual percentage rate (APR) rounded to two decimal places. Here are the details: - The APR is calculated using the formula: [ text{APR} = frac{text{interest} times 100}{text{principal}} ] - If the principal is zero or negative, your function should raise a `ValueError` with the message \\"The principal must be a positive number\\". - Ensure your function handles both positive and negative interest rates properly. **Function Signature:** ```python def calculate_apr(principal: float, interest: float) -> float: ``` **Input:** - `principal`: A float representing the total principal amount of the loan (dollars). - `interest`: A float representing the yearly interest rate as a percentage. **Output:** - Returns a float representing the annual percentage rate (APR) rounded to two decimal places. **Examples:** ```python >>> calculate_apr(10000, 500) 5.0 >>> calculate_apr(15000, 750) 5.0 >>> calculate_apr(25000, -1000) -4.0 >>> calculate_apr(50000, 2000) 4.0 >>> calculate_apr(10000, 0) 0.0 ``` Ensure your implementation correctly handles edge cases and potential errors, providing accurate results for all valid inputs.","solution":"def calculate_apr(principal: float, interest: float) -> float: Calculate the annual percentage rate (APR) for a loan. Args: principal (float): The total principal amount of the loan (dollars). interest (float): The yearly interest rate as a percentage. Returns: float: The annual percentage rate (APR) rounded to two decimal places. Raises: ValueError: If the principal is zero or negative. if principal <= 0: raise ValueError(\\"The principal must be a positive number\\") apr = (interest * 100) / principal return round(apr, 2)"},{"question":"# Problem Description You are given a list of integers `input_list`. Your task is to write a function `group_and_count` that groups the integers by their value, counts the occurrences of each integer, and returns a dictionary with each unique integer as the key and the count of its occurrences as the value. # Input * `input_list` (list): A list of integers. # Output * The function should return a dictionary where the keys are the unique integers from the `input_list` and the values are the counts of their occurrences. # Constraints * The list can contain negative and positive integers, as well as zero. * The list can be empty. * The integers in the list can repeat. # Example ```python >>> group_and_count([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) {1: 1, 2: 2, 3: 3, 4: 4} >>> group_and_count([4, 4, 4, 4]) {4: 4} >>> group_and_count([-1, -1, 0, 1, 1, 1]) {-1: 2, 0: 1, 1: 3} >>> group_and_count([]) {} ``` # Requirements * Implement the function `group_and_count` that meets the specifications. * Ensure the code handles all edge cases and constraints efficiently.","solution":"def group_and_count(input_list): Groups the integers by their value, counts the occurrences of each integer, and returns a dictionary with each unique integer as the key and the count of its occurrences as the value. Parameters: input_list (list): A list of integers. Returns: dict: A dictionary with unique integers as keys and their counts as values. count_dict = {} for num in input_list: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 return count_dict"},{"question":"# Task You are asked to implement a function that finds the longest subsequence of a string where each character appears an even number of times. This type of problem is often encountered in scenarios such as genetic sequencing or cryptography. # Problem Statement **Function Signature**: ```python def longest_even_subsequence(s: str) -> int: \'\'\' Parameters: s (str): A string containing only lowercase alphabets. Returns: int: The length of the longest subsequence where each character appears an even number of times. \'\'\' ``` Your task is to implement the `longest_even_subsequence` function that calculates the length of the longest subsequence in which every character appears an even number of times. A subsequence is derived from a string by deleting some or no characters without changing the order of the remaining characters. # Constraints * The input string `s` will only contain lowercase alphabets. * The length of the string `s` will be between 1 and 10^5. # Examples Example 1: * Input: ```python s = \\"aabbcc\\" ``` * Output: ```python 6 ``` Example 2: * Input: ```python s = \\"abcabcab\\" ``` * Output: ```python 6 ``` Example 3: * Input: ```python s = \\"aabcccdd\\" ``` * Output: ```python 6 ``` # Notes * The function should be efficient both in terms of time complexity and memory usage. * You may assume that the input string contains only lowercase alphabets (\'a\'-\'z\'). * A subsequence can be derived by deleting some characters of the string such that the order of the remaining characters is preserved.","solution":"def longest_even_subsequence(s: str) -> int: Returns the length of the longest subsequence where each character appears an even number of times. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Initialize the length of the longest subsequence with even counts even_length = 0 # Iterate through each frequency value for count in freq.values(): # If the count is even, add it to even_length if count % 2 == 0: even_length += count else: # If the count is odd, add the largest even number just smaller than the count even_length += (count - 1) return even_length"},{"question":"Problem Statement You are given a sorted list of integers and a range defined by two integers, `low` and `high`. Your task is to implement a function `search_range` that returns a list of all elements within the given range [low, high] (inclusive). # Function Signature ```python def search_range(sorted_list: list[int], low: int, high: int) -> list[int]: pass ``` # Input - `sorted_list`: A list of integers sorted in ascending order. - `low`: The lower bound of the range (inclusive). - `high`: The upper bound of the range (inclusive). # Output - A list of integers from `sorted_list` that are within the specified range [low, high]. # Constraints - `1 <= len(sorted_list) <= 10^5` - `-10^9 <= sorted_list[i], low, high <= 10^9` - `low <= high` # Requirements - Use binary search to find the starting index of the first element greater than or equal to `low` and the ending index of the last element less than or equal to `high`. - Your implementation should handle edge cases like an empty list, range bounds outside the actual list bounds, and cases where no elements fall within the range. # Example Example 1: ```python sorted_list = [1, 2, 3, 4, 5, 6, 7, 8, 9] low = 3 high = 7 search_range(sorted_list, low, high) ``` **Output**: `[3, 4, 5, 6, 7]` Example 2: ```python sorted_list = [10, 20, 30, 40, 50] low = 15 high = 35 search_range(sorted_list, low, high) ``` **Output**: `[20, 30]` Example 3: ```python sorted_list = [1, 2, 3, 4, 5] low = 6 high = 9 search_range(sorted_list, low, high) ``` **Output**: `[]` # Additional Requirements - Your implementation should be efficient with a time complexity of O(log n). # Hints - Think about how you can use binary search to find the lower and upper bounds for the range and then slice the list accordingly.","solution":"def search_range(sorted_list: list[int], low: int, high: int) -> list[int]: def binary_search_left(array, target): left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < target: left = mid + 1 else: right = mid return left def binary_search_right(array, target): left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] <= target: left = mid + 1 else: right = mid return left left_index = binary_search_left(sorted_list, low) right_index = binary_search_right(sorted_list, high) return sorted_list[left_index:right_index]"},{"question":"# AVL Tree Implementation and Height Calculation An AVL tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. Your task is to implement the AVL tree and calculate its height after multiple insertions. Task Requirements 1. **Class Implementation**: - Implement a class `AVLTree` that supports insertion operations maintaining AVL tree properties. - Ensure the tree balances itself after each insertion to maintain the AVL property. 2. **Methods**: - `insert(data: int)`: Insert an integer value into the AVL tree while maintaining its balance. - `height() -> int`: Calculate and return the height of the AVL tree. 3. **Testing**: - Write comprehensive test cases for your class, ensuring all edge cases are covered. Class Signature ```python class AVLTree: def __init__(self): Initialize an empty AVL tree. # Your implementation here def insert(self, data: int): Insert a new integer into the AVL tree. Parameters ---------- data : int The value to insert into the AVL tree. # Your implementation here def height(self) -> int: Calculate and return the height of the AVL tree. Returns ------- int The height of the AVL tree. # Your implementation here ``` Input and Output Formats - **Input**: - A series of integer values inserted into the AVL tree. - **Output**: - The height of the AVL tree after all insertions. Constraints - Do not use any libraries that handle the entire tree management process for you. Example ```python avl_tree = AVLTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) assert avl_tree.height() == 2 avl_tree.insert(40) avl_tree.insert(50) avl_tree.insert(25) assert avl_tree.height() == 3 ```","solution":"class AVLTree: class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return self.Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._rotate_right(node) if balance < -1 and key > node.right.key: return self._rotate_left(node) if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def height(self): return self._get_height(self.root)"},{"question":"# Coding Question Task: You are required to write a function that takes an array of integers and a target integer. The function should return the indices of the two numbers in the array that add up to the target. Your implementation should ensure there is exactly one solution, and you may not use the same element twice. Function Signature: ```python def two_sum(nums: List[int], target: int) -> List[int]: pass ``` Input: * `nums` (List[int]): A list of integers. * `target` (int): The target integer. Output: * The function should return a list of two integers which are the indices of the two numbers in `nums` that add up to `target`. Constraints: * Each input would have exactly one solution. * `nums` can have any length from 2 to 10^4. * Each element in `nums` is an integer from `-10^9` to `10^9`. * The same element cannot be used twice. Example: ```python print(two_sum([2, 7, 11, 15], 9)) print(two_sum([3, 2, 4], 6)) print(two_sum([3, 3], 6)) ``` Expected Outputs: ``` [0, 1] [1, 2] [0, 1] ``` Performance Requirements: The solution should aim for an O(n) time complexity. Hints: 1. Use a hash map to store the difference between the target and each element. 2. Iterate through the list and check if the current element exists in the hash map.","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in the list that add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return [] # Given the constraints, this will never be reached"},{"question":"# Coding Assessment Question Context In graph theory, a connected component of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. Given an undirected graph represented as an adjacency list, your task is to implement a function to find the number of connected components in the graph. Task Write a function `count_connected_components(graph: dict) -> int` that returns the number of connected components in the given graph. Input * A dictionary `graph` where the keys are integers representing the nodes, and the values are lists of integers representing the adjacent nodes. Output * An integer representing the number of connected components in the graph. Constraints * Each node in the graph has a distinct integer identifier. * The graph can have at most 100,000 nodes and 200,000 edges. Example ```python def count_connected_components(graph: dict) -> int: # Implementation here pass # Example Usage graph = { 0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3] } print(count_connected_components(graph)) # Output: 2 graph = { 0: [1], 1: [0, 2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [6], 6: [5] } print(count_connected_components(graph)) # Output: 2 ``` # Requirements * Implement a Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse the graph. * Utilize this traversal method to identify and count the number of connected components. * Return the count of connected components in the graph.","solution":"def count_connected_components(graph): Returns the number of connected components in the given graph. Parameters: graph (dict): A dictionary representing the graph in adjacency list format. Returns: int: The number of connected components. visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) count = 0 for node in graph: if node not in visited: visited.add(node) dfs(node) count += 1 # Handle any disconnected nodes that are not present in the keys of the graph dictionary disconnected_nodes = set(graph.keys()).difference(visited) count += len(disconnected_nodes) return count"},{"question":"# Coding Assessment Question: Design and Implement a Custom LinkedList with Sorting Objective: Design and implement a custom linked list data structure with the ability to sort its elements. Description: Design and implement a class `CustomLinkedList` which supports the following methods: * `__init__(self)`: Initializes an empty linked list. * `insert(self, value)`: Inserts a value into the linked list at the end. * `sort(self)`: Sorts the elements of the linked list in non-decreasing order. * `to_list(self)`: Returns a Python list containing all elements in the linked list. Input/Output: * `__init__(self)`: Initializes an empty linked list. * `insert(self, value)`: Inserts the value into the linked list. * `sort(self)`: Sorts the linked list in non-decreasing order. * `to_list(self)`: Returns the linked list elements as a Python list. Constraints: * The linked list should only use basic data structures (no using Python’s built-in list except for the `to_list` method). * You may assume the values are integers. * Implement a sorting algorithm of your choice, ensuring it operates in-place on the linked list. Example: ```python # Example usage ll = CustomLinkedList() ll.insert(3) ll.insert(1) ll.insert(2) ll.insert(4) print(ll.to_list()) # Output: [3, 1, 2, 4] ll.sort() print(ll.to_list()) # Output: [1, 2, 3, 4] ``` Requirements: * Implement in-place sorting for the linked list. * Ensure the linked list can handle edge cases like duplicates and an initially empty list. * Implement efficient insertion and sorting logic. Here\'s a template to help you get started: ```python class Node: def __init__(self, value=None): self.value = value self.next = None class CustomLinkedList: def __init__(self): self.head = None def insert(self, value): # Implementation for inserting a value into the linked list pass def sort(self): # Implementation for sorting the linked list using an in-place sorting algorithm pass def to_list(self): # Implementation for converting linked list to a Python list pass # Example usage ll = CustomLinkedList() ll.insert(3) ll.insert(1) ll.insert(2) ll.insert(4) print(ll.to_list()) # Output: [3, 1, 2, 4] ll.sort() print(ll.to_list()) # Output: [1, 2, 3, 4] ```","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None class CustomLinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def sort(self): if not self.head or not self.head.next: return self.head = self.merge_sort(self.head) def merge_sort(self, head): if not head or not head.next: return head mid = self.get_mid(head) left = head right = mid.next mid.next = None left = self.merge_sort(left) right = self.merge_sort(right) return self.merge(left, right) def get_mid(self, head): slow = head fast = head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next return slow def merge(self, left, right): dummy = Node() current = dummy while left and right: if left.value <= right.value: current.next = left left = left.next else: current.next = right right = right.next current = current.next current.next = left if left else right return dummy.next def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"# Problem Statement Given a list of integers, you need to find the length of the longest subsequence such that each element in this subsequence is a multiple of the previous element in the subsequence. # Objective Write a function `longest_multiple_subsequence(lst)` that takes a list of integers `lst` and returns the length of the longest subsequence where every element is a multiple of its predecessor. # Input - `lst`: A list of integers (`1 <= len(lst) <= 1000`, `1 <= lst[i] <= 10^9`). # Output - Returns an integer representing the length of the longest subsequence where each element is a multiple of the previous element in the subsequence. # Constraints - Elements of the list are positive integers. - You can assume the input list is non-empty. # Performance Requirements The function should be optimized to handle lists up to 1000 elements efficiently. # Example ```python # Input: [1, 2, 4, 8, 16, 3, 9, 27] # Output: 5 # Explanation: The longest subsequence where each element is a multiple of the previous one is [1, 2, 4, 8, 16]. # Input: [3, 6, 4, 12, 24] # Output: 4 # Explanation: The longest subsequence where each element is a multiple of the previous one is [3, 6, 12, 24]. # Input: [4, 8, 5, 10] # Output: 2 # Explanation: One possible subsequence is [4, 8] and another is [5, 10]. ``` # Function Definition ```python def longest_multiple_subsequence(lst: list[int]) -> int: n = len(lst) if n == 1: return 1 lst.sort() dp = [1] * n for i in range(1, n): for j in range(i): if lst[i] % lst[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Testing the function print(longest_multiple_subsequence([1, 2, 4, 8, 16, 3, 9, 27])) # Output: 5 print(longest_multiple_subsequence([3, 6, 4, 12, 24])) # Output: 4 print(longest_multiple_subsequence([4, 8, 5, 10])) # Output: 2 ```","solution":"def longest_multiple_subsequence(lst): n = len(lst) if n == 1: return 1 lst.sort() dp = [1] * n # dp[i] will store the length of the longest subsequence ending with lst[i] for i in range(1, n): for j in range(i): if lst[i] % lst[j] == 0: # If lst[i] is a multiple of lst[j] dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Coding Assessment Question Context: You are designing a software application that manipulates string data. One of the common operations involves finding all the unique substrings of a given string. To test your proficiency in string manipulation and algorithm design, you need to implement a function that generates all unique substrings of a given string and displays them sorted in lexicographical order. Task: 1. Implement a function to generate all unique substrings of a given string. 2. Sort the resulting substrings in lexicographical order. 3. Include a main function to accept a string input from users, generate the substrings, sort them, and print them. Requirements: 1. **Function `generate_unique_substrings(s: str) -> List[str]`** - Receive a string as input and return a list of all unique substrings sorted in lexicographical order. 2. **Function `main()`** - Accept a string from the user. - Generate all unique substrings using `generate_unique_substrings`. - Sort the substrings in lexicographical order. - Print the sorted substrings. Constraints: - The input string can be of length up to 100. - The function should handle edge cases such as empty strings or strings with all identical characters. - The substrings should be unique and sorted lexicographically. Example: For an input string `\\"abc\\"`: - `generate_unique_substrings(\\"abc\\")` should return `[\'a\', \'ab\', \'abc\', \'b\', \'bc\', \'c\']`. For an input string `\\"aba\\"`: - `generate_unique_substrings(\\"aba\\")` should return `[\'a\', \'ab\', \'aba\', \'b\', \'ba\']`.","solution":"from typing import List def generate_unique_substrings(s: str) -> List[str]: This function generates all unique substrings of a given string `s` and returns them sorted in lexicographical order. unique_substrings = set() length = len(s) # Generate all substrings for i in range(length): for j in range(i + 1, length + 1): unique_substrings.add(s[i:j]) # Convert to list and sort lexicographically return sorted(unique_substrings) def main(): Main function that accepts a string input from the user, generates all unique substrings, sorts them, and prints them. input_string = input(\\"Enter a string: \\") substrings = generate_unique_substrings(input_string) print(\\"n\\".join(substrings))"},{"question":"# Coding Assessment Question You\'ve been assigned to create a data processing pipeline for a time-series dataset. The goal is to compute a feature matrix suitable for training a predictive model. The dataset is provided in a CSV file with two columns: \\"timestamp\\" and \\"value\\". Your task is to implement a function that reads this file and generates a matrix where each row represents a time-step with a specified number of lagged observations as features. Function Signature ```python def create_feature_matrix( file_path: str, n_lags: int, output_path: str ) -> None: ``` Input Specifications: - **file_path** (*str*): Path to the CSV file containing the dataset. - **n_lags** (*int*): Number of lagged observations to include as features in the generated matrix. - **output_path** (*str*): Path to save the generated feature matrix CSV file. Output Specifications: - This function does not return anything. Instead, it writes the generated feature matrix to a CSV file specified by `output_path`. Example Usage: Given a CSV file `data.csv` with the following contents: ``` timestamp,value 2023-01-01 00:00:00,10 2023-01-01 01:00:00,15 2023-01-01 02:00:00,20 2023-01-01 03:00:00,25 2023-01-01 04:00:00,30 ``` If `n_lags` is set to 3, the function should generate a feature matrix like this: ``` lag_1,lag_2,lag_3,value 10.0,NaN,NaN,15 15,10.0,NaN,20 20,15,10.0,25 25,20,15,30 ``` This feature matrix should then be saved to the specified `output_path`. Constraints: - You may assume the timestamps are ordered chronologically and there are no missing time steps. - Handle files with up to 1 million rows efficiently. - Ensure proper handling of edge cases, such as files with less data than `n_lags`. - Use robust error handling and data integrity checks. Implementation Example: ```python import pandas as pd def create_feature_matrix(file_path: str, n_lags: int, output_path: str) -> None: df = pd.read_csv(file_path) for i in range(1, n_lags + 1): df[f\'lag_{i}\'] = df[\'value\'].shift(i) df.to_csv(output_path, index=False) ``` Compose your function under the guidelines provided, ensuring it performs accurately and handles all cases gracefully.","solution":"import pandas as pd def create_feature_matrix(file_path: str, n_lags: int, output_path: str) -> None: Reads a CSV file and generates a matrix with lagged observations as features. Parameters: file_path (str): Path to the CSV file containing the dataset. n_lags (int): Number of lagged observations to include as features. output_path (str): Path to save the generated feature matrix CSV file. Returns: None try: # Read the CSV file df = pd.read_csv(file_path) # Generate lagged features for i in range(1, n_lags + 1): df[f\'lag_{i}\'] = df[\'value\'].shift(i) # Save the resulting dataframe to the specified output path df.to_csv(output_path, index=False) except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"# Coding Assessment Question You have been hired by a logistics company to improve their package tracking system. The company previously used a simple, linear way to track the packages, but it has become inefficient due to the increasing data size. Your tasks are: 1. **Implement a function to fetch package details using a new and optimized API endpoint.** - The new endpoint is \\"https://optimization-api.com/packages\\". - Ensure the function can handle large volumes of data efficiently. 2. **Improve package search functionality:** - Replace the linear search mechanism with a binary search method to enhance the search speed for the packages. - Assure that the package data is sorted based on package ID or other relevant identifiers before performing a binary search. 3. **Enhance error handling:** - Implement comprehensive error handling to manage scenarios such as timeout errors, API response errors, and corrupted data entries. - Ensure appropriate error logging and provide a fallback mechanism if the API is unreachable. 4. **Implement data caching:** - Add a caching mechanism to store recent package data and reduce the number of API calls. - Ensure the cache is updated regularly and invalidated correctly when new data is fetched. **Input:** - A string representing the package ID to be searched. - An integer defining the maximum cache size. - An integer representing the timeout for each network request in milliseconds. **Output:** - Details of the specific package corresponding to the provided package ID if found. - Raise an appropriate error with a clear message if the package is not found or if there\'s an API failure. **Constraints:** - The API endpoint must return data in JSON format containing package details. - API calls can include up to 5 package requests per second. - Package data includes information such as package ID, origin, destination, current status, estimated delivery time, and last update timestamp. - Ensure your binary search function operates in `O(log n)` complexity. **Scenario Context:** Consider a scenario where the logistics company is expanding its operations, and the ability to quickly and accurately track packages becomes increasingly essential. The system must handle high traffic, provide fast lookup, and gracefully manage potential failures to ensure continuous service to the clients.","solution":"import requests from cachetools import LRUCache import logging from typing import List import time # Initialize logger logging.basicConfig(level=logging.INFO) logger = logging.getLogger() # Initialize LRU Cache cache = None def fetch_package_data(api_url: str, timeout: int): Function to fetch package details from the optimized API endpoint. :param api_url: the API URL to fetch data from :param timeout: the timeout for the API request in seconds :return: List of package data in JSON format try: response = requests.get(api_url, timeout=timeout) response.raise_for_status() return response.json() except requests.exceptions.Timeout: logger.error(\\"The request timed out\\") raise TimeoutError(\\"The request timed out\\") except requests.exceptions.RequestException as e: logger.error(f\\"An error occurred: {e}\\") raise Exception(\\"An error occurred during the API request\\") def binary_search(package_list: List[dict], package_id: str) -> dict: Perform a binary search on the sorted package list based on package ID. :param package_list: List of packages sorted by package ID :param package_id: The package ID to search for :return: Dictionary containing package details or None if not found left, right = 0, len(package_list) - 1 while left <= right: mid = (left + right) // 2 if package_list[mid][\'package_id\'] == package_id: return package_list[mid] elif package_list[mid][\'package_id\'] < package_id: left = mid + 1 else: right = mid - 1 return None def get_package_details(package_id: str, cache_size: int, timeout: int): Main function to get package details by package ID. :param package_id: the package ID to search for :param cache_size: maximum size of the LRU cache :param timeout: timeout for the API request in seconds :return: Dictionary with the package details or raise an error if not found global cache if cache is None: cache = LRUCache(maxsize=cache_size) api_url = \\"https://optimization-api.com/packages\\" # Check cache first if package_id in cache: logger.info(\\"Fetching from cache\\") return cache[package_id] logger.info(\\"Fetching from API\\") package_data = fetch_package_data(api_url, timeout) # Assume data is sorted for efficient binary search sorted_package_data = sorted(package_data, key=lambda x: x[\'package_id\']) package = binary_search(sorted_package_data, package_id) if package: cache[package_id] = package return package logger.error(\\"Package not found\\") raise ValueError(f\\"Package with ID {package_id} not found\\")"},{"question":"New Question You are tasked with developing a system to find the shortest paths from a library\'s main entrance to different sections of the library using Dijkstra\'s Algorithm. The library is represented as a graph where nodes correspond to different sections, and edges with weights represent the possible paths between these sections and the respective travel time in minutes. # Function Signature: ```python def dijkstra(graph: dict, start: int) -> dict: ``` # Input: - `graph`: A dictionary of dictionaries, where `graph[u][v]` represents the travel time from section `u` to section `v`. - `start`: An integer representing the starting section in the library (main entrance). # Output: - A dictionary where keys are the section numbers and values are the shortest travel times from the `start` section to that section. # Constraints: - The travel time on each path is a non-negative integer. - 1 <= number of sections <= 1000 - 0 <= travel time on each path <= 1000 # Performance Requirements: - Your implementation should efficiently compute the shortest paths, considering potential performance bottlenecks for large graphs. # Example: ```python graph = { 0: {1: 4, 2: 1}, 1: {3: 1}, 2: {1: 2, 3: 5}, 3: {} } start = 0 dijkstra(graph, start) # returns {0: 0, 1: 3, 2: 1, 3: 4} ``` # Notes: - You can assume the input graph is valid and that there is at least one path from the start section to any other section. - Ensure to handle edge cases where parts of the library graph may be isolated or the graph is very sparse. - Consider the time complexity while designing your solution and attempt to make the algorithm as efficient as possible. # Explanation: - Initialize the distance to the start section as 0 and all other sections as infinity. - Use a priority queue to always expand the shortest known distance. - Update the distances to all adjacent sections in the graph where a shorter path is found. - Continue until all sections have been visited and the shortest distances have been calculated. This problem will test your understanding of Dijkstra\'s algorithm, priority queues, and graph traversal techniques.","solution":"import heapq def dijkstra(graph, start): Uses Dijkstra\'s algorithm to find the shortest path from the start node to every other node in the graph. Parameters: graph (dict): A dictionary of dictionaries representing the graph. start (int): The starting node. Returns: dict: A dictionary where keys are the section numbers and values are the shortest travel times from the start section. # Initialize distances with infinity and set the distance to the start node to be 0 distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Priority queue to store (distance, node) tuples priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the current distance is greater than the recorded shortest distance, skip this node if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Question - Balancing Parentheses for Nested Expressions In developing a parser for a new programming language, you need to ensure that the expressions are well-formed, particularly when it comes to nested parentheses. Your task is to write a function that checks whether an expression containing various types of parentheses (round `()`, square `[]`, and curly `{}`) is properly balanced. Properly balanced means that the parentheses close in the correct order and type. # Scenario A programming language parser must validate expressions to ensure they are syntactically correct. In this case, you are tasked with validating a particular subset of expressions to ensure all types of parentheses are correctly balanced and closed. # Task 1. Implement the `is_balanced` function according to the given specification. 2. Ensure the function can handle expressions containing multiple types of parentheses. # Function Signature ```python def is_balanced(expression: str) -> bool: pass ``` # Input * `expression`: A string containing the expression with various types of parentheses. # Output * Return `True` if the expression is properly balanced, `False` otherwise. # Constraints * The string length does not exceed 10^6 characters. * The expression contains only the following characters: `()[]{}` and any other alphanumeric characters or symbols. # Example ```python assert is_balanced(\\"a * (b + c) / {d - [e * f]}\\") == True assert is_balanced(\\"{a + b * (c / d)}\\") == True assert is_balanced(\\"[{a + b} * (c + d)] / e\\") == True assert is_balanced(\\"a + b * {(c + d)\\") == False assert is_balanced(\\"[a + b] * (c + d] - e\\") == False assert is_balanced(\\"a + b * {c + d}\\") == True assert is_balanced(\\"}\\") == False ``` # Additional Notes * Consider edge cases such as empty strings or strings without any parentheses. * Utilize a stack data structure to help with checking the balance and order of the parentheses. * Focus on maintaining efficient time and space complexity, aiming for O(n) time and O(n) space complexity where n is the length of the expression.","solution":"def is_balanced(expression: str) -> bool: stack = [] matching_parentheses = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in expression: if char in \'([{\': stack.append(char) elif char in \')]}\': if not stack or stack.pop() != matching_parentheses[char]: return False return not stack"},{"question":"# Sorting a Dictionary by Values Task Scenario You are developing a data analysis tool where a part of the process involves sorting data by various criteria for better insights. To simplify this task, you need to implement a function that sorts the contents of a dictionary based on its values. Requirements Implement a function `sort_dict_by_values()` that sorts a dictionary\'s keys based on their corresponding values. The function should return a list of tuples representing the key-value pairs, sorted in ascending order by value. If the values are the same, maintain the order of first appearance. Function Signature ```python def sort_dict_by_values(data: dict) -> list: pass ``` Input * `data` (dict): A dictionary where keys are strings and values are integers. Output * Returns a list of tuples, each tuple containing a key and its corresponding value from the input dictionary, sorted by value in ascending order. Constraints * Keys in the dictionary are unique strings. * Values in the dictionary are integers which could be positive, negative, or zero. Test Case Example Input: ```python data = { \\"apple\\": 3, \\"banana\\": 1, \\"cherry\\": 2, \\"date\\": 1 } ``` Expected Output: ```python [ (\\"banana\\", 1), (\\"date\\", 1), (\\"cherry\\", 2), (\\"apple\\", 3) ] ``` # Notes - Ensure that if values are the same, the order of their first appearance in the original dictionary is retained in the output.","solution":"def sort_dict_by_values(data: dict) -> list: Sorts the dictionary by its values in ascending order and returns a list of tuples, where each tuple contains a key-value pair. If two values are the same, the order of their first appearance is maintained. return sorted(data.items(), key=lambda item: item[1])"},{"question":"# Problem Statement You have been assigned to develop a feature for a weather forecasting application, allowing users to convert temperatures between Fahrenheit, Celsius, and Kelvin. The application should handle different formats of input units and ensure accurate conversions, providing clear error messages for unsupported input units. Implement a function `temperature_conversion(value: float, from_unit: str, to_unit: str) -> float` that performs the necessary conversions. # Input: - `value` (float): The numerical value of the temperature to be converted. - `from_unit` (str): The unit of the input value (valid units are \'Fahrenheit\', \'Celsius\', \'Kelvin\'). - `to_unit` (str): The target unit to which the value should be converted (valid units are \'Fahrenheit\', \'Celsius\', \'Kelvin\'). # Output: - Return the converted temperature as a float. # Constraints: - The function should support the following temperature units: Fahrenheit, Celsius, Kelvin. - Units are case insensitive. - If unsupported units are provided, raise a `ValueError` with a descriptive error message. Requirements: 1. Conversion between supported temperature units must be precise. 2. Input units that are not recognized must result in a `ValueError` with a message specifying the valid unit names. # Example Usage: ```python >>> temperature_conversion(32, \'fahrenheit\', \'celsius\') 0.0 >>> temperature_conversion(0, \'celsius\', \'kelvin\') 273.15 >>> temperature_conversion(273.15, \'kelvin\', \'fahrenheit\') 32.0 >>> temperature_conversion(100, \'celsius\', \'fahrenheit\') 212.0 >>> temperature_conversion(100, \'invalidUnit\', \'fahrenheit\') Traceback (most recent call last): ... ValueError: Invalid \'from_unit\' value: \'invalidUnit\'. Valid units are: Fahrenheit, Celsius, Kelvin >>> temperature_conversion(100, \'celsius\', \'invalidUnit\') Traceback (most recent call last): ... ValueError: Invalid \'to_unit\' value: \'invalidUnit\'. Valid units are: Fahrenheit, Celsius, Kelvin ``` Conversion Formulas: 1. **Fahrenheit to Celsius**: `C = (F - 32) * 5/9` 2. **Celsius to Fahrenheit**: `F = C * 9/5 + 32` 3. **Celsius to Kelvin**: `K = C + 273.15` 4. **Kelvin to Celsius**: `C = K - 273.15` 5. **Fahrenheit to Kelvin**: `K = (F - 32) * 5/9 + 273.15` 6. **Kelvin to Fahrenheit**: `F = (K - 273.15) * 9/5 + 32`","solution":"def temperature_conversion(value: float, from_unit: str, to_unit: str) -> float: Converts temperature between Fahrenheit, Celsius, and Kelvin. Parameters: value (float): The numerical value of the temperature to be converted. from_unit (str): The unit of the input value (valid units are \'Fahrenheit\', \'Celsius\', \'Kelvin\'). to_unit (str): The target unit to which the value should be converted (valid units are \'Fahrenheit\', \'Celsius\', \'Kelvin\'). Returns: float: The converted temperature. Raises: ValueError: If unsupported units are provided. # Normalize unit names to lowercase from_unit = from_unit.lower() to_unit = to_unit.lower() valid_units = [\'fahrenheit\', \'celsius\', \'kelvin\'] if from_unit not in valid_units: raise ValueError(f\\"Invalid \'from_unit\' value: \'{from_unit}\'. Valid units are: Fahrenheit, Celsius, Kelvin\\") if to_unit not in valid_units: raise ValueError(f\\"Invalid \'to_unit\' value: \'{to_unit}\'. Valid units are: Fahrenheit, Celsius, Kelvin\\") # Conversion formulas if from_unit == \'fahrenheit\': celsius = (value - 32) * 5/9 elif from_unit == \'celsius\': celsius = value elif from_unit == \'kelvin\': celsius = value - 273.15 if to_unit == \'fahrenheit\': return celsius * 9/5 + 32 elif to_unit == \'celsius\': return celsius elif to_unit == \'kelvin\': return celsius + 273.15"},{"question":"# Question Scenario You are tasked with building a basic recommendation system for an online bookstore. The system will recommend book titles based on the purchase history of customers. Each customer has a list of book titles they have purchased, and you need to recommend books that other customers with similar purchase histories have bought. Task Write a Python function `recommend_books` that takes in the purchase history of customers and the customer of interest, and returns a list of recommended book titles. Function Specification ```python def recommend_books(purchase_history, customer): Recommends books based on the purchase history of similar customers. Args: purchase_history (dict): A dictionary where keys are customer IDs and values are lists of book titles purchased by that customer. customer (str): The customer ID for whom recommendations are to be made. Returns: list of str: A list of recommended book titles. ``` Constraints - `purchase_history` dictionary will have at least 2 customer IDs. - All book titles are strings. - You should base your recommendations on the book titles purchased by the most similar customer to the given customer. - If there are multiple customers with the same similarity score, use the one that comes first in alphabetical order of customer ID. - You should not recommend any book titles that the given customer has already purchased. Example ```python purchase_history = { \\"C1\\": [\\"BookA\\", \\"BookB\\", \\"BookC\\"], \\"C2\\": [\\"BookD\\", \\"BookE\\", \\"BookA\\"], \\"C3\\": [\\"BookA\\", \\"BookC\\", \\"BookE\\"] } customer = \\"C1\\" assert recommend_books(purchase_history, customer) == [\\"BookE\\"] ``` Performance Requirements - The function should handle a purchase history dictionary with up to 1000 customers efficiently. - Memory usage should remain within typical bounds for personal computers.","solution":"def recommend_books(purchase_history, customer): Recommends books based on the purchase history of similar customers. Args: purchase_history (dict): A dictionary where keys are customer IDs and values are lists of book titles purchased by that customer. customer (str): The customer ID for whom recommendations are to be made. Returns: list of str: A list of recommended book titles. target_books = set(purchase_history[customer]) max_similarity = -1 best_match = None for other_customer, books in purchase_history.items(): if other_customer == customer: continue common_books = target_books.intersection(books) similarity = len(common_books) if (similarity > max_similarity) or (similarity == max_similarity and other_customer < best_match): max_similarity = similarity best_match = other_customer if best_match is None: return [] recommended_books = set(purchase_history[best_match]) - target_books return list(recommended_books)"},{"question":"# Question: You are required to create a function that analyzes the stock market data for a given company listed on the Alpha Vantage API. The objective is to extract specific information about the company\'s stock performance for a certain date. # Function Specification **Function Signature** ```python def fetch_stock_data(company_symbol: str, date: str) -> StockData: pass ``` **Input** - `company_symbol` (string): The stock symbol of the company (e.g., \\"AAPL\\" for Apple Inc.). This parameter should be a valid stock symbol. - `date` (string): The specific date for which you require the stock data in the format YYYY-MM-DD. **Output** - Returns an instance of `StockData`, which is a namedtuple containing: - `open_price` (float): Opening price of the stock on the given date. - `high_price` (float): Highest price of the stock on the given date. - `low_price` (float): Lowest price of the stock on the given date. - `close_price` (float): Closing price of the stock on the given date. - `volume` (int): Number of shares traded on the given date. **Constraints** - The function should handle timeouts and other network-related errors gracefully. - The input `company_symbol` and `date` must be valid parameters that Alpha Vantage API can process correctly. - Use the Alpha Vantage API endpoint for fetching the daily stock time series (https://www.alphavantage.co/documentation/). # Example ```python data = fetch_stock_data(\\"AAPL\\", \\"2022-03-15\\") print(f\\"Open: {data.open_price}, High: {data.high_price}, Low: {data.low_price}, Close: {data.close_price}, Volume: {data.volume}\\") ``` **Performance Requirements** - The function should efficiently fetch and parse the stock data for the given date. # Instructions 1. Familiarize yourself with the Alpha Vantage API and its usage, especially the endpoint for the daily stock time series data. 2. Write the `fetch_stock_data` function utilizing `requests` and JSON parsing techniques. 3. Implement error handling for scenarios like invalid API responses, HTTP errors, and cases where the specified date has no trading data (e.g., weekends or holidays). 4. Test the function with various company symbols and dates to ensure its accuracy and robustness.","solution":"import requests from collections import namedtuple StockData = namedtuple(\\"StockData\\", [\\"open_price\\", \\"high_price\\", \\"low_price\\", \\"close_price\\", \\"volume\\"]) def fetch_stock_data(company_symbol: str, date: str) -> StockData: API_KEY = \'YOUR_API_KEY\' # Replace with your actual Alpha Vantage API key BASE_URL = \'https://www.alphavantage.co/query\' params = { \\"function\\": \\"TIME_SERIES_DAILY\\", \\"symbol\\": company_symbol, \\"apikey\\": API_KEY } response = requests.get(BASE_URL, params=params) if response.status_code == 200: data = response.json() if \\"Time Series (Daily)\\" in data and date in data[\\"Time Series (Daily)\\"]: daily_data = data[\\"Time Series (Daily)\\"][date] return StockData( open_price=float(daily_data[\\"1. open\\"]), high_price=float(daily_data[\\"2. high\\"]), low_price=float(daily_data[\\"3. low\\"]), close_price=float(daily_data[\\"4. close\\"]), volume=int(daily_data[\\"5. volume\\"]) ) else: raise ValueError(\\"No data available for the given date.\\") else: response.raise_for_status()"},{"question":"# Sum of Leaf Nodes in a Binary Tree **Objective:** Write a function that takes a binary tree represented as a dictionary and returns the sum of all its leaf nodes. **Function Signature:** ```python def sum_leaves(binary_tree: dict, root: int = 1) -> int: Given a binary tree, calculate the sum of all its leaf nodes. Parameters: binary_tree (dict): Dictionary representing the binary tree where the key is the node and the value is a list of two integers [left_child, right_child]. root (int): The root of the binary tree. Returns: int: The sum of all leaf nodes. Raises: ValueError: If the binary tree is empty or the root is not present in the binary tree. Examples: >>> sum_leaves({1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [], 6: [], 7: []}, 1) 22 >>> sum_leaves({1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [8, 9], 5: [], 6: [], 7: [], 8: [], 9: []}, 1) 35 >>> sum_leaves({1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [8, 9], 5: [], 6: [10, 11], 7: [], 8: [], 9: [], 10: [], 11: []}, 1) 39 >>> sum_leaves({}, 1) Traceback (most recent call last): ... ValueError: binary tree cannot be empty >>> sum_leaves({1: [2, 3]}, 5) Traceback (most recent call last): ... ValueError: root 5 is not present in the binary_tree ``` **Requirements:** 1. **Input:** - `binary_tree`: A dictionary representing the binary tree. - `root`: An integer representing the root node. 2. **Constraints:** - The binary tree dictionary is not empty. - Each key-value pair in the dictionary represents a node and its children as a list [left_child, right_child]. - Handle scenarios where the root is not present in the dictionary. 3. **Output:** - An integer representing the sum of all leaf nodes. 4. **Performance Considerations:** - Aim for a time complexity of O(n) where n is the number of nodes in the tree. - Space complexity should be O(h), where h is the height of the tree. Enforce the error handling for edge cases such as an empty tree and invalid roots.","solution":"def sum_leaves(binary_tree: dict, root: int = 1) -> int: Given a binary tree, calculate the sum of all its leaf nodes. Parameters: binary_tree (dict): Dictionary representing the binary tree where the key is the node and the value is a list of two integers [left_child, right_child]. root (int): The root of the binary tree. Returns: int: The sum of all leaf nodes. Raises: ValueError: If the binary tree is empty or the root is not present in the binary tree. if not binary_tree: raise ValueError(\\"binary tree cannot be empty\\") if root not in binary_tree: raise ValueError(f\\"root {root} is not present in the binary_tree\\") def traverse(node): if node not in binary_tree: return 0 children = binary_tree[node] if not children: # Leaf node return node left_sum = traverse(children[0]) if children[0] else 0 right_sum = traverse(children[1]) if children[1] else 0 return left_sum + right_sum return traverse(root)"},{"question":"# Question: Implement a Custom Linear Regression Model You are tasked with writing a function to implement a custom linear regression model from scratch. This exercise will test your understanding of fundamental machine learning concepts, specifically linear regression, gradient descent optimization, and performance evaluation. Your function should involve calculating the optimal weights using gradient descent, making predictions, and evaluating the model using Root Mean Squared Error (RMSE). # Function Signature: ```python def linear_regression_model(X_train: np.ndarray, y_train: np.ndarray, X_test: np.ndarray, y_test: np.ndarray, learning_rate: float, n_iterations: int) -> tuple[np.ndarray, float]: pass ``` # Input: 1. `X_train` (np.ndarray): A 2D numpy array of shape (n_samples, n_features) representing the training data. 2. `y_train` (np.ndarray): A 1D numpy array of shape (n_samples,) representing the target values for training data. 3. `X_test` (np.ndarray): A 2D numpy array of shape (m_samples, n_features) representing the test data. 4. `y_test` (np.ndarray): A 1D numpy array of shape (m_samples,) representing the target values for test data. 5. `learning_rate` (float): The learning rate for gradient descent. 6. `n_iterations` (int): The number of iterations for running gradient descent. # Output: 1. A 1D numpy array of shape (n_features + 1,) representing the learned weights (including the bias term as the first element). 2. A float representing the RMSE of the model on the test set. # Constraints: 1. `X_train` and `X_test` should not contain missing data. 2. Ensure `learning_rate` is a small positive number, e.g., 0.01. 3. `n_iterations` should be a positive integer. # Example Usage: ```python weights, rmse = linear_regression_model(np.array([[1, 2], [3, 4], [5, 6]]), np.array([7, 8, 9]), np.array([[1, 2], [5, 6]]), np.array([7, 9]), 0.01, 1000) print(weights) # Output could be: np.array([0.1, 0.2, 0.3]) print(rmse) # Output could be: 0.5 ``` # Task: * Implement the described function. * Calculate the optimal weights using gradient descent. * Make predictions on the test data and evaluate the model using RMSE. * Perform necessary checks and exception handling to ensure robustness. * Test the function with multiple data inputs of varying sizes to verify accuracy. # Notes: - Use of libraries such as NumPy is encouraged. - Pay attention to features normalization if necessary to improve gradient descent performance. - Consider the addition of bias as part of the feature set for better prediction accuracy.","solution":"import numpy as np def linear_regression_model(X_train: np.ndarray, y_train: np.ndarray, X_test: np.ndarray, y_test: np.ndarray, learning_rate: float, n_iterations: int) -> tuple[np.ndarray, float]: Train a linear regression model using gradient descent and evaluate it using RMSE. Parameters: X_train (np.ndarray): Training data of shape (n_samples, n_features) y_train (np.ndarray): Target values for training data of shape (n_samples,) X_test (np.ndarray): Test data of shape (m_samples, n_features) y_test (np.ndarray): Target values for test data of shape (m_samples,) learning_rate (float): Learning rate for gradient descent n_iterations (int): Number of iterations for gradient descent Returns: tuple: A tuple containing the learned weights and RMSE on test data # Add bias term to the training and test data X_train = np.c_[np.ones(X_train.shape[0]), X_train] X_test = np.c_[np.ones(X_test.shape[0]), X_test] # Initialize weights weights = np.zeros(X_train.shape[1]) # Perform gradient descent for _ in range(n_iterations): predictions = X_train.dot(weights) errors = predictions - y_train gradients = (2 / X_train.shape[0]) * X_train.T.dot(errors) weights -= learning_rate * gradients # Calculate predictions for test set y_pred = X_test.dot(weights) # Calculate RMSE rmse = np.sqrt(np.mean((y_test - y_pred) ** 2)) return weights, rmse"},{"question":"**Context:** Graph traversal techniques are fundamental in computer science, especially for navigating through graphs. One common method is Depth First Search (DFS). For a given directed graph, we are interested in identifying all reachable nodes from a given starting node. **Question:** Write a function `reachable_nodes(graph: Dict[int, List[int]], start: int) -> List[int]` that returns a sorted list of all nodes reachable from the given start node using DFS. **Expected Input and Output:** * **Input:** - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of integers representing directed edges. - `start`: An integer representing the starting node. * **Output:** A sorted list of integers representing all nodes reachable from the start node in ascending order. If no nodes are reachable, return an empty list. **Example:** ``` graph = { 0: [1, 2], 1: [2], 2: [3], 3: [], 4: [5], 5: [] } start = 0 ``` Should return `[0, 1, 2, 3]`, as nodes 0, 1, 2, and 3 are reachable from node 0. **Function Signature:** ```python from typing import List, Dict def reachable_nodes(graph: Dict[int, List[int]], start: int) -> List[int]: pass ``` **Constraints:** - The graph may have up to (10^5) nodes and (10^5) edges. - Nodes identifiers are non-negative integers.","solution":"from typing import List, Dict def reachable_nodes(graph: Dict[int, List[int]], start: int) -> List[int]: def dfs(node): if node not in visited: visited.add(node) result.append(node) for neighbor in graph.get(node, []): dfs(neighbor) visited = set() result = [] dfs(start) return sorted(result)"},{"question":"# Question: Optimizing Delivery Route using Dynamic Programming Context: A delivery company needs to optimize the route for delivering packages to ensure minimal travel distance while visiting multiple locations. This is a variant of the classic Travelling Salesperson Problem (TSP) where the goal is to find the shortest possible route that visits each location exactly once and returns to the starting point. Problem Statement: Write a Python function `optimize_delivery_route(distances: list, start: int) -> tuple:` that uses dynamic programming to solve the TSP for a given set of locations. Your function should: 1. Take as input a list of lists `distances` representing the distance matrix between locations and an integer `start` representing the starting location index. 2. Use a dynamic programming approach to find the optimal route with the minimal distance. 3. Return a tuple with the minimal travel distance and the order of locations visited in the optimal route. Input: - `distances`: a `n x n` list of lists where `n` is the number of locations, and `distances[i][j]` represents the travel distance from location `i` to location `j`. - `start`: an integer representing the starting location index. Output: - A tuple where the first element is the minimal travel distance and the second element is a list representing the order of locations visited in the optimal route including the starting point again at the end. Constraints: - Ensure the distance matrix is well-formed and distances are non-negative integers. - Implement an efficient solution that can handle up to 20 locations. - Assume that there is at least one location and the distances between all pairs of locations are known. Example: ```python # Example Input distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] start = 0 # Expected Output minimal_distance, optimal_route = optimize_delivery_route(distances, start) print(minimal_distance) # 80 print(optimal_route) # [0, 1, 3, 2, 0] ``` Implement the complete function `optimize_delivery_route` to solve the given problem.","solution":"def optimize_delivery_route(distances, start): Solves the Travelling Salesperson Problem using dynamic programming to find the minimal travel distance and the optimal route for a given set of locations. Args: distances (list of list of int): The distance matrix where distances[i][j] represents the travel distance from location i to location j. start (int): The starting location index. Returns: tuple: A tuple containing the minimal travel distance and the order of locations visited in the optimal route including the starting point again at the end. from functools import lru_cache n = len(distances) @lru_cache(None) def tsp(mask, pos): # If all cities have been visited, return to the start city if mask == (1 << n) - 1: return distances[pos][start] # Try all cities to find the minimum route ans = float(\'inf\') for city in range(n): if mask & (1 << city) == 0: # if the city is not visited new_ans = distances[pos][city] + tsp(mask | (1 << city), city) ans = min(ans, new_ans) return ans # Find the minimum cost starting from the start city minimal_distance = tsp(1 << start, start) # Reconstruct the optimal route mask = 1 << start pos = start optimal_route = [start] for _ in range(n - 1): best_city = -1 best_cost = float(\'inf\') for city in range(n): if mask & (1 << city) == 0: # if the city is not visited cost = distances[pos][city] + tsp(mask | (1 << city), city) if cost < best_cost: best_city = city best_cost = cost optimal_route.append(best_city) mask |= 1 << best_city pos = best_city optimal_route.append(start) return minimal_distance, optimal_route"},{"question":"# Question: Multi-Leveled Inventory Management System Background You are required to implement an inventory management system for a warehouse. The system needs to track items, their categories, and the quantities available. It should allow for adding items, updating quantities, and viewing the inventory in a grouped format by category. # Requirements: 1. **Class: `Item`** - **Attributes**: - `name` (str): Name of the item. - `category` (str): Category to which the item belongs. - `quantity` (int): Quantity available in stock. - **Methods**: - `__str__() -> str`: Return a string representation of the item as \\"Item(name, category, quantity)\\". 2. **Class: `InventorySystem`** - **Attributes**: - `inventory` (dict): A dictionary where each key is a category and each value is a list of `Item` objects. - **Methods**: - `add_item(name: str, category: str, quantity: int) -> None`: Add a new item to the inventory. - `update_quantity(name: str, category: str, quantity: int) -> None`: Update the quantity of an existing item. If the item does not exist, add it to the inventory. - `view_inventory() -> str`: Return a string that represents the inventory grouped by categories in a readable format. # Constraints: - Ensure items with the same name and category are not duplicated but have their quantities updated. - Input validation should be done to avoid negative quantities. - The `view_inventory` method should ensure a clear and readable presentation. # Example: ```python # Create inventory system inventory = InventorySystem() # Adding items inventory.add_item(\\"Laptop\\", \\"Electronics\\", 10) inventory.add_item(\\"Smartphone\\", \\"Electronics\\", 5) inventory.add_item(\\"Desk Chair\\", \\"Furniture\\", 15) # Updating quantity inventory.update_quantity(\\"Smartphone\\", \\"Electronics\\", 8) # Viewing inventory print(inventory.view_inventory()) ``` The output of `view_inventory` should be: ``` Category: Electronics - Item(name=Laptop, category=Electronics, quantity=10) - Item(name=Smartphone, category=Electronics, quantity=8) Category: Furniture - Item(name=Desk Chair, category=Furniture, quantity=15) ``` Implement the classes and methods as per the requirements. Ensure you test the inventory system with various scenarios, including adding new items, updating existing ones, and viewing the final inventory.","solution":"class Item: def __init__(self, name, category, quantity): self.name = name self.category = category self.quantity = quantity def __str__(self): return f\\"Item(name={self.name}, category={self.category}, quantity={self.quantity})\\" class InventorySystem: def __init__(self): self.inventory = {} def add_item(self, name, category, quantity): if quantity < 0: raise ValueError(\\"Quantity cannot be negative\\") if category not in self.inventory: self.inventory[category] = [] for item in self.inventory[category]: if item.name == name: item.quantity += quantity return new_item = Item(name, category, quantity) self.inventory[category].append(new_item) def update_quantity(self, name, category, quantity): if quantity < 0: raise ValueError(\\"Quantity cannot be negative\\") if category not in self.inventory: self.inventory[category] = [] for item in self.inventory[category]: if item.name == name: item.quantity = quantity return new_item = Item(name, category, quantity) self.inventory[category].append(new_item) def view_inventory(self): result = [] for category, items in self.inventory.items(): result.append(f\\"Category: {category}\\") for item in items: result.append(f\\"- {item}\\") return \\"n\\".join(result)"},{"question":"# Problem Statement: Implement a Custom String Manipulation Function You are tasked with implementing a custom string manipulation function that performs a series of operations on a given input string. The function should: 1. Reverse the order of words in the string. 2. Convert all characters to uppercase. 3. Remove any punctuation from the string. 4. Return the transformed string. # Function Signature ```python def custom_string_manipulation(s: str) -> str: Transforms the input string by reversing the order of words, converting to uppercase, and removing punctuation. Parameters: s (str): The input string. Returns: str: The transformed string. pass ``` # Input * `s`: A string containing words possibly separated by spaces and punctuated with standard punctuation marks. # Output * A string that has the words in reversed order, all characters converted to uppercase, and without any punctuation. # Constraints * The input string will only contain alphabetic characters, spaces, and standard punctuation marks (e.g., commas, periods, exclamation marks). * The input string will have at most 1000 characters. # Example Usage ```python s = \\"Hello, world! How\'s everything?\\" result = custom_string_manipulation(s) print(result) # Expected Output: `EVERYTHING HOWS WORLD HELLO` ``` # Solution Requirements * Implement the `custom_string_manipulation` function to perform the specified transformations on the input string. * Ensure the transformation adheres to the specified order of operations. * Handle edge cases such as empty strings and strings with only punctuation gracefully. # Example Solution ```python import string def custom_string_manipulation(s: str) -> str: # Remove punctuation s = s.translate(str.maketrans(\'\', \'\', string.punctuation)) # Convert to uppercase s = s.upper() # Reverse the order of words words = s.split() reversed_words = words[::-1] result = \' \'.join(reversed_words) return result ``` This question requires a comprehensive understanding of string manipulation, including punctuation handling, case conversion, and word order reversal. It is designed to challenge the ability to integrate multiple string operations into a single, cohesive function while ensuring efficiency and correctness. The example provided demonstrates the expected functionality and serves as a guide for evaluating the implementation.","solution":"import string def custom_string_manipulation(s: str) -> str: Transforms the input string by reversing the order of words, converting to uppercase, and removing punctuation. Parameters: s (str): The input string. Returns: str: The transformed string. # Remove punctuation s = s.translate(str.maketrans(\'\', \'\', string.punctuation)) # Convert to uppercase s = s.upper() # Reverse the order of words words = s.split() reversed_words = words[::-1] result = \' \'.join(reversed_words) return result"},{"question":"# Merge K Sorted Linked Lists You are required to merge multiple sorted linked lists into one sorted linked list. Specifically, you will be implementing a function to handle merging in an efficient manner, leveraging appropriate data structures to ensure optimal performance. The constraints and requirements listed below should guide your implementation. Implementation Details: 1. Create a `ListNode` class to represent each node in the linked list. 2. Implement a function `merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]` that takes a list of sorted linked lists and merges them into a single sorted linked list. 3. Use a min-heap (or priority queue) to streamline merging the lists efficiently. Constraints: - Each linked list is sorted in ascending order. - The total number of nodes across all linked lists is `n`, and `0 ≤ n ≤ 5000`. - The value of each node is within the range of [-10^4, 10^4]. - The input list `lists` contains at most `k` linked lists, where `1 ≤ k ≤ 100`. Example Usage: ```python >>> list1 = ListNode(1, ListNode(4, ListNode(5))) >>> list2 = ListNode(1, ListNode(3, ListNode(4))) >>> list3 = ListNode(2, ListNode(6)) >>> merged = merge_k_lists([list1, list2, list3]) >>> while merged: >>> print(merged.val, end=\\" -> \\") >>> merged = merged.next 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 -> ``` Submit your implementation with the following function and class signatures: ```python from typing import Optional, List import heapq class ListNode: def __init__(self, val: int = 0, next: \'Optional[ListNode]\' = None) -> None: self.val: int = val self.next: Optional[ListNode] = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize the heap for idx, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst.val, idx, lst)) dummy = ListNode() current = dummy # Process the heap and build the merged list while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next ```","solution":"from typing import Optional, List import heapq class ListNode: def __init__(self, val: int = 0, next: \'Optional[ListNode]\' = None) -> None: self.val: int = val self.next: Optional[ListNode] = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize the heap for idx, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst.val, idx, lst)) dummy = ListNode() current = dummy # Process the heap and build the merged list while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next"},{"question":"Finding the Longest Path in a Directed Acyclic Graph (DAG) Given a Directed Acyclic Graph (DAG) with `n` nodes and `m` edges described by a list of edges `edges` where each edge is represented as a tuple `(u, v)` indicating a directed edge from node `u` to node `v`, find the length of the longest path in the graph. Write a function `longest_path(n: int, edges: List[Tuple[int, int]]) -> int` that takes an integer `n` representing the number of nodes and a list of edges `edges` and returns the length of the longest path in the graph. # Input - An integer `n` (1 ≤ n ≤ 10^4) representing the number of nodes. - A list of edges `edges` (0 ≤ len(edges) ≤ 10^5) where each edge is a tuple `(u, v)` representing a directed edge from node `u` to node `v`. Nodes are zero-indexed. # Output - An integer representing the length of the longest path in the DAG. # Constraints - The graph is guaranteed to be acyclic. - Optimize the solution for efficiency given the constraints on `n` and the number of edges. # Example ```python >>> longest_path(4, [(0, 1), (1, 2), (1, 3), (2, 3)]) 3 >>> longest_path(5, [(0, 1), (1, 2), (2, 3), (3, 4), (1, 4)]) 4 ``` # Notes - Nodes are zero-indexed, meaning they range from `0` to `n-1`. - A topological sort of the nodes can be helpful in solving this problem. - Consider edge cases where the graph has no edges, or where multiple paths of the same maximum length exist.","solution":"def longest_path(n, edges): from collections import defaultdict, deque # Build the adjacency list for the graph adj_list = defaultdict(list) indegree = [0] * n for u, v in edges: adj_list[u].append(v) indegree[v] += 1 # Perform topological sort using Kahn\'s algorithm topological_order = [] queue = deque([node for node in range(n) if indegree[node] == 0]) while queue: node = queue.popleft() topological_order.append(node) for neighbor in adj_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Initialize distance (path length) array dist = [0] * n # Process nodes in topological order for node in topological_order: for neighbor in adj_list[node]: if dist[neighbor] < dist[node] + 1: dist[neighbor] = dist[node] + 1 # The length of the longest path return max(dist)"},{"question":"# Question: You are a software developer working on a data analysis tool that needs to organize large volumes of records in an efficient and reliable manner. To accomplish this, you need to implement a sorting algorithm that can handle a variety of edge cases and input configurations. Write a function `merge_sort(arr: list) -> list` that implements the merge sort algorithm, an efficient, stable, and reliable sorting method with a time complexity of O(n log n). Your function should sort a list of integers in ascending order. Ensure that your implementation can gracefully handle edge cases such as an empty list or a list with one element. # Input: - `arr` (list): A list of integers that needs to be sorted. The list can be empty or contain one or more integers. # Output: A single list of integers sorted in ascending order. # Constraints: - The input list can contain any number of integers (including none). - The integers in the list can be positive, negative, or zero. # Examples: 1. Given the input list `[34, -2, 45, 29, 8]`: ```python merge_sort([34, -2, 45, 29, 8]) ``` Should return `[-2, 8, 29, 34, 45]`. 2. Given the input list `[5, 1, 1, 2, 0, 0]`: ```python merge_sort([5, 1, 1, 2, 0, 0]) ``` Should return `[0, 0, 1, 1, 2, 5]`. 3. For an empty input list `[]`: ```python merge_sort([]) ``` Should return `[]`. 4. For a single element list `[42]`: ```python merge_sort([42]) ``` Should return `[42]`. # Additional Notes: - Ensure that your implementation uses the divide-and-conquer paradigm characteristic of the merge sort algorithm. - Include test cases to verify the correctness and efficiency of your implementation. - Remember that merge sort is particularly advantageous for large lists because of its predictable performance and suitability for parallel execution.","solution":"def merge_sort(arr): Sorts a list of integers in ascending order using the merge sort algorithm. Parameters: arr (list): A list of integers Returns: list: The sorted list if len(arr) <= 1: return arr def merge(left, right): result = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Problem Statement You are given a list of points in a 2D space and a positive integer `k`. Your task is to find the `k` closest points to the origin (0,0). The distance between two points in a 2D space can be measured using the Euclidean distance formula. Utilize Python and the `heapq` module to find the solution efficiently. # Function Signature ```python def k_closest_points(points: List[Tuple[float, float]], k: int) -> List[Tuple[float, float]]: Finds the `k` closest points to the origin (0,0) using the Euclidean distance. :param points: A list of tuples where each tuple contains two floats representing the x and y coordinates of a point. :param k: An integer representing the number of closest points to find. :return: A list of `k` tuples, each containing the x and y coordinates of the closest points to the origin. ``` # Input - points: List[Tuple[float, float]] * A list where each tuple consists of two values: - `x` : float: The x-coordinate of the point. - `y` : float: The y-coordinate of the point. - k: int * A positive integer representing the number of closest points to find. # Output - Returns a list of `k` tuples, each containing the coordinates of the closest points to the origin. # Examples ```python assert k_closest_points( points=[ (1, 2), (3, 4), (1, -1) ], k=2 ) == [ (1, 2), (1, -1) ] assert k_closest_points( points=[ (7, 9), (1.1, 1.2), (8, 8), (0.5, 0.5) ], k=3 ) == [ (0.5, 0.5), (1.1, 1.2), (8, 8) ] ``` # Constraints - The list `points` will contain between 1 and 10,000 points. - Each point will have coordinates in the range [-10^4, 10^4]. - The value of `k` will be between 1 and the length of the `points` list. - The coordinates of each point will be real numbers. # Notes - Use the Euclidean distance formula to compute the distance from the origin for each point: (text{distance} = sqrt{x^2 + y^2}). - Utilize Python\'s `heapq` module to efficiently find the `k` closest points. - Ensure the solution is optimized for performance, considering the potential large size of the input list.","solution":"from typing import List, Tuple import heapq import math def k_closest_points(points: List[Tuple[float, float]], k: int) -> List[Tuple[float, float]]: def euclidean_distance(point): return math.sqrt(point[0]**2 + point[1]**2) # Create a max-heap to keep track of the k closest points max_heap = [] for point in points: dist = euclidean_distance(point) if len(max_heap) < k: heapq.heappush(max_heap, (-dist, point)) else: heapq.heappushpop(max_heap, (-dist, point)) return [point for _, point in max_heap]"},{"question":"# Question: Implement a Recipe API Query Function In this exercise, you are to implement a Python function that queries a recipe API and returns a list of recipes that match a given ingredient and dietary restriction. Function Signature ```python def get_recipes(ingredient: str, dietary_restriction: str) -> list: ``` Input * A string `ingredient` representing the main ingredient to search for in recipes. * A string `dietary_restriction` representing a dietary restriction. Valid values are: * \\"none\\" * \\"vegetarian\\" * \\"vegan\\" * \\"gluten-free\\" * \\"dairy-free\\" * \\"nut-free\\" Output * A list of strings, where each string is a recipe name that matches the search criteria. Constraints * You must use the provided URL template to fetch the recipes: ``` url = \\"https://api.sample-recipes.com/recipes?ingredient={ingredient}&dietary_restriction={dietary_restriction}\\" ``` * You must handle network errors and invalid inputs gracefully. Requirements * The function must use the `requests` library to make an HTTP GET request. * It should parse the JSON response to extract the list of recipes. * You must handle cases where the JSON structure differs or the API is not reachable. * Validate the inputs and provide meaningful error messages for invalid inputs. # Example Usage ```python print(get_recipes(\\"chicken\\", \\"low-carb\\")) ``` # Example Output ```python [\\"Chicken Salad\\", \\"Grilled Chicken Breast\\", \\"Chicken Stir Fry\\"] ```","solution":"import requests def get_recipes(ingredient: str, dietary_restriction: str) -> list: Queries a recipe API to get recipes that match a given ingredient and dietary restriction. Parameters: - ingredient (str): The main ingredient to search for in recipes. - dietary_restriction (str): The dietary restriction to filter recipes. Valid values are \\"none\\", \\"vegetarian\\", \\"vegan\\", \\"gluten-free\\", \\"dairy-free\\", \\"nut-free\\". Returns: - list: A list of recipe names that match the search criteria. valid_restrictions = [\\"none\\", \\"vegetarian\\", \\"vegan\\", \\"gluten-free\\", \\"dairy-free\\", \\"nut-free\\"] if dietary_restriction not in valid_restrictions: raise ValueError(f\\"Invalid dietary restriction: {dietary_restriction}. Valid values are {valid_restrictions}\\") url = f\\"https://api.sample-recipes.com/recipes?ingredient={ingredient}&dietary_restriction={dietary_restriction}\\" try: response = requests.get(url) response.raise_for_status() data = response.json() if \'recipes\' in data: return data[\'recipes\'] else: return [] except requests.exceptions.RequestException as e: print(f\\"An error occurred: {e}\\") return []"},{"question":"# KMP Pattern Matching Algorithm Challenge You\'ve been tasked to implement the Knuth-Morris-Pratt (KMP) pattern matching algorithm to search for a given pattern in a provided text. Objective Implement a function that searches for all occurrences of a given pattern in a provided text using the KMP algorithm, and returns the starting indices of each match. Function Signature ```python def kmp_search(text: str, pattern: str) -> List[int]: Args: text (str): The text in which to search for the pattern. pattern (str): The pattern to search for in the text. Returns: List[int]: A list of starting indices where the pattern is found in the text. ``` Input Constraints - 1 <= len(text), len(pattern) <= 10^5 - The text and pattern consist of lowercase English letters only. Example ```python text = \\"ababcabcabababd\\" pattern = \\"ababd\\" print(kmp_search(text, pattern)) # Output: [10] ``` Explanation For the given text and pattern, the KMP algorithm finds one occurrence of the pattern \\"ababd\\" starting at index 10 in the text. Your goal is to efficiently implement the KMP pattern matching algorithm and ensure it works within the constraints provided.","solution":"from typing import List def kmp_search(text: str, pattern: str) -> List[int]: Knuth-Morris-Pratt (KMP) pattern matching algorithm to search for a pattern in a provided text. Args: text (str): The text in which to search for the pattern. pattern (str): The pattern to search for in the text. Returns: List[int]: A list of starting indices where the pattern is found in the text. def compute_lps_array(pattern: str) -> List[int]: Computes the Longest Prefix Suffix (LPS) array for given pattern. Args: pattern (str): The pattern for which to compute the LPS array. Returns: List[int]: LPS array. length = len(pattern) lps = [0] * length j = 0 # length of the previous longest prefix suffix i = 1 while i < length: if pattern[i] == pattern[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j-1] else: lps[i] = 0 i += 1 return lps n = len(text) m = len(pattern) if m == 0: return [] lps = compute_lps_array(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Question Description Context A common task in software development is validating input strings against specific formatting rules. One such rule could involve checking whether a string represents a valid hex color code. Task You are required to design a function to check if an input string is a valid hex color code. A valid hex color code starts with a hash (`#`) followed by exactly 6 characters which must be either digits (0-9) or letters from A-F (case-insensitive). Detailed Instructions * **Function Signature**: ```python def is_valid_hex_color(s: str) -> bool: Validate if the given string is a valid hex color code. :param s: Input string to validate. :return: True if the input string is a valid hex color code, False otherwise. ``` * **Expected Input and Output Formats**: * The function accepts a single string `s`. * The function returns a boolean representing whether the string is a valid hex color code. * **Constraints**: * Ensure the input is a string. * Hex color codes must start with a hash (`#`) symbol. * Hex color codes must be exactly 7 characters long including the hash (`#`). * Only the digits `0-9` and letters `A-F` (case-insensitive) are valid in the code. * **Performance Requirements**: The function should run in linear time, i.e., O(n), where n is the length of the string. Examples: ```python >>> is_valid_hex_color(\\"#1A2b3C\\") True >>> is_valid_hex_color(\\"123456\\") False >>> is_valid_hex_color(\\"#1234G6\\") False >>> is_valid_hex_color(\\"#abcdef\\") True >>> is_valid_hex_color(\\"#ABCDEF\\") True >>> is_valid_hex_color(\\"#123\\") False >>> is_valid_hex_color(\\"#1234567\\") False >>> is_valid_hex_color(\\"\\") False ``` Edge Cases: 1. If the input string is empty, the function should return False. 2. If the input string does not start with a hash (`#`), the function should return False. 3. If the input string contains characters other than 0-9 or A-F after the hash (`#`), the function should return False. 4. The function should handle both lower-case and upper-case letters correctly.","solution":"import re def is_valid_hex_color(s: str) -> bool: Validate if the given string is a valid hex color code. :param s: Input string to validate. :return: True if the input string is a valid hex color code, False otherwise. # Regex to match a valid hex color code pattern = r\'^#[0-9A-Fa-f]{6}\' return bool(re.match(pattern, s))"},{"question":"# Scenario: You are tasked with developing a tool for generating user reports for your company\'s new customer relationship management (CRM) software. One of the features requested is a function that compiles a report of user activity within a specified date range. # Function Specification: You are to implement a function called `generate_user_activity_report` that adheres to the following: Input: - `user_activities` (list of tuples): a list of tuples where each tuple contains a user\'s ID (integer), and the date of activity (string in the format \'YYYY-MM-DD\'). - `start_date` (string): the start date of the range, in the format \'YYYY-MM-DD\'. - `end_date` (string): the end date of the range, in the format \'YYYY-MM-DD\'. Output: - Returns a dictionary where the keys are user IDs and the values are the number of activities each user had within the specified date range. # Constraints: - The `end_date` must not be before the `start_date`. If it is, raise a `ValueError` with the message \\"End date must not be before start date\\". - Each date string is guaranteed to be a valid date in the format \'YYYY-MM-DD\'. - If no user activities fall within the date range, the function should return an empty dictionary. # Examples: ```python >>> generate_user_activity_report([(1, \'2023-01-15\'), (2, \'2023-02-20\'), (1, \'2023-02-25\'), (3, \'2023-03-10\')], \'2023-02-01\', \'2023-02-28\') {1: 1, 2: 1} >>> generate_user_activity_report([(1, \'2023-01-15\'), (2, \'2023-02-20\'), (1, \'2023-02-25\'), (3, \'2023-03-10\')], \'2023-01-01\', \'2023-03-31\') {1: 2, 2: 1, 3: 1} >>> generate_user_activity_report([(1, \'2023-01-15\'), (2, \'2023-02-20\'), (1, \'2023-02-25\'), (3, \'2023-03-10\')], \'2023-03-01\', \'2023-03-31\') {3: 1} >>> generate_user_activity_report([(1, \'2023-01-15\'), (2, \'2023-02-20\'), (1, \'2023-02-25\'), (3, \'2023-03-10\')], \'2023-04-01\', \'2023-04-30\') {} >>> generate_user_activity_report([(1, \'2023-01-15\'), (2, \'2023-02-20\'), (1, \'2023-02-25\'), (3, \'2023-03-10\')], \'2023-03-20\', \'2023-03-10\') Traceback (most recent call last): ... ValueError: End date must not be before start date ``` # Implementation Details: Make use of Python\'s datetime module to efficiently handle date comparisons and range inclusions. Ensure the function is robust and handles the constraints and edge cases as specified.","solution":"from datetime import datetime def generate_user_activity_report(user_activities, start_date, end_date): Generates a report of user activities within a specified date range. Parameters: - user_activities (list of tuples): A list of tuples where each tuple contains a user\'s ID (integer), and the date of activity (string in the format \'YYYY-MM-DD\'). - start_date (string): The start date of the range, in the format \'YYYY-MM-DD\'. - end_date (string): The end date of the range, in the format \'YYYY-MM-DD\'. Returns: - dict: A dictionary where the keys are user IDs and the values are the number of activities each user had within the specified date range. Raises: - ValueError: If the end_date is before the start_date. start_datetime = datetime.strptime(start_date, \'%Y-%m-%d\') end_datetime = datetime.strptime(end_date, \'%Y-%m-%d\') if end_datetime < start_datetime: raise ValueError(\\"End date must not be before start date\\") activity_report = {} for user_id, activity_date in user_activities: activity_datetime = datetime.strptime(activity_date, \'%Y-%m-%d\') if start_datetime <= activity_datetime <= end_datetime: if user_id not in activity_report: activity_report[user_id] = 0 activity_report[user_id] += 1 return activity_report"},{"question":"# Problem Statement You are required to implement a `CustomDeque` class from scratch in Python. A `CustomDeque` (Double-ended Queue) is a data structure that allows insertion and deletion of elements from both ends efficiently. The operations should maintain the properties of the deque: 1. **Add to the front** of the deque. 2. **Add to the back** of the deque. 3. **Remove from the front** of the deque. 4. **Remove from the back** of the deque. 5. **Peek from the front** to see the element at the front without removing it. 6. **Peek from the back** to see the element at the back without removing it. 7. **Get size** of the deque to know the number of elements. 8. **Check if empty** to know whether the deque is empty. # Input and Output - **add_front(value)**: Adds a value to the front of the deque. - **Input**: Single value. - **Output**: None - **add_back(value)**: Adds a value to the back of the deque. - **Input**: Single value. - **Output**: None - **remove_front()**: Removes and returns the value from the front of the deque. - **Output**: The value at the front. - **Exceptions**: Raise `IndexError` if the deque is empty. - **remove_back()**: Removes and returns the value from the back of the deque. - **Output**: The value at the back. - **Exceptions**: Raise `IndexError` if the deque is empty. - **peek_front()**: Returns the value at the front without removing it. - **Output**: The value at the front. - **Exceptions**: Raise `IndexError` if the deque is empty. - **peek_back()**: Returns the value at the back without removing it. - **Output**: The value at the back. - **Exceptions**: Raise `IndexError` if the deque is empty. - **size()**: Returns the number of elements in the deque. - **Output**: Integer - **is_empty()**: Returns whether the deque is empty. - **Output**: Boolean # Constraints - `<value>` in operations can be of any type. - All operations must adhere to O(1) complexity where N is the number of elements in the deque. - You must handle cases where operations are performed on an empty deque gracefully. # Example Usage ```python dq = CustomDeque() dq.add_front(1) dq.add_back(2) dq.add_front(3) print(dq.peek_front()) # Output: 3 print(dq.peek_back()) # Output: 2 print(dq.remove_front()) # Output: 3 print(dq.remove_back()) # Output: 2 print(dq.size()) # Output: 1 print(dq.is_empty()) # Output: False dq.remove_front() print(dq.is_empty()) # Output: True print(dq.remove_front()) # Raises IndexError ``` You must implement the entire CustomDeque class with the specified methods and properties.","solution":"class CustomDeque: def __init__(self): # Using Python list to store elements self.deque = [] def add_front(self, value): # Insert value at the front of the deque self.deque.insert(0, value) def add_back(self, value): # Append value to the back of the deque self.deque.append(value) def remove_front(self): # Remove and return the value from the front of the deque if self.is_empty(): raise IndexError(\\"remove_front from empty deque\\") return self.deque.pop(0) def remove_back(self): # Remove and return the value from the back of the deque if self.is_empty(): raise IndexError(\\"remove_back from empty deque\\") return self.deque.pop() def peek_front(self): # Return the value at the front without removing it if self.is_empty(): raise IndexError(\\"peek_front from empty deque\\") return self.deque[0] def peek_back(self): # Return the value at the back without removing it if self.is_empty(): raise IndexError(\\"peek_back from empty deque\\") return self.deque[-1] def size(self): # Return the number of elements in the deque return len(self.deque) def is_empty(self): # Return whether the deque is empty return len(self.deque) == 0"},{"question":"Problem Statement You need to develop a function that determines whether a given string of characters can be reorganized such that no two adjacent characters are the same. If possible, return one such reorganized version of the string. Otherwise, return an empty string. # Function Specification Implement the function `reorganize_string(s: str) -> str` where: - `s` is a string consisting of lowercase English letters. Your function should: 1. Determine if it\'s possible to rearrange the characters so that no two adjacent characters are the same. 2. Return any one valid rearrangement of the string if possible, or return an empty string if no such rearrangement exists. # Input - A string `s` containing only lowercase English letters with length at most 10^4. # Output - A rearranged version of the string where no two adjacent characters are the same or an empty string if it\'s not possible. # Constraints - The string length can be up to 10,000 characters. # Example Usage ```python print(reorganize_string(\\"aab\\")) # Possible output: \\"aba\\" print(reorganize_string(\\"aaab\\")) # Possible output: \\"\\" ``` # Performance Requirements - The function should efficiently handle strings up to the maximum length constraint. - Aim for an optimal algorithm with respect to time and space complexity. # Hint You may want to use a max-heap (priority queue) to efficiently retrieve and rearrange the characters based on their frequency of occurrence.","solution":"from collections import Counter import heapq def reorganize_string(s: str) -> str: if not s: return \\"\\" counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged_string = \'\'.join(result) if len(rearranged_string) != len(s): return \\"\\" return rearranged_string"},{"question":"# Problem Statement You are tasked with developing a system to manage server loads in a datacenter. Each server has a maximum capacity, and you need to distribute incoming tasks to the servers in such a way that no server exceeds its capacity. Each task has a specific load, and your goal is to minimize the number of servers used to handle all the tasks. # Function to Implement Implement the function `minimize_servers(tasks: List[int], capacity: int) -> int`. This function should return the minimum number of servers required to handle all the tasks without exceeding the capacity of any server. # Input * `tasks` (List[int]): A list of positive integers representing the load of each task. * `capacity` (int): A positive integer representing the maximum capacity of each server. # Output * (int): The minimum number of servers needed. # Constraints 1. The length of `tasks` will be at most (10^5). 2. The load of each task and the capacity will be positive integers less than or equal to (10^4). # Examples ```python assert minimize_servers([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == 5 assert minimize_servers([9, 9, 9, 9, 9], 10) == 5 assert minimize_servers([1, 2, 3, 4, 5], 15) == 1 ``` # Additional Notes * You may use greedy algorithms or other heuristic methods to achieve the optimal solution efficiently. * Consider edge cases where the load of some tasks might be exactly equal to the server capacity. * The order of assigning tasks to servers may affect the number of servers used; thus, consider different strategies for task assignment to minimize the number of servers. # Scenario Imagine you are part of a team managing a cloud computing service, and you need to assign incoming computational tasks to a fixed number of physical servers based on their capacities. You must ensure that all tasks are handled efficiently, utilizing the least number of servers while avoiding overloading any single server.","solution":"def minimize_servers(tasks, capacity): Returns the minimum number of servers required to handle all the tasks without exceeding the capacity of any server. :param tasks: List[int] - A list of positive integers representing the load of each task. :param capacity: int - A positive integer representing the maximum capacity of each server. :return: int - The minimum number of servers needed. tasks.sort(reverse=True) # Sort tasks in descending order servers = [] for task in tasks: placed = False for i, server in enumerate(servers): if server + task <= capacity: servers[i] += task placed = True break if not placed: servers.append(task) return len(servers)"},{"question":"# Coding Question: Advanced Dictionary Operations A data analytics company needs to manage large dictionaries of user data for pattern recognition and analysis. They often require checking the existence of keys and retrieving counts of certain entries efficiently. To help them streamline their operations, they need a function that performs an optimized check for key existence and counts how many times specific values appear across the entire dictionary. Task: Write a function that takes a dictionary and a target value, and returns the number of entries with the target value. Additionally, the function should return a boolean indicating if the target value exists in the dictionary. Requirements: 1. **Input**: - A dictionary `data_dict` where keys are strings and values are integers. - An integer `target_value`. 2. **Output**: - A boolean indicating if the target value is found in the dictionary. - The count of how many times the target value appears in the dictionary. Constraints: - The number of dictionary entries (n) is between 0 and 10^6. - Dictionary keys are strings with lengths of up to 100 characters. - Dictionary values are integers within the range of -10^9 to 10^9. - Handle scenarios where `data_dict` might be an empty dictionary. Example: ```python >>> dictionary_value_check({\'a\': 1, \'b\': 2, \'c\': 2, \'d\': 3}, 2) (True, 2) >>> dictionary_value_check({\'a\': 1, \'b\': 3, \'c\': 4}, 5) (False, 0) >>> dictionary_value_check({}, 1) (False, 0) ``` # Your task: 1. Implement the function `dictionary_value_check` with the required functionality. 2. Ensure that your function is efficient in both time and space complexity. 3. Handle edge cases and invalid input gracefully. **Function signature**: ```python def dictionary_value_check(data_dict: dict, target_value: int) -> tuple: pass ``` Note: - You should not use any in-built functions for direct value count. - Provide a brief explanation of your approach and how you handle edge cases and exceptions.","solution":"def dictionary_value_check(data_dict: dict, target_value: int) -> tuple: Returns a tuple indicating whether the target value is found in the dictionary and the count of how many times the target value appears in the dictionary. value_found = False value_count = 0 for value in data_dict.values(): if value == target_value: value_found = True value_count += 1 return value_found, value_count"},{"question":"# Coding Question: Advanced Matrix Spiral Traversal Imagine you are developing a visualization tool for a data analytics platform. Your task is to implement a feature that performs a spiral traversal on a 2D matrix of integers and returns the resulting sequence of the traversal. # Requirements: 1. Implement the `spiral_order(matrix: list[list[int]]) -> list[int]` function. 2. The function should perform a spiral traversal starting from the top-left corner and return the sequence of traversed elements. 3. The traversal should proceed as follows: rightwards across the top row, down the last column, left across the bottom row, and up the first column, repeating as necessary. 4. The matrix is guaranteed to have at least one row and one column and contains only integers. 5. Aim for a solution that is efficient in both time and space complexity. # Input: * `matrix`: A 2D list of integers representing the matrix. # Output: * A list of integers representing the sequence of elements traversed in spiral order. # Constraints: * The matrix is non-empty and contains only integer values. * Rows and columns of the matrix may not necessarily be of equal length. # Performance Requirements: * Your solution should be efficient, ideally with a time complexity of O(N) where N is the total number of elements in the matrix. # Function Signature: ```python def spiral_order(matrix: list[list[int]]) -> list[int]: pass ``` # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert spiral_order(matrix) == [1, 2, 3, 6, 9, 8, 7, 4, 5] # Expected spiral order matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] assert spiral_order(matrix) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] # Expected spiral order matrix = [ [1] ] assert spiral_order(matrix) == [1] # Single element ``` # Additional Notes: * Thoroughly test your function with diverse cases, including large matrices and those with varying row lengths. * Efficient handling of corner cases and typical matrix structures will be crucial for grading.","solution":"def spiral_order(matrix): result = [] while matrix: # remove the first row result += matrix.pop(0) # remove the last element of every remaining row if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # remove the last row in reverse order if matrix: result += matrix.pop()[::-1] # remove the first element of every remaining row in reverse order if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"# Scenario Your company has a web application that provides weather forecasts for different cities around the world. Users can query the forecast for a specific city and specific future dates. To enhance the user experience, the development team has decided to implement an additional feature that lists all cities with possible rain conditions on given dates. # Problem Statement You are tasked with developing a function that identifies the cities where rain is predicted on given dates. You have access to weather data that includes predictions for multiple cities over a set period. # Requirements Implement the `rain_forecast` function that takes two parameters: 1. `weather_data` (list): A list of dictionaries where each dictionary contains the city name, date, and weather condition. 2. `query_dates` (list): A list of strings representing the dates for which to check the weather predictions. Your function should return a list of city names where rain is predicted on any of the specified dates. If no rain is predicted on the given dates, return an empty list. Cities should only appear once in the output list even if rain is predicted on multiple query dates. # Input - `weather_data`: A list of dictionaries where each dictionary has: - `city` (str): The name of the city. - `date` (str): The date in \\"YYYY-MM-DD\\" format. - `weather` (str): The weather condition (e.g., \\"sunny\\", \\"rain\\", \\"cloudy\\"). - `query_dates`: A list of strings representing the dates to check (e.g., [\\"2023-03-10\\", \\"2023-03-11\\"]). # Output - Returns a list of city names (strings) in which rain is predicted on any of the query dates. # Constraints - The `weather_data` will contain at least one entry. - The `query_dates` will contain at least one date. - All dates in `weather_data` and `query_dates` will follow the specified format. # Example ```python def rain_forecast(weather_data: list, query_dates: list) -> list: Identifies cities where rain is predicted on given dates. Parameters: weather_data (list): List of dictionaries with city, date, and weather condition. query_dates (list): List of dates to query the weather data for. Returns: list: List of city names where rain is predicted on any of the query dates. rainy_cities = set() for entry in weather_data: if entry[\'date\'] in query_dates and entry[\'weather\'] == \'rain\': rainy_cities.add(entry[\'city\']) return list(rainy_cities) # Example usage: weather_data = [ {\\"city\\": \\"New York\\", \\"date\\": \\"2023-03-10\\", \\"weather\\": \\"rain\\"}, {\\"city\\": \\"Los Angeles\\", \\"date\\": \\"2023-03-10\\", \\"weather\\": \\"sunny\\"}, {\\"city\\": \\"Chicago\\", \\"date\\": \\"2023-03-11\\", \\"weather\\": \\"rain\\"}, {\\"city\\": \\"Houston\\", \\"date\\": \\"2023-03-10\\", \\"weather\\": \\"cloudy\\"}, {\\"city\\": \\"Phoenix\\", \\"date\\": \\"2023-03-12\\", \\"weather\\": \\"rain\\"} ] query_dates = [\\"2023-03-10\\", \\"2023-03-11\\"] print(rain_forecast(weather_data, query_dates)) # Should output: [\'New York\', \'Chicago\'] ```","solution":"def rain_forecast(weather_data: list, query_dates: list) -> list: Identifies cities where rain is predicted on given dates. Parameters: weather_data (list): List of dictionaries with city, date, and weather condition. query_dates (list): List of dates to query the weather data for. Returns: list: List of city names where rain is predicted on any of the query dates. rainy_cities = set() for entry in weather_data: if entry[\'date\'] in query_dates and entry[\'weather\'] == \'rain\': rainy_cities.add(entry[\'city\']) return list(rainy_cities)"},{"question":"**Scenario**: You are working on a data compression software designed to reduce the storage space required for large sequences of integers. As part of this, you need to implement a function that identifies and removes all consecutive duplicate elements from any given list of integers. **Task**: Develop the core functionality to compress the sequence by eliminating consecutive duplicates. # Compress Sequence Function 1. **Function Name**: `compress_sequence` 2. **Input**: - `sequence`: A list of integers. 3. **Output**: A new list of integers with consecutive duplicates removed. # Detailed Requirements: 1. **Input validation**: - The input should be a list of integers. - If the input list is empty, return an empty list. 2. **Output**: - Return the compressed list of integers. # Constraints & Performance: - The function should handle lists containing up to 100,000 elements efficiently. - Maintain the order of the remaining elements after removal of consecutive duplicates. # Example Function Signature: ```python def compress_sequence(sequence: list[int]) -> list[int]: pass ``` # Example Usage: ```python input_sequence = [1, 1, 2, 2, 2, 3, 4, 4, 5, 5, 5, 5, 6] result = compress_sequence(input_sequence) print(result) # Expected output: [1, 2, 3, 4, 5, 6] ``` # Additional Notes: - This is distinct from simply removing all duplicates; only consecutive duplicates should be removed. - Your function should traverse the input list only once to achieve the desired output efficiently.","solution":"def compress_sequence(sequence): Compresses a list of integers by removing consecutive duplicates. Args: sequence (list): A list of integers. Returns: list: A new list with consecutive duplicates removed. if not sequence: return [] compressed = [sequence[0]] for num in sequence[1:]: if num != compressed[-1]: compressed.append(num) return compressed"},{"question":"# Question: Implement a Custom Exponential Moving Average Function You are implementing a custom version of the Exponential Moving Average (EMA) function, commonly used in time series analysis for smoothing data points by applying more weight to recent values. Description: The Exponential Moving Average (EMA) is calculated by applying a weighting factor to the current data point and the previous EMA value. The weighting factor (alpha) determines how much importance is given to recent values compared to older values. Function Signature: ```python import numpy as np def exponential_moving_average(data: np.ndarray, alpha: float) -> np.ndarray: Computes the Exponential Moving Average (EMA) of a given data array. Parameters: data (ndarray): A 1-dimensional array of numeric values. alpha (float): The smoothing factor, a value between 0 (exclusive) and 1 (inclusive). Returns: ema (ndarray): A 1-dimensional array of the same length as the input, containing the EMA of the input data. ``` Input: * `data`: A 1-dimensional numpy array containing numeric values. * `alpha`: A float value in the range (0, 1] that serves as the smoothing factor. Output: * A 1-dimensional numpy array of the same length as the input data containing the calculated EMA values. Constraints: * The input data array will contain only numeric values. * The function should properly handle arrays of any length, including arrays with a single element. * Utilize efficient looping or vectorized operations to ensure performance for large datasets. Example: ```python >>> import numpy as np >>> data = np.array([1, 2, 3, 4, 5]) >>> alpha = 0.5 >>> exponential_moving_average(data, alpha) array([1. , 1.5, 2.25, 3.125, 4.0625]) ``` Implement the `exponential_moving_average` function according to the above specifications.","solution":"import numpy as np def exponential_moving_average(data: np.ndarray, alpha: float) -> np.ndarray: Computes the Exponential Moving Average (EMA) of a given data array. Parameters: data (ndarray): A 1-dimensional array of numeric values. alpha (float): The smoothing factor, a value between 0 (exclusive) and 1 (inclusive). Returns: ema (ndarray): A 1-dimensional array of the same length as the input, containing the EMA of the input data. if not (0 < alpha <= 1): raise ValueError(\\"Alpha must be between 0 (exclusive) and 1 (inclusive).\\") ema = np.zeros(len(data)) ema[0] = data[0] # Set the first EMA value to the first data point for i in range(1, len(data)): ema[i] = alpha * data[i] + (1 - alpha) * ema[i - 1] return ema"},{"question":"# Problem Statement You are developing software for a banking system that needs to efficiently manage and analyze transaction data. One important task is to determine the balance of each customer\'s account after processing a series of transactions. # Problem Description Write a function `process_transactions` that processes a list of transactions and returns the final balance for each account involved. # Function Signature ```python def process_transactions(transactions: list[dict[str, str or float]]) -> dict[str, float]: ``` # Input - `transactions`: A list of dictionaries where each dictionary represents a transaction. Each dictionary contains the following keys: - `account`: A string representing the account identifier. - `type`: A string which can be either `\\"deposit\\"` or `\\"withdrawal\\"`. - `amount`: A float representing the transaction amount. # Output - A dictionary where the keys are account identifiers (strings) and the values are floats representing the final balance of each account. # Constraints - `1 ≤ len(transactions) ≤ 1000` - The `amount` in each transaction will be a positive number. - Each `account` identifier will be a non-empty string. - The type of transaction will always be either `\\"deposit\\"` or `\\"withdrawal\\"`. # Examples 1. ```python process_transactions([ {\\"account\\": \\"A1\\", \\"type\\": \\"deposit\\", \\"amount\\": 100.0}, {\\"account\\": \\"A1\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 50.0}, {\\"account\\": \\"A2\\", \\"type\\": \\"deposit\\", \\"amount\\": 200.0} ]) ``` should return `{\'A1\': 50.0, \'A2\': 200.0}`. 2. ```python process_transactions([ {\\"account\\": \\"B1\\", \\"type\\": \\"deposit\\", \\"amount\\": 300.0}, {\\"account\\": \\"B2\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 100.0}, {\\"account\\": \\"B1\\", \\"type\\": \\"deposit\\", \\"amount\\": 200.0}, {\\"account\\": \\"B2\\", \\"type\\": \\"deposit\\", \\"amount\\": 150.0} ]) ``` should return `{\'B1\': 500.0, \'B2\': 50.0}`. 3. ```python process_transactions([ {\\"account\\": \\"C1\\", \\"type\\": \\"deposit\\", \\"amount\\": 1000.0}, {\\"account\\": \\"C2\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 450.0}, {\\"account\\": \\"C1\\", \\"type\\": \\"deposit\\", \\"amount\\": 150.0}, {\\"account\\": \\"C2\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 550.0} ]) ``` should return `{\'C1\': 1150.0, \'C2\': -100.0}`. # Notes - Ensure that the function handles multiple transactions for the same account correctly. - The final balance for an account can be negative if the withdrawals exceed deposits. - The solution should efficiently process the transactions using appropriate data structures. # Hints 1. Use a dictionary to keep track of the balance of each account. 2. Iterate through each transaction and update the balance of the corresponding account based on the transaction type. 3. Ensure to initialize account balances to zero before starting the transactions calculation if they are encountered for the first time.","solution":"def process_transactions(transactions): Processes a list of transactions and returns the final balance for each account involved. Parameters: transactions (list of dict): A list of transactions. Each transaction is represented as a dictionary with keys: - \'account\': A string representing the account identifier. - \'type\': A string which can be either \'deposit\' or \'withdrawal\'. - \'amount\': A float representing the transaction amount. Returns: dict: A dictionary where the keys are account identifiers (strings) and the values are floats representing the final balance of each account. account_balances = {} for transaction in transactions: account = transaction[\'account\'] trans_type = transaction[\'type\'] amount = transaction[\'amount\'] # Initialize the account balance to 0 if it\'s the first occurrence of the account if account not in account_balances: account_balances[account] = 0.0 # Update the account balance based on the type of transaction if trans_type == \'deposit\': account_balances[account] += amount elif trans_type == \'withdrawal\': account_balances[account] -= amount return account_balances"},{"question":"Coding Assessment Question You are required to develop a function to assist with data processing in a financial analysis system. The function will identify and return the total value of transactions that exceed a specified threshold within a given list of detailed transaction records. # Function Signature ```python def calculate_high_value_transactions(transactions: List[Dict[str, Any]], threshold: float) -> float: ``` # Objective Develop the `calculate_high_value_transactions` function that: 1. Takes a list of transaction records and a threshold value as parameters. 2. Returns the sum of the values for transactions that exceed the specified threshold. # Input/Output Format * **Input**: * `transactions` (List[Dict[str, Any]]): A list of transaction records where each record is a dictionary with at least a \'value\' key indicating the transaction amount. * `threshold` (float): The value above which transactions should be summed up. * **Output**: * (float): The total sum of transaction values that exceed the specified threshold. # Constraints * Each transaction record is guaranteed to contain a \'value\' key with a numeric value. * The transaction list is potentially large (up to 10^5 records), so optimize for performance. * Floating point precision should be handled appropriately. # Context This function will be part of a larger financial analysis toolkit used to identify high-value transactions. By summing up such transactions, analysts can quickly gauge the financial impact of significant activities. # Performance Requirements * Ensure the function handles large datasets efficiently. * Optimize for minimal computational overhead. # Implementation Notes * Utilize appropriate Python data structures and loops for efficient calculation. * Consider edge cases such as an empty transaction list or no transactions exceeding the threshold. Design and implement the `calculate_high_value_transactions` function based on the above requirements. # Example ```python transactions = [ {\'id\': 1, \'value\': 150.0, \'currency\': \'USD\'}, {\'id\': 2, \'value\': 50.5, \'currency\': \'USD\'}, {\'id\': 3, \'value\': 200.3, \'currency\': \'USD\'} ] threshold = 100.0 # The function should return 350.3 as only transactions with values 150.0 and 200.3 exceed the threshold. result = calculate_high_value_transactions(transactions, threshold) print(result) # Output: 350.3 ```","solution":"from typing import List, Dict, Any def calculate_high_value_transactions(transactions: List[Dict[str, Any]], threshold: float) -> float: Sums up the values of transactions that exceed the specified threshold. Args: transactions (List[Dict[str, Any]]): A list of transaction records. threshold (float): The threshold value. Returns: float: The total sum of transaction values that exceed the threshold. total = 0.0 for transaction in transactions: if transaction[\'value\'] > threshold: total += transaction[\'value\'] return total"},{"question":"**Managing Inventory in an E-commerce Platform** As a software engineer at an e-commerce company, you have been tasked with developing a function to manage the inventory of products. The objective is to process a series of transactions, updating the inventory levels accordingly. Each transaction can be adding new stock or selling items from the inventory. **Objective**: Write a function to process a list of transactions and update the inventory. The function should handle edge cases such as attempting to sell more items than are in stock and ensure that the inventory does not go into negative values. **Tasks**: 1. **Function Signature**: ```python def process_transactions(transactions: List[Dict[str, Any]]) -> Dict[str, int]: Processes a list of transactions and updates the inventory. Args: transactions (List[Dict[str, Any]]): A list of transactions where each transaction is represented as a dictionary with \'product_id\' (str), \'type\' (str), and \'quantity\' (int). Returns: Dict[str, int]: The updated inventory where keys are product IDs and the values are quantities. ``` 2. **Transaction Types**: - `add`: Adds new stock to the inventory. - `sell`: Reduces the stock in the inventory but must handle cases where the stock is insufficient by not allowing negative inventory. 3. **Edge Cases**: - Selling more than available stock should not reduce stock below zero. - Adding stock should increase the inventory correctly. - Ensure the transactions list may contain transactions for various product IDs. 4. **Constraints**: - `transactions`: List of dictionaries representing transactions (1 ≤ len(transactions) ≤ 10^4). - Each transaction dictionary must contain: - `product_id`: A unique identifier for the product (string, 1 ≤ len(product_id) ≤ 20). - `type`: Type of transaction, either \'add\' or \'sell\' (string). - `quantity`: The number of products to add or sell (integer, 1 ≤ quantity ≤ 10^3). 5. **Assumptions**: - Initially, all product quantities are zero. - The input list `transactions` is always valid and does not contain any invalid transaction types. **Example Input**: ```python [ {\\"product_id\\": \\"A123\\", \\"type\\": \\"add\\", \\"quantity\\": 10}, {\\"product_id\\": \\"B456\\", \\"type\\": \\"add\\", \\"quantity\\": 5}, {\\"product_id\\": \\"A123\\", \\"type\\": \\"sell\\", \\"quantity\\": 3}, {\\"product_id\\": \\"B456\\", \\"type\\": \\"sell\\", \\"quantity\\": 7}, {\\"product_id\\": \\"A123\\", \\"type\\": \\"add\\", \\"quantity\\": 7}, {\\"product_id\\": \\"B456\\", \\"type\\": \\"sell\\", \\"quantity\\": 2}, ] ``` **Example Output**: ```python { \\"A123\\": 14, \\"B456\\": 3, } ``` **Requirements**: - Implement the `process_transactions` function in a way that ensures the inventory levels accurately reflect the transactions while handling edge cases to prevent negative inventory. This question requires knowledge of dictionary operations, handling lists of dictionaries, and managing state updates, while ensuring data integrity and handling edge cases effectively.","solution":"from typing import List, Dict, Any def process_transactions(transactions: List[Dict[str, Any]]) -> Dict[str, int]: Processes a list of transactions and updates the inventory. Args: transactions (List[Dict[str, Any]]): A list of transactions where each transaction is represented as a dictionary with \'product_id\' (str), \'type\' (str), and \'quantity\' (int). Returns: Dict[str, int]: The updated inventory where keys are product IDs and the values are quantities. inventory = {} for transaction in transactions: product_id = transaction[\\"product_id\\"] type_ = transaction[\\"type\\"] quantity = transaction[\\"quantity\\"] if product_id not in inventory: inventory[product_id] = 0 if type_ == \\"add\\": inventory[product_id] += quantity elif type_ == \\"sell\\": inventory[product_id] = max(0, inventory[product_id] - quantity) return inventory"},{"question":"# Binary Search Tree with Range Sum Query Problem Statement: You are tasked with implementing a Binary Search Tree (BST) that supports insertion of elements, querying if an element exists, and computing the sum of elements within a specified range [low, high]. Requirements: 1. **Function Signature**: ```python class BSTNode: def __init__(self, key: int) -> None: def __repr__(self) -> str: class BST: def __init__(self) -> None: def insert(self, key: int) -> None: def contains(self, key: int) -> bool: def range_sum(self, low: int, high: int) -> int: def __repr__(self) -> str: ``` 2. **Input and Output Format**: - `BSTNode.__init__(self, key: int)`: Initializes a node with a given key. - `BST.__init__(self)`: Initializes an empty BST. - `BST.insert(self, key: int)`: Inserts a new key into the BST. - `BST.contains(self, key: int)`: Returns `True` if the key exists in the BST, otherwise returns `False`. - `BST.range_sum(self, low: int, high: int)`: Returns the sum of all keys in the BST that lie within the inclusive range [low, high]. - `BST.__repr__(self)`: Returns a string representation of the BST in sorted order. 3. **Constraints**: - The keys are integers. - Elements must be inserted and stored in accordance with the properties of a BST (left child < parent < right child). - The BST should handle duplicate keys by ignoring insertions of duplicate values. 4. **Performance Requirements**: - Average case operations for insertion, lookup, and range sum queries should be logarithmic time O(log n). - Ensure the `range_sum` method efficiently computes the sum by traversing the minimal necessary part of the tree. Example Usage: ```python # Initializing BST bst = BST() # Inserting elements bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) # Checking if elements exist print(bst.contains(10)) # Output: True print(bst.contains(6)) # Output: False # Range sum query print(bst.range_sum(5, 15)) # Output: 37 # String representation of BST in sorted order print(bst) # Output: BST(3 -> 5 -> 7 -> 10 -> 15) ``` Implement the `BST` and `BSTNode` classes to fulfill the above specifications.","solution":"class BSTNode: def __init__(self, key: int) -> None: self.key = key self.left = None self.right = None def __repr__(self) -> str: return f\'BSTNode({self.key})\' class BST: def __init__(self) -> None: self.root = None def insert(self, key: int) -> None: if not self.root: self.root = BSTNode(key) else: self._insert(self.root, key) def _insert(self, node: BSTNode, key: int) -> None: if key < node.key: if node.left is None: node.left = BSTNode(key) else: self._insert(node.left, key) elif key > node.key: if node.right is None: node.right = BSTNode(key) else: self._insert(node.right, key) # If the key is equal, do nothing (i.e., ignore duplicates) def contains(self, key: int) -> bool: return self._contains(self.root, key) def _contains(self, node: BSTNode, key: int) -> bool: if node is None: return False if key == node.key: return True elif key < node.key: return self._contains(node.left, key) else: return self._contains(node.right, key) def range_sum(self, low: int, high: int) -> int: return self._range_sum(self.root, low, high) def _range_sum(self, node: BSTNode, low: int, high: int) -> int: if not node: return 0 if node.key < low: return self._range_sum(node.right, low, high) elif node.key > high: return self._range_sum(node.left, low, high) else: return (node.key + self._range_sum(node.left, low, high) + self._range_sum(node.right, low, high)) def __repr__(self) -> str: return \\"BST(\\" + \\" -> \\".join(map(str, self._inorder(self.root))) + \\")\\" def _inorder(self, node: BSTNode): if not node: return [] return self._inorder(node.left) + [node.key] + self._inorder(node.right)"},{"question":"# Question Plant Growth Forecast Using Exponential Model Implement a function that uses an exponential growth model to forecast the size of a plant after a certain number of days. The function should calculate the size of the plant given its current size, the growth rate, and the number of days. Function Signature ```python def forecast_growth(current_size: float, growth_rate: float, days: int) -> float: pass ``` Input * `current_size`: A float representing the current size of the plant in centimeters. * `growth_rate`: A float representing the daily growth rate (as a percentage) of the plant. * `days`: An integer representing the number of days over which the growth is to be calculated. Output * Returns a float representing the forecasted size of the plant after the specified number of days. Constraints * 0 ≤ current_size ≤ 10^7 * 0 ≤ growth_rate ≤ 100 (representing 0% to 100% growth per day) * 0 ≤ days ≤ 365 Notes * The formula for exponential growth is given by `future_size = current_size * (1 + growth_rate / 100) ^ days`. * Ensure the output is rounded to two decimal places if necessary. Example ```python current_size = 10.0 growth_rate = 5.0 days = 10 print(forecast_growth(current_size, growth_rate, days)) ``` Expected Output: ``` 16.29 ``` Additional Requirements * The result should be calculated using an efficient and accurate method for computing powers. * Ensure the function handles edge cases where the growth rate is zero or the number of days is zero by returning the current size directly in such cases.","solution":"def forecast_growth(current_size: float, growth_rate: float, days: int) -> float: Calculate the forecasted size of the plant after a given number of days using an exponential growth model. # Handle edge cases where growth_rate or days is zero if growth_rate == 0 or days == 0: return round(current_size, 2) # Calculate the future size using the exponential growth formula future_size = current_size * (1 + growth_rate / 100) ** days # Return the result rounded to two decimal places return round(future_size, 2)"},{"question":"# Question You are developing a file management application that needs to organize files within a directory based on their types. Your task is to create a Python script to scan a specified directory and move files into subdirectories categorized by their file extensions. # Function Specification **Task**: * You need to implement a function `organize_files` that manages file organization based on their types. * Additionally, implement a helper function `create_subdirectories` that prepares the subdirectory structure needed for file organization. **Functions to Implement**: ```python def organize_files(directory_path: str) -> None: pass def create_subdirectories(base_path: str, extensions: list) -> None: pass ``` **Parameters**: * `organize_files`: * `directory_path` (str): The path to the directory containing the files to be organized. * `create_subdirectories`: * `base_path` (str): The path where subdirectories should be created. * `extensions` (list): A list of file extensions for which subdirectories should be created. **Returns**: * Nothing. The function `organize_files` should rearrange the files and the function `create_subdirectories` should just create the needed subdirectories. # Constraints: * The directory path provided is always a valid path. * Only files (not subdirectories) should be considered for reorganization. * The program should create a subdirectory for each file extension found within the directory. * If a subdirectory for a file type already exists, it should not recreate it but use the existing subdirectory. # Examples: ```python # If directory \\"my_files\\" contains: # file1.txt, file2.jpg, file3.png, file4.txt organize_files(\\"my_files\\") # After running the function, \\"my_files\\" should be organized as: # my_files/ # ├── txt/ # │ └── file1.txt # │ └── file4.txt # ├── jpg/ # │ └── file2.jpg # └── png/ # └── file3.png ``` # Implementation Notes: * For `create_subdirectories`, ensure that subdirectories are created with names matching their respective file extensions. * Use the `os` module to handle file and directory operations. * Utilize efficient methods to minimize processing time, especially for directories with a large number of files. # Performance Considerations: * Focus on reducing the time complexity of file scanning and moving operations. * Optimize for large numbers of files by leveraging batch operations if possible.","solution":"import os import shutil def create_subdirectories(base_path: str, extensions: list) -> None: for ext in extensions: dir_path = os.path.join(base_path, ext) if not os.path.exists(dir_path): os.makedirs(dir_path) def organize_files(directory_path: str) -> None: # Scan the directory and gather file extensions files = [f for f in os.listdir(directory_path) if os.path.isfile(os.path.join(directory_path, f))] extensions = set(os.path.splitext(f)[1][1:] for f in files if os.path.splitext(f)[1]) # Create necessary subdirectories create_subdirectories(directory_path, extensions) # Move files into their respective subdirectories for file in files: ext = os.path.splitext(file)[1][1:] # Get file extension without dot if ext: current_path = os.path.join(directory_path, file) new_path = os.path.join(directory_path, ext, file) shutil.move(current_path, new_path)"},{"question":"# Repeated Substring Problem Context: You are developing a software tool that processes textual data to identify patterns and repetitions. One important feature is to detect whether a string can be constructed by repeating a substring multiple times. This functionality is critical in compression algorithms and text analysis tasks. Task: Write a function named `is_repeated_substring` that determines if a given string can be formed by repeating a smaller substring multiple times. Input: * A single string `s` consisting of lowercase English letters (a-z). * The length of `s` ranges from 1 to (10^5). Output: * Return `True` if `s` can be constructed by repeating a substring, otherwise return `False`. Constraints: * Your solution should be efficient with a time complexity of (O(n)), where (n) is the length of the string `s`. Function Signature: ```python def is_repeated_substring(s: str) -> bool: pass ``` Examples: ```python assert is_repeated_substring(\\"abab\\") == True assert is_repeated_substring(\\"aba\\") == False assert is_repeated_substring(\\"abcabcabcabc\\") == True assert is_repeated_substring(\\"a\\") == False assert is_repeated_substring(\\"bbbbbb\\") == True ``` Notes: * Consider edge cases, such as strings of length 1, strings with no repetitions, and strings where only part of it repeats. * Use efficient string manipulation techniques to ensure the solution scales well with the input size.","solution":"def is_repeated_substring(s: str) -> bool: Determines if the string can be constructed by repeating a smaller substring. length = len(s) # Check all possible lengths of the potential repeating substring for i in range(1, length // 2 + 1): if length % i == 0: # The substring can be repeated length // i times to form the string if s[:i] * (length // i) == s: return True return False"},{"question":"# Introduction You will implement a custom Min-Heap data structure with specific operations for maintaining and interacting with the heap. # Objective Write a class `CustomMinHeap` that implements: 1. The method `insert` to insert a new element into the heap. 2. The method `extract_min` to extract and return the minimum element from the heap. 3. The method `get_min` to return the minimum element without removing it. 4. The method `decrease_key` to decrease the value of a specific element in the heap. # Specifications Insert Method ```python def insert(self, element: int) -> None: Inserts a new element into the heap. :param element: The element to be inserted. ``` Extract Min Method ```python def extract_min(self) -> int: Extracts and returns the minimum element from the heap. :return: The minimum element. ``` Get Min Method ```python def get_min(self) -> int: Returns the minimum element from the heap without removing it. :return: The minimum element. ``` Decrease Key Method ```python def decrease_key(self, index: int, new_value: int) -> None: Decreases the value of the element at the given index to the new value. :param index: The index of the element whose value is to be decreased. :param new_value: The new value of the element. ``` # Constraints * Your heap should be implemented using a list. * Insertions should maintain the heap property. * Extracting the minimum element should maintain the heap property. * The `decrease_key` method should make sure the heap property is maintained after the key decrease. # Example ```python heap = CustomMinHeap() heap.insert(9) heap.insert(4) heap.insert(7) heap.insert(1) print(heap.get_min()) # 1 print(heap.extract_min()) # 1 print(heap.get_min()) # 4 heap.decrease_key(2, 2) print(heap.get_min()) # 2 ``` # Note Design your heap operations (insertions, deletions, find min, and decrease key) efficiently to maintain the overall time complexity. Handle edge cases appropriately to ensure your heap maintains its properties at all times.","solution":"class CustomMinHeap: def __init__(self): self.heap = [] def insert(self, element: int) -> None: self.heap.append(element) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: if not self.heap: raise IndexError(\\"Heap is empty\\") if len(self.heap) == 1: return self.heap.pop() min_element = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_element def get_min(self) -> int: if not self.heap: raise IndexError(\\"Heap is empty\\") return self.heap[0] def decrease_key(self, index: int, new_value: int) -> None: if index < 0 or index >= len(self.heap): raise IndexError(\\"Index out of bound\\") if new_value > self.heap[index]: raise ValueError(\\"New value is greater than the current value\\") self.heap[index] = new_value self._heapify_up(index) def _heapify_up(self, index): parent_index = (index - 1) // 2 if parent_index >= 0 and self.heap[parent_index] > self.heap[index]: self.heap[parent_index], self.heap[index] = self.heap[index], self.heap[parent_index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Coding Assessment Question **Scenario**: You are developing a financial application that summarizes user transactions. One of the features requires calculating the maximum sum of a contiguous subarray in a list of daily profit/loss values. This will help users understand their best and worst performing periods quickly. # Problem Statement: Implement a function `max_subarray_sum(arr: List[int]) -> int` that determines the maximum sum of any contiguous subarray within the given list `arr`. # Requirements: 1. **Input**: - A list `arr` of integers representing daily profit/loss values. The length of the list is `n`. 2. **Output**: - An integer that is the maximum sum of any contiguous subarray within `arr`. 3. **Constraints**: - The length of the list `arr` will be between 1 and 1000. - The values in the list will range from -10^4 to 10^4. # Examples: ```python >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([4, -1, -2, 1, 5]) 7 ``` # Guidelines: * Ensure your function is efficient with a time complexity of O(n). * Handle edge cases such as all negative values and single-element arrays appropriately. * You may use Kadane\'s algorithm, which is an efficient way to solve this problem. # Notes: The function should be implemented using the following template: ```python from typing import List def max_subarray_sum(arr: List[int]) -> int: # Your code here ```","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Determines the maximum sum of any contiguous subarray within the given list `arr`. if not arr: return 0 max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Merge K Sorted Lists **Context**: Your task is to implement a function that merges k sorted linked lists into one sorted linked list and returns it. This problem is commonly encountered in scenarios involving external sorting and priority queues. # Problem Description **Function Signature**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: list[ListNode]) -> ListNode: ``` **Parameters**: - `lists` (list): A list of `ListNode` objects. Each `ListNode` represents the head of a sorted linked list. **Output**: - A `ListNode` that is the head of the merged sorted linked list. # Constraints - `lists` will contain between 1 to 100 linked lists. - The value in each node of a linked list will be an integer between -10^4 and 10^4. - The length of each linked list will be between 0 to 500 nodes. # Requirements 1. Implement the `merge_k_sorted_lists` function. 2. Maintain the order of elements from the original lists in the merged list. 3. Optimize for efficiency considering the total number of nodes across all lists could be quite large. # Example ```python if __name__ == \\"__main__\\": def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head def print_linked_list(node): result = [] while node: result.append(node.val) node = node.next return result lists = [ create_linked_list([1, 4, 5]), create_linked_list([1, 3, 4]), create_linked_list([2, 6]) ] merged_head = merge_k_sorted_lists(lists) print(print_linked_list(merged_head)) # Expected output: [1, 1, 2, 3, 4, 4, 5, 6] ``` # Hints 1. You may use a min-heap (priority queue) to efficiently merge the k sorted lists. 2. Consider edge cases like when one or more input lists are empty.","solution":"from heapq import heappush, heappop class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: list[ListNode]) -> ListNode: min_heap = [] # Initialize the heap with head nodes of each list for i, node in enumerate(lists): if node: heappush(min_heap, (node.val, i, node)) dummy = ListNode() current = dummy while min_heap: val, i, node = heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"# Coding Assessment Question # Scenario As part of a software utility library, you are required to develop a system to manage the versions of documents. Each version of a document is represented by a string in the format \\"major.minor.patch\\", where `major`, `minor`, and `patch` are non-negative integers. You need to build a system that can compare two versions and determine which one is more recent. # Task Implement a function: 1. `compare_versions(version1: str, version2: str) -> int` **Function Details**: 1. **compare_versions**: Compares two version strings and determines their order. * **Input**: * `version1` (str): A version string in the format \\"major.minor.patch\\". * `version2` (str): Another version string in the format \\"major.minor.patch\\". * **Output**: * (int): Returns 1 if `version1` is more recent than `version2`, -1 if `version2` is more recent than `version1`, and 0 if both versions are the same. # Constraints and Requirements * Both `version1` and `version2` will be valid strings in the format \\"major.minor.patch\\". * Each part of the version (major, minor, and patch) will be a non-negative integer. * The function should have a time complexity of O(n) where n is the maximum length of the versions. * The function should handle versions with differing numbers of components gracefully (e.g., \\"1.2\\" and \\"1.2.0\\"). **Example**: ```python compare_versions(\\"1.0.0\\", \\"1.0.1\\") -> -1 compare_versions(\\"1.2.0\\", \\"1.2\\") -> 0 compare_versions(\\"2.1.0\\", \\"1.9.9\\") -> 1 ``` # Additional Requirements 1. Handle string inputs properly, ensuring no leading zeros interfere with comparisons. 2. The function should be robust and handle corner cases such as different lengths in version parts. 3. Write at least 3 test cases to validate the correctness and robustness of your implementation.","solution":"def compare_versions(version1: str, version2: str) -> int: def to_int_list(version): return list(map(int, version.split(\'.\'))) v1 = to_int_list(version1) v2 = to_int_list(version2) max_length = max(len(v1), len(v2)) # Normalize lengths by appending zeros v1.extend([0] * (max_length - len(v1))) v2.extend([0] * (max_length - len(v2))) for a, b in zip(v1, v2): if a > b: return 1 elif a < b: return -1 return 0"},{"question":"# Coding Assessment Question Scenario: A company wishes to track the times employees check into the office and ensure no employee checks in multiple times in a single day. You need to implement a function that processes a series of check-in records and returns a summary of check-ins, ensuring each employee checks in only once per day. If multiple check-ins are recorded for a single employee in a single day, only the first one should be considered valid. Task: Write a Python function that takes a list of check-in records and returns a summary dictionary indicating the first check-in time for each employee per day. Each record consists of an employee ID, a timestamp, and a date. Your function should ensure that only the first check-in of the day is recorded for each employee. Function Signature: ```python def track_checkins(records: List[Tuple[int, str, str]]) -> Dict[str, Dict[int, str]]: ``` Input: * `records`: A list of tuples where each tuple contains: - An integer `employee_id` (1 ≤ employee_id ≤ 10^6) - A string `timestamp` in the format \\"HH:MM\\" - A string `date` in the format \\"YYYY-MM-DD\\" Output: * A dictionary where: - The keys are date strings \\"YYYY-MM-DD\\". - The values are dictionaries where the keys are employee IDs and the values are timestamps for their first check-in of the day. Examples: ```python assert track_checkins([(1, \\"08:30\\", \\"2023-01-01\\"), (2, \\"09:00\\", \\"2023-01-01\\"), (1, \\"09:15\\", \\"2023-01-01\\"), (1, \\"08:45\\", \\"2023-01-02\\")]) == { \\"2023-01-01\\": {1: \\"08:30\\", 2: \\"09:00\\"}, \\"2023-01-02\\": {1: \\"08:45\\"} } assert track_checkins([(1, \\"07:30\\", \\"2023-05-05\\"), (1, \\"07:30\\", \\"2023-05-05\\"), (2, \\"08:00\\", \\"2023-05-05\\"), (3, \\"08:45\\", \\"2023-05-05\\"), (2, \\"08:30\\", \\"2023-05-05\\")]) == { \\"2023-05-05\\": {1: \\"07:30\\", 2: \\"08:00\\", 3: \\"08:45\\"} } assert track_checkins([]) == {} ``` Notes: - If an employee checks in multiple times on the same day, only the first check-in should be recorded. - Ensure your function handles an empty list input correctly. - Ensure performance considerations as the number of records may be large. Use these guidelines to implement your function correctly to properly track employee check-ins.","solution":"from typing import List, Tuple, Dict def track_checkins(records: List[Tuple[int, str, str]]) -> Dict[str, Dict[int, str]]: checkin_summary = {} for employee_id, timestamp, date in records: if date not in checkin_summary: checkin_summary[date] = {} if employee_id not in checkin_summary[date]: checkin_summary[date][employee_id] = timestamp return checkin_summary"},{"question":"# Sorting 0s, 1s, and 2s You are given an array containing only the numbers 0, 1, and 2. Your task is to sort this array in non-decreasing order without using any extra space for another array (i.e., you have to solve it in-place). Implement a function `sort_colors` which takes a list of integers `nums` containing only 0s, 1s, and 2s and returns the same list sorted in non-decreasing order. Input: * A list of integers `nums` where each element is either 0, 1, or 2, with size up to 10^5. Output: * The input list `nums` sorted in non-decreasing order. Constraints: * The array will only contain 0s, 1s, and 2s. * The solution should handle large sizes efficiently. * You should not use any built-in sorting functions. * Do not use any extra space for another array (i.e., in-place sorting is required). Performance Requirement: * The expected time complexity for the solution is O(n). # Example ```python nums = [2, 0, 1, 2, 0, 1, 2, 0] output = [0, 0, 0, 1, 1, 2, 2, 2] nums = [1, 2, 0] output = [0, 1, 2] ``` # Notes: 1. Ensure your implementation handles edge cases gracefully. 2. Aim for optimal performance in terms of both speed and memory usage. 3. Consider edge cases such as arrays with all similar elements or already sorted arrays. Below is a skeleton code to get you started: ```python def sort_colors(nums: list[int]) -> list[int]: # Your implementation here pass # Example usage: if __name__ == \\"__main__\\": nums = [2, 0, 1, 2, 0, 1, 2, 0] sort_colors(nums) print(nums) # Output: [0, 0, 0, 1, 1, 2, 2, 2] ``` Your task is to complete the function `sort_colors`.","solution":"def sort_colors(nums: list[int]) -> list[int]: Sorts the input list containing only 0, 1, and 2 in non-decreasing order. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1 return nums"},{"question":"# Question: Circle and Rectangle Intersection You are given a function that checks if a circle and a rectangle intersect. The function should return `True` if the circle and rectangle intersect, and `False` otherwise. You need to implement the `is_circle_and_rectangle_intersect` function described below: Function Signature ```python def is_circle_and_rectangle_intersect(circle: Tuple[int, int, int], rectangle: List[int]) -> bool: ``` Inputs 1. `circle`: A tuple `(x, y, r)` representing the circle\'s center `(x, y)` and its radius `r`. 2. `rectangle`: A list `[x1, y1, x2, y2]` representing the coordinates of the top-left `(x1, y1)` and bottom-right `(x2, y2)` corners of the rectangle. Output 1. `intersect`: A boolean value `True` if the circle and rectangle intersect, and `False` otherwise. Constraints - Assume that the inputs will always describe a valid circle and rectangle. - The circle may be partially or completely inside the rectangle, or it may intersect with the rectangle\'s boundary. # Context This function is useful in various computer graphics and game development applications where collision detection is necessary. Example ```python # Example 1 circle = (5, 5, 3) rectangle = [4, 4, 10, 10] print(is_circle_and_rectangle_intersect(circle, rectangle)) # Output: True # Example 2 circle = (1, 1, 1) rectangle = [4, 4, 10, 10] print(is_circle_and_rectangle_intersect(circle, rectangle)) # Output: False # Example 3 circle = (8, 8, 3) rectangle = [5, 5, 10, 10] print(is_circle_and_rectangle_intersect(circle, rectangle)) # Output: True ``` In the examples above: - In Example 1, the circle with radius 3 centered at (5, 5) intersects with the rectangle [4, 4, 10, 10]. - In Example 2, the circle with radius 1 centered at (1, 1) does not intersect with the rectangle [4, 4, 10, 10]. - In Example 3, the circle with radius 3 centered at (8, 8) intersects with the rectangle [5, 5, 10, 10].","solution":"from typing import Tuple, List def is_circle_and_rectangle_intersect(circle: Tuple[int, int, int], rectangle: List[int]) -> bool: cx, cy, cr = circle rx1, ry1, rx2, ry2 = rectangle # Find the closest point to the circle within the rectangle closest_x = max(rx1, min(cx, rx2)) closest_y = max(ry1, min(cy, ry2)) # Calculate the distance between the circle\'s center and this closest point distance_x = cx - closest_x distance_y = cy - closest_y # If the distance is less than the circle\'s radius, an intersection occurs return (distance_x ** 2 + distance_y ** 2) <= (cr ** 2)"},{"question":"# Problem Statement You are provided with a list of integers where all the numbers appear an even number of times except for one number that appears an odd number of times. Your task is to find that unique number. Detailed Requirements: 1. Implement the function `find_unique_number` which identifies the single number that appears an odd number of times in the given list. 2. The function should take a list of integers as input. 3. The function should return the integer that appears an odd number of times. Input - A single list `arr` of integers where the constraints hold. Output - Return a single integer which is the unique number that appears an odd number of times. Constraints - The length of the list `arr` is denoted as ( n ) and (1 leq n leq 10^6). - Each integer in the list lies in the range ( -10^9 leq text{arr}[i] leq 10^9 ). Performance Expectations - Time Complexity: O(n) - Space Complexity: O(1) Example ```python def find_unique_number(arr): # Implement the function to solve the problem. pass # Test Case: assert find_unique_number([4, 3, 3, 4, 5, 5, 5]) == 5 assert find_unique_number([10, 1, 1, 10, 20]) == 20 ``` The expected outputs for the above test cases are `5` and `20` respectively because they are the numbers that appear an odd number of times in their respective arrays.","solution":"def find_unique_number(arr): This function finds the unique number that appears an odd number of times in the given list of integers. :param arr: List[int] - A list of integers. :return: int - The integer that appears an odd number of times. unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"# Vector Dot Product Calculation You are developing a mathematical library and are tasked with implementing a function that computes the dot product of two vectors. The dot product is an essential operation in various fields including computer graphics, physics, and machine learning. Requirements: 1. The function should take two lists of integers as input, representing the vectors. 2. The two input vectors will always have the same length. 3. The function should return the dot product of the two vectors. Input: * `vector1` (list of ints): the first vector. * `vector2` (list of ints): the second vector. Output: * An integer that is the dot product of the two input vectors. Function Signature: ```python def calculate_dot_product(vector1: list, vector2: list) -> int: pass ``` Example: ```python # Example usage: assert calculate_dot_product([1, 3, -5], [4, -2, -1]) == 3 ``` Constraints: * `1 <= len(vector1) == len(vector2) <= 10^3` * `-10^3 <= vector1[i], vector2[i] <= 10^3` for all valid `i` Implement the function `calculate_dot_product` adhering to the above specifications.","solution":"def calculate_dot_product(vector1: list, vector2: list) -> int: Returns the dot product of two vectors. Parameters: - vector1: List of integers representing the first vector - vector2: List of integers representing the second vector Returns: - An integer representing the dot product of the two vectors return sum(x * y for x, y in zip(vector1, vector2))"},{"question":"# Coding Question: Validating and Parsing Nested JSON Structures in Real-Time You are tasked with implementing a function that validates and parses nested JSON structures efficiently. Your function should identify if a given JSON string is well-formed according to standard JSON rules and then parse its contents into a Python dictionary if valid. The validation should account for various types within JSON (e.g., numbers, strings, null, booleans, arrays, and objects). Function Signature ```python def validate_and_parse_json(json_str: str) -> dict: Validate and parse a JSON string into a Python dictionary, if valid. Parameters: json_str (str): A string representing a JSON object. Returns: dict: Parsed JSON content as a dictionary if the JSON string is valid. pass ``` # Input * A string `json_str` representing a JSON object. # Output * A dictionary that contains the parsed content of the JSON string if valid. * If the JSON string is invalid, raise an appropriate exception with a helpful message. # Constraints * Your function should handle deeply nested JSON structures efficiently. * You must provide meaningful error messages for common JSON errors (e.g., missing commas, unclosed brackets). * Perform input validation to separate the validation phase from the parsing phase. # Performance Requirements * Time Complexity: Should handle parsing in O(n) where n is the length of the JSON string. * Space Complexity: O(n) to manage the parsed data and any auxiliary data structures. # Example Given input: ```python json_str = \'{\\"name\\": \\"John\\", \\"age\\": 30, \\"cars\\": {\\"car1\\": \\"Ford\\", \\"car2\\": \\"BMW\\"}, \\"children\\": [\\"Ann\\", \\"Billy\\"]}\' print(validate_and_parse_json(json_str)) ``` Expected output: ```python {\'name\': \'John\', \'age\': 30, \'cars\': {\'car1\': \'Ford\', \'car2\': \'BMW\'}, \'children\': [\'Ann\', \'Billy\']} ``` # Scenario Imagine you are contributing to a real-time web service that receives nested JSON data from various sources. Ensuring that the JSON data is both valid and parsable into data structures used within your application is essential for maintaining data integrity and preventing runtime errors.","solution":"import json def validate_and_parse_json(json_str: str) -> dict: Validate and parse a JSON string into a Python dictionary, if valid. Parameters: json_str (str): A string representing a JSON object. Returns: dict: Parsed JSON content as a dictionary if the JSON string is valid. try: parsed_json = json.loads(json_str) if isinstance(parsed_json, dict): return parsed_json else: raise ValueError(\\"JSON is valid but does not represent a dictionary\\") except json.JSONDecodeError as e: raise ValueError(f\\"Invalid JSON: {e.msg} at line {e.lineno} column {e.colno}\\") # Example usage: # json_str = \'{\\"name\\": \\"John\\", \\"age\\": 30, \\"cars\\": {\\"car1\\": \\"Ford\\", \\"car2\\": \\"BMW\\"}, \\"children\\": [\\"Ann\\", \\"Billy\\"]}\' # print(validate_and_parse_json(json_str))"},{"question":"# Question **Graph Traversal: Shortest Path in a Weighted Grid** In this challenge, you will implement a function that determines the shortest path in a weighted grid using Dijkstra\'s algorithm. The weighted grid is represented as a list of lists where each value in the grid represents the weight of that cell. Problem Statement 1. **Function to Implement**: Implement the function `shortest_path(grid: List[List[int]]) -> int`. 2. **Function Signature**: The function signature should be `def shortest_path(grid: List[List[int]]) -> int:` 3. **Input**: - `grid` (list of lists of integers): A 2D list representing the weighted grid. - The grid dimensions will be at least 1x1 and at most 100x100. - The grid values are non-negative integers where 0 <= grid[i][j] <= 1000. 4. **Output**: - The function should return an integer representing the minimum cost required to travel from the top-left corner of the grid to the bottom-right corner. Requirements Implement your function to adhere to the following steps: 1. **Initialization**: Start at the top-left corner of the grid. 2. **Move Constraints**: From any cell `(i, j)`, you can move to its adjacent cells `(i+1, j)`, `(i-1, j)`, `(i, j+1)`, or `(i, j-1)`, provided that the adjacent cell is within the grid boundaries. 3. **Path Cost Calculation**: The cost of a path is the sum of the grid values along that path. 4. **Shortest Path Calculation**: Use Dijkstra\'s algorithm to find the path with the minimum cost from the top-left corner to the bottom-right corner. Example ```python # Example call grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(shortest_path(grid)) # Output should be 7 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(shortest_path(grid)) # Output should be 21 ``` Additional Information - You may use Python\'s heapq module which provides an implementation of the priority queue that Dijkstra\'s algorithm needs. - Be mindful of the computational efficiency as the grid size can be up to 100x100. Testing Your implementation will be tested with various sizes of grids and weights to ensure it handles edge cases effectively and computes the shortest path accurately and efficiently.","solution":"import heapq from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path in a weighted grid using Dijkstra\'s algorithm. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Min-heap priority queue to store (cost, x, y) min_heap = [(grid[0][0], 0, 0)] # Distance (cost) array initialized to infinity dist = [[float(\'inf\')] * cols for _ in range(rows)] dist[0][0] = grid[0][0] while min_heap: current_cost, x, y = heapq.heappop(min_heap) # If we reached the bottom-right corner, return the cost if x == rows - 1 and y == cols - 1: return current_cost # Explore all possible directions for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < rows and 0 <= new_y < cols: new_cost = current_cost + grid[new_x][new_y] if new_cost < dist[new_x][new_y]: dist[new_x][new_y] = new_cost heapq.heappush(min_heap, (new_cost, new_x, new_y)) return dist[rows - 1][cols - 1]"},{"question":"# Problem Description Implement a function to identify unique trips from a set of travel logs. Each log contains information on user id, origin city, destination city, and travel start and end times. The objective is to count unique trips based on cities visited and trip duration. # Inputs and Outputs * **Input**: - A JSON file named `travel_logs.json` which contains an array of trip objects in the following format: ```json [ { \\"user_id\\": \\"user1\\", \\"origin\\": \\"CityA\\", \\"destination\\": \\"CityB\\", \\"start_time\\": \\"2023-01-01T08:00:00Z\\", \\"end_time\\": \\"2023-01-01T12:00:00Z\\" }, { \\"user_id\\": \\"user2\\", \\"origin\\": \\"CityB\\", \\"destination\\": \\"CityA\\", \\"start_time\\": \\"2023-01-02T09:00:00Z\\", \\"end_time\\": \\"2023-01-02T13:00:00Z\\" } ... ] ``` - An integer `duration_threshold` representing the minimum total trip duration in hours to be considered a unique trip. * **Output**: - An integer representing the number of unique trips that meet or exceed the specified `duration_threshold`. # Constraints - Each user can have multiple trips, but the uniqueness is determined by the combination of `origin`, `destination`, and `duration`. - The formats must follow the ISO 8601 datetime standard. - `duration_threshold` should be a non-negative integer. # Requirements You are required to: 1. Parse the JSON file and read in the trip data. 2. Compute the total duration of each trip in hours. 3. Count the unique trips where the duration meets or exceeds the `duration_threshold`. # Example Sample `travel_logs.json`: ```json [ { \\"user_id\\": \\"user1\\", \\"origin\\": \\"CityA\\", \\"destination\\": \\"CityB\\", \\"start_time\\": \\"2023-01-01T08:00:00Z\\", \\"end_time\\": \\"2023-01-01T12:00:00Z\\" }, { \\"user_id\\": \\"user2\\", \\"origin\\": \\"CityB\\", \\"destination\\": \\"CityA\\", \\"start_time\\": \\"2023-01-02T09:00:00Z\\", \\"end_time\\": \\"2023-01-02T13:00:00Z\\" }, { \\"user_id\\": \\"user1\\", \\"origin\\": \\"CityA\\", \\"destination\\": \\"CityB\\", \\"start_time\\": \\"2023-01-03T10:00:00Z\\", \\"end_time\\": \\"2023-01-03T15:00:00Z\\" } ] ``` Given: - `duration_threshold = 4` Your function should return 2, since there are two unique trips (`\\"CityA-CityB\\"` and `\\"CityB-CityA\\"`) each with duration of 4 hours or more. # Function Signature ```python import json from datetime import datetime def count_unique_trips(file_path: str, duration_threshold: int) -> int: # Loading and processing data pass # Example usage unique_trips_count = count_unique_trips(\'travel_logs.json\', duration_threshold=4) print(unique_trips_count) ```","solution":"import json from datetime import datetime def count_unique_trips(file_path: str, duration_threshold: int) -> int: with open(file_path, \'r\') as file: logs = json.load(file) unique_trips = set() for log in logs: start_time = datetime.fromisoformat(log[\'start_time\'].replace(\\"Z\\", \\"+00:00\\")) end_time = datetime.fromisoformat(log[\'end_time\'].replace(\\"Z\\", \\"+00:00\\")) duration_hours = (end_time - start_time).total_seconds() / 3600 if duration_hours >= duration_threshold: trip_key = (log[\'origin\'], log[\'destination\']) unique_trips.add(trip_key) return len(unique_trips)"},{"question":"# Scenario Graph traversal is a fundamental algorithm in computer science that involves visiting all the nodes or vertices in a graph in a systematic manner. Depth-first search (DFS) and Breadth-first search (BFS) are two common methods used for this purpose. One application of these traversal techniques is determining whether a path exists between two nodes in a graph. # Problem Statement You are tasked with writing a function that determines the shortest path between two nodes in an undirected graph. The graph is represented as an adjacency list, and the function should return a list of nodes representing the shortest path from the start node to the end node. If no path exists, the function should return an empty list. # Function Signature ```python def shortest_path(graph: dict, start: int, end: int) -> list: pass ``` # Input * `graph`: A dictionary where keys are integers representing nodes and values are lists of integers representing the nodes connected to the key node. * `start`: An integer representing the starting node. * `end`: An integer representing the ending node. # Output * A list of integers representing the shortest path from the start node to the end node. If no path exists, return an empty list. # Constraints * The graph does not contain any negative weights. * The graph is undirected and connected. * The nodes are labeled with non-negative integers. * The graph can have up to 10,000 nodes, and each node can have up to 1,000 connections. # Examples ```python assert shortest_path({ 0: [1, 2], 1: [2, 0], 2: [0, 1, 3], 3: [2] }, 0, 3) == [0, 2, 3] assert shortest_path({ 0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3] }, 0, 3) == [] assert shortest_path({ 0: [1, 2, 3], 1: [0, 4], 2: [0, 4], 3: [0, 4], 4: [1, 2, 3] }, 0, 4) == [0, 1, 4] or [0, 2, 4] or [0, 3, 4] ``` # Explanation 1. In the first example, the shortest path from node 0 to node 3 is `[0, 2, 3]`. 2. In the second example, there is no path from node 0 to node 3, so the function returns an empty list. 3. In the third example, there are multiple shortest paths from node 0 to node 4, and any of them are acceptable. # Note To achieve the best results, consider using the Breadth-first search (BFS) algorithm, as it is well-suited for finding the shortest path in an unweighted graph.","solution":"from collections import deque def shortest_path(graph, start, end): Determines the shortest path between two nodes in an undirected graph. Args: graph (dict): A dictionary where keys are integers representing nodes and values are lists of integers representing the nodes connected to the key node. start (int): An integer representing the starting node. end (int): An integer representing the ending node. Returns: list: A list of integers representing the shortest path from the start node to the end node. If no path exists, return an empty list. if start == end: return [start] # Breadth-first search (BFS) initialization queue = deque([start]) visited = {start} parent = {start: None} while queue: node = queue.popleft() for neighbor in graph.get(node, []): if neighbor not in visited: visited.add(neighbor) parent[neighbor] = node queue.append(neighbor) # Stop BFS if we reached the end if neighbor == end: queue.clear() break # Reconstruct the path if end was reached if end in visited: path = [] current = end while current is not None: path.append(current) current = parent[current] path.reverse() return path return []"},{"question":"# File Tree Traversal and Summarization Application You are a software engineer working on a file management system, and you need to develop a function that will help traverse a directory tree and compute the total size of files for each file type. Your task involves the following steps: 1. **Implement File Summarization**: Write a function `summarize_directory(path)` that: * Takes as input: * `path`, a string representing the root directory path. * Returns: * A dictionary where keys are file extensions (e.g., \'.txt\', \'.py\'), and the values are the total sizes (in bytes) of files with that extension within the directory tree. 2. **File Traversal**: Your function should recursively traverse all subdirectories starting from the root directory specified by `path`. 3. **Handle Edge Cases**: * If the directory is empty, return an empty dictionary. * Ensure appropriate handling of files without an extension (use an empty string as the key). **Input and Output Format:** Input: ```python path = \\"/example_root\\" ``` Output: ```python { \\".txt\\": 12345, \\".py\\": 5678, \\"\\": 256 } ``` Your implementation must account for the following constraints and ensure it performs these operations correctly and efficiently. ```python import os def summarize_directory(path): Recursively traverse the directory tree and compute the total size of files for each file type. Args: path (str): The root directory path. Returns: dict: A dictionary where keys are file extensions and values are total file sizes (in bytes) for that extension. file_summary = {} for root, dirs, files in os.walk(path): for file in files: file_extension = os.path.splitext(file)[1] file_path = os.path.join(root, file) file_size = os.path.getsize(file_path) if file_extension in file_summary: file_summary[file_extension] += file_size else: file_summary[file_extension] = file_size return file_summary # Example usage (you can use this for testing your function): path = \\"/example_root\\" summary = summarize_directory(path) print(summary) # Example output: {\\".txt\\": 12345, \\".py\\": 5678, \\"\\": 256} ```","solution":"import os def summarize_directory(path): Recursively traverse the directory tree and compute the total size of files for each file type. Args: path (str): The root directory path. Returns: dict: A dictionary where keys are file extensions and values are total file sizes (in bytes) for that extension. file_summary = {} for root, dirs, files in os.walk(path): for file in files: file_extension = os.path.splitext(file)[1] file_path = os.path.join(root, file) file_size = os.path.getsize(file_path) if file_extension in file_summary: file_summary[file_extension] += file_size else: file_summary[file_extension] = file_size return file_summary"},{"question":"# Problem Description: You are tasked with designing a system to efficiently store and retrieve records for an array of temperature readings. You need to implement a class `TemperatureLog` that supports the following operations: 1. `record(temperature: int) -> None`: Records a new temperature reading. 2. `get_max() -> int`: Returns the highest temperature recorded so far. 3. `get_min() -> int`: Returns the lowest temperature recorded so far. 4. `get_median() -> float`: Returns the median of all the recorded temperatures. If the number of records is even, return the average of the two central elements. # Class Definition: ```python class TemperatureLog: def __init__(self): pass def record(self, temperature: int) -> None: pass def get_max(self) -> int: pass def get_min(self) -> int: pass def get_median(self) -> float: pass ``` # Examples: ```python # Example Usage log = TemperatureLog() log.record(30) log.record(40) log.record(35) log.record(25) print(log.get_max()) # Output: 40 print(log.get_min()) # Output: 25 print(log.get_median()) # Output: 32.5 log.record(20) print(log.get_median()) # Output: 30 ``` # Explanation: In the example, after recording four temperatures [30, 40, 35, 25]: - The maximum temperature is 40. - The minimum temperature is 25. - The median temperature, since the number of records is even, is the average of the two central elements when [25, 30, 35, 40] are sorted, which is (30+35)/2 = 32.5. After recording another temperature [20]: - The sorted temperatures are [20, 25, 30, 35, 40]. - The median temperature, since the number of records is odd, is the central element: 30. # Constraints: - All temperature readings are integers between -100 and 100. - The `record` function will be called at most (10^5) times. - The maximum and minimum temperatures will always exist once a record has been made. # Notes: - Consider efficient ways to keep track of the median to ensure quick retrieval. - Maintain the efficiency of operations in both time and space complexities.","solution":"import bisect class TemperatureLog: def __init__(self): self.temperatures = [] def record(self, temperature: int) -> None: bisect.insort(self.temperatures, temperature) def get_max(self) -> int: return self.temperatures[-1] def get_min(self) -> int: return self.temperatures[0] def get_median(self) -> float: n = len(self.temperatures) if n % 2 == 1: return float(self.temperatures[n // 2]) else: return (self.temperatures[n // 2 - 1] + self.temperatures[n // 2]) / 2.0"},{"question":"# Course Grading System In this task, your job is to implement a simple course grading system. The grading system needs to evaluate students\' scores based on their performance in multiple assessments and compute their final grade in the course. Function Specifications 1. `calculate_final_grade(assignments: List[float], project: float, exams: List[float]) -> str` This function should compute and return the final grade based on the given scores. The final grade is determined by weighted average calculations using specific weightage for assignments, project, and exams. - **Weights**: - Assignments: 40% - Project: 30% - Exams: 30% - **Input**: - `assignments (List[float])`: A list of float numbers representing the scores in the assignments (each must be between 0 and 100). - `project (float)`: A float number representing the score in the project (must be between 0 and 100). - `exams (List[float])`: A list of float numbers representing the scores in the exams (each must be between 0 and 100). - **Output**: - `str`: Final letter grade based on the weighted average score calculated as follows: - \'A\' for scores 90 and above. - \'B\' for scores 80 to 89.99. - \'C\' for scores 70 to 79.99. - \'D\' for scores 60 to 69.99. - \'F\' for scores below 60. - **Constraints**: - The list of assignments and exams must each contain at least one score. - Raise `ValueError` if any score is not between 0 and 100. Example ```python >>> calculate_final_grade([85, 90, 93], 88, [76, 82]) \'B\' >>> calculate_final_grade([70, 75, 80], 72, [68, 74]) \'C\' >>> calculate_final_grade([100, 100], 100, [100]) \'A\' >>> calculate_final_grade([50, 60], 55, [45, 50]) \'F\' >>> calculate_final_grade([], 85, [75, 80]) Traceback (most recent call last): ... ValueError: Each of assignments and exams must contain at least one score. >>> calculate_final_grade([105], 85, [75]) Traceback (most recent call last): ... ValueError: Scores must be between 0 and 100. ``` Notes - Ensure efficient handling of all calculations and edge cases. - Validate all inputs; scores must be within the specified range (0-100). - Raise `ValueError` for invalid inputs as described.","solution":"from typing import List def calculate_final_grade(assignments: List[float], project: float, exams: List[float]) -> str: Compute and return the final grade based on weighted average calculations for assignments, project, and exams scores. # Validate inputs if not assignments or not exams: raise ValueError(\\"Each of assignments and exams must contain at least one score.\\") if any(not (0 <= score <= 100) for score in assignments + [project] + exams): raise ValueError(\\"Scores must be between 0 and 100.\\") # Calculate weighted average assignment_score = sum(assignments) / len(assignments) exam_score = sum(exams) / len(exams) final_score = (0.4 * assignment_score) + (0.3 * project) + (0.3 * exam_score) # Determine final grade if final_score >= 90: return \'A\' elif final_score >= 80: return \'B\' elif final_score >= 70: return \'C\' elif final_score >= 60: return \'D\' else: return \'F\'"},{"question":"# Graph Path Finder Scenario In a weighted graph, finding the shortest path between nodes is a common requirement in many applications, from network routing to game development. You must implement a function that uses Dijkstra\'s algorithm to find the shortest path between two specified nodes in a graph. The graph is represented using an adjacency list. # Function Signature Write a function `shortest_path`: ```python def shortest_path(graph: dict, start: str, end: str) -> list: pass ``` # Requirements * Ensure the function finds the shortest path and returns it as a list of nodes from `start` to `end`. * Use Dijkstra\'s algorithm for finding the shortest path. * Handle cases where no path exists between the nodes, returning an empty list. * The graph is represented as a dictionary where keys are node identifiers (strings), and values are lists of tuples representing the connected nodes and the weights of those edges. # Constraints 1. The graph can contain up to 10^4 nodes. 2. The graph can contain up to 10^5 edges. 3. The weights of edges are positive integers and will be within the range of 1 to 1000. 4. Node identifiers are unique strings consisting of lowercase alphabetic characters. # Input and Output Format * **Input**: - `graph`: A dictionary representing the adjacency list of the graph. - `start`: The starting node identifier. - `end`: The ending node identifier. * **Output**: A list representing the shortest path from `start` to `end`. If no path exists, return an empty list. # Examples ```python graph = { \\"a\\": [(\\"b\\", 1), (\\"c\\", 4)], \\"b\\": [(\\"a\\", 1), (\\"c\\", 2), (\\"d\\", 5)], \\"c\\": [(\\"a\\", 4), (\\"b\\", 2), (\\"d\\", 1)], \\"d\\": [(\\"b\\", 5), (\\"c\\", 1)] } assert shortest_path(graph, \\"a\\", \\"d\\") == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert shortest_path(graph, \\"c\\", \\"a\\") == [\\"c\\", \\"b\\", \\"a\\"] assert shortest_path(graph, \\"a\\", \\"a\\") == [\\"a\\"] assert shortest_path(graph, \\"a\\", \\"e\\") == [] ``` # Evaluation Criteria Your implementation will be evaluated on: * Correctness: The returned list must correctly represent the shortest path or an empty list if no path exists. * Efficiency: Ensure that the implementation efficiently finds the shortest path using Dijkstra\'s algorithm. * Robustness: Handle various edge cases, such as non-existent nodes or disconnected subgraphs, gracefully.","solution":"import heapq def shortest_path(graph: dict, start: str, end: str) -> list: Returns the shortest path from start to end in the given weighted graph using Dijkstra\'s algorithm. If no path exists, return an empty list. if start not in graph or end not in graph: return [] # Priority queue pq = [(0, start, [])] # (weight, node, path) visited = set() while pq: (current_weight, current_node, path) = heapq.heappop(pq) if current_node in visited: continue path = path + [current_node] visited.add(current_node) # Return the path if we\'ve reached the end if current_node == end: return path # Add neighbors to the priority queue for neighbor, weight in graph[current_node]: if neighbor not in visited: heapq.heappush(pq, (current_weight + weight, neighbor, path)) # If we exhaust the priority queue and don\'t find the end return []"},{"question":"# Attendance Calculator Background An online education platform records student attendance in a list. For each student, their attendance is logged as a dictionary with the number of classes attended. To incentivize attendance, the platform wants to implement a feature that calculates the percentage of classes attended by each student and determines whether the student meets the minimum attendance threshold. Task Implement a function `calculate_attendance(attendance_records: List[Dict[str, int]], total_classes: int, min_percentage: float) -> List[Dict[str, Any]]` that calculates the attendance percentage for each student and determines if they meet the minimum required attendance. Function Signature ```python from typing import List, Dict, Any def calculate_attendance(attendance_records: List[Dict[str, int]], total_classes: int, min_percentage: float) -> List[Dict[str, Any]]: pass ``` Input - `attendance_records`: A list of dictionaries, where each dictionary represents a student\'s attendance. Each dictionary has the keys `\'name\'` (a string) and `\'classes_attended\'` (an integer). - `total_classes`: An integer `1 <= total_classes <= 1000`, representing the total number of classes held. - `min_percentage`: A float `0 <= min_percentage <= 100`, representing the minimum required attendance percentage. Output - A list of dictionaries, each containing three key-value pairs: - `\'name\'`: a string, the name of the student. - `\'attendance_percentage\'`: a float, the percentage of classes attended by the student. - `\'meets_requirement\'`: a boolean, `True` if the student meets or exceeds the minimum required attendance percentage, `False` otherwise. Constraints - The function should handle the list of attendance records efficiently. - Attendance percentages are rounded to two decimal places. Examples ```python attendance_records = [ {\'name\': \'Alice\', \'classes_attended\': 45}, {\'name\': \'Bob\', \'classes_attended\': 30}, {\'name\': \'Charlie\', \'classes_attended\': 50} ] total_classes = 50 min_percentage = 80.0 calculate_attendance(attendance_records, total_classes, min_percentage) # Expected output: # [ # {\'name\': \'Alice\', \'attendance_percentage\': 90.0, \'meets_requirement\': True}, # {\'name\': \'Bob\', \'attendance_percentage\': 60.0, \'meets_requirement\': False}, # {\'name\': \'Charlie\', \'attendance_percentage\': 100.0, \'meets_requirement\': True} # ] ``` Notes - The function should round the calculated attendance percentage to two decimal places.","solution":"from typing import List, Dict, Any def calculate_attendance(attendance_records: List[Dict[str, int]], total_classes: int, min_percentage: float) -> List[Dict[str, Any]]: results = [] for record in attendance_records: name = record[\'name\'] attended = record[\'classes_attended\'] attendance_percentage = round((attended / total_classes) * 100, 2) meets_requirement = attendance_percentage >= min_percentage results.append({ \'name\': name, \'attendance_percentage\': attendance_percentage, \'meets_requirement\': meets_requirement }) return results"},{"question":"# Coding Assessment Question As a software developer, you often need to manage and manipulate structured data. One common task is rotating elements within a matrix. To assist with this, you are tasked with writing a program that can rotate a given NxN matrix by 90 degrees in a clockwise direction. You need to implement the function `rotate_matrix_90_degrees(matrix)` which accepts an NxN matrix (a list of lists) and returns a new matrix with the elements rotated by 90 degrees clockwise. Function Signature ```python def rotate_matrix_90_degrees(matrix: List[List[int]]) -> List[List[int]]: ``` Input - `matrix`: A list of lists, where each inner list represents a row of the NxN matrix. Each element is an integer. Output - Return a new NxN matrix which is the result of rotating the input matrix 90 degrees clockwise. Constraints - The input matrix will always be square (NxN) and the dimensions will be between 2 and 10, inclusive. Examples 1. `rotate_matrix_90_degrees([[1, 2], [3, 4]])` should return `[[3, 1], [4, 2]]`. 2. `rotate_matrix_90_degrees([[1, 2, 3], [4, 5, 6], [7, 8, 9]])` should return `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]`. 3. `rotate_matrix_90_degrees([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])` should return `[[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]`. Ensure that your implementation works efficiently for all valid NxN matrices within the given constraints.","solution":"from typing import List def rotate_matrix_90_degrees(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix 90 degrees clockwise. Args: - matrix (List[List[int]]): The NxN matrix to rotate. Returns: - List[List[int]]: The rotated NxN matrix. n = len(matrix) # Creating a new matrix of the same dimensions rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Reverse a Linked List in Groups Write a function `reverse_linked_list_in_groups` that reverses a singly linked list in groups of a given size. Function Signature ```python def reverse_linked_list_in_groups(head: Node, k: int) -> Node: pass ``` # Input - The head of a singly linked list `head` of type `Node`. - An integer `k` indicating the size of the groups. # Output - The head of the new linked list with nodes reversed in groups of size `k`. # Constraints - The linked list contains at least one node. - The value of `k` is between 1 and the length of the linked list. - The nodes in each group should be reversed, but the overall order of the groups should remain the same. - If the number of nodes is not a multiple of `k`, the remaining nodes at the end should remain in their original order. # Example ```python # Example input head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) k = 2 # Example output new_head = reverse_linked_list_in_groups(head, k) print_linked_list(new_head) # Output: \'2 -> 1 -> 4 -> 3 -> 5\' ``` **Note**: You are given the `Node` data class and the complete setup of the linked list in the initial setup. Use this as the basis for reversing the linked list in groups. # Additional Requirements - Handle edge cases such as `k` equal to 1 and the entire linked list. - Ensure that the function is efficient in terms of time complexity. - Provide error handling for invalid inputs, such as `k` being zero or negative.","solution":"class Node: def __init__(self, data): self.data = data self.next = None def reverse_linked_list_in_groups(head: Node, k: int) -> Node: if not head or k <= 0: return None current = head prev_tail = None new_head = None while current: count = 0 curr_tail = current prev = None # Reverse k nodes of the linked list while current and count < k: next_node = current.next current.next = prev prev = current current = next_node count += 1 # new_head will be the head of the first set of reversed nodes if not new_head: new_head = prev # Connect the previous reversed group\'s tail to the new reversed head if prev_tail: prev_tail.next = prev prev_tail = curr_tail return new_head"},{"question":"# Description: Develop a program that calculates the sum of all even-valued terms in the Fibonacci sequence up to a given limit. The Fibonacci sequence is defined such that each number is the sum of the two preceding ones, starting from 0 and 1. The generated sequence should be terminated when the next term exceeds the provided limit. # Objective: Write a function `sum_even_fibonacci(limit: int) -> int` that returns the sum of all even-valued terms in the Fibonacci sequence whose values do not exceed the given limit. Ensure your implementation is efficient and handles edge cases appropriately. # Input: * A positive integer `limit` where `1 <= limit <= 10^18`. # Output: * An integer representing the sum of all even-valued Fibonacci terms that do not exceed the given limit. # Requirements: * Your implementation should be well-optimized for speed and efficiency. * Consider performance implications and use an iterative approach. * Ensure your function correctly handles the limit constraints. # Constraints: * Do not use any third-party libraries. * The time complexity of your solution should be O(n), where n is the number of integers in the Fibonacci sequence up to the given limit. Example: ``` >>> sum_even_fibonacci(10) 10 >>> sum_even_fibonacci(100) 44 >>> sum_even_fibonacci(4000000) 4613732 >>> sum_even_fibonacci(1) 0 ``` Test Cases to Validate: ```python assert sum_even_fibonacci(10) == 10 assert sum_even_fibonacci(100) == 44 assert sum_even_fibonacci(4000000) == 4613732 assert sum_even_fibonacci(1) == 0 assert sum_even_fibonacci(0) == 0 assert sum_even_fibonacci(8) == 10 ``` # Implementation Function Stub ```python def sum_even_fibonacci(limit: int) -> int: if not isinstance(limit, int) or limit < 1: raise ValueError(\\"Limit must be a positive integer\\") sum_even = 0 a, b = 0, 1 while b <= limit: if b % 2 == 0: sum_even += b a, b = b, a + b return sum_even ```","solution":"def sum_even_fibonacci(limit: int) -> int: Returns the sum of all even-valued terms in the Fibonacci sequence whose values do not exceed the given limit. if limit < 1: return 0 sum_even = 0 a, b = 0, 1 while b <= limit: if b % 2 == 0: sum_even += b a, b = b, a + b return sum_even"},{"question":"# Problem Statement: Write a function that determines if a given list of integers contains any Pythagorean Triplets. A Pythagorean Triplet is a set of three integers a, b, c (where a ≤ b ≤ c) that satisfy the equation a² + b² = c². # Input: - A list of integers `numbers` containing at least three elements. # Output: - Return `True` if there exists a Pythagorean Triplet within the list, otherwise return `False`. # Constraints: - The function should efficiently handle lists of varying lengths. - The function should ensure input validation, raising exceptions if the input is not a list of integers. - Consider edge cases such as negative numbers and non-integer elements within the list. # Function Signature: ```python def has_pythagorean_triplet(numbers: List[int]) -> bool: # Your implementation goes here ``` # Examples: ```python assert has_pythagorean_triplet([3, 1, 4, 6, 5]) == True assert has_pythagorean_triplet([10, 4, 6, 12, 5]) == False assert has_pythagorean_triplet([5, 12, 13]) == True assert has_pythagorean_triplet([3, 6, -1, 9, 7, 1]) == False assert has_pythagorean_triplet([24, 7, 25]) == True ```","solution":"from typing import List def has_pythagorean_triplet(numbers: List[int]) -> bool: Determines if there exists a Pythagorean Triplet in the given list of integers. A Pythagorean Triplet is a set of three integers a, b, c (where a <= b <= c) such that a^2 + b^2 = c^2. Parameters: numbers (List[int]): A list of integers. Returns: bool: True if there exists a Pythagorean Triplet, False otherwise. # Check if the input is a list of integers if not all(isinstance(num, int) for num in numbers): raise ValueError(\\"The input list must contain integers only.\\") # If the list contains less than 3 elements, it\'s impossible to form a triplet if len(numbers) < 3: return False # Sort the list numbers.sort() # Use a set to store the squares of the numbers squares = set(x * x for x in numbers) # Iterate through each pair (a, b) and check if a^2 + b^2 is in the set n = len(numbers) for i in range(n): for j in range(i + 1, n): if numbers[i] ** 2 + numbers[j] ** 2 in squares: return True return False"},{"question":"# Scenario As part of your job at a software development company, you are tasked with improving the efficiency of a common algorithm used in data processing tasks. Your goal is to implement a function that finds the k-th largest element in an array. This function is crucial for various tasks including statistical analysis, where it is used to find specific percentiles. # Task Implement an efficient function to find the k-th largest element in an unsorted list. The function should be optimized to handle large datasets and perform better than a simple sort-and-access method (i.e., sorting the entire list and then accessing the k-th largest element). # Input - A list of integers and an integer k. - Constraints: The list can have up to 1000 elements and k is a valid index within the list. # Output - The k-th largest element in the list. # Function Signature ```python from typing import List def find_kth_largest(nums: List[int], k: int) -> int: pass ``` # Example ```python # Example 1 print(find_kth_largest([3, 2, 1, 5, 6, 4], 2)) # Output: 5, since the 2nd largest element is 5 # Example 2 print(find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4)) # Output: 4, since the 4th largest element is 4 # Example 3 print(find_kth_largest([1], 1)) # Output: 1, since the 1st largest element is 1 # Complex example import random collection_arg = random.sample(range(-1000, 1000), 1000) k_arg = 500 assert find_kth_largest(collection_arg, k_arg) == sorted(collection_arg, reverse=True)[k_arg-1] ``` # Constraints - The algorithm should handle edge cases gracefully, such as lists with duplicate elements or only one element. - Aim for O(n) complexity on average, leveraging efficient selection algorithms like Quickselect. - Do not use library functions that directly sort the list. Ensure that your implementation provides the k-th largest element efficiently even for the largest allowed list size.","solution":"from typing import List import random def find_kth_largest(nums: List[int], k: int) -> int: Finds the k-th largest element in an unsorted list. Uses the Quickselect algorithm which is efficient with average O(n) time complexity. def partition(left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] > pivot_value: # Change the comparison operator to \'>\' for finding the k-th largest. nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[store_index], nums[right] = nums[right], nums[store_index] return store_index def quickselect(left, right, k_smallest): Quickselect algorithm to find the k-th smallest element in an unsorted list. if left == right: return nums[left] pivot_index = random.randint(left, right) pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) n = len(nums) return quickselect(0, n - 1, k - 1)"},{"question":"# Coding Assessment Question Problem Statement: Implement a Python function `find_max_subarray(arr: List[int]) -> Tuple[int, int, int]` that finds the subarray with the maximum sum in a given list of integers using the divide-and-conquer approach. Requirements: * **Input Format**: * `arr` (List[int]): A list of integers. * **Output Format**: * `(start, end, max_sum)`: A tuple containing the starting index, ending index, and the sum of the maximum subarray. * **Constraints**: * The input list can have up to `10^5` elements. * Each element in the list can range from `-10^9` to `10^9`. * **Performance**: * Your solution should run in O(n log n) time complexity. Example: ```python >>> find_max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (3, 6, 6) >>> find_max_subarray([1, 2, 3, 4, 5]) (0, 4, 15) >>> find_max_subarray([-1, -2, -3, -4, -5]) (0, 0, -1) >>> find_max_subarray([]) (0, 0, 0) >>> find_max_subarray([4, -1, 2, 1]) (0, 3, 6) ``` Hints: 1. Split the array into two halves recursively until you reach a single element. 2. Calculate the maximum sum subarray in each half. 3. Calculate the maximum sum subarray that crosses the middle point. 4. Use an auxiliary function `_max_crossing_subarray(arr: List[int], low: int, mid: int, high: int) -> Tuple[int, int, int]` to find the maximum subarray sum crossing the mid point. Edge Cases: 1. An empty list should return a tuple (0, 0, 0). 2. A list with one element should return that element\'s sum as the maximum subarray. 3. A list with all negative elements should return the maximum single element as the subarray with the maximum sum. Implement your function below: ```python from typing import List, Tuple def find_max_subarray(arr: List[int]) -> Tuple[int, int, int]: if not arr: return 0, 0, 0 return _find_max_subarray(arr, 0, len(arr) - 1) def _find_max_subarray(arr: List[int], low: int, high: int) -> Tuple[int, int, int]: if low == high: return low, high, arr[low] mid = (low + high) // 2 left_low, left_high, left_sum = _find_max_subarray(arr, low, mid) right_low, right_high, right_sum = _find_max_subarray(arr, mid + 1, high) cross_low, cross_high, cross_sum = _max_crossing_subarray(arr, low, mid, high) if left_sum >= right_sum and left_sum >= cross_sum: return left_low, left_high, left_sum elif right_sum >= left_sum and right_sum >= cross_sum: return right_low, right_high, right_sum else: return cross_low, cross_high, cross_sum def _max_crossing_subarray(arr: List[int], low: int, mid: int, high: int) -> Tuple[int, int, int]: left_sum = float(\'-inf\') sum = 0 cross_low = mid for i in range(mid, low - 1, -1): sum += arr[i] if sum > left_sum: left_sum = sum cross_low = i right_sum = float(\'-inf\') sum = 0 cross_high = mid + 1 for j in range(mid + 1, high + 1): sum += arr[j] if sum > right_sum: right_sum = sum cross_high = j return cross_low, cross_high, left_sum + right_sum ```","solution":"from typing import List, Tuple def find_max_subarray(arr: List[int]) -> Tuple[int, int, int]: if not arr: return 0, 0, 0 return _find_max_subarray(arr, 0, len(arr) - 1) def _find_max_subarray(arr: List[int], low: int, high: int) -> Tuple[int, int, int]: if low == high: return low, high, arr[low] mid = (low + high) // 2 left_low, left_high, left_sum = _find_max_subarray(arr, low, mid) right_low, right_high, right_sum = _find_max_subarray(arr, mid + 1, high) cross_low, cross_high, cross_sum = _max_crossing_subarray(arr, low, mid, high) if left_sum >= right_sum and left_sum >= cross_sum: return left_low, left_high, left_sum elif right_sum >= left_sum and right_sum >= cross_sum: return right_low, right_high, right_sum else: return cross_low, cross_high, cross_sum def _max_crossing_subarray(arr: List[int], low: int, mid: int, high: int) -> Tuple[int, int, int]: left_sum = float(\'-inf\') sum = 0 cross_low = mid for i in range(mid, low - 1, -1): sum += arr[i] if sum > left_sum: left_sum = sum cross_low = i right_sum = float(\'-inf\') sum = 0 cross_high = mid + 1 for j in range(mid + 1, high + 1): sum += arr[j] if sum > right_sum: right_sum = sum cross_high = j return cross_low, cross_high, left_sum + right_sum"},{"question":"Title: Count the Number of 1 Bits in an Integer # Description You are to write a function that counts the number of `1` bits (also known as the Hamming weight or population count) in the binary representation of a given non-negative integer. The process should be efficient, using bitwise operations. Your function should handle cases where the input is zero or a non-integer by raising a `ValueError` with the message \\"Input must be a non-negative integer.\\" # Function Signature ```python def count_one_bits(number: int) -> int: pass ``` # Input * `number` (int): A non-negative integer. # Output * Returns the number of `1` bits in the binary representation of `number`. # Constraints * The function should only accept non-negative integers. * If the input `number` is not a non-negative integer, raise a `ValueError` with the message \\"Input must be a non-negative integer\\". * Aim to solve the problem using bitwise operations with time complexity of O(log N) and space complexity of O(1). # Examples ```python count_one_bits(5) # returns 2 (binary: 101) count_one_bits(8) # returns 1 (binary: 1000) count_one_bits(15) # returns 4 (binary: 1111) count_one_bits(0) # returns 0 (binary: 0) count_one_bits(31) # returns 5 (binary: 11111) ``` # Notes * Make sure to test the function with edge cases such as `0`, negative numbers, and non-integer inputs. * Remember to use bitwise operations wherever possible to ensure optimal performance.","solution":"def count_one_bits(number: int) -> int: Counts the number of 1 bits in the binary representation of a non-negative integer. Parameters: number (int): A non-negative integer. Returns: int: The number of 1 bits in the binary representation of number. Raises: ValueError: If the input is not a non-negative integer. if not isinstance(number, int) or number < 0: raise ValueError(\\"Input must be a non-negative integer\\") count = 0 while number: count += number & 1 number >>= 1 return count"},{"question":"# Problem Statement You are given a string containing lowercase and uppercase alphabetic characters, digits, and special characters. Your task is to write a function that masks all the digits and replaces each masked digit with a \\"#\\" symbol, while leaving all other characters unchanged. Function Signature ```python def mask_digits(s: str) -> str: ``` Input - A string `s` that contains lowercase and uppercase alphabetic characters, digits, and special characters. - The length of the string will be between 1 and 10^5. Output - Return a new string where all digits in the input string are replaced by \\"#\\". Constraints - The input string will be non-empty. - Digits are characters from \'0\' to \'9\'. - The function should handle strings of considerable length efficiently. Examples ```python assert mask_digits(\\"Hello123\\") == \\"Hello#\\" assert mask_digits(\\"P@ssw0rd!\\") == \\"P@ssw#rd!\\" assert mask_digits(\\"Secr3tC0d3\\") == \\"Secr#tC#d#\\" assert mask_digits(\\"2022-10-04\\") == \\"--\\" assert mask_digits(\\"UniVers1ty3\\") == \\"UniVers#ty#\\" assert mask_digits(\\"!23*abc\\") == \\"!*abc\\" ``` Additional Notes - Ensure any solution meets the efficiency requirements for large input lengths. - Consider edge cases where there might be no digits to mask. Scenario Imagine you are working on a content moderation tool that processes user data while preserving privacy. You need to ensure that any numeric data (like phone numbers or social security numbers) within a provided string is masked so that it cannot be read or decoded easily. Your function helps in anonymizing such critical data while leaving other information untouched.","solution":"def mask_digits(s: str) -> str: Returns a new string where all digits in the input string are replaced with the \\"#\\" symbol. return \'\'.join([\'#\' if char.isdigit() else char for char in s])"},{"question":"# Coding Assessment Question: 3D Rotation in Computer Graphics **Problem Statement**: In the realm of computer graphics, 3D rotations are fundamental for manipulating objects in three-dimensional space. You are tasked with writing an advanced algorithm to perform a 3D rotation of a point around an arbitrary axis. Given the following constraints: - Ensure the rotation axis is non-zero and normalized (unit length). - The point to rotate and the rotation angle in radians should be provided. Implement a function `rotate_point` that, given a point `P` (a list or array representing `[x, y, z]`), an axis `A` (a list or array representing `[a_x, a_y, a_z]`), and an angle `theta` (in radians), computes the rotated coordinates based on Rodrigues\' rotation formula. Here\'s what you should focus on: 1. **Normalize the axis**: Ensure the rotation axis vector is of unit length. 2. **Compute the rotation matrix** using Rodrigues\' rotation formula. 3. **Apply the rotation**: Use the rotation matrix to find the new coordinates of the point. **Function Signature**: ```python import numpy as np def rotate_point(point: list, axis: list, theta: float) -> np.ndarray: pass ``` **Expected Inputs**: - `point` (`list[float]`): A list of three float values representing the coordinates `[x, y, z]`. - `axis` (`list[float]`): A list of three float values representing the rotation axis `[a_x, a_y, a_z]`. - `theta` (`float`): The rotation angle in radians. **Expected Outputs**: - Returns a numpy array of length 3, representing the rotated point coordinates `[x\', y\', z\']`. **Constraints**: - Ensure the axis vector is non-zero. - The point list contains exactly 3 float elements. **Examples**: 1. `rotate_point([1, 0, 0], [0, 0, 1], np.pi / 2)` should output approximately `[0, 1, 0]`. 2. `rotate_point([1, 2, 3], [0, 0, 1], np.pi)` should output approximately `[-1, -2, 3]`. **Requirements**: - Ensure Doctest is used to validate the function automatically. - Handle edge cases and erroneous values gracefully (raising appropriate exceptions). Here is an example implementation that uses the cross product and dot product. ```python import numpy as np def rotate_point(point, axis, theta): # Normalize axis axis = np.array(axis) if np.linalg.norm(axis) == 0: raise ValueError(\\"Axis vector must be non-zero.\\") axis = axis / np.linalg.norm(axis) # Rodrigues\' rotation formula components K = np.array([[0, -axis[2], axis[1]], [axis[2], 0, -axis[0]], [-axis[1], axis[0], 0]]) I = np.identity(3) R = I + np.sin(theta) * K + (1 - np.cos(theta)) * np.dot(K, K) # Rotate the point point = np.array(point) rotated_point = np.dot(R, point) return rotated_point ``` Test your implementation with the provided examples and make sure the results are as expected. This exercise will help in understanding 3D transformations critical to computer graphics and robotics.","solution":"import numpy as np def rotate_point(point, axis, theta): Rotates a point in 3D space around a given axis by a specified angle using Rodrigues\' rotation formula. Parameters: point (list): A list of three float values representing the point coordinates [x, y, z]. axis (list): A list of three float values representing the rotation axis [a_x, a_y, a_z]. theta (float): The rotation angle in radians. Returns: np.ndarray: A numpy array of length 3, representing the rotated point coordinates [x\', y\', z\']. # Normalize the axis axis = np.array(axis) if np.linalg.norm(axis) == 0: raise ValueError(\\"Axis vector must be non-zero.\\") axis = axis / np.linalg.norm(axis) # Rodrigues\' rotation formula components K = np.array([ [0, -axis[2], axis[1]], [axis[2], 0, -axis[0]], [-axis[1], axis[0], 0] ]) I = np.identity(3) R = I + np.sin(theta) * K + (1 - np.cos(theta)) * np.dot(K, K) # Rotate the point point = np.array(point) rotated_point = np.dot(R, point) return rotated_point"},{"question":"# Sorting Words by Frequency You are given a list of words and you need to write a function that sorts these words based on their frequency in descending order. If two words have the same frequency, they should be sorted lexicographically (alphabetically) in ascending order. # Function Signature ```python def sort_words_by_frequency(words): Sort words by frequency and lexicographically if frequencies are the same. :param words: List of words. :return: List of words sorted by frequency and lexicographically. pass ``` # Requirements 1. **Frequency Calculation**: Calculate the frequency of each word in the input list. 2. **Sorting**: - Primary criteria: Sort by frequency in descending order. - Secondary criteria: Sort lexicographically (alphabetically) in ascending order if frequencies are the same. 3. **Correctness**: Ensure the function produces the correct sorted list based on the criteria specified. # Input - `words`: List of words (strings). Example Input ```python words = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"] ``` # Output - Return a list of words sorted by the specified criteria. Example Output ```python [\\"apple\\", \\"banana\\", \\"orange\\"] ``` # Constraints - The number of words in the input list will not exceed 1000. - Each word in the list will have at most 50 characters. - All words will be lowercase letters only. # Note Consider edge cases such as an empty list or all words being unique and appearing exactly once.","solution":"from collections import Counter def sort_words_by_frequency(words): Sort words by frequency and lexicographically if frequencies are the same. :param words: List of words. :return: List of words sorted by frequency and lexicographically. # Count the frequency of each word word_count = Counter(words) # Sort primarily by frequency in descending order, # and by word lexicographically in ascending order for ties sorted_words = sorted(word_count.keys(), key=lambda x: (-word_count[x], x)) return sorted_words"},{"question":"# Coding Question: String Permutations with Constraints Scenario You are working on a text processing tool that needs to generate all distinct permutations of a given string under certain constraints. The string can include alphabetical characters, digits, and special characters. However, to manage computation and relevance, permutations should only be generated for strings up to a certain length. Your task is to write a function that generates all unique permutations of a string, ensuring that no duplicate permutations are returned even if the input string contains duplicate characters. # Function Signature ```python def unique_string_permutations(s: str, max_length: int) -> list: pass ``` # Input - `s` (str): The original string for which permutations need to be generated. - `max_length` (int): The maximum length permissible for any permutation. # Output - Returns a list of unique permutations sorted in lexicographical order. # Constraints - The input string `s` can have a maximum length of 10. - The characters in the string can include alphabets (both uppercase and lowercase), digits, and special characters. - The generated list should not contain duplicate permutations. - If `max_length` is greater than the length of `s`, consider the length of `s` for generating permutations. # Requirements - Generate unique permutations only. - Output should be sorted lexicographically. Performance Requirements: - Ensure the algorithm handles typical edge cases like empty strings and single-character strings gracefully. # Example ```python >>> s = \\"abca\\" >>> max_length = 3 >>> unique_string_permutations(s, max_length) [\'a\', \'aa\', \'ab\', \'abc\', \'ac\', \'aca\', \'b\', \'ba\', \'bac\', \'bc\', \'bca\', \'c\', \'ca\', \'cab\'] >>> s = \\"123\\" >>> max_length = 2 >>> unique_string_permutations(s, max_length) [\'1\', \'12\', \'13\', \'2\', \'21\', \'23\', \'3\', \'31\', \'32\'] ``` # Explanation - The `unique_string_permutations` function should generate all distinct permutations of the input string `s` with lengths up to `max_length`. - The output should list permutations in lexicographical order ensuring no duplicates are present even when the input string contains duplicate characters.","solution":"from itertools import permutations def unique_string_permutations(s: str, max_length: int) -> list: Generate all unique permutations of the string `s` up to the length of `max_length`. The permutations are sorted in lexicographical order and contain no duplicates. Parameters: s (str): The original string. max_length (int): The maximum length permissible for any permutation. Returns: list: A list of unique permutations sorted in lexicographical order. max_length = min(len(s), max_length) unique_perms = set() for length in range(1, max_length + 1): for p in permutations(s, length): unique_perms.add(\'\'.join(p)) return sorted(unique_perms)"},{"question":"# Problem Statement You are required to implement a function that transposes a given N x M matrix. The input is a matrix with N rows and M columns, and your task is to return the transposed version of this matrix. Write a function `transpose_matrix` that performs the transposition operation. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ... ``` Input - `matrix`: A list of N lists, each containing M integers, representing an N x M matrix. Output - Returns a list of M lists, each containing N integers, representing the transposed matrix of size M x N. Constraints - 1 ≤ N, M ≤ 1000 (Dimensions of the matrix) Performance Requirements - The solution should handle matrices of large dimensions efficiently. # Example Example 1 ```python matrix = [ [1, 2, 3], [4, 5, 6] ] assert transpose_matrix(matrix) == [ [3, 2, 1], [6, 5, 4] ] ``` Example 2 ```python matrix = [ [1, 2], [3, 4], [5, 6] ] assert transpose_matrix(matrix) == [ [1, 3, 5], [2, 4, 6] ] ``` # Notes - Ensure that your function can handle both square and non-square matrices. - Consider edge cases such as matrices with only one row or one column. - Focus on minimizing runtime complexity to handle matrices at the upper constraint limits effectively.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given N x M matrix. if not matrix or not matrix[0]: return [] rows = len(matrix) cols = len(matrix[0]) # Initialize the transposed matrix with dimensions MxN transposed_matrix = [[0 for _ in range(rows)] for _ in range(cols)] for i in range(rows): for j in range(cols): transposed_matrix[j][i] = matrix[i][j] return transposed_matrix"},{"question":"# Context You are developing a software system for managing the inventory of a bookstore. One crucial requirement is to categorize and count books based on their genre. The bookstore maintains a list of books, each represented by a dictionary with `title` and `genre` keys. # Task Implement a Python function called `categorize_books_by_genre` that organizes books from a list into categories based on their genres and counts the number of books in each category. Your function should adhere to the following requirements: # Requirements * Define the function as `categorize_books_by_genre(books: list) -> dict`. * The function should take a list of dictionaries, where each dictionary represents a book with the keys `title` (a string) and `genre` (a string). * The function should return a dictionary where the keys are genres and the values are the count of books for each genre. * If the input list is empty, the function should return an empty dictionary. # Example Usage ```python >>> books = [ ... {\\"title\\": \\"The Catcher in the Rye\\", \\"genre\\": \\"Fiction\\"}, ... {\\"title\\": \\"To Kill a Mockingbird\\", \\"genre\\": \\"Fiction\\"}, ... {\\"title\\": \\"A Brief History of Time\\", \\"genre\\": \\"Science\\"}, ... {\\"title\\": \\"The Art of Computer Programming\\", \\"genre\\": \\"Computer Science\\"}, ... {\\"title\\": \\"The Selfish Gene\\", \\"genre\\": \\"Science\\"} ... ] >>> categorize_books_by_genre(books) {\'Fiction\': 2, \'Science\': 2, \'Computer Science\': 1} >>> categorize_books_by_genre([]) {} ``` # Constraints * Each book dictionary will contain exactly two keys: `title` and `genre`. * Both `title` and `genre` will be non-empty strings. * The list will contain up to 10,000 books. # Performance Requirements * Your function should run in linear time, O(n), where n is the number of books in the input list. * Ensure that your solution is optimized for both efficiency and clarity of code.","solution":"def categorize_books_by_genre(books): Organizes books into categories based on their genres and counts the number of books in each category. Args: books (list): A list of dictionaries, each representing a book with \'title\' and \'genre\' keys. Returns: dict: A dictionary where the keys are genres and the values are the count of books for each genre. genre_count = {} for book in books: genre = book[\'genre\'] if genre in genre_count: genre_count[genre] += 1 else: genre_count[genre] = 1 return genre_count"},{"question":"# Maximum Subarray with At Most K Distinct Elements Background In array manipulation problems, one common task is to find subarrays that satisfy certain conditions. Here, let\'s focus on identifying the longest subarray that contains at most K distinct elements. Task Write a function `max_subarray_k_distinct` that takes an integer array `nums` and an integer `k` and returns the length of the longest subarray that contains at most `k` distinct elements. Function Signature ```python def max_subarray_k_distinct(nums: List[int], k: int) -> int: pass ``` Input - `nums`: A list of integers representing the array. - `k`: An integer representing the maximum number of distinct elements allowed in the subarray. Output - An integer representing the length of the longest subarray with at most `k` distinct elements. Constraints - The length of `nums` will not exceed 10^5. - The elements in `nums` are in the range -10^4 to 10^4. - `1 <= k <= len(nums)` Example ```python nums = [1, 2, 1, 2, 3, 4, 5] k = 2 print(max_subarray_k_distinct(nums, k)) # Output: 4 (The subarray [1, 2, 1, 2] has the maximum length of 4 with at most 2 distinct elements) ``` # Instructions 1. Utilize an efficient algorithm to handle arrays close to the upper constraint limit. 2. Ensure that the solution runs in O(n) time complexity. 3. Add a brief docstring explaining your approach to solve the problem. --- # Sample Solution ```python def max_subarray_k_distinct(nums: List[int], k: int) -> int: Finds the length of the longest subarray that contains at most k distinct elements. Args: nums (List[int]): List of integers representing the array. k (int): Maximum number of distinct elements allowed in the subarray. Returns: int: Length of the longest subarray with at most k distinct elements. from collections import defaultdict left = 0 right = 0 max_length = 0 freq_map = defaultdict(int) while right < len(nums): freq_map[nums[right]] += 1 right += 1 while len(freq_map) > k: freq_map[nums[left]] -= 1 if freq_map[nums[left]] == 0: del freq_map[nums[left]] left += 1 max_length = max(max_length, right - left) return max_length ```","solution":"from typing import List def max_subarray_k_distinct(nums: List[int], k: int) -> int: Finds the length of the longest subarray that contains at most k distinct elements. Args: nums (List[int]): List of integers representing the array. k (int): Maximum number of distinct elements allowed in the subarray. Returns: int: Length of the longest subarray with at most k distinct elements. from collections import defaultdict left = 0 right = 0 max_length = 0 freq_map = defaultdict(int) while right < len(nums): freq_map[nums[right]] += 1 right += 1 while len(freq_map) > k: freq_map[nums[left]] -= 1 if freq_map[nums[left]] == 0: del freq_map[nums[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"**Maximum Subarray Sum with Non-adjacent Elements** You are given an array of integers, and your task is to find the maximum sum of a subsequence with the constraint that no two elements in the subsequence should be adjacent in the original array. **Function Signature**: ```python def max_non_adjacent_sum(nums: list[int]) -> int: pass ``` **Input**: - `nums`: A list of integers representing the array. **Output**: - An integer representing the maximum sum of the selected subsequence with non-adjacent elements. **Constraints**: - The `nums` list contains between 1 and 10000 integers. - Each integer in the `nums` list is between -1000 and 1000. **Example**: ```python >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) 8 ``` **Explanation**: 1. For the first example: - Selecting elements `3, 5, 7` (indices 0, 2, 4 respectively) yields the maximum sum of 15. 2. For the second example: - Selecting elements `3, 10` (indices 0, 3 respectively) yields the maximum sum of 13. 3. For the third example: - Selecting elements `3, 5` (indices 2, 4 respectively) yields the maximum sum of 8. Consider edge cases where all numbers might be negative or positive, the approach should handle these smoothly, ensuring the constraints of non-adjacency are met while maximizing the sum. **Performance Requirements**: Due to the potentially large input size, an optimal solution with a time complexity of O(n) is expected to handle the worst-case scenario efficiently. **Scenarios**: For setting up the question context, consider real-world scenarios like selecting non-adjacent houses for targeted maintenance budgets, or maximizing the non-consecutive daily profits in a financial forecasting model.","solution":"def max_non_adjacent_sum(nums: list[int]) -> int: if not nums: return 0 # Initialization include = 0 exclude = 0 for num in nums: # Current max excluding num new_exclude = max(include, exclude) # Current max including num include = exclude + num exclude = new_exclude # Final max value return max(include, exclude)"},{"question":"# Problem Statement: Context: In computer science, a common problem is checking whether a sequence of numbers can be arranged to form an arithmetic series. An arithmetic series is one in which the difference between consecutive terms is constant. Additionally, once identified, calculating the sum of such a series can be useful for various applications. Task: 1. Enhance the `is_arithmetic_series(series)` function to handle edge cases such as detecting sequences with only one unique element. 2. Develop a `sum_of_arithmetic_series(series)` function to compute the sum of the series efficiently. Function Signature: ```python def is_arithmetic_series(series: list) -> bool def sum_of_arithmetic_series(series: list) -> int ``` Input Formats: - `is_arithmetic_series(series)`: A list of integers or floats. - `sum_of_arithmetic_series(series)`: A list of integers or floats. Output Formats: - `is_arithmetic_series(series)`: Returns a boolean value indicating if the series is arithmetic. - `sum_of_arithmetic_series(series)`: Returns an integer, the sum of the series if the series is arithmetic; otherwise, return `None`. Constraints: - The input series list will have a length of up to 1000 elements. - The elements can be both positive and negative numbers, and can include zero. - Handle edge cases such as series with one element and sequences with identical elements. Example: ```python # Example inputs for is_arithmetic_series print(is_arithmetic_series([2, 4, 6, 8])) # True print(is_arithmetic_series([5, 5, 5, 5])) # True print(is_arithmetic_series([1, 2, 4, 8])) # False # Example inputs for sum_of_arithmetic_series print(sum_of_arithmetic_series([2, 4, 6, 8])) # 20 print(sum_of_arithmetic_series([5, 5, 5, 5])) # 20 print(sum_of_arithmetic_series([1, 2, 4, 8])) # None ``` Performance Requirements: - Ensure efficient computation with minimal complexity. - Properly handle edge cases and possible errors. Implementation Details: - Enhance the current functions to improve error handling and validation. - Use arithmetic formulas to calculate the sum of the series efficiently if it is identified as arithmetic.","solution":"def is_arithmetic_series(series): Check if the input series is arithmetic. An arithmetic series is defined as a series where the difference between consecutive terms is constant. if len(series) <= 1: return True # A series with 0 or 1 elements is trivially arithmetic common_difference = series[1] - series[0] for i in range(1, len(series)): if series[i] - series[i - 1] != common_difference: return False return True def sum_of_arithmetic_series(series): Compute the sum of the series if it is arithmetic. If the series is not arithmetic, return None. if not is_arithmetic_series(series): return None n = len(series) if n == 0: return 0 elif n == 1: return series[0] # If the series is arithmetic, use the formula: sum = n/2 * (first_element + last_element) return n * (series[0] + series[-1]) // 2"},{"question":"# Problem Statement You are required to implement a function that takes as input a list of strings and returns a single string with these strings interleaved character by character. If the strings are of different lengths, the function should append the remaining characters from the longer strings once the shorter ones are exhausted. # Input - A list of strings `str_list` of non-negative length `n` (0 <= n <= 10). # Output - A single string that consists of interleaved characters from the input strings. # Constraints 1. The input list may contain up to 10 strings. 2. Each string in the input list has a length `m` (0 <= m <= 100). 3. The function should handle empty input lists and strings. 4. The function should be efficient in both time and space. # Requirements 1. Implement the function `interleave_strings()` that adheres to the above constraints and solves the problem. 2. The function should be efficient and optimized for performance. 3. Include appropriate comments and documentation for clarity. # Example **Example 1:** ```python str_list = [\\"abc\\", \\"123\\", \\"XYZ\\"] print(interleave_strings(str_list)) ``` Expected output: ``` \\"a1Xb2Yc3Z\\" ``` **Example 2:** ```python str_list = [\\"hello\\", \\"world\\"] print(interleave_strings(str_list)) ``` Expected output: ``` \\"hweolrllod\\" ``` **Example 3:** ```python str_list = [\\"a\\", \\"b\\", \\"c\\"] print(interleave_strings(str_list)) ``` Expected output: ``` \\"abc\\" ``` **Example 4:** ```python str_list = [\\"\\", \\"1234\\"] print(interleave_strings(str_list)) ``` Expected output: ``` \\"1234\\" ``` **Example 5:** ```python str_list = [] print(interleave_strings(str_list)) ``` Expected output: ``` \\"\\" ``` # Function Signature ```python def interleave_strings(str_list: list) -> str: # Your code here pass ``` # Evaluation Your solution will be evaluated based on: 1. **Correctness**: Accurate interleaving of characters from the input list. 2. **Efficiency**: Use of efficient algorithms to manage the operations, especially with variable input sizes. 3. **Code Quality**: Clear, readable, and well-commented code.","solution":"def interleave_strings(str_list: list) -> str: Interleaves characters from a list of strings. Args: str_list (list): A list of strings to be interleaved. Returns: str: A single string with characters interleaved character by character from the input strings. if not str_list: return \\"\\" max_len = max(len(s) for s in str_list) result = [] for i in range(max_len): for s in str_list: if i < len(s): result.append(s[i]) return \'\'.join(result)"},{"question":"# Coding Question: Graph Connectivity with Depth-First Search **Context**: Bob is working on a network analysis tool where he needs to determine if two nodes in a network are connected. The network is represented as an undirected graph using an adjacency list. To achieve this, he uses Depth-First Search (DFS) to explore the graph. **Objective**: Your task is to implement the `GraphConnectivityDFS` class that checks if there is a path between two given nodes using a DFS-based algorithm. **Function to Implement**: You need to implement the `GraphConnectivityDFS` class with the following method: ```python class GraphConnectivityDFS: def __init__(self, graph: dict[int, list[int]]): # Initialize the class with the graph representation. pass def are_connected(self, node1: int, node2: int) -> bool: # Method to check if node1 and node2 are connected. pass ``` **Input Format**: - The constructor `__init__` receives a dictionary `graph` representing an adjacency list of an undirected graph. - Example: `graph = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1]}` - The `are_connected` method receives two integers `node1` and `node2` representing the nodes to check connectivity. - Example: `node1 = 0` and `node2 = 3` **Output Format**: - The `are_connected` method should return a boolean value: `True` if there is a path between `node1` and `node2`, otherwise `False`. **Constraints**: - The graph will have at least one node. - The number of nodes (N) and edges (M) will satisfy `1 <= N, M <= 10^4`. **Performance Requirements**: - The solution must efficiently handle large graphs, optimizing both time and space complexity for DFS traversal. **Example**: Given the following graph: ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1, 4], 4: [3, 5], 5: [4] } node1 = 0 node2 = 5 ``` Output: - The `are_connected` method should return: `True`, since there is a path: `0 -> 1 -> 3 -> 4 -> 5`. Write your implementation in the class provided to correctly determine the connectivity of two nodes using DFS.","solution":"class GraphConnectivityDFS: def __init__(self, graph: dict[int, list[int]]): self.graph = graph def are_connected(self, node1: int, node2: int) -> bool: visited = set() return self.dfs(node1, node2, visited) def dfs(self, current: int, target: int, visited: set[int]) -> bool: if current == target: return True visited.add(current) for neighbor in self.graph.get(current, []): if neighbor not in visited: if self.dfs(neighbor, target, visited): return True return False"},{"question":"# Coding Assessment Question Context: Stacks are a fundamental data structure in computer science, often used to manage function calls in programming languages and to evaluate expressions. Their Last-In-First-Out (LIFO) characteristic makes them ideal for certain types of problem solving. Problem: You are required to implement a function that evaluates the value of an arithmetic expression given in **Reverse Polish Notation (RPN)**. The operators and operands will be separated by spaces. Function Signature: ```python def evaluate_rpn(expression: str) -> int: pass ``` Input: * `expression`: A string containing a valid Reverse Polish Notation expression with integers and the operators \'+\', \'-\', \'*\', \'/\' separated by spaces. Output: * Return an integer representing the result of the expression. Constraints: * The expression will always be valid and will not need to be checked for errors. * The division between two integers should truncate towards zero (i.e., `5 / -2` should return `-2`). * You may assume that the input conforms to standard Reverse Polish Notation rules and contains no invalid characters. Example: ```python expression = \\"2 1 + 3 *\\" evaluate_rpn(expression) # Output: 9 expression = \\"4 13 5 / +\\" evaluate_rpn(expression) # Output: 6 expression = \\"10 6 9 3 + -11 * / * 17 + 5 +\\" evaluate_rpn(expression) # Output: 22 ``` Instructions: 1. Implement the `evaluate_rpn` function to process the given RPN expression. 2. Use a stack to evaluate the expression. 3. Handle the arithmetic operations as per standard RPN evaluation rules. 4. Ensure to maintain performance efficiency. Note: You may use helper functions if necessary to keep your code clean and modular.","solution":"def evaluate_rpn(expression: str) -> int: Evaluates the value of an arithmetic expression given in Reverse Polish Notation (RPN). :param expression: A string containing the RPN expression with integers and \'+\', \'-\', \'*\', \'/\' operators separated by spaces. :return: The integer result of evaluating the RPN expression. stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': # Perform integer division truncating towards zero stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"# Scenario A company has developed a password strength checker and would like to enhance it by adding a feature to suggest improvements for weak passwords. Weak passwords are defined as those that are either too short, lack a mix of character types, or are common words found in a predefined list. The company aims to guide users to create stronger passwords by suggesting necessary improvements. # Problem Statement Write a function `password_suggester` that accepts a `password` string and a `common_words` list, and returns a tuple containing: 1. A boolean indicating if the password is strong. 2. A list of suggestions to improve the password if it is weak. A strong password must meet all the following criteria: 1. At least 8 characters long. 2. Contains at least one uppercase letter (A-Z). 3. Contains at least one lowercase letter (a-z). 4. Contains at least one digit (0-9). 5. Contains at least one special character (e.g., !, @, #, etc.). 6. Is not a common word found in the `common_words` list (case-insensitive). For weak passwords, provide suggestions to meet the criteria. Each suggestion should be a string describing the required improvement. # Function Signature ```python def password_suggester(password: str, common_words: List[str]) -> Tuple[bool, List[str]]: pass ``` # Input - `password`: a string representing the password to check. - `common_words`: a list of strings representing the common words. # Output - A tuple containing: 1. A boolean indicating if the password is strong. 2. A list of suggestions to improve the password if it is weak. # Constraints - `password` can have a maximum length of 100 characters. - `common_words` is a list of strings with a maximum length of 1000, each string having a maximum length of 50 characters. - The password can contain any printable ASCII characters except spaces. # Example Given the inputs: ```python password = \\"P@ssw0rd\\" common_words = [\\"password\\", \\"123456\\", \\"qwerty\\", \\"p@ssw0rd\\"] ``` The function call `password_suggester(password, common_words)` should return: ```python (False, [\\"Password should not be a common word\\", \\"Add at least 1 special character\\"]) ``` Given the inputs: ```python password = \\"Str0ngP@ss\\" common_words = [\\"password\\", \\"123456\\", \\"qwerty\\", \\"abc123\\"] ``` The function call `password_suggester(password, common_words)` should return: ```python (True, []) ``` **Note**: Ensure the case-insensitivity check for common words and provide clear, actionable suggestions for weak passwords.","solution":"from typing import List, Tuple import re def password_suggester(password: str, common_words: List[str]) -> Tuple[bool, List[str]]: Checks the strength of `password` and returns a tuple indicating whether it is strong, along with a list of suggestions for improvement if it is weak. A strong password adheres to the criteria outlined in the problem statement. suggestions = [] is_strong = True # Check Length if len(password) < 8: suggestions.append(\\"Password must be at least 8 characters long\\") is_strong = False # Check uppercase letter if not any(c.isupper() for c in password): suggestions.append(\\"Add at least 1 uppercase letter\\") is_strong = False # Check lowercase letter if not any(c.islower() for c in password): suggestions.append(\\"Add at least 1 lowercase letter\\") is_strong = False # Check digit if not any(c.isdigit() for c in password): suggestions.append(\\"Add at least 1 digit\\") is_strong = False # Check special character if not any(c in \\"!@#%^&*()-_=+[]{}|;:\'\\",.<>?/\\" for c in password): suggestions.append(\\"Add at least 1 special character\\") is_strong = False # Check common words (case-insensitive) if password.lower() in (word.lower() for word in common_words): suggestions.append(\\"Password should not be a common word\\") is_strong = False return is_strong, suggestions"},{"question":"# Problem Statement You are given an integer array `arr` and an integer `k`. Your task is to implement a function `find_pairs_with_sum(arr: List[int], k: int) -> List[Tuple[int, int]]` that finds all unique pairs of elements in `arr` whose sum is equal to `k`. # Function Signature ```python def find_pairs_with_sum(arr: List[int], k: int) -> List[Tuple[int, int]]: pass ``` # Input * `arr` (List[int]): A list of integers where 0 ≤ |arr| ≤ 1000 and -10^6 ≤ arr[i] ≤ 10^6. * `k` (int): An integer value for which we need to find pairs in `arr` that sum up to `k`. # Output * `List[Tuple[int, int]]`: A list of unique pairs `(a, b)` such that `a + b = k` and `a <= b`. Each pair should only appear once in the output list. # Constraints * Each pair `(a, b)` in the output must be unique, meaning that if `(a, b)` is in the list, then `(b, a)` should not be included. * The function should not return pairs where the same element is used twice unless it appears twice in the input array. # Examples ```python >>> find_pairs_with_sum([1, 2, 3, 4, 3], 6) [(2, 4), (3, 3)] >>> find_pairs_with_sum([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)] >>> find_pairs_with_sum([0, -1, 2, -3, 1], -2) [(-3, 1)] >>> find_pairs_with_sum([1, 2, 3], 5) [(2, 3)] >>> find_pairs_with_sum([5, 5, 5], 10) [(5, 5)] ``` # Notes * Ensure to account for cases where no pairs sum up to `k`. * The order of the pairs in the result does not matter, as long as they are unique pairs.","solution":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], k: int) -> List[Tuple[int, int]]: seen = set() pairs = set() for num in arr: complement = k - num if complement in seen: # Ensure that the pair order is consistent (a <= b) pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return list(pairs)"},{"question":"# Sentence Substring Matching Given a main sentence and a list of words, write functions to identify which words from the list appear as exact substrings in the main sentence, case-insensitively. Your task is to implement the following functions: 1. **`find_substrings(main_sentence: str, words: list[str]) -> list[str]`**: This function should return a list of words from the input `words` list that are found as exact substrings in the `main_sentence`, regardless of case. 2. **`substring_occurrence_count(main_sentence: str, words: list[str]) -> dict[str, int]`**: This function should return a dictionary where the keys are words from the `words` list that are found in the `main_sentence`, and the values are the number of times they appear as substrings in the `main_sentence`. 3. **`substring_presence_score(main_sentence: str, words: list[str]) -> float`**: This function should return a score representing the percentage of words from the `words` list that appear as exact substrings in the `main_sentence`. # Requirements - **Input Format**: - `main_sentence`: A string representing the main sentence to check. - `words`: A list of words to search for in the main sentence. - **Output Format**: - For `find_substrings`: A list of words (from the input `words` list) that are found in the `main_sentence`. - For `substring_occurrence_count`: A dictionary mapping each word (found in the main sentence) to its count of occurrences. - For `substring_presence_score`: A float representing the percentage of words (from the `words` list) that are found as substrings in the `main_sentence`. - **Constraints**: - `main_sentence` will only contain ASCII characters and spaces. - `words` will only contain ASCII alphabetic characters. - **Performance**: - Focus on efficiency in string search operations. # Example ```python # Given the main sentence \\"The quick brown fox jumps over the lazy dog\\" main_sentence = \\"The quick brown fox jumps over the lazy dog\\" words = [\\"quick\\", \\"dog\\", \\"cat\\", \\"Fox\\"] # Expected output for find_substrings [\\"quick\\", \\"dog\\", \\"Fox\\"] # Expected output for substring_occurrence_count { \\"quick\\": 1, \\"dog\\": 1, \\"Fox\\": 1 } # Expected output for substring_presence_score 75.0 ``` Implement the specified functions ensuring correctness and optimal performance.","solution":"def find_substrings(main_sentence: str, words: list[str]) -> list[str]: Identify which words from the list appear as exact substrings in the main sentence, case-insensitively. main_sentence_lower = main_sentence.lower() return [word for word in words if word.lower() in main_sentence_lower] def substring_occurrence_count(main_sentence: str, words: list[str]) -> dict[str, int]: Count the number of times words from the provided list appear as exact substrings in the main sentence, case-insensitively. main_sentence_lower = main_sentence.lower() count_dict = {} for word in words: word_lower = word.lower() count = main_sentence_lower.count(word_lower) if count > 0: count_dict[word] = count return count_dict def substring_presence_score(main_sentence: str, words: list[str]) -> float: Calculate the percentage of words from the list that appear as exact substrings in the main sentence, case-insensitively. found_words = find_substrings(main_sentence, words) return (len(found_words) / len(words)) * 100 if words else 0.0"},{"question":"# Question Scenario: You are assisting a senior software engineer in developing tools for data analysis. One of the tasks is to implement a function that sanitizes a given list of integer pairs by removing pairs that contain duplicate elements while maintaining all unique pairs. Task: Write a Python function `sanitize_pairs` that takes a list of integer pairs and returns a sanitized list. The function should remove pairs where both elements are the same and keep the relative order of valid pairs. Function Signature: ```python def sanitize_pairs(pairs: list[tuple[int, int]]) -> list[tuple[int, int]]: ``` Input: - A list of integer pairs, `pairs` (0 <= len(pairs) <= 10^3). Output: - A sanitized list of integer pairs where pairs with duplicate elements are removed while preserving the relative order of unique pairs. Constraints: - Do not use any third-party libraries. - Ensure the relative order of valid pairs is maintained. - Aim for an efficient solution. Example Usage: ```python >>> sanitize_pairs([(1, 2), (2, 2), (3, 4), (5, 5)]) [(1, 2), (3, 4)] >>> sanitize_pairs([(1, 1), (2, 3), (4, 4), (5, 6)]) [(2, 3), (5, 6)] >>> sanitize_pairs([(0, 0), (2, 2), (3, 3)]) [] >>> sanitize_pairs([(1, 2), (3, 4), (5, 6)]) [(1, 2), (3, 4), (5, 6)] >>> sanitize_pairs([]) [] ```","solution":"def sanitize_pairs(pairs: list[tuple[int, int]]) -> list[tuple[int, int]]: Returns a list of pairs where pairs with duplicate elements are removed and the relative order of unique pairs is maintained. return [pair for pair in pairs if pair[0] != pair[1]]"},{"question":"# Scenario You are working with a two-dimensional grid-based game map where cells can either be an empty space or a wall. Your objective is to determine the shortest path from a given starting point to a destination point, avoiding walls. If no path exists, return -1. The player can only move up, down, left, or right. # Task Implement a function `def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:` that, given a grid, a starting position, and an end position, returns the length of the shortest path from start to end. If no path exists, it should return -1. # Input and Output Formats 1. **Input**: - `grid`: A list of lists of integers representing the game map where `0` indicates an empty space and `1` indicates a wall. - `start`: A tuple of two integers (row, column) representing the starting position. - `end`: A tuple of two integers (row, column) representing the destination. 2. **Output**: - An integer representing the length of the shortest path from `start` to `end`, or `-1` if no path exists. # Constraints 1. The grid will have a maximum size of 1000x1000. 2. The start and end positions will be within the bounds of the grid. 3. The start and end positions will always be `0` (i.e., an empty space). 4. There will be at least one empty space in the grid. 5. The player can move up, down, left, or right but not diagonally. # Examples ```python from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: rows, cols = len(grid), len(grid[0]) queue = deque([start]) visited = set(start) steps = 0 while queue: for _ in range(len(queue)): r, c = queue.popleft() if (r, c) == end: return steps for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc)) steps += 1 return -1 # Example 1: print(shortest_path( [[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0]], (0, 0), (4, 4) )) # Output: 8 # Example 2: print(shortest_path( [[0, 1, 0], [1, 1, 0], [0, 0, 0]], (0, 0), (2, 2) )) # Output: 4 # Example 3: print(shortest_path( [[1, 1, 0], [1, 1, 0], [0, 0, 0]], (2, 0), (0, 2) )) # Output: 4 # Example 4: print(shortest_path( [[0, 1], [1, 0]], (0, 0), (1, 1) )) # Output: -1 ``` Make sure to consider edge cases such as: - The start and end positions being the same. - The grid being fully blocked except for the start and end positions directly next to each other.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: rows, cols = len(grid), len(grid[0]) if start == end: return 0 queue = deque([start]) visited = set([start]) steps = 0 while queue: for _ in range(len(queue)): r, c = queue.popleft() if (r, c) == end: return steps for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc)) steps += 1 return -1"},{"question":"# Question: Anagram Substring Check with Validation Context: You are developing a text processing utility and need to check if any permutation of a smaller string (anagram) is a substring of a larger string. This is a common problem in text analysis and bioinformatics, where sequences must be matched or patterns detected robustly. Task: Write a function `is_anagram_substring` that checks if any permutation of a string `s1` is a substring of another string `s2`, with the following specifications: 1. **Input**: * `s1` and `s2` are two strings consisting of lowercase alphabetical characters. * Demonstrate input validation to handle: * Non-string inputs. * Check if `s1` is not longer than `s2`. * Raise appropriate errors with meaningful messages for invalid inputs. 2. **Output**: * Return `True` if any permutation of `s1` is a substring of `s2`. * Return `False` otherwise. * If the inputs are invalid, raise a `ValueError` with an appropriate message. 3. **Constraints**: * Inputs consist only of lowercase alphabetical characters. * Length of `s1` can be up to 10 characters. * Length of `s2` can be up to 10,000 characters. 4. **Performance**: * Aim to implement the function efficiently with a linear time complexity, O(n). 5. **Edge Cases**: * Empty strings. * Edge cases with invalid data types such as integers or lists. * `s1` being longer than `s2`. * Case sensitivity is not a concern; all inputs are lowercase. Example Usage: ```python def is_anagram_substring(s1: str, s2: str) -> bool: # Your implementation goes here pass # Example test cases print(is_anagram_substring(\\"ab\\", \\"eidbaooo\\")) # Output: True print(is_anagram_substring(\\"abc\\", \\"bbbca\\")) # Output: True print(is_anagram_substring(\\"abc\\", \\"bbbcca\\")) # Output: False # Example of error handling try: is_anagram_substring(\\"abc\\", 12345) except ValueError as e: print(e) # Output: Both inputs must be strings try: is_anagram_substring(\\"abc\\", \\"ab\\") except ValueError as e: print(e) # Output: First string must not be longer than the second string ``` Note: Test cases should also handle scenarios where errors are expected to ensure robust input validation.","solution":"from collections import Counter def is_anagram_substring(s1: str, s2: str) -> bool: Checks if any permutation of the string `s1` is a substring of string `s2`. Args: s1 (str): The string of which permutations are to be checked. s2 (str): The string to be checked against. Returns: bool: True if any permutation of `s1` is a substring of `s2`, False otherwise. Raises: ValueError: If the inputs are invalid. # Input validation if not isinstance(s1, str) or not isinstance(s2, str): raise ValueError(\\"Both inputs must be strings\\") if len(s1) > len(s2): raise ValueError(\\"First string must not be longer than the second string\\") # Base case for empty string s1 if not s1: return True # Create counters for s1 and the initial window in s2. s1_counter = Counter(s1) window_counter = Counter(s2[:len(s1)]) # Initialize left and right pointers for the sliding window. left, right = 0, len(s1) while right < len(s2): if s1_counter == window_counter: return True # Slide the window to the right by one character. window_counter[s2[right]] += 1 window_counter[s2[left]] -= 1 if window_counter[s2[left]] == 0: del window_counter[s2[left]] left += 1 right += 1 # Final check outside the loop for the last window position. return s1_counter == window_counter"},{"question":"# Question: Implement a Balanced AVL Tree **Context**: You are tasked with implementing an AVL Tree, a self-balancing binary search tree, to maintain a sorted collection of data that supports efficient insertion, deletion, and search operations. **Objective**: Given a sequence of key-value pairs, implement methods to insert, delete, and search for keys in the AVL Tree while ensuring the tree remains balanced after each operation. **Function Signature**: ```python class AVLNode: def __init__(self, key: int, value: any): self.key = key self.value = value self.height = 1 self.left = None self.right = None class AVLTree: def __init__(self): self.root = None def insert(self, key: int, value: any) -> None: Insert a key-value pair into the AVL Tree, ensuring the tree remains balanced. Args: - key: The key to insert. - value: The value associated with the key. Returns: - None def delete(self, key: int) -> None: Delete a key from the AVL Tree, ensuring the tree remains balanced. Args: - key: The key to delete. Returns: - None def search(self, key: int) -> any: Search for a key in the AVL Tree and return its value if found. Args: - key: The key to search for. Returns: - The value associated with the key, or None if the key is not found. def _balance(self, node: AVLNode) -> AVLNode: Balance the subtree rooted at the given node. Args: - node: The root of the subtree to balance. Returns: - The new root of the balanced subtree. def _rotate_left(self, node: AVLNode) -> AVLNode: Perform a left rotation on the given node. Args: - node: The node to rotate. Returns: - The new root after the rotation. def _rotate_right(self, node: AVLNode) -> AVLNode: Perform a right rotation on the given node. Args: - node: The node to rotate. Returns: - The new root after the rotation. def _get_height(self, node: AVLNode) -> int: Get the height of the given node. Args: - node: The node whose height is to be obtained. Returns: - The height of the node. def _get_balance(self, node: AVLNode) -> int: Get the balance factor of the given node. Args: - node: The node whose balance factor is to be obtained. Returns: - The balance factor of the node. ``` **Instructions**: 1. Implement the `insert` method to add a key-value pair while ensuring the tree remains balanced. 2. Implement the `delete` method to remove a key while ensuring the tree remains balanced. 3. Implement the `search` method to find the value associated with a key. 4. Use rotations to maintain the balance of the AVL Tree after insertions and deletions. 5. Ensure proper handling of corner cases, such as inserting a duplicate key or deleting a non-existent key. 6. Optimize for space and time complexity to handle up to 10^4 operations efficiently. **Example**: ```python avl_tree = AVLTree() avl_tree.insert(10, \\"A\\") avl_tree.insert(20, \\"B\\") avl_tree.insert(30, \\"C\\") avl_tree.insert(40, \\"D\\") avl_tree.insert(50, \\"E\\") avl_tree.insert(25, \\"F\\") print(avl_tree.search(10)) # Output: \\"A\\" print(avl_tree.search(50)) # Output: \\"E\\" print(avl_tree.search(60)) # Output: None avl_tree.delete(50) print(avl_tree.search(50)) # Output: None ``` **Performance Requirements**: * Your solution should handle up to 10^4 insertions, deletions, and searches efficiently.","solution":"class AVLNode: def __init__(self, key: int, value: any): self.key = key self.value = value self.height = 1 self.left = None self.right = None class AVLTree: def __init__(self): self.root = None def insert(self, key: int, value: any) -> None: self.root = self._insert(self.root, key, value) def _insert(self, node, key, value): if not node: return AVLNode(key, value) if key < node.key: node.left = self._insert(node.left, key, value) elif key > node.key: node.right = self._insert(node.right, key, value) else: # Update existing key with new value node.value = value return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key, node.value = temp.key, temp.value node.right = self._delete(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def search(self, key: int) -> any: node = self._search(self.root, key) return node.value if node else None def _search(self, node, key): if not node or node.key == key: return node if key < node.key: return self._search(node.left, key) return self._search(node.right, key) def _balance(self, node: AVLNode) -> AVLNode: balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_left(self, z: AVLNode) -> AVLNode: y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, y: AVLNode) -> AVLNode: x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _get_height(self, node: AVLNode) -> int: return node.height if node else 0 def _get_balance(self, node: AVLNode) -> int: return self._get_height(node.left) - self._get_height(node.right) if node else 0 def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Question You are given a list of `n` integers and your task is to write a function `find_k_closest_elements(arr: List[int], k: int, x: int) -> List[int]` that returns the `k` closest integers to `x` in the array `arr`. The result should be sorted in ascending order. If there is a tie, the smaller elements are preferred. Input - A list of integers `arr` where (1 leq n leq 10^4) and each element is between (-10^9) and (10^9). - Two integers `k` where (1 leq k leq n) and `x` where (-10^9 leq x leq 10^9). Output - A list of `k` integers which are the closest to `x`. Examples ```python assert find_k_closest_elements([1, 2, 3, 4, 5], 4, 3) == [1, 2, 3, 4] assert find_k_closest_elements([1, 2, 3, 4, 5], 4, -1) == [1, 2, 3, 4] assert find_k_closest_elements([10, 12, 15, 17, 20, 25], 3, 15) == [12, 15, 17] ``` Constraints - Handle edge cases such as `k` being equal to `n` or `arr` containing duplicate values. - Optimize for both time complexity and space complexity to handle large values of `n`. - Consider scenarios where the elements of the array are larger or smaller than `x`. * Use efficient sorting and selection algorithms to ensure that the function performs well on the upper limits of the constraints. * Carefully manage ties by returning the smaller numbers first to ensure consistency with the problem\'s requirements.","solution":"from typing import List def find_k_closest_elements(arr: List[int], k: int, x: int) -> List[int]: Finds the k closest integers to x in the array arr. The result should be sorted in ascending order. # Sort `arr` based on the difference from `x` and then by the value itself sorted_arr = sorted(arr, key=lambda num: (abs(num - x), num)) # Take the first `k` elements from the sorted list closest_elements = sorted_arr[:k] # Sort the result before returning closest_elements.sort() return closest_elements"},{"question":"# Coding Assessment Question You are developing a software component for a transportation system that handles different vehicles on a highway. Each vehicle has its own unique characteristics, and your task is to create a class hierarchy that correctly models these characteristics and behaviors. Additionally, you need to implement a function that calculates the time it takes for a vehicle to travel a specified distance, taking into account its speed and any applicable restrictions. # Task Details 1. Implement a base class `Vehicle` with the following properties and methods: - **Properties**: - `make` (str): The manufacturer of the vehicle. - `model` (str): The model of the vehicle. - `year` (int): The manufacturing year of the vehicle. - `speed` (float): The speed of the vehicle in km/h. - **Methods**: - `__init__(self, make: str, model: str, year: int, speed: float)`: Constructor to initialize the properties. - `time_to_travel(self, distance: float) -> float`: Method to calculate time to travel a given distance in hours. 2. Implement derived classes for specific vehicle types: - `Car`: - Additional properties: - `number_of_doors` (int): Number of doors in the car. - `Bike`: - Additional properties: - `helmet_required` (bool): Indicates if a helmet is required by law. 3. Implement a function `calculate_travel_time(vehicle: Vehicle, distance: float) -> str`: - This function should: - Accept an instance of `Vehicle` or its subclasses and a distance in km. - Use the vehicle\'s `time_to_travel` method to compute the travel time. - Return a formatted string indicating the type of vehicle and the calculated time to travel the distance. # Example Usage ```python class Vehicle: def __init__(self, make: str, model: str, year: int, speed: float): if speed <= 0: raise ValueError(\\"Speed must be positive.\\") self.make = make self.model = model self.year = year self.speed = speed def time_to_travel(self, distance: float) -> float: if distance < 0: raise ValueError(\\"Distance must be non-negative.\\") return distance / self.speed class Car(Vehicle): def __init__(self, make: str, model: str, year: int, speed: float, number_of_doors: int): super().__init__(make, model, year, speed) self.number_of_doors = number_of_doors class Bike(Vehicle): def __init__(self, make: str, model: str, year: int, speed: float, helmet_required: bool): super().__init__(make, model, year, speed) self.helmet_required = helmet_required def calculate_travel_time(vehicle: Vehicle, distance: float) -> str: time = vehicle.time_to_travel(distance) vehicle_type = type(vehicle).__name__.lower() return f\\"A {vehicle_type} takes {time:.2f} hours to travel {distance} km.\\" # Example usage: car = Car(\\"Toyota\\", \\"Corolla\\", 2020, 120.0, 4) print(calculate_travel_time(car, 240)) # Example: \\"A car takes 2.00 hours to travel 240 km.\\" bike = Bike(\\"Yamaha\\", \\"YZF-R3\\", 2019, 100.0, True) print(calculate_travel_time(bike, 150)) # Example: \\"A bike takes 1.50 hours to travel 150 km.\\" # Test with various edge cases: try: slow_bike = Bike(\\"Honda\\", \\"CB125\\", 2018, 0, True) except ValueError as e: print(e) # \\"Speed must be positive.\\" ``` # Additional Requirements - Ensure your implementation includes appropriate error handling, especially for invalid input values. - Use inheritance and polymorphism effectively to avoid code duplication. - Provide at least four unit tests that cover expected normal cases, boundary conditions, and potential error cases. Deliver the Python code that passes the above example usages and unit tests.","solution":"class Vehicle: def __init__(self, make: str, model: str, year: int, speed: float): if speed <= 0: raise ValueError(\\"Speed must be positive.\\") self.make = make self.model = model self.year = year self.speed = speed def time_to_travel(self, distance: float) -> float: if distance < 0: raise ValueError(\\"Distance must be non-negative.\\") return distance / self.speed class Car(Vehicle): def __init__(self, make: str, model: str, year: int, speed: float, number_of_doors: int): super().__init__(make, model, year, speed) self.number_of_doors = number_of_doors class Bike(Vehicle): def __init__(self, make: str, model: str, year: int, speed: float, helmet_required: bool): super().__init__(make, model, year, speed) self.helmet_required = helmet_required def calculate_travel_time(vehicle: Vehicle, distance: float) -> str: time = vehicle.time_to_travel(distance) vehicle_type = type(vehicle).__name__.lower() return f\\"A {vehicle_type} takes {time:.2f} hours to travel {distance} km.\\""},{"question":"# Scenario A company is developing a new encryption system and needs help designing a basic shift cipher. A shift cipher is a type of substitution cipher where each letter in the plaintext is shifted a certain number of places down the alphabet. # Task Implement a function named `shift_cipher` that encrypts a given plaintext string by shifting each letter a specified number of places down the alphabet. Non-alphabet characters should remain unchanged. Both uppercase and lowercase letters should retain their case after shifting. # Function Signature ```python def shift_cipher(plaintext: str, shift: int) -> str: Encrypt the plaintext using a shift cipher. :param plaintext: The input string to be encrypted. :param shift: The number of places to shift each letter (positive for right shift, negative for left shift). :return: The encrypted string after applying the shift cipher. :raises ValueError: If the plaintext contains non-ASCII characters. ``` # Input * `plaintext`: a string containing the text to be encrypted. * `shift`: an integer representing the number of positions to shift each letter. # Output Returns the encrypted string after shifting the letters in `plaintext`. # Constraints * The characters in the string must be ASCII-compliant. * The shift value can be any integer (positive or negative). # Example ```python >>> shift_cipher(\\"abc\\", 3) \\"def\\" >>> shift_cipher(\\"ABC\\", 3) \\"DEF\\" >>> shift_cipher(\\"xyz\\", 4) \\"bcd\\" >>> shift_cipher(\\"XYZ\\", 4) \\"BCD\\" >>> shift_cipher(\\"Hello, World!\\", 5) \\"Mjqqt, Btwqi!\\" >>> shift_cipher(\\"Hello, World!\\", -5) \\"Czggj, Rjmgy!\\" >>> shift_cipher(\\"1234\\", 2) \\"1234\\" >>> shift_cipher(\\"abc\\", \\"a\\") # Invalid input example Traceback (most recent call last): ... ValueError: Plaintext must contain only ASCII characters ``` # Notes * Ensure your implementation runs efficiently and the time complexity is O(n), where n is the length of the plaintext. * Proper validation should be performed to ensure the input constraints are met. * Consider edge cases where shift values may require wrapping around the alphabet.","solution":"import string def shift_cipher(plaintext: str, shift: int) -> str: Encrypt the plaintext using a shift cipher. :param plaintext: The input string to be encrypted. :param shift: The number of places to shift each letter (positive for right shift, negative for left shift). :return: The encrypted string after applying the shift cipher. :raises ValueError: If the plaintext contains non-ASCII characters. if not all(ord(char) < 128 for char in plaintext): raise ValueError(\\"Plaintext must contain only ASCII characters\\") encrypted_text = [] for char in plaintext: if char.isalpha(): alphabet = string.ascii_lowercase if char.islower() else string.ascii_uppercase index = (alphabet.index(char) + shift) % 26 encrypted_text.append(alphabet[index]) else: encrypted_text.append(char) return \'\'.join(encrypted_text)"},{"question":"# Question: Implement a User Engagement Analyzer Based on Event Data Your task is to implement a function that analyzes user engagement by evaluating event participation rates using provided historical data. The function should determine the percentage of users participating in events and evaluate the stability of user engagement over a given period. Function Specifications 1. **Function Signature** ```python def user_engagement_analyzer( train_dates: list, train_users: list, train_events: list, analyze_date: int, threshold: float = 0.05 ) -> tuple: ``` 2. **Input** - `train_dates`: List of historical dates (e.g., [1, 2, 3, ...]). - `train_users`: List of number of users corresponding to `train_dates`. - `train_events`: List of number of events corresponding to `train_dates`. - `analyze_date`: Specific date to analyze user engagement. - `threshold` (optional): Float indicating the threshold for determining stability (default is 0.05). 3. **Output** - A tuple containing: - Engagement percentages for each date in `train_dates`. - A boolean indicating whether user engagement is stable based on the given threshold. Constraints - The length of `train_dates`, `train_users`, and `train_events` will be equal. - The analysis for `analyze_date` must be contained within `train_dates`. - `train_dates`, `train_users`, and `train_events` will contain at least 4 values. Performance Requirements - The implementation should work efficiently for input data up to 1000 elements. Edge Cases to Consider - Dates with zero users. - Ensure the stability evaluation handles small variations gracefully. - Floating-point calculations should be accurate within a tolerance of 1e-6. Example ```python # Given historical data train_dates = [1, 2, 3, 4] train_users = [100, 150, 120, 130] train_events = [40, 60, 50, 55] # Analyze engagement on a specific date analyze_date = 3 # Call the function engagement_percentages, is_stable = user_engagement_analyzer(train_dates, train_users, train_events, analyze_date) # Expected output print(engagement_percentages) # Example: [0.4, 0.4, 0.4167, 0.4231] print(is_stable) # Example: True or False ```","solution":"def user_engagement_analyzer(train_dates, train_users, train_events, analyze_date, threshold=0.05): # Calculate the engagement percentages engagement_percentages = [ events / users if users != 0 else 0 for users, events in zip(train_users, train_events) ] # Calculate the average engagement avg_engagement = sum(engagement_percentages) / len(engagement_percentages) # Find the index of the analyze_date date_index = train_dates.index(analyze_date) # Determine the stability of engagement stable = all( abs(engagement - avg_engagement) <= threshold for i, engagement in enumerate(engagement_percentages) if i != date_index # Exclude the analyze date itself ) return engagement_percentages, stable"},{"question":"# Question: Design a class that constructs a special type of linked list, called a \\"Skip List,\\" which supports efficient lookup, insertion, and deletion operations. The Skip List should be able to perform these operations in O(log n) time on average. The Skip List must support the following operations: - `insert(value)`: Inserts a value into the Skip List. - `exists(value)`: Checks if a value exists in the Skip List. - `delete(value)`: Removes a value from the Skip List if it exists. **Requirements**: - Implement the class `SkipList` to support the Skip List operations. - The internal structure should maintain multiple levels for fast traversal. **Input/Output**: - `insert(value: int) -> None` - `exists(value: int) -> bool` - `delete(value: int) -> None` **Constraints**: - The values will be in the range of [1, 10^6]. - The number of operations `insert`, `exists`, and `delete` will be in the range [1, 10^5]. **Example**: ```python skip_list = SkipList() skip_list.insert(3) skip_list.insert(6) skip_list.insert(7) skip_list.insert(9) skip_list.insert(12) skip_list.insert(19) skip_list.insert(17) skip_list.insert(26) skip_list.insert(21) skip_list.insert(25) print(skip_list.exists(19)) # returns True print(skip_list.exists(15)) # returns False skip_list.delete(19) print(skip_list.exists(19)) # returns False skip_list.insert(15) print(skip_list.exists(15)) # returns True ``` **Challenge**: Implement the `SkipList` class ensuring the skip list operations are performed efficiently while maintaining the average time complexity constraints.","solution":"import random class Node: def __init__(self, value, level): self.value = value self.forward = [None] * (level + 1) class SkipList: def __init__(self, max_level): self.max_level = max_level self.header = Node(None, max_level) self.level = 0 def random_level(self): level = 0 while random.randint(0, 1) and level < self.max_level: level += 1 return level def insert(self, value): update = [None] * (self.max_level + 1) current = self.header for i in range(self.level, -1, -1): while current.forward[i] and current.forward[i].value < value: current = current.forward[i] update[i] = current current = current.forward[0] if current is None or current.value != value: new_level = self.random_level() if new_level > self.level: for i in range(self.level + 1, new_level + 1): update[i] = self.header self.level = new_level new_node = Node(value, new_level) for i in range(new_level + 1): new_node.forward[i] = update[i].forward[i] update[i].forward[i] = new_node def exists(self, value): current = self.header for i in range(self.level, -1, -1): while current.forward[i] and current.forward[i].value < value: current = current.forward[i] current = current.forward[0] return current is not None and current.value == value def delete(self, value): update = [None] * (self.max_level + 1) current = self.header for i in range(self.level, -1, -1): while current.forward[i] and current.forward[i].value < value: current = current.forward[i] update[i] = current current = current.forward[0] if current is not None and current.value == value: for i in range(self.level + 1): if update[i].forward[i] != current: break update[i].forward[i] = current.forward[i] while self.level > 0 and self.header.forward[self.level] is None: self.level -= 1"},{"question":"# Largest Network of Friends You are tasked with finding the largest network of friends from a given list of friendships. Each friendship is a bidirectional relationship between two people. Input - `friendships`: A list of tuples, where each tuple `(a, b)` represents a friendship between person `a` and person `b`. Output - Return an integer representing the size of the largest group of friends. Example ```python def largest_network(friendships: list[tuple[int, int]]) -> int: # Your implementation here friendships = [(1, 2), (2, 3), (4, 5), (5, 6), (1, 3)] print(largest_network(friendships)) # 3 (Friends network: 1-2-3) friendships = [(1, 2), (3, 4), (4, 5)] print(largest_network(friendships)) # 3 (Friends network: 3-4-5) ``` # Constraints - The list of friendships will contain at most 100 pairs. - Each person is represented by an integer between 1 and 100. # Performance Requirement - The function should be optimized for time complexity, considering the constraints of up to 100 individuals and 100 friendships. # Detailed Requirements - Implement helper functions such as `bfs` (breadth-first search) or `dfs` (depth-first search) to explore connected components in the network. - Ensure the function handles edge cases such as multiple small groups and isolated individuals. - Focus on optimizing the traversal of the network to minimize redundant checks and utilize efficient data structures like sets and dictionaries for tracking visited nodes. Showcase your solution by demonstrating the ability to identify and return the size of the largest connected group of friends. Validate your solution with the provided example tests.","solution":"def largest_network(friendships: list[tuple[int, int]]) -> int: from collections import defaultdict, deque def bfs(start, adj_list, visited): queue = deque([start]) visited.add(start) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return count # Build the adjacency list adj_list = defaultdict(list) for a, b in friendships: adj_list[a].append(b) adj_list[b].append(a) # Track visited nodes visited = set() largest_component_size = 0 for person in adj_list: if person not in visited: component_size = bfs(person, adj_list, visited) largest_component_size = max(largest_component_size, component_size) return largest_component_size"},{"question":"# Question: Evaluate Reverse Polish Notation with Custom Operators You are given an expression in Reverse Polish Notation (RPN) that includes custom operators. In RPN, the operator follows the operands, for example, `3 4 +` is equivalent to `3 + 4`. # Your Task Implement the function `evaluate_custom_rpn(expression: List[str], operators: Dict[str, Callable[[int, int], int]]) -> int`. The function should evaluate the given RPN expression using the provided custom operators and return the result. **Requirements:** 1. The function should be capable of dynamically handling the custom operators defined in the `operators` dictionary. 2. The custom operators dictionary keys are the operator symbols, and the values are functions that take two integers and return an integer. # Input Format - **expression**: A list of strings representing the RPN expression. - **operators**: A dictionary where keys are operator symbols (strings) and values are functions that take two integer arguments and return an integer. # Output Format Return an integer which is the result of evaluating the RPN expression using the provided custom operators. # Constraints 1. The expression will be a valid RPN expression. 2. The operators dictionary will not be empty and will always provide valid functions. # Example ```python def evaluate_custom_rpn(expression: List[str], operators: Dict[str, Callable[[int, int], int]]) -> int: >>> from operator import add, sub, mul, truediv >>> expression = [\\"2\\", \\"3\\", \\"+\\", \\"5\\", \\"*\\"] >>> operators = {\\"+\\": add, \\"-\\": sub, \\"*\\": mul, \\"/\\": truediv} >>> evaluate_custom_rpn(expression, operators) 25 >>> expression = [\\"10\\", \\"2\\", \\"/\\", \\"3\\", \\"-\\"] >>> evaluate_custom_rpn(expression, operators) 2 pass ``` **Notes**: - Ensure robust handling of all provided operators, even unusual or unconventional ones. - You can assume the input is always valid, and there will be no division by zero or similar edge cases where an operation cannot be performed. # Submission Complete the function `evaluate_custom_rpn` as specified above to evaluate the given RPN expression using the custom operators.","solution":"from typing import List, Dict, Callable def evaluate_custom_rpn(expression: List[str], operators: Dict[str, Callable[[int, int], int]]) -> int: Evaluates a Reverse Polish Notation expression with custom operators. Args: expression (List[str]): A list of strings representing the RPN expression. operators (Dict[str, Callable[[int, int], int]]): A dictionary of operators and their corresponding functions. Returns: int: The result of evaluating the RPN expression. stack = [] for token in expression: if token in operators: # It\'s an operator, pop the last two elements from the stack. b = stack.pop() a = stack.pop() # Apply the operation and push the result back to the stack. result = operators[token](a, b) stack.append(result) else: # It\'s a number, push it to the stack. stack.append(int(token)) # The final result should be the only element left in the stack. return stack.pop()"},{"question":"Python Memory Management with Custom Reference Counting Given the implementation of a custom reference counter for memory management, complete the provided functions for incrementing and decrementing reference counts, as well as for garbage collecting objects when their reference count drops to zero. Implement the `inc_ref`, `dec_ref` and `collect_garbage` functions. Function Signature ```python def inc_ref(obj: str) -> None: pass def dec_ref(obj: str) -> None: pass def collect_garbage() -> None: pass ``` Inputs - `obj (str)`: A string representing the memory object being referenced. Outputs - `inc_ref`: Increment the reference count for the given object. If the object is not already tracked, initialize its reference count to 1. - `dec_ref`: Decrement the reference count for the given object. If the reference count drops to 0, the object should be marked for garbage collection. - `collect_garbage`: Remove all objects marked for garbage collection from memory. Implementation Details 1. Maintain a global dictionary to track reference counts of objects. 2. Reference counts: - Increment when `inc_ref` is called. - Decrement when `dec_ref` is called. - If a reference count decrements to 0, the object should be removed from the dictionary upon garbage collection. 3. `collect_garbage` should remove objects with a reference count of 0. Example ```python def inc_ref(obj: str) -> None: global ref_counts if obj in ref_counts: ref_counts[obj] += 1 else: ref_counts[obj] = 1 def dec_ref(obj: str) -> None: global ref_counts if obj in ref_counts: ref_counts[obj] -= 1 if ref_counts[obj] == 0: collect_garbage() else: raise ValueError(\\"Object not found in reference counter.\\") def collect_garbage() -> None: global ref_counts to_delete = [obj for obj, count in ref_counts.items() if count == 0] for obj in to_delete: del ref_counts[obj] # Example Test Case ref_counts = {} inc_ref(\\"object1\\") inc_ref(\\"object1\\") dec_ref(\\"object1\\") print(ref_counts) # Output: {\'object1\': 1} dec_ref(\\"object1\\") print(ref_counts) # Output: {} ``` Constraints - The `obj` input will only consist of ASCII characters. - There will be no duplicate `obj` strings provided to `inc_ref` consecutively without a corresponding `dec_ref` call. # Hints 1. Use a global dictionary `ref_counts` to maintain the reference count of objects. 2. Implement necessary checks to ensure an object\'s reference count does not fall below zero. 3. The garbage collection should only remove objects that have a reference count of zero.","solution":"ref_counts = {} def inc_ref(obj: str) -> None: global ref_counts if obj in ref_counts: ref_counts[obj] += 1 else: ref_counts[obj] = 1 def dec_ref(obj: str) -> None: global ref_counts if obj in ref_counts: ref_counts[obj] -= 1 if ref_counts[obj] == 0: collect_garbage() else: raise ValueError(\\"Object not found in reference counter.\\") def collect_garbage() -> None: global ref_counts to_delete = [obj for obj, count in ref_counts.items() if count == 0] for obj in to_delete: del ref_counts[obj]"},{"question":"# Question: Implement In-order Traversal of a Binary Tree Write a function to perform an in-order traversal of a binary tree. The function should return a list of values in the order they were visited. # Function Signature: You need to write the following function: ```python def inorder_traversal(root: Optional[TreeNode]) -> List[int]: pass ``` # Input: - `root` (TreeNode or None): The root node of the binary tree. # Output: - Returns a list of integers representing the in-order traversal of the tree. # Constraints: - The number of nodes in the tree is in the range [0, 1000]. - -100 ≤ Node.val ≤ 100 # Requirements: - The function should handle trees with no nodes (empty tree). - Ensure the function works efficiently with the given constraints. - The implementation should not use recursion due to potential stack overflow issues on larger trees. # Example: ```python # Example 1: # Input: [1, null, 2, 3] # The binary tree is as follows: # 1 # # 2 # / # 3 # Output: [1, 3, 2] # Example 2: # Input: [] # Output: [] # Example 3: # Input: [1] # Output: [1] ``` ```python # Example Input: tree1 = TreeNode(1, None, TreeNode(2, TreeNode(3))) assert inorder_traversal(tree1) == [1, 3, 2] tree2 = None assert inorder_traversal(tree2) == [] tree3 = TreeNode(1) assert inorder_traversal(tree3) == [1] ```","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: Perform in-order traversal of a binary tree and return the values in a list. result = [] stack = [] current = root while current is not None or stack: # Reach the leftmost Node of the current Node while current is not None: stack.append(current) current = current.left # Current must be None at this point current = stack.pop() result.append(current.val) # We have visited the node and its left subtree. Now, it\'s right subtree\'s turn current = current.right return result"},{"question":"Problem Statement Create a function that implements the A* (A-star) algorithm for finding the shortest path in a grid. The grid is represented as a 2D list of integers, where `0` denotes a walkable cell and `1` denotes an obstacle. The function should find the shortest path from the top-left corner to the bottom-right corner of the grid. If no path exists, the function should return `None`. Diagonal movement is not allowed. # Function Signature ```python def a_star_search(grid: list[list[int]]) -> list[tuple[int, int]] | None: # Your code here ``` # Input * `grid` (list[list[int]]): A 2D list representing the grid, where `0` denotes a walkable cell and `1` denotes an obstacle. The grid has at least one cell (1x1 grid) and is at most 100x100 cells. # Output * `list[tuple[int, int]] | None`: A list of tuples representing the coordinates of the cells in the shortest path from the top-left corner to the bottom-right corner, including both endpoints. If no path is found, return `None`. # Constraints * The grid will not contain any invalid values and will always be rectangular. * The function should handle grids up to 100x100 efficiently. * The function should be able to navigate through typical maze-like structures as well as grids with dense obstacles. # Performance Requirements * Implement the A* search algorithm for optimal pathfinding. * Use an appropriate heuristic, such as the Manhattan distance, for the A* algorithm. * Aim for O(n log n) time complexity, where n is the number of cells in the grid. # Example ```python >>> grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] >>> a_star_search(grid) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3), (3, 3)] >>> grid = [ [0, 1], [1, 0] ] >>> a_star_search(grid) None >>> grid = [ [0, 0], [0, 0] ] >>> a_star_search(grid) [(0, 0), (0, 1), (1, 1)] ``` # Additional Notes * The function should handle edge cases such as small grids (1x1), grids with no obstacles, and grids with no possible paths. * Ensure your implementation is robust and accounts for potential performance bottlenecks in larger grids. * Prefer clear and concise coding practices to facilitate easy understanding and maintenance.","solution":"from heapq import heappop, heappush def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def a_star_search(grid): rows, cols = len(grid), len(grid[0]) start = (0, 0) end = (rows - 1, cols - 1) open_set = [] heappush(open_set, (0 + heuristic(start, end), 0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, end)} while open_set: current = heappop(open_set)[2] if current == end: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]: neighbor = (current[0] + direction[0], current[1] + direction[1]) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, end) heappush(open_set, (f_score[neighbor], tentative_g_score, neighbor)) return None"},{"question":"# Question: Implement a Custom Sorting Algorithm with Pairing Constraint Context: You are working on a data processing task where you need to sort a list of tuples based on a specific constraint. The list consists of pairs, with each pair representing a key-value relationship. Your task is to implement a custom sorting function that sorts the list of tuples primarily by the value in non-decreasing order. If two pairs have the same value, their order should be determined by the key in non-increasing order. # Function Signature ```python def custom_sort(pairs: list) -> list: pass ``` # Requirements 1. **Input**: A list of tuples (`pairs`), where each tuple contains exactly two elements: a key and a value. 2. **Output**: A list of tuples sorted based on the value in non-decreasing order. If values are equal, sort by the key in non-increasing order. 3. **Constraints**: - List must not be empty. - Each tuple must contain exactly two elements. - Both elements in the tuples must be integers or floats. - The list should be non-null. # Error Handling 1. If the input list is None, raise a `ValueError` with the message \\"Input list cannot be None\\". 2. If any tuple does not contain exactly two elements, raise a `ValueError` with the message \\"Each tuple must contain exactly two elements\\". 3. If any input is not a tuple of two numbers, raise a `TypeError` with the appropriate message indicating the type issue. # Examples ```python >>> custom_sort([(1, 2), (2, 1), (3, 1), (1, 3)]) [(3, 1), (2, 1), (1, 2), (1, 3)] >>> custom_sort([(4, 4), (2, 3), (3, 3), (1, 3)]) [(3, 3), (2, 3), (1, 3), (4, 4)] >>> custom_sort([(4.5, 4.5), (2.2, 3.3), (3.3, 3.3), (1.1, 3.3)]) [(3.3, 3.3), (2.2, 3.3), (1.1, 3.3), (4.5, 4.5)] >>> custom_sort([(4, 4, 4), (2, 1)]) Traceback (most recent call last): ... ValueError: Each tuple must contain exactly two elements >>> custom_sort([(4, 4), (2, \\"one\\")]) Traceback (most recent call last): ... TypeError: Expected a tuple of numbers as input, found str >>> custom_sort(None) Traceback (most recent call last): ... ValueError: Input list cannot be None ```","solution":"def custom_sort(pairs: list) -> list: if pairs is None: raise ValueError(\\"Input list cannot be None\\") for pair in pairs: if not isinstance(pair, tuple): raise TypeError(f\\"Expected a tuple as input, found {type(pair).__name__}\\") if len(pair) != 2: raise ValueError(\\"Each tuple must contain exactly two elements\\") if not (isinstance(pair[0], (int, float)) and isinstance(pair[1], (int, float))): raise TypeError(f\\"Expected a tuple of numbers as input, found {type(pair[0]).__name__} and {type(pair[1]).__name__}\\") return sorted(pairs, key=lambda x: (x[1], -x[0]))"},{"question":"Next Smaller Element Given an array of integers, you are required to write a function `next_smaller_elements` to find the next smaller element for each element of the array. The next smaller element for an element `x` is the first smaller element on the right side of `x` in the array. If no such element exists, output -1 for that number. # Function Definition The function should be defined as follows: ```python def next_smaller_elements(arr: list) -> list: Find the next smaller element for each element in the array. Parameters: arr (list): A list of integers Returns: list: A list where each element is the next smaller element of the corresponding input element Raises: ValueError: If the input is not a list of integers ``` # Constraints: - The input `arr` will be a list of integers with a length in the range (0 ≤ len(arr) ≤ 1000). # Example: ```python assert next_smaller_elements([4, 5, 2, 10, 8]) == [2, 2, -1, 8, -1] assert next_smaller_elements([3, 2, 1]) == [2, 1, -1] assert next_smaller_elements([]) == [] assert next_smaller_elements([5, 7, 5, 4]) == [4, 5, 4, -1] assert next_smaller_elements([\'a\', 1, 2]) raises ValueError ``` # Requirements: 1. Implement the function using a stack to ensure an efficient solution. 2. Handle invalid inputs by raising a `ValueError` with an appropriate message. 3. Ensure your function completes within a reasonable time for input length up to 1000. # Additional Information: * The solution must efficiently handle the constraints. * Typical stack-based approach operates in O(n) time complexity.","solution":"def next_smaller_elements(arr): Find the next smaller element for each element in the array. Parameters: arr (list): A list of integers Returns: list: A list where each element is the next smaller element of the corresponding input element Raises: ValueError: If the input is not a list of integers if not isinstance(arr, list): raise ValueError(\\"Input must be a list\\") if not all(isinstance(x, int) for x in arr): raise ValueError(\\"All elements of the list must be integers\\") result = [-1] * len(arr) stack = [] for i in range(len(arr) - 1, -1, -1): while stack and stack[-1] >= arr[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(arr[i]) return result"},{"question":"# Scenario You are developing a search engine, and as part of its core functionalities, you need to implement a spell checker that suggests corrections for misspelled words. One common way to find suggested corrections is to use the Damerau-Levenshtein distance, which measures the minimum number of single-character edits (insertions, deletions, substitutions, or transpositions) required to change one word into another. # Problem Statement **Task**: Implement a function that computes the Damerau-Levenshtein distance between two given strings. # Input & Output **Function Name**: `damerau_levenshtein_distance` **Input**: - `str1`: A string, representing the first word. - `str2`: A string, representing the second word. **Output**: - An integer, representing the Damerau-Levenshtein distance between the two strings. # Constraints - The input strings will contain only lowercase alphabetic characters. - The maximum length of the strings will be 1000 characters. - The implementation should be efficient in terms of both time and space complexity. # Performance Requirements - The solution should have a time complexity of O(N * M) where N and M are the lengths of the two input strings. - The space complexity should be O(N * M). ```python def damerau_levenshtein_distance(str1: str, str2: str) -> int: Compute the Damerau-Levenshtein distance between two strings. len_str1 = len(str1) + 1 len_str2 = len(str2) + 1 # Create a matrix dp = [[0] * len_str2 for _ in range(len_str1)] # Initialize source prefixes to empty target for i in range(len_str1): dp[i][0] = i # Initialize target prefixes to empty source for j in range(len_str2): dp[0][j] = j # Compute Damerau-Levenshtein distance for i in range(1, len_str1): for j in range(1, len_str2): cost = 0 if str1[i-1] == str2[j-1] else 1 # Compute cost for the standard operations deletion = dp[i-1][j] + 1 insertion = dp[i][j-1] + 1 substitution = dp[i-1][j-1] + cost dp[i][j] = min(deletion, insertion, substitution) # Check for transposition if i > 1 and j > 1 and str1[i-1] == str2[j-2] and str1[i-2] == str2[j-1]: dp[i][j] = min(dp[i][j], dp[i-2][j-2] + cost) # Return the distance value return dp[-1][-1] # To test the function print(damerau_levenshtein_distance(\\"kitten\\", \\"sitting\\")) # Expected output: 3 print(damerau_levenshtein_distance(\\"flaw\\", \\"lawn\\")) # Expected output: 2 ```","solution":"def damerau_levenshtein_distance(str1: str, str2: str) -> int: Compute the Damerau-Levenshtein distance between two strings. len_str1 = len(str1) + 1 len_str2 = len(str2) + 1 # Create a matrix dp = [[0] * len_str2 for _ in range(len_str1)] # Initialize source prefixes to empty target for i in range(len_str1): dp[i][0] = i # Initialize target prefixes to empty source for j in range(len_str2): dp[0][j] = j # Compute Damerau-Levenshtein distance for i in range(1, len_str1): for j in range(1, len_str2): cost = 0 if str1[i-1] == str2[j-1] else 1 # Compute cost for the standard operations deletion = dp[i-1][j] + 1 insertion = dp[i][j-1] + 1 substitution = dp[i-1][j-1] + cost dp[i][j] = min(deletion, insertion, substitution) # Check for transposition if i > 1 and j > 1 and str1[i-1] == str2[j-2] and str1[i-2] == str2[j-1]: dp[i][j] = min(dp[i][j], dp[i-2][j-2] + cost) # Return the distance value return dp[-1][-1]"},{"question":"# Question: You are tasked with implementing a function that processes user-inputted transactions and updates a ledger. Your function should follow these steps: 1. Accept a list of transactions where each transaction is represented as a string. 2. Each transaction string contains a command (\\"ADD\\", \\"REMOVE\\", \\"VIEW\\"), followed by the transaction\'s detail. - For \\"ADD\\" commands, the transaction detail includes a unique identifier, description, and amount. - For \\"REMOVE\\" commands, only an identifier is provided to remove the corresponding entry. - For \\"VIEW\\" commands, a view of the current state of the ledger is required. 3. Maintain a ledger using a dictionary where keys are unique identifiers and values are tuples of (description, amount). 4. Implement transaction processing such that: - \\"ADD\\" adds a new entry to the ledger or updates an existing one. - \\"REMOVE\\" deletes an existing entry from the ledger based on the identifier. - \\"VIEW\\" returns a formatted string showing all transactions in the ledger sorted by their identifiers. Your function should handle invalid commands and malformed entries gracefully. # Specifications: * **Function Name**: `process_transactions` * **Inputs**: - `transactions`: A list of strings representing the transactions. * **Outputs**: - A string message indicating the success, failure, or the current state of the ledger. * **Constraints**: - Assume all identifiers are alphanumeric strings. - Transaction descriptions are short strings. - Amounts are non-negative decimals. - The function must handle and report invalid transactions gracefully. # Example: ```python transactions = [ \\"ADD ID12345 Lunch 12.50\\", \\"ADD ID54321 Coffee 3.00\\", \\"REMOVE ID12345\\", \\"VIEW\\", ] print(process_transactions(transactions)) # Possible output: \\"ID54321: Coffee, Amount: 3.00\\" or appropriate error messages if the transactions are invalid. ``` **Note**: Ensure that your function processes transactions in the order they are provided and maintains a correctly updated ledger throughout the operations.","solution":"def process_transactions(transactions): ledger = {} result_string = [] for transaction in transactions: parts = transaction.split() command = parts[0] if command == \\"ADD\\" and len(parts) == 4: identifier, description, amount = parts[1:] try: amount = float(amount) if amount < 0: result_string.append(\\"Error: Amount cannot be negative.\\") else: ledger[identifier] = (description, amount) except ValueError: result_string.append(\\"Error: Invalid amount format.\\") elif command == \\"REMOVE\\" and len(parts) == 2: identifier = parts[1] if identifier in ledger: del ledger[identifier] else: result_string.append(f\\"Error: No entry with identifier \'{identifier}\' found.\\") elif command == \\"VIEW\\" and len(parts) == 1: if ledger: result_string.append(\\", \\".join( [f\\"{id}: {desc}, Amount: {amt:.2f}\\" for id, (desc, amt) in sorted(ledger.items())] )) else: result_string.append(\\"Ledger is empty.\\") else: result_string.append(\\"Error: Invalid transaction format.\\") return \\"n\\".join(result_string)"},{"question":"# Coding Assessment Question **Context**: You are part of a team developing a health monitoring application. As part of the application\'s features, you need to implement a function that calculates the Body Mass Index (BMI) and categorizes it according to standard health guidelines. # Task Write a function `calculate_bmi` that computes the BMI for a given weight in kilograms and height in centimeters and returns both the BMI value and its category based on the World Health Organization\'s (WHO) classification. # Function Signature ```python def calculate_bmi(weight: float, height: float) -> Tuple[float, str]: ``` # Input - `weight` (float): A float representing the user\'s weight in kilograms. - `height` (float): A float representing the user\'s height in centimeters. # Output - Returns a tuple `(bmi, category)`, where: - `bmi` (float): The calculated Body Mass Index. - `category` (str): The BMI category as a string. # Constraints - `weight` should be a positive float. - `height` should be a positive float greater than 0. # BMI Categories - Underweight: BMI < 18.5 - Normal weight: 18.5 <= BMI < 24.9 - Overweight: 25 <= BMI < 29.9 - Obesity: BMI >= 30 # Calculation ```python BMI = weight / (height/100)^2 ``` # Error Handling - Return an appropriate error message if weight or height is non-positive. # Example ```python print(calculate_bmi(70, 175)) ``` Expected Output: ```python (22.86, \'Normal weight\') ``` # Additional Information 1. **Rounding**: Round the BMI to two decimal places for the final output. 2. **Error Messages**: Handle edge cases with clear error messages, e.g., if weight or height are non-positive. 3. **Test Cases**: Ensure your function is tested with a variety of inputs to cover different categories and error scenarios. **Notes**: Ensure compliance with health data privacy standards when integrating this module into larger applications.","solution":"from typing import Tuple def calculate_bmi(weight: float, height: float) -> Tuple[float, str]: if weight <= 0: return (None, \\"Error: Weight must be a positive number\\") if height <= 0: return (None, \\"Error: Height must be a positive number\\") # Convert height from centimeters to meters height_m = height / 100 # Calculate BMI bmi = weight / (height_m ** 2) # Round BMI to two decimal places bmi = round(bmi, 2) # Determine the BMI category if bmi < 18.5: category = \'Underweight\' elif 18.5 <= bmi < 24.9: category = \'Normal weight\' elif 25 <= bmi < 29.9: category = \'Overweight\' else: category = \'Obesity\' return (bmi, category)"},{"question":"# Problem Statement You are given a matrix `grid` representing a rectangular map where: - `0` represents water. - `1` represents land. An island is a group of `1`s (land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The task is to calculate the perimeter of the island. The perimeter is the sum of the lengths of all the edges of the island. # Function Signature ```python def island_perimeter(grid: list[list[int]]) -> int: ``` # Input - `grid`: A 2D list of integers where each value is either `0` or `1`. - The number of rows (`n`) and columns (`m`) will each be in the range `[1, 1000]`. # Output - An integer representing the perimeter of the island. # Example ```python grid = [ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0] ] print(island_perimeter(grid)) # Output: 16 ``` # Constraints - All cells outside the grid boundaries are considered water. - The grid contains exactly one island (i.e., one or more connected land cells). # Performance Requirements - Your solution should run in (O(n times m)) time complexity and use (O(1)) extra space complexity beyond the input grid storage. # Notes - Be sure your implementation works for all edge cases such as a grid consisting entirely of water or completely of land. - You may assume that the input grid is valid and contains exactly one contiguous island.","solution":"def island_perimeter(grid): Calculate the perimeter of the island in the grid. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) perimeter = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: # Start with a perimeter of 4 for each land cell perimeter += 4 # Substract edges where the current cell is connected to another land cell if i > 0 and grid[i-1][j] == 1: # check north perimeter -= 2 if j > 0 and grid[i][j-1] == 1: # check west perimeter -= 2 return perimeter"},{"question":"# Bakery Inventory Management Scenario You\'ve been asked to develop a small inventory management system for a local bakery. The bakery wants to keep track of the quantity of each type of pastry they have, add new types of pastries, update the quantities, and generate a report of their current inventory. Problem Statement Implement a class `BakeryInventory` that: 1. Initializes with an empty dictionary to store the inventory, where keys are pastry names (strings) and values are quantities (integers). 2. Provides the following methods: - `add_pastry(pastry_name: str, quantity: int) -> None`: Adds a new type of pastry to the inventory with the given quantity. If the pastry already exists, it should update the quantity. - `update_quantity(pastry_name: str, quantity: int) -> None`: Updates the quantity of an existing pastry. If the pastry does not exist, it should raise a `ValueError`. - `generate_report() -> str`: Returns a formatted string listing all pastries and their quantities, sorted by pastry name. Input - For `add_pastry`: a string `pastry_name` and an integer `quantity`. - For `update_quantity`: a string `pastry_name` and an integer `quantity`. Output - The `generate_report` method returns a formatted string. Constraints - Pastry names are case-sensitive and unique. - The quantity for any pastry must be a non-negative integer. Example ```python # Create an instance of BakeryInventory inventory = BakeryInventory() # Add and update pastries inventory.add_pastry(\\"Croissant\\", 50) inventory.add_pastry(\\"Baguette\\", 30) inventory.update_quantity(\\"Croissant\\", 20) # Generate and print the report print(inventory.generate_report()) ``` The output should be: ``` Baguette: 30 Croissant: 20 ``` This question is intended to test your understanding of classes, methods, and basic inventory management logic.","solution":"class BakeryInventory: def __init__(self): self.inventory = {} def add_pastry(self, pastry_name: str, quantity: int) -> None: Adds a new type of pastry to the inventory with the given quantity. If the pastry already exists, it updates the quantity. if pastry_name in self.inventory: self.inventory[pastry_name] += quantity else: self.inventory[pastry_name] = quantity def update_quantity(self, pastry_name: str, quantity: int) -> None: Updates the quantity of an existing pastry. If the pastry does not exist, it raises a ValueError. if pastry_name in self.inventory: self.inventory[pastry_name] = quantity else: raise ValueError(f\\"Pastry \'{pastry_name}\' does not exist in the inventory.\\") def generate_report(self) -> str: Returns a formatted string listing all pastries and their quantities, sorted by pastry name. report = [] for pastry in sorted(self.inventory.keys()): report.append(f\\"{pastry}: {self.inventory[pastry]}\\") return \\"n\\".join(report)"},{"question":"# Question: Creating a Simple Key-Value Store with Persistence Context You are required to design and implement a simplified key-value store that supports basic CRUD (Create, Read, Update, Delete) operations with persistent storage. The store should allow storing, retrieving, and updating key-value pairs, and it should save the data to a file so that the data persists even after the program exits. Task Implement the following functions within a Python class `SimpleKVStore`: 1. `__init__(self, storage_file)`: - Initialize the store, loading existing data from the file if it exists. - Input: - `storage_file`: String, file path where the store data will be saved. 2. `set_item(self, key, value)`: - Add a new key-value pair to the store or update the value of an existing key. - Input: - `key`: String, the key to add/update. - `value`: Arbitrary data type, the value to associate with the key. - Output: None. 3. `get_item(self, key)`: - Retrieve the value associated with the given key. - Input: - `key`: String, the key to look up. - Output: The value associated with the key. If the key does not exist, return `None`. 4. `delete_item(self, key)`: - Remove a key-value pair from the store. - Input: - `key`: String, the key to remove. - Output: None. 5. `save(self)`: - Persist the current state of the key-value store to the storage file. - Output: None. 6. `load(self)`: - Load the key-value store data from the storage file. It should be called when initializing the store. - Output: None. Constraints - The key should be unique in the store. - Use appropriate file operations for loading and saving data. - Ensure that the file operations are robust, handling exceptions appropriately. - Implement basic serialization and deserialization for storing and retrieving the data. You may use JSON for this purpose. # Solution Outline ```python import json import os class SimpleKVStore: def __init__(self, storage_file): self.data = {} self.storage_file = storage_file self.load() def set_item(self, key, value): self.data[key] = value self.save() def get_item(self, key): return self.data.get(key, None) def delete_item(self, key): if key in self.data: del self.data[key] self.save() def save(self): try: with open(self.storage_file, \'w\') as f: json.dump(self.data, f) except IOError as e: print(f\\"Error saving data: {e}\\") def load(self): if os.path.exists(self.storage_file): try: with open(self.storage_file, \'r\') as f: self.data = json.load(f) except (IOError, json.JSONDecodeError) as e: print(f\\"Error loading data: {e}\\") # Sample usage: kv_store = SimpleKVStore(\\"kv_store.json\\") kv_store.set_item(\\"key1\\", \\"value1\\") print(kv_store.get_item(\\"key1\\")) # Output: value1 kv_store.delete_item(\\"key1\\") print(kv_store.get_item(\\"key1\\")) # Output: None ```","solution":"import json import os class SimpleKVStore: def __init__(self, storage_file): self.data = {} self.storage_file = storage_file self.load() def set_item(self, key, value): self.data[key] = value self.save() def get_item(self, key): return self.data.get(key, None) def delete_item(self, key): if key in self.data: del self.data[key] self.save() def save(self): try: with open(self.storage_file, \'w\') as f: json.dump(self.data, f) except IOError as e: print(f\\"Error saving data: {e}\\") def load(self): if os.path.exists(self.storage_file): try: with open(self.storage_file, \'r\') as f: self.data = json.load(f) except (IOError, json.JSONDecodeError) as e: print(f\\"Error loading data: {e}\\") # Sample usage: kv_store = SimpleKVStore(\\"kv_store.json\\") kv_store.set_item(\\"key1\\", \\"value1\\") print(kv_store.get_item(\\"key1\\")) # Output: value1 kv_store.delete_item(\\"key1\\") print(kv_store.get_item(\\"key1\\")) # Output: None"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},L={class:"card-container"},O={key:0,class:"empty-state"},R=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",O,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const j=h(N,[["render",D],["__scopeId","data-v-b9642e82"]]),V=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/39.md","filePath":"drive/39.md"}'),Y={name:"drive/39.md"},B=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{V as __pageData,B as default};
