import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},j={class:"review-title"},R={class:"review-content"};function Y(i,e,u,c,s,a){return n(),r("div",q,[t("div",T,[t("div",j,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const I=m(k,[["render",Y],["__scopeId","data-v-1532aacf"]]),F=JSON.parse('[{"question":"You are given a list of `n` movies, where each movie is represented by an integer `duration` which denotes its duration in minutes. Additionally, you have an integer `flightDuration` which represents the total duration of a flight in minutes. You want to watch exactly two different movies on the flight such that the total duration of the two movies is the maximum possible but does not exceed the `flightDuration` minus 30 minutes (because you need 30 minutes for take-off and landing). Return _the indices of the two movies you will watch_. If there are multiple answers, return any one of them. If no such pair of movies exists, return an empty list.","solution":"def find_movies_pair(durations, flightDuration): Returns the indices of the two movies whose total duration is the maximum possible but does not exceed the flightDuration minus 30 minutes. durations: List[int] - List of movie durations in minutes. flightDuration: int - Total duration of the flight in minutes. return: List[int] - Indices of the two movies. max_duration = flightDuration - 30 best_pair = [] best_time = 0 durations_with_indices = list(enumerate(durations)) # Sort the list of movie durations with their corresponding indices durations_with_indices.sort(key=lambda x: x[1]) left, right = 0, len(durations) - 1 while left < right: time_left = durations_with_indices[left][1] time_right = durations_with_indices[right][1] current_time = time_left + time_right if current_time > max_duration: right -= 1 else: if current_time > best_time: best_time = current_time best_pair = [durations_with_indices[left][0], durations_with_indices[right][0]] left += 1 return best_pair"},{"question":"A linked list of integers is given. Write a function that removes all nodes that have duplicate integers, leaving only distinct numbers from the original list. Return the linked list sorted as well. - class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } - For example: Given the linked list `1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5`, return `1 -> 2 -> 5`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_unsorted_linked_list(head): Removes all nodes that have duplicate integers, leaving only distinct numbers from the original list. The list will be sorted in ascending order before returning. if not head: return None # count occurrences of each value count = {} current = head while current: count[current.val] = count.get(current.val, 0) + 1 current = current.next # collect distinct values distinct_values = [val for val, occ in count.items() if occ == 1] # if no distinct values found, return empty list if not distinct_values: return None # sort distinct values distinct_values.sort() # create new linked list new_head = ListNode(distinct_values[0]) current = new_head for val in distinct_values[1:]: current.next = ListNode(val) current = current.next return new_head"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to construct a new string by rearranging the letters of `s` such that no two adjacent characters are the same. If it is not possible to do so, return an empty string. If there are multiple valid rearrangements, return any one of them. Write a function `reorganizeString(s: str) -> str` that achieves the objective.","solution":"import heapq from collections import Counter def reorganizeString(s: str) -> str: Rearranges the string so that no two adjacent characters are the same. If it is not possible, returns an empty string. count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char, prev_freq = char, freq + 1 result_str = \\"\\".join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"You are given a binary tree where each node contains an integer value. A **valid path** is defined as a path that starts at the root and ends at any leaf node, such that the sum of the values along the path is equal to a given integer `targetSum`. Write a function to determine if there exists at least one valid path in the binary tree. Return `true` if such a path exists, otherwise return `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root, targetSum): Determines if there exists a root-to-leaf path in the binary tree that sums to targetSum. Parameters: root (TreeNode): The root of the binary tree. targetSum (int): The sum to check for the valid path. Returns: bool: True if such a path exists, False otherwise. if not root: return False # If we reach a leaf node, check if the remaining targetSum equals the node\'s value if not root.left and not root.right: return root.val == targetSum # Recursively check the left and right subtrees targetSum -= root.val return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"},{"question":"You have a `0-indexed` array of integers `heights` of length `n` representing the heights of buildings. You\'re tasked with determining the number of buildings that have an unobstructed view of the sunrise. A building has an unobstructed view of the sunrise if there is no other building to the left (i.e., towards the 0th index) with a greater or equal height. Return the number of buildings that have an unobstructed view of the sunrise.","solution":"def count_buildings_with_sunrise_view(heights): Returns the number of buildings that have an unobstructed view of the sunrise. if not heights: return 0 max_height = heights[0] count = 1 for i in range(1, len(heights)): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"Given a singly linked list, return the node where the cycle begins. If there is no cycle, return `null`. A cycle is present in a linked list if a node\'s `next` pointer points back to a previous node somewhere in the list. Modify the given linked list only if absolutely necessary. Use O(1) (i.e., constant) memory.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detects the node where the cycle begins in a singly linked list. If there is no cycle, returns null. :param head: ListNode, head of the singly linked list :return: ListNode, node where cycle begins or None if no cycle if not head or not head.next: return None slow = head fast = head has_cycle = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: has_cycle = True break if not has_cycle: return None slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Given a string `str`, return _the longest substring without repeating characters_. Example: if the input string is `\\"abcabcbb\\"`, the output should be `\\"abc\\"`, which has length 3. If the string is empty, return an empty string. If there are multiple longest substrings with the same length, return the one which appears first.","solution":"def longest_substring_without_repeating_characters(s): Returns the longest substring without repeating characters. char_map = {} left = 0 longest = 0 start_index = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right if right - left + 1 > longest: longest = right - left + 1 start_index = left return s[start_index:start_index + longest]"},{"question":"Given an integer array `nums`, return the length of the longest subsequence such that every element in the subsequence is strictly greater than all elements that came before it. The subsequence does not have to be contiguous, but it must maintain the order of appearance of elements in `nums`.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the given list. :param nums: List of integers :return: Integer length of the longest increasing subsequence if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"We are given a sequence of integers representing the heights of buildings in a cityscape. Each building has a unique height. You need to determine the number of buildings that have a direct view of the sunset. A building has a direct view of the sunset if there are no taller buildings to its right. Write a function that returns the number of such buildings. Create a function `sunsetView(buildings: List[int]) -> int` that takes a list of integers `buildings` and returns the number of buildings with a direct view of the sunset.","solution":"def sunsetView(buildings): Returns the number of buildings with a direct view of the sunset. Parameters: buildings (List[int]): List of building heights. Returns: int: Number of buildings with a direct view of the sunset. count = 0 max_height = float(\'-inf\') for height in reversed(buildings): if height > max_height: count += 1 max_height = height return count"},{"question":"Given an integer `n`, return an array `answer` that contains all the integers from `1` to `n` in lexicographical order. Lexicographical order is similar to the dictionary order in which words are arranged. For example, if `n = 13`, the output should be `[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]`.","solution":"def lexical_order(n): Returns a list of integers from 1 to n in lexicographical order. return sorted(range(1, n + 1), key=str)"},{"question":"You are given an array of integers `heights` representing the heights of flower pots placed in a row. Each day, you choose a `left` and `right` index within the array and water all flower pots within this range, inclusive. Any flower pot that has not received water for `k` consecutive days will wilt. Write a function to determine the minimum number of days required to water all flower pots such that none of them wilts. To achieve this, you need to: 1. Find the positions `left` and `right` so that all pots within this range receive water. 2. Ensure that no flower pot has `k` consecutive days of not receiving water. 3. Return the minimum number of days required to water all flower pots to meet the condition. You may assume the array `heights` has at least one flower pot.","solution":"def min_watering_days(heights, k): Determines the minimum number of days required to water all flower pots such that none of them wilts. :param heights: List of integers representing the heights of flower pots. :param k: Integer representing the number of consecutive days a flower pot can go without water before it wilts. :return: Integer representing the minimum number of days required. n = len(heights) # There\'s only one flower pot; we need to water it every k-1 days if n == 1: return 1 days = 0 i = 0 while i < n: days += 1 i += k return days"},{"question":"Given an array of integers `nums`, find all unique triplets in the array which gives the sum of zero. Notice that the solution set must not contain duplicate triplets. Return the solution as a list of lists. For example, if `nums = [-1, 0, 1, 2, -1, -4]`, the unique triplets are: [ [-1, -1, 2], [-1, 0, 1] ].","solution":"def three_sum(nums): Given an array of integers, find all unique triplets which sum to zero. :param nums: List of integers :return: List of unique triplets that sum to zero nums.sort() triplets = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # skip duplicates left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s < 0: left += 1 elif s > 0: right -= 1 else: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # skip duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # skip duplicates left += 1 right -= 1 return triplets"},{"question":"Given a list of strings `words` and a width value `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified. You should pack your words into a series of lines, making sure to adhere to the following rules: * Each word is separated by exactly one space. * Each line should have as many words as possible. * Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. * For the last line of text, it should be left-justified and no extra space is inserted between words. Implement the function `fullJustify(List<String> words, int maxWidth)`, which outputs a list of strings representing the fully justified text.","solution":"def fullJustify(words, maxWidth): def justify_line(line, maxWidth, is_last): if len(line) == 1 or is_last: # For a single word or the last line, left-justify return \' \'.join(line).ljust(maxWidth) total_whitespace = maxWidth - sum(len(word) for word in line) spaces_between_words = len(line) - 1 min_spaces = total_whitespace // spaces_between_words extra_spaces = total_whitespace % spaces_between_words justified = \\"\\" for idx, word in enumerate(line): justified += word if idx < spaces_between_words: justified += \' \' * (min_spaces + (1 if idx < extra_spaces else 0)) return justified result = [] current_line = [] current_length = 0 for word in words: # Check if adding the next word will exceed the maxWidth if current_length + len(word) + len(current_line) > maxWidth: result.append(justify_line(current_line, maxWidth, False)) current_line, current_length = [], 0 current_line.append(word) current_length += len(word) # Justify the last line if current_line: result.append(justify_line(current_line, maxWidth, True)) return result"},{"question":"You are given a **sorted 0-indexed** integer array `arr` and an integer `k`. A **subarray** of `arr` is defined as a contiguous segment of elements within `arr`. Find the maximum possible sum of a subarray with length `k`. Ensure your solution has a time complexity of O(n). If no subarray of length `k` exists, return `0`.","solution":"def max_subarray_sum(arr, k): Returns the maximum possible sum of a subarray with length k. If no subarray of length k exists, returns 0. n = len(arr) if k > n: return 0 current_sum = sum(arr[:k]) max_sum = current_sum for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` consisting of lowercase English letters and an array of integers `indices` where `indices[i]` indicates the position in the string to which the `i-th` character of the string should be shuffled. Shuffle the string according to `indices` and return the resultant shuffled string. For example, suppose `s = \\"abc\\"` and `indices = [2, 0, 1]`, the resultant shuffled string would be `\\"cab\\"` because: - The character at `s[0]` which is \'a\' moves to index 2 in the new string, - The character at `s[1]` which is \'b\' moves to index 0 in the new string, - The character at `s[2]` which is \'c\' moves to index 1 in the new string.","solution":"def shuffle_string(s, indices): Shuffles the string `s` according to the `indices` array. Parameters: s (str): The input string to be shuffled. indices (List[int]): The array of indices representing the new positions of characters in the shuffled string. Returns: str: The shuffled string. shuffled = [\'\'] * len(s) for i, idx in enumerate(indices): shuffled[idx] = s[i] return \'\'.join(shuffled)"},{"question":"Given a list of timestamps in increasing order, represented as strings in the format \\"HH:MM:SS\\", write a function to find the maximum interval between any two consecutive timestamps. Return this interval as a string in the format \\"HH:MM:SS\\". If the list contains fewer than two timestamps, return \\"00:00:00\\". Each timestamp is a valid time in 24-hour format.","solution":"def max_interval(timestamps): Returns the maximum interval between any two consecutive timestamps in the given list. Args: timestamps (list): List of timestamps in the format \\"HH:MM:SS\\". Returns: str: Maximum interval as a string in the format \\"HH:MM:SS\\". if len(timestamps) < 2: return \\"00:00:00\\" max_diff = 0 def time_to_seconds(time_str): h, m, s = map(int, time_str.split(\':\')) return h * 3600 + m * 60 + s def seconds_to_time(seconds): h = seconds // 3600 m = (seconds % 3600) // 60 s = seconds % 60 return f\\"{h:02}:{m:02}:{s:02}\\" for i in range(1, len(timestamps)): t1 = time_to_seconds(timestamps[i-1]) t2 = time_to_seconds(timestamps[i]) diff = t2 - t1 if diff > max_diff: max_diff = diff return seconds_to_time(max_diff)"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house, arranged in a circle. A thief wants to maximize the amount of money he can rob tonight without alerting the police. Given that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night, return the maximum amount of money the thief can rob tonight without alerting the police. Here\'s the twist: since the houses are arranged in a circle, the first house is considered adjacent to the last house, and the thief cannot rob both the first and last house.","solution":"def rob(nums): Returns the maximum amount of money a thief can rob from the circle of houses. def rob_linear(houses): rob1, rob2 = 0, 0 for n in houses: new_rob = max(rob1 + n, rob2) rob1 = rob2 rob2 = new_rob return rob2 if len(nums) == 1: return nums[0] # Exclude the first house or the last house because they can\'t be robbed together return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"Given a binary tree rooted at `root`, where each node has a unique value from `1` to `n`, you are to find the **longest path** such that each node in the path has a **unique value**. A path in the tree is defined as a sequence of nodes starting from any node and moving only to its children or parent (i.e., it doesn\'t need to be confined to any specific direction). Return _the length of the longest path_. Note that the path does not necessarily need to go through the root.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_unique_path(root): def dfs(node): if not node: return 0, set() # Length 0, empty set of values left_length, left_set = dfs(node.left) right_length, right_set = dfs(node.right) current_set = {node.value} # Start with current node\'s value if node.left and node.value not in left_set: current_set.update(left_set) left_length += 1 else: left_length = 1 if node.right and node.value not in right_set: current_set.update(right_set) right_length += 1 else: right_length = 1 max_length = max(left_length, right_length) return max_length, current_set max_path_length, _ = dfs(root) return max_path_length"},{"question":"You are given a robot that is initially located at the origin `(0, 0)` in an infinite 2D grid. The robot can move either up, down, left, or right by one step at a time. The robot needs to reach a target position `(x, y)`. Each step incurs a certain cost: moving left costs `leftCost`, moving right costs `rightCost`, moving up costs `upCost`, and moving down costs `downCost`. Given the coordinates of the target position `x` and `y`, and the respective movement costs, return _the minimum cost required for the robot to reach the target position_.","solution":"def min_cost_to_reach_target(x, y, leftCost, rightCost, upCost, downCost): Calculate the minimum cost for the robot to reach the target position (x, y) from the origin (0, 0). Parameters: x (int): The X-coordinate of the target position. y (int): The Y-coordinate of the target position. leftCost (int): Cost of moving left. rightCost (int): Cost of moving right. upCost (int): Cost of moving up. downCost (int): Cost of moving down. Returns: int: The minimum cost to reach the target position. total_cost = 0 # Move horizontally if x > 0: total_cost += x * rightCost else: total_cost += abs(x) * leftCost # Move vertically if y > 0: total_cost += y * upCost else: total_cost += abs(y) * downCost return total_cost"},{"question":"You are given a list of `n` tasks, where each task `tasks[i]` has a duration denoted by `tasks[i].duration` and a deadline denoted by `tasks[i].deadline`. You need to schedule the tasks in such a way that the total lateness is minimized. The lateness of a task `i` is defined as the amount of time the task completes after its deadline, i.e., if task `i` starts at time `s_i` and ends at time `e_i`, then lateness `L` of task `i` is `max(0, e_i - tasks[i].deadline)`. Return _a 1-indexed array_ `order` _representing the sequence in which the tasks should be executed to achieve the minimum total lateness_. The `order` array should consist of integer indices, where `order[i]` is the index of the `task` to be scheduled at the `i-th` position.","solution":"def minimize_total_lateness(tasks): Returns the order of tasks that minimizes the total lateness. Parameters: tasks (list): List of dictionaries where each dictionary represents a task with \'duration\' and \'deadline\'. Returns: list: A 1-indexed list of task indices representing the order. # Sort tasks by deadlines sorted_tasks = sorted(enumerate(tasks), key=lambda x: x[1][\'deadline\']) # Extract the original indices (1-indexed) of the sorted tasks order = [task[0] + 1 for task in sorted_tasks] return order"},{"question":"Given an array of integers `arr`, return the **length of the longest subsequence** that is a bitonic sequence. A sequence is bitonic if it is first increasing and then decreasing. A strictly increasing or strictly decreasing sequence is also considered a bitonic sequence. For example, for the array `[1, 2, 3, 4, 3, 2, 1]`, the function should return `7` because the entire array itself is bitonic. However, for the array `[1, 11, 2, 10, 4, 5, 2, 1]`, the function should return `6` because the longest bitonic sequence is `[1, 2, 10, 4, 2, 1]`.","solution":"def longest_bitonic_subsequence(arr): n = len(arr) if n == 0: return 0 # Initialize the increasing subsequence table inc = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: inc[i] = max(inc[i], inc[j] + 1) # Initialize the decreasing subsequence table dec = [1] * n for i in reversed(range(n-1)): for j in reversed(range(i, n)): if arr[i] > arr[j]: dec[i] = max(dec[i], dec[j] + 1) # Calculate the length of the longest bitonic subsequence max_length = 0 for i in range(n): max_length = max(max_length, inc[i] + dec[i] - 1) return max_length"},{"question":"Given an array of integers `heights` representing the height of buildings from left to right, return the list of indices of buildings that can see the sunset. A building can see the sunset if it is taller than all the buildings to its right. The order of indices in the output list should be from left to right. Example: ``` Input: heights = [3, 7, 8, 3, 6, 1] Output: [2, 4, 5] Explanation: Building at index 2 (height 8) can see the sunset because there are no taller buildings to its right. Similarly, buildings at indices 4 and 5 can see the sunset. ```","solution":"def buildings_with_sunset_view(heights): Return the list of indices of buildings that can see the sunset. A building can see the sunset if it is taller than all the buildings to its right. Args: heights (list[int]): List of building heights. Returns: list[int]: List of indices of buildings that can see the sunset. n = len(heights) result = [] max_height_from_right = float(\'-inf\') # Traverse the array from right to left for i in range(n-1, -1, -1): if heights[i] > max_height_from_right: result.append(i) max_height_from_right = heights[i] # Reverse to get indices in order from left to right result.reverse() return result"},{"question":"You are given a string `s` that represents a compressed version of a string where each character can be followed by a positive integer indicating the number of times it is repeated. You need to decompress this string and return the resulting expanded string. The format of the string is such that each character in the string is either an alphabet character or a digit representing the count of the preceding character. The characters are always lowercase letters. For example, for the input `s = \\"a2b3\\"`, the output should be \\"aabbb\\".","solution":"def decompress_string(s): Decompress a compressed string where each character can be followed by a positive integer indicating the number of times it is repeated. :param s: Compressed input string :return: Decompressed output string decompressed = [] i = 0 while i < len(s): if s[i].isalpha(): char = s[i] count = 0 i += 1 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 if count == 0: decompressed.append(char) else: decompressed.append(char * count) else: i += 1 return \'\'.join(decompressed)"},{"question":"Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the `WordDictionary` class: - `WordDictionary()` Initializes the object. - `void addWord(word)` Adds a word to the data structure. - `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. A word could contain the \'.\' character to represent any one letter. For example: ``` addWord(\\"bad\\") addWord(\\"dad\\") addWord(\\"mad\\") search(\\"pad\\") -> false search(\\"bad\\") -> true search(\\".ad\\") -> true search(\\"b..\\") -> true ```","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: import re # Convert the word to a regex pattern pattern = \'^\' + word.replace(\'.\', \'[a-z]\') + \'\' regex = re.compile(pattern) return any(regex.match(w) for w in self.words)"},{"question":"Given a binary tree with `n` nodes, where each node contains a value from `0` to `9`. Return the sum of all the numbers formed by the root-to-leaf paths in the tree. Each root-to-leaf path represents a number formed by concatenating the values of the nodes along the path. If the tree is empty, return `0`. A **binary tree** is defined as a tree where each node has at most two children. Note: A **leaf** is a node with no children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Returns the sum of all numbers formed by root-to-leaf paths in the binary tree. def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: # If leaf node return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"You are given a string `s` consisting of `n` integers separated by commas, representing coin denominations. Write a function to determine the minimum number of coins needed to make an amount `m` using the denominations given in `s`. If it is not possible to make the amount `m` with the given denominations, return -1. The function should be optimized for performance with respect to the given constraints.","solution":"def min_coins(s, m): Determines the minimum number of coins needed to make amount m using the given denominations. :param s: A string of integers separated by commas representing coin denominations. :param m: The amount to form using the coins. :return: Minimum number of coins needed to make the amount m, or -1 if it\'s not possible. coins = list(map(int, s.split(\',\'))) n = len(coins) # Create a table to store the minimum number of coins for values from 0 to m dp = [float(\'inf\')] * (m + 1) dp[0] = 0 # base case: 0 coins are needed to make 0 amount # Update dp table for each coin available for coin in coins: for x in range(coin, m + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[m] if dp[m] != float(\'inf\') else -1"},{"question":"Given a linked list, determine if it has a cycle in it. For this assignment, assume the linked list could be either singly or doubly linked. To represent the existence of a cycle, we use the `next` pointer of a node to point back to one of the previous nodes in the list. Return `true` if there is a cycle in the linked list. Otherwise, return `false`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head): Determines if a linked list has a cycle. :param head: Head node of the linked list :return: True if there is a cycle, False otherwise if not head: return False slow = head fast = head.next while fast and fast.next: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"Given an array of integers `heights` representing the height of buildings standing in a row, each building is 1 unit wide. Suppose it\'s raining, and the buildings form a series of valleys and peaks. You need to calculate how much water would be trapped between these buildings after it rains. Write a function to compute and return the total amount of trapped water.","solution":"def trap_rainwater(heights): Function to calculate the total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"You are given an array of integers `heights` representing the height of each person in a queue. You are also given an array of integers `inFront`, where `inFront[i]` is the number of people in front of the `i`th person who have a height greater than or equal to `heights[i]`. Write an algorithm to reconstruct the queue based on these two arrays and return the reconstructed queue. The output should be a 2D list where each element is a list containing a height followed by the corresponding inFront value.","solution":"def reconstructQueue(heights, inFront): Reconstructs the queue based on the heights and inFront arrays. :param heights: List[int], list of heights of people :param inFront: List[int], list of number of people in front with height greater than or equal to corresponding height :return: List[List[int]], reconstructed queue # Creating the array of people with (height, inFront) people = sorted(zip(heights, inFront), key=lambda x: (-x[0], x[1])) # Reconstructing the queue queue = [] for height, front in people: queue.insert(front, [height, front]) return queue"},{"question":"You are given an integer array `nums` of size `n`, where each element in the array represents the number of apples present in a basket. Also, you have an integer `k` representing the maximum number of baskets you can select. Your task is to maximize the total number of apples you can collect by selecting up to `k` baskets. Return the maximum number of apples that can be collected by selecting up to `k` baskets.","solution":"def max_apples(nums, k): Returns the maximum number of apples that can be collected by selecting up to k baskets. # Sort the array in descending order to pick the baskets with the most apples nums.sort(reverse=True) # Select the top k baskets return sum(nums[:k])"},{"question":"Given two strings `word1` and `word2`, return the length of their longest common subsequence. If there is no common subsequence, return `0`.","solution":"def longest_common_subsequence(word1, word2): Returns the length of the longest common subsequence between word1 and word2. m, k = len(word1), len(word2) dp = [[0] * (k + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, k + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][k]"},{"question":"You are given a list of strings `words` and a target string `target`. Each string in `words` and the `target` string consists of lowercase English letters. You need to form the `target` string by concatenating strings from the list `words`. You can use each string in `words` as many times as necessary. Return _the **minimum** number of strings from `words` required to form the `target` string_. If it is not possible to form the `target` string, return `-1`.","solution":"def min_words_to_form_target(words, target): Function to find the minimum number of strings from \'words\' required to form \'target\'. Each string from \'words\' can be used multiple times. If it is not possible to form \'target\', return -1. from collections import defaultdict, deque n = len(target) # Cache for minimum words needed for each substring of target ending at each character dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # Base case, 0 words needed to form the empty substring # Preprocessing: map every character in target to positions where it occurs char_positions = defaultdict(list) for i, char in enumerate(target): char_positions[char].append(i) # Use BFS to find the minimum number of words needed to form each prefix of the target queue = deque([(0, 0)]) # (current index in target, number of words used) while queue: current_index, num_words = queue.popleft() if current_index == n: return num_words for word in words: match_length = len(word) if target[current_index:current_index + match_length] == word: new_index = current_index + match_length if new_index <= n and dp[new_index] > num_words + 1: dp[new_index] = num_words + 1 queue.append((new_index, num_words + 1)) return dp[n] if dp[n] != float(\'inf\') else -1"},{"question":"You are given a 2D integer array `matrix` representing a matrix of size `m x n`, and an integer `k`. Your task is to find the `kth` smallest element in the sorted order of all elements in the matrix. Each row and each column of the matrix is sorted in non-decreasing order. Return the `kth` smallest element.","solution":"import heapq def kth_smallest(matrix, k): Finds the kth smallest element in the sorted order of all elements in a sorted m x n matrix. Args: matrix (List[List[int]]): 2D list of integers, with each row and column sorted in non-decreasing order. k (int): The kth smallest element to find. Returns: int: The kth smallest element in the sorted order of the matrix. min_heap = [] n = len(matrix) # Build a list of the smallest element from each row along with their coordinates. for r in range(min(k, n)): # No need to consider more than k rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Remove the smallest element from the heap k times while k: element, r, c = heapq.heappop(min_heap) # If there\'s a next element in the row of the current smallest element, add it to the heap. if c < n - 1: heapq.heappush(min_heap, (matrix[r][c+1], r, c+1)) k -= 1 return element"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `k`. Your goal is to partition the array into contiguous subarrays such that the sum of the largest elements in each subarray is maximized. The number of contiguous subarrays should be exactly `k`. Return _an integer denoting the maximum possible sum of the largest elements in each subarray_. If it\'s not possible to partition `nums` into exactly `k` subarrays, return `-1`.","solution":"def max_sum_of_k_subarray_max_elements(nums, k): if k > len(nums): return -1 # Dynamic programming approach n = len(nums) dp = [[float(\'-inf\')] * (k + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n + 1): for j in range(1, k + 1): current_max = float(\'-inf\') for m in range(i, 0, -1): current_max = max(current_max, nums[m - 1]) if dp[m - 1][j - 1] != float(\'-inf\'): dp[i][j] = max(dp[i][j], dp[m - 1][j - 1] + current_max) return dp[n][k] if dp[n][k] != float(\'-inf\') else -1"},{"question":"In an ancient kingdom, there is a respected tradition of holding archery tournaments. The kingdom has `n` towns, and each town `i` needs to send archers to the tournament. The number of archers sent from town `i` is given by `archers[i]`. Since the tournament is prestigious, the archers must arrive in increasing order of their town IDs. However, due to logistic reasons, each town\'s archers can only move to the adjacent town or stay in the current town. Moving archers costs resources, and the cost of moving one archer from town `i` to town `i+1` is `cost[i]`, and the cost from town `i` to town `i-1` is also `cost[i-1]`. Your task is to determine the minimum total cost for distributing the archers such that each town\'s archer count is non-decreasing. You are given an integer array `archers` of size `n` where `archers[i]` represents the number of archers in the `i`-th town, and an integer array `cost` of size `n-1` where `cost[i]` represents the cost to move an archer between town `i` and town `i+1`. Return _the minimum total cost for aligning the archers in non-decreasing order of towns_.","solution":"def minimum_moving_cost(archers, cost): Determines the minimum total cost to distribute archers to ensure non-decreasing order of archer counts. :param archers: List[int] - number of archers in each town :param cost: List[int] - cost to move an archer between adjacent towns :return: int - minimum total cost for non-decreasing order of archer counts n = len(archers) if n == 0: return 0 # Minimum cost calculation is based on dynamic programming dp = [float(\'inf\')] * n dp[0] = 0 # No cost to align archers in the first town for i in range(1, n): if archers[i] >= archers[i - 1]: dp[i] = dp[i - 1] if archers[i] < archers[i - 1]: dp[i] = min(dp[i], dp[i - 1] + cost[i - 1]) return dp[-1]"},{"question":"You are given an array of integers `arr`, which represents a sequence of numbers. Define a **bitonic sequence** as a sequence which first increases and then decreases. A strictly increasing or decreasing sequence is also considered bitonic. Your task is to find the length of the longest bitonic subsequence in `arr`. You may assume that the sequence always has at least one bitonic subsequence. Return _the length of the longest bitonic subsequence_.","solution":"def longest_bitonic_subsequence(arr): n = len(arr) if n == 0: return 0 inc = [1] * n dec = [1] * n # prepare increasing subsequence array for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: inc[i] = max(inc[i], inc[j] + 1) # prepare decreasing subsequence array for i in range(n - 2, -1, -1): for j in range(n - 1, i, -1): if arr[i] > arr[j]: dec[i] = max(dec[i], dec[j] + 1) # find the maximum value of (inc[i] + dec[i] - 1) max_len = 1 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"Given a string `s` consisting of the characters \'a\', \'b\', and \'c\', return _the minimum number of characters you need to delete_ to make the string a valid sequence. A valid sequence is defined as a string where no three consecutive characters are the same.","solution":"def min_deletions_to_make_valid(s): Returns the minimum number of characters that need to be deleted to make the string a valid sequence. A valid sequence is defined as a string where no three consecutive characters are the same. deletions = 0 n = len(s) # Iterate over the string and check for three consecutive characters. i = 0 while i < n - 2: if s[i] == s[i+1] == s[i+2]: deletions += 1 i += 1 # Skip one character else: i += 1 return deletions"},{"question":"You are given an integer array `heights` representing the heights of plants in a garden. A gardener has tools to trim the height of any plant by 1 unit per operation. However, the gardener can choose to perform this operation on a single plant, or on every plant within a contiguous subarray. Return the **minimum number of operations** required to make all the plants in the garden have the same height.","solution":"def min_operations_to_equal_height(heights): Returns the minimum number of operations required to make all the plants in the garden have the same height. :param heights: List[int] - heights of the plants :return: int - minimum number of operations max_height = max(heights) operations = 0 for height in heights: operations += max_height - height return operations"},{"question":"You are given an array of integers `nums` and an integer `k`. You need to determine if there is a pair of indices `(i, j)` such that `i != j` and the sum of `nums[i]` and `nums[j]` is divisible by `k`. If such a pair exists, return `true`; otherwise, return `false`.","solution":"def has_pair_with_sum_divisible_by_k(nums, k): Determine if there is a pair of indices (i, j) such that i != j and the sum of nums[i] and nums[j] is divisible by k. :param nums: List[int] - List of integers :param k: int - The divisor :return: bool - True if such a pair exists, False otherwise if k == 0: return False # Division by zero is not defined remainders = {} for num in nums: remainder = num % k if remainder in remainders: return True complement = (k - remainder) % k remainders[complement] = True return False"},{"question":"You are given a string `s` and an array of integers `queries` where each `queries[i] = [start, end, threshold]`. For each query, you need to determine if the substring of `s` that starts at index `start` and ends at index `end` (inclusive) has any character that appears at least `threshold` times. Return an array of booleans corresponding to each query, where each boolean value indicates whether the substring meets the threshold condition.","solution":"def substring_threshold(s, queries): Determine if each substring defined in queries has any character that appears at least \'threshold\' times. Parameters: s (str): The input string queries (List[List[int]]): A list of queries, each with [start, end, threshold] Returns: List[bool]: A list of booleans corresponding to each query, indicating if the condition is met. result = [] for start, end, threshold in queries: substring = s[start:end+1] # Count the frequency of each character in the substring freq = {} for char in substring: if char in freq: freq[char] += 1 else: freq[char] = 1 # Check if any character exceeds or meets the threshold meets_threshold = any(count >= threshold for count in freq.values()) result.append(meets_threshold) return result"},{"question":"You are given a **0-indexed** binary matrix `board` with dimensions `m x n` representing a rectangular board game. Each cell in the board can either be `0` (empty) or `1` (occupied by a game piece). You are also given a piece represented as a list of coordinates `piece`, where `piece[i] = [xi, yi]` indicates the coordinates to be `1` in the game piece\'s shape. The piece can be rotated 90 degrees any number of times and placed on the board. Your goal is to determine whether you can place this piece on the board such that all the `1`s in the piece correspond to `0`s on the board. Return `true` if it is possible to place the piece on the board, and `false` otherwise.","solution":"def rotate_piece(piece): Rotate piece coordinates by 90 degrees clockwise. return [[y, -x] for x, y in piece] def normalize_piece(piece): Normalize piece coordinates to make the minimum x and y as 0. min_x = min(x for x, y in piece) min_y = min(y for x, y in piece) return [[x - min_x, y - min_y] for x, y in piece] def can_place_piece(board, piece): Check if the given piece can be placed on the board by rotating 90 degrees any number of times. m = len(board) n = len(board[0]) def fits(x, y, piece): for px, py in piece: if not (0 <= x + py < m and 0 <= y + px < n and board[x + py][y + px] == 0): return False return True normalized_piece = normalize_piece(piece) for _ in range(4): # Check for each rotation for i in range(m): for j in range(n): if fits(i, j, normalized_piece): return True piece = rotate_piece(piece) normalized_piece = normalize_piece(piece) return False"},{"question":"You are given a string `s` that consists of the characters \'(\', \')\' and lowercase English letters. Your task is to remove the minimum number of parentheses (either \'(\' or \')\') so that the resulting string is valid, meaning that it is correctly matched. Additionally, return any valid string that can be obtained this way. Implement a function `minRemoveToMakeValid` that takes the string `s` and returns a valid string with the minimum number of parentheses removed.","solution":"def minRemoveToMakeValid(s): Removes the minimum number of parentheses to make the input string valid. A valid string has balanced parentheses. stack = [] valid_chars = list(s) # First pass to remove unmatched closing parentheses for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: valid_chars[i] = \'\' # Second pass to remove any unmatched opening parentheses while stack: valid_chars[stack.pop()] = \'\' return \'\'.join(valid_chars)"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. Return _the head of the rotated linked list_. Here is the definition for the singly linked list node: class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } }","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def get_list_length(head): length = 0 current = head while current: length += 1 current = current.next return length def rotateRight(head, k): if not head or k == 0: return head length = get_list_length(head) k %= length if k == 0: return head slow = fast = head for _ in range(k): fast = fast.next while fast.next: slow = slow.next fast = fast.next new_head = slow.next slow.next = None fast.next = head return new_head"},{"question":"You are given a list of integers `nums` and an integer `k`. Determine if there exists a continuous subarray of size at least 2 that sums up to a multiple of `k`, that is, sums up to `n*k` where `n` is an integer. If the subarray does exist, return `true`; otherwise, return `false`. A continuous subarray is defined as a subarray obtained by deleting some (possibly no) elements from the beginning and some (possibly no) elements from the end of the array.","solution":"def check_subarray_sum(nums, k): Determines if there exists a continuous subarray of size at least 2 that sums up to a multiple of k. if k == 0: return any(nums[i] == 0 and nums[i + 1] == 0 for i in range(len(nums) - 1)) remainder_map = {0: -1} cumulative_sum = 0 for i, num in enumerate(nums): cumulative_sum += num remainder = cumulative_sum % k if remainder in remainder_map: if i - remainder_map[remainder] > 1: return True else: remainder_map[remainder] = i return False"},{"question":"Given a matrix `mat` of integers of size `m x n`, your goal is to find a rectangular submatrix of `mat` such that the sum of the elements in the submatrix is maximized. The submatrix must contain at least one element. Return a tuple of four integers `(r1, c1, r2, c2)` representing the top-left (`r1`, `c1`) and bottom-right (`r2`, `c2`) coordinates of the submatrix with the maximum sum. If there are multiple such submatrices, return any of them.","solution":"def max_submatrix_sum(mat): Finds the submatrix with the maximum sum in a given matrix. Parameters: mat (list of list of int): The input matrix. Returns: tuple: Top-left (r1, c1) and bottom-right (r2, c2) coordinates of the submatrix with maximum sum. if not mat or not mat[0]: return None m, n = len(mat), len(mat[0]) max_sum = float(\'-inf\') coordinates = (0, 0, 0, 0) for left in range(n): row_sum = [0] * m for right in range(left, n): for i in range(m): row_sum[i] += mat[i][right] current_sum = 0 start_row = 0 for i in range(m): if current_sum <= 0: start_row = i current_sum = row_sum[i] else: current_sum += row_sum[i] if current_sum > max_sum: max_sum = current_sum coordinates = (start_row, left, i, right) return coordinates"},{"question":"Write a function that takes a string representing a mathematical expression in infix notation and converts it to postfix notation (Reverse Polish Notation). The given infix expression will be a valid composition of integers and operators (+, -, *, and /) with no parentheses. Ensure your implementation maintains the order of precedence and supports multiple-digit integers. For example, the input \\"3 + 4 * 2 / 1\\" should be converted to \\"3 4 2 * 1 / +\\".","solution":"def infix_to_postfix(expression): Converts an infix expression to postfix notation (RPN). :param expression: A string representing a mathematical expression in infix notation. :return: A string representing the expression in postfix notation. precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} output = [] stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): # if the token is an operand output.append(token) else: while stack and precedence[stack[-1]] >= precedence[token]: output.append(stack.pop()) stack.append(token) while stack: output.append(stack.pop()) return \\" \\".join(output)"},{"question":"You are given a list of `n` integers `nums` and an integer `k`. Your task is to return the length of the longest subarray of `nums` that contains at most `k` distinct integers. If there is no such subarray, return 0. Write an efficient solution that works in `O(n)` time complexity.","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest subarray with at most k distinct integers. Parameters: nums (list): The list of integers. k (int): The maximum number of distinct integers. Returns: int: The length of the longest subarray with at most k distinct integers. from collections import defaultdict n = len(nums) if k == 0 or n == 0: return 0 left = 0 right = 0 max_length = 0 current_count = defaultdict(int) distinct_count = 0 while right < n: if current_count[nums[right]] == 0: distinct_count += 1 current_count[nums[right]] += 1 while distinct_count > k: current_count[nums[left]] -= 1 if current_count[nums[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given a **0-indexed** integer array `tasks` of size `n`, where `tasks[i]` represents the number of hours needed to complete the `i-th` task. You are also given an integer `d` representing the number of workers available to complete these tasks. Each worker can work on exactly one task at a time, and a task can only be processed by one worker. The goal is to distribute the tasks among the workers such that the tasks get completed in the minimum number of days possible. On any given day, all workers can work simultaneously, but only on separate tasks. Return _the minimum number of days needed to complete all tasks_.","solution":"def minimum_days_to_complete_tasks(tasks, d): Returns the minimum number of days needed to complete all tasks. :param tasks: List of integers where tasks[i] represents the hours needed for the i-th task. :param d: Integer representing the number of workers available. :return: Integer representing the minimum number of days needed. if not tasks: return 0 # Sorting the tasks in descending order to distribute the heaviest tasks first. tasks.sort(reverse=True) days = 0 while tasks: days += 1 # Each worker takes up one task if available for _ in range(d): if tasks: tasks.pop(0) else: break return days"},{"question":"You are given an array of integers `prices` representing the prices of `n` different books and an integer `budget`. You want to determine the maximum number of distinct books you can buy without exceeding `budget`. Each book can be bought at most once. Return _the maximum number of distinct books that can be bought_.","solution":"def max_books(prices, budget): Determines the maximum number of distinct books that can be bought without exceeding the budget. :param prices: List of integers representing the price of each book :param budget: Integer representing the available budget :return: Maximum number of distinct books that can be bought # Sort the book prices in ascending order to try to buy cheaper books first prices.sort() count = 0 total_spent = 0 for price in prices: if total_spent + price <= budget: total_spent += price count += 1 else: break return count"},{"question":"Given an integer array `arr` and an integer `k`, return the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. Implement the following function: ```python def findKthLargest(arr: List[int], k: int) -> int: # Your code here ``` Ensure your solution is efficient, aiming for a time complexity better than O(n log n).","solution":"from typing import List def findKthLargest(arr: List[int], k: int) -> int: import heapq # Use a min-heap to keep track of the k largest elements min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappushpop(min_heap, num) return min_heap[0]"},{"question":"Given a `root` node of a binary tree, you need to perform a **level-order traversal**. The binary tree is defined as follows: - Each node contains an integer value and pointers to the left and right child nodes. - Level-order traversal means all nodes are visited level by level from left to right. Implement a function `List<List<Integer>> levelOrder(TreeNode root)` that returns a list of lists, where each list contains the values of nodes at each level. For example: ``` Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] ```","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() if node: level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"Given a string `s` consisting of lowercase English letters, a character can be **rearranged** into a new string by altering its position, but it should not change the **frequency** of each character. Write a function that determines if `s` can be rearranged into a palindrome. A palindrome is a string that reads the same backward as forward. Return `true` _if it is possible to rearrange the characters of `s` to form a palindrome or_ `false` _otherwise_.","solution":"def can_rearrange_to_palindrome(s): Determines if the string `s` can be rearranged to form a palindrome from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 == 1) return odd_count <= 1"},{"question":"Given a binary tree, implement a method to populate each next pointer for each node to point to its next right node. If there is no next right node, the next pointer should be set to `null`. Originally, all next pointers are set to `null`. The goal is to utilize constant extra space (excluding the space for recursion stack). Define the TreeNode and populateNext methods as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def populateNext(root: TreeNode) -> None: Populates each next pointer to point to its next right node. # Your implementation goes here ``` _Your implementation should traverse the tree using the existing next pointers (if any), thereby only using O(1) space (excluding the input tree). The solution should leverage pointers and reference manipulation within the tree to achieve the desired connections._","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def populateNext(root: TreeNode) -> None: Populates each next pointer to point to its next right node. leftmost = root while leftmost: curr = leftmost prev, leftmost = None, None while curr: # Establish first child of the next level if not leftmost: leftmost = curr.left if curr.left else curr.right if curr.left: if prev: prev.next = curr.left prev = curr.left if curr.right: if prev: prev.next = curr.right prev = curr.right curr = curr.next"},{"question":"Given a string s and a dictionary of words `wordDict`, determine if `s` can be segmented into a sequence of one or more words in the dictionary. Implement the function `bool wordBreak(string s, List<string> wordDict)`. Use a dynamic programming approach to solve the problem.","solution":"def wordBreak(s, wordDict): Returns True if s can be segmented into a sequence of one or more words in the wordDict. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # base case: empty string can be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"Given a list of integers `nums`, return a new list containing only the elements that appear more than once in `nums`, preserving their original order of first appearance. * For example, given `nums = [4, 3, 2, 7, 8, 2, 3, 1]`, the result will be `[2, 3]` since `2` and `3` appear more than once.","solution":"def find_duplicates(nums): Return a list containing only the elements that appear more than once in nums, preserving their original order of first appearance. count = {} duplicates = [] for num in nums: if num in count: count[num] += 1 if count[num] == 2: duplicates.append(num) else: count[num] = 1 return duplicates"},{"question":"You are given a list of `strings` where each string represents a binary number. Return a list of integers where each integer is the decimal representation of the corresponding binary string in the input list. The resulting list should be sorted in **descending** order. For example, given `[\\"101\\", \\"10\\", \\"111\\", \\"1\\"]`, the output should be `[7, 5, 2, 1]` because the decimal representations of \\"111\\", \\"101\\", \\"10\\", and \\"1\\" are 7, 5, 2, and 1, respectively. Ensure that the input strings are valid binary numbers with no leading zeros, except for \\"0\\".","solution":"def binary_to_sorted_decimal(binary_strings): Converts a list of binary strings to a list of integers representing the decimal values of the binary strings, sorted in descending order. Parameters: binary_strings (list of str): The list of binary strings. Returns: list of int: The list of decimal integers, sorted in descending order. # Convert each binary string to a decimal integer decimal_numbers = [int(binary, 2) for binary in binary_strings] # Sort the list of decimal numbers in descending order sorted_decimal_numbers = sorted(decimal_numbers, reverse=True) return sorted_decimal_numbers"},{"question":"You are given a list of `n` integers `arr` representing heights of `n` buildings in a city. A building has a panoramic view if there are no taller buildings to its right. Write a function that returns a list containing the indices of buildings that have a panoramic view. The buildings should be listed in the order they appear from left to right. For example, given `arr = [4, 2, 3, 1]`, the buildings with panoramic views are at indices `[0, 2, 3]`.","solution":"def panoramic_view_indices(arr): Returns the list of indices of buildings that have a panoramic view. A building has a panoramic view if there are no taller buildings to its right. n = len(arr) result = [] max_height = float(\'-inf\') for i in range(n-1, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] return result[::-1]"},{"question":"A car manufacturer has designed a production schedule to assemble components for each of its car models. Each car model is represented by an integer array `schedule` where `schedule[i]` is the time it takes to complete the i-th component of the car. To ensure maximum efficiency, they want to determine the shortest total assembly time if the assembly of multiple car models can start and run in parallel, but each car model must be processed in sequence. Write a function that takes a list of `schedules`, where each `schedules[j]` represents the schedule array for car model `j`, and returns the minimum time required to complete the assembly of all car models with the above constraints. **Example:** ``` Input: schedules = [[3, 6, 1], [2, 8], [5, 4]] Output: 14 ``` **Explanation:** We can parallelize the car model productions as follows: - Start assembling first car model [3, 6, 1] which takes 10 units of time. - Start the second car model [2, 8] with assembly of the first component (2 units) beginning when the first car model is done. This adds an additional 8 units, for a total of 10 + 8 = 18 units if done sequentially. - However, by overlapping the start of the second car model during the first, the effective cumulative assembly time properly optimizes total elapsed time, resulting in a total time of 14 units with optimal scheduling.","solution":"def min_assembly_time(schedules): Determines the minimum time required to complete the assembly of all car models, given that each car model can be processed in sequence, but multiple models can run in parallel. :param schedules: List[List[int]] where each inner list represents the schedule of a car model. :return: Minimum time required to complete the assembly of all car models as an integer. if not schedules: return 0 max_times = [sum(schedule) for schedule in schedules] return max(max_times)"},{"question":"You are given an array of integers `arr` where each element appears **twice except for one**. All elements in the array are positive integers. Your task is to **find** and **return** the single element that appears only once in the array. Note that your solution should have a linear runtime complexity and you may not use extra memory.","solution":"def find_single_element(arr): Finds and returns the single element that appears exactly once in the array. This uses the XOR operation to achieve linear runtime complexity with constant space. single_element = 0 for num in arr: single_element ^= num return single_element"},{"question":"A **prime number** is a natural number greater than 1 that has no positive divisors other than 1 and itself. A prime number `p` is called an **emirp** if the reverse of its digits is also a prime. Given an integer `k`, return _the **largest emirp** number **less than or equal to**_ `k`_. If no such number exists, return -1._","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def reverse_number(n): Reverse the digits of a number. return int(str(n)[::-1]) def largest_emirp(k): Find the largest emirp number less than or equal to k. for num in range(k, 1, -1): if is_prime(num) and is_prime(reverse_number(num)) and num != reverse_number(num): # Ensuring it\'s not a palindrome prime return num return -1"},{"question":"You are given a list of integers `nums`, where each integer represents the number of points an archer can score in that round. The game consists of exactly 3 rounds. Return a list of all distinct possible scores that can be obtained by selecting one integer from each of the 3 rounds\' scores, sorted in ascending order. If there are fewer than 3 rounds, return an empty list.","solution":"from itertools import product def possible_scores(nums): Returns all distinct possible scores that can be obtained by selecting one integer from each of the 3 rounds\' scores, sorted in ascending order. If there are fewer than 3 rounds, return an empty list. if len(nums) < 3: return [] distinct_scores = set() for combination in product(nums, repeat=3): distinct_scores.add(sum(combination)) return sorted(distinct_scores)"},{"question":"Write a function that accepts a string `s` consisting of lowercase alphabetic characters and returns the length of the longest substring of `s` that contains at most two distinct characters. If the input string is empty, return `0`. A substring is defined as a contiguous sequence of characters within the string.","solution":"def longest_substring_with_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. n = len(s) if n == 0: return 0 max_len = 0 left = 0 char_map = {} for right in range(n): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an integer `n`, generate an `n x n` matrix filled with elements from `1` to `n^2` in a spiral order starting from the top-left corner, moving right, then down, then left, and then up, and repeating this pattern as the elements increase. Return the generated matrix. # Example If `n = 3`, the resulting matrix should be: ``` [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] ``` If `n = 4`, the resulting matrix should be: ``` [ [ 1, 2, 3, 4 ], [ 12, 13, 14, 5 ], [ 11, 16, 15, 6 ], [ 10, 9, 8, 7 ] ] ```","solution":"def generate_spiral_matrix(n): Generates an n x n matrix filled with elements from 1 to n^2 in spiral order. if n <= 0: return [] matrix = [[0]*n for _ in range(n)] left, right = 0, n - 1 top, bottom = 0, n - 1 num = 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"Given a **0-indexed** integer array `arr`, write a function to determine if the array can be split into two contiguous subarrays such that the sum of the elements in both subarrays is equal. If such a split is possible, return `true`, otherwise return `false`. Note that both subarrays must contain at least one element.","solution":"def can_be_split(arr): Determines if the array can be split into two contiguous subarrays such that the sum of the elements in both subarrays is equal. Parameters: arr (list): The input array of integers. Returns: bool: True if the array can be split, False otherwise. total_sum = sum(arr) if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 for i in range(len(arr) - 1): current_sum += arr[i] if current_sum == target_sum: return True return False"},{"question":"You are given an array of integers `nums`. Write a function to find the length of the longest contiguous subarray that contains no more than two distinct integers. Implement the `Solution` class: * `int lengthOfLongestSubstringTwoDistinct(int[] nums)` - Returns the length of the longest contiguous subarray that contains no more than two distinct integers. Example: Given `nums = [1, 2, 1, 2, 3, 4]`, the function should return `4`, since the longest contiguous subarray with no more than two distinct integers is `[1, 2, 1, 2]`.","solution":"def lengthOfLongestSubstringTwoDistinct(nums): Returns the length of the longest contiguous subarray that contains no more than two distinct integers. if not nums: return 0 start = 0 max_length = 0 count_map = {} for end in range(len(nums)): current_num = nums[end] if current_num in count_map: count_map[current_num] += 1 else: count_map[current_num] = 1 while len(count_map) > 2: count_map[nums[start]] -= 1 if count_map[nums[start]] == 0: del count_map[nums[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given two strings `s` and `t`. You want to convert `s` into `t` by performing a series of operations. In each operation, you can change any character in `s` to any other character. Each operation costs a certain amount, which is given by a 2D array `cost` where `cost[i][j]` represents the cost of changing character `i` of the English alphabet to character `j` of the English alphabet. Return _the minimum cost to convert `s` into `t`._ If it is impossible to convert `s` into `t`, return `-1`.","solution":"def min_conversion_cost(s, t, cost): if len(s) != len(t): return -1 total_cost = 0 for ch_s, ch_t in zip(s, t): if ch_s != ch_t: index_s = ord(ch_s) - ord(\'a\') index_t = ord(ch_t) - ord(\'a\') total_cost += cost[index_s][index_t] return total_cost"},{"question":"Given a binary tree, write a function to find the level of the tree with the maximum sum of node values. Return the level number (0-indexed). Level of a binary tree is defined as the distance from the root. The root is at level 0, its children are at level 1, and so on. One example of a binary tree could be: ``` 1 / 7 0 / 7 -8 ``` For this particular tree, the level with the maximum sum is 1 with a sum of 7 + 0 = 7.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_level_sum(root): if not root: return -1 max_sum = float(\'-inf\') max_level = 0 current_level = 0 queue = deque([(root, 0)]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node, level = queue.popleft() level_sum += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) if level_sum > max_sum: max_sum = level_sum max_level = current_level current_level += 1 return max_level"},{"question":"You are given a **2D matrix** `grid` of size `m x n`, where each cell contains an integer. A cell is called a **peak** if it is greater than or equal to all of its 4 possible neighbors (left, right, top, bottom). Return _the_ coordinates `[i, j]` of any one peak. If multiple peaks exist, return the coordinates of any one of them.","solution":"def find_peak(grid): Finds any peak in the 2D matrix grid. A peak is a cell that is greater than or equal to its 4 possible neighbors: left, right, top, bottom. :param grid: 2D list of integers :return: List of the coordinates [i, j] of any peak found m, n = len(grid), len(grid[0]) def is_peak(i, j): val = grid[i][j] if i > 0 and val < grid[i - 1][j]: return False if i < m - 1 and val < grid[i + 1][j]: return False if j > 0 and val < grid[i][j - 1]: return False if j < n - 1 and val < grid[i][j + 1]: return False return True for i in range(m): for j in range(n): if is_peak(i, j): return [i, j] return None"},{"question":"You are given a string `s` and an integer `k`. You can choose any substring of `s` and replace it with any character at most `k` times. After performing this operation, the goal is to obtain the longest substring with all repeating characters. Write a function that returns the length of this longest substring. You must solve the problem with an efficient algorithm.","solution":"def characterReplacement(s, k): Returns the length of the longest substring with all repeating characters after performing at most k replacements. max_len = 0 left = 0 max_count = 0 char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 max_count = max(max_count, char_count[s[right]]) if (right - left + 1) - max_count > k: char_count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water. A **land** patch is a connected component of `1`s where cells are connected **horizontally or vertically**. Two patches are considered **distinct** if they are not connected horizontally or vertically. Write a function that returns _the number of distinct land patches_ on the map.","solution":"def numDistinctPatches(grid): Returns the number of distinct land patches in the grid. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(i, j): if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0 or visited[i][j]: return visited[i][j] = True dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) land_patches = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: dfs(i, j) land_patches += 1 return land_patches"},{"question":"Design a function that receives a string `s` and an integer `k`. The string `s` contains only lowercase English letters and digits. Your task is to shift each character in the string `s` to the right by `k` positions. For alphabetic characters, the shift should wrap around (\'z\' follows \'a\'). For digits, the shift should also wrap around (\'9\' follows \'0\'). Digits should remain digits, and letters should remain letters. Return the resulting string after applying the shift.","solution":"def shift_characters(s, k): Shifts each character in the string \'s\' to the right by \'k\' positions. Characters wrap around within their respective groups (letters and digits). result = [] for char in s: if char.isalpha(): if char.islower(): result.append(chr((ord(char) - ord(\'a\') + k) % 26 + ord(\'a\'))) elif char.isdigit(): result.append(chr((ord(char) - ord(\'0\') + k) % 10 + ord(\'0\'))) return \'\'.join(result)"},{"question":"You are given an array of integers `nums` containing `n` positive elements. Your task is to find the length of the longest contiguous subarray that strictly increases. A contiguous subarray is a sequence of consecutive elements from the original array, and it is said to strictly increase if each element is greater than the one before it. Return _the length of the longest contiguous strictly increasing subarray in_ `nums`.","solution":"def longest_increasing_subarray(nums): Finds the length of the longest contiguous strictly increasing subarray. Parameters: nums (list of int): A list containing n positive elements. Returns: int: The length of the longest contiguous strictly increasing subarray. if not nums: return 0 longest_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 return longest_length"},{"question":"Given an array of integers `arr` where the length is `n`, you need to find the length of the longest subarray, which when sorting the subarray results in the entire array being sorted in non-decreasing order. In other words, find the longest contiguous subarray such that sorting this subarray makes the whole array sorted. Return the length of this subarray.","solution":"def longest_subarray_to_sort(arr): n = len(arr) if n <= 1: return n start, end = -1, -1 for i in range(n - 1): if arr[i] > arr[i + 1]: start = i break if start == -1: return n for i in range(n - 1, 0, -1): if arr[i] < arr[i - 1]: end = i break subarray_min = float(\'inf\') subarray_max = float(\'-inf\') for i in range(start, end + 1): subarray_min = min(subarray_min, arr[i]) subarray_max = max(subarray_max, arr[i]) while start > 0 and arr[start - 1] > subarray_min: start -= 1 while end < n - 1 and arr[end + 1] < subarray_max: end += 1 return end - start + 1"},{"question":"Suppose you are given an array of integers `heights` representing the heights of students standing in a line. Each student\'s height is unique. Write a function to return the number of students standing in positions where that student\'s height is greater than all the previous students\' heights in the line.","solution":"def count_increasing_heights(heights): Returns the number of students standing in positions where the student\'s height is greater than all previous students\' heights in the line. Parameters: heights (list): A list of unique integers representing the heights of students. Returns: int: The count of students taller than all previous students in the line. count = 0 max_height_so_far = float(\'-inf\') for height in heights: if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"You are hosting a party and want to ensure that friends who know each other are seated at different tables. You are given an integer `n` which represents the number of friends and a list of pairs `friendships` where each pair `[a, b]` represents that friend `a` knows friend `b` and vice versa. Your goal is to find the minimum number of tables required such that no two friends who know each other are seated at the same table. Return this minimum number of tables. For example, given `n = 4` and `friendships = [[0, 1], [1, 2], [2, 3]]`, return `2` because you can split the friends into two tables: one containing friends `0` and `2`, and another containing friends `1` and `3`.","solution":"from collections import defaultdict, deque def min_number_of_tables(n, friendships): Determine the minimum number of tables required such that no two friends who know each other are seated at the same table. Parameters: n (int): Number of friends. friendships (list): List of friendships where each pair [a,b] indicates that friend `a` knows friend `b`. Returns: int: The minimum number of tables required. def is_bipartite(graph, n): colors = [-1] * n for i in range(n): if colors[i] != -1: continue queue = deque([i]) colors[i] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if colors[neighbor] == -1: colors[neighbor] = 1 - colors[node] queue.append(neighbor) elif colors[neighbor] == colors[node]: return False return True graph = defaultdict(list) for a, b in friendships: graph[a].append(b) graph[b].append(a) if is_bipartite(graph, n): return 2 return 1"},{"question":"Given a sorted array of unique integers `arr` and an integer `k`, return the `k-th` missing positive integer from the array. The `k-th` missing positive integer is the positive integer that has a difference of `k` when considering the gaps in the sorted sequence starting from `1`.","solution":"def find_kth_missing(arr, k): Returns the k-th missing positive integer from the sorted array of unique integers arr. current = 1 # The number we are currently checking for missing status missing_count = 0 # Counter for missing numbers for num in arr: while current < num: missing_count += 1 if missing_count == k: return current current += 1 current = num + 1 # Move to the next number after the current element in arr # If we haven\'t found the k-th missing number in the range of the array, continue the count while missing_count < k: missing_count += 1 if missing_count == k: return current current += 1"},{"question":"You are given a matrix `grid` of size `n x m` and an integer threshold `k`. Each cell in the grid contains an integer value which represents the height of a terrain at that cell. A **path** in the matrix is defined as a sequence of cells starting from the top-left corner to the bottom-right corner, where each move can be to an adjacent cell (right, down, left, or up). The **weight** of a path is defined as the maximum height encountered along the path. Your task is to determine the minimum possible weight of any path from the top-left corner to the bottom-right corner that is less than or equal to `k`. If no such path exists, return -1. Return _the minimum possible weight of any path in_ `grid` _with a weight of at most_ `k`. _If no such path exists, return -1_.","solution":"from heapq import heappop, heappush from typing import List def minimum_weight_path(grid: List[List[int]], k: int) -> int: n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_within_bounds(x, y): return 0 <= x < n and 0 <= y < m def dijkstra(): heap = [(grid[0][0], 0, 0)] dist = [[float(\'inf\')] * m for _ in range(n)] dist[0][0] = grid[0][0] while heap: weight, x, y = heappop(heap) if weight > k: continue if x == n - 1 and y == m - 1: return weight for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny): new_weight = max(weight, grid[nx][ny]) if new_weight < dist[nx][ny]: dist[nx][ny] = new_weight heappush(heap, (new_weight, nx, ny)) return -1 return dijkstra()"},{"question":"Given an integer array `arr` and an integer `x`, return the number of pairs `(i, j)` such that `i < j` and `arr[i] + arr[j] == x`. For example, given `arr = [1, 2, 3, 4, 5]` and `x = 5`, the possible pairs are `(0, 3)` and `(1, 2)`, so the function should return `2`. Implement a function that solves this problem efficiently.","solution":"def count_pairs_with_sum(arr, x): Returns the number of pairs (i, j) such that i < j and arr[i] + arr[j] == x count = 0 seen = {} for i, num in enumerate(arr): target = x - num if target in seen: count += seen[target] if num in seen: seen[num] += 1 else: seen[num] = 1 return count"},{"question":"You are given a string `s` and an integer `k`. A **substring** is defined as a contiguous sequence of characters within the string. Calculate the number of distinct substrings of length `k` that occur more than once in the string `s`. Return the count of such substrings. Note that the substrings are considered the same if they are composed of the same characters in the same order.","solution":"def count_repeated_substrings(s, k): Returns the number of distinct substrings of length k that occur more than once in s. from collections import defaultdict if k > len(s): return 0 substring_count = defaultdict(int) # Traverse through the string to count all substrings of length k for i in range(len(s) - k + 1): substring = s[i:i + k] substring_count[substring] += 1 # Count substrings that appear more than once repeated_substrings_count = sum(1 for count in substring_count.values() if count > 1) return repeated_substrings_count"},{"question":"Given a `string s` containing only lowercase letters, return the length of the longest subsequence that can be formed by deleting some or no characters from `s` such that the sequence is a palindrome. A palindrome is a sequence that reads the same forward and backward. You must solve this problem using dynamic programming with a time complexity of O(n^2), where `n` is the length of the input string. Implement the function `int longestPalindromeSubseq(String s)` to return the required length.","solution":"def longestPalindromeSubseq(s): Returns the length of the longest palindromic subsequence in the string s. n = len(s) if n == 0: return 0 # Create a 2D DP array where dp[i][j] = length of longest palindrome subseq in s[i..j] dp = [[0] * n for _ in range(n)] # Strings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Build the DP table for cl in range(2, n+1): # cl is substring length for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: if cl == 2: dp[i][j] = 2 else: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # Length of longest palindromic subseq return dp[0][n-1]"},{"question":"Given an array `tasks` where `tasks[i]` represents the type of the `i`-th task, and an integer `n` representing the cooldown period between two tasks of the same type, return _the **minimum number of time units** required to complete all tasks_ while adhering to the cooldown constraint. *Example:* - Input: `tasks = [\'A\', \'A\', \'A\', \'B\', \'B\', \'B\']`, `n = 2` - Output: 8 Explanation: One possible sequence could be `[\'A\', \'B\', \'idle\', \'A\', \'B\', \'idle\', \'A\', \'B\']`.","solution":"from collections import Counter def least_interval(tasks, n): Returns the minimum number of time units required to complete all tasks adhering to the cooldown constraint. task_counts = Counter(tasks) max_count = max(task_counts.values()) max_count_tasks = sum(1 for count in task_counts.values() if count == max_count) part_count = max_count - 1 part_length = n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"You are given a string `s` containing only lowercase English letters. You can choose any single character from `s` and replace it with any other lowercase English letter. Your goal is to create the longest possible substring of `s` that contains the same character. Return the length of the longest such substring you can achieve with at most one replacement. For example, if you are given the string `s = \\"ababa\\"`: - You can replace the character `b` at index 1 with `a` to obtain the substring \\"aaa\\", resulting in a length of 3. - Or replace the character `b` at index 3 with `a` to get the substring \\"aaa\\", also resulting in a length of 3. The function should return 3 in this case.","solution":"def longest_substring_with_one_replacement(s: str) -> int: Returns the length of the longest possible substring that can be achieved by replacing at most one character in `s`. n = len(s) max_len = 0 for char in set(s): left, count = 0, 0 for right in range(n): if s[right] != char: count += 1 while count > 1: if s[left] != char: count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an integer array `nums` and an integer `k`, rearrange `nums` such that the difference between the maximum and minimum value of any adjacent elements does not exceed `k`. Return the lexicographically smallest possible array after rearrangement.","solution":"def rearrange_within_k(nums, k): Rearranges the array nums such that the difference between the maximum and minimum value of any adjacent elements does not exceed k. Returns the lexicographically smallest possible array after rearrangement. nums.sort() for i in range(len(nums) - 1): if nums[i + 1] - nums[i] > k: return [] return nums"},{"question":"Given a `2D` matrix representing an image, write a function `rotateImage(matrix: List[List[int]]) -> None` to rotate the image by `90` degrees clockwise in-place. The matrix is guaranteed to be square (i.e., the number of rows is equal to the number of columns). Your function should modify the input matrix directly with no return value.","solution":"def rotateImage(matrix): Rotates the image represented by the 2D matrix by 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Given a string `sentence` that consists of words separated by spaces, return _the words in `sentence` sorted in reverse order of their lengths_. If two words have the same length, they should appear in the same order as they do in the original sentence.","solution":"def sort_words_by_length(sentence): Returns the words in the sentence sorted in reverse order of their lengths. Parameters: sentence (str): A string consisting of words separated by spaces. Returns: list: A list of words sorted in reverse order of their lengths. words = sentence.split() words.sort(key=len, reverse=True) return words"},{"question":"You are given a list of `n` strings. Each string contains only lowercase alphabetic characters. You need to determine if you can form a palindrome by concatenating some (or all) of the given strings in any order. If it is possible to create such a palindrome, return `true`; otherwise, return `false`.","solution":"from collections import Counter def can_form_palindrome(strings): Determines if you can form a palindrome by concatenating some (or all) of the given strings in any order. Args: strings (list of str): List of strings containing only lowercase alphabetic characters. Returns: bool: True if a palindrome can be formed, False otherwise. # Counter to count all characters in all strings char_count = Counter() for s in strings: char_count.update(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # We can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"Given a binary search tree (BST), write a function to find the lowest common ancestor (LCA) of two given nodes in the BST. The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where a node can be a descendant of itself). Assume all values in the BST are unique. Your function should return a pointer to the LCA of the two nodes. Implement the function `TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root, p, q): Finds the LCA of two nodes p and q in a BST. current = root while current: # If both p and q are smaller than current, LCA lies in left if p.val < current.val and q.val < current.val: current = current.left # If both p and q are greater than current, LCA lies in right elif p.val > current.val and q.val > current.val: current = current.right else: # We have found the split point, i.e., the LCA node. return current"},{"question":"You are given an array `timePoints` that represents the times of the day in the \\"HH:MM\\" format. Your task is to find the minimum difference in minutes between any two time points in the array. Each time point in `timePoints` represents the exact hour and minute on a 24-hour clock. Return _the minimum difference in minutes between any two time points in the array._","solution":"def findMinDifference(timePoints): Returns the minimum difference in minutes between any two time points in the array. Parameters: timePoints (List[str]): a list of time points in \\"HH:MM\\" format on a 24-hour clock. Returns: int: the minimum difference in minutes between any two time points. # Convert time points to minutes minutes = [] for time in timePoints: h, m = map(int, time.split(\':\')) total_minutes = h * 60 + m minutes.append(total_minutes) # Sort the list of minutes minutes.sort() # Initialize min_diff to a large value min_diff = float(\'inf\') # Calculate the differences and keep track of the minimum difference for i in range(len(minutes) - 1): diff = minutes[i + 1] - minutes[i] min_diff = min(min_diff, diff) # Also consider the difference between the first and last time points across midnight min_diff = min(min_diff, (1440 - minutes[-1] + minutes[0])) return min_diff"},{"question":"Design a data structure that supports the following operations efficiently: - **insert(key)**: Adds a `key` to the data structure. - **delete(key)**: Deletes a `key` from the data structure. - **getRandom()**: Returns a random key from the current set of keys. Each key must have an equal probability of being returned. Implement the data structure with these operations having average time complexity of O(1).","solution":"import random class RandomizedSet: def __init__(self): self.array = [] self.index_map = {} def insert(self, key): Inserts a key into the data structure. Returns True if the key was successfully added, and False if the key was already present. if key in self.index_map: return False self.array.append(key) self.index_map[key] = len(self.array) - 1 return True def delete(self, key): Deletes a key from the data structure. Returns True if the key was successfully deleted, and False if the key was not present. if key not in self.index_map: return False index = self.index_map[key] last_element = self.array[-1] self.array[index] = last_element self.index_map[last_element] = index self.array.pop() del self.index_map[key] return True def getRandom(self): Returns a random key from the current set of keys. Each key must have an equal probability of being returned. if not self.array: raise IndexError(\\"getRandom() cannot be called on an empty set\\") return random.choice(self.array)"},{"question":"You are given a binary tree with `n` nodes. Each node has a value associated with it. Find the number of paths that form a valid \\"zigzag\\" pattern in the tree. A \\"zigzag\\" path starts at any node and alternates between left and right child nodes. Specifically, a valid \\"zigzag\\" path is a sequence of nodes where the direction alternates at each step (left -> right -> left, or right -> left -> right, etc.). Return the length of the longest such path in the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestZigZag(root: TreeNode) -> int: def dfs(node, direction, length): nonlocal max_length if not node: return max_length = max(max_length, length) if direction == 0: # coming from left dfs(node.right, 1, length + 1) dfs(node.left, 0, 1) else: # coming from right dfs(node.left, 0, length + 1) dfs(node.right, 1, 1) max_length = 0 dfs(root, 0, 0) dfs(root, 1, 0) return max_length"},{"question":"You are given an integer array `weights` and two integers `k` and `maxSum`. Find the number of distinct subsequences whose sum is equal to `maxSum` given that the subsequence length must be exactly `k`. Return _the number of such subsequences_. A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. Each subsequence should contain exactly `k` elements, and their sum must be equal to `maxSum`.","solution":"from itertools import combinations def count_valid_subsequences(weights, k, maxSum): Returns the number of distinct subsequences of length k whose sum equals maxSum. :param weights: List of integer weights. :param k: Integer, length of the subsequences. :param maxSum: Integer, the target sum of the subsequences. :returns: Integer, number of valid subsequences. count = 0 for subseq in combinations(weights, k): if sum(subseq) == maxSum: count += 1 return count"},{"question":"Design a function to merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. Implement the `mergeTwoLists` function: * `ListNode mergeTwoLists(ListNode l1, ListNode l2)` - Merges two sorted linked lists `l1` and `l2` into one sorted linked list and returns the head of the new list. For example, if: * `l1 = [1, 2, 4]` * `l2 = [1, 3, 4]` The function should return `mergeTwoLists(l1, l2)` as `[1, 1, 2, 3, 4, 4]`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): dummy = ListNode() current = dummy while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next"},{"question":"You are given a binary tree where each node contains an integer value. Design an algorithm to find all the root-to-leaf paths where the sum of the values along the path equals a given target sum. Each path should be returned as a list of the node values. The tree and the target sum are given as inputs in the form of a root node and an integer value, respectively. For example, given the tree: ``` 5 / 4 8 / / 11 13 4 / / 7 2 5 1 ``` and a target sum of 22, the output should be: ``` [ [5, 4, 11, 2], [5, 8, 4, 5] ] ``` Each path must start at the root node and end at a leaf node, and all the values along the path must sum to the target sum. Use depth-first search (DFS) to explore the tree and backtracking to construct the paths.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_paths(root, target_sum): def dfs(node, current_sum, path, paths): if not node: return current_sum += node.value path.append(node.value) if not node.left and not node.right and current_sum == target_sum: paths.append(list(path)) else: dfs(node.left, current_sum, path, paths) dfs(node.right, current_sum, path, paths) path.pop() # backtrack paths = [] dfs(root, 0, [], paths) return paths"},{"question":"You are given a string `s` containing only characters `a`, `b`, and `c`. You can change one character to any other character `a`, `b`, or `c` in one operation. Your task is to return _the minimum number of operations required so that no two adjacent characters in the string are the same._ If the string is empty or has only one character, return `0`.","solution":"def min_operations_to_avoid_adjacent(s): Returns the minimum number of operations required so that no two adjacent characters in the string s are the same. Parameters: s (str): The input string containing only characters \'a\', \'b\', and \'c\'. Returns: int: The minimum number of operations required. if len(s) < 2: return 0 operations = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: operations += 1 # Change the current character to one that is not the same as the previous or the next character (if possible) if s[i - 1] != \'a\' and (i + 1 >= len(s) or s[i + 1] != \'a\'): s = s[:i] + \'a\' + s[i+1:] elif s[i - 1] != \'b\' and (i + 1 >= len(s) or s[i + 1] != \'b\'): s = s[:i] + \'b\' + s[i+1:] else: s = s[:i] + \'c\' + s[i+1:] return operations"},{"question":"You are given a balanced binary search tree (BST) with `n` nodes. Each node represents an integer value. You need to modify the BST such that the sum of the values of all nodes greater than or equal to the current node\'s value is added to the current node\'s value. After modifying the BST, return the root of the new BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstToGst(root): Given a BST, modify the BST such that each node\'s value is replaced with the sum of all values greater than or equal to the node\'s value in the original tree. def reverse_inorder_traversal(node, accumulated_sum): if node is None: return accumulated_sum # Traverse the right subtree first because it has greater values accumulated_sum = reverse_inorder_traversal(node.right, accumulated_sum) # Add the current node\'s value to accumulated_sum accumulated_sum += node.val # Update the current node\'s value node.val = accumulated_sum # Traverse the left subtree accumulated_sum = reverse_inorder_traversal(node.left, accumulated_sum) return accumulated_sum reverse_inorder_traversal(root, 0) return root"},{"question":"Write a function `findPeakElement` that takes an integer array `nums` and returns the index of a peak element. A peak element is an element that is strictly greater than its neighbors. Given an array `nums`, your task is to find an index `i` such that `nums[i] > nums[i-1]` and `nums[i] > nums[i+1]`. If the array contains multiple peaks, return the index to any of the peaks. You may assume that `nums[-1]` and `nums[n]` are sentinels with value `-`. The solution should have a time complexity of O(log n).","solution":"def findPeakElement(nums): Finds the index of a peak element in the array. A peak element is an element that is strictly greater than its neighbors. :param nums: List[int] - the input array of integers :return: int - the index of any peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"You are given a string `s` and an integer `n`. Rotate the string in a way that shifts each character to the left by `n` positions. For example, if the string is \\"abcdefg\\" and `n` is 2, the result should be \\"cdefgab\\". If `n` is greater than the length of the string, it should rotate the string `n % length` times. Return the _rotated string_.","solution":"def rotate_string(s, n): Rotate the string \'s\' to the left by \'n\' positions. Parameters: s (str): The string to rotate. n (int): The number of positions to rotate the string to the left. Returns: str: The rotated string. if not s: return s n = n % len(s) # In case n is larger than the length of s. return s[n:] + s[:n]"},{"question":"Given an array of integers `nums` where each integer appears exactly twice, except for one integer which appears exactly once. Write a function to find and return the integer that appears only once. Your implementation should have a linear runtime complexity.","solution":"def single_number(nums): Returns the integer that appears only once in the list nums where every other integer appears exactly twice. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"Given a string `s` consisting of lowercase letters, you are to perform a series of operations to form the lexicographically smallest string possible. In one operation, you can choose any character in the string and move it to the start of the string. Determine the lexicographically smallest string that can be formed after performing any number of such operations. For example, given the string `\\"cbad\\"`, one possible smallest string after the operation could be `\\"abcd\\"`.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be formed from the string s by moving characters to the start. return \'\'.join(sorted(s))"},{"question":"You are given an array of integers `arr` representing the heights of buildings along a street. Each building spans 1 unit of width. You can add water of height `h` in between buildings such that the water is contained within the buildings and does not spill over. Calculate the maximum volume of water that can be trapped between the buildings after any amount of water is added. Return an integer representing the maximum amount of trapped water.","solution":"def max_trapped_water(arr): Calculate the maximum volume of water that can be trapped between the buildings. Parameters: arr (list of int): List of heights of buildings. Returns: int: Maximum volume of water that can be trapped. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) # Fill right_max array right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - arr[i] return trapped_water"},{"question":"Given a list of integers `arr` representing the number of tasks completed on each day, and an integer `k` representing the number of consecutive days, return _the maximum number of tasks that can be completed in any **k** consecutive days_. If `k` is greater than the length of the list, return the total number of tasks completed for all days.","solution":"def max_tasks_in_k_days(arr, k): Returns the maximum number of tasks that can be completed in any k consecutive days. If k is greater than the length of the list, return the total number of tasks for all days. Parameters: arr (list): List of integers representing the number of tasks completed on each day. k (int): Number of consecutive days. Returns: int: Maximum number of tasks completed in any k consecutive days. if k > len(arr): return sum(arr) current_sum = sum(arr[:k]) max_sum = current_sum for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a list of integers `nums` representing positions of stones on an infinite number line. A stone can be removed if it shares the same position with another stone, making both positions empty. Two stones can be removed simultaneously if they are at the same position. You need to find the **maximum number of moves** required to make all stone positions empty. Each move consists of choosing a pair of stones at the same position and removing them. Return _the maximum number of moves_ to empty every stone position entirely.","solution":"def max_moves(nums): Given a list of integers representing positions of stones on a number line, returns the maximum number of moves required to make all stone positions empty. Parameters: - nums (list of int): The positions of the stones. Returns: - int: The maximum number of moves to make all stone positions empty. from collections import Counter # Count the frequency of each position position_count = Counter(nums) # For each position, the maximum number of moves we can make is half the count # since each move removes two stones. max_moves = 0 for count in position_count.values(): max_moves += count // 2 return max_moves"},{"question":"You are given an integer array `nums` where each element represents the cost of applying a certain operation to a subarray. You need to divide the array into multiple non-overlapping subarrays such that the sum of the costs of the subarrays is minimized. The cost of a subarray is defined as the maximum element in that subarray. Return the minimum possible sum of the costs of the subarrays.","solution":"def min_cost_to_divide_into_subarrays(nums): Given an array of integers `nums`, returns the minimum possible sum of the costs (maximum element) of the subarrays formed by dividing the array into multiple non-overlapping subarrays. # The minimum cost to split the array is the sum of max elements in each individual element subarray return sum(nums)"},{"question":"Given an array of integers `nums`, you are asked to perform a series of range queries on it. Each query is represented by the array `queries` where `queries[i] = [L, R, k]`. For each query, you need to determine whether there exists at least one subarray of `nums` within the range `[L, R]` (inclusive) that has an average equal to `k`. If such a subarray exists, return `true`; otherwise, return `false`. Implement the `SubarrayAverage` class: - `SubarrayAverage(int[] nums)` - Initializes the class with the integer array `nums`. - `boolean[] query(int[][] queries)` - For each query, returns `true` if there exists at least one subarray within the range `[L, R]` that has an average equal to `k`; otherwise, returns `false`. The method returns an array of boolean values, one for each query. Note that the average of a subarray is defined as the sum of the elements in the subarray divided by the length of the subarray.","solution":"class SubarrayAverage: def __init__(self, nums): self.nums = nums self.prefix_sum = self._compute_prefix_sum(nums) def _compute_prefix_sum(self, nums): prefix_sum = [0] for num in nums: prefix_sum.append(prefix_sum[-1] + num) return prefix_sum def query(self, queries): results = [] for L, R, k in queries: find_avg_k = False for start in range(L, R + 1): for end in range(start, R + 1): subarray_sum = self.prefix_sum[end + 1] - self.prefix_sum[start] subarray_length = end - start + 1 if subarray_sum / subarray_length == k: find_avg_k = True break if find_avg_k: break results.append(find_avg_k) return results"},{"question":"You are given a list of `n` items each with a positive weight, represented by an array `weights`, and an integer `m` representing the maximum capacity of a knapsack. Each item can either be included in the knapsack or excluded. The goal is to maximize the sum of the weights of the items included in the knapsack without the total weight exceeding the given limit `m`. Return _the **maximum weight** that can be achieved without exceeding the capacity of the knapsack._ You must solve the problem using dynamic programming.","solution":"def knapsack_max_weight(weights, m): Computes the maximum weight that can be achieved without exceeding the capacity of the knapsack. Parameters: weights (list): List of positive weights. m (int): Maximum capacity of the knapsack. Returns: int: Maximum weight that can be achieved without exceeding the capacity. n = len(weights) dp = [0] * (m + 1) for weight in weights: for j in range(m, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return dp[m]"},{"question":"You are given an integer array `height` of size `n` that represents the height of n poles arranged linearly. You need to find out the **water trapping capacity** when it rains heavily. More specifically, you need to calculate the total units of water that can be trapped between the poles after it rains. The water trapped between two poles is determined by the minimum height of the two poles, minus the height of the poles between them. Return an integer representing the **total units** of water that can be trapped between the poles. [Question] 4:","solution":"def trap_rain_water(height): Calculate the total units of water that can be trapped between poles. Parameters: height (list): List of integers representing the height of poles. Returns: int: Total units of trapped water. if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate total water trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a `list of strings`, group the strings into categories such that the strings in each category are anagrams of each other. Return the grouped anagrams as a list of lists. An **anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, \\"listen\\" and \\"silent\\" are anagrams of each other. The input strings should be grouped based on their canonical form, where canonical form means sorting the letters in a string alphabetically.","solution":"from collections import defaultdict def group_anagrams(strings): Groups a list of strings into categories such that the strings in each category are anagrams of each other. :param strings: List of strings :return: List of lists containing grouped anagrams anagrams = defaultdict(list) for string in strings: canonical_form = \'\'.join(sorted(string)) anagrams[canonical_form].append(string) return list(anagrams.values())"},{"question":"You are given a string `s` and an integer `k`. The string `s` consists of only lowercase English letters. You need to perform the following operations until the length of the string `s` becomes less than or equal to `k`: 1. Remove the lexicographically largest character from the string. 2. If there are multiple such characters, remove only one instance of that character. Return the final modified string after performing the above operations.","solution":"def remove_to_length_k(s, k): Removes the lexicographically largest characters from the string `s` until its length is less than or equal to `k`. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The target length for the string `s`. Returns: str: The modified string with length less than or equal to `k`. s = list(s) while len(s) > k: max_char = max(s) s.remove(max_char) return \'\'.join(s)"},{"question":"You are managing a library that has a collection of books. Each book is identified by a unique ID represented as an integer. The library uses a system to lend and return books. You need to keep track of the current state of each book in the library. You are given an integer array `operations` where: * `operations[i] > 0` means a book with ID `operations[i]` is being lent out. * `operations[i] < 0` means a book with ID `-operations[i]` is being returned. Write a function that determines the final state of the library by returning a list of IDs of books that are currently lent out, in the order they were lent out. If a book is returned that was not previously lent out, it can be ignored. Implement the function to return the list of IDs of lent out books. For example, given the input `operations = [1, 2, 3, -2, 4, -1]`, the output should be `[3, 4]` since book with ID 2 is returned, thus not being in the final list of lent out books.","solution":"def final_lent_books(operations): lent_books = {} result = [] for operation in operations: book_id = abs(operation) if operation > 0: if book_id not in lent_books: lent_books[book_id] = True result.append(book_id) elif operation < 0: if book_id in lent_books: lent_books.pop(book_id) result.remove(book_id) return result"},{"question":"You are given an array of integers `arr` representing the heights of a number of trees in a forest, and an integer `k` representing the number of workers assigned to cut the trees. Each worker can cut a tree down to the ground (height 0) in one minute. Each worker works independently and can simultaneously cut down a different tree. Return the minimum number of minutes required for the workers to cut down all the trees in the forest. If `k` exceeds the number of trees, consider using only the necessary number of workers instead.","solution":"def min_minutes_to_cut_trees(arr, k): Returns the minimum number of minutes required for the workers to cut down all the trees in the forest. :param arr: List[int], list of tree heights. :param k: int, number of workers assigned to cut the trees. :return: int, minimum number of minutes required. num_trees = len(arr) # If there are no trees, no time is required. if num_trees == 0: return 0 # The minimum number of minutes is the number of trees divided by the number of workers, # rounded up to account for any remaining trees. return (num_trees + k - 1) // k"},{"question":"You are given a binary tree with `n` nodes, where each node is uniquely assigned a value between `1` and `n`. Write a function to determine if the given binary tree is a Symmetric Tree, which means it is a mirror of itself (i.e., symmetric around its center). Return `true` if the tree is symmetric, otherwise return `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Returns whether the binary tree is symmetric. if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.right, right.left) and is_mirror(left.left, right.right) return is_mirror(root.left, root.right)"},{"question":"Given an array of integers `arr` where `arr[i]` could be positive, negative or zero. You are allowed to perform exactly one operation where you can replace any element in the array with any integer value. Determine whether you can make the array non-decreasing by performing no more than one such operation. Return `True` if possible, otherwise return `False`.","solution":"def can_be_non_decreasing(arr): Determine whether the array can be made non-decreasing with at most one replacement. Parameters: arr (List[int]): List of integers which may include positive, negative, or zero values. Returns: bool: True if the array can be made non-decreasing with at most one replacement, False otherwise. n = len(arr) if n <= 1: return True count = 0 for i in range(1, n): if arr[i] < arr[i - 1]: count += 1 if count > 1: return False if i > 1 and arr[i] < arr[i - 2]: arr[i] = arr[i - 1] return True"},{"question":"You are given a list of `n` integers where each integer represents the height of a building, from left to right. Find out how many buildings have ocean view, considering that the buildings can only have an ocean view if there are no taller building(s) to their right. The rightmost building always has an ocean view. Return an array of the indices of such buildings in ascending order.","solution":"def findBuildingsWithOceanView(heights): Find out which buildings have an ocean view. A building has an ocean view if all buildings to its right are shorter. Parameters: heights (list of int): Heights of the buildings. Returns: list of int: Indices of buildings with ocean view in ascending order. ocean_view_buildings = [] max_height = 0 for i in reversed(range(len(heights))): if heights[i] > max_height: ocean_view_buildings.append(i) max_height = heights[i] # Since we\'ve collected indices from right to left, reverse to get ascending order ocean_view_buildings.reverse() return ocean_view_buildings"},{"question":"You are given a grid of size `m x n` consisting of non-negative integers. Each cell in the grid represents a point with a certain height. Water can flow either from a cell to its 4 neighboring cells (North, East, South, West) if the neighboring cell has a height equal to or less than the current cell. A cell is called \\"reachable\\" if water can start from any cell on the boundary of the grid and flow to this specific cell. Write a function that returns a list of all cells that are reachable from any boundary cell of the grid. The result should be a list of lists, where each element is a pair `[i, j]` denoting the row and column of a reachable cell. The list should be sorted first by row and then by column.","solution":"def pacific_atlantic_water_flow(heights): if not heights or not heights[0]: return [] m, n = len(heights), len(heights[0]) def bfs(starts): visited = set(starts) queue = starts[:] while queue: x, y = queue.pop(0) for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = x + i, y + j if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and heights[nx][ny] >= heights[x][y]: visited.add((nx, ny)) queue.append((nx, ny)) return visited pacific_starts = [(i, 0) for i in range(m)] + [(0, j) for j in range(n)] atlantic_starts = [(i, n-1) for i in range(m)] + [(m-1, j) for j in range(n)] pacific_reachable = bfs(pacific_starts) atlantic_reachable = bfs(atlantic_starts) results = list(pacific_reachable & atlantic_reachable) results.sort() return [[x, y] for x, y in results]"},{"question":"Given an array of integers `nums` and an integer `target`, return the indices of the two numbers in the array that add up to exactly `target`. Each input would have exactly one solution, and you may not use the same element twice. For example, given nums = `[2, 7, 11, 15]` and target = `9`, the output should be `[0, 1]` because nums[0] + nums[1] = 2 + 7 = 9.","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the array that add up to exactly target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"You are given a **0-indexed** `m x n` binary matrix `grid` where `0` represents water and `1` represents land. An island is a maximal **4-directionally** connected group of `1`s. The grid is said to be **connected** if we have exactly **one island**. A grid is said to be **#1-enclave** connected if every island cell that is not on the border of the grid is surrounded by water on its 4 neighboring cells. Return _the total number of land cells that are **#1-enclave** connected islands in `grid`_.","solution":"def numEnclaves(grid): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return grid[x][y] = 0 dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) m, n = len(grid), len(grid[0]) # Eliminate border connected lands for i in range(m): for j in [0, n - 1]: if grid[i][j] == 1: dfs(i, j) for i in [0, m - 1]: for j in range(n): if grid[i][j] == 1: dfs(i, j) # Count enclave lands count = 0 for i in range(1, m - 1): for j in range(1, n - 1): if grid[i][j] == 1: count += 1 return count"},{"question":"You are given a list of `n` strings, where each string consists of only lowercase English letters. You need to find the length of the longest chain of strings such that for each string in the chain, starting from the second string, all its letters are also in the previous string. You can rearrange the letters in each string while forming the chain. Return _the length of the longest possible chain_.","solution":"def longest_chain(strings): Finds the length of the longest chain of strings such that for each string in the chain, starting from the second string, all its letters are also in the previous string. Args: strings (list): List of strings consisting of lowercase English letters. Returns: int: The length of the longest possible chain. from collections import defaultdict # Count frequency of each character in each string def get_char_frequency(s): freq = defaultdict(int) for char in s: freq[char] += 1 return freq # Check if str1 contains all characters of str2 def contains_all_chars(freq1, freq2): for char in freq2: if freq2[char] > freq1.get(char, 0): return False return True # Start main logic n = len(strings) if n == 0: return 0 # Sort strings by length in descending order strings.sort(key=len, reverse=True) longest_chain_length = 1 dp = [1] * n for i in range(n): freq1 = get_char_frequency(strings[i]) for j in range(i): freq2 = get_char_frequency(strings[j]) if contains_all_chars(freq2, freq1): dp[i] = max(dp[i], dp[j] + 1) longest_chain_length = max(longest_chain_length, dp[i]) return longest_chain_length"},{"question":"Given an array of integers `nums` representing daily stock prices, return _the length of the longest strictly increasing subsequence_ of stock prices.","solution":"def length_of_lis(nums): Returns the length of the longest strictly increasing subsequence of the given list of stock prices. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given an array of integers `arr` and an integer `k`, return the maximum sum of `k` consecutive elements in the array. Implement the class `MaxSubArraySum` which includes: * `MaxSubArraySum(int[] arr)` initializes the object with the given array `arr`. * `int findMaxSum(int k)` returns the maximum sum of `k` consecutive elements in the array. If `k` is greater than the length of the array, return `-1`.","solution":"class MaxSubArraySum: def __init__(self, arr): self.arr = arr def findMaxSum(self, k): n = len(self.arr) if k > n: return -1 # find the sum of the first k elements max_sum = sum(self.arr[:k]) current_sum = max_sum for i in range(k, n): current_sum += self.arr[i] - self.arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an array `logs` where each entry is a string representing a log message with the format: \\"timestamp user_id action\\". The `timestamp` is a unique integer representing the time at which the action was logged, `user_id` is an alphanumeric identifier for a user, and `action` is a string describing what action the user performed. Write a function that: 1. Sorts the logs based on their timestamps in ascending order. 2. Groups the logs by `user_id`. 3. Within each group of logs for a particular user, counts the occurrences of each `action` performed by that user. Return a dictionary where keys are `user_id`s and values are dictionaries with `action` as keys and their respective counts as values. For example, for an input `logs` array: ``` [ \\"1618301200 user1 login\\", \\"1618301250 user2 logout\\", \\"1618301150 user1 logout\\", \\"1618301300 user2 login\\", \\"1618301100 user1 login\\" ] ``` The return value should be: ``` { \\"user1\\": { \\"login\\": 2, \\"logout\\": 1 }, \\"user2\\": { \\"logout\\": 1, \\"login\\": 1 } } ```","solution":"def process_logs(logs): Given an array of log messages, sorts the logs by timestamp, groups the logs by user_id, and counts occurrences of each action by user. Args: logs (list): List of log message strings in the format \\"timestamp user_id action\\". Returns: dict: Dictionary where keys are user_ids and values are dictionaries with actions and their counts. # Parse logs into a list of tuples (timestamp, user_id, action) parsed_logs = [(int(log.split()[0]), log.split()[1], log.split()[2]) for log in logs] # Sort the parsed logs based on timestamp sorted_logs = sorted(parsed_logs, key=lambda x: x[0]) # Initialize an empty result dictionary user_actions = {} for _, user_id, action in sorted_logs: if user_id not in user_actions: user_actions[user_id] = {} if action not in user_actions[user_id]: user_actions[user_id][action] = 0 user_actions[user_id][action] += 1 return user_actions"},{"question":"You are given a string `order` representing the desired order of characters, and another string `s` which is a permutation of the characters in `order`. Your task is to return a permutation of the string `s` that matches the order specified in `order`. If there are multiple correct results, return any of them. For example, if `order` is `\\"cba\\"` and `s` is `\\"bca\\"`, the result should be `\\"cba\\"`.","solution":"def custom_sort(order, s): Returns a permutation of s that matches the order specified in order. order_index = {char: idx for idx, char in enumerate(order)} return \'\'.join(sorted(s, key=lambda x: order_index[x]))"},{"question":"You are given a sorted array `arr` of unique integers which was rotated at some pivot unknown to you beforehand (i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`). Assuming that the original array was sorted in ascending order, find the minimum element in the rotated array. You must write an algorithm that runs in O(log n) time and utilizes constant space.","solution":"def find_min_in_rotated_sorted_array(arr): Returns the minimum element in a rotated sorted array. The algorithm runs in O(log n) time using binary search and constant space. if not arr: return None # handle edge case where the array is empty left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[right]: left = mid + 1 else: right = mid return arr[left]"},{"question":"You are given an unsorted integer array `nums` and need to remove duplicates from it. Each element should appear only once, and you should retain the first occurrence of each element. Write an algorithm to modify the input array in-place and return the new length of the array after duplicates have been removed. You must also ensure the first part of the array contains only the unique elements in the order they appeared in the original array. Implement the function `int removeDuplicates(int[] nums)`, which takes an array of integers and modifies it to remove duplicates, retaining the initial order of elements and returning the length of the array after duplicates have been removed.","solution":"def removeDuplicates(nums): Removes duplicates from the list in-place and returns the new length of the list. :param nums: List[int] - The input list of integers. :return: int - The length of the list after duplicates have been removed. if not nums: return 0 unique_position = 0 seen = set() for num in nums: if num not in seen: seen.add(num) nums[unique_position] = num unique_position += 1 return unique_position"},{"question":"You are given an `n` x `n` grid representing a maze where `0` represents an empty space and `1` represents a wall. You have a ball at the start position `(i, j)` and a hole at the destination position `(x, y)`. The ball can only move up, down, left, or right and can only stop moving when it hits a wall. Determine if the ball can reach the hole. Return `true` if the ball can reach the hole, otherwise return `false`.","solution":"from collections import deque def can_reach_hole(maze, start, destination): Determines if the ball can reach the hole in the maze. Parameters: maze (List[List[int]]): The grid representing the maze. start (Tuple[int, int]): The starting position of the ball. destination (Tuple[int, int]): The hole\'s position. Returns: bool: True if the ball can reach the hole, otherwise False. n = len(maze) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right visited = set() queue = deque([start]) while queue: x, y = queue.popleft() if (x, y) in visited: continue visited.add((x, y)) for d in directions: new_x, new_y = x, y # Roll the ball until it hits a wall while 0 <= new_x + d[0] < n and 0 <= new_y + d[1] < n and maze[new_x + d[0]][new_y + d[1]] == 0: new_x += d[0] new_y += d[1] if (new_x, new_y) == destination: return True if (new_x, new_y) not in visited: queue.append((new_x, new_y)) return False"},{"question":"You are given a string `words` containing a list of words separated by spaces. Your task is to reverse the order of words in the string without altering the letters within each word. Return the resulting string after reversing the words.","solution":"def reverse_words(words): Reverses the order of words in the input string without altering the letters within each word. Args: - words: A string containing words separated by spaces. Returns: - A string with the words reversed in order. word_list = words.split() reversed_word_list = word_list[::-1] reversed_words_string = \' \'.join(reversed_word_list) return reversed_words_string"},{"question":"You are given a string `s` representing a sentence containing multiple words separated by spaces. Return _a string with the words in reverse order_. The words should be returned in reverse sequence exactly how they appeared in the input, and leading or trailing spaces should be removed. If there are multiple spaces between words, reduce them to a single space in the output. Note that the input string may contain spaces only, or no spaces at all, requiring special handling.","solution":"def reverse_words(s): Returns a string with words in reverse order. Leading or trailing spaces are removed, and multiple spaces are reduced to a single space. # Split the string by spaces, filtering out any empty strings (from multiple spaces) words = s.strip().split() # Reverse the list of words reversed_words = words[::-1] # Join the words back into a string with single spaces return \' \'.join(reversed_words)"},{"question":"Given a string `s` consisting of only the characters \'a\' and \'b\', you need to delete the minimum number of characters from the string so that there are no three consecutive characters that are the same. Return the minimum number of deletions required.","solution":"def min_deletions_to_avoid_three_consecutive(s): Given a string s consisting only of the characters \'a\' and \'b\', this function deletes the minimum number of characters so that there are no three consecutive characters that are the same. :param s: Input string consisting of \'a\' and \'b\' :type s: str :return: Minimum number of deletions required :rtype: int if len(s) < 3: return 0 deletions = 0 count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 if count == 3: deletions += 1 count = 2 else: count = 1 return deletions"},{"question":"You are given a string `s` and an integer `k`. You need to split the string into **k** contiguous substrings such that the sum of the lengths of these substrings is the same as the length of the original string `s`. The goal is to maximize the minimum length among these `k` substrings. Return the maximum possible minimum length. If it\'s not possible to split the string into exactly `k` parts, return `-1`.","solution":"def maximize_min_length(s, k): Split the string s into k contiguous substrings such that the sum of the lengths of these substrings is the same as the length of the original string s. The goal is to maximize the minimum length among these k substrings. Return the maximum possible minimum length. If it\'s not possible to split the string into exactly k parts, return -1. if len(s) < k: return -1 length = len(s) max_min_length = length // k return max_min_length"},{"question":"You are given `n` binary strings, all of the same length `m`. Your task is to determine how many of these strings share a common prefix of length `k` with a given binary string `targetPrefix`. Specifically, you need to find the number of strings in the array `strings` that have the same first `k` characters as the `targetPrefix`. Return _the integer count_ of such strings that match the condition.","solution":"def count_matching_prefix(strings, targetPrefix, k): Counts the number of strings from the list that share a common prefix of length k with the targetPrefix. Args: strings (List[str]): List of binary strings to check. targetPrefix (str): The binary string to be used as the reference prefix. k (int): Length of the prefix to match. Returns: int: The count of strings that match the specified prefix. # Extract the target prefix of length k target = targetPrefix[:k] count = 0 for string in strings: if string[:k] == target: count += 1 return count"},{"question":"Given an array of integers `arr`, find the maximum length of a subarray where the sum of elements equals `k`. Return the length of this subarray. For example, given `arr = [1, -1, 5, -2, 3]` and `k = 3`, the maximum length subarray with sum 3 is `[1, -1, 5, -2]`, which has length 4.","solution":"def max_len_subarray_with_sum_k(arr, k): Returns the maximum length of a subarray with the sum equal to k. sum_indices = {} current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == k: max_length = i + 1 if (current_sum - k) in sum_indices: max_length = max(max_length, i - sum_indices[current_sum - k]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_length"},{"question":"A group of friends wants to distribute a certain number of candies among themselves. The group is standing in a line, and each friend has a unique rating associated with them, given in an integer array `ratings`, where `ratings[i]` is the rating of the `ith` friend. The goal is to distribute the candies such that: - Each friend gets at least one candy. - Friends with a higher rating get more candies than their immediate neighbors. Given the array `ratings`, return the minimum number of candies required to distribute among the friends according to the above rules.","solution":"def min_candies(ratings): Determine the minimum number of candies required to distribute to friends based on their ratings. Each friend gets at least one candy, and friends with higher ratings get more candies than their immediate neighbors. Parameters: - ratings (List[int]): List of integer ratings of the friends. Returns: - int: Minimum number of candies required. if not ratings: return 0 n = len(ratings) candies = [1] * n # Traverse from left to right for i in range(1, n): if ratings[i] > ratings[i - 1]: candies[i] = candies[i - 1] + 1 # Traverse from right to left for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) return sum(candies)"},{"question":"You are given a **0-indexed** integer array `candies`, where `candies[i]` represents the number of candies available at the `i-th` store. You are also given an array `queries` where each `queries[j] = [startj, endj, k]` represents a query asking whether it is possible to collect exactly `k` candies by visiting a contiguous subarray of stores from `startj` to `endj` (both inclusive). Return _a boolean array_ `answer` _of the same length as_ `queries`_, where_ `answer[j]` _is_ `true` _if it is possible to collect exactly_ `k` _candies in the subarray defined by_ `queries[j]`, _and_ `false` _otherwise_.","solution":"def can_collect_candies(candies, queries): prefix_sums = [0] * (len(candies) + 1) for i in range(len(candies)): prefix_sums[i + 1] = prefix_sums[i] + candies[i] result = [] for start, end, k in queries: total_candies = prefix_sums[end + 1] - prefix_sums[start] result.append(total_candies == k) return result"},{"question":"You are given a **2D integer matrix** `grid` of size `m x n` and an integer `limit`. Return _the **maximum sum**_ of a subgrid such that the sum of all its elements is less than or equal to `limit`. A **subgrid** is a rectangular portion of the grid. If no such subgrid exists, return `0`.","solution":"def maxSumSubgrid(grid, limit): Returns the maximum sum of a subgrid such that the sum of all its elements is less than or equal to limit. If no such subgrid exists, return 0. m = len(grid) n = len(grid[0]) max_sum = 0 # Precompute the prefix sums prefix_sums = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix_sums[i + 1][j + 1] = grid[i][j] + prefix_sums[i + 1][j] + prefix_sums[i][j + 1] - prefix_sums[i][j] # Check all subgrids for r1 in range(1, m + 1): for r2 in range(r1, m + 1): for c1 in range(1, n + 1): for c2 in range(c1, n + 1): subgrid_sum = prefix_sums[r2][c2] - prefix_sums[r1 - 1][c2] - prefix_sums[r2][c1 - 1] + prefix_sums[r1 - 1][c1 - 1] if subgrid_sum <= limit: max_sum = max(max_sum, subgrid_sum) return max_sum"},{"question":"Given an `M x N` matrix `grid` representing a field of oranges, where each cell in the grid represents one of three possible states: - `0` representing an empty cell, - `1` representing a fresh orange, - `2` representing a rotten orange, Return _the minimum number of minutes that must elapse until no cell has a fresh orange_. If this is impossible, return `-1`. A rotten orange can rot adjacent fresh oranges in the four possible cardinal directions (up, down, left, right) in one minute. A cell is adjacent if it is directly connected to the current cell in one of the four cardinal directions.","solution":"from collections import deque def orangesRotting(grid): rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Add all rotten oranges to the queue and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 # If there are no fresh oranges, return 0 if fresh_oranges == 0: return 0 minutes_elapsed = 0 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Perform BFS starting from initially rotten oranges while queue and fresh_oranges > 0: minutes_elapsed += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: grid[nx][ny] = 2 queue.append((nx, ny)) fresh_oranges -= 1 # If there are still fresh oranges left, return -1. Otherwise, return the time elapsed. return -1 if fresh_oranges > 0 else minutes_elapsed"},{"question":"You are given an array of integers `arr` and an integer `k`. An integer is considered **beautiful** if it is the product of exactly `k` distinct elements from `arr`. Return _the **maximum beautiful** integer as an `integer` or `-1` if no such integer exists_. Note: * `arr` may contain duplicate elements. * Each element in `arr` can only be used once in forming the product.","solution":"from itertools import combinations from math import prod def max_beautiful_integer(arr, k): Returns the maximum beautiful integer which is the product of exactly k distinct elements from arr. If no such integer exists, returns -1. if k > len(arr): return -1 max_product = -1 for combo in combinations(set(arr), k): product = prod(combo) if product > max_product: max_product = product return max_product"},{"question":"Given an integer array `arr` and an integer `k`, return _the **k-th** smallest element in the array_. The array may contain duplicates, and it is guaranteed that `k` is always valid (1  `k`  number of elements in `arr`). Do not use built-in sorting functions to solve this problem.","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in the array. :param arr: List of integers :param k: Integer representing k-th position (1-based) :return: The k-th smallest element in arr def quick_select(l, r, k_smallest): if l == r: return arr[l] pivot_index = partition(l, r) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quick_select(l, pivot_index - 1, k_smallest) else: return quick_select(pivot_index + 1, r, k_smallest) def partition(l, r): pivot = arr[r] store_index = l for i in range(l, r): if arr[i] < pivot: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[r] = arr[r], arr[store_index] return store_index return quick_select(0, len(arr) - 1, k - 1)"},{"question":"You are given a 2D list `forest` where `forest[i][j] = 1` represents a tree and `forest[i][j] = 0` represents an empty cell. Each tree provides shade to the cells that are immediately adjacent to it either vertically or horizontally (not diagonally). Determine the total number of cells that are shaded by at least one tree. A tree cell is considered to shade itself.","solution":"def count_shaded_cells(forest): Returns the number of cells that are shaded by at least one tree. A tree cell is considered to shade itself. :param forest: List[List[int]], a 2D list representing the forest :return: int, the count of shaded cells if not forest: return 0 rows = len(forest) cols = len(forest[0]) shaded = set() for i in range(rows): for j in range(cols): if forest[i][j] == 1: shaded.add((i, j)) if i > 0: shaded.add((i - 1, j)) if i < rows - 1: shaded.add((i + 1, j)) if j > 0: shaded.add((i, j - 1)) if j < cols - 1: shaded.add((i, j + 1)) return len(shaded)"},{"question":"You are given a list of `n` integers representing the positions of `n` points on a number line. You are to partition these points into `k` non-empty subsets such that the maximum difference between the minimum and maximum positions in each subset is minimized. Return the minimized maximum difference.","solution":"def minimize_max_difference(nums, k): def is_valid(max_diff): count = 1 min_val = nums[0] for num in nums: if num - min_val > max_diff: count += 1 min_val = num if count > k: return False return True nums.sort() left, right = 0, nums[-1] - nums[0] while left < right: mid = (left + right) // 2 if is_valid(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a two-dimensional grid of size `n x m`, where each cell of the grid contains either a `0` or a `1`. Each row and column of the grid can be flipped (changed all `0`s to `1`s, and all `1`s to `0`s) any number of times. Find the maximum number of `1`s that can be obtained in the grid after performing any number of flips. Return _an integer_ `answer`_, the maximum number of_ `1`s _that can be obtained in the grid_.","solution":"def max_ones(grid): This function accepts a 2D list \'grid\' containing 0s and 1s and returns the maximum number of 1s that can be obtained by flipping any row or column any number of times. def count_ones(grid): return sum(sum(row) for row in grid) def flip_row(grid, row_idx): grid[row_idx] = [1 - cell for cell in grid[row_idx]] def flip_col(grid, col_idx): for row in grid: row[col_idx] = 1 - row[col_idx] n = len(grid) m = len(grid[0]) max_ones_count = 0 for row_mask in range(1 << n): # Flip specified rows: flipped_grid = [row[:] for row in grid] # Deep copy of the grid for row in range(n): if row_mask & (1 << row): flip_row(flipped_grid, row) for col_mask in range(1 << m): temp_grid = [row[:] for row in flipped_grid] # Copy the flipped grid for col in range(m): if col_mask & (1 << col): flip_col(temp_grid, col) max_ones_count = max(max_ones_count, count_ones(temp_grid)) return max_ones_count"},{"question":"Devise an algorithm to determine the maximum depth of a binary tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Given the root of a binary tree, return its maximum depth. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function with the following signature: ```python def maxDepth(root: TreeNode) -> int: # Your code here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: if root is None: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"You are given a list of `directories` with their paths and file names. Each directory is represented as a string of the form `\\"dir/subdir/subdir_name/.../filename\\"` where \\"dir\\" is the root directory. Write a function that takes the list of directories and returns a list of unique file names along with their full paths, sorted by their file names. If a file name occurs more than once, the corresponding paths should all be included in the result, associated with their respective file names. For example, given the input list: ``` [ \\"dir1/subdir1/file1\\", \\"dir1/subdir2/file2\\", \\"dir2/subdir1/file1\\", \\"dir3/subdir3/file3\\" ] ``` The function should output: ``` [ [\\"file1\\", [\\"dir1/subdir1/file1\\", \\"dir2/subdir1/file1\\"]], [\\"file2\\", [\\"dir1/subdir2/file2\\"]], [\\"file3\\", [\\"dir3/subdir3/file3\\"]] ] ``` The list of directories will not contain any duplicates, and at least one directory will be provided.","solution":"from collections import defaultdict def unique_files_with_paths(directories): Returns a list of unique file names along with their full paths, sorted by their file names. :param directories: List of directory paths with filenames. :return: List of lists that includes unique file names and their corresponding paths. file_dict = defaultdict(list) for directory in directories: parts = directory.split(\'/\') file_name = parts[-1] file_dict[file_name].append(directory) result = [] for file_name in sorted(file_dict.keys()): result.append([file_name, file_dict[file_name]]) return result"},{"question":"Given a list of integers `nums`, find all pairs of distinct indices `(i, j)` such that the absolute difference between `nums[i]` and `nums[j]` is less than or equal to a given integer `k`. Return _a list of such pairs_ `(i, j)` in any order.","solution":"def find_pairs(nums, k): Given a list of integers nums, find all pairs of distinct indices (i, j) such that the absolute difference between nums[i] and nums[j] is less than or equal to k. Parameters: nums (list): List of integers. k (int): The absolute difference constraint. Returns: list: A list of tuples representing pairs (i, j). pairs = [] for i in range(len(nums)): for j in range(i + 1, len(nums)): if abs(nums[i] - nums[j]) <= k: pairs.append((i, j)) return pairs"},{"question":"You are given an array of `n` integers. Your task is to partition the array into exactly `k` non-empty subarrays such that the maximum sum of any subarray is minimized. Return the minimized maximum sum. **Example:** Input: nums = [7,2,5,10,8], k = 2 Output: 18 **Explanation:** There are four ways to partition nums into two subarrays: - [7,2,5] and [10,8], sum of each subarray is 14 and 18. The maximum is 18. - [7,2,5,10] and [8], sum of each subarray is 24 and 8. The maximum is 24. - [7,2] and [5,10,8], sum of each subarray is 9 and 23. The maximum is 23. - [7] and [2,5,10,8], sum of each subarray is 7 and 25. The maximum is 25. The best way is to partition nums into [7,2,5] and [10,8] with minimized maximum sum being 18. **Constraints:** * 1 <= nums.length <= 1000 * 0 <= nums[i] <= 10^6 * 1 <= k <= nums.length","solution":"def minimize_max_sum(nums, k): Function to partition the array into exactly k non-empty subarrays such that the maximum sum of any subarray is minimized. def can_partition(max_sum): current_sum = 0 required_splits = 1 for num in nums: if current_sum + num > max_sum: required_splits += 1 current_sum = num if required_splits > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = left + (right - left) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"A company wants to promote teamwork by arranging employees into different **teams**. You are given an array `skills` where `skills[i]` represents the skill level of the `i-th` employee. The formation of a team is valid if the difference between the maximum and minimum skill levels of the team members does not exceed a threshold value `t`. Write a function that returns the maximum number of teams that can be formed under these conditions. Each employee can belong to exactly one team. If it is not possible to form any team, return `0`.","solution":"def max_teams(skills, t): Returns the maximum number of teams that can be formed such that the difference between the maximum and minimum skill levels of the team members does not exceed t. :param skills: List[int] - list of skill levels of employees :param t: int - threshold value for the maximum allowed difference between skill levels in a team :return: int - maximum number of teams that can be formed if not skills: return 0 skills.sort() teams = 0 n = len(skills) i = 0 while i < n: start_skill = skills[i] j = i while j < n and skills[j] - start_skill <= t: j += 1 teams += 1 i = j return teams"},{"question":"Design a parking lot system with multiple levels and each level having multiple spots. Each parking spot can either be occupied or not. The system should allow parking vehicles, removing vehicles from parking spots, and checking whether a spot is available or not. Implement the `ParkingLot` class: * `ParkingLot(int levels, int spotsPerLevel)` Initializes the parking lot with the given number of levels and the given number of spots per level. * `boolean park(int level, int spot)` Parks a vehicle at the specified `level` and `spot`. Returns `true` if the spot was successfully occupied, and `false` if the spot is already taken or if the provided level and spot are out of range. * `boolean leave(int level, int spot)` Removes a vehicle from the specified `level` and `spot`. Returns `true` if the spot was successfully freed, and `false` if the spot was already empty or if the provided level and spot are out of range. * `boolean isAvailable(int level, int spot)` Checks if a vehicle can be parked at the specified `level` and `spot`. Returns `true` if the spot is empty and within range, `false` otherwise.","solution":"class ParkingLot: def __init__(self, levels, spotsPerLevel): # Initialize the parking lot with specified levels and spots per level self.levels = levels self.spotsPerLevel = spotsPerLevel # Create a parking lot structure which is a 2D list self.parkingLot = [[False for _ in range(spotsPerLevel)] for _ in range(levels)] def park(self, level, spot): # Check if the spot is within range and not already occupied if level < 0 or level >= self.levels or spot < 0 or spot >= self.spotsPerLevel: return False if self.parkingLot[level][spot]: return False # Park the vehicle self.parkingLot[level][spot] = True return True def leave(self, level, spot): # Check if the spot is within range and currently occupied if level < 0 or level >= self.levels or spot < 0 or spot >= self.spotsPerLevel: return False if not self.parkingLot[level][spot]: return False # Remove the vehicle self.parkingLot[level][spot] = False return True def isAvailable(self, level, spot): # Check if the spot is within range and not occupied if level < 0 or level >= self.levels or spot < 0 or spot >= self.spotsPerLevel: return False return not self.parkingLot[level][spot]"},{"question":"You are given a **doubly linked list** where each node contains an integer value and a pointer to the next node and the previous node. Write a function to merge a group of `k` sorted doubly linked lists into a single sorted doubly linked list. The function should efficiently merge the lists by repeatedly merging pairs of lists until only one list remains. Return the head of the merged sorted doubly linked list. Each of the `k` doubly linked lists may have different lengths and contain duplicates.","solution":"class ListNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next def merge_two_lists(l1, l2): dummy = ListNode() curr = dummy while l1 and l2: if l1.val < l2.val: curr.next = l1 l1.prev = curr l1 = l1.next else: curr.next = l2 l2.prev = curr l2 = l2.next curr = curr.next if l1: curr.next = l1 l1.prev = curr if l2: curr.next = l2 l2.prev = curr merged_head = dummy.next if merged_head: merged_head.prev = None return merged_head def merge_k_lists(lists): if not lists: return None while len(lists) > 1: merged_lists = [] for i in range(0, len(lists), 2): l1 = lists[i] l2 = lists[i+1] if i+1 < len(lists) else None merged_lists.append(merge_two_lists(l1, l2)) lists = merged_lists return lists[0]"},{"question":"You are given a **0-indexed** integer array `arr` of length `n` representing the height of trees on a straight line. You need to cut down trees to create a clear view. You can cut down any tree, but you must adhere to the following conditions: 1. You can only cut down exactly `k` consecutive trees. 2. After cutting down the trees, the height of any remaining tree should not exceed an integer `h`. Return _an integer representing the minimum height restriction `h` needed to cut down `k` consecutive trees such that all remaining trees do not exceed this height_. If it\'s not possible to cut down the trees to meet the requirement, return `-1`.","solution":"def min_height_restriction(arr, k): Given an array of tree heights and the number of consecutive trees to cut (k), return the minimum height restriction needed to ensure all remaining trees do not exceed this height. If it\'s not possible, return -1. n = len(arr) # Early return if k is greater than the number of trees if k > n: return -1 min_height = float(\'inf\') # Iterate over all possible consecutive ranges for i in range(n - k + 1): # Calculate the max height of remaining trees if we cut down k consecutive trees starting from index i current_max_height = max(arr[:i] + arr[i + k:]) min_height = min(min_height, current_max_height) return min_height if min_height != float(\'inf\') else -1"},{"question":"You are given an integer array `timeSeries`, where `timeSeries[i]` represents the time at which a particular event occurs. The events cause a continuous effect that lasts for a duration given by an integer `duration`. If an event occurs before the previous effect has ended, the effect time is extended by the duration but doesn\'t double-count the overlapping periods. For example, if an effect starts at time `t` and another event occurs at `t+2` with a duration of 4, the total effective time ends at `t+6`. Return _the **total** duration of all the effects_.","solution":"def findPoisonedDuration(timeSeries, duration): This function calculates the total duration of an effect caused by event occurrences at specific times. Parameters: timeSeries (list of int): List of times at which events occur. duration (int): Duration of the effect caused by each event. Returns: int: The total duration of the effect. if not timeSeries: return 0 total_duration = 0 for i in range(len(timeSeries) - 1): total_duration += min(duration, timeSeries[i + 1] - timeSeries[i]) return total_duration + duration"},{"question":"You are given a linked list where each node contains a unique integer value. Write a function to insert a new node with a given unique integer value into the linked list in its correct position to maintain the sorted order of the linked list. You are not allowed to alter the values of the existing nodes, but you can change the `next` pointers of the nodes. Return the head of the modified linked list.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def insert_into_sorted_list(head, val): Inserts a new node with the given unique integer value into the sorted linked list. new_node = ListNode(val) if head is None or val < head.val: new_node.next = head return new_node current = head while current.next is not None and current.next.val < val: current = current.next new_node.next = current.next current.next = new_node return head"},{"question":"Given a `n x n` 2D matrix representing an image, rotate the matrix 90 degrees clockwise in-place. You must solve the problem without using extra space for another matrix. Below is the method signature: ```python def rotate(matrix: List[List[int]]) -> None: Do not return anything, modify matrix in-place instead. ```","solution":"def rotate(matrix): Rotates the given n x n 2D matrix representing an image 90 degrees clockwise in-place. Args: matrix (List[List[int]]): The n x n 2D matrix to be rotated. Returns: None: The function modifies the matrix in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Given an integer `n`, return the list of all integers from `1` to `n` in lexicographical order. For example, given `n = 13`, the list should be: [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]. Note that the function should be efficient and avoid generating the list and then sorting it, as the input value `n` could be very large.","solution":"def lexical_order(n): Returns a list of integers from 1 to n in lexicographical order. result = [] def dfs(current): if current > n: return result.append(current) for i in range(10): next_num = current * 10 + i if next_num > n: return dfs(next_num) for i in range(1, 10): dfs(i) return result"},{"question":"Create a function to determine if a given string `s` can be where `s` is a valid string representing a series of open and close parentheses and braces: \'(\' `{` `}`. Each open parenthesis or brace must be closed by the same type of parenthesis or brace. Additionally, parentheses and braces must be correctly nested within each other. Return `true` if the given string is valid; otherwise, return `false`. For example, the string `\\"{[()()]}\\"` is valid, while the string `\\"[({)}]\\"` is not valid.","solution":"def is_valid(s): Determine if a given string `s` is valid based on proper nesting and matching of parentheses and braces. Args: - s (str): The input string to be checked Returns: - bool: True if valid, False otherwise stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_bracket.values(): # If it\'s an opening bracket stack.append(char) elif char in matching_bracket.keys(): # If it\'s a closing bracket if stack == [] or stack.pop() != matching_bracket[char]: return False else: # If the character is not one of the expected parentheses or braces, it\'s invalid return False return stack == [] # Example usage: is_valid(\\"{[()()]}\\") should return True # Example usage: is_valid(\\"[({)}]\\") should return False"},{"question":"Given a matrix `mat` of size `m x n`, where every cell represents a cost to travel through, find a path from the top-left corner to the bottom-right corner which minimizes the sum of the costs of the cells on that path. You can only move **right** or **down** from a cell. Return the minimum cost of such a path.","solution":"def min_path_sum(mat): Given a matrix mat of size m x n, where every cell represents a cost to travel through, find a path from the top-left corner to the bottom-right corner which minimizes the sum of the costs of the cells on that path. You can only move right or down from a cell. Args: mat (list of list of int): The cost matrix. Returns: int: The minimum cost to travel from the top-left to the bottom-right. if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) # Create a 2D dp array to store the minimum cost up to each cell dp = [[0] * n for _ in range(m)] # Initialize the top-left cell with the cost of the starting point dp[0][0] = mat[0][0] # Fill in the cost for the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + mat[i][0] # Fill in the cost for the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + mat[0][j] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + mat[i][j] return dp[m-1][n-1]"},{"question":"A DNA sequence can be represented as a string consisting of the characters \'A\', \'C\', \'G\', and \'T\'. We want to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Write a function `List<String> findRepeatedDnaSequences(String s)` that returns all the 10-letter-long sequences (substrings) that occur more than once in the given string `s`. You may return the answer in any order. The input string `s` represents the DNA sequence you need to analyze. Your function should focus on finding efficiency in terms of time and space.","solution":"def findRepeatedDnaSequences(s): Returns all 10-letter-long sequences (substrings) that occur more than once in the given DNA sequence. sequence_counts = {} result = set() # Iterate over the string and use a sliding window approach to find all substrings of length 10 for i in range(len(s) - 9): substring = s[i:i + 10] if substring in sequence_counts: sequence_counts[substring] += 1 else: sequence_counts[substring] = 1 # If a substring is found more than once, add it to the result set if sequence_counts[substring] == 2: result.add(substring) return list(result)"},{"question":"Given an integer array `arr` and an integer `x`, return _the **maximum length** of a subarray with at most `x` distinct integers_. A **subarray** is a contiguous sequence of elements within an array.","solution":"def max_length_subarray(arr, x): Returns the maximum length of a subarray with at most x distinct integers. if x == 0: return 0 from collections import defaultdict max_len = 0 left = 0 counts = defaultdict(int) for right, value in enumerate(arr): counts[value] += 1 while len(counts) > x: counts[arr[left]] -= 1 if counts[arr[left]] == 0: del counts[arr[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"There is a rectangular `m x n` grid and a robot initially located at the top-left corner (0, 0). The robot can move either right, down, or diagonally right-down. The robot aims to reach the bottom-right corner `(m-1, n-1)`. Given `m` and `n`, return _the number of distinct paths the robot can take to reach the destination_.","solution":"def unique_paths(m, n): Given m and n, returns the number of distinct paths the robot can take from (0, 0) to (m-1, n-1) where it can move right, down, or diagonally right-down. # Create a 2D array to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # There is exactly 1 way to reach the first cell (stay put) dp[0][0] = 1 for i in range(m): for j in range(n): if i - 1 >= 0: dp[i][j] += dp[i - 1][j] # from above if j - 1 >= 0: dp[i][j] += dp[i][j - 1] # from left if i - 1 >= 0 and j - 1 >= 0: dp[i][j] += dp[i - 1][j - 1] # from diagonal return dp[m - 1][n - 1]"},{"question":"You have a list of events represented as intervals where `events[i] = [start_i, end_i]`. Each event `start_i` and `end_i` represent the start and end time of the event, respectively. All start times are unique. You are allowed to attend only one event per day. Determine the **maximum number of non-overlapping** events you can attend. Write a function `maxEvents` that receives a list of events and returns the maximum number of events you can attend. ``` class Solution: def maxEvents(self, events: List[List[int]]) -> int: ``` # Example: ``` Input: events = [[1,2],[2,3],[3,4]] Output: 3 ``` # Explanation: * Attend the first event on day 1 * Attend the second event on day 2 * Attend the third event on day 3 * All events are attended with no overlap.","solution":"import heapq class Solution: def maxEvents(self, events): # Sort events by their starting day events.sort() max_events = 0 min_heap = [] day = 0 event_id = 0 num_events = len(events) while event_id < num_events or len(min_heap) > 0: if len(min_heap) == 0: # No active events day = events[event_id][0] # Add all events that start today while event_id < num_events and events[event_id][0] <= day: heapq.heappush(min_heap, events[event_id][1]) event_id += 1 # Remove all events that have ended before today while len(min_heap) > 0 and min_heap[0] < day: heapq.heappop(min_heap) # Attend the event that ends the earliest (if any) if len(min_heap) > 0: heapq.heappop(min_heap) max_events += 1 day += 1 return max_events"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `m`. Your task is to determine if there exists a non-empty subsequence of `nums` such that the sum of its elements is divisible by `m`. A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Return `true` if such a subsequence exists, otherwise, return `false`.","solution":"def is_subsequence_sum_divisible(nums, m): Determines if there exists a non-empty subsequence of nums such that the sum of its elements is divisible by m. Args: nums: List[int] - A list of integers. m: int - The integer by which the subsequence sum should be divisible. Returns: bool - True if such a subsequence exists, False otherwise. # Use a set to keep track of all possible sums modulo m mod_set = set([0]) for num in nums: new_mod_set = mod_set.copy() for mod_val in mod_set: new_mod_val = (mod_val + num) % m if new_mod_val == 0: return True new_mod_set.add(new_mod_val) mod_set = new_mod_set return False"},{"question":"You are given a string `s` and an integer `k`. The string `s` contains letters and digits. You need to partition the string into consecutive substrings such that each substring contains exactly `k` characters. If the last part is shorter than `k` characters, it remains as it is. Return the array of substrings. The substrings should maintain the original order of characters from the string `s`. For example, for `s = \\"a2b3c4d5e6f7\\"` and `k = 3`, the output should be `[\\"a2b\\", \\"3c4\\", \\"d5e\\", \\"6f7\\"]`.","solution":"def partition_string(s, k): Partitions the string `s` into consecutive substrings each having exactly `k` characters. If the last part is shorter than `k` characters, it remains as it is. Args: s: str - The input string containing letters and digits. k: int - The length of each partition. Returns: list of str: The list of partitions. return [s[i:i+k] for i in range(0, len(s), k)]"},{"question":"You are given an integer array `array` of length `n` and an integer `m`. Your task is to determine the maximum sum of any subarray of length exactly `m`. A subarray is a contiguous part of an array. For example, if `array = [2, 1, 5, 1, 3, 2]` and `m = 3`, then the subarrays of length 3 are `[2, 1, 5]`, `[1, 5, 1]`, `[5, 1, 3]`, and `[1, 3, 2]`. The respective sums are 8, 7, 9, and 6, so the maximum sum is 9. Return the maximum sum of any subarray of length `m`.","solution":"def max_subarray_sum(array, m): Returns the maximum sum of any subarray of length exactly m. if len(array) < m or m <= 0: return 0 max_sum = current_sum = sum(array[:m]) for i in range(m, len(array)): current_sum = current_sum - array[i - m] + array[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given an integer array `heights` representing the heights of a group of students standing in a line, return the minimum number of indices where the heights need to be swapped to make the entire array sorted in non-decreasing order. Note that each student must maintain their original position index after sorting. You need to determine the indices that are out of place and return the count of such indices.","solution":"def count_swaps_to_sort(heights): Returns the minimum number of indices where the heights need to be swapped to make the entire array sorted in non-decreasing order. sorted_heights = sorted(heights) out_of_place_count = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: out_of_place_count += 1 return out_of_place_count"},{"question":"Given an integer array `nums` of length `n`, you need to determine if it is possible to make the entire array strictly increasing by modifying at most one element. An array `a` is considered strictly increasing if `a[i] < a[i+1]` for all `0 <= i < n-1`. Return _`true` if the array can be modified to be strictly increasing by modifying at most one element, otherwise return_ `false`.","solution":"def can_be_strictly_increasing(nums): Determines if the array can be made strictly increasing by modifying at most one element. n = len(nums) if n == 1: return True # Count the number of places where nums[i] is not less than nums[i + 1] count = 0 for i in range(n - 1): if nums[i] >= nums[i + 1]: count += 1 if count > 1: return False # If nums[i] >= nums[i+1], we can either change nums[i] or nums[i+1] if i > 0 and nums[i-1] >= nums[i+1] and i < n-2 and nums[i] >= nums[i+2]: return False return True"},{"question":"You are given an array of `n` integers `nums` and an integer `k` representing the number of sliding operations. Your goal is to perform exactly `k` sliding operations on the array, where each sliding operation consists of removing the smallest element from the array and appending it to the end of the array. After performing `k` sliding operations, return the resulting array. Note that multiple elements can be the smallest, but you should only remove and append one element per operation.","solution":"def sliding_operations(nums, k): Perform k sliding operations on the array `nums`, where each sliding operation consists of removing the smallest element from the array and appending it to the end of the array. Args: nums (List[int]): The array of integers. k (int): The number of sliding operations to perform. Returns: List[int]: The resulting array after performing k sliding operations. for _ in range(k): min_element = min(nums) nums.remove(min_element) nums.append(min_element) return nums"},{"question":"You are given a list of events, each represented by a pair of integers `[start, end]` indicating the start and end times of the event. An event `[start, end]` is considered overlapping with another event `[start2, end2]` if `start < end2` and `start2 < end`. Given a list of such events, your task is to determine the minimum number of meeting rooms required to accommodate all events without any overlaps. Implement the function `minMeetingRooms(events)` that takes a list of events and returns the minimum number of meeting rooms needed.","solution":"def minMeetingRooms(events): if not events: return 0 starts = sorted(event[0] for event in events) ends = sorted(event[1] for event in events) start_pointer = 0 end_pointer = 0 num_rooms = 0 max_rooms = 0 while start_pointer < len(events): if starts[start_pointer] < ends[end_pointer]: num_rooms += 1 start_pointer += 1 else: num_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, num_rooms) return max_rooms"},{"question":"You are given a list `logs` where each element is a string in the format `\\"id status timestamp\\"`. Here, `id` is an identifier, `status` is either `\\"start\\"` or `\\"end\\"`, and `timestamp` is an integer representing the start or end time of an event. Each `\\"id\\"` can have only one `\\"start\\"` and one `\\"end\\"` event. The task is to calculate the total duration of each event denoted by its `id` and output it as a dictionary where the key is the `id` and the value is the total time (`end` time minus `start` time) the event lasted. If an event has not ended (missing `end` time), assume its duration is `0`. Write a function that takes the list `logs` and returns the required dictionary.","solution":"def calculate_event_durations(logs): Calculate the total duration of each event. Parameters: logs (list): List of strings in the format \\"id status timestamp\\" Returns: dict: Dictionary where key is the event \'id\' and value is the total duration of the event. events = {} # Dictionary to store the start time of each event. start_times = {} for log in logs: log_parts = log.split() event_id = log_parts[0] status = log_parts[1] timestamp = int(log_parts[2]) if status == \\"start\\": start_times[event_id] = timestamp elif status == \\"end\\": if event_id in start_times: duration = timestamp - start_times[event_id] events[event_id] = duration # For events that have a start time but no end time, set their duration to 0. for event_id in start_times: if event_id not in events: events[event_id] = 0 return events"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. In one operation, you can choose any `a` in the string and replace it with either \'b\' or \'c\'. Similarly, you can choose any `b` and replace it with either \'a\' or \'c\', and you can choose any `c` and replace it with either \'a\' or \'b\'. Your goal is to make the string have **no instances of three consecutive identical characters** after performing any number of operations. Return _the **minimum number of operations** required to achieve this_. If the string already satisfies the condition, return 0.","solution":"def min_operations_to_avoid_consecutive(s): Returns the minimum number of operations required to avoid three consecutive identical characters in the string. operations = 0 i = 0 while i < len(s) - 2: if s[i] == s[i+1] == s[i+2]: operations += 1 i += 2 else: i += 1 return operations"},{"question":"You are given two integer arrays `arr1` and `arr2` of equal length. Each element in `arr1` can be incremented or decremented by 1 in one operation. Determine the minimum number of operations required to make the two arrays identical.","solution":"def min_operations_to_make_identical(arr1, arr2): Determine the minimum number of operations required to make arr1 identical to arr2. Each element in arr1 can be incremented or decremented by 1 in one operation. Parameters: arr1 (list of int): The first array. arr2 (list of int): The second array. Returns: int: The minimum number of operations required. return sum(abs(a1 - a2) for a1, a2 in zip(arr1, arr2))"},{"question":"You are given a **2D integer matrix** `grid` of size `n x m`. Your task is to find the **maximum sum** of a rectangle in the matrix whose sum is at most `k`. A rectangle is defined by its **top-left** and **bottom-right** corners within the matrix. If there is no valid rectangle, return `-1`.","solution":"import bisect def maxSumSubmatrix(matrix, k): Find the maximum sum of a rectangle in the matrix whose sum is at most k. Parameters: matrix (list of list of int): The 2D integer matrix. k (int): The maximum sum limit for the rectangle. Returns: int: The maximum sum of a rectangle whose sum is at most k, or -1 if no such rectangle exists. def maxSumSubarray(arr, k): accu_sum = [0] curr_sum = 0 max_sum = float(\'-inf\') for sum_ in arr: curr_sum += sum_ idx = bisect.bisect_left(accu_sum, curr_sum - k) if idx < len(accu_sum): max_sum = max(max_sum, curr_sum - accu_sum[idx]) bisect.insort(accu_sum, curr_sum) return max_sum if not matrix: return -1 rows, cols = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left in range(cols): row_sums = [0] * rows for right in range(left, cols): for r in range(rows): row_sums[r] += matrix[r][right] curr_max_sum = maxSumSubarray(row_sums, k) max_sum = max(max_sum, curr_max_sum) return max_sum if max_sum != float(\'-inf\') else -1"},{"question":"Given a string `s` representing a mathematical expression, implement a basic calculator to evaluate it. The expression `s` can contain \'+\', \'-\', \'(\', \')\', non-negative integers, and white spaces. Return the result of the evaluation. Note that you are not allowed to use any built-in library function to directly evaluate the expression (like eval()). The string length will be in the range [1, 3 * 10^5], and the integer values are guaranteed to fit within the range of a 32-bit signed integer.","solution":"def calculate(s: str) -> int: def evaluate(tokens): stack = [] num = 0 sign = 1 while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) while len(tokens) > 0 and tokens[0].isdigit(): num = num * 10 + int(tokens.pop(0)) stack.append(sign * num) num = 0 elif token == \'+\': sign = 1 elif token == \'-\': sign = -1 elif token == \'(\': num = evaluate(tokens) stack.append(sign * num) num = 0 elif token == \')\': break return sum(stack) # Remove the spaces and convert to list of tokens tokens = list(s.replace(\' \', \'\')) return evaluate(tokens)"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to segment the array into consecutive non-overlapping subarrays, such that each subarray has a sum less than or equal to `k`, and minimize the number of subarrays that respect this condition. A subarray is defined as a contiguous portion of the original array. Return _the **minimum** number of subarrays needed such that the sum of each subarray is **less than or equal to**_ `k`.","solution":"def min_subarrays_with_max_sum(arr, k): Returns the minimum number of subarrays needed such that the sum of each subarray is less than or equal to k. :param arr: List[int] - The input array of integers :param k: int - The maximum allowed sum of each subarray :return: int - The minimum number of subarrays required n = len(arr) current_sum = 0 subarray_count = 0 for num in arr: # If a single element is greater than k, we cannot satisfy the condition if num > k: raise ValueError(f\\"A single element ({num}) in the array is greater than k ({k})\\") if current_sum + num <= k: current_sum += num else: subarray_count += 1 current_sum = num # For the last subarray if current_sum > 0: subarray_count += 1 return subarray_count"},{"question":"You are given a binary tree represented as an array where null values are represented by `None`. Write a function that returns the **maximum sum** of any path from the tree\'s root node to any leaf node. A leaf node is a node with no children. The path must follow the parent-child connections established in the tree structure.","solution":"def max_path_sum(tree): Given a binary tree represented as a list, calculates the maximum sum from the root to any leaf node. if not tree or tree[0] is None: return 0 def helper(index): if index >= len(tree) or tree[index] is None: return 0 left_index = 2 * index + 1 right_index = 2 * index + 2 left_sum = helper(left_index) right_sum = helper(right_index) if left_sum == 0 and right_sum == 0 and (left_index < len(tree) or right_index < len(tree)): return tree[index] return tree[index] + max(left_sum, right_sum) return helper(0)"},{"question":"Write a function that simulates a water pouring process. You are given two jugs with capacities `jug1Capacity` and `jug2Capacity` respectively. There is an infinite amount of water supply. Your goal is to measure exactly `targetCapacity` liters of water using these two jugs. Implement a function that returns a boolean value of `True` if the target can be achieved and `False` otherwise. The allowed operations in one move are: - Fill any one jug completely. - Empty any one jug. - Pour water from one jug to the other until either the other jug is full or the first jug is empty.","solution":"def canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity): Determine if it is possible to measure exactly targetCapacity using the two jugs. from math import gcd # If the target capacity is greater than the combined capacity of the two jugs, it\'s impossible if targetCapacity > jug1Capacity + jug2Capacity: return False # If the target capacity is zero, it\'s always possible if targetCapacity == 0: return True # Using the theory of Bezout\'s identity, check if the targetCapacity is a multiple of the GCD return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0"},{"question":"Given a list of integers, where each integer represents the number of days required to complete a task, return the minimum number of units of time needed to complete all tasks when up to `k` tasks can be performed simultaneously per unit time.","solution":"import math def min_time_to_complete_tasks(tasks, k): Returns the minimum number of units of time needed to complete all tasks where up to `k` tasks can be performed simultaneously per unit time. :param tasks: List of integers representing the number of days required for each task. :param k: Integer, maximum number of tasks that can be performed simultaneously. :return: Integer, minimum number of units of time needed to complete all tasks. total_days = sum(tasks) return math.ceil(total_days / k)"},{"question":"Given a string `s` and a string `t`, you want to generate the string `t` using the characters from `s` following these rules: 1. Only lower-case letters will be used. 2. Each character from `s` can be used at most once. 3. The characters in `s` can be rearranged in any order. Return `true` if you can generate `t` using the characters from `s`, otherwise return `false`.","solution":"def can_generate(s, t): Returns True if string t can be generated from the characters in string s. from collections import Counter # Count the characters in both strings s_count = Counter(s) t_count = Counter(t) # Check if t can be formed from s by comparing character counts for char, count in t_count.items(): if s_count[char] < count: return False return True"},{"question":"A **card game** involves a deck of `n` cards uniquely numbered from `1` to `n`. The game starts by arranging the cards in a line in a **random order**. You have to rearrange the cards into the sequence `1, 2, ..., n` by performing a series of allowed moves. In each move, you can pick any subsequence of cards that forms an increasing sequence and move it to the front of the deck. Given the initial random order of the cards as an array `cards`, return _the **minimum number** of moves required to sort the deck_.","solution":"def min_moves_to_sort(cards): Returns the minimum number of moves required to sort the deck. Args: cards (List[int]): A list of integers representing the initial order of cards. Returns: int: The minimum number of moves required to sort the deck. n = len(cards) # Create a list to store the length of the longest increasing subsequence ending at each index lis = [1] * n for i in range(1, n): for j in range(i): if cards[i] > cards[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # The result will be the total number of cards minus the length of the longest increasing subsequence return n - max(lis)"},{"question":"Given an array of integers `arr`, you are tasked with finding the length of the longest subarray with a sum equal to 0. Implement the function `int longestZeroSumSubarray(int[] arr)` which returns an integer representing the length of the longest subarray. The function must run in `O(n)` time complexity.","solution":"def longestZeroSumSubarray(arr): Returns the length of the longest subarray with sum equal to 0. hashmap = {} max_len = 0 current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == 0: max_len = i + 1 if current_sum in hashmap: max_len = max(max_len, i - hashmap[current_sum]) else: hashmap[current_sum] = i return max_len"},{"question":"Given an `m x n` matrix `matrix` and an integer `k`, return _the **kth** smallest element in the matrix_. Note that it is the `kth` smallest element in the sorted order, not the `kth` distinct element. The matrix is sorted in a non-decreasing order both row-wise and column-wise.","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in a sorted m x n matrix n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Remove the smallest element from the heap k-1 times for _ in range(k - 1): value, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to partition the string into the minimum number of contiguous substrings such that each character appears in at most one substring. Return the _minimum number of partitions_ you can achieve. For example, if `s = \\"ababcbacadefegdehijhklij\\"`, the result would be 3 because the string can be partitioned as `[\\"ababcbaca\\", \\"defegde\\", \\"hijhklij\\"]` where each character appears only in one substring.","solution":"def partition_labels(s): Returns the minimum number of partitions such that each character appears in at most one substring. # Step 1: Record the last occurrence of each character last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] # This will store the sizes of each partition start, end = 0, 0 # Step 2: Traverse the string and determine the partitions for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions.append(s[start:end+1]) start = i + 1 return len(partitions)"},{"question":"Given an unsorted array of integers `nums`, reorder it such that all odd elements come before all even elements. You must solve it in `O(n)` time and with `O(1)` extra space. Return the reordered array.","solution":"def reorder_odd_even(nums): Reorder the array such that all odd elements come before all even elements. Parameters: nums (list): The list of integers. Returns: list: The reordered list with all odd elements before even elements. left, right = 0, len(nums) - 1 while left < right: while left < right and nums[left] % 2 != 0: left += 1 while left < right and nums[right] % 2 == 0: right -= 1 if left < right: nums[left], nums[right] = nums[right], nums[left] return nums"},{"question":"You are given an array of strings `words` and a string `target`. Your task is to construct `target` using any number of words from the `words` array. Each word can be used multiple times. Return the total number of distinct ways to construct `target` using the given `words`. If it is not possible to construct `target`, return `0`. Two ways are considered distinct if the order of the words used differs.","solution":"def count_construct(target, words): Returns the number of ways to construct the target using the words from the words array. Each word can be used multiple times. memo = {} def helper(t): if t in memo: return memo[t] if t == \\"\\": return 1 count = 0 for word in words: if t.startswith(word): suffix = t[len(word):] count += helper(suffix) memo[t] = count return count return helper(target)"},{"question":"You are given a **0-indexed** integer array `nums` representing the number of candies in each basket. You also have an integer `k`, representing the number of baskets you want to distribute the candies into so that each basket ends up with the same total number of candies. Determine if it\'s possible to distribute the candies from all the baskets into exactly `k` baskets without any candies left over. Return `true` if it\'s possible, otherwise return `false`.","solution":"def can_distribute_evenly(nums, k): Check if candies can be evenly distributed into exactly k baskets. Parameters: nums (list): A list of integers representing the number of candies in each basket. k (int): Number of baskets to distribute the candies into. Returns: bool: True if candies can be evenly distributed, otherwise False. total_candies = sum(nums) return total_candies % k == 0"},{"question":"A company is designing a new parking lot. The parking lot is represented as a grid of size `m x n`, where each cell can be either empty or occupied by a parked car. Each cell is represented by either a `0` (empty) or `1` (occupied by a car). The company wants to install charging stations for electric cars such that every parked car in the parking lot can access at least one charging station. Given the grid `parkingLot`, return _the **minimum number of charging stations** required to ensure that every parked car can access at least one charging station_. A parked car can directly access a charging station if the station is located in the same row, same column, or in one of the diagonal positions adjacent to the car. You are required to determine the optimal placement of charging stations and return the minimum number of stations required for the entire parking lot.","solution":"def minChargingStations(parkingLot): rows = len(parkingLot) cols = len(parkingLot[0]) def countCoverage(x, y): coverage_positions = set() for i in range(rows): if parkingLot[i][y] == 1: coverage_positions.add((i, y)) for j in range(cols): if parkingLot[x][j] == 1: coverage_positions.add((x, j)) for i in range(rows): for j in range(cols): if abs(x - i) == abs(y - j) and parkingLot[i][j] == 1: coverage_positions.add((i, j)) return coverage_positions car_positions = [(i, j) for i in range(rows) for j in range(cols) if parkingLot[i][j] == 1] charging_stations = 0 while car_positions: max_coverage = 0 best_position = None best_coverage_set = set() for i in range(rows): for j in range(cols): coverage_set = countCoverage(i, j) if len(coverage_set) > max_coverage: max_coverage = len(coverage_set) best_position = (i, j) best_coverage_set = coverage_set charging_stations += 1 car_positions = [car for car in car_positions if car not in best_coverage_set] for car in best_coverage_set: parkingLot[car[0]][car[1]] = 0 return charging_stations"},{"question":"You are given an m x n integer matrix `heights` representing the heights of each cell in a 2D grid. An oceanic wave can flow from one cell to another if and only if the height of the latter cell is less than or equal to the height of the former cell. Two types of oceans are on either side of this matrix: - The **Pacific Ocean** touches the left and top edges. - The **Atlantic Ocean** touches the right and bottom edges. Return a list of grid coordinates where the oceanic waves can flow to both the Pacific and Atlantic oceans.","solution":"def pacific_atlantic(heights): if not heights: return [] m, n = len(heights), len(heights[0]) pacific_queue = [(i, 0) for i in range(m)] + [(0, j) for j in range(1, n)] atlantic_queue = [(i, n-1) for i in range(m)] + [(m-1, j) for j in range(n-1)] def bfs(queue): reachable = set(queue) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.pop(0) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in reachable and heights[nx][ny] >= heights[x][y]: reachable.add((nx, ny)) queue.append((nx, ny)) return reachable pacific_reachable = bfs(pacific_queue) atlantic_reachable = bfs(atlantic_queue) return list(pacific_reachable & atlantic_reachable)"},{"question":"Implement a function `findBuildingsWithSunsetView(heights)` that takes a list of integers, `heights`, representing the heights of buildings in a city from east to west. The function should return a list of indices (0-based) of the buildings that have a view of the sunset. A building has a sunset view if there are no taller buildings to the west (to the right) of it. The returned indices should be in the order from east to west.","solution":"def findBuildingsWithSunsetView(heights): Returns the list of indices of buildings that have a sunset view. A building has a sunset view if there are no taller buildings to the west (to the right) of it. :param heights: List of integers representing the heights of buildings from east to west :return: List of indices of buildings with sunset view. result = [] max_height = 0 for i in range(len(heights) - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] result.reverse() # Reverse to maintain the order from east to west return result"},{"question":"A popular online store sells candles of varying heights. Each candle can be placed on top of another but with the restriction that a candle can only be placed on a shorter one. You are given a list of integers `candles` where each integer represents the height of a candle. Your task is to determine the maximum number of candles that can be stacked on top of one another. Return an integer representing the maximum stacking height that can be achieved. Write a function that takes in the list `candles` and returns the maximum stack height.","solution":"def max_candle_stack(candles): Returns the maximum number of candles that can be stacked on top of one another. if not candles: return 0 candles.sort(reverse=True) max_stack_height = 1 cur_height = candles[0] for height in candles[1:]: if height < cur_height: max_stack_height += 1 cur_height = height return max_stack_height"},{"question":"You are given a 2D grid of size `m x n` representing a box, and you have `n` balls. The box is open on the top and bottom sides. Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left. - A board that redirects a ball to the right spans the top-right corner to the bottom-left corner in the cell and is represented in the grid as `1`. - A board that redirects a ball to the left spans the top-left corner to the bottom-right corner in the cell and is represented in the grid as `-1`. We drop one ball at a time from the top of each column of the grid. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits the side of the box or `2` consecutive boards directed in the opposite direction. Return _an array_ `answer` _of size `n`_ _where_ `answer[i]` _is the column that the ball falls out of at the bottom after dropping the ball from the_ `i`th _column at the top, or** `-1` **if the ball gets stuck in the box_.","solution":"def findBall(grid): Simulates the fall of each ball in the grid and determines the column it exits or gets stuck. Parameters: grid (List[List[int]]): 2D list representing the grid of diagonal boards. Returns: List[int]: List of integers where each element is the exit column or -1 if the ball gets stuck. m, n = len(grid), len(grid[0]) result = [] for start_col in range(n): col = start_col for row in range(m): direction = grid[row][col] next_col = col + direction # Check if the ball gets stuck if next_col < 0 or next_col >= n or grid[row][next_col] != direction: col = -1 break col = next_col result.append(col) return result"},{"question":"Given a list of `n` integers, find the length of the **longest increasing subsequence (LIS)**. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The following points should be considered: - Your algorithm should aim for a time complexity of `O(n log n)`. - If there are multiple longest increasing subsequences of the same length, you only need to return the length. For example, given the input list `[10, 9, 2, 5, 3, 7, 101, 18]`, the output would be `4` because the longest increasing subsequence is `[2, 3, 7, 101]`.","solution":"import bisect def length_of_lis(nums): Returns the length of the longest increasing subsequence in the list of integers. if not nums: return 0 lis = [] # This will store the smallest tail of all increasing subsequences of different lengths found so far. for num in nums: # Find the index in lis where num should be placed to maintain order in lis index = bisect.bisect_left(lis, num) # If index is equal to the length of lis, it means num is greater than any element in lis and can extend the largest subsequence if index == len(lis): lis.append(num) else: # Otherwise, replace the element at the found index with num lis[index] = num return len(lis)"},{"question":"You are given a **0-indexed** array of integers `numbers` of length `n`. A subarray of `numbers` is said to be a **balanced subarray** if the sum of its elements is exactly `k`. Return _the number of **balanced subarrays** in_ `numbers`. A **subarray** is a contiguous non-empty sequence of elements within an array.","solution":"def count_balanced_subarrays(numbers, k): Returns the number of balanced subarrays in the given list \'numbers\' that sum up to \'k\'. count = 0 n = len(numbers) for i in range(n): curr_sum = 0 for j in range(i, n): curr_sum += numbers[j] if curr_sum == k: count += 1 return count"},{"question":"A robot is located at the top-left corner of a `m x n` grid (marked \'Start\' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \'Finish\' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. ``` Example: Input: [ [0,0,0], [0,1,0], [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right ``` Given an `m x n` grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.","solution":"def unique_paths_with_obstacles(obstacle_grid): Returns the number of unique paths to reach from the top-left corner to the bottom-right corner, navigating through a grid with obstacles. :param obstacle_grid: List[List[int]] :return: int if not obstacle_grid or obstacle_grid[0][0] == 1: return 0 m, n = len(obstacle_grid), len(obstacle_grid[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 # Starting point for i in range(m): for j in range(n): if obstacle_grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"You are given a list of non-negative integers representing the amount of money of each house located along a street. Each house is labeled as `nums[i]`. An experienced robber is planning to rob the houses along the street, but he can only rob two houses if they are not adjacent to each other. Given the list `nums`, return _the maximum amount of money the robber can steal without alerting the police_.","solution":"def rob(nums): Given a list of non-negative integers representing the amount of money of each house located along a street, returns the maximum amount of money the robber can steal without alerting the police. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # dp[i] represents the maximum amount of money we can rob up to house i dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): # Decide whether to rob house i or not dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"Given a 2D grid of `m` by `n` cells, where each cell is either land (`1`) or water (`0`), you need to find the largest island. An island is a group of `1`s (land) connected 4-directionally (horizontal or vertical). You may choose to flip one `0` (water) to `1` (land) to form a larger island. Return the size of the largest island possible after converting at most one water cell to land. If no water cell can be converted to increase the maximum island size, return the size of the original largest island.","solution":"def largest_island(grid): def dfs(r, c, index): stack = [(r, c)] islands[index] = 0 while stack: i, j = stack.pop() if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1: grid[i][j] = index islands[index] += 1 stack.extend([(i-1, j), (i+1, j), (i, j-1), (i, j+1)]) return islands[index] rows, cols = len(grid), len(grid[0]) islands = {} index = 2 for r in range(rows): for c in range(cols): if grid[r][c] == 1: dfs(r, c, index) index += 1 max_island = max(islands.values(), default=0) for r in range(rows): for c in range(cols): if grid[r][c] == 0: neighbors = set() for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: if 0 <= i < rows and 0 <= j < cols and grid[i][j] > 1: neighbors.add(grid[i][j]) new_area = 1 + sum(islands[idx] for idx in neighbors) max_island = max(max_island, new_area) return max_island"},{"question":"You are given a `n x n` 2D matrix `matrix` representing an image, where each entry in the matrix contains an integer representing the pixel intensity. Rotate the image by 90 degrees (clockwise). You have to modify the input `matrix` in-place without using any extra space for another matrix. Return the modified `matrix` after rotating it by 90 degrees clockwise.","solution":"def rotate(matrix): Rotates the given n x n matrix by 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): The n x n matrix to be rotated. Returns: List[List[int]]: The rotated matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given a binary tree. Design an algorithm to serialize and deserialize the tree. The binary tree is serialized into a string, and this string should be deserialized back to the original binary tree. The structure and the values of the tree nodes should be maintained accurately during this conversion process. Serialize the following binary tree: ``` 1 / 2 3 / 4 5 ``` The serialized data would be a string in such a format that allows for reliable reconstruction into the same binary tree. Provide both the serialization and deserialization functions.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def helper(node): if node is None: return \\"None,\\" return str(node.val) + \\",\\" + helper(node.left) + helper(node.right) return helper(root) def deserialize(data): Decodes your encoded data to tree. def helper(data_list): if data_list[0] == \\"None\\": data_list.pop(0) return None node = TreeNode(int(data_list[0])) data_list.pop(0) node.left = helper(data_list) node.right = helper(data_list) return node data_list = data.split(\\",\\") return helper(data_list[:-1])"},{"question":"A group of friends is planning to hang out at different restaurants. Each restaurant has two attributes: `cost` and `rating`. You are given two integer arrays `costs` and `ratings`, where `costs[i]` is the cost of the i-th restaurant and `ratings[i]` is the rating of the i-th restaurant. They have a limited budget `B` and want to maximize the total rating of the restaurants they can visit without exceeding their budget. Return the maximum total rating they can achieve.","solution":"def maximize_ratings(costs, ratings, budget): Function to maximize the total rating without exceeding the budget. Parameters: costs (list of int): Costs of the restaurants. ratings (list of int): Ratings of the restaurants. budget (int): Budget limit. Returns: int: Maximum total rating achievable within the budget. n = len(costs) dp = [[0 for _ in range(budget + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for b in range(budget + 1): if costs[i - 1] <= b: dp[i][b] = max(dp[i - 1][b], ratings[i - 1] + dp[i - 1][b - costs[i - 1]]) else: dp[i][b] = dp[i - 1][b] return dp[n][budget]"},{"question":"Given a list of `start` and `end` times for a collection of meetings, where each meeting is represented as a tuple `(start, end)`, return the maximum number of meetings that can be attended by a single person. A person can attend a meeting if and only if the meeting starts after the previous meeting ends. If two meetings end at the same time, a person can still attend another meeting starting at that very time. Extend the functionality to return the sorted list of the indexes (0-indexed) of the meetings attended for this maximum count. If there are multiple correct answers, return any one of them.","solution":"def max_meetings(meetings): Returns the maximum number of meetings that can be attended by a single person, and the list of indexes of the meetings attended. # Pair indices with meetings and sort by the end time. indexed_meetings = sorted(enumerate(meetings), key=lambda x: (x[1][1], x[1][0])) count = 0 end_time = -1 attended_indices = [] for index, (start, end) in indexed_meetings: if start >= end_time: count += 1 end_time = end attended_indices.append(index) return count, attended_indices"},{"question":"You are given an array of `n` positive integers where all elements except one element appear an even number of times. Find and return the element that appears an odd number of times. The solution should have a linear time complexity of `O(n)` and use a constant space complexity of `O(1)`.","solution":"def find_odd_occurrence(arr): Returns the element that appears an odd number of times in the array. Uses bitwise XOR to achieve linear time complexity and constant space complexity. result = 0 for num in arr: result ^= num return result"},{"question":"A company wishes to track the compensation given to its employees on a bi-weekly basis. The company issues a report that consists of a list of tuples, where each tuple represents the compensation details for an employee in a given week. Each tuple consists of three values: `(employee_id, week_number, compensation)`. Your task is to write a function that takes this list of tuples and returns a dictionary where each `employee_id` maps to their total compensation over the provided weeks. For instance, given the list `[(1, 1, 1000), (2, 1, 1500), (1, 2, 1000), (2, 2, 1600), (1, 3, 1100)]`, the function should return `{1: 3100, 2: 3100}`.","solution":"def calculate_total_compensation(compensation_list): Calculates the total compensation for each employee over the provided weeks. Parameters: compensation_list (list of tuples): List of tuples where each tuple represents the compensation details for an employee in a given week Returns: dict: A dictionary where each employee_id maps to their total compensation over the provided weeks total_compensation = {} for employee_id, week_number, compensation in compensation_list: if employee_id not in total_compensation: total_compensation[employee_id] = 0 total_compensation[employee_id] += compensation return total_compensation"},{"question":"You are given an array `nums` of integers. Your task is to find and return the **length** of the longest contiguous subsequence such that every element in the subsequence is either strictly increasing or strictly decreasing. Note that the sequence should not be static; it must exhibit a change from one element to the next. For example, in the array `[1, 3, 2, 2, 4, 5, 3]`, the longest contiguous sequence could be `[1, 3, 2, 2]`, resulting in a length of `3` (ignoring `2` as it causes a static subsequence).","solution":"def longest_contiguous_sequence(nums): if not nums: return 0 max_length = 1 current_length = 1 is_increasing = None for i in range(1, len(nums)): if nums[i] > nums[i-1]: if is_increasing is None or is_increasing: current_length += 1 else: current_length = 2 is_increasing = True elif nums[i] < nums[i-1]: if is_increasing is None or not is_increasing: current_length += 1 else: current_length = 2 is_increasing = False else: current_length = 1 is_increasing = None max_length = max(max_length, current_length) return max_length"},{"question":"You are given a list of strings `words` of length `n`. Each string in `words` is uppercase and has the same length. You need to find the length of the **longest common prefix** shared among all the strings in the list `words`. A common prefix is a substring that appears at the beginning of each string. If there is no common prefix, return `0`.","solution":"def longest_common_prefix(words): Finds the length of the longest common prefix in a list of words. :param words: List of uppercase strings of equal length :return: Length of the longest common prefix if not words: return 0 min_length = min(len(word) for word in words) prefix_length = 0 for i in range(min_length): current_char = words[0][i] if all(word[i] == current_char for word in words): prefix_length += 1 else: break return prefix_length"},{"question":"You are given an **m x n** integer matrix `grid`. A **move** consists of choosing any element and incrementing or decrementing it by 1. A matrix is considered \\"balanced\\" if every row has the same sum and every column has the same sum. Determine the **minimum number of moves** required to make the matrix balanced, or return `-1` if it\'s not possible.","solution":"def min_moves_to_balance_grid(grid): Determine the minimum number of moves needed to balance the grid. If balancing is not possible, return -1. :param grid: List[List[int]]: The input grid. :return: int: The minimum number of moves, or -1 if not possible. m = len(grid) n = len(grid[0]) # Calculate the sum of each row and each column row_sums = [sum(row) for row in grid] col_sums = [sum(grid[i][j] for i in range(m)) for j in range(n)] # Check if all row sums and column sums are equal if len(set(row_sums)) != 1 or len(set(col_sums)) != 1: return -1 # If we reach here, that means balanced grid is possible avg_row_sum = row_sums[0] avg_col_sum = col_sums[0] row_moves = sum(abs(sum(row) - avg_row_sum) for row in grid) col_moves = sum(abs(sum(grid[i][j] for i in range(m)) - avg_col_sum) for j in range(n)) # Since each move affects both row and column, we count half the total moves return (row_moves + col_moves) // 2"},{"question":"You are given an integer array `arr` and an integer `n`. You need to perform the following operations exactly `n` times: choose any subarray (continuous part) of the array and reverse it. Return the lexicographically smallest array possible after performing the operations.","solution":"def reverse_subarray_to_minimize(arr, n): Returns the lexicographically smallest array possible after performing the operation of reversing any subarray exactly n times. :param arr: List[int] - List of integers. :param n: int - Number of times to perform the reversing operation. :return: List[int] - Lexicographically smallest array possible. # If n==0, return the array as is if n == 0: return arr # If we have at least one operation, we can sort the array to get the # lexicographically smallest permutation arr.sort() return arr"},{"question":"Given an array of integers `arr`, return the **maximum** sum of any **non-empty** subarray that can be obtained by deleting at most one element from the array. A subarray is a contiguous part of an array.","solution":"def maximum_sum(arr): Returns the maximum sum of any non-empty subarray that can be obtained by deleting at most one element from the array. :param arr: List[int] - The array of integers :return: int - The maximum sum if not arr: raise ValueError(\\"Array should not be empty\\") n = len(arr) dp1 = [0] * n # Maximum subarray sum we can get ending at each index without deleting any elements dp2 = [0] * n # Maximum subarray sum we can get ending at each index with deleting one element dp1[0] = arr[0] dp2[0] = arr[0] result = arr[0] for i in range(1, n): dp1[i] = max(dp1[i-1] + arr[i], arr[i]) dp2[i] = max(dp1[i-1], dp2[i-1] + arr[i]) result = max(result, dp1[i], dp2[i]) return result"},{"question":"Given an array of positive integers representing the heights of buildings, where each building\'s width is exactly `1`, find the amount of rainwater that can be trapped between the buildings after it rains. The amount of rainwater trapped on top of each building is determined by the difference between the height of the building and the shortest of the buildings to its left and right. Assume that the buildings at the ends of the array cannot trap any water. Return the total amount of trapped rainwater.","solution":"def trap_rainwater(heights): Given a list of building heights, returns the total amount of rainwater that can be trapped between the buildings. Parameters: heights (list): A list of positive integers representing the heights of buildings. Returns: int: The total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the total trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"Given an array of integers `nums`, find the **nearest smaller element** for each element in the array. The **nearest smaller element** for an element `x` in the array is the largest element on the left side of `x` that is smaller than `x`. If no such element exists for `x`, consider the nearest smaller element to be `-1`. Return an array of integers where the `i-th` element is the **nearest smaller element** for the element at `i-th` position in the input array. [Question] 4:","solution":"def nearest_smaller_elements(nums): Function to find the nearest smaller element for each element in the array. Parameters: nums (list): List of integers. Returns: list: List of nearest smaller elements for each input element. result = [] stack = [] for num in nums: while stack and stack[-1] >= num: stack.pop() if stack: result.append(stack[-1]) else: result.append(-1) stack.append(num) return result"},{"question":"You are given an array of `n` integers where each integer is in the range from `1` to `n` inclusive. Some elements appear twice and others appear once. Find all the elements of `[1, n]` inclusive that do not appear in this array. You must implement your solution with a linear runtime complexity and use only constant extra space. Return an array of the missing elements.","solution":"def find_disappeared_numbers(nums): Finds all the elements that are missing from the array where each integer is in the range from 1 to n inclusive. Args: nums (List[int]): List of integers where each integer is in the range from 1 to n inclusive. Returns: List[int]: List of missing elements between 1 and n. # Iterate over each number and mark the corresponding index negative for i in range(len(nums)): val = abs(nums[i]) - 1 if nums[val] > 0: nums[val] = -nums[val] # The positive numbers\' indices + 1 are the missing numbers return [i + 1 for i in range(len(nums)) if nums[i] > 0]"},{"question":"You are given a **directed, weighted graph** with `n` nodes numbered from `0` to `n - 1`, represented by an edge list `edges` where `edges[i] = [ui, vi, wi]` denotes an edge from node `ui` to node `vi` with weight `wi`. You are also given an integer `start` representing the starting node and an integer `destination` representing the destination node. Your task is to implement a function to find the **shortest path** from the starting node to the destination node considering the weights of the edges. If there is no path from `start` to `destination`, return `-1`. Otherwise, return the **total weight** of the shortest path.","solution":"import heapq from collections import defaultdict def shortest_path(n, edges, start, destination): Returns the total weight of the shortest path from start to destination. If there is no path, returns -1. # Create graph representation graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Dijkstra\'s algorithm heap = [(0, start)] distances = {node: float(\'inf\') for node in range(n)} distances[start] = 0 while heap: current_distance, current_node = heapq.heappop(heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return distances[destination] if distances[destination] != float(\'inf\') else -1"},{"question":"Write a function that takes a string `s` and returns the number of substrings that are palindromes. A substring is a contiguous sequence of characters within the string. A palindromic string reads the same backward as forward. For this problem, single character substrings are also considered palindromic.","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the input string `s`. if not s: return 0 n = len(s) count = 0 # Create a 2D array to store whether a substring is palindrome dp = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): dp[i][i] = True count += 1 # Check for 2-character palindromes for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True count += 1 # Check for longer substrings for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True count += 1 return count"},{"question":"You are given an integer array `nums` consisting of `n` elements, all in the range `1` to `n` inclusive, and there is **exactly one** duplicate element in the array. Your task is to find and return this duplicate number. You must solve the problem without modifying the array `nums` and use only constant, `O(1)` extra space. Note that the duplicates may appear more than once in the array, but there is only one number that is duplicated.","solution":"def find_duplicate(nums): Find and return the duplicate number in the given array nums. The solution uses Floyd\'s Tortoise and Hare (Cycle Detection) algorithm. if len(nums) <= 1: return None # Initialize the Tortoise and Hare tortoise = nums[0] hare = nums[0] # Phase 1: Find the intersection point of the two runners while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Phase 2: Find the entrance to the cycle tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"Design an algorithm to generate all possible **valid parenthesis combinations** for a given number of pairs of parentheses. Implement the `ParenthesisGenerator` class with the following methods: * `ParenthesisGenerator(int pairs)` Initializes the data structure with the given number of pairs of parentheses. * `List<String> generateCombinations()` Generates and returns a list of all valid combinations of parentheses. For example, given `pairs = 3`, the method should return: ``` [ \\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\" ] ```","solution":"class ParenthesisGenerator: def __init__(self, pairs): self.pairs = pairs def generateCombinations(self): result = [] self._generate(self.pairs, self.pairs, \\"\\", result) return result def _generate(self, open, close, current, result): if open == 0 and close == 0: result.append(current) return if open > 0: self._generate(open-1, close, current + \\"(\\", result) if close > open: self._generate(open, close-1, current + \\")\\", result)"},{"question":"Given a list of `n` positive integers `nums`, arrange them such that they form the largest possible concatenated number. Return the largest concatenated number in string form. The resulting string should not contain leading zeroes unless the number is zero.","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of `n` positive integers `nums`, arrange them such that they form the largest possible concatenated number. Returns the largest concatenated number in string form. :param nums: A list of positive integers :return: The largest concatenated number as a string def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Map the numbers to strings to be able to concatenate them nums = list(map(str, nums)) # Sort the numbers based on the custom comparator nums.sort(key=cmp_to_key(compare)) # Join the sorted numbers into a single string largest_num = \'\'.join(nums) # Edge case: If the largest number is \'0\', we should return \'0\' not \'0000\' etc. return largest_num if largest_num[0] != \'0\' else \'0\'"},{"question":"Given a string `s` that may represent a floating point number, check if it is a valid number based on the following criteria: - It is composed of digits (`0-9`), a decimal point `\'.\'`, or an optional leading `\'+/-\'` sign. - There should be at least one digit on either side of the decimal point if it exists. - The string can also be an integer, i.e., it does not need to contain a decimal point. - The string should not contain any other characters or whitespace. Return `true` if `s` is a valid number according to the criteria, and `false` otherwise.","solution":"def is_valid_number(s): Returns True if the input string is a valid number according to the specified criteria, otherwise returns False. import re # Regex pattern to match valid number according to the given criteria pattern = re.compile(r\\"^[+-]?(d+(.d*)?|.d+)\\") return bool(pattern.match(s))"},{"question":"You are given a list of integers `arr` and an integer `k`. You need to find the `k`th largest element in the list `arr` defined as: The `k`th largest element is the `k`th element in the sorted order, not the `k`th distinct element. You must solve the problem with a time complexity better than `O(n log n)`. Implement the function `kthLargest(arr, k)` that returns the `k`th largest element in the list. **Note:** You may assume `k` is always valid, `1  k  arr.length`.","solution":"import heapq def kthLargest(arr, k): Returns the k-th largest element in the list arr. # Use a min heap of size k to find the kth largest element. min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"You are given two integers `n` and `k`. Create a function that returns the number of different arrays of length `n` consisting of non-negative integers such that the sum of the elements in each array is divisible by `k`. Note that two arrays are considered different if there is at least one index `i` such that the `i-th` element of one array is different from the `i-th` element of the other array.","solution":"def count_arrays(n, k): Returns the number of different arrays of length n consisting of non-negative integers such that the sum of the elements in each array is divisible by k. # The number of such arrays is (k^n) return k ** n"},{"question":"You are given a grid of size `m x n` where each cell contains an integer representing the height. The grid represents a geographical area where each cell is a unit of land. Rainfall can only flow from a cell to any of its four adjacent cells (north, south, east, west) if the adjacent cell has an equal or lower height. Water can exit the grid from any cell on the boundary. Write a program that determines the list of all cells where water can flow to the boundary when it rains. Return the cells in any order.","solution":"def pacificAtlantic(heights): if not heights: return [] m, n = len(heights), len(heights[0]) pacific_reachable = [[False] * n for _ in range(m)] atlantic_reachable = [[False] * n for _ in range(m)] directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def dfs(row, col, reachable): reachable[row][col] = True for dr, dc in directions: new_row, new_col = row + dr, col + dc if (0 <= new_row < m and 0 <= new_col < n and not reachable[new_row][new_col] and heights[new_row][new_col] >= heights[row][col]): dfs(new_row, new_col, reachable) for i in range(m): dfs(i, 0, pacific_reachable) dfs(i, n-1, atlantic_reachable) for j in range(n): dfs(0, j, pacific_reachable) dfs(m-1, j, atlantic_reachable) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find and return the length of the longest substring that contains only vowels (`a`, `e`, `i`, `o`, `u`) and does not have the same consecutive characters. For instance, if `s = \\"aeiouuoea\\"`, the longest substring that meets the criteria is `\\"aeiou\\"`, having a length of `5`. Return the length of such a substring. If no such substring exists, return `0`.","solution":"def longest_vowel_substring(s): Returns the length of the longest substring that contains only vowels and does not have the same consecutive characters. vowels = set(\'aeiou\') max_length = 0 current_length = 0 prev_char = \'\' for char in s: if char in vowels: if char != prev_char: current_length += 1 else: current_length = 1 prev_char = char else: current_length = 0 prev_char = \'\' max_length = max(max_length, current_length) return max_length"},{"question":"You are given an integer array `distances` where `distances[i]` represents the distance of the `i-th` city from a fixed point. You are also given an integer `k`. The array is sorted in non-decreasing order. Find the minimum number of cities you can select such that the sum of their distances is at least `k`. If it is impossible to reach `k`, return `-1`. The selected cities do not need to be contiguous in the array, but you cannot skip any backward in the array.","solution":"def min_cities_to_reach_distance(distances, k): Returns the minimum number of cities needed to reach at least distance \'k\'. If it is impossible to reach \'k\', returns -1. total_distance = 0 for i, distance in enumerate(distances): total_distance += distance if total_distance >= k: return i + 1 return -1"},{"question":"Write a function that finds all the starting indices of substring(s) in a given string that are anagrams of a given pattern. Implement the function `findAnagrams(s, p)` that receives a string `s` and a non-empty string `p`, and returns a list of all the start indices of `p`\'s anagrams in `s`. The order of output does not matter. A string is an anagram of another string if it uses the same characters in the same quantity, only rearranged. Determine if the substring can be rearranged to form the pattern string.","solution":"from collections import Counter def findAnagrams(s, p): Returns a list of starting indices of p\'s anagrams in s. p_len = len(p) s_len = len(s) if p_len > s_len: return [] p_counter = Counter(p) s_counter = Counter(s[:p_len-1]) result = [] for i in range(p_len-1, s_len): s_counter[s[i]] += 1 # Add the current character to the window # If window matches with the frequency map of p if s_counter == p_counter: result.append(i - p_len + 1) # Remove the character going out of the window s_counter[s[i - p_len + 1]] -= 1 if s_counter[s[i - p_len + 1]] == 0: del s_counter[s[i - p_len + 1]] return result"},{"question":"Given an array of integers `arr`, find the length of the shortest contiguous subarray, **if any**, that when sorted, results in the entire array being sorted in non-decreasing order. Return the length of such a subarray. If the array is already sorted, return `0`.","solution":"def find_unsorted_subarray(arr): Returns the length of the shortest contiguous subarray that, when sorted, results in the entire array being sorted in non-decreasing order. If the array is already sorted, return 0. n = len(arr) if n <= 1: return 0 start, end = -1, -1 max_seen, min_seen = float(\'-inf\'), float(\'inf\') for i in range(n): max_seen = max(max_seen, arr[i]) if arr[i] < max_seen: end = i for i in range(n-1, -1, -1): min_seen = min(min_seen, arr[i]) if arr[i] > min_seen: start = i if start == -1: # The array is already sorted return 0 return end - start + 1"},{"question":"Given a list of student names and their corresponding scores in two subjects, `students` where `students[i] = [name, score1, score2]`, return the names of the top three students based on their average scores. If there is a tie, the higher average score will be determined by comparing their `score1`. If there is still a tie, choose the student whose name comes first lexicographically. If there are fewer than three students, return the names of all students sorted based on the aforementioned criteria. The average score for each student is calculated as `(score1 + score2) / 2`.","solution":"def top_three_students(students): Returns the names of the top three students based on their average scores. If there is a tie, the higher average score will be determined by comparing score1. If there is still a tie, names are compared lexicographically. # Calculate the average score for each student students_with_avg = [ (name, (score1 + score2) / 2, score1, score2) for name, score1, score2 in students ] # Sort the students based on the criteria sorted_students = sorted(students_with_avg, key=lambda x: (-x[1], -x[2], x[0])) # Extract only the top 3 names top_three = [student[0] for student in sorted_students[:3]] return top_three"},{"question":"Given a string `s` that consists of only uppercase English letters, you need to find the length of the longest substring that contains all distinct characters. Implement a function `int lengthOfLongestSubstringWithDistinctChars(string s)` that takes a string `s` and returns the length of the longest such substring. Note that the answer should be calculated in O(n) time complexity where n is the length of the string.","solution":"def lengthOfLongestSubstringWithDistinctChars(s): Returns the length of the longest substring of `s` that contains all distinct characters. n = len(s) max_length = 0 start = 0 char_index_map = {} for end in range(n): current_char = s[end] if current_char in char_index_map: start = max(start, char_index_map[current_char] + 1) char_index_map[current_char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an array of integers `arr`, find the **maximum length of an increasing subsequence** such that the difference between adjacent elements in the subsequence is at most `k`. Return the count of such subsequence.","solution":"def max_increasing_subsequence_with_diff(arr, k): Returns the length of the maximum increasing subsequence with adjacent elements having a difference of at most k. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and arr[i] - arr[j] <= k: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a sorted array `arr` of **unique integers**, write a function that finds a pair of numbers (`x`, `y`) in the array such that `x * y` is as close as possible to a target number `t`, but does not exceed it. Return the pair as a tuple `(x, y)`. If there are multiple valid pairs, return the one with the largest `x`. If no such pair exists, return an empty tuple.","solution":"def find_optimal_pair(arr, t): Finds a pair (x, y) in the array such that x * y is as close as possible to t without exceeding it. If there are multiple valid pairs, returns the one with the largest x. Returns an empty tuple if no such pair exists. if not arr or len(arr) < 2: return () closest_pair = () closest_product = float(\'-inf\') for i in range(len(arr)): for j in range(i+1, len(arr)): product = arr[i] * arr[j] if product <= t and product > closest_product: closest_product = product closest_pair = (arr[i], arr[j]) elif product == closest_product and arr[i] > closest_pair[0]: closest_pair = (arr[i], arr[j]) return closest_pair"},{"question":"You are given a string `s` consisting of lowercase English letters. A letter is called a **vowel** if it is one of `\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, `\'u\'`. In one **operation**, you can replace any character in the string with any other lowercase English letter. Return _the **minimum number of operations** required to make the string contain no vowels._","solution":"def min_operations_to_remove_vowels(s): Returns the minimum number of operations required to make the string contain no vowels. :param s: Input string consisting of lowercase English letters. :return: Minimum number of operations. vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} operations = 0 for char in s: if char in vowels: operations += 1 return operations"},{"question":"# Generated Question: [Question 4]: Given a binary tree, return the sum of the depths of all nodes. The depth of a node is the number of edges from the tree\'s root to the node. For example, the root node has a depth of `0`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_of_depths(root): Returns the sum of the depths of all nodes in the binary tree rooted at \'root\'. def helper(node, depth): if not node: return 0 return depth + helper(node.left, depth+1) + helper(node.right, depth+1) return helper(root, 0)"},{"question":"Given an unsorted array of integers, write a function to find the smallest missing positive integer. You should implement a solution with O(n) time complexity and O(1) space complexity.","solution":"def find_smallest_missing_positive(nums): Find the smallest missing positive integer from an unsorted array of integers. This solution works in O(n) time complexity and O(1) space complexity. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"You are given a list of integers representing the prices of items in a store and a budget `B`. Your task is to determine the maximum number of items that can be purchased without exceeding the budget `B`. Each item can only be bought once, and you must calculate the maximum number of items that can be purchased optimally. Return the maximum number of items, or 0 if no items can be bought within the budget.","solution":"def max_items(prices, B): Returns the maximum number of items that can be purchased without exceeding the budget B. :param prices: List of integers representing prices of items. :param B: An integer representing the budget. :return: Maximum number of items that can be purchased. prices.sort() count = 0 total_cost = 0 for price in prices: if total_cost + price <= B: total_cost += price count += 1 else: break return count"},{"question":"Given a binary tree, return the _inorder traversal_ of its nodes\' values as a list. The binary tree is represented using TreeNode objects, defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The inorder traversal of a binary tree is a depth-first traversal where for each node, the order is: 1. Traverse the left subtree 2. Visit the root node 3. Traverse the right subtree","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree node values. :param TreeNode root: The root node of the binary tree. :return: A list of node values in inorder traversal. :rtype: List[int] result = [] def _inorder(node): if node: _inorder(node.left) result.append(node.val) _inorder(node.right) _inorder(root) return result"},{"question":"You are given a string `s` representing a sentence containing words separated by single spaces. However, the order of the words in the sentence has been randomly shuffled. Additionally, each word is followed by an integer indicating its original position in the sentence. Words are indexed from 0. Your task is to write a function that reconstructs the original sentence from the shuffled words and integers. For example, given the input string `s = \\"sentence4 is2 a3 This0\\"`, the function should return the original sentence `\\"This is a sentence\\"`.","solution":"def reconstruct_sentence(s): Reconstructs the original sentence from a shuffled sentence with word positions. Args: s (str): A shuffled sentence where each word is followed by its original position. Returns: str: The original sentence with the correct order of words. words = s.split() sorted_words = sorted(words, key=lambda x: int(x[-1])) # Sort by the integer at the end of each word original_sentence = \' \'.join(word[:-1] for word in sorted_words) # Remove the integers and join words return original_sentence"},{"question":"You are given a string `expression` representing an **arithmetic expression** containing non-negative integers and the operators `+, -, *, /` without any parentheses. The expression is properly formatted such that each operator and operand is separated by a single space. Return _the result of evaluating the expression_. Integer division should truncate towards zero.","solution":"def evaluate_expression(expression): Evaluates a properly formatted arithmetic expression containing non-negative integers and the operators +, -, *, / separated by spaces. Integer division truncates towards zero. # Split the expression into tokens tokens = expression.split() # This will hold the current index in the tokens list index = 0 def get_next_token(): nonlocal index token = tokens[index] index += 1 return token def parse_term(): nonlocal index result = int(get_next_token()) while index < len(tokens): operator = tokens[index] if operator in \'+-\': break index += 1 next_value = int(get_next_token()) if operator == \'*\': result *= next_value elif operator == \'/\': result = int(result / next_value) # Truncate towards zero return result def parse_expression(): nonlocal index result = parse_term() while index < len(tokens): operator = tokens[index] if operator not in \'+-\': break index += 1 next_value = parse_term() if operator == \'+\': result += next_value elif operator == \'-\': result -= next_value return result return parse_expression()"},{"question":"You are given a list of `n` unique integers. Your task is to determine the **number of distinct ways** to form pairs of integers such that each pair\'s sum is an **even number**. Two pairs `(a, b)` and `(c, d)` are considered the same if `a = c` and `b = d` or if `a = d` and `b = c`. Given the list of integers, return the number of distinct pairs whose sum is even. As the answer may be very large, **return the answer modulo** `10^9 + 7`.","solution":"def count_even_sum_pairs(arr): MOD = 10**9 + 7 # First, we count the number of even and odd numbers in the list. evens = sum(1 for x in arr if x % 2 == 0) odds = len(arr) - evens # The number of ways to pick 2 evens or 2 odds are the pairs that will sum to an even value. even_pairs = evens * (evens - 1) // 2 # Combination nC2 for evens odd_pairs = odds * (odds - 1) // 2 # Combination nC2 for odds # The result is the sum of both pairs taken modulo 10^9 + 7 result = (even_pairs + odd_pairs) % MOD return result"},{"question":"You are given an integer array `arr` consisting of positive integers and an integer `k`. You need to find and return the number of distinct pairs `(arr[i], arr[j])` where `i != j` such that the absolute difference between `arr[i]` and `arr[j]` is equal to `k`.","solution":"def find_pairs_with_difference(arr, k): Returns the number of distinct pairs (arr[i], arr[j]) such that i != j and the absolute difference between arr[i] and arr[j] is equal to k. seen = set() pairs = set() for num in arr: if num + k in seen: pairs.add((num, num + k)) if num - k in seen: pairs.add((num - k, num)) seen.add(num) return len(pairs)"},{"question":"You are given a string `s` and an integer `t`. A **transformation** operation on the string is defined as selecting any two **distinct** characters in `s` and swapping all their occurrences. You want to transform the string such that after up to `t` transformations, the number of distinct characters in `s` is minimized. Return _the minimum number of distinct characters_ in the string after performing at most `t` swap operations.","solution":"from collections import Counter def min_distinct_chars(s: str, t: int) -> int: Returns the minimum number of distinct characters in the string after performing at most t swap operations. freq = Counter(s) counts = sorted(freq.values(), reverse=True) while t > 0 and len(counts) > 1: # We will try to merge the two least frequent characters if t >= counts[-1]: t -= counts[-1] counts.pop() else: break return len(counts)"},{"question":"You are given a string `s` consisting of lowercase English letters. A k-palindrome is a string that becomes a palindrome after removing at most `k` characters from it. Write a function to determine whether the given string `s` can be transformed into a palindrome with at most `k` deletions. Return `true` if it is possible, otherwise return `false`.","solution":"def is_k_palindrome(s, k): Determines if the given string can be transformed into a palindrome with at most k deletions. :param s: Input string consisting of lowercase English letters :param k: Number of allowed deletions :return: True if the string can be transformed into a palindrome with at most k deletions, otherwise False. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] n = len(s) lps = longest_palindromic_subsequence(s) return (n - lps) <= k"},{"question":"You are given an array `arr` of integers and an integer `k`. You need to find a subsequence of `arr` of length `k` that has the largest sum. Return _the subsequence_ such that it appears in the same relative order as in `arr`. The returned subsequence should be formatted as an array `subseq`, which maintains the order of appearance from `arr`.","solution":"def max_sum_subsequence(arr, k): Returns a subsequence of length k which has the largest sum, while maintaining the order of appearance from arr. if len(arr) < k or k == 0: return [] # Identify the k largest elements along with their indices index_value_pairs = sorted(enumerate(arr), key=lambda x: x[1], reverse=True) k_largest_pairs = sorted(index_value_pairs[:k], key=lambda x: x[0]) # Extract the subsequence based on indices subseq = [pair[1] for pair in k_largest_pairs] return subseq"},{"question":"Given a list of integers `arr`, return the number of **contiguous subarrays** where the product of all the elements in the subarray is less than a given integer `k`. The test cases are generated such that the expected answer fits within a 32-bit signed integer.","solution":"def num_subarray_product_less_than_k(arr, k): Given a list of integers arr, return the number of contiguous subarrays where the product of all elements in the subarray is less than k. if k <= 1: return 0 prod = 1 result = 0 left = 0 for right in range(len(arr)): prod *= arr[right] while prod >= k: prod /= arr[left] left += 1 result += right - left + 1 return result"},{"question":"Given a positive integer `n`, return the _length of the shortest sequence of perfect squares that sum up to_ `n`. A perfect square is an integer that is the square of an integer, e.g., `1, 4, 9, 16`. You can use each perfect square as many times as needed.","solution":"from math import isqrt def numSquares(n: int) -> int: Returns the length of the shortest sequence of perfect squares that sum up to n. dp = [float(\'inf\')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]"},{"question":"You are given a **sorted** integer array `nums` of length `n`. Your task is to remove all duplicate elements in-place such that each unique element appears only **once** while preserving the sorted order. The relative order of the elements should not be changed. After removing the duplicates, return _the new length of the array_. You must write an algorithm with an **O(n)** time complexity and **O(1)** space complexity.","solution":"def remove_duplicates(nums): Removes duplicates in-place in a sorted list of integers such that each unique element appears only once. Returns the new length of the array. if not nums: return 0 # Initialize the pointer for the position of the last unique element last_unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[last_unique_index]: last_unique_index += 1 nums[last_unique_index] = nums[i] return last_unique_index + 1"},{"question":"You are given a string `s` which consists of lowercase English letters and an integer `n`. You need to generate a new string by shifting each character in the string forward by `n` positions in the alphabet. If the end of the alphabet is reached, continue from the beginning. Return the new string after shifting all characters. For example, given the string `\\"xyz\\"` and `n = 2`, the new string would be `\\"zab\\"`.","solution":"def shift_string(s, n): Shifts each character in the string s forward by n positions in the alphabet. If the end of the alphabet is reached, continue from the beginning. Args: s (str): The input string consisting of lowercase English letters. n (int): Number of positions to shift. Returns: str: The new string after shifting characters. shifted_string = \\"\\" for char in s: shifted_char = chr(((ord(char) - ord(\'a\') + n) % 26) + ord(\'a\')) shifted_string += shifted_char return shifted_string"},{"question":"Given a string `str`, return the longest palindromic substring in `str`. A string is called a palindrome if it reads the same backward as forward. Note that the length of the palindrome is maximized and the input string can contain both uppercase and lowercase letters. The palindrome substring should be case-sensitive, meaning \\"Aa\\" is not considered a palindrome. The solution should be efficient enough to handle strings of length up to 1000 characters. Return the longest palindromic substring. If there are multiple such substrings with the same maximum length, return the one which appears first.","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string. n = len(s) if n == 0: return \\"\\" # Table to store the fact if s[i..j] is a palindrome dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 # Every single character is a palindrome for i in range(n): dp[i][i] = True # Check for sub-string of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"You are given a 2D array `grid` representing a rectangular matrix where each cell contains an integer. The task is to rotate the matrix in place 90 degrees clockwise. Write a function to modify the `grid` array directly, and return the modified grid. You are not allowed to use extra space for another matrix.","solution":"def rotate_matrix_in_place(grid): Rotates the input matrix 90 degrees clockwise in place. :param grid: List[List[int]] - The 2D list representation of the matrix :return: List[List[int]] - The same grid rotated 90 degrees clockwise n = len(grid) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): grid[i][j], grid[j][i] = grid[j][i], grid[i][j] # Step 2: Reverse each row for i in range(n): grid[i].reverse() return grid"},{"question":"Given a list of `projects` where each project is represented as a list of two integers `[duration, deadline]`, your task is to determine the maximum number of projects that can be completed on time. You can start any project at any point in time, but you can only work on one project at a time. A project is considered completed on time if it finishes before or at its deadline. Return _the maximum number of projects_ that can be completed on time.","solution":"def max_projects_on_time(projects): Determines the maximum number of projects that can be completed on time. Parameters: projects (list of lists): A list where each element is a list containing two integers - [duration, deadline] Returns: int: The maximum number of projects that can be completed on time. # Sort projects by their deadlines projects.sort(key=lambda x: x[1]) current_time = 0 count = 0 for duration, deadline in projects: if current_time + duration <= deadline: current_time += duration count += 1 return count"},{"question":"You are given a string `expression` representing a boolean expression containing `\'T\'` (True), `\'F\'` (False), `\'&\'` (AND), `\'|\'` (OR), and `\'!\'` (NOT). The expression may include parentheses for grouping sub-expressions. Implement a function to evaluate this boolean expression and return its result as a boolean value. The expression is guaranteed to be valid. For example, given the expression `\\"T&!F|F\\"`, the result would be `true`. Create a function that evaluates the boolean expression and returns the corresponding `boolean` result.","solution":"def evaluate_boolean_expression(expression: str) -> bool: def eval_sub_expression(tokens): stack = [] for token in tokens: if token == \'T\' or token == \'F\': stack.append(token == \'T\') elif token == \'!\': stack.append(not stack.pop()) elif token == \'&\': right = stack.pop() left = stack.pop() stack.append(left and right) elif token == \'|\': right = stack.pop() left = stack.pop() stack.append(left or right) return stack[0] def to_tokens(expression): output = [] stack = [] prec = {\'!\': 3, \'&\': 2, \'|\': 1, \'(\': 0} for char in expression: if char == \'T\' or char == \'F\': output.append(char) elif char == \'(\': stack.append(char) elif char == \')\': while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() else: while stack and prec[char] <= prec[stack[-1]]: output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) return output tokens = to_tokens(expression) return eval_sub_expression(tokens)"},{"question":"You are given an array of integers `arr` of length `n` where each element `arr[i]` represents the height of a block at index `i`. The rainwater begins to fill up the spaces between the blocks. Your task is to find out how much water is trapped between the blocks after it rains. Return _the total amount of water trapped_. Assume that the width of each block is `1`.","solution":"def trap_rainwater(arr): Calculates the total amount of water trapped between the blocks after it rains. :param arr: List of integer heights representing the blocks :return: Integer representing the total amount of water trapped if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) # Fill right max array right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) # Calculate the water trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"Given a string `s` consisting of lowercase letters and parentheses, you need to determine if the parentheses are balanced. The string contains only `a`-`z`, `(`, and `)`. A string with balanced parentheses means every opening parenthesis has a matching closing parenthesis, and the pairs of parentheses are properly nested. Return `true` if the string has balanced parentheses, otherwise return `false`.","solution":"def is_balanced_parentheses(s): Checks if the parentheses in the string s are balanced. Args: s (str): The input string containing lowercase letters, \'(\' and \')\' Returns: bool: True if the parentheses are balanced, otherwise False stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack or stack[-1] != \'(\': return False stack.pop() return len(stack) == 0"},{"question":"Given a **non-negative** integer `x`, return _the square root of_ `x` _rounded down to the nearest integer_. If the number is not a perfect square, you should still return the floor value. **Avoid using built-in math functions** for computing the square root.","solution":"def floor_sqrt(x): Returns the floor value of the square root of a non-negative integer x. if x < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if x == 0 or x == 1: return x start, end = 1, x result = 1 while start <= end: mid = (start + end) // 2 if mid * mid == x: return mid elif mid * mid < x: start = mid + 1 result = mid else: end = mid - 1 return result"},{"question":"You are given a binary tree with `n` nodes. Each node is uniquely assigned a value from `1` to `n`. All left and right child pointers in the tree are initially `null`. You are provided with a **0-indexed** 2D integer array `relations` where `relations[i] = [parenti, childi, isLefti]` indicates that `childi` is a left child of `parenti` if `isLefti` is `1`, or a right child if `isLefti` is `0`. After constructing the binary tree, you need to find the node with the maximum depth. The depth of a node is the number of edges from the node to the tree\'s root. Return _the value of the node that has the maximum depth_. If there are multiple nodes with the same maximum depth, return the one with the smallest value.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def add_child(parent, child, is_left, nodes): if is_left: parent.left = child else: parent.right = child nodes[child.value - 1] = child def find_max_depth_node(relations): if not relations: return -1 # Edge case: no relations, e.g. empty tree input nodes = [TreeNode(i + 1) for i in range(max(max(relations, key=lambda x: max(x[:2]))[:2]))] for parent_value, child_value, is_left in relations: parent = nodes[parent_value - 1] child = TreeNode(child_value) add_child(parent, child, is_left, nodes) def dfs(node, depth): if not node: return (depth - 1, float(\'inf\')) if not node.left and not node.right: return (depth, node.value) left_depth, left_value = dfs(node.left, depth + 1) right_depth, right_value = dfs(node.right, depth + 1) if left_depth > right_depth: return (left_depth, left_value) elif right_depth > left_depth: return (right_depth, right_value) else: return (left_depth, min(left_value, right_value)) root = nodes[0] max_depth, max_depth_node_value = dfs(root, 0) return max_depth_node_value"},{"question":"Given an integer array `arr`, a **mountain** subarray is defined as a subarray where there exists exactly one index `i` such that: - `arr[0] < arr[1] < ... < arr[i]` - `arr[i] > arr[i + 1] > ... > arr[k]` for 0 <= i < k. An element is a **peak** if it is greater than its adjacent elements. Return the length of the longest **mountain** subarray that can be found in `arr`. If no such subarray exists, return 0. **Note**: A **subarray** is a contiguous part of an array.","solution":"def longest_mountain(arr): Returns the length of the longest mountain subarray in arr. A mountain subarray has the property that there exists an index i such that: arr[0] < arr[1] < ... < arr[i] > arr[i + 1] > ... > arr[k] n = len(arr) if n < 3: return 0 max_len = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 right = i + 1 while left > 0 and arr[left] > arr[left - 1]: left -= 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a string `s` consisting of lowercase characters. Write a function to determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For this problem, define a palindrome as a string that reads the same forward and backward.","solution":"def is_palindrome(s): Determines if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. # Extract only alphanumeric characters and convert to lower case cleaned_s = \'\'.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"You are given two integer arrays `preorder` and `inorder`, representing the preorder traversal and inorder traversal of a binary tree, respectively. Construct and return the binary tree. Preorder traversal is defined as visiting the root node first, followed by the left subtree, and finally the right subtree. Inorder traversal is defined as visiting the left subtree first, followed by the root node, and finally the right subtree. Note that it is guaranteed that the given traversals are valid and correspond to the same binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder, inorder): Constructs the binary tree from preorder and inorder traversal. if not preorder or not inorder: return None # The first element in preorder is the root. root_val = preorder.pop(0) root = TreeNode(root_val) # Find the index of the root in inorder list. inorder_index = inorder.index(root_val) # Recursively build the left and right subtrees. root.left = build_tree(preorder, inorder[:inorder_index]) root.right = build_tree(preorder, inorder[inorder_index+1:]) return root"},{"question":"A company utilizes a server farm consisting of multiple servers. Each server can handle a certain number of connections, which is represented by an integer array `connections` where `connections[i]` indicates the number of connections server `i` can handle. Your task is to determine the minimum number of servers required to handle a given number of connections `m`. If it is not possible to handle `m` connections with the available servers, return `-1`. The servers can share the load, i.e., you can distribute connections across multiple servers.","solution":"def min_servers(connections, m): Determines the minimum number of servers required to handle `m` connections. If it\'s not possible to handle `m` connections with the available servers, return -1. Parameters: connections (list of int): List representing the maximum connections each server can handle. m (int): Number of connections that need to be handled. Returns: int: Minimum number of servers required to handle `m` connections, or -1 if not possible. connections.sort(reverse=True) total_connections = 0 for i, connection in enumerate(connections): total_connections += connection if total_connections >= m: return i + 1 return -1"},{"question":"You are given a matrix `grid` consisting of integers where each element represents the height of a tower. Two towers are considered **connected** if they are directly adjacent to each other either horizontally or vertically and have the same height. Return _the size of the largest connected tower cluster in the matrix_.","solution":"def largest_connected_cluster(grid): if not grid or not grid[0]: return 0 def dfs(r, c): stack = [(r, c)] height = grid[r][c] size = 0 while stack: x, y = stack.pop() if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == height: grid[x][y] = None # Mark as visited size += 1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: nx, ny = x + dx, y + dy stack.append((nx, ny)) return size max_cluster_size = 0 for row in range(len(grid)): for col in range(len(grid[0])): if grid[row][col] is not None: cluster_size = dfs(row, col) if cluster_size > max_cluster_size: max_cluster_size = cluster_size return max_cluster_size"},{"question":"You are given a binary tree in which each node contains an integer value. Design an algorithm to find all paths in the tree that sum up to a given target value. A path is defined as any sequence of nodes in the tree, starting from any node and ending at any node, but must go downwards (travelling only from parent nodes to child nodes). The tree is non-empty, and there is no distinction between left or right child nodes for defining a path, meaning that all paths must follow a single direction from parent to child. Given a binary tree root and an integer `target_sum`, return a list of all unique paths where the sum of the values along the path equals `target_sum`. For example, given the following tree and target sum of `22`: ``` 5 / 4 8 / / 11 13 4 / / 7 2 5 1 ``` One of the valid paths would be `[5, 4, 11, 2]` and another valid path may be `[5, 8, 4, 5]`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target_sum): result = [] def find_paths(node, current_path, target): if node is None: return current_path.append(node.val) current_sum = sum(current_path) if current_sum == target: result.append(list(current_path)) find_paths(node.left, current_path, target) find_paths(node.right, current_path, target) current_path.pop() find_paths(root, [], target_sum) return result"},{"question":"You are given a rectangular island represented as a 2D grid where each cell is either \'0\' (water) or \'1\' (land). A group of connected \'1\'s forms an island. Except for the edges of the grid, a cell\'s four possible neighbors are top, left, right, and bottom. An island is considered surrounded if water surrounds all cells of the island. Return `true` if all islands in the grid are surrounded by water, and `false` otherwise.","solution":"def surrounded_islands(grid): Returns true if all islands in the grid are surrounded by water, false otherwise. An island is represented by connected \'1\'s and water by \'0\'s. rows, cols = len(grid), len(grid[0]) def dfs(r, c): # If out of bounds or at water or already visited if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == \'0\' or grid[r][c] == \'2\': return True # If on the boundary and it\'s an island cell, it\'s not surrounded if r == 0 or c == 0 or r == rows - 1 or c == cols - 1: return False # Mark the cell as visited by converting \'1\'s to \'2\'s grid[r][c] = \'2\' # Explore all four directions top = dfs(r - 1, c) bottom = dfs(r + 1, c) left = dfs(r, c - 1) right = dfs(r, c + 1) # An island is surrounded if all its parts are surrounded return top and bottom and left and right for i in range(rows): for j in range(cols): if grid[i][j] == \'1\': if not dfs(i, j): return False return True"},{"question":"You are given a list of unique integers `nums` and an integer `target`. Return _all unique quadruplets `[a, b, c, d]` in `nums` such that `a + b + c + d` equals `target`_. You may return the result in any order. For example, given `nums = [1, 0, -1, 0, -2, 2]` and `target = 0`, your function should return `[[2,1,1,2],[2,0,0,2],[1,0,0,1]]`. Note that there are no repeated quadruplets in the result list.","solution":"def four_sum(nums, target): Returns all unique quadruplets [a, b, c, d] in `nums` such that a + b + c + d equals `target`. nums.sort() quadruplets = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, length - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"You are given a **binary** matrix `mat` of size `m x n`. The matrix represents a grid where `0` indicates an empty cell and `1` indicates an obstacle. You need to find a path from the top-left corner of the grid `(0, 0)` to the bottom-right corner `(m-1, n-1)` such that the path does not pass through any `1`s. You may move up, down, left, or right from a given cell to another. If such a path exists, return _the **minimum number of steps** required to reach the bottom-right corner. If no such path exists, return `-1`_.","solution":"from collections import deque def min_steps_to_exit(mat): Returns the minimum number of steps required to reach the bottom-right corner of the matrix from the top-left corner without passing through any obstacles. If no such path exists, returns -1. if not mat or mat[0][0] == 1 or mat[-1][-1] == 1: return -1 m, n = len(mat), len(mat[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) while queue: r, c, steps = queue.popleft() if r == m-1 and c == n-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and mat[nr][nc] == 0: mat[nr][nc] = 1 # Mark visited queue.append((nr, nc, steps + 1)) return -1"},{"question":"You are given an array of strings `words` and a string `target`. Return the number of strings in the `words` array that can be formed by rearranging the letters of the `target` string. Each letter in `target` can only be used once per string formed.","solution":"from collections import Counter def count_anagrams(words, target): Returns the number of strings in the `words` array that can be formed by rearranging the letters of the `target` string. target_count = Counter(target) def is_anagram(word, target_count): return Counter(word) == target_count count = sum(1 for word in words if is_anagram(word, target_count)) return count"},{"question":"Given `m` strings, each string can be formed by concatenating any permutation of a given set of `n` unique words. You need to check if you can create all the `m` strings using exactly the given `n` words without repeating any word. Return `true` if it is possible to form all the strings using the exact set of unique words, otherwise return `false`. The strings are case-sensitive. For example, if the unique words are `[\\"apple\\", \\"banana\\", \\"cherry\\"]` and the strings are `[\\"applebanana\\", \\"bananacherry\\"]`, the result should be `true` since every string can be formed by concatenating a permutation of the given words.","solution":"def can_form_strings(unique_words, strings): This function checks if all the strings can be formed using permutations of the unique words provided. from collections import Counter def word_counter(strings_list): This function constructs a counter dictionary of letters from a list of strings. return Counter(\'\'.join(strings_list)) # Get a counter for the letters in the unique words unique_word_counter = word_counter(unique_words) for s in strings: if word_counter([s]) != unique_word_counter: return False return True"},{"question":"You are given a linked list where each node contains an integer value. Implement a function to reorder the linked list such that it alternates between nodes from the beginning and end of the original list. For example, given a linked list `1 -> 2 -> 3 -> 4 -> 5`, reorder it to become `1 -> 5 -> 2 -> 4 -> 3`. Your algorithm should not use any extra space for storing nodes, and the reordering should be done in-place. Return the head of the reordered linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): if not head or not head.next: return head # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev, curr = None, slow while curr: next_node = curr.next curr.next = prev prev, curr = curr, next_node # Step 3: Merge the two halves first, second = head, prev while second.next: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first, second = tmp1, tmp2 return head"},{"question":"Write a function that receives a list of integers as input, and returns the length of the longest increasing subsequence in the list. A subsequence is a sequence derived from another sequence by deleting some or none of the elements without changing the order of the remaining elements. For example, given the list `[10, 9, 2, 5, 3, 7, 101, 18]`, the length of the longest increasing subsequence is `4` (that is `[2, 3, 7, 101]`). Your function should efficiently handle a list of up to 10,000 integers.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the list nums. if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given two 0-indexed integer arrays `nums1` and `nums2`, both of length `n`. Your goal is to transform `nums1` into `nums2` using the minimum number of operations. In one operation, you can select two adjacent elements in `nums1` and swap them. Find and return the minimum number of adjacent swaps required.","solution":"def min_swaps_to_sort(nums1, nums2): Given two integer arrays nums1 and nums2, return the minimum number of adjacent swaps required to transform nums1 into nums2. if len(nums1) != len(nums2): return -1 # The lengths of the arrays should match to perform transformation. def build_index_map(nums): index_map = {} for i, num in enumerate(nums): if num in index_map: index_map[num].append(i) else: index_map[num] = [i] return index_map index_map1 = build_index_map(nums1) index_map2 = build_index_map(nums2) target_positions = [] for num in nums2: if num not in index_map1 or not index_map1[num]: return -1 # Transformation isn\'t possible if any element in nums2 is missing in nums1. target_positions.append(index_map1[num].pop(0)) def count_min_swaps(arr): visited = [False] * len(arr) swaps = 0 for i in range(len(arr)): if visited[i] or arr[i] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr[x] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps return count_min_swaps(target_positions)"},{"question":"Given an integer array `nums`, you need to find the length of the longest subarray with elements having a maximum absolute difference of 1 between any two elements in the subarray. Return _the length of the longest such subarray_.","solution":"def find_longest_subarray(nums): Returns the length of the longest subarray with elements having a maximum absolute difference of 1. if not nums: return 0 max_length = 0 freq = {} left = 0 for right in range(len(nums)): if nums[right] in freq: freq[nums[right]] += 1 else: freq[nums[right]] = 1 while len(freq) > 2 or (len(freq) == 2 and abs(min(freq.keys()) - max(freq.keys())) > 1): freq[nums[left]] -= 1 if freq[nums[left]] == 0: del freq[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a **0-indexed** array of integers `nums` and an integer `threshold`. The task is to find the **minimum possible sum** of a contiguous subarray of `nums` such that the sum is **greater than or equal to** `threshold`. If no such subarray exists, return `-1`. A contiguous subarray is defined as a subset of the array that appears sequentially within the original array.","solution":"def min_sum_subarray(nums, threshold): Returns the minimum possible sum of a contiguous subarray of nums such that the sum is greater than or equal to threshold. If no such subarray exists, return -1. n = len(nums) min_sum = float(\'inf\') for i in range(n): current_sum = 0 for j in range(i, n): current_sum += nums[j] if current_sum >= threshold: min_sum = min(min_sum, current_sum) break return min_sum if min_sum != float(\'inf\') else -1"},{"question":"You are given a string `s` that consists of only lowercase English letters. You need to partition the string into as many parts as possible such that each letter appears in at most one part. Return the lengths of these parts. To solve this, you need to find the last occurrence index of each character in the string and use this information to determine where to partition the string. Each partition should be as large as possible, ensuring no character appears in more than one part. For example, if the input string is `s = \\"ababcbacadefegdehijhklij\\"`, the output should be `[9, 7, 8]` because: - The substring `ababcbaca` ends at index 8, and this includes all of the letters from the first part. - The substring `defegde` is the next part which ends at index 14, covering the second part. - Finally, the substring `hijhklij` covers the remaining part of the string.","solution":"def partition_labels(s): Partitions the string into as many parts as possible so that each letter appears in at most one part. Returns a list of lengths of these parts. # Find the last occurrence of each character last_occurrence = {char: i for i, char in enumerate(s)} # Initialize variables partitions = [] start = 0 end = 0 # Iterate through the string to determine partitions for i, char in enumerate(s): end = max(end, last_occurrence[char]) # If the current index is the end of the partition if i == end: partitions.append(end - start + 1) start = i + 1 return partitions"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings within a city. The city has a rule that a building can see the sunset if there are no taller buildings to its right. Return _the list of indices of the buildings that can see the sunset_, in **ascending** order.","solution":"def buildings_with_sunset_view(heights): Returns the list of indices of buildings that can see the sunset. A building can see the sunset if all the buildings to its right are shorter. result = [] current_max_height = 0 for i in range(len(heights) - 1, -1, -1): if heights[i] > current_max_height: result.append(i) current_max_height = heights[i] result.reverse() return result"},{"question":"You are given an array of integers `arr` and an integer `x`. Your task is to find if there exist two distinct elements in the array whose absolute difference is `x`. If such a pair exists, return `true`; otherwise, return `false`. Note that the array may contain negative numbers and should be considered while checking the absolute difference.","solution":"def has_pair_with_difference(arr, x): Given an array of integers \'arr\' and an integer \'x\', find if there exist two distinct elements in the array whose absolute difference is \'x\'. Return True if such a pair exists, otherwise return False. value_set = set(arr) for num in arr: if (num + x in value_set) or (num - x in value_set): return True return False"},{"question":"You are given a **positive** integer `n`. Your task is to construct and return an integer matrix `n x n` where the matrix should be filled with the numbers from 1 to n^2 in a spiral order starting from the top-left corner and moving in a clockwise direction. Here is how the filling should proceed: - Start from the top-left corner. - Move right until you reach the end of the column. - Move down until you reach the end of the row. - Move left until you reach the beginning of the column. - Move up until you reach the beginning of the row. - Continue spiraling inwards until all cells are filled. For example, given n = 3, the output should be: ``` [[ 1, 2, 3], [ 8, 9, 4], [ 7, 6, 5]] ``` Return the generated spiral matrix.","solution":"def generate_spiral_matrix(n): Generate an n x n matrix filled with numbers from 1 to n^2 in spiral order. matrix = [[0] * n for _ in range(n)] num = 1 left, right = 0, n - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: # Traverse from left to right for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Traverse downwards for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Traverse from right to left if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Traverse upwards if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"Given a string `s` consisting of lowercase alphabetic characters, you need to find the length of the shortest substring that contains all the unique characters of `s` at least once. For example, if the string contains the characters `a`, `b`, and `c`, the substring must include all these characters. If there are multiple substrings that satisfy the condition, return the length of the shortest one. Return an integer representing the length of such a substring.","solution":"def length_of_shortest_substring(s): Returns the length of the shortest substring that contains all unique characters of s at least once. if not s: return 0 unique_chars = set(s) required_length = len(unique_chars) n = len(s) min_length = n left = 0 current_chars = {} for right in range(n): char = s[right] if char in current_chars: current_chars[char] += 1 else: current_chars[char] = 1 while len(current_chars) == required_length: min_length = min(min_length, right - left + 1) left_char = s[left] current_chars[left_char] -= 1 if current_chars[left_char] == 0: del current_chars[left_char] left += 1 return min_length"},{"question":"You are given a binary tree where each node has a unique value. In one operation, you can swap the values of any two nodes in the tree. Your task is to determine the minimum number of swaps required to convert the binary tree into a Binary Search Tree (BST). Note that a BST is a binary tree where for each node, the values in its left subtree are smaller, and the values in its right subtree are larger. Return _the minimum number of swaps required to convert the given binary tree to a BST_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Performs in-order traversal on the binary tree and returns a list of node values. values = [] def traverse(node): if node: traverse(node.left) values.append(node.val) traverse(node.right) traverse(root) return values def minimum_swaps_to_sort(arr): Finds the minimum number of swaps required to sort the array. This uses the concept of graph cycles. n = len(arr) arrpos = list(enumerate(arr)) arrpos.sort(key=lambda it: it[1]) visited = {i: False for i in range(n)} ans = 0 for i in range(n): if visited[i] or arrpos[i][0] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arrpos[x][0] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans def min_swaps_to_convert_to_bst(root): Returns the minimum number of swaps required to convert the binary tree root into a BST. in_order_vals = inorder_traversal(root) return minimum_swaps_to_sort(in_order_vals)"},{"question":"Given a **0-indexed** integer array `nums`, return the **length** of the longest strictly **increasing** subarray. A **subarray** is a contiguous part of an array. Note that a subarray of length 1 is considered strictly increasing.","solution":"def longest_increasing_subarray_length(nums): Returns the length of the longest strictly increasing subarray in a given list of integers. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given a matrix of characters `board` and a string `word`, return `true` _if_ `word` _exists in the guide_. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. The board and word are provided as input and you need to determine if the word can be formed by navigating through the board.","solution":"def exist(board, word): Check if the word can be constructed from the board by navigating through it. Parameters: board (list of list of str): A 2D board of characters. word (str): The word to be searched. Returns: bool: True if the word exists in the board, otherwise False. def dfs(board, word, index, x, y): if index == len(word): return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or word[index] != board[x][y]: return False temp = board[x][y] board[x][y] = \\"#\\" exists = (dfs(board, word, index + 1, x + 1, y) or dfs(board, word, index + 1, x - 1, y) or dfs(board, word, index + 1, x, y + 1) or dfs(board, word, index + 1, x, y - 1)) board[x][y] = temp return exists if not board: return False for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, 0, i, j): return True return False"},{"question":"You are given a **0-indexed** integer array `numbers` and an integer `targetSum`. Your task is to find all unique quadruplets in the array which sum to the `targetSum`. Each quadruplet should be sorted in non-descending order before being added to the list of result quadruplets, and the list should be sorted in non-descending lexicographic order. Return the list of all such quadruplets. Note: A quadruplet consists of four elements from the array. *Example:* - Input: `numbers = [1, 0, -1, 0, -2, 2]`, `targetSum = 0` - Output: `[[-2, -1, 1, 2], [-2, 0,0, 2], [-1, 0, 0, 1]]` Ensure the solution is capable of handling large arrays efficiently.","solution":"def four_sum(numbers, targetSum): Returns a list of all unique quadruplets in the array which sum to targetSum. Each quadruplet is sorted in non-descending order and the list is sorted in non-descending lexicographic order. numbers.sort() n = len(numbers) result = set() for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: total = numbers[i] + numbers[j] + numbers[left] + numbers[right] if total == targetSum: result.add((numbers[i], numbers[j], numbers[left], numbers[right])) left += 1 right -= 1 elif total < targetSum: left += 1 else: right -= 1 return [list(quad) for quad in sorted(result)]"},{"question":"You are given a matrix consisting of integers, where each element represents the height of a certain position in a 2D landscape. Water can flow from one cell to any of its 4 adjacent cells (up, down, left, or right) if the height of the next cell is less than or equal to the current cell. Initially, water only starts from the cells on the border of the matrix. Write a function to find the cells where water can flow to the border either directly or indirectly. Return a list of coordinates of all such cells sorted in ascending order, starting with the row index.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) def dfs(r, c, visited, prev_height): if (r < 0 or r >= rows or c < 0 or c >= cols or (r, c) in visited or matrix[r][c] < prev_height): return visited.add((r, c)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc, visited, matrix[r][c]) pacific_reachable = set() atlantic_reachable = set() for i in range(rows): dfs(i, 0, pacific_reachable, float(\'-inf\')) dfs(i, cols - 1, atlantic_reachable, float(\'-inf\')) for j in range(cols): dfs(0, j, pacific_reachable, float(\'-inf\')) dfs(rows - 1, j, atlantic_reachable, float(\'-inf\')) result = list(pacific_reachable & atlantic_reachable) result.sort(key=lambda x: (x[0], x[1])) return result"},{"question":"Given the `root` of a binary search tree (BST), your task is to find the sum of all node values that lie within a given range `[low, high]` (inclusive). The BST has the property that all values in the left subtree of a node are lesser, and all values in the right subtree of a node are greater than the node\'s value. Return the sum of the node values within the specified range.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSumBST(root, low, high): Given the root of a binary search tree, return the sum of values of all nodes with value between low and high (inclusive). if not root: return 0 total_sum = 0 if low <= root.val <= high: total_sum += root.val if low < root.val: total_sum += rangeSumBST(root.left, low, high) if root.val < high: total_sum += rangeSumBST(root.right, low, high) return total_sum"},{"question":"You are given a list of integers `nums` and a target integer `k`. A **beautiful subarray** is defined as a contiguous subarray that contains **exactly** `k` odd numbers. Return _the number of beautiful subarrays_ in the list. If there are no such subarrays, return `0`.","solution":"def count_beautiful_subarrays(nums, k): Counts the number of beautiful subarrays in the list `nums` that contain exactly `k` odd numbers. from collections import defaultdict count = 0 prefix_counts = defaultdict(int) prefix_counts[0] = 1 odd_count = 0 for num in nums: if num % 2 != 0: odd_count += 1 if odd_count - k in prefix_counts: count += prefix_counts[odd_count - k] prefix_counts[odd_count] += 1 return count"},{"question":"You are given a binary tree with `n` nodes where each node contains a value. Write a function to serialize and deserialize the binary tree. The serialization and deserialization should be done in such a way that ensures the tree structure remains unchanged. The serialization should convert the tree into a single string, and the deserialization should convert the string back into the tree structure. The input for deserialization will be the string obtained from the serialization process. You may assume that the tree does not contain duplicate nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root): Encodes a tree to a single string. :type root: TreeNode :rtype: str def rserialize(node, string): if not node: string += \\"None,\\" else: string += str(node.val) + \\",\\" string = rserialize(node.left, string) string = rserialize(node.right, string) return string return rserialize(root, \\"\\") def deserialize(self, data): Decodes your encoded data to tree. :type data: str :rtype: TreeNode def rdeserialize(data_list): if data_list[0] == \\"None\\": data_list.pop(0) return None root = TreeNode(int(data_list[0])) data_list.pop(0) root.left = rdeserialize(data_list) root.right = rdeserialize(data_list) return root data_list = data.split(\',\') root = rdeserialize(data_list) return root"},{"question":"You are given an array of integers `arr` and an integer `k`. A partition of the array is defined as splitting the array into `k` contiguous subarrays. The score of a partition is defined as the maximum sum of any of its subarrays. Return the minimum possible score after partitioning the array into `k` subarrays.","solution":"def min_max_partition(arr, k): Returns the minimum possible score after partitioning the array into k subarrays. The score is defined as the maximum sum of any subarray in the partition. def can_partition(max_sum): current_sum = 0 partitions = 1 for num in arr: if current_sum + num > max_sum: partitions += 1 current_sum = num if partitions > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"Given an integer array `nums` and an array of queries where each query is represented as an array `[left, right]`, return an array of results where the `ith` result is defined by the **maximum subarray sum** from index `left` to index `right` inclusive. Note that the subarray sum can include negative numbers. For each query, you need to find the contiguous subarray within `[left, right]` which has the largest sum and return that sum. Output an array of these sums, one for each query.","solution":"def maxSubArray(nums): Helper function to find the maximum subarray sum using Kadane\'s algorithm. current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def maxSubArrayQueries(nums, queries): Returns an array of results where each result is the maximum subarray sum for the range specified by each query in the queries array. results = [] for left, right in queries: subarray = nums[left:right+1] results.append(maxSubArray(subarray)) return results"},{"question":"Design a data structure that simulates an in-memory file system. The file system should support the following operations: * `mkdir(path)` - This method creates a new directory at the specified path. If intermediate directories in the path do not exist, they should be created automatically. * `addContentToFile(path, content)` - This method appends the given content to a file at the specified path. If the file does not exist, a new file should be created. * `readContentFromFile(path)` - This method returns the content of the file at the specified path as a single string. * `ls(path)` - This method returns the list of files and directories in the specified path. The implementation should consider edge cases, such as attempting to read a directory as a file or creating nested directories and files.","solution":"class FileSystem: def __init__(self): self.file_system = {\'/\': {}} def mkdir(self, path): current = self.file_system[\'/\'] for part in path.split(\'/\'): if part: # Ignore empty strings if part not in current: current[part] = {} current = current[part] def addContentToFile(self, path, content): current = self.file_system[\'/\'] parts = path.split(\'/\') for part in parts[:-1]: if part: if part not in current: current[part] = {} current = current[part] if parts[-1] in current: if isinstance(current[parts[-1]], str): current[parts[-1]] += content else: raise ValueError(\\"Path is a directory, not a file\\") else: current[parts[-1]] = content def readContentFromFile(self, path): current = self.file_system[\'/\'] parts = path.split(\'/\') for part in parts: if part: current = current[part] if isinstance(current, str): return current else: raise ValueError(\\"Path is a directory, not a file\\") def ls(self, path): current = self.file_system[\'/\'] if path != \'/\': parts = path.split(\'/\') for part in parts: if part: current = current[part] if isinstance(current, str): return [parts[-1]] return sorted(current.keys())"},{"question":"You are given a string `s` containing only lowercase alphabetic characters, and an integer `k`. Your task is to rearrange the string such that the same characters are at least `k` indices apart. If it is not possible to rearrange the string to satisfy this condition, return an empty string. Otherwise, return the rearranged string. For example, given `s = \\"aabbcc\\"`, and `k = 3`, the answer could be `\\"abcabc\\"`.","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): if k == 0: return s # Step 1: Count the frequency of each character freq = Counter(s) # Step 2: Use a max heap to get the most frequent characters first max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) # Step 3: Initialize the result and a queue to keep track of wait time for characters result = [] wait_queue = deque() while max_heap: current_freq, current_char = heapq.heappop(max_heap) result.append(current_char) wait_queue.append((current_char, current_freq + 1)) # Decrease frequency if len(wait_queue) < k: continue # Release the character from the wait queue if it has waited enough char_to_release, freq_to_release = wait_queue.popleft() if freq_to_release < 0: heapq.heappush(max_heap, (freq_to_release, char_to_release)) result_str = \\"\\".join(result) # Step 4: If the length of the result does not match input, it is not possible if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"You are given a binary tree in which each node contains a value. Design a data structure that supports the following operations: 1. `sumEvenGrandparents(TreeNode root)`: Given the root of the binary tree, return the sum of all values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0. 2. `TreeNode findDeepestLeaf(TreeNode root)`: Given the root of the binary tree, return the value of the deepest leaf node. If there are multiple deepest nodes with the same depth, return the leftmost one. **Note**: - The binary tree is non-empty, and all node values are non-negative. - TreeNode is a predefined class representing a node in the binary tree, where `TreeNode(int val)` initializes the node with a value `val`, and `TreeNode left` and `TreeNode right` are the left and right children of the node, respectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumEvenGrandparents(root): def dfs(node, parent_val, grandparent_val): if not node: return 0 sum_val = 0 if grandparent_val % 2 == 0: sum_val += node.val sum_val += dfs(node.left, node.val, parent_val) sum_val += dfs(node.right, node.val, parent_val) return sum_val return dfs(root, 1, 1) # Initial parent and grandparent values are odd, placeholder values def findDeepestLeaf(root): if not root: return None queue = [(root, 0)] max_depth = -1 deepest_leaf = None while queue: node, depth = queue.pop(0) if node: if depth > max_depth: max_depth = depth deepest_leaf = node queue.append((node.left, depth + 1)) queue.append((node.right, depth + 1)) return deepest_leaf.val"},{"question":"You are given a **0-indexed** array `peaks` where each element `peaks[i]` represents the height of a mountain peak at index `i`. A peak `peaks[i]` is considered \\"visible\\" from the left if there is no higher peak to the left of `i`. Similarly, a peak `peaks[i]` is considered \\"visible\\" from the right if there is no higher peak to the right of `i`. A peak might be visible from the left, right, both sides, or neither side. Return an array `visibility` of the same length as `peaks`, where `visibility[i]` is a 2-element list `[left, right]`. `left` is `1` if the peak at index `i` is visible from the left and `0` otherwise. `right`is `1` if the peak at index `i` is visible from the right and `0` otherwise.","solution":"def visibility(peaks): n = len(peaks) visibility = [[0, 0] for _ in range(n)] # Check visibility from the left max_left = float(\'-inf\') for i in range(n): if peaks[i] > max_left: visibility[i][0] = 1 max_left = peaks[i] # Check visibility from the right max_right = float(\'-inf\') for i in range(n-1, -1, -1): if peaks[i] > max_right: visibility[i][1] = 1 max_right = peaks[i] return visibility"},{"question":"You are given an array `projects` where `projects[i]` represents the cost of the `i-th` project, and an integer `budget`. Each project can only be funded if its cost is less than or equal to the remaining `budget`. You start with the full budget and can fund projects in any order. Return _the maximum number of unique projects you can fund_, such that the total cost does not exceed the initial `budget`.","solution":"def max_projects(projects, budget): Returns the maximum number of unique projects that can be funded without exceeding the initial budget. projects.sort() count = 0 total_cost = 0 for cost in projects: if total_cost + cost <= budget: total_cost += cost count += 1 else: break return count"},{"question":"You are given an integer array `arr` of length `n` and an integer `k`. Find the `k-th` **smallest** element in the array using the **Quickselect** algorithm. * Implement the `Quickselect` class: * `Quickselect(int[] arr)` Initializes the Quickselect with the given array `arr`. * `int kthSmallest(int k)` Returns the `k-th` smallest element in the array. The Quickselect algorithm is a selection algorithm to find the `k-th` smallest element in an unordered list. It is related to the quicksort sorting algorithm. For example, given `arr = [3, 2, 1, 5, 4]` and `k = 2`, the `k-th` smallest element is `2`.","solution":"class Quickselect: def __init__(self, arr): self.arr = arr def kthSmallest(self, k): return self.quickselect(0, len(self.arr) - 1, k - 1) def partition(self, left, right, pivot_index): pivot_value = self.arr[pivot_index] self.arr[pivot_index], self.arr[right] = self.arr[right], self.arr[pivot_index] store_index = left for i in range(left, right): if self.arr[i] < pivot_value: self.arr[store_index], self.arr[i] = self.arr[i], self.arr[store_index] store_index += 1 self.arr[right], self.arr[store_index] = self.arr[store_index], self.arr[right] return store_index def quickselect(self, left, right, k): if left == right: return self.arr[left] pivot_index = (left + right) // 2 pivot_index = self.partition(left, right, pivot_index) if k == pivot_index: return self.arr[k] elif k < pivot_index: return self.quickselect(left, pivot_index - 1, k) else: return self.quickselect(pivot_index + 1, right, k)"},{"question":"A company has a `data structure` to store employee information, comprising `n` employees represented as nodes in a list where each node has a unique integer ID from `0` to `n-1`. Each node contains the employee\'s ID and their immediate manager\'s ID, forming a hierarchy. The company\'s CEO does not have a manager, represented by a `-1`. You are given an array `managers`, where `managers[i]` is the manager ID of the `i-th` employee, and `employeeTimes` array where `employeeTimes[i]` is the time it takes for the `i-th` employee to complete a task. When an employee completes a task, they immediately relay the task completion to their manager, who then reports to their own manager, and so on up the hierarchy until the CEO is informed. Write a function that calculates the total time it takes for the task completion to be reported to the CEO given any `employeeID` who starts the task. The function should return the total reporting time for each employee.","solution":"def total_report_time(managers, employeeTimes, employeeID): Calculates the total time taken for task completion to be reported to the CEO starting from a given employeeID. Args: managers (List[int]): list where managers[i] denotes the manager ID of the i-th employee. employeeTimes (List[int]): list where employeeTimes[i] denotes the time taken by the i-th employee to complete a task. employeeID (int): the ID of the employee who starts the task. Returns: int: The total reporting time taken for the task completion to be reported to the CEO. total_time = 0 current_ID = employeeID while current_ID != -1: total_time += employeeTimes[current_ID] current_ID = managers[current_ID] return total_time"},{"question":"Design a program that takes in a non-empty string `s` consisting only of lowercase letters and returns the length of the longest substring with at most two distinct characters.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. if len(s) < 3: return len(s) # Initialize sliding window and result variable left = 0 right = 0 char_map = {} max_length = 2 while right < len(s): char = s[right] if char in char_map: char_map[char] += 1 else: char_map[char] = 1 # If we have more than 2 distinct characters, shrink the window while len(char_map) > 2: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 # Update the result max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given a string `s` representing a sequence of lowercase letters, and an integer `k`. A **substring** is a contiguous segment of a string. A substring is considered to be **special** if no two adjacent characters are identical. Return the length of the longest **special** substring of `s` that contains at most `k` distinct characters. If there are multiple such substrings of the same length, return the length of any one of them.","solution":"def longest_special_substring(s, k): Returns the length of the longest special substring of `s` that contains at most `k` distinct characters. def is_special(sub): return all(sub[i] != sub[i + 1] for i in range(len(sub) - 1)) max_length = 0 n = len(s) for start in range(n): for end in range(start + 1, n + 1): substring = s[start:end] if len(set(substring)) <= k and is_special(substring): max_length = max(max_length, len(substring)) return max_length # Example usage # Suppose s = \\"abcba\\"* and k = 2 # The function should return 2 as \\"ab\\", \\"bc\\", and \\"cb\\" are the longest special substrings with at most 2 distinct characters."},{"question":"Write a function to find the missing number in a given sequence of `n` integers, where the sequence contains all the consecutive numbers from `0` to `n` except one. Your function should return the missing number. For example, if the input sequence is `[3, 0, 1]`, the missing number is `2`, and if the input sequence is `[0, 1]`, the missing number is `2`. You can assume that the input sequence is always valid, and there will be exactly one number missing.","solution":"def find_missing_number(sequence): Finds the missing number in a sequence of consecutive integers from 0 to n except one. Args: sequence (list): A list of integers containing n integers where one is missing. Returns: int: The missing integer. n = len(sequence) expected_sum = n * (n + 1) // 2 actual_sum = sum(sequence) return expected_sum - actual_sum"},{"question":"Implement a function `int closestPalindrome(int num)` that takes an integer `num` as input and returns the closest integer palindrome. If there are multiple palindromes at the same distance, return the smaller one. An integer palindrome is a number that reads the same backward and forward.","solution":"def closestPalindrome(num): Returns the closest integer palindrome to the given number. If there are multiple palindromes at the same distance, returns the smaller one. if str(num) == str(num)[::-1]: return num lower = num - 1 upper = num + 1 while True: if str(lower) == str(lower)[::-1]: return lower if str(upper) == str(upper)[::-1]: return upper lower -= 1 upper += 1"},{"question":"You are given a string `s` of length `n` consisting of lowercase English letters, and an integer `k`. You need to perform a series of operations to create the lexicographically smallest string possible. In one operation, you can either: * Remove the first character of `s` and append it to the end of the string. * Rearrange the entire string `s` in any order you like, but you can only do this if `k` is at least 2. Write a function `minLexString(s, k)` that returns the lexicographically smallest string that can be obtained after performing some number of the above operations.","solution":"def minLexString(s, k): Returns the lexicographically smallest string possible by performing a series of operations on the string s. if k == 1: # Generate all rotations and return the smallest one min_string = s for i in range(len(s)): rotated_string = s[i:] + s[:i] if rotated_string < min_string: min_string = rotated_string return min_string else: # If k >= 2, we can just return the sorted version of s return \'\'.join(sorted(s))"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting of non-negative integers where `grid[i][j]` represents the height of terrain at coordinate `(i, j)`. You are also given the coordinates of a source cell `source` and a destination cell `destination`. You start at the source cell and can move to any of the four adjacent cells (up, down, left, right). You want to determine the minimum maximum height encountered on any path from `source` to `destination`. If it is impossible to reach the destination, return `-1`. Otherwise, return the minimum maximum height encountered.","solution":"from heapq import heappop, heappush from typing import List, Tuple def min_max_path(grid: List[List[int]], source: Tuple[int, int], destination: Tuple[int, int]) -> int: Returns the minimum maximum height encountered on any path from source to destination. If it\'s impossible to reach the destination, return -1. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def in_bounds(x, y): return 0 <= x < m and 0 <= y < n pq = [(grid[source[0]][source[1]], source)] visited = set() while pq: max_height, (x, y) = heappop(pq) if (x, y) == destination: return max_height if (x, y) in visited: continue visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and (nx, ny) not in visited: heappush(pq, (max(max_height, grid[nx][ny]), (nx, ny))) return -1"},{"question":"Implement a class `LruCache` which simulates a Least Recently Used (LRU) cache. The cache should support the following operations: `get(key)` and `set(key, value)`. For `get(key)`, it should return the value associated with the key if the key exists in the cache, otherwise return -1. For `set(key, value)`, it should insert the value keyed by the key into the cache. If inserting the new item causes the cache to exceed its predetermined capacity, it should evict the least recently used item before inserting the new item. When an item is accessed or inserted, it should become the most recently used item. The `LruCache` class should be initialized with an integer capacity specifying the maximum number of items it can hold. **Example:** ```python cache = LruCache(2) cache.set(1, 1) # cache is {1=1} cache.set(2, 2) # cache is {1=1, 2=2} cache.get(1) # returns 1 cache.set(3, 3) # evicts key 2, cache is {1=1, 3=3} cache.get(2) # returns -1 (not found) cache.set(4, 4) # evicts key 1, cache is {3=3, 4=4} cache.get(1) # returns -1 (not found) cache.get(3) # returns 3 cache.get(4) # returns 4 ``` **Note:** The cache must be implemented with a mechanism that ensures both operations run in O(1) time complexity.","solution":"class LruCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.insert(0, key) return self.cache[key] return -1 def set(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: oldest_key = self.order.pop() del self.cache[oldest_key] self.cache[key] = value self.order.insert(0, key)"},{"question":"You are given a binary tree with `n` nodes. Each node in the tree contains a single-digit integer value (0-9). Define the **path sum** of a path in the binary tree as the number formed by concatenating the values on the linear path from the root to any leaf node. For instance, if a path from the root to a leaf node is 1  2  3, the corresponding path sum is 123. Write a function that returns the **maximum** path sum in the binary tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_sum(root): Returns the maximum path sum in the binary tree. def dfs(node, current_sum): if not node: return 0 current_sum = current_sum * 10 + node.value if not node.left and not node.right: return current_sum left_sum = dfs(node.left, current_sum) right_sum = dfs(node.right, current_sum) return max(left_sum, right_sum) return dfs(root, 0)"},{"question":"You are given a string `s` representing a sentence, and an integer `k`. You need to return the length of the longest substring that contains no more than `k` distinct characters. If `k` is greater than or equal to the number of unique characters in `s`, return the length of the entire string `s`. Ensure the solution has optimal time complexity.","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains no more than k distinct characters. If k is greater than or equal to the number of unique characters in s, returns the length of s. :param s: str - the input string :param k: int - the maximum number of distinct characters :return: int - the length of the longest substring meeting the criteria if k == 0 or not s: return 0 n = len(s) if k >= len(set(s)): return n left = 0 right = 0 char_map = {} max_length = 0 while right < n: char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"Given a string `s` representing an arithmetical expression in which the operands are non-negative integers and the operator is one of `+`, `-`, `*`, or `/`, write a function to evaluate the expression and return the result as an integer. Note that division between two integers should truncate toward zero. You may assume that the given string is always valid and does not contain any leading or trailing spaces. The input expression may have spaces between the operands and operators, and the operators and operands are separated by at least one space. **Example 1:** **Input:** s = \\"3 + 5\\" **Output:** 8 **Example 2:** **Input:** s = \\"10 + 2 * 6\\" **Output:** 22 **Example 3:** **Input:** s = \\"100 * 2 + 12\\" **Output:** 212 **Example 4:** **Input:** s = \\"100 * ( 2 + 12 )\\" **Output:** 1400 **Example 5:** **Input:** s = \\"100 - 6 / 3\\" **Output:** 98","solution":"def evaluate_expression(s): Evaluates an arithmetical expression given as a string and returns the result as an integer. # Helper function to perform the basic arithmetic def operate(a, b, op): if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b elif op == \'/\': return int(a / b) # Truncate towards zero # Tokenize the string by spaces tokens = s.split() values = [] operations = [] i = 0 while i < len(tokens): token = tokens[i] if token.isdigit(): values.append(int(token)) elif token in \\"+-\\": while (operations and operations[-1] in \\"+-*/\\"): values.append(operate(values.pop(-2), values.pop(), operations.pop())) operations.append(token) elif token in \\"*/\\": while (operations and operations[-1] in \\"*/\\"): values.append(operate(values.pop(-2), values.pop(), operations.pop())) operations.append(token) elif token == \'(\': operations.append(token) elif token == \')\': while operations[-1] != \'(\': values.append(operate(values.pop(-2), values.pop(), operations.pop())) operations.pop() # Remove \'(\' from stack i += 1 while operations: values.append(operate(values.pop(-2), values.pop(), operations.pop())) return values[0]"},{"question":"You are working as a network administrator for a company. The company has a set of connected servers represented by a graph. Each server is labeled from `0` to `n - 1`. Some pairs of servers are directly connected by cables, and each cable has a certain delay time in milliseconds. Your task is to ensure that there is a data transfer path between any two servers with the minimum possible maximum delay time along that path. You are given an integer `n` representing the number of servers and a list `edges` where `edges[i] = [u, v, time]` represents a cable with a delay time between server `u` and server `v`. Return _the minimum possible maximum delay time to ensure connectivity between every pair of servers_. **Note:** If it\'s not possible to connect all servers, return `-1`.","solution":"def minimum_maximum_delay(n, edges): parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Sort edges based on the delay time edges.sort(key=lambda x: x[2]) max_delay = 0 for u, v, time in edges: if find(u) != find(v): union(u, v) max_delay = time # Check if all servers are connected root = find(0) if all(find(i) == root for i in range(n)): return max_delay else: return -1"},{"question":"You are given a list of integers representing values in a sequence. Your task is to find and return a list containing the longest subsequence such that all elements in this subsequence are in non-decreasing order. If there are multiple subsequences of the same maximum length, return any one of them. Formally, given a list of integers `nums`, return _a list of integers_ representing the longest non-decreasing subsequence found within `nums`. For example, given `nums = [1, 3, 2, 3, 4, 1, 2, 3]`, one possible longest non-decreasing subsequence is `[1, 2, 3, 4]`. Note that `[1, 3, 3, 4]` is also correct as it has the same length.","solution":"def longest_non_decreasing_subsequence(nums): if not nums: return [] n = len(nums) lengths = [1] * n previous = [-1] * n for i in range(1, n): for j in range(i): if nums[i] >= nums[j] and lengths[i] < lengths[j] + 1: lengths[i] = lengths[j] + 1 previous[i] = j max_length = max(lengths) max_index = lengths.index(max_length) result = [] while max_index != -1: result.append(nums[max_index]) max_index = previous[max_index] return result[::-1]"},{"question":"Given an integer array `arr` and two integers `x` and `y`, return the length of the smallest contiguous subarray of `arr` containing at least one occurrence of both elements `x` and `y`. If such a subarray does not exist, return `-1`.","solution":"def min_subarray_length_with_elements(arr, x, y): Returns the length of the smallest contiguous subarray of `arr` containing at least one occurrence of both elements `x` and `y`. If such a subarray does not exist, returns -1. n = len(arr) min_length = float(\'inf\') last_x, last_y = -1, -1 for i in range(n): if arr[i] == x: last_x = i if arr[i] == y: last_y = i if last_x != -1 and last_y != -1: current_length = abs(last_x - last_y) + 1 min_length = min(min_length, current_length) if min_length == float(\'inf\'): return -1 return min_length"},{"question":"You are given a directed graph of `n` nodes and `m` edges, where each node is labeled from `0` to `n-1`. The graph is represented by a 2D integer array `edges` where `edges[i] = [ui, vi]` indicates a directed edge from node `ui` to node `vi`. You are also given two nodes, `start` and `end`. Your task is to determine if there is a **valid path** from `start` to `end` in the given directed graph. Return `true` if such a path exists, `false` otherwise. The input follows these conditions: - `n` is in the range `[2, 10^4]`. - `m` is in the range `[1, 2 * 10^4]`. - `edges[i]` consists of two different nodes `ui` and `vi`. - The graph may contain cycles.","solution":"def valid_path(n, edges, start, end): Determines if there is a valid path from start to end in the given directed graph. :param n: Number of nodes in the graph :param edges: List of directed edges in the form [ui, vi] :param start: Starting node :param end: Ending node :return: True if there is a valid path from start to end, False otherwise from collections import deque, defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"You are given a string `s` representing a **valid** parentheses sequence. Your task is to determine the **maximal nesting depth** of the parentheses in the string. The nesting depth of a pair of parentheses is the number of pairs contained within it, including the pair itself. For example, in the string `((()))`, the nesting depth is 3, because there are three pairs of parentheses contained within the outermost pair. Return _an integer denoting the maximal nesting depth of the parentheses in the string_.","solution":"def max_nesting_depth(s): Returns the maximal nesting depth of the parentheses in the string `s`. max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"You are given a string `s` consisting of only lowercase English letters. You need to form a new string by deleting some characters from `s` such that no two adjacent characters are the same. Return _the minimum number of deletions required to achieve this_. The test cases are generated so that the answer fits in a **32-bit** signed integer.","solution":"def min_deletions(s): Calculates the minimum number of deletions required such that no two adjacent characters are the same :param s: input string consisting of only lowercase English letters :return: minimum number of deletions required if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"You are given an undirected graph represented as an adjacency list, where the graph can be disconnected. Each node in the graph has a label (an integer) and is connected to a list of other nodes. You need to determine if the graph has a **cycle**. A cycle is a path of edges and vertices wherein a vertex is reachable from itself. Return _true_ if there is at least one cycle in the graph, and _false_ otherwise.","solution":"def has_cycle(graph): def dfs(node, parent, visited): visited[node] = True for neighbor in graph[node]: if not visited.get(neighbor): if dfs(neighbor, node, visited): return True elif neighbor != parent: return True return False visited = {} for node in graph: if not visited.get(node): if dfs(node, None, visited): return True return False"},{"question":"You are given a list of flights `flights` represented as triplets `[from, to, price]`, and a source city `src`, a destination city `dst`, and an integer `k`. Find the cheapest price from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`. A stop is defined as a city where you can transfer from one flight to another. Note that `from` city in `flights` is the departure city, `to` city is the arrival city, and `price` is the cost of the flight between those cities. Return _the cheapest price to get from `src` to `dst` with at most `k` stops or `-1` if no such route exists_.","solution":"import heapq def findCheapestPrice(n, flights, src, dst, k): # Create dictionary to store all flights adjacency graph = {i: [] for i in range(n)} for u, v, price in flights: graph[u].append((v, price)) # Min-heap to store the current total cost, current city, and remaining stops heap = [(0, src, k + 1)] while heap: total_cost, u, stops_left = heapq.heappop(heap) if u == dst: return total_cost if stops_left > 0: for v, price in graph[u]: heapq.heappush(heap, (total_cost + price, v, stops_left - 1)) return -1"},{"question":"A **tree** is a special type of **graph** that is connected and has no cycles. A tree can be represented using an array `parent` where `parent[i]` represents the parent node of the `i-th` node. The root node always has a parent value of `-1`. You are given a tree containing `n` nodes labeled from `0` to `n-1` in the form of this `parent` array. Write a function to find the **height** of the tree. The height of a tree is the number of edges on the longest path from the root to any leaf. ```python def treeHeight(parent: List[int]) -> int: # Implement your function here ```","solution":"from typing import List def treeHeight(parent: List[int]) -> int: def find_height(node: int, memo: List[int]) -> int: if memo[node] != -1: return memo[node] if parent[node] == -1: memo[node] = 0 else: memo[node] = 1 + find_height(parent[node], memo) return memo[node] n = len(parent) memo = [-1] * n height = 0 for i in range(n): height = max(height, find_height(i, memo)) return height"},{"question":"Given a binary tree, find the length of the longest path which is a zig-zag path. A zig-zag path is defined as follows: - Each node in the path must have a child that alternates between left and right. - For instance, if a node has a left child, the next node in the path must have a right child, and vice versa. Return the length of the longest zig-zag path in the given binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestZigZag(root: TreeNode) -> int: def dfs(node, direction, length): if not node: return nonlocal max_length max_length = max(max_length, length) if direction == \'left\': dfs(node.left, \'right\', length + 1) dfs(node.right, \'left\', 1) else: dfs(node.left, \'right\', 1) dfs(node.right, \'left\', length + 1) max_length = 0 if root: dfs(root.left, \'right\', 1) dfs(root.right, \'left\', 1) return max_length"},{"question":"You are given a list of `events`, where each event is a tuple with two elements: a timestamp and a description. Your task is to process this list of events and group them by date. For each date, you need to return the list of descriptions sorted by their timestamps. To achieve this: 1. Parse the timestamp to extract the date. 2. Group the events by their date. 3. Sort the descriptions within each date group based on the associated timestamps. Return a dictionary where the keys are the dates and the values are lists of descriptions sorted by their timestamps. For example, given the `events` list: ``` events = [( \'2023-10-01 08:00:00\', \'Event A\'), ( \'2023-10-01 09:00:00\', \'Event B\'), ( \'2023-10-02 07:00:00\', \'Event C\')] ``` The expected output would be: ``` { \'2023-10-01\': [\'Event A\', \'Event B\'], \'2023-10-02\': [\'Event C\'] } ```","solution":"from collections import defaultdict from datetime import datetime def group_events_by_date(events): Groups events by their dates and sorts descriptions by their timestamps. Parameters: events (list of tuple): A list where each tuple contains a timestamp and a description. Returns: dict: A dictionary with dates as keys and lists of sorted descriptions as values. grouped_events = defaultdict(list) for timestamp, description in events: date = timestamp.split()[0] grouped_events[date].append((timestamp, description)) for date in grouped_events: grouped_events[date].sort() grouped_events[date] = [desc for _, desc in grouped_events[date]] return dict(grouped_events)"},{"question":"Given a string `s`, you are required to find the length of the longest substring with at most `k` distinct characters. Implement the following function: * `public int lengthOfLongestSubstringKDistinct(String s, int k)` Where: - `s` is a string consisting of characters. - `k` is an integer representing the maximum distinct characters allowed in the substring. Note: - If `k` is 0, return 0. - If the length of the string is less than or equal to `k`, return the length of the string. For example: - Given `s = \\"eceba\\"` and `k = 2`, the longest substring with at most 2 distinct characters is `\\"ece\\"` which has a length of 3. - Given `s = \\"aaaa\\"` and `k = 1`, the longest substring with at most 1 distinct character is `\\"aaaa\\"` with a length of 4.","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. if k == 0: return 0 n = len(s) if n <= k: return n left = 0 right = 0 max_length = 0 char_map = {} while right < n: char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Your task is to determine whether there are three integers in the array that form an arithmetic progression. An arithmetic progression is a sequence of numbers where the difference between consecutive numbers is constant. Return `true` if such a progression exists, and `false` otherwise.","solution":"def has_arithmetic_progression(nums): Determines if there are three integers in the array that form an arithmetic progression. n = len(nums) if n < 3: return False for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if nums[j] - nums[i] == nums[k] - nums[j]: return True return False"},{"question":"You are given an integer array `nums`, where `nums[i]` represents the number of candies in the `i-th` box. A box may contain a negative number of candies, representing a debt that must be paid. Your task is to find the maximum number of candies that can be collected by picking a contiguous subarray from `nums`. Return this maximum number.","solution":"def max_candies(nums): Returns the maximum number of candies that can be collected by picking a contiguous subarray from nums. Parameters: nums (List[int]): List of integers representing the number of candies in each box. Returns: int: The maximum number of candies from any contiguous subarray. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"Given a binary tree, return the number of paths with a sum that equals a given value `sum`, where the path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, sum): Returns the number of paths with a specified sum in a binary tree. The path does not need to start or end at the root, but it must go downwards (traveling only from parent nodes to child nodes). def dfs(node, current_path): if not node: return 0 current_path.append(node.val) path_count, path_sum = 0, 0 for val in reversed(current_path): path_sum += val if path_sum == sum: path_count += 1 path_count += dfs(node.left, current_path) path_count += dfs(node.right, current_path) current_path.pop() return path_count return dfs(root, []) # Example usage: # tree = TreeNode(10) # tree.left = TreeNode(5) # tree.right = TreeNode(-3) # tree.left.left = TreeNode(3) # tree.left.right = TreeNode(2) # tree.right.right = TreeNode(11) # tree.left.left.left = TreeNode(3) # tree.left.left.right = TreeNode(-2) # tree.left.right.right = TreeNode(1) # assert path_sum(tree, 8) == 3"},{"question":"Given an array of integers `arr` and an integer `k`, return _the`k`th **distinct** integer in the array_. If there are fewer than `k` distinct integers, return `-1`. The array contains at most `10^4` integers, and each integer is at most `10^6`.","solution":"def kth_distinct(arr, k): Returns the k-th distinct integer in the array or -1 if there are fewer than k distinct integers. Parameters: arr (list of int): List of integers. k (int): The k-th distinct number to find. Returns: int: The k-th distinct integer or -1 if k is greater than the number of distinct integers. distinct_elements = list(dict.fromkeys(arr)) if k <= len(distinct_elements): return distinct_elements[k-1] else: return -1"},{"question":"You are given a string `s` consisting of only the characters \'a\', \'b\', and \'c\'. Your task is to find the length of the longest substring of `s` that does not contain more than 1 occurrence of any character. If the input string is empty, return 0. For example, for the input string `\\"abcabcbb\\"`, the longest substring without repeating characters is `\\"abc\\"`, which has a length of 3. Similarly, for the input string `\\"bbbbb\\"`, the longest substring without repeating characters is `\\"b\\"`, which has a length of 1.","solution":"def longest_substring_without_repeating_chars(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string consisting of only \'a\', \'b\', and \'c\'. Returns: int: The length of the longest substring without repeating characters. if not s: return 0 n = len(s) max_length = 0 char_set = set() left = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given two integer arrays `nums1` and `nums2` representing the digits of two large numbers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return the resulting sum as a reverse ordered array where each element represents a single digit of the sum.","solution":"def add_two_numbers(nums1, nums2): Adds two numbers represented by reversed arrays of digits. Args: nums1: List[int] - List of digits of the first number in reverse order. nums2: List[int] - List of digits of the second number in reverse order. Returns: List[int] - List of digits of the resulting sum in reverse order. carry = 0 result = [] # Process each digit until the end of longer list is reached for i in range(max(len(nums1), len(nums2))): # Get current digits or 0 if index is beyond list length digit1 = nums1[i] if i < len(nums1) else 0 digit2 = nums2[i] if i < len(nums2) else 0 # Sum current digits and carry total = digit1 + digit2 + carry # Current digit is total modulo 10, carry is total divided by 10 result.append(total % 10) carry = total // 10 # If carry remains, add it as a new digit if carry: result.append(carry) return result"},{"question":"You are given an array `servers` where `servers[i]` represents the processing power of the i-th server. You also have a 2D array `tasks` where `tasks[i] = [starti, endi, powi]` denotes that there is a task which starts at time `starti`, ends at time `endi`, and requires at least `powi` processing power. A server can only process one task at a time. Return _the maximum number of tasks that can be successfully assigned to the servers without overlapping_. If no tasks can be assigned, return 0.","solution":"def max_tasks(servers, tasks): # Sort the tasks by their end time tasks.sort(key=lambda x: x[1]) # Represents the availability of each server server_availability = [0] * len(servers) tasks_completed = 0 for task in tasks: starti, endi, powi = task for i, server_power in enumerate(servers): # Check if this server can handle this task and is available if server_power >= powi and server_availability[i] <= starti: server_availability[i] = endi tasks_completed += 1 break return tasks_completed"},{"question":"You are given a string `s` consisting of characters `\'a\'`, `\'b\'`, and `\'c\'`. A substring of `s` is called a good substring if it does not contain any repeated characters. Return _the number of good substrings of length `3` in `s`_. For example, if the input is `\\"abacabc\\"`, the good substrings are `\\"abc\\"`, `\\"bac\\"`, and `\\"cab\\"`, so the output should be `3`.","solution":"def count_good_substrings(s: str) -> int: Counts the number of good substrings of length 3 in the given string s. A good substring is defined as a substring that does not contain any repeated characters. :param s: The input string containing characters \'a\', \'b\', and \'c\'. :return: The number of good substrings of length 3. count = 0 for i in range(len(s) - 2): substring = s[i:i+3] if len(set(substring)) == 3: count += 1 return count"},{"question":"Given an array of integers `nums`, you are to find the position of the peak element. A peak element is an element that is strictly greater than its neighbors. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that `nums[-1]` and `nums[n]` (where `n` is the length of `nums`) are both negative infinity (-). Implement your solution in `O(log n)` time complexity.","solution":"def find_peak_element(nums): Finds the index of a peak element in the array. A peak element is an element that is strictly greater than its neighbors. The function is optimized to run in O(log n) time complexity using binary search. :param nums: List[int] :return: int if not nums: return -1 left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given a list of bank account transactions represented as a 2D array `transactions` where each `transactions[i] = [accountNumberi, transactionTypei, amounti]`. `accountNumberi` is a string representing a unique account number, `transactionTypei` is a string that can either be `\\"deposit\\"` or `\\"withdraw\\"`, and `amounti` is an integer representing the amount of the transaction. Each transaction is applied sequentially. If a withdrawal transaction results in a negative balance for that account, that specific transaction is ignored. Return _the account number that has the highest balance after all transactions have been processed_. If there are multiple accounts with the same highest balance, return the account number that appears first in the input.","solution":"def find_highest_balance_account(transactions): Returns the account number that has the highest balance after all transactions have been processed. Arguments: transactions -- list of transactions, where each transaction is represented as [accountNumber, transactionType, amount] Returns: string -- the account number with the highest balance account_balances = {} for accountNumber, transactionType, amount in transactions: if accountNumber not in account_balances: account_balances[accountNumber] = 0 if transactionType == \'deposit\': account_balances[accountNumber] += amount elif transactionType == \'withdraw\': if account_balances[accountNumber] >= amount: account_balances[accountNumber] -= amount # Find the account number with the highest balance highest_balance_account = max(account_balances.keys(), key=lambda k: account_balances[k]) return highest_balance_account"},{"question":"Given a matrix `mat` of size `m x n`, return _the number of islands_. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the matrix are surrounded by water. Use depth-first search (DFS) to solve the problem.","solution":"def num_islands(mat): Return the number of islands in the given matrix using DFS. :param mat: List[List[int]] - Matrix of size m x n with 1s (land) and 0s (water). :return: int - Number of islands. if not mat: return 0 def dfs(mat, i, j): Perform DFS to visit all parts of the island if i < 0 or i >= len(mat) or j < 0 or j >= len(mat[0]) or mat[i][j] == 0: return mat[i][j] = 0 # Mark the visited land as water dfs(mat, i+1, j) dfs(mat, i-1, j) dfs(mat, i, j+1) dfs(mat, i, j-1) count = 0 for i in range(len(mat)): for j in range(len(mat[0])): if mat[i][j] == 1: count += 1 dfs(mat, i, j) return count"},{"question":"You are given a **0-indexed** `n` x `n` binary matrix `grid` where `1` represents land and `0` represents water. A **lake** is a collection of water cells (`0`s) connected 4-directionally (up, down, left, right). A lake is **surrounded** by land if all the water cells are completely enclosed by land (`1`s). Return the number of lakes in the grid that are completely surrounded by land.","solution":"def num_enclosed_lakes(grid): Returns the number of lakes that are completely surrounded by land in the given grid. if not grid or not grid[0]: return 0 n = len(grid) visited = [[False] * n for _ in range(n)] def is_on_border(x, y): return x == 0 or y == 0 or x == n - 1 or y == n - 1 def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= n or visited[x][y] or grid[x][y] == 1: return visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy) # Mark all water cells that are connected to the border for i in range(n): for j in range(n): if (i == 0 or i == n - 1 or j == 0 or j == n - 1) and grid[i][j] == 0 and not visited[i][j]: dfs(i, j) # Now count all the lakes that are surrounded by land lake_count = 0 for i in range(1, n - 1): for j in range(1, n - 1): if grid[i][j] == 0 and not visited[i][j]: # Found a lake that is surrounded by land lake_count += 1 dfs(i, j) return lake_count"},{"question":"You are given a positive integer `target` and an array of positive integers `numbers`. A number is called \\"special\\" if it is a divisor of `target`. You can select multiple indices from `numbers` (you may not select any as well), and then form a sum with the corresponding values of the selected indices. Determine if there exists a subset of `numbers` such that their sum is a \\"special\\" number. Return _true_ if such a subset exists, otherwise return _false_.","solution":"def is_special_subset(target, numbers): Determines if there exists a subset of `numbers` such that their sum is a divisor of `target`. Parameters: target (int): The target number. numbers (list of int): The list of positive integers. Returns: bool: True if such a subset exists, False otherwise. # Set of \\"special\\" numbers which are divisors of `target` special_numbers = {i for i in range(1, target+1) if target % i == 0} # Dynamic programming approach to find the possible sums we can achieve possible_sums = {0} for num in numbers: new_sums = {num + ps for ps in possible_sums} possible_sums.update(new_sums) # Check if any of the possible sums is a \\"special\\" number return not special_numbers.isdisjoint(possible_sums)"},{"question":"Given a rectangular grid of characters, where each cell contains exactly one lowercase letter, you are asked to find the largest rectangle (subgrid) that can be formed such that all the letters in this rectangle are the same. Return _the area of the largest rectangle with only one distinct character_ in the grid. If no such rectangle can be formed, return `0`.","solution":"def largest_rectangle(grid): Function to find the largest rectangle in a grid where all characters are the same. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) max_area = 0 for i in range(rows): for j in range(cols): char = grid[i][j] width = cols for k in range(i, rows): if grid[k][j] != char: break width = min(width, len([x for x in grid[k][j:cols] if x == char])) height = k - i + 1 max_area = max(max_area, width * height) return max_area"},{"question":"You are given a binary tree with its root labeled as `root`. Each node in the tree has a distinct value. You are also given a list of values `to_delete`. After deleting all nodes with values in `to_delete`, a forest is generated and you need to find the roots of the resulting trees. Return the list of the roots of the trees in the forest in any order. Be sure to consider edge cases where all nodes are deleted, or no nodes are deleted.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def del_nodes(root, to_delete): to_delete_set = set(to_delete) remaining_forest = [] def helper(node): if not node: return None node.left = helper(node.left) node.right = helper(node.right) if node.val in to_delete_set: if node.left: remaining_forest.append(node.left) if node.right: remaining_forest.append(node.right) return None return node if helper(root): remaining_forest.append(root) return [node.val for node in remaining_forest]"},{"question":"You are given a list of tuples where each tuple contains an `employee_id` and their respective `manager_id`. The `CEO` of the company is the only employee with their `manager_id` as `-1`. Each employee directly reports to one manager and there are no cycles in the reporting structure. Write a function to return the hierarchy of the company as a nested dictionary, starting from the `CEO`. For example, given the input `[(1, -1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 3)]`, the output should be: ``` { 1: { 2: { 4: {}, 5: {} }, 3: { 6: {} } } } ```","solution":"def build_hierarchy(employee_manager_pairs): def build_sub_tree(manager_id): return { employee_id: build_sub_tree(employee_id) for employee_id in manager_dict.get(manager_id, []) } manager_dict = {} ceo_id = -1 for employee_id, manager_id in employee_manager_pairs: if manager_id == -1: ceo_id = employee_id if manager_id in manager_dict: manager_dict[manager_id].append(employee_id) else: manager_dict[manager_id] = [employee_id] hierarchy = {ceo_id: build_sub_tree(ceo_id)} return hierarchy"},{"question":"Given a string `s` and an integer `k`, move each character in `s` forward by `k` positions in the alphabetical order. If a character exceeds \'z\' after the shift, it wraps around to the beginning of the alphabet. For example, with `s = \\"abcd\\"` and `k = 1`, the result would be `\\"bcde\\"`. Return _the transformed string_.","solution":"def shift_string(s, k): Shifts each character in the string s forward by k positions in the alphabetical order. If a character exceeds \'z\', it wraps around to the beginning of the alphabet. Parameters: s (str): The input string to be shifted. k (int): The number of positions to shift each character. Returns: str: The transformed string after shifting. # Define the alphabet length alphabet_length = 26 # Create the transformed string list shifted_string = [] for char in s: # Calculate the new position of the character new_position = (ord(char) - ord(\'a\') + k) % alphabet_length # Append the new character to the transformed string list shifted_string.append(chr(ord(\'a\') + new_position)) # Join the list to form the final transformed string return \'\'.join(shifted_string)"},{"question":"Given an array `heights` representing the heights of adjacent buildings, determine the maximum water that can be trapped between the buildings after raining. Each building has unit width, and the water can only be trapped between two buildings if it is bounded by taller buildings on both sides. Return the maximum amount of water that can be trapped.","solution":"def max_water_trapped(heights): Calculate the maximum water trapped between the buildings after raining. Args: heights (list of int): The heights of adjacent buildings. Returns: int: The maximum amount of water that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"You are given a **triangular array** of integers `triangle`. Your task is to find the **minimum path sum** from the top to the bottom. Each step you may move to an adjacent number on the row below. More formally, if you are on the ( i )-th row and ( j )-th column, you may move to either the ( (i+1) )-th row and ( j ) column or the ( (i+1) )-th row and ( j+1 ) column. Return the minimum path sum from top to bottom.","solution":"def minimum_total(triangle): if not triangle: return 0 # Start from the second to last row, reduce upwards to the top row. for row in range(len(triangle) - 2, -1, -1): for col in range(len(triangle[row])): # Update the current value to be the minimum path sum of itself and the numbers in the row below triangle[row][col] += min(triangle[row+1][col], triangle[row+1][col+1]) # The top element will have the minimum path sum at the end return triangle[0][0]"},{"question":"You are given a 2D grid consisting of integers, where each cell represents a specific height. Starting from the top-left corner of the grid, try to reach the bottom-right corner. You can move up, down, left, or right. The effort of a path is defined as the maximum absolute difference in heights between two consecutive cells of the path. Find a path with the minimum effort and return its effort.","solution":"from heapq import heappop, heappush def minimum_effort_path(heights): Calculates the minimum effort to traverse from the top-left to the bottom-right corner of a given 2D grid. The effort is defined as the maximum absolute difference in heights between two consecutive cells of the path. :param heights: List of List of ints, representing the heights of the grid :return: The minimum effort required to traverse the grid # Possible moves (right, left, down, up) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] rows, cols = len(heights), len(heights[0]) # Min-heap to store (effort, row, column) heap = [(0, 0, 0)] efforts = [[float(\'inf\')] * cols for _ in range(rows)] efforts[0][0] = 0 while heap: current_effort, row, col = heappop(heap) if row == rows - 1 and col == cols - 1: return current_effort for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols: new_effort = max(current_effort, abs(heights[new_row][new_col] - heights[row][col])) if new_effort < efforts[new_row][new_col]: efforts[new_row][new_col] = new_effort heappush(heap, (new_effort, new_row, new_col))"},{"question":"You are given a string `str` containing only lowercase English letters. A substring is defined as a contiguous sequence of characters in the string. Find the longest substring where the number of distinct characters is exactly `k`. If there are multiple substrings with the same length that satisfy the condition, return the first one you encounter. If no such substring exists, return an empty string.","solution":"def longest_k_distinct_substring(s, k): Returns the longest substring where the number of distinct characters is exactly k. If there are multiple substrings with the same length, return the first one encountered. If no such substring exists, return an empty string. if k == 0 or not s: return \\"\\" char_count = {} left = 0 max_length = 0 max_substr = \\"\\" for right in range(len(s)): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: if right - left + 1 > max_length: max_length = right - left + 1 max_substr = s[left:right + 1] return max_substr"},{"question":"You are given a grid with `n` rows and `m` columns, where each cell in the grid contains either a 0 or a 1. You are initially positioned at the top-left cell of the grid (i.e., cell (0, 0)). At each step, you can move to any of the four adjacent cells (left, right, up, down). Your goal is to reach the bottom-right cell of the grid (i.e., cell (n-1, m-1)). However, you can only move through cells that contain a 0. Your task is to determine the **minimum number of steps** required to reach the bottom-right cell from the top-left cell. If there is no possible way to reach the goal, return -1.","solution":"from collections import deque def min_steps_to_reach_end(grid): Returns the minimum number of steps required to reach the bottom-right cell of the grid from the top-left cell. If there is no possible way, return -1. n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Given a string `s` consisting of lowercase alphabets, remove the minimum number of characters so that no two adjacent characters are the same. Return the resulting string. If there are multiple valid solutions, return any one of them.","solution":"def remove_adjacent_duplicates(s): Given a string s consisting of lowercase alphabets, remove the minimum number of characters so that no two adjacent characters are the same. :param s: str - input string consisting of lowercase alphabets :return: str - resulting string with no adjacent duplicates result = [] for char in s: if result and result[-1] == char: continue result.append(char) return \'\'.join(result)"},{"question":"Write a function that takes a string containing only lowercase letters and returns the length of the longest substring with all unique characters. For instance, the substring \\"abc\\" has all unique characters, and the length would be 3. If there are no such substrings, return 0. Note that you must solve it with a time complexity of O(n).","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_index_map = {} max_len = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given a list of `n` positive integers, where each integer represents the height of a building. Rainwater can be trapped between the buildings. You need to calculate how much water can be trapped after raining. Return _the total amount of rainwater that can be trapped._","solution":"def trap_rainwater(heights): Given a list of non-negative integers representing the heights of buildings, calculates the total amount of rainwater that can be trapped. :param heights: List[int] - List of building heights :return: int - Total amount of trapped rainwater if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"Implement an iterator class for a binary search tree (BST). The iterator should be initialized with the root node of a BST. Implement the following methods: * `BSTIterator(TreeNode root)` - Constructs an iterator that initializes itself with the root node of the BST. * `int next()` - Returns the next smallest number in the BST. * `boolean hasNext()` - Returns `true` if there is a next smallest number, otherwise returns `false`. A `TreeNode` structure is defined with `int val`, `TreeNode left`, and `TreeNode right`. The methods should ensure the iterator traverses the tree in an in-order manner.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self): topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self): return bool(self.stack)"},{"question":"You are given a list of `n` network nodes, labeled `0` to `n-1`. To identify important nodes, you need to calculate the **closeness centrality** for each node. The closeness centrality of a node is defined as the reciprocal of the sum of the shortest path distances from that node to all other nodes in the network. You are given the network as an adjacency list where `graph[i]` contains a list of all nodes directly connected to node `i`. Implement the `Centrality` class: - `Centrality(List<List<Integer>> graph)` Initializes the object with the adjacency list `graph`. - `double[] calculateClosenessCentrality()` Returns a double array `result` where `result[i]` is the closeness centrality of the node `i`. If a node is isolated, its centrality should be `0`. Handling large networks efficiently is crucial. Consider using appropriate graph algorithms to compute shortest paths.","solution":"import collections import sys class Centrality: def __init__(self, graph): Initializes the Centrality object with the adjacency list graph self.graph = graph self.n = len(graph) def bfs_shortest_path(self, start_node): Performs BFS from the start_node to calculate shortest paths to all other nodes Returns a list of shortest path distances distances = [sys.maxsize] * self.n distances[start_node] = 0 queue = collections.deque([start_node]) while queue: curr_node = queue.popleft() for neighbor in self.graph[curr_node]: if distances[neighbor] == sys.maxsize: distances[neighbor] = distances[curr_node] + 1 queue.append(neighbor) return distances def calculateClosenessCentrality(self): Returns a double array result where result[i] is the closeness centrality of the node `i` centrality = [0.0] * self.n for i in range(self.n): distances = self.bfs_shortest_path(i) sum_distances = sum(d for d in distances if d != sys.maxsize) reachable_nodes = sum(1 for d in distances if d != sys.maxsize) if reachable_nodes > 1: # if there\'s at least one reachable node other than itself centrality[i] = (reachable_nodes - 1) / sum_distances return centrality"},{"question":"You are given an array of integers `arr` and an integer `target_value`. Your task is to determine if there exists a subset of the given array whose sum is equal to `target_value`. Return `true` if such a subset exists, otherwise return `false`. Note that an empty subset with sum `0` is considered valid only if `target_value` is `0`.","solution":"def subset_sum(arr, target_value): Determines if there is a subset of arr that sums up to target_value. n = len(arr) dp = [[False for _ in range(target_value + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target_value + 1): if j < arr[i - 1]: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] return dp[n][target_value]"},{"question":"You are given a list of `n` words and a string `pattern`, where each word in the list consists of lowercase English letters. If the pattern matches the word, return `true`; otherwise, return `false`. A word matches the pattern if there exists a permutation of letters `p` such that after substituting each letter x in the pattern with `p(x)`, we obtain the word. All occurrences of a letter must be mapped to the same letter, and no two letters may map to the same letter. For example, given the words `[\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"]` and the pattern `\\"abb\\"`, the output should be `[\\"mee\\",\\"aqq\\"]` because they match the pattern.","solution":"def find_and_replace_pattern(words, pattern): def is_match(word, pattern): if len(word) != len(pattern): return False char_to_pattern = {} pattern_to_char = {} for w_char, p_char in zip(word, pattern): if w_char not in char_to_pattern: char_to_pattern[w_char] = p_char if p_char not in pattern_to_char: pattern_to_char[p_char] = w_char if (char_to_pattern[w_char], pattern_to_char[p_char]) != (p_char, w_char): return False return True return [word for word in words if is_match(word, pattern)]"},{"question":"You are given a string `s` consisting of lowercase English letters. You have to determine the frequency of each character in the string and then sort the characters by their frequencies in non-increasing order. If two characters have the same frequency, they should be sorted in alphabetical order. Return the sorted string based on these criteria. For example, given the string `s = \\"tree\\"`, the frequencies of the characters are `t: 1`, `r: 1`, `e: 2`. Therefore, the sorted string based on the frequencies in non-increasing order will be `\\"eert\\"`. If the characters with the same frequency are present, they should be ordered alphabetically.","solution":"from collections import Counter def frequency_sort(s): Sorts the characters in the string based on their frequency in non-increasing order. If frequencies of characters are the same, they are sorted alphabetically. :param s: input string :return: sorted string based on character frequencies freq = Counter(s) sorted_chars = sorted(freq.items(), key=lambda x: (-x[1], x[0])) return \'\'.join([char * count for char, count in sorted_chars])"},{"question":"You are given a string `s` representing a list of words separated by spaces and a dictionary `dict` where each key is a word, and the value is a Boolean indicating if the word is valid (True) or invalid (False). Your task is to return a rearranged version of `s` where all valid words appear before any invalid words while maintaining the original relative order of both valid and invalid words from the string `s`. For example: Given `s = \\"apple banana orange pear kiwi grape\\"` and `dict = {\\"apple\\": True, \\"banana\\": False, \\"orange\\": True, \\"pear\\": True, \\"kiwi\\": False, \\"grape\\": True}`, Return `\\"apple orange pear grape banana kiwi\\"`. You are to implement a function `rearrange_string(s: str, dict: Dict[str, bool]) -> str` that achieves this.","solution":"def rearrange_string(s, dict): Rearranges the words in the string s such that all valid words appear before any invalid words while maintaining the original relative order of both valid and invalid words. Args: s (str): The input string containing words separated by spaces. dict (dict): Dictionary where keys are words and values are Booleans indicating if the word is valid. Returns: str: The rearranged string. words = s.split() valid_words = [word for word in words if dict.get(word, False)] invalid_words = [word for word in words if not dict.get(word, False)] return \' \'.join(valid_words + invalid_words)"},{"question":"You are given a data structure for a limited-size queue that can be appended to but only dequeues elements when a provided condition is met. Implement the `ConditionalQueue` class with the following methods: * `ConditionalQueue(int limit)` Initializes the queue with a size limit of `limit`. If an element is added when the queue is at its size limit, the oldest element should be automatically dequeued. * `void append(int element)` Adds an `element` to the queue. If the queue exceeds its size limit, the oldest element is removed. * `List<Integer> dequeueIf(Predicate<Integer> condition)` Removes and returns all the elements from the queue that satisfy the given `condition`. For the `dequeueIf` method, a **predicate** function is applied to each element of the queue, and only the elements for which the condition returns `true` are dequeued and returned in a list.","solution":"from collections import deque from typing import List, Callable class ConditionalQueue: def __init__(self, limit: int): self.limit = limit self.queue = deque() def append(self, element: int): if len(self.queue) >= self.limit: self.queue.popleft() # Remove the oldest element self.queue.append(element) def dequeueIf(self, condition: Callable[[int], bool]) -> List[int]: removed_elements = [] remaining_elements = deque() while self.queue: element = self.queue.popleft() if condition(element): removed_elements.append(element) else: remaining_elements.append(element) self.queue = remaining_elements return removed_elements"},{"question":"You are given an integer array `nums`. Find all the **unique quadruplets** `[a, b, c, d]` in the array which gives the sum of zero. Note that the solution set must not contain duplicate quadruplets. You may return the solution in **any order**.","solution":"def four_sum(nums): Returns a list of unique quadruplets that sum up to zero. nums.sort() results = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left = j + 1 right = length - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == 0: results.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return results"},{"question":"You are given an integer array `nums` of length `n`. You have to determine if it is possible to make `nums` a strictly increasing sequence by removing at most one element. A sequence is \\"strictly increasing\\" if `nums[i] < nums[i+1]` for every `0 <= i < n-1`. If it is possible, return `true`; otherwise, return `false`.","solution":"def can_be_increasing(nums): Returns True if it\'s possible to make the array strictly increasing by removing at most one element, otherwise returns False. n = len(nums) def is_strictly_increasing(arr): for i in range(len(arr) - 1): if arr[i] >= arr[i+1]: return False return True for i in range(n): if i == 0: if is_strictly_increasing(nums[1:]): return True elif i == n - 1: if is_strictly_increasing(nums[:-1]): return True else: if is_strictly_increasing(nums[:i] + nums[i+1:]): return True return False"},{"question":"Given an integer array `heights` representing the height of buildings along a street, and each element represents the height of a building. A building `i` can block the view of another building `j` (j > i) if the height of building `i` is greater than or equal to the height of building `j`. Return _an array containing the **indices** of the buildings that have an unobstructed view to the right_ (i.e., no building to the right has a greater or equal height). The returned indices should be sorted in **ascending** order.","solution":"def unobstructed_buildings(heights): Returns an array of indices of buildings that have an unobstructed view to the right. n = len(heights) if n == 0: return [] result = [] max_height = float(\'-inf\') for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"You are given an array of integers `data` representing binary data. You can change at most `k` `0`s to `1`s in the array. Return the maximum number of consecutive `1`s you can get in the array after making the allowed changes.","solution":"def max_consecutive_ones(data, k): Returns the maximum number of consecutive 1s that can be achieved by flipping at most k 0s to 1s. left = 0 max_ones = 0 zeros_count = 0 for right in range(len(data)): # If we encounter a 0, increment the zero count if data[right] == 0: zeros_count += 1 # While we have more than k zeros in the current window, move the left pointer to the right while zeros_count > k: if data[left] == 0: zeros_count -= 1 left += 1 # Update the maximum length of the window with at most k zeros max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":": A string is called **anti-palindromic** if it does not contain any palindrome of length greater than 1 as a contiguous substring. Given an integer `n`, return the lexicographically smallest anti-palindromic string of length `n` consisting only of lowercase English letters.","solution":"def smallest_antipalindromic_string(n): Returns the lexicographically smallest anti-palindromic string of length n consisting only of lowercase English letters. if n == 1: return \'a\' res = [] letters = [\'a\', \'b\'] for i in range(n): res.append(letters[i % 2]) return \'\'.join(res)"},{"question":"Imagine you are designing a simple text editor. You need to implement a function `processEditorActions(actions)` where `actions` is an array of strings representing a sequence of operations to be performed in the editor. The possible operations are: - `\\"INSERT x\\"`: Add the character `x` to the end of the string. - `\\"BACKSPACE\\"`: Remove the last character of the string if the string is not empty. - `\\"UNDO\\"`: Revert the last operation (either `INSERT` or `BACKSPACE`). If there is no operation to undo, the string remains unchanged. The function should return the final state of the string after processing all the given actions. If there are multiple `UNDO` operations in a row, the operations should be undone sequentially in reverse order of their execution. For example, if `actions = [\\"INSERT a\\", \\"INSERT b\\", \\"BACKSPACE\\", \\"UNDO\\", \\"UNDO\\"]`, the final state of the string should be `\\"a\\"`.","solution":"def processEditorActions(actions): Processes a sequence of editor actions and returns the final state of the string. Parameters: actions (list): A list of strings representing the actions to be performed. Returns: str: The final state of the string after all actions are performed. result = [] history = [] for action in actions: if action.startswith(\\"INSERT\\"): char = action.split()[1] result.append(char) history.append(action) elif action == \\"BACKSPACE\\": if result: # Only backspace if there are characters in the result removed_char = result.pop() history.append(f\\"REMOVE {removed_char}\\") elif action == \\"UNDO\\": if history: last_action = history.pop() if last_action.startswith(\\"INSERT\\"): result.pop() elif last_action.startswith(\\"REMOVE\\"): char = last_action.split()[1] result.append(char) return \'\'.join(result)"},{"question":"Given two strings `s` and `target`, each consisting of lowercase English letters, check if it is possible to convert string `s` into string `target` by rearranging its characters. You are allowed to change the order of characters in `s` in any manner but cannot add or remove characters. Return `true` if it is possible to create string `target` by rearranging the characters of string `s`. Otherwise, return `false`.","solution":"def can_rearrange_to_target(s, target): Returns True if it is possible to create string \'target\' by rearranging the characters of string \'s\'. from collections import Counter return Counter(s) == Counter(target)"},{"question":"You are given an `n x n` grid where each cell contains a positive integer representing the cost to enter that cell. You can only move **right** or **down** from a cell. Calculate the minimum cost required to move from the top-left corner to the bottom-right corner of the grid. The function should take the following input: - `grid`: A list of lists of integers representing the cost grid. The function should return an integer representing the minimum path cost.","solution":"def min_path_cost(grid): if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) for i in range(1, n): grid[i][0] += grid[i-1][0] for j in range(1, m): grid[0][j] += grid[0][j-1] for i in range(1, n): for j in range(1, m): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1]"},{"question":"Given an array of integers `heights` representing the heights of students in a line, returning an array of indices of the students, in ascending order of their height, such that it follows the rule of standing in a queue where each student can only see the person immediately in front of them. If two students have the same height, they should appear in the order they are in the original array.","solution":"def order_students_by_height(heights): Returns the array of indices of the students, ordered by their height in ascending order. If two students have the same height, they appear in the order they are in the original array. # Create a list of tuples where each tuple is (index, height) indexed_heights = list(enumerate(heights)) # Sort the list of tuples by height and then by index indexed_heights.sort(key=lambda x: (x[1], x[0])) # Extract the sorted indices from the sorted list of tuples sorted_indices = [index for index, height in indexed_heights] return sorted_indices"},{"question":"You are given a binary tree where each node has an integer value. A *uni-value path* is a path that consists of nodes with the same value. The path may or may not pass through the root. The length of a path is the number of edges in that path. Write a function that returns the length of the longest uni-value path in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_univalue_path(root): Returns the length of the longest path where all nodes have the same value. def dfs(node): nonlocal longest_path if not node: return 0 left_len = dfs(node.left) right_len = dfs(node.right) left_path = right_path = 0 if node.left and node.left.val == node.val: left_path = left_len + 1 if node.right and node.right.val == node.val: right_path = right_len + 1 longest_path = max(longest_path, left_path + right_path) return max(left_path, right_path) longest_path = 0 dfs(root) return longest_path"},{"question":"You are given a string `s` that consists of only digits. We want to find the maximum sum of its substrings such that no two substrings overlap and each substring is a palindrome. Return the maximum sum you can achieve. A substring `s[i:j]` is a palindrome if it reads the same backward as forward.","solution":"def is_palindrome(s): return s == s[::-1] def max_sum_of_palindromic_substrings(s): n = len(s) dp = [0] * (n + 1) for i in range(1, n + 1): for j in range(i): if is_palindrome(s[j:i]): dp[i] = max(dp[i], dp[j] + int(s[j:i])) return dp[n]"},{"question":"Given a 2D grid of integers `grid` and an integer `threshold`, determine if it is possible to reach the bottom-right corner of the grid starting from the top-left corner under the constraint that the absolute difference between two consecutive cells in your path can be at most `threshold`. You can only move right or down from the current cell. Return _`true` if such a path exists, otherwise return `false`_.","solution":"def isPathPossible(grid, threshold): Determines if it is possible to reach the bottom-right corner of the grid from the top-left corner under the constraint that the absolute difference between two consecutive cells in the path is at most `threshold`. Movement is allowed only right or down from the current cell. :param grid: List of List of integers representing the grid :param threshold: Integer indicating the maximum allowed absolute difference between two consecutive cells :return: Boolean value indicating if such a path exists if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) dp = [[False]*cols for _ in range(rows)] dp[0][0] = True for r in range(rows): for c in range(cols): if not dp[r][c]: continue if r+1 < rows and abs(grid[r][c] - grid[r+1][c]) <= threshold: dp[r+1][c] = True if c+1 < cols and abs(grid[r][c] - grid[r][c+1]) <= threshold: dp[r][c+1] = True return dp[rows-1][cols-1]"},{"question":"Given an array of positive integers representing the durations of different tasks, and a positive integer `sessionTime`, partition the tasks into the minimum number of sessions such that the sum of task durations in each session is less than or equal to `sessionTime`. Each task must be assigned to exactly one session, and tasks cannot be split across sessions. Return the minimum number of sessions needed.","solution":"def min_sessions(tasks, sessionTime): Returns the minimum number of sessions needed to complete all tasks given that the sum of task durations in each session should not exceed sessionTime. n = len(tasks) dp = [float(\'inf\')] * (1 << n) dp[0] = 1 # Calculate the sum of the tasks for each subset subset_sum = [0] * (1 << n) for mask in range(1 << n): total = 0 for i in range(n): if mask & (1 << i): total += tasks[i] subset_sum[mask] = total # Dynamic programming to find the minimum number of sessions for mask in range(1 << n): if subset_sum[mask] <= sessionTime: dp[mask] = 1 else: submask = mask while submask: if subset_sum[submask] <= sessionTime: dp[mask] = min(dp[mask], dp[mask ^ submask] + 1) submask = (submask - 1) & mask return dp[(1 << n) - 1]"},{"question":"You are given an integer array `arr`. A pair `(i, j)` is _good_ if `arr[i] == arr[j]` and `i < j`. Return _the number of_ good pairs _in the array_.","solution":"def numIdenticalPairs(arr): Returns the number of good pairs in the array where arr[i] == arr[j] and i < j. count = 0 freq = {} for num in arr: if num in freq: count += freq[num] freq[num] += 1 else: freq[num] = 1 return count"},{"question":"Given a binary tree, imagine you put a light on all the leaves and extend the wires towards the root such that they meet at one common point. The wire length from one node to its parent is considered to be `1` unit. Write a function to return the sum of the shortest wire lengths required to light up all the leaves. The input is the root node of the binary tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_of_wire_lengths(root): Given a binary tree, return the sum of the shortest wire lengths required to light up all the leaves. def dfs(node, depth): if not node: return 0 if not node.left and not node.right: return depth return dfs(node.left, depth + 1) + dfs(node.right, depth + 1) return dfs(root, 0)"},{"question":"You are given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water. A **land** cell is a part of an island if it is adjacent to another land cell (horizontally or vertically). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Given this grid, write a function to return the length of the shortest bridge needed to connect any two islands. A bridge can only be built vertically or horizontally and can only connect points in the ocean (`0`s). The length of a bridge is the number of `0`s in the path connecting two land cells from different islands.","solution":"from collections import deque def shortestBridge(grid): def in_bounds(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def dfs(x, y, q): grid[x][y] = 2 q.append((x, y, 0)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and grid[nx][ny] == 1: dfs(nx, ny, q) found = False q = deque() # Step 1: Find one island and mark it for i in range(len(grid)): if found: break for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j, q) found = True break # Step 2: Use BFS to find the shortest path to the second island while q: x, y, dist = q.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if in_bounds(nx, ny): if grid[nx][ny] == 1: return dist if grid[nx][ny] == 0: grid[nx][ny] = 2 q.append((nx, ny, dist + 1)) return -1 # Example usage (debugging purposes) print(shortestBridge([[0,1],[1,0]])) print(shortestBridge([[0,1,0],[0,0,0],[0,0,1]])) print(shortestBridge([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]))"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `m`. An array is considered `beautiful` if the sum of absolute differences between every pair of adjacent elements in the array is **at most** `m`. Your task is to determine the minimum number of operations required to make the array `beautiful`. In one operation, you can increment or decrement any element of the array by `1`. Return _the **minimum number of operations** required to make `nums` a `beautiful` array_.","solution":"def min_operations(nums, m): Returns the minimum number of operations required to make the array \'beautiful\'. n = len(nums) operations = 0 for i in range(1, n): if abs(nums[i] - nums[i - 1]) > m: operations += abs(nums[i] - nums[i - 1]) - m return operations"},{"question":"Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses. A string is considered valid if each opening parenthesis \\"(\\" has a corresponding closing parenthesis \\")\\" and they are properly nested. Return the result as a list of strings representing all possible combinations in lexicographic order. Note: You should use backtracking to construct the solution.","solution":"def generateParenthesis(n): Generate all combinations of well-formed parentheses for n pairs of parentheses. Args: n (int): Number of pairs of parentheses. Returns: List[str]: A list of all combinations of well-formed parentheses. result = [] def backtrack(current, open_count, close_count): if len(current) == 2 * n: result.append(current) return if open_count < n: backtrack(current + \'(\', open_count + 1, close_count) if close_count < open_count: backtrack(current + \')\', open_count, close_count + 1) backtrack(\'\', 0, 0) return result"},{"question":"You are given a list of integers `arr` and an integer `k`. A subarray is defined by a starting and ending index, and includes all the elements in between. Write a function to find the maximum sum of any subarray of length `k`. If the array has fewer than `k` elements, return `0`. Your function should run in O(n) time where `n` is the length of the array.","solution":"def max_sum_subarray_of_length_k(arr, k): if len(arr) < k: return 0 # Compute the sum of the first \'k\' elements max_sum = curr_sum = sum(arr[:k]) # Use sliding window technique for i in range(k, len(arr)): curr_sum += arr[i] - arr[i - k] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"You are given two strings, `s1` and `s2`, which represent two words. You need to check if `s2` is a scrambled string of `s1`. A scrambled string is a string that can be formed by recursively partitioning the original string into two non-empty substrings and swapping them. Given two strings `s1` and `s2`, write a function to determine if `s2` is a scrambled string of `s1`. Return `true` if `s2` is a scrambled string of `s1`, otherwise return `false`.","solution":"def is_scramble(s1, s2): Returns true if s2 is a scrambled string of s1, otherwise returns false. # Base cases if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): # Check if there is a valid split that makes s2 a scrambled string of s1 if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"Given a directed acyclic graph (DAG) represented by `n` nodes labeled from `0` to `n-1` and an array of `edges` where `edges[i] = [u, v]` indicates a directed edge from `u` to `v`, return the number of different paths from node `0` to node `n-1`.","solution":"def count_paths_dag(n, edges): from collections import defaultdict, deque # Create graph from edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Initialize the dp table. dp[i] means the number of ways to reach node i from node 0. dp = [0] * n dp[0] = 1 # There\'s one way to be at the starting location # Perform topological sort using Kahn\'s algorithm in_degree = [0] * n for u in graph: for v in graph[u]: in_degree[v] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) top_order = [] while queue: node = queue.popleft() top_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Calculate the number of ways to reach each node using topological order for node in top_order: for neighbor in graph[node]: dp[neighbor] += dp[node] return dp[n-1]"},{"question":"Design an elevator system for a building with `n` floors. Each elevator can stop at any floor between 1 and `n`. Requests for elevator stops are represented as a list of tuples, where each tuple contains two integers - the current floor where the request is made and the target floor. Implement the `ElevatorSystem` class: * `ElevatorSystem(int n, int m)`: Initializes the elevator system with `n` floors and `m` elevators. * `void request(int currentFloor, int targetFloor)`: Registers a request to move from `currentFloor` to `targetFloor`. * `List<List<Integer>> getElevatorStops()`: Returns a list of lists, where each inner list contains the floors at which each elevator will stop, in the order they will be visited. Your implementation should efficiently manage the requests such that the elevators complete all registered stops in a reasonable manner.","solution":"class ElevatorSystem: def __init__(self, n, m): Initializes the elevator system with `n` floors and `m` elevators. :param n: Number of floors in the building. :param m: Number of elevators. self.n = n self.m = m self.elevator_stops = [[] for _ in range(m)] self.requests = [] def request(self, currentFloor, targetFloor): Registers a request to move from `currentFloor` to `targetFloor`. :param currentFloor: The floor where the request is made. :param targetFloor: The target floor to which the user wants to go. self.requests.append((currentFloor, targetFloor)) def get_elevator_stops(self): Returns a list of lists, where each inner list contains the floors at which each elevator will stop, in the order they will be visited. :return: List of lists of integers. for i, request in enumerate(self.requests): currentFloor, targetFloor = request self.elevator_stops[i % self.m].append(currentFloor) self.elevator_stops[i % self.m].append(targetFloor) return self.elevator_stops"},{"question":"Given a list of integers `nums`, return _a list of all the integers that appear more than once in `nums`_, preserving their first occurrence order. If no such integers exist, return an empty list.","solution":"def find_duplicates(nums): Returns a list of all integers that appear more than once in nums, preserving their first occurrence order. seen = set() duplicates = set() result = [] for num in nums: if num in seen: # It\'s a duplicate duplicates.add(num) else: seen.add(num) # We list duplicates in the order they first appeared in the input list for num in nums: if num in duplicates and num not in result: result.append(num) return result"},{"question":"A bakery wants to create the perfect assortment of pastries based on customers\' preferences. Each pastry has a specific **cost** and a **popularity** value. The bakery has a limited budget and aims to maximize the total popularity of the selected pastries without exceeding the budget. Given two lists, `costs` and `popularities`, where `costs[i]` and `popularities[i]` represent the cost and popularity of the `i-th` pastry respectively, and an integer `budget` representing the maximum total cost allowed, return _the maximum total popularity that can be achieved within the given budget._","solution":"def max_popularity(costs, popularities, budget): Returns the maximum total popularity that can be achieved within the given budget. Parameters: costs (List[int]): A list of integers where costs[i] is the cost of the i-th pastry. popularities (List[int]): A list of integers where popularities[i] is the popularity of the i-th pastry. budget (int): The maximum total cost allowed. Returns: int: The maximum total popularity. n = len(costs) dp = [0] * (budget + 1) for i in range(n): for j in range(budget, costs[i] - 1, -1): dp[j] = max(dp[j], dp[j - costs[i]] + popularities[i]) return dp[budget]"},{"question":"You are given an array of integers `eventOrder` where `eventOrder[i]` represents the ID of the `i`th event a user has participated in, and an integer `k` which represents the maximum number of distinct event IDs allowed in a valid contiguous subarray. The objective is to find the length of the longest contiguous subarray that contains no more than `k` distinct event IDs. Implement the function `int longestValidSubarray(int[] eventOrder, int k)` that returns the length of such a longest subarray. Note: The integer array `eventOrder` can have up to 10^5 elements, and you can assume `k` is a positive integer less than or equal to the length of `eventOrder`.","solution":"def longestValidSubarray(eventOrder, k): from collections import defaultdict n = len(eventOrder) if n == 0 or k == 0: return 0 left = 0 max_length = 0 event_count = defaultdict(int) for right in range(n): event_count[eventOrder[right]] += 1 while len(event_count) > k: event_count[eventOrder[left]] -= 1 if event_count[eventOrder[left]] == 0: del event_count[eventOrder[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of integers `arr` sorted in non-decreasing order, and an integer `k`. Your task is to find the `k`-th smallest element in the array, but you have to ignore any duplicate values in the array. If there are fewer than `k` distinct elements, return `-1`.","solution":"def kth_smallest_distinct(arr, k): Finds the k-th smallest distinct element in a sorted array. If there are fewer than k distinct elements, returns -1. distinct_elements = [] prev_element = None for element in arr: if element != prev_element: distinct_elements.append(element) prev_element = element if len(distinct_elements) < k: return -1 else: return distinct_elements[k - 1]"},{"question":"You are given a list of events represented as a 2D integer array `events`, where each `events[i] = [starti, endi]` denotes the start and end times of an event. You need to decide how many events you can attend if you don\'t attend events that overlap with each other. An event `[starta, enda]` is said to overlap with event `[startb, endb]` if `starta < endb && startb < enda`. Return _the maximum number of non-overlapping events you can attend_.","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events that can be attended. :param events: List[List[int]] - List of events with start and end times :return: int - Maximum number of non-overlapping events # Sort events by their ending times events.sort(key=lambda x: x[1]) max_events = 0 last_end_time = float(\'-inf\') for start, end in events: if start >= last_end_time: max_events += 1 last_end_time = end return max_events"},{"question":"Given a list of `words` and an array `sentences` consisting of multiple sentences, return the _word_ that appears the most frequently across all the sentences within the list. If there is a tie, return the word that comes first lexicographically (alphabetically). Note that the comparison should be **case-insensitive** and the result should be returned in **lowercase**.","solution":"def most_frequent_word(words, sentences): from collections import Counter import re word_count = Counter() word_set = set(word.lower() for word in words) for sentence in sentences: sentence_words = re.findall(r\'bw+b\', sentence.lower()) for word in sentence_words: if word in word_set: word_count[word] += 1 if not word_count: return None most_common_word = min(word_count.items(), key=lambda x: (-x[1], x[0]))[0] return most_common_word"},{"question":"Given a string `s`, return _a new string formed by rearranging the characters of_ `s` _such that all the digits (0-9) appear before the letters (a-z) in their original relative order within their respective groups_. For example, if the input string is `\\"a1b2c3\\"`, the output should be `\\"123abc\\"`.","solution":"def rearrange_string(s): Rearranges the characters of the input string `s` such that all the digits (0-9) appear before the letters (a-z) in their original relative order within their respective groups. :param s: input string :return: rearranged string with digits before letters digits = [] letters = [] for char in s: if char.isdigit(): digits.append(char) elif char.isalpha(): letters.append(char) return \'\'.join(digits) + \'\'.join(letters)"},{"question":"You are given a matrix `grid` of n x n integers representing a city landscape where each cell contains an elevation. You are also given an integer `floodHeight`. You need to determine the number of distinct plots that would be completely submerged if the water level increases to `floodHeight`. A plot is defined as a contiguous region of cells with equal or lower elevation to `floodHeight` and is completely surrounded by cells with higher elevation or the grid boundary. Return the count of such distinct plots.","solution":"def count_submerged_plots(grid, floodHeight): Counts the number of distinct plots completely submerged if the water level increases to floodHeight. :param grid: A list of list of integers representing the elevation. :param floodHeight: An integer representing the flood height level :returns: An integer count of distinct submerged plots. n = len(grid) visited = [[False] * n for _ in range(n)] def dfs(x, y): Depth first search to explore a plot. if not (0 <= x < n and 0 <= y < n) or visited[x][y] or grid[x][y] > floodHeight: return visited[x][y] = True dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) count = 0 for i in range(n): for j in range(n): if grid[i][j] <= floodHeight and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"You are given a **binary tree** with `n` nodes, each node having a positive integer value. The nodes of the binary tree are uniquely labeled from `1` to `n`, and the value of the node labeled `i` is represented by `values[i-1]`. A **path** in the tree is any sequence of nodes starting from any node and ending at any node, traversing only through the tree\'s edges. The **path sum** is the sum of the values of the nodes in that path. Return _the sum of all values of the **longest path** in the binary tree_. If there are multiple longest paths, return the maximum sum among them.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_path_sum(root): Returns the sum of values of the longest path in the binary tree. If there are multiple longest paths, returns the maximum sum among them. def dfs(node): if not node: return (0, 0) # (max depth, max sum at max depth) left_depth, left_sum = dfs(node.left) right_depth, right_sum = dfs(node.right) if left_depth > right_depth: return (left_depth + 1, left_sum + node.value) elif right_depth > left_depth: return (right_depth + 1, right_sum + node.value) else: return (left_depth + 1, max(left_sum, right_sum) + node.value) _, max_path_sum = dfs(root) return max_path_sum"},{"question":"You are given an integer array `ratings` where `ratings[i]` represents the movie rating given by the `ith` user. The fair rating score for a movie is calculated by removing the lowest `m` ratings and the highest `m` ratings, and then taking the average of the remaining ratings. Given the integer `m`, implement a function to calculate and return the fair rating score for the movie. If there are fewer than `2 * m` ratings, return `-1`. ```python def fairRatingScore(ratings: List[int], m: int) -> float: # Implementation here ```","solution":"from typing import List def fairRatingScore(ratings: List[int], m: int) -> float: Calculates the fair rating score for a movie by removing the lowest `m` ratings and the highest `m` ratings and then averaging the remaining ratings. If there are fewer than `2 * m` ratings, returns -1. if len(ratings) < 2 * m: return -1 # Sort the ratings to easily remove the lowest and highest `m` ratings sorted_ratings = sorted(ratings) # Remove the lowest `m` and the highest `m` ratings trimmed_ratings = sorted_ratings[m:-m] # Calculate the average of the remaining ratings if len(trimmed_ratings) == 0: return -1 return sum(trimmed_ratings) / len(trimmed_ratings)"},{"question":"You are given a list of non-negative integers `nums` representing the number of candles on a birthday cake. Each integer corresponds to the height of a candle. The birthday person can only blow out the tallest candles. Return _the number of candles that will be blown out._","solution":"def birthday_candles(nums): Finds out the number of tallest candles that can be blown out. Parameters: nums (list): A list of non-negative integers representing candle heights. Returns: int: Number of tallest candles. if not nums: return 0 max_height = max(nums) return nums.count(max_height)"},{"question":"There are n students in a line, and each student has a grade represented by an integer array `grades`, where `grades[i]` is the grade of the `ith` student in the line. Each student is holding a balloon. You are asked to distribute candies to these students according to the following rules: 1. Each student must have at least one candy. 2. Students with a higher grade than their neighbors must get more candies than their neighbors. Write a function `int distributeCandies(int[] grades)` to determine the minimum number of candies you need to distribute to satisfy the above conditions. Calculate the minimum number of candies needed and return this value.","solution":"def distributeCandies(grades): n = len(grades) if n == 0: return 0 candies = [1] * n # Traverse from left to right for i in range(1, n): if grades[i] > grades[i - 1]: candies[i] = candies[i - 1] + 1 # Traverse from right to left for i in range(n - 2, -1, -1): if grades[i] > grades[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) return sum(candies)"},{"question":"You are given an integer array `heights` representing the height of stones arranged in a row. You can make a jump from one stone to another if the next stone is of the same height or any height less than or equal to the maximum height you\'ve jumped before. Return _the **minimum** number of jumps required to reach the last stone from the first stone_. If it is not possible to reach the last stone, return `-1`. The stones must be visited in a strictly increasing index order.","solution":"def min_jumps(heights): n = len(heights) if n <= 1: return 0 max_reach = heights[0] jumps = 1 steps = heights[0] for i in range(1, n): if i == n-1: return jumps max_reach = max(max_reach, i + heights[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"You are given a string `s` consisting of multiple words separated by spaces. Define a word as the largest sequence of non-space characters. Reverse the order of words in the string while preserving the original whitespace. Specifically, you need to maintain all leading or trailing spaces, reduce multiple spaces between words to a single space after reversing, and ensure words are separated by a single space in the reversed output. Return the resulting string after reversing the word order.","solution":"def reverse_words(s): Given a string s consisting of multiple words separated by spaces, reverses the order of words in the string while preserving the original whitespace, reducing multiple spaces between words to a single space, and ensuring words are separated by a single space in the reversed output. Args: s (str): Input string. Returns: str: The resulting string after reversing the word order. words = s.split() reversed_words = words[::-1] result = \' \'.join(reversed_words) return result"},{"question":"You are given a string `s` which consists of lowercase English letters. A **good substring** is a substring that contains unique characters only. Find the length of the longest **good substring** in `s`. Return the length of this substring. The solution should have a time complexity of O(n).","solution":"def length_of_longest_good_substring(s): Returns the length of the longest substring of `s` that contains unique characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a list of integers `arr` representing the number of movies each user has watched out of a collection of movies. Two users are considered to be _cinephiles_ if the number of movies both of them watched is equal. Return the number of unique pairs of users who are cinephiles. Each pair should be counted only once, regardless of the order of the users in the pair.","solution":"from collections import defaultdict def count_cinephile_pairs(arr): Returns the number of unique pairs of users who are cinephiles. movie_count = defaultdict(int) # Count occurrences of each number of movies watched for count in arr: movie_count[count] += 1 total_pairs = 0 # Calculate the number of pairs for each movie count for count in movie_count.values(): if count > 1: total_pairs += count * (count - 1) // 2 return total_pairs"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to determine if there exists a combination of elements in the array (order matters) that sums up to `target`. However, you are allowed to use each element in the array multiple times. Return _true_ if such a combination exists, otherwise return _false_. Note that you can assume all elements in the array are positive integers.","solution":"def combination_sum(arr, target): Determine if there exists a combination of elements in arr that sums up to the target. Each element can be used multiple times. if target == 0: return True if target < 0: return False for num in arr: if combination_sum(arr, target - num): return True return False"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings on a street. A building `heights[i]` has a **clear view** if for every building `heights[j]` to its right (`j > i`), `heights[i] > heights[j]` (i.e., there is no building taller than or equal to it blocking its view). Return _the list of indices of the buildings that have a clear view, sorted in ascending order_.","solution":"def find_buildings(heights): Returns the list of indices of the buildings that have a clear view. n = len(heights) result = [] max_height_seen_so_far = -1 for i in range(n - 1, -1, -1): if heights[i] > max_height_seen_so_far: result.append(i) max_height_seen_so_far = heights[i] return result[::-1]"},{"question":"You are given a **0-indexed** integer array `arr` and a positive integer `x`. Your task is to split the array into **two non-empty subarrays** such that the sum of elements in the first subarray is less than or equal to the sum of elements in the second subarray, and the length of the first subarray is **exactly** `x`. Return _the maximum possible sum of the elements in the second subarray after the split_. If it is not possible to split the array satisfying these conditions, return `-1`.","solution":"def max_second_subarray_sum(arr, x): Function to split the array into two non-empty subarrays such that the sum of elements in the first subarray is less than or equal to the sum of elements in the second subarray, and the length of the first subarray is exactly x. Returns the maximum possible sum of the elements in the second subarray after the split. n = len(arr) # Early exit if it\'s not possible to split with the given condition if x >= n or x <= 0: return -1 # Calculate the prefix sums up to the length x first_sum = sum(arr[:x]) second_sum = sum(arr[x:]) if first_sum > second_sum: return -1 max_second_sum = second_sum for i in range(x, n-1): first_sum += arr[i] second_sum -= arr[i] if first_sum > second_sum: break max_second_sum = max(max_second_sum, second_sum) return max_second_sum"},{"question":"You are given a list of `n` integers `nums` and a target integer `k`. Your task is to determine if there is a contiguous subarray within `nums` that sums up to `k`. Return _true_ if such a subarray exists, and _false_ otherwise. A contiguous subarray means elements that are sequentially connected in the input array.","solution":"def check_subarray_sum(nums, k): Returns True if there exists a contiguous subarray within nums that sums up to k, otherwise returns False. :param nums: List of integers :param k: Target sum integer :return: Boolean indicating the existence of such a subarray current_sum = 0 sum_dict = {0: -1} # To handle the case when the subarray starts from index 0 for i, num in enumerate(nums): current_sum += num required_sum = current_sum - k if required_sum in sum_dict: return True # Add current sum to dictionary # This will keep track of the index where such sum was first seen if current_sum not in sum_dict: sum_dict[current_sum] = i return False"},{"question":"You are given a list of integers `arr` representing the strengths of `n` students, where `n` is always an even number. You are asked to split this list into `n/2` pairs such that each pair consists of two students. The score of a pair is defined as the product of the strengths of the two students in that pair. Your goal is to maximize the sum of the scores of all pairs. Write a function `maxPairSum(arr: List[int]) -> int` that returns the maximum possible sum of the scores of all pairs.","solution":"from typing import List def maxPairSum(arr: List[int]) -> int: Given a list of integers representing strengths of students, returns the maximum possible sum of the scores of all pairs. arr.sort(reverse=True) n = len(arr) max_sum = 0 for i in range(0, n, 2): max_sum += arr[i] * arr[i + 1] return max_sum"},{"question":"Given a non-empty list of words, return a list containing all the words that can be typed using letters of the alphabet on only one row of a standard QWERTY keyboard. The rows of the QWERTY keyboard are as follows: - Row 1: \\"qwertyuiop\\" - Row 2: \\"asdfghjkl\\" - Row 3: \\"zxcvbnm\\" Each word in the result list should maintain its original case as it appears in the input list. Return the output list in the same order as the input list. # Example **Input:** `words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]` **Output:** `[\\"Alaska\\", \\"Dad\\"]` **Constraints:** - All the words will have length in the range [1, 12]. - Each word consists of only alphabetic characters (both lowercase and uppercase). Ensure that you thoroughly test the validity of your function against different cases, such as words that cannot be formed using a single row on the keyboard.","solution":"def find_words_with_one_row(words): Given a non-empty list of words, return a list containing all the words that can be typed using letters of the alphabet on only one row of a standard QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_be_typed_with_one_row(word): lower_word = word.lower() return (set(lower_word).issubset(row1) or set(lower_word).issubset(row2) or set(lower_word).issubset(row3)) return [word for word in words if can_be_typed_with_one_row(word)]"},{"question":"Given a 2D grid `grid` of size `m x n` which represents a map where `1` represents land and `0` represents water, you are tasked with finding the length of the shortest path from the top-left cell (0, 0) to the bottom-right cell (m-1, n-1). You may move in four possible directions: left, right, up, and down. You cannot move diagonally or through cells containing water. If there is no valid path, return `-1`. The shortest path is defined as the minimum number of cells traversed from the start cell to the destination cell.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left cell (0, 0) to the bottom-right cell (m-1, n-1) in the given 2D grid. Returns -1 if no such path exists. if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 m, n = len(grid), len(grid[0]) directions = [(0,1), (1,0), (0,-1), (-1,0)] queue = deque([(0, 0, 1)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, distance = queue.popleft() if x == m - 1 and y == n - 1: # reached bottom-right cell return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1"},{"question":"You are given a string `s` and an array of strings `patterns`. Each pattern in `patterns` represents a query, and your goal is to find out how many times each pattern appears as a substring in `s`. Return an array `result` of size equal to the length of `patterns`, where `result[i]` is the number of occurrences of the `i-th` pattern in `s`. For example, if `s = \\"abcabcabc\\"` and `patterns = [\\"abc\\", \\"bc\\", \\"a\\", \\"d\\"]`, the result will be `[3, 3, 3, 0]` because: - `\\"abc\\"` appears 3 times in `s` - `\\"bc\\"` appears 3 times in `s` - `\\"a\\"` appears 3 times in `s` - `\\"d\\"` does not appear in `s`","solution":"def count_patterns(s, patterns): Returns the number of times each pattern in patterns appears as a substring in s. result = [] for pattern in patterns: count = 0 start = 0 while True: start = s.find(pattern, start) if start == -1: # No more occurrences found break count += 1 start += 1 # Move past the last found occurrence result.append(count) return result"},{"question":"You are given an array of integers `heights` representing the heights of plants. A gardener wants to water the plants, and he has a watering can that can water a fixed range of height levels in one go. Specifically, the gardener can choose a `range` value, which specifies the maximum height difference he can cover when stretching the garden hose from a specific height `h`. The watering can can therefore cover heights from `h` to `h + range`. Given the array `heights` and an integer `range`, return _the minimum number of watering operations required to water all the plants_.","solution":"def min_watering_operations(heights, range): Returns the minimum number of watering operations required to water all the plants. :param heights: List of integers representing the heights of plants. :param range: Integer, the fixed range of the watering can. :return: Integer, minimum number of watering operations required. if not heights: return 0 heights.sort() operations = 0 i = 0 n = len(heights) while i < n: # Start a new watering operation operations += 1 # Find the maximum height that can be watered in this operation coverage_end = heights[i] + range while i < n and heights[i] <= coverage_end: i += 1 return operations"},{"question":"You are given a `height` integer array representing the height of bars in a histogram. Each bar has unit width. Implement a function to compute the area of the largest rectangle in the histogram. **Example 1:** **Input:** height = [2, 1, 5, 6, 2, 3] **Output:** 10 **Explanation:** The largest rectangle has area 10 (5 + 5). **Example 2:** **Input:** height = [2, 4] **Output:** 4 **Explanation:** The largest rectangle has area 4 (2 + 2). **Constraints:** * 1 <= height.length <= 10^5 * 0 <= height[i] <= 10^4","solution":"def largest_rectangle_area(height): Compute the area of the largest rectangle in a histogram. :param height: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(height): if not stack or height[stack[-1]] <= height[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (height[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (height[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given an array of integers `nums` and an integer `k`, where `k` is guaranteed to be smaller than the size of `nums`, return the `k-th` **largest** element in the array. Note that it is the `k-th` largest **sorted order**, not the `k-th` distinct element. Implement an efficient approach that runs faster than O(n log n), such as using a heap or quickselect algorithm.","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the array nums. # Use a min heap with size k min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"You are given a binary tree where each node contains an integer value. The integer value of each node is unique. Remove the node with the specified value from the tree and return the root of the modified tree. If the node to be removed is not found, return the original tree. Note that the removal of a node may require re-arranging the children nodes to maintain the properties of the binary tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_min(node): while node.left: node = node.left return node def delete_node(root, key): if root is None: return root if key < root.val: root.left = delete_node(root.left, key) elif key > root.val: root.right = delete_node(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = find_min(root.right) root.val = min_larger_node.val root.right = delete_node(root.right, min_larger_node.val) return root"},{"question":"You are given an integer array `arr` and an integer `x`. Your task is to modify the array such that every element becomes a multiple of `x` by adding the minimum non-negative integer (including zero) to each element. Return the modified array. If an element is already a multiple of `x`, it should remain unchanged. Note that `x` is guaranteed to be greater than 0.","solution":"def make_multiples(arr, x): Modifies the array such that every element becomes a multiple of x by adding the minimum non-negative integer (including zero) to each element. Parameters: arr (list of int): The array of integers to be modified. x (int): The integer to which array elements should be multiples of. Returns: list of int: The modified array where each element is a multiple of x. return [num if num % x == 0 else num + (x - num % x) for num in arr]"},{"question":"You are given a list of integers `nums` representing a deck of cards. The deck has cards numbered from `1` to `n` (where `n` is the length of the list). Each integer in `nums` represents the value on a card. You are also given an integer `m` representing the maximum possible value of any card in the deck. Your task is to determine the minimum number of cards that need to be removed from the deck so that the deck contains at most one card of each value from `1` to `m`. If the deck already meets the condition, return `0`. **Note:** The order of removal does not matter.","solution":"def min_removals_to_unique_deck(nums, m): Returns the minimum number of cards that need to be removed from the deck so that the deck contains at most one card of each value from 1 to m. # Create a frequency dictionary to count occurrences of each card value freq = {} for num in nums: if num not in freq: freq[num] = 0 freq[num] += 1 # Calculate the number of removals needed removals = 0 for key, count in freq.items(): if key <= m and count > 1: removals += count - 1 elif key > m: removals += count return removals"},{"question":"You are given an array `bookings` where each entry is a tuple `(startDay, endDay, numRooms)` representing a booking at a hotel. Each booking reserves `numRooms` rooms from `startDay` to `endDay` (both inclusive). The hotel has a fixed number of rooms available each day. Write a function that checks if all bookings can be accommodated given the number of rooms available each day. The function should return `true` if it is possible to accommodate all bookings, and `false` otherwise.","solution":"def can_accommodate_bookings(bookings, total_rooms): Determines if all bookings can be accommodated given the total number of rooms available each day. :param bookings: List[Tuple[int, int, int]] - A list of bookings where each booking is a tuple (startDay, endDay, numRooms) :param total_rooms: int - Total number of rooms available in the hotel each day :return: bool - True if all bookings can be accommodated, False otherwise # Dictionary to track the net change in the number of rooms needed on each day delta = {} # Process each booking for start, end, numRooms in bookings: if start not in delta: delta[start] = 0 if end + 1 not in delta: delta[end + 1] = 0 delta[start] += numRooms delta[end + 1] -= numRooms # Track the number of rooms in use day by day current_rooms_in_use = 0 for day in sorted(delta.keys()): current_rooms_in_use += delta[day] if current_rooms_in_use > total_rooms: return False return True"},{"question":"You are given the head of a singly linked list where each node contains an integer value. Determine if the linked list has a cycle in it. A cycle occurs when a node\'s next pointer points back to a previous node in the list, thus forming a loop. Return `true` if there is a cycle in the linked list, otherwise, return `false`. Implement the function with the following signature: `boolean hasCycle(ListNode head)`. **Note:** - You are not allowed to modify the linked list. - Optimize for both time and space complexity as much as possible.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Detect if a singly linked list has a cycle. :type head: ListNode :rtype: bool slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are given an array of integers `heights` representing the heights of students standing in a line in non-decreasing order. Each student can see forward if there are no taller students in front of them. Determine the minimum number of students that need to be removed so that each remaining student can see at least `k` other students in front of them who are shorter than themselves. Return this minimum number.","solution":"def min_students_to_remove(heights, k): Determines the minimum number of students to be removed so that each remaining student can see at least k other students in front of them who are shorter than themselves. :param heights: List[int] :param k: int :return: int n = len(heights) if k == 0: return 0 if k >= n: return n # Generally, we need to ensure k students are in front, which means checking from the k-th index up to the end for idx in range(n - k): if heights[idx + k] <= heights[idx]: # If such sequence is not possible for the extent of the array return n - k # Else, return 0 since no students need to be removed return 0"},{"question":"You are given a string `s` consisting of only lowercase letters. You can select any two non-overlapping substrings of `s` and swap them. The goal is to make the string a palindrome with the minimum number of such operations. If it is not possible to make `s` a palindrome, return `-1`. Write a function that returns the minimum number of swap operations required to make `s` a palindrome, or `-1` if it\'s impossible.","solution":"def min_swaps_to_palindrome(s): from collections import Counter # Function to return the minimum number of swaps needed to make a palindrome def count_min_swaps(data): n = len(data) if data == data[::-1]: return 0 data = list(data) min_swaps = 0 i, j = 0, n-1 while i < j: if data[i] != data[j]: k = j while k > i and data[k] != data[i]: k -= 1 if k == i: data[i], data[i+1] = data[i+1], data[i] min_swaps += 1 else: for l in range(k, j): data[l], data[l+1] = data[l+1], data[l] min_swaps += 1 i += 1 j -= 1 else: i += 1 j -= 1 return min_swaps # Count characters\' frequencies freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) # If more than one character has an odd frequency, it is impossible if odd_count > 1: return -1 return count_min_swaps(s)"},{"question":"You are given a list of strings, `words`, where each word can be considered a subword of another word if, after deleting some characters (possibly none) of the longer word, you get the shorter word. The goal is to find the longest possible sequence of words such that each successive word is a subword of the next word in the sequence. Return _the length of the longest possible sequence_.","solution":"def is_subword(shorter, longer): it = iter(longer) return all(char in it for char in shorter) def longest_subword_sequence(words): words.sort(key=len) dp = [1] * len(words) for i in range(len(words)): for j in range(i): if is_subword(words[j], words[i]) and dp[j] + 1 > dp[i]: dp[i] = dp[j] + 1 return max(dp)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to perform a series of transformations on the string to minimize its lexicographical order. Specifically, you can select any character in the string and move it to the beginning of the string. However, you are allowed to perform this operation at most `k` times. Return the lexicographically smallest string possible after performing at most `k` operations.","solution":"def min_lexicographical_order(s, k): Returns the lexicographically smallest string possible after performing at most k operations where each operation consists of moving any character in the string to the beginning. :param s: A string consisting of lowercase English letters :param k: An integer specifying the maximum number of operations allowed :return: The lexicographically smallest string achievable within the given constraints if k == 1: # If k is 1, we can only rotate the string fully and find the minimum rotation n = len(s) return min(s[i:] + s[:i] for i in range(n)) else: # If k > 1, we can freely sort the string to get the lexicographically smallest result return \'\'.join(sorted(s))"},{"question":"Given a binary tree, find the smallest subtree with all the deepest nodes. A node is considered deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is its smallest subtree, which includes all the deepest nodes in the entire tree. * A binary tree is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * The function signature is: ```python def subtreeWithAllDeepest(root: TreeNode) -> TreeNode: ``` For example, given the following tree: ``` 3 / 5 1 /| | 6 2 0 8 / 7 4 ``` The function should return the node with value `2`, as this is the root of the smallest subtree containing all the deepest nodes (`7` and `4`). Note: The number of nodes in the tree will be between `1` and `500`, and the value of each node will be unique.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def subtreeWithAllDeepest(root: TreeNode) -> TreeNode: def dfs(node): if not node: return (None, 0) left_result = dfs(node.left) right_result = dfs(node.right) if left_result[1] > right_result[1]: return (left_result[0], left_result[1] + 1) elif left_result[1] < right_result[1]: return (right_result[0], right_result[1] + 1) else: return (node, left_result[1] + 1) result = dfs(root) return result[0]"},{"question":"You are given an array `events` where `events[i] = [startDayi, endDayi, valuei]`, and you can attend at most two non-overlapping events. Select two non-overlapping events such that their combined value is maximized. Each event must be attended for the entire duration from its `startDay` to its `endDay` (inclusive). You may assume that `events` is sorted by `endDay`. Return _the maximum combined value of the two non-overlapping events you can attend_.","solution":"def maxTwoEvents(events): events.sort(key=lambda x: x[1]) # Sort events by endDay def upper_bound(event_list, day): Binary search to find the index of the first event in the event_list whose endDay is greater than the given day low, high = 0, len(event_list) while low < high: mid = (low + high) // 2 if event_list[mid][1] <= day: low = mid + 1 else: high = mid return low max_single_event = 0 max_combined_value = 0 single_event_values = [] # To store maximum value before each event # Traverse each event for i in range(len(events)): # Maximum single event value till the current event\'s startDay idx = upper_bound(events, events[i][0] - 1) max_single_event = single_event_values[idx - 1] if idx > 0 else 0 # Update the maximum combined value considering the current event max_combined_value = max(max_combined_value, max_single_event + events[i][2]) # Update the single event values list if i == 0: single_event_values.append(events[i][2]) else: single_event_values.append(max(single_event_values[-1], events[i][2])) return max_combined_value"},{"question":"Given two strings `s1` and `s2`, determine if `s2` is an anagram of `s1`, ignoring spaces and capitalization. Return `true` if `s2` is an anagram of `s1`, otherwise return `false`. For the purpose of this problem, consider an anagram to be a rearrangement of the letters of `s1` to form `s2`, where case and spaces are not considered.","solution":"def is_anagram(s1, s2): Determines if s2 is an anagram of s1, ignoring spaces and capitalization. Args: s1 (str): First string. s2 (str): Second string. Returns: bool: True if s2 is an anagram of s1, False otherwise. # Remove spaces and convert to lowercase s1_cleaned = s1.replace(\\" \\", \\"\\").lower() s2_cleaned = s2.replace(\\" \\", \\"\\").lower() # Sort the characters and compare return sorted(s1_cleaned) == sorted(s2_cleaned)"},{"question":"Implement a function that takes a positive integer `n` and returns the sum of its digits repeated until a single-digit result is produced. For example, given `n = 38`, the function should return `2`, since 3 + 8 = 11 and 1 + 1 = 2. This process continues until a single-digit result is obtained.","solution":"def digit_root(n): Returns the sum of the digits of a positive integer n, repeated until a single-digit result is produced. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"Given an integer `n`, return all possible combinations of its factors, excluding 1 and `n` itself (if n is not a prime number). Each combination should be represented as a list of integers, and the result should be a list of lists. Factors in each combination should be in non-descending order.","solution":"def get_factors(n): Returns all possible combinations of factors of the given integer `n` excluding 1 and `n` itself. Each combination is represented as a list in non-descending order. def backtrack(start, n, path, res): if n == 1 and len(path) > 1: res.append(path[:]) return for i in range(start, n + 1): if n % i == 0: path.append(i) backtrack(i, n // i, path, res) path.pop() res = [] backtrack(2, n, [], res) return res"},{"question":"Given a list of accounts with each account consisting of a list of emails and a first element representing the account name, merge the accounts such that the same email address in different lists belongs to the same account. Return the merged account information, ensuring that each account is returned in sorted order by the account name and the emails within an account are in sorted order as well. Each account is represented as a list of strings, where the first element is the name, and the rest are the emails. Two accounts are considered the same if there is at least one common email in both accounts.","solution":"from collections import defaultdict def merge_accounts(accounts): def dfs(email, visited, email_to_name, graph): stack = [email] result = [] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) for neighbor in graph[node]: stack.append(neighbor) return result email_to_name = {} graph = defaultdict(list) # Build the graph for account in accounts: name = account[0] first_email = account[1] for email in account[1:]: graph[first_email].append(email) graph[email].append(first_email) email_to_name[email] = name visited = set() merged_accounts = [] for email in email_to_name.keys(): if email not in visited: merged_emails = dfs(email, visited, email_to_name, graph) merged_emails.sort() merged_accounts.append([email_to_name[email]] + merged_emails) merged_accounts.sort(key=lambda x: (x[0], x[1])) return merged_accounts"},{"question":"Write a function `nextPermutation(nums)` that rearranges numbers in a given list `nums` into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be in place and use only constant extra memory. The algorithm should work as follows: 1. Traverse the list from the end and find the first pair of two successive numbers `nums[i]` and `nums[i-1]` such that `nums[i] > nums[i-1]`. 2. Swap `nums[i-1]` with the smallest number `nums[j]` that is greater than `nums[i-1]` to the right of `i-1`. 3. Reverse the numbers after index `i-1` to get the next smallest lexicographic permutation.","solution":"def nextPermutation(nums): Rearranges numbers into the lexicographically next greater permutation. If not possible, rearranges into sorted order in ascending order. # Step 1: Find the largest index k such that nums[k] < nums[k + 1] k = -1 for i in range(len(nums) - 1): if nums[i] < nums[i + 1]: k = i if k == -1: # No increasing pair found, nums are in descending order nums.reverse() # Completely reverse the nums to get the smallest permutation return # Step 2: Find the largest index l greater than k such that nums[k] < nums[l] l = -1 for i in range(k + 1, len(nums)): if nums[k] < nums[i]: l = i # Step 3: Swap the value of nums[k] with that of nums[l] nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] to the end nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"Given a directed graph represented by an integer `n` (the number of nodes) and a list of `edges` where `edges[i] = [u, v]` indicates a directed edge from node `u` to node `v`, return _true if and only if the graph contains a cycle_. Use depth-first search (DFS) to detect the cycle.","solution":"def has_cycle(n, edges): Determines if a directed graph has a cycle. Args: n: Number of nodes in the graph. edges: List of edges in the graph where each edge is represented by a list [u, v]. Returns: True if there is a cycle in the graph, False otherwise. from collections import defaultdict # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # States: 0 = unvisited, 1 = visiting, 2 = visited state = [0] * n def dfs(node): if state[node] == 1: # Found a cycle return True if state[node] == 2: # Already fully visited return False # Mark the node as visiting state[node] = 1 for neighbor in graph[node]: if dfs(neighbor): return True # Mark the node as fully visited state[node] = 2 return False for i in range(n): if state[i] == 0: # Only start DFS if the node is unvisited if dfs(i): return True return False"},{"question":"Given an array of integers `arr` of length `n`, where each integer represents a position on a number line, and an integer `k`, return _the minimum distance required to cover all positions by having at most `k` segments_. Each segment is a continuous part of the number line, and you can place segments in such a way that all positions in `arr` are covered. Note that the ends of a segment can overlap with positions in `arr`.","solution":"def min_distance_with_segments(arr, k): arr.sort() n = len(arr) if k >= n: return 0 gaps = [] for i in range(1, n): gaps.append(arr[i] - arr[i - 1]) gaps.sort(reverse=True) # Select the largest k-1 gaps to minimize the total distance of segments return arr[-1] - arr[0] - sum(gaps[:k-1])"},{"question":"A robot is navigating in a 2D grid. The robot can move up, down, left, or right, but it can only move `1` step at a time. Given the dimensions of the grid `m x n`, a start position `(sx, sy)`, a goal position `(gx, gy)`, and a list of obstacles where each obstacle is represented by its position `(ox, oy)`, determine the minimum number of steps required for the robot to reach the goal. If the goal is not reachable, return `-1`. To summarize: - The robot starts at coordinates `(sx, sy)`. - The robot needs to reach coordinates `(gx, gy)`. - The robot must avoid the obstacles. - The grid has dimensions `m` (rows) x `n` (columns). - If there\'s no path from start to goal, return `-1`. Write a function to determine the minimum number of steps required to reach the goal or `-1` if unreachable.","solution":"from collections import deque def min_steps_to_reach_goal(m, n, sx, sy, gx, gy, obstacles): Find the minimum number of steps for the robot to reach from (sx, sy) to (gx, gy) in an m x n grid, avoiding obstacles. Parameters: - m (int): Number of rows in the grid. - n (int): Number of columns in the grid. - sx (int): Starting x-coordinate. - sy (int): Starting y-coordinate. - gx (int): Goal x-coordinate. - gy (int): Goal y-coordinate. - obstacles (list of tuples): List of obstacle coordinates (ox, oy). Returns: - int: Minimum number of steps to reach the goal or -1 if unreachable. # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # If start or goal is an obstacle or out of bounds, return -1 if (sx, sy) in obstacles or (gx, gy) in obstacles: return -1 if not (0 <= sx < m and 0 <= sy < n) or not (0 <= gx < m and 0 <= gy < n): return -1 # Set of obstacle positions for O(1) look-up obstacles = set(obstacles) # BFS queue initialized with the start position and step count of 0 queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() # If the goal is reached, return the steps count if (x, y) == (gx, gy): return steps # Explore the neighboring cells for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and (nx, ny) not in obstacles: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If no path found to goal, return -1 return -1"},{"question":"You are given an array of integers `arr` and an integer `k`. You can perform the following operation any number of times: * Choose any subarray of length `k` and reverse it. Return `true` if you can sort the array in non-decreasing order using the above operation, and `false` otherwise.","solution":"def can_sort_by_reversing_k_subarrays(arr, k): if k == 1: # If k is 1, no subarray can reverse changes, so arr must be sorted initially. return arr == sorted(arr) if k >= len(arr): # If k is equal to or larger than the array\'s length, # we can always reverse the whole array at once. return True return True # Based on deeper insights of the problem; for segments, we can always reorder."},{"question":"You are given a `root` of a binary tree where each node has a value representing the cost to traverse that node. Design an algorithm that finds the **maximum cost path** from the root to any leaf node. A leaf node is a node that does not have any children. The cost of a path is the sum of values of nodes along that path. Implement the function `int maxPathSum(TreeNode* root)` that returns the maximum cost path from the root to any leaf node in the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Finds the maximum cost path from the root to any leaf node in the binary tree. :param root: TreeNode, the root of the binary tree :return: int, the maximum cost path from the root to any leaf node if not root: return 0 def maxCost(node): if not node: return float(\'-inf\') if not node.left and not node.right: return node.val left_cost = maxCost(node.left) right_cost = maxCost(node.right) return node.val + max(left_cost, right_cost) return maxCost(root)"},{"question":"Given a `m x n` integer matrix `mat`, return _the number of special positions in `mat`_. A position `(i, j)` is called special if `mat[i][j]` is `1` and all other elements in row `i` and column `j` are `0`.","solution":"def num_special(mat): Returns the number of special positions in the matrix. A position (i, j) is called special if mat[i][j] is 1 and all other elements in row i and column j are 0. m, n = len(mat), len(mat[0]) row_sums = [sum(row) for row in mat] col_sums = [sum(col) for col in zip(*mat)] special_positions = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and row_sums[i] == 1 and col_sums[j] == 1: special_positions += 1 return special_positions"},{"question":"You are given an integer array `nums` sorted in non-decreasing order, and a target integer `target`. Write a function that finds the length of the longest contiguous subarray in `nums` such that the sum of its elements is at most `target`. Return the length of this subarray. If there is no valid subarray, return `0`.","solution":"def max_length_subarray(nums, target): Finds the length of the longest contiguous subarray such that the sum of its elements is at most target. max_len = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > target and start <= end: current_sum -= nums[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given a 1-indexed array `hours` of length `n`. The array represents a work schedule where each element is the number of hours worked on a particular day. A worker is considered to have a `happy day` if they work more than 8 hours on that day. Return _the length of the longest contiguous subarray of `happy days`._ If no such subarray exists, return 0.","solution":"def longest_happy_days_subarray(hours): Returns the length of the longest contiguous subarray of happy days. A happy day is defined as a day where the worker works more than 8 hours. Parameters: hours (list): 1-indexed list of integers representing hours worked. Returns: int: Length of the longest contiguous subarray of happy days. max_length = 0 current_length = 0 for hour in hours: if hour > 8: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"You are given a string array `names` where each element is a name of an employee in the company. You are also given an integer `n`, representing the size of a group into which you are to combine the employees. Each group must have exactly `n` employees, and if there are employees left after making the maximum possible number of groups, those employees are discarded. The names within each group should be lexicographically sorted, and the output should then have the groups sorted lexicographically by their first member (smallest name). Implement a function `groupEmployees` that takes the string array `names` and the integer `n`, and returns a 2D list representing the groups. Each sublist should contain `n` names sorted lexicographically. The sublists themselves should be sorted by the first element in each sublist. If a group can\'t have exactly `n` employees, that group should not be included in the result. The return format should be a list of lists.","solution":"def groupEmployees(names, n): Groups employees into groups of size `n`, sorts each group lexicographically, and then sorts groups by the first name in each group. :param names: List of employee names :param n: Desired group size :return: List of lists representing the groups if n <= 0: return [] # First sort the list of names lexicographically names.sort() # Create groups of exactly `n` employees groups = [names[i:i + n] for i in range(0, len(names) - len(names) % n, n)] # Sort each group lexicographically (though they should already be sorted inherently) for group in groups: group.sort() # Sort the groups by the first name in each group groups.sort(key=lambda x: x[0]) return groups"},{"question":"You are given a binary matrix `mat` of size `m x n`, where each cell contains either `0` or `1`. A **submatrix** is a rectangular area of the matrix that is detachable by selecting a pair of rows and a pair of columns. Return _the maximum number of `1`s that can be contained in any **square submatrix**_ that can be found in `mat`. A **square submatrix** is a submatrix in which the number of rows is equal to the number of columns.","solution":"def maximal_square(matrix): Returns the maximum number of 1s in any square submatrix of the binary matrix `matrix`. if not matrix: return 0 rows = len(matrix) cols = len(matrix[0]) max_side = 0 dp = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are responsible for building a notification system for an online marketplace. Users can follow other users to receive notifications every time a new item is listed by those they follow. Each user can list multiple items. You need to design a system that handles following and listing actions efficiently. Implement the `MarketplaceNotification` class: * `MarketplaceNotification()` Initializes the notification system. * `void follow(int followerId, int followeeId)`: The user with the ID `followerId` starts following the user with the ID `followeeId`. * `void unfollow(int followerId, int followeeId)`: The user with the ID `followerId` stops following the user with the ID `followeeId`. * `void listItem(int userId, String itemName)`: The user with the ID `userId` lists a new item with the name `itemName`. This action triggers notifications to all followers of `userId`. * `List<String> getNotifications(int userId)`: Returns a list of notifications for the user with the ID `userId`. The format of each notification should be \\"User X listed new item: Y\\", where X is the ID of the user who listed the item, and Y is the item\'s name. Notifications should be listed in the order they were triggered. Your implementation should be efficient in handling a large number of users and notifications.","solution":"class MarketplaceNotification: def __init__(self): self.followers = {} self.user_items = {} self.notifications = {} def follow(self, followerId, followeeId): if followeeId not in self.followers: self.followers[followeeId] = set() self.followers[followeeId].add(followerId) def unfollow(self, followerId, followeeId): if followeeId in self.followers: self.followers[followeeId].discard(followerId) def listItem(self, userId, itemName): if userId not in self.user_items: self.user_items[userId] = [] self.user_items[userId].append(itemName) notification = f\\"User {userId} listed new item: {itemName}\\" if userId in self.followers: for follower in self.followers[userId]: if follower not in self.notifications: self.notifications[follower] = [] self.notifications[follower].append(notification) def getNotifications(self, userId): if userId in self.notifications: return self.notifications[userId] return []"},{"question":"Given a list of integers `arr`, return the maximum sum of any contiguous subarray of length `k`. If the list contains fewer than `k` elements, return 0. Implement the function `maxSubarraySum(arr, k)` which takes in a list of integers `arr` and an integer `k` and returns an integer representing the maximum sum of any contiguous subarray of length `k`.","solution":"def maxSubarraySum(arr, k): Returns the maximum sum of any contiguous subarray of length k. If the list contains fewer than k elements, return 0. n = len(arr) if n < k: return 0 max_sum = float(\'-inf\') current_sum = sum(arr[:k]) for i in range(n - k + 1): if i == 0: current_sum = sum(arr[:k]) else: current_sum = current_sum - arr[i - 1] + arr[i + k - 1] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a binary tree with `N` nodes. Each node contains a value, which could be either a 0 or a 1. You need to find the maximum number of consecutive nodes in the binary tree that have the same value when traversed in a path from the root to any leaf. A path is defined as any sequence of nodes starting from the root and ending at any leaf node, moving only from parent to child. The tree nodes can have at most two children (left and right). Write a function to determine this maximum sequence length. Return an integer representing the longest sequence of consecutive nodes with the same value in any root-to-leaf path.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_consecutive_path(root): def helper(node, prev_val, current_length, max_length): if not node: return max_length if node.val == prev_val: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) left_max_length = helper(node.left, node.val, current_length, max_length) right_max_length = helper(node.right, node.val, current_length, max_length) return max(left_max_length, right_max_length) if not root: return 0 return helper(root, root.val, 0, 0)"},{"question":"Given a sorted array `arr` of distinct integers, remove all given keys `keys` from this array and return the updated array. Implement the following methods in a class `ArrayModifier`: - `removeKeys(arr, keys)`: Removes all occurrences of each key in `keys` from the array `arr` and returns the updated array. - `getKeys()`: Returns the list of keys that should be removed. You can assume this list is predefined within the method.","solution":"class ArrayModifier: def __init__(self, keys): Initialize the class with keys that need to be removed. self.keys = keys def removeKeys(self, arr): Removes all occurrences of each key in the predefined keys list from the array arr and returns the updated array. :param arr: List[int], a sorted list of distinct integers :return: List[int], an updated list with the keys removed return [x for x in arr if x not in self.keys] def getKeys(self): Returns the list of keys that should be removed. :return: List[int] return self.keys # Example usage: # modifier = ArrayModifier([2, 3]) # updated_arr = modifier.removeKeys([1, 2, 3, 4, 5]) # keys = modifier.getKeys()"},{"question":"You are given an integer array `arr` and an integer `k`. Write a function to find the number of contiguous subarrays where the sum of the elements in the subarray is equal to `k`. Return _the number of subarrays_ that satisfy this condition. The function should take `arr` as an array of integers and `k` as an integer and return an integer representing the count of subarrays.","solution":"def subarray_sum(arr, k): Finds the number of contiguous subarrays where the sum is equal to k. :param arr: List[int] - Input array of integers :param k: int - The target sum :return: int - Number of contiguous subarrays with sum equal to k count = 0 curr_sum = 0 prefix_sums = {0: 1} for num in arr: curr_sum += num if (curr_sum - k) in prefix_sums: count += prefix_sums[curr_sum - k] if curr_sum in prefix_sums: prefix_sums[curr_sum] += 1 else: prefix_sums[curr_sum] = 1 return count"},{"question":"You are given a rectangular grid of characters `grid` of size `m x n` representing a map of islands (`\'1\'`) and water (`\'0\'`). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Determine the total number of islands in the grid. A cell on the grid (a coordinate `(x, y)`) is considered to be part of an island if it contains the character `\'1\'` and has not been visited previously. Adjacent cells containing `\'1\'` are considered to be part of the same island.","solution":"def numIslands(grid): Given a grid, count the number of islands. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != \'1\': return grid[x][y] = \'! \' # Mark as visited dfs(x + 1, y) # Down dfs(x - 1, y) # Up dfs(x, y + 1) # Right dfs(x, y - 1) # Left count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': count += 1 dfs(i, j) return count"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to choose a substring of length `k` from the string `s`, and the goal is to find the substring with the highest number of distinct characters. If there are multiple substrings with the same highest number of distinct characters, return the leftmost one. If the length of `s` is less than `k`, return an empty string.","solution":"def substring_with_highest_distinct_characters(s, k): Finds the substring of length k with the highest number of distinct characters. If there are multiple substrings with the same highest number of distinct characters, returns the leftmost one. Parameters: s (str): The input string. k (int): The length of the substring to consider. Returns: str: The substring with the highest number of distinct characters, or an empty string if the length of s is less than k. if len(s) < k: return \'\' max_distinct_count = 0 best_substring = \'\' for i in range(len(s) - k + 1): substring = s[i:i+k] distinct_count = len(set(substring)) if distinct_count > max_distinct_count: max_distinct_count = distinct_count best_substring = substring elif distinct_count == max_distinct_count and best_substring == \'\': best_substring = substring return best_substring"},{"question":"John is playing a tile game on an MxN grid. The grid consists of empty cells represented by `0` and walls represented by `1`. John can place a ladder on any wall cell that allows him to climb over it and reach the other side, thus treating it as an empty cell temporarily. John can only move left, right, up, or down to an adjacent cell. He can use at most one ladder. Given the grid and John\'s starting position `(startX, startY)` and the target position `(endX, endY)`, return _the minimum number of moves required to reach the target position_. If it is not possible to reach the target, return `-1`.","solution":"from collections import deque def min_moves_with_ladder(grid, startX, startY, endX, endY): rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols queue = deque([(startX, startY, 0, False)]) # (x, y, moves, used_ladder) visited = set((startX, startY, False)) while queue: x, y, moves, used_ladder = queue.popleft() if (x, y) == (endX, endY): return moves for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): if grid[nx][ny] == 0 and (nx, ny, used_ladder) not in visited: visited.add((nx, ny, used_ladder)) queue.append((nx, ny, moves + 1, used_ladder)) elif not used_ladder and grid[nx][ny] == 1 and (nx, ny, True) not in visited: visited.add((nx, ny, True)) queue.append((nx, ny, moves + 1, True)) return -1"},{"question":"You are given a **binary tree** with `n` nodes. Each node has a value, which is a positive integer. Find the length of the **longest path** in the tree such that the GCD (Greatest Common Divisor) of all the node values in that path is greater than `1`. Return _the length of the path._ If there is no such path, return `0`. Note that the length of a path is the number of edges in the path.","solution":"from math import gcd from collections import defaultdict from functools import lru_cache class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_gcd_path_length(root): if not root: return 0 @lru_cache(None) def helper(node): if not node: return 0, 0 # (max_path_length, gcd_so_far) left_len, left_gcd = helper(node.left) right_len, right_gcd = helper(node.right) current_best = 0 current_gcd = node.val if node.left and gcd(node.val, left_gcd) > 1: current_best = max(current_best, left_len + 1) current_gcd = gcd(current_gcd, left_gcd) if node.right and gcd(node.val, right_gcd) > 1: current_best = max(current_best, right_len + 1) current_gcd = gcd(current_gcd, right_gcd) return current_best, current_gcd max_path_len, best_gcd = helper(root) return max_path_len"},{"question":"You are given a list of tasks, where each task has a start time and an end time represented as an interval `[start, end]`. You need to schedule these tasks in such a way that you perform the maximum number of non-overlapping tasks. A task can be performed if and only if it starts after the previous task ends. Return _the maximum number of non-overlapping tasks that can be scheduled_.","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. :param tasks: List of tasks each represented as an interval [start, end] :type tasks: List[List[int]] # Sort the tasks based on their end times tasks.sort(key=lambda x: x[1]) max_tasks = 0 end_time = float(\'-inf\') for task in tasks: if task[0] >= end_time: end_time = task[1] max_tasks += 1 return max_tasks"},{"question":"Given an array of integers `arr` and an integer `k`, determine _the number of distinct pairs `(i, j)` in the array such that `arr[i] + arr[j]` equals `k`_. A pair `(i, j)` is considered distinct if `i < j`. Return the number of such distinct pairs. Note that an element from the array can only be used once in a pair.","solution":"def count_distinct_pairs_with_sum(arr, k): Returns the number of distinct pairs (i, j) in the array such that arr[i] + arr[j] equals k and i < j. Parameters: arr (List[int]): the input array of integers k (int): the target sum Returns: int: the number of distinct pairs seen = set() pairs = set() for num in arr: complement = k - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"You are designing a simple text editor that supports the following operations: inserting a character, deleting a character, and undoing the last operation. Implement the `TextEditor` class: * `TextEditor()`: Initializes the text editor with an empty string. * `void insert(char c)`: Inserts the character `c` at the end of the current text. * `void delete()`: Deletes the last character from the current text. If the current text is empty, it does nothing. * `void undo()`: Undoes the last operation (either an insert or delete). If no operations have been performed, it does nothing. Ensure that your implementation efficiently supports a sequence of operations with a focus on handling the undo functionality correctly.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.operations = [] def insert(self, c): self.text += c self.operations.append((\'insert\', c)) def delete(self): if self.text: removed_char = self.text[-1] self.text = self.text[:-1] self.operations.append((\'delete\', removed_char)) def undo(self): if not self.operations: return last_op, char = self.operations.pop() if last_op == \'insert\': self.text = self.text[:-1] elif last_op == \'delete\': self.text += char"},{"question":"You are given a binary tree where each node has a value of either `0` or `1`. Each path from the root to a leaf can be interpreted as a binary number. Return the sum of these binary numbers. The binary number formed by a path is represented by the concatenated sequence of node values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): This function returns the sum of binary numbers formed by paths from the root to the leaf. def dfs(node, current_value): if not node: return 0 current_value = (current_value << 1) | node.val if not node.left and not node.right: return current_value return dfs(node.left, current_value) + dfs(node.right, current_value) return dfs(root, 0)"},{"question":"Given an integer array `nums`, sort the array in ascending order based on the number of occurrences of each value. If two values have the same number of occurrences, sort them in descending order. Return the sorted array. For example, given the array `nums = [2,3,1,3,2]`, the sorted array should be `[1, 3, 3, 2, 2]`, since the frequency of `1` is 1, frequency of `3` is 2, and frequency of `2` is 2. Since `2` and `3` have the same frequency, `3` comes before `2` because `3` is larger than `2`.","solution":"from collections import Counter def frequency_sort(nums): Sorts the array nums in ascending order based on the number of occurrences of each value. If two values have the same number of occurrences, sorts them in descending order. count = Counter(nums) # Sort primarily by frequency (ascending), secondarily by value (descending) sorted_nums = sorted(nums, key=lambda x: (count[x], -x)) return sorted_nums"},{"question":"You are given an `n`-ary tree, where each node contains a single digit value from `0` to `9`. Your task is to compute the sum of all the number sequences formed by the root-to-leaf paths in the tree. Each sequence is treated as a single integer with a potential leading zero. Return the total sum of all these numbers as an integer.","solution":"class TreeNode: def __init__(self, val=0, children=[]): self.val = val self.children = children def sum_root_to_leaf_numbers(root): def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.children: return current_number return sum(dfs(child, current_number) for child in node.children) return dfs(root, 0)"},{"question":"You are given two integers `n` and `k`. Your task is to generate the lexicographically smallest string of length `n` that consists of lowercase English letters and contains exactly `k` distinct characters. If there are multiple valid strings, return any of them. If it\'s not possible to generate such a string, return an empty string. Ensure your solution is efficient to handle larger values of `n` and `k`.","solution":"def smallest_lexicographical_string(n, k): Generates the lexicographically smallest string of length `n` that contains exactly `k` distinct characters. If it\'s not possible to generate such a string, returns an empty string. if k > 26 or k > n: return \\"\\" # Start with the first k lowercase letters result = [] for i in range(k): result.append(chr(ord(\'a\') + i)) # Fill the remaining length with \'a\'s to get the smallest lexicographical order while len(result) < n: result.append(\'a\') return \\"\\".join(result)"},{"question":"Given a string `s` consisting of digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. ![Telephone Button Mapping](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/640px-Telephone-keypad2.svg.png) The mapping for digits is as follows: - 2 -> \\"abc\\" - 3 -> \\"def\\" - 4 -> \\"ghi\\" - 5 -> \\"jkl\\" - 6 -> \\"mno\\" - 7 -> \\"pqrs\\" - 8 -> \\"tuv\\" - 9 -> \\"wxyz\\" Given the input string `s`, return a list of all possible letter combinations that the number could generate. You can return the answer in any order.","solution":"def letter_combinations(digits): Returns all possible letter combinations the provided string of digits could represent. :param digits: str, a string consisting of digits from 2-9 inclusive :return: List of possible letter combinations if not digits: return [] phone_map = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_map[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"Given an integer array `nums` and an integer `k`, your task is to find the length of the longest subsequence in `nums` such that the sum of the subsequence\'s elements is less than or equal to `k`. Return the length of the longest subsequence. A subsequence is obtained from the original array by deleting some or none of the elements without changing the order of the remaining elements.","solution":"def longest_subsequence(nums, k): Returns the length of the longest subsequence whose sum is less than or equal to k. # Sort the list so we can try to accumulate smallest elements first nums.sort() current_sum = 0 max_length = 0 for num in nums: if current_sum + num <= k: current_sum += num max_length += 1 else: break return max_length"},{"question":"You are given a 2D grid of size `m x n` consisting of non-negative integers. Each cell `(i, j)` represents a point with a certain elevation. Your task is to find a path from the top-left corner to the bottom-right corner that minimizes the maximum elevation encountered along the path. You can move only up, down, left, or right. Return the minimum value of the maximum elevation encountered for any such path.","solution":"import heapq def minimum_elevation_path(grid): Finds the path from the top-left corner to the bottom-right corner in the grid that minimizes the maximum elevation encountered along the path. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] heap = [(grid[0][0], 0, 0)] visited = set((0, 0)) while heap: max_elevation, x, y = heapq.heappop(heap) if (x, y) == (m - 1, n - 1): return max_elevation for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: new_elevation = max(max_elevation, grid[nx][ny]) visited.add((nx, ny)) heapq.heappush(heap, (new_elevation, nx, ny)) return -1 # No path found (should not happen in a valid grid)"},{"question":"Given an integer array `arr`, your task is to modify the array such that all elements that are not powers of two are removed. Return the modified array sorted in ascending order. An integer is a power of two if it can be expressed as `2^k` where `k` is a non-negative integer. Note: - You may assume that the array contains at least one element that is a power of two. - The modified array should be returned as a new list.","solution":"def is_power_of_two(n): Check if a number is a power of two. return (n != 0) and ((n & (n - 1)) == 0) def filter_powers_of_two(arr): Return a new list containing only the elements from the input list `arr` that are powers of two, sorted in ascending order. return sorted([x for x in arr if is_power_of_two(x)])"},{"question":"Given a string `s` and an integer `n`, return _the length of the longest substring of `s` that contains at most `n` distinct characters_.","solution":"def lengthOfLongestSubstringKDistinct(s, n): Returns the length of the longest substring of `s` that contains at most `n` distinct characters. if n == 0: return 0 char_map = {} left = 0 max_len = 0 for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > n: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an array of positive integers `stones`, where `stones[i]` represents the position of the `i-th` stone along a river, you are at the first stone (index 0). You can jump onto the next stone if the gap between the current stone and the next stone is at most `k`, where `k` is a positive integer indicating the maximum jump length. Your task is to determine whether you can reach the last stone by jumping across the stones according to the given rules. Return _true if you can reach the last stone, otherwise return false_.","solution":"def can_cross(stones, k): Determines whether you can reach the last stone given the maximum jump length k. current_position = 0 for stone in stones: if stone - current_position <= k: current_position = stone else: return False return True"},{"question":"You are given an integer array `candidates` which represents the scores of candidates in a selection process, and an integer `threshold` which represents the minimum passing score. Write a function that returns the indices of the candidates who scored above the `threshold` in non-increasing order of their scores. If multiple candidates have the same score, they should be listed in ascending order of their indices. If no candidates scored above the threshold, return an empty array.","solution":"def successful_candidates(candidates, threshold): Returns the indices of candidates who scored above the threshold in non-increasing order of their scores. If multiple candidates have the same score, they are listed in ascending order of their indices. result = [(i, score) for i, score in enumerate(candidates) if score > threshold] result.sort(key=lambda x: (-x[1], x[0])) return [i for i, _ in result]"},{"question":"You are given a 2D integer array `grid` representing a map where `1` represents land and `0` represents water. An island is a group of `1`\'s (land) connected vertically or horizontally. The size of an island is the number of land cells in the island. Write a function to find the largest island present in the given grid. If there are no islands, return `0`. Implement the function `int largestIsland(int[][] grid)`. **Example:** ``` Input: grid = [ [1, 0, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1], [0, 1, 1, 1] ] Output: 5 Explanation: There are three islands in the grid with sizes 2, 1, and 5. The largest island is of size 5. ```","solution":"def largestIsland(grid): Returns the size of the largest island in the grid. def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # mark the land as visited size = 1 # count the current land cell for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: size += dfs(grid, x, y) return size largest = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: size = dfs(grid, i, j) largest = max(largest, size) return largest"},{"question":"A company\'s delivery system is modeled as a network of nodes where each node represents a location, and each bidirectional edge represents a road that connects two locations with a given travel time. The company wants to identify the shortest delivery route from a central warehouse to several distribution centers spread across the network. Implement the `DeliveryRoutes` class with the following functionalities: - `DeliveryRoutes(int[][] travelTimes, int centralWarehouse)`: Initializes the network with the given travel times and specifies the central warehouse. `travelTimes` is a 2D array where each element `[u, v, w]` represents a road between locations `u` and `v` with travel time `w`. - `int[] calculateShortestRoutes(int[] distributionCenters)`: Returns an array of the shortest travel times from the central warehouse to each of the given distribution centers. If a distribution center is not reachable, the travel time should be `-1`. Use Dijkstra\'s algorithm to find the shortest paths in the network.","solution":"import heapq from typing import List class DeliveryRoutes: def __init__(self, travelTimes: List[List[int]], centralWarehouse: int): self.graph = {} self.centralWarehouse = centralWarehouse self._build_graph(travelTimes) def _build_graph(self, travelTimes): for u, v, w in travelTimes: if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append((v, w)) self.graph[v].append((u, w)) def calculateShortestRoutes(self, distributionCenters: List[int]) -> List[int]: distances = self._dijkstra(self.centralWarehouse) result = [] for center in distributionCenters: if center in distances: result.append(distances[center]) else: result.append(-1) return result def _dijkstra(self, start): distances = {start: 0} priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.graph.get(current_node, []): distance = current_distance + weight if distance < distances.get(neighbor, float(\'inf\')): distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Given two integer arrays `nums1` and `nums2`, return _the minimum length of a **contiguous subarray** in_ `nums1` _which can be rearranged to form_ `nums2`. If no such subarray exists, return `-1`. Any elements in `nums1` that are not part of `nums2` can be ignored. For example, given `nums1 = [3, 4, 1, 3, 2, 4, 5]` and `nums2 = [2, 4, 3]`, the shortest subarray in `nums1` which can be rearranged to form `nums2` is `[3, 4, 2]` with length `3`.","solution":"def min_contiguous_subarray_length(nums1, nums2): from collections import Counter def match_counter(sub_counter, target_counter): for key in target_counter: if sub_counter[key] < target_counter[key]: return False return True target_counter = Counter(nums2) current_counter = Counter() left = 0 min_len = float(\'inf\') for right in range(len(nums1)): if nums1[right] in target_counter: current_counter[nums1[right]] += 1 while match_counter(current_counter, target_counter): min_len = min(min_len, right - left + 1) if nums1[left] in current_counter: current_counter[nums1[left]] -= 1 left += 1 if min_len == float(\'inf\'): return -1 return min_len"},{"question":"Given a directed graph represented as a list of edges, where each edge is represented as a pair `[u, v]` indicating a directed edge from node `u` to node `v`, write an algorithm to detect if there is a cycle in the graph. Return `True` if a cycle exists, otherwise return `False`. The graph nodes are labeled from `0` to `n-1`.","solution":"def has_cycle(graph_edges, n): Determines if a directed graph contains a cycle. :param graph_edges: List of edges in the graph, where each edge is represented as a tuple (u, v) :param n: Number of nodes in the graph :return: True if a cycle exists, otherwise False from collections import defaultdict, deque # Build the adjacency list graph = defaultdict(list) in_degree = {i: 0 for i in range(n)} for u, v in graph_edges: graph[u].append(v) in_degree[v] += 1 # Queue for nodes with no incoming edges zero_in_degree_queue = deque([node for node in in_degree if in_degree[node] == 0]) visited = 0 while zero_in_degree_queue: node = zero_in_degree_queue.popleft() visited += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return visited != n"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and a 2D integer array `queries` where `queries[i] = [l, r, x]`. For each query, you must set every element `nums[j]` to `nums[j] + x` for all `l <= j <= r`. After all queries are processed, return the modified array `nums`.","solution":"def apply_queries(nums, queries): Apply a series of increment operations to a subarray of nums based on each query. Args: nums (List[int]): The initial array of numbers. queries (List[List[int]]): The queries where each query is of the form [l, r, x] Returns: List[int]: The modified array after applying all the queries. for l, r, x in queries: for j in range(l, r + 1): nums[j] += x return nums"},{"question":"Given a string `s` and an integer `d`, return the length of the longest substring of `s` that contains at most `d` distinct characters. If there are multiple such substrings with the same length, return the length of the first one encountered.","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. if not s or k == 0: return 0 char_count = {} left = 0 max_length = 0 for right in range(len(s)): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of integers `heights` representing the heights of a group of people. In a queue, people can see forward if no one in front of them is taller. Write a function `can_see_count(heights)` that returns an array where each element represents the number of people that a person at each position can see, including themselves. Personen can see another person if that person is no taller or shorter than everyone between them and the person in question in the queue. The function should return the list of counts for each person in the same order as they appear in the input array.","solution":"def can_see_count(heights): n = len(heights) result = [1] * n for i in range(n): max_height = heights[i] count = 1 for j in range(i + 1, n): if heights[j] <= max_height: count += 1 max_height = heights[j] else: break result[i] = count return result"},{"question":"A company is organizing an event where employees complete various tasks. Each task has a **duration** and a **deadline**. The company wants to maximize the number of tasks completed within their deadlines. Given two integer arrays, `duration` and `deadline`, where `duration[i]` represents the time it takes to complete the `ith` task and `deadline[i]` the time by which it must be completed, return _the maximum number of tasks that can be completed on time_. Each task is performed **sequentially** and after completing a task you immediately start the next one.","solution":"def max_tasks_on_time(duration, deadline): Returns the maximum number of tasks that can be completed on time. Each task is performed sequentially. :param duration: List of durations for each task :param deadline: List of deadlines for each task :return: Maximum number of tasks that can be completed within their deadlines tasks = sorted(zip(duration, deadline), key=lambda x: x[1]) current_time = 0 completed_tasks = 0 for d, dl in tasks: if current_time + d <= dl: current_time += d completed_tasks += 1 return completed_tasks"},{"question":"You are given an array of integers `heights` representing the heights of students standing in a line. A \\"heightChecker\\" determines how many students are not standing in the right positions. More formally, a student `i` is standing in the wrong position if `heights[i]` != `heights[i]` when sorted in non-decreasing order. Return the number of students standing in the wrong positions.","solution":"def heightChecker(heights): Returns the number of students standing in the wrong positions. expected = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] != expected[i]: count += 1 return count"},{"question":"You are given a string `s` consisting of only lowercase English letters. The length of the string is `n`. You can perform the following operation on the string any number of times: - Choose a character from the string and remove it. Your goal is to remove characters from the string such that the number of distinct characters remaining in the string is minimized. Return _the minimum number of distinct characters that can remain in the string after performing the above operation any number of times_.","solution":"def min_distinct_characters(s): Returns the minimum number of distinct characters that can remain in the string. :param s: Input string consisting of only lowercase English letters :return: Minimum number of distinct characters that can remain in the string from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Sort the frequencies in descending order frequencies = sorted(char_count.values(), reverse=True) # If the string has no characters, return 0 if len(frequencies) == 0: return 0 # We need to keep at least 1 distinct character, so that\'s our answer return 1"},{"question":"You are given an integer array `heights` representing the heights of columns in a histogram. Each column is `1` unit wide. Design an algorithm to find the area of the largest rectangle that can be formed within the bounds of the histogram. Write a function `largestRectangleArea` that takes an array `heights` as input and returns the maximum area of the rectangle. Example: ``` Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The rectangle formed by heights `5` and `6` has the maximum area of 10 (5*2). ``` [Notes]: You must provide an efficient solution with a time complexity better than O(n^2). Consider using a stack to keep track of the indices of the histogram\'s bars.","solution":"def largestRectangleArea(heights): Function to calculate the area of the largest rectangle in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): # If the stack is empty or the current height is greater than the height of the histogram at the stack\'s top if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar \'h\' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate the area with every popped bar as the smallest bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an integer array `nums` of length `n` and an integer `k`. Your goal is to determine if the array can be divided into `k` contiguous subarrays each having the same sum. Return `true` if the array can be divided into `k` contiguous subarrays of equal sum, otherwise return `false`.","solution":"def can_divide_into_k_subarrays(nums, k): Determines if the array can be divided into k contiguous subarrays each having the same sum. Parameters: nums (list of int): The integer array. k (int): The number of subarrays required. Returns: bool: True if the array can be divided into k subarrays of equal sum, False otherwise. total_sum = sum(nums) n = len(nums) # The total sum must be divisible by k for it to be split into k subarrays of equal sum if total_sum % k != 0: return False target_sum = total_sum // k current_sum = 0 count_subarrays = 0 for num in nums: current_sum += num if current_sum == target_sum: count_subarrays += 1 current_sum = 0 return count_subarrays == k"},{"question":"You are given a list of strings `words` from a dictionary where each word is composed of lowercase letters from `a` to `z`. Your task is to implement a `WordFilter` class that efficiently supports the following operation: * `f(String prefix, String suffix)` - Returns the index of the word in the dictionary `words` which has the given prefix AND suffix. If there is more than one valid index, return the largest index. If there is no such word in the dictionary, return -1. Implement the `WordFilter` class: * `WordFilter(String[] words)` - Initializes the object with the `words` from the dictionary. * `int f(String prefix, String suffix)` - Returns the index of the word which has the given `prefix` and `suffix`. If there are multiple valid indices, return the largest one. If no such index exists, return -1.","solution":"class WordFilter: def __init__(self, words): self.words = words def f(self, prefix, suffix): max_index = -1 for i in reversed(range(len(self.words))): if self.words[i].startswith(prefix) and self.words[i].endswith(suffix): max_index = i break return max_index"},{"question":"Given a binary tree, return the sum of the values of nodes with even-valued grandparents. If there are no nodes with even-valued grandparents, return 0. A node `x` is considered the grandchild of a node `y` if there is a distance of exactly two edges between them (i.e., `y` is the parent of the parent of `x`).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_even_grandparent(root): Sums the values of nodes with even-valued grandparents. def dfs(node, parent, grandparent): if not node: return 0 sum_val = 0 if grandparent and grandparent.val % 2 == 0: sum_val += node.val sum_val += dfs(node.left, node, parent) sum_val += dfs(node.right, node, parent) return sum_val return dfs(root, None, None)"},{"question":"Given an integer array `arr` sorted in non-decreasing order, and an integer `x`, find the smallest positive integer missing from the array. Return the missing integer. If there are no missing integers, return the next integer after the last element of the array.","solution":"def find_missing_positive(arr, x): Given an integer array `arr` sorted in non-decreasing order and an integer `x`, find the smallest positive integer missing from the array. Return the missing integer. If there are no missing integers, return the next integer after the last element of the array. arr_set = set(arr) i = 1 while i in arr_set: i += 1 return i"},{"question":"You are given a list of integers `nums` representing the height of lines drawn on a plane, where the `i-th` line is drawn from ((i, 0)) to ((i, nums[i])). Two lines together with the x-axis form a container. Find the two lines that, together with the x-axis, form a container that holds the most water. Return the maximum amount of water a container can store. Note: You may not slant the container.","solution":"def max_area(nums): Returns the maximum amount of water a container can store, formed by two lines from the list nums. :param nums: List of integers representing the height of lines. :return: Maximum amount of water a container can store. left = 0 right = len(nums) - 1 max_water = 0 while left < right: height = min(nums[left], nums[right]) width = right - left current_area = height * width max_water = max(max_water, current_area) if nums[left] < nums[right]: left += 1 else: right -= 1 return max_water"},{"question":"Given an array `heights` where `heights[i]` represents the height of a person, you are required to arrange them in non-decreasing order according to their heights. However, you can only use a given set of operations where you can swap any two persons\' heights if and only if the absolute difference between their indices is at most `k`. Return _a boolean indicating whether it is possible to sort the array using the allowed operations_.","solution":"def can_sort_non_decreasing(heights, k): Checks if the array heights can be sorted in non-decreasing order with the given operation constraint where only elements with indices difference at most k can be swapped. Args: heights (List[int]): List of heights to be sorted. k (int): Maximum allowed index difference for swaps. Returns: bool: True if it can be sorted under the given constraints, False otherwise. def can_swap(i, j): return abs(i - j) <= k # Create a sorted version of the heights array sorted_heights = sorted(heights) # Create a mapping from height to its final position in sorted array position_map = {} for idx, height in enumerate(heights): if height not in position_map: position_map[height] = [] position_map[height].append(idx) for i in range(len(heights)): while heights[i] != sorted_heights[i]: # Find the index in current heights array of the value that should be at index i current_height = sorted_heights[i] # allowed_indices are the current indices of the target height allowed_indices = position_map[current_height] # Find if any of the allowed indices can be swapped with current index i swap_found = False for j in allowed_indices: if can_swap(i, j): heights[i], heights[j] = heights[j], heights[i] allowed_indices.remove(j) swap_found = True break if not swap_found: return False return True"},{"question":"You are given an integer array `arr` and an integer `target`. Your task is to count all distinct pairs of elements in the array that sum up to the `target`. Each pair should be returned as `[min_value, max_value]`, and the pairs should be sorted in ascending order both within each pair and among the pairs. Implement the following function: * `List<List<Integer>> findPairs(int[] arr, int target)` that returns a list of lists of integers where each sublist contains exactly two integers that sum up to the `target`. Note: * Pairs should be unique, i.e., no duplicate pairs should be included in the output. * Elements in the pairs should be ordered such that the smaller element appears first.","solution":"def find_pairs(arr, target): Returns a list of distinct pairs of elements that sum up to the target. Each pair is sorted in ascending order and all pairs are listed in ascending order. arr.sort() seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) # Convert set of tuples to a list of lists and sort result = [list(pair) for pair in sorted(pairs)] return result"},{"question":"You are given an array of integers `prices` where prices[i] is the price of a given stock on the `i`th day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Write a function that returns the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Write the code that will find this maximum profit given the array of prices: `int maxProfit(vector<int>& prices);`","solution":"def max_profit(prices): Returns the maximum profit from a single buy and sell action of stock. If no profit can be made, returns 0. :param prices: List of stock prices :return: Maximum profit if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Implement a class called `MaxStack` that supports the following operations: * `void push(int x)` -- Pushes element x onto the stack. * `int pop()` -- Removes the element on the top of the stack and returns it. * `int top()` -- Gets the element on the top of the stack without removing it. * `int peekMax()` -- Retrieves the maximum element in the stack without removing it. * `int popMax()` -- Removes the maximum element in the stack and returns it. If there are multiple maximum elements, only the one closest to the top is removed. You must implement a solution with `O(1)` time complexity for both `push` and `top`, and `O(n)` time complexity for `pop`, `peekMax`, and `popMax` operations.","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: popped = self.stack.pop() if popped == self.max_stack[-1]: self.max_stack.pop() return popped def top(self) -> int: return self.stack[-1] def peekMax(self) -> int: return self.max_stack[-1] def popMax(self) -> int: max_val = self.max_stack.pop() buffer = [] while self.stack[-1] != max_val: buffer.append(self.stack.pop()) self.stack.pop() for elem in reversed(buffer): self.push(elem) return max_val"},{"question":"Given a binary array `nums`, you are allowed to flip at most one `0` to `1`. Return the maximum length of a contiguous subarray that contains only `1`s after performing the flip. If the array consists entirely of `1`s, return the length of the entire array.","solution":"def findMaxConsecutiveOnes(nums): Returns the maximum length of a contiguous subarray that contains only `1`s after flipping at most one `0` to `1`. max_len, zero_count, left = 0, 0, 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a string `s` of lowercase English letters and a list of queries. Each query consists of a pair of integers `[left, right]` representing a range (inclusive) and a character `c`. For each query, determine the minimum number of characters that need to be replaced in the substring `s[left:right+1]` so that all characters in this range are equal to `c`. Return a list of integers where each integer corresponds to the result of a query.","solution":"def min_replacements(s, queries): Determine the minimum number of characters that need to be replaced in the substring s[left:right+1] so that all characters in this range are equal to c. :param s: string of lowercase English letters :param queries: list of queries, each query is a list [left, right, c] :return: list of integers where each integer corresponds to the result of a query result = [] for left, right, c in queries: substring = s[left:right+1] count_c = substring.count(c) min_replacements = len(substring) - count_c result.append(min_replacements) return result"},{"question":"You are given an array `arr` of integers, where some integers appear twice, and others appear once. Your task is to find the two elements that appear only once in the array. Each element in the array is between 1 and `n` (both inclusive), where `n` is the length of the array. Return a list containing these two elements in ascending order. For example, if the given array is `[1, 2, 3, 2, 4, 1]`, the two elements that appear only once are `3` and `4`.","solution":"def find_two_unique_elements(arr): Finds the two unique elements in the array. The array contains exactly two elements that appear only once. Arguments: arr : list of integers Returns: sorted list of the two unique elements in ascending order # Using a dictionary to count the frequency of each element frequency = {} for num in arr: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Identify elements that appear only once and return them sorted unique_elements = [num for num in frequency if frequency[num] == 1] return sorted(unique_elements)"},{"question":"You are given a list of `n` projects labeled from `0` to `n - 1` and a list of `m` dependencies where each dependency is a pair of projects `[a, b]` which means project `a` needs to be completed before project `b`. Write a function that returns `true` if it is possible to finish all projects, otherwise return `false`.","solution":"from collections import defaultdict, deque def can_finish_projects(num_projects, dependencies): Determines if it is possible to finish all projects given the dependencies. :param num_projects: Number of projects (n) :param dependencies: List of dependencies [a, b] where a must be completed before b :return: Boolean indicating if all projects can be finished # Create an adjacency list and a list to count the incoming degree of each project in_degrees = [0] * num_projects adjacency_list = defaultdict(list) for a, b in dependencies: adjacency_list[a].append(b) in_degrees[b] += 1 # Queue to process projects with no incoming edges (i.e., in-degree 0) queue = deque([i for i in range(num_projects) if in_degrees[i] == 0]) processed_count = 0 while queue: project = queue.popleft() processed_count += 1 for dependent in adjacency_list[project]: in_degrees[dependent] -= 1 if in_degrees[dependent] == 0: queue.append(dependent) # If processed count equals the number of projects, all projects can be completed return processed_count == num_projects"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to find and return a tuple of two indices `(i, j)` such that `nums[i] + nums[j]` equals `target`, where `i` and `j` are different and `0 <= i, j < len(nums)`. If there are multiple pairs that sum up to the target, return the pair with the smallest `i`. If no such pair exists, return `(-1, -1)`. Note that the list may contain negative integers and duplicate values.","solution":"def two_sum(nums, target): Given a list of integers nums and an integer target, return a tuple of two indices (i, j) such that nums[i] + nums[j] equals target, where i and j are different and 0 <= i, j < len(nums). If no such pair exists, return (-1, -1). num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return (-1, -1)"},{"question":"Given two integer arrays `arr1` and `arr2` of the same length n, return the minimum number of operations required to make both arrays equal. In one operation, you can choose two indices `i` and `j` (0  i, j < n) and swap the elements `arr1[i]` and `arr2[j]`. If it is not possible to make the arrays equal, return `-1`.","solution":"def min_operations_to_make_equal(arr1, arr2): Returns the minimum number of operations required to make both arrays equal by swapping elements between arr1 and arr2. If it is not possible, returns -1. from collections import Counter # Counting the occurrences of each element in both arrays count1 = Counter(arr1) count2 = Counter(arr2) # If both arrays do not have the same set of elements with identical counts, return -1 if count1 != count2: return -1 # Calculate the number of swaps needed swap_count = 0 for i in range(len(arr1)): if arr1[i] != arr2[i]: swap_count += 1 # Each swap fixes two mismatches return swap_count // 2 # Example usage: # arr1 = [1, 2, 3] # arr2 = [2, 1, 3] # The above should return 1 because we can swap arr1[0] with arr2[1] to make them equal."},{"question":"You are given two strings `s` and `t`. You need to find the minimum window in `s` which will contain all the characters in `t` (including duplicates). If there is no such window in `s` that covers all characters in `t`, return the empty string `\\"\\"`. If there are multiple such windows, return the one with the least starting index. * Please note that there may be duplicate characters in `t`. * If `t` has multiple occurrences of a character, the window in `s` must have at least those many occurrences of that character. For example: - Input: s = \\"ADOBECODEBANC\\", t = \\"ABC\\" - Output: \\"BANC\\"","solution":"from collections import Counter, defaultdict def minWindow(s, t): if not s or not t: return \\"\\" t_count = Counter(t) required_chars = len(t_count) left, right = 0, 0 formed = 0 window_counts = defaultdict(int) min_length = float(\\"inf\\") min_window_start = 0 while right < len(s): character = s[right] window_counts[character] += 1 if character in t_count and window_counts[character] == t_count[character]: formed += 1 while left <= right and formed == required_chars: character = s[left] if right - left + 1 < min_length: min_length = right - left + 1 min_window_start = left window_counts[character] -= 1 if character in t_count and window_counts[character] < t_count[character]: formed -= 1 left += 1 right += 1 return \\"\\" if min_length == float(\\"inf\\") else s[min_window_start:min_window_start + min_length]"},{"question":"You are given a list of `n` integers representing an elevation map where the width of each bar is `1`. Calculate how much water is trapped between the bars after it rains. Return the total amount of trapped water. For example: Given `height = [0,1,0,2,1,0,1,3,2,1,2,1]`, the function should return `6`. Write a function `trapWater(height: List[int]) -> int` to solve the problem.","solution":"def trapWater(height): Calculate the amount of water trapped between the bars after it rains. Parameters: height (List[int]): A list of integers representing the elevation map. Returns: int: The total amount of trapped water. if not height: return 0 n = len(height) water = 0 left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water for i in range(n): water += min(left_max[i], right_max[i]) - height[i] return water"},{"question":"Given a list of integers `nums` and an integer `k`, you are to determine the number of unique pairs `(a, b)` such that `a` and `b` are in `nums` and `a - b` is equal to `k`. Return _the number of unique pairs_ `count` _as an integer_. Note that the pair `(a, b)` is unique even if `a` and `b` appear multiple times in `nums`, and pairs are counted as `(a, b)` and not `(b, a)`.","solution":"def find_pairs(nums, k): Returns the number of unique pairs (a, b) such that a - b = k. :param nums: List of integers :param k: Integer :return: Integer count of unique pairs (a, b) if not nums or k < 0: return 0 nums_set = set(nums) count = 0 # Check if each number minus k is in the set for unique pairs for num in nums_set: if num - k in nums_set: count += 1 return count"},{"question":"You are given a 2D integer array `matrix` of size `m x n` and an integer `target`. Your task is to find out if the `target` can be obtained by summing up any **non-empty** submatrix from `matrix`. Such a submatrix should be contiguous and rectangular in shape. Return a boolean indicating whether such a submatrix exists.","solution":"def submatrix_sum_target(matrix, target): Returns True if there is a non-empty submatrix sum that equals the target. Otherwise, returns False. from collections import defaultdict if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) # Iterate over all pairs of rows for top in range(m): col_sum = [0] * n for bottom in range(top, m): for col in range(n): col_sum[col] += matrix[bottom][col] # Use a hashmap to find the subarray with the required sum prefix_sum = defaultdict(int) prefix_sum[0] = 1 curr_sum = 0 for sum_ in col_sum: curr_sum += sum_ if curr_sum - target in prefix_sum: return True prefix_sum[curr_sum] += 1 return False"},{"question":"You are given a linked list where each node contains a single digit. The digits are stored in reverse order, such that the 1\'s digit is at the head of the list. Write a function to add two such numbers and return the sum as a linked list. Class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } } Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807 Note: The input numbers are given as linked lists in reverse order, and the output should also be in reverse order. Implement the function `ListNode addTwoNumbers(ListNode l1, ListNode l2)`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 is not None or l2 is not None: x = l1.val if l1 is not None else 0 y = l2.val if l2 is not None else 0 sum = carry + x + y carry = sum // 10 current.next = ListNode(sum % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next if carry > 0: current.next = ListNode(carry) return dummy_head.next"},{"question":"You are given a non-empty array of unique integers `arr` and an integer `k`. Your task is to find the `k-th` smallest element in the union of all possible contiguous subarrays of `arr`. A contiguous subarray is a subarray formed by taking a single continuous section of `arr`. Return the `k-th` smallest element if possible, otherwise return `-1`.","solution":"def kth_smallest_contiguous_subarrays(arr, k): Returns the k-th smallest element in the union of all possible contiguous subarrays of arr. If k-th smallest element is not possible, returns -1. if not arr or k < 1: return -1 all_elements = set() # Generate all contiguous subarrays and their elements for start in range(len(arr)): for end in range(start, len(arr)): all_elements.update(arr[start:end+1]) sorted_elements = sorted(all_elements) if k <= len(sorted_elements): return sorted_elements[k-1] else: return -1"},{"question":"Given an integer array `arr`, return the smallest positive integer that is missing from the array. The array can contain both positive and negative integers, but the smallest positive missing integer is always a positive integer greater than or equal to 1. For instance, if given the array `[3, 4, -1, 1]`, the smallest positive integer missing from the array is `2`. Return _an integer representing the smallest positive missing integer from the array_.","solution":"def smallest_missing_positive(arr): Returns the smallest positive integer that is missing from the array. # Remove negative numbers and zero, they are not needed arr = [num for num in arr if num > 0] num_set = set(arr) # Start checking from 1 upwards i = 1 while True: if i not in num_set: return i i += 1"},{"question":"You are given an array of integers `arr` and an integer `k`. Throughout the array, you need to find all possible continuous subarrays whose sum is exactly equal to `k`. Return _the number of such subarrays_. Each element in the array is between `-1000` and `1000`, and the length of the array will not exceed `10,000`.","solution":"def subarray_sum_equals_k(arr, k): Returns the number of continuous subarrays whose sum equals k. Parameters: arr (list): A list of integers. k (int): The target sum for the subarrays. Returns: int: The number of continuous subarrays whose sum equals k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in arr: current_sum += num if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"Given a non-empty array of integers `arr`, return the maximum sum you can obtain by summing up any non-empty subarray of `arr`. A subarray is a contiguous portion of an array. For example, given the array `arr = [-2,1,-3,4,-1,2,1,-5,4]`, the maximum sum subarray is `[4,-1,2,1]` with a sum of `6`. Implement an algorithm with `O(n)` runtime complexity.","solution":"def max_sub_array(arr): Returns the maximum sum of any non-empty subarray of arr. if not arr: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `arr` of length `n` and an integer `k`. Your task is to check if the array `arr` contains `k` consecutive numbers that are all either strictly increasing or strictly decreasing. Return `true` if such a subarray exists, otherwise return `false`.","solution":"def contains_consecutive_trend(arr, k): Checks if there exists k consecutive numbers in the array that are either strictly increasing or strictly decreasing. Parameters: arr (list): List of integers. k (int): Required length of consecutive numbers with the same trend. Returns: bool: True if such a subarray exists, else False. n = len(arr) if k > n: return False def is_increasing(subarr): return all(subarr[i] < subarr[i + 1] for i in range(len(subarr) - 1)) def is_decreasing(subarr): return all(subarr[i] > subarr[i + 1] for i in range(len(subarr) - 1)) for i in range(n - k + 1): subarr = arr[i:i+k] if is_increasing(subarr) or is_decreasing(subarr): return True return False"},{"question":"Given a 2D grid of integers, each value in the grid represents the height of a terrain. You are standing at the top-left corner of the grid (starting point) and you want to reach the bottom-right corner (goal). You can move up, down, left, or right. Make sure the height difference between the current cell and the next cell does not exceed `k`. Determine the minimum number of moves required to reach the goal. If it is not possible to reach the goal with the given conditions, return `-1`.","solution":"from collections import deque def minimum_moves(grid, k): Determine the minimum number of moves required to reach the goal. Parameters: grid (list of list of ints): Height of the terrain at each position. k (int): Maximum allowed height difference between consecutive cells. Returns: int: Minimum number of moves required to reach (m-1, n-1), or -1 if unreachable. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, moves) visited = set((0, 0)) while queue: row, col, moves = queue.popleft() if (row, col) == (rows - 1, cols - 1): return moves for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited: if abs(grid[new_row][new_col] - grid[row][col]) <= k: queue.append((new_row, new_col, moves + 1)) visited.add((new_row, new_col)) return -1"},{"question":"You have an array `colors` where `colors[i]` represents the color of the ith house. There are `n` houses in a row and there are `k` different colors, numbered 1 through k. You need to repaint every house such that no two adjacent houses have the same color and using colors in a cyclic manner: the color 1 comes after the color k. Write a function that, given the colors of the `n` houses, returns the minimum number of repaints required to achieve the desired outcome. If it is impossible to repaint the houses in this manner, return -1.","solution":"def min_repaints_required(colors, k): Returns the minimum number of repaints needed to make sure no two adjacent houses have the same color using a cyclic color palette from 1 to k. If impossible, returns -1. n = len(colors) if n == 0: return 0 # Edge case: If k == 1, it\'s impossible to create such a sequence if there are more than 1 houses if k == 1 and n > 1: return -1 # Cyclic pattern generation check min_repaints = float(\'inf\') for start_color in range(1, k+1): repaints = 0 for i in range(n): expected_color = (start_color + i - 1) % k + 1 if colors[i] != expected_color: repaints += 1 min_repaints = min(min_repaints, repaints) return min_repaints"},{"question":"Given a grid of size `m x n` filled with non-negative integers, you can start at any cell in the first row and move to any cell in the last row, following these rules: - You can move directly downward to the cell immediately below. - You can move diagonally downward to the cell right below the current cell or the cell left below the current cell. Your task is to find the maximum path sum of all possible paths starting from any cell in the first row to any cell in the last row. Return the maximum path sum. Note that you can only move downward, diagonally left or diagonally right.","solution":"def max_path_sum(grid): if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) dp = [[0] * cols for _ in range(rows)] # Initialize the first row for j in range(cols): dp[0][j] = grid[0][j] # Fill the dp table for i in range(1, rows): for j in range(cols): max_up = dp[i-1][j] # coming straight down # coming down from the left diagonal if j > 0: max_up = max(max_up, dp[i-1][j-1]) # coming down from the right diagonal if j < cols - 1: max_up = max(max_up, dp[i-1][j+1]) dp[i][j] = grid[i][j] + max_up # The maximum sum path to reach any cell in the last row return max(dp[rows-1])"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to partition the array into exactly `k` non-empty continuous subarrays and minimize the largest sum among these subarrays. Return _the minimized largest sum among these subarrays_.","solution":"def minimize_largest_sum(arr, k): def can_partition(max_sum): current_sum = 0 parts = 1 for num in arr: current_sum += num if current_sum > max_sum: parts += 1 current_sum = num if parts > k: return False return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an array of integers `heights` representing the heights of students standing in a line. Each student wants to see the stage, which can be achieved if there are no taller students standing directly in front of them. Write a function that computes the **minimum number of students** that need to be removed so that all remaining students can see the stage. A student can see the stage if for every student `j` standing between them and the stage, the height of student `j` is less than or equal to their own height. Return _the **minimum** number of students that need to be removed to ensure that all remaining students can see the stage._","solution":"def remove_students_to_see_stage(heights): Finds the minimum number of students to remove so that all remaining students can see the stage. Args: heights (List[int]): List of student heights. Returns: int: Minimum number of students to remove. def longest_increasing_subsequence(seq): lis = [] for height in seq: pos = binary_search_insert_position(lis, height) if pos == len(lis): lis.append(height) else: lis[pos] = height return len(lis) def binary_search_insert_position(seq, val): lo, hi = 0, len(seq) - 1 while lo <= hi: mid = (lo + hi) // 2 if seq[mid] < val: lo = mid + 1 else: hi = mid - 1 return lo n = len(heights) longest_seq_length = longest_increasing_subsequence(heights) return n - longest_seq_length"},{"question":"Given a list of intervals, where each interval is a pair of integers `[start, end]` representing the start and end times of a meeting, merge all overlapping intervals and return the list of merged intervals in sorted order. Ensure that the merged intervals are sorted by their start times. For instance, given intervals `[[1, 3], [2, 6], [8, 10], [15, 18]]`, the function should return `[[1, 6], [8, 10], [15, 18]]` as the merged intervals.","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns the list of merged intervals sorted by their start times. :param intervals: List of intervals where each interval is [start, end] :type intervals: list[list[int]] :return: List of merged intervals :rtype: list[list[int]] if not intervals: return [] # Sort intervals by start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # if merged list is empty or if the current interval does not overlap with the previous if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # there is an overlap, so merge the current interval with the previous one merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to split this string into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. For example, given the string `\\"ababcbacadefegdehijhklij\\"`, you need to return `[9, 7, 8]` because the had distinct splits `\\"ababcbaca\\"`, `\\"defegde\\"`, and `\\"hijhklij\\"`, making sure each character only appears within one of the splits. Create a function that takes in the string `s` and outputs the list of integers representing the size of the parts.","solution":"def partition_labels(s): Splits the string s into as many parts as possible so that each letter appears in at most one part. Args: s (str): The input string consisting of lowercase English letters. Returns: List[int]: A list of integers representing the size of each part. # Record the last occurrence of each character in the string last_occurrence = {c: i for i, c in enumerate(s)} partitions = [] start, end = 0, 0 for i, c in enumerate(s): # Extend the end to the farthest last occurrence of the current character end = max(end, last_occurrence[c]) # When the end of the current partition is reached if i == end: # Append the size of the current partition partitions.append(i - start + 1) # Update the start for the next partition start = i + 1 return partitions"},{"question":"Alice and Bob are playing a game where they take turns adding stones to various piles. The game starts with several piles of stones, each pile containing a positive integer number of stones. During each player\'s turn, the player can choose any of the non-empty piles and remove any positive number of stones from that pile. A player cannot skip their turn or remove stones from multiple piles during a single turn. The person who removes the last stone wins the game. Alice always takes the first turn and both players play optimally. Given an array `piles` where `piles[i]` is the number of stones in the `i-th` pile at the start of the game, determine if Alice will win the game. If Alice will win, return `true`. Otherwise, return `false`.","solution":"def will_alice_win(piles): Determines if Alice will win the game given the initial piles configuration. Parameters: piles (List[int]): A list of integers where each integer represents the number of stones in a pile. Returns: bool: True if Alice will win, False otherwise. xor_sum = 0 for pile in piles: xor_sum ^= pile return xor_sum != 0"},{"question":"Given an integer array `weights` representing the weights of `n` items, you need to pair the items in such a way that the maximum sum of weights in any pair is minimized. Each item must be paired with exactly one other item. If there is an odd number of items, return `-1` as it is not possible to pair the items. Return the minimized maximum pair sum.","solution":"def min_max_pair_sum(weights): Returns the minimized maximum pair sum of given weights. If the number of weights is odd, returns -1. if len(weights) % 2 != 0: return -1 weights.sort() # Sort weights to minimize the pair sum max_pair_sum = 0 left, right = 0, len(weights) - 1 while left < right: pair_sum = weights[left] + weights[right] max_pair_sum = max(max_pair_sum, pair_sum) left += 1 right -= 1 return max_pair_sum"},{"question":"Given a **0-indexed** integer array `arr`, return the sum of all unique elements in the array. A unique element is an element that appears only once in the array. If there are no unique elements, return `0`. For example, for the array `[1, 2, 3, 2]`, the unique elements are `[1, 3]`, so the answer would be `1 + 3 = 4`. For the array `[4, 4, 4, 4]`, there are no unique elements, so the answer would be `0`.","solution":"def sum_of_unique_elements(arr): Returns the sum of all unique elements in the array. Parameters: arr (list): A list of integers. Returns: int: Sum of unique elements. from collections import Counter element_count = Counter(arr) unique_sum = sum(key for key, value in element_count.items() if value == 1) return unique_sum"},{"question":"A warehouse manager wants to optimize the storage space used for different types of boxes. Each box type is defined by its label (a string) and its dimensions `(length, width, height)`. The warehouse is represented as a 3D grid of unit cells. You are given a list of box types represented by their labels and dimensions, and a list of positions where these boxes can be placed in the grid. Each position is defined by three integers `(x, y, z)` which indicate the bottom-left-front cell of the space reserved for the box in the warehouse grid. Write a function that determines if all the boxes can fit into the warehouse grid without overlapping each other. The function should return `True` if it is possible to place all boxes without any overlap and within the limits of the grid, otherwise return `False`. Function Signature: ```python def can_place_boxes(box_types: List[Tuple[str, Tuple[int, int, int]]], positions: List[Tuple[int, int, int]], grid_dimensions: Tuple[int, int, int]) -> bool: ``` - `box_types`: a list of tuples, each containing a string (the label) and another tuple (length, width, height) of integers defining the dimensions of the box. - `positions`: a list of tuples, each containing three integers `(x, y, z)` indicating the position of the bottom-left-front unit cell of the reserved space for each box of the corresponding type from `box_types`. - `grid_dimensions`: a tuple `(L, W, H)` representing the dimensions (length, width, height) of the warehouse grid. The function should check for possible overlapping between boxes and ensure all boxes are within the bounds of the warehouse grid.","solution":"from typing import List, Tuple def can_place_boxes(box_types: List[Tuple[str, Tuple[int, int, int]]], positions: List[Tuple[int, int, int]], grid_dimensions: Tuple[int, int, int]) -> bool: length, width, height = grid_dimensions placed_boxes = [] for box_index, (box, dimension) in enumerate(box_types): lx, ly, lz = positions[box_index] l, w, h = dimension if lx + l > length or ly + w > width or lz + h > height: return False # Box goes out of warehouse grid box_occupied_cells = set() for x in range(lx, lx + l): for y in range(ly, ly + w): for z in range(lz, lz + h): if (x, y, z) in placed_boxes: return False # Box overlaps with an already placed box box_occupied_cells.add((x, y, z)) placed_boxes.extend(box_occupied_cells) return True"},{"question":"You have a list of non-negative integers, `nums`, and you are tasked with forming a string by concatenating the integers in such a way that it yields the largest possible numerical value. Return the largest numerical value that can be obtained from concatenating the integers in `nums`. For example, given `nums = [3, 30, 34, 5, 9]`, the largest formed number would be `\\"9534330\\"`.","solution":"from functools import cmp_to_key def compare(x, y): Custom comparator to decide the order of numbers based on concatenation result. if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_number(nums): Returns the largest numerical value that can be obtained from concatenating the integers in nums. # Convert all numbers to strings nums = list(map(str, nums)) # Sort the array with custom comparator nums.sort(key=cmp_to_key(compare)) # Concatenate sorted array result = \\"\\".join(nums) # To handle the case where the input is all zeros, we strip leading zeros and return a single \'0\' return result.lstrip(\'0\') or \'0\'"},{"question":"You are given an `n x n` 2D array representing a grid of integers where each cell can either have a value of `0` (empty cell) or `1` (block cell). You need to calculate the number of distinct paths from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. Implement the `GridPaths` class which contains the following methods: - `GridPaths(int[][] grid)` - Constructs an instance of the class with the given 2D grid integer array `grid`. - `int countPaths()` - Returns the number of distinct paths from the top-left to the bottom-right of the grid. A path is defined as a sequence of moves where each move is either a step down or a step to the right, and you cannot move through cells containing a `1`. Consider implementing a dynamic programming approach to optimize the calculation of distinct paths in larger grids.","solution":"class GridPaths: def __init__(self, grid): Initializes the instance with the provided 2D grid. self.grid = grid self.n = len(grid) self.dp = [[0] * self.n for _ in range(self.n)] def countPaths(self): Returns the number of distinct paths from the top-left to the bottom-right of the grid. if self.grid[0][0] == 1 or self.grid[self.n-1][self.n-1] == 1: return 0 self.dp[0][0] = 1 for i in range(self.n): for j in range(self.n): if self.grid[i][j] == 0: if i > 0: self.dp[i][j] += self.dp[i-1][j] if j > 0: self.dp[i][j] += self.dp[i][j-1] return self.dp[self.n-1][self.n-1]"},{"question":"You are given an integer array `nums` which contains `n` positive integers. You can perform the following operation any number of times: Choose a subarray (a continuous non-empty segment) and, if all the elements of the subarray are even, divide each of them by `2`. Your goal is to minimize the element values in the array. Return _the sum of the array after performing the described operation any number of times._","solution":"def minimize_array_sum(nums): Minimize the element values in the array and return the sum after performing the described operation any number of times. # Dividing all even numbers by 2 until they become odd minimized_nums = [] for num in nums: while num % 2 == 0: num //= 2 minimized_nums.append(num) return sum(minimized_nums) # Example usage: # nums = [8, 3, 6, 10, 5] # Result of minimize_array_sum(nums) would be 3 + 3 + 3 + 5 + 5 = 19"},{"question":"Given a binary tree, populate each `next` pointer to point to its **next right node**. If there is no next right node, the next pointer should be set to `NULL`. Initially, all next pointers are set to `NULL`. Assume the binary tree is a perfect binary tree (i.e., all leaves are at the same level, and every parent has two children). You must solve the problem using **constant extra space**. Return the root of the modified tree.","solution":"class Node: def __init__(self, val: int = 0, left = None, right = None, next = None): self.val = val self.left = left self.right = right self.next = next def connect(root: \'Node\') -> \'Node\': Populates each next pointer to point to its next right node. if not root: return root # We start with the root node leftmost = root # Iterate over each level using the leftmost node while leftmost.left: # Traverse the current level head = leftmost while head: # Connect the children of the current head node head.left.next = head.right # Connect the right child to the next subtree\'s left child if head.next: head.right.next = head.next.left # Move to the next node in the current level head = head.next # Shift to the next level leftmost = leftmost.left return root"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`, and an integer `x` such that `1 <= x <= n`. You need to divide this array into exactly `x` non-overlapping subarrays. Our goal is to minimize the maximum sum among these `x` subarrays. Return _the minimum possible value of the maximum sum of the `x` subarrays_. --- This question maintains consistency with the style, length, and complexity of the provided set, exploring concepts of array manipulation and optimization, similar to topics covered in the previous questions.","solution":"def minimize_max_sum(nums, x): Returns the minimum possible value of the maximum sum of x subarrays. Parameters: nums (List[int]): A zero-indexed integer array of length n. x (int): The number of subarrays to divide the array into. Returns: int: The minimum possible value of the maximum sum among the x subarrays. def can_split(nums, x, max_sum): count = 1 current_sum = 0 for num in nums: current_sum += num if current_sum > max_sum: count += 1 current_sum = num if count > x: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, x, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a matrix `mat` of size `m x n` with values `0` or `1`, where `mat[i][j] = 1` indicates that there is a server (computer) at position `(i, j)` and `mat[i][j] = 0` means there is no server there. Two servers are said to communicate if they are on the same row or on the same column. Return _the number of servers that can communicate with at least one other server._","solution":"def countServers(grid): Returns the number of servers that can communicate with at least one other server. Parameters: grid (List[List[int]]): The matrix representing servers and their positions. Returns: int: The number of servers that can communicate with at least one other server. m, n = len(grid), len(grid[0]) row_count = [0] * m col_count = [0] * n # Count the number of servers in each row and column for i in range(m): for j in range(n): if grid[i][j] == 1: row_count[i] += 1 col_count[j] += 1 # Find how many servers can communicate with at least one other server count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and (row_count[i] > 1 or col_count[j] > 1): count += 1 return count"},{"question":"You are given a binary tree where each node contains an integer value. Determine the length of the longest path which is a sequence of nodes such that every node in the sequence has the same value. The path may or may not pass through the root. This path is not necessarily a straight path, but can bend at any node. Return the length of this path in terms of the number of nodes it contains.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root): Finds the length of the longest path in the binary tree where every node in the path has the same value. :param root: TreeNode, the root of the binary tree :return: int, the length of the longest univalue path def dfs(node): nonlocal longest_path if not node: return 0 left_length = dfs(node.left) right_length = dfs(node.right) left_arrow = right_arrow = 0 if node.left and node.left.val == node.val: left_arrow = left_length + 1 if node.right and node.right.val == node.val: right_arrow = right_length + 1 longest_path = max(longest_path, left_arrow + right_arrow) return max(left_arrow, right_arrow) longest_path = 0 dfs(root) return longest_path"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. A **subarray** is a contiguous non-empty sequence of elements from `arr`. The product of a subarray is the result of multiplying all its elements. * For example, the product of the subarray `[2, 3, 4]` is `2 * 3 * 4 = 24`. You need to find the maximum product of any subarray of `arr` that has exactly `k` elements. If there is no such subarray, return `-1`. Return _the maximum product of any subarray of `arr` with `k` elements, or `-1` if it does not exist_.","solution":"def max_product_subarray(arr, k): n = len(arr) if k > n: return -1 max_product = float(\'-inf\') for i in range(n - k + 1): product = 1 for j in range(k): product *= arr[i + j] max_product = max(max_product, product) return max_product"},{"question":"You are given a list of non-negative integers `nums` representing the histogram\'s bar height where the width of each bar is `1`. Find the area of the largest rectangle in the histogram. **Example:** ``` Input: nums = [2, 1, 5, 6, 2, 3] Output: 10 ``` **Explanation:** The largest rectangle has height 2 and width 5, giving an area of 10.","solution":"def largest_rectangle_area(nums): Finds the area of the largest rectangle in the histogram. Args: nums (List[int]): A list of non-negative integers representing the histogram\'s bar height. Returns: int: The area of the largest rectangle in the histogram. stack = [] max_area = 0 index = 0 while index < len(nums): if not stack or nums[stack[-1]] <= nums[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house, and you need to determine the maximum amount of money you can rob tonight without alerting the police. Each house is indexed with a unique number and you cannot rob two adjacent houses. Implement a function `rob(nums)` that returns the maximum amount of money you can rob. Your algorithm should take into account all possible scenarios, ensuring you achieve the maximum outcome.","solution":"def rob(nums): Returns the maximum amount of money you can rob tonight without alerting the police. Args: nums (list): A list of non-negative integers representing the amount of money of each house. Returns: int: The maximum amount of money you can rob. if not nums: return 0 elif len(nums) == 1: return nums[0] # Dynamic programming array to store the maximum amount robbed up to each house. dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given an array `nums` consisting of n positive integers. Construct a new array `result` where `result[i]` is equal to the product of all the elements of `nums` except `nums[i]`. Return the `result` array. Note: You should solve this problem without using division.","solution":"def product_except_self(nums): Returns an array where each element i is the product of all elements except nums[i]. n = len(nums) result = [1] * n # Calculate the products of elements before the current element left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Calculate the products of elements after the current element right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"A string is considered a **palindromic substring** if it reads the same backward as forward. Given a string `s`, return the **number of palindromic substrings** in `s`. A **substring** is a contiguous sequence of characters within the string. For example, for a given string `\\"abc\\"`: - The substrings are `\\"a\\"`, `\\"b\\"`, `\\"c\\"`, `\\"ab\\"`, `\\"bc\\"`, and `\\"abc\\"`. - Out of these, the palindromic substrings are `\\"a\\"`, `\\"b\\"`, and `\\"c\\"`. Similarly, for the input `\\"aaa\\"`, the palindromic substrings would be `\\"a\\"`, `\\"a\\"`, `\\"a\\"`, `\\"aa\\"`, `\\"aa\\"`, and `\\"aaa\\"`, resulting in a total of 6.","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string `s`. n = len(s) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Expand around one single center (odd-length palindromes) expand_around_center(i, i) # Expand around two adjacent centers (even-length palindromes) expand_around_center(i, i + 1) return count"},{"question":"You are given a `k`-keys keyboard and two integers `n` and `k`. Initially, the keyboard has `k` keys with each key mapped to a unique letter from `a` to the `k-th` letter of the alphabet in sorted order. You want to generate all possible strings of length `n` that can be typed using this keyboard. Write a function that returns a list of all possible strings of length `n` that can be formed using the first `k` letters of the alphabet. The output strings should be sorted in lexicographical order. Return _the list of all possible strings._","solution":"def generate_strings(n, k): Generate all possible strings of length n using the first k letters of the alphabet. Args: n (int): Length of the strings. k (int): Number of keys corresponding to first k letters of the alphabet. Returns: List[str]: A list of all possible strings of length n. from itertools import product letters = [chr(i) for i in range(ord(\'a\'), ord(\'a\') + k)] return [\'\'.join(p) for p in product(letters, repeat=n)]"},{"question":"You are given a string `s` representing a sentence containing words separated by spaces. The sentence may also contain punctuations (`.` and `,`). Your task is to return the length of the longest word in the sentence. A word is defined as a maximal substring consisting of English letters only. For example, given `s = \\"Hello, world! This is a test.\\"`, the output should be `5` because \\"Hello\\" and \\"world \\"are the longest words in the sentence, each with a length of 5.","solution":"import re def longest_word_length(s): Returns the length of the longest word in the sentence `s`. A word is defined as a maximal substring consisting of English letters only. words = re.findall(r\'b[A-Za-z]+b\', s) if not words: return 0 return max(len(word) for word in words)"},{"question":"You are given a list of `coins` where each element represents a coin with a specific value, and a target amount `amount`. Your goal is to determine the **fewest number of coins** that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`. Write a function `coinChange(coins, amount)` that takes an array `coins` and an integer `amount`, and returns the minimum number of coins needed to make up the `amount`.","solution":"def coinChange(coins, amount): Determine the fewest number of coins needed to make up the given amount. If that amount cannot be made up by any combination of the coins, return -1. # Initialize dp array where the value at each index represents the fewest # number of coins needed to make up that amount. dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"You are given an array `nums` consisting of `n` non-negative integers. Each element represents the maximum length you can jump forward from that position. Your task is to determine if you can reach the last index starting from the first index. Return `true` if you can reach the last index, or `false` otherwise. * For example, given `nums = [2,3,1,1,4]`, you can jump to the last index by jumping `2` positions to index `1`, then `3` positions to the last index. * Given `nums = [3,2,1,0,4]`, you will eventually reach the element with a jump length `0` before the last index, making it impossible to reach the last index. Hence, return `false`.","solution":"def can_jump(nums): Determine whether you can reach the last index starting from the first index. Parameters: nums (List[int]): An array of non-negative integers representing the maximum length of jump at each position. Returns: bool: True if you can reach the last index, False otherwise. max_reachable = 0 for i, jump in enumerate(nums): if i > max_reachable: return False max_reachable = max(max_reachable, i + jump) return max_reachable >= len(nums) - 1"},{"question":"You are given an array of non-overlapping integers, `nums`, sorted in ascending order, representing the positions where houses are located along a street. A new gas station is to be built such that it minimizes the maximum distance to any house in `nums`. Return the optimal location for the gas station so that the maximum distance to any house is minimized. The gas station can be built at any real number along the street, not necessarily at an integer position.","solution":"def find_optimal_gas_station_location(nums): Returns the optimal location for the gas station to minimize the maximum distance to any house. Parameters: nums (list): A list of non-overlapping, sorted integers representing house positions. Returns: float: The optimal location for the gas station. if not nums: return 0.0 n = len(nums) # If there\'s only one house, the best place is at the house if n == 1: return float(nums[0]) max_distance = 0.0 optimal_location = 0.0 for i in range(n - 1): midpoint = (nums[i] + nums[i + 1]) / 2.0 distance = (nums[i + 1] - nums[i]) / 2.0 if distance > max_distance: max_distance = distance optimal_location = midpoint return optimal_location"},{"question":"Given the `root` of a binary tree, design an algorithm that flattens the binary tree into a \\"linked list\\": - The \\"linked list\\" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `None`. - The \\"linked list\\" should be in the same order as a **pre-order traversal** of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flattens the binary tree into a \\"linked list\\" in the pre-order traversal order. if not root: return stack = [root] prev = None while stack: curr = stack.pop() if prev: prev.right = curr prev.left = None if curr.right: stack.append(curr.right) if curr.left: stack.append(curr.left) prev = curr"},{"question":"Given an array of integers `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array. You must solve this in **O(n)** time complexity using **constant extra space**.","solution":"def missing_number(nums): Returns the missing number from the array of distinct numbers in the range [0, n]. n = len(nums) expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"You are given two strings, `s1` and `s2`, which may be of different lengths. A string `t` is called a **subsequence** of a string `s` if `t` can be derived from `s` by deleting some or no characters without changing the order of the remaining characters. Determine if `s1` is a subsequence of `s2`. If `s1` is a subsequence of `s2`, return **true**; otherwise, return **false**. * For example, given `s1 = \\"abc\\"` and `s2 = \\"ahbgdc\\"`, `s1` is a subsequence of `s2`. However, if `s1 = \\"axc\\"` and `s2 = \\"ahbgdc\\"`, `s1` is not a subsequence of `s2`.","solution":"def is_subsequence(s1, s2): Determine if s1 is a subsequence of s2. it = iter(s2) return all(char in it for char in s1)"},{"question":"Suppose you have a string `s` of lowercase English letters. You need to perform the following operation repeatedly until the string becomes empty: Choose any two adjacent characters that are the same and delete them. You need to determine the minimum possible length of the string after performing the above operations as many times as possible. Write a function that returns this minimum possible length.","solution":"def min_possible_length(s): Returns the minimum possible length of the string after performing the operation repeatedly: Choose any two adjacent characters that are the same and delete them. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"Implement a data structure that supports the following operations efficiently: insert, delete, search, and getRandom. The data structure should handle a dynamic set of unique integers. Implement the `RandomizedSet` class: * `RandomizedSet()` Initializes the data structure. * `bool insert(int val)` Inserts the item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise. * `bool remove(int val)` Removes the item `val` from the set if present. Returns `true` if the item was present, `false` otherwise. * `int getRandom()` Returns a random element from the set. Each element must have the same probability of being returned. The test cases are generated such that the operations and calls to `getRandom()` are made in a valid sequence with only valid values being passed to the functions.","solution":"import random class RandomizedSet: def __init__(self): Initializes the data structure. self.data = [] self.index_map = {} def insert(self, val: int) -> bool: Inserts the item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise. if val in self.index_map: return False # Store index of the inserted value self.index_map[val] = len(self.data) self.data.append(val) return True def remove(self, val: int) -> bool: Removes the item `val` from the set if present. Returns `true` if the item was present, `false` otherwise. if val not in self.index_map: return False # Swap the value with the last value in the list last_val = self.data[-1] val_index = self.index_map[val] self.data[val_index] = last_val self.index_map[last_val] = val_index # Remove the last value from the array self.data.pop() del self.index_map[val] return True def getRandom(self) -> int: Returns a random element from the set. Each element must have the same probability of being returned. return random.choice(self.data)"},{"question":"You are given a list of strings `parkings` where each string represents a parking event in the format `\\"HH:MM-HH:MM\\"`, indicating the start and end times of the parking event within a 24-hour period. Each parking event is considered valid if the start time is strictly earlier than the end time and both times lie within the same day. Your task is to calculate the total free parking time available over the course of the day (00:00-24:00), assuming no overlaps in parking events. Return the total free time in minutes as an integer.","solution":"from datetime import datetime def calculate_free_parking_time(parkings): Calculate the total free parking time in minutes given a list of parking events. Args: parkings (list): List of strings, each in the format \\"HH:MM-HH:MM\\" representing parking events. Returns: int: Total free parking time in minutes. # Helper function to convert time string to minutes from start of day. def time_to_minutes(t): h, m = map(int, t.split(\':\')) return h * 60 + m all_day_minutes = 24 * 60 # Total minutes in a day total_occupied_minutes = 0 for event in parkings: start, end = event.split(\'-\') start_minutes = time_to_minutes(start) end_minutes = time_to_minutes(end) # Validate the event if start_minutes < end_minutes: total_occupied_minutes += (end_minutes - start_minutes) total_free_parking_time = all_day_minutes - total_occupied_minutes return total_free_parking_time"},{"question":"You are given a list of integers `nums`, where the length of the list is `n`. Your task is to find _the **length of the longest subsequence**_ such that all elements of the subsequence are strictly increasing. A subsequence is derived from the list `nums` by deleting some or no elements without changing the order of the remaining elements. Replace `n` with the length of `nums`.","solution":"def length_of_lis(nums): Returns the length of the longest strictly increasing subsequence in nums. Parameters: nums (list): A list of integers. Returns: int: Length of the longest strictly increasing subsequence. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a list of strings `patterns` and a single string `s`. A string is considered a subsequence of another string if it can be derived from the other string by deleting some characters without changing the order of the remaining characters. Your task is to determine how many strings in `patterns` are subsequences of `s`. Return _the **number** of strings in `patterns` that are subsequences of `s`_.","solution":"def is_subsequence(small, large): it = iter(large) return all(char in it for char in small) def count_subsequences(patterns, s): count = 0 for pattern in patterns: if is_subsequence(pattern, s): count += 1 return count"},{"question":"Given a string `sequence`, find the minimum number of operations required to make every character in the string unique. In one operation, you can choose any character from `sequence` and replace it with any uppercase English letter that is not already present in the `sequence`. Return an integer representing the minimum number of operations required.","solution":"def min_operations_to_unique(sequence): Given a string `sequence`, find the minimum number of operations required to make every character in the string unique. Args: - sequence (str): The input string where we need to make each character unique. Returns: - int: The minimum number of operations required. from collections import Counter # Count the frequency of each character in the input string frequency = Counter(sequence) # List of characters that we can use to replace duplicates available_chars = set(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") # Remove already present characters from the available characters list for char in sequence: if char in available_chars: available_chars.remove(char) operations = 0 for char, count in frequency.items(): # If there are duplicates while count > 1: operations += 1 count -= 1 # Replace one occurence of the character with an available character # Remove one character from the available set if available_chars: available_chars.pop() return operations"},{"question":"You are given an integer array `nums` and you need to determine if it can be split into two contiguous subarrays such that the sum of the elements in the first subarray is equal to the sum of the elements in the second subarray. Return _true if such a split is possible, and false otherwise._","solution":"def can_split_array(nums): Determine if the given array can be split into two contiguous subarrays with equal sums. Parameters: nums (list of int): The input array of integers. Returns: bool: True if such a split is possible, False otherwise. total_sum = sum(nums) if total_sum % 2 != 0: return False left_sum = 0 target = total_sum // 2 for num in nums: left_sum += num if left_sum == target: return True elif left_sum > target: return False return False"},{"question":"You are given a binary tree where each node contains an integer value. Write a function to determine if the tree is a \\"Sum Tree\\". A Sum Tree is a binary tree where the value of each node is equal to the sum of the values of its left and right subtrees. An empty tree and a single node tree are considered Sum Trees. Your function should return `true` if the given binary tree is a Sum Tree, and `false` otherwise.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_sum_tree(root): Determines if a binary tree is a Sum Tree. :param root: TreeNode - The root of the binary tree. :return: bool - True if the binary tree is a Sum Tree, False otherwise. def sum_tree_and_sum(node): if node is None: return (True, 0) if node.left is None and node.right is None: return (True, node.value) left_sum_tree, left_sum = sum_tree_and_sum(node.left) right_sum_tree, right_sum = sum_tree_and_sum(node.right) is_current_sum_tree = (node.value == left_sum + right_sum) return (left_sum_tree and right_sum_tree and is_current_sum_tree, node.value + left_sum + right_sum) is_tree_sum, _ = sum_tree_and_sum(root) return is_tree_sum"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. Design an algorithm to partition the list into `k` contiguous subarrays such that the total sum of the maximum sums of each subarray is minimized. Implement the `Solution` class: * `Solution()` Initializes the object. * `int splitArray(int[] nums, int k)` Returns the minimized maximum sum of the subarrays. For example: Input: `nums = [7, 2, 5, 10, 8]`, `k = 2` Output: `18` Explanation: Possible partitions are `[7, 2, 5]`, `[10, 8]` or `[7, 2]`, `[5, 10, 8]`. The maximum sums of the partitions are `[14, 18]` or `[9, 18]`, respectively. The minimized maximum sum is `18`.","solution":"class Solution: def splitArray(self, nums, k): Returns the minimized maximum sum of the subarrays. def can_split(nums, k, mid): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num > mid: current_sum = num required_subarrays += 1 if required_subarrays > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"A busy mall is trying to optimize foot traffic near its main entrance. There are `n` stores aligned in a row, each represented by a certain number of customers entering the mall through that store. You are given an integer array `foot_traffic`, where `foot_traffic[i]` indicates the number of customers entering from the `i-th` store. Additionally, you need to consider `k` special days when a particular event at the mall shifts extra `x` customers to every store simultaneously. Determine _the maximum number of total customers entering the mall during any of the given days, including the special event days._ Note: - Each store has its own entrance and the special event causes an equal increase in customers for all stores. - You can assume the special days happen exactly `k` times and always affect all stores the same way. For example, if `n = 4`, `foot_traffic = [5,8,3,6]`, `k = 2`, and `x = 4`, the output would be the maximum number of customers entering the mall on any such special day considering the given `k` special days.","solution":"def max_total_customers(foot_traffic, k, x): Returns the maximum total number of customers entering the mall on any day, considering the special event days. Parameters: - foot_traffic (list of int): Number of customers entering from each store on a regular day. - k (int): Number of special days with extra customers. - x (int): Number of extra customers on special days per store. Returns: - int: Maximum total number of customers entering the mall on any given day. regular_day_total = sum(foot_traffic) increase_per_day = x * len(foot_traffic) max_customers_on_special_day = regular_day_total + k * increase_per_day return max_customers_on_special_day"},{"question":"A valid parentheses string is a string that follows the rules: - An empty string \\"\\" is valid. - If \\"X\\" and \\"Y\\" are valid, then \\"XY\\" is valid. - If \\"X\\" is valid, then \\"(X)\\" is valid. Given a string comprising only \'(\' and \')\', determine the length of the longest valid parentheses substring. Write a function that takes this string as input and returns the length of this substring.","solution":"def longest_valid_parentheses(s): This function returns the length of the longest valid parentheses substring. :param s: String comprising only \'(\' and \')\' :return: Length of the longest valid parentheses substring n = len(s) stack = [] max_length = 0 last_invalid_index = -1 for i in range(n): if s[i] == \'(\': stack.append(i) else: # s[i] == \')\' if stack: stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: max_length = max(max_length, i - last_invalid_index) else: last_invalid_index = i return max_length"},{"question":"A railway network consists of `n` stations numbered from `0` to `n-1`. You are given a 2-dimensional array `distances` where `distances[i][j]` is the time it takes to travel directly between stations `i` and `j`. If there is no direct train between stations `i` and `j`, then `distances[i][j]` is `-1`. Write a function that takes the `distances` array and returns a 2-dimensional array `shortestPaths` such that `shortestPaths[i][j]` contains the shortest travel time between stations `i` and `j`. If there is no possible route between stations `i` and `j`, the value should remain `-1`. You may assume that the direct travel times between stations are non-negative.","solution":"def floyd_warshall(distances): Applies the Floyd-Warshall algorithm to find the shortest paths between each pair of stations. Parameters: distances (List[List[int]]): 2D array representing the direct travel times between stations Returns: List[List[int]]: 2D array where shortestPaths[i][j] is the shortest travel time between stations i and j n = len(distances) shortestPaths = [[float(\'inf\')] * n for _ in range(n)] for i in range(n): for j in range(n): if i == j: shortestPaths[i][j] = 0 elif distances[i][j] != -1: shortestPaths[i][j] = distances[i][j] for k in range(n): for i in range(n): for j in range(n): if shortestPaths[i][k] != float(\'inf\') and shortestPaths[k][j] != float(\'inf\'): shortestPaths[i][j] = min(shortestPaths[i][j], shortestPaths[i][k] + shortestPaths[k][j]) for i in range(n): for j in range(n): if shortestPaths[i][j] == float(\'inf\'): shortestPaths[i][j] = -1 return shortestPaths"},{"question":"You are given an array `tasks`, where `tasks[i]` represents the time required to complete the `i-th` task, and an integer `k` which represents the maximum number of workers available. Return _the minimum amount of time needed to complete all tasks if each worker can work on exactly one task at a time._ Note that a worker cannot start a new task until the current one is finished, and all tasks start at the same time.","solution":"def minimum_time(tasks, k): Returns the minimum amount of time needed to complete all tasks using up to k workers. Tasks array holds times needed to complete each task. Each worker can handle exactly one task at a time. All tasks start simultaneously. if not tasks: return 0 if k <= 0: raise ValueError(\\"Number of workers must be a positive integer.\\") tasks.sort(reverse=True) workers = [0] * min(k, len(tasks)) for task in tasks: workers[0] += task workers.sort() return max(workers)"},{"question":"You are given a list of integers representing the heights of buildings as they appear in a straight line. Each element in the list represents the height of a building at that specific position. Two buildings can form a container with the line segment connecting them. The container will hold water up to the height of the shorter building. Find the maximum amount of water a container can store between these buildings. Return the _**maximum volume of water** that can be stored_.","solution":"def max_area(height): Returns the maximum volume of water that can be stored between the buildings. :param height: List[int] - list representing the heights of buildings :return: int - maximum volume of water that can be stored left, right = 0, len(height) - 1 max_vol = 0 while left < right: width = right - left current_height = min(height[left], height[right]) current_vol = width * current_height max_vol = max(max_vol, current_vol) if height[left] < height[right]: left += 1 else: right -= 1 return max_vol"},{"question":"You are given a list of `n` integers representing building heights. An integer `k` indicates the maximum number of jumps you can make. You start at the first building (index 0) and want to reach the last building (index n-1). From any building at index `i`, you can choose to jump to any building at index `j` (i < j <= i + k) given that you can only jump to a building of equal or greater height. Return _the minimum number of jumps needed to reach the last building of the array, or_ `-1` _if it is not possible_.","solution":"from collections import deque def min_jumps_to_reach_end(buildings, k): Given a list of building heights and the maximum number of jumps allowed, returns the minimum number of jumps needed to reach the last building. Returns -1 if it is not possible to reach the end. :param buildings: List[int] - array of building heights :param k: int - maximum number of jumps allowed :return: int - minimum number of jumps to reach the end or -1 if not possible n = len(buildings) if n == 1: return 0 jumps = [float(\'inf\')] * n jumps[0] = 0 queue = deque([0]) while queue: i = queue.popleft() for j in range(i + 1, min(i + k + 1, n)): if buildings[j] >= buildings[i] and jumps[j] > jumps[i] + 1: jumps[j] = jumps[i] + 1 if j == n - 1: return jumps[j] queue.append(j) return -1"},{"question":"A company manages its project schedule using a dependency tree where each project depends on one or more other projects. You are given an integer `n` representing the total number of projects, and an array `dependencies` where each element is a tuple `(a, b)` indicating that project `b` depends on project `a` (i.e., project `b` cannot start until project `a` is completed). Your task is to determine the shortest time in days to complete all the projects, given that each project takes exactly one day to complete and multiple projects can be worked on simultaneously as long as their dependencies are met. If it is not possible to complete all the projects due to a circular dependency, return `-1`.","solution":"from collections import defaultdict, deque def find_order(n, dependencies): Determines the shortest time in days to complete all the projects, or returns -1 if it is not possible due to a circular dependency. :param n: int - Total number of projects :param dependencies: List[Tuple[int, int]] - List of dependencies where project b depends on project a :return: int - Shortest time in days to complete all projects, or -1 if there is a circular dependency indegree = defaultdict(int) graph = defaultdict(list) # Building the graph and calculating in-degrees for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Initialize queue with nodes that have zero in-degree queue = deque([i for i in range(n) if indegree[i] == 0]) completed_projects = 0 days = 0 while queue: days += 1 # Number of projects that can be done on the same day for _ in range(len(queue)): project = queue.popleft() completed_projects += 1 for dependent in graph[project]: indegree[dependent] -= 1 if indegree[dependent] == 0: queue.append(dependent) return days if completed_projects == n else -1"},{"question":"Given an integer n, return _all distinct combinations of n numbers where each number is between 1 and 9 inclusive, and the sum of these combinations equals n_. Each combination should be a list of numbers `[a1, a2, ..., ak]` which are in non-descending order and contain no duplicate combinations. Example: ``` Input: n = 7 Output: [[1, 1, 5], [1, 2, 4], [1, 6], [2, 2, 3], [2, 5], [3, 4], [7]] ``` Note: - All numbers in the combination should be in the range of `1` to `9`.","solution":"def find_combinations(n): Find all distinct combinations of numbers that add up to n, where each number is between 1 and 9. def backtrack(target, start, path, res): if target == 0: res.append(path) return for i in range(start, 10): if i > target: break backtrack(target - i, i, path + [i], res) result = [] backtrack(n, 1, [], result) return result"},{"question":"You are given a string `s` consisting of lowercase English letters. You can choose a set of **non-overlapping substrings** from `s` and replace each substring with any of its permutations. Determine the lexicographically smallest string that can be obtained after performing the replacements. Return the modified string. A **substring** is a contiguous sequence of characters within a string. Two substrings are **non-overlapping** if there exists no index that belongs to both substrings.","solution":"def smallest_lexicographic_string(s: str) -> str: This function returns the lexicographically smallest string that can be obtained by replacing non-overlapping substrings with any of their permutations. Since all individual substrings can be replaced with any permutation, the smallest possible result is the sorted version of the entire string. return \'\'.join(sorted(s))"},{"question":"You are asked to design a data structure that supports adding historical price values and efficiently returning moving averages over a specified window size in real-time. Implement the `MovingAverage` class: - `MovingAverage(int size)` Initializes the object with the size of the moving window. - `void add(int value)` Adds a new price value. - `double getAverage()` Returns the current moving average of the added values within the window size. The `getAverage` method should return the average of the last `size` values (or fewer if there are not yet `size` values). Efficient implementation is expected for adding new values and computing the moving average. Example: - MovingAverage m = new MovingAverage(3); - m.add(1); - m.add(10); - m.add(3); - m.add(5); m.getAverage() should return 6.0 (the average of 10, 3, and 5).","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initializes the object with the size of the moving window. self.size = size self.window = deque() self.window_sum = 0 def add(self, value: int): Adds a new price value. if len(self.window) == self.size: self.window_sum -= self.window.popleft() self.window.append(value) self.window_sum += value def getAverage(self) -> float: Returns the current moving average of the added values within the window size. if not self.window: return 0 return self.window_sum / len(self.window)"},{"question":"You are given a singly linked list where each node contains an integer value. Design a class `UniqueLinkedList` that supports the following operations: * `UniqueLinkedList()` Initializes the linked list object. * `void add(int value)` Adds a new node with the given value to the end of the linked list. If the value already exists in the linked list, do not add it. * `boolean remove(int value)` Removes the node with the given value from the linked list. Returns `true` if the node was successfully removed, otherwise returns `false`. * `boolean contains(int value)` Checks whether the linked list contains a node with the given value. Returns `true` if such a node exists, otherwise returns `false`. * `List<Integer> getAllElements()` Returns all the values in the linked list as a list. Implementing these operations should ensure efficient handling of the unique constraints on node values in the linked list.","solution":"class UniqueLinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None self.value_set = set() def add(self, value): if value in self.value_set: return new_node = self.Node(value) self.value_set.add(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def remove(self, value): if value not in self.value_set: return False self.value_set.remove(value) current = self.head prev = None while current: if current.value == value: if prev: prev.next = current.next else: self.head = current.next return True prev = current current = current.next return False def contains(self, value): return value in self.value_set def getAllElements(self): elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"Given an array of integers `nums`, write a function that returns the longest increasing subsequence present in the array. The longest increasing subsequence is defined as a sequence of numbers from the array where each number is greater than the previous one and they appear in the same order as they do in the array. Your solution should have a time complexity of O(n log n).","solution":"from bisect import bisect_left def longest_increasing_subsequence(nums): Returns the longest increasing subsequence from the array nums. if not nums: return [] lis = [] for num in nums: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return lis"},{"question":"You are given an array of integers `satisfactions` where `satisfactions[i]` represents the satisfaction level of preparing the `i`-th dish. You want to prepare a meal by selecting and arranging some of the dishes to maximize the total satisfaction. The total satisfaction of a meal is calculated by summing the satisfaction of each selected dish, weighted by its position in the meal, starting from 1. In other words, if you choose `m` dishes and arrange them in some order, the total satisfaction is `satisfaction[1] * 1 + satisfaction[2] * 2 + ... + satisfaction[m] * m`. Return the maximum possible total satisfaction you can achieve by selecting and arranging the dishes.","solution":"def max_satisfaction(satisfactions): Return the maximum possible total satisfaction by selecting and arranging some of the dishes. satisfactions.sort(reverse=True) max_satisfaction, current_sum, total = 0, 0, 0 for satisfaction in satisfactions: if current_sum + satisfaction > 0: current_sum += satisfaction total += current_sum max_satisfaction = max(max_satisfaction, total) else: break return max_satisfaction"},{"question":"Given a string `s` which represents a sentence, and an integer `k`, write a function to return the length of the longest substring of `s` that contains at most `k` distinct characters.","solution":"def longest_substring_with_k_distinct_chars(s, k): Returns the length of the longest substring that contains at most k distinct characters. if k == 0: return 0 n = len(s) left = 0 right = 0 max_len = 0 char_count = {} while right < n: char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given an `m x n` grid consisting of non-negative integers representing the number of coins located at each cell. You have one robot, and its task is to collect as many coins as possible without revisiting any cell. The robot can move to neighboring cells to the right or down from each cell. Write a program to find the maximum number of coins that the robot can collect. You are required to return the maximum number of coins collected by the robot starting from the top-left cell `(0, 0)` to the bottom-right cell `(m-1, n-1)`.","solution":"def max_coins(grid): This function computes the maximum number of coins that can be collected by a robot moving from the top-left corner to the bottom-right corner of a grid. The robot can only move right or down. Parameters: grid (List[List[int]]): A 2D list where each entry represents the coins in a cell. Returns: int: The maximum number of coins that can be collected. m, n = len(grid), len(grid[0]) # Create a 2D dp array dp = [[0]*n for _ in range(m)] # Initialize the dp array with the coins in the first cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum coins that can be collected return dp[m-1][n-1]"},{"question":"Given an integer array `arr` of length `n`, return an array `result` of the same length where `result[i]` is the length of the longest subsequence ending at index `i`, such that every element in the subsequence is larger than its predecessor. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, given the array `arr = [4, 1, 2, 3, 5]`, the function would return `[1, 1, 2, 3, 4]`.","solution":"def longest_subsequence_lengths(arr): Returns an array `result` where result[i] is the length of the longest subsequence ending at index `i`. n = len(arr) result = [1] * n # Minimum length of subsequence is 1 (the element itself) for i in range(1, n): for j in range(i): if arr[i] > arr[j]: result[i] = max(result[i], result[j] + 1) return result"},{"question":"You are given a **0-indexed** integer array `nums` of length `m`. Your task is to transform `nums` in such a way that for each element at every **even index** in the array, it is greater than its **neighboring odd index elements**. If there are multiple possible solutions, return any one of them. If no such transformation is possible, return an empty array. Write a function to transform the array as described.","solution":"def transform_array(nums): Transforms the array such that for each element at every even index, it is greater than its neighboring odd index elements. Parameters: nums (list): The input list of integers Returns: list: A transformed list meeting the criteria or an empty list if no such transformation is possible. if not nums: return [] m = len(nums) for i in range(0, m, 2): if i > 0 and nums[i] <= nums[i - 1]: nums[i], nums[i - 1] = nums[i - 1], nums[i] if i < m - 1 and nums[i] <= nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] for i in range(0, m, 2): if (i > 0 and nums[i] <= nums[i - 1]) or (i < m - 1 and nums[i] <= nums[i + 1]): return [] return nums"},{"question":"Given an integer array `nums` and an integer `target`, return an array of all the **unique** combinations of numbers in `nums` where the numbers sum to `target`. You may return the combinations in any order. Note: - Each number in `nums` can be used an unlimited number of times. - The solution set must not contain duplicate combinations. **Example 1:** **Input:** nums = [2,3,6,7], target = 7 **Output:** [[2,2,3],[7]] **Explanation:** The combination [2,2,3] can be used to get 7. The combination [7] can also be used to get 7. **Example 2:** **Input:** nums = [2,3,5], target = 8 **Output:** [[2,2,2,2],[2,3,3],[3,5]] **Example 3:** **Input:** nums = [2], target = 1 **Output:** [] **Explanation:** There is no combination that adds up to 1. **Constraints:** - `1 <= nums.length <= 30` - `1 <= nums[i] <= 200` - All elements of `nums` are distinct. - `1 <= target <= 500`","solution":"def combinationSum(nums, target): def backtrack(remain, path, start): if remain == 0: result.append(list(path)) return elif remain < 0: return for i in range(start, len(nums)): # include the number into the combination path.append(nums[i]) # give the current number another chance, since we can use them unlimited times backtrack(remain - nums[i], path, i) # backtrack, remove the number from the combination path.pop() nums.sort() result = [] backtrack(target, [], 0) return result"},{"question":"You are given a list of `n` strings, `words`, where each string is of the same length. You need to arrange all the strings into a single chain such that each word is connected to the next by exactly one character (the last character of the current word matches the first character of the next word). Return _any such sequence of words_. If there is no such sequence, return an empty list. For example, given words = [\\"cat\\", \\"tap\\", \\"pat\\"], one of the possible sequences is [\\"cat\\", \\"tap\\", \\"pat\\"]. The inputs are guaranteed to have at least one possible valid chain.","solution":"def form_chain(words): Forms a chain from words where the last character of each word matches the first character of the next word. Args: words (list of str): List of strings where each string is of the same length. Returns: list of str: A sequence of words forming the required chain. An empty list if no such sequence exists. Guaranteed to have at least one possible valid chain. def backtrack(chain): if len(chain) == len(words): return chain last_char = chain[-1][-1] for i, word in enumerate(words): if not used[i] and word[0] == last_char: used[i] = True result = backtrack(chain + [word]) if result: return result used[i] = False return [] for start_word in words: used = [False] * len(words) used[words.index(start_word)] = True result = backtrack([start_word]) if result: return result return []"},{"question":"Given a string `s` representing a mathematical expression that includes integers, the operators `+`, `-`, `*`, and `/`, and `(` and `)` for grouping, implement a function to evaluate and return the result of the expression. The integer division should truncate toward zero. The input string is guaranteed to be a valid mathematical expression.","solution":"def evaluate_expression(s): Evaluates a given mathematical expression string. :param s: A string representing a mathematical expression :return: The evaluated result as an integer def calc(it): num = 0 stack = [] sign = \\"+\\" while it < len(s): ch = s[it] if ch.isdigit(): num = num * 10 + int(ch) if ch == \\"(\\": num, j = calc(it + 1) it = j if ch in \\"+-*/)\\" or it == len(s) - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = ch num = 0 if ch == \\")\\": return sum(stack), it it += 1 return sum(stack) return calc(0)"},{"question":"Given an integer array `arr` of length `n` representing the amount of money in each house, determine the maximum amount of money you can steal without stealing from two adjacent houses. You are not allowed to steal from the first and last house simultaneously as they are adjacent in the circular street layout. Return the maximum money you can steal.","solution":"def rob(arr): Returns the maximum amount of money that can be stolen without stealing from two adjacent houses in a circular street layout. if not arr: return 0 n = len(arr) if n == 1: return arr[0] if n == 2: return max(arr) def rob_linear(houses): prev1, prev2 = 0, 0 for amount in houses: temp = prev1 prev1 = max(prev2 + amount, prev1) prev2 = temp return prev1 # Case 1: Rob excluding the first house max1 = rob_linear(arr[1:]) # Case 2: Rob excluding the last house max2 = rob_linear(arr[:-1]) return max(max1, max2)"},{"question":"You are given an array of integers `heights` representing the heights of students in a class. You need to form the minimum number of groups such that the difference between the tallest and the shortest student in each group is at most a given integer `k`. A group can consist of any number of students. Return the minimum number of groups needed to satisfy this condition.","solution":"def min_groups(heights, k): Returns the minimum number of groups needed such that the difference between the tallest and the shortest student in each group is at most k. if not heights: return 0 heights.sort() count = 1 start = heights[0] for height in heights: if height - start > k: count += 1 start = height return count"},{"question":"You are given an integer array `nums` sorted in **non-decreasing order** and an integer `target`. Write a function that finds the starting and ending position of a given `target` value. If `target` is not found in the array, return `[-1, -1]`. You must solve this problem using a binary search algorithm with a runtime complexity of `O(log n)`. For example, given `nums = [5, 7, 7, 8, 8, 10]` and `target = 8`, the function should return `[3, 4]` because `8` first appears at index `3` and last appears at index `4` in the array. If the `target` value `6` is not present, the function should return `[-1, -1]`.","solution":"def search_range(nums, target): Finds the starting and ending position of a given target value in a sorted array. Args: nums - List of integers sorted in non-decreasing order. target - Integer value to find in the array. Returns: A list containing the starting and ending position of the target value, or [-1, -1] if the target is not found. def find_left_index(nums, target): left, right = 0, len(nums) - 1 left_index = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: left_index = mid right = mid - 1 elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left_index def find_right_index(nums, target): left, right = 0, len(nums) - 1 right_index = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: right_index = mid left = mid + 1 elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return right_index left_index = find_left_index(nums, target) right_index = find_right_index(nums, target) return [left_index, right_index] if left_index != -1 else [-1, -1]"},{"question":"You are given a string `s` consisting of lowercase English letters. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \\"ace\\" is a subsequence of \\"abcde\\" while \\"aec\\" is not. Given a string `t`, return the number of distinct subsequences of `s` which equals `t`. The answer can be very large, so return it modulo `10^9 + 7`.","solution":"def numDistinct(s, t): Returns the number of distinct subsequences of s which equals t. mod = 10**9 + 7 m, n = len(s), len(t) if n == 0: return 1 if m == 0: return 0 dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 # An empty t can always be formed. for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"You are given an integer array `nums` of length `n`, where each element is between `1` and `n` inclusive. Some elements may appear more than once, while others may be missing. Your task is to return a list of the numbers that are missing from the array in any order. Implement the function `findMissingNumbers(nums)` that returns the missing numbers in the array. For example, given `nums = [4, 3, 2, 7, 8, 2, 3, 1]`, your function should return `[5, 6]`.","solution":"def findMissingNumbers(nums): Given an integer array nums of length n, where each element is between 1 and n inclusive, return a list of the numbers that are missing from the array. :param nums: List[int] - The input list of integers :return: List[int] - The list of missing numbers n = len(nums) all_numbers = set(range(1, n + 1)) present_numbers = set(nums) missing_numbers = list(all_numbers - present_numbers) return missing_numbers"},{"question":"You are given a **0-indexed** string array `words` and an integer `k`. The string array consists of lowercase English letters and has no duplicate strings. A subsequence of `words` is a sequence that can be derived by deleting some or no elements from `words` without changing the order of the remaining elements. Return _the length of the **longest** subsequence in `words` such that its **total length** of characters is at most_ `k`.","solution":"def longest_subsequence(words, k): Returns the length of the longest subsequence in `words` such that its total length of characters is at most `k`. words.sort(key=len) # Sort words by their lengths in ascending order total_length = 0 subsequence_count = 0 for word in words: word_length = len(word) if total_length + word_length <= k: total_length += word_length subsequence_count += 1 else: break return subsequence_count"},{"question":"Given a 2D integer array `ranges` representing intervals where `ranges[i] = [start_i, end_i]`, determine if it\'s possible to merge all the intervals into a single continuous interval. Return `true` if they can be merged into one continuous interval without any gaps, otherwise return `false`.","solution":"def can_merge_to_single_interval(ranges): Determines if the 2D integer array `ranges` can be merged into a single continuous interval. Args: ranges (list of lists): A list of intervals where each interval is represented as [start, end]. Returns: bool: True if they can be merged into one continuous interval without any gaps, otherwise False. if not ranges: return False # Sort intervals by their start value ranges.sort(key=lambda x: x[0]) # Merge intervals step current_start, current_end = ranges[0][0], ranges[0][1] for start, end in ranges[1:]: # If the start of the next interval is within or touching the current interval if start <= current_end: current_end = max(current_end, end) else: # Found a gap, can\'t be merged to a single interval return False return True"},{"question":"You are given a string `s` consisting only of characters \'a\' and \'b\'. You can perform the following operation on the string any number of times: choose any two different characters at positions `i` and `j` (1-based index) and remove them from the string, where `i < j`. What is the minimum length of the string after performing the operations any number of times? Implement the function `minLengthAfterOperations(s)` that returns the minimum length of the string after performing the operations.","solution":"def minLengthAfterOperations(s): Returns the minimum length of the string after performing the operations. Any two different characters at positions i and j (1-based index) can be removed where i < j. # Count the number of \'a\' and \'b\' characters count_a = s.count(\'a\') count_b = s.count(\'b\') # The minimum length of the string after performing the operations return abs(count_a - count_b)"},{"question":"You are given an array of integers `prices` where `prices[i]` represents the price of a particular item on the `i`-th day. There is also a sliding window of size `k`. Your task is to find, for each day `i`, the maximum price of the items within the sliding window of size `k` that ends on day `i`. Return an array of these maximum prices. Assume that `k` is always greater than 1 and less than or equal to the length of the `prices` array.","solution":"from collections import deque def sliding_window_maximum(prices, k): Returns an array of the maximum prices within a sliding window of size k. :param prices: List of integers representing the prices :param k: Size of the sliding window :returns: List of integers representing the maximum prices within each window # Resultant list to hold the maximum of each sliding window max_prices = [] # Deque to store indices of elements within the current window deq = deque() for i in range(len(prices)): # Remove elements not within the window while deq and deq[0] < i - k + 1: deq.popleft() # Remove elements that are less than the current element while deq and prices[deq[-1]] < prices[i]: deq.pop() # Add current element\'s index deq.append(i) # Add the current window\'s maximum to the result list if i >= k - 1: max_prices.append(prices[deq[0]]) return max_prices"},{"question":"You have a string `s` consisting of lowercase alphabets and a list of words `words` where each word is a substring of `s`. Your task is to find the number of words in the list that can be formed by deleting some (possibly none) characters of `s` without reordering the remaining characters. Return _the **count** of such words_ from the list. **Example:** - Input: `s = \\"abcde\\"`, `words = [\\"a\\", \\"bb\\", \\"acd\\", \\"aces\\"]` - Output: `2` **Explanation:** - \\"a\\", \\"acd\\" can be formed from \\"abcde\\" by deleting some characters. - \\"bb\\" and \\"aces\\" cannot be formed.","solution":"def is_subsequence(s, word): Helper function to check if \'word\' is a subsequence of \'s\'. it = iter(s) return all(char in it for char in word) def count_matching_subsequences(s, words): Returns count of words in \'words\' list that can be formed by deleting some characters of \'s\' without reordering the remaining characters. count = 0 for word in words: if is_subsequence(s, word): count += 1 return count"},{"question":"You are given an array of integers `heights` representing a sequence of buildings where heights[i] denotes the height of the ith building. A building is considered **good** if the buildings to its left all have lesser heights and the buildings to its right all have greater heights. Return _the total number of good buildings_ in the sequence.","solution":"def count_good_buildings(heights): Returns the total number of good buildings in the given sequence of heights. A building is considered good if all buildings to its left are smaller in height and all buildings to its right are larger in height. :param heights: List[int] :return: int n = len(heights) if n == 0: return 0 good_buildings_count = 0 for i in range(n): is_good = True for j in range(i): if heights[j] >= heights[i]: is_good = False break if is_good: for k in range(i + 1, n): if heights[k] <= heights[i]: is_good = False break if is_good: good_buildings_count += 1 return good_buildings_count"},{"question":"You are given two strings, `s` and `t`, consisting of only lowercase English letters. Your task is to determine if `t` is an anagram of `s`, but with the additional constraint that each letter in `t` must come from the consecutive characters of `s` (i.e., `t` must be a contiguous substring of any permutation of `s`). In other words, determine if there exists a contiguous substring of any permutation of `s` that can be rearranged to form `t`. Return `true` if such a substring exists, and `false` otherwise.","solution":"def check_anagram_substring(s, t): Determines if `t` is an anagram of a contiguous substring of any permutation of `s`. from collections import Counter len_s = len(s) len_t = len(t) if len_t > len_s: return False count_t = Counter(t) count_s = Counter(s[:len_t]) if count_s == count_t: return True for i in range(len_t, len_s): count_s[s[i]] += 1 count_s[s[i - len_t]] -= 1 if count_s[s[i - len_t]] == 0: del count_s[s[i - len_t]] if count_s == count_t: return True return False"},{"question":"Given a 2D grid of dimensions m x n and an integer 0 <= k <= min(m, n), return the maximum sum of all possible submatrices of dimension k x k within the grid. A submatrix is defined as a contiguous block of elements in the grid. If the grid has multiple submatrices with the same maximum sum, you may return the sum of any one of them.","solution":"def max_sum_submatrix(grid, k): Finds the maximum sum of all possible submatrices of dimension k x k within the grid. :param grid: List[List[int]] - 2D grid of dimensions m x n :param k: int - dimension of the submatrix :return: int - maximum sum of any k x k submatrix m, n = len(grid), len(grid[0]) if k > min(m, n): return None # k cannot be bigger than the smallest grid dimension max_sum = float(\'-inf\') # Find the sum of all k x k submatrices for i in range(m - k + 1): for j in range(n - k + 1): current_sum = sum(grid[x][y] for x in range(i, i + k) for y in range(j, j + k)) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a string `s` and an integer `n`, rotate the string to the right by `n` characters and return the resulting string. For example, rotating the string \\"hello\\" by 2 positions to the right yields \\"lohel\\".","solution":"def rotate_string(s, n): Rotate the string s to the right by n characters. if not s: return s n = n % len(s) return s[-n:] + s[:-n]"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a row. A building with a height `heights[i]` can see the skyline if there is no taller building to its right. Return _an integer array_ `result` _of all indices of the buildings that can see the skyline_. Ensure the indices are in the order of the original array.","solution":"def skyline_buildings(heights): Given an array of integers \'heights\' representing the heights of buildings in a row, returns an integer array \'result\' of all indices of the buildings that can see the skyline. result = [] max_height = float(\'-inf\') # Traverse the buildings from right to left for i in range(len(heights) - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] # Return result in the original order of buildings return list(reversed(result))"},{"question":"You are given a list of `n` intervals represented by a 2D list `intervals`, where each interval is defined as `[start_i, end_i]`, and two integers `a` and `b`. A point `x` is said to be covered by an interval `[start_i, end_i]` if `start_i <= x <= end_i`. The range `[a, b]` is fully covered if every point `x` in the range `[a, b]` is covered by at least one interval from the list `intervals`. Return _`True` if the range `[a, b]` is fully covered, and `False` otherwise._","solution":"def is_range_covered(intervals, a, b): covered = [False] * (b - a + 1) for start, end in intervals: for i in range(max(start, a), min(end, b) + 1): covered[i - a] = True return all(covered)"},{"question":"You are given an array of integers `heights` representing the height of buildings in a line. You are also given an integer `x`, where `x` indicates the maximum number of adjacent buildings that can be painted in one stroke. You need to find the minimum number of strokes required to paint all the buildings. Note that you can only paint `x` adjacent buildings in a single stroke each time. Return _the minimum number of strokes needed_.","solution":"def min_strokes(heights, x): Returns the minimum number of strokes required to paint all buildings. Parameters: heights (list of int): A list representing the heights of buildings. x (int): Maximum number of adjacent buildings that can be painted in one stroke. Returns: int: Minimum number of strokes needed. n = len(heights) # If no buildings, return 0 strokes needed. if n == 0: return 0 # Minimum strokes required to paint all buildings. min_strokes_required = (n + x - 1) // x return min_strokes_required"},{"question":"Given an `m x n` binary matrix `mat`, return _the **number of submatrices** that have all 1\'s_. A submatrix is any `m1 x n1` matrix within the original matrix where `0 <= m1 <= m` and `0 <= n1 <= n`.","solution":"def numSubmat(mat): if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) hist = [[0] * n for _ in range(m)] # Build the histogram of heights for 1\'s for i in range(m): for j in range(n): if mat[i][j] == 0: hist[i][j] = 0 else: hist[i][j] = hist[i-1][j] + 1 if i > 0 else 1 # Calculate the number of submatrices with all 1\'s ans = 0 for i in range(m): for j in range(n): min_height = float(\'inf\') for k in range(j, -1, -1): if hist[i][k] == 0: break min_height = min(min_height, hist[i][k]) ans += min_height return ans"},{"question":"You are working on a project that requires you to analyze a list of reviews left by customers on multiple products. Each review is represented as a string, and each product has multiple reviews. Your task is to determine the product with the most frequent occurrence of a specific keyword in its reviews. You are given: - An integer `n` representing the number of products. - A list of `n` lists of strings, `reviews`, where `reviews[i]` is the list of reviews for the `i-th` product. - A keyword, `keyword`, which you need to count. Return _the index of the product with the highest frequency of the keyword in its reviews_. If there is a tie, return the smallest index. Note: - All strings are in lowercase. - A keyword is considered an exact match in the reviews. - Each product has at least one review.","solution":"def product_with_most_keyword(n, reviews, keyword): def keyword_count(review_list): return sum(review.split().count(keyword) for review in review_list) max_count = 0 product_index = -1 for i in range(n): count = keyword_count(reviews[i]) if count > max_count: max_count = count product_index = i elif count == max_count and product_index == -1: product_index = i return product_index"},{"question":"You are given a binary tree with `n` nodes, each node having a unique value from `1` to `n`. A **binary tree** is defined as a tree data structure in which each node has at most two children, referred to as the left child and the right child. You need to implement a function that determines the **diameter** of the tree. The **diameter** of a binary tree is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. Return _an integer_ representing the diameter of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root): Finds the diameter of a binary tree, which is the length of the longest path between any two nodes in the tree. def depth(node): # Helper function to calculate the depth of the tree and update the diameter nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) # Path through this node is left_depth + right_depth diameter = max(diameter, left_depth + right_depth) # Return the depth of the tree rooted at this node return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter"},{"question":"You are given an undirected graph represented as an adjacency list `graph` where the `i-th` list contains all the nodes `adjacent` to node `i`. Write a function to determine whether the graph is *bipartite*. A graph is *bipartite* if its nodes can be colored with two colors such that no two adjacent nodes share the same color. Return `true` if the given graph is bipartite, otherwise return `false`.","solution":"def is_bipartite(graph): Returns True if the graph is bipartite, otherwise returns False. color = {} def dfs(node, c): if node in color: return color[node] == c color[node] = c return all(dfs(nei, c ^ 1) for nei in graph[node]) return all(dfs(node, 0) for node in range(len(graph)) if node not in color)"},{"question":"You are given an integer array `arr` of length `n` and two integers `k` and `target`. The task is to determine whether there exists a subsequence of `k` distinct integers in the array whose sum is equal to `target`. Return `true` if such a subsequence exists, and `false` otherwise. A subsequence of an array is a new array generated from the original array by deleting some elements (can be none) without changing the order of the remaining elements.","solution":"from itertools import combinations def subsequence_sum_exists(arr, k, target): Determines if there exists a subsequence of k distinct integers in arr whose sum equals target. Parameters: arr (list of int): The input array of integers. k (int): The length of the subsequence. target (int): The target sum for the subsequence. Returns: bool: True if such a subsequence exists, otherwise False. if k > len(arr): return False for combo in combinations(arr, k): if sum(combo) == target: return True return False"},{"question":"You are given two strings `str1` and `str2` of lengths `m` and `n` respectively. You want to form the longest possible subsequence common to both strings by removing some characters (possibly none) from each string without reordering the remaining characters. Write a function to return the length of the longest common subsequence (LCS) of `str1` and `str2`.","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence between str1 and str2. m, n = len(str1), len(str2) # Create a 2D array to store the lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"Given an array of integers `arr`, return an array of the same length where each element at index `i` is replaced with the product of all the elements in `arr` except `arr[i]`. Implement this with a time complexity of `O(n)` and without using the division operation. For example, given the array `[1,2,3,4]`, the output should be `[24,12,8,6]`.","solution":"def product_except_self(arr): length = len(arr) if length == 0: return [] left_products = [0] * length right_products = [0] * length output = [0] * length # Initialize the left_products array left_products[0] = 1 for i in range(1, length): left_products[i] = left_products[i - 1] * arr[i - 1] # Initialize the right_products array right_products[length - 1] = 1 for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Construct the output array for i in range(length): output[i] = left_products[i] * right_products[i] return output"},{"question":"Implement a function `maxProduct` that takes an array of integers `nums` and returns the maximum product of any three numbers in the array. You must optimize your solution to run in O(n) time complexity, where `n` is the length of the array.","solution":"def maxProduct(nums): Returns the maximum product of any three numbers in the array. if len(nums) < 3: raise ValueError(\\"Input array must have at least three elements\\") # Initialize the three highest numbers and the two lowest numbers max1 = max2 = max3 = float(\'-inf\') min1 = min2 = float(\'inf\') # Traverse the array to find the three largest and two smallest numbers for num in nums: # Update the largest numbers if num > max1: max3 = max2 max2 = max1 max1 = num elif num > max2: max3 = max2 max2 = num elif num > max3: max3 = num # Update the smallest numbers if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num # The max product of three numbers would be the maximum of: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers and the largest number return max(max1 * max2 * max3, min1 * min2 * max1)"},{"question":"Given a string `str`, find the length of the longest substring that contains at most two distinct characters. The string `str` will consist of lowercase letters only. Return _the length of the longest substring_.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. Args: s (str): The input string consisting of lowercase letters. Returns: int: The length of the longest substring with at most two distinct characters. if len(s) < 3: return len(s) left, right = 0, 0 max_len = 2 char_map = {} while right < len(s): if len(char_map) < 3: char_map[s[right]] = right right += 1 if len(char_map) == 3: min_index = min(char_map.values()) del char_map[s[min_index]] left = min_index + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given a binary string `s` consisting of only the characters \'0\' and \'1\'. You can flip at most one \'0\' to \'1\'. Find the length of the longest contiguous subsequence of \'1\'s that can be obtained by performing at most one flip to \'0\'. Return the length of this maximum contiguous subsequence of \'1\'s.","solution":"def longest_ones_with_flip(s): n = len(s) max_length = 0 left = 0 zero_count = 0 for right in range(n): if s[right] == \'0\': zero_count += 1 while zero_count > 1: if s[left] == \'0\': zero_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house, and you are tasked with robbing the houses. At each house, you cannot rob the house directly next to the previously robbed house due to its security system. Return the maximum amount of money you can rob without setting off the alarms.","solution":"def rob(nums): Returns the maximum amount of money you can rob without setting off the alarms. if not nums: return 0 if len(nums) == 1: return nums[0] rob1, rob2 = 0, 0 for n in nums: new_rob = max(rob1 + n, rob2) rob1 = rob2 rob2 = new_rob return rob2"},{"question":"Given a string representing a mathematical expression, implement a function to evaluate its value and return the result as an integer. The expression string may contain open `(` and closing parentheses `)`, the plus `+` or minus sign `-`, non-negative integers, and empty spaces. You may assume that the given expression is always valid. * For example, `\\"1 + 1\\"` should return `2`, and `\\"(1+(4+5+2)-3)+(6+8)\\"` should return `23`. The function should support nested expressions and ignore any extraneous spaces.","solution":"def evaluate_expression(expression): Evaluates a string mathematical expression and returns its integer value. The expression may contain +, -, parentheses, non-negative integers, and spaces. def helper(s, i): stack = [] num = 0 sign = 1 while i < len(s): char = s[i] if char.isdigit(): num = num * 10 + int(char) elif char == \'+\': stack.append(sign * num) num = 0 sign = 1 elif char == \'-\': stack.append(sign * num) num = 0 sign = -1 elif char == \'(\': num, j = helper(s, i + 1) i = j - 1 elif char == \')\': stack.append(sign * num) return sum(stack), i + 1 i += 1 stack.append(sign * num) return sum(stack), i expression = expression.replace(\' \', \'\') result, _ = helper(expression, 0) return result"},{"question":"Implement a data structure that efficiently supports the following operations for a dynamic array of integers: appending an integer to the end of the array, removing the element at any given index, and finding the median of the array. Develop the `DynamicArray` class: * `DynamicArray()` Initializes the dynamic array object. * `void append(int num)` Appends the integer `num` to the end of the array. * `void remove(int index)` Removes the element at the specified `index` from the array. If the `index` is out of range, do nothing. * `double findMedian()` Returns the median of the current elements in the array. If the array is empty, return `0.0`. The median is the middle element of the array when it is sorted. If the array has an even number of elements, the median is the average of the two middle elements. All methods should be optimized for performance, ensuring efficient handling of dynamically changing arrays.","solution":"class DynamicArray: def __init__(self): self.array = [] def append(self, num): self.array.append(num) self.array.sort() def remove(self, index): if 0 <= index < len(self.array): del self.array[index] def findMedian(self): if not self.array: return 0.0 n = len(self.array) if n % 2 == 1: return float(self.array[n // 2]) else: mid1 = n // 2 mid2 = mid1 - 1 return (self.array[mid1] + self.array[mid2]) / 2.0"},{"question":"You are given a matrix `grid` of size `m x n`, where each cell contains an integer. A textbf{rotated} subgrid is any subgrid of `grid` that can be rotated 90 degrees clockwise any number of times. Determine whether it is possible to make all rows in the rotated subgrid equal to each other. Return a boolean value indicating if such a subgrid exists.","solution":"def is_rotated_subgrid_possible(grid): m, n = len(grid), len(grid[0]) def check_square(i, j, k): square = [] for x in range(k): row = [grid[i + x][j + y] for y in range(k)] square.append(row) def rotate(square): return [list(row) for row in zip(*square[::-1])] for _ in range(4): square = rotate(square) if all(row == square[0] for row in square): return True return False for i in range(m): for j in range(n): max_size = min(m - i, n - j) for k in range(2, max_size + 1): if check_square(i, j, k): return True return False"},{"question":"A messaging application has a feature to organize messages into threads. Each message has a unique ID and optionally contains a reference to the ID of the message it is replying to. Given a list of messages, where each message is represented as a tuple `(message_id, reply_to_id)`, write an algorithm to group messages into threads and return the threads sorted in chronological order. Each thread starts with a message that is not a reply to any other message; subsequent messages in the thread are replies to the previously listed message. If a message is a reply to another message that does not appear in the input list, treat it as starting a new thread.","solution":"def organize_messages(messages): Organizes a list of messages into threads. Parameters: - messages: List of tuples (message_id, reply_to_id) Returns: A list of threads, where each thread is a list of message_ids sorted in chronological order. # Create a dictionary to map each message_id to its index in the list message_index = {} for i, (mid, reply_to) in enumerate(messages): message_index[mid] = i # Initialize tracking structures threads = [] thread_mapping = {} in_reply_to_mapping = {} # Organize messages for mid, reply_to in messages: if reply_to is None or reply_to not in message_index: # New thread threads.append([mid]) thread_mapping[mid] = mid else: # Add to existing thread thread_id = thread_mapping.get(reply_to, None) if thread_id is not None: threads[in_reply_to_mapping[thread_id]].append(mid) thread_mapping[mid] = thread_id else: # Reply to a message that\'s not in the list, start a new thread threads.append([mid]) thread_mapping[mid] = mid in_reply_to_mapping[mid] = len(threads) - 1 return threads"},{"question":"Given an undirected graph represented as an adjacency list, determine if the graph contains a cycle. The graph is provided as a 2D list `graph`, where `graph[i]` is a list of all vertices connected to vertex `i`. Return `true` if there is a cycle in the graph, and `false` otherwise. The graph does not contain self-loops or multiple edges between the same pair of vertices.","solution":"def is_cyclic(graph): Determines if an undirected graph contains a cycle. Parameters: graph (list of list of int): Adjacency list of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(v, parent): visited.add(v) for neighbor in graph[v]: if neighbor not in visited: if dfs(neighbor, v): return True elif parent != neighbor: return True return False visited = set() for vertex in range(len(graph)): if vertex not in visited: if dfs(vertex, -1): return True return False"},{"question":"You are given a 2D integer array `events` where `events[i] = [starti, endi, valuei]` represents an event that starts at `starti` and ends at `endi`, with a value of `valuei`. You can attend an event if and only if it does not overlap with any other event you have attended. Return _the **maximum value** you can obtain by attending a subset of the given events_.","solution":"def max_value(events): # Sort events by their ending time events.sort(key=lambda x: x[1]) # DP array to store the maximum values dp = [0] * len(events) # Function to find the last event that doesn\'t conflict with event[i] def find_last_non_conflicting(i): low, high = 0, i-1 while low <= high: mid = (low + high) // 2 if events[mid][1] < events[i][0]: if events[mid + 1][1] < events[i][0]: low = mid + 1 else: return mid else: high = mid - 1 return -1 # Fill dp array dp[0] = events[0][2] for i in range(1, len(events)): include = events[i][2] l = find_last_non_conflicting(i) if l != -1: include += dp[l] dp[i] = max(include, dp[i-1]) return dp[-1]"},{"question":"Given a string `stream` that represents a continuous stream of characters appearing in chronological order, implement a class `FirstUnique` that provides two operations: 1. `FirstUnique(char stream[])`: Initializes the object with the stream of characters. 2. `char showFirstUnique()`: Returns the first unique character in the stream. If there is no such character, return `\'#\'`. 3. `void add(char c)`: Adds the character `c` to the stream. For example: ``` FirstUnique fu = new FirstUnique(\\"aabbcd\\"); fu.showFirstUnique(); // returns \'c\' fu.add(\'a\'); fu.showFirstUnique(); // returns \'c\' fu.add(\'c\'); fu.showFirstUnique(); // returns \'#\' fu.add(\'d\'); fu.showFirstUnique(); // returns \'#\' ```","solution":"from collections import OrderedDict, defaultdict class FirstUnique: def __init__(self, stream): self.stream = OrderedDict() self.count = defaultdict(int) for char in stream: self.add(char) def showFirstUnique(self): for char in self.stream: if self.count[char] == 1: return char return \'#\' def add(self, char): if char in self.stream: self.count[char] += 1 else: self.stream[char] = None self.count[char] = 1"},{"question":"You are given a string `s` consisting of lowercase alphabets. You can apply one of two operations any number of times in any order: 1. Select a character in `s` and move it to the beginning of the string. 2. Select a character in `s` and move it to the end of the string. Return _the **lexicographically smallest** string possible after performing the operations any number of times._","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string possible by moving characters to the beginning or end of the string any number of times. return \'\'.join(sorted(s))"},{"question":"You are given an integer array `arr` consisting of `n` integers and you need to determine if it is possible to partition this array into `k` consecutive subsequences. A consecutive subsequence is a sequence where each element is exactly one more than the previous element in the sequence. Return `true` if it is possible to partition the array into `k` consecutive subsequences, and `false` otherwise. A subsequence is formed by deleting some or no elements from the array without changing the order of the remaining elements. For example, given the array `arr = [1,2,3,3,4,4,5,6]` and `k = 4`, the function should return `true` because the array can be partitioned as `[1,2,3,4]` and `[3,4,5,6]`.","solution":"from collections import Counter import heapq def is_possible_to_partition(arr, k): Determine if it is possible to partition the array into k consecutive subsequences. :param arr: List[int] - The input array of integers :param k: int - The desired number of consecutive subsequences :return: bool - True if possible, otherwise False if len(arr) % k != 0: return False counter = Counter(arr) min_heap = list(counter.keys()) heapq.heapify(min_heap) while min_heap: first = min_heap[0] for i in range(first, first + k): if counter[i] == 0: return False counter[i] -= 1 if counter[i] == 0: if i != min_heap[0]: return False heapq.heappop(min_heap) return True"},{"question":"You are given a binary string `s` consisting only of the characters \'0\' and \'1\'. You need to find the maximum number of contiguous substrings such that each substring contains an equal number of \'0\'s and \'1\'s. If it is impossible to split the string in such a way, return `-1`. Return the maximum number of equal \'0\' and \'1\' substrings.","solution":"def max_equal_substrings(s): Finds the maximum number of contiguous substrings such that each substring contains an equal number of \'0\'s and \'1\'s. If it is impossible to split the string in such a way, return -1. count_0 = 0 count_1 = 0 max_substrings = 0 for char in s: if char == \'0\': count_0 += 1 else: count_1 += 1 if count_0 == count_1: max_substrings += 1 if max_substrings == 0: return -1 return max_substrings"},{"question":"You are given two integers `x` and `y` which represent the dimensions of a 2D grid. In this grid, the top-left corner is `(1,1)` and the bottom-right corner is `(x,y)`. A robot starts at position `(1,1)` and can only move to the right or down. Given a list of obstacles where each obstacle is represented as a pair `(i, j)` indicating its position in the grid, implement a function `bool isPathExist(int x, int y, List<pair<int, int>> obstacles)` that returns `true` if there is a path from the top-left corner to the bottom-right corner avoiding all obstacles, and `false` otherwise.","solution":"def isPathExist(x, y, obstacles): Determines if there is a path from top-left to bottom-right corner avoiding the provided obstacles. :param x: Number of columns in the grid :param y: Number of rows in the grid :param obstacles: List of tuples indicating obstacle positions :return: True if there is a path, False otherwise if (1, 1) in obstacles or (x, y) in obstacles: return False grid = [[0] * y for _ in range(x)] for o in obstacles: grid[o[0]-1][o[1]-1] = -1 for i in range(x): if grid[i][0] == -1: break grid[i][0] = 1 for j in range(y): if grid[0][j] == -1: break grid[0][j] = 1 for i in range(1, x): for j in range(1, y): if grid[i][j] == -1: continue if grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] return grid[x-1][y-1] > 0"},{"question":"You are given `n` events represented by an array `events`, where `events[i]` is a pair of start and end day of the ith event. The ith event starts at `events[i][0]` and ends at `events[i][1]`. You can attend an event `i` if the start day of event `i` meets the current day, you can finish attending event `i` at the end day of event `i`. The events must be attended sequentially. Return the maximum number of events you can attend. Implement the `maxEvents` function: * `maxEvents(int[][] events)` - Given an array of events where each event is represented by a pair [startDay, endDay], return the maximum number of events you can attend.","solution":"def maxEvents(events): import heapq events.sort() min_heap = [] attended_events = 0 day = 0 i = 0 n = len(events) while i < n or min_heap: if len(min_heap) == 0: day = events[i][0] while i < n and events[i][0] == day: heapq.heappush(min_heap, events[i][1]) i += 1 heapq.heappop(min_heap) attended_events += 1 day += 1 while min_heap and min_heap[0] < day: heapq.heappop(min_heap) return attended_events"},{"question":"You are given a string `s` containing letters and digits. You need to separate the letters and digits into two groups, sort each group in ascending order, and then concatenate the sorted groups, with letters coming before digits in the concatenated result. If `s` does not contain any letters or any digits, keep the group empty but still concatenate based on the order described. Return the concatenated string as the final result. For example: Given `s = \\"a1c3b2\\"`, the sorted letters are \\"abc\\" and the sorted digits are \\"123\\". The concatenated result is `\\"abc123\\"`.","solution":"def separate_and_sort(s): Separates letters and digits from the input string, sorts each group in ascending order, and concatenates the sorted groups with letters coming before digits. Parameters: s (str): Input string containing letters and digits. Returns: str: Concatenated result of sorted letters and sorted digits. letters = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) return \'\'.join(letters) + \'\'.join(digits)"},{"question":"You are given an unsorted array of integers `nums`. Write a function to find the number of contiguous subarrays within which the product of all the elements is less than a given integer `k`. For example, given the array `nums = [10, 5, 2, 6]` and `k = 100`, the answer would be `8` as there are the subarrays: `[10]`, `[5]`, `[2]`, `[6]`, `[10, 5]`, `[5, 2]`, `[2, 6]`, and `[5, 2, 6]`, all having products less than `100`. Return the number of subarrays where the product of all elements in the subarray is less than `k`. Ensure that the solution has a time complexity efficient enough to handle large input sizes.","solution":"def num_subarray_product_less_than_k(nums, k): Returns the number of contiguous subarrays where the product of all the elements is less than k. if k <= 1: return 0 count = 0 product = 1 left = 0 for right in range(len(nums)): product *= nums[right] while product >= k: product //= nums[left] left += 1 count += right - left + 1 return count"},{"question":"A group of friends is planning to go out together. You are given an integer array `arrivals` representing the arrival times of each friend, where `arrivals[i]` is the arrival time of the i-th friend. Additionally, you are provided an integer `time_window` representing the maximum time gap allowed between the first friend to arrive and the last friend to arrive. Your task is to determine and return the maximum number of friends that can meet up within this `time_window`. For example, if `arrivals = [1, 3, 5, 7, 9]` and `time_window = 4`, the function should return `3` since friends can arrive within the time window [1, 5] or [3, 7], but no larger group can meet within any 4-minute window.","solution":"def max_friends_in_window(arrivals, time_window): Given a list of arrival times and a time window, find the maximum number of friends that can meet up within the time window. arrivals.sort() max_count = 0 n = len(arrivals) for i in range(n): count = 1 for j in range(i + 1, n): if arrivals[j] - arrivals[i] <= time_window: count += 1 else: break max_count = max(max_count, count) return max_count"},{"question":"You are given a string `s` consisting of lowercase English letters and wildcards represented by the character `*`. A wildcard can be replaced by any single lowercase English letter. You need to determine the number of distinct strings that can be generated by replacing the wildcards in the string `s`. Return _the total number of distinct strings that can be formed_. For example, if `s = \\"a*c\\"`, the possible distinct strings are `\\"aac\\"`, `\\"abc\\"`, `\\"acc\\"`, ..., `\\"azc\\"`. The total number of such strings would be 26.","solution":"def count_distinct_strings(s): Returns the number of distinct strings that can be generated by replacing the wildcards in the string. Parameters: s (str): Input string containing lowercase English letters and wildcard \'*\' characters. Returns: int: Number of distinct strings that can be generated. wildcard_count = s.count(\'*\') return 26 ** wildcard_count"},{"question":"You are given an array of integers representing the heights of a group of people, and a 2D array `friends` where `friends[i] = [a, b]` indicates that person `a` is a friend of person `b`. Each person wants to know the height difference between themselves and the tallest friend they have. Implement a function that returns an array where each element at index `i` represents the height difference between person `i` and their tallest friend. If a person doesn\'t have any friends, their height difference should be `0`.","solution":"def height_difference(heights, friends): Calculate the height difference between each person and their tallest friend. Parameters: heights (list[int]): List of heights of people. friends (list[list[int]]): List of pairs indicating friendships. Returns: list[int]: List of height differences for each person. n = len(heights) result = [0] * n # Initialize result with 0s, assuming no friends # Dictionary to store friends of each person friend_dict = {i: [] for i in range(n)} # Fill the friend_dict with friends for a, b in friends: friend_dict[a].append(b) friend_dict[b].append(a) for i in range(n): if friend_dict[i]: # Get the max height among friends max_friend_height = max(heights[j] for j in friend_dict[i]) result[i] = max_friend_height - heights[i] return result"},{"question":"You are given a list of strings `words` and a string `pattern`. You want to find all strings in `words` that match the `pattern`. A string matches the pattern if the characters in the string can be replaced to get the pattern. For each string in `words`, determine if it matches the pattern and return a list of all matching strings. For example, given `words = [\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"]` and `pattern = \\"abb\\"`, the strings \\"mee\\" and \\"aqq\\" match the pattern because: - \\"mee\\" can be transformed to \\"abb\\" by replacing \'m\' with \'a\' and \'e\' with \'b\'. - \\"aqq\\" can be transformed to \\"abb\\" by replacing \'a\' with \'a\' and \'q\' with \'b\'. The function should return `[\\"mee\\", \\"aqq\\"]`.","solution":"def find_and_replace_pattern(words, pattern): This function finds all the words in the list `words` that match the `pattern`. def matches(word): if len(word) != len(pattern): return False forward_map = {} backward_map = {} for w_char, p_char in zip(word, pattern): if w_char in forward_map and forward_map[w_char] != p_char: return False if p_char in backward_map and backward_map[p_char] != w_char: return False forward_map[w_char] = p_char backward_map[p_char] = w_char return True return [word for word in words if matches(word)]"},{"question":"Given an array of integers `nums` and an integer `target`, return _the minimum size of a subarray whose sum is greater than or equal to `target`_. If there is no such subarray, return _0_ instead. The goal is to find an optimal solution with time complexity better than O(n^2).","solution":"def min_subarray_len(target, nums): Returns the minimum size of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead. n = len(nums) min_len = float(\'inf\') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float(\'inf\') else 0"},{"question":"You are given a `root` of a binary tree. You need to reverse the level order traversal of its nodes\' values. That is, from left to right, level by level, and from leaf to root. Return _the reversed level order traversal of the given binary tree\'s nodes\' values as an array of arrays_.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reverse_level_order(root): if not root: return [] queue = deque([root]) result = deque() while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.appendleft(level_nodes) return list(result)"},{"question":"Given an array of integers `nums`, you are asked to find and return a list of all the unique permutations of the array. For example, given `nums = [1, 1, 2]`, the unique permutations are `[[1, 1, 2], [1, 2, 1], [2, 1, 1]]`. Generate the permutations without using built-in library functions that perform permutations directly. Ensure that the output list does not include any duplicate permutations. The permutations can be returned in any order.","solution":"def unique_permutations(nums): Returns a list of unique permutations of the given list of numbers. def backtrack(start=0): if start == len(nums): perm = nums[:] if perm not in result: result.append(perm) return seen = set() for i in range(start, len(nums)): if nums[i] not in seen: seen.add(nums[i]) nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1) nums[start], nums[i] = nums[i], nums[start] result = [] backtrack() return result"},{"question":"Given an integer array `arr` and an integer `x`, determine if there exist two distinct indices `i` and `j` in the array such that `|arr[i] - arr[j]| <= x` and `|i - j| <= x`. Return `true` if such indices exist, and `false` otherwise.","solution":"def contains_nearby_almost_duplicate(arr, x): Determines if there exist two distinct indices i and j in the array such that |arr[i] - arr[j]| <= x and |i - j| <= x. :param arr: List of integers :param x: Integer threshold for both value difference and index difference :return: Boolean indicating if such indices exist for i in range(len(arr)): for j in range(i + 1, len(arr)): if abs(arr[i] - arr[j]) <= x and abs(i - j) <= x: return True return False"},{"question":"You are given an integer array `steps` of size `n`, where `steps[i]` denotes the maximum number of steps you can advance forward from the `i-th` position. Your goal is to determine the minimum number of steps required to reach the last index starting from the first index of the array. Return the minimum number of steps needed, or `-1` if it is not possible to reach the last index.","solution":"def min_steps_to_end(steps): Determines the minimum number of steps required to reach the last index of the array or returns -1 if it is not possible to reach the last index. :param steps: List[int] - List of steps where steps[i] denotes the maximum number of steps you can advance forward from the i-th position. :return: int - Minimum number of steps needed to reach the end or -1 if not possible. n = len(steps) if n == 0: return -1 jumps = 0 curr_end = 0 curr_furthest = 0 for i in range(n-1): curr_furthest = max(curr_furthest, i + steps[i]) if i == curr_end: jumps += 1 curr_end = curr_furthest if curr_end >= n - 1: return jumps return -1 if curr_end < n - 1 else jumps"},{"question":"You are given `n` ranges represented by pairs of integers, where each pair denotes a range `[l_i, r_i]` inclusive. Each range can be seen on a number line. Your task is to find the maximum number of ranges that overlap at a single point on the number line. If there\'s no overlap, return `0`. The ranges are given in a list of tuples `ranges` such that each tuple represents a range `[l_i, r_i]` where `1 <= l_i <= r_i <= 10^9` and `1 <= n <= 10^6`. Return the maximum number of ranges that overlap at a single point.","solution":"def max_overlap(ranges): events = [] for l, r in ranges: events.append((l, 1)) events.append((r + 1, -1)) events.sort() max_overlap = 0 current_overlap = 0 for _, event in events: current_overlap += event max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"A company has hired you to develop a system to track their inventory items. Each item in the inventory is represented by an integer ID and is part of a batch identified by a unique positive integer batch number. Given a list of tuples `inventory` where each tuple contains two integers (item_id, batch_number), your task is to write a function that returns a dictionary where the keys are the batch numbers and the values are lists of item IDs sorted in ascending order corresponding to that batch number. For example, given `inventory = [(3, 101), (4, 102), (1, 101), (2, 102)]`, the output should be `{101: [1, 3], 102: [2, 4]}`.","solution":"def organize_inventory(inventory): Organizes the inventory into a dictionary where the keys are batch numbers and the values are lists of item IDs sorted in ascending order. Parameters: - inventory: List of tuples, where each tuple contains (item_id, batch_number) Returns: - Dictionary with batch numbers as keys and sorted lists of item IDs as values. inventory_dict = {} for item_id, batch_number in inventory: if batch_number in inventory_dict: inventory_dict[batch_number].append(item_id) else: inventory_dict[batch_number] = [item_id] for batch_number in inventory_dict: inventory_dict[batch_number].sort() return inventory_dict"},{"question":"You are given an array of strings `logs` where each string represents a log entry, and each entry is either in the format `log_id: operation: timestamp`. There are two types of operations: 1. \\"start\\" - indicates the start of a function with the log_id. 2. \\"end\\" - indicates the end of the same function with the log_id. Each `start` log entry will have a corresponding `end` log entry with the same `log_id`. A function can call other functions (nested calls), and each log will maintain this nesting structure. The `timestamp` is a non-negative integer representing the time in milliseconds since the start of an arbitrary reference point. Your task is to determine the exclusive execution time of each function. That is, the total time a function spends executing, excluding the time spent in other functions it calls. Return a dictionary where the keys are the `log_id` and the values are the exclusive execution times of the functions. For example: ```python logs = [\\"1:start:0\\", \\"2:start:2\\", \\"2:end:5\\", \\"1:end:6\\"] ``` In this example, function `1` calls function `2`. Function `2` runs from timestamp `2` to `5` and function `1` runs from timestamp `0` to `6` but calling function `2` spent `4` units of time (from `2` to `6`), so function `1`\'s exclusive time is `1` unit + `1` unit at the ends (from `0` to `2` and `5` to `6`). Return the result as: ```python { \\"1\\": 3, \\"2\\": 3 } ```","solution":"def exclusive_time(logs): stack = [] times = {} prev_time = 0 for log in logs: log_id, typ, time = log.split(\':\') log_id, time = int(log_id), int(time) if typ == \'start\': if stack: times[stack[-1]] = times.get(stack[-1], 0) + (time - prev_time) stack.append(log_id) prev_time = time else: times[stack.pop()] = times.get(log_id, 0) + (time - prev_time + 1) prev_time = time + 1 return times"},{"question":"Implement a function that receives a string `s` containing only characters `X` and `Y`. The function should return the minimum number of operations required to make the string alternating, where no two consecutive characters are the same. Each operation consists of changing one `X` to `Y` or one `Y` to `X`.","solution":"def min_operations_to_alternate(s): Given a string \'s\' containing only characters \'X\' and \'Y\', return the minimum number of operations required to make the string alternating where no two consecutive characters are the same. Each operation consists of changing one \'X\' to \'Y\' or one \'Y\' to \'X\'. :param s: str - input string containing only \'X\' and \'Y\' :return: int - minimum number of operations required # Two patterns to compare: starting with \'X\' and starting with \'Y\' pattern1 = \'\'.join([\'X\' if i % 2 == 0 else \'Y\' for i in range(len(s))]) pattern2 = \'\'.join([\'Y\' if i % 2 == 0 else \'X\' for i in range(len(s))]) # Count operations needed to match each pattern operations1 = sum([1 for i in range(len(s)) if s[i] != pattern1[i]]) operations2 = sum([1 for i in range(len(s)) if s[i] != pattern2[i]]) # Return the minimum of the two counts return min(operations1, operations2)"},{"question":"You are given a rectangular cake represented as a 2D integer grid of dimensions `rows x cols`. Each cell of the grid contains either a `0` or a `1`, where `1` represents a cherry and `0` represents an empty cell. A horizontal cut divides the cake into two parts that each contain at least one cell, and a vertical cut also divides the cake similarly. A piece of cake is defined by a subrectangle (subgrid) of the original cake grid. Your task is to maximize the number of cherries in the largest piece after exactly one horizontal and one vertical cut. Return _the maximum number of cherries in the largest piece._","solution":"def maxCherries(grid): Returns the maximum number of cherries in the largest piece of cake after exactly one horizontal and one vertical cut. :param grid: List[List[int]], a 2D list representing the cake, where 1 represents a cherry and 0 represents an empty cell. :return: int, the maximum number of cherries in the largest piece. rows = len(grid) cols = len(grid[0]) # Precompute the prefix sum 2D array prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] for i in range(1, rows + 1): for j in range(1, cols + 1): prefix_sum[i][j] = (grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) def get_sum(top_left, bottom_right): (r1, c1), (r2, c2) = top_left, bottom_right return prefix_sum[r2+1][c2+1] - prefix_sum[r1][c2+1] - prefix_sum[r2+1][c1] + prefix_sum[r1][c1] max_cherries = 0 for i in range(1, rows): for j in range(1, cols): top_left = get_sum((0, 0), (i-1, j-1)) top_right = get_sum((0, j), (i-1, cols-1)) bottom_left = get_sum((i, 0), (rows-1, j-1)) bottom_right = get_sum((i, j), (rows-1, cols-1)) max_cherries = max(max_cherries, top_left, top_right, bottom_left, bottom_right) return max_cherries"},{"question":"You are given a linked list where each node contains an integer value. Design an algorithm to split this linked list into two separate linked lists: one containing all the nodes with even values, and the other containing all the nodes with odd values. The nodes in each new linked list should preserve the relative order they appeared in the original linked list. Return the two separate linked lists.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def split_linked_list(head): Split the given linked list into two separate linked lists: one containing all the nodes with even values, and the other with odd values. if not head: return None, None even_dummy = ListNode(0) odd_dummy = ListNode(0) even_tail = even_dummy odd_tail = odd_dummy current = head while current: if current.val % 2 == 0: even_tail.next = current even_tail = even_tail.next else: odd_tail.next = current odd_tail = odd_tail.next current = current.next even_tail.next = None odd_tail.next = None return even_dummy.next, odd_dummy.next"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to find pairs of distinct indices `(i, j)` such that the sum of the integers `nums[i]` and `nums[j]` is equal to `target`. Return _a list of all pairs of indices (i, j) that satisfy this condition. Make sure the pairs are presented in ascending order of the first element of the pair, and for pairs with the same first element, sort based on the second element. If no such pairs exist, return an empty list_.","solution":"def find_pairs(nums, target): Finds all pairs of distinct indices (i, j) such that nums[i] + nums[j] == target and returns them in sorted order. pairs = [] nums_len = len(nums) for i in range(nums_len): for j in range(i + 1, nums_len): if nums[i] + nums[j] == target: pairs.append((i, j)) return sorted(pairs, key=lambda x: (x[0], x[1]))"},{"question":"A car manufacturer wants to track the performance of their latest model over multiple test races. Each race is represented as an array `speed` where each element denotes the speed of the car at different checkpoints. The car manufacturer\'s engineers have identified a particular interest in tracking consecutive increasing speed sequences during each race. A consecutive increasing speed sequence is a sequence where each subsequent speed is strictly greater than the previous one. Given an array `speed` representing the speed of the car at various checkpoints during a race, return _the length of the longest consecutive increasing speed sequence_. For example, given the array `speed = [3, 4, 5, 1, 2, 3, 4, 5, 6]`, the function should return `6` because the longest consecutive increasing speed sequence is `[1, 2, 3, 4, 5, 6]`.","solution":"def longest_increasing_sequence(speed): Returns the length of the longest consecutive increasing speed sequence. if not speed: return 0 longest = 1 current = 1 for i in range(1, len(speed)): if speed[i] > speed[i - 1]: current += 1 longest = max(longest, current) else: current = 1 return longest"},{"question":"You are given an integer array `nums` sorted in ascending order, and an integer `target`. Suppose that `nums` is rotated at some pivot unknown to you beforehand (i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`). If `target` is found in the array, return its index; otherwise, return `-1`. You must write an algorithm with `O(log n)` runtime complexity. Additionally, implement it without using recursion. Example 1: Input: `nums = [4,5,6,7,0,1,2]`, `target = 0` Output: 4 Example 2: Input: `nums = [4,5,6,7,0,1,2]`, `target = 3` Output: -1 Example 3: Input: `nums = [1]`, `target = 0` Output: -1 Your implementation should search for the target within the array, determining its index if it exists. If the target is present multiple times in `nums`, return the index of any instance.","solution":"def search(nums, target): Searches for the target in the rotated sorted array nums and returns its index if found, otherwise returns -1. The algorithm runs in O(log n) time complexity. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given two **non-negative** integers `x` and `y` representing the coordinates of a point in a 2D grid. Your task is to find the shortest path from the origin `(0, 0)` to the point `(x, y)`, where you can move in four possible directions: up, down, left, or right. Return the length of this shortest path as an integer. For example, if `x = 3` and `y = 4`, the shortest path from `(0, 0)` to `(3, 4)` is 7 steps.","solution":"def shortest_path_length(x, y): Calculates the shortest path length from (0, 0) to (x, y) in a 2D grid. Since we can move in four directions (up, down, left, right), the shortest path will always be the Manhattan distance, which is the sum of the absolute differences of the coordinates. :param x: Non-negative integer, x-coordinate of the target point. :param y: Non-negative integer, y-coordinate of the target point. :return: Integer, length of the shortest path. return x + y"},{"question":"You are given an integer array `nums`. A value `val` is considered a **peak** element if it is strictly greater than its neighbors. Given that `nums`[i] is not necessarily distinct and `nums` may contain multiple peaks, return _the index of **any** peak element_. You may imagine that `nums`[-1] and `nums`[`nums`.length] are both negative infinity (`-`). The goal is to find an algorithm that works efficiently.","solution":"def findPeakElement(nums): Returns the index of any peak element. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given a matrix `grid` of `0`s and `1`s. Find the largest square containing only `1`s and return its area. A square is defined as a sub-matrix where all of its entries are `1`s, and its sides are parallel to the grid sides. The area of a square is side length squared. If there are multiple squares with the same maximum area, any one of them can be considered.","solution":"def largest_square(matrix): if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) max_side = 0 dp = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"Given a string `s` containing only lowercase letters, you need to determine the maximum length of a substring that contains no more than 2 distinct characters. Return the length of such a substring. For example, given `s = \\"eceba\\"`, the function should return `3` as the substring `\\"ece\\"` contains only 2 distinct characters (\'e\' and \'c\') and is of maximum length.","solution":"def max_length_of_substring_with_2_distinct_chars(s): Returns the maximum length of a substring that contains no more than 2 distinct characters. if not s: return 0 left, right = 0, 0 max_len = 0 char_count = {} while right < len(s): if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"A company has workstations arranged in a grid format on multiple floors. Each floor is represented by a 2D grid of dimensions `rows` x `cols`, where each cell represents a workstation that can either be **empty** (`0`) or **occupied** (`1`). The company management wants to find out the first day when it is no longer possible for any employee to move from an **occupied** workstation to another **occupied** workstation on the same floor, where movement is only possible horizontally or vertically to adjacent cells. You are given an integer `n` representing the number of floors, and a list of `n` 2D arrays `floors`, where `floors[i]` is the 2D grid representing the `i-th` floor\'s workstations. Additionally, you are provided with a 2D array `actions`, where each element `actions[i] = [f, r, c]` indicates that on the `i-th` day, the workstation at the `r-th` row and `c-th` column on the `f-th` floor becomes **occupied** (i.e., changed to `1`). Return _the first day after which no employee can move from one **occupied** workstation to another on the same floor on any of the floors_ based on the given action updates.","solution":"def find_disconnection_day(n, floors, actions): Returns the first day after which no employee can move from one occupied workstation to another on the same floor based on the given actions. :param n: Number of floors. :param floors: List of n 2D arrays where each element represents the workstations on each floor. :param actions: List of actions where each action is a tuple [f, r, c]. :return: The first day where no employee can move between any occupied workstation on any floor. def disjoint_set(rows, cols): parent = { (i, j): (i, j) for i in range(rows) for j in range(cols) } def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return find, union, parent rows, cols = len(floors[0]), len(floors[0][0]) for day, (f, r, c) in enumerate(actions): floors[f][r][c] = 1 find, union, parent = disjoint_set(rows, cols) for i in range(rows): for j in range(cols): if floors[f][i][j] == 1: for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]: ni, nj = i + di, j + dj if 0 <= ni < rows and 0 <= nj < cols and floors[f][ni][nj] == 1: union((i, j), (ni, nj)) components = set(find((i, j)) for i in range(rows) for j in range(cols) if floors[f][i][j] == 1) if len(components) > 1: return day + 1 return len(actions)"},{"question":"Given the `root` of a binary tree, return the maximum sum of values obtained by summing up all values from the nodes on a path from the root down to any leaf. A **leaf** is a node with no children. A **path** is any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Return the maximum sum of values obtained by summing up all values from the nodes on a path from the root down to any leaf. if root is None: return 0 left_sum = maxPathSum(root.left) right_sum = maxPathSum(root.right) return root.val + max(left_sum, right_sum)"},{"question":"You are given an array of non-negative integers representing the amount of money of each house, arranged in a circular manner. You are also a professional robber, but you cannot rob two adjacent houses, and since they are arranged in a circle, the first and last house are also considered adjacent. Determine the maximum amount of money you can rob without alerting the police. Implement a function `int rob(vector<int>& nums)` that returns the maximum amount of money you can rob.","solution":"def rob(nums): Given a circular array of non-negative integers representing the money at each house, return the maximum amount of money you can rob without alerting the police, considering the constraint that the houses are in a circle (first and last house are adjacent). if not nums: return 0 if len(nums) == 1: return nums[0] def rob_linear(houses): Helper function to rob houses linearly, i.e., without the circular constraint. prev_max, curr_max = 0, 0 for money in houses: temp = curr_max curr_max = max(curr_max, prev_max + money) prev_max = temp return curr_max # Compute maximum money excluding the first house and excluding the last house rob_without_first = rob_linear(nums[1:]) rob_without_last = rob_linear(nums[:-1]) return max(rob_without_first, rob_without_last)"},{"question":"You are given an array of strings `words` and a string `target`. Each word in `words` matches the pattern of the `target` if replacing all instances of one character in the `target` with another character consistently throughout the string results in one of the commands in `words`. For example, with the target \\"abb\\", \\"dee\\" and \\"mee\\" match the pattern, but \\"pop\\" and \\"boo\\" do not. Write a function that returns an array containing all the strings in `words` that match the `target` pattern.","solution":"def matches_pattern(word: str, pattern: str) -> bool: if len(word) != len(pattern): return False char_map_word = {} char_map_pattern = {} for w_char, p_char in zip(word, pattern): if w_char in char_map_word: if char_map_word[w_char] != p_char: return False if p_char in char_map_pattern: if char_map_pattern[p_char] != w_char: return False char_map_word[w_char] = p_char char_map_pattern[p_char] = w_char return True def find_and_replace_pattern(words, target): Returns an array of words that match the target pattern. return [word for word in words if matches_pattern(word, target)]"},{"question":"You are given two **0-indexed** integer arrays `timeSeries1` and `timeSeries2` representing the time series data of two sensors. The sensors record data points at non-negative integer times and the arrays are sorted in non-decreasing order. Each element in `timeSeries1` and `timeSeries2` represents a time point at which the sensor recorded a data point. Your task is to determine the longest contiguous time interval during which data points from both sensors overlap. An overlap means that there is a range `[a, b]` (inclusive), where `a` and `b` are integers, such that both sensors have recorded data points at all time points in this range. Return the length of the longest overlapping contiguous time interval. If there is no overlap between the two time series, return 0. For example, given `timeSeries1 = [1, 2, 3, 5, 6]` and `timeSeries2 = [3, 4, 5, 6]`, the longest overlapping contiguous time interval is `[3, 3]` or `[5, 6]`, and the function should return `2`.","solution":"def longest_overlap(timeSeries1, timeSeries2): Determines the length of the longest overlapping contiguous time interval between two sorted time series. Args: - timeSeries1 (list of int): the first time series - timeSeries2 (list of int): the second time series Returns: - int: the length of the longest overlapping contiguous time interval if not timeSeries1 or not timeSeries2: return 0 i, j = 0, 0 max_overlap = 0 current_overlap = 0 while i < len(timeSeries1) and j < len(timeSeries2): if timeSeries1[i] == timeSeries2[j]: if current_overlap == 0: current_overlap = 1 else: current_overlap += 1 max_overlap = max(max_overlap, current_overlap) i += 1 j += 1 elif timeSeries1[i] < timeSeries2[j]: current_overlap = 0 i += 1 else: current_overlap = 0 j += 1 return max_overlap"},{"question":"You are given an array of integers `arr`, and a threshold `target`. The array represents the number of calories each food item contains. You need to determine the minimum number of food items you must consume to reach or exceed the `target` calories. If it is not possible to reach the `target`, return `-1`. The food items can be consumed in any order. Return _the minimum number of food items required to reach or exceed the target calories_.","solution":"def min_food_items_to_reach_target(arr, target): Returns the minimum number of food items required to reach or exceed the target calories. If it is not possible to reach the target, returns -1. # Sort the array in descending order to try the largest calories first arr.sort(reverse=True) sum_calories = 0 count = 0 for calories in arr: sum_calories += calories count += 1 if sum_calories >= target: return count return -1"},{"question":"Given a binary tree and an integer `target`, find all **root-to-leaf** paths where each path\'s sum equals the given `target`. Each path should be returned as a list of the node values, and the result should be returned as a list of these paths. A **root-to-leaf** path is defined as a sequence of nodes from the root of the tree to any leaf (i.e., a node with no children). Note that the paths need not be distinct, and they must be returned in any order.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target): def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target: paths.append(list(current_path)) dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) current_path.pop() paths = [] dfs(root, [], 0) return paths"},{"question":"You are given an array of integers `nums` where each integer appears exactly twice, except for one integer which appears exactly once. Find and return the single integer that appears only once. Your algorithm should have a linear runtime complexity. Can you implement this without using extra memory?","solution":"def single_number(nums): Finds the single number in the list where every other number appears twice. :param nums: List of integers :return: The integer that appears only once unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"Given a list of integers `nums` and an integer `k`, return the root of a binary search tree (BST) constructed from `nums` such that the tree contains exactly `k` nodes and the sum of the values of all nodes in the tree is as close as possible to the sum of the first `k` elements of the sorted version of `nums`. If there are multiple answers, return any valid tree. Note that the BST should maintain its property and `nums` may contain duplicate values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_balanced_bst(sorted_nums, start, end): if start > end: return None mid = (start + end) // 2 node = TreeNode(sorted_nums[mid]) node.left = build_balanced_bst(sorted_nums, start, mid - 1) node.right = build_balanced_bst(sorted_nums, mid + 1, end) return node def closest_bst(nums, k): if not nums or k <= 0: return None sorted_nums = sorted(nums) target_sum = sum(sorted_nums[:k]) closest_bst_root = None closest_sum_difference = float(\'inf\') for i in range(len(sorted_nums) - k + 1): potential_tree_nums = sorted_nums[i:i+k] current_sum = sum(potential_tree_nums) current_difference = abs(current_sum - target_sum) if current_difference < closest_sum_difference: closest_sum_difference = current_difference closest_bst_root = build_balanced_bst(potential_tree_nums, 0, k - 1) return closest_bst_root"},{"question":"Given an array of integers `nums` and an integer `k`, return the number of unique subsets of `nums` that sum up to `k`. A subset is defined as any collection of elements taken from the array (order does not matter and no repeated elements are allowed). The answer should illustrate the approach to finding the unique combinations that produce the desired sum.","solution":"from itertools import combinations def unique_subsets(nums, k): Returns the number of unique subsets of nums that sum up to k. unique_subset_count = 0 # Remove duplicates to simplify the problem as subsets do not need repeated elements nums = list(set(nums)) n = len(nums) for r in range(1, n+1): for subset in combinations(nums, r): if sum(subset) == k: unique_subset_count += 1 return unique_subset_count"},{"question":"Given two integers `n` and `k`, where `n` represents the total number of distinct elements, and `k` is the size of the combination, generate all possible combinations of `k` elements out of the set `{1, 2, ..., n}`. Return all possible combinations as a list of lists. Each combination should be sorted in ascending order, and the list of combinations should be sorted lexicographically.","solution":"from itertools import combinations def generate_combinations(n, k): Generates all possible combinations of k elements out of the set {1, 2, ..., n}. Parameters: n (int): The total number of distinct elements. k (int): The size of each combination. Returns: list: A list of lists containing all possible combinations. return [list(comb) for comb in combinations(range(1, n + 1), k)]"},{"question":"You are given a binary string `s` and an integer `k`. A binary string is a string containing only the characters \'0\' and \'1\'. You can perform the following operation on the string at most `k` times: select any \'0\' in the string and flip it to \'1\'. Return _the maximum number of consecutive \'1\'s you can obtain in the string after performing the operation at most `k` times_.","solution":"def max_consecutive_ones(s, k): Returns the maximum number of consecutive \'1\'s that can be obtained after performing at most k flips of \'0\'s to \'1\'s. Parameters: s (str): The input binary string. k (int): The maximum number of flips. Returns: int: The maximum number of consecutive \'1\'s. max_len = 0 left = 0 zero_count = 0 for right in range(len(s)): if s[right] == \'0\': zero_count += 1 while zero_count > k: if s[left] == \'0\': zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a sequence of integers `arr`, a permutation of `arr` is considered **beautiful** if the sequence satisfies the following condition: for every `i` (1 <= i < length of the permutation), either ( perm[i] > perm[i-1] ) or ( perm[i-1] > perm[i] ) holds. In other words, a permutation is beautiful if each element is either greater than or less than its preceding element. Your task is to determine if there exists a **beautiful** permutation of `arr`. If there is such a permutation, return **any one**. If no beautiful permutation exists, return an empty list.","solution":"from typing import List def find_beautiful_permutation(arr: List[int]) -> List[int]: Function to find any beautiful permutation of arr if it exists. Returns the permutation if it exists, otherwise returns an empty list. if len(arr) <= 2: return list(sorted(arr)) if len(arr) <= 2 else [] arr.sort() n = len(arr) # Check if the maximum adjacent difference in the sorted array is not greater than 1 for i in range(1, n): if arr[i] - arr[i - 1] <= 0: return [] # If the above condition is passed then there exists a beautiful permutation result = [0] * n left, right = 0, n - 1 # Zigzag filling to ensure the alternating property for i in range(n): if i % 2 == 0: result[i] = arr[right] right -= 1 else: result[i] = arr[left] left += 1 return result"},{"question":"You are given a list of integers `nums`. Your task is to find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Implement a function `maxSubArray(nums)` that returns this largest sum. For example, given the array `nums = [-2,1,-3,4,-1,2,1,-5,4]`, the function should return `6`, since the subarray `[4,-1,2,1]` has the largest sum, which is `6`. Ensure your solution has a time complexity of O(n).","solution":"def maxSubArray(nums): Finds the contiguous subarray within an array (containing at least one number) which has the largest sum and returns its sum. Uses Kadane\'s Algorithm to find the maximum sum subarray in O(n) time complexity. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given an array of integers `nums` and an integer `k`. You need to determine whether there is a pair of distinct indices `(i, j)` such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`. Implement the function `boolean containsNearbyDuplicate(int[] nums, int k)` that returns `true` if such a pair exists and `false` otherwise.","solution":"def containsNearbyDuplicate(nums, k): Returns True if there are two distinct indices i and j in the array such that nums[i] == nums[j] and the absolute difference between i and j is at most k. Otherwise, returns False. num_dict = {} for i, num in enumerate(nums): if num in num_dict and i - num_dict[num] <= k: return True num_dict[num] = i return False"},{"question":"You are given an integer array `arr` of length `n` representing scores of students in a class. Each student is eligible for a star if their score is strictly greater than the scores of their adjacent students. The task is to distribute stars to eligible students such that the number of stars each student receives is as minimal as possible, but not less than 1. Write a function to determine the minimum number of stars to be distributed among all the students.","solution":"def distribute_stars(arr): Distributes stars such that each student with a score greater than their adjacent students receives more stars than those adjacent students. Each student receives at least 1 star. n = len(arr) if n == 0: return 0 # Initialize all students with one star stars = [1] * n # Traverse from left to right, and assign stars considering left neighbor for i in range(1, n): if arr[i] > arr[i - 1]: stars[i] = stars[i - 1] + 1 # Traverse from right to left, and assign stars considering right neighbor for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: stars[i] = max(stars[i], stars[i + 1] + 1) # The total number of stars is the sum of stars array return sum(stars)"},{"question":"You are given two strings `s1` and `s2` of equal length consisting of lowercase letters. You need to transform string `s1` into `s2` using the minimum number of adjacent swaps, where a swap can only be performed between two neighboring characters. Return an integer representing the minimum number of swaps required. If it is not possible to transform `s1` into `s2`, return -1.","solution":"def min_adjacent_swaps(s1, s2): Returns the minimum number of adjacent swaps required to transform s1 into s2. If it is not possible, returns -1. if sorted(s1) != sorted(s2): return -1 swaps = 0 s1 = list(s1) for i in range(len(s2)): j = i while s1[j] != s2[i]: j += 1 while j > i: s1[j], s1[j-1] = s1[j-1], s1[j] swaps += 1 j -= 1 return swaps"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to find two distinct integers `nums[i]` and `nums[j]` (where `i != j`) in the array that add up to `target`. Return _an array containing the indices of the two numbers_, `i` and `j`, in any order. If no such pair exists, return `[-1, -1]`. Each input would have exactly one solution or no solution.","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, returns the indices of the two numbers that add up to the target. Parameters: nums (List[int]): An array of integers. target (int): The target sum. Returns: List[int]: Indices of the two numbers such that they add up to target. If no such pair exists, returns [-1, -1]. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return [-1, -1]"},{"question":"Given a binary tree, write a function to check if it is a symmetric tree. A binary tree is symmetric if you can draw a vertical line through the root and the left subtree is a mirror reflection of the right subtree. Note that an empty tree is symmetric. You should return `true` if the tree is symmetric and `false` otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Function to check if a binary tree is symmetric. if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.right, right.left) and is_mirror(left.left, right.right) return is_mirror(root.left, root.right)"},{"question":"You are given a binary tree. Write a function that returns a list of the tree\'s node values collected using an inorder traversal. The binary tree structure is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Using this structure, implement the function: ```python def inorderTraversal(root: TreeNode) -> List[int]: ``` Your function should handle cases where the tree is empty, and nodes may have either or both left and right children.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root: TreeNode) -> List[int]: result = [] def traverse(node): if node is not None: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"Given a string `s` containing digits from \'0\' to \'9\' and a number `k`, find the largest number that can be formed by deleting exactly `k` digits from `s`.","solution":"def largest_number_after_deletion(s, k): Returns the largest number that can be formed by deleting exactly k digits from the string s containing digits. stack = [] for digit in s: while k > 0 and stack and stack[-1] < digit: stack.pop() k -= 1 stack.append(digit) return \'\'.join(stack[:len(stack) - k])"},{"question":"Given a list of integers, `nums`, and an integer `target`, you need to determine if there are two distinct indices `i` and `j` in the list such that `nums[i] + nums[j] == target`. Return _an array of the two indices_ `[i, j]`. You must implement a solution with a linear runtime complexity, i.e., O(n). If no such indices exist, return `[-1, -1]`.","solution":"def two_sum(nums, target): Returns indices of the two numbers in the list such that they add up to the target. If no such numbers exist, returns [-1, -1]. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]"},{"question":"Given a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children. Each path should be returned as a string in the following format: \\"root->node1->...->leaf\\". The input consists of the root node of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binaryTreePaths(root): Returns all root-to-leaf paths in the binary tree. def construct_paths(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \\"->\\" construct_paths(node.left, path, paths) construct_paths(node.right, path, paths) paths = [] construct_paths(root, \\"\\", paths) return paths"},{"question":"Consider a matrix `mat` where each element is either a 0 or a 1. Each move in the matrix is defined as swapping any element with one of its four neighbors (up, down, left, right). Your task is to transform the matrix such that all 1s are adjacent to each other forming a single connected component. Return the _minimum number of swaps needed_ to achieve this configuration. If it is impossible to form such a connected component, return `-1`. Note: A single connected component of 1s means that there is one contiguous block of 1s with no 1s separated by 0s.","solution":"from collections import deque def min_swaps_to_connect_ones(mat): rows, cols = len(mat), len(mat[0]) def bfs_count_cells_and_is_connected(start_i, start_j): queue = deque([(start_i, start_j)]) visited = set([(start_i, start_j)]) component = [(start_i, start_j)] while queue: i, j = queue.popleft() for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_i, new_j = i + di, j + dj if 0 <= new_i < rows and 0 <= new_j < cols and (new_i, new_j) not in visited: if mat[new_i][new_j] == 1: queue.append((new_i, new_j)) visited.add((new_i, new_j)) component.append((new_i, new_j)) return len(component) == num_ones, component def manhattan_distance(pos1, pos2): return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1]) # Find all positions of 1s one_positions = [(i, j) for i in range(rows) for j in range(cols) if mat[i][j] == 1] num_ones = len(one_positions) if num_ones == 0: return -1 # No swaps needed as there are no 1s at all start_i, start_j = one_positions[0] is_connected, component = bfs_count_cells_and_is_connected(start_i, start_j) if is_connected: return 0 # To form one connected component, the minimum swaps needed can be large. # This problem is non-trivial and requires advanced techniques like Minimum Cost Max Flow or similar methods, # and might be out of the scope for direct implementation in this short format. return -1 # Placeholder for the minimal swaps calculation implementation."},{"question":"Given a string `s`, you need to remove the minimum number of parentheses (either \'(\' or \')\') so that the resulting string is valid. A string is considered valid if it is formed by properly closed parentheses. Return _the resulting string after the removal of the minimum number of parentheses_. If there are multiple valid strings, return any of them. For example: - Input: \\"a)b(c)d\\" - Output: \\"ab(c)d\\"","solution":"def minRemoveToMakeValid(s): This function removes the minimum number of parentheses to make the input string valid. indices_to_remove = set() stack = [] for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: indices_to_remove.add(i) indices_to_remove = indices_to_remove.union(set(stack)) result = [] for i, char in enumerate(s): if i not in indices_to_remove: result.append(char) return \'\'.join(result)"},{"question":"You have a list of non-negative integers `nums`, and you are tasked to implement a function that rearranges the numbers to form the largest possible integer. Since the result might be very large, return the result as a string. **Example:** ``` Input: nums = [3,30,34,5,9] Output: \\"9534330\\" ```","solution":"from functools import cmp_to_key def largestNumber(nums): Rearranges the numbers in `nums` to form the largest possible integer. # Convert all numbers to string to prepare for comparison nums_str = list(map(str, nums)) # Custom comparator to determine the order def compare(a, b): if a + b > b + a: return -1 elif a + b < b + a: return 1 else: return 0 # Sort with custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join sorted array into a single string largest_num = \'\'.join(nums_str) # To handle the case where the array has leading zeros like [0, 0] return \'0\' if largest_num[0] == \'0\' else largest_num"},{"question":"You are given an unsorted integer array `arr` and an integer `k`. Your task is to find the `k`th smallest element in the array. Write a function that implements an efficient algorithm to find this element using a divide-and-conquer method. Return the `k`th smallest element in the array. Note that the elements in the array are distinct and the value of `k` is always valid (1  `k`  length of the array).","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in the unsorted array using Quickselect method. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(left, right, k_smallest): Returns the k-th smallest element of list within left..right. if left == right: return arr[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"You are given an integer array `arr` and an integer `target`. Each element in the array represents a coin of that denomination. You can use each coin as many times as you want. Return the number of distinct combinations that you can use to sum up to `target`. If no combination can be found, return `0`. A combination is considered distinct if the frequency of at least one coin in the combination is different.","solution":"def coin_combinations(arr, target): Return the number of distinct combinations to sum up to the target using coins in the given array. :param arr: List[int] - List of available coin denominations :param target: int - Target sum :return: int - Number of distinct combinations to reach the target # Initialize a list to store the number of ways to make each amount dp = [0] * (target + 1) dp[0] = 1 # There is one way to make 0, which is to use no coins # Iterate over each coin for coin in arr: # Update the combinations count for each possible sub-target for amount in range(coin, target + 1): dp[amount] += dp[amount - coin] return dp[target]"},{"question":"Given a string `s` that consists of only digits, you can remove at most one digit from the string so that the resulting string is the largest possible number. Return the largest possible number you can obtain by removing one digit from `s`.","solution":"def largest_number_after_removal(s: str) -> str: This function takes a string s consisting of only digits and removes at most one digit to form the largest possible number. It returns the resulting largest possible number as a string. max_number = \\"\\" for i in range(len(s)): # Create a new number by skipping the digit at index i new_number = s[:i] + s[i+1:] # Compare to find the maximum number if new_number > max_number: max_number = new_number return max_number"},{"question":"Imagine you are playing a game in which you must collect keys to unlock a series of doors. Each key can unlock only certain doors, and you must determine if a sequence of keys can be used to open all required doors. You are given an array `keys` where each element is a list of doors that a specific key can open, and a list `doors` of integers representing doors that need to be opened. Return `true` if it is possible to use the keys to open all the doors in the `doors` list, and `false` otherwise. For example: ```python keys = [[1, 2], [2, 3], [5]] doors = [1, 3, 5] ``` In this example, return `true` because there is a sequence of keys that can open all doors: key 1 opens doors 1 and 2, key 2 opens doors 2 and 3, and key 3 opens door 5.","solution":"def can_open_all_doors(keys, doors): Determine if it\'s possible to open all doors using the given keys. :param keys: List[List[int]] - a list where each element is a list of doors that a specific key can open :param doors: List[int] - a list of doors that need to be opened :return: bool - True if all doors can be opened, False otherwise # Create a set to store all unique doors that can be opened by the given keys openable_doors = set() # Add each door from the key\'s list to the openable_doors set for key in keys: openable_doors.update(key) # Check if all doors that need to be opened are in the openable_doors set for door in doors: if door not in openable_doors: return False return True"},{"question":"You are given a **0-indexed** matrix `mat` of `m` rows and `n` columns consisting of non-negative integers. A magic square is a `3x3` square submatrix such that the sum of each row, column, and both diagonals are equal. Your task is to determine the number of `3x3` magic squares present in the given matrix `mat`. Return _the **number** of such magic squares found in the matrix._ Keep in mind, a `3x3` magic square is a submatrix that must satisfy the magic square condition.","solution":"def is_magic(square): s = sum(square[0]) return all(sum(row) == s for row in square) and all(sum(square[i][j] for i in range(3)) == s for j in range(3)) and sum(square[i][i] for i in range(3)) == s and sum(square[i][2-i] for i in range(3)) == s def numMagicSquaresInside(grid): def isValid(x, y): s = {grid[x + i][y + j] for i in range(3) for j in range(3)} return s == {1,2,3,4,5,6,7,8,9} if not grid or len(grid) < 3 or len(grid[0]) < 3: return 0 count = 0 for i in range(len(grid) - 2): for j in range(len(grid[0]) - 2): if isValid(i, j): square = [grid[i+k][j:j+3] for k in range(3)] if is_magic(square): count += 1 return count"},{"question":"Given a string `s` consisting of `n` characters and a set of `m` valid words `words_dict`, find the minimum number of characters needed to be inserted into `s` such that `s` can be segmented into a sequence of one or more dictionary words from `words_dict`. Return the minimum number of insertions required.","solution":"def min_insertions_for_word_break(s, words_dict): Returns the minimum number of insertions required to make \'s\' a valid sequence of words from \'words_dict\'. word_set = set(words_dict) n = len(s) # Create a dp array to store the minimum insertions for each prefix of s dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # No insertions needed for an empty prefix for i in range(1, n + 1): for j in range(i): segment = s[j:i] if segment in word_set: dp[i] = min(dp[i], dp[j]) else: for k in range(i - j + 1): for c in \'abcdefghijklmnopqrstuvwxyz\': new_segment = segment[:k] + c + segment[k:] if new_segment in word_set: dp[i] = min(dp[i], dp[j] + 1) return dp[n]"},{"question":"Write a function that takes two integers, `x` and `y`, and returns the number of valid paths from the top-left to the bottom-right corner of an `x` by `y` grid. You can only move either down or right at any point in time. Calculate the number of paths using a recursive approach, making sure your function handles large grids efficiently.","solution":"def unique_paths(x, y, memo=None): if memo is None: memo = {} if (x, y) in memo: return memo[(x, y)] if x == 1 or y == 1: return 1 memo[(x, y)] = unique_paths(x - 1, y, memo) + unique_paths(x, y - 1, memo) return memo[(x, y)]"},{"question":"You are given a linked list where each node contains an integer value. The linked list is sorted in non-decreasing order, but it may contain duplicates. Your task is to write a function that removes all duplicates from the linked list and returns the head of the updated list. The resulting linked list should still maintain the non-decreasing order.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def deleteDuplicates(head): Removes duplicates from a sorted linked list and returns the head of the updated list. if not head: return head current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head"},{"question":"Given an integer array `nums`, return the number of reverse pairs in the array. A reverse pair is a pair `(i, j)` where `0 <= i < j < nums.length` and `nums[i] > 2 * nums[j]`. To achieve the desired performance, you should aim to devise a solution with a time complexity that is better than `O(n^2)`.","solution":"def reverse_pairs(nums): Returns the number of reverse pairs in the given array. A reverse pair is a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2 * nums[j]. if not nums: return 0 def merge_sort_and_count(arr, left, right): if left >= right: return 0 mid = (left + right) // 2 count = merge_sort_and_count(arr, left, mid) + merge_sort_and_count(arr, mid + 1, right) # Count reverse pairs j = mid + 1 for i in range(left, mid + 1): while j <= right and arr[i] > 2 * arr[j]: j += 1 count += j - (mid + 1) # Merge the two halves temp = [] l, r = left, mid + 1 while l <= mid and r <= right: if arr[l] <= arr[r]: temp.append(arr[l]) l += 1 else: temp.append(arr[r]) r += 1 while l <= mid: temp.append(arr[l]) l += 1 while r <= right: temp.append(arr[r]) r += 1 for i in range(left, right + 1): arr[i] = temp[i - left] return count return merge_sort_and_count(nums, 0, len(nums) - 1)"},{"question":"You are given a list of integers `nums` and a target integer `targetSum`. Your task is to determine if there exists a continuous subarray within `nums` that sums up to `targetSum`. Return `true` if such a subarray exists, otherwise return `false`. A subarray is a contiguous portion of an array, and two subarrays are considered different if they start or end at different indices in the array. A subarray can be empty or contain a single element. For example: - Given `nums = [1, 2, 3, 7, 5]` and `targetSum = 12`, the function should return `true` because there is a subarray `[5, 7]` which sums up to `12`. - Given `nums = [1, 2, 3, 4, 5]` and `targetSum = 20`, the function should return `false` because there\'s no subarray that sums up to `20`.","solution":"def has_subarray_with_target_sum(nums, targetSum): Determines if there exists a continuous subarray within nums that sums up to targetSum. Args: nums: List of integers. targetSum: An integer representing the target subarray sum. Returns: bool: True if such a subarray exists, otherwise False. current_sum = 0 sum_indices_map = {} for i, num in enumerate(nums): current_sum += num if current_sum == targetSum: return True if (current_sum - targetSum) in sum_indices_map: return True sum_indices_map[current_sum] = i return False"},{"question":"You are given a `rows x cols` matrix `mat` of integers and an integer `k`. A **block sum** of the matrix is defined as the sum of all elements in a block, where a block is a submatrix of size `(2k+1) x (2k+1)` and the center of the block is at a given element `(i, j)`. The elements outside the matrix boundary are treated as `0`. Return _a new matrix `answer` where each element `answer[i][j]` is the block sum of `mat` with a center at the element `(i, j)`._","solution":"def matrixBlockSum(mat, k): Calculate the block sum of the matrix. Parameters: - mat: List[List[int]]: The input matrix. - k: int: The size parameter for the blocks. Returns: - List[List[int]]: The resulting matrix where each element is the block sum centered at that element. rows, cols = len(mat), len(mat[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] # Construct the prefix sum matrix for i in range(1, rows + 1): for j in range(1, cols + 1): dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] # Calculate the block sum for each element in the result matrix result = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): r1 = max(0, i - k) r2 = min(rows - 1, i + k) c1 = max(0, j - k) c2 = min(cols - 1, j + k) # Sum in the block using the inclusion-exclusion principle result[i][j] = dp[r2 + 1][c2 + 1] - dp[r1][c2 + 1] - dp[r2 + 1][c1] + dp[r1][c1] return result"},{"question":"You are given a 2D integer grid `grid` where each cell represents the elevation at that point. An island is a group of non-zero cells that are horizontally or vertically adjacent. Water cells are represented by 0s. Two islands are considered distinct if there is at least one cell in one island that is not in the other island. Your task is to determine the number of distinct islands in the grid after considering all connected non-zero cells as single islands.","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c, direction): if ( r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or (r, c) in visited): return \\"\\" visited.add((r, c)) shape = direction shape += dfs(r + 1, c, \\"D\\") # Down shape += dfs(r - 1, c, \\"U\\") # Up shape += dfs(r, c + 1, \\"R\\") # Right shape += dfs(r, c - 1, \\"L\\") # Left shape += \\"B\\" # Backtrack return shape shapes = set() for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r, c) not in visited: shape = dfs(r, c, \\"O\\") # Origin shapes.add(shape) return len(shapes)"},{"question":"A chef is creating a new menu and needs to balance the nutritional value of his dishes. Each dish has a specific calorie count, and he wants to create a set of dishes with exactly `T` calories. Given an array of integers `calories` where each element represents the calorie count of a dish, return the minimum number of dishes needed to achieve exactly `T` calories. If it is not possible to achieve exactly `T` calories with any combination of dishes, return `-1`.","solution":"def min_dishes(calories, T): Given an array of integers `calories` and a target calorie count `T`, return the minimum number of dishes needed to achieve exactly `T` calories. If it is not possible, return -1. dp = [float(\'inf\')] * (T + 1) dp[0] = 0 for calorie in calories: for i in range(T, calorie - 1, -1): if dp[i - calorie] != float(\'inf\'): dp[i] = min(dp[i], dp[i - calorie] + 1) return dp[T] if dp[T] != float(\'inf\') else -1"},{"question":"You are given an array of `n` integers, `arr`, and an integer `k`. An operation consists of choosing any integer from the array and either increasing or decreasing it by 1. Your task is to return _the minimum number of operations required to make all elements of the array equal to `k`_. If it is not possible to make all elements equal to `k`, return `-1`.","solution":"def min_operations_to_make_all_elements_equal(arr, k): Returns the minimum number of operations required to make all elements of the array equal to k. If not possible, returns -1. if not all(isinstance(i, int) for i in arr): return -1 operations = 0 for num in arr: operations += abs(num - k) return operations"},{"question":"You are given an integer array `arr` of positive integers and an integer `target`. You need to determine if there are three distinct elements in `arr` that add up to the `target`. If such elements exist, return `true`, otherwise return `false`. Make sure your algorithm runs with a time complexity of O(n^2).","solution":"def three_sum(arr, target): Determines if there are three distinct elements in arr that add up to the target. Parameters: arr (list): List of positive integers. target (int): The target sum. Returns: bool: True if there exist three distinct elements that add up to the target, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given a binary search tree (BST) with distinct integers, you need to modify it and return a new BST such that every nodes key in the new BST is the same as the original BST but with a twist: each nodes key should be replaced by the sum of all keys greater than or equal to the current key. Your task is to write a function that performs this modification to the BST and returns the new tree.","solution":"class TreeNode: def __init__(self, key=0, left=None, right=None): self.key = key self.left = left self.right = right def bstToGst(root): Modifies a binary search tree (BST) such that each node\'s key is replaced by the sum of all keys greater than or equal to the current key. :param root: The root of the BST :return: The root of the modified BST def reverse_inorder(node, accum): if not node: return accum right_accum = reverse_inorder(node.right, accum) node.key += right_accum return reverse_inorder(node.left, node.key) reverse_inorder(root, 0) return root"},{"question":"Given an array of integers `nums`, return the maximum value of `nums[i] - nums[j]` for all `0 <= j < i < nums.length`. If the array is empty or has only one element, return `0`. Note that `nums[i]` and `nums[j]` must be elements of the array.","solution":"def max_difference(nums): Returns the maximum value of nums[i] - nums[j] for all 0 <= j < i < nums.length. If the array is empty or has only one element, return 0. if len(nums) <= 1: return 0 min_value = nums[0] max_diff = float(\'-inf\') for i in range(1, len(nums)): max_diff = max(max_diff, nums[i] - min_value) min_value = min(min_value, nums[i]) return max_diff if max_diff != float(\'-inf\') else 0"},{"question":"You are given a list of non-negative integers representing the amount of time each student in a class needs to complete a certain project. A student can only work on the project during school hours, from 9 AM to 3 PM, which equals 6 hours each day. Write a function `days_needed(times: List[int]) -> int` that determines the minimum number of school days required for all students to complete their projects, given that only one student can work on his or her project at any given time.","solution":"from typing import List def days_needed(times: List[int]) -> int: Returns the minimum number of school days required for all students to complete their projects. if not times: return 0 total_hours = sum(times) hours_per_day = 6 days = (total_hours + hours_per_day - 1) // hours_per_day # Calculate the ceiling of total hours divided by hours per day return days"},{"question":"Given a string `time` representing a time in 24-hour `HH:MM` format, return the number of minutes that have elapsed from `00:00`. The input string is guaranteed to be a valid time. For example, given the input `\\"14:30\\"`, the function should return `870`, since `14` hours and `30` minutes is `870` minutes past midnight.","solution":"def minutes_from_midnight(time): Given a string `time` representing a time in 24-hour HH:MM format, returns the number of minutes that have elapsed from 00:00 (midnight). Parameters: time (str): A time in HH:MM format. Returns: int: The number of minutes elapsed from midnight. hours, minutes = map(int, time.split(\':\')) return hours * 60 + minutes"},{"question":"Create a `ContactManager` class that manages a list of contacts. Each contact is represented by a unique ID and a contact name. The class should support the following operations: * `ContactManager()` Initializes the contact manager. * `void addContact(int id, string name)` Adds a contact with the given `id` and `name` to the list. If a contact with the given `id` already exists, updates the name. * `void removeContact(int id)` Removes the contact with the given `id` from the list. If no contact with the given `id` exists, does nothing. * `string getContactName(int id)` Returns the name of the contact with the given `id`. If no contact with the given `id` exists, returns an empty string. * `vector<string> searchContactByPrefix(string prefix)` Returns a list of all contact names that start with the given `prefix`, sorted alphabetically. **Example:** * Adding contacts with IDs 1 and 2 with names \\"Alice\\" and \\"Aaron\\", respectively, and then searching with prefix \\"A\\" should return [\\"Aaron\\", \\"Alice\\"]. * If contact with ID 1 is updated to \\"Bob\\" and a search is done with prefix \\"A\\", the result should be [\\"Aaron\\"].","solution":"class ContactManager: def __init__(self): self.contacts = {} def addContact(self, id, name): self.contacts[id] = name def removeContact(self, id): if id in self.contacts: del self.contacts[id] def getContactName(self, id): return self.contacts.get(id, \\"\\") def searchContactByPrefix(self, prefix): return sorted([name for name in self.contacts.values() if name.startswith(prefix)])"},{"question":"Given a 2D grid of integers `grid` representing a map where `0` indicates water and `1` indicates land, an island is defined as a group of `1`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Count the number of distinct islands in the grid. Note that matrix cells connected diagonally are not considered part of the same island. Return the total number of distinct islands. Implement the function `def num_islands(grid: List[List[int]]) -> int:` which takes the 2D grid and returns the number of islands.","solution":"from typing import List def num_islands(grid: List[List[int]]) -> int: if not grid: return 0 num_rows = len(grid) num_cols = len(grid[0]) visited = [[False for _ in range(num_cols)] for _ in range(num_rows)] def dfs(row, col): if row < 0 or col < 0 or row >= num_rows or col >= num_cols or visited[row][col] or grid[row][col] == 0: return visited[row][col] = True dfs(row - 1, col) # up dfs(row + 1, col) # down dfs(row, col - 1) # left dfs(row, col + 1) # right count = 0 for row in range(num_rows): for col in range(num_cols): if grid[row][col] == 1 and not visited[row][col]: dfs(row, col) count += 1 return count"},{"question":"You are given an array of integers `nums` of size `n` and an integer `k`. You need to transform the array by rotating it to the right `k` times. This means that the last `k` elements of the array will become the first `k` elements, shifting the remaining elements `k` positions to the right. Return the array after `k` rotations. Note that `k` can be larger than or equal to `n`.","solution":"def rotate_array(nums, k): Rotates the array to the right by k steps. Parameters: nums (list): The list of integers to rotate. k (int): The number of steps to rotate the array to the right. Returns: list: The rotated list. n = len(nums) if n == 0: return [] k = k % n # Normalize k if it is greater than the length of the array return nums[-k:] + nums[:-k]"},{"question":"A security system operates by validating a sequence of numeric codes. Each code can be repeated in the sequence, but consecutive codes must be distinct. Given a list of codes, validate the sequence based on the following rules: 1. Consecutive codes cannot be equal. 2. There must be at least one instance of a specified mandatory code in the sequence. 3. No required code specified can appear more than a given maximum number of times. Write a function that takes four parameters: 1. A list `codes` representing the sequence of numeric codes. 2. An integer `required_code` representing the code that must appear in the sequence. 3. An integer `max_occurrences` representing the maximum number of times the `required_code` can appear in the sequence. 4. An integer `n` representing the total number of distinct codes in the `codes` list. Return `True` if the sequence meets all the above rules and `False` otherwise. Example: ```python validate_sequence([1, 2, 3, 4, 2, 3], 3, 2, 4) ``` Output: ```python True ``` Explanation: - The codes sequence [1, 2, 3, 4, 2, 3] satisfies the rule as no consecutive codes are the same. - The `required_code` 3 appears twice, which is within the `max_occurrences` limit. - There are 4 distinct codes in the `codes` list, matching the given `n`.","solution":"def validate_sequence(codes, required_code, max_occurrences, n): Validates the code sequence based on the provided rules. Parameters: codes (list of int): The sequence of numeric codes. required_code (int): The code that must appear in the sequence. max_occurrences (int): The maximum occurrences of the required_code in the sequence. n (int): The total number of distinct codes in the codes list. Returns: bool: True if the sequence meets all the rules, False otherwise. if not codes: return False # Check condition 1: Consecutive codes cannot be equal. for i in range(1, len(codes)): if codes[i] == codes[i - 1]: return False # Count occurrences of required_code. required_code_count = codes.count(required_code) # Check condition 2: There must be at least one instance of a specified mandatory code in the sequence. if required_code_count < 1: return False # Check condition 3: No required code specified can appear more than a given maximum number of times. if required_code_count > max_occurrences: return False # Check the number of distinct codes. if len(set(codes)) != n: return False return True"},{"question":"Given a string `s` and an integer `k`, split the string into substrings such that each substring has exactly `k` distinct characters. Return the number of such substrings you can form. If it\'s not possible to split the string in such a way, return `0`. You can assume that the string contains only lowercase English letters and its length does not exceed `10^5`.","solution":"def count_k_distinct_substrings(s, k): Returns the number of substrings of length \'k\' with exactly \'k\' distinct characters. If it is not possible to split the string in such a way, return 0. if k > len(s): return 0 n = len(s) result = 0 for i in range(n - k + 1): substring = s[i:i + k] if len(set(substring)) == k: result += 1 return result"},{"question":"Given a string `s` containing only characters \'a\', \'b\', and \'c\', you need to remove the minimum number of characters from the string so that the string becomes balanced. A string is considered balanced if no two consecutive characters are the same. Return the minimum number of deletions required to balance the string.","solution":"def minimum_deletions_to_balance(s): deletions = 0 i = 0 while i < len(s) - 1: if s[i] == s[i+1]: deletions += 1 i += 1 return deletions"},{"question":"You are given a string `s` which consists of only lowercase English letters. You can perform at most one operation on this string, in which you can select any one character and remove it from the string. Your goal is to determine the length of the longest palindrome that can be obtained by performing at most one such operation. Return the _length of the longest possible palindrome_ obtainable from the given string `s`.","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be obtained by removing at most one character from the string s. def is_palindrome(sub): return sub == sub[::-1] if is_palindrome(s): # The original string is already a palindrome return len(s) n = len(s) for i in range(n): if is_palindrome(s[:i] + s[i+1:]): return n - 1 return n - 2 # In the worst case, removing one character doesn\'t help much # Example test case # s = \\"abac\\", removes \'b\' or \'c\' to get \\"aba\\" # longest_palindrome_length(\\"abac\\") should return 3"},{"question":"Given a list of integers `nums` and an integer `target`, return all unique pairs of integers from the list that add up to the `target`. Each pair should be returned as a list with two elements. The solution set must not contain duplicate pairs, and the order of the pairs does not matter. If no such pairs exist, return an empty list.","solution":"def two_sum_pairs(nums, target): Returns all unique pairs of integers that add up to the target. seen = set() output = set() for num in nums: complement = target - num if complement in seen: output.add(tuple(sorted((num, complement)))) seen.add(num) return [list(pair) for pair in output]"},{"question":"Implement a class `TimeMap` to store key-value pairs along with a timestamp, and retrieve the value of a key at a particular timestamp, or the latest value before that timestamp. Implement the `TimeMap` class as follows: - `TimeMap()` Initializes the object of the `TimeMap` class. - `void set(string key, string value, int timestamp)` Stores the key `key` with the value `value` at the given `timestamp`. - `string get(string key, int timestamp)` Returns the value associated with `key` at the largest possible time `t` in the range `[0, timestamp]`. If there is no such `t`, return an empty string. Your implementation should appropriately handle a sequence of operations and be efficient in both time and space.","solution":"from collections import defaultdict import bisect class TimeMap: def __init__(self): self.store = defaultdict(list) def set(self, key, value, timestamp): Stores the key with the value at the given timestamp. self.store[key].append((timestamp, value)) def get(self, key, timestamp): Returns the value associated with the key at the largest possible time <= timestamp. If no such value exists, returns an empty string. if key not in self.store: return \\"\\" values = self.store[key] idx = bisect.bisect_right(values, (timestamp, chr(255))) if idx == 0: return \\"\\" else: return values[idx-1][1]"},{"question":"You are given an **n x n** grid representing a maze where each cell can either be a wall `\'W\'` or an empty space `\'.\'`. You can only move horizontally or vertically to an adjacent cell. The goal is to determine if there is a path from the top-left cell to the bottom-right cell. Return `true` if such a path exists, and `false` otherwise.","solution":"def is_path(maze): Determine if there is a path from the top-left cell to the bottom-right cell. Parameters: maze (list of list of str): The n x n grid representing the maze. Returns: bool: True if there is a path from top-left to bottom-right, False otherwise. def dfs(x, y): # If we are out of bounds or at a wall, return False if not (0 <= x < len(maze) and 0 <= y < len(maze[0])) or maze[x][y] == \'W\': return False # If we have reached the bottom-right corner, return True if x == len(maze) - 1 and y == len(maze[0]) - 1: return True # Mark the cell as visited maze[x][y] = \'W\' # Explore in all four directions if (dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1)): return True # Unmark the cell (backtracking) maze[x][y] = \'.\' return False # Start DFS from the top-left corner return dfs(0, 0)"},{"question":"Given a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom. The binary tree is represented by the root node, which is an instance of `TreeNode` with properties including `val`, `left`, and `right`. Your function should return a list of integers representing the visible nodes\' values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes visible from the right side of the binary tree. if not root: return [] result = [] queue = [(root, 0)] rightmost_value_at_depth = dict() max_depth = -1 while queue: node, depth = queue.pop(0) if node: max_depth = max(max_depth, depth) rightmost_value_at_depth[depth] = node.val queue.append((node.left, depth + 1)) queue.append((node.right, depth + 1)) return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]"},{"question":"You are given an array `arr` of integers and an integer `d`. Your task is to ensure that for every element in the array, the absolute difference between any two consecutive elements is less than or equal to `d`. If it\'s already true, return the same array. Otherwise, find the lexicographically smallest array that satisfies this condition and return it. If there are multiple solutions, return the one with the smallest sum of its elements.","solution":"def ensure_difference(arr, d): Ensures that for every element in the array, the absolute difference between any two consecutive elements is less than or equal to d. n = len(arr) if not arr or n < 2: return arr result = [arr[0]] for i in range(1, n): if abs(arr[i] - result[-1]) > d: result.append(result[-1] + d if arr[i] > result[-1] else result[-1] - d) else: result.append(arr[i]) return result"},{"question":"Write a function to determine if a given positive integer `n` is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper positive divisors, excluding the number itself. For example, 28 is a perfect number because its divisors (excluding 28) are 1, 2, 4, 7, and 14, and 1 + 2 + 4 + 7 + 14 = 28. Return `true` if `n` is a perfect number, otherwise return `false`.","solution":"def is_perfect_number(n): Determine if a given positive integer `n` is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper positive divisors, excluding the number itself. Parameters: n (int): the positive integer to check Returns: bool: `True` if `n` is a perfect number, otherwise `False` if n <= 1: return False sum_divisors = 0 for i in range(1, n): if n % i == 0: sum_divisors += i return sum_divisors == n"},{"question":"A city is represented as a 2D grid where each cell is either a building (represented by 1) or an empty land (represented by 0). The distance between two points is measured as the sum of the absolute differences in their row and column indices. You are asked to build a school that minimizes the sum of the distances from the school to all the buildings. Return the minimal distance sum. If it is not possible to build a school such that every building can access it (i.e., the grid has no 0s), return `-1`.","solution":"from collections import deque def min_distance_sum(grid): # Edge case - no empty land to build the school if not any(0 in row for row in grid): return -1 rows, cols = len(grid), len(grid[0]) total_dist = [[0] * cols for _ in range(rows)] reach = [[0] * cols for _ in range(rows)] buildings = sum(val for line in grid for val in line if val == 1) def bfs(start_r, start_c): visited = [[False] * cols for _ in range(rows)] dist = [[0] * cols for _ in range(rows)] queue = deque([(start_r, start_c, 0)]) directions = [(0,1),(1,0),(0,-1),(-1,0)] while queue: r, c, d = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 0: visited[nr][nc] = True dist[nr][nc] = d + 1 total_dist[nr][nc] += d + 1 reach[nr][nc] += 1 queue.append((nr, nc, d + 1)) for r in range(rows): for c in range(cols): if grid[r][c] == 1: bfs(r, c) min_dist = float(\'inf\') for r in range(rows): for c in range(cols): if grid[r][c] == 0 and reach[r][c] == buildings: min_dist = min(min_dist, total_dist[r][c]) return -1 if min_dist == float(\'inf\') else min_dist"},{"question":"Given a 2D grid of integers representing a map where `0` represents water and `1` represents land, your task is to determine the total number of distinct islands. An island is defined as a group of connected `1`s (land) and it\'s connected **horizontally or vertically**. Consider two islands distinct if and only if one island is not a part of another (i.e., one island must have at least one cell that is not shared with the other). You need to return the _total number of distinct islands_.","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in a 2D grid. def dfs(r, c, di, island): if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 1: island.add((r - di[0], c - di[1])) grid[r][c] = 0 # mark as visited dfs(r + 1, c, di, island) dfs(r - 1, c, di, island) dfs(r, c + 1, di, island) dfs(r, c - 1, di, island) distinct_islands = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: island = set() dfs(r, c, (r, c), island) if island: distinct_islands.add(frozenset(island)) return len(distinct_islands)"},{"question":"You are given a list of strings `wordList` of length `n` and a target string `targetWord`. Each word in `wordList` has the same length as `targetWord`. You need to transform `targetWord` into another word by changing exactly one character at a time. Each transformed word must exist in `wordList`. Your task is to determine the minimum number of transformations needed to convert `targetWord` into any word in `wordList` that is closest to the last word in the `wordList` (minimum lexicographical order in case of multiple words). If no such transformation is possible, return `-1`. Implement the function `int minTransformations(List<String> wordList, String targetWord)`.","solution":"from collections import deque def is_one_char_different(word1, word2): Helper function to determine if two words differ by exactly one character. if len(word1) != len(word2): return False diff_count = sum(1 for a, b in zip(word1, word2) if a != b) return diff_count == 1 def minTransformations(wordList, targetWord): Returns the minimum number of transformations needed to convert targetWord into any word in wordList that is closest to the last word in the wordList. If no such transformation is possible, returns -1. wordList = set(wordList) # Convert to set for O(1) lookups if targetWord not in wordList: # If target word isn\'t in the list, no transformation is possible return -1 # Breadth-First Search (BFS) to find the minimum transformation steps queue = deque([(targetWord, 0)]) visited = set(targetWord) while queue: current_word, steps = queue.popleft() for word in wordList: if word not in visited and is_one_char_different(current_word, word): if word in wordList: return steps + 1 # Target word found visited.add(word) queue.append((word, steps + 1)) return -1 # Example usage: # wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] # targetWord = \\"hit\\" # print(minTransformations(wordList, targetWord)) # Output should be 4 in the ideal case"},{"question":"You are given a list of non-negative integers representing the heights of pillars where the width of each pillar is 1. These pillars form a histogram. Compute the area of the largest rectangle that can be formed within the bounds of the histogram. The rectangle must be aligned with the coordinate axes and can span across multiple consecutive pillars. Return the maximum possible area of such a rectangle.","solution":"def largestRectangleArea(heights): Calculates the largest rectangular area that can be formed within a histogram defined by heights. max_area = 0 stack = [] # this will store the indices of the histogram bars for i in range(len(heights)): # maintain the stack in increasing order while stack and heights[i] < heights[stack[-1]]: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) # process any remaining bars in the stack while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"You are given an integer array `arr` of length `n` which represents a permutation of integers from `1` to `n`. A **valid segment** is a contiguous subarray of `arr` such that if you sort the subarray in non-decreasing order, the subarray will still form a contiguous segment of numbers from `k` to `k + m - 1` for some integers `k` and `m >= 1`. Find the length of the longest valid segment in `arr`. Return _an integer representing the length of the longest valid segment_.","solution":"def longest_valid_segment(arr): Returns the length of the longest valid segment in the permutation array `arr`. n = len(arr) max_len = 1 current_len = 1 for i in range(1, n): if arr[i] - arr[i - 1] == 1: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"You are given a list of `n` integers `heights` representing the heights of `n` people standing in a queue. The queue has a particular property where each person must either see the person in front of them, or if blocked, they must count the number of people who are taller than the person directly in front of them until they can see. A person `i` can see the person in front of them `j` if `heights[j]` is greater than `heights[i]`, and they must count the number of taller people blocking their view otherwise. Return an array `view_count` of length `n` where `view_count[i]` is the count of people blocking the view of person `i`. Note: The person at the front of the queue (index 0) has a clear view and their view count is 0.","solution":"def count_blocking_view(heights): n = len(heights) view_count = [0] * n for i in range(1, n): count = 0 j = i - 1 while j >= 0: if heights[j] > heights[i]: count += 1 j -= 1 view_count[i] = count return view_count"},{"question":"# New Question 4: Given an `m x n` matrix `matrix` and an integer `k`, return the **kth smallest element** in the matrix. Note that it is the `kth smallest element` in the sorted order, not the `kth distinct` element. The matrix is sorted in ascending order both row-wise and column-wise.","solution":"import heapq def kth_smallest(matrix, k): Finds the kth smallest element in a sorted matrix. :param matrix: List[List[int]], a 2D list representing the matrix :param k: int, the position of the smallest element to find :return: int, the kth smallest element in the matrix n = len(matrix) min_heap = [] # Initialize min heap with the first element of each row. for r in range(min(k, n)): # Only need to consider at most k rows. heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k-1 times to get to the kth smallest element. for i in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"You are given a `2D` matrix `matrix` of integers and an integer `target`. The task is to find the `maximum sum` of a non-empty submatrix in `matrix` such that this sum is less than or equal to `target`. A submatrix is a group of contiguous cells forming a rectangle within the original matrix. Return the maximum sum of such submatrix, or `0` if no such submatrix exists.","solution":"import bisect def maxSumSubmatrix(matrix, target): Returns the maximum sum of a submatrix that is less than or equal to target. If no such submatrix exists, returns 0. def maxSumSubarray(nums, k): # Function to find the maximum sum of a subarray that\'s no more than k accu_sum = 0 accu_set = [0] max_sum = float(\'-inf\') for num in nums: accu_sum += num idx = bisect.bisect_left(accu_set, accu_sum - k) if idx < len(accu_set): max_sum = max(max_sum, accu_sum - accu_set[idx]) bisect.insort(accu_set, accu_sum) return max_sum if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_result = float(\'-inf\') for left in range(cols): row_sum = [0] * rows for right in range(left, cols): for r in range(rows): row_sum[r] += matrix[r][right] current_max = maxSumSubarray(row_sum, target) if current_max == target: return target # Found the best possible solution max_result = max(max_result, current_max) return max_result if max_result != float(\'-inf\') else 0"},{"question":"Given a string `s` consisting of lowercase English letters, we need to calculate the number of distinct substrings (consecutive characters) that can be formed from the string. A substring is defined as any sequence of consecutive characters of `s`. Return the total number of distinct substrings.","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of the given string s. substrings = set() for i in range(len(s)): for j in range(i+1, len(s)+1): substrings.add(s[i:j]) return len(substrings)"},{"question":"Given an integer array `nums`, return _the number of elements that have an even number of digits_.","solution":"def count_even_digit_numbers(nums): Returns the number of elements in the input list that have an even number of digits. :param nums: List of integers :return: Integer count of elements with an even number of digits def is_even_digit_count(num): return len(str(abs(num))) % 2 == 0 return sum(1 for num in nums if is_even_digit_count(num))"},{"question":"You are given a string `s` containing only lowercase alphabetic characters. You need to find and return the length of the **longest substring** of `s` where the characters are in **alphabetical order**. Characters are considered to be in alphabetical order if they appear naturally in sequential order in the alphabet, for instance, \\"abc\\" is in alphabetical order, while \\"acb\\" is not. For example, given the string `\\"abacbed\\"`, the longest substring is `\\"ab\\"`, with a length of 2, since \\"abc\\" is a valid substring but interrupted by \\"a\\".","solution":"def longest_alphabetical_substring(s): Finds the length of the longest substring with characters in alphabetical order. Parameters: s (str): A string containing only lowercase alphabetic characters. Returns: int: Length of the longest alphabetical substring. if not s: return 0 max_len = 1 current_len = 1 for i in range(1, len(s)): if s[i] >= s[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"You are given a 2D integer grid `grid` representing a maze where `0` represents an open path and `1` represents a wall. You start at the top-left corner of the grid and need to reach the bottom-right corner. From each cell, you can move in the four cardinal directions (left, right, up, down) to an adjacent cell that is within the boundaries of the grid and is an open path (`0`). Implement a function that returns the minimum number of steps required to reach the bottom-right corner from the top-left corner. If there is no valid path, return `-1`.","solution":"from collections import deque def min_steps_maze(grid): Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner in a given 2D grid maze. Returns -1 if there is no valid path. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False for _ in range(cols)] for _ in range(rows)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited[0][0] = True while queue: row, col, steps = queue.popleft() # Check if we have reached the bottom-right corner if row == rows - 1 and col == cols - 1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and not visited[new_row][new_col] and grid[new_row][new_col] == 0: visited[new_row][new_col] = True queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"Given an array of strings `words`, return _an array of all the unique character sets that can be used to form all the words in the array_. Each character set should be represented in the form of a dictionary where keys are characters and values are their respective frequencies. The goal is to find the smallest number of unique character sets that can construct each word in the array (without sharing characters between sets for each word). Assume no two words in the array share common characters.","solution":"from collections import Counter def unique_character_sets(words): Given an array of strings \'words\', returns an array of all the unique character sets that can be used to form all the words in the array in terms of dictionaries with character frequencies. return [Counter(word) for word in words]"},{"question":"A company warehouse is represented by a 2D grid, `warehouse`, consisting of `0`s (empty spaces) and `1`s (spaces occupied by obstacles). The warehouse has a robot that can move up, down, left, or right, and is initially located at the top-left corner (start position) `[0, 0]`. The robot is trying to reach the bottom-right corner (goal position) `[m-1, n-1]`. However, it can only move to empty spaces and cannot move outside the grid or into spaces occupied by obstacles. Return `true` if the robot can reach the goal position, and `false` otherwise.","solution":"def can_robot_reach_goal(warehouse): Determine if the robot can reach the bottom-right corner of the grid. :param warehouse: List[List[int]], a 2D grid representing the warehouse :return: bool, True if the robot can reach the goal, False otherwise if not warehouse or not warehouse[0]: return False m, n = len(warehouse), len(warehouse[0]) if warehouse[0][0] == 1 or warehouse[m-1][n-1] == 1: return False from collections import deque directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) warehouse[0][0] = 1 # mark as visited while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and warehouse[nx][ny] == 0: queue.append((nx, ny)) warehouse[nx][ny] = 1 # mark as visited return False"},{"question":"Given an integer array `nums`, return a list of all possible unique subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. For example, if `nums = [1,2,2]`, a solution is: ``` [ [], [1], [2], [1,2], [2,2], [1,2,2] ] ``` You must write an algorithm that evaluates all subsets of the given array while ensuring no duplicates in the resulting power set.","solution":"import itertools def subsets(nums): Returns list of all possible unique subsets of the nums array. nums.sort() # Sort to handle duplicates result = [] for i in range(len(nums) + 1): for combo in itertools.combinations(nums, i): if list(combo) not in result: result.append(list(combo)) return result"},{"question":"You are given a 2D integer array `rectangles` where `rectangles[i] = [li, wi]` represents the length and width of the `i-th` rectangle on a 2D plane. Return _the number of squares_ you can form by selecting a side length `len` such that `len` is less than or equal to both the length and width of at least one rectangle in the origin list. A square\'s side length must be a positive integer. If two rectangles can form squares of the same size determine only one of those, so the square count doesn\'t include duplicates.","solution":"def count_squares(rectangles): Returns the number of unique side lengths that can form squares. Arguments: rectangles : List[List[int]] : list of rectangles dimensions [li, wi] Returns: int : number of unique square side lengths unique_squares = set() for l, w in rectangles: min_side = min(l, w) for length in range(1, min_side + 1): unique_squares.add(length) return len(unique_squares)"},{"question":"Design a **Trie** (prefix tree) without using any built-in libraries. A **Trie** is a tree-like data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure such as autocomplete and spell checker. For example, consider the sequence of operations: ``` Trie trie = new Trie(); trie.insert(\\"apple\\"); trie.search(\\"apple\\"); // returns true trie.search(\\"app\\"); // returns false trie.startsWith(\\"app\\"); // returns true trie.insert(\\"app\\"); trie.search(\\"app\\"); // returns true ``` Implement the `Trie` class: * `Trie()` Initializes the Trie object. * `void insert(String word)` Inserts the string `word` into the Trie. * `boolean search(String word)` Returns `true` if the string `word` is in the Trie, and `false` otherwise. * `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string in the Trie that has the prefix `prefix`, and `false` otherwise. Note that you may assume all inputs are lowercase English letters.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"Given a string `s` consisting of only the characters `(` and `)`, find the **length** of the longest substring that forms a valid parentheses sequence. A valid parentheses sequence is one where all opened parentheses are properly closed. Write a function: ```python def longestValidParentheses(s: str) -> int: # Your code here ``` # Example: ``` Input: s = \\"(()\\" Output: 2 Explanation: The longest valid parentheses substring is \\"()\\". Input: s = \\")()())\\" Output: 4 Explanation: The longest valid parentheses substring is \\"()()\\". ``` # Constraints: - `0 <= s.length <= 3 * 10^4` - `s[i]` is either `(` or `)`","solution":"def longestValidParentheses(s: str) -> int: Returns the length of the longest valid parentheses substring. max_len = 0 stack = [-1] # Stack to hold the indices for i, char in enumerate(s): if char == \'(\': stack.append(i) else: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: stack.append(i) return max_len"},{"question":"You are given a string `s` consisting of lowercase English letters. A **cyclic shift** of the string means moving the last character to the front. For example, the cyclic shifts of the string `abc` are: `cab` (shift once), and `bca` (shift twice). Determine the number of distinct strings that can be obtained by performing a number of cyclic shifts (including the original string). Implement the function `int distinctCyclicShifts(String s)` that takes the string `s` as input and returns the number of distinct strings that can be obtained by performing cyclic shifts on `s`. The function should be efficient in terms of both time and space complexity.","solution":"def distinct_cyclic_shifts(s): Return the number of distinct cyclic shifts of the input string s. n = len(s) if n == 0: return 0 # Create a suffix array of s + s double_s = s + s suffixes = sorted(double_s[i:i+n] for i in range(n)) # Find the number of distinct strings in the sorted list of suffixes distinct_count = 1 for i in range(1, n): if suffixes[i] != suffixes[i - 1]: distinct_count += 1 return distinct_count"},{"question":"You are given a 2D grid `board` of size `m x n` which represents a battleship board, where each cell is either a battleship (\'X\') or empty (\'.\'). A battleship is represented by one or more consecutive \'X\'s vertically or horizontally. There are no adjacent battleships (i.e., no two battleships will share a cell that is horizontally, vertically, or diagonally adjacent). Return the number of distinct battleships on the board.","solution":"def count_battleships(board): Returns the number of distinct battleships on the board. if not board or not board[0]: return 0 m, n = len(board), len(board[0]) count = 0 for i in range(m): for j in range(n): if board[i][j] == \'X\': if (i == 0 or board[i-1][j] == \'.\') and (j == 0 or board[i][j-1] == \'.\'): count += 1 return count"},{"question":"You are given an **m x n** grid `grid` of 0\'s (representing water) and 1\'s (representing land). An island is a maximal 4-directionally connected group of 1\'s. You need to determine the largest island\'s size. If no island exists, return 0. Consider the following rules: 1. You may connect two 1\'s from different islands by flipping exactly one 0 to 1. 2. The size of an island is the number of 1\'s it contains. Implement the function `largestIsland(grid: List[List[int]]) -> int` that returns the size of the largest possible island after exactly one 0 is flipped to 1.","solution":"from typing import List def largestIsland(grid: List[List[int]]) -> int: def dfs(x, y, index): stack = [(x, y)] seen.add((x, y)) area = 0 while stack: cx, cy = stack.pop() area += 1 island_ids[cx][cy] = index for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < row and 0 <= ny < col and (nx, ny) not in seen and grid[nx][ny] == 1: stack.append((nx, ny)) seen.add((nx, ny)) return area row, col = len(grid), len(grid[0]) island_ids = [[0] * col for _ in range(row)] island_areas = {} index = 2 seen = set() for i in range(row): for j in range(col): if grid[i][j] == 1 and (i, j) not in seen: area = dfs(i, j, index) island_areas[index] = area index += 1 max_area = max(island_areas.values(), default=0) for i in range(row): for j in range(col): if grid[i][j] == 0: possible_area = 1 seen_islands = set() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + dx, j + dy if 0 <= ni < row and 0 <= nj < col and grid[ni][nj] == 1: island_id = island_ids[ni][nj] if island_id not in seen_islands: possible_area += island_areas[island_id] seen_islands.add(island_id) max_area = max(max_area, possible_area) return max_area"},{"question":"You are given a list of meeting time intervals `intervals` where each interval is represented as a tuple of two integers `[start, end]`, representing the start and end times of the meeting respectively. You need to determine if a person could attend all meetings. Implement the function `canAttendMeetings(intervals)` that returns a boolean value, `True` if a person can attend all the given meetings without any overlap, and `False` otherwise.","solution":"def canAttendMeetings(intervals): Determines if a person can attend all meetings without overlap. Args: intervals (list of tuples): List of meeting time intervals represented as tuples (start, end). Returns: bool: True if a person can attend all meetings without overlap, False otherwise. intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"You are given an array of positive integers representing job durations, `jobs`, where `jobs[i]` is the duration of the `i-th` job in hours. Additionally, you are given an integer `days`, which represents the number of days you have to complete all the jobs. Each day, you can decide the order in which you tackle the jobs, but you cannot split a job between days. You wish to minimize the maximum number of hours worked on any single day to complete all jobs within the given number of days. Return _the minimum possible maximum number of hours worked on any single day to complete all jobs within_ `days`.","solution":"def canComplete(jobs, days, max_hours): current_hours = 0 required_days = 1 for job in jobs: if current_hours + job > max_hours: required_days += 1 current_hours = 0 current_hours += job return required_days <= days def minMaxHours(jobs, days): left, right = max(jobs), sum(jobs) while left < right: mid = (left + right) // 2 if canComplete(jobs, days, mid): right = mid else: left = mid + 1 return left"},{"question":"Given two arrays of integers `nums1` and `nums2`, return the element-wise maximum of the two arrays. The element-wise maximum of two arrays is a new array such that each element at index `i` from the new array is the maximum of `nums1[i]` and `nums2[i]`. If the lengths of `nums1` and `nums2` are not the same, fill the shorter array with `-Infinity` until they are of equal length. For example, if `nums1 = [1, 2, 3]` and `nums2 = [2, 3, 1]`, the output should be `[2, 3, 3]`. Similarly, if `nums1 = [4, 5]` and `nums2 = [1, 6, 7]`, the output should be `[4, 6, 7]` (considering `nums1` as `[4, 5, -Infinity]` to match the length of `nums2`).","solution":"def element_wise_max(nums1, nums2): Returns the element-wise maximum of two arrays. If lengths of nums1 and nums2 are not the same, fill the shorter array with -Infinity until they are of equal length. len1, len2 = len(nums1), len(nums2) # Fill the shorter list with -Infinity up to the size of the longer list if len1 < len2: nums1 += [-float(\'inf\')] * (len2 - len1) elif len2 < len1: nums2 += [-float(\'inf\')] * (len1 - len2) # Calculate the element-wise maximum result = [max(a, b) for a, b in zip(nums1, nums2)] return result"},{"question":"You are given `n` bulbs arranged in a row, numbered from `1` to `n`. Initially, all the bulbs are off. You also have an array `flipOperations` where `flipOperations[i]` represents the position of the bulb that is flipped in the `i`-th operation. When a bulb is flipped, its state changes from ON to OFF or from OFF to ON. For example, if a bulb is initially OFF (0) and is flipped, it becomes ON (1). If it is ON (1) and is flipped, it becomes OFF (0). Return the minimum number of bulbs that are still ON at the end of all the flip operations. The array `flipOperations` will contain at least one element, and each flip operation will be valid (i.e., refer to an existing bulb).","solution":"def min_bulbs_on(n, flipOperations): Returns the minimum number of bulbs that are still ON at the end of all flip operations. :param n: The number of bulbs. :param flipOperations: List of positions of the bulbs to be flipped. :return: The number of bulbs that are ON at the end. bulbs = [0] * n for pos in flipOperations: bulbs[pos - 1] ^= 1 return sum(bulbs)"},{"question":"Given an array of integers `nums`, you are allowed to perform at most `k` consecutive decrements to any element in the array. Return the maximum possible sum of the array after performing the decrements.","solution":"def max_possible_sum(nums, k): Returns the maximum possible sum of the array after performing at most k consecutive decrements to any element. nums.sort(reverse=True) max_sum = sum(nums) for i in range(len(nums)): while k > 0 and nums[i] > 0: nums[i] -= 1 max_sum -= 1 k -= 1 return max_sum"},{"question":"Given a linked list, implement a function `reorderList` that rearranges the nodes in a specific order. The goal is to reorder the list so that the result alternates between the first and the last remaining nodes. Specifically, the resulting list should follow the sequence - first node, last node, second node, second last node, and so on. For example, given the list `1 -> 2 -> 3 -> 4 -> 5`, the reordered list should be `1 -> 5 -> 2 -> 4 -> 3`. Implement the `reorderList` function taking the head of the linked list as its parameter and returning nothing (the list should be modified in place). ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: # Your implementation here ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: if not head or not head.next: return # Use a slow and fast pointer to find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev, curr = None, slow while curr: nxt = curr.next curr.next = prev prev = curr curr = nxt # Merge the two halves first, second = head, prev while second.next: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first = temp1 second = temp2"},{"question":"Given an integer array `nums` of size `n`, return _the length of the longest subsequence that is a strict alternation of increase and decrease._ In other words, find and return the length of the longest subsequence such that no two consecutive elements in the subsequence are either both increasing or both decreasing.","solution":"def longest_alternating_subsequence(nums): Returns the length of the longest alternating subsequence of nums. if not nums: return 0 n = len(nums) up = [1] * n down = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: up[i] = max(up[i], down[j] + 1) elif nums[i] < nums[j]: down[i] = max(down[i], up[j] + 1) return max(max(up), max(down))"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to determine if there exists a **subarray** whose sum is equal to `k`. A subarray is a contiguous part of the array. Return `true` if such a subarray exists, otherwise return `false`. For example, given `nums = [1, 2, 3, 4, 5]` and `k = 9`, the answer would be `true` because the subarray `[2, 3, 4]` has a sum of 9. If `nums = [1, 2, 3, 4, 5]` and `k = 15`, the answer would be `true` because the subarray `[1, 2, 3, 4, 5]` sums to 15, and if `nums = [1, 2, 3, 4, 5]` and `k = 20`, the answer would be `false` as no subarray sums to 20.","solution":"def subarray_sum(nums, k): Returns true if there exists a subarray in nums whose sum is equal to k otherwise false. current_sum = 0 sum_map = {0: True} for num in nums: current_sum += num if (current_sum - k) in sum_map: return True sum_map[current_sum] = True return False"},{"question":"You are given an array of integers `nums`, and another integer `x`. Your task is to determine whether there exists a **subarray** of `nums` with a sum equal to `x`. A subarray is a contiguous portion of an array, meaning it contains a sequence of consecutive elements from the original array. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def subarray_with_sum(nums, x): Determines if there exists a subarray with sum equal to x. :param nums: List of integers. :param x: Target sum. :return: Boolean indicating whether such a subarray exists. current_sum = 0 sums = {} for i, num in enumerate(nums): current_sum += num if current_sum == x: return True if (current_sum - x) in sums: return True sums[current_sum] = i return False"},{"question":"You are given two strings `s1` and `s2`. Write a function that returns _the length of the longest common substring of_ `s1` _and_ `s2`. A substring is a contiguous sequence of characters within a string.","solution":"def longest_common_substring_length(s1, s2): Returns the length of the longest common substring between two strings. if not s1 or not s2: return 0 len_s1, len_s2 = len(s1), len(s2) longest = 0 # Create a 2D list to store lengths of longest common suffixes dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)] # Build the dp array from bottom up for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 longest = max(longest, dp[i][j]) return longest"},{"question":"You are given a string `s` which consists of lowercase English letters and contains at least one letter \'a\'. Your task is to find and return the length of the shortest substring of `s` that contains at least one of every different letter that appears in `s`. Implement a function `int shortestUniqueSubstring(String s)` that takes the string `s` as input and returns the length of the shortest substring containing all unique characters present in `s`.","solution":"def shortestUniqueSubstring(s): Returns the length of the shortest substring that contains at least one of every different letter that appears in s. unique_chars = set(s) required_char_count = len(unique_chars) left = 0 min_length = float(\'inf\') char_frequency = {} num_unique_found = 0 for right in range(len(s)): if s[right] not in char_frequency: char_frequency[s[right]] = 0 char_frequency[s[right]] += 1 if char_frequency[s[right]] == 1: num_unique_found += 1 while num_unique_found == required_char_count: min_length = min(min_length, right - left + 1) char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: num_unique_found -= 1 left += 1 return min_length"},{"question":"You are given a **0-indexed** two-dimensional integer array `grid` of `n` rows and `m` columns, where `grid[i][j]` represents the number of gold coins at the cell `(i, j)`. Initially, you are positioned at the top-left corner of the grid i.e., `(0, 0)`, and you aim to collect as many gold coins as possible before reaching the bottom-right corner (i.e., `(n-1, m-1)`). You can only move to the right or down from any cell, i.e., from `(i, j)` you can move to `(i+1, j)` or `(i, j+1)`. Write a function to determine the maximum number of gold coins you can collect from the top-left to the bottom-right corner of the grid.","solution":"def max_gold_coins(grid): Returns the maximum number of gold coins that can be collected from the top-left to the bottom-right corner of the grid. if not grid: return 0 n = len(grid) m = len(grid[0]) # Create a dp table with the same dimensions as grid dp = [[0]*m for _ in range(n)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[n-1][m-1]"},{"question":"Given a string `s` and a string `t`, return the number of distinct subsequences of `s` which equals `t`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \\"ACE\\" is a subsequence of \\"ABCDE\\" while \\"AEC\\" is not. Since the answer may be very large, return the result **modulo** `109 + 7`.","solution":"def numDistinct(s, t): Returns the number of distinct subsequences of s which equals t. MOD = 10**9 + 7 m, n = len(s), len(t) if n == 0: return 1 # An empty t is a subsequence of any s including an empty s. if m == 0: return 0 # Non-empty t cannot be a subsequence of an empty s. dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 # An empty t is a subsequence of any prefix of s. for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"Given an array of integers `nums` representing stock prices on different days, design an algorithm to find two non-overlapping subarrays of the stock prices that yield the maximum sum of the subarray profits if you can buy and sell only once within each subarray. Return the maximum profit you can achieve from these two transactions.","solution":"def max_profit_two_transactions(prices): Returns the maximum profit achievable with two non-overlapping transactions. n = len(prices) if n < 2: return 0 left_profits = [0] * n right_profits = [0] * n # Calculate maximum profit for transactions from the left side min_price_left = prices[0] for i in range(1, n): min_price_left = min(min_price_left, prices[i]) left_profits[i] = max(left_profits[i-1], prices[i] - min_price_left) # Calculate maximum profit for transactions from the right side max_price_right = prices[-1] for i in range(n-2, -1, -1): max_price_right = max(max_price_right, prices[i]) right_profits[i] = max(right_profits[i+1], max_price_right - prices[i]) # Calculate the maximum profit by summing up the left and right profits max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"You are a financial analyst and need to create a report that analyzes fluctuations in a stock\'s price over a period of time. You are given an array `prices` where `prices[i]` is the price of a given stock on the ith day. Calculate the maximum profit you can achieve. You can achieve this by buying on one day and selling on a later day. However, you are restricted to completing at most two transactions. Note that you cannot engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Implement a function that returns the maximum profit you can achieve with at most two transactions.","solution":"def maxProfit(prices): Calculate the maximum profit achievable with at most two transactions. Parameters: prices (List[int]): List of stock prices by day. Returns: int: The maximum profit possible with at most two transactions. if not prices: return 0 n = len(prices) if n < 2: return 0 # Step 1: Create DP arrays to store max profit up to day i (before second transaction) profit1 = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit1[i] = max(profit1[i - 1], prices[i] - min_price) # Step 2: Create another DP array to store max profit after day i (after first transaction) profit2 = [0] * n max_price = prices[-1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) profit2[i] = max(profit2[i + 1], max_price - prices[i]) # Step 3: Combine the two profits for the maximum profit with 2 transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, profit1[i] + profit2[i]) return max_profit"},{"question":"You are given an `m x n` grid filled with non-negative integers representing the height of each unit cell in a 2D elevation map, where the `rain water` can only move vertically or horizontally to adjacent cells of lower height. Write a function that returns the amount of water it can trap after raining. For example, given the elevation map below, the maximum amount of water trapped is 4. ``` [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] ```","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the boundary cells into the heap for i in range(m): for j in range(n): if i == 0 or j == 0 or i == m - 1 or j == n - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for d in dirs: nx, ny = x + d[0], y + d[1] if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) visited[nx][ny] = True return water_trapped"},{"question":"Given an array of `n` integers where `n > 0`, determine if the integers form an arithmetic sequence. An arithmetic sequence is one in which the difference between any two consecutive elements is the same. Return _`true` if the array forms an arithmetic sequence_, otherwise return _`false`_.","solution":"def is_arithmetic_sequence(arr): Checks if the given array of integers forms an arithmetic sequence. An arithmetic sequence is one in which the difference between any two consecutive elements is the same. Parameters: arr (list of int): An array of integers. Returns: bool: True if the array forms an arithmetic sequence, otherwise False. if len(arr) <= 1: return True # A single element or empty list can be considered as an arithmetic sequence common_difference = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != common_difference: return False return True"},{"question":"You are given an array of strings `words` and a prefix string `pref`. You may perform the following operation any number of times: * Choose any word `w` from `words` and remove a single character from `w`. Your goal is to determine if it is possible to make at least one of the words start with the prefix `pref` after performing the above operation any number of times on the words. Return `true` if it is possible, otherwise return `false`.","solution":"def can_form_prefix(words, pref): Checks if it is possible to make at least one of the words start with the prefix `pref` after removing any number of characters from the words. # Sorting the prefix itself due to the operation: Letters are arbitrary in positions pref_sorted = sorted(pref) for word in words: # Try to form pref from sorted version of word word_sorted = sorted(word) if can_form_from(word_sorted, pref_sorted): return True return False def can_form_from(word_sorted, pref_sorted): Helper function to check if pref_sorted can be formed by removing any number of characters from word_sorted. # Initialize pointers for two arrays i, j = 0, 0 while i < len(word_sorted) and j < len(pref_sorted): if word_sorted[i] == pref_sorted[j]: j += 1 i += 1 # if we have traversed all characters in pref_sorted, return True return j == len(pref_sorted)"},{"question":"Given an array of integers `heights` representing the height of blocks in a histogram, return the largest rectangular area that can be formed within the histogram. The width of each block is 1.","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area possible in a histogram. :param heights: List[int] a list of integers representing histogram heights. :return: int the area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a 2D matrix of integers `grid`, find the maximum sum of any submatrix in the grid. A submatrix is defined as any contiguous block within the matrix. Return the maximum possible sum of any submatrix.","solution":"def max_sum_submatrix(grid): def max_subarray(nums): max_sum = float(\'-inf\') current_sum = 0 for num in nums: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum rows, cols = len(grid), len(grid[0]) max_sum = float(\'-inf\') for left in range(cols): temp = [0] * rows for right in range(left, cols): for i in range(rows): temp[i] += grid[i][right] max_sum = max(max_sum, max_subarray(temp)) return max_sum"},{"question":"Given a string `s` and an array of strings `wordDict` containing non-empty words, return _all possible sentences **formed by concatenating** words from `wordDict` that can **exactly** recreate the string_ `s`. Each word in `wordDict` can be used multiple times in the composition of the sentence, and the order of words in the sentence must match the order in the original string `s`.","solution":"def wordBreak(s, wordDict): Returns all possible sentences formed by concatenating words from wordDict to exactly match the string s. Each word in wordDict can be used multiple times. def backtrack(s, wordDict, start, memo): if start in memo: return memo[start] result = [] if start == len(s): result.append(\\"\\") for word in wordDict: if s.startswith(word, start): sub_sentences = backtrack(s, wordDict, start + len(word), memo) for sub_sentence in sub_sentences: if sub_sentence: result.append(word + \\" \\" + sub_sentence) else: result.append(word) memo[start] = result return result return backtrack(s, wordDict, 0, {})"},{"question":"Given an array `transactions` where `transactions[i]` is a tuple `(sender, receiver, amount)` representing a transaction where `sender` sends `amount` money to `receiver`. You are also given an integer `n` representing the total number of unique people involved in transactions, numbered from `0` to `n-1`. Calculate the net balance for each person and return an array `balances` where `balances[i]` represents the net balance of person `i`. A positive balance indicates the amount of money the person has received more than they have sent, while a negative balance indicates the amount they have sent more than they have received.","solution":"def calculate_net_balances(transactions, n): Calculate the net balance for each person involved in transactions. Args: - transactions (list of tuples): Each tuple is (sender, receiver, amount) - n (int): Total number of unique people Returns: - list: Net balance for each person balances = [0] * n for sender, receiver, amount in transactions: balances[sender] -= amount balances[receiver] += amount return balances"},{"question":"A **circular array** is an array where the first element is considered to follow the last element. You are given a circular array of integers `nums` and an integer `target`. Your task is to determine the minimum number of elements you need to sum sequentially in the circular array (starting at any position) to reach or exceed the `target` value. Return the length of the shortest subarray that reaches or exceeds the `target`. If no such subarray exists, return `-1`. **Note:** The subarray can wrap around the circular array boundary. For example, if you have `nums = [3, 1, 4, 2]` and `target = 6`, one possible subarray is `[4, 2]` starting from index `2`. **Example**: - Input: `nums = [1, 2, 3, 4, 5]`, `target = 11` - Output: `3` In this example, the shortest subarray sum that reaches or exceeds `11` starts at index `3` and includes `[4, 5, 1]`.","solution":"def min_subarray_sum(arr, target): n = len(arr) arr = arr + arr # Creating a duplicated circular array min_length = n + 1 for start in range(n): current_sum = 0 for end in range(start, start + n): current_sum += arr[end] if current_sum >= target: min_length = min(min_length, end - start + 1) break return min_length if min_length <= n else -1"},{"question":"You are given a 2D integer grid, `grid`, where each cell has a value representing the elevation at that point. You want to calculate the amount of water that can be trapped after raining over this elevation map. The water is trapped between the elevations, and the trapped water at a point is determined by the maximum height of the lowest boundary in the surrounding 4-directional cells. Your task is to compute and return _the total amount of water trapped_ in the given grid.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Add all the border cells to the heap for i in range(m): for j in range(n): if i == 0 or i == m - 1 or j == 0 or j == n - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) new_height = max(height, heightMap[nx][ny]) heapq.heappush(heap, (new_height, nx, ny)) return water_trapped"},{"question":"Given a string `s` consisting of lowercase English letters, you need to remove the minimum number of characters to make any two consecutive characters in the string different. Return the resulting string after these removals. For example, for `s = \\"aabcc\\"`, removing one \'a\' and one \'c\' will yield \\"abcc\\" and then \\"abc\\" respectively, which has no two consecutive matching characters. If there are multiple solutions, return the lexicographically smallest one.","solution":"def remove_consecutive_duplicates(s): Removes the minimum number of characters from a string to ensure no two consecutive characters are the same. Parameters: s (str): the input string consisting of lowercase English letters. Returns: str: the resulting string after removals. if not s: return s result = [] for char in s: if not result or char != result[-1]: result.append(char) return \'\'.join(result)"},{"question":"You are given a string `s` consisting of lowercase English letters. You have the ability to perform an unlimited number of operations on the string. In one operation, you can select any character from the string and replace it with any other lowercase English letter. The goal is to transform `s` into a string such that no two adjacent characters are the same. Return _the minimum number of operations required to achieve such a transformation_.","solution":"def min_operations_to_alternate_string(s): Returns the minimum number of operations required to transform the string such that no two adjacent characters are the same. if len(s) <= 1: return 0 operations = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: operations += 1 # Choose a different character for the next position to avoid consecutive duplicates if i + 1 < len(s) and s[i + 1] == s[i]: s = s[:i] + \'z\' + s[i + 1:] # Replace with \'z\' or any other letter different from s[i] and s[i + 1] else: s = s[:i] + chr((ord(s[i]) - ord(\'a\') + 1) % 26 + ord(\'a\')) + s[i + 1:] return operations"},{"question":"You are given a 2D matrix `mat` of integers where each row is sorted in ascending order. You need to find an element that is the smallest common number in all rows of the matrix. If no such element exists, return `-1`. The algorithm should be efficient and take advantage of the sorting properties of the rows.","solution":"def smallest_common_number(mat): Find the smallest common number in all rows of the sorted 2D matrix. Parameters: mat (list of list of int): The input sorted 2D matrix Returns: int: The smallest common number or -1 if no common number exists num_rows = len(mat) num_columns = len(mat[0]) if mat else 0 if num_rows == 0 or num_columns == 0: return -1 column_indices = [0] * num_rows # To keep track of elements in each row while True: current_elements = [mat[i][column_indices[i]] for i in range(num_rows)] max_element = max(current_elements) if all(element == max_element for element in current_elements): return max_element for i in range(num_rows): while column_indices[i] < num_columns and mat[i][column_indices[i]] < max_element: column_indices[i] += 1 if column_indices[i] == num_columns: return -1"},{"question":"Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the smallest sum and return its sum. If there are multiple such subarrays, return the sum of the one that appears first.","solution":"def min_sub_array_sum(nums): Returns the sum of the contiguous subarray with the smallest sum. :param nums: List of integers :return: Integer - smallest sum of a contiguous subarray if not nums: return 0 # Default case for empty input min_sum = float(\'inf\') # Initialize to a very large number current_sum = 0 for num in nums: current_sum += num if current_sum < min_sum: min_sum = current_sum if current_sum > 0: current_sum = 0 return min_sum"},{"question":"You are given a list of non-negative integers `numbers` representing the cost of coins, and an integer `k` representing the number of coins you want to choose. Your task is to minimize the total cost of selecting `k` coins in such a way that no two selected coins are adjacent in the original `numbers` list. Return _the minimum cost_ to choose `k` coins under the given constraint.","solution":"def min_cost_for_k_coins(numbers, k): n = len(numbers) # A helper function to perform Depth First Search algorithm def dfs(index, coins_remaining, current_cost): if coins_remaining == 0: return current_cost if index >= n: return float(\'inf\') # Option 1: Skip current index skip = dfs(index + 1, coins_remaining, current_cost) # Option 2: Choose current index and skip next one choose = dfs(index + 2, coins_remaining - 1, current_cost + numbers[index]) return min(skip, choose) return dfs(0, k, 0)"},{"question":"You are given a 2D grid of size `m x n` representing a box with some empty cells, walls, and water cells. Each cell is represented by one of the following integers: - `0` represents an empty cell, - `1` represents a water cell, - `-1` represents a wall. Water can flow from a water cell to any of its four adjacent cells (up, down, left, right) if the adjacent cell is empty. A cell stops the flow of water if it is a wall or out of the grid boundaries. Determine if there exists a path that water can flow from any water cell in the first row to any water cell in the last row. Return `true` if such a path exists, otherwise return `false`.","solution":"def can_water_flow(grid): if not grid or not grid[0]: return False m, n = len(grid), len(grid[0]) def dfs(i, j, visited): if i == m - 1 and grid[i][j] == 1: return True directions = [(0,1), (1,0), (0,-1), (-1,0)] visited.add((i, j)) for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited: if grid[ni][nj] == 1: if dfs(ni, nj, visited): return True elif grid[ni][nj] == 0: visited.add((ni, nj)) grid[ni][nj] = 1 # fill with water return False for j in range(n): if grid[0][j] == 1: visited = set() if dfs(0, j, visited): return True return False"},{"question":"Write a function that takes an array of integers `nums` and returns the **index** of the peak element. A peak element is an element that is strictly greater than its neighbors. If the array contains multiple peaks, return the index to any of the peaks. **You may assume the array will not have duplicate elements.** For the purpose of this problem, consider the end elements as neighbors to only one adjacent element.","solution":"def find_peak_element(nums): Finds the peak element in an array of integers and returns its index. A peak element is an element that is strictly greater than its neighbors. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You are also given an integer `k`. Your task is to replace exactly `k` characters in the string `s` such that the length of the longest substring containing only the character \'a\' is maximized. Return the length of this longest substring.","solution":"def maximize_a_substring_length(s, k): Returns the length of the longest substring containing only character \'a\' that can be achieved by replacing exactly k characters in the given string s. def max_length_after_replacement(char): left = 0 max_len = 0 count = 0 for right in range(len(s)): if s[right] != char: count += 1 while count > k: if s[left] != char: count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len # We only need to maximize the length of \'a\' substring. return max_length_after_replacement(\'a\')"},{"question":"Given an array of integers `nums`, you are allowed to perform the following operation any number of times: - Select a contiguous subarray and increase each element of that subarray by 1. Your task is to determine the minimum number of operations required to make all elements in the array equal. Return this minimum number of operations. Example: - Input: `nums = [1, 2, 3]` - Output: `2` Explanation: 1. Increment the subarray `[2, 3]` to `[3, 4]`, resulting in array `[1, 3, 4]`. 2. Increment the subarray `[1, 3, 4]` to `[4, 4, 4]`. Hence, a total of 2 operations are required to make all the elements equal.","solution":"def min_operations_to_equal_elements(nums): Returns the minimum number of operations required to make all elements in the array equal. max_num = max(nums) min_num = min(nums) # Calculate the difference between max and min difference = max_num - min_num return difference"},{"question":"In a 2-dimensional grid of size `m x n`, each cell is either empty (`0`) or contains a house (`1`). You want to place a wireless router in one of the empty cells to minimize the sum of the Manhattan distances from this cell to all the houses. Return the minimum sum of distances. If there is no empty cell, return `-1`. The Manhattan distance between two cells (x1, y1) and (x2, y2) is `|x1 - x2| + |y1 - y2|`.","solution":"from collections import deque def min_total_distance(grid): Find the minimum sum of Manhattan distances from the best position to place the wireless router in an empty cell (0) to all the houses (1). m, n = len(grid), len(grid[0]) houses = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1] if not houses: return 0 # no houses, zero distance if all(grid[i][j] == 1 for i in range(m) for j in range(n)): return -1 # no empty cell # BFS function to determine the total distance from all houses to a specific cell def bfs(start): visited = [[False]*n for _ in range(m)] queue = deque([(*start, 0)]) visited[start[0]][start[1]] = True total_distance = 0 visited_houses = 0 while queue: x, y, dist = queue.popleft() if grid[x][y] == 1: total_distance += dist visited_houses += 1 if visited_houses == len(houses): return total_distance for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, dist+1)) return float(\'inf\') min_distance = float(\'inf\') for i in range(m): for j in range(n): if grid[i][j] == 0: # find all empty cells to place router min_distance = min(min_distance, bfs((i, j))) return min_distance if min_distance != float(\'inf\') else -1"},{"question":"Given a string `str` and an integer `n`, return _an array of all possible substrings of length `n` in the given string_. If `n` is greater than the length of the string, return an empty array. The substrings in the resultant array should be unique and appear in the order they occur in `str`.","solution":"def substrings_of_length_n(s, n): Returns an array of all possible substrings of length n in the given string. If n is greater than the length of the string, returns an empty array. The substrings in the resultant array are unique and appear in the order they occur in the string. if n > len(s): return [] substrings = set() result = [] for i in range(len(s) - n + 1): substring = s[i:i+n] if substring not in substrings: substrings.add(substring) result.append(substring) return result"},{"question":"Given two integers `start` and `goal`, and a set of operations you can perform on `start`: 1. Increment `start` by 1. 2. Decrement `start` by 1. 3. Double the value of `start`. Write a function to determine the minimum number of operations required to transform `start` into `goal`. Return the minimum number of operations needed.","solution":"from collections import deque def min_operations(start, goal): Determines the minimum number of operations required to transform start into goal using the allowed operations. if start == goal: return 0 queue = deque([(start, 0)]) # (current value, current number of operations) visited = set([start]) while queue: current, steps = queue.popleft() # Possible operations next_steps = [current + 1, current - 1, current * 2] for next_value in next_steps: if next_value == goal: return steps + 1 if next_value not in visited and 0 <= next_value <= 2 * goal: visited.add(next_value) queue.append((next_value, steps + 1)) return -1 # In case it is impossible to reach the goal (which theoretically shouldn\'t happen)"},{"question":"You are given an undirected graph with `n` nodes, numbered from `0` to `n-1`, and a list of `edges` where `edges[i] = [u_i, v_i]` indicates that there is an edge between nodes `u_i` and `v_i` in the graph. Write a function to determine if the graph is a **valid tree**. A valid tree has the following characteristics: * It is connected, i.e., there is a path between any two nodes. * It has no cycles, i.e., there is only one single path between any two nodes. Your function should return `true` if the graph is a valid tree, and `false` otherwise. Function Signature: `def valid_tree(n: int, edges: List[List[int]]) -> bool` **Constraints:** * `1 <= n <= 2000` * `0 <= edges.length <= 2000` * `edges[i].length == 2` * `0 <= u_i, v_i < n` * All the pairs `[u_i, v_i]` are unique. * There are no self-loops (i.e., no edges where `u_i` == `v_i`).","solution":"def valid_tree(n, edges): Determines if a given graph is a valid tree. Args: n: int - Number of nodes in the graph. edges: List[List[int]] - List of undirected edges in the graph. Returns: bool - True if the graph is a valid tree, False otherwise. if n == 0: return False if len(edges) != n - 1: return False parent = [-1] * n # Helper function to find the root of the node def find(x): if parent[x] == -1: return x return find(parent[x]) for u, v in edges: root_u = find(u) root_v = find(v) if root_u == root_v: return False # Cycle detected parent[root_u] = root_v return True"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. Find the `k`th largest element in the array after performing `m` operations. In each operation, you can increase the value of any element in the array by 1. Return _the **minimum** number of operations required_ to ensure that the kth largest element in the array is **at least** `desired`. The resulting array may include duplicate values.","solution":"def min_operations(arr, k, desired, m): Returns the minimum number of operations required to ensure that the kth largest element in the array is at least `desired`. import heapq # Step 1: Get the current kth largest element kth_largest = heapq.nlargest(k, arr)[-1] # Step 2: Calculate the difference needed to make the kth largest element at least `desired` diff = desired - kth_largest # Step 3: If diff is non-positive, the kth largest element is already at least `desired` if diff <= 0: return 0 # Step 4: Calculate the number of operations needed operations_needed = diff # Return the minimum number of operations required return min(operations_needed, m)"},{"question":"Write a function that takes in a string `s` consisting of lowercase alphabets and an integer `k`. The function should return the maximum number of non-overlapping substrings of length `k` that contain exactly `k` distinct characters. If no such substring exists, return `0`.","solution":"def max_non_overlapping_substrings(s, k): Returns the maximum number of non-overlapping substrings of length `k` that contain exactly `k` distinct characters. :param s: A string consisting of lowercase alphabets :param k: An integer representing the length of the substring :return: An integer representing the maximum number of non-overlapping substrings if k > len(s): return 0 count = 0 i = 0 while i <= len(s) - k: substring = s[i:i+k] if len(set(substring)) == k: count += 1 i += k # Move i forward by k to ensure non-overlapping else: i += 1 # Move i forward by 1 to check next potential substring return count"},{"question":"A company is organizing a team-building event where employees will be grouped based on their departments. You are given a 2D array `relations`, where each `relations[i]` is a pair `[emp1, emp2]` indicating that employee `emp1` and employee `emp2` belong to the same department. The goal is to count the number of departments based on these relations. Return the total number of distinct departments. Note: - Each employee belongs to exactly one department. - The employee IDs are unique and non-negative integers. - Each pair in `relations` indicates that two employees are directly related; however, departments can form through indirect relations as well (e.g., if employee 1 is related to employee 2, and employee 2 is related to employee 3, then employees 1, 2, and 3 belong to the same department). Example: - Input: `relations = [[1, 2], [2, 3], [4, 5]]` - Output: `2` Explanation: - There are two departments: one consisting of employees 1, 2, and 3, and another consisting of employees 4 and 5.","solution":"def find_departments(relations): Finds the number of distinct departments based on the given employee relations. def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY employees = set() for emp1, emp2 in relations: employees.add(emp1) employees.add(emp2) parent = {emp: emp for emp in employees} for emp1, emp2 in relations: union(emp1, emp2) departments = len(set(find(emp) for emp in parent)) return departments"},{"question":"You are given a **0-indexed** integer array `weights` where `weights[i]` is the weight of the `i`-th item. You need to split these items into two groups such that the absolute difference between the sums of the weights of the two groups is minimized. Each item must go into one of the two groups. Return _the minimum absolute difference between the sums of the weights of the two groups_.","solution":"def minimumDifference(weights): Returns the minimum absolute difference between the sums of the weights of the two groups. total_sum = sum(weights) n = len(weights) subset_sums = {0} for weight in weights: new_sums = set() for s in subset_sums: new_sums.add(s + weight) subset_sums.update(new_sums) min_diff = float(\'inf\') for s in subset_sums: diff = abs(total_sum - 2 * s) if diff < min_diff: min_diff = diff return min_diff"},{"question":"You are given a `n` x `n` 2D matrix `grid` that represents an island map where `1` represents land and `0` represents water. Determine the length of the perimeter of the island. The island doesn\'t have any lakes (water inside that isn\'t connected to the water around the island). Cells are connected horizontally or vertically (not diagonally). The perimeter is the sum of the lengths of all the island\'s boundaries which are connected to the water or the edges of the grid.","solution":"def island_perimeter(grid): Returns the perimeter of the island represented in the 2D grid. :param grid: List of List of int, where 1 represents land and 0 represents water. :return: int, perimeter of the island. if not grid: return 0 rows, cols = len(grid), len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Check all four directions if r == 0 or grid[r-1][c] == 0: # up perimeter += 1 if r == rows-1 or grid[r+1][c] == 0: # down perimeter += 1 if c == 0 or grid[r][c-1] == 0: # left perimeter += 1 if c == cols-1 or grid[r][c+1] == 0: # right perimeter += 1 return perimeter"},{"question":"You are given a list `nums` of positive integers. You must form a triangle using exactly three different elements from `nums` such that the sum of the lengths of any two sides is greater than the length of the remaining side. Return _the maximum perimeter_ of such a triangle. If it is not possible to form any triangle of non-zero area, return `0`.","solution":"def maximum_perimeter_triangle(nums): Returns the maximum perimeter of a triangle that can be formed with any three different elements from nums. If no valid triangle can be formed, returns 0. nums.sort(reverse=True) for i in range(len(nums) - 2): if nums[i] < nums[i+1] + nums[i+2]: return nums[i] + nums[i+1] + nums[i+2] return 0"},{"question":"Given a string `s` representing a decimal number, your task is to determine the smallest possible number of swaps of any two digits within the string that makes the number even. If it is impossible to make the number even, return -1. Note that the number can have leading zeros after the swaps if it decreases in value. Return the minimum number of swaps needed. Example: Input: `s = \\"2593\\"` Output: `1` Explanation: Swap the digits `3` and `2` to form the smallest even number `2395`.","solution":"def min_swaps_to_make_even(s): Returns the minimum number of swaps needed to make the number represented by the string s even. If it is impossible to make the number even, return -1. n = len(s) last_digit = int(s[-1]) # If the last digit is already even, no swaps are needed if last_digit % 2 == 0: return 0 # Find the rightmost even digit for i in range(n - 1, -1, -1): if int(s[i]) % 2 == 0: if i == n - 1: return 0 else: # If we find an even digit, check the number of swaps needed to move it to the end return 1 # If no even digits are found, return -1 return -1"},{"question":"Given an array of integers `nums` and a positive integer `k`, rearrange the array such that the difference between consecutive elements is at most `k`. If no such rearrangement is possible, return `false`. If multiple rearrangements are possible, return any valid one.","solution":"def rearrange_array(nums, k): Rearranges the array such that the difference between consecutive elements is at most k. If no such rearrangement is possible, returns False. :param nums: List of integers :param k: Positive integer :return: Rearranged list of integers or False if not possible # Sort the array to make consecutive elements as close as possible nums.sort() # Check if we can rearrange to satisfy the condition for i in range(len(nums) - 1): if abs(nums[i] - nums[i + 1]) > k: return False return nums"},{"question":"You are given a **0-indexed** integer array `arr` consisting of `n` non-negative integers. A subarray is defined as a contiguous part of an array. You can choose at most one subarray from `arr` and delete it completely. After deleting this subarray, the remaining parts are concatenated. Return _the length of the longest possible **increasing** subarray that can be obtained after deleting at most one subarray from `arr`._","solution":"def longest_increasing_subarray(arr): n = len(arr) if n == 0: return 0 # Step 1: Find the lengths of increasing subarrays inc_left = [1] * n for i in range(1, n): if arr[i] > arr[i - 1]: inc_left[i] = inc_left[i - 1] + 1 inc_right = [1] * n for i in range(n - 2, -1, -1): if arr[i] < arr[i + 1]: inc_right[i] = inc_right[i + 1] + 1 # Step 2: Find the maximum length considering at most one deletion max_length = max(inc_left) # Length without any deletion for i in range(1, n - 1): if arr[i - 1] < arr[i + 1]: max_length = max(max_length, inc_left[i - 1] + inc_right[i + 1]) return max_length"},{"question":"You are provided a 2D grid representing a maze where each cell is either a wall (`#`) or an open space (`.`). Additionally, two pairs of coordinates `(sx, sy)` and `(dx, dy)` are given, representing the start and destination points in the maze, respectively. You need to find the shortest path from the start point to the destination point while avoiding walls. You can move in four possible directions: up, down, left, or right, but you cannot move diagonally or pass through walls. If the destination is not reachable from the start point, return `-1`. Write a function that takes the grid, start, and destination coordinates and returns the length of the shortest path.","solution":"from collections import deque def shortest_path_maze(grid, start, destination): def is_valid_move(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == \'.\' sx, sy = start dx, dy = destination if grid[sx][sy] == \'#\' or grid[dx][dy] == \'#\': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (dx, dy): return dist for direction in directions: nx, ny = x + direction[0], y + direction[1] if is_valid_move(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Given an array `strength` where `strength[i]` represents the strength of the `ith` player in a team, you need to form a group of `k` players such that the difference between the strongest and the weakest player in the group is minimized. Return _the minimum possible difference between the strength of the strongest and the weakest player in the group_. If it\'s not possible to form such a group of `k` players, return `-1`.","solution":"def minimize_difference(strength, k): Returns the minimum possible difference between the strength of the strongest and the weakest player in a group of k players. Parameters: strength (list of int): an array of integers where strength[i] is the strength of the ith player. k (int): the number of players in the group. Returns: int: the minimum possible difference or -1 if a group of k players cannot be formed. # If it\'s not possible to form a group of k players if k > len(strength): return -1 # Sort the strengths to consider possible groups strength.sort() # Initialize the minimum difference to a large value min_diff = float(\'inf\') # Iterate through the sorted strengths to find the minimum difference for any possible group of k players for i in range(len(strength) - k + 1): diff = strength[i + k - 1] - strength[i] min_diff = min(min_diff, diff) return min_diff"},{"question":"Write a function `countValidParentheses(s: str) -> int` that takes a string `s` consisting of characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. Your function should return the count of valid pairs of parentheses, brackets, or braces in the string. A pair is considered valid if the closing character matches the most recent unmatched opening character and follows the correct order. For instance, `()`, `[]`, and `{}` are valid pairs.","solution":"def countValidParentheses(s: str) -> int: This function takes a string s consisting of characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' and returns the count of valid pairs of parentheses, brackets, or braces in the string. stack = [] valid_pairs_count = 0 matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_parentheses.values(): # if it is an opening bracket stack.append(char) elif char in matching_parentheses.keys(): # if it is a closing bracket if stack and stack[-1] == matching_parentheses[char]: stack.pop() # remove the matched opening bracket valid_pairs_count += 1 return valid_pairs_count"},{"question":"You are given two integer arrays `studyTime` and `scores` of length `n` and an integer `timeLimit`. Each element in `studyTime` represents the time in hours required to study a particular topic, and each element in `scores` represents the score gained from studying that topic. You need to determine the maximum score you can achieve without exceeding the given `timeLimit` by selecting an optimal combination of topics. Return the maximum score that can be achieved under the given `timeLimit`.","solution":"def knapsack(studyTime, scores, timeLimit): Returns the maximum score achievable within the given time limit using a 0/1 knapsack approach. Arguments: studyTime -- a list of integers representing the time required to study each topic scores -- a list of integers representing the score for each topic timeLimit -- an integer representing the maximum time limit Returns: An integer representing the maximum score n = len(studyTime) # Create a 2D DP array to store the maximum score for each time limit dp = [[0 for _ in range(timeLimit + 1)] for _ in range(n + 1)] # Populate the DP array for i in range(1, n + 1): for j in range(timeLimit + 1): if studyTime[i-1] <= j: dp[i][j] = max(dp[i-1][j], dp[i-1][j - studyTime[i-1]] + scores[i-1]) else: dp[i][j] = dp[i-1][j] return dp[n][timeLimit]"},{"question":"Determine whether a given string of parentheses is balanced. A string consisting of `\'(\'` and `\')\'` characters is considered balanced if the following criteria are met: 1. Each opening parenthesis `\'(\'` has a corresponding closing parenthesis `\')\'`. 2. Opening parentheses `\'(\'` must be closed in the correct order (i.e., the most recent unclosed `\'(\'` must be closed first). For example, the string `\\"()()\\"` is balanced, but the string `\\")(\\"` is not. You need to implement a function that takes a string of parentheses as input and returns `True` if the string is balanced, and `False` otherwise.","solution":"def is_balanced_parentheses(s): Determines if a string of parentheses is balanced. Args: s (str): The input string consisting of \'(\' and \')\'. Returns: bool: True if the string is balanced, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"You are given a list of integers `arr` representing a set of targets and an integer `k`. You can perform the following operation any number of times: choose two indices `i` and `j` (i  j) and replace `arr[i]` with `arr[i] + arr[j]`. The goal is to determine whether you can reach exactly `k` using these operations. If possible, return `true`; otherwise, return `false`.","solution":"def can_reach_k(arr, k): Determines whether it is possible to reach exactly `k` by choosing two indices `i` and `j` and replacing `arr[i]` with `arr[i] + arr[j]` any number of times. if k in arr: return True return k % gcd_list(arr) == 0 def gcd(a, b): while b: a, b = b, a % b return a def gcd_list(arr): result = arr[0] for num in arr[1:]: result = gcd(result, num) return result"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find and return the maximum number of instances of the substring `\\"balloon\\"` that can be formed using the characters in `s`. Each character in the string `s` may be used at most once in each substring. [Question 4]:","solution":"from collections import Counter def max_instances_of_balloon(s): Returns the maximum number of instances of the substring \\"balloon\\" that can be formed using the characters in s. # Count the frequency of each character in the given string char_count = Counter(s) # \\"balloon\\" requires 1 \'b\', 1 \'a\', 2 \'l\', 2 \'o\', and 1 \'n\' # Calculate how many times we can form the word \\"balloon\\" count_b = char_count[\'b\'] count_a = char_count[\'a\'] count_l = char_count[\'l\'] // 2 count_o = char_count[\'o\'] // 2 count_n = char_count[\'n\'] return min(count_b, count_a, count_l, count_o, count_n)"},{"question":"Given a positive integer `n`, return the number of distinct integers that can be formed by reordering its digits. Note that leading zeros are not allowed. For example, for the integer `123`, the distinct integers that can be formed are `123`, `132`, `213`, `231`, `312`, and `321`, resulting in 6 distinct integers.","solution":"from itertools import permutations def count_distinct_reorderings(n): Returns the number of distinct integers that can be formed by reordering the digits of n. Leading zeros are not allowed in the formed integers. Parameters: n (int): A positive integer Returns: int: Count of distinct integers # Convert the integer to string to get its digits digits = str(n) # Generate all unique permutations of the digits perm_set = set(int(\'\'.join(p)) for p in permutations(digits)) # Filter out numbers with leading zeros, not counting the original number filtered_perm_set = {num for num in perm_set if len(str(num)) == len(digits)} # Return the count of unique valid integers return len(filtered_perm_set)"},{"question":"You are given an array `positions` where `positions[i] = [xi, yi]` represents a position on a 2D plane. Your task is to determine the maximum number of non-overlapping squares that can be formed using these positions as their vertices. A square is formed by four positions `(x1, y1)`, `(x2, y2)`, `(x3, y3)`, and `(x4, y4)` if and only if all four sides are of the same length and the diagonals intersect at a right angle. Return _the maximum number of non-overlapping squares that can be formed using the provided positions_. You may return the answer in **any order**.","solution":"def distance(p1, p2): return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 def is_square(p1, p2, p3, p4): d = [distance(p1, p2), distance(p1, p3), distance(p1, p4), distance(p2, p3), distance(p2, p4), distance(p3, p4)] d.sort() return d[0] > 0 and d[0] == d[1] and d[2] == d[3] and d[4] == d[5] and d[0] + d[1] == d[4] def max_non_overlapping_squares(positions): from itertools import combinations n = len(positions) used = [False] * n count = 0 for i, (p1, p2, p3, p4) in enumerate(combinations(positions, 4)): if is_square(p1, p2, p3, p4): indices = [positions.index(p1), positions.index(p2), positions.index(p3), positions.index(p4)] if all(not used[idx] for idx in indices): for idx in indices: used[idx] = True count += 1 return count"},{"question":"You are given a sorted array of non-negative integers `nums` from which you need to form the largest possible number by concatenating the elements. Write a function `largestNumber(nums)` which returns this largest number as a string. Note that the resulting number may be very large, so you need to handle it as a string.","solution":"from functools import cmp_to_key def largestNumber(nums): Forms the largest number possible by concatenating elements of the sorted array. Args: nums (List[int]): A list of non-negative integers. Returns: str: The largest possible number as a string. if not nums: return \\"\\" # Custom comparator to sort numbers in the desired order def compare(n1, n2): if n1 + n2 > n2 + n1: return -1 elif n1 + n2 < n2 + n1: return 1 else: return 0 # Convert all integers to strings for concatenation purpose nums_str = list(map(str, nums)) # Sort the array using the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Edge case: when the array is full of zeros if nums_str[0] == \'0\': return \'0\' # Join the sorted numbers into a single string return \'\'.join(nums_str)"},{"question":"Create a function that takes an array of integers `nums` and an integer `k`, and returns the maximum sum of any contiguous subarray of length `k`. If the array length is less than `k`, return `-1`. Implement the function with an efficient algorithm to handle large input sizes.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of any contiguous subarray of length `k`. If the array length is less than `k`, return `-1`. n = len(nums) if n < k: return -1 max_sum = current_sum = sum(nums[:k]) for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `arr` and an integer `k`. The task is to determine whether there exists a subarray of length exactly `k` such that the sum of the elements in the subarray is a prime number. Return _true_ if such a subarray exists, and _false_ otherwise. A **subarray** is a contiguous part of the array.","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def subarray_sum_is_prime(arr, k): n = len(arr) if k > n: return False current_sum = sum(arr[:k]) if is_prime(current_sum): return True for i in range(k, n): current_sum += arr[i] - arr[i - k] if is_prime(current_sum): return True return False"},{"question":"You are given an array `arr` consisting of `n` integers. Your task is to find a subarray with the maximum possible sum. A subarray is defined as a contiguous segment of the array. Return _the sum of the subarray with the maximum sum_.","solution":"def max_subarray_sum(arr): Function to find the maximum sum of a contiguous subarray using Kadane\'s Algorithm. :param arr: List[int] - input array of integers :return: int - the maximum possible sum of a subarray if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form of a parent array `parent` where `parent[i]` is the parent of the `ith` node. The root of the tree is node `0`, so `parent[0] = -1` since it has no parent. Each node has a value assigned as given in the `values` array, where `values[i]` is the value of the `ith` node. Your task is to design a data structure that supports the following operations: * **Update Value**: Update the value at a particular node. * **Sum of Subtree**: Return the sum of values of all the nodes in the subtree rooted at a given node. Implement the `TreeValueTracker` class: * `TreeValueTracker(int[] parent, int[] values)` initializes the class with the parent array and the initial values array. * `void updateValue(int node, int value)` updates the value of the `node` to the given `value`. * `int sumOfSubtree(int node)` returns the sum of all values in the subtree rooted at the `node`.","solution":"class TreeValueTracker: def __init__(self, parent, values): self.parent = parent self.values = values self.n = len(values) # Build the adjacency list for the tree self.children = [[] for _ in range(self.n)] for i in range(1, self.n): self.children[parent[i]].append(i) # Calculate initial sums for all subtrees self.subtree_sums = [0] * self.n self.calculate_subtree_sums(0) def calculate_subtree_sums(self, node): self.subtree_sums[node] = self.values[node] for child in self.children[node]: self.subtree_sums[node] += self.calculate_subtree_sums(child) return self.subtree_sums[node] def updateValue(self, node, value): diff = value - self.values[node] self.values[node] = value self.update_subtree_sums(node, diff) def update_subtree_sums(self, node, diff): self.subtree_sums[node] += diff if self.parent[node] != -1: self.update_subtree_sums(self.parent[node], diff) def sumOfSubtree(self, node): return self.subtree_sums[node]"},{"question":"You are given a string `s` representing a sequence of lowercase Latin letters, and an integer `k`. The task is to remove `k` characters from the string in such a way that the resulting string is the lexicographically smallest possible. Return _the lexicographically smallest string_ that can be obtained after removing exactly `k` characters from `s`.","solution":"def remove_k_characters(s, k): Returns the lexicographically smallest string after removing exactly k characters from s. stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still characters to remove, remove them from the end of the stack return \'\'.join(stack[:len(stack)-k])"},{"question":"You are given a string `s` consisting of lowercase English letters. In one move, you can select any character of `s` and change it to any other lowercase English letter. Your task is to return _the minimum number of moves required to make all characters in the string unique_. If it\'s impossible to make all characters unique, return `-1`.","solution":"def min_moves_to_make_unique(s): Returns the minimum number of moves required to make all characters in the string unique. If it\'s impossible to make all characters unique, return -1. from collections import Counter if len(s) > 26: return -1 counter = Counter(s) duplicates = sum(count - 1 for count in counter.values() if count > 1) return duplicates"},{"question":"You are given a 2D grid of size `m x n` filled with non-negative integers. Your task is to start from the top-left corner of the grid and move to the bottom-right corner. You can only move in two directions: right and down. At each cell, you collect the value of that cell, and you aim to collect the maximum sum of values along your path. _Return the maximum sum you can collect by moving from the top-left corner to the bottom-right corner of the grid._","solution":"def maxPathSum(grid): Finds the maximum sum of values from the top-left to the bottom-right corner of a grid. You can only move right or down at each step. Parameters: grid (List[List[int]]): 2D list of non-negative integers. Returns: int: Maximum sum collected along the path. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"You are given a 0-indexed integer array `nums` consisting of `n` elements. You can perform the following operation any number of times (including zero): 1. Choose two adjacent elements in `nums` and divide one by the other, leaving the result as an integer part after division. Your task is to determine the minimum possible value that can be obtained for any element of the array after performing the operation any number of times. Return the minimum possible value. Example: Input: `nums = [10, 30, 2]` Output: `1` Explanation: One possible sequence of operations is: - Divide `30` by `10` resulting in `[10, 3, 2]` - Divide `10` by `3` resulting in `[3, 3, 2]` - Divide `3` by `2` resulting in `[1, 3, 2]` - Continue until all elements are reduced to `1` eventually. Hence, the minimum possible value is `1`.","solution":"def find_minimum_value(nums): Finds the minimum possible value of any element in the array after performing any number of the allowed operations. Parameters: nums (list): 0-indexed integer array of n elements. Returns: int: The minimum possible value of any element in the array. return 1"},{"question":"You are given an array of strings `paths` where each path represents an absolute path to a file or directory in a file system. Each string consists of directory names and/or file names, all separated by slashes `/`. A directory or subdirectory may contain multiple files or subdirectories. You need to find the deepest path in terms of depth (the number of directories from the root to the deepest file or directory). If there is a tie, any one of them is acceptable. Return the deepest path as a string. For example, given `paths = [\\"/a/b/c/d/file.txt\\", \\"/a/b/file2.txt\\", \\"/a/b/c/e/directory\\"]`, the deepest path would be `\\"/a/b/c/d/file.txt\\"`. Create a function that processes the array of paths and returns the desired result.","solution":"def find_deepest_path(paths): Given a list of absolute paths, return the deepest path. Parameters: paths (list of str): The list of absolute paths in a file system Returns: str: The deepest path string if not paths: return \\"\\" # Initialize the deepest path and its depth max_depth = 0 deepest_path = \\"\\" for path in paths: # Calculate the depth (number of slashes) for the current path depth = path.count(\'/\') # Check if this path is deeper than the current deepest path if depth > max_depth: max_depth = depth deepest_path = path return deepest_path"},{"question":"Implement a function `canBeSplit` that takes an array of integers and determines if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Return `true` if such a partition is possible, otherwise return `false`. **Function Signature:** ```python def canBeSplit(nums: List[int]) -> bool: # Your implementation goes here ```","solution":"from typing import List def canBeSplit(nums: List[int]) -> bool: Determines if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. total_sum = sum(nums) # If total sum is odd, it cannot be split into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) # DP array to check if certain sum is possible dp = [False] * (target_sum + 1) dp[0] = True # A sum of 0 is always possible (by taking no elements) for num in nums: # Traverse dp array backwards to ensure each num is only used once for j in range(target_sum, num - 1, -1): if dp[j - num]: dp[j] = True return dp[target_sum]"},{"question":"You are given a 2D integer array `grid` representing a maze where `0` represents an open space, and `1` represents a wall. You are also given two pairs of coordinates, `start` and `end`, each represented as a list of two integers `[start_row, start_col]` and `[end_row, end_col]` respectively. Write a function to determine if there is a valid path from `start` to `end` moving only horizontally and vertically through open spaces (`0`s). If a path exists, return `true`, otherwise return `false`.","solution":"def is_valid_path(grid, start, end): Determines if there is a valid path from start to end in the grid. :param grid: List of List of int, representing the maze :param start: List of two int, representing the start coordinates :param end: List of two int, representing the end coordinates :return: bool, True if there\'s a path, False otherwise from collections import deque rows, cols = len(grid), len(grid[0]) start_row, start_col = start end_row, end_col = end if grid[start_row][start_col] == 1 or grid[end_row][end_col] == 1: return False directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([(start_row, start_col)]) visited.add((start_row, start_col)) while queue: current_row, current_col = queue.popleft() if (current_row, current_col) == (end_row, end_col): return True for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col)) return False"},{"question":"Given an integer `n`, return the smallest prime number that is greater than `n`. A prime number is a natural number greater than 1 that is not divisible by any number other than 1 and itself. Use an efficient algorithm to handle large values of `n`.","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def next_prime(n): Returns the smallest prime number greater than n. candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"You are designing a pathfinding algorithm for a robot vacuum cleaner in a `m*n` grid. The grid consists of cells marked as either empty (`0`) or containing an obstacle (`1`). The robot starts at the upper left corner `(0, 0)` and aims to reach the bottom right corner `(m-1, n-1)`. It can only move one step at a time in any of the four directions: up (`U`), down (`D`), left (`L`), or right (`R`). However, the robot can only move to an empty cell and cannot go out of the grid boundaries. Given the grid, return the minimum number of steps required for the robot to reach its destination. If there is no possible path, return `-1`.","solution":"from collections import deque def min_steps_to_destination(grid): Returns the minimum number of steps for the robot to reach destination (m-1, n-1) from the starting point (0, 0) in the given grid or -1 if no path exists. :param grid: List[List[int]] -- the grid representing the environment :return: int -- minimum number of steps to reach the destination or -1 if no path exists if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"Given an array of integers `nums` and an integer `k`, return **the maximum product** of `k` consecutive elements in `nums`. Implement the function `maxProduct(nums: List[int], k: int) -> int`. **Example:** ```python maxProduct([1, 5, 2, 6, 3, 4], 2) ``` **Output:** ```python 15 ``` In the above example, the function returns `15` since the maximum product of 2 consecutive elements in the array `[1, 5, 2, 6, 3, 4]` is `6 * 3 = 18`.","solution":"from typing import List def maxProduct(nums: List[int], k: int) -> int: Returns the maximum product of k consecutive elements in nums. if len(nums) == 0 or k == 0 or k > len(nums): return 0 max_product = float(\'-inf\') for i in range(len(nums) - k + 1): current_product = 1 for j in range(k): current_product *= nums[i + j] max_product = max(max_product, current_product) return max_product"},{"question":"Given a list of strings `words`, where each word is either a valid English word or a sequence of characters that represent a concatenation of shorter words from the same list, write a function to identify and return all the words that are concatenations of other words in the list. A concatenation is defined as a word that can be formed by concatenating one or more smaller words in sequence. Note that each smaller word must also be present in the original list. For example, given the list `[\\"cat\\", \\"cats\\", \\"catsdog\\", \\"dog\\", \\"dogcatsdog\\"]`, `words[2]` (\\"catsdog\\") is a concatenation of `words[0]` (\\"cat\\") and `words[3]` (\\"dog\\"). Implement the function `List<String> findAllConcatenatedWords(String[] words)`, which returns a list of all concatenated words in `words`.","solution":"def findAllConcatenatedWords(words): Returns a list of all concatenated words in the input list of words. words_set = set(words) def canForm(word): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in words_set and (suffix in words_set or canForm(suffix)): memo[word] = True return True memo[word] = False return False memo = {} concatenated_words = [] for word in words: if canForm(word): concatenated_words.append(word) return concatenated_words"},{"question":"You are given a list of integers `ratings` representing the ratings of students in a line. Each student must receive at least one candy. Students with a higher rating get more candies than their immediate neighbors. Return _the minimum number of candies you need to distribute to the students_. The test cases are generated so that the answer fits in a 32-bit integer.","solution":"def min_candies(ratings): Returns the minimum number of candies needed to distribute to the students according to their ratings. if not ratings: return 0 n = len(ratings) candies = [1] * n # First pass to ensure right neighbor condition for i in range(1, n): if ratings[i] > ratings[i - 1]: candies[i] = candies[i - 1] + 1 # Second pass to ensure left neighbor condition for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) return sum(candies)"},{"question":"Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the **longest path** between any two nodes in a tree. This path may or may not pass through the root. You are given the `TreeNode` class, which represents nodes in the binary tree, and the binary tree is defined using this `TreeNode` class as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function `diameterOfBinaryTree` that takes the root of a binary tree and returns the length of the diameter of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root): Compute the length of the diameter of a binary tree. The diameter is the length of the longest path between any two nodes. def dfs(node): nonlocal diameter if not node: return 0 left = dfs(node.left) right = dfs(node.right) diameter = max(diameter, left + right) return 1 + max(left, right) diameter = 0 dfs(root) return diameter"},{"question":"You are given an array `heights` representing the heights of buildings. The array `heights` has `n` elements (`n > 1`) where each element represents the height of a building. You aim to distribute water from a starting building such that all buildings receive water within the limits of a certain capacity `k`. The water flow can only move horizontally from one building to an adjacent building, and the capacity limits the maximum allowable height difference between any two adjacent buildings that the water can flow through. Write a function to determine if it is possible to start from the first building (index 0) and reach the last building (index `n-1`) or vice versa given this restriction. Return `true` if it\'s possible to distribute the water to all buildings while adhering to the capacity limit, otherwise return `false`.","solution":"def can_distribute_water(heights, k): Determines if water can be distributed from the first building to the last or vice versa given the height difference limit k. :param heights: List[int] - The heights of the buildings. :param k: int - the maximum allowable height difference for water distribution. :return: bool - True if water can be distributed as per the restrictions, else False. n = len(heights) reachable = [False] * n reachable[0] = True for i in range(n - 1): if reachable[i]: for j in range(i + 1, n): if abs(heights[j] - heights[i]) <= k: reachable[j] = True else: break return reachable[-1]"},{"question":"You are given an integer array `nums` and an integer `target`. You need to return an array of all unique pairs `[nums[i], nums[j]]` such that the sum of `nums[i]` and `nums[j]` equals `target`. Each pair should be sorted in non-decreasing order, and the result array should not contain duplicate pairs. Note that you cannot use the same element twice. Return the result array in lexicographically increasing order with respect to the first element of each pair.","solution":"def find_pairs(nums, target): Given an integer array nums and an integer target, return all unique pairs [nums[i], nums[j]] such that the sum of nums[i] and nums[j] equals target. Each pair should be sorted in non-decreasing order, and the result array should not contain duplicate pairs. The result array should be sorted lexicographically with respect to the first element of each pair. :param nums: List[int] :param target: int :return: List[List[int]] nums.sort() pairs = set() result = [] left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pairs.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 for pair in sorted(pairs): result.append(list(pair)) return result"},{"question":"You are given a **0-indexed** string `s` consisting of only lowercase English letters. You need to make the string a palindrome by inserting characters at the beginning of the string. Return _the shortest palindrome_ you can make by performing this transformation. A palindrome is a string that reads the same forward and backward. For example, given the string `s = \\"abcd\\"`, you can insert \\"dcb\\" at the beginning to form the palindrome \\"dcbabcd\\".","solution":"def shortest_palindrome(s): Returns the shortest palindrome that can be made by inserting characters at the beginning of s. # Helper function to check if a string is a palindrome def is_palindrome(x): return x == x[::-1] if is_palindrome(s): return s # Reverse the input string rev_s = s[::-1] # Add characters from the reversed string to the beginning until the full string is a palindrome for i in range(len(s)): if is_palindrome(rev_s[:i] + s): return rev_s[:i] + s # Example Usage # shortest_palindrome(\\"abcd\\") should return \\"dcbabcd\\""},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a line. A building `i` can check another building `j` if: - `j` is to the right of `i` and - the height of building `j` is greater than or equal to the height of building `i`. Determine the number of buildings each building can check, and return the result as a **0-indexed** integer array where the `i-th` element represents the number of buildings building `i` can check.","solution":"def number_of_buildings_each_can_check(heights): Determines the number of buildings each building can check. :param heights: List[int] heights of the buildings :return: List[int] number of buildings each building can check n = len(heights) result = [0] * n for i in range(n): for j in range(i + 1, n): if heights[j] >= heights[i]: result[i] += 1 return result"},{"question":"You are given a list of `n` courses labeled from `0` to `n-1` to be completed, along with a list of `prerequisites` where `prerequisites[i] = [a, b]` indicates that course `a` must be completed before course `b`. Assume there are no duplicate prerequisites and assume that prerequisites are in a directed acyclic graph form. Each course takes one unit of time to complete. Determine the minimum number of units of time required to complete all the courses if they are completed such that no prerequisites are violated. If it is not possible to complete all the courses, return `-1`.","solution":"from collections import deque, defaultdict def minimum_time_to_complete_courses(n, prerequisites): Determine the minimum number of units of time required to complete all courses. Args: n : int Number of courses. prerequisites : list of list of int List of prerequisite pairs, where each pair [a, b] indicates that course `a` must be completed before course `b`. Returns: int Minimum number of units of time required to complete all courses, or -1 if it is not possible. # Initialize in-degree and adjacency list indegree = [0] * n adj_list = defaultdict(list) for dest, src in prerequisites: adj_list[src].append(dest) indegree[dest] += 1 # Queue for zero in-degree nodes queue = deque() for course in range(n): if indegree[course] == 0: queue.append(course) time = 0 count_of_courses_taken = 0 while queue: time += 1 # Each level of courses takes one unit of time number_of_courses_at_this_level = len(queue) for _ in range(number_of_courses_at_this_level): course = queue.popleft() count_of_courses_taken += 1 for neighbor in adj_list[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If we were able to take all courses return time if count_of_courses_taken == n else -1"},{"question":"You are given a list of strings `emails` where each string represents an email address consisting of a local part and a domain part, separated by the \'@\' symbol. Your task is to count the number of unique email addresses after applying two rules: 1. **Dots in the Local Part**: If you add periods (\'.\') between some characters in the local part, it does not change the email address. For example, \\"alice.z@leetcode.com\\" and \\"alicez@leetcode.com\\" are considered the same email address. 2. **Plus in the Local Part**: If you add a plus (\'+\') in the local part, everything after the first plus sign will be ignored. This allows certain emails to be filtered or categorized. For example, \\"alice+a@leetcode.com\\" and \\"alice+b@leetcode.com\\" are considered the same email address as \\"alice@leetcode.com\\". Return _the number of unique email addresses_ after applying these two rules.","solution":"def num_unique_emails(emails): Returns the number of unique email addresses after normalization. Args: emails (List[str]): List of email addresses. Returns: int: Number of unique email addresses. unique_emails = set() for email in emails: local, domain = email.split(\'@\') local = local.split(\'+\')[0].replace(\'.\', \'\') unique_emails.add(local + \'@\' + domain) return len(unique_emails)"},{"question":"Suppose you have a list of `n` positive integers representing the heights of towers in a row. You are allowed to add one block to any tower in the list to make all towers the same height. Return the minimum number of blocks required to equalize the heights of all towers.","solution":"def min_blocks_to_equalize(heights): Returns the minimum number of blocks required to make all towers in the list of same height. :param heights: List of integers representing the heights of towers. :return: Integer representing the minimum number of blocks required. max_height = max(heights) total_blocks_required = sum(max_height - height for height in heights) return total_blocks_required"},{"question":"You are given an integer array `nums` where each element represents the height of a person in a line. The goal is to change the order of the people by swapping the heights of any two people until the heights of all the people are in non-decreasing order. For each swap, the heights of the two people are exchanged. Write a function that returns the minimum number of swaps required to sort the array in non-decreasing order. Note: The function should take an integer array `nums` and return an integer representing the minimum number of swaps.","solution":"def minimum_swaps_to_sort(nums): Returns the minimum number of swaps required to sort the array in non-decreasing order. n = len(nums) sorted_nums = sorted(nums) index_map = {value: idx for idx, value in enumerate(nums)} swaps = 0 for i in range(n): if nums[i] != sorted_nums[i]: swaps += 1 swap_idx = index_map[sorted_nums[i]] index_map[nums[i]] = swap_idx nums[i], nums[swap_idx] = nums[swap_idx], nums[i] return swaps"},{"question":"You are given an integer array `nums` and an integer `target`. Return `true` if there exists a **contiguous subarray** whose sum of elements equals `target`, or `false` otherwise. A **contiguous subarray** is a sequence of consecutive elements within the array.","solution":"def has_subarray_with_sum(nums, target): Returns True if there exists a contiguous subarray whose sum equals target, else False. current_sum = 0 sum_dict = {0: -1} # Maps sum to the index where this sum occurs for i, num in enumerate(nums): current_sum += num if current_sum - target in sum_dict: return True # Record the current sum with its corresponding index if current_sum not in sum_dict: sum_dict[current_sum] = i return False"},{"question":"You are given an integer array `arr` representing the positions of element\'s readings along a one-dimensional line. Each reading is taken at a specific position, and this position is recorded as an integer in the array. You are required to find the maximum gap between any two consecutive readings after the array is sorted in ascending order. If the array has less than two readings, return `0`. Implement the `MaxGap` class: * `MaxGap(int[] arr)` Initializes the object with the integer array `arr`. * `int findMaximumGap()` Finds and returns the maximum gap between any two consecutive readings in the sorted array. If there are less than two readings, return `0`.","solution":"class MaxGap: def __init__(self, arr): Initializes the object with the integer array arr. self.arr = arr def findMaximumGap(self): Finds and returns the maximum gap between any two consecutive readings in the sorted array. If there are less than two readings, returns 0. if len(self.arr) < 2: return 0 self.arr.sort() max_gap = 0 for i in range(1, len(self.arr)): gap = self.arr[i] - self.arr[i - 1] if gap > max_gap: max_gap = gap return max_gap"},{"question":"You are provided with an array `logs` where each element `logs[i]` represents a log entry in the format `[user_id, timestamp, action]`, where `user_id` is a unique identifier for each user, `timestamp` is the time at which the action occurred, and `action` is a string describing the action taken by the user. You are also supplied with two user IDs, `userA` and `userB`. Return an integer that represents the number of times users `userA` and `userB` performed the same action at the exact same timestamp. If they never performed the same action at the same time, return `0`.","solution":"def count_common_actions(logs, userA, userB): Returns the number of times users `userA` and `userB` performed the same action at the exact same timestamp. Parameters: logs (List[List[str, int, str]]): A list of logs where each log is in the format [user_id, timestamp, action] userA (str): The user ID of the first user userB (str): The user ID of the second user Returns: int: The number of times users `userA` and `userB` performed the same action at the exact same timestamp # Create dictionaries to store the actions for each user at each timestamp actionsA = {} actionsB = {} for log in logs: user_id, timestamp, action = log if user_id == userA: if timestamp not in actionsA: actionsA[timestamp] = set() actionsA[timestamp].add(action) elif user_id == userB: if timestamp not in actionsB: actionsB[timestamp] = set() actionsB[timestamp].add(action) # Count the number of common actions at the same timestamps count = 0 for timestamp in actionsA: if timestamp in actionsB: common_actions = actionsA[timestamp].intersection(actionsB[timestamp]) count += len(common_actions) return count"},{"question":"Implement a data structure `CustomDeque` that supports the following operations efficiently: * `void pushFront(int x)`: Adds the element `x` to the front of the deque. * `void pushBack(int x)`: Adds the element `x` to the back of the deque. * `int popFront()`: Removes and returns the element from the front of the deque. If the deque is empty, return `-1`. * `int popBack()`: Removes and returns the element from the back of the deque. If the deque is empty, return `-1`. * `int peekFront()`: Returns the element at the front of the deque without removing it. If the deque is empty, return `-1`. * `int peekBack()`: Returns the element at the back of the deque without removing it. If the deque is empty, return `-1`.","solution":"class CustomDeque: def __init__(self): self.deque = [] def pushFront(self, x): self.deque.insert(0, x) def pushBack(self, x): self.deque.append(x) def popFront(self): if self.deque: return self.deque.pop(0) return -1 def popBack(self): if self.deque: return self.deque.pop() return -1 def peekFront(self): if self.deque: return self.deque[0] return -1 def peekBack(self): if self.deque: return self.deque[-1] return -1"},{"question":"You are given a string `str` and an integer `x`. Your task is to check if it\'s possible to partition `str` into exactly `x` contiguous substrings such that each substring is a palindrome. Return `true` if it is possible, else return `false`. A **palindrome** is a string that reads the same backward as forward.","solution":"def is_palindrome(s): return s == s[::-1] def can_partition_into_palindromes(s, x): n = len(s) if x > n: return False # Create a 2D DP table to store whether s[i:j+1] is a palindrome dp = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): dp[i][i] = True # Check for palindromes of length 2 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True # Check for palindromes for lengths greater than 2 for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True # Create a 1D DP array to store the minimum cuts needed cuts = [float(\'inf\')] * n for i in range(n): if dp[0][i]: cuts[i] = 0 else: for j in range(i): if dp[j+1][i] and cuts[j] + 1 < cuts[i]: cuts[i] = cuts[j] + 1 # Adding 1 because we are calculating cuts which is one less than the partitions return (cuts[-1] + 1) <= x"},{"question":"You are given an array `arr` consisting of `n` integers. You need to implement a function that returns an array containing the maximum of each sliding window of size `k`. A **sliding window** is a subarray of length `k` that slides from left to right by one position at a time. Implement the function `maxSlidingWindow` with the following signature: ```python def maxSlidingWindow(arr: List[int], k: int) -> List[int]: ``` # Example: ```python maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3) ``` Output: ``` [3,3,5,5,6,7] ``` The sliding windows are: - `[1,3,-1]` -> `3` - `[3,-1,-3]` -> `3` - `[-1,-3,5]` -> `5` - `[-3,5,3]` -> `5` - `[5,3,6]` -> `6` - `[3,6,7]` -> `7` # Constraints: - `1 <= n <= 10^4` - `1 <= k <= n` - `-10^4 <= arr[i] <= 10^4`","solution":"from collections import deque from typing import List def maxSlidingWindow(arr: List[int], k: int) -> List[int]: Returns an array containing the maximum of each sliding window of size k. if not arr or k == 0: return [] n = len(arr) if k == 1: return arr def clean_deque(i): if deq and deq[0] == i - k: deq.popleft() while deq and arr[i] > arr[deq[-1]]: deq.pop() deq = deque() max_indices = [] max_numbers = [] for i in range(n): clean_deque(i) deq.append(i) if i >= k - 1: max_numbers.append(arr[deq[0]]) return max_numbers"},{"question":"You are given a string consisting of only the characters \'(\' and \')\'. A balanced string is defined such that every \'(\' has a corresponding \')\'. Write a function that determines the minimum number of insertions needed to make the string balanced. If the string is already balanced, return 0. Your solution should efficiently handle very large strings.","solution":"def min_insertions_to_balance(s): Returns the minimum number of insertions needed to make the string balanced. left_count = 0 right_needed = 0 for char in s: if char == \'(\': left_count += 1 elif char == \')\': if left_count > 0: left_count -= 1 else: right_needed += 1 return left_count + right_needed"},{"question":"You are given a directed graph represented by an integer `n` (the number of nodes) and a list of `edges` where each `edges[i] = [ui, vi]` represents a directed edge from node `ui` to node `vi`. Each edge has a `weight` associated with it, given in the same order as the edges. Find the longest path you can take starting from any node and ending at any node, such that the sum of the weights of the edges in the path is maximized. Return the **sum of the weights** of this longest path. Note that the graph does not contain any cycles (i.e., it is a Directed Acyclic Graph).","solution":"from collections import defaultdict, deque def find_longest_path(n, edges, weights): # Create adjacency list and in-degree of each node adj_list = defaultdict(list) in_degree = [0] * n for i, (u, v) in enumerate(edges): adj_list[u].append((v, weights[i])) in_degree[v] += 1 # Find all nodes with 0 in-degree to initialize the queue queue = deque([i for i in range(n) if in_degree[i] == 0]) # Initialize distance array where distance[i] represents the longest path to node i distances = [-float(\'inf\')] * n for node in queue: distances[node] = 0 # Topological sorting and calculating longest path while queue: node = queue.popleft() for neighbor, weight in adj_list[node]: if distances[neighbor] < distances[node] + weight: distances[neighbor] = distances[node] + weight in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Return the maximum value in the distances array max_path_sum = max(distances) return max_path_sum if max_path_sum != -float(\'inf\') else 0"},{"question":"You are given a string `s` that contains only lowercase characters. Define the **frequency** of a character in a string as the number of times it appears. A **substring** of a string is a contiguous block of characters within the original string. Return _the sum of the frequencies of the most frequent character of every possible substring_ of `s`. For example, if `s = \\"abb\\"`, then the substrings are: - \\"a\\", the most frequent character is \'a\' with frequency 1. - \\"ab\\", the most frequent character is \'a\' and \'b\' both with frequency 1. - \\"abb\\", the most frequent character is \'b\' with frequency 2. - \\"b\\", the most frequent character is \'b\' with frequency 1. - \\"bb\\", the most frequent character is \'b\' with frequency 2. - \\"b\\", the most frequent character is \'b\' with frequency 1. Thus, the sum of these frequencies is 1 + 1 + 2 + 1 + 2 + 1 = 8.","solution":"def sum_of_most_frequent_character_frequencies(s): Returns the sum of the frequencies of the most frequent character of every possible substring of s. total_sum = 0 n = len(s) # Iterate through all possible starting points of substrings for i in range(n): freq = [0] * 26 # There are 26 lowercase letters max_freq = 0 # Iterate through all possible ending points starting from i for j in range(i, n): char_index = ord(s[j]) - ord(\'a\') freq[char_index] += 1 max_freq = max(max_freq, freq[char_index]) total_sum += max_freq return total_sum"},{"question":"You are given a list of meetings where each meeting is represented by a tuple `(startTime, endTime)`. The start and end times are given as integers representing the number of minutes past midnight. Determine if a single person can attend all the given meetings. Return _`true` if a person can attend all meetings without any overlaps, `false` otherwise_.","solution":"def can_attend_all_meetings(meetings): Determine if a single person can attend all meetings without overlaps. Parameters: - meetings (list of tuple): List of tuples where each tuple represents a meeting with (startTime, endTime). Returns: - bool: True if a person can attend all meetings without any overlaps, False otherwise. if not meetings: return True # Sort the meetings by start time meetings.sort(key=lambda x: x[0]) # Check for overlaps for i in range(1, len(meetings)): if meetings[i][0] < meetings[i-1][1]: return False return True"},{"question":"You are given a square matrix `mat` containing only the integers 0 and 1. A **square submatrix** is a contiguous block of the matrix that is square-shaped and contains all 1s. Find and return _the side length of the **largest** square submatrix containing only 1s_. If there is no such submatrix, return 0.","solution":"def largest_square_submatrix(mat): if not mat or not mat[0]: return 0 n = len(mat) m = len(mat[0]) # Initialize a DP array to store the size of the largest square submatrix ending at (i, j) dp = [[0] * m for _ in range(n)] max_side = 0 # Iterate through the matrix to fill the DP array for i in range(n): for j in range(m): if mat[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"Given an array of integers `nums` and an integer `target`, return the number of non-empty **subarrays** whose sum is equal to `target`. A **subarray** is a contiguous part of the array. You may assume the result fits within a 32-bit integer.","solution":"def subarray_sum(nums, target): Returns the number of non-empty subarrays whose sum is equal to target. count = 0 current_sum = 0 sum_count = {0: 1} for num in nums: current_sum += num if (current_sum - target) in sum_count: count += sum_count[current_sum - target] if current_sum in sum_count: sum_count[current_sum] += 1 else: sum_count[current_sum] = 1 return count"},{"question":"You are given a matrix `mat` of integers with `m` rows and `n` columns. You need to perform multiple queries on the matrix. Each query is given as four integers `row1`, `col1`, `row2`, `col2` where `(row1, col1)` represents the top-left corner and `(row2, col2)` represents the bottom-right corner of a submatrix. Implement the `MatrixQueries` class to handle these queries: * `MatrixQueries(int[][] mat)` Initializes the object with the matrix `mat`. * `int sumRegion(int row1, int col1, int row2, int col2)` Returns the **sum** of the elements in the rectangle defined by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)` inclusive.","solution":"class MatrixQueries: def __init__(self, mat): self.m = len(mat) self.n = len(mat[0]) if self.m > 0 else 0 self.dp = [[0] * (self.n + 1) for _ in range(self.m + 1)] for i in range(self.m): for j in range(self.n): self.dp[i+1][j+1] = mat[i][j] + self.dp[i][j+1] + self.dp[i+1][j] - self.dp[i][j] def sumRegion(self, row1, col1, row2, col2): return (self.dp[row2+1][col2+1] - self.dp[row1][col2+1] - self.dp[row2+1][col1] + self.dp[row1][col1])"},{"question":"Given a **directed acyclic graph (DAG)** represented as an adjacency list, where each node represents a task and an edge from node `u` to node `v` indicates that task `u` must be performed before task `v`, return _the order in which the tasks can be completed_. Ensure that the returned order is a valid topological sort of the graph.","solution":"from collections import deque, defaultdict def topological_sort(graph): Returns a valid topological sort order of tasks represented by the given DAG. The graph is represented as an adjacency list. indegree = defaultdict(int) # To store the indegree of each node for nodes in graph.values(): for node in nodes: indegree[node] += 1 zero_indegree = deque() for node in graph.keys(): if indegree[node] == 0: zero_indegree.append(node) topo_order = [] while zero_indegree: current = zero_indegree.popleft() topo_order.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree.append(neighbor) if len(topo_order) == len(graph): return topo_order else: return [] # If theres a cycle, return an empty list indicating no valid order exists"},{"question":"You are given a 2D-array `grid` of size `m x n` representing a rectangular garden. Some cells of the garden contain a tree with the value 1, and others are empty with the value 0. Your task is to count the number of distinct groups of connected trees. A group of trees is formed by cells connected horizontally or vertically. Two trees in diagonal positions are not considered connected. Return _the number of distinct groups of connected trees in the garden_.","solution":"def count_tree_groups(grid): Returns the number of distinct groups of connected trees in the garden. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] == 0: return visited[x][y] = True dfs(x-1, y) dfs(x+1, y) dfs(x, y-1) dfs(x, y+1) count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"You have an integer matrix `mat` where you can perform the following operation on any submatrix: increase every element in the submatrix by 1. Return the minimum number of operations to make every element in `mat` equal. The dimensions of `mat` are `m` x `n` where `1 <= m, n <= 100` and the elements of `mat` are integers between `1` and `1000`.","solution":"def min_operations(mat): def get_min(mat): return min(map(min, mat)) def get_max(mat): return max(map(max, mat)) min_val = get_min(mat) max_val = get_max(mat) diff = max_val - min_val return diff"},{"question":"You are given a string `s` and you need to reorder the characters so that no two adjacent characters are the same. If it is possible to do so, return _the rearranged string_. If it is not possible, return an empty string.","solution":"from heapq import heappush, heappop from collections import Counter def reorganizeString(s): Reorganize the string so that no two adjacent characters are the same. # Count the frequency of each character char_count = Counter(s) # Add all characters and their counts to a max heap max_heap = [] for char, count in char_count.items(): heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) # If the previous character\'s count is greater than 0, push it back to heap if prev_char and prev_count < 0: heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 # Decrement the count # Check if the result is valid if len(result) == len(s): return \'\'.join(result) else: return \\"\\""},{"question":"You are given an array `arr` of `n` integers, where each integer represents the height of a vertical line drawn at that index on a 1-D graph. Compute the maximum amount of water that can be trapped between the lines after it rains. The structure of the array is such that if you think of the heights as walls, the water will be trapped between them in the valleys. Return _the maximum volume of water that can be trapped between the lines_.","solution":"def trap(arr): Compute the maximum volume of water that can be trapped between the lines. Parameters: arr (List[int]): A list of integers representing the height of lines. Returns: int: The maximum volume of water that can be trapped. if not arr or len(arr) < 3: return 0 left, right = 0, len(arr) - 1 left_max, right_max = arr[left], arr[right] water_trapped = 0 while left < right: if arr[left] < arr[right]: if arr[left] >= left_max: left_max = arr[left] else: water_trapped += left_max - arr[left] left += 1 else: if arr[right] >= right_max: right_max = arr[right] else: water_trapped += right_max - arr[right] right -= 1 return water_trapped"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `target`. Your task is to find all unique pairs of elements `(nums[i], nums[j])` from the array such that `nums[i] + nums[j] == target` and `i != j`. Return a list of the unique pairs. Make sure each pair is sorted in ascending order, and the final list of pairs is sorted in ascending order based on the first element, and in case of a tie, by the second element. Each pair should be represented as a list `[nums[i], nums[j]]`. * For example, if `nums = [1, 2, 2, 3, 4]` and `target = 4`, then valid pairs are `[[1, 3], [2, 2]]`. If `nums = [1, 1, 1, 2, 2, 2, 3]` and `target = 4`, then valid pairs are `[[1, 3], [2, 2]]`. Return the list of unique pairs that sum to the target.","solution":"def find_pairs(nums, target): Find all unique pairs of elements (nums[i], nums[j]) such that nums[i] + nums[j] == target and i != j. Returns a list of unique pairs, sorted as specified. pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) result = [list(pair) for pair in pairs] result.sort() return result"},{"question":"Given a non-empty array of integers `nums`, you may perform the following operation any number of times: Choose any two adjacent elements and replace them with their sum. For example, if the array is `[1, 2, 3]`, you can choose elements `1` and `2` and replace them with `3`, resulting in the new array `[3, 3]`. Return the maximum possible value you can obtain for the only element left in the array after performing the above operations. **Note:** The order of array elements must be preserved during each operation.","solution":"def max_possible_value(nums): Returns the maximum possible value of the last remaining element in the array after performing the operation any number of times. return sum(nums)"},{"question":"A certain string `s` can be split into multiple substrings based on delimiter characters. You are given two inputs: a string `s` and a string `delimiters` which contains unique characters that act as delimiters. Your task is to split the string `s` using the delimiters and return a list of non-empty substrings in the same order they appear in `s`. For example, given `s = \\"hello,world;this|is:a=test\\"` and `delimiters = \\",;|:=\\"`, the function should return `[\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]`.","solution":"def split_string(s, delimiters): Splits the string `s` using the characters in `delimiters` as delimiters and returns a list of non-empty substrings. :param s: The string to be split :param delimiters: A string containing unique delimiter characters :return: A list of non-empty substrings import re # Create a regex pattern from the delimiters pattern = \'[\' + re.escape(delimiters) + \']\' # Split the string using the regex pattern substrings = re.split(pattern, s) # Return list of non-empty substrings return [substring for substring in substrings if substring]"},{"question":"You are given an array of integers `nums` and an integer `target`. You want to find the number of non-empty subsequences of `nums` such that the sum of the minimum and maximum elements in the subsequence is less than or equal to `target`. Return the number of such subsequences. Since the answer may be large, return it **modulo** `10^9 + 7`.","solution":"def num_subsequences(nums, target): Returns the number of non-empty subsequences such that the sum of the minimum and maximum elements in the subsequence is less than or equal to \'target\'. The result is returned modulo 10^9 + 7. MOD = 10**9 + 7 nums.sort() n = len(nums) result = 0 powers = [1] * n for i in range(1, n): powers[i] = (powers[i-1] * 2) % MOD left, right = 0, n - 1 while left <= right: if nums[left] + nums[right] <= target: result = (result + powers[right - left]) % MOD left += 1 else: right -= 1 return result"},{"question":"You are given two strings `s` and `goal` of the same length. Determine if you can obtain `goal` by rotating `s` any number of times. Return `true` if it is possible, and `false` otherwise.","solution":"def can_rotate_to_goal(s, goal): Determines if you can obtain `goal` by rotating `s` any number of times. :param s: Original string :param goal: Target string after rotation :return: True if goal can be obtained by rotating s, False otherwise if len(s) != len(goal): return False return goal in (s + s)"},{"question":"You are given a **0-indexed** array `arr` consisting of `n` distinct integers. A **winner** is an element that is greater than the previous and the next element in the array (if they exist). * Formally, an element `arr[i]` is a winner if `arr[i] > arr[i - 1]` and `arr[i] > arr[i + 1]`. Return _the list of all winners in the array_. If there are no winners, return an empty list.","solution":"def find_winners(arr): Returns a list of winners in the array. An element is considered a winner if it is greater than the previous and next elements. :param arr: List[int] - An array of distinct integers :return: List[int] - A list of winners winners = [] n = len(arr) for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: winners.append(arr[i]) return winners"},{"question":"Given a **binary string** `s`, you are allowed to change at most one \'0\' to \'1\'. Return the length of the longest contiguous substring of \'1\'s in the resulting string. If the string already consists entirely of \'1\'s, you may not make any change and should return the length of the string.","solution":"def longest_substring_with_one_change(s): Given a binary string s, you are allowed to change at most one \'0\' to \'1\'. Returns the length of the longest contiguous substring of \'1\'s in the resulting string. If the string already consists entirely of \'1\'s, you may not make any change and should return the length of the string. n = len(s) if n == 0: return 0 # Check if the string already consists entirely of \'1\'s if \'0\' not in s: return n max_len = 0 zero_count = 0 left = 0 for right in range(n): if s[right] == \'0\': zero_count += 1 while zero_count > 1: if s[left] == \'0\': zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given two string arrays `words1` and `words2`. A string `b` is a **subsequence** of a string `a` if `b` can be obtained from `a` by deleting some number of characters (possibly zero), without rearranging the remaining characters. Determine the count of strings in `words1` that are subsequences of any string in `words2`. For example, if `words1 = [\\"abc\\", \\"de\\", \\"f\\", \\"gh\\"]` and `words2 = [\\"abcd\\", \\"efghi\\"]`, the subsequences are `[\\"abc\\", \\"de\\", \\"f\\"]` since \\"abc\\" is a subsequence of \\"abcd\\", \\"de\\" is a subsequence of \\"efghi\\", and \\"f\\" is also a subsequence of \\"efghi\\". The function should return `3`. Return _the count of strings in `words1` that are subsequences of any string in `words2`_.","solution":"def is_subsequence(small, large): Helper function to determine if \'small\' is a subsequence of \'large\'. it = iter(large) return all(char in it for char in small) def count_subsequences(words1, words2): Counts the number of strings in words1 which are subsequences of any strings in words2. count = 0 for word1 in words1: if any(is_subsequence(word1, word2) for word2 in words2): count += 1 return count"},{"question":"You have a list of building heights and an integer `d`. Write a function to determine the farthest building you can reach without moving more than `d` units horizontally. You start at index 0, and at each step, you can move to the next or previous building. However, you can only move to a building if the height difference between the current building and the next one is not greater than 1. Note: You need to return the index of the farthest building you can reach under these conditions. If there are multiple farthest buildings, return the smallest index.","solution":"def farthest_building(heights, d): Determines the farthest building index that can be reached without moving more than `d` units horizontally and while adhering to the height difference constraint. Args: heights: List of building heights. d: Maximum allowable horizontal movement distance. Returns: The index of the farthest building that can be reached under the given constraints. max_index = 0 for i in range(len(heights)): if i > d: break if i > 0 and abs(heights[i] - heights[i - 1]) > 1: break max_index = i return max_index"},{"question":"You are given an array `swaps` of length `n` where `swaps[i] = [a, b]` represents a potential swap between elements at indices `a` and `b` in another given array `nums` of the same length. You are allowed to perform the swaps in any order as many times as needed. After performing the swaps, your goal is to form a lexicographically smallest array. Return the lexicographically smallest array that can be formed. Note: An array `a` is lexicographically smaller than an array `b` if at the first index where `a` and `b` differ, the array `a` has a smaller element than `b`.","solution":"def lexicographically_smallest_array(nums, swaps): Returns the lexicographically smallest array that can be formed by performing the allowed swaps an indefinite number of times. :param nums: List[int] - The initial array of numbers :param swaps: List[List[int]] - List of swap pairs :return: List[int] - The lexicographically smallest array from collections import defaultdict import heapq # Disjoint Set Union (DSU) / Union-Find structure with path compression parent = list(range(len(nums))) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): root_x, root_y = find(x), find(y) if root_x != root_y: parent[root_y] = root_x # Apply unions to build the connected components for a, b in swaps: union(a, b) # Group all indices by their root parent groups = defaultdict(list) for i in range(len(nums)): groups[find(i)].append(i) # Place the smallest possible elements in the correct positions result = [0] * len(nums) for indices in groups.values(): values = [nums[i] for i in indices] heapq.heapify(values) for i in sorted(indices): result[i] = heapq.heappop(values) return result"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Design an algorithm to remove the duplicates in place such that each unique element appears only once. The relative order of the elements should be kept the same, and you cannot use extra space (i.e., no additional array should be used). After removing the duplicates, elements beyond the new length should be considered irrelevant. Return the new length of the array after removing duplicates. Remember to modify the input array in place as required.","solution":"def remove_duplicates(nums): Removes duplicates in place for a sorted array and returns the new length. :param nums: List[int] - A list of integers sorted in non-decreasing order. :return: int - The new length of the array after duplicates are removed. if not nums: return 0 write_index = 1 # Index to write the next unique element for read_index in range(1, len(nums)): if nums[read_index] != nums[read_index - 1]: nums[write_index] = nums[read_index] write_index += 1 return write_index"},{"question":"Given a string `s` and an integer `n`, your task is to determine if it\'s possible to rearrange the characters of `s` to form a new string such that every substring with a length of `n` has at least `m` distinct characters. Return `true` if such a rearrangement is possible, and `false` otherwise.","solution":"from collections import Counter def is_possible_rearrangement(s, n, m): Determine if it\'s possible to rearrange the characters of `s` such that every substring with length `n` has at least `m` distinct characters. Parameters: - s: the input string - n: the length of the substring - m: the minimum number of distinct characters in every substring of length `n` Returns: - True if the rearrangement is possible, False otherwise. if n < m: return False # It\'s not possible because there cannot be more distinct characters than the length of the substring. counter = Counter(s) # If the total number of characters in string `s` is less than `n`, it\'s not possible if len(s) < n: return False # Count the number of different characters in `s` distinct_char_count = len(counter) if distinct_char_count < m: return False # Not enough distinct characters to meet the requirement return True"},{"question":"Given an m x n grid `grid` of integers, each cell represents a different elevation on a hillside. You are on a bike and want to navigate from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) such that the absolute difference in elevation between any two consecutive cells along the path is minimized. Return the minimum possible difference in elevation you can achieve for any path from the top-left corner to the bottom-right corner. Note: You can move in four directions - up, down, left, or right.","solution":"import heapq def minimumEffortPath(grid): Returns the minimum possible difference in elevation you can achieve for any path from the top-left corner to the bottom-right corner. m, n = len(grid), len(grid[0]) # Directions for moving in the grid (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Priority queue for the Dijkstra-like algorithm pq = [(0, 0, 0)] # (effort, row, col) efforts = [[float(\'inf\')] * n for _ in range(m)] efforts[0][0] = 0 while pq: effort, x, y = heapq.heappop(pq) # If we reach the bottom-right corner, return the effort if x == m - 1 and y == n - 1: return effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_effort = max(effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heapq.heappush(pq, (new_effort, nx, ny)) return -1 # This line will not be reached"},{"question":"You are given two **0-indexed** integer arrays `nums1` and `nums2`, both of the same length. Each element in the arrays represents a certain value. A **double-element pair** is a pair of integers, one from `nums1` and one from `nums2`, such that their sum forms an element of the combination list. The combination list is formed by taking the sum of every possible pair of elements from `nums1` and `nums2`. Return _the total number of **double-element pairs** such that their sums exist in the combination list_.","solution":"def double_element_pairs(nums1, nums2): Returns the number of double-element pairs such that their sums exist in the combination list. Parameters: nums1 (list): List of integers. nums2 (list): List of integers. Returns: int: Total number of double-element pairs. combination_sum_set = set() # Populate combination list with sums of every possible pair from nums1 and nums2 for num1 in nums1: for num2 in nums2: combination_sum_set.add(num1 + num2) count = 0 # Check for double-element pairs for num1 in nums1: for num2 in nums2: if (num1 + num2) in combination_sum_set: count += 1 return count"},{"question":"Given a string `s`, remove the minimum number of parentheses (either \'(\' or \')\') so that the resulting string is valid and return any valid string. A string is considered valid if it is empty or if there are no parentheses mismatch.","solution":"def min_remove_to_make_valid(s: str) -> str: Remove the minimum number of parentheses to make a string valid. A string is valid if it is empty or if it has no parentheses mismatch. stack = [] s = list(s) for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: s[i] = \'\' while stack: s[stack.pop()] = \'\' return \'\'.join(s) # Example usage: s = \\"lee(t(c)o)de)\\" print(min_remove_to_make_valid(s)) # Output: \\"lee(t(c)o)de\\""},{"question":"Given an integer `n` representing the total number of courses a student needs to complete, and an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must complete course `bi` before you can take course `ai`, return _the ordering of courses you should take to finish all courses_. If there are multiple correct answers, return any of them. If it is impossible to complete all courses, return an empty array.","solution":"from collections import defaultdict, deque def find_course_order(num_courses, prerequisites): Determines the order of courses one should take to finish all courses. Args: num_courses (int): The total number of courses. prerequisites (list of list of int): Each inner list has two elements [a, b] meaning course b must be taken before course a. Returns: list of int: The order of courses to complete, or an empty list if it\'s not possible to complete all courses. # Graph adjacency list representation graph = defaultdict(list) # In-degree of each course in_degree = {i: 0 for i in range(num_courses)} # Build graph and populate in-degree for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Queue for courses with no prerequisites zero_in_degree_queue = deque([k for k in in_degree if in_degree[k] == 0]) order = [] while zero_in_degree_queue: node = zero_in_degree_queue.popleft() order.append(node) # Decrease the in-degree of neighboring courses for neighbor in graph[node]: in_degree[neighbor] -= 1 # If in-degree becomes zero, add to queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the order contains all courses, return it if len(order) == num_courses: return order else: return []"},{"question":"A company has a network of servers connected by bidirectional links between pairs of servers. You are given an integer `n` representing the number of servers (labeled from `0` to `n-1`) and a 2D integer array `edges` where `edges[i] = [ui, vi]` indicates there is a link between servers `ui` and `vi`. Your task is to determine if all servers are connected, meaning there is a path between every pair of servers. Return `true` if all servers are connected; otherwise, return `false`.","solution":"def are_all_servers_connected(n, edges): Determines if all servers are connected. :param n: Number of servers :param edges: List of edges where each edge is represented as [ui, vi] :return: True if all servers are connected, False otherwise if n <= 1: return True from collections import defaultdict, deque # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS to check connectivity visited = set() queue = deque([0]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == n"},{"question":"You are given a 0-indexed integer array `arr` and an integer `k`. An array `arr` is called **k-diverse** if the difference between the maximum and minimum values in any contiguous subarray of length `k` is less than or equal to `k`. Return `true` if the given array `arr` is **k-diverse**, otherwise return `false`.","solution":"def is_k_diverse(arr, k): This function determines if the array is k-diverse. A k-diverse array is one where the difference between the maximum and minimum values in any contiguous subarray of length k is  k. n = len(arr) if k == 1: return True for i in range(n - k + 1): subarray = arr[i:i + k] if max(subarray) - min(subarray) > k: return False return True"},{"question":"You have a string consisting of lowercase letters and digits (\'0\'-\'9\'). Write a function that reorders the string such that all the lowercase letters come before any digits, but the relative order among letters and among digits should be preserved. For example, if `s = \\"a1b2c3\\"`, you should return `\\"abc123\\"`.","solution":"def reorder_string(s): Reorders the string such that all the lowercase letters come before any digits, while preserving the relative order among letters and digits. letters = [char for char in s if char.isalpha()] digits = [char for char in s if char.isdigit()] return \'\'.join(letters + digits)"},{"question":"You are given a sorted array of `n` integers and a target integer `k`. Write a function to determine if there exists a triplet in the array whose sum is equal to `k`. Return `true` if such a triplet exists, otherwise return `false`.","solution":"def find_triplet_with_sum(arr, k): Determines if there exists a triplet in the sorted array `arr` that sums up to `k`. :param arr: List[int] - A sorted list of integers :param k: int - Target sum for the triplets :return: bool - True if such a triplet exists, otherwise False n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"You are given two strings `word1` and `word2`, each representing a sequence of lowercase English letters. You need to determine if `word1` can be formed by rearranging the characters of `word2` (i.e., if `word1` is an anagram of `word2`). Return `true` if `word1` is an anagram of `word2`, and `false` otherwise.","solution":"def is_anagram(word1, word2): Returns True if word1 is an anagram of word2, otherwise False. return sorted(word1) == sorted(word2)"},{"question":"There is a list of `n` courses labeled from `0` to `n - 1`. You are given an array `prerequisites` where `prerequisites[i] = [a_i, b_i]` indicates that you must complete course `b_i` before you can take course `a_i`. You want to find out if it is possible to finish all courses given the prerequisites. Return `true` _if you can complete all courses_, or `false` _otherwise_.","solution":"def can_finish_courses(num_courses, prerequisites): Determine if it\'s possible to finish all courses given the prerequisites. :param num_courses: Number of courses :param prerequisites: List of prerequisite pairs [a_i, b_i] :return: True if it\'s possible to finish all courses, False otherwise from collections import deque, defaultdict # Create a list of incoming edges and an adjacency list indegree = [0] * num_courses adjacency_list = defaultdict(list) # Populate indegree and adjacency list for a, b in prerequisites: indegree[a] += 1 adjacency_list[b].append(a) # Use a queue to perform a topological sort queue = deque() # Add courses with no prerequisites to the queue for course in range(num_courses): if indegree[course] == 0: queue.append(course) taken_courses = 0 while queue: current_course = queue.popleft() taken_courses += 1 for neighbor in adjacency_list[current_course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return taken_courses == num_courses"},{"question":"Given an array of integers `heights` representing the heights of buildings arranged in a line, calculate the area of the largest rectangle that can be formed by any contiguous subarray of these buildings. The area of the rectangle is determined by the shortest building in the subarray multiplied by the number of buildings in that subarray. Implement the function `maxRectangleArea(int[] heights)` to achieve this. For example, given the array `[2, 1, 5, 6, 2, 3]`, the largest rectangle that can be formed has an area of 10, which corresponds to the subarray `[5, 6]` with a minimum height of 5 and containing 2 buildings (5 * 2 = 10).","solution":"def maxRectangleArea(heights): Given an array of integers \'heights\' representing the heights of buildings arranged in a line, calculate the area of the largest rectangle that can be formed by any contiguous subarray of these buildings. The area of the rectangle is determined by the shortest building in the subarray multiplied by the number of buildings in that subarray. stack = [] max_area = 0 index = 0 while index < len(heights): # If the current building is taller than the building at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) building area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now pop the remaining buildings from stack and calculate area with every popped building while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a binary search tree (BST), write an algorithm to convert it into a greater sum tree where each node\'s value is replaced by the sum of all values greater than or equal to the node\'s value in the BST. The original structure of the BST should be maintained. **Definition of the function:** Parameters: `TreeNode root` Returns: `TreeNode` **Example:** Given the BST with the following structure: ``` 4 / 1 6 / / 0 2 5 7 8 ``` The converted greater sum tree would be as follows: ``` 30 / 36 21 / / 36 35 26 15 8 ``` **Note:** * A binary search tree is a binary tree in which for every node, the value of all the nodes in the left subtree is less than the node\'s value, and the value of all the nodes in the right subtree is more than the node\'s value. * The function should have a linear time complexity relative to the number of nodes in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_to_gst(root): Convert a BST to a Greater Sum Tree where each node\'s value is replaced by the sum of all values greater than or equal to the node\'s value in the BST. :param TreeNode root: The root of the binary search tree. :return TreeNode: The root of the greater sum tree. def reverse_inorder_traversal(node, acc_sum): if node is None: return acc_sum # Traverse the right subtree acc_sum = reverse_inorder_traversal(node.right, acc_sum) # Update the node\'s value acc_sum += node.val node.val = acc_sum # Traverse the left subtree acc_sum = reverse_inorder_traversal(node.left, acc_sum) return acc_sum reverse_inorder_traversal(root, 0) return root"},{"question":"You are given a `rows x cols` matrix of integers `grid` representing a city map, where the value of each cell represents the height of a building. Write a function to find the **maximum building height** that can be visible when viewed from any of its four sides (north, south, east, and west). A building height is considered visible if it is not obstructed by any taller buildings lying between it and the city boundary in any direction. **Return the maximum visible building height**. For example, given the grid `[[3, 5, 4], [2, 1, 6], [3, 8, 7]]`, the function should return `8`. Provide an efficient solution to handle large values for `rows` and `cols`.","solution":"def max_visible_height(grid): Given a rows x cols matrix of integers representing building heights in a city, returns the maximum building height that can be visible from any of the four sides. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) max_height = -1 # Check from north to south and south to north for c in range(cols): north_max = -1 south_max = -1 for r in range(rows): north_max = max(north_max, grid[r][c]) south_max = max(south_max, grid[rows-1-r][c]) max_height = max(max_height, north_max, south_max) # Check from west to east and east to west for r in range(rows): west_max = -1 east_max = -1 for c in range(cols): west_max = max(west_max, grid[r][c]) east_max = max(east_max, grid[r][cols-1-c]) max_height = max(max_height, west_max, east_max) return max_height"},{"question":"You are given an array of integers `nums` and an integer `target`. You want to find **two distinct** integers in the array such that their difference equals the target, i.e., `nums[i] - nums[j] = target` (where `i` and `j` are different indices). Return _the indices of the two numbers_ as a list `[i, j]` (such that `i` < `j`). If there are multiple pairs, return any one of them. If no such pair exists, return an empty list.","solution":"def find_indices_with_diff(nums, target): Find two distinct integers in \'nums\' such that their difference equals \'target\'. Parameters: nums (list): A list of integers. target (int): The target difference. Returns: list: A list containing the indices of the two numbers such that nums[i] - nums[j] = target. If no such pair exists, return an empty list. num_indices = {} for i, num in enumerate(nums): if num - target in num_indices: return [num_indices[num - target], i] if num + target in num_indices: return [num_indices[num + target], i] num_indices[num] = i return []"},{"question":"You are given a list of `n` friends numbered from `0` to `n-1`. Each friend is represented by a pair `(xi, yi)` which indicates their position on a 2D grid. You are also given an integer `k`. The goal is to find the **k-th closest pair** of friends based on the **Euclidean distance** between each pair. If there are multiple pairs with the same distance, return the pair with the smallest friend index first, and if there is still a tie, compare the second friend index. Return an array `[ai, bi]` where `ai` and `bi` are the indices of the friends in the k-th closest pair. The **Euclidean distance** between `p1` and `p2` is `sqrt((p1.x - p2.x)^2 + (p1.y - p2.y)^2)`. Note: for the purpose of this question, you can ignore the precision issues with floating-point calculations and assume appropriate precision in intermediate steps.","solution":"import math from itertools import combinations def euclidean_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def kth_closest_pair(friends, k): Find the k-th closest pair of friends based on the Euclidean distance. distances = [] # Generate all pairs of friends for i, j in combinations(range(len(friends)), 2): dist = euclidean_distance(friends[i], friends[j]) distances.append((dist, i, j)) # Sort based on the distance, and then on the indices if there is a tie distances.sort(key=lambda x: (x[0], x[1], x[2])) # Get the k-th (1-indexed) closest pair closest_pair = distances[k-1] return [closest_pair[1], closest_pair[2]]"},{"question":"You are given an integer array `arr` and an integer `threshold`. A **threshold subsequence** of `arr` is a subsequence such that the sum of its elements does not exceed the given `threshold`. Return _the length of the longest threshold subsequence of_ `arr`. A **subsequence** is a sequence derived from another sequence by deleting some or none of the elements without changing the order of the remaining elements.","solution":"def longest_threshold_subsequence(arr, threshold): Returns the length of the longest threshold subsequence of arr such that the sum of its elements does not exceed threshold. arr.sort() subseq_sum = 0 length = 0 for num in arr: if subseq_sum + num <= threshold: subseq_sum += num length += 1 else: break return length"},{"question":"You are given a string `s` consisting of lowercase alphabets, and an integer `t`. A substring of `s` is considered **good** if it contains exactly `t` unique characters. Return the number of **good** substrings of `s`.","solution":"def count_good_substrings(s, t): Returns the number of good substrings of s that contains exactly t unique characters. n = len(s) count = 0 for i in range(n): unique_characters = set() for j in range(i, n): unique_characters.add(s[j]) if len(unique_characters) == t: count += 1 if len(unique_characters) > t: break return count"},{"question":"Given a list of integers where each integer represents the number of units of water trapped at that position, implement a function that calculates the total amount of water trapped after raining. The list corresponds to an elevation map where the width of each bar is 1. The height of the elevation map is given by the integers in the list. For example, given input `[0,1,0,2,1,0,1,3,2,1,2,1]`, the output should be `6`.","solution":"def trap_water(elevation_map): Calculates the total amount of water trapped after raining given the elevation map. elevation_map: List[int]: List representing elevation heights. Returns int: Total units of water trapped. if not elevation_map or len(elevation_map) < 3: return 0 left, right = 0, len(elevation_map) - 1 left_max, right_max = elevation_map[left], elevation_map[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, elevation_map[left]) water_trapped += max(0, left_max - elevation_map[left]) else: right -= 1 right_max = max(right_max, elevation_map[right]) water_trapped += max(0, right_max - elevation_map[right]) return water_trapped"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to construct a new string by concatenating exactly `k` substrings from `s` such that the lexicographical order of the new string is minimized among all possible constructions. Return the minimized string.","solution":"def minimize_lexicographical_string(s, k): Constructs a new string by concatenating exactly `k` substrings from `s` such that the lexicographical order of the new string is minimized. Parameters: s (str): input string consisting of lowercase English letters k (int): number of substrings to concatenate Returns: str: the minimized lexicographical string n = len(s) minimized_substr = [] for i in range(n - k + 1): minimized_substr.append(s[i: i + k]) return min(minimized_substr)"},{"question":"You are given a **0-indexed** integer array `nums` representing the daily profits of a company. `nums[i]` denotes the profit on the `i-th` day. The company wants to maximize its profit by choosing some days to work and some days to rest. On each day, if the company chooses to work, it earns the profit `nums[i]`. However, the company **cannot work on two consecutive days**. Return _the **maximum** profit the company can achieve without working two consecutive days_.","solution":"def max_profit(nums): Returns the maximum profit the company can achieve without working two consecutive days. if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) dp = [0] * n dp[0] = max(0, nums[0]) dp[1] = max(dp[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) return dp[-1]"},{"question":"You are given an undirected graph represented by an adjacency list where `graph[a]` contains a list of all nodes `b` such that there is an edge between nodes `a` and `b`. Write a function that determines if there is a cycle in the graph. A cycle is defined as a path of edges that starts and ends at the same node, without repeating any edges or nodes. The function should return `true` if there is at least one cycle in the graph, and `false` otherwise. Implement the function: ```python def has_cycle(graph: List[List[int]]) -> bool: ``` where: - `graph` is a List of Lists of integers representing the adjacency list of the graph. # Example ```python # Example 1: graph = [ [1, 2], [0, 3], [0, 3], [1, 2] ] # has_cycle(graph) returns: True # Example 2: graph = [ [1], [0, 2], [1] ] # has_cycle(graph) returns: False ```","solution":"def has_cycle(graph: list[list[int]]) -> bool: Determines if there is a cycle in an undirected graph. Parameters: graph (list[list[int]]): The adjacency list of the graph. Returns: bool: True if there is at least one cycle in the graph, False otherwise. visited = [False] * len(graph) def dfs(v, parent): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: if dfs(neighbour, v): return True elif neighbour != parent: return True return False for node in range(len(graph)): if not visited[node]: # If the node hasn\'t been visited yet. if dfs(node, -1): # We use -1 as the parent of the root node. return True return False"},{"question":"You are given an integer `N` representing the number of nodes in a network. The network is represented as an array of edges where each edge is a tuple `(u, v, w)` indicating there is a connection between nodes `u` and `v` with a weight `w`. You need to determine if there is a cycle in the network that includes node 1 and has the total weight of edges exactly equal to `k`. Return `true` if such a cycle exists, and `false` otherwise.","solution":"def has_cycle_with_exact_weight(edges, N, k): from collections import defaultdict graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dfs(node, parent, current_sum, target, visited): if visited[node]: return current_sum == target visited[node] = True for neighbor, weight in graph[node]: if neighbor != parent: if dfs(neighbor, node, current_sum + weight, target, visited): return True visited[node] = False return False visited = [False] * (N + 1) return dfs(1, -1, 0, k, visited)"},{"question":"Given an integer `n`, generate the first `n` numbers of the Fibonacci sequence and return them as an array. The Fibonacci sequence is defined as follows: * `F(0) = 0, F(1) = 1`, and * `F(n) = F(n-1) + F(n-2)` for `n > 1`","solution":"def fibonacci_sequence(n): Generates the first n numbers of the Fibonacci sequence and returns them as an array. Parameters: n (int): The number of Fibonacci numbers to generate. Returns: list[int]: A list containing the first n Fibonacci numbers. if n <= 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] sequence = [0, 1] for i in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"Given an integer array `nums`, you are allowed to modify at most one element to make the array strictly increasing. An array is strictly increasing if `nums[i] < nums[i+1]` holds true for every `i` (0  i < n-1). Return whether it is possible to do this modification by changing at most one element.","solution":"def can_be_strictly_increasing(nums): Returns whether it\'s possible to make the array strictly increasing by modifying at most one element. altered = False for i in range(len(nums) - 1): if nums[i] >= nums[i + 1]: if altered: return False altered = True # Check if modifying nums[i] or nums[i + 1] can make the sequence strictly increasing if i > 0 and nums[i - 1] >= nums[i + 1]: if i + 2 < len(nums) and nums[i] >= nums[i + 2]: return False return True"},{"question":"You are given a list of non-overlapping intervals, each interval `intervals[i]` is a pair of integers `[start, end]` representing the start and end times of an event. Now, you want to add a new event represented by a pair `[new_start, new_end]` to this list, and merge the intervals if necessary to ensure no overlapping events. Return a list of the new merged intervals. Example: ``` Input: intervals = [[1, 3], [6, 9]], new_event = [2, 5] Output: [[1, 5], [6, 9]] ```","solution":"def insert_and_merge_intervals(intervals, new_event): Inserts new_event into intervals and merges overlapping intervals. :param intervals: List of non-overlapping intervals [start, end] :param new_event: New interval [new_start, new_end] to be added :return: List of merged intervals merged = [] i = 0 n = len(intervals) # Add all intervals ending before new_event starts while i < n and intervals[i][1] < new_event[0]: merged.append(intervals[i]) i += 1 # Merge all overlapping intervals with new_event while i < n and intervals[i][0] <= new_event[1]: new_event[0] = min(new_event[0], intervals[i][0]) new_event[1] = max(new_event[1], intervals[i][1]) i += 1 merged.append(new_event) # Add all remaining intervals while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"You are given a string `s` and an array of strings `words`. The string `s` is formatted by concatenating each word in the array `words` in a given order with some `#` (hash) characters in between. This sequence may include some extra `#` characters at the beginning or the end. Write a function that removes all `#` characters from the string `s` and returns the array `words` in the same order they were concatenated. For example, given the string `s` as `#hello#world#this#is#a#test#` and the array `words` as `[\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]`, return the cleaned array `[\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]`. Implement the function `def remove_hash(s: str, words: List[str]) -> List[str]` that takes in a string `s` and an array of strings `words`, removes all the `#` characters from `s`, and returns the specified structure of the string in array form.","solution":"from typing import List def remove_hash(s: str, words: List[str]) -> List[str]: Removes all hash(#) characters from the string s and returns the array of words in the same order they were concatenated. cleaned_string = s.replace(\\"#\\", \\"\\") result = [] start = 0 for word in words: length = len(word) result.append(cleaned_string[start:start+length]) start += length return result"},{"question":"You are given a string `s` which represents a mathematical expression in **infix notation**. The expression can contain non-negative integers, operators (`+`, `-`, `*`, `/`), and parentheses `(` and `)`. Your task is to evaluate this expression and return the result as an integer. Note that the division should truncate towards zero when necessary. The input string is guaranteed to be a valid expression.","solution":"def evaluate_expression(s): Evaluate a mathematical expression in infix notation and return the result. def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b elif op == \'/\': return int(a / b) # Truncates towards zero def calculate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens)) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while ops and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while ops and precedence(ops[-1]) >= precedence(tokens[i]): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while ops: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[0] return calculate(s)"},{"question":"You are given a list of integers `arr` representing the heights of different buildings in a city skyline, where `arr[i]` is the height of the `i-th` building. The city also has a rule that no building can be taller than a certain height `h`. Write a function that adjusts the height of buildings to adhere to this rule. Specifically, if a building\'s height exceeds `h`, reduce it to `h`. Return the list of adjusted building heights. Example: ```python Input: arr = [3, 9, 7, 6, 2, 5], h = 6 Output: [3, 6, 6, 6, 2, 5] ``` Explanation: The second, third, and fourth buildings have heights greater than `6`, so they are all reduced to `6`. The other buildings remain unchanged.","solution":"def adjust_building_heights(arr, h): Adjust the heights of buildings to obey the height limit `h`. Parameters: arr (list): List of building heights. h (int): Maximum allowed building height. Returns: list: List of adjusted building heights. return [min(height, h) for height in arr]"},{"question":"You are given an integer array `nums` of length `n`. You need to find the minimum sum of any **non-empty** subsequence of `nums`, such that no two elements of the subsequence are adjacent in the original array `nums`. Return _the minimum possible sum of such a subsequence_. The test cases are generated so that the answer fits in a **32-bit** integer.","solution":"def min_non_adjacent_subsequence_sum(nums): Returns the minimum sum of any non-empty subsequence of the array `nums`, such that no two elements of the subsequence are adjacent in `nums`. # The answer will always be the minimum element in the array # because picking a single element is always a valid non-adjacent subsequence. return min(nums)"},{"question":"You are given an array of integers `nums` and a positive integer `k`. A **partition** of the array is defined as a division of the array into `k` non-overlapping subarrays such that the maximum sum of any subarray is minimized. For example, given `nums = [7, 2, 5, 10, 8]` and `k = 2`, a valid partition could be `([7, 2, 5], [10, 8])`. The sum of the first subarray is 14 and the sum of the second subarray is 18, so the maximum sum amongst these subarrays is 18. Return _the minimized largest sum among these `k` subarrays_.","solution":"def splitArray(nums, k): Return the minimized largest sum among these `k` subarrays. :param nums: List[int] :param k: int :return: int def isValid(nums, mid, k): current_sum = 0 count = 1 for num in nums: current_sum += num if current_sum > mid: current_sum = num count += 1 if count > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if isValid(nums, mid, k): right = mid else: left = mid + 1 return left"},{"question":"Given a binary tree, return the preorder traversal of its nodes\' values. Preorder traversal is defined as follows: - Visit the root node. - Recursively traverse the left subtree. - Recursively traverse the right subtree. The binary tree is represented by `TreeNode` class with the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` You need to write a function that receives the root of the binary tree and returns a list of values in preorder. ```python def preorderTraversal(root: TreeNode) -> List[int]: # Your implementation here ```","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorderTraversal(root: TreeNode) -> List[int]: def traverse(node): if node: result.append(node.val) traverse(node.left) traverse(node.right) result = [] traverse(root) return result"},{"question":"You are given a string `s` representing an expression of digits and `+`, `-`, `*`, and `/` operators. The task is to evaluate this expression using Basic Calculator operations by following the operator precedence. The operators `+` and `-` have the same precedence, and `*` and `/` have the same precedence; `*` and `/` have higher precedence over `+` and `-`. Implement a function to return the final result as an integer, ensuring to adhere to the usual mathematical rules of precedence and associativity.","solution":"def evaluate_expression(s): Evaluates a mathematical expression containing digits and +, -, *, / operators. def helper(s, index): stack = [] num = 0 sign = \'+\' while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) if char in \'+-*/\' or index == len(s) - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': # For Python\'s floor division, we need to care of negative numbers # This ensures that flooring towards zero stack.append(int(stack.pop() / float(num))) num = 0 sign = char index += 1 return sum(stack), index result, _ = helper(s.replace(\\" \\", \\"\\"), 0) return result"},{"question":"You are given an integer array `arr` where each element is either `0` or `1`. You can flip exactly one `0` to `1` or one `1` to `0`. After the flip, find the length of the longest contiguous subarray that contains only `1`s. Return the _**maximum length** of the subarray formed after the flip._","solution":"def longest_subarray_after_flip(arr): Returns the length of the longest contiguous subarray of 1s after flipping exactly one 0 to 1 or one 1 to 0. max_len = 0 zero_count = 0 left = 0 for right in range(len(arr)): if arr[right] == 0: zero_count += 1 while zero_count > 1: if arr[left] == 0: zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a list of `logs` where each `logs[i] = [user_id, timestamp, event_type]` denotes an event where `user_id` performed an `event_type` operation at `timestamp`. `timestamp` is represented as an integer. Implement the class `UserActivityTracker` with the following functionalities: 1. `addLog(user_id: int, timestamp: int, event_type: str)`: - Records the log associated with the given user, timestamp, and event type. 2. `getMostRecentEvent(user_id: int, event_type: str) -> int`: - Returns the timestamp of the most recent event of the specified `event_type` for the given `user_id`. If there is no such event, return `-1`. 3. `getEventsInRange(user_id: int, start: int, end: int) -> List[str]`: - Returns a list of all event types recorded for the given `user_id` between the `start` and `end` timestamps (inclusive). The list should include events in the order they occurred.","solution":"from collections import defaultdict class UserActivityTracker: def __init__(self): # Dictionary to store user logs with user_id as the key self.logs = defaultdict(list) def addLog(self, user_id: int, timestamp: int, event_type: str): Records the log associated with the given user, timestamp, and event type. self.logs[user_id].append((timestamp, event_type)) def getMostRecentEvent(self, user_id: int, event_type: str) -> int: Returns the timestamp of the most recent event of the specified event_type for the given user_id. If there is no such event, return -1. if user_id not in self.logs: return -1 # Filter logs to find the most recent event of the given type most_recent = -1 for timestamp, event in self.logs[user_id]: if event == event_type and timestamp > most_recent: most_recent = timestamp return most_recent def getEventsInRange(self, user_id: int, start: int, end: int) -> list: Returns a list of all event types recorded for the given user_id between the start and end timestamps (inclusive). The list includes events in the order they occurred. if user_id not in self.logs: return [] return [event for timestamp, event in self.logs[user_id] if start <= timestamp <= end]"},{"question":"Given an array of integers where some elements appear twice and others appear once, find all the elements that appear twice. Return the result as an array of integers in ascending order. You must write an algorithm that runs in O(n) time and uses only constant extra space.","solution":"def find_duplicates(nums): Finds all elements that appear twice in the array. :param nums: List of integers :return: List of integers that appear twice, sorted in ascending order duplicates = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: duplicates.append(index + 1) else: nums[index] = -nums[index] duplicates.sort() return duplicates"},{"question":"You are given a string `s` containing only lowercase English letters. You can apply the following operation on the string _any number of times_: choose any two adjacent characters and swap them. The goal is to count the number of distinct permutations of `s` that can be obtained by performing any number of such operations. Return the number of distinct permutations of `s`.","solution":"from math import factorial from collections import Counter def count_permutations(s): Returns the number of distinct permutations of string s. # Count the frequency of each character in the string freq = Counter(s) # Calculate the factorial of the length of the string n = len(s) total_permutations = factorial(n) # Divide by the factorial of each frequency to avoid overcounting permutations with identical characters for count in freq.values(): total_permutations //= factorial(count) return total_permutations"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine the length of the longest substring of `s` that contains at most two distinct characters. * For example, given `s = \\"eceba\\"`, the longest substring that contains at most two distinct characters is `\\"ece\\"` with length `3`. Here is the function signature: ```python def lengthOfLongestSubstringTwoDistinct(s: str) -> int: pass ``` Return _the length of the longest substring in `s` that contains at most two distinct characters_.","solution":"def lengthOfLongestSubstringTwoDistinct(s: str) -> int: Returns the length of the longest substring of s that contains at most two distinct characters. n = len(s) if n < 3: return n left, right = 0, 0 hashmap = {} max_len = 2 while right < n: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given an `n x n` 2D matrix `grid` representing a maze where: - Each cell is either an obstacle represented by `-1` or an open space represented by `0`. - You need to find the shortest path from the top-left corner `(0, 0)` to the bottom-right corner `(n-1, n-1)`. - You can only move up, down, left, or right. - If there is no valid path, return `-1`. Return the length of the shortest path from the top-left corner to the bottom-right corner.","solution":"from collections import deque def shortest_path_in_maze(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a maze grid. If no such path exists, returns -1. n = len(grid) if grid[0][0] == -1 or grid[n-1][n-1] == -1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == n-1 and col == n-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < n and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"Given an array of intervals [[start1, end1], [start2, end2], ..., [startn, endn]] representing highway bridges, where each interval represents the start and end point (inclusive) of a bridge on a single highway, write a function to return the minimum number of new bridges required to make the entire highway passable without any gap. The new bridges should only be placed beginning at the end of the last bridge and end at the start of the next bridge. If the intervals already cover the entire highway without any gaps, return 0. For example, given intervals `[[1, 3], [6, 9], [11, 13]]`, you would need to add two new bridges: one covering `[3, 6]` and another covering `[9, 11]`. Write a function: ```python def min_new_bridges(intervals: List[List[int]]) -> int: # Your code here ``` Your task is to complete the function `min_new_bridges` to determine the minimum number of additional bridges required. The input `intervals` will be given as a list of lists where each sublist contains two integers representing the start and end of an existing bridge. The output should be a single integer representing the minimum number of new bridges required.","solution":"from typing import List def min_new_bridges(intervals: List[List[int]]) -> int: if not intervals: return 0 # Sort intervals by their start time intervals.sort() # Initialize gap count gaps = 0 # Iterate through sorted intervals and check for gaps for i in range(1, len(intervals)): # If there\'s a gap between the end of the previous bridge and the start of the current one if intervals[i][0] > intervals[i-1][1]: gaps += 1 return gaps"},{"question":"A company hosts a coding competition where programmers need to solve problems in a specified runtime limit. Each problem has an individual time limit and a list of dependencies. A problem can only be attempted if all of its dependencies have been solved. Given an integer `n` representing the number of problems, an array `time` of length `n` where `time[i]` is the time limit to solve problem `i`, and a 2D array `dependencies` where each `dependencies[i]` is a pair `[a, b]` indicating that problem `a` must be solved before problem `b`, determine the minimum total time required to solve all problems. If it is impossible to solve all problems due to cyclical dependencies, return `-1`.","solution":"from collections import defaultdict, deque def minimum_time_required(n, time, dependencies): # Create an adjacency list for the problems adj_list = defaultdict(list) in_degree = [0] * n # Build the graph and in-degree count for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Initialize a queue and add all nodes with zero in-degree queue = deque() for i in range(n): if in_degree[i] == 0: queue.append(i) # Track the total time required total_time = [0] * n while queue: node = queue.popleft() for neighbor in adj_list[node]: in_degree[neighbor] -= 1 total_time[neighbor] = max(total_time[neighbor], total_time[node] + time[node]) if in_degree[neighbor] == 0: queue.append(neighbor) # Check if there\'s any cyclic dependency if any(in_degree): return -1 # The answer is the maximum total time taken to solve any problem return max(total_time[i] + time[i] for i in range(n))"},{"question":"Given a string `s`, return `true` if the string contains at least one instance of three consecutive identical characters, and `false` otherwise.","solution":"def has_three_consecutive_identical_chars(s): Returns True if the string contains at least one instance of three consecutive identical characters, False otherwise. for i in range(len(s) - 2): if s[i] == s[i + 1] == s[i + 2]: return True return False"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring is considered \\"nice\\" if it contains all the letters of the alphabet in it at least once. Write a function to find the length of the smallest \\"nice\\" substring in `s`. If there are no such substrings, return -1.","solution":"def smallest_nice_substring(s): Returns the length of the smallest substring in s that contains all the letters of the English alphabet at least once. If no such substring exists, returns -1. from collections import Counter # Define the alphabet alphabet = set(\'abcdefghijklmnopqrstuvwxyz\') n = len(s) left, right = 0, 0 min_len = float(\'inf\') current_counter = Counter() while right < n: current_counter[s[right]] += 1 # Check if current window contains all alphabet letters while all(char in current_counter and current_counter[char] > 0 for char in alphabet): min_len = min(min_len, right - left + 1) current_counter[s[left]] -= 1 if current_counter[s[left]] == 0: del current_counter[s[left]] left += 1 right += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given a list of strings `words` where each string represents a word composed of lowercase English letters. Define the **weight** of a word as the total number of distinct characters it contains. Return _a list of integers where each integer corresponds to the **weight** of the respective word in the input list._ The order of the returned weights should match the order of the words in the input list.","solution":"def word_weights(words): Given a list of words, return a list of integers representing the weight of each word. Weight of a word is defined as the total number of distinct characters it contains. return [len(set(word)) for word in words]"},{"question":"You are given two strings `initialState` and `finalState`, both consisting of lowercase letters. Your task is to determine if you can transform `initialState` into `finalState` by following a specific set of operations. An operation consists of selecting any character in the current string and moving it to the front of the string. Return _the minimum number of operations required to transform `initialState` into `finalState`, or `-1` if it is not possible_. Example: - Input: initialState = \\"abc\\", finalState = \\"bca\\" - Output: 2 **Note:** - The length of both strings will be the same. - The transformation should only consider the possibility of character rearrangement without altering the frequency of any character between the strings.","solution":"def min_operations(initialState, finalState): if sorted(initialState) != sorted(finalState): return -1 n = len(initialState) ops = 0 j = n - 1 for i in range(n - 1, -1, -1): if initialState[i] == finalState[j]: j -= 1 else: ops += 1 return ops"},{"question":"Given an integer array `nums`, return the length of the longest contiguous subarray that contains only unique integers. In other words, you need to find the maximum length of a subarray where every element appears exactly one time.","solution":"def longest_unique_subarray(nums): Returns the length of the longest subarray with unique elements. n = len(nums) if n == 0: return 0 max_len = 0 start = 0 seen = {} for end in range(n): if nums[end] in seen and seen[nums[end]] >= start: start = seen[nums[end]] + 1 seen[nums[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an integer array `nums`. We define a running median of the array `nums` as an array of the same length where the i-th element is the median of the first `i+1` elements of `nums`. Write a function that returns the running median array. Note: The median of a list of numbers is the middle number when the numbers are sorted in order. If the list has an even number of elements, the median is the average of the two middle numbers.","solution":"import bisect def running_median(nums): Returns the running median array of the given list \'nums\'. medians = [] current_elements = [] for i in range(len(nums)): bisect.insort(current_elements, nums[i]) length = len(current_elements) if length % 2 == 1: medians.append(current_elements[length // 2]) else: medians.append((current_elements[length // 2 - 1] + current_elements[length // 2]) / 2) return medians"},{"question":"You are given a list of unique integers named `nums` where each integer is between 1 and `n` (inclusive), and there are no duplicates. However, one integer between 1 and `n` is missing. Write a function that finds and returns the missing number. For example, if `nums = [1, 2, 4, 5, 6]`, then the function should return `3` since `3` is the missing number in the range from `1` to `6`. Consider the array may be unsorted.","solution":"def find_missing_number(nums): Returns the missing number in the list of integers from 1 to n. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"Given an integer array `heights` representing the heights of buildings, where `heights[i]` is the height of the `i`-th building, a rainwater lake can form between two buildings if the heights of all buildings between them are less than or equal to the smaller of the two. Calculate the total amount of rainwater that can be trapped after it rains. Implement the method `int trapRainwater(int[] heights)` that returns the amount of trapped rainwater.","solution":"def trapRainwater(heights): Calculates the total amount of rainwater trapped between the buildings. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: Total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"You are given a 2D grid `grid` of size `n x m` representing a map of a city. Each cell in the grid contains a value representing the height of a building in that location. You are standing at the top-left corner of the grid (cell `(0, 0)`) and you want to reach the bottom-right corner of the grid (cell `(n-1, m-1)`). From any cell `(i, j)`, you can move to any of the four neighboring cells `(i+1, j)`, `(i-1, j)`, `(i, j+1)`, or `(i, j-1)`, but the absolute difference in height between the current cell and the target cell must not exceed a given threshold `k`. Return the minimum number of steps required to reach the bottom-right corner from the top-left corner of the grid. If it is not possible to reach the bottom-right corner, return `-1`. The new problem tests the ability to navigate a grid with specific movement constraints, aligning with existing problem concepts and maintaining a similar level of complexity.","solution":"from collections import deque def min_steps(grid, k): Given a 2D grid \'grid\' of size n x m and a height difference threshold \'k\', return the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner. If it is not possible, return -1. def is_within_bounds(x, y, n, m): return 0 <= x < n and 0 <= y < m n = len(grid) m = len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == n - 1 and y == m - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny, n, m) and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= k: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given a 2D grid of size `m x n` representing a labyrinth where each cell can either be an empty space (represented by \'0\') or a wall (represented by \'1\'). You start at the top-left corner of the grid and need to find the shortest path to the bottom-right corner. However, you can break up to one wall (convert \'1\' to \'0\') to potentially shorten the path. Return the length of the shortest path that reaches the bottom-right corner while possibly breaking one wall. If there is no path, return `-1`.","solution":"from collections import deque def shortest_path_with_one_wall_break(grid): Function to find the shortest path from top-left to bottom-right in a labyrinth where you can break up to one wall. Parameters: grid (List[List[str]]): 2D list representing the labyrinth. Returns: int: Length of the shortest path or -1 if no such path exists. m, n = len(grid), len(grid[0]) if not grid or grid[0][0] == \'1\' or grid[m-1][n-1] == \'1\': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1, 0)]) # (x, y, distance, wall_broken) visited = set((0, 0, 0)) while queue: x, y, distance, wall_broken = queue.popleft() if (x, y) == (m - 1, n - 1): return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == \'0\' and (nx, ny, wall_broken) not in visited: visited.add((nx, ny, wall_broken)) queue.append((nx, ny, distance + 1, wall_broken)) elif grid[nx][ny] == \'1\' and wall_broken == 0 and (nx, ny, 1) not in visited: visited.add((nx, ny, 1)) queue.append((nx, ny, distance + 1, 1)) return -1"},{"question":"You are given an integer matrix `grid` representing a rectangular grid of cells, where each cell contains an integer. Write a function to find the **largest** value that can be achieved by starting at any cell in the grid and moving to adjacent cells (up, down, left, right) with non-decreasing values. You may only move to a cell if its value is greater than or equal to the value of the current cell. Return the value of the largest possible path in the grid.","solution":"def longest_increasing_path_value(grid): Finds the largest value that can be achieved by starting at any cell in the grid and moving to adjacent cells with non-decreasing values. Parameters: grid (List[List[int]]): A 2D list of integers representing the grid. Returns: int: The largest value of the path found in the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[None] * cols for _ in range(rows)] def dfs(r, c): if dp[r][c] is not None: return dp[r][c] value = grid[r][c] max_value_path = value for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] >= value: max_value_path = max(max_value_path, dfs(nr, nc)) dp[r][c] = max_value_path return dp[r][c] max_path_value = 0 for r in range(rows): for c in range(cols): max_path_value = max(max_path_value, dfs(r, c)) return max_path_value"},{"question":"A company is organizing a conference, and they have a list of `n` sessions. Each session is represented by an integer array `session` where `session[i] = [starti, endi]` signifies the start and end times of the `i-th` session. The company wants to find the maximum number of non-overlapping sessions they can schedule. A session can be attended entirely from its start time to its end time without any overlap with other sessions. Given an array `sessions` where `sessions[i] = [starti, endi]`, return _the maximum number of non-overlapping sessions that can be attended_.","solution":"def max_non_overlapping_sessions(sessions): Returns the maximum number of non-overlapping sessions that can be attended. Parameters: sessions (List[List[int]]): A list of [start, end] time pairs for each session. Returns: int: The maximum number of non-overlapping sessions. # Sort the sessions based on their end times sessions.sort(key=lambda x: x[1]) # Initialize the end time of the last attended session to a very small value last_end_time = float(\'-inf\') max_sessions = 0 for start, end in sessions: if start >= last_end_time: # Attend this session last_end_time = end max_sessions += 1 return max_sessions"},{"question":"You are given an integer array `arr` (**0-indexed**). In one operation, you can remove any element from the array and place it at the end. Your goal is to determine the **minimum** number of operations needed to make the sum of any `k` consecutive elements in the array greater than or equal to a given integer `x`. Return the minimum number of operations required, or `-1` if it is not possible to achieve the goal.","solution":"def min_operations_to_reach_sum(arr, k, x): Returns the minimum number of operations needed to make the sum of any k consecutive elements in the array greater than or equal to x. Return -1 if it\'s not possible to achieve the goal. n = len(arr) if k > n: return -1 # Compute initial sum of first k elements current_sum = sum(arr[:k]) if current_sum >= x: return 0 # Find the max sum of k consecutive elements by shifting window max_sum = current_sum for i in range(1, n - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] max_sum = max(max_sum, current_sum) if max_sum >= x: return 0 else: return -1"},{"question":"You are given two strings `s` and `t` of equal length consisting only of lowercase English letters. You can change either of the strings one character at a time. Each operation consists of changing a character in `s` to any other character of the alphabet. The goal is to make both strings equal. Compute the minimum number of operations required to make the two strings identical. Return _the minimum number of operations to make `s` and `t` identical_.","solution":"def min_operations_to_make_equal(s, t): Returns the minimum number of operations required to make strings s and t identical. :param s: First string :param t: Second string :return: Minimum number of operations required to make s and t identical if len(s) != len(t): raise ValueError(\\"The strings must be of equal length.\\") return sum(1 for ch1, ch2 in zip(s, t) if ch1 != ch2)"},{"question":"A conveyor belt has `n` packages with weights represented by an array `weights`. Each package needs to be delivered to one of two destinations. There are two workers available, each with a capacity equal to the total weight of half the packages, rounded up. Your task is to determine if it\'s possible to distribute the packages between the two workers such that neither worker exceeds their capacity. Return `True` if it\'s possible to evenly distribute the packages based on their capacities, otherwise return `False`.","solution":"def can_distribute_packages(weights): Determines if it\'s possible to distribute the packages between the two workers such that neither worker exceeds their capacity. :param weights: List[int], the weights of the packages :return: boolean, True if the distribution is possible, False otherwise total_weight = sum(weights) half_capacity = (total_weight + 1) // 2 n = len(weights) dp = [False] * (half_capacity + 1) dp[0] = True for weight in weights: for j in range(half_capacity, weight - 1, -1): if dp[j - weight]: dp[j] = True return dp[half_capacity]"},{"question":"You are given an array `events`, where `events[i] = [startDayi, endDayi]` represents an event that starts at `startDayi` and ends at `endDayi`, inclusive. You can attend an event i if you are free on every day from `startDayi` to `endDayi`. Note that you can only attend one event at a time. Return the maximum number of events you can attend.","solution":"def maxEvents(events): Returns the maximum number of events that can be attended. events.sort(key=lambda x: x[1]) # Sort events by their end days. attended_days = set() for event in events: for day in range(event[0], event[1] + 1): if day not in attended_days: attended_days.add(day) break return len(attended_days)"},{"question":"Given a binary tree, implement a class `BinaryTree` with the following methods: 1. `void add(int value)` - Adds a node with the given `value` to the binary tree. 2. `List<Integer> getLeaves()` - Returns a list of all leaf nodes\' values of the binary tree. 3. `boolean isBalanced()` - Returns `true` if the binary tree is balanced, and `false` otherwise. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Implement the class accordingly.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add(self, value): Adds a node with the given value to the binary tree. if not self.root: self.root = TreeNode(value) else: self._add_recursive(self.root, value) def _add_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._add_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._add_recursive(node.right, value) def getLeaves(self): Returns a list of all leaf nodes\' values of the binary tree. leaves = [] self._collect_leaves(self.root, leaves) return leaves def _collect_leaves(self, node, leaves): if node is not None: if node.left is None and node.right is None: leaves.append(node.value) if node.left: self._collect_leaves(node.left, leaves) if node.right: self._collect_leaves(node.right, leaves) def isBalanced(self): Returns True if the binary tree is balanced, and False otherwise. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) balanced = abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced and left_balanced and right_balanced _, is_balanced = check_balance(self.root) return is_balanced"},{"question":"A data analyst needs to segment a list of customer transactions into 2 distinct groups such that the difference between the sum of transactions in each group is minimized. Given a list of integers representing transaction amounts, return the minimum difference achievable between the total sums of the two groups.","solution":"def minimum_difference_partition(transactions): Segments a list of customer transactions into 2 groups such that the difference between the sum of transactions in each group is minimized and returns the minimal difference. total_sum = sum(transactions) n = len(transactions) target = total_sum // 2 # Initializing DP table where dp[i] means if we can form sum i with any subset of transactions dp = [False] * (target + 1) dp[0] = True for transaction in transactions: # We iterate backwards to avoid using the same element multiple times for j in range(target, transaction - 1, -1): dp[j] = dp[j] or dp[j - transaction] # Finding the highest value we can reach <= target which indicates the closest sum to half the total sum for i in range(target, -1, -1): if dp[i]: sum1 = i break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"You are given a binary tree where each node represents a different unique integer value. The distance between two nodes in the tree is defined as the number of edges in the path connecting them. Given the root of the tree and two integers `x` and `y`, find the minimum distance between the nodes with these values. If either of the values `x` or `y` does not exist in the tree, return `-1`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_lca(root, x, y): if not root: return None if root.value == x or root.value == y: return root left_lca = find_lca(root.left, x, y) right_lca = find_lca(root.right, x, y) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca def find_distance_from_lca(lca, value, distance=0): if not lca: return -1 if lca.value == value: return distance left_dist = find_distance_from_lca(lca.left, value, distance + 1) right_dist = find_distance_from_lca(lca.right, value, distance + 1) return left_dist if left_dist != -1 else right_dist def find_minimum_distance(root, x, y): if not root: return -1 lca = find_lca(root, x, y) if not lca: return -1 dist_x = find_distance_from_lca(lca, x) dist_y = find_distance_from_lca(lca, y) if dist_x == -1 or dist_y == -1: return -1 return dist_x + dist_y"},{"question":"You are given a list of integers `arr` which is guaranteed to be **bitonic**. A bitonic sequence is a sequence that first increases and then decreases. Your task is to find the **maximum element** in this bitonic sequence. Return an integer `max_element`, the maximum value in the provided bitonic list `arr`.","solution":"def find_max_in_bitonic(arr): Finds the maximum element in a bitonic sequence. Bitonic sequence: A sequence that first increases then decreases. :param arr: List of integers in bitonic order. :return: The maximum element in the bitonic sequence. left, right = 0, len(arr) - 1 while left < right: mid = left + (right - left) // 2 if arr[mid] > arr[mid + 1]: right = mid else: left = mid + 1 return arr[left]"},{"question":"You are given a list of strings `operations` where each string represents an operation and has one of the following formats: 1. `\\"PUSH x\\"` - Push integer `x` onto the stack. 2. `\\"POP\\"` - Remove the top element of the stack. 3. `\\"INCREMENT k val\\"` - Increment the bottom `k` elements of the stack by the integer `val`. You need to implement a function that simulates the stack operations and returns the final state of the stack as a list of integers. The function should initialize with an empty stack and process the operations in the order they are given. If a `POP` operation is performed on an empty stack, it should be ignored. Return the final state of the stack after all operations have been performed.","solution":"def process_operations(operations): stack = [] for op in operations: parts = op.split() if parts[0] == \\"PUSH\\": stack.append(int(parts[1])) elif parts[0] == \\"POP\\": if stack: stack.pop() elif parts[0] == \\"INCREMENT\\": k = int(parts[1]) val = int(parts[2]) for i in range(min(k, len(stack))): stack[i] += val return stack"},{"question":"Given an array of distinct integers `arr` and an integer `k`, find the **k-th** lexicographical permutation of the array. The lexicographical order of permutations is the order in which they appear in a dictionary if each permutation is treated as a word. Return the k-th permutation as an array of integers. If `k` is greater than the total number of permutations, return an empty array.","solution":"import math def kth_permutation(arr, k): Returns the k-th lexicographical permutation of the array. Parameters: arr (list): A list of distinct integers. k (int): The k-th permutation to find. Returns: list: The k-th permutation as a list of integers or an empty list if k is greater than the total number of permutations. n = len(arr) if k > math.factorial(n): return [] k -= 1 # Convert to zero-based index result = [] arr = sorted(arr) # Ensure arr is sorted for i in range(n): factor = math.factorial(n - 1 - i) index = k // factor result.append(arr.pop(index)) k %= factor return result"},{"question":"You are given a `2 x n` 0-indexed integer array `grid` representing a grid of coins, where `grid[0][j]` and `grid[1][j]` are the number of coins at position `(0, j)` and `(1, j)` respectively. You can move to any `(i, j)` from `(i, j-1)`, meaning you can move horizontally or switch rows. You need to find the maximum number of coins you can collect starting from the leftmost position `(0, 0)` or `(1, 0)` and ending at the rightmost position `(0, n-1)` or `(1, n-1)`. Return the maximum number of coins you can collect.","solution":"def max_coins(grid): n = len(grid[0]) # Initialize dp table dp = [[0] * n for _ in range(2)] # Base cases dp[0][0] = grid[0][0] dp[1][0] = grid[1][0] # Fill dp table for j in range(1, n): dp[0][j] = grid[0][j] + max(dp[0][j-1], dp[1][j-1]) dp[1][j] = grid[1][j] + max(dp[0][j-1], dp[1][j-1]) # Return the maximum coins collected return max(dp[0][n-1], dp[1][n-1])"},{"question":"Given an array `heights` representing the heights of buildings, return a list of all buildings that have an unobstructed ocean view. A building has an unobstructed ocean view if all the buildings to its right are shorter. The buildings are represented in an array from left to right, and the ocean is on the right side of the array. Implement the `Solution` class: * `Solution()` Initializes the object. * `List<Integer> findBuildingsWithOceanView(int[] heights)` Returns a list of indices of the buildings that have an unobstructed ocean view.","solution":"class Solution: def findBuildingsWithOceanView(self, heights): Returns a list of indices of buildings that have an unobstructed ocean view. if not heights: return [] n = len(heights) result = [n - 1] for i in range(n - 2, -1, -1): if heights[i] > heights[result[-1]]: result.append(i) return result[::-1]"},{"question":"You are organizing a coding competition and need to create a leaderboard. The leaderboard should display the scores of each participant in descending order. You are given a list of tuples `results`, where each tuple contains a participant\'s name and their score in the format `(name, score)`. Return _a list of participants\' names sorted by their scores in descending order_. If two participants have the same score, they should be sorted by their names in lexicographical order. **Note:** Make sure to handle cases where there are participants with the same name but different scores. Here is function signature: `def sort_leaderboard(results: List[Tuple[str, int]]) -> List[str]:`","solution":"from typing import List, Tuple def sort_leaderboard(results: List[Tuple[str, int]]) -> List[str]: Returns the list of participant names sorted by their scores in descending order. If scores are equal, names are sorted lexicographically. # Sort the results first by score (descending) and then by name (ascending) sorted_results = sorted(results, key=lambda x: (-x[1], x[0])) # Extract the names from the sorted results return [name for name, score in sorted_results]"},{"question":"You are given a string `s` of lowercase letters and an array of strings `words`. All the strings in `words` are of the same length. A word is called a predecessor of another word if and only if you can add exactly one letter anywhere in the former word to obtain the latter word. For example, \\"abc\\" is a predecessor of \\"abac\\". Return the number of words in `words` that are predecessors of `s`, or can be transformed into `s` by adding one letter. **Example:** Input: ```text s = \\"abc\\" words = [\\"ab\\", \\"ac\\", \\"bc\\", \\"abd\\", \\"abc\\"] ``` Output: ```text 3 ``` Explanation: The words \\"ab\\", \\"ac\\", and \\"bc\\" can each be transformed into \\"abc\\" by adding one letter. The words \\"abd\\" and \\"abc\\" either cannot be transformed to \\"abc\\" by adding one letter, or are already equal to \\"s\\".","solution":"def count_predecessors(s, words): def is_predecessor(word1, word2): # Only proceed if the length difference is exactly 1 if len(word2) - len(word1) != 1: return False # Iterate through word2 and try removing one character for i in range(len(word2)): if word1 == word2[:i] + word2[i+1:]: return True return False count = 0 for word in words: if is_predecessor(word, s): count += 1 return count"},{"question":"You are given a string `s` that consists of only uppercase English letters. You can perform two types of operations on this string: 1. Choose any character in the string and change it to any other uppercase English letter. 2. Choose any two adjacent characters in the string and swap them. You are also given an integer `k` which denotes the maximum number of operations you can perform. Determine the lexicographically smallest string that can be obtained by performing at most `k` operations on the string `s`. Return _the lexicographically smallest string that can be obtained_.","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by performing at most k operations on the string s. if k >= len(s): # If k is greater or equal to the length of string, we can sort the string. return \'\'.join(sorted(s)) else: # We can only swap adjacent characters or change any character to any other one. # Use bubble sort like approach considering k swaps to get closer to the lexicographically smallest string. s = list(s) for i in range(len(s)): for j in range(min(k, len(s) - i - 1)): if s[j] > s[j + 1]: s[j], s[j + 1] = s[j + 1], s[j] k -= 1 if k == 0: return \'\'.join(s) return \'\'.join(s)"},{"question":"You are given a list of non-negative integers representing the heights of a series of vertical lines drawn on an x-axis, where the distance between each consecutive pair of lines is exactly 1. Each line represents a point `(i, height[i])` on the coordinate plane. Two lines form a container which can hold water, and the area of water that can be held by the container is determined by the shorter of the two lines and the distance between them. Determine the maximum amount of water that can be contained by any two lines drawn on the coordinate plane. Return _the maximum area of water that the container can hold_.","solution":"def max_area(heights): Returns the maximum area of water that the container can hold given the heights of the lines. max_area_water = 0 left = 0 right = len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area_water = max(max_area_water, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area_water"},{"question":"You are given a string `s` and an integer `numRows`. Your task is to convert `s` into a zigzag pattern on a given number of rows, and then read the converted string line by line. Specifically, you will be writing the characters in a zigzag fashion like this (assuming `numRows` is 4): ``` P I N A L S I G Y A H R P I ``` Given `numRows`, return the string that will be formed when you rearrange the characters in this zigzag order.","solution":"def convert(s, numRows): if numRows == 1 or numRows >= len(s): return s # Create an array to hold the zigzag pattern rows = [\'\' for _ in range(numRows)] # Initialize variables to track the direction and current position current_row = 0 going_down = False # Traverse the input string and place each character in the appropriate row for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 # Join all rows to form the final zigzag string return \'\'.join(rows)"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring of `s` is called **good** if it contains no repeating characters. Return the length of the longest **good** substring. If no such substring exists, return `0`. Implement a function `int longestGoodSubstring(String s)` that computes the result. For example: - Input: \\"abcabcbb\\" - Output: 3 Here, the answer is \\"abc\\", with the length of 3. - Input: \\"bbbbb\\" - Output: 1 Here, the answer is \\"b\\", with the length of 1. - Input: \\"pwwkew\\" - Output: 3 Here, the answer is \\"wke\\", with the length of 3.","solution":"def longestGoodSubstring(s): Returns the length of the longest good substring. A good substring is a substring that contains no repeating characters. :param s: A string consisting of lowercase English letters. :type s: str :return: Length of the longest good substring. :rtype: int if not s: return 0 n = len(s) max_len = 0 char_index = {} start = 0 for end in range(n): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an integer array `nums` and an integer `k`. In one move, you can choose any single element in the array and change it to any value. Return the _minimum number of moves_ required to make the array such that the difference between the maximum and minimum elements in `nums` is _at most_ `k`.","solution":"def min_moves_to_reduce_range(nums, k): Returns the minimum number of moves required to make the difference between the maximum and minimum elements in nums at most k. Parameters: nums (list of int): The list of integers. k (int): The maximum allowed difference between the maximum and minimum elements. Returns: int: The minimum number of moves required. min_num, max_num = min(nums), max(nums) # If the range is already within k, no moves are needed if max_num - min_num <= k: return 0 else: return len(nums) # All elements need to be changed to either min_num + k or max_num - k # Example usage: # nums = [1, 3, 6, 10, 15], k = 4 # After 3 moves: [1, 3, 7, 7, 7], difference between max and min is 6, which is <= 4. Output should be 3."},{"question":"Given a string `s`, return the length of the longest substring of `s` such that all the characters in this substring are the same. If the string `s` is empty, return 0.","solution":"def longest_uniform_substring_length(s): Returns the length of the longest substring of `s` such that all the characters in this substring are the same. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"Given two integer arrays `arr1` and `arr2` of the same length, return an array of integers `result` such that `result[i] = min(arr1[i], arr2[i])` for every `i` where `0 <= i < arr1.length`. If the arrays are not of the same length, return an empty array.","solution":"def min_elements(arr1, arr2): Returns an array of integers where each element is the minimum between the corresponding elements of arr1 and arr2. If the arrays are not of the same length, returns an empty array. if len(arr1) != len(arr2): return [] result = [min(a, b) for a, b in zip(arr1, arr2)] return result"},{"question":"Given an integer array `nums` and an integer `k`, modify the array in the following way: randomly pick an index `i` between `0` and `n-1` (where `n` is the size of the array) and change `nums[i]` to any value between `1` and `k` inclusive. Return the minimum number of changes required such that no two adjacent elements are the same in the final array.","solution":"def min_changes_to_no_adjacent(nums, k): Returns the minimum number of changes required such that no two adjacent elements are the same in the final array. :param nums: List of integers :param k: Integer, range of the values from 1 to k (inclusive) :return: Integer, minimum number of changes n = len(nums) # Edge case: If nums has only 1 or no element if n <= 1: return 0 # Initialize the changes array with large numbers dp = [[float(\'inf\')] * (k + 1) for _ in range(n)] # Base case: First element can be any number between 1 and k for i in range(1, k + 1): dp[0][i] = 0 if i == nums[0] else 1 # Fill dp array for i in range(1, n): for j in range(1, k + 1): if dp[i - 1][j] != float(\'inf\'): for l in range(1, k + 1): if l != j: # no adjacent duplicates dp[i][l] = min(dp[i][l], dp[i - 1][j] + (0 if nums[i] == l else 1)) # Get the minimum changes from the last row of the dp return min(dp[-1])"},{"question":"You are given a string `s` consisting of lowercase English letters. You are also given a character `c`. Return an integer array `result` of the same length as `s` where `result[i]` is the shortest distance from the character `s[i]` to the character `c` in the string `s`. If there are multiple occurrences of `c`, consider the shortest distance to any occurrence.","solution":"def shortest_to_char(s, c): Given a string s and a character c, return an array where each element is the shortest distance from the character at that position in s to c. n = len(s) result = [float(\'inf\')] * n # Forward pass to find shortest distance to previous occurrences of c prev = float(\'-inf\') for i in range(n): if s[i] == c: prev = i result[i] = i - prev # Backward pass to find shortest distance to next occurrences of c next = float(\'inf\') for i in range(n-1, -1, -1): if s[i] == c: next = i result[i] = min(result[i], next - i) return result"},{"question":"You are given a list of integers `nums` and an integer `k`. You need to determine if there exists any subarray of length `k` that can be rearranged to form a consecutive sequence of numbers (i.e., each number in the subarray is one more than the previous number). Return `true` if such a subarray exists, otherwise return `false`. Note that the elements of the subarray do not need to be unique but should be able to form a consecutive sequence when reordered.","solution":"def can_form_consecutive(nums, k): Determines if there exists any subarray of length k that can be rearranged to form a consecutive sequence of numbers. :param nums: List[int] :param k: int :return: bool if k > len(nums): return False for i in range(len(nums) - k + 1): subarray = sorted(nums[i:i + k]) consecutive = True for j in range(1, k): if subarray[j] != subarray[j - 1] + 1: consecutive = False break if consecutive: return True return False"},{"question":"You are given an array of integers `arr` and an integer `m`. You need to find the maximum sum of `m` consecutive elements in the array. If the array has fewer than `m` elements, return the sum of all elements in the array. Implement a function that returns the maximum sum as described. **Function Signature:** ```python def max_consecutive_sum(arr: List[int], m: int) -> int: pass ```","solution":"from typing import List def max_consecutive_sum(arr: List[int], m: int) -> int: Returns the maximum sum of m consecutive elements in the array. If the array has fewer than m elements, returns the sum of all elements in the array. if len(arr) < m: return sum(arr) max_sum = current_sum = sum(arr[:m]) for i in range(m, len(arr)): current_sum += arr[i] - arr[i - m] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an `m x n` integer matrix `grid`, return the length of the longest increasing path in `grid`. An increasing path is a path where each subsequent cell is strictly greater than the previous cell. You may move in any of the four cardinal directions (up, down, left, right) from a cell. **Example:** ```python grid = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] The longest increasing path is [1, 2, 6, 9], so the length is 4. ``` Implement the following method: ```python def longestIncreasingPath(grid: List[List[int]]) -> int: # Your code here ```","solution":"from typing import List def longestIncreasingPath(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[-1] * cols for _ in range(rows)] def dfs(r, c): if dp[r][c] != -1: return dp[r][c] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_path = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] > grid[r][c]: max_path = max(max_path, 1 + dfs(nr, nc)) dp[r][c] = max_path return dp[r][c] return max(dfs(r, c) for r in range(rows) for c in range(cols))"},{"question":"You are given two strings `word1` and `word2`. Implement a function `minDistance` to find the minimum number of operations required to convert `word1` to `word2`. You can perform the following operations on a string: - **Insert** a character. - **Delete** a character. - **Replace** a character. Given the constraints that both strings consist of lowercase English letters only, find and return the minimum number of operations required.","solution":"def minDistance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # delete dp[i][j - 1], # insert dp[i - 1][j - 1]) # replace return dp[m][n]"},{"question":"Given two strings, write a function to determine if one string is a permutation of another. The function should return `true` if one string is a permutation of the other, and `false` otherwise. Note that the comparison is case-sensitive and whitespace is significant.","solution":"def are_permutations(str1, str2): Determines if str1 is a permutation of str2. return sorted(str1) == sorted(str2)"},{"question":"Given a string `s` consisting of lowercase English letters, you need to determine the minimum number of steps required to make `s` a palindrome. In one step, you can insert any character at any position in the string. Return _the minimum number of insertion steps required to make the string a palindrome_.","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of insertions required to make the string `s` a palindrome. def lcs(a, b): dp = [[0] * (len(b) + 1) for _ in range(len(a) + 1)] for i in range(1, len(a) + 1): for j in range(1, len(b) + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[len(a)][len(b)] reverse_s = s[::-1] lcs_length = lcs(s, reverse_s) return len(s) - lcs_length"},{"question":"You are given two integer arrays `arr1` and `arr2` sorted in **ascending order** and of size `m` and `n`, respectively. Write a function that finds the **k-th** smallest element in the merged array formed by merging `arr1` and `arr2`. _Implement your solution in_ O(log(min(m, n))) _time complexity_.","solution":"def find_kth_element(arr1, arr2, k): Finds the k-th smallest element in the merged array formed by arr1 and arr2 in O(log(min(m, n))) time complexity. m, n = len(arr1), len(arr2) if m > n: return find_kth_element(arr2, arr1, k) if m == 0: return arr2[k - 1] if k == 1: return min(arr1[0], arr2[0]) i = min(m, k // 2) j = min(n, k // 2) if arr1[i - 1] > arr2[j - 1]: return find_kth_element(arr1, arr2[j:], k - j) else: return find_kth_element(arr1[i:], arr2, k - i)"},{"question":"You are given a list of `n` integers representing the radii of circles arranged in a single file line. Each circle is tangent to the next one in line, implying that the distance between the centers of two adjacent circles is the sum of their radii. Write a function that determines the total length of this arrangement, measured as the distance from the center of the first circle to the center of the last circle. Return this distance as an integer.","solution":"def total_length_of_circles(radii): Returns the total length of the arrangement of circles. The length is measured as the distance from the center of the first circle to the center of the last circle. Parameters: radii (list of int): List of radii of the circles. Returns: int: The total length of the arrangement in a single file line. if not radii: # if the list is empty return 0 total_length = 0 for i in range(len(radii) - 1): total_length += radii[i] + radii[i + 1] return total_length"},{"question":"You are given a string `s` containing only digits and an integer `k`. A k-substring is defined as a substring of `s` with a length of exactly `k` that contains unique digits. Return the number of k-substrings in `s`. **Example:** * Input: s = \\"123456\\", k = 3 * Output: 4 **Explanation:** The input string \\"123456\\" has 4 unique k-substrings of length 3: \\"123\\", \\"234\\", \\"345\\", and \\"456\\". **Notes:** * A substring is a contiguous sequence of characters within a string. * Digits in the k-substring should be unique.","solution":"def count_unique_k_substrings(s, k): Returns the number of unique k-substrings in string s. A k-substring is defined as a substring of s with length exactly k that contains unique digits. if k > len(s): return 0 count = 0 for i in range(len(s) - k + 1): substring = s[i:i + k] if len(set(substring)) == k: count += 1 return count"},{"question":"Given an integer `n`, implement a function that returns the `n`th term of the **look-and-say sequence**. The look-and-say sequence is a sequence of integers starting with \\"1\\" where each subsequent term is generated by describing the digits of the previous term. * For example, the first few terms of the look-and-say sequence are: 1. 1 2. 11 (one 1) 3. 21 (two 1s) 4. 1211 (one 2, then one 1) 5. 111221 (one 1, one 2, then two 1s) You may assume `n` is a positive integer and 1  `n`  30.","solution":"def look_and_say(n): Returns the `n`th term of the look-and-say sequence. if n == 1: return \\"1\\" prev_term = look_and_say(n - 1) result, i = \\"\\", 0 while i < len(prev_term): count = 1 while i + 1 < len(prev_term) and prev_term[i] == prev_term[i + 1]: i += 1 count += 1 result += str(count) + prev_term[i] i += 1 return result"},{"question":"You are given an array of integers `height` representing the heights of walls in a row where the width of each wall is 1. Imagine it rains heavily, forming trapped water between walls. Write an algorithm to compute how much water it can trap after raining. The amount of water trapped between walls is determined by how much water can accumulate above each wall where the depth of water is limited by the shorter of the two tallest walls to the left and right of that point. Return an integer representing the total amount of trapped water.","solution":"def trap(height): Calculate the total amount of rain water trapped between walls. Parameters: height (List[int]): A list of integers representing the height of walls. Returns: int: Total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given an array of integers `nums`, determine if there are three distinct elements `a`, `b`, and `c` in `nums` such that `a + b + c == 0`. Return `true` if such a triplet exists and `false` otherwise. The function should have a time complexity better than O(n^3).","solution":"def three_sum(nums): Determine if there are three distinct elements a, b, and c in nums such that a + b + c == 0. nums.sort() n = len(nums) for i in range(n): # Avoid duplicates for i if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: return True elif total < 0: left += 1 else: right -= 1 return False"},{"question":"You are given a 2D integer matrix `grid` where each cell has a value `0` representing an empty cell or `1` representing an obstacle. You can move from one cell to another adjacent cell (up, down, left, or right) if the adjacent cell\'s value is `0`. Diagonals are not allowed. Given a start cell `(x1, y1)` and an end cell `(x2, y2)`, return _the **minimum** number of steps required to reach the end cell from the start cell_. If it is not possible to reach the end cell, return `-1`.","solution":"from collections import deque def min_steps(grid, start, end): Returns the minimum number of steps required to reach the end cell from the start cell in a given grid. If the path is not possible, returns -1. :param grid: List[List[int]] :param start: Tuple[int, int] :param end: Tuple[int, int] :return: int rows, cols = len(grid), len(grid[0]) x1, y1 = start x2, y2 = end if grid[x1][y1] == 1 or grid[x2][y2] == 1: return -1 queue = deque([(x1, y1, 0)]) # (x, y, steps) visited = set() visited.add((x1, y1)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, steps = queue.popleft() if (x, y) == (x2, y2): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"You are given an array of integers `heights` representing the histogramss bar height where the width of each bar is `1`. Implement a function `largestRectangleArea` that returns the area of the largest rectangle that can be formed within the histogram. Here\'s a brief explanation of what you need to do: 1. Create a stack to store the indices of the histogram bars. 2. Iterate through each bar in the `heights` array: * While the stack is not empty and the current bar is shorter than the bar at the index stored on top of the stack: - Pop the top index from the stack. - Calculate the area with the popped height as the smallest (or minimum height) bar. - Update the maximum area if needed. * Push the current index to the stack. 3. After the iteration, check the remaining indices in the stack and calculate the area for each popped height. 4. Return the maximum area found.","solution":"def largestRectangleArea(heights): Calculate the area of the largest rectangle in the histogram. :param heights: List[int], list of heights of the histogram bars. :return: int, area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given two arrays `original` and `target`, both containing integer values. You need to determine whether you can transform `original` into `target` by applying a series of operations. In one operation, you can remove two equal elements from `original` regardless of their positions. Implement the function `canTransform(original, target)` that returns `true` if it is possible to transform `original` into `target` through the described operations, or `false` otherwise. Note that you cannot add elements to `original` or modify `target`.","solution":"def canTransform(original, target): Determines if original can be transformed into target by removing pairs of equal elements. :param original: List[int] :param target: List[int] :return: bool from collections import Counter # Count the frequency of each element in original and target original_count = Counter(original) target_count = Counter(target) # For transformation to be possible, for each element in target, original must have at least that many for key, count in target_count.items(): if original_count[key] < count: return False return True"},{"question":"You are given a string `s` containing only the characters \'a\', \'b\', and \'c\'. Your task is to return the minimum number of deletions needed so that no two consecutive characters are the same.","solution":"def min_deletions(s: str) -> int: deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions"},{"question":"There are `n` distinct points on a 2D plane, each represented by an array `points` where `points[i] = [xi, yi]` indicates that there is a point at coordinates `(xi, yi)`. Your task is to determine the pair of points that are closest to each other, and return the **Manhattan distance** between these points. The **Manhattan distance** between two points `(x1, y1)` and `(x2, y2)` is defined as `|x1 - x2| + |y1 - y2|`.","solution":"def manhattan_distance(point1, point2): Returns the Manhattan distance between two points. return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1]) def closest_pair(points): Returns the Manhattan distance of the closest pair of points. min_distance = float(\'inf\') n = len(points) for i in range(n): for j in range(i + 1, n): distance = manhattan_distance(points[i], points[j]) if distance < min_distance: min_distance = distance return min_distance"},{"question":"You are given an integer array `nums` and an integer `k`. You need to determine if there exists a pair of distinct integers in the array whose sum is equal to `k`. Return _a boolean value_ indicating whether such a pair exists. The function should have a time complexity better than O(n^2).","solution":"def has_pair_with_sum(nums, k): Determines if there exists a pair of distinct integers in the array whose sum is equal to k. :param nums: List of integers :param k: The target sum :return: Boolean whether such a pair exists seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"You are given an integer array `a` and an integer `k`. Your task is to return the maximum possible sum of a subarray of length `k`. A subarray is a contiguous part of an array. If `k` is greater than the length of the array, return `0`. Here is an example: Example 1: - Input: `a = [2, 1, 5, 1, 3, 2]`, `k = 3` - Output: `9` Example 2: - Input: `a = [1, 2]`, `k = 3` - Output: `0`","solution":"def max_subarray_sum(a, k): Returns the maximum possible sum of a subarray of length \'k\'. If \'k\' is greater than the length of the array \'a\', return 0. n = len(a) if k > n: return 0 max_sum = curr_sum = sum(a[:k]) for i in range(k, n): curr_sum += a[i] - a[i - k] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"Given an m x n integer grid `heightMap` representing the height of each unit cell in a 2D elevation map, write a function to calculate the volume of water it is able to trap after raining. Each cell can either trap water or let it spill over its sides. Treat the borders of the grid as walls that do not let water escape from the edges. Return the total amount of trapped water.","solution":"import heapq def trap_rain_water(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] min_heap = [] # Push all the border cells into heap and mark them visited for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heapq.heappush(min_heap, (heightMap[i][j], i, j)) visited[i][j] = True # Directions for moving up, down, left, right directions = [(1,0), (-1,0), (0,1), (0,-1)] water_trapped = 0 while min_heap: height, x, y = heapq.heappop(min_heap) for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(min_heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"Given a non-negative integer `n`, your task is to generate a list of all possible **unique palindrome permutations** of the string representation of `n`. A palindrome is a string that reads the same backward as forward, and a permutation is a rearrangement of its characters. Return the list of palindrome permutations in any order. If no such permutations exist, return an empty list. You may assume that the given integer `n` does not contain leading zeros.","solution":"from collections import Counter from itertools import permutations def can_form_palindrome(s): Returns True if the string s can be rearranged into a palindrome, False otherwise. counts = Counter(s) odd_count = sum(1 for count in counts.values() if count % 2 == 1) return odd_count <= 1 def generate_palindrome_permutations(n): Given a non-negative integer n, returns a list of all unique palindrome permutations of its string representation. s = str(n) if not can_form_palindrome(s): return [] # Helper function to build palindromes from half permutations def build_palindromes(half_perms, odd_char): palindromes = set() for half in half_perms: half_str = \'\'.join(half) palindrome = half_str + (odd_char if odd_char else \'\') + half_str[::-1] palindromes.add(palindrome) return list(palindromes) # Count characters and find if there is any odd-count character counts = Counter(s) half_counts = {char: count // 2 for char, count in counts.items()} odd_char = [char for char, count in counts.items() if count % 2 == 1] odd_char = odd_char[0] if odd_char else \'\' # Create half-permutations half = \'\'.join(char * count for char, count in half_counts.items()) half_perms = set(permutations(half)) return build_palindromes(half_perms, odd_char)"},{"question":"Given an integer array `arr`, move all `0`s to the end of it while maintaining the relative order of the non-zero elements. Implement a function that modifies the array in-place with `O(1)` extra space.","solution":"def move_zeros_to_end(arr): Moves all zeros in the array to the end, maintaining the relative order of non-zero elements. Modifies the array in-place. non_zero_index = 0 # First pass: Move all non-zero elements to the front for i in range(len(arr)): if arr[i] != 0: arr[non_zero_index] = arr[i] non_zero_index += 1 # Second pass: Fill the rest with zeros for i in range(non_zero_index, len(arr)): arr[i] = 0"},{"question":"Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, return the `kth` smallest element in the matrix. Ensure that the solution has an average time complexity better than O(n).","solution":"import heapq def kth_smallest(matrix, k): Returns the kth smallest element in the given n x n sorted matrix. n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row. for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k times for _ in range(k): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c+1], r, c+1)) return element"},{"question":"You are given an array of strings `words` representing a list of words. Each word consists of lowercase English letters and can be of varying lengths. Write a function that groups the words that are anagrams of each other. For instance, two words are anagrams if they can be rearranged to form the same word. Return a list of lists, where each list contains the words that are anagrams of each other, sorted in lexicographical order within the list. The output lists themselves should also be sorted in lexicographical order based on the first word of each list.","solution":"def group_anagrams(words): Groups words that are anagrams of each other. Parameters: - words (list of str): List of words consisting of lowercase English letters. Returns: - list of list of str: Each list contains words that are anagrams, sorted lexicographically within the list. from collections import defaultdict anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) result = [sorted(group) for group in anagrams.values()] result.sort() return result"},{"question":"You are given a list of non-negative integers representing the heights of pillars in a histogram. Each pillar\'s width is 1. Determine the largest rectangular area that can be formed within the bounds of this histogram. Return _the maximum rectangular area possible_. For instance, given the list `[2, 1, 5, 6, 2, 3]`, the largest rectangular area is `10` which is formed by pillars with heights `[5, 6]`.","solution":"def largest_rectangle_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a list of n integers where each integer is in the range [1, n] inclusive. Some elements appear twice and others appear once. Find all the elements that appear twice in this list without using any extra space and in O(n) runtime complexity. Return a list of these elements.","solution":"def find_duplicates(nums): Find all the elements that appear twice in this list without using any extra space and in O(n) runtime complexity. Parameters: nums (list): List of integers. Returns: list: List of duplicated integers. # Result list to store duplicates duplicates = [] # Iterate over the nums list for i in range(len(nums)): # Index derived from the absolute value of the current element index = abs(nums[i]) - 1 # If the number at index is negative, it means the number at current index is a duplicate if nums[index] < 0: duplicates.append(index + 1) else: # Mark the number at the derived index as visited by making it negative nums[index] = -nums[index] return duplicates"},{"question":"Given a list of integers `nums` and an integer `k`, where `k` is guaranteed to be smaller than the length of the list, find the `k`-th largest element in the list. Note that it is the `k`-th largest element in the sorted order, not the `k`-th distinct element. You must solve it in `O(n)` average time complexity.","solution":"import random def partition(nums, left, right): pivot_index = random.randint(left, right) pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[i], nums[store_index] = nums[store_index], nums[i] store_index += 1 nums[store_index], nums[right] = nums[right], nums[store_index] return store_index def quick_select(nums, left, right, k): if left == right: return nums[left] pivot_index = partition(nums, left, right) if k == pivot_index: return nums[k] elif k < pivot_index: return quick_select(nums, left, pivot_index - 1, k) else: return quick_select(nums, pivot_index + 1, right, k) def find_kth_largest(nums, k): size = len(nums) target = size - k return quick_select(nums, 0, size - 1, target)"},{"question":"Given a binary search tree (BST), write a function that inserts a new value into the BST. You cannot modify the structure of the BST and must ensure the tree remains a valid BST after the insertion. The function should return the root of the BST after inserting the new value. The function signature should be: ```python def insert_into_bst(root: Optional[TreeNode], val: int) -> Optional[TreeNode]: # Your code here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root: TreeNode, val: int) -> TreeNode: Inserts a new value into the BST and returns the root of the BST. if root is None: return TreeNode(val) if val < root.val: if root.left is None: root.left = TreeNode(val) else: insert_into_bst(root.left, val) else: if root.right is None: root.right = TreeNode(val) else: insert_into_bst(root.right, val) return root"},{"question":"You are given two arrays `arr1` and `arr2`, each of length `n`. An element from either `arr1` or `arr2` can be selected and added to an initially empty array `result`, such that the `result` array contains exactly `n` elements. The `result` array should maintain the non-decreasing order. The goal is to minimize the largest difference between consecutive elements in `result`. Return _the minimum possible largest difference_ between consecutive elements of `result`.","solution":"def min_max_difference(arr1, arr2): Returns the minimum possible largest difference between consecutive elements in result array formed from elements of arr1 and arr2. n = len(arr1) combined = sorted(arr1 + arr2) min_largest_diff = float(\'inf\') for i in range(n - 1): current_diff = combined[i + 1] - combined[i] if current_diff < min_largest_diff: min_largest_diff = current_diff return min_largest_diff"},{"question":"You are given a list of `n` integers called `target` and a starting integer called `start`. You can perform the following operation any number of times: - Increment or decrement the integer value of `start` by 1. Your goal is to make `start` equal to one of the integers in the `target` list. Return the minimum number of operations required to accomplish this. If it is not possible to achieve the goal, return -1. Note: You may assume that the `target` array is non-empty and contains distinct integers.","solution":"def min_operations_to_target(start, target): Returns the minimum number of operations required to make `start` equal to any integer in `target`. If it is not possible, returns -1. :param start: The starting integer :param target: A list of integers :return: Minimum number of operations or -1 if not possible if not target: return -1 min_operations = float(\'inf\') for t in target: min_operations = min(min_operations, abs(start - t)) return min_operations if min_operations != float(\'inf\') else -1"},{"question":"Given a 2D grid `grid` of size `m x n` consisting of `\'L\'` (land) and `\'W\'` (water) tiles, group all land tiles connected 4-directionally (horizontal or vertical) into islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Return the number of islands.","solution":"def numIslands(grid): Given a 2D grid of \'L\' (land) and \'W\' (water), this function returns the number of islands. An island is surrounded by water and is formed by connecting adjacent land horizontally or vertically. if not grid: return 0 # Dimensions of the grid rows, cols = len(grid), len(grid[0]) visited = set() # To keep track of visited land tiles def dfs(r, c): Depth First Search to mark all connected lands as visited. if r < 0 or r >= rows or c < 0 or c >= cols or (r, c) in visited or grid[r][c] == \'W\': return # Mark the current tile as visited visited.add((r, c)) # Explore all 4-directional neighbors dfs(r + 1, c) # Down dfs(r - 1, c) # Up dfs(r, c + 1) # Right dfs(r, c - 1) # Left island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'L\' and (r, c) not in visited: # If we find an unvisited land, we found a new island island_count += 1 # Perform DFS to mark all the land tiles in this island as visited dfs(r, c) return island_count"},{"question":"You are given an array of integers `heights` representing the heights of students standing in a line. A student `i` can see another student `j` standing in front of them if and only if `heights[j]` is greater than or equal to `heights[i]` for all the students standing in between `i` and `j`. Return _an array of integers where the value at each index `i` is the number of students `i` can see in front of them_. Iterate over each student and calculate how many students the current student can see.","solution":"def can_see_count(heights): Returns an array of integers where the value at each index i is the number of students i can see in front of them. n = len(heights) result = [0] * n # Initialize result with 0\'s for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] >= heights[i]: count += 1 result[i] = count return result"},{"question":"You are given a string containing only digits. Your task is to return the sum of all possible substrings of the given string as integers. For example, given the string \\"123\\", the substrings are \\"1\\", \\"2\\", \\"3\\", \\"12\\", \\"23\\", and \\"123\\". The sum of these substrings as integers is 164 (1 + 2 + 3 + 12 + 23 + 123).","solution":"def sum_of_substrings(s): Returns the sum of all possible substrings of the given string as integers. Parameters: s (str): A string containing only digits. Returns: int: The sum of all possible substrings converted to integers. total_sum = 0 n = len(s) for i in range(n): for j in range(i + 1, n + 1): total_sum += int(s[i:j]) return total_sum"},{"question":"You are given a string `s` representing a sentence with words separated by spaces. Reorder the words in the sentence such that each word is capitalized (the first letter is uppercase and the remaining letters are lowercase). The sentence should be returned as a single string where the words are separated by a single space and no leading or trailing spaces. If `s` is an empty string or contains only spaces, return the empty string `\\" \\"`.","solution":"def capitalize_sentence(s): Reorders the words in the sentence such that each word is capitalized. The sentence should be returned as a single string with words separated by a single space and no leading or trailing spaces. If `s` is empty or contains only spaces, return the empty string \\"\\". if not s.strip(): return \\"\\" words = s.split() capitalized_words = [word.capitalize() for word in words] return \\" \\".join(capitalized_words)"},{"question":"You are given a list of `n` integers `arr` and an integer `targetSum`. Your task is to determine whether there are three distinct integers in the list that add up to `targetSum`. If such a triplet exists, return `true`, otherwise, return `false`. The function should have a time complexity better than O(n^3).","solution":"def three_sum(arr, targetSum): Determines if there are three distinct integers in the list that add up to the targetSum. Parameters: arr (list): A list of integers. targetSum (int): The target sum. Returns: bool: True if such a triplet exists, otherwise False. arr.sort() # Sort the array to use two-pointer technique n = len(arr) for i in range(n - 2): # Fix one element and use two pointers for the other two left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == targetSum: return True elif current_sum < targetSum: left += 1 else: right -= 1 return False"},{"question":"Given the head of a singly linked list, reverse the list, and return the reversed list. The list is represented by a pointer to the head node. Write a function that takes a reference to the head of a list and returns a reference to the head of the reversed list. Implement the function iteratively.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list iteratively. :param head: ListNode, the head of the singly linked list :return: ListNode, the head of the reversed singly linked list prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"Given a positive integer `n`, return _the number of unique ways to climb to the top of a staircase with_ `n` _steps if you can either take 1 or 2 steps at a time._ Each step combination is counted as different if a different sequence of steps is taken. For example, if `n = 3`, there are 3 combinations: (1,1,1), (1,2), and (2,1).","solution":"def climb_stairs(n): Returns the number of unique ways to climb to the top of a staircase with n steps where you can either take 1 or 2 steps at a time. if n <= 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"You have a string `s` that consists of lower case English letters and a pattern `p` which also consists of lower case English letters. Determine if the pattern `p` is a subsequence of the string `s`. Return `true` if `p` is a subsequence of `s`, and `false` otherwise.","solution":"def is_subsequence(s, p): Determines if pattern p is a subsequence of string s. Parameters: s (str): The string to be checked. p (str): The pattern to find as a subsequence in s. Returns: bool: True if p is a subsequence of s, False otherwise. iter_s = iter(s) return all(char in iter_s for char in p)"},{"question":"Given a string `s` that consists of both uppercase and lowercase letters, check whether the string is a **Palindrome** after converting all the uppercase letters into their corresponding lowercase letters and removing all non-alphanumeric characters. Return `true` _if_ `s` _is a valid palindrome after the mentioned transformations, and_ `false` _otherwise_.","solution":"import re def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome after converting all uppercase letters into their corresponding lowercase letters and removing all non-alphanumeric characters. # Convert to lowercase and remove non-alphanumeric characters cleaned_s = re.sub(r\'[^a-z0-9]\', \'\', s.lower()) # Check if cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"Given a `MxN` 2D grid initialized with zeros and a list of `mines` where mines[i] = [xi, yi] represents the position of a mine, return an `M x N` grid where each cell represents the number of adjacent mines for that cell. Cells with mines should have a value of -1. The adjacent cells include the eight possible directions: up, down, left, right, and the four diagonal directions.","solution":"def update_minefield(grid, mines): Returns the MxN grid with the number of adjacent mines in each cell. Cells with mines have a value of -1. :param grid: 2D list of integers representing the MxN grid initialized with zeros. :param mines: List of lists representing the positions of the mines. def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) for mine in mines: x, y = mine grid[x][y] = -1 for dx in [-1, 0, 1]: for dy in [-1, 0, 1]: if dx == 0 and dy == 0: continue nx, ny = x + dx, y + dy if is_valid(nx, ny) and grid[nx][ny] != -1: grid[nx][ny] += 1 return grid"},{"question":"You are given a set of tasks with their corresponding durations, represented as an array of integers `tasks`, and a positive integer `n` representing the number of available workers. Each worker can work on any task, and each worker can only work on one task at a time. Write a function to find the minimum time required to complete all the tasks using the given workers. Implement the `minTime` function: * `minTime(tasks, n)` This function will take an integer array `tasks` and an integer `n` as input and return the minimum amount of time required to complete all tasks. Consider the following points: - All the tasks can start at the same time, but the available workers are limited to `n`. - Tasks must be distributed as evenly as possible among the workers to minimize the total time. Your implementation should efficiently distribute the tasks among the available workers to minimize the overall completion time.","solution":"import heapq def minTime(tasks, n): Returns the minimum time required to complete all tasks with n workers. Parameters: tasks (List[int]): List of task durations. n (int): Number of available workers. Returns: int: Minimum time to complete all tasks. if not tasks: return 0 # Create a min-heap to keep track of the current end times for each worker worker_times = [0] * n # Sort the tasks in descending order to assign the longest task first tasks.sort(reverse=True) for task in tasks: # Assign the task to the worker who will finish the earliest heapq.heapreplace(worker_times, worker_times[0] + task) # The time it will take to complete all tasks is the maximum worker time return max(worker_times)"},{"question":"You are given a matrix of integers `mat` where each row is 0-indexed. The entire matrix is rotated to the right, one element at a time, such that the last element of each row becomes the first element of that row. This rotation is carried out `k` times. Write a function to compute the resulting matrix after `k` rotations. For instance, given the matrix `mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]` and `k = 1`, the output should be `[[3, 1, 2], [6, 4, 5], [9, 7, 8]]`. Return _the rotated matrix after_ `k` _rotations_.","solution":"def rotate_matrix(mat, k): Rotate the rows of the matrix `k` times to the right. Parameters: mat (list of list of int): The matrix to rotate. k (int): The number of times to rotate each row. Returns: list of list of int: The rotated matrix. num_rows = len(mat) if num_rows == 0: return mat num_cols = len(mat[0]) rotated_matrix = [] for row in mat: k_mod = k % num_cols # to handle cases where k > num_cols rotated_row = row[-k_mod:] + row[:-k_mod] rotated_matrix.append(rotated_row) return rotated_matrix"},{"question":"Given an array of integers `nums` and an integer `threshold`, return _the smallest integer `k` such that it is possible to divide the array into `k` or fewer non-empty subarrays, where the sum of the largest element in each subarray is less than or equal to_ `threshold`. Each subarray contains at least one integer from `nums`, and you must use all integers in `nums`. The answer should be the smallest possible integer meeting these conditions.","solution":"def splitArray(nums, threshold): Returns the smallest integer k such that it is possible to divide the array nums into k or fewer non-empty subarrays, where the sum of the largest element in each subarray is less than or equal to threshold. def can_split(nums, max_sum, k): current_sum = 0 subarrays = 0 for num in nums: if num > max_sum: return False if current_sum + num > max_sum: subarrays += 1 current_sum = num if subarrays >= k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, mid, threshold): right = mid else: left = mid + 1 return left"},{"question":"You are given two arrays `ar1` and `ar2` of lengths `n` and `m` respectively. Write a function to remove any element from `ar1` and insert it into `ar2` such that the median of the modified array `ar2` is maximized. Return the modified array `ar2`. If there are multiple valid results, return any. A **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.","solution":"def maximize_median(ar1, ar2): Remove any element from ar1 and insert it into ar2 such that the median of the modified ar2 is maximized. Return the modified array ar2. ar2_sorted = sorted(ar2) max_median = -float(\'inf\') resulting_ar2 = [] for elem in ar1: temp_ar2 = ar2 + [elem] temp_ar2.sort() n = len(temp_ar2) if n % 2 == 1: median = temp_ar2[n//2] else: median = (temp_ar2[n//2 - 1] + temp_ar2[n//2]) / 2.0 if median > max_median: max_median = median resulting_ar2 = temp_ar2 return resulting_ar2"},{"question":"You are given an array `arr` of integers. An element `x` in `arr` is called a _peak_ if it is greater than its neighbors. For the first and last elements, consider only one neighbor. Write a function that finds all the peak elements in `arr` and returns their indices in any order. If there are no peak elements, return an empty list. For example, given the array `[1, 3, 2, 4, 1, 5]`, the peaks are `3`, `4`, and `5`, and the function should return the indices `[1, 3, 5]`.","solution":"def find_peak_indices(arr): Finds all the peak elements in `arr` and returns their indices. if not arr: return [] peaks = [] for i in range(len(arr)): if i == 0: if len(arr) > 1 and arr[i] > arr[i+1]: peaks.append(i) elif len(arr) == 1: peaks.append(i) elif i == len(arr) - 1: if arr[i] > arr[i-1]: peaks.append(i) else: if arr[i] > arr[i-1] and arr[i] > arr[i+1]: peaks.append(i) return peaks"},{"question":"You are given a string `str` representing an encoded message. Write a function that decodes the message by shifting each letter a specific number of places down the alphabet defined by a given integer `shift`. Non-alphabet characters should remain the same. The shift should wrap around the alphabet (e.g., shifting \'z\' by 1 results in \'a\'). The function should return the decoded message string.","solution":"def decode_message(encoded_message, shift): Decodes the encoded message by shifting each letter by the specified number of places down the alphabet. Non-alphabet characters remain the same. Parameters: encoded_message (str): The string to decode. shift (int): The number of places to shift each alphabet letter. Returns: str: The decoded message. decoded_chars = [] for char in encoded_message: if char.isalpha(): if char.islower(): decoded_chars.append(chr((ord(char) - ord(\'a\') - shift) % 26 + ord(\'a\'))) elif char.isupper(): decoded_chars.append(chr((ord(char) - ord(\'A\') - shift) % 26 + ord(\'A\'))) else: decoded_chars.append(char) return \'\'.join(decoded_chars)"},{"question":"Given a `2D grid` of size `m x n` where each cell represents a `gate`, `wall`, or an `empty` room. The cells are represented by three possible values: - `-1` for a `wall`; - `0` for a `gate`; - `2147483647` (which represents INF) for an `empty room`. You need to fill each `empty room` with the distance to its nearest `gate`. If it\'s impossible to reach a gate, it should remain `INF`. Return _the modified grid with distances filled in for each empty room_.","solution":"from collections import deque def walls_and_gates(rooms): Fills each empty room in the grid with the distance to its nearest gate. If it\'s impossible to reach a gate, it should remain 2147483647. Parameters: rooms (List[List[int]]): 2D grid representing rooms, gates, and walls. Returns: None: Modifies input grid in-place. if not rooms: return m, n = len(rooms), len(rooms[0]) queue = deque() # Enqueue all gates for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Directions for top, bottom, left, right directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # BFS from all gates while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"Given an array of integers `arr`, return the sum of the largest sum subarray, where the subarray is at most length `m`. A subarray is a contiguous part of an array. You need to find the subarray that provides the highest sum while ensuring the length of the subarray does not exceed `m`. If the array contains only negative numbers, return the largest negative number.","solution":"def max_sum_subarray(arr, m): Returns the sum of the largest sum subarray of length at most m. If the array contains only negative numbers, returns the largest negative number. if not arr: return 0 max_so_far = float(\'-inf\') max_current = 0 for i in range(len(arr)): current_sum = 0 for j in range(i, min(i + m, len(arr))): current_sum += arr[j] max_so_far = max(max_so_far, current_sum) return max_so_far"},{"question":"A company has a list of `n` tasks each assigned with a unique integer ID from `1` to `n`. The tasks have dependencies such that certain tasks must be completed before others. You are given a list `dependencies` where each element is a pair `[a, b]` indicating that task `a` must be completed before task `b`. You need to determine if it\'s possible to finish all tasks. If it is possible, return the order in which the tasks should be completed. If it is not possible, return an empty list. Write a function that takes `n` and `dependencies` as input and returns a list representing a possible order of task completion or an empty list if all tasks cannot be completed.","solution":"from collections import defaultdict, deque def find_task_order(n, dependencies): Given the number of tasks `n` and a list of dependencies `dependencies`, returns a list representing a possible order of task completion or an empty list if all tasks cannot be completed. # Create an adjacency list for the graph adj_list = defaultdict(list) in_degree = {i: 0 for i in range(1, n + 1)} # Build the graph and in-degree count for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Initialize the queue with tasks that have no dependencies (in-degree 0) zero_in_degree_queue = deque([k for k in in_degree if in_degree[k] == 0]) order = [] while zero_in_degree_queue: task = zero_in_degree_queue.popleft() order.append(task) # Decrease the in-degree of neighboring tasks for neighbor in adj_list[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the resulting order contains all tasks, return the order if len(order) == n: return order else: return []"},{"question":"Given two arrays of integers `arr1` and `arr2`, return the **smallest absolute difference** between any element of `arr1` and any element of `arr2`.","solution":"def smallest_abs_difference(arr1, arr2): Returns the smallest absolute difference between any element of arr1 and any element of arr2. arr1.sort() arr2.sort() i = 0 j = 0 min_diff = float(\'inf\') while i < len(arr1) and j < len(arr2): min_diff = min(min_diff, abs(arr1[i] - arr2[j])) if arr1[i] < arr2[j]: i += 1 else: j += 1 return min_diff"},{"question":"You are given two arrays of integers `arr1` and `arr2` of the same length. You need to generate a new array where each element is the **minimum value** from either `arr1` or `arr2` at each corresponding index. Return the resulting array. Note that the arrays may contain both positive and negative numbers.","solution":"def min_values_from_arrays(arr1, arr2): Returns a new array where each element is the minimum value from either arr1 or arr2 at each corresponding index. Parameters: arr1 (list of int): The first input array. arr2 (list of int): The second input array. Returns: list of int: The array containing minimum values at each index. return [min(a, b) for a, b in zip(arr1, arr2)]"},{"question":"You are given an array `nums` consisting of positive integers. You are allowed to perform the following operation as many times as you want: pick any two elements of the array and replace both elements with their greatest common divisor (GCD). Your task is to determine whether it\'s possible to make all the elements in the array equal using the described operation. If it is possible, return `true`, otherwise return `false`.","solution":"from math import gcd from functools import reduce def can_make_elements_equal(nums): Determine if it\'s possible to make all elements in the array equal using the described operation. total_gcd = reduce(gcd, nums) return all(x == total_gcd for x in nums)"},{"question":"You are given an integer array `nums` sorted in **non-decreasing** order, and an integer `target`. Your goal is to determine if `target` is a **mountain element** in `nums`. An element `nums[i]` is considered a **mountain element** if it is larger than its immediate neighbors, i.e., `nums[i-1] < nums[i] > nums[i+1]`. Return `true` if `target` is a mountain element in `nums`, otherwise return `false`. If `target` does not exist in `nums`, also return `false`. Assume that the array has at least three elements.","solution":"def is_mountain_element(nums, target): Determine if the target is a mountain element in the nums array. Arguments: nums : List[int] -- sorted array of integers in non-decreasing order target : int -- target integer to check Returns: bool -- True if target is a mountain element, False otherwise for i in range(1, len(nums)-1): if nums[i] == target and nums[i-1] < nums[i] > nums[i+1]: return True return False"},{"question":"You are given a 2D grid of size `m x n` representing an island map where each cell is either water (\'0\') or land (\'1\'). A set of operations needs to be performed on this grid: 1. **AddLand**: Set the value of a cell in the grid to \'1\' to mark it as land. 2. **CountIslands**: Determine the number of distinct islands in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You can assume that all four edges of the grid are surrounded by water. Implement the `IslandCounter` class: * `IslandCounter(char[][] grid)` Initializes the `IslandCounter` object with a `m x n` grid of water and land. * `void addLand(int row, int col)` Sets the value at `grid[row][col]` to \'1\', marking it as land. * `int countIslands()` Returns the number of distinct islands present in the grid after all operations have been performed. Note: You are required to ensure that your data structure handles the addition of new land and counting of islands efficiently.","solution":"class IslandCounter: def __init__(self, grid): self.grid = grid self.m = len(grid) self.n = len(grid[0]) self.visited = [[False] * self.n for _ in range(self.m)] def addLand(self, row, col): self.grid[row][col] = \'1\' def countIslands(self): def dfs(r, c): if r < 0 or c < 0 or r >= self.m or c >= self.n or self.grid[r][c] == \'0\' or self.visited[r][c]: return self.visited[r][c] = True dfs(r+1, c) dfs(r-1, c) dfs(r, c+1) dfs(r, c-1) self.visited = [[False] * self.n for _ in range(self.m)] island_count = 0 for i in range(self.m): for j in range(self.n): if self.grid[i][j] == \'1\' and not self.visited[i][j]: island_count += 1 dfs(i, j) return island_count"},{"question":"You have a **0-indexed** integer array `arr` of length `n` where the elements represent the heights of pillars. Every time you jump from one pillar to another, the jump length is the absolute difference between the heights of the pillars. You need to start at pillar `0` and reach pillar `n-1`. However, you can only jump to a pillar `i` if `i` is greater than the current pillar\'s index and is within a given maximum distance `d`. Return _the **minimum** number of jumps needed to reach the last pillar or `-1` if it is not possible_.","solution":"from collections import deque def min_jumps_to_last_pillar(arr, d): Return the minimum number of jumps needed to reach the last pillar or -1 if it is not possible. Parameters: arr (list of int): heights of the pillars. d (int): maximum distance between pillars that can be jumped. Returns: int: minimum number of jumps needed to reach the last pillar, or -1 if not possible. n = len(arr) if n == 1: return 0 # BFS initialization queue = deque([(0, 0)]) # (current index, current jump count) visited = [False] * n visited[0] = True while queue: index, jumps = queue.popleft() # Check if we have reached the last pillar if index == n - 1: return jumps # Check each possible jump from the current index for i in range(index - d, index + d + 1): if 0 <= i < n and not visited[i]: if abs(arr[index] - arr[i]) <= d: queue.append((i, jumps + 1)) visited[i] = True return -1"},{"question":"You are given a list of `words` and a list of `queries`. Each query consists of two strings, `query_word` and `pattern`. A word matches the pattern if there exists a permutation of `pattern` such that it is a substring of `query_word`. Return a list of booleans where each element indicates whether the corresponding query can be matched to the given pattern. For example, if the `words` list is `[\\"apple\\", \\"banana\\", \\"caramel\\"]` and the queries list is `[(\\"appetizing\\", \\"eat\\"), (\\"carnival\\", \\"arc\\"), (\\"chocolate\\", \\"late\\")]`, the function should return `[False, True, True]`.","solution":"def query_match(words, queries): Returns a list of booleans where each element indicates whether the corresponding query can be matched to the given pattern. :param words: List of words :param queries: List of tuples (query_word, pattern) :return: List of booleans def can_match(query_word, pattern): from collections import Counter pattern_count = Counter(pattern) query_length = len(pattern) for i in range(len(query_word) - query_length + 1): substring = query_word[i:i+query_length] if Counter(substring) == pattern_count: return True return False results = [] for query_word, pattern in queries: results.append(can_match(query_word, pattern)) return results"},{"question":"Given a 2D integer matrix `matrix` containing `0`s and `1`s, write a function that returns the size of the largest square containing only `1`s. The size of a square is determined by the length of its side. The input matrix will be at least 1x1 in size.","solution":"def largest_square(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"Given an integer array `nums`, return _the **maximum difference** between the increasing adjacent elements in a subarray where the elements are in strictly increasing order._ If the array is already in strictly increasing order, return the maximum difference between its adjacent elements. If no such subarray exists, return `0`.","solution":"def max_diff_increasing_subarray(nums): Returns the maximum difference between increasing adjacent elements in a subarray. If no such subarray exists or array is too short, return 0. if len(nums) < 2: return 0 max_diff = 0 current_diff = 0 for i in range(1, len(nums)): if nums[i] > nums[i-1]: diff = nums[i] - nums[i-1] current_diff = max(current_diff, diff) max_diff = max(max_diff, current_diff) else: current_diff = 0 return max_diff"},{"question":"You are given a string `s` representing the pressed keys of a phone keypad where each keypress corresponds to a digit. Each possible key on the keypad has a few corresponding letters as follows: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" Find all possible letter combinations that the number `s` could represent. Return the answer _as a list of strings in **lexicographical order**_, each string being a valid combination of the letters corresponding to the digits in `s`. If `s` contains no digits, return an empty list.","solution":"def letter_combinations(s): Returns all possible letter combinations that the digits in s could represent on a phone keypad. if not s: return [] digit_to_chars = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(s): combinations.append(\\"\\".join(path)) return possible_chars = digit_to_chars[s[index]] for char in possible_chars: path.append(char) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return sorted(combinations)"},{"question":"You are given two binary strings `a` and `b`, both of which have the same length. Your task is to simultaneously convert both strings into another binary string `c` such that `c[i]` (the i-th bit of `c`) is `1` if bits `a[i]` and `b[i]` are different, and `0` if they are the same. Return the resulting binary string `c`. For example, given `a = \\"1101\\"` and `b = \\"1011\\"`, the result would be `\\"0110\\"` because at the first and fourth positions `a` and `b` differ, while at the second and third positions they are the same.","solution":"def bitwise_xor_bin_str(a, b): Takes two binary strings `a` and `b` of the same length and returns a binary string `c` where each bit `c[i]` is \'1\' if `a[i]` and `b[i]` are different, and \'0\' if they are the same. # Lengths of both strings should be the same assert len(a) == len(b) # Using list comprehension to generate the result c = \'\'.join(\'1\' if a[i] != b[i] else \'0\' for i in range(len(a))) return c"},{"question":"Given an array of integers `nums` and an integer `threshold`, you need to split the array into some number of non-empty continuous subarrays such that the sum of the maximum value in each subarray is less than or equal to `threshold`. Return _the minimum number of subarrays_ you need to achieve this. Each subarray must have at least one element.","solution":"def min_number_of_subarrays(nums, threshold): Finds the minimum number of subarrays such that the sum of the maximum value in each subarray is less than or equal to the threshold. :param nums: List[int] - The input array of integers. :param threshold: int - The threshold value. :return: int - The minimum number of subarrays required. current_sum = 0 subarray_count = 1 for num in nums: if current_sum + num > threshold: subarray_count += 1 current_sum = num else: current_sum += num return subarray_count"},{"question":"You are provided a `matrix` of size `n x m` filled with integer values representing a grid. Each cell in the grid can have a value of 0 or 1. Your task is to count the number of unique islands in the grid. An island is defined as a group of \\"1\\"s connected vertically or horizontally (not diagonally) and surrounded by \\"0\\"s or the boundaries of the grid. Two islands are considered to be different if and only if one island is not the exact translation (not rotation or reflection) of the other. You need to write a function that returns the total number of unique islands in the grid. ```python def numDistinctIslands(grid: List[List[int]]) -> int: # Implement your solution here ```","solution":"def numDistinctIslands(grid): def dfs(row, col, direction): if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] == 1: grid[row][col] = 0 path_signature.append(direction) dfs(row + 1, col, \\"D\\") # Down dfs(row - 1, col, \\"U\\") # Up dfs(row, col + 1, \\"R\\") # Right dfs(row, col - 1, \\"L\\") # Left path_signature.append(\\"B\\") # Backtrack unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path_signature = [] dfs(i, j, \\"O\\") # Origin unique_islands.add(tuple(path_signature)) return len(unique_islands)"},{"question":"A company distributes payslips to its employees by email. You are given a list of employee email addresses represented as strings. Each email address contains the following components in order: `<local-part>@<domain-part>`. The local-part of an email may contain alphabets, digits, and special characters like periods (`\'.\'`) and plus signs (`\'+\'`). However, a plus sign indicates that any characters after it and before the at sign (`\'@\'`) should be ignored, and periods in the local-part can be ignored as well. For instance, `\\"test.email+alex@domain.com\\"` and `\\"test.email@domain.com\\"` should be treated as the same email address, and only one payslip should be sent. Given an array of email addresses, write a function to return the number of unique email addresses.","solution":"def num_unique_emails(emails): Returns the number of unique email addresses. :param emails: List[str], list of email addresses :return: int, number of unique email addresses unique_emails = set() for email in emails: local_part, domain_part = email.split(\'@\') # Ignore characters after \'+\' in local-part local_part = local_part.split(\'+\')[0] # Remove periods from local-part local_part = local_part.replace(\'.\', \'\') unique_email = local_part + \'@\' + domain_part unique_emails.add(unique_email) return len(unique_emails)"},{"question":"You are given a list of `n` integers, `nums`, where each integer represents a point. You need to find the length of the longest subsequence such that the difference between every consecutive pair of elements is either `0` or `1`. Return _the length of the longest such subsequence._","solution":"def longest_subsequence(nums): if not nums: return 0 subseq_map = {} longest_length = 0 for num in nums: if num in subseq_map: continue length_with_num = nums.count(num) length_with_num_and_next = nums.count(num + 1) current_length = length_with_num + length_with_num_and_next longest_length = max(longest_length, current_length) subseq_map[num] = current_length subseq_map[num + 1] = current_length return longest_length"},{"question":"You are given a binary tree with `n` nodes where each node has a unique value ranging from `1` to `n`. Each node in the tree has a pointer `random` which can point to any node in the tree or be `null`. The task is to serialize and deserialize the binary tree. Serialization is the process of converting the tree into a string representation that can be easily stored or transmitted. Deserialization is the process of converting the string representation back into the original binary tree structure. Implement the `serialize` and `deserialize` functions. The `serialize` function should take the root of the binary tree and return the string representation, and the `deserialize` function should take the string representation and return the root of the binary tree. Note that the tree might be very large, so efficiency is important.","solution":"import json class TreeNode: def __init__(self, val=0, left=None, right=None, random=None): self.val = val self.left = left self.right = right self.random = random def serialize(root): Encodes a binary tree to a single string. if not root: return \\"null\\" def build_dict(node): if not node: return None node_dict = { \\"val\\": node.val, \\"left\\": build_dict(node.left), \\"right\\": build_dict(node.right), \\"random\\": node.random.val if node.random else None } return node_dict result = json.dumps(build_dict(root)) return result def deserialize(data): Decodes your encoded data to tree. if data == \\"null\\": return None node_dict = json.loads(data) def build_tree(node_dict): if not node_dict: return None node = TreeNode(node_dict[\\"val\\"]) node.left = build_tree(node_dict[\\"left\\"]) node.right = build_tree(node_dict[\\"right\\"]) return node root = build_tree(node_dict) def assign_random(node, node_dict): if not node or not node_dict: return if node_dict[\\"random\\"] is not None: node.random = get_node_by_val(root, node_dict[\\"random\\"]) assign_random(node.left, node_dict[\\"left\\"]) assign_random(node.right, node_dict[\\"right\\"]) def get_node_by_val(node, val): if not node: return None if node.val == val: return node left_result = get_node_by_val(node.left, val) return left_result if left_result else get_node_by_val(node.right, val) assign_random(root, node_dict) return root"},{"question":"Given a list of strings `words`, you are to create a data structure that supports the following operations: * `WordDictionary()` Initializes the object. * `void addWord(String word)` Adds a word into the data structure. * `boolean search(String word)` Returns `true` if the `word` is in the data structure, otherwise `false`. A `word` containing the dot character `\'.\'` can represent any one letter. Implement the `WordDictionary` class as follows: * The `addWord` method adds the word to the data structure. * The `search` method can search for a specific word or a regular expression string containing dots, where a dot can represent any letter. For example: * Input: `WordDictionary dictionary = new WordDictionary();` * Input: `dictionary.addWord(\\"bat\\");` * Input: `dictionary.addWord(\\"ball\\");` * Input: `dictionary.search(\\"bat\\")` -> Output: `true` * Input: `dictionary.search(\\".at\\")` -> Output: `true` * Input: `dictionary.search(\\"b.ll\\")` -> Output: `true` * Input: `dictionary.search(\\"ba.\\")` -> Output: `true` * Input: `dictionary.search(\\"b..\\")` -> Output: `true` * Input: `dictionary.search(\\"batman\\")` -> Output: `false`","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: import re for w in self.words: if re.fullmatch(word, w): return True return False"},{"question":"Write a function that, given a list of strings `words` and a string `chars`, returns the sum of the lengths of all good strings in `words`. A string is considered good if it can be formed by characters from `chars` (each character can be used only once). **Example:** ``` Input: words = [\\"cat\\",\\"bt\\",\\"hat\\",\\"tree\\"], chars = \\"atach\\" Output: 6 Explanation: The strings that can be formed are \\"cat\\" and \\"hat\\" so the answer is 6. ```","solution":"def count_good_strings(words, chars): Return the sum of the lengths of all good strings in words that can be formed by characters in chars. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) for char, count in word_count.items(): if chars_count[char] < count: break else: total_length += len(word) return total_length"},{"question":"You are given a list of marks (`marksList`) obtained by students in an exam. Each element in the list represents the marks obtained by one student. Your task is to calculate the mode of the marks  the mark that appears most frequently in the list. If there are multiple marks with the same highest frequency, return the smallest mark among them. Implement the class `MarksAnalyzer`: * `MarksAnalyzer(List<Integer> marksList)` Initializes your object with the list of marks. * `int findMode()` Returns the mode of the `marksList`. If multiple modes exist, return the smallest one. You can assume that the list is not empty and contains at least one element.","solution":"from collections import Counter from typing import List class MarksAnalyzer: def __init__(self, marksList: List[int]): Initializes the object with the list of marks. self.marksList = marksList def findMode(self) -> int: Returns the mode of the marksList. If multiple modes exist, return the smallest one. count = Counter(self.marksList) max_frequency = max(count.values()) modes = [mark for mark, freq in count.items() if freq == max_frequency] return min(modes)"},{"question":"Given an array of strings `bits` consisting of \\"0\\" and \\"1\\" characters, return the minimum number of swaps needed to group all \\"1\\"s together in a contiguous block. If it is not possible to form such a block, return `-1`.","solution":"def min_swaps_to_group_ones(bits): Returns the minimum number of swaps needed to group all \\"1\\"s together in a contiguous block. num_ones = bits.count(\\"1\\") if num_ones == 0: return -1 num_bits = len(bits) min_swaps = float(\'inf\') ones_count_in_window = 0 left = 0 for right in range(num_bits): if bits[right] == \\"1\\": ones_count_in_window += 1 if right - left + 1 == num_ones: min_swaps = min(min_swaps, num_ones - ones_count_in_window) if bits[left] == \\"1\\": ones_count_in_window -= 1 left += 1 return min_swaps"},{"question":"You are given a list of non-negative integers `nums` which represents the number of points in a game for each round. Your task is to determine the maximum points you can achieve with the constraint that once you score points from a particular round, you cannot score points from the previous or the following round. For example, if you have scored points from the `i-th` round, you cannot score points from `(i-1)-th` and `(i+1)-th` rounds. Implement a function that returns the maximum points you can achieve given these constraints.","solution":"def max_points(nums): Returns the maximum points achievable with the given constraints. :param nums: List of non-negative integers representing points in each round. :return: Maximum points achievable. if not nums: return 0 if len(nums) == 1: return nums[0] n = len(nums) # dp[i] will store the maximum points we can achieve considering up to round i dp = [0] * n # Base cases dp[0] = nums[0] if n > 1: dp[1] = max(nums[0], nums[1]) # Fill dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given a **0-indexed** integer array `numList` where each element is a positive integer. You can perform the following operation any number of times: choose an element of the array and divide it by 2, rounding down. Return _the **minimum** number of operations required to make all elements of the array equal, or_ `-1` _if it is not possible._","solution":"def min_operations_to_equal_elements(numList): from collections import Counter def get_div_2_count(x): count = 0 while x % 2 == 0: x //= 2 count += 1 return count def get_odd_part(x): while x % 2 == 0: x //= 2 return x odd_parts = [get_odd_part(x) for x in numList] if len(set(odd_parts)) != 1: return -1 div_counts = [get_div_2_count(x) for x in numList] min_operations = sum(div_counts) - len(div_counts) * min(div_counts) return min_operations"},{"question":"You are given a binary tree represented by its root node `root`. Write an algorithm to check whether it is a complete binary tree. In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Return _`true` if the tree is complete and `false` otherwise_. (Note: You should define the `TreeNode` class to represent the nodes of the binary tree, where each node contains an integer value and two children pointers left and right to the respective subtrees.)","solution":"from collections import deque class TreeNode: Represents a node in a binary tree. def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_complete_binary_tree(root): Check if a binary tree is a complete binary tree. :param root: TreeNode representing the root of the binary tree :return: bool indicating whether the tree is complete if not root: return True queue = deque([root]) end = False while queue: node = queue.popleft() if node: if end: return False queue.append(node.left) queue.append(node.right) else: end = True return True"},{"question":"You are given an **m x n** grid where each cell can either be: - `0` representing water - `1` representing land A **region** is a group of `1`s (land) connected **4-directionally** (horizontal or vertical). You need to find and mark all land cells that are surrounded by water cells. A land cell is considered **surrounded by water** if all horizontal and vertical neighbors are either water or are also part of the surroundings that do not eventually connect to the boundary of the grid. **Note**: The edges of the grid are assumed to be surrounded by water. Return the modified grid where all surrounded land cells are marked with `2` (a new value to indicate they are surrounded by water). If no cells are surrounded by water, return the grid as it is.","solution":"def surrounded_regions(grid): rows, cols = len(grid), len(grid[0]) def dfs(r, c): # If we\'re out of bounds or at a cell that isn\'t land, return if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != 1: return # Mark the current cell as visited by changing it to -1 grid[r][c] = -1 # Perform DFS in all 4-directionally connected cells (up, down, left, right) dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) # First, mark all lands connected to the boundaries as not surrounded using DFS for i in range(rows): for j in range(cols): if (i in [0, rows - 1] or j in [0, cols - 1]) and grid[i][j] == 1: dfs(i, j) # Now, mark all surrounded land cells with 2 for i in range(rows): for j in range(cols): if grid[i][j] == 1: grid[i][j] = 2 elif grid[i][j] == -1: grid[i][j] = 1 return grid"},{"question":"There is a company that manages robotic arms placed on a grid. The grid is represented by a 2D matrix of size `m x n`, where each cell can either be empty (denoted by a 0) or have a robotic arm (denoted by a 1). The robotic arms can perform a \\"clean\\" operation that cleans the cell they are located at and spreads to adjacent cells in the four cardinal directions (up, down, left, right) concurrently. Given the grid `initialState` as the initial setup of the arms, you need to determine the total number of distinct cells that will be cleaned over a specified number of operations, `k`. - Implement the `RoboticGridCleaner` class: * `RoboticGridCleaner(int[][] initialState)` - Initializes the grid with the given initial setup of robotic arms. * `int clean(int k)` - Simulates the cleaning operations by the robotic arms and returns the number of distinct cells that would be cleaned after `k` operations. **Constraints:** - `1 <= m, n <= 1000` - `1 <= k <= 1000` - `initialState` is an `m x n` matrix where each element is either 0 or 1. - At least one cell in `initialState` contains a robotic arm (1). Note that all arms clean simultaneously in each operation step.","solution":"class RoboticGridCleaner: def __init__(self, initialState): self.grid = initialState self.m = len(initialState) self.n = len(initialState[0]) self.cleaned = set((i, j) for i in range(self.m) for j in range(self.n) if self.grid[i][j] == 1) def clean(self, k): dirs = [(0,1), (1,0), (0,-1), (-1,0)] current_clean = set(self.cleaned) for _ in range(k): next_clean = current_clean.copy() for i, j in current_clean: for d in dirs: ni, nj = i+d[0], j+d[1] if 0 <= ni < self.m and 0 <= nj < self.n: next_clean.add((ni, nj)) current_clean = next_clean return len(current_clean)"},{"question":"Given a sorted array of unique integers `arr` and a target integer `k`, find the **k-th missing positive integer** in the array. The missing positive integers are the positive integers that do not appear in the array. Return _the k-th missing positive integer_. If there are fewer than `k` missing positive integers, return `-1`.","solution":"def find_kth_missing(arr, k): Finds the k-th missing positive integer in a sorted array of unique integers. Parameters: arr (List[int]): A sorted list of unique integers. k (int): The k-th missing positive integer to find. Returns: int: The k-th missing positive integer, or -1 if there are fewer than k missing positive integers. missing_count = 0 current = 1 index = 0 while missing_count < k: if index < len(arr) and arr[index] == current: index += 1 else: missing_count += 1 if missing_count == k: return current current += 1 return -1"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. The list has the following properties: - Each node in the linked list contains a single integer value. - The list does not contain any cycles. - You may assume the linked list is non-empty.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotateRight(head, k): if not head or not head.next or k == 0: return head # Find the length of the list length = 1 old_tail = head while old_tail.next: old_tail = old_tail.next length += 1 # Connect the tail to the head to make it circular old_tail.next = head # Calculate the new tail position and new head position k = k % length new_tail_position = length - k - 1 new_tail = head for _ in range(new_tail_position): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"You are given two integers, `x` and `y`, and an array of integers `arr`. You can perform one of the following operations on `arr`: * Increment exactly one element by `x`. * Decrement exactly one element by `y`. You need to determine if it is possible to make all elements of the array equal after performing any number of the allowed operations. Return `true` if it is possible, otherwise return `false`.","solution":"def can_make_equal(x, y, arr): Determines if it is possible to make all elements of the array equal after performing any number of the allowed operations (increment one element by x or decrement one element by y) Args: x (int): the increment value y (int): the decrement value arr (array of int): the input array of integers Returns: bool: True if it is possible to make all elements equal, otherwise False min_val = min(arr) gcd = y for num in arr: if (num - min_val) % gcd != 0: return False return True"},{"question":"You are given an integer `n` and a `0-indexed` integer array `heights` of length `n`, where `heights[i]` represents the height of a student standing in a line. Find the number of students that must be moved to place the rest of the students in non-decreasing order of their heights. You can only move a student to a different position if they are taller than the student in front of them. Return _the minimum number of students that need to be moved._","solution":"def min_students_to_move(heights): Returns the minimum number of students that need to be moved to make the heights non-decreasing. :param heights: List[int] - List of student heights :return: int - Minimum number of students that need to be moved n = len(heights) lis = [1] * n # Longest Increasing Subsequence lengths for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) longest_increasing_subsequence_length = max(lis) return n - longest_increasing_subsequence_length"},{"question":"You are given an integer array `nums` and an integer `k`. You need to distribute the elements of `nums` into `k` subarrays such that the largest sum of any subarray is minimized. For example, given `nums = [7, 2, 5, 10, 8]` and `k = 2`: - One possible way to split the array could be `[7, 2, 5]` and `[10, 8]`, with the sums 14 and 18 respectively. The largest sum among these subarrays is 18. - However, another way to split the array is `[7, 2, 5, 10]` and `[8]`, with sums 24 and 8 respectively. Here, the largest sum among these subarrays is 24. Return the minimized largest sum among the partitions.","solution":"def distribute(nums, k): def can_partition(nums, k, max_sum): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num > max_sum: required_subarrays += 1 current_sum = num if required_subarrays > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are provided with an `n x n` matrix that represents an image. Each element in the matrix is a pixel value, where `matrix[i][j]` represents the pixel value at position `(i, j)`. You are required to reflect the image along its main diagonal. The main diagonal of a matrix runs from the top-left corner to the bottom-right corner. Your task is to implement the following operations: * Reflect the matrix along its main diagonal. Reflecting an image along its main diagonal means that the element at position `(i, j)` will be swapped with the element at position `(j, i)`. Implement the `ReflectMatrix` class: * `ReflectMatrix(int[][] matrix)` Initializes the object with the provided matrix. * `void reflect()` Reflects the matrix along its main diagonal. * `int[][] getMatrix()` Returns the matrix after it has been reflected.","solution":"class ReflectMatrix: def __init__(self, matrix): Initialize the ReflectMatrix object with the given matrix. self.matrix = matrix def reflect(self): Reflects the matrix along its main diagonal. n = len(self.matrix) for i in range(n): for j in range(i + 1, n): # Swap element at (i, j) with element at (j, i) self.matrix[i][j], self.matrix[j][i] = self.matrix[j][i], self.matrix[i][j] def getMatrix(self): Returns the matrix after it has been reflected. return self.matrix"},{"question":"You are given an array of integers `arr` and two integers `a` and `b`. Write a function that modifies the array such that for every segment of consecutive elements where the absolute difference between elements is less than or equal to `a`, the elements of the segment should be changed to have the same value, which is equal to the sum of the elements in the segment divided by the length of the segment and rounded down to the nearest integer. All the other elements in the array remain unchanged. Return the modified array.","solution":"def modify_array(arr, a): Modifies the array such that for every segment of consecutive elements where the absolute difference between elements is less than or equal to `a`, the elements of the segment should be changed to have the same value, which is equal to the sum of the elements in the segment divided by the length of the segment and rounded down to the nearest integer. All the other elements in the array remain unchanged. n = len(arr) if n == 0: return arr result = arr[:] i = 0 while i < n: start = i while i + 1 < n and abs(arr[i + 1] - arr[i]) <= a: i += 1 end = i segment_sum = sum(arr[start:end + 1]) segment_length = end - start + 1 new_value = segment_sum // segment_length for j in range(start, end + 1): result[j] = new_value i += 1 return result"},{"question":"You are given an array of binary strings `strs` and two integers `m` and `n`. Each binary string can represent a sum of the count of \'0\'s and \'1\'s, corresponding to m zeros and n ones. Find the maximum number of strings that you can form with given m zeros and n ones. You cannot reuse any string. Implement the function `findMaxForm(List<String> strs, int m, int n)` that returns the maximum number of binary strings you can form. - `findMaxForm(List<String> strs, int m, int n)`: - `strs`: List of binary strings. - `m`: Integer representing the number of zeros you can use. - `n`: Integer representing the number of ones you can use. For example: ``` findMaxForm([\\"10\\", \\"0001\\", \\"111001\\", \\"1\\", \\"0\\"], 5, 3) should return 4. ```","solution":"from typing import List def findMaxForm(strs: List[str], m: int, n: int) -> int: # dp[i][j] means the maximum number of strings we can form with i 0s and j 1s dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: zeros = s.count(\'0\') ones = s.count(\'1\') # Update the dp array from bottom right to top left for i in range(m, zeros - 1, -1): for j in range(n, ones - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1) return dp[m][n]"},{"question":"Given a list of words, each word consisting of lowercase letters, construct a **Trie** (prefix tree) from the words and return the root node of the Trie. Each node in the Trie should be represented by a class `TrieNode` with the following attributes: - `children`: a dictionary where keys are characters and values are `TrieNode` objects representing the child nodes. - `is_word`: a boolean indicating whether the node represents the end of a word. Implement the following methods for the Trie: - `insert(word: str) -> None`: Inserts a word into the Trie. - `search(word: str) -> bool`: Returns `True` if the word is in the Trie (i.e., it forms a complete word), otherwise returns `False`. - `startsWith(prefix: str) -> bool`: Returns `True` if there is any word in the Trie that starts with the given prefix, otherwise returns `False`. Use the `TrieNode` class to construct the Trie and support the operations. ```python class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: pass # Implement this method def search(self, word: str) -> bool: pass # Implement this method def startsWith(self, prefix: str) -> bool: pass # Implement this method ``` **Constraints**: - All input strings are non-empty and contain only lowercase letters. - The number of words given for constructing the Trie does not exceed 10^4. - The length of each word does not exceed 100.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def startsWith(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"You are given an array of integers `arr` and an integer `k`. Your goal is to find the maximum average value of any contiguous subarray of length `k`. A **contiguous subarray** is a sequence of `k` adjacent elements from the original array. Return _the maximum average value of any contiguous subarray of length `k` as a float_. Note that the answer can be up to 5 decimal places. For example, if `arr = [1, 12, -5, -6, 50, 3]` and `k = 4`, the maximum average would be calculated from the subarray `[12, -5, -6, 50]`, resulting in an average value of `12.75`.","solution":"def find_max_average(arr, k): if len(arr) < k: raise ValueError(\\"The length of the array must be greater than or equal to k.\\") # Initial window sum max_sum = sum(arr[:k]) window_sum = max_sum # Sliding window to find the maximum sum for i in range(k, len(arr)): window_sum = window_sum - arr[i - k] + arr[i] if window_sum > max_sum: max_sum = window_sum # Calculate the maximum average max_average = max_sum / k return round(max_average, 5)"},{"question":"You are given a list of `n` integers, `arr`, where `arr[i]` represents the number of **tasks** that need to be performed on the `i-th` day. Each task can be completed in exactly one day. You are also given an integer `k`, which denotes a threshold. A **peak** day is defined as a day where the number of tasks is strictly greater than both the previous day and the following day. Return _the number of peak days in the `arr` that have a number of tasks greater than the threshold `k`._ If there are no peak days, return `0`. Note that the first and last days cannot be peak days.","solution":"def count_peak_days(arr, k): Counts peak days in the array `arr` with a task number greater than threshold `k`. :param arr: List of integers where arr[i] is the number of tasks on the i-th day. :param k: Integer threshold for the number of tasks. :return: Integer count of peak days with more than `k` tasks. if len(arr) < 3: return 0 # There cannot be any peak days if length of arr is less than 3 peak_days_count = 0 for i in range(1, len(arr) - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1] and arr[i] > k: peak_days_count += 1 return peak_days_count"},{"question":"Given a list of unique integers `arr`, you need to determine whether it can be partitioned into two subsets such that the sum of the elements in both subsets is equal. Return `true` if you can partition the list into two subsets with equal sum, and `false` otherwise. **Example:** ``` Input: arr = [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11] Input: arr = [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets ``` Implement the function: ``` bool canPartition(int[] arr) ```","solution":"def canPartition(arr): Determines whether the array can be partitioned into two subsets with equal sum. total_sum = sum(arr) if total_sum % 2 != 0: return False target = total_sum // 2 n = len(arr) dp = [[False] * (target + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): dp[i][0] = True for j in range(1, target + 1): dp[i][j] = dp[i - 1][j] if arr[i - 1] <= j: dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]] return dp[n][target]"},{"question":"You are given two strings `word1` and `word2` representing two version numbers. Each version number consists of digits and periods `\'.\'`. Each period `\'.\'` separates the version number into hierarchical levels. For example, `\\"1.2\\"` and `\\"1.2.1\\"` are valid version numbers. Convert the version numbers to lists of integers, compare each hierarchical level, and return: - `1` if `word1` is a larger version - `-1` if `word2` is a larger version - `0` if both version numbers are equivalent **Examples:** ``` Input: word1 = \\"1.01\\", word2 = \\"1.001\\" Output: 0 Explanation: Both version numbers are the same. \\"1.01\\" equals \\"1.001\\". Input: word1 = \\"1.0\\", word2 = \\"1.0.0\\" Output: 0 Explanation: Both version numbers are the same. \\"1.0\\" equals \\"1.0.0\\". Input: word1 = \\"0.1\\", word2 = \\"1.1\\" Output: -1 Explanation: \\"0.1\\" is less than \\"1.1\\". ```","solution":"def compare_version(word1, word2): Compares two version numbers. :param word1: str - Version number in string format. :param word2: str - Version number in string format. :return: int - 1 if word1 is a larger version, -1 if word2 is a larger version, 0 if both are equivalent. v1 = list(map(int, word1.split(\'.\'))) v2 = list(map(int, word2.split(\'.\'))) # Normalize lengths of both lists by padding with zeros max_len = max(len(v1), len(v2)) v1.extend([0] * (max_len - len(v1))) v2.extend([0] * (max_len - len(v2))) # Compare each level for i in range(max_len): if v1[i] > v2[i]: return 1 elif v1[i] < v2[i]: return -1 return 0"},{"question":"You are given a `0-indexed` array of integers `nums` of length `n`. The array contains alternating odd and even numbers. You can perform the following operation any number of times: select any subarray and reverse it. An array is sorted if for every pair of adjacent elements `a` and `b`, `a <= b`. Return _the minimum number of operations required_ to sort the array `nums`.","solution":"def min_operations_to_sort(nums): Returns the minimum number of operations to sort the array nums. n = len(nums) odd = sorted(nums[::2]) even = sorted(nums[1::2]) sorted_nums = [] for i in range((n+1)//2): sorted_nums.append(odd[i]) if i < len(even): sorted_nums.append(even[i]) # Check if the sorted_nums array is already sorted if all(sorted_nums[i] <= sorted_nums[i + 1] for i in range(n - 1)): return 0 else: return 1"},{"question":"Given a string `s` and an array of strings `words`, return _the length of the longest substring in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters_. You may assume each word in `words` is of the same length. For example, given `s = \\"barfoothefoobarman\\"` and `words = [\\"foo\\",\\"bar\\"]`, you should return `6` because the substring `\\"foobar\\"` has length `6` and is a concatenation of `\\"foo\\"` and `\\"bar\\"`.","solution":"def findSubstring(s, words): Return the length of the longest substring in s that is a concatenation of each word in words exactly once and without any intervening characters. from collections import Counter if not s or not words or not words[0]: return 0 word_length = len(words[0]) word_count = len(words) total_length = word_length * word_count word_dict = Counter(words) def is_concatenation(start): seen_words = Counter() for i in range(start, start + total_length, word_length): current_word = s[i:i+word_length] if current_word not in word_dict: return False seen_words[current_word] += 1 if seen_words[current_word] > word_dict[current_word]: return False return True for i in range(len(s) - total_length + 1): if is_concatenation(i): return total_length return 0"},{"question":"You are given an array of integers `arr` representing the heights of buildings in a city skyline. A building `i` is said to have an **unobstructed view** if from the top of the building, you can see the sunset directly, meaning that there are no taller buildings to the right of it. Return an array containing the indices of all buildings that have an **unobstructed view** sorted in ascending order.","solution":"def unobstructed_view_buildings(arr): Returns the indices of buildings that have an unobstructed view of the sunset. Only buildings that have no taller buildings to their right have an unobstructed view. n = len(arr) if n == 0: return [] result = [] max_height = float(\'-inf\') for i in reversed(range(n)): if arr[i] > max_height: result.append(i) max_height = arr[i] return sorted(result)"},{"question":"You are given a `n x n` grid representing a city with `n` intersections and `n` roads, where each intersection is represented by a 0-indexed integer from `0` to `n - 1`. The traffic between intersections is bidirectional. Each road between intersections is represented by the 2D integer list `roads`, where `roads[i] = [u, v]` denotes a bi-directional road between intersections `u` and `v`. A list `traffic` is also provided, where `traffic[i]` represents the traffic congestion for intersection `i`. Your goal is to reroute traffic by selecting exactly two intersections `a` and `b` and swapping their traffic values, aiming to minimize the maximum traffic congestion at any intersection after the swap. Return _the **minimum** maximum traffic congestion possible after swapping_.","solution":"def minimize_max_traffic(n, roads, traffic): Given a city with n intersections and n roads, this function reroutes traffic by swapping the traffic values of two intersections to minimize the maximum traffic congestion at any intersection. :param n: int, the number of intersections :param roads: List[List[int]], the roads connecting the intersections :param traffic: List[int], the traffic congestion at each intersection :return: int, the minimum maximum traffic congestion possible after swapping # Sort the traffic values traffic_sorted = sorted(traffic) # The minimum maximum traffic congestion after swapping will always be between # the initially sorted penultimate and second values as we can swap # the lowest traffic value with the highest and similar considerations. possible_scenarios = [] if n > 1: possible_scenarios.append(max(traffic_sorted[1], traffic_sorted[-1])) possible_scenarios.append(max(traffic_sorted[0], traffic_sorted[-2])) return min(possible_scenarios)"},{"question":"A palindrome is a word or phrase that reads the same forwards and backwards (ignoring spaces, punctuation, and capitalization). Given a string `s`, return `true` if it is a palindrome. _Otherwise, return_ `false`.","solution":"def is_palindrome(s): Returns True if the input string s is a palindrome, ignoring spaces, punctuation, and capitalization. Otherwise, returns False. # Filter only alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters reads the same forwards and backwards return filtered_chars == filtered_chars[::-1]"},{"question":"Given an integer array `arr`, reverse the order of the elements between the indices `i` and `j` (inclusive) without using any extra space. Return the modified array.","solution":"def reverse_subarray(arr, i, j): Reverses the order of the elements in arr between the indices i and j (inclusive). Parameters: arr (list): The input array. i (int): The starting index of the subarray to reverse. j (int): The ending index of the subarray to reverse. Returns: list: The modified array with the subarray reversed. while i < j: arr[i], arr[j] = arr[j], arr[i] i += 1 j -= 1 return arr"},{"question":"Given a list of non-negative integers `nums`, you are tasked with partitioning the list into two subsets such that the absolute difference between their sums is minimized. Return _the minimum_ _absolute difference_. For example, given the list `nums = [1, 6, 11, 5]`, you can partition it into subsets `[1, 6, 5]` and `[11]`, resulting in an absolute difference of `1`. --- This question engages with dynamic programming, a core concept in computer science, and involves subset partitioning, a problem similar in complexity and nature to those given in the original set.","solution":"def min_subset_difference(nums): Returns the minimum absolute difference between the sums of two subsets of nums. total_sum = sum(nums) n = len(nums) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(target, -1, -1): if dp[n][j]: subset_sum = j break other_subset_sum = total_sum - subset_sum return abs(other_subset_sum - subset_sum)"},{"question":"You are given a list of `n` integers, `heights`, which represent the heights of buildings arranged sequentially. You need to calculate the maximum area of a rectangle formed by these buildings, where the rectangle\'s width is the number of consecutive buildings and its height is the minimum height of the buildings in that range. Write a function that returns the maximum area of such a rectangle. For example, given `heights = [2, 1, 5, 6, 2, 3]`, the maximum rectangle has an area of `10` (formed by the buildings with heights `[5, 6]`). Return the maximum area of a rectangle in the histogram.","solution":"def max_histogram_area(heights): Calculates the maximum area of a rectangle formed by consecutive building heights. :param heights: List[int] - List of building heights. :return: int - Maximum area of a rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"You are given an integer array `cards` where `cards[i]` represents the value of the `i-th` card. There are two players, Alice and Bob, who take turns playing a game with these cards. Each player has two choices on their turn: they can either take the card from the start of the array or the end of the array. The player who takes the card adds the value of that card to their score, and the card is then removed from the array. Alice always goes first. Both players play optimally to maximize their final scores. If there are two or more optimal moves, Alice prioritizes the one that leaves Bob with the smallest possible score next. Return _the maximum score Alice can achieve given that both players play optimally_.","solution":"def max_score(cards): n = len(cards) # dp[i][j] will store the max score player 1 (Alice) can achieve for the subarray cards[i:j+1] dp = [[0] * n for _ in range(n)] # initialize for one card scenario for i in range(n): dp[i][i] = cards[i] # fill the dp array for subarrays longer than one card for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max( cards[i] + (sum(cards[i+1:j+1]) - dp[i+1][j]), cards[j] + (sum(cards[i:j]) - dp[i][j-1]) ) total_sum = sum(cards) max_alice_score = dp[0][n-1] return max_alice_score"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. You need to split the array into `k` subarrays, and compute the sum of each subarray. Your goal is to minimize the difference between the maximum subarray sum and the minimum subarray sum. Return _the minimum possible difference between the maximum subarray sum and the minimum subarray sum after splitting the array into `k` subarrays_.","solution":"def get_min_difference(nums, k): Returns the minimum possible difference between the maximum subarray sum and the minimum subarray sum after splitting the array into `k` subarrays. def can_partition(max_sum): count, curr_sum = 1, 0 for num in nums: curr_sum += num if curr_sum > max_sum: count += 1 curr_sum = num if count > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 min_possible_difference = right return min_possible_difference"},{"question":"Given a list of `n` integers representing the profit of `n` houses located along a street, devise an algorithm to determine the maximum amount of money a thief can rob tonight without alerting the police. The constraint is that the thief cannot rob two adjacent houses due to an automatic security system. Return the maximum amount of money the thief can rob without triggering the security system.","solution":"def rob(houses): Determine the maximum amount of money a thief can rob without triggering the security system. :param houses: List[int] - a list of integers representing the profit of n houses :return: int - the maximum money that can be robbed if not houses: return 0 if len(houses) == 1: return houses[0] # Dynamic programming array to store the maximum profit up to each house dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"Given an array of integers `nums`, return the **length of the longest subsequence** such that the difference between adjacent elements is either exactly `1` or exactly `-1`. A subsequence is defined as a sequence derived from the array `nums` by deleting some or no elements without changing the order of the remaining elements. For example: * For `nums = [3, 4, 2, 5, 3, 4, 5, 6]`, one of the longest subsequences with differences exactly `1` or `-1` is `[3, 4, 3, 4, 5, 6]`, and the length is 6. * For `nums = [1, 2, 3, 4, 5, 2, 3, 4, 5, 5]`, one of the longest subsequences with differences exactly `1` or `-1` is `[1, 2, 3, 4, 5, 4, 5]` and the length is 7.","solution":"def longest_subsequence(nums): if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if abs(nums[i] - nums[j]) == 1: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a string `s` consisting of lowercase English letters. A character `c` in `s` is said to be **dominant** if the number of times it appears in `s` is strictly greater than the occurrences of all other characters combined. Return the character `c` if it is dominant, otherwise return an empty string. For example, given the string `\\"aabbc\\"`, no character is dominant as \'a\' and \'b\' both appear twice and \'c\' once, which means no single character strictly exceeds the occurrence count of all others combined. For `\\"aaaab\\"`, \'a\' is dominant because it appears four times, and \'b\' appears once. As four is strictly greater than the combined occurrences of all other characters (which is 1), \'a\' is dominant.","solution":"def find_dominant_character(s): Returns the dominant character if one exists, otherwise an empty string. A character is dominant if the number of times it appears in the string is strictly greater than the occurrences of all other characters combined. if not s: return \\"\\" char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 total_length = len(s) for char, count in char_count.items(): if count > (total_length - count): return char return \\"\\""},{"question":"You are given a `m * n` matrix `grid` containing integers, where each integer represents the height of a cell. You can move from a cell to any of its four neighboring cells (up, down, left, or right) if and only if the absolute difference in height between the current cell and the destination cell is less than or equal to a given threshold `t`. Your task is to determine whether there is a path from the top-left cell `(0, 0)` to the bottom-right cell `(m-1, n-1)` in the matrix such that the absolute height differences between adjacent cells in the path do not exceed `t`. Return `true` if such a path exists, and `false` otherwise.","solution":"def can_traverse(grid, t): from collections import deque m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y, visited): return 0 <= x < m and 0 <= y < n and not visited[x][y] visited = [[False for _ in range(n)] for _ in range(m)] # Start BFS from the top-left cell (0, 0) queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, visited) and abs(grid[nx][ny] - grid[x][y]) <= t: visited[nx][ny] = True queue.append((nx, ny)) return False"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `n`. A substring is defined as a contiguous (non-empty) sequence of characters within `s`. Your task is to determine the number of substrings of `s` whose length is exactly `n` and whose characters are unique. Return this count as an integer.","solution":"def unique_substrings_count(s, n): Returns the number of substrings of `s` whose length is exactly `n` and whose characters are unique. Parameters: s (str): Input string consisting of lowercase English letters. n (int): Length of the substrings to consider. Returns: int: Number of substrings of length `n` with unique characters. if n > len(s) or n < 1: return 0 unique_count = 0 for i in range(len(s) - n + 1): substring = s[i:i+n] if len(set(substring)) == n: unique_count += 1 return unique_count"},{"question":"In a online multiplayer game, you are tasked with managing friend requests among `n` players. You are given a 0-indexed 2D integer array `requests`, where each `requests[i]` is an array of two integers `[a, b]` representing a friend request from player `a` to player `b`. Friendships are bidirectional, meaning if player `a` and player `b` become friends then both players will consider each other as friends. Your task is to process each friend request in the order they appear and compute the total number of friend groups (clusters of connected players) after all requests have been processed. Return the number of such friend groups. Note that each player can belong to only one friend group.","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.count = size def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) # path compression return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def get_count(self): return self.count def friend_groups(n, requests): uf = UnionFind(n) for a, b in requests: uf.union(a, b) return uf.get_count()"},{"question":"Given a list of non-negative integers `nums` and an integer `k`, write a function that returns **the length of the longest subarray** containing at most `k` distinct integers. The subarray should be contiguous and, if there are multiple such subarrays, return the length of any one of them. For example, given `nums = [1, 2, 1, 2, 3]` and `k = 2`, the longest subarray containing at most 2 distinct integers is `[1, 2, 1, 2]` with length 4.","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest subarray with at most k distinct integers. from collections import defaultdict window_start = 0 max_length = 0 freq_map = defaultdict(int) for window_end in range(len(nums)): right_char = nums[window_end] freq_map[right_char] += 1 while len(freq_map) > k: left_char = nums[window_start] freq_map[left_char] -= 1 if freq_map[left_char] == 0: del freq_map[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"You are given a positive integer `n` representing the number of nodes in a binary tree, where each node has a unique value from `1` to `n`. You need to construct all possible unique binary search trees (BSTs) that store values `1` to `n`. Write a function `generateTrees(n: Int) -> List[TreeNode]` that returns all possible unique BSTs. Each generated tree should be represented using the `TreeNode` class, defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Return the list of root nodes of all possible unique BSTs.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n: int) -> List[TreeNode]: if n == 0: return [] def generate(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate(start, i - 1) right_trees = generate(i + 1, end) for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees return generate(1, n)"},{"question":"You are given a non-empty string `s` consisting of lowercase alphabets. Your task is to return the length of the longest substring that contains only unique characters. Implement the function `int lengthOfLongestSubstring(string s)`. The function should use an efficient approach to solve the problem, considering the constraints on time complexity.","solution":"def lengthOfLongestSubstring(s): Returns the length of the longest substring with unique characters. char_map = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a list of integers `arr`, and an integer `target`, determine if there are four elements in `arr` that add up to `target`. Your function should return `true` if such a combination exists, and `false` otherwise. The solution should refrain from using the same element more than once within a combination. Analyze the given list to find these quadruples efficiently despite potential length or value constraints of `arr`.","solution":"def four_sum(arr, target): Determines if there are four elements in the list `arr` that add up to `target`. Args: arr (list of int): List of integers to analyze. target (int): The target sum. Returns: bool: True if there are four elements that add up to the target, False otherwise. arr.sort() n = len(arr) for i in range(n - 3): if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left = j + 1 right = n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. Determine the length of the longest substring of `s` that contains at most `k` distinct characters. If there are multiple such substrings, return the length of the first one found during traversal.","solution":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring of `s` that contains at most `k` distinct characters. from collections import defaultdict if k == 0 or not s: return 0 left = 0 max_length = 0 char_count = defaultdict(int) for right in range(len(s)): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an integer array `nums` and a target integer `targetSum`, determine if there exists a subset of `nums` whose elements sum to `targetSum`. Return `true` if such a subset exists, and `false` otherwise. Use dynamic programming to solve this problem efficiently.","solution":"def subset_sum(nums, targetSum): Determine if there exists a subset of `nums` whose elements sum to `targetSum`. Arguments: nums -- List of integers targetSum -- Target sum integer Returns: Boolean -- True if such a subset exists, False otherwise n = len(nums) dp = [[False] * (targetSum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, targetSum + 1): if nums[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] return dp[n][targetSum]"},{"question":"Given a list of intervals representing `n` `meetings`, where `meetings[i] = [start, end]` for meeting `i` indicates its start time and end time, determine the minimum number of meeting rooms required. A meeting room can only host one meeting at a time. Implement the `MeetingRooms` class: * `MeetingRooms(int[][] meetings)` Initializes the object with the intervals representing the meetings. * `int minMeetingRooms()` Returns the minimum number of meeting rooms required to host all the meetings. Ensure your algorithm can efficiently handle scenarios where meetings may overlap.","solution":"import heapq class MeetingRooms: def __init__(self, meetings): self.meetings = meetings def minMeetingRooms(self): if not self.meetings: return 0 # Sort the meetings by their start time self.meetings.sort(key=lambda x: x[0]) min_rooms = 0 end_times = [] for meeting in self.meetings: # While there\'s a meeting that ended before the current one starts while end_times and end_times[0] <= meeting[0]: heapq.heappop(end_times) # Add the current meeting\'s end time to the heap heapq.heappush(end_times, meeting[1]) # The number of rooms needed is the size of the heap min_rooms = max(min_rooms, len(end_times)) return min_rooms"},{"question":"You are given a **0-indexed** array of integers `nums` of length `n` and an integer `target`. Your task is to determine if there exist four distinct indices `i`, `j`, `k`, and `l` (where `i`, `j`, `k`, `l` are all different) such that the sum of elements at these indices equals `target`. Return _true_ if such quadruplets exist, and _false_ otherwise.","solution":"def has_quadruplet(nums, target): Determines if there exist four distinct indices i, j, k, and l such that the sum of elements at those indices equals the target. :param nums: List[int] - a list of integers :param target: int - the target sum for the quadruplet :return: bool - True if such quadruplet exists, otherwise False nums_len = len(nums) if nums_len < 4: return False nums.sort() for i in range(nums_len - 3): for j in range(i + 1, nums_len - 2): for k in range(j + 1, nums_len - 1): for l in range(k + 1, nums_len): if nums[i] + nums[j] + nums[k] + nums[l] == target: return True return False"},{"question":"You are given two strings, `s` and `t`, consisting of only lowercase English letters. You need to check whether `t` is an anagram of `s`. An anagram is a word formed by rearranging the letters of another, using all the original letters exactly once. Return `true` if `t` is an anagram of `s`, and `false` otherwise. Implement the function `boolean isAnagram(String s, String t)` which checks if the string `t` is an anagram of string `s`. Example: - `s = \\"listen\\"`, `t = \\"silent\\"` -> `true` - `s = \\"hello\\"`, `t = \\"billion\\"` -> `false`","solution":"def isAnagram(s, t): Checks if string t is an anagram of string s. Parameters: s (str): The original string. t (str): The string to check if it is an anagram of s. Returns: bool: True if t is an anagram of s, False otherwise. if len(s) != len(t): return False return sorted(s) == sorted(t)"},{"question":"Given an `m x n` matrix `mat` filled with non-negative integers, find the largest square containing only `1`s and return its area. Implement the `maximalSquare` method to solve this problem as efficiently as possible. The `maximalSquare` method should take a 2D list `mat` as input and return an integer representing the largest square\'s area. Your solution should use dynamic programming to achieve an optimal time complexity.","solution":"def maximalSquare(mat): if not mat: return 0 m, n = len(mat), len(mat[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if mat[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"You are given an integer array `heights` representing the heights of students in a classroom, where `heights[i]` is the height of the `ith` student. The students are currently standing in a random order. Your task is to find the minimum number of students that must be moved to new positions such that the entire class is arranged in non-decreasing order of their heights. Return the minimum number of moves required.","solution":"def min_moves_to_arrange(heights): # find the length of LIS using dynamic programming n = len(heights) if n == 0: return 0 dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) lis_length = max(dp) return n - lis_length"},{"question":"You are given a string `s` containing only the characters `a` and `b`. A substring of `s` is called **special** if it contains equal numbers of the character `a` and the character `b`. Find the **maximum length** of a special substring. If no such substring exists, return 0.","solution":"def max_length_of_special_substring(s): Finds the maximum length of a special substring containing equal numbers of \'a\' and \'b\' in the string s. If no such substring exists, returns 0. max_length = 0 for i in range(len(s)): count_a = 0 count_b = 0 for j in range(i, len(s)): if s[j] == \'a\': count_a += 1 elif s[j] == \'b\': count_b += 1 if count_a == count_b: max_length = max(max_length, j - i + 1) return max_length"},{"question":"You are given an m x n binary matrix **grid**, where 0 represents a free cell and 1 represents an obstacle. A path is a sequence of adjacent cells that starts from the top-left cell (0,0) and ends at the bottom-right cell (m-1,n-1). You can only move right or down at any point in time. Return the number of unique paths from top-left to bottom-right cell that do not pass through any obstacle. If there is no such path, return 0.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right of the grid avoiding obstacles. :param grid: List[List[int]] where 0 represents free cell and 1 represents obstacle :return: Number of unique paths avoiding obstacles if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Starting point for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given an **undirected graph** represented by an integer `n`, the number of nodes, and an array `edges`, where `edges[i] = [u_i, v_i]` indicates that there is an edge between `u_i` and `v_i` in the graph. The graph contains no self-loops or multiple edges. Your task is to determine if the graph contains a cycle. If a cycle is detected, return `true`, otherwise return `false`.","solution":"def contains_cycle(n, edges): Determines if the graph contains a cycle. :param n: Number of nodes in the graph. :param edges: List of edges, where each edge is represented by a tuple or list [u, v]. :return: True if the graph contains a cycle, False otherwise. parent = [-1] * n def find(i): if parent[i] == -1: return i return find(parent[i]) def union(x, y): x_set = find(x) y_set = find(y) if x_set != y_set: parent[x_set] = y_set else: return True return False for u, v in edges: if union(u, v): return True return False"},{"question":"You are given a list of tasks where each task is represented by an interval `[start, end)` indicating the start time and the end time. You need to schedule these tasks on a single machine such that no two tasks overlap on that machine. Return the maximum number of non-overlapping tasks that can be scheduled. If it is impossible to schedule any tasks without overlap, return 0. For example, given the tasks `[[1, 3], [2, 5], [4, 6]]`, the maximum number of non-overlapping tasks that can be scheduled is 2 (e.g., tasks `[1, 3]` and `[4, 6]`).","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. if not tasks: return 0 # Sort tasks based on their end time tasks.sort(key=lambda x: x[1]) count = 0 end_time = 0 for task in tasks: if task[0] >= end_time: count += 1 end_time = task[1] return count"},{"question":"You are given an array of integers `arr` and an integer `k`. You need to transform the array plane such that the sum of all its elements becomes equal to `k`. In one operation, you can pick any subarray (a contiguous segment of the array) and increase or decrease each element of that subarray by `1`. Return _the minimum number of operations required to make the sum of the array_ `arr` _equal to_ `k`_. If it is not possible, return `-1`.","solution":"def min_operations_to_sum_k(arr, k): This function returns the minimum number of operations required to make the sum of the array `arr` equal to `k`. If it is not possible, the function returns -1. current_sum = sum(arr) difference = abs(k - current_sum) if difference == 0: return 0 # Since picking any subarray and increasing/decreasing each element by 1 affects the overall sum by the # length of the subarray, the minimum number of operations is the number of absolute difference. return difference"},{"question":"A robot is positioned at a 2D grid starting from the top-left corner (0, 0). The grid is of size `m x n`. The robot can move either left, right, up, or down, but it cannot visit the same cell more than once. Your task is to write a function that determines the number of distinct paths the robot can take to reach the bottom-right corner (m-1, n-1) starting from the top-left corner. Given two integers `m` and `n`, return the number of distinct paths to reach the destination. For example, given `m = 3` and `n = 3`, the function should return 6 as there are 6 distinct paths: - Right, Right, Down, Down - Right, Down, Right, Down - Right, Down, Down, Right - Down, Right, Right, Down - Down, Right, Down, Right - Down, Down, Right, Right Implement your solution to achieve this task.","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) of an mxn grid. # Create a 2D list to store the number of paths to reach each cell dp = [[0] * n for _ in range(m)] # There is only one way to reach the starting point dp[0][0] = 1 # Fill the dp table for i in range(m): for j in range(n): if i > 0: dp[i][j] += dp[i-1][j] # paths from the cell above if j > 0: dp[i][j] += dp[i][j-1] # paths from the cell to the left # Return the number of paths to reach the bottom-right corner return dp[m-1][n-1]"},{"question":"You are given an `m x n` binary grid `grid` representing an island, where `0` represents water and `1` represents land. An island is a maximal group of `1`s connected vertically or horizontally. You need to find the perimeter of the island. The perimeter of the island is the total length of the boundary around the island. Return the perimeter of the island. If there are no `1`s in the grid, return `0`.","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Check all four directions if r == 0 or grid[r-1][c] == 0: # Up perimeter += 1 if r == rows-1 or grid[r+1][c] == 0: # Down perimeter += 1 if c == 0 or grid[r][c-1] == 0: # Left perimeter += 1 if c == cols-1 or grid[r][c+1] == 0: # Right perimeter += 1 return perimeter"},{"question":"You are managing a network of servers, and you need to implement a function to balance load across them efficiently. The servers can handle a certain amount of load, and you can add new servers as needed. Given an array `load` where `load[i]` represents the load handled by the `i-th` server, and an integer `maxLoad` indicating the maximum load a single server can handle, return the minimum number of servers required to handle all loads without exceeding the `maxLoad` for any server. You can distribute the load arbitrarily across servers. Write an algorithm that runs in `O(n log n)` time.","solution":"def min_servers(load, maxLoad): Given a list of loads and the maximum load a single server can handle, returns the minimum number of servers required to handle all loads without exceeding the max load for any server. if maxLoad <= 0: raise ValueError(\\"maxLoad must be a positive integer.\\") load.sort(reverse=True) servers = [] for l in load: placed = False for i in range(len(servers)): if servers[i] + l <= maxLoad: servers[i] += l placed = True break if not placed: servers.append(l) return len(servers)"},{"question":"You are given a list of `n` strings `products` and a string `searchWord`. You want to design a system that suggests at most three product names from `products` after each character of `searchWord` is typed. Suggested products should start with the searchWord and are given in descending order of their match quality. If there are more than three products that match the search word, return the top 3 matches. Each of the suggested product names must be sorted in lexicographical order. Return a list of `lists` of the suggested products after each character of `searchWord` is typed.","solution":"from typing import List def suggested_products(products: List[str], searchWord: str) -> List[List[str]]: Returns a list of lists containing suggested products after each character of searchWord is typed. # Sort the products lexicographically products.sort() result = [] prefix = \'\' for char in searchWord: prefix += char suggestions = [] for product in products: if product.startswith(prefix): suggestions.append(product) if len(suggestions) == 3: break result.append(suggestions) return result"},{"question":"You are given a binary tree where each node contains an integer value. Write a function to return the postorder traversal of the binary tree as a list of integers. A postorder traversal is a type of depth-first traversal where you visit the left subtree, then the right subtree, and finally the root node. The tree is represented as a TreeNode structure as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your function should return a list of integer values representing the postorder traversal. Consider the following binary tree: ``` 1 / 2 3 / 4 5 ``` The expected return for postorder traversal of this tree would be: `[4, 5, 2, 3, 1]`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root): Returns the postorder traversal of the binary tree as a list of integers. result = [] def traverse(node): if node is not None: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"You are given a list of intervals and a number `x`. Each interval is represented as a pair `[start, end]`, where `start` and `end` are non-negative integers. An interval `[start, end]` includes all numbers `yy` such that `start <= y <= end`. Your task is to determine the smallest number of intervals you need to remove such that the remaining intervals don\'t cover the number `x`. If the number `x` is not covered by any interval initially, return `0`. Example: Input: intervals = [[1, 4], [2, 5], [7, 8]], x = 3 Output: 1 Explanation: By removing the interval [1, 4], the number 3 is no longer covered by any remaining intervals.","solution":"def min_intervals_to_remove(intervals, x): Determine the minimum number of intervals to remove such that the number x is not covered by any remaining intervals. :param intervals: List of intervals where each interval is represented as a list [start, end] :param x: The number to ensure is not covered by any interval :return: Minimum number of intervals to remove # Find all intervals that cover the number x covering_intervals = [interval for interval in intervals if interval[0] <= x <= interval[1]] # If no intervals cover x initially, return 0 if not covering_intervals: return 0 # We need to remove all intervals that cover x to make x not covered return len(covering_intervals)"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `threshold`. Return _the **length** of the longest contiguous subarray such that the average of **all** elements in the subarray is **greater than or equal to**_ `threshold`. A contiguous subarray is a sequence of elements that are next to each other, indexed from `i` to `j` where (0 leq i leq j < text{length of } arr).","solution":"def longest_subarray_with_avg_gte_threshold(arr, threshold): def is_valid_subarray(start, end): subarray = arr[start:end + 1] return sum(subarray) / len(subarray) >= threshold n = len(arr) max_length = 0 for start in range(n): for end in range(start, n): if is_valid_subarray(start, end): max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a 2D integer matrix `grid` representing the state of a minefield, where `grid[i][j]` can either be `0` (an empty cell) or `1` (a mine). A robot starts from the top-left corner of the grid and can only move right or down. You need to determine the number of distinct paths the robot can take to reach the bottom-right corner of the grid without triggering any mines. Note that the robot can only traverse through empty cells. Return the total number of distinct paths from the top-left corner to the bottom-right corner.","solution":"def unique_paths(grid): Function to calculate the number of unique paths in a minefield grid. Parameters: grid (list of list of int): 2D grid representation of the minefield where 0 is an empty cell and 1 is a mine. Returns: int: The number of unique paths from the top-left corner to the bottom-right corner. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"Given two integer arrays `arr1` and `arr2` of the same length, you need to form a new array `result` where each element `result[i]` is the minimum of `arr1[i]` and `arr2[i]`. You are also required to calculate the sum of all elements in the `result` array. Return the `result` array and the calculated sum as a pair.","solution":"def min_and_sum_arrays(arr1, arr2): Given two integer arrays `arr1` and `arr2` of the same length, return a tuple containing a new array `result` where each element `result[i]` is the minimum of `arr1[i]` and `arr2[i]` and the sum of all elements in the `result` array. result = [min(a, b) for a, b in zip(arr1, arr2)] total_sum = sum(result) return result, total_sum"},{"question":"You are given a string `s` and an array of queries `q`, where each query consists of a pair of indices `(l, r)` representing the left and right bounds of a substring (inclusive and 0-indexed). Return an array `results` where `results[i]` is the number of distinct characters in the substring `s[l:r+1]` for the i-th query. If the substring is empty, the count should be `0`.","solution":"def count_distinct_characters(s, queries): Returns an array of distinct character counts for each query\'s substring. Parameters: s (str): The input string. queries (list of tuple): Array of queries where each query is a tuple (l, r) representing the bounds of the substring. Returns: list: Array of distinct character counts for each substring defined by queries. results = [] for l, r in queries: if l > r: results.append(0) else: substring = s[l:r+1] distinct_characters = set(substring) results.append(len(distinct_characters)) return results"},{"question":"You are given a list of string transformations where each transformation is represented as a triplet `[start, end, steps]`. This indicates that the string `start` can be transformed into the string `end` in exactly `steps` operations. Given an initial string `initial` and a target string `target`, determine the minimum number of operations required to transform `initial` to `target` using the given transformations. If it\'s not possible to transform `initial` to `target`, return `-1`. The transformations are non-reversible, meaning they only work in the described direction.","solution":"from collections import deque, defaultdict def min_operations_to_transform(initial, target, transformations): adj_list = defaultdict(list) for start, end, steps in transformations: adj_list[start].append((end, steps)) queue = deque([(initial, 0)]) visited = set() visited.add(initial) while queue: current, current_steps = queue.popleft() if current == target: return current_steps for neighbor, steps in adj_list[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_steps + steps)) return -1"},{"question":"You are given an array of `n` integers where every element appears exactly twice except for one element which appears only once. Write a function to find the element that appears only once. Your solution should have a linear runtime complexity and use only constant extra space.","solution":"def find_single_element(arr): Returns the element that appears only once in the array. The array is guaranteed to have all elements appearing exactly twice except for one element. Time Complexity: O(n) Space Complexity: O(1) unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"There is a music streaming service that categorizes songs by their genres. The available songs are represented as a list of strings `songs`, where each string represents the title of the song, and an array `genres`, where `genres[i]` is the genre of the `songs[i]`. Users of the streaming service can create their own playlists. Each user can create one playlist represented as a list of song titles. Implement the `PlaylistManager` class: * `PlaylistManager(String[] songs, String[] genres)` Initializes the object with the available songs and their genres. * `void createUserPlaylist(String username, String[] playlist)` Creates a playlist for a user with the specified `username` containing the songs in `playlist`. * `String[] getUserPlaylist(String username)` Returns the playlist of the user with the given `username`. * `Map<String, List<String>> getUserPlaylistByGenre(String username)` Returns a map where the keys are genres and the values are lists of song titles in the user\'s playlist for that genre. * `int getGenreCount(String username, String genre)` Returns the number of songs in the users playlist that belong to the specified genre.","solution":"class PlaylistManager: def __init__(self, songs, genres): self.songs = songs self.genres = genres self.song_genre_map = {song: genre for song, genre in zip(songs, genres)} self.user_playlists = {} def createUserPlaylist(self, username, playlist): self.user_playlists[username] = playlist def getUserPlaylist(self, username): return self.user_playlists.get(username, []) def getUserPlaylistByGenre(self, username): playlist_by_genre = {} playlist = self.user_playlists.get(username, []) for song in playlist: genre = self.song_genre_map.get(song, \\"Unknown\\") if genre not in playlist_by_genre: playlist_by_genre[genre] = [] playlist_by_genre[genre].append(song) return playlist_by_genre def getGenreCount(self, username, genre): playlist = self.user_playlists.get(username, []) return sum(1 for song in playlist if self.song_genre_map.get(song, \\"Unknown\\") == genre)"},{"question":"You are given an integer array `nums` where each element is unique and represents a node value in a binary search tree (BST). Construct the BST by inserting the values in the order they appear in `nums`, and then calculate the height of the BST. The height of a BST is the number of edges in the longest path from the root to any leaf. Return the height of the BST.","solution":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def calculate_height(root): if root is None: return -1 left_height = calculate_height(root.left) right_height = calculate_height(root.right) return max(left_height, right_height) + 1 def bst_height(nums): if not nums: return 0 root = None for num in nums: root = insert_into_bst(root, num) return calculate_height(root)"},{"question":"Given a `list` of integers `nums` and an integer `k`, return the maximum sum of a non-empty subsequence of `nums` that contains at most `k` distinct numbers. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Note that the subsequence does not need to be contiguous.","solution":"from collections import Counter def max_sum_subsequence(nums, k): Returns the maximum sum of a non-empty subsequence of nums that contains at most k distinct numbers. if k == 0: return 0 freq = Counter(nums) freq_sorted = sorted(freq.items(), key=lambda x: x[0], reverse=True) max_sum = 0 distinct_count = 0 for num, count in freq_sorted: if distinct_count < k: max_sum += num * count distinct_count += 1 else: break return max_sum"},{"question":"You are given an array of integers `nums` representing the numbers on a circular spinner, and an integer `target` representing a target value. The spinner can be spun in either direction (clockwise or counterclockwise) starting from any index. Return the minimum number of spins required to reach the `target` value starting from any index in the array. A spin is defined as moving from one index to an adjacent index in the array.","solution":"def min_spins_to_target(nums, target): Returns the minimum number of spins required to reach the target value starting from any index in the array. Args: nums (List[int]): An array of integers representing the numbers on a circular spinner. target (int): The target value to reach on the spinner. Returns: int: The minimum number of spins required. if target not in nums: return -1 n = len(nums) min_spins = float(\'inf\') for i in range(n): if nums[i] == target: min_spins = min(min_spins, i, n - i) return min_spins"},{"question":"You are given an integer array `nums` representing the number of apples in different baskets. You can perform the following operation at most once: pick any two different baskets and swap the number of apples between them. Your task is to determine the maximum number of apples you can have in any one basket after performing the operation at most once. Return the maximum number of apples in a single basket after performing the swap operation.","solution":"def max_apples_after_swap(nums): Returns the maximum number of apples in any one basket after performing at most one swap operation. Parameters: - nums: List[int], a list of integers representing the number of apples in different baskets. Returns: - int: The maximum number of apples in a single basket after the swap. if not nums or len(nums) == 1: return nums[0] if nums else 0 max_apples = max(nums) for i in range(len(nums)): for j in range(i + 1, len(nums)): # Swap baskets i and j nums[i], nums[j] = nums[j], nums[i] max_after_swap = max(nums) max_apples = max(max_apples, max_after_swap) # Swap back nums[i], nums[j] = nums[j], nums[i] return max_apples"},{"question":"Implement a class `LFUCache` that models a Least Frequently Used (LFU) cache. The `LFUCache` should have the following methods: 1. `LFUCache(capacity)`: Initializes the `LFUCache` object with the provided capacity. 2. `get(key)`: Retrieves the value associated with the given key from the cache. If the key does not exist, return -1. 3. `put(key, value)`: Inserts a new key-value pair into the cache. If the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting the new key-value pair. If there is a tie (multiple keys with the same frequency), the least recently used key should be removed. The `LFUCache` should operate with an optimal time complexity regarding its operations to handle real-time data efficiently.","solution":"from collections import defaultdict, OrderedDict class LFUCache: def __init__(self, capacity): Initializes the LFUCache object with the provided capacity. self.capacity = capacity self.minFreq = 0 self.key_to_val = {} self.key_to_freq = defaultdict(int) self.freq_to_keys = defaultdict(OrderedDict) def _update(self, key, value=None): Internal function to update key frequency and value. freq = self.key_to_freq[key] # Remove key from old freq list del self.freq_to_keys[freq][key] if not self.freq_to_keys[freq]: del self.freq_to_keys[freq] if freq == self.minFreq: self.minFreq += 1 # Add key to new freq list new_freq = freq + 1 self.freq_to_keys[new_freq][key] = value if value is not None else self.key_to_val[key] self.key_to_freq[key] = new_freq # Update key_to_val with new value if provided if value is not None: self.key_to_val[key] = value def get(self, key): Retrieves the value associated with the given key from the cache. If the key does not exist, return -1. if key not in self.key_to_val: return -1 self._update(key) return self.key_to_val[key] def put(self, key, value): Inserts a new key-value pair into the cache. If the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting the new key-value pair. if self.capacity == 0: return if key in self.key_to_val: self._update(key, value) return if len(self.key_to_val) >= self.capacity: # Evict the least frequently used key evict_key, _ = self.freq_to_keys[self.minFreq].popitem(last=False) if not self.freq_to_keys[self.minFreq]: del self.freq_to_keys[self.minFreq] del self.key_to_val[evict_key] del self.key_to_freq[evict_key] # Insert the new key self.key_to_val[key] = value self.key_to_freq[key] = 1 self.freq_to_keys[1][key] = value self.minFreq = 1"},{"question":"You are given a list of integers `arr`. You need to find two disjoint subarrays of `arr` such that the sum of the elements in each subarray is equal. Return `true` if such subarrays exist, otherwise return `false`. Note that the subarrays should be non-overlapping and should contain at least one element each.","solution":"def find_disjoint_subarrays_with_equal_sum(arr): Checks if there are two disjoint subarrays with equal sum in the list \'arr\'. n = len(arr) if n < 2: return False prefix_sum = {} current_sum = 0 for i in range(n): current_sum += arr[i] # If current_sum already exists in prefix_sum, it means there are subarrays that can sum to the same value. if current_sum in prefix_sum: return True # Store the sum up to the current index prefix_sum[current_sum] = i # At the end of the loop, check if there is any prefix sum that can be split into two parts resulting in the same sum. total_sum = current_sum current_sum = 0 for i in range(n): current_sum += arr[i] remaining_sum = total_sum - current_sum if remaining_sum in prefix_sum and prefix_sum[remaining_sum] > i: return True return False"},{"question":"Consider a `linked list` where each node contains a single digit and the digits are stored in reverse order. This means that the 1\'s digit is at the head of the list. Write a function to add two such numbers and return the sum as a linked list in the same reverse order format. The provided linked lists could have different lengths. Create the result linked list by traversing both input lists and handling any remaining carry from the addition. Example: Input: list1: 2 -> 4 -> 3 list2: 5 -> 6 -> 4 Output: result: 7 -> 0 -> 8 Explanation: 342 + 465 = 807 (stored in reverse order as 7 -> 0 -> 8)","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): dummy_head = ListNode() current = dummy_head carry = 0 while l1 is not None or l2 is not None or carry: val1 = l1.val if l1 is not None else 0 val2 = l2.val if l2 is not None else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next return dummy_head.next"},{"question":"You are given an integer array `heights` representing the heights of buildings along a street, where `heights[i]` denotes the height of the `i-th` building. A building `i` is considered to have a **nice view** if for all buildings to its right, none of them are equal to or taller than `heights[i]`. Write a function that returns an array of indices of buildings that have a **nice view** in the order from left to right. Implement a solution that efficiently finds the indices of buildings with a nice view.","solution":"def buildings_with_nice_view(heights): Returns indices of buildings that have a nice view. A building has a nice view if there are no buildings to the right that are equal to or taller than the current building. n = len(heights) result = [] max_height = -1 # Initialize with a height lower than the minimum possible height for i in range(n-1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"Design a data structure that simulates a **stack** with the following operations in average O(1) time: * `void push(int x)` - Pushes element x onto the stack. * `int pop()` - Removes the element on top of the stack and returns it. * `int top()` - Returns the element on the top of the stack without removing it. * `int getMin()` - Returns the minimum element in the stack. Note: - You must implement the `StackWithMin` class in a way that ensures each operation is performed in average O(1) time complexity.","solution":"class StackWithMin: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() return top def top(self) -> int: if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def getMin(self) -> int: if not self.min_stack: raise IndexError(\\"getMin from empty stack\\") return self.min_stack[-1]"},{"question":"Given an array of integers `nums`, where `nums[i]` represents a different job\'s duration, and an integer `d` which represents the maximum number of days you have to complete all the jobs. Your goal is to minimize the maximum job duration that you need to work over the days. Return the minimum possible maximum job duration that can be achieved by optimally distributing the jobs over the given days.","solution":"from typing import List def is_valid(nums: List[int], days: int, max_job_duration: int) -> bool: day_count = 1 current_duration = 0 for num in nums: if current_duration + num > max_job_duration: day_count += 1 current_duration = 0 current_duration += num if day_count > days: return False return True def min_job_duration(nums: List[int], days: int) -> int: left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if is_valid(nums, days, mid): right = mid else: left = mid + 1 return left"},{"question":"Given two strings `s` and `t`, return a list of all the start indices of `t`\'s anagrams in `s`. You may return the answer in **any order**. An Anagram is a rearrangement of the original letters to form a new word. For example, `\\"abc\\"` is an anagram of `\\"cba\\"`.","solution":"from collections import Counter def find_anagrams(s, t): Returns a list of all the start indices of t\'s anagrams in s. len_s, len_t = len(s), len(t) if len_s < len_t: return [] t_count = Counter(t) window_count = Counter(s[:len_t-1]) result = [] for i in range(len_t - 1, len_s): window_count[s[i]] += 1 start = i - len_t + 1 if window_count == t_count: result.append(start) window_count[s[start]] -= 1 if window_count[s[start]] == 0: del window_count[s[start]] return result"},{"question":"You are given a list of integers `nums` representing a poker hand, where each integer represents a poker card\'s value. The hand is considered **straight** if the five cards form a sequence of consecutive values. The ace (value of 1) can function as either the lowest card (1) or the highest card (14). Write a function to determine if the given hand is a straight or not. Return `true` if the hand is a straight, and `false` otherwise. The list `nums` will always have exactly 5 cards.","solution":"def is_straight_hand(nums): Determines if the given hand is a straight in poker. Parameters: nums (list of int): A list of 5 integers representing poker cards\' values. Returns: bool: True if the hand is a straight, False otherwise. nums.sort() for i in range(len(nums) - 1): if nums[i] + 1 != nums[i + 1]: return False return True"},{"question":"You are given two positive integer arrays `workers` and `tasks`, where `workers[i]` represents the maximum capacity of the `i-th` worker and `tasks[j]` represents the amount of effort required for the `j-th` task. Each worker can be assigned to at most one task. Return the maximum number of tasks that can be completed if a worker can only be assigned a task that does not exceed their maximum capacity.","solution":"def max_tasks(workers, tasks): Returns the maximum number of tasks that can be completed given workers\' capacities and tasks\' efforts. workers.sort() tasks.sort() max_completed_tasks = 0 task_index = 0 for worker in workers: if task_index < len(tasks) and worker >= tasks[task_index]: max_completed_tasks += 1 task_index += 1 return max_completed_tasks"},{"question":"You are given a string `s` consisting of lowercase English letters, and a list of strings `dict` where each string is a distinct word in the dictionary. A string `s` is formed by concatenating one or more dictionary words from `dict` in any order, with each dictionary word appearing at most once in the concatenation. You are required to return the starting index of each substring in `s` which is a concatenation of all the words in `dict` exactly once, in any order. The returned indices should be in ascending order.","solution":"def find_substring(s, words): from collections import Counter if not s or not words: return [] word_len = len(words[0]) total_words = len(words) substring_len = word_len * total_words word_count = Counter(words) result_indices = [] for i in range(word_len): left = i right = i current_count = Counter() while right + word_len <= len(s): word = s[right:right + word_len] right += word_len if word in word_count: current_count[word] += 1 while current_count[word] > word_count[word]: current_count[s[left:left + word_len]] -= 1 left += word_len if right - left == substring_len: result_indices.append(left) else: current_count.clear() left = right return sorted(result_indices)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `target`. You need to design an algorithm that finds the **longest consecutive subarray** of `nums` such that the sum of its elements is less than or equal to `target`. Return the length of this subarray. If there is no such subarray, return `0`.","solution":"def longest_subarray(nums, target): Returns the length of the longest consecutive subarray such that the sum of its elements is less than or equal to target. Parameters: nums (list of int): The input array of integers. target (int): The target sum. Returns: int: Length of the longest subarray with sum <= target. n = len(nums) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum > target: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an array `arr` consisting of `n` integers. You need to perform a series of operations to make all elements in the array equal. In each operation, you can increment or decrement the value of an element by `1`. The goal is to perform the minimum number of operations to make all the elements equal. Implement a function `minOperationsToEqualElements(arr: List[int]) -> int` that takes the array `arr` and returns the minimum number of operations needed.","solution":"from typing import List def minOperationsToEqualElements(arr: List[int]) -> int: Returns the minimum number of operations needed to make all the elements in the array equal. if not arr: # If the array is empty return 0 arr.sort() median = arr[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"You are given a `word` as a string of lowercase English letters. Your task is to determine the number of unique substrings that can be formed from `word`. Two substrings are different if they start or end at different positions in the `word`, even if they consist of the same characters. Return the count of all unique substrings of `word`. Consider focusing on optimizing the time complexity to handle large inputs efficiently.","solution":"def count_unique_substrings(word): Returns the number of unique substrings that can be formed from the word. n = len(word) unique_substrings = set() # Generate all substrings and add them to a set to ensure uniqueness for i in range(n): for j in range(i + 1, n + 1): unique_substrings.add(word[i:j]) return len(unique_substrings)"},{"question":"You are given a binary string `s` consisting of only \'1\'s and \'0\'s. You can flip at most one \'0\' to \'1\' and you want to maximize the length of any subsequence of consecutive \'1\'s after performing at most one flip. Determine the maximum length of such a subsequence in the string. Return _the maximum length of consecutive \'1\'s possible after performing the flip (if any)._","solution":"def maximize_consecutive_ones(s): Returns the maximum length of consecutive \'1\'s possible after flipping at most one \'0\' to \'1\'. max_len = 0 left = 0 zero_count = 0 for right in range(len(s)): if s[right] == \'0\': zero_count += 1 while zero_count > 1: if s[left] == \'0\': zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a list of `n` integers where the `i-th` integer represents the number of points a participant scored in the `i-th` round of a competition. Design a function to determine the score that needs to be added to the lowest score(s) to match the highest score(s). Implement the `calculatePoints` function, which returns a list of integers representing the scores added to the lowest score(s). * `int[][] scores` - A list of integers representing the scores in each round. The function should output an array containing the points to be added to each of the lowest score(s) to match the highest score(s).","solution":"def calculatePoints(scores): Returns the points that need to be added to the lowest score(s) to match the highest score(s). if not scores: # In case of an empty list return [] max_score = max(scores) min_score = min(scores) return [max_score - min_score] * scores.count(min_score)"},{"question":"Given a string `s` consisting of lowercase alphabetic characters only, you have to find the longest substring of `s` that contains at most two distinct characters. Implement a function: ```python def longest_substring_with_two_distinct(s: str) -> str: # Your code here ``` Given a string `s`, return the longest substring that contains at most two distinct characters. If there are multiple such substrings of the same maximum length, return the one that appears first. For example, if the input is `s = \\"eceba\\"`, the output should be `\\"ece\\"` because the longest substring with at most two distinct characters is `\\"ece\\"`. If the input is `s = \\"ccaabbb\\"`, the output should be `\\"aabbb\\"`.","solution":"def longest_substring_with_two_distinct(s: str) -> str: Returns the longest substring containing at most two distinct characters. if len(s) == 0: return \\"\\" max_length = 0 max_substring = \\"\\" left = 0 char_count = {} for right in range(len(s)): if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if right - left + 1 > max_length: max_length = right - left + 1 max_substring = s[left:right+1] return max_substring"},{"question":"You are given a linked list where each node contains a single digit from 0 to 9. The digits are stored in reverse order, such that the head of the list represents the least significant digit. Write a function that takes in the head node of this linked list and returns the number it represents as an integer. For instance, if the linked list is (2 -> 4 -> 3), it represents the number 342, and your function should return 342. You may assume that the linked list does not contain leading zeroes except when the number itself is zero.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_to_number(head): Converts a linked list, where nodes contain digits stored in reverse order, to the corresponding integer. Parameters: head (ListNode): The head node of the linked list. Returns: int: The integer represented by the linked list. current = head number = 0 factor = 1 while current: number += current.val * factor factor *= 10 current = current.next return number"},{"question":"Given a list of n positive integers, find the **longest** subsequence such that the absolute difference between any two elements in the subsequence is equal to the difference between their respective indices in the original list. Return the length of this subsequence. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, [1,3,5] is a subsequence of [1,2,3,4,5] while [1,5,2] is not.","solution":"def longest_constrained_subsequence(arr): Function to find the longest subsequence such that the absolute difference between any two elements is equal to the difference between their respective indices. n = len(arr) if n == 0: return 0 dp = [1] * n # dp[i] will store the length of the longest valid subsequence ending at index i for i in range(n): for j in range(i): if abs(arr[i] - arr[j]) == i - j: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a linked list where each node contains an integer value. Find the first node of the linked list that forms the beginning of a cycle, if it exists. If the linked list does not contain a cycle, return `null`. A cycle is defined as a sequence of nodes starting from some node and ending back at the same node. You are expected to implement this function with space complexity of O(1).","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the node where the cycle begins in a linked list. If no cycle, returns None. :param head: The head node of the linked list. :return: The node where the cycle begins, or None if no cycle exists. if not head or not head.next: return None slow = head fast = head # Step 1: Determine whether a cycle exists using Floyd\'s Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # If we\'re here, it means no cycle was detected return None # Step 2: Find the start node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"In a game, you are given a `n x m` grid representing the game\'s playing field. Each cell in the grid can be either empty (denoted by \'.\') or occupied by an obstacle (denoted by \'#\'). Players can move from one cell to another if the destination cell is within the grid bounds and is empty. The possible movements are one cell up, down, left, or right. Given the starting position of the player as `(startX, startY)` and the ending position as `(endX, endY)`, determine the minimum number of moves required for the player to reach the ending position from the starting position. If it is not possible to reach the ending position, return `-1`. Write a function `minMoves(grid, startX, startY, endX, endY)` that takes in the grid, the starting position, and the ending position as inputs and returns an integer representing the minimum number of moves or `-1` if the destination is not reachable.","solution":"from collections import deque def minMoves(grid, startX, startY, endX, endY): Determine the minimum number of moves required for the player to reach the ending position from the starting position. rows, cols = len(grid), len(grid[0]) if grid[startX][startY] == \'#\' or grid[endX][endY] == \'#\': return -1 # Directions for up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue with the starting position queue = deque([(startX, startY, 0)]) # (currentX, currentY, currentMoves) visited = set((startX, startY)) while queue: curX, curY, curMoves = queue.popleft() if curX == endX and curY == endY: return curMoves for direction in directions: nextX, nextY = curX + direction[0], curY + direction[1] if 0 <= nextX < rows and 0 <= nextY < cols and (nextX, nextY) not in visited and grid[nextX][nextY] == \'.\': visited.add((nextX, nextY)) queue.append((nextX, nextY, curMoves + 1)) return -1 # If the end position is not reachable"},{"question":"There is a two-dimensional grid `m x n` representing an incomplete Sudoku puzzle, where a cell can contain a digit from `1` to `9` or be empty (represented by `\'.\'`). The goal is to fill the empty cells such that each row, each column, and each of the nine `3 x 3` sub-boxes contains all of the digits from `1` to `9` exactly once. Write a function `solveSudoku` that takes a grid and solves the Sudoku puzzle in-place. The given input will have at least one valid solution.","solution":"def solveSudoku(board): Solves the Sudoku puzzle in-place. def isValid(board, row, col, num): for x in range(9): if board[row][x] == num: return False if board[x][col] == num: return False if board[3 * (row // 3) + x // 3][3 * (col // 3) + x % 3] == num: return False return True def solve(board): for i in range(9): for j in range(9): if board[i][j] == \'.\': for num in \'123456789\': if isValid(board, i, j, num): board[i][j] = num if solve(board): return True board[i][j] = \'.\' return False return True solve(board) # Helper to create deep copies of boards for testing purposes import copy"},{"question":"You are given a list of integers `nums` representing a sequence of steps you can take on a ladder. Each integer represents the maximum number of steps you can move forward from that position. Your goal is to determine the minimum number of jumps required to reach the top of the ladder (end of the list). If reaching the top is not possible, return `-1`. For example, given the list `[2, 3, 1, 1, 4]`, the minimum number of jumps to reach the end is `2` (i.e., 2 -> 3 -> 4).","solution":"def min_jumps(nums): Returns the minimum number of jumps required to reach the top of the ladder. If reaching the top is not possible, returns -1. if not nums or len(nums) == 1: return 0 jumps = 0 curr_end = 0 curr_farthest = 0 for i in range(len(nums) - 1): curr_farthest = max(curr_farthest, i + nums[i]) if i == curr_end: jumps += 1 curr_end = curr_farthest if curr_end >= len(nums) - 1: return jumps return -1"},{"question":"An organization hosts a tournament with `n` participants. Each participant can compete against every other participant exactly once. You are given a 2D integer array `matches` where `matches[i] = [winner, loser]` denotes that the participant `winner` won against the participant `loser`. Each participant\'s skill level is a value between 0 and 100, which is unique to each individual. Your task is to determine the participant with the highest skill level who has not lost any match. Return the skill level of the participant who remained undefeated for the entire tournament. If no such participant exists, return `-1`.","solution":"def find_undefeated_participant(matches, skill_levels): Returns the skill level of the participant who remained undefeated for the entire tournament. :param matches: List of lists, where each list contains two elements [winner, loser] :param skill_levels: Dictionary where key is the participant and value is their skill level :return: Skill level of the undefeated participant, or -1 if no such participant exists defeated = set() for match in matches: winner, loser = match defeated.add(loser) undefeated = None highest_skill_level = -1 for participant, skill_level in skill_levels.items(): if participant not in defeated: if skill_level > highest_skill_level: highest_skill_level = skill_level undefeated = participant return highest_skill_level if undefeated is not None else -1"},{"question":"You are given an integer `x` which represents the total number of units you need to climb to reach the top floor of a building. You can take stairs, with a single step covering 1 unit and costing 1 energy unit, or take an elevator, which can instantly cover any desired units but costs k energy units (where `k` is a given integer). Determine the minimum energy required to reach exactly `x` units, given the options of taking stairs or the elevator. Note that once you use the elevator, you cannot use it again. Return the minimum energy required to climb to the top floor.","solution":"def min_energy_to_reach_top(x, k): Returns the minimum energy required to reach exactly x units. Parameters: x (int): Total number of units to reach the top floor k (int): Energy units required to use the elevator Returns: int: Minimum energy required # If taking stairs all the way is cheaper or x is less than k if x <= k: return x else: return min(x, k)"},{"question":"You have a list of `stockPrices` for a company\'s stock measured sequentially over `n` days, where `stockPrices[i]` represents the price of the stock on the `i-th` day. You would like to determine the best day to buy one stock and a different day to sell that same stock to maximize your profit. Return _the **maximum profit** you can achieve from this transaction_. If no profit can be achieved, return `0`. Note that you must buy the stock before you can sell it, and you are only allowed to complete one transaction (i.e., buy one and sell one).","solution":"def maxProfit(stockPrices): Returns the maximum profit that can be achieved from a single buy and sell transaction if not stockPrices or len(stockPrices) < 2: return 0 min_price = stockPrices[0] max_profit = 0 for price in stockPrices[1:]: current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit if price < min_price: min_price = price return max_profit"},{"question":"Given a string `s`, return the longest palindromic subsequence in `s`. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, given the string `s = \\"bbbab\\"`, the longest palindromic subsequence is `\\"bbbb\\"`, which has a length of 4. Write an efficient algorithm to find this longest palindromic subsequence.","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"You are given `n` events represented as an array of intervals `events`, where `events[i] = [start_i, end_i]` represents the start and end time of the `i-th` event. Find the maximum number of non-overlapping intervals (events) that you can attend. Events `[start_a, end_a]` and `[start_b, end_b]` are considered overlapping if `start_a < end_b` and `start_b < end_a`. Return the maximum number of non-overlapping intervals you can attend.","solution":"def max_non_overlapping_intervals(events): Finds the maximum number of non-overlapping intervals. Parameters: events (List[List[int]]): A list of intervals represented by [start, end]. Returns: int: The maximum number of non-overlapping intervals. # Sort the events by their end times events.sort(key=lambda x: x[1]) count = 0 end_time = float(\'-inf\') for start, end in events: if start >= end_time: count += 1 end_time = end return count"},{"question":"Given a 2D grid of size `m x n` representing a map where each cell can be `0` (empty) or `1` (obstacle), find the shortest path from the top-left corner (grid[0][0]) to the bottom-right corner (grid[m-1][n-1]) through empty cells. You can only move up, down, left, or right. Return the length of the shortest path. If there is no valid path, return -1.","solution":"from collections import deque def shortest_path(grid): if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, distance = queue.popleft() if x == m-1 and y == n-1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1"},{"question":"You are given an integer array `arr` and a positive integer `d`. An element `arr[i]` can jump to `arr[i + k]` if `0 < k <= d` and `arr[i + k] < arr[i]`, or `arr[i - k]` if `0 < k <= d` and `arr[i - k] < arr[i]` if the destination index is within bounds. The step from `i` to `i + k` or `i - k` is considered a \\"jump\\". Find the maximum number of indices visited starting from any index. The element itself counts as a visit. Return the maximum number of jumps you can make starting from any index in `arr`.","solution":"def max_jumps(arr, d): Returns the maximum number of indices visited starting from any index in array `arr` with jump distance `d`. Args: arr (List[int]): The array of integers. d (int): The maximum jump distance. Returns: int: The maximum number of indices visited. n = len(arr) dp = [-1] * n # dp array to store the maximum jumps from each index def dfs(i): if dp[i] != -1: return dp[i] max_steps = 1 # At least the position itself is visited # Check all positions right from i within d range for k in range(1, d + 1): if i + k < n and arr[i + k] < arr[i]: max_steps = max(max_steps, 1 + dfs(i + k)) else: break # Since further right positions will be greater or equal # Check all positions left from i within d range for k in range(1, d + 1): if i - k >= 0 and arr[i - k] < arr[i]: max_steps = max(max_steps, 1 + dfs(i - k)) else: break # Since further left positions will be greater or equal dp[i] = max_steps return dp[i] max_result = 0 for i in range(n): max_result = max(max_result, dfs(i)) return max_result"},{"question":"Given an array of integers `arr` and an integer `difference`, return the length of the longest subsequence in the array that forms an arithmetic sequence with the given difference. An arithmetic sequence is a sequence of numbers such that the difference between consecutive terms is constant. For example, if `arr = [1, 2, 3, 4]` and `difference = 1`, the longest arithmetic subsequence would be `[1, 2, 3, 4]` with length `4`, as the difference between each consecutive term is `1`.","solution":"def longest_subsequence_with_difference(arr, difference): Returns the length of the longest subsequence in the array that forms an arithmetic sequence with the given difference. dp = {} max_length = 0 for num in arr: if num - difference in dp: dp[num] = dp[num - difference] + 1 else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"Given a list of integers `nums`, you need to find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Implement a function that computes this in linear time complexity. **Example:** ``` Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. ``` Input: nums = [1] Output: 1 Explanation: As it contains a single element. Input: nums = [5,4,-1,7,8] Output: 23 Explanation: As it contains subarray with sum equal to 23.","solution":"def max_subarray_sum(nums): Finds the contiguous subarray within an array which has the largest sum and returns the sum. Parameters: nums (list of int): List of integers Returns: int: The sum of the maximum subarray if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given the root of a binary search tree (BST) and an integer target. You need to find the k values in the BST that are closest to the target. The result should be returned in a list of integers, sorted in ascending order. If there are ties, the smaller values should be preferred. To implement this, you should design the algorithm as follows: 1. Implement the `Solution` class, which initializes with the root of the BST. 2. Implement the `kClosestValues` function, which accepts an integer target and integer k, and returns a list of k closest values to the target in ascending order. The BST node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your implementation should efficiently handle potentially large BSTs and values of k.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def __init__(self, root): self.root = root def kClosestValues(self, target, k): import heapq self.heap = [] def inorder(node): if not node: return inorder(node.left) diff = abs(node.val - target) heapq.heappush(self.heap, (-diff, node.val)) if len(self.heap) > k: heapq.heappop(self.heap) inorder(node.right) inorder(self.root) return sorted(val for _, val in self.heap)"},{"question":"There is a warehouse organized as a grid, represented by a `m x n` integer matrix `warehouse`. Each cell in the grid contains a certain number of boxes. You are also given a **0-indexed** 2D integer array `requests` where `requests[i] = [x1, y1, x2, y2]` denotes that you want to move all the boxes from cell `(x1, y1)` to cell `(x2, y2)`. When moving boxes from one cell to another, the number of boxes in the target cell increases by the number of boxes moved, while the number of boxes in the source cell becomes zero. Calculate the state of the warehouse after all the requests have been performed. Return the final state of the warehouse as a `m x n` matrix.","solution":"def execute_requests(warehouse, requests): Modifies the warehouse based on the requests to move boxes. Args: warehouse (list of list of int): The initial state of the warehouse. requests (list of list of int): The list of requests to move boxes. Returns: list of list of int: The final state of the warehouse. for request in requests: x1, y1, x2, y2 = request box_count = warehouse[x1][y1] warehouse[x2][y2] += box_count warehouse[x1][y1] = 0 return warehouse"},{"question":"You are given a string `s` consisting of only the characters \'a\' and \'b\'. You are allowed to perform exactly one move where you can select any two adjacent characters and swap them. Return the length of the longest substring consisting of only \'a\'s or only \'b\'s that can be achieved after performing exactly one swap. For example, given the string `s = \\"baab\\"`, swapping the first and second characters results in the string `\\"abab\\"`, and the longest substring of identical characters (\'a\' or \'b\') in this new string is of length 2. Therefore, the output for this example would be 2.","solution":"def longest_substring_after_one_swap(s): def max_substring_length(s, c): n = len(s) cnt = s.count(c) max_len, curr_len = 0, 0 for i in range(n): if s[i] == c: curr_len += 1 else: max_len = max(max_len, curr_len + 1) curr_len = 0 return min(max(max_len, curr_len + 1), cnt) return max(max_substring_length(s, \'a\'), max_substring_length(s, \'b\'))"},{"question":"Given a `2D` array of integers `grid`, representing a gold mine, where `grid[i][j]` is the amount of gold in cell `(i, j)`. Your task is to find the maximum amount of gold you can accumulate starting from any cell in the grid and moving in the four possible directions (up, down, left, right). You can only move to a cell if it has gold and you cannot visit the same cell more than once. Return the maximum gold you can collect.","solution":"def get_maximum_gold(grid): rows = len(grid) cols = len(grid[0]) max_gold = 0 def dfs(row, col, current_gold): nonlocal max_gold if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0: return current_gold += grid[row][col] max_gold = max(max_gold, current_gold) original_gold = grid[row][col] grid[row][col] = 0 # mark as visited # Explore the four possible directions dfs(row + 1, col, current_gold) dfs(row - 1, col, current_gold) dfs(row, col + 1, current_gold) dfs(row, col - 1, current_gold) grid[row][col] = original_gold # unmark, backtracking for r in range(rows): for c in range(cols): if grid[r][c] != 0: dfs(r, c, 0) return max_gold"},{"question":"You are given a 2D grid of characters, where each cell in the grid represents a letter in the English alphabet. The grid is represented by a list of strings `grid`, where each string is a row of characters and all strings are of the same length. You are also given a target word `word`. You need to determine if the word exists in the grid following these rules: - The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. - The same letter cell may not be used more than once. Return `true` if the word exists in the grid, or `false` otherwise.","solution":"def exist(grid, word): def dfs(x, y, word_index): if word_index == len(word): return True if (x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] != word[word_index] or visited[x][y]): return False visited[x][y] = True # Explore neighbors in DFS manner has_path = (dfs(x + 1, y, word_index + 1) or dfs(x - 1, y, word_index + 1) or dfs(x, y + 1, word_index + 1) or dfs(x, y - 1, word_index + 1)) visited[x][y] = False return has_path if not grid: return False rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child. The **depth** of a node is the number of edges from the root to that node. A **balanced binary tree** is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than one. Given a binary tree, write a function `is_balanced(root)` to determine if it is height-balanced. A tree is considered height-balanced if for any given node in the tree, the height of its left subtree and right subtree differ by no more than one. The input to the function is the root of the binary tree, and the function should return a boolean value indicating whether the tree is balanced or not. For example, * Given the following binary tree: 3 / 9 20 / 15 7 The output should be `True`, because the tree is balanced. * Given the following binary tree: 1 / 2 2 / 3 3 / 4 4 The output should be `False`, because the height of the left subtree of the root exceeds the height of the right subtree by more than one.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine if a binary tree is height-balanced. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is balanced, False otherwise def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, balanced = check_balance(root) return balanced"},{"question":"You are given a rectangle represented by a 2D grid of integer values. Each cell in the grid can either have a value of `0` (representing empty) or a value of `1` (representing an obstacle). Starting from the top-left corner of the grid, you have to find the number of distinct paths you can take to reach the bottom-right corner. You can only move either down or right at any point in time, and you must avoid cells with obstacles. Write an algorithm to calculate the number of such distinct paths. Return the number of distinct paths if there is at least one valid path, and `0` if no valid paths exist.","solution":"def unique_paths_with_obstacles(obstacle_grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid that avoid obstacles. obstacle_grid: 2D list of integers (0 represents empty cell, 1 represents obstacle) if not obstacle_grid or obstacle_grid[0][0] == 1: return 0 m, n = len(obstacle_grid), len(obstacle_grid[0]) dp = [[0] * n for _ in range(m)] # Initialize the starting position if there\'s no obstacle dp[0][0] = 1 - obstacle_grid[0][0] # Fill the first row for j in range(1, n): if obstacle_grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Fill the first column for i in range(1, m): if obstacle_grid[i][0] == 0: dp[i][0] = dp[i-1][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): if obstacle_grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given an array of integers `arr`. Your task is to implement the function `findNumberOfLIS`, which returns the number of **longest increasing subsequences** in the array. An increasing subsequence is a subsequence that appears in the same order as the original array and each element of the subsequence is larger than its predecessor. Two subsequences are considered different if they have different sets of indices, even if the subsequences themselves are identical. If there are multiple longest increasing subsequences, count all of them.","solution":"def findNumberOfLIS(nums): if not nums: return 0 n = len(nums) lengths = [0] * n counts = [0] * n for i in range(n): lengths[i] = 1 counts[i] = 1 for j in range(i): if nums[j] < nums[i]: if lengths[j] + 1 > lengths[i]: lengths[i] = lengths[j] + 1 counts[i] = counts[j] elif lengths[j] + 1 == lengths[i]: counts[i] += counts[j] longest = max(lengths) return sum(c for i, c in enumerate(counts) if lengths[i] == longest)"},{"question":"Given a string `s` containing only lowercase English letters and a list of words `words`, determine the number of words in the list that are subsequences of the string `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Implement the function `numMatchingSubseq(string s, vector<string>& words)` which returns the number of words that are subsequences of `s`.","solution":"def numMatchingSubseq(s, words): def is_subsequence(x, y): it = iter(y) return all(char in it for char in x) return sum(is_subsequence(word, s) for word in words)"},{"question":"You are given an array of integers `nums` where each element appears exactly three times, except for one element which appears exactly once. Find and return the element that appears only once in `O(n)` time complexity and without using extra memory.","solution":"def singleNumber(nums): Finds the element that appears exactly once in an array where every other element appears three times. Args: nums (List[int]): The list of integers. Returns: int: The single integer that appears once. one, two = 0, 0 for num in nums: one = (one ^ num) & ~two two = (two ^ num) & ~one return one"},{"question":"Write a function that receives a list of strings `strs` and an integer `k`. The function should return the `k` most common words in the list, sorted by their occurrence in descending order. If two words have the same frequency, they should be sorted lexicographically in ascending order. Assume `1 <= k <= number of unique words in strs`. For words with the same frequency, sort by lexicographical order.","solution":"from collections import Counter def top_k_frequent_words(strs, k): Returns the k most frequent words from the list of strings. Args: strs (list): List of strings. k (int): Number of top frequent words to return. Returns: list: List of k most frequent words sorted by frequency and lexicographical order. count = Counter(strs) sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0])) return [word for word, freq in sorted_words[:k]]"},{"question":"You are given an array `houses` and an integer `heaters`. Each element in `houses` represents the position of a house along a street, and each element in `heaters` represents the position of a heater along the street. Both arrays are sorted in ascending order. Every house can only be warmed by the nearest heater. Return the minimum radius `r` such that all houses can be covered by at least one heater. The radius `r` of a heater positioned at `heaters[i]` means the heater can warm any house positioned within `heaters[i] - r` to `heaters[i] + r`.","solution":"def find_closest_heater(house, heaters): Returns the minimum distance from the house to the nearest heater using binary search. left, right = 0, len(heaters) - 1 while left < right: mid = (left + right) // 2 if heaters[mid] < house: left = mid + 1 else: right = mid return left def find_min_radius(houses, heaters): Returns the minimum radius `r` such that all houses can be covered by at least one heater. # Sort houses and heaters (they are assumed sorted but we ensure it) houses.sort() heaters.sort() min_radius = 0 for house in houses: # Find the nearest heater index = find_closest_heater(house, heaters) # Calculate distances to the possible nearest heaters dist1 = abs(house - heaters[index]) dist2 = float(\'inf\') if index > 0: dist2 = abs(house - heaters[index - 1]) # Choose the minimum distance nearest_heater_dist = min(dist1, dist2) # Update the minimum radius required min_radius = max(min_radius, nearest_heater_dist) return min_radius"},{"question":"You are given a binary tree where each node has a value `0` or `1`. Each root-to-leaf path in the tree represents a binary number starting with the most significant bit. For example, if a path from the root to a leaf is `1 -> 0 -> 1`, this represents the binary number `101` (which is `5` in decimal). Return _the sum of all the numbers represented by the root-to-leaf paths_ in the tree. The binary tree is represented using level-order traversal where `null` signifies a path terminator where no node exists below. Example: **Input:** ``` [1,0,1,0,1,0,1] ``` **Explanation:** ``` The given tree equals to: 1 / 0 1 / / 0 1 0 1 Paths: 1 -> 0 -> 0 (binary 100 = 4) 1 -> 0 -> 1 (binary 101 = 5) 1 -> 1 -> 0 (binary 110 = 6) 1 -> 1 -> 1 (binary 111 = 7) Sum = 4 + 5 + 6 + 7 = 22 ``` **Output:** `22`","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: def dfs(node, current_path): if not node: return 0 current_path = (current_path << 1) | node.val if not node.left and not node.right: return current_path return dfs(node.left, current_path) + dfs(node.right, current_path) return dfs(root, 0)"},{"question":"You are given an integer array `nums` of length `n`. You are allowed to permute `nums` into a new sequence `arr`. A permutation of `nums` is considered **valid** if for every `i` (1 <= `i` <= n/2), the sum of `arr[i]` and `arr[n-i+1]` is the same. Return `true` if there exists at least one valid permutation of `nums`, otherwise, return `false`.","solution":"from itertools import permutations def has_valid_permutation(nums): Returns if there exists a valid permutation of nums where for every i (1 <= i <= n/2), the sum of arr[i] and arr[n-i+1] is the same. n = len(nums) # Check all permutations of nums for perm in permutations(nums): # Check if the permutation is valid valid = True sum_val = perm[0] + perm[-1] for i in range(1, n//2 + 1): if perm[i-1] + perm[-i] != sum_val: valid = False break if valid: return True return False"},{"question":"Given an array of `n` integers, return the length of the longest subsequence where the difference between adjacent elements is either `+1` or `-1`. A subsequence is a sequence derived by deleting some or no elements of the array without changing the order of the remaining elements. Note that the elements in the subsequence must be contiguous in terms of their original position in the array.","solution":"def longest_subsequence(arr): Returns the length of the longest subsequence where the difference between adjacent elements is either +1 or -1. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Implement a **Reading Tracker** system that allows users to keep track of their reading progress in different books. Each user can add books to their reading list, update their progress, and get the current status of any book. Implement the `ReadingTracker` class: * `ReadingTracker()` Initializes the reading tracker system. * `void addBook(String userId, String bookId)` Adds a book with the given `bookId` to the reading list of the user with the given `userId`. If the user does not exist, they should be added to the system. * `void updateProgress(String userId, String bookId, int page)` Updates the reading progress of the book with `bookId` for the user with `userId` to the given page number. If the book does not exist in the user\'s reading list, it should be added first with the initial progress set to the given page number. * `int getProgress(String userId, String bookId)` Returns the current page number the user with `userId` is on for the book with `bookId`. If the book does not exist in the user\'s reading list, return `-1`. **Note:** Assume all `userId`s and `bookId`s are unique strings, and all page numbers are non-negative integers.","solution":"class ReadingTracker: def __init__(self): self.users = {} def addBook(self, userId, bookId): if userId not in self.users: self.users[userId] = {} self.users[userId][bookId] = 0 def updateProgress(self, userId, bookId, page): if userId not in self.users: self.users[userId] = {} self.users[userId][bookId] = page def getProgress(self, userId, bookId): if userId not in self.users: return -1 if bookId not in self.users[userId]: return -1 return self.users[userId][bookId]"},{"question":"Given a string `s` consisting of only characters \'a\', \'b\', and \'c\', you need to remove the minimum number of characters from the string so that no two consecutive characters are the same. Write a function to return the resulting string after removal of the necessary characters. If there are multiple valid results, return the one which comes first lexicographically.","solution":"def remove_min_chars(s): Removes the minimum number of characters from the string so that no two consecutive characters are the same. If there are multiple valid results, returns the one which comes first lexicographically. if not s: return \\"\\" result = [] previous_char = None for char in s: if char != previous_char: result.append(char) previous_char = char return \'\'.join(result)"},{"question":"You are given a 2D integer grid `grid` of size `m x n` and an integer `k`. Each cell in the grid has either a value of `0`, representing open space, or `1`, representing an obstacle. You are also given a starting point `(startRow, startCol)` and a goal point `(endRow, endCol)`. Your task is to determine if there is a path from the starting point to the goal point that can navigate through at most `k` obstacles. Return _`true` if such a path exists, otherwise return `false`._ You can move up, down, left, or right from a cell in the grid.","solution":"from collections import deque def is_path_possible(grid, k, startRow, startCol, endRow, endCol): Determine if there is a path from (startRow, startCol) to (endRow, endCol) navigating through at most `k` obstacles in the given grid. :param grid: List[List[int]] :param k: int :param startRow: int :param startCol: int :param endRow: int :param endCol: int :return: bool m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startRow, startCol, 0)]) # (row, col, obstacles) visited = set([(startRow, startCol, 0)]) while queue: row, col, obstacles = queue.popleft() # Check if we reached the goal if row == endRow and col == endCol: return True # Try all 4 possible directions for dr, dc in directions: newRow, newCol = row + dr, col + dc newObstacles = obstacles + grid[newRow][newCol] if 0 <= newRow < m and 0 <= newCol < n else obstacles if 0 <= newRow < m and 0 <= newCol < n and newObstacles <= k and (newRow, newCol, newObstacles) not in visited: visited.add((newRow, newCol, newObstacles)) queue.append((newRow, newCol, newObstacles)) return False"},{"question":"You are given a binary tree with `n` nodes where each node is assigned a unique integer value from `1` to `n`. Each node has a value `node.val` associated with it. You need to perform the following operations: 1. For each node, determine the sum of the values of all nodes in its subtree. 2. Return an array where the `ith` element represents the sum of the subtree values for the node with value `i`. A subtree of a node is defined as the node itself plus all its descendants.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def subtreeSums(root): def dfs(node): if not node: return 0 total_sum = node.val + dfs(node.left) + dfs(node.right) result[node.val - 1] = total_sum return total_sum if root is None: return [] # Determine number of nodes by finding max value in the tree def find_max_value(node): if not node: return float(\'-inf\') return max(node.val, find_max_value(node.left), find_max_value(node.right)) n = find_max_value(root) result = [0] * n dfs(root) return result"},{"question":"You are given a list of non-negative integers `arr` representing the amount of money of each house, and an integer `m` representing the number of houses you can rob at once. You cannot rob two consecutive houses and need to maximize the amount of money you can rob. Return _the maximum amount of money you can rob without robbing two consecutive houses._","solution":"def rob_houses(arr, m): Given a list of non-negative integers representing the amount of money of each house and an integer m representing the number of houses you can rob at once, returns the maximum amount of money you can rob without robbing two consecutive houses. n = len(arr) if n == 0: return 0 if n == 1: return arr[0] # Initialize dp array dp = [0] * (n + 1) dp[1] = arr[0] for i in range(2, n + 1): dp[i] = max(dp[i-1], dp[i-2] + arr[i-1]) return dp[n]"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings. Your task is to **rearrange** the buildings such that the **absolute difference** between the heights of any two adjacent buildings is **maximized**. Return _the rearranged array_. If there are multiple answers, return any of them.","solution":"def rearrange_buildings(heights): Rearrange the buildings such that the absolute difference between the heights of any two adjacent buildings is maximized. Parameters: heights (list of int): List of building heights. Returns: list of int: Rearranged list of building heights. heights.sort() rearranged = [] left, right = 0, len(heights) - 1 while left <= right: if left == right: rearranged.append(heights[left]) else: rearranged.append(heights[right]) rearranged.append(heights[left]) left += 1 right -= 1 return rearranged"},{"question":"Given an array of integers `nums`, you need to find the contiguous subarray (containing at least one number) which has the largest sum and return _that sum_. A **contiguous subarray** is a subset of array elements which are consecutive.","solution":"def max_subarray_sum(nums): Returns the largest sum of any contiguous subarray in nums. max_sum = float(\'-inf\') current_sum = 0 for num in nums: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` elements, where `n` is even. The array is called **well-balanced** if the sum of the even-indexed elements equals the sum of the odd-indexed elements. You are allowed to perform at most one swap between an even-indexed element and an odd-indexed element. Return _the maximum possible number of such swaps that can be performed on `nums` so that the array becomes **well-balanced**_. If the array is already well-balanced, return `0`.","solution":"def max_swaps_to_balance(nums): Returns the maximum possible number of swaps to make the array well-balanced. If already well-balanced, returns 0. # Calculate initial sums of even-indexed and odd-indexed elements sum_even = sum(nums[i] for i in range(0, len(nums), 2)) sum_odd = sum(nums[i] for i in range(1, len(nums), 2)) # If already well-balanced, return 0 if sum_even == sum_odd: return 0 # Calculate the difference diff = abs(sum_even - sum_odd) # Initialize the maximum number of swaps max_swaps = 0 # Iterate through possible swaps for i in range(0, len(nums), 2): for j in range(1, len(nums), 2): # Calculate new sums after a swap between nums[i] and nums[j] new_sum_even = sum_even - nums[i] + nums[j] new_sum_odd = sum_odd - nums[j] + nums[i] if new_sum_even == new_sum_odd: max_swaps = 1 break if max_swaps == 1: break return max_swaps"},{"question":"You are given two strings `s1` and `s2`, where `s1` represents a reference string and `s2` represents a target string. You may perform the following operations on `s2` any number of times: - Insert any single character. - Remove any single character. - Replace any single character with another character. Return the minimum number of operations required to transform `s2` into `s1`. **Note:** Both strings consist of lowercase English letters.","solution":"def minDistance(s1, s2): Return the minimum number of operations required to transform s2 into s1. len1, len2 = len(s1), len(s2) # Create a 2D array where dp[i][j] represents the edit distance between # s1 up to length i and s2 up to length j. dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Initialize the base cases for i in range(len1 + 1): dp[i][0] = i for j in range(len2 + 1): dp[0][j] = j # Fill the dp array for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation required else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Replacement return dp[len1][len2]"},{"question":"Given an array of integers `nums` and an integer `k`, where the array represents the number of books and each integer in the array represents the time required to read a book. You want to split the books into `k` contiguous subarrays (each subarray represents a set of books assigned to one reader) in such a way that the maximum reading time among all readers is minimized. Return the minimum possible maximum reading time in this arrangement.","solution":"def can_split(nums, k, max_time): current_sum = 0 required_splits = 1 for num in nums: if current_sum + num > max_time: required_splits += 1 current_sum = num if required_splits > k: return False else: current_sum += num return True def splitArray(nums, k): Returns the minimum possible maximum reading time to split the array into k subarrays. left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` consisting of lowercase letters. You need to group all the identical characters of `s` together while maintaining their original relative order. For example, given the string `\\"abacbc\\"`, you should return `\\"aabbcc\\"`. Your solution should be efficient enough to handle long input strings.","solution":"def group_identical_characters(s): from collections import defaultdict # Create a dictionary to store characters and their occurrences char_dict = defaultdict(list) # Iterate over the string and group characters for char in s: char_dict[char].append(char) # Combine the grouped characters maintaining their original order result = \'\'.join(\'\'.join(char_dict[char]) for char in sorted(char_dict.keys(), key=lambda x: s.index(x))) return result"},{"question":"You are given an integer array `sweets`, where `sweets[i]` represents the number of candies available at position `i`. There is a group of children who will collect candies by visiting these positions. Each child can start at any position and must collect candies from at least one position but can stop at any point. They can move in either direction (left or right). However, as they move, they cannot turn back and have to keep moving in the same direction until they decide to stop collecting. The task is to maximize the number of candies collected by a child. Return the maximum number of candies that can be collected by a single child from the given array.","solution":"def max_candies_collected(sweets): Returns the maximum number of candies that can be collected by a single child. n = len(sweets) if n == 0: return 0 max_candies = 0 # Calculating maximum candies collected moving right from each position right_candies = [0] * n right_candies[0] = sweets[0] for i in range(1, n): right_candies[i] = right_candies[i-1] + sweets[i] # Calculating maximum candies collected moving left from each position left_candies = [0] * n left_candies[n-1] = sweets[n-1] for i in range(n-2, -1, -1): left_candies[i] = left_candies[i+1] + sweets[i] for candies in right_candies + left_candies: if candies > max_candies: max_candies = candies return max_candies"},{"question":"Using the same style, complexity, and scope of the given sample questions, here is an additional question for the coding assessment: [Question 4]: Given a list of words and an integer `k`, return the `k` most frequent words. The answer should be sorted by frequency from highest to lowest. If multiple words have the same frequency, sort them by their lexicographical order. The function should return the list of `k` most frequent words in the specified order.","solution":"from collections import Counter def top_k_frequent(words, k): Returns the k most frequent words in the list sorted by frequency and lexicographical order. Args: words: List[str] - a list of words k: int - the number of most frequent words to return Returns: List[str] - the k most frequent words count = Counter(words) candidates = sorted(count.items(), key=lambda item: (-item[1], item[0])) return [word for word, freq in candidates[:k]]"},{"question":"Given an array of integers `nums`, partition it into **subarrays** such that each subarray is sorted in non-decreasing order. Find the minimum number of subarrays needed in any such partition. A subarray is a contiguous portion of the original array. Return the minimum number of **subarrays** needed.","solution":"def min_partitions(nums): Returns the minimum number of subarrays needed such that each subarray is sorted in non-decreasing order. if not nums: return 0 count = 1 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: count += 1 return count"},{"question":"Given a binary tree, find the longest path where each node in the path has the same value. This path may or may not pass through the root. The length of the path is the number of edges between the nodes in the path. You need to return the length of this longest path. The tree is represented as an array where each element corresponds to a node value, and the children are located at the array indices for left child as `2*i + 1` and the right child as `2*i + 2`. If a node doesn\'t have a child, it\'s represented by `None` or `null`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def array_to_tree(arr): if not arr: return None nodes = [None if val is None else TreeNode(val) for val in arr] kid = nodes[::-1] root = kid.pop() for node in nodes: if node: if kid: node.left = kid.pop() if kid: node.right = kid.pop() return root def longest_univalue_path(arr): if not arr: return 0 root = array_to_tree(arr) global_max = [0] def helper(node): if not node: return 0 left_length = helper(node.left) right_length = helper(node.right) left_path = right_path = 0 if node.left and node.left.val == node.val: left_path = left_length + 1 if node.right and node.right.val == node.val: right_path = right_length + 1 global_max[0] = max(global_max[0], left_path + right_path) return max(left_path, right_path) helper(root) return global_max[0]"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to remove `k` characters from the string such that the resulting string has the highest possible lexicographical value. Return the resulting string after removing `k` characters.","solution":"def remove_k_characters(s, k): Remove k characters from the string s to get the highest possible lexicographical value. Parameters: - s (str): string of lowercase letters. - k (int): number of characters to remove. Returns: - str: resulting string after removing k characters. stack = [] for char in s: while stack and k > 0 and stack[-1] < char: stack.pop() k -= 1 stack.append(char) # If k is still greater than 0 after the loop if k > 0: stack = stack[:-k] return \'\'.join(stack)"},{"question":"Given a string `s` containing only anglophone uppercase letters, return the length of the shortest palindrome that can be formed by appending characters to the end of `s`. **Note:** A palindrome is a word that reads the same backward as forward. For example, for `s = \\"ABC\\"`, the shortest palindrome that can be formed by appending characters is `\\"ABCBA\\"` with length `5`.","solution":"def shortest_palindrome(s): Returns the length of the shortest palindrome that can be formed by appending characters to the end of string s. :param s: input string containing only anglophone uppercase letters :return: length of the shortest palindrome if not s: return 0 rev_s = s[::-1] for i in range(len(s)): if s.startswith(rev_s[i:]): return len(s) + i return 2 * len(s) - 1 # In the worst case, we need to fully reverse and add (e.g., \\"AB\\" -> \\"ABBA\\") # Example usage: # result = shortest_palindrome(\\"ABC\\") # print(result) # Output: 5, because \\"ABCBA\\" is the shortest palindrome that can be formed"},{"question":"Given a directed graph represented as an adjacency list, write a function to determine if there is a cycle present in the graph. The function should return `true` if there is a cycle and `false` otherwise. To solve this problem, you can use Depth First Search (DFS) traversal.","solution":"def has_cycle(graph): Function to detect a cycle in a directed graph represented as an adjacency list. :param graph: A dictionary where the keys are nodes and the values are lists of neighboring nodes. :return: True if there is a cycle, False otherwise. def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if dfs(node): return True return False"},{"question":"Given a 2D grid of integers `grid` representing a boolean matrix, where `1` represents land and `0` represents water, you need to find the largest connected land mass (a region of `1`s) in terms of number of `1`s. You can move up, down, left, or right to connect to other `1`s. _Return the size of the largest connected land mass._","solution":"def largest_land_mass(grid): Computes the largest connected land mass in terms of number of \'1\'s in the grid. :param grid: List[List[int]]: 2D grid of integers representing the boolean matrix :return: int: size of the largest connected land mass if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(x, y): if x < 0 or y < 0 or x >= rows or y >= cols or grid[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True area = 1 area += dfs(x+1, y) area += dfs(x-1, y) area += dfs(x, y+1) area += dfs(x, y-1) return area largest_area = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1 and not visited[i][j]: largest_area = max(largest_area, dfs(i, j)) return largest_area"},{"question":"You are working on a text editor with a special feature to manage words. Each word can be selected and removed if necessary. The text editor supports the following operations: - `TextEditor()`: Initializes the text editor with an empty content. - `void addWord(String word)`: Adds a word to the end of the content. - `String removeWord()`: Removes the last added word from the content and returns it. If the content is empty, it returns an empty string. - `String getContent()`: Returns the current content as a single string, with the words separated by a single space. Implement the `TextEditor` class with the above functionalities.","solution":"class TextEditor: def __init__(self): self.content = [] def addWord(self, word): Adds a word to the end of the content. self.content.append(word) def removeWord(self): Removes the last added word from the content and returns it. If the content is empty, returns an empty string. if self.content: return self.content.pop() return \\"\\" def getContent(self): Returns the current content as a single string, with the words separated by a single space. return \\" \\".join(self.content)"},{"question":"You are given a 2D grid of integers `matrix` where each integer represents the height of a cell. The grid is guaranteed to have at least one cell. You want to calculate the largest square containing only 1\'s and return its area. Design a function to find the area of the largest square composed of 1\'s. Write a function `maximalSquare(matrix: List[List[int]]) -> int` that takes in a 2D list of integers `matrix` and returns the area of the largest square containing only 1\'s. Notice that the area is defined as the number of cells in the largest square, not the side length squared.","solution":"def maximalSquare(matrix): Returns the area of the largest square containing only 1\'s in the given 2D grid of integers. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] max_side = 0 for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i - 1][j - 1] == 1: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"Given an array of integers `nums` and an integer `x`, return _the minimum number of operations to reduce the sum of the array by exactly_ `x`. _An operation consists of removing an element from either the left or the right end of the array._ If it\'s not possible to reduce the sum by `x`, return -1.","solution":"def min_operations(nums, x): Returns the minimum number of operations to reduce the sum of the array by x. total_sum = sum(nums) target = total_sum - x if target < 0: return -1 max_len = -1 current_sum = 0 left = 0 for right in range(len(nums)): current_sum += nums[right] while current_sum > target and left <= right: current_sum -= nums[left] left += 1 if current_sum == target: max_len = max(max_len, right - left + 1) return len(nums) - max_len if max_len != -1 else -1"},{"question":"You are given two strings `s1` and `s2` of equal length. Determine if `s2` can be obtained by rotating `s1` by some number of positions. A rotation by `k` positions means shifting the characters of `s1` `k` positions to the left and moving the first `k` characters to the end of the string. For example, rotating `s1 = \\"abcdef\\"` by 2 positions results in `s1 = \\"cdefab\\"`. Return `true` if `s2` can be obtained by rotating `s1`, otherwise, return `false`.","solution":"def is_rotation(s1, s2): Returns True if s2 can be obtained by rotating s1, otherwise False. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"You are given a binary tree represented by its root node. Each node in the tree contains an integer value. Return the number of unique paths in the tree such that the product of the values in the path is **even**. A path in the tree is defined as a sequence of nodes starting from the root and ending at any node, moving only downward (i.e., from parent to child). Each path includes the root node and ends at either a leaf node or some intermediate node along the root-to-leaf route. Your function should consider only unique paths in terms of their node values sequence. Return the count of unique even-product paths in the tree. Since the answer may be very large, return it **modulo** `10^9 + 7`.","solution":"MOD = 10**9 + 7 class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def count_even_product_paths(root: TreeNode) -> int: def dfs(node, current_product): if not node: return 0 # Update the current product current_product *= node.val # Check if the current product is even is_even = current_product % 2 == 0 # Start counting from 0 count = 1 if is_even else 0 # Explore left and right subtrees if node.left: count += dfs(node.left, current_product) if node.right: count += dfs(node.right, current_product) # Return count modulo MOD at each point return count % MOD return dfs(root, 1)"},{"question":"You are given an integer array `weights` representing the weights of `n` items and an integer `maxCapacity` representing the maximum capacity of a knapsack. You want to pack the knapsack such that the total weight is as close as possible to the `maxCapacity` without exceeding it. Return the maximum weight that can be achieved by selecting some of the items in the array.","solution":"def knapsack(weights, maxCapacity): Returns the maximum weight that can be achieved without exceeding the maxCapacity. Parameters: weights (list of int): The list of item weights. maxCapacity (int): The maximum capacity of the knapsack. Returns: int: The maximum weight that can be achieved without exceeding the maxCapacity. n = len(weights) dp = [0] * (maxCapacity + 1) for i in range(n): for w in range(maxCapacity, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + weights[i]) return dp[maxCapacity]"},{"question":"You are given a `boolean` 2D grid, `grid`, of size `m x n`. Elements in the grid are either `0` (representing water) or `1` (representing land). An island is a group of `1`s (land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D grid. An island\'s area is the number of `1`s in the island. Return the maximum area of an island in `grid`.","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the given 2D grid. def dfs(r, c): if r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] == 0: return 0 grid[r][c] = 0 area = 1 area += dfs(r + 1, c) area += dfs(r - 1, c) area += dfs(r, c + 1) area += dfs(r, c - 1) return area max_area = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"You are given two strings `word1` and `word2` consisting of lowercase English letters. You can perform the following operation on either word any number of times: choose any character and delete it. Find the minimum number of operations required to make `word1` and `word2` anagrams of each other. Two strings are anagrams if they contain the same characters with the same frequency. Return the minimum number of deletion operations required to achieve this.","solution":"from collections import Counter def min_anagram_deletions(word1, word2): Returns the minimum number of deletions required to make word1 and word2 anagrams of each other. counter1 = Counter(word1) counter2 = Counter(word2) deletions = 0 # Calculate deletions for characters in word1 that are not in word2 or have different frequencies for char in counter1: if char in counter2: deletions += abs(counter1[char] - counter2[char]) else: deletions += counter1[char] # Calculate deletions for characters in word2 that are not in word1 for char in counter2: if char not in counter1: deletions += counter2[char] return deletions"},{"question":"You are given an array of integers `arr` and an integer `k`. Implement the `SubarraySumK` class that supports the following methods: - **SubarraySumK(int[] arr, int k)**: Initializes the class with the given array `arr` and integer `k`. - **int countSubarrays()**: Returns the count of contiguous subarrays whose sum is exactly `k`. For example, given the array `[1, 1, 1]` and `k = 2`, the contiguous subarrays that sum to `k` are `[1, 1]` and `[1, 1]`, so the count would be `2`. Note: Be sure to implement an efficient algorithm that can handle large arrays effectively.","solution":"class SubarraySumK: def __init__(self, arr, k): Initializes the class with the given array \'arr\' and integer \'k\'. self.arr = arr self.k = k def countSubarrays(self): Returns the count of contiguous subarrays whose sum is exactly \'k\'. count = 0 current_sum = 0 sum_dict = {0: 1} for num in self.arr: current_sum += num if current_sum - self.k in sum_dict: count += sum_dict[current_sum - self.k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"Implement a function that takes a string `s` and an integer `n`, which represents the length of substrings to consider. The function should return the number of distinct substrings of length `n` in `s`. A substring is a contiguous sequence of characters within the string. For example, given `s = \\"ababc\\"` and `n = 2`, the distinct substrings are `\\"ab\\"`, `\\"ba\\"`, and `\\"bc\\"`, so the function should return `3`. If `n` is greater than the length of the string `s`, the function should return `0`.","solution":"def count_distinct_substrings(s, n): Returns the number of distinct substrings of length `n` in the given string `s`. if n > len(s): return 0 substrings = set() # Using a set to keep track of unique substrings for i in range(len(s) - n + 1): substrings.add(s[i:i+n]) return len(substrings)"},{"question":"A company wants to interactively and efficiently manage their meeting rooms usage throughout the day. You need to implement an efficient system to solve this problem. There are `n` meeting rooms, and you have the following methods to implement: * `MeetingRooms(n: int)` Initializes the meeting rooms system with `n` available meeting rooms. * `bool book(int startTime, int endTime)` Checks if there is an available meeting room for the given time interval `[startTime, endTime)`, and if so, books a room and returns `true`; otherwise returns `false`. * `bool cancel(int startTime, int endTime)` Cancels a previously booked meeting for the given time interval `[startTime, endTime)`, freeing up the room and returning `true`; if there was no such booking, returns `false`. All time intervals are given in the format `[startTime, endTime)` where `startTime` and `endTime` are integers representing the start and end of the meeting time in hours (0 <= `startTime`, `endTime` <= 24). The start time is inclusive, and the end time is exclusive. Ensure that each method operates in a time-efficient manner, suitable for real-time interaction under potentially high-load conditions.","solution":"class MeetingRooms: def __init__(self, n: int): Initializes the meeting rooms system with n available meeting rooms. self.n = n self.bookings = [] def book(self, startTime: int, endTime: int) -> bool: Checks if there is an available meeting room for the given time interval [startTime, endTime), and if so, books a room and returns true; otherwise returns false. count = 0 for book in self.bookings: if max(book[0], startTime) < min(book[1], endTime): count += 1 if count < self.n: self.bookings.append((startTime, endTime)) return True return False def cancel(self, startTime: int, endTime: int) -> bool: Cancels a previously booked meeting for the given time interval [startTime, endTime), freeing up the room and returning true; if there was no such booking, returns false. if (startTime, endTime) in self.bookings: self.bookings.remove((startTime, endTime)) return True return False"},{"question":"You are given an array of strings `words` and an integer `k`. Each string in the array `words` consists of lowercase English letters. A string is called **k-anagram** of another string if you can form the second string by rearranging the characters of the first string, and each pair of strings `words[i]` and `words[j]` are **k-anagrams** if you require at most `k` swaps of any letter in `words[i]` to make it identical to `words[j]`. Find all pairs of indices `(i, j)` such that `words[i]` and `words[j]` are **k-anagrams** of each other. Return the list of pairs `(i, j)` **in lexicographical order** where `0 <= i < j < words.length`.","solution":"def are_k_anagrams(word1, word2, k): Determine if word1 can be transformed into word2 by at most k swaps. if len(word1) != len(word2): return False diff_count = 0 counter_word1 = [0] * 26 counter_word2 = [0] * 26 for i in range(len(word1)): counter_word1[ord(word1[i]) - ord(\'a\')] += 1 counter_word2[ord(word2[i]) - ord(\'a\')] += 1 # Counting the differences in characters for i in range(26): if counter_word1[i] != counter_word2[i]: diff_count += abs(counter_word1[i] - counter_word2[i]) # Total swaps needed = half of the total differences (since swap involves pairs) return diff_count // 2 <= k def k_anagram_pairs(words, k): pairs = [] n = len(words) for i in range(n): for j in range(i + 1, n): if are_k_anagrams(words[i], words[j], k): pairs.append((i, j)) return pairs"},{"question":"Given an array of integers `arr` of size `n`, implement a function to find and return the length of the longest **unique path** in a binary tree structured from the `arr` elements such that each node in this path has a unique value. Here, unique path means each node\'s value appears only once in the path (i.e., there are no repeating values). The binary tree is constructed in a level-order manner from the given array where `arr[0]` is the root, `arr[1]` and `arr[2]` are the children of the root, and so on. If the array is empty, return 0.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(arr): if not arr: return None nodes = [TreeNode(val) if val is not None else None for val in arr] root = nodes[0] child_index = 1 for node in nodes: if node: if child_index < len(arr): node.left = nodes[child_index] child_index += 1 if child_index < len(arr): node.right = nodes[child_index] child_index += 1 return root def longest_unique_path(root): def helper(node, seen): if not node or node.val in seen: return 0 seen.add(node.val) left = helper(node.left, seen) right = helper(node.right, seen) seen.remove(node.val) return 1 + max(left, right) if not root: return 0 return helper(root, set()) def longest_unique_path_from_array(arr): root = build_tree(arr) return longest_unique_path(root)"},{"question":"Given a linked list, a node **X** in the list is called a **pivotal node** if it has the same value as the median of all the node values in the list. Write a function to find the value of the pivotal node in the list. If there are two medians (i.e., the list has an even number of nodes), return the smaller value. Assume all node values are distinct and the list has at least one node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_pivotal_node_value(head): Returns the value of the pivotal node in the given linked list. # Step 1: Extract the values in the linked list into a list values = [] current = head while current: values.append(current.val) current = current.next # Step 2: Sort the values list values.sort() # Step 3: Find the median n = len(values) if n % 2 == 1: # If the list has an odd number of elements, the median is the middle element return values[n // 2] else: # If the list has an even number of elements, the median is the smaller of the two middle elements return values[(n // 2) - 1]"},{"question":"Consider an array of integers `nums` where each integer is between `1` and `n` (inclusive), where `n` is the length of the array. Some integers appear once, while others appear exactly twice. Your task is to return an array of all the integers that appear exactly twice. You must solve the problem without using extra space and in linear time complexity.","solution":"def find_duplicates(nums): Returns a list of all integers that appear exactly twice in the given list \'nums\'. The algorithm runs in linear time and uses constant extra space. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) else: nums[index] = -nums[index] return duplicates"},{"question":"You are given a list of non-negative integers representing the heights of vertical lines drawn on a 2D plane such that each pair of lines with the x-axis forms a container. Design an algorithm to find the maximum amount of water a container can store. The distance between the two lines and the x-axis calculate the area that the container can hold. You need to ensure that the container holds the maximum water possible.","solution":"def max_area(height): Given a list of non-negative integers representing the heights of vertical lines, this function calculates the maximum amount of water a container can store formed by these lines and the x-axis. left = 0 right = len(height) - 1 max_water = 0 while left < right: # Calculate the height and width of the container container_height = min(height[left], height[right]) container_width = right - left # Calculate the area of the container current_water = container_height * container_width # Update max_water if we found a larger container max_water = max(max_water, current_water) # Move the pointer for the shorter line inward if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a linked list where each node contains an integer value. Your task is to sort the linked list in ascending order using the merge sort algorithm. Return the head of the sorted linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head): if not head or not head.next: return head def split(head): slow = head fast = head.next while fast and fast.next: slow = slow.next fast = fast.next.next middle = slow.next slow.next = None return head, middle def merge(l1, l2): dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next def merge_sort(head): if not head or not head.next: return head left, right = split(head) left = merge_sort(left) right = merge_sort(right) return merge(left, right) return merge_sort(head)"},{"question":"You are given two non-negative integer arrays `nums1` and `nums2`, where `nums2` is a subset of `nums1`. For each element in `nums2`, find the next greater element in `nums1`. The next greater element of an element `x` in `nums1` is the first greater element to its right in `nums1`. If it does not exist, return -1 for this element. Construct an array `result` such that `result[i]` is the next greater element of `nums2[i]` in `nums1`. Return the `result` array.","solution":"def next_greater_element(nums1, nums2): Finds the next greater element for each element in nums2 within nums1. result = [] num_dict = {val: idx for idx, val in enumerate(nums1)} for num in nums2: found = False for i in range(num_dict[num] + 1, len(nums1)): if nums1[i] > num: result.append(nums1[i]) found = True break if not found: result.append(-1) return result"},{"question":"You are given a list of `points` where `points[i] = [xi, yi]` represents a point in a 2D plane. A sequence of points is called a **monotonic** path if either the x-coordinates or the y-coordinates of the points in the sequence are strictly increasing or strictly decreasing. Return _the length of the longest monotonic path_ that can be formed using the given points.","solution":"def longest_monotonic_path(points): Given a list of points in a 2D plane, return the length of the longest monotonic path. if not points: return 0 points.sort() def lis(sequence): Helper function to calculate the longest increasing subsequence. if not sequence: return 0 dp = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def lds(sequence): Helper function to calculate the longest decreasing subsequence. if not sequence: return 0 dp = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(i): if sequence[i] < sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) x_coords = [x for x, y in points] y_coords = [y for x, y in points] longest_increasing_x = lis(x_coords) longest_decreasing_x = lds(x_coords) longest_increasing_y = lis(y_coords) longest_decreasing_y = lds(y_coords) return max(longest_increasing_x, longest_decreasing_x, longest_increasing_y, longest_decreasing_y)"},{"question":"You are given a 2D integer grid `obstacleGrid` of dimensions `m x n`. Each cell in the grid contains either a `0` indicating that the cell is empty, or a `1` indicating that there is an obstacle in that cell. You are standing at the top-left corner of the grid (position `(0, 0)`) and need to reach the bottom-right corner of the grid (position `(m-1, n-1)`). You can only move either down or right at any point in time. Return _the number of distinct paths to reach the bottom-right corner of the grid from the top-left corner_. If there is no such path, return `0`.","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. Parameters: obstacleGrid (List[List[int]]): 2D grid with 0s for empty cells and 1s for obstacles. Returns: int: Number of unique paths. m = len(obstacleGrid) n = len(obstacleGrid[0]) # If starting or ending point is an obstacle, return 0 if obstacleGrid[0][0] == 1 or obstacleGrid[m-1][n-1] == 1: return 0 # Initialize the DP table with zeros dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 # Fill the DP table for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"Given a sorted array `arr` of integers, remove the duplicates in-place such that each element appears only once and returns the new length. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory.","solution":"def remove_duplicates(arr): Removes duplicates in-place in a sorted array such that each element appears only once. Returns the new length of the array. if not arr: return 0 write_index = 1 for i in range(1, len(arr)): if arr[i] != arr[write_index - 1]: arr[write_index] = arr[i] write_index += 1 return write_index"},{"question":"Given an `n x n` integer matrix `grid`, where each cell contains a contagiousness value, help Dr. Anna find the least infectious path from the top-left corner to the bottom-right corner. Dr. Anna can only move **right** or **down** at each step. The total contagiousness of a path is defined as the sum of the values of the cells along the path. Return the **minimum total contagiousness** value for any path from the top-left to the bottom-right. For example, given `grid = [[1,3,1],[1,5,1],[4,2,1]]`, the least infectious path would be `13111`, resulting in a sum of `7`.","solution":"def min_path_sum(grid): Returns the minimum total contagiousness value for any path from the top-left to the bottom-right. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize a dp array with the same dimensions as grid dp = [[0] * cols for _ in range(rows)] # Start at the top-left corner dp[0][0] = grid[0][0] # Fill the first row cumulative sum for col in range(1, cols): dp[0][col] = dp[0][col - 1] + grid[0][col] # Fill the first column cumulative sum for row in range(1, rows): dp[row][0] = dp[row - 1][0] + grid[row][0] # Fill the rest of the dp array for row in range(1, rows): for col in range(1, cols): dp[row][col] = grid[row][col] + min(dp[row - 1][col], dp[row][col - 1]) return dp[rows - 1][cols - 1]"},{"question":"Given a positive integer `n`, return the smallest positive integer that is a multiple of both `a` and `b`, where `a` and `b` are integers that satisfy the conditions `1 <= a, b <= n`. If there are no valid integers `a` and `b` such that `a != b`, return `-1`. Write a function `smallest_multiple` that takes in an integer `n` and returns the smallest multiple or `-1` as described.","solution":"from math import gcd def smallest_multiple(n): Returns the smallest positive integer that is a multiple of both `a` and `b`, where `a` and `b` are integers that satisfy the conditions `1 <= a, b <= n` and `a != b`. If there are no valid integers `a` and `b` such that `a != b`, returns -1. def lcm(x, y): return x * y // gcd(x, y) smallest = float(\'inf\') found = False for a in range(1, n + 1): for b in range(a + 1, n + 1): # No need to check b <= a found = True multiple = lcm(a, b) if multiple < smallest: smallest = multiple if found: return smallest else: return -1"},{"question":"You are given an integer array `nums` and an integer target `k`. The `nums` array represents a series of buildings, where `nums[i]` denotes the height of the `i-th` building. Your task is to determine the number of distinct pairs of buildings `(i, j)` such that: * `0 <= i < j < len(nums)` * The difference in height between `i-th` and `j-th` buildings is exactly `k`. For example, if `nums = [1, 5, 3, 4, 2]` and `k = 2`, the pairs that satisfy the conditions are `(0, 2), (1, 3), and (3, 4)`. Return the number of such valid pairs in the array.","solution":"def count_building_pairs(nums, k): Count the number of distinct pairs of buildings (i, j) such that: * 0 <= i < j < len(nums) * The difference in height between i-th and j-th buildings is exactly k Args: nums (List[int]): List of building heights k (int): Target difference in heights Returns: int: The number of valid pairs (i, j) # Initialize count of pairs count = 0 # Iterate over the array with two nested loops to find pairs for i in range(len(nums)): for j in range(i + 1, len(nums)): if abs(nums[i] - nums[j]) == k: count += 1 return count"},{"question":"Given a string `s` and an integer `x`, find the maximum length of a substring that contains at most `x` distinct characters. Return the length of this substring.","solution":"def max_length_substring_with_distinct_chars(s, x): Finds the maximum length of a substring that contains at most x distinct characters. Args: s (str): The input string. x (int): The maximum number of distinct characters allowed in the substring. Returns: int: The length of the longest substring with at most x distinct characters. n = len(s) if n == 0 or x == 0: return 0 char_count = {} left = 0 max_length = 0 for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > x: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `arr` and an integer `target`. Write a function to find the smallest contiguous subarray length such that the sum of the subarray is **greater than or equal to** `target`. If there is no such subarray, return `0`.","solution":"def min_subarray_len(arr, target): Finds the smallest contiguous subarray length such that the sum is at least target. If no such subarray exists, returns 0. :param arr: List of integers. :param target: Integer target sum. :return: Minimum length of a qualifying subarray or 0 if no such subarray exists. n = len(arr) min_length = float(\'inf\') start = 0 curr_sum = 0 for end in range(n): curr_sum += arr[end] while curr_sum >= target: min_length = min(min_length, end - start + 1) curr_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"Given an array of integers `nums`, you need to find the maximum product obtained by multiplying 3 numbers from the array. You must write a function `maxProductOfThree(nums)` that returns this maximum product. Note that the array may contain both positive and negative numbers.","solution":"def maxProductOfThree(nums): Returns the maximum product obtained by multiplying 3 numbers from the array. nums.sort() # Maximum product can be with the last three largest numbers # or two smallest (possibly the negatives) and the largest number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"Given an array of integers `nums` and an integer `target`, return _the number of **unique** combinations of numbers from the array that add up to `target`_. Each number in `nums` can be used an unlimited number of times in the combination. The combinations themselves must be presented as unique based on the numbers they contain, not the order of the elements. For example, given `nums = [2, 3, 6, 7]` and `target = 7`, the unique combinations are `[[2, 2, 3], [7]]`. Return the number 2.","solution":"from itertools import combinations_with_replacement def unique_combinations(nums, target): nums = sorted(set(nums)) # Remove duplicates and sort unique_combos = set() def find_combinations(comb, remainder, start): if remainder == 0: unique_combos.add(tuple(sorted(comb))) return if remainder < 0: return for i in range(start, len(nums)): find_combinations(comb + [nums[i]], remainder - nums[i], i) find_combinations([], target, 0) return len(unique_combos)"},{"question":"You are given a string `s` consisting only of the characters \'a\' and \'b\'. A substring is a contiguous sequence of characters within the string. Return the length of the longest substring containing only one unique character. For example, for the string \\"aaabbbaac\\", the longest substring with one unique character is \\"aaa\\", which has a length of 3.","solution":"def longest_unique_char_substring(s): Returns the length of the longest substring containing only one unique character. Parameters: s (str): The input string consisting only of the characters \'a\' and \'b\'. Returns: int: The length of the longest substring with one unique character. if not s: return 0 max_len = 1 current_len = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 return max(max_len, current_len)"},{"question":"You have an integer array `arr` of length `n` which consists of non-negative integers. Each element in the array represents the maximum jump length you can make from that position. Determine if you are able to reach the last index starting from the first index. Return `true` if you can reach the last index, or `false` otherwise. Formally, you can jump from index `i` to any index `j` such that `i < j = i + arr[i]` and `j < n`.","solution":"def can_jump(arr): Determines if it\'s possible to reach the last index of the array starting from the first index. Parameters: arr (list[int]): The input array of non-negative integers where each element represents the maximum jump length. Returns: bool: True if able to reach the last index, otherwise False. max_reachable = 0 n = len(arr) for i in range(n): if i > max_reachable: return False max_reachable = max(max_reachable, i + arr[i]) return max_reachable >= (n - 1)"},{"question":"You are given an array of integers `arr`. Your task is to determine if it is possible to split the array into two non-empty parts such that the sum of the elements in the first part is equal to the sum of the elements in the second part. If such a split is possible, return `true`, otherwise return `false`.","solution":"def can_split_equal_sum(arr): Determines if it is possible to split the array into two non-empty parts with equal sum. Parameters: arr (list): List of integers. Returns: bool: True if such a partition is possible, otherwise False. total_sum = sum(arr) if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 for num in arr: current_sum += num if current_sum == target_sum: return True return False"},{"question":"You are given an array of integers `arr` and an integer `k`. A **subarray** is a contiguous part of an array. The **average value** of a subarray is the sum of its elements divided by the number of elements in it. Your task is to find the **k-th** largest **average value** among all possible contiguous subarrays of `arr`. Return this average value. If the subarray is empty or `k` is greater than the number of subarrays, return 0.","solution":"def find_kth_largest_average(arr, k): This function returns the k-th largest average value among all possible contiguous subarrays of `arr`. If the subarray is empty or `k` is greater than the number of subarrays, return 0. if not arr or k <= 0: return 0 n = len(arr) subarray_averages = [] for i in range(n): current_sum = 0 for j in range(i, n): current_sum += arr[j] current_length = j - i + 1 average = current_sum / current_length subarray_averages.append(average) if k > len(subarray_averages): return 0 subarray_averages.sort(reverse=True) return subarray_averages[k-1]"},{"question":"Given an array of integers `nums`, where each integer is unique, return an array of the same length where each element at index `i` represents the count of elements in `nums` that are smaller than `nums[i]`.","solution":"def smaller_numbers_than_current(nums): Given an array of integers nums, where each integer is unique, returns an array of the same length where each element at index i represents the count of elements in nums that are smaller than nums[i]. sorted_nums = sorted(nums) return [sorted_nums.index(num) for num in nums]"},{"question":"You are given a list of strings `words`, where each string consists of lowercase English alphabet characters. Return the list of indices of `words` where the corresponding string is a palindrome. A palindrome is a word that reads the same forwards and backwards. For example, \\"madam\\" is a palindrome but \\"hello\\" is not. Return the indices in ascending order.","solution":"def palindrome_indices(words): Returns the list of indices of words where the corresponding string is a palindrome. Parameters: words (list of str): A list of strings where each string consists of lowercase English alphabet characters. Returns: list of int: List of indices of words which are palindromes. indices = [] for i, word in enumerate(words): if word == word[::-1]: indices.append(i) return indices"},{"question":"You are given a binary tree where each node contains an integer value. Design an algorithm to find the **second smallest value** in the tree. If there is no such second smallest value, return `-1`. **Note** that a node cannot contain the same value as its parent or its children, and every node has a unique integer value in this tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_second_smallest(root): def inorder_traversal(node): if node: inorder_traversal(node.left) result.append(node.value) inorder_traversal(node.right) if not root: return -1 result = [] inorder_traversal(root) sorted_unique_values = list(sorted(set(result))) if len(sorted_unique_values) < 2: return -1 else: return sorted_unique_values[1]"},{"question":"Given a linked list, each node containing an integer value, return the length of the **longest consecutive sequence** of nodes where each node\'s value is exactly one greater than the previous node\'s value. If there is no such sequence, return `0`.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def longest_consecutive_sequence(head): Return the length of the longest consecutive sequence in the linked list. if not head: return 0 max_length = 1 current_length = 1 current_node = head while current_node.next: if current_node.next.value == current_node.value + 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 current_node = current_node.next max_length = max(max_length, current_length) return max_length"},{"question":"Given a binary tree, imagine yourself walking and narrating your journey. If you start at the root and can move either to the left or to the right child, define a \\"valid path\\" as a sequence of steps from the root to any node such that no two consecutive nodes along the sequence are both \'left\' children or both \'right\' children. In other words, you alternate between left and right child nodes. Write a function that takes as input the root node of a binary tree and returns the length of the longest \\"valid path\\". The length of a path is the number of nodes in the path, including the start and end nodes. If the tree is empty, return 0. You may assume the binary tree is implemented with TreeNode class: ``` class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_valid_path(root): def dfs(node, comes_from_left, length): if not node: return length left_length = dfs(node.left, True, length+1 if not comes_from_left else 1) right_length = dfs(node.right, False, length+1 if comes_from_left else 1) return max(left_length, right_length) return dfs(root, False, 0)"},{"question":"You are given an array `arr` of integers. A subarray (continuous sub-sequence) is called **distinct** if it contains no duplicate integers. Return the total number of distinct subarrays in `arr`.","solution":"def count_distinct_subarrays(arr): Returns the total number of distinct subarrays in arr. n = len(arr) subarrays_count = 0 for start in range(n): seen = set() for end in range(start, n): if arr[end] in seen: break seen.add(arr[end]) subarrays_count += 1 return subarrays_count"},{"question":"You are given a linked list where each node contains a positive integer value. The linked list represents a non-negative integer, where each node\'s value is a single digit and the digits are stored in reverse order, i.e., the first node contains the least significant digit. Additionally, you are given an integer `k`. Your task is to insert a new node with the value `k` into the linked list in such a way that the new node is placed in the correct position to maintain the list sorted in ascending order. Your function should return the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def insert_into_sorted_linked_list(head, k): Inserts a new node with value `k` into the sorted linked list and returns the head of the updated list. new_node = ListNode(k) # Special case: If the list is empty or the new node should be placed at the beginning if not head or head.val >= k: new_node.next = head return new_node # Traverse the list to find the correct position current = head while current.next and current.next.val < k: current = current.next # Insert the new node at the correct position new_node.next = current.next current.next = new_node return head"},{"question":"You are given an integer array `nums` and an integer `k`. A partition of the array is called **K-partitioned** if every segment of the partition has a sum less than or equal to `k`. For example, if `nums = [1, 4, 3, 2, 5]` and `k = 5`, one valid partition would be `[[1, 4], [3, 2], [5]]`. Write a function that returns the minimum number of segments such that the array `nums` can be partitioned into a K-partitioned array. Return _the minimum number of segments required to partition the array to satisfy the condition_. **Note**: - Each element in the array should be included in exactly one segment. - Each segment\'s sum must be less than or equal to `k`.","solution":"def min_segments(nums, k): Returns the minimum number of segments required to partition the array `nums` such that every segment has a sum less than or equal to `k`. segments = 0 current_sum = 0 for num in nums: if current_sum + num <= k: current_sum += num else: segments += 1 current_sum = num if current_sum > 0: segments += 1 return segments"},{"question":"You are given a 2-dimensional grid of integers `grid`, where each integer represents the height of a point in the grid. A water flow is defined as moving from a cell to an adjacent cell (up, down, left, or right) with equal or lower height. Water can flow from any cell to the border of the grid. Determine all the cells from which water can flow to the border in any direction. Return a list of coordinates `(i, j)` representing those cells.","solution":"def pacific_atlantic(grid): if not grid: return [] rows, cols = len(grid), len(grid[0]) pacific_reachable = set() atlantic_reachable = set() def dfs(r, c, reachable, prev_height): if ((r, c) in reachable or r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] < prev_height): return reachable.add((r, c)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc, reachable, grid[r][c]) for r in range(rows): dfs(r, 0, pacific_reachable, grid[r][0]) dfs(r, cols - 1, atlantic_reachable, grid[r][cols - 1]) for c in range(cols): dfs(0, c, pacific_reachable, grid[0][c]) dfs(rows - 1, c, atlantic_reachable, grid[rows - 1][c]) return list(pacific_reachable & atlantic_reachable)"},{"question":"You are given a list of tasks, where each task is represented by an integer indicating its duration. You are also given an integer `n` representing the number of workers available to complete these tasks. Each worker can only work on one task at a time. The goal is to minimize the maximum amount of time any single worker spends on their tasks. Design an algorithm that assigns the tasks to the workers such that the maximum time taken by any worker is minimized. Return the minimum possible value of the maximum time taken by any worker.","solution":"def min_max_time(tasks, n): def canCompleteWithin(mid): workers = [0] * n for task in sorted(tasks, reverse=True): workers[0] += task workers.sort() if workers[-1] > mid: return False return True left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if canCompleteWithin(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an integer array `arr` consisting of `n` positive integers. A **move** consists of selecting an element and incrementing its value by 1. You need to make all elements in the array equal using the minimum number of moves. Return the minimum number of moves required.","solution":"def min_moves_to_equal_elements(arr): Returns the minimum number of moves to make all elements in the array equal. # The optimal way is to increment all elements except the maximum element until they become equal. # This is equivalent to making all elements equal to the minimum element by a number of decrements. min_element = min(arr) moves = sum(element - min_element for element in arr) return moves"},{"question":"You are given two strings `s` and `t` of lengths `m` and `n` respectively. Your task is to determine if `s` can be transformed into `t` by deleting some (possibly zero) characters from `s` without changing the order of the remaining characters. Return `true` if it is possible, otherwise return `false`.","solution":"def can_transform(s: str, t: str) -> bool: Determines if string s can be transformed into string t by deleting some characters from s without changing the order of the remaining characters. Args: s (str): The source string. t (str): The target string. Returns: bool: True if s can be transformed into t, otherwise False. m, n = len(s), len(t) j = 0 for i in range(m): if j < n and s[i] == t[j]: j += 1 return j == n"},{"question":"Given an integer `n`, return an array `answer` such that for each `i` (1  i  n), `answer[i - 1]` is the number of integers `1, 2, ..., i` that are divisible by at least one prime number less than or equal to `i`. Make sure you optimize for performance, especially for larger values of `n`.","solution":"def sieve_of_eratosthenes(n): Returns a list of primes less than or equal to n is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(n + 1) if is_prime[p]] def count_divisibles_by_primes(n): primes = sieve_of_eratosthenes(n) answer = [0] * n cumulative_count = 0 for i in range(1, n + 1): for prime in primes: if prime > i: break if i % prime == 0: cumulative_count += 1 break answer[i - 1] = cumulative_count return answer"},{"question":"You are given a string `s` consisting of lower-case English letters. You need to determine whether it is possible to partition the string `s` into substrings such that each substring is a palindrome. Return _true_ if such a partitioning is possible and _false_ otherwise. A palindrome is a string that reads the same forward and backward.","solution":"def can_partition_palindromes(s): Determines if it is possible to partition the string s into substrings such that each substring is a palindrome. :param s: A string consisting of lower-case English letters. :return: True if such a partition is possible, False otherwise. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Check the number of characters that have odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # If more than one character has an odd frequency, # then it\'s not possible to partition the string into palindromic substrings return odd_count <= 1"},{"question":"Given an integer array `nums`, return the length of the longest contiguous subarray that contains **no duplicate elements**. A subarray is a contiguous part of an array.","solution":"def length_of_longest_subarray(nums): Returns the length of the longest contiguous subarray without duplicate elements. Parameters: nums (List[int]): List of integers. Returns: int: Length of the longest contiguous subarray without duplicates. n = len(nums) if n == 0: return 0 max_len = 0 start = 0 seen = {} for end in range(n): if nums[end] in seen and seen[nums[end]] >= start: start = seen[nums[end]] + 1 seen[nums[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given an `m x n` integer matrix `matrix`, you need to determine the length of the longest increasing path in the matrix. From each cell, you can move to either the four cardinal directions (up, down, left, or right) if they have a strictly greater value than the current cell. You should return an integer representing the length of the longest such path.","solution":"def longest_increasing_path(matrix): Returns the length of the longest increasing path in the given matrix. Moves are allowed to the four cardinal directions (up, down, left, right). if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[-1] * cols for _ in range(rows)] def dfs(r, c): if dp[r][c] != -1: return dp[r][c] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_length = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] > matrix[r][c]: max_length = max(max_length, 1 + dfs(nr, nc)) dp[r][c] = max_length return max_length max_path_length = 0 for r in range(rows): for c in range(cols): max_path_length = max(max_path_length, dfs(r, c)) return max_path_length"},{"question":"You are given an array of integers `arr` where each element represents a stone at position `i` with `arr[i]` stones on it. You need to determine whether it\'s possible to make all stones in the array equal by following these steps: - In one move, you can increase or decrease the number of stones on a stone to exactly match the number of stones on an adjacent stone (`i-1` or `i+1`). Write a function that returns a boolean value indicating whether it\'s possible to make all stones have the same number of stones using any number of moves.","solution":"def can_make_stones_equal(arr): Determines whether it is possible to make all stones in the array equal. Returns: bool: True if it\'s possible, False otherwise. if not arr: return False # Get the set of all unique elements in arr unique_elements = set(arr) # If the number of unique elements is 1, then all elements are already equal return len(unique_elements) == 1"},{"question":"Given a matrix of integers, determine if there is a path from the top-left corner to the bottom-right corner of the matrix where you can only move to the right or down. You cannot move through cells that contain zero. Each cell contains either a one or a zero, where one means you can move through that cell and zero means you cannot. Return `true` if such a path exists, otherwise return `false`. Example: ``` [ [1, 0, 0], [1, 1, 0], [0, 1, 1] ] ``` In this example, a path exists from the top-left to the bottom-right corner, so the function should return `true`. Function signature: ```python def is_path(matrix: List[List[int]]) -> bool: pass ```","solution":"from typing import List def is_path(matrix: List[List[int]]) -> bool: if not matrix or not matrix[0] or matrix[0][0] == 0: return False rows, cols = len(matrix), len(matrix[0]) directions = [(1, 0), (0, 1)] stack = [(0, 0)] visited = set((0, 0)) while stack: r, c = stack.pop() if r == rows - 1 and c == cols - 1: return True for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < rows and 0 <= new_c < cols and (new_r, new_c) not in visited and matrix[new_r][new_c] == 1: stack.append((new_r, new_c)) visited.add((new_r, new_c)) return False"},{"question":"Given a string `s` and an integer `k`, rearrange the string such that the same characters are at least `k` distance apart. If it\'s not possible to rearrange the string in such a way, return an empty string. The input string will contain only lowercase English letters.","solution":"from heapq import heappush, heappop from collections import Counter, deque def rearrange_string(s, k): if k <= 1: return s freq_map = Counter(s) max_heap = [] for char, count in freq_map.items(): heappush(max_heap, (-count, char)) result = [] wait_queue = deque() while max_heap: count, char = heappop(max_heap) result.append(char) wait_queue.append((char, count + 1)) if len(wait_queue) < k: continue wait_char, wait_count = wait_queue.popleft() if wait_count < 0: heappush(max_heap, (wait_count, wait_char)) return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"Given a list of `points` on a 2D plane where each `point = [x, y]`, determine the maximum number of points that lie on the same straight line. You should implement a function that returns the maximum number of points that lie on a single straight line.","solution":"from collections import defaultdict from math import gcd def max_points(points): def get_slope(p1, p2): dx = p2[0] - p1[0] dy = p2[1] - p1[1] if dx == 0: return (0, p1[0]) if dy == 0: return (p1[1], 0) d = gcd(dx, dy) return (dy // d, dx // d) n = len(points) if n < 3: return n max_points_on_line = 0 for i in range(n): slopes = defaultdict(int) duplicates = 1 for j in range(i + 1, n): if points[i] == points[j]: duplicates += 1 else: slope = get_slope(points[i], points[j]) slopes[slope] += 1 current_max = duplicates for count in slopes.values(): current_max = max(current_max, count + duplicates) max_points_on_line = max(max_points_on_line, current_max) return max_points_on_line"},{"question":"Given a matrix `mat` of integers, where each row is sorted in ascending order, and a target integer `target`, write a function that searches for `target` in `mat`. If `target` is found, return `true`; otherwise, return `false`. Utilize an efficient search algorithm that leverages the sorted properties of the matrix.","solution":"def search_matrix(mat, target): Returns true if the target is found in the sorted matrix mat; otherwise, returns false. Utilizes an efficient search algorithm that leverages the sorted properties of the matrix. if not mat or not mat[0]: return False rows = len(mat) cols = len(mat[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if mat[row][col] == target: return True elif mat[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given an array `bookPages` where `bookPages[i]` represents the number of pages in the `i-th` book. There are `k` students and each student is assigned to read a contiguous sequence of books. Each book must be assigned to exactly one student, and each student must be assigned at least one book. The goal is to minimize the maximum number of pages read by any student. Return the minimum possible value of the maximum pages read by any student. Assume k is always less than or equal to the number of books.","solution":"def min_max_pages(bookPages, k): def is_feasible(max_pages): required_students = 1 current_pages = 0 for pages in bookPages: if current_pages + pages > max_pages: required_students += 1 current_pages = pages if required_students > k: return False else: current_pages += pages return True lower_bound = max(bookPages) upper_bound = sum(bookPages) while lower_bound < upper_bound: mid = (lower_bound + upper_bound) // 2 if is_feasible(mid): upper_bound = mid else: lower_bound = mid + 1 return lower_bound"},{"question":"A city keeps track of vehicle trips between various districts. Your task is to develop a system to calculate the average time it takes for a vehicle to travel a specific route. Implement the `TripSystem` class: - `void startTrip(int id, string startDistrict, int t)` - Records that a vehicle with a unique `id` starts a trip from `startDistrict` at time `t`. - Each vehicle can have only one active trip at any point in time. - `void endTrip(int id, string endDistrict, int t)` - Records that the vehicle with `id` ends its trip at `endDistrict` at time `t`. - `double getAverageTripTime(string startDistrict, string endDistrict)` - Returns the average time it takes to travel from `startDistrict` to `endDistrict`. - The average time is based on all completed trips directly from `startDistrict` to `endDistrict`. - It is expected that at least one trip from `startDistrict` to `endDistrict` has been completed before calling `getAverageTripTime`. Assumptions: - All methods are called with consistent data. - If a trip starts at time `t1` and ends at time `t2`, then `t1 < t2`. - Events are processed in chronological order.","solution":"class TripSystem: def __init__(self): self.active_trips = {} self.completed_trips = {} def startTrip(self, id, startDistrict, t): Records that a vehicle with a unique `id` starts a trip from `startDistrict` at time `t`. self.active_trips[id] = (startDistrict, t) def endTrip(self, id, endDistrict, t): Records that the vehicle with `id` ends its trip at `endDistrict` at time `t`. startDistrict, startTime = self.active_trips.pop(id) trip_duration = t - startTime if (startDistrict, endDistrict) not in self.completed_trips: self.completed_trips[(startDistrict, endDistrict)] = [] self.completed_trips[(startDistrict, endDistrict)].append(trip_duration) def getAverageTripTime(self, startDistrict, endDistrict): Returns the average time it takes to travel from `startDistrict` to `endDistrict`. trips = self.completed_trips[(startDistrict, endDistrict)] return sum(trips) / len(trips)"},{"question":"You are developing a magical garden where plants can grow in unique patterns. Each plant has a growth rate associated with it, represented by an array `growthRates` where `growthRates[i]` denotes the growth rate of the `i-th` plant. You want to find the maximum possible total growth of any contiguous group of plants within a given period. For a given integer `days`, compute the maximum sum of growth rates of any contiguous subarray of length `days` from the array `growthRates`. Return the maximum sum. If there are multiple answers, return the first one that appears. If the length of `growthRates` is less than `days`, return -1.","solution":"def max_growth_rates_sum(growthRates, days): Returns the maximum sum of growth rates of any contiguous subarray of length `days` from the array `growthRates`. Parameters: growthRates (list): List of integers representing growth rates of plants. days (int): The length of the contiguous subarray to consider. Returns: int: The maximum sum of the contiguous subarray of length `days`, or -1 if the length of `growthRates` is less than `days`. n = len(growthRates) if n < days: return -1 max_sum = sum(growthRates[:days]) current_sum = max_sum for i in range(days, n): current_sum += growthRates[i] - growthRates[i - days] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a string `inputStr` consisting of uppercase English letters. You need to rearrange the letters of `inputStr` such that no two adjacent letters are the same. If it is possible to rearrange the letters in this manner, return the rearranged string. Otherwise, return an empty string.","solution":"import heapq from collections import Counter def rearrangeString(inputStr): Rearranges the characters in the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. char_count = Counter(inputStr) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap or prev_count < 0: if max_heap: count, char = heapq.heappop(max_heap) result.append(char) count += 1 if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char, prev_count = char, count rearranged_str = \'\'.join(result) return rearranged_str if len(rearranged_str) == len(inputStr) else \'\'"},{"question":"You are given a **0-indexed** integer array `arr` of length `n`. Your task is to find and return the maximum value of `j - i` for all valid pairs of indices `(i, j)` such that `arr[i] <= arr[j]`. If no such pair exists, return `0`.","solution":"def maxIndexDifference(arr): n = len(arr) if n == 0: return 0 left_min = [0] * n right_max = [0] * n left_min[0] = arr[0] for i in range(1, n): left_min[i] = min(arr[i], left_min[i - 1]) right_max[n - 1] = arr[n - 1] for j in range(n - 2, -1, -1): right_max[j] = max(arr[j], right_max[j + 1]) i, j = 0, 0 max_diff = 0 while i < n and j < n: if left_min[i] <= right_max[j]: max_diff = max(max_diff, j - i) j = j + 1 else: i = i + 1 return max_diff"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `threshold`. A **threshold index** is an index `i` of `nums` for which the product of all elements from `nums[0]` to `nums[i]` (inclusive) is less than or equal to `threshold`. Return _a list of all threshold indices sorted in **increasing order**_. If there is no such index, return an empty list.","solution":"def threshold_indices(nums, threshold): Returns a list of threshold indices such that the product of all elements from nums[0] to nums[i] is less than or equal to threshold. result = [] product = 1 for i in range(len(nums)): product *= nums[i] if product <= threshold: result.append(i) else: break return result"},{"question":"You are given a list of `n` integers `nums` and a target integer `target`. Find two distinct integers in the list such that their sum is equal to `target` and return their indices as a tuple. You may assume that there is exactly one solution, and you must not use the same element twice. The return value should be in the form of a tuple `(index1, index2)` where `index1` is less than `index2`. If no such pair exists, return an empty tuple.","solution":"def two_sum(nums, target): Finds two distinct integers in the list such that their sum is equal to `target` and returns their indices as a tuple. The returned indices are in ascending order. :param nums: List of integers :param target: Target sum :return: Tuple of indices (index1, index2) where index1 < index2. If no valid pair, return empty tuple. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"You are given a list of integers `arr` representing the heights of buildings in a city skyline from left to right, with the width of each building being 1 unit. The city has experienced a tremendous earthquake which tipped over all buildings to the right (except the rightmost building). The heights of the fallen buildings contribute to forming a new skyline where each building\'s height adds to the height of the building directly to the right of it. Compute the resulting skyline and return it as a list of integers.","solution":"def skyline_after_earthquake(arr): Given a list of integers arr representing the heights of buildings in a city skyline from left to right, compute the resulting skyline after all buildings except the rightmost one are tipped over to the right. Parameters: arr (list): A list of integers representing the initial heights of buildings. Returns: list: A list of integers representing the heights of buildings after the earthquake. n = len(arr) if n == 0: return [] if n == 1: return arr result = [0] * n result[-1] = arr[-1] for i in range(n-2, -1, -1): result[i] = arr[i] + result[i+1] return result"},{"question":"You are given a **0-indexed** array `grades` where `grades[i]` denotes the grade of the `ith` student. A bonus point will be given to every student who has a better grade than the student right before them. However, if a student has the same grade or a worse grade than the previous student, they do not get a bonus point. Return _the total number of bonus points given out to the students._","solution":"def calculate_bonus_points(grades): Returns the total number of bonus points given out to the students. A bonus point is given to every student who has a better grade than the student right before them. :param grades: List of integers representing the grades of students. :return: Integer representing the total number of bonus points. if not grades or len(grades) == 1: return 0 bonus_points = 0 for i in range(1, len(grades)): if grades[i] > grades[i - 1]: bonus_points += 1 return bonus_points"},{"question":": Given a rectangular `m x n` grid representing a maze, you must find the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). You may move in four possible directions (left, right, up, down) but can only move through cells that are open (represented by a \'0\'). A cell with a \'1\' represents an obstacle. If there is no valid path, return -1. Given the grid as a list of lists where each element is either \'0\' or \'1\', return the length of the shortest path from start to end.","solution":"from collections import deque def shortest_path_maze(grid): This function finds the shortest path in a maze from the top-left corner (0,0) to the bottom-right corner (m-1, n-1). It uses Breadth-First Search (BFS) to ensure the shortest path in an unweighted grid. Args: grid (list of list of int): The maze grid where \'0\' represents an open cell and \'1\' represents an obstacle. Returns: int: The length of the shortest path, or -1 if no path exists. # Edge case for empty grid if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 # Directions for moving in the grid (right, left, down, up) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # If we reach the bottom-right corner if r == m - 1 and c == n - 1: return dist # Explore all possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1 # No path found"},{"question":"You are given a grid of size `m x n` representing a map of a town, where each cell is either a house `\'H\'`, a store `\'S\'`, or empty `\'.\'`. The goal is to build a new store such that the sum of the distances from this new store to all the houses is minimized. You can only build the new store on an empty cell `\'.\'`. The distance between two cells `(i1, j1)` and `(i2, j2)` is defined as the absolute difference `|i1 - i2| + |j1 - j2|`. Return the coordinates `[x, y]` of the cell where the new store should be built to minimize the total distance to all houses. If there are multiple optimal positions, return any one of them.","solution":"def best_store_location(grid): Finds the optimal empty cell location to place a store to minimize total distance to all houses. Args: grid (List[List[str]]): 2D list representing the town. Returns: List[int]: Coordinates [row, col] of the optimal location to place the store. if not grid or not grid[0]: return [] rows, cols = len(grid), len(grid[0]) houses = [] empty_cells = [] # Collect houses and empty cells coordinates for i in range(rows): for j in range(cols): if grid[i][j] == \'H\': houses.append((i, j)) elif grid[i][j] == \'.\': empty_cells.append((i, j)) # If no house or empty cell, return empty array if not houses or not empty_cells: return [] min_distance = float(\'inf\') best_location = None for cell in empty_cells: total_distance = sum(abs(cell[0] - h[0]) + abs(cell[1] - h[1]) for h in houses) if total_distance < min_distance: min_distance = total_distance best_location = cell return list(best_location)"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of students standing in a line. Each student wants to see the stage, which means no one in front of them should be taller. Find the minimum number of students in the line that need to be removed so that every student remaining can see the stage. In other words, your task is to find the longest subsequence of students where each student is shorter than the next student in line. Return the number of students that need to be removed to achieve this.","solution":"def min_students_to_remove(heights): Returns the minimum number of students that need to be removed so that every remaining student can see the stage. def length_of_lis(seq): Returns the length of longest increasing subsequence in seq. if not seq: return 0 dp = [1] * len(seq) for i in range(1, len(seq)): for j in range(i): if seq[i] > seq[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) lis_length = length_of_lis(heights) return len(heights) - lis_length"},{"question":"You are given a list of `n` integers `arr` where each integer represents a different product sold. The `i-th` product had `arr[i]` units sold over a period. A new marketing strategy can increase the units sold for any chosen product. Given an integer `k`, determine _the **minimum number** of products that need to be chosen_ and have their unit sales increased such that the total units sold for the selected products is at least `k`._","solution":"def min_products_to_increase_sales(arr, k): Determines the minimum number of products to choose to increase their sales such that the total units sold for the selected products is at least k. :param arr: List of integers where arr[i] is the number of units sold of the i-th product :param k: Integer representing the target total units of sales to be incremented :return: Minimum number of products needed to be chosen to reach at least k units of sales # Sort the products in descending order of their unit sales sorted_sales = sorted(arr, reverse=True) # Initialize the current sum and the count of products current_sum = 0 count = 0 # Increment the total units sold and count the products chosen until the sum is at least k for sales in sorted_sales: if current_sum >= k: break current_sum += sales count += 1 return count"},{"question":"You are given a string `s` representing a sentence, which consists of words separated by spaces. Some of the words are followed by a number of exclamation marks, which indicates the words\' emphasis. Your task is to write a function that returns a new sentence where the words are sorted in descending order based on the number of exclamation marks. If two words have the same number of exclamation marks, maintain their original order. For example, given the input string `s = \\"hello! world!! programming!!! is fun!!\\"`, the function should return `\\"programming!!! world!! fun!! hello! is\\"`. [Question 4]:","solution":"def sort_by_exclamation_marks(s): Sorts the words in the sentence in descending order based on the number of exclamation marks. Parameters: s (str): A sentence where words might have exclamation marks. Returns: str: The input sentence with words sorted by the number of exclamation marks in descending order. def exclamation_count(word): return word.count(\'!\') words = s.split() words_sorted = sorted(words, key=exclamation_count, reverse=True) return \' \'.join(words_sorted)"},{"question":"You are given a list of `n` words and a string `s` of length `m`. The task is to count the number of words in the list that can be formed by deleting one or more characters from the string `s` without reordering the remaining characters. A word can be formed if it appears as a subsequence in the string `s`. Return the count of such words.","solution":"def count_formable_words(words, s): Count the number of words from the list that can be formed by deleting one or more characters from the string `s` without reordering them. Args: words (list of str): List of words to check. s (str): The reference string. Returns: int: The count of words that can be formed from the string `s`. def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) count = 0 for word in words: if is_subsequence(word, s): count += 1 return count"},{"question":"Given an array of integers `arr`, an integer `k`, and an integer `x`, find the `k` closest integers to `x` in the array. The result should also be sorted in ascending order. An integer `a` is closer to `x` than an integer `b` if: - |a - x| < |b - x|, or - |a - x| == |b - x| and a < b Return _the sorted list of the `k` closest integers_.","solution":"def find_k_closest_integers(arr, k, x): Returns the k closest integers to x in the array arr, sorted in ascending order. Parameters: arr (list): List of integers. k (int): Number of closest integers to find. x (int): Target integer. Returns: list: k closest integers sorted in ascending order. # Sort the array with custom key: absolute difference from x and then by the values themselves sorted_by_closeness = sorted(arr, key=lambda num: (abs(num - x), num)) # Slice to get the k closest numbers and sort them in ascending order k_closest_sorted = sorted(sorted_by_closeness[:k]) return k_closest_sorted"},{"question":"You are given a **m x n** matrix `grid` consisting of positive integers. Each cell of the matrix represents the cost to visit that cell. You can start at any cell in the first row and move to any cell in the next row either directly below or diagonally below-left or below-right. Your goal is to find the **minimum** cost to reach any cell in the last row from any cell in the first row. Return _the **minimum** cost to reach the last row._","solution":"def min_cost_to_last_row(grid): Finds the minimum cost to reach any cell in the last row from any cell in the first row. Args: - grid (List[List[int]]): m x n matrix of costs. Returns: - int: Minimum cost to reach any cell in the last row. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp table initialized to a high cost value dp = [[float(\'inf\')] * n for _ in range(m)] # Initialize the first row of dp table with the first row of grid dp[0] = grid[0][:] # Fill the dp table for i in range(1, m): for j in range(n): # The cost to reach cell (i, j) dp[i][j] = grid[i][j] + dp[i - 1][j] # Directly above # Check diagonally left if not in the first column if j > 0: dp[i][j] = min(dp[i][j], grid[i][j] + dp[i - 1][j - 1]) # Check diagonally right if not in the last column if j < n - 1: dp[i][j] = min(dp[i][j], grid[i][j] + dp[i - 1][j + 1]) # Minimum cost to reach any cell in the last row return min(dp[m - 1])"},{"question":"Given an integer array `nums` representing the number of stones in different piles, two players take turns to take a non-zero number of stones from any single pile until no stones are left. The player to take the last stone wins the game. Both players play optimally. Determine whether the player who starts the game will win, assuming both players play optimally. Return `true` if the first player will win, otherwise return `false`.","solution":"def can_first_player_win(nums): Determines whether the first player will win the game assuming both players play optimally. Args: nums (List[int]): An integer array representing the number of stones in different piles. Returns: bool: True if the first player will win, otherwise False. xor_sum = 0 for num in nums: xor_sum ^= num return xor_sum != 0"},{"question":"Given an array of integers `nums` and an integer `k`, find the minimum number of consecutive elements required to sum up to at least `k`. If there is no such subarray, return `-1`. Implement the function `minSubArrayLen(nums, k)` that takes two parameters `nums` and `k`, and returns the length of the smallest subarray with a sum greater than or equal to `k`.","solution":"def minSubArrayLen(nums, k): Returns the length of the smallest subarray with a sum greater than or equal to k. If there is no such subarray, return -1. from collections import deque n = len(nums) if n == 0: return -1 min_len = float(\'inf\') current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= k: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given a `root` of a binary tree with `n` nodes. Each node is assigned a unique value from `1` to `n`. You have to find all the **paths from the root** to any node in the tree where the sum of the node values in the path is equal to a given integer `targetSum`. Return _a list of lists_, where each list contains the node values along the path from the root to any node where the sum of the node values is equal to `targetSum`. **Note**: - A path is defined as a sequence of nodes starting from the root node to any node in the tree and ending at that node. - You may use the same node value in multiple paths if the paths themselves are different. - If no such path exists, return an empty list.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): Find all paths from the root to any node in the tree where the sum of the node values in the path is equal to targetSum. def dfs(node, current_sum, path, results): if not node: return current_sum += node.val path.append(node.val) # If the current path sum equals targetSum, add the path to results if current_sum == targetSum: results.append(list(path)) # Continue searching in the left and right subtrees dfs(node.left, current_sum, path, results) dfs(node.right, current_sum, path, results) # Backtrack path.pop() results = [] dfs(root, 0, [], results) return results"},{"question":"You are given two strings `s1` and `s2`, return `true` _if `s2` contains a **substring** that is an anagram of `s1`, and `false` otherwise_. An anagram of a string is another string that contains the same characters, only the order of characters can be different.","solution":"def is_anagram(s1, s2): Checks if s2 contains a substring that is an anagram of s1. from collections import Counter len_s1 = len(s1) s1_count = Counter(s1) for i in range(len(s2) - len_s1 + 1): if Counter(s2[i:i+len_s1]) == s1_count: return True return False"},{"question":"Given a list `logs` where each element is a string representing the login and logout times of various users in the format `\\"user_id,login_time,logout_time\\"`. Write a function that returns a list of user IDs of users who were logged in at the same time. The order of user IDs in the output list should match the order in which they appear in the input list. For example, given the input `logs = [\\"1,10,20\\", \\"2,19,30\\", \\"3,15,25\\"]`, the function should return `[\\"1\\", \\"2\\", \\"3\\"]` because all three users were logged in during the time window where their login and logout times overlap. If no users were logged in at the same time, return an empty list.","solution":"def overlapping_users(logs): Returns a list of user IDs of users who were logged in at the same time. Args: logs (list): List of strings representing login and logout times in the format \\"user_id,login_time,logout_time\\". Returns: list: List of user IDs that were logged in at the same time. intervals = [] for log in logs: user_id, login_time, logout_time = log.split(\',\') intervals.append((user_id, int(login_time), int(logout_time))) result = [] for i in range(len(intervals)): user1, start1, end1 = intervals[i] for j in range(i + 1, len(intervals)): user2, start2, end2 = intervals[j] if max(start1, start2) < min(end1, end2): result.append(user1) result.append(user2) break return sorted(set(result), key=lambda x: int(x))"},{"question":"You are given a binary tree with `n` nodes where each node is labeled from `1` to `n`. The tree is represented as an array `parent` of size `n`, where `parent[i]` is the parent node of node `i`. The root node will have `parent[i] = -1`. Each node also has a value associated with it stored in the array `values` of size `n`, where `values[i]` is the value of node `i`. Define the _weight_ of a subtree rooted at node `i` as the **sum** of the values of all nodes in that subtree. You need to find the node `i` which has the maximum subtree weight. If multiple nodes have the same maximum subtree weight, return the one with the smallest index. Return _the index of the node with the maximum subtree weight_ and _the weight of the subtree_.","solution":"def find_max_subtree_weight(parent, values): Returns the index of the node with the maximum subtree weight and the weight of the subtree. n = len(parent) from collections import defaultdict tree = defaultdict(list) for i in range(n): if parent[i] != -1: tree[parent[i]].append(i) def calculate_weights(node): Calculate the subtotal weight of the subtree rooted at `node`. Return both the weight and update the weights array. total_weight = values[node] for child in tree[node]: total_weight += calculate_weights(child) weights[node] = total_weight return total_weight weights = [0] * n calculate_weights(parent.index(-1)) max_weight = max(weights) max_weight_node = min(i for i in range(n) if weights[i] == max_weight) return max_weight_node, max_weight"},{"question":"You are given a list of strings `transactions` where each transaction is represented as a comma-separated string in the format \\"name,city,time,amount\\". A transaction is considered \\"suspicious\\" if the transaction amount exceeds 1000 or if there are two different transactions with the same name that occur within 60 minutes of each other from different cities. Your task is to return a list of all \\"suspicious\\" transactions in any order. Two transactions are considered different if they occur at different times or in different cities, even if they have the same name.","solution":"def find_suspicious_transactions(transactions): suspicious = [] trans_details = [tran.split(\',\') for tran in transactions] for i, tran in enumerate(trans_details): name1, city1, time1, amount1 = tran time1, amount1 = int(time1), int(amount1) if amount1 > 1000: suspicious.append(transactions[i]) for j, other_tran in enumerate(trans_details): if i == j: continue name2, city2, time2, _ = other_tran time2 = int(time2) if name1 == name2 and city1 != city2 and abs(time1 - time2) <= 60: suspicious.append(transactions[i]) break return suspicious"},{"question":"You are given a 2D grid of characters, `board`, and a string `word`. Return `true` if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Write an algorithm to solve the given problem.","solution":"def exist(board, word): Returns True if the word exists in the board following the described rules, else False. def backtrack(i, j, k): if k == len(word): return True if (i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]): return False temp, board[i][j] = board[i][j], \\"#\\" found = (backtrack(i + 1, j, k + 1) or backtrack(i - 1, j, k + 1) or backtrack(i, j + 1, k + 1) or backtrack(i, j - 1, k + 1)) board[i][j] = temp return found for row in range(len(board)): for col in range(len(board[0])): if backtrack(row, col, 0): return True return False"},{"question":"You are given an array of integers `height` representing the height of a building from ground level at various points. Two points `(i, height[i])` and `(j, height[j])` can form a container which can hold water. The amount of water a container can hold is determined by the shorter height of the two points multiplied by the distance between them, i.e., `(j - i) * min(height[i], height[j])`. Find the maximum amount of water a container can hold in the given array. Return _the maximum water held by any container_ in the form of an integer.","solution":"def max_area(height): Returns the maximum amount of water a container can hold in the given heights array. :param height: List[int] :return: int if not height or len(height) < 2: return 0 left, right = 0, len(height) - 1 max_water = 0 while left < right: min_height = min(height[left], height[right]) current_water = min_height * (right - left) max_water = max(max_water, current_water) if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given `n` ropes of varying lengths in an array `lengths`. Your task is to connect the ropes into one continuous rope. The cost to connect two ropes is equal to the sum of their lengths. Connect the ropes with minimum cost. You need to return the minimum cost of connecting all the ropes. Write a function that takes in an integer array `lengths` and returns an integer representing the minimum cost to connect all the ropes into one continuous rope.","solution":"import heapq def minimum_cost_to_connect_ropes(lengths): Connects the ropes with minimum cost. Args: lengths (list): A list of integers representing the lengths of ropes. Returns: int: The minimum cost to connect all ropes into one continuous rope. if not lengths: return 0 heapq.heapify(lengths) total_cost = 0 while len(lengths) > 1: first = heapq.heappop(lengths) second = heapq.heappop(lengths) cost = first + second total_cost += cost heapq.heappush(lengths, cost) return total_cost"},{"question":"There is an array of integers where the `ith` integer represents the time it takes to execute the `i`th task. A task can be assigned to any machine but there is a restriction: a machine will not start a new task until it finishes its current task. You need to distribute the tasks into `k` machines in such a way that the total time taken to complete all the tasks is minimized. Return _the **minimum** time required_ to complete all tasks when optimally distributed among the `k` machines.","solution":"def can_distribute(tasks, k, max_time): Helper function to check if tasks can be distributed among k machines such that no machine takes more than max_time to complete its assigned tasks. current_time = 0 machines_required = 1 for task in tasks: if current_time + task <= max_time: current_time += task else: machines_required += 1 current_time = task if machines_required > k: return False return True def min_time_to_complete_tasks(tasks, k): Returns the minimum time required to complete all tasks when optimally distributed among k machines. if not tasks or k <= 0: return 0 left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_distribute(tasks, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` which represents a valid parentheses sequence. For example, \\"()\\" and \\"()()()\\" are valid, while \\"(()\\" and \\")(\\" are not. Your task is to determine the minimum number of parentheses that need to be added or removed so that the string becomes valid. A string is considered valid if there is the same number of opening parentheses \\"(\\" and closing parentheses \\")\\" and for every prefix in the string, the number of opening parentheses is greater than or equal to the number of closing parentheses. Write a function that takes the string `s` and returns the minimum number of modifications needed to make the string valid.","solution":"def min_modifications_to_make_valid(s: str) -> int: Returns the minimum number of parentheses that need to be added or removed to make the string valid. open_count = 0 # Keeps track of the number of unmatched \'(\' close_needed = 0 # Keeps track of how many \')\' are needed to balance \'(\' for char in s: if char == \'(\': open_count += 1 elif char == \')\': if open_count > 0: open_count -= 1 else: close_needed += 1 # Total modifications needed is the sum of unmatched \'(\' and \')\' needed return open_count + close_needed"},{"question":"You are given a string `s` which consists of only lowercase English letters. Each letter in the string can be replaced with another letter from the same string, without changing the relative order of characters in the string. Your task is to find the **length of the shortest possible string** that can be obtained after performing such replacements. Return _the length of the shortest string_ that can be achieved by these replacements.","solution":"def shortest_unique_string_length(s): Finds the length of the shortest possible string that can be obtained by replacing characters in the string `s` while maintaining the relative order of characters. Args: s (str): The input string consisting of only lowercase English letters. Returns: int: The length of the shortest possible string. return len(set(s))"},{"question":"You are given a string `s`, which consists only of lowercase English letters. You need to group all characters in `s` such that each group\'s characters are the same and the number of groups is minimized. Return the resulting string after grouping all the characters. If there are multiple solutions, return **any one** of them.","solution":"def group_characters(s): Groups all characters in the string so that each group\'s characters are the same and the number of groups is minimized. :param s: input string consisting only of lowercase English letters :return: resulting string with grouped characters from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Initialize the result as an empty list result = [] # Append characters sorted by their order for char, count in char_count.items(): result.append(char * count) # Join the list into a string and return return \'\'.join(result)"},{"question":"You are given a **0-indexed** array `nums` of length `n` consisting of integers from `0` to `n-1` where exactly one integer is missing. The array represents a cyclic permutation where the missing number is replaced by another number, causing a repetition of a number already present in the array. Write a function that returns _the missing number and the repeated number in the array_. The function should return a tuple `(missing, repeated)`. Examples: - If `nums = [3, 1, 0, 2, 3]`, the function should return `(4, 3)` since `4` is missing and `3` is repeated. - If `nums = [0, 2, 2, 1, 3]`, the function should return `(4, 2)` since `4` is missing and `2` is repeated.","solution":"def find_missing_and_repeated(nums): Returns the missing and repeated number in the array. :param nums: list of integers :return: tuple (missing, repeated) n = len(nums) expected_sum = sum(range(n)) actual_sum = sum(nums) actual_sum_of_squares = sum(x ** 2 for x in nums) expected_sum_of_squares = sum(x ** 2 for x in range(n)) diff = expected_sum - actual_sum sum_sq_diff = expected_sum_of_squares - actual_sum_of_squares repeated = (sum_sq_diff - (diff ** 2)) // (2 * diff) missing = repeated + diff return (missing, repeated)"},{"question":"You are given a list of integers `nums` representing the number of candies each child has in a line. Each child can only give candies to their immediate left or right neighbor. If a child has more candies than their neighbor, they are required to give one candy to that neighbor. Return _the minimum number of moves required to ensure that all the children have the same number of candies_.","solution":"def min_moves_to_equal_candies(nums): Returns the minimum number of moves required to ensure that all the children have the same number of candies. # Sort list to find the median easily nums.sort() # Find the median median = nums[len(nums) // 2] # Calculate the number of moves to make all elements equal to the median moves = sum(abs(num - median) for num in nums) return moves"},{"question":"You are given an integer array `nums` where each integer represents a position on a number line. Write a function to find the smallest range that includes at least one number from each of the `k` lists. If there are multiple answers, return the range that starts at the smallest number. Return the start and end of the range as a list of two integers.","solution":"from typing import List import heapq def smallestRange(nums: List[List[int]]) -> List[int]: min_heap = [] max_value = float(\'-inf\') for i in range(len(nums)): heapq.heappush(min_heap, (nums[i][0], i, 0)) max_value = max(max_value, nums[i][0]) start, end = float(\'-inf\'), float(\'inf\') while min_heap: min_value, row, idx = heapq.heappop(min_heap) if max_value - min_value < end - start: start, end = min_value, max_value if idx + 1 == len(nums[row]): break next_value = nums[row][idx + 1] heapq.heappush(min_heap, (next_value, row, idx + 1)) max_value = max(max_value, next_value) return [start, end]"},{"question":"Given two non-empty binary trees `root1` and `root2`, write a function to determine if they are **leaf-similar**. Two binary trees are considered leaf-similar if their leaf value sequence is the same. The **leaf value sequence** is the sequence of values in the leaf nodes when traversed from left to right. Return _`true` if the two trees are leaf-similar, and `false` otherwise_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def leafSimilar(root1, root2): Determine if the two binary trees are leaf-similar. def getLeafValues(root): leaves = [] def traverse(node): if node: if not node.left and not node.right: # It\'s a leaf node leaves.append(node.val) traverse(node.left) traverse(node.right) traverse(root) return leaves return getLeafValues(root1) == getLeafValues(root2)"},{"question":"Given an array of integers `nums` sorted in non-decreasing order, and an integer `target`, find the starting and ending position of a given `target` value. Your algorithm should run in O(log n) time. If the target is not found in the array, return `[-1, -1]`. Implement a function that determines the _first and last position of an element in a sorted array_.","solution":"def search_range(nums, target): def find_leftmost(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_rightmost(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right leftmost = find_leftmost(nums, target) rightmost = find_rightmost(nums, target) if leftmost <= rightmost: return [leftmost, rightmost] else: return [-1, -1]"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine if `s` is a \\"double-palindrome\\", which means that it reads the same both forwards and backwards, **and** its first half and its second half are also palindromes. For the given string `s` of length `n`, check whether the following conditions hold true: * The entire string `s` is a palindrome. * The first half of the string `s` (i.e., `s[0]` to `s[(n-1)//2]`) is a palindrome. * The second half of the string `s` (i.e., `s[(n+1)//2]` to `s[n-1]`) is a palindrome. If all conditions are satisfied, return `true`; otherwise, return `false`. Note that the length `n` of the string `s` is always even.","solution":"def is_double_palindrome(s): Determines if the string `s` is a double-palindrome. n = len(s) # Helper function to check if a given substring is a palindrome def is_palindrome(sub): return sub == sub[::-1] # The entire string should be a palindrome if not is_palindrome(s): return False # The first half should be a palindrome first_half = s[:n//2] if not is_palindrome(first_half): return False # The second half should be a palindrome second_half = s[n//2:] if not is_palindrome(second_half): return False return True"},{"question":"You are given a list of `n` distinct integers and an integer `target`. Return a list of all unique combinations of numbers from the given list that add up to the `target`. Each number from the list can only be used once in a combination. The combinations should be returned in ascending order and each combination itself should be in non-descending order as well. If there are no such combinations, return an empty list.","solution":"from typing import List def combination_sum(arr: List[int], target: int) -> List[List[int]]: arr.sort() result = [] def backtrack(start, path, target): if target == 0: result.append(path) return elif target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue backtrack(i + 1, path + [arr[i]], target - arr[i]) backtrack(0, [], target) return result"},{"question":"Given an integer array `arr` and an integer `target`, find the two integers in `arr` that add up to `target` and return their indices as a list `[index1, index2]`. You may assume that each input would have exactly one solution, and you may not use the same element twice. The solution must use constant space complexity (i.e., O(1) extra space). If no such pair exists, return an empty list.","solution":"def two_sum(arr, target): Given an integer array `arr` and an integer `target`, find the two integers in `arr` that add up to `target` and return their indices as a list `[index1, index2]`. Args: arr: List of integers - The input array. target: Integer - The target sum. Returns: A list containing the indices of the two numbers such that they add up to `target`. for i in range(len(arr)): for j in range(i + 1, len(arr)): if arr[i] + arr[j] == target: return [i, j] return []"},{"question":"You are given an array of strings `words` and a string `target`. Each string in the array `words` is sorted. A string is considered a valid subsequence of `target` if it contains all characters of `target` in the same order, but not necessarily contiguously. Write a function to return the count of strings in `words` that are valid subsequences of `target`.","solution":"def is_subsequence(word, target): it = iter(target) return all(char in it for char in word) def count_valid_subsequences(words, target): return sum(is_subsequence(word, target) for word in words)"},{"question":"**Given an `m x n` matrix of non-negative integers representing the height of each unit cell in a continent, the \\"Pacific ocean\\" touches the left and top edges of the matrix and the \\"Atlantic ocean\\" touches the right and bottom edges. Write a function to find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Water can flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower to it. Return _an array of integer arrays representing the grid coordinates (i, j) for the cells where water can flow to both oceans._**","solution":"def pacificAtlantic(matrix): if not matrix or not matrix[0]: return [] def dfs(visited, x, y): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and matrix[nx][ny] >= matrix[x][y]: dfs(visited, nx, ny) m, n = len(matrix), len(matrix[0]) pacific_reach = set() atlantic_reach = set() for i in range(m): dfs(pacific_reach, i, 0) dfs(atlantic_reach, i, n - 1) for j in range(n): dfs(pacific_reach, 0, j) dfs(atlantic_reach, m - 1, j) return list(pacific_reach & atlantic_reach)"},{"question":"Suppose you have a 2D grid, where each cell represents a flowerbed. A cell can either contain a flower (represented by \'1\') or be empty (represented by \'0\'). Two flowers are said to be adjacent if they are directly connected horizontally, vertically, or diagonally. A flower border is a collection of flowers that are adjacent. Given such a 2D grid of flowers, write an algorithm to find the number of distinct flower borders in the grid.","solution":"def count_flower_borders(grid): Returns the number of distinct flower borders in a 2D grid. if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' # Mark as visited # Explore all 8 directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] for d in directions: dfs(grid, i + d[0], j + d[1]) num_borders = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': num_borders += 1 dfs(grid, i, j) return num_borders"},{"question":"You are tasked with writing a script to track the visitors to a library. Implement a class `LibraryTracker` which tracks the number of visitors per day. It should support the following operations: - `visit(day: int) -> None`: Records a visitor for the given day. - `count(day: int) -> int`: Returns the number of visitors recorded for the given day. - `total(start_day: int, end_day: int) -> int`: Returns the total number of visitors between the `start_day` and `end_day` (inclusive). Assume the `day` parameter is a positive integer and that days are recorded sequentially starting from 1. If no visitor has been recorded for a given day, the count should be considered `0`.","solution":"class LibraryTracker: def __init__(self): self.visitors = {} def visit(self, day: int) -> None: if day in self.visitors: self.visitors[day] += 1 else: self.visitors[day] = 1 def count(self, day: int) -> int: return self.visitors.get(day, 0) def total(self, start_day: int, end_day: int) -> int: return sum(self.visitors.get(day, 0) for day in range(start_day, end_day + 1))"},{"question":"Given a list of directories `paths`, where each directory is represented by a string containing the directory path and files within the directory, return a list of lists grouped by **duplicate file contents**. Each file is represented by a string in the format: `\\"filename(content)\\"`. For example, consider the following list of directories: ``` [\\"root/a 1.txt(abcd) 2.txt(efgh)\\", \\"root/c 3.txt(abcd)\\", \\"root/c/d 4.txt(efgh)\\", \\"root 4.txt(efgh)\\"] ``` The output should be grouped as follows (the order of paths within each group and the order of groups does not matter): ``` [ [\\"root/a/1.txt\\", \\"root/c/3.txt\\"], [\\"root/a/2.txt\\", \\"root/c/d/4.txt\\", \\"root/4.txt\\"] ] ```","solution":"def find_duplicate(paths): content_to_paths = {} for path in paths: parts = path.split(\\" \\") directory = parts[0] for file_info in parts[1:]: filename, content = file_info.split(\\"(\\") content = content[:-1] # Remove the closing \')\' full_path = directory + \\"/\\" + filename if content in content_to_paths: content_to_paths[content].append(full_path) else: content_to_paths[content] = [full_path] # We need to filter out groups that have only one file, since they have no duplicates return [group for group in content_to_paths.values() if len(group) > 1]"},{"question":"You are given an integer array `arr` of size `n` (**0-indexed**). In one operation, you can increment any element of the array by 1. Your task is to make all elements of the array unique using the minimum number of operations. Return _the **minimum number of operations** required to make all elements of_ `arr` _unique_. Note that you are allowed to modify the array in-place.","solution":"def min_operations_to_make_unique(arr): Returns the minimum number of operations required to make all elements of the array unique. arr.sort() operations = 0 for i in range(1, len(arr)): if arr[i] <= arr[i - 1]: increment = arr[i - 1] - arr[i] + 1 arr[i] += increment operations += increment return operations"},{"question":"You are given two strings `str1` and `str2`, each consisting of lowercase English letters. Determine whether the two strings are **anagrams** of each other. Two strings are considered anagrams if they contain the same characters, with the same frequencies. Return `true` _if `str1` and `str2` are anagrams_. Otherwise, return `false`.","solution":"def are_anagrams(str1, str2): Returns True if str1 and str2 are anagrams of each other, False otherwise. return sorted(str1) == sorted(str2)"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to determine if there are four distinct elements in `nums` whose sum is equal to `target`. Return `true` if such a combination exists, and `false` otherwise. The function should run in O(n^3) time complexity.","solution":"def four_sum(nums, target): Returns True if there are four distinct elements in nums whose sum is equal to target, False otherwise. nums.sort() n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left = j + 1 right = n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"You are given a **0-indexed** integer array `nums`. In one operation, you can choose any subarray of `nums` and increase each element within that subarray by `1`. An array is called **non-decreasing** if `nums[i] <= nums[i+1]` holds for every index `i` from `0` to `len(nums) - 2`. Return `true` if it is possible to make the given array `nums` non-decreasing using any number of operations, or `false` otherwise.","solution":"def can_be_non_decreasing(nums): Returns True if it is possible to make the array non-decreasing by increasing subarrays, False otherwise. # We can instantly return True if the array length is 1 or 0 because they are already non-decreasing if len(nums) <= 1: return True for i in range(len(nums) - 1): if nums[i] > nums[i + 1]: return False return True"},{"question":"Given an integer array `nums` of length `n`, your task is to find all the unique triplets `[nums[i], nums[j], nums[k]]` such that `i`, `j`, and `k` are distinct indices, and the sum of the triplet is zero. Return the list of all such unique triplets. The solution should not contain duplicate triplets and the order of the triplets does not matter. An example input could be `nums = [-1, 0, 1, 2, -1, -4]`, and the expected output would be `[[-1, 0, 1], [-1, -1, 2]]`. Ensure that your solution is efficient and can handle larger input sizes gracefully.","solution":"def three_sum(nums): Returns a list of unique triplets from nums such that the sum of the triplet is zero. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: # skip the same result continue left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return result"},{"question":"A company has `n` projects and a list of dependencies where each dependency is a pair of projects `[a, b]`, indicating that project `a` must be completed before project `b` can begin. Determine if it is possible to complete all projects. Implement a function `canFinishProjects(n, dependencies)` that returns `true` if all projects can be completed, and `false` otherwise. Use appropriate algorithms and data structures to ensure efficiency.","solution":"from collections import deque, defaultdict def canFinishProjects(n, dependencies): Determines if it\'s possible to finish all projects given their dependencies. Parameters: n (int): Total number of projects. dependencies (List[List[int]]): List of dependencies where each dependency is a pair [a, b]. Returns: bool: True if all projects can be completed, False otherwise. graph = defaultdict(list) in_degree = [0] * n for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return count == n"},{"question":"You are given an array `arr` of positive integers representing coordinates of houses along a street. There are `m` mailboxes to be relocated such that each mailbox can only service houses at its current coordinate or at a different coordinate of another house in the list. The cost of relocating a mailbox to a new coordinate is the sum of distances from each house to the new mailbox coordinate. Return _the minimum total relocation cost to service all houses with the new mailbox locations_.","solution":"def min_relocation_cost(houses, m): houses.sort() # Sort the coordinates of houses n = len(houses) if m >= n: return 0 dp = [[0] * n for _ in range(m + 1)] cost = [[0] * n for _ in range(n)] for i in range(n): for j in range(i, n): mid = (i + j) // 2 for k in range(i, j + 1): cost[i][j] += abs(houses[k] - houses[mid]) for i in range(n): dp[1][i] = cost[0][i] for i in range(2, m + 1): for j in range(i - 1, n): dp[i][j] = float(\'inf\') for k in range(i - 2, j): dp[i][j] = min(dp[i][j], dp[i - 1][k] + cost[k + 1][j]) return dp[m][n - 1]"},{"question":"You are given a singly linked list `head` which represents the head of the linked list. Each node in the list contains an integer value. Write a function to reverse every consecutive group of `k` nodes in the linked list. If the number of nodes is not a multiple of `k`, then reverse the last remaining nodes as is. Return the modified linked list after applying the reverse in groups of `k`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): if not head or k == 1: return head dummy = ListNode(0) dummy.next = head prev_group_end = dummy while True: k_end = prev_group_end for _ in range(k): k_end = k_end.next if not k_end: return dummy.next group_start = prev_group_end.next group_end = k_end.next prev_group_end.next = reverse(group_start, group_end) group_start.next = group_end prev_group_end = group_start def reverse(start, end): prev = None current = start while current != end: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"Given a list of words, you need to find the **longest word** that can be constructed one character at a time by **other words** in the list. * If multiple words have the same length, return the one that is lexicographically smallest. * For example, given the list `[\\"w\\",\\"wo\\",\\"wor\\",\\"worl\\",\\"world\\"]`, the longest word is `\\"world\\"` since its construction can be traced as `\\"w\\" -> \\"wo\\" -> \\"wor\\" -> \\"worl\\" -> \\"world\\"`. * If the list was `[\\"a\\",\\"banana\\",\\"app\\",\\"appl\\",\\"ap\\",\\"apply\\",\\"apple\\"]`, the longest word is `\\"apple\\"`.","solution":"def longest_word(words): Finds the longest word that can be constructed one character at a time by other words in the list. If multiple words have the same length, returns the one that is lexicographically smallest. words.sort() # Sort words to ensure lexicographical order word_set = set([\'\']) # Initialize with empty string to allow building from smallest strings longest = \\"\\" for word in words: if word[:-1] in word_set: word_set.add(word) if len(word) > len(longest): longest = word return longest"},{"question":"You are given an array of integers `arr` representing the sizes of packets of candies. Each child, when given a packet, wants to receive exactly `k` candies, no more and no less. You need to determine if it is possible to distribute all the packets to children such that each child gets exactly `k` candies. Each packet can only be given to one child and cannot be split. Return _true_ if it is possible to distribute all packets of candies with each child getting exactly `k` candies, otherwise, return _false_.","solution":"def can_distribute_all_packets(arr, k): Checks if it is possible to distribute all packets such that each child gets exactly k candies. Parameters: arr (list of int): List representing sizes of packets of candies. k (int): Number of candies each child should receive. Returns: bool: True if it is possible to distribute all packets to meet the requirement, False otherwise. if k == 0: return all(candy == 0 for candy in arr) for size in arr: if size % k != 0: return False return True"},{"question":"You are given an integer array `height`, where `height[i]` represents the height of a building at position `i`. The city has decided to place a billboard on exactly one of these buildings. The value of placing a billboard on the building at position `i` is calculated as the sum of the values of all buildings to its left (`0` to `i-1`) multiplied by the `height[i]`. Write a function `findBestPosition(height)` that returns the index `i` where placing the billboard yields the maximum sum. If there are multiple such positions, return the smallest index. If the array is empty or all buildings have height `0`, return `-1`.","solution":"def findBestPosition(height): Finds the index where placing a billboard yields the maximum sum of the values of all buildings to its left multiplied by the height of the building at that index. :param height: List[int], heights of buildings. :return: int, the index of the best position to place the billboard. if not height or all(h == 0 for h in height): return -1 max_value = float(\'-inf\') best_position = -1 current_sum = 0 for i in range(len(height)): if height[i] == 0: continue value = current_sum * height[i] if value > max_value: max_value = value best_position = i current_sum += height[i] return best_position"},{"question":"You are given two strings `s` and `t`, where `t` is a shuffled and possibly modified version of `s`. The modification can involve either inserting a new character or deleting a character from `s`. Your goal is to determine if `t` can be made identical to `s` by inserting at most one character or deleting at most one character. Return a boolean value _`true`_ if its possible to transform `t` into `s` by applying at most one insertion or deletion, and _`false`_ otherwise.","solution":"def can_transform(s, t): Determines if t can be transformed into s by inserting or deleting at most one character. len_s = len(s) len_t = len(t) if abs(len_s - len_t) > 1: return False i = j = 0 diff_count = 0 while i < len_s and j < len_t: if s[i] != t[j]: if diff_count == 1: return False diff_count += 1 if len_s > len_t: i += 1 elif len_s < len_t: j += 1 else: i += 1 j += 1 else: i += 1 j += 1 return True"},{"question":"You are given an integer `n` and a 2D array `edges` where each `edges[i] = [u, v]` represents a direct connection between two nodes `u` and `v`. Each node represents a city and each edge represents a two-way road between those cities. Find the **smallest number** of roads you need to remove to make the graph a **tree of n nodes**. A tree is an undirected graph where any two vertices are connected by exactly one path and has no cycles. If it\'s impossible to achieve, return `-1`.","solution":"def min_roads_to_remove(n, edges): Returns the smallest number of roads to remove to make the graph a tree of n nodes. If impossible, returns -1. from collections import defaultdict, deque # Check if it\'s even possible if len(edges) < n - 1: return -1 parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Connect all nodes and count redundancies for u, v in edges: union(u, v) unique_roots = len(set(find(i) for i in range(n))) # the graph needs to have exactly 1 connected component to be a tree return len(edges) - (n - 1) if unique_roots == 1 else -1"},{"question":"You are given a list `stations` where `stations[i] = (xi, yi, inneri, outeri)` represents a Wi-Fi station at coordinates `(xi, yi)` with an inner range radius of `inneri` and an outer range radius of `outeri`. A device at point `(a, b)` can connect to this station if it lies within the outer range but is not guaranteed a stable connection if it lies outside the inner range. Given the coordinates of a device `(a, b)`, return an integer representing the number of stations to which the device can connect with a stable connection. A stable connection means the distance between the device and the station must be less than or equal to `inneri`.","solution":"import math def count_stable_connections(stations, a, b): Counts how many stations provide a stable connection. Args: stations (list of tuples): List of tuples where each tuple represent a station (xi, yi, inneri, outeri). a, b (float): Coordinates of the device. Returns: int: Number of stations providing a stable connection. stable_count = 0 for (xi, yi, inneri, outeri) in stations: distance = math.sqrt((a - xi) ** 2 + (b - yi) ** 2) if distance <= inneri: stable_count += 1 return stable_count"},{"question":"A **special subsequence** of an integer array `nums` is defined as a sequence derived by deleting some or no elements of `nums` without changing the order of the remaining elements, and having a length that is a **prime number**. Given an integer array `nums`, return _the length of the longest special subsequence_. Two subsequences are different if there is some index `i` such that one has `nums[i]` while the other does not.","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def longest_special_subsequence_length(nums): n = len(nums) result = 0 # Iterate over all possible lengths for length in range(1, n + 1): if is_prime(length): result = length return result"},{"question":"A company has a list of job applicants, where each applicant is represented as a tuple `(name, score)`, with `name` being a string and `score` an integer. You need to write a function that returns the list of applicants sorted by their scores in non-decreasing order. If two applicants have the same score, they should be sorted alphabetically by their names. Assume that all applicants have unique names. Write a function `sort_applicants(applicants: List[Tuple[str, int]]) -> List[Tuple[str, int]]` that takes a list of tuples `(name, score)` and returns the list of tuples sorted as described.","solution":"from typing import List, Tuple def sort_applicants(applicants: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the list of applicants by their scores in non-decreasing order. If two applicants have the same score, they are sorted alphabetically by their names. Parameters: applicants (List[Tuple[str, int]]): A list of tuples where each tuple contains a name (str) and a score (int). Returns: List[Tuple[str, int]]: The sorted list of applicants. return sorted(applicants, key=lambda x: (x[1], x[0]))"},{"question":"You are given a linked list of integers. Implement a function to reverse the nodes of the linked list in `k`-group chunks and return the modified linked list. If the number of nodes is not a multiple of `k`, leave the remaining nodes as-is. Implement the function `ListNode* reverseKGroup(ListNode* head, int k)` where `ListNode` is defined as: ```cpp struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; ``` The function should: - Take as input the head of a linked list and an integer `k`. - Reverse the nodes of the linked list in `k`-groups. - Return the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): prev = None curr = head while k: next = curr.next curr.next = prev prev = curr curr = next k -= 1 return prev count = 0 node = head while node and count != k: node = node.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(node, k) return reversed_head return head"},{"question":"You are given a matrix `grid` of dimensions `m x n` with only values `0` (representing water) and `1` (representing land). An island is defined as a group of connected `1`s horizontally or vertically. You must determine the size of the largest island. If there is no land, return `0`. Write a function that returns the size of the largest island in the given `grid`.","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the cell as visited size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_island_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"You are given a binary tree and you need to implement functions that perform the following operations: * `insert(value)`: Inserts a value into the binary tree following the binary search tree property. Duplicate values are not allowed. * `delete(value)`: Removes a value from the binary tree if it exists and maintains the binary search tree property. * `exists(value)`: Checks whether a value exists in the binary tree and returns `True` if it does, otherwise returns `False`. * `find_min()`: Returns the smallest value in the binary tree. * `find_max()`: Returns the largest value in the binary tree. Implement these operations with the following complexity requirements: * The time complexity for `insert`, `delete`, and `exists` should be on average `O(log n)`. * The time complexity for `find_min` and `find_max` should be `O(1)` if the tree operates with a reference to the smallest and largest elements. Otherwise, it should be `O(h)` where `h` is the height of the tree.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) elif value > node.value: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) # if value == node.value, do nothing to avoid duplicates def delete(self, value): self.root = self._delete(self.root, value) def _delete(self, node, value): if node is None: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.value = min_larger_node.value node.right = self._delete(node.right, min_larger_node.value) return node def exists(self, value): return self._exists(self.root, value) def _exists(self, node, value): if node is None: return False if value == node.value: return True elif value < node.value: return self._exists(node.left, value) else: return self._exists(node.right, value) def find_min(self): if self.root is None: return None return self._find_min(self.root).value def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find_max(self): if self.root is None: return None return self._find_max(self.root).value def _find_max(self, node): current = node while current.right is not None: current = current.right return current"},{"question":"A **Binary Search Tree (BST)** is a data structure that maintains elements in a sorted order, allowing for efficient search, insertion, and deletion operations. Given the root of a BST and a value `val`, insert `val` into the BST such that the BST properties are maintained. Return _the root of the modified BST_. You can assume that `val` does not already exist in the BST and that `val` is a valid integer. The structure of a BST Node is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Implement a function: ```python def insert_into_bst(root: TreeNode, val: int) -> TreeNode: ``` that performs this insertion.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root: TreeNode, val: int) -> TreeNode: if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root"},{"question":"You are given a **2D binary matrix** `mat` of size `m x n`, where each cell contains either a `0` or a `1`. A `row` is a contiguous sequence of `1`s bordered by either `0`s or matrix boundaries. Identify and return the length of the **longest row** of `1`s in the matrix. If there are multiple rows with the same maximum length, return any one of them. For example, if the input matrix is: ``` [ [0, 1, 1, 0], [1, 1, 1, 1], [0, 0, 1, 1] ] ``` The function should return `4`, which is the length of the longest row of `1`s in the second row.","solution":"def longest_row_of_ones(mat): Returns the length of the longest row of 1s in the matrix mat. If there are multiple rows with the same maximum length, return any one of them. max_length = 0 for row in mat: current_length = 0 for val in row: if val == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"Given an array of `n` integers `arr`, return the length of the longest subarray that forms an increasing sequence. An increasing sequence is defined as `arr[i] < arr[i+1] < arr[i+2] < ... < arr[k]` for all valid indices `i` to `k`. If the array is empty or contains only one element, the longest subarray length is 1.","solution":"def longest_increasing_subarray_length(arr): Returns the length of the longest subarray that forms an increasing sequence. if not arr: return 0 if len(arr) == 1: return 1 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given a two-dimensional grid containing letters, where each cell has a single letter. Determine if there exists a sequence in the grid that spells out the given target word by moving sequentially adjacent cells. \\"Adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Return _a boolean indicating whether such a path exists in the grid for the target word_.","solution":"def exist(board, word): def dfs(board, word, i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[word_index]: return False temp = board[i][j] board[i][j] = \\"#\\" found = (dfs(board, word, i + 1, j, word_index + 1) or dfs(board, word, i - 1, j, word_index + 1) or dfs(board, word, i, j + 1, word_index + 1) or dfs(board, word, i, j - 1, word_index + 1)) board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"You are given a string `str`, which represents a sentence composed of multiple words. Write a function to return the longest word in the sentence. If there are multiple words with the same maximum length, return the word that appears first in the sentence. A **word** is defined as a sequence of non-space characters separated by space(s).","solution":"def longest_word(sentence): Returns the longest word in the sentence. If there are multiple words with the same maximum length, returns the word that appears first in the sentence. :param sentence: str, input sentence :return: str, the longest word in the sentence words = sentence.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"You are given a **0-indexed** integer array `arr` with the constraint that all elements are distinct. An inversion in an array is a pair of indices `(i, j)` such that `i < j` and `arr[i] > arr[j]`. Return _the **minimum** number of adjacent swaps required to sort the array in ascending order_.","solution":"def min_adjacent_swaps_to_sort(arr): Returns the minimum number of adjacent swaps required to sort the array in ascending order. def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort(arr, temp_arr, left, mid) inv_count += merge_sort(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort(arr, temp_arr, 0, n-1)"},{"question":"You are given an array of integers `nums` representing the number of balloons in various sections of a long hallway. Each balloon can be popped, and popping a balloon at index `i` results in a score equal to `nums[i - 1] * nums[i] * nums[i + 1]`, where `nums[-1]` and `nums[length]` are considered to be `1`. After popping a balloon at index `i`, the balloons at `i - 1` and `i + 1` become adjacent. Return the maximum score you can achieve by popping all the balloons optimally.","solution":"def maxCoins(nums): Given a list of integers representing the number of balloons in sections of a hallway, returns the maximum score achieved by popping all balloons optimally. # Pad nums with 1 at the start and end to handle edge cases nums = [1] + nums + [1] n = len(nums) # Create a memoization table to store the results of subproblems dp = [[0] * n for _ in range(n)] # Build the table dp[][] in bottom-up manner for length in range(2, n): # length is the range we consider for left in range(n - length): # left is the starting index right = left + length # right is the ending index set after the length # Initialize the score for (left, right) range dp[left][right] = 0 # Iterating in the range (left+1, right) for i in range(left + 1, right): # coins gained by popping the current balloon is nums[left] * nums[i] * nums[right] # adding the coins from previously solved subproblems dp[left][right] = max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]) return dp[0][n - 1]"},{"question":"Given an integer array `nums`, find the **longest increasing subsequence** such that the difference between consecutive elements is exactly one. Return the length of the longest increasing subsequence within `nums`. For example, given `nums = [1, 2, 3, 4, 2, 3, 4, 5]`: - One of the longest increasing subsequences is `[1, 2, 3, 4, 5]`, which has a length of 5. Note: The subsequence can include non-consecutive elements of the array, and you need to identify the longest sequence where each subsequent number is exactly one larger than the preceding number.","solution":"def longest_increasing_subsequence_with_difference_one(nums): Returns the length of the longest increasing subsequence such that the difference between consecutive elements is exactly one. :param nums: List[int] - list of integers :return: int - length of the longest increasing subsequence if not nums: return 0 n = len(nums) dp = {} longest_length = 0 for num in nums: if num-1 in dp: dp[num] = dp[num-1] + 1 else: dp[num] = 1 longest_length = max(longest_length, dp[num]) return longest_length"},{"question":"You are given a binary tree rooted at node `root`. Each node in the tree has a value between 0 and 9, represented by the `TreeNode` class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your task is to find the maximum value path from the root to any leaf node. The value of a path is calculated by concatenating the values of the nodes along the path to form an integer. Return the maximum value path as an integer. For example, for the following tree: ``` 1 / 2 3 / 4 5 ``` The paths would be 124, 125, and 13. Thus, the function should return 125.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_value_path(root): Returns the maximum value path from the root to any leaf node as an integer. def dfs(node, current_path): if node is None: return 0 current_path = current_path * 10 + node.val if node.left is None and node.right is None: return current_path left_max = dfs(node.left, current_path) right_max = dfs(node.right, current_path) return max(left_max, right_max) return dfs(root, 0)"},{"question":"You are given a string containing just the characters \'(\' and \')\'. You need to find the length of the longest valid (well-formed) parentheses substring. For instance, in the string \\"(()\\", the longest valid parentheses substring is \\"()\\", which has length 2. In the string \\")()())\\", the longest valid parentheses substring is \\"()()\\", which has length 4. Write a function `longestValidParentheses` that takes such a string `s` as input and returns the length of the longest valid parentheses substring.","solution":"def longestValidParentheses(s): Returns the length of the longest valid (well-formed) parentheses substring. Args: s (str): The input string containing just the characters \'(\' and \')\'. Returns: int: The length of the longest valid parentheses substring. max_len = 0 stack = [-1] # Initialize stack with -1 to handle base case where a valid substring starts at index 0 for i, char in enumerate(s): if char == \'(\': stack.append(i) else: # char == \')\' stack.pop() if not stack: stack.append(i) else: max_len = max(max_len, i - stack[-1]) return max_len"},{"question":"You are given an array of integers `arr` and an integer `target`. Return _the minimum number of operations required_ to reduce `target` to exactly 0 by subtracting elements of the array from it. In each operation, you can choose any element from the array and subtract it from the `target`. You may use the same element multiple times. If it\'s not possible to reduce `target` to exactly 0, return -1. Each element in the array is positive, and there may be duplicates in the array.","solution":"def min_operations_to_zero(arr, target): Returns the minimum number of operations required to reduce target to 0 by subtracting elements of the array. If it\'s not possible to reduce target to 0, return -1. dp = [float(\'inf\')] * (target + 1) dp[0] = 0 # Zero operations to reduce target 0 to 0 for t in range(1, target + 1): for num in arr: if t - num >= 0: dp[t] = min(dp[t], dp[t - num] + 1) return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"Given an integer matrix `grid` where each cell represents the elevation of a piece of land, calculate the maximum area of water that can be trapped in a valley when it rains. The water cannot flow off the edges of the grid. Note that the water level in each cell cannot exceed the height of any of its 4-directionally adjacent cells (up, down, left, right). **Return:** the maximum volume of water that can be trapped. **Example:** ``` Input: grid = [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] Output: 4 ```","solution":"import heapq def trap_rain_water(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] heap = [] # Push all the boundary cells into the heap for r in range(rows): heapq.heappush(heap, (grid[r][0], r, 0)) heapq.heappush(heap, (grid[r][cols - 1], r, cols - 1)) visited[r][0] = True visited[r][cols - 1] = True for c in range(1, cols - 1): heapq.heappush(heap, (grid[0][c], 0, c)) heapq.heappush(heap, (grid[rows - 1][c], rows - 1, c)) visited[0][c] = True visited[rows - 1][c] = True directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny]: water_trapped += max(0, height - grid[nx][ny]) heapq.heappush(heap, (max(height, grid[nx][ny]), nx, ny)) visited[nx][ny] = True return water_trapped"},{"question":"You are tasked with building a simple text editor which includes functionality to keep track of the word count in the document. Each word is defined as a contiguous sequence of letters (only `a`-`z` or `A`-`Z`). The editor should support the following three operations: 1. **Insert a word**: Adds a word to the document. 2. **Delete a word**: Removes the first occurrence of the specified word from the document. 3. **Get word count**: Returns the number of times a word appears in the document. Implement a class `TextEditor` with the following methods: - `insert(word: str) -> None`: Inserts the specified word into the document. - `delete(word: str) -> None`: Deletes the first occurrence of the specified word from the document. - `count(word: str) -> int`: Returns the count of the specified word in the document. Note: The text editor should handle case-insensitivity when performing operations on the document.","solution":"class TextEditor: def __init__(self): self.document = [] def insert(self, word: str) -> None: if word.isalpha(): self.document.append(word.lower()) def delete(self, word: str) -> None: word_lower = word.lower() if word_lower in self.document: self.document.remove(word_lower) def count(self, word: str) -> int: return self.document.count(word.lower())"},{"question":"You are given a 2D integer grid `grid` of size `m x n` representing an initial board configuration of the game of life. Each cell is either `0` (dead) or `1` (alive). The game of life evolves in steps, where each cell\'s state is updated based on its eight neighbors (horizontal, vertical, and diagonal adjacent cells) according to the following rules: 1. Any live cell with fewer than two live neighbors dies as if caused by under-population. 2. Any live cell with two or three live neighbors lives on to the next generation. 3. Any live cell with more than three live neighbors dies, as if by over-population. 4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function `gameOfLife(grid: List[List[int]]) -> None` to update the grid in place to its next state following the above rules. The next state is generated by applying the rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.","solution":"from typing import List def gameOfLife(grid: List[List[int]]) -> None: Update the \'grid\' in-place to the next state of the Game of Life. m, n = len(grid), len(grid[0]) # Helper function to calculate live neighbors of a cell def live_neighbors(r, c): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_count = 0 for dr, dc in directions: if 0 <= r + dr < m and 0 <= c + dc < n: live_count += grid[r + dr][c + dc] & 1 return live_count # Iterate through every cell to determine its next state for r in range(m): for c in range(n): live_count = live_neighbors(r, c) if grid[r][c] == 1 and (live_count < 2 or live_count > 3): # Live cells with fewer than two or more than three live neighbors die grid[r][c] = 1 # Setting the second bit to 0 (already 0 if &= 1) elif grid[r][c] == 1 and (live_count == 2 or live_count == 3): # Live cells with two or three live neighbors continue to live grid[r][c] = 3 # Mark it as live in next state (bit 1 kept as it is, bit 2 set to 1) elif grid[r][c] == 0 and live_count == 3: # Dead cells with exactly three live neighbors become alive grid[r][c] = 2 # Mark it as live in next state (bit 2 set to 1) # Update the grid to the next state by shifting bits for r in range(m): for c in range(n): grid[r][c] >>= 1"},{"question":"You are given an integer array `heights` where `heights[i]` represents the height of the `i-th` building, and another integer `bricks`. You want to jump from the first building to the last one, but you can only jump to a higher building if you use bricks equal to the difference in height between the buildings. In case two buildings are at the same height or the next building is lower, no bricks are needed. Calculate the minimum number of bricks required to jump from the first building to the last one such that all buildings are visited exactly once. If it is not possible to reach the last building with the given bricks, return `-1`.","solution":"def min_bricks_to_end(heights, bricks): Calculates the minimum number of bricks required to jump from the first building to the last one. If it is not possible within the given bricks, returns -1. :param heights: List[int] - List of building heights :param bricks: int - Total number of bricks available :return: int - Minimum bricks required or -1 if not possible total_bricks_needed = 0 for i in range(len(heights) - 1): if heights[i + 1] > heights[i]: diff = heights[i + 1] - heights[i] total_bricks_needed += diff if total_bricks_needed > bricks: return -1 return total_bricks_needed"},{"question":"You are given a **binary tree** with integer values. Write a function that returns the **inorder traversal** of the tree\'s nodes\' values as an array. Recall that the inorder traversal of a binary tree is performed by visiting the left subtree, the root node, and the right subtree. The tree is represented using TreeNode objects where each TreeNode has an integer value `val`, and two children: a left child `left` and a right child `right`. If the tree is empty, return an empty list.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree\'s nodes\' values as an array. def inorder(node, result): if node: inorder(node.left, result) result.append(node.val) inorder(node.right, result) result = [] inorder(root, result) return result"},{"question":"You are given a string `s` containing only lowercase letters. You need to compute the length of the longest substring of `s` that contains at most `k` distinct characters. If `k` is greater than or equal to the total number of distinct characters in `s`, return the length of the string `s`. Use the sliding window approach to solve this problem.","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring of `s` that contains at most `k` distinct characters. if k == 0: return 0 if k >= len(set(s)): return len(s) n = len(s) char_count = {} left = 0 max_len = 0 for right in range(n): char = s[right] char_count[char] = char_count.get(char, 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Suppose you are given an array of non-negative integers `nums` representing the amount of money of each house. Each house is arranged in a line, and you are a burglar who can steal from the houses. However, you can only steal from non-adjacent houses, meaning that you cannot steal from two consecutive houses. Write a function `maxRob(nums: List[int]) -> int` that returns the maximum amount of money you can rob tonight without alerting the police. The function should aim to maximize the sum of the stolen amounts while adhering to the non-adjacency rule.","solution":"from typing import List def maxRob(nums: List[int]) -> int: Returns the maximum amount of money that can be robbed from the houses without robbing two consecutive houses. if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"Given an integer array `arr` of length `n` where each element is at most `k` times its previous element (i.e., (arr[i] leq arr[i-1] * k) for all valid `i`), determine if it is possible to partition this array into one or more contiguous subarrays such that the sum of the elements in each subarray is equal. Return _true_ if such a partitioning is possible, otherwise _return false_. --- This question tests the ability to handle array partitioning and employs logical reasoning to determine if equal sum subarrays can be formed under given constraints.","solution":"def can_partition_equal_sum_subarrays(arr, k): Determine if the array can be partitioned into contiguous subarrays with equal sums. total_sum = sum(arr) n = len(arr) # If the total sum is not divisible by the length of array, we cannot partition it into equal sum subarrays if total_sum % n != 0: return False subarray_sum = total_sum // n current_sum = 0 partitions = 0 for num in arr: current_sum += num if current_sum == subarray_sum: partitions += 1 current_sum = 0 # If the number of partitions found is equal to the length of the array, return True return partitions == n"},{"question":"Create a class `FileSystem` that simulates a simple in-memory file management system. The file system supports two main operations: creating a file path and fetching a file\'s content. Implement the `FileSystem` class: * `FileSystem()` Initializes the file system. * `bool create(String path, String content)` Attempts to create a file at the specified path with the given content. Returns `true` if the file was successfully created; otherwise, returns `false`. The path should be a valid absolute path, starting from the root directory (`/`). * `String get(String path)` Returns the content of the file at the specified path. If the file does not exist, it returns an empty string. You may assume that all paths are valid and no path will be an empty string or contain trailing slashes.","solution":"class FileSystem: def __init__(self): Initializes the file system. self.files = {} def create(self, path, content): Creates a file at the specified path with the given content. :param path: str, absolute path of the file :param content: str, content of the file :return: bool, True if the file was created, False otherwise if path in self.files or \'/\' not in path: return False parent_path = \'/\'.join(path.split(\'/\')[:-1]) if parent_path != \'\' and parent_path not in self.files: return False self.files[path] = content return True def get(self, path): Returns the content of the file at the specified path. :param path: str, absolute path of the file :return: str, content of the file, or an empty string if the file does not exist return self.files.get(path, \\"\\")"},{"question":"You are given a **0-indexed** integer array `arr` where the first and last elements are non-zero. Each element in the array represents your maximum jump length at that position. You can assume you are initially positioned at the first index of the array. Your goal is to determine if you can reach the last index of the array, going through each step moving forward from your current index using the value at each index as the maximum number of steps you can take from there. Return `true` _if you can reach the last index, and_ `false` _otherwise._","solution":"def can_jump(arr): Determines if you can reach the last index from the first index. Parameters: arr (list): A list of integers where each element represents the maximum jump length at that position. Returns: bool: True if you can reach the last index, False otherwise. max_reach = 0 for i, jump in enumerate(arr): if i > max_reach: return False max_reach = max(max_reach, i + jump) if max_reach >= len(arr) - 1: return True return False"},{"question":"Write a function that takes a string `s` comprising only lowercase alphabets and returns the length of the longest substring with each unique character appearing an even number of times. For example, for the input `\\"aabbac\\"`, the longest substring where each character appears an even number of times is `\\"aabb\\"`, and its length is `4`. The function should efficiently handle strings of substantial length.","solution":"def longest_even_char_substring(s): Returns the length of the longest substring with each unique character appearing an even number of times. n = len(s) max_len = 0 prefix_xor = [0] * (n+1) first_occur = {0: -1} for i in range(n): # Update prefix xor for each character prefix_xor[i+1] = prefix_xor[i] ^ (1 << (ord(s[i]) - ord(\'a\'))) if prefix_xor[i+1] in first_occur: max_len = max(max_len, i - first_occur[prefix_xor[i+1]]) else: first_occur[prefix_xor[i+1]] = i return max_len"},{"question":"Given an array of `n` integers, return _an array of the counts of digits 0 through 9 for all non-negative integers in each element of the array_. For example, if an element is `234`, it will contribute to the counts of digits `2`, `3`, and `4`. Negative numbers should be ignored. Example: if the array is `[123, 456, 789, -101]`, the output should be `[1, 1, 1, 1, 1, 1, 1, 1, 1, 0]` because: - Digit `0` appears `0` times. - Digit `1` appears `1` time. - Digit `2` appears `1` time. - Digit `3` appears `1` time. - Digit `4` appears `1` time. - Digit `5` appears `1` time. - Digit `6` appears `1` time. - Digit `7` appears `1` time. - Digit `8` appears `1` time. - Digit `9` appears `0` times.","solution":"def digit_counts(arr): Given an array of n integers, return an array of the counts of digits 0 through 9 for all non-negative integers in each element of the array. Negative numbers are ignored. counts = [0] * 10 for num in arr: if num >= 0: for digit in str(num): counts[int(digit)] += 1 return counts"},{"question":"You are given a string s consisting of lowercase English letters. You need to perform a series of transformations to make the string palindrome. In a single step, you can replace any character of the string with any other character. Find the minimum number of steps required to make the string palindrome. A string is considered a palindrome if it reads the same backward as it does forward. For example, given `s = \\"abca\\"`, the minimum number of steps to make it a palindrome is 1 because you can replace the first or the last \'a\' with \'b\' to make it \\"abcba\\" or \\"acbca\\". Write a function `minStepsToPalindrome(s)` that returns an integer representing the minimum number of steps required to transform the string `s` into a palindrome.","solution":"def minStepsToPalindrome(s): Returns the minimum number of steps required to make the string s a palindrome. n = len(s) steps = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: steps += 1 return steps"},{"question":"You are given a string `s` which represents a valid mathematical expression containing only non-negative integers, `+`, `-`, `*`, `/` operators, and empty spaces. The expression should be evaluated following the standard operator precedence and associativity rules. Implement a function to evaluate and return the result of the expression. Your solution should not use any built-in library methods to solve the problem directly. **Note:** You should handle the division in integer format, truncating towards zero.","solution":"def evaluate_expression(s): Evaluate the given string mathematical expression `s` containing non-negative integers and operators +, -, *, /. Handle the division in integer format, truncating towards zero. :param s: str :return: int def operate(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return int(a / b) # to truncate towards zero num_stack = [] op_stack = [] i = 0 n = len(s) while i < n: if s[i].isdigit(): num = 0 while i < n and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 num_stack.append(num) # Debug: print current num_stack print(f\\"num_stack: {num_stack}\\") else: if s[i] in \\"+-*/\\": while (op_stack and (op_stack[-1] in \\"*/\\" or (op_stack[-1] in \\"+-\\" and s[i] in \\"+-\\"))): num2 = num_stack.pop() num1 = num_stack.pop() op = op_stack.pop() result = operate(num1, num2, op) num_stack.append(result) # Debug: print after operation print(f\\"Operate: {num1} {op} {num2} = {result}, num_stack: {num_stack}\\") op_stack.append(s[i]) # Debug: print op_stack print(f\\"op_stack: {op_stack}\\") i += 1 while op_stack: num2 = num_stack.pop() num1 = num_stack.pop() op = op_stack.pop() result = operate(num1, num2, op) num_stack.append(result) # Debug: print after operation print(f\\"Final Operate: {num1} {op} {num2} = {result}, num_stack: {num_stack}\\") return num_stack[0]"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` positive integers. You can choose an integer `k` where `1 <= k <= n` and partition the array into exactly `k` **non-empty** contiguous subarrays. The **cost** of a partition is the **sum** of the largest elements of each subarray. Return _the **minimum possible cost** to partition `nums`._ For example, if `nums = [2, 3, 1, 4]` and you choose `k = 2` and partition into subarrays `[2, 3, 1]` and `[4]`, the cost is `max([2, 3, 1]) + max([4]) = 3 + 4 = 7`. You may partition the array into fewer subarrays to minimize the cost.","solution":"from functools import lru_cache def min_cost_partition(nums): @lru_cache(None) def dp(i, k): if k == 1: return max(nums[:i]) min_cost = float(\'inf\') for j in range(1, i): min_cost = min(min_cost, max(nums[j:i]) + dp(j, k-1)) return min_cost return min(dp(len(nums), k) for k in range(1, len(nums)+1))"},{"question":"You are given a list of `points` in the 2D plane. Each point is represented as a coordinate pair `[x, y]`. Your task is to determine if a set of four of these points can form a square. A square is defined as a quadrilateral with four equal sides and four right angles. Write a function `isValidSquare(points: List[List[int]]) -> bool` that returns `True` if there exists a subset of four points that can form a square, and `False` otherwise. Keep the function signature consistent and consider edge cases such as less than four points or duplicate points in the list. The function should ideally be optimized for efficiency, taking into account the properties of Euclidean distance and perpendicular lines regarding the coordinates.","solution":"from typing import List from itertools import combinations def distance_squared(p1, p2): return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 def is_square(p1, p2, p3, p4): distances = [ distance_squared(p1, p2), distance_squared(p1, p3), distance_squared(p1, p4), distance_squared(p2, p3), distance_squared(p2, p4), distance_squared(p3, p4) ] distances.sort() return distances[0] > 0 and distances[0] == distances[1] == distances[2] == distances[3] and distances[4] == distances[5] def isValidSquare(points: List[List[int]]) -> bool: if len(points) < 4: return False for quad in combinations(points, 4): if is_square(*quad): return True return False"},{"question":"You are given a **0-indexed** array of integers `arr`, where each element is either a `0` or a `1`. You can flip one `0` to a `1` or one `1` to a `0` in a single operation. Return the length of the longest contiguous subarray that contains the same number of `0`s and `1`s after performing at most one operation.","solution":"def longest_equal_subarray(arr): def longest_balanced_subarray(arr, x, y): prefix_sum = 0 sum_indices = {0: -1} max_len = 0 for i, num in enumerate(arr): if num == x: prefix_sum += 1 else: prefix_sum -= 1 if prefix_sum in sum_indices: max_len = max(max_len, i - sum_indices[prefix_sum]) else: sum_indices[prefix_sum] = i return max_len count_zero = arr.count(0) count_one = arr.count(1) max_len = longest_balanced_subarray(arr, 0, 1) if count_zero > 0: max_len = max(max_len, longest_balanced_subarray([1 - num if i == 0 else num for i, num in enumerate(arr)], 0, 1)) if count_one > 0: max_len = max(max_len, longest_balanced_subarray([1 - num if i == 1 else num for i, num in enumerate(arr)], 0, 1)) return max_len"},{"question":"Given an array of `n` positive integers representing the heights of `n` buildings, arrange them in such a way that the water trapped between them after a rain can be maximized. You need to return the maximum amount of water that can be trapped. An array of heights `heights = [h1, h2, ..., hn]` serves as an elevation map where the width of each bar is 1, and `hi` represents the height of the `i-th` building. The water that can be trapped between two buildings is determined by the difference in height between them, taking into account any intermediate buildings. For example, given `heights = [0,1,0,2,1,0,1,3,2,1,2,1]`, the maximum amount of water that can be trapped is 6.","solution":"def trap(height): Calculate the maximum water that can be trapped. :param height: List[int] representing the heights of buildings. :return: int, the total amount of trapped water. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water += max(0, right_max - height[right]) return water"},{"question":"Given a string of parentheses `s`, write a function to determine the maximum nesting depth of the parentheses. The depth of a parenthesis pattern `()(()())` is defined as the maximum number of nested parentheses in depth. `()` has a depth of 1, `(()())` has a depth of 2, and `((()))` has a depth of 3. Return an integer representing the maximum depth of the string. The input string is guaranteed to be a valid parenthesis string.","solution":"def max_nesting_depth(s): Returns the maximum nesting depth of the parentheses in string s. :param s: str - a string containing only valid parentheses :return: int - the maximum depth of nested parentheses max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"You are given an integer array `arr` and an integer `k`. Your task is to determine if there are two distinct indices `i` and `j` in the array such that `arr[i]` is evenly divisible by `arr[j]` or vice versa, and the absolute difference between `i` and `j` is at most `k`. Return a boolean result  `true` if such elements exist and `false` otherwise.","solution":"def find_indices(arr, k): Determines whether there are two distinct indices i and j in arr such that arr[i] is divisible by arr[j] or vice versa and the absolute difference between i and j is at most k. Parameters: arr (list): List of integers. k (int): Maximum allowed absolute difference between indices. Returns: bool: True if such elements exist, False otherwise. n = len(arr) for i in range(n): for j in range(max(0, i - k), min(n, i + k + 1)): if i != j and (arr[i] % arr[j] == 0 or arr[j] % arr[i] == 0): return True return False"},{"question":"Given a string `s` that consists of only digits and lowercase English letters, return the number of substrings that contain only unique characters. A substring is defined as a contiguous sequence of characters within a string. For example, for the string `\\"abcabc\\"`, the substrings `\\"abc\\"`, `\\"bca\\"`, and `\\"cab\\"` have only unique characters. Similarly, for the string `\\"aab\\"`, the substrings `\\"a\\"` and `\\"ab\\"` have only unique characters.","solution":"def count_unique_substrings(s): Returns the number of substrings that contain only unique characters. n = len(s) count = 0 for i in range(n): seen = set() for j in range(i, n): if s[j] in seen: break seen.add(s[j]) count += 1 return count"},{"question":"You are given a list of `n` integers representing the heights of buildings in a row. The list is guaranteed to be non-empty. Your task is to find the **maximum area** of a rectangle that can be formed by choosing any two buildings and using the shorter of the two heights as the rectangle\'s height. The width of the rectangle is measured by the distance between the two buildings. Return the maximum possible area. Example: Given the list `[1,8,6,2,5,4,8,3,7]`, the maximum area would be `49`.","solution":"def max_area(heights): Calculates the maximum area of a rectangle that can be formed by any two buildings in the list using the shorter of the two heights. :param heights: List of integers representing heights of buildings. :return: The maximum possible area. max_area = 0 left = 0 right = len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) # Move the pointers to try and find a potentially greater area if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a **0-indexed** integer array `arr` consisting of **positive** integers. Your task is to rearrange the elements of `arr` such that the difference between every consecutive pair of elements is minimized. Formally, if rearranged array is `b`, you need to minimize the value of `max(abs(b[i] - b[i+1]))` for all possible values of `i` where `0 <= i < len(arr) - 1`. Return the rearranged array. The output should be any one of the possible solutions if there are multiple valid rearrangements.","solution":"def rearrange_array(arr): Rearranges arr such that the difference between every contiguous pair of elements is minimized. # Sort the array arr_sorted = sorted(arr) # The sorted array itself minimizes the differences between consecutive elements. return arr_sorted"},{"question":"Given an undirected graph represented as an adjacency list, determine if the graph is bipartite. A bipartite graph is one that can be colored using two colors such that no two adjacent vertices share the same color. Implement a function that returns `true` if the graph is bipartite and `false` otherwise. The graph is represented as an adjacency list where `graph[i]` is a list of all the vertices connected to vertex `i`. Example: ```plaintext Input: graph = [[1, 3], [0, 2], [1, 3], [0, 2]] Output: true Explanation: We can create a bipartite graph with two sets {0, 2} and {1, 3}. ```","solution":"def is_bipartite(graph): Determines if the given graph is bipartite. :param graph: List[List[int]] - adjacency list representing the graph. :return: bool - True if the graph is bipartite, otherwise False. color = {} def dfs(node, c): if node in color: return color[node] == c color[node] = c return all(dfs(nei, c ^ 1) for nei in graph[node]) return all(dfs(node, 0) for node in range(len(graph)) if node not in color)"},{"question":"You are given two integer arrays `nums1` and `nums2` of lengths `n1` and `n2`, respectively. You can complete the following operation on `nums1` any number of times: remove the first element from `nums1` and append it to the end of `nums1`. A pair `(a, b)` is called valid if there is an index `i` such that `nums1[i + 1] = a` and `nums2[i] = b`. Return the minimum number of operations required to make at least one valid pair exist between the two arrays. If it is not possible to create a valid pair, return `-1`.","solution":"def min_operations_to_create_valid_pair(nums1, nums2): Returns the minimum number of operations needed to make at least one valid pair (a, b) exist, where a and b satisfy the problem condition. If it is not possible, returns -1. n1, n2 = len(nums1), len(nums2) # It\'s impossible if nums1 length is less than or equal to nums2, because we can\'t find a valid \\"i\\" if n1 <= n2: return -1 # Check cyclic shifts on nums1 for k in range(n1): for i in range(min(n1 - k - 1, n2)): if nums1[k + i + 1] == nums2[i]: return k return -1"},{"question":"You are given an integer array `prices` representing the price of a stock on different days, and an integer `fee` representing a transaction fee. Write an algorithm to find the maximum profit you can achieve after performing multiple transactions involving buying and selling the stock. Note: You may complete as many transactions as you like, but you need to pay the transaction fee for each purchase. However, you may not have more than one share of the stock at a time (i.e., you must sell the stock before you buy again). Compose a function `int maxProfit(int[] prices, int fee)` that returns the maximum profit you can achieve. Example: Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: - Buy on day 1 (price = 1) and sell on day 4 (price = 8), profit = 8-1-2 = 5. - Buy on day 5 (price = 4) and sell on day 6 (price = 9), profit = 9-4-2 = 3. Total profit is 5 + 3 = 8.","solution":"def maxProfit(prices, fee): n = len(prices) if not prices or n < 2: return 0 cash, hold = 0, -prices[0] for price in prices: # Store the previous cash value prev_cash = cash # Update cash to either keep it as is, # or sell the stock we\'re holding (paying the fee) cash = max(cash, hold + price - fee) # Update hold to either keep it as is, # or buy the stock with the current price (spending cash) hold = max(hold, prev_cash - price) return cash"},{"question":"You need to design a data structure capable of tracking historical versions of an array which allows you to modify the array and revert it back to a previous state. The operations you need to support are: * `VersionedArray(int length)`: Initializes the object with the specified length array filled with zeros. * `void set(int index, int value)`: Updates the element at the specified index in the current version of the array to the given value. * `int get(int index)`: Retrieves the value of the element at the specified index in the current version of the array. * `int snapshot()`: Takes a snapshot of the array and saves it as a new version, returning the version number of the snapshot taken. * `void revert(int version)`: Reverts the array to the state saved in the given snapshot version. If the version does not exist, this operation should do nothing. You are expected to implement this functionality efficiently so that all operations run with optimal time complexity.","solution":"class VersionedArray: def __init__(self, length): Initializes the object with the specified length array filled with zeros. self.current = [0] * length self.snapshots = [] def set(self, index, value): Updates the element at the specified index in the current version of the array to the given value. self.current[index] = value def get(self, index): Retrieves the value of the element at the specified index in the current version of the array. return self.current[index] def snapshot(self): Takes a snapshot of the array and saves it as a new version, returning the version number of the snapshot taken. self.snapshots.append(self.current[:]) return len(self.snapshots) - 1 def revert(self, version): Reverts the array to the state saved in the given snapshot version. If the version does not exist, this operation should do nothing. if 0 <= version < len(self.snapshots): self.current = self.snapshots[version][:]"},{"question":"You are given an array `heights` representing the heights of buildings where `heights[i]` is the height of the `i-th` building, and an integer `maxHeight` representing the maximum height a building is allowed to be. You need to determine the maximum number of operations required to make all the buildings\' heights not exceed `maxHeight`, where an operation is defined as: 1. Decreasing the height of a building by 1 unit. Return _the maximum number of operations required_. **Example:** - Input: `heights = [5, 8, 6, 4]`, `maxHeight = 5` - Output: `4` **Explanation:** - Decrease the height of the second building from 8 to 5 (3 operations). - Decrease the height of the third building from 6 to 5 (1 operation). - Total operations = 3 + 1 = 4. Note: - If a building already has a height less than or equal to `maxHeight`, no operation is required for that building.","solution":"def max_operations_to_limit_heights(heights, maxHeight): Returns the maximum number of operations required to make all building heights not exceed maxHeight. Parameters: heights (list of int): A list of integers representing heights of buildings. maxHeight (int): The maximum height a building is allowed to be. Returns: int: The maximum number of operations required. operations = 0 for height in heights: if height > maxHeight: operations += (height - maxHeight) return operations"},{"question":"Given an array of integers `nums`, you need to design a data structure that supports the following operations efficiently: - **add(num)**: Adds the integer `num` to the data structure. - **find(target)**: Returns `true` if there exists any pair of integers whose sum is equal to the `target`, otherwise returns `false`. Implement the `TwoSum` class: - `TwoSum()` Initializes the TwoSum object. - `void add(int number)` Adds the number `number` to the internal data structure. - `boolean find(int value)` Returns `true` if there exists any pair of numbers which sum is equal to `value`, otherwise returns `false`. Note: You can assume that all elements added to the data structure are integers.","solution":"class TwoSum: def __init__(self): Initialize your data structure here. The data structure will use a dictionary to keep track of the numbers and their frequencies. self.num_counts = {} def add(self, number): Add the number to the data structure. if number in self.num_counts: self.num_counts[number] += 1 else: self.num_counts[number] = 1 def find(self, value): Find if there exists any pair of integers which sum is equal to the value. for num in self.num_counts: complement = value - num if complement in self.num_counts: if complement != num or self.num_counts[num] > 1: return True return False"},{"question":"You are given an array of integers `numbers` where each element `numbers[i]` represents a different stock price on the `i-th` day. You are also given an integer `k`. You can only complete at most one transaction, which means you can buy one and sell one share of the stock within the timeframe of `k` days. Write a function that returns the maximum profit you can achieve. If no profit can be achieved, return 0. A transaction is a sequence of one buy followed by one sell within `k` days and must satisfy `sell_day > buy_day`. Note that `k` is always greater than or equal to the length of the `numbers` array.","solution":"def maxProfitWithinKDays(numbers, k): Returns the maximum profit that can be achieved from at most one transaction within k days. If no profit can be achieved, returns 0. if not numbers or len(numbers) < 2: return 0 min_price = float(\'inf\') max_profit = 0 for price in numbers: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"A company has a list of employees, each identified by a unique ID number. However, due to an error in the database, some employees\' ID numbers have been classified incorrectly. For each employee, their ID number should be increased by the sum of the digits of their current ID number to correct the error. For instance, if an employee\'s ID number is `456`, the correct ID number should be `456 + (4 + 5 + 6) = 471`. Given a list of ID numbers, return a new list of corrected ID numbers. The input is an array of integers representing the original ID numbers. Write a function that performs this correction for each ID number in the list. Return the list of corrected ID numbers in the same order they appeared in the input list.","solution":"def correct_id_numbers(id_numbers): Returns a list of corrected ID numbers. Each ID number is increased by the sum of its digits. Parameters: id_numbers (list of int): A list of original ID numbers. Returns: list of int: A list of corrected ID numbers. def sum_of_digits(n): return sum(int(digit) for digit in str(n)) corrected_numbers = [ id_number + sum_of_digits(id_number) for id_number in id_numbers ] return corrected_numbers"},{"question":"Given an `n x n` grid where some cells are empty (represented by `0`) and some cells are obstacles (represented by `1`), you are initially positioned at the top-left corner (i.e., `grid[0][0]`). You can only move right or down. Your goal is to find the number of unique paths from the top-left corner to the bottom-right corner (i.e., `grid[n-1][n-1]`) while avoiding the obstacles. If there\'s no valid path, return `0`. Implement a function `int uniquePathsWithObstacles(int[][] grid)` that takes a `2D` array `grid` as input and returns the number of unique paths from `grid[0][0]` to `grid[n-1][n-1]`.","solution":"def uniquePathsWithObstacles(grid): Returns the number of unique paths from top-left corner to bottom-right corner avoiding obstacles. if not grid or grid[0][0] == 1: return 0 n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"You are given a binary tree where each node contains an integer value. Find the path in the tree that maximizes the sum of the node values, and return the sum. A path starts at any node and can end at any node in the tree, traversing parent-child connections (both upwards and downwards are allowed). The path must contain at least one node and does not need to pass through the root. Consider the following helper class definition for a binary tree node: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum path sum of the given binary tree. def dfs(node): if not node: return (0, float(\'-inf\')) # Returns (max path sum including this node, max path sum in subtree) left_single, left_max = dfs(node.left) right_single, right_max = dfs(node.right) single_path_sum = max(left_single, right_single, 0) + node.val max_sum_at_node = max(left_single + node.val + right_single, single_path_sum) return single_path_sum, max(max_sum_at_node, left_max, right_max) return dfs(root)[1]"},{"question":"You are given a list of unique integers `nums` where each integer is between `1` and `n` (inclusive), and `n` is the length of the list. Find the missing integer in the sequence and return it. For example, if `nums = [3, 7, 1, 2, 8, 4, 5]` and `n = 8`, the missing integer is `6`. The list `nums` contains every number from `1` to `n` except for the number `6`, hence the function should return `6`.","solution":"def find_missing_number(nums): Given a list of unique integers nums where each integer is between 1 and n (inclusive). Finds and returns the missing integer in the sequence. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"Given a list of positive integers representing the heights of buildings and a positive integer `d`, write a function to determine the maximum number of buildings you can paint starting from the first building in the list, moving to the right, such that the height difference between any two consecutive buildings you paint is at most `d`. Return the maximum number of buildings you can paint. For example, given the list of heights `[2, 3, 8, 4, 6]` and `d` equal to `2`, you can paint a maximum of `4` buildings by painting the first (`2`), second (`3`), fourth (`4`), and fifth (`6`) buildings since the differences between consecutive painted buildings are within `2`.","solution":"def max_buildings_to_paint(heights, d): Determine the maximum number of buildings you can paint starting from the first building in the list, moving to the right, such that the height difference between any two consecutive buildings you paint is at most `d`. Parameters: heights (list): List of positive integers representing the heights of buildings d (int): A positive integer representing the maximum allowed height difference Returns: int: The maximum number of buildings you can paint # Initialize count of buildings that can be painted count = 1 last_height = heights[0] for i in range(1, len(heights)): if abs(heights[i] - last_height) <= d: count += 1 last_height = heights[i] return count"},{"question":"You are given a matrix `mat` of size `m x n` consisting of non-negative integers. Your task is to find the smallest value in each row and then return a list containing the largest value among these smallest values from all rows. Implement the function `largestOfRowMin(mat: List[List[int]]) -> int` that takes the matrix `mat` as input and returns an integer representing the largest value among the smallest values of each row. For example, given the matrix `[[3, 7, 8], [9, 2, 5], [1, 4, 6]]`, the smallest values in each row are `[3, 2, 1]`, and the largest value among them is `3`.","solution":"from typing import List def largestOfRowMin(mat: List[List[int]]) -> int: Returns the largest value among the smallest values in each row of the matrix. :param mat: List[List[int]] - Input matrix of non-negative integers :return: int - Largest value among the smallest values of each row if not mat or not mat[0]: return float(\'-inf\') # Define behavior for empty matrix as returning negative infinity row_mins = [min(row) for row in mat] return max(row_mins)"},{"question":"You are given a 2D list `grid` of size `m x n` where each cell represents a plot of land. Each cell can either be `0` (empty plot) or `1` (plot that contains a building). You want to build a plaza so that the total travel distance from the plaza to all buildings is minimized. The travel distance between two cells `(r1, c1)` and `(r2, c2)` is defined as the absolute difference in the row numbers plus the absolute difference in the column numbers: `|r1 - r2| + |c1 - c2|`. Return the minimum total travel distance from the plaza to all buildings. If there is no empty plot to build the plaza, return `-1`.","solution":"def min_total_travel_distance(grid): Returns the minimum total travel distance from the plaza to all buildings or -1 if no empty plot is available. if not grid: return -1 rows = [] cols = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: rows.append(i) cols.append(j) if not rows: return -1 # No buildings to determine travel distance from if len(rows) == len(grid) * len(grid[0]): return -1 # No empty plot to build plaza rows.sort() cols.sort() median_row = rows[len(rows) // 2] median_col = cols[len(cols) // 2] min_distance = sum(abs(row - median_row) for row in rows) + sum(abs(col - median_col) for col in cols) return min_distance"},{"question":"You are given an array of integers `arr` and a series of queries `queries`. Each query is represented by two integers **[x, y]**, which require you to find the bitwise AND of the segment `arr[x...y]` inclusive. Return an array of results for each query. Example: ```python arr = [1, 3, 5, 7] queries = [[0, 1], [1, 2], [0, 3]] ``` Output: ```python [1 & 3, 3 & 5, 1 & 3 & 5 & 7] # [1, 1, 1] ```","solution":"def range_bitwise_and(arr, queries): Function to compute the bitwise AND for each query interval [x, y] in the array arr. Parameters: arr (list): The array of integers. queries (list): A list of queries, each containing two integers [x, y]. Returns: list: A list of results for each query. results = [] for x, y in queries: result = arr[x] for i in range(x + 1, y + 1): result &= arr[i] results.append(result) return results"},{"question":"You are given a list of events, each represented by a start time and an end time over a given day in minutes from `0` to `1440` (representing the beginning to the end of the day). Each event is represented as a list `[startTime, endTime]`. You need to determine the maximum number of events that you can attend without overlapping. Two events overlap if and only if one events start time is less than the other events end time and one events end time is greater than the other events start time. You are given a 2D list `events`, where each `events[i] = [startTimei, endTimei]`. Return _the maximum number of non-overlapping events that you can attend._","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events. Parameters: events (list[list[int]]): A list of events where each event is represented by [startTime, endTime] Returns: int: The maximum number of non-overlapping events. # Sort events based on their end times events.sort(key=lambda x: x[1]) # Initialize counters max_events = 0 last_end_time = 0 # Loop through sorted events and select non-overlapping events for event in events: if event[0] >= last_end_time: max_events += 1 last_end_time = event[1] return max_events"},{"question":"You are managing a reservation system for a small conference room. There are a series of bookings represented as a list of tuples `bookings`, where each tuple `(start, end)` represents the time the booking starts and ends. Each booking starts and ends on the hour and is represented in 24-hour format. Assume the room is available from `00:00` to `23:59` each day. Given a new booking request represented as a tuple `newBooking`, write a function to determine if the new booking can be scheduled without conflicting with the existing bookings. Return `true` if it can be scheduled, otherwise return `false`. A booking `(start1, end1)` is considered to conflict with another booking `(start2, end2)` if `start1 < end2` and `start2 < end1`.","solution":"def can_schedule(bookings, newBooking): Determines if a new booking can be scheduled without conflicting with existing bookings. Parameters: bookings (list of tuples): A list of tuples where each tuple contains two integers representing the start and end time of existing bookings. newBooking (tuple): A tuple containing two integers representing the start and end time of the new booking. Returns: bool: True if the new booking can be scheduled without conflicting, False otherwise. new_start, new_end = newBooking for start, end in bookings: if new_start < end and start < new_end: return False return True"},{"question":"You are given an array of unique integers `nums` representing a set of numbers from `1` to `n` such that one number between `1` and `n` is missing from the array. Write a function that finds and returns the missing number. The falsey number can be identified using the inequality sum of integers formula. For example, if `nums = [3, 7, 1, 2, 8, 4, 5]` and the array should contain numbers from `1` to `8`, then the missing number would be `6`. **Your function should be efficient in terms of time and space complexities.**","solution":"def find_missing_number(nums): Finds and returns the missing number in an array containing unique integers from 1 to n with one missing number. Parameters: nums: list of int Returns: int: the missing number n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"A company records the prices of their product over `n` consecutive days in an array `prices` where `prices[i]` represents the price of the product on the `i`-th day. They offer a special discount policy as follows: If the price of the product on day `j` is strictly lower than its price on day `i` and `j` is after `i`, then the product will be sold at a discount, and the price on day `i` will be reduced by the price on day `j`. Write a function that returns an array `final_prices` where `final_prices[i]` is the final price of the product on the `i`-th day after applying the discount policy. If no such `j` exists for day `i`, then the price remains the same. Example: Input: prices = [8, 4, 6, 2, 3] Output: [4, 2, 4, 2, 3] Explanation: - On day 0, the price is reduced by the price of day 1 (8 - 4 = 4). - On day 1, the price is reduced by the price of day 3 (4 - 2 = 2). - On day 2, the price is reduced by the price of day 3 (6 - 2 = 4). - On day 3, the price does not change as there is no price lower after it. - On day 4, the price does not change as there is no price lower after it.","solution":"def final_prices(prices): This function returns the final prices after applying the discount policy. n = len(prices) final_prices = prices[:] for i in range(n): for j in range(i + 1, n): if prices[j] < prices[i]: final_prices[i] -= prices[j] break return final_prices"},{"question":"You are given an integer array `heights` representing the heights of buildings, where `heights[i]` is the height of the building at index `i`. The array is **0-indexed** and contains `n` buildings. A \\"viewing platform\\" is defined as a set of buildings where a person standing on top of each building can see all other buildings in that set without their view being blocked by a taller building in between. Return the **maximum size** of any viewing platform that can be formed. A viewing platform is valid if for every pair of indices `(i, j)` in the subset, there does not exist an index `k` such that `i < k < j` and `heights[k] > min(heights[i], heights[j])`.","solution":"def max_viewing_platform(heights): Returns the maximum size of any viewing platform that can be formed. n = len(heights) if n == 0: return 0 max_platform_size = 1 for start in range(n): current_min = heights[start] current_platform_size = 1 for end in range(start + 1, n): if heights[end] >= current_min: current_platform_size += 1 max_platform_size = max(max_platform_size, current_platform_size) current_min = heights[end] else: break return max_platform_size"},{"question":"Given a binary tree where each node has an integer value, return the sum of all values in the binary tree. You may assume that the binary tree is non-empty and well-formed. Define a function `sumOfTree` that takes the root node of the binary tree and returns the sum of all the values. Example: ``` 1 / 2 3 / 4 5 ``` For the above tree, `sumOfTree(root)` should return 15. Notes: - You may use any tree traversal method (e.g., pre-order, in-order, post-order, level-order), but ensure that all node values are included in the sum. - Consider both iterative and recursive approaches, but your function must handle the tree correctly regardless of depth.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfTree(root): Returns the sum of all values in the binary tree. if not root: return 0 return root.val + sumOfTree(root.left) + sumOfTree(root.right)"},{"question":"You are given a string `str` consisting of lowercase English letters and a string `sub` also consisting of lowercase English letters. You need to determine all the starting indices in `str` where `sub` is a contiguous substring. Your solution should be efficient in both time and space complexity. For example: ``` Input: str: \\"ababcabc\\" sub: \\"abc\\" Output: [2, 5] ``` Ensure your solution runs in `O(n + m)` time, where `n` is the length of `str` and `m` is the length of `sub`. You can assume that both `str` and `sub` are non-empty.","solution":"def find_substring_indices(s, sub): Returns a list of starting indices in the string `s` where the string `sub` is a contiguous substring. Parameters: s (str): the main string in which to search for the substring sub (str): the substring to search for in the main string Returns: list: a list of starting indices where the substring `sub` occurs in the string `s` # The length of the main string and the substring n, m = len(s), len(sub) result = [] # Use the sliding window technique and direct comparison for i in range(n - m + 1): if s[i:i + m] == sub: result.append(i) return result"},{"question":"You are given a robot starting at position (0, 0) in an infinite grid. The robot can move in four directions denoted by \'U\' (up), \'D\' (down), \'L\' (left), and \'R\' (right). The program needs to determine whether the robot returns to its original position after performing a given sequence of moves. Implement the `Robot` class: * `Robot()` Initializes the robot at position (0, 0). * `void move(char direction)` Moves the robot one step in the given direction. * `boolean isAtOrigin()` Returns true if the robot is at the origin (0, 0); otherwise, returns false. Notes: - The `direction` parameter in the `move` method is guaranteed to be one of \'U\', \'D\', \'L\', or \'R\'.","solution":"class Robot: def __init__(self): self.x, self.y = 0, 0 def move(self, direction): if direction == \'U\': self.y += 1 elif direction == \'D\': self.y -= 1 elif direction == \'L\': self.x -= 1 elif direction == \'R\': self.x += 1 def isAtOrigin(self): return self.x == 0 and self.y == 0"},{"question":"You are given a rectangle grid represented by a 2D list `grid` where each cell contains an integer. You need to implement the `GridSum` class that supports the following operations: * `GridSum(int[][] grid)` - Initializes the object with the given `grid`. * `void update(int row, int col, int val)` - Sets the value at position (row, col) in the grid to `val`. * `int sumRegion(int row1, int col1, int row2, int col2)` - Returns the sum of the elements within the rectangle defined by (row1, col1) and (row2, col2), inclusive. The test cases are generated such that all the calls to `sumRegion` will always be valid.","solution":"class GridSum: def __init__(self, grid): Initializes the object with the given grid. self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 def update(self, row, col, val): Sets the value at position (row, col) in the grid to val. self.grid[row][col] = val def sumRegion(self, row1, col1, row2, col2): Returns the sum of the elements within the rectangle defined by (row1, col1) and (row2, col2), inclusive. total_sum = 0 for i in range(row1, row2 + 1): for j in range(col1, col2 + 1): total_sum += self.grid[i][j] return total_sum"}]'),N={name:"App",components:{PoemCard:I},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},L={class:"card-container"},z={key:0,class:"empty-state"},D=["disabled"],C={key:0},S={key:1};function E(i,e,u,c,s,a){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")},"  ")):l("",!0)]),t("div",L,[(n(!0),r(y,null,w(a.displayedPoems,(o,g)=>(n(),v(f,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",z,' No results found for "'+h(s.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",S,"Loading...")):(n(),r("span",C,"See more"))],8,D)):l("",!0)])}const G=m(N,[["render",E],["__scopeId","data-v-7f5472e5"]]),W=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/9.md","filePath":"library/9.md"}'),P={name:"library/9.md"},M=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{W as __pageData,M as default};
