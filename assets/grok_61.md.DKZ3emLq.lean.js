import{_ as c,o as s,c as r,a as t,m as _,t as d,C as h,M as g,U as b,f as l,F as y,p as w,e as x,q as v}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},R={class:"review-content"};function A(n,e,u,m,i,a){return s(),r("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(d(u.poem.solution),1)])])])}const N=c(q,[["render",A],["__scopeId","data-v-972356ef"]]),F=JSON.parse(`[{"question":"def min_operations_to_transform(N: int, K: int, a: List[int], Q: int, targets: List[int]) -> List[int]: For each query, find the minimum number of operations required to make all elements of the sequence equal to the target value. Args: N (int): The number of elements in the sequence. K (int): The integer used for the XOR operation. a (List[int]): The sequence of integers. Q (int): The number of queries. targets (List[int]): The target values to which Alex wants to transform the sequence. Returns: List[int]: A list of integers representing the minimum number of operations for each query. Example: >>> min_operations_to_transform(3, 2, [1, 2, 3], 2, [3, 1]) [2, 2] >>> min_operations_to_transform(4, 3, [4, 8, 2, 6], 3, [2, 6, 0]) [3, 3, 4] pass def test_case_1(): N, K = 3, 2 a = [1, 2, 3] Q = 2 targets = [3, 1] assert min_operations_to_transform(N, K, a, Q, targets) == [2, 2] def test_case_2(): N, K = 4, 3 a = [4, 8, 2, 6] Q = 3 targets = [2, 6, 0] assert min_operations_to_transform(N, K, a, Q, targets) == [3, 3, 4] def test_case_3(): N, K = 1, 0 a = [10] Q = 1 targets = [10] assert min_operations_to_transform(N, K, a, Q, targets) == [0] def test_case_4(): N, K = 5, 5 a = [5, 5, 5, 5, 5] Q = 2 targets = [5, 0] assert min_operations_to_transform(N, K, a, Q, targets) == [0, 5] def test_case_5(): N, K = 3, 1 a = [1, 2, 3] Q = 2 targets = [3, 0] assert min_operations_to_transform(N, K, a, Q, targets) == [2, 3] def test_case_6(): N, K = 10, 4 a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Q = 1 targets = [5] assert min_operations_to_transform(N, K, a, Q, targets) == [9]","solution":"def min_operations_to_transform(N, K, a, Q, targets): results = [] for X in targets: operations = 0 for value in a: if value != X: if K == 0: operations += float('inf') # Impossible to change value else: operations += 1 results.append(operations) return results"},{"question":"def long_pressed_name(name: str, typed: str) -> bool: Determine if a string \`typed\` could have been produced by long pressing the characters on a string \`name\`. >>> long_pressed_name(\\"alex\\", \\"aaleex\\") True >>> long_pressed_name(\\"saeed\\", \\"ssaaedd\\") False >>> long_pressed_name(\\"leelee\\", \\"lleeelee\\") True >>> long_pressed_name(\\"laiden\\", \\"laiden\\") True from solution import long_pressed_name def test_example_cases(): assert long_pressed_name(\\"alex\\", \\"aaleex\\") == True assert long_pressed_name(\\"saeed\\", \\"ssaaedd\\") == False assert long_pressed_name(\\"leelee\\", \\"lleeelee\\") == True assert long_pressed_name(\\"laiden\\", \\"laiden\\") == True def test_edge_cases(): assert long_pressed_name(\\"\\", \\"\\") == True # Both are empty strings assert long_pressed_name(\\"a\\", \\"a\\") == True # Single character, exact match assert long_pressed_name(\\"a\\", \\"aa\\") == True # Single character, long pressed match assert long_pressed_name(\\"a\\", \\"b\\") == False # Single character, non match def test_complex_cases(): assert long_pressed_name(\\"alex\\", \\"aaleexa\\") == False # Additional unmatched character at end assert long_pressed_name(\\"leelee\\", \\"lleeeleeee\\") == True # Multiple long presses assert long_pressed_name(\\"abcdefg\\", \\"aabbccddeeffgg\\") == True # Each character long pressed twice assert long_pressed_name(\\"abcdefg\\", \\"aabbccddeeffgh\\") == False # Last character mismatched def test_long_strings(): name = \\"a\\" * 500 + \\"b\\" * 500 typed = \\"a\\" * 1000 + \\"b\\" * 1000 assert long_pressed_name(name, typed) == True # Long strings def test_short_strings(): assert long_pressed_name(\\"a\\", \\"aa\\") == True assert long_pressed_name(\\"a\\", \\"aaa\\") == True","solution":"def long_pressed_name(name: str, typed: str) -> bool: Check if \`typed\` could be produced by long pressing the characters in \`name\`. i, j = 0, 0 while j < len(typed): if i < len(name) and name[i] == typed[j]: i += 1 elif j == 0 or typed[j] != typed[j - 1]: return False j += 1 return i == len(name)"},{"question":"def find_odd_occurrence(arr: List[int]) -> int: Returns the integer that appears an odd number of times in the array. >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) 3 >>> find_odd_occurrence([1]) 1 >>> find_odd_occurrence([4, 4, 4, 4, 4]) 4 >>> find_odd_occurrence([10, 10, 20, 20, 30, 30, 30, 30, 50]) 50 >>> find_odd_occurrence([5, 7, 9, 7, 5, 9, 8]) 8","solution":"def find_odd_occurrence(arr): Returns the integer that appears an odd number of times in the array. Args: arr (list): List of integers where all integers except one appear an even number of times. Returns: int: The integer that appears an odd number of times. result = 0 for number in arr: result ^= number return result"},{"question":"def minUniqueSum(arr: List[int]) -> int: Returns the minimum possible sum of the elements of the array such that all elements are unique. You can increment elements in the array to make them unique. >>> minUniqueSum([1, 2, 2]) 6 >>> minUniqueSum([3, 2, 1, 2, 1, 7]) 22 >>> minUniqueSum([]) 0 >>> minUniqueSum([1, 2, 3]) 6 >>> minUniqueSum([1, 1, 1, 1]) 10 >>> minUniqueSum([100, 200, 100, 300]) 701","solution":"def minUniqueSum(arr): Returns the minimum possible sum of the elements of the array such that all elements are unique. You can increment elements in the array to make them unique. if not arr: return 0 arr.sort() result_sum = arr[0] for i in range(1, len(arr)): if arr[i] <= arr[i-1]: arr[i] = arr[i-1] + 1 result_sum += arr[i] return result_sum"},{"question":"import os def get_current_timestamp(): # This helper function is assumed to exist and return a formatted timestamp pass def log_event(event_description): Logs an event to the 'event_log.txt' file with a timestamp. Each log entry should be written on a new line and follow this format: [YYYY-MM-DD HH:MM:SS] - Event Description Example: >>> log_event(\\"User logged in\\") (This will append the entry \\"[2023-10-15 14:35:20] - User logged in\\" to the 'event_log.txt' if the timestamp is '2023-10-15 14:35:20') Args: event_description (str): Description of the event to log. try: timestamp = get_current_timestamp() log_entry = f\\"[{timestamp}] - {event_description}n\\" with open(\\"event_log.txt\\", \\"a\\") as file: file.write(log_entry) except Exception as e: print(f\\"An error occurred while logging the event: {e}\\")","solution":"import os def get_current_timestamp(): from datetime import datetime return datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") def log_event(event_description): try: timestamp = get_current_timestamp() log_entry = f\\"[{timestamp}] - {event_description}n\\" with open(\\"event_log.txt\\", \\"a\\") as file: file.write(log_entry) except Exception as e: print(f\\"An error occurred while logging the event: {e}\\")"},{"question":"def max_sum_sublist(arr, k): Returns the maximum sum among all contiguous sublists of length k. >>> max_sum_sublist([1, 4, 2, 10, 2, 3, 1, 0, 20], 4) == 24 >>> max_sum_sublist([2, 3, 5, 2, 9, 7, 1], 3) == 18 >>> max_sum_sublist([5], 1) == 5 >>> max_sum_sublist([5, 5, 5, 5, 5, 5], 2) == 10 >>> max_sum_sublist([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 55 >>> max_sum_sublist([1, 2, 3, 4, 5], 4) == 14 >>> max_sum_sublist([10, 2, 3, 1, 1, 1], 2) == 12 >>> max_sum_sublist([1, 1, 1, 1, 1, 2, 10], 2) == 12","solution":"def max_sum_sublist(arr, k): Returns the maximum sum among all contiguous sublists of length k. :param arr: List of non-negative integers. :param k: Length of sublist. :return: Maximum sum of contiguous sublists of length k. # Initial sum of the first window of size k max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window over the array and calculate the sum for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a string mathematical expression consisting of non-negative integers, +, -, *, / operators with integer division truncating towards zero. Examples: >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5","solution":"def evaluate_expression(expression): Evaluate a string mathematical expression consisting of non-negative integers, +, -, *, / operators with integer division truncating towards zero. def apply_ops(ops, nums): right = nums.pop() left = nums.pop() op = ops.pop() if op == \\"+\\": nums.append(left + right) elif op == \\"-\\": nums.append(left - right) elif op == \\"*\\": nums.append(left * right) elif op == \\"/\\": nums.append(int(left / right)) # truncate towards zero ops = [] nums = [] i, n = 0, len(expression) while i < n: if expression[i] == \\" \\": i += 1 continue if expression[i] in \\"+-*/\\": while ops and (ops[-1] in \\"*/\\" or (ops[-1] in \\"+-\\" and expression[i] in \\"+-\\")): apply_ops(ops, nums) ops.append(expression[i]) i += 1 else: j = i while j < n and expression[j].isdigit(): j += 1 nums.append(int(expression[i:j])) i = j while ops: apply_ops(ops, nums) return nums[0]"},{"question":"def unique_pairs(arr: List[int], target: int) -> int: Returns the number of unique pairs of integers in the array that sum up to the target integer. Each pair is counted once, and order of elements in the pair doesn’t matter. >>> unique_pairs([1, 2, 3, 4, 3], 6) 2 >>> unique_pairs([1, 2, 3], 10) 0 >>> unique_pairs([3, 3, 3, 3], 6) 1 >>> unique_pairs([-1, -2, 3, 2, 0], 1) 2 >>> unique_pairs([], 5) 0 >>> unique_pairs([5], 5) 0 >>> unique_pairs([100000, 50000, -50000, -100000], 0) 2","solution":"def unique_pairs(arr, target): Returns the number of unique pairs of integers in the array that sum up to the target integer. Each pair is counted once, and order of elements in the pair doesn’t matter. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def manipulateString(str, commands): Manipulates the string according to the commands and returns the modified string. - 'lowercase': Converts the entire string to lowercase. - 'uppercase': Converts the entire string to uppercase. - 'charAt {index}': Returns the character at the specified index. Parameters: - str (string): The input string. - commands (list): List of commands. Returns: - string: The manipulated string or character based on the commands. >>> manipulateString(\\"Hello, World!\\", [\\"lowercase\\"]) \\"hello, world!\\" >>> manipulateString(\\"Hello, World!\\", [\\"uppercase\\"]) \\"HELLO, WORLD!\\" >>> manipulateString(\\"Hello, World!\\", [\\"charAt 7\\"]) \\"W\\" >>> manipulateString(\\"Hello, World!\\", [\\"lowercase\\", \\"charAt 7\\"]) \\"w\\" >>> manipulateString(\\"Hello, World!\\", [\\"uppercase\\", \\"charAt 7\\"]) \\"W\\" >>> manipulateString(\\"Hello, World!\\", []) \\"Hello, World!\\" >>> manipulateString(\\"Hello\\", [\\"charAt 0\\"]) \\"H\\"","solution":"def manipulateString(str, commands): Manipulates the string according to the commands and returns the modified string. - 'lowercase': Converts the entire string to lowercase. - 'uppercase': Converts the entire string to uppercase. - 'charAt {index}': Returns the character at the specified index. Parameters: - str (string): The input string. - commands (list): List of commands. Returns: - string: The manipulated string or character based on the commands. for command in commands: if command == 'lowercase': str = str.lower() elif command == 'uppercase': str = str.upper() elif command.startswith('charAt'): parts = command.split() if len(parts) == 2 and parts[1].isdigit(): index = int(parts[1]) if 0 <= index < len(str): return str[index] else: return '' return str"},{"question":"def reorder_string(s: str) -> str: Reorder the string such that all digits come before the letters while preserving the relative order. >>> reorder_string(\\"a1b2c3\\") \\"123abc\\" >>> reorder_string(\\"3z4x1a\\") \\"341zxa\\" >>> reorder_string(\\"ab12cd34\\") \\"1234abcd\\"","solution":"def reorder_string(s): Reorders the string such that all digits come before letters while preserving relative order. Parameters: s (str): input string containing digits and lowercase letters Returns: str: reordered string with digits before letters digits = [char for char in s if char.isdigit()] letters = [char for char in s if char.isalpha()] return ''.join(digits + letters)"},{"question":"def balanced_substrings(s: str) -> int: Returns the maximum number of balanced substrings that can be obtained from the input string. Parameters: s (str): A string containing only the characters 'L' and 'R'. Returns: int: The count of the maximum number of balanced substrings. # Test cases def test_example_cases(): assert balanced_substrings(\\"RLRRLLRLRL\\") == 4 assert balanced_substrings(\\"RLLLLRRRLR\\") == 3 assert balanced_substrings(\\"LLLLRRRR\\") == 1 assert balanced_substrings(\\"RLRRRLLRLL\\") == 2 def test_all_l(): assert balanced_substrings(\\"LLLL\\") == 0 # no 'R', can't be balanced def test_all_r(): assert balanced_substrings(\\"RRRR\\") == 0 # no 'L', can't be balanced def test_single_lr(): assert balanced_substrings(\\"LR\\") == 1 # exactly one balanced substring def test_single_rl(): assert balanced_substrings(\\"RL\\") == 1 # exactly one balanced substring def test_empty_string(): assert balanced_substrings(\\"\\") == 0 # no substrings in an empty string def test_alternating_lr(): assert balanced_substrings(\\"LRLRLRLRLR\\") == 5 # alternating L and R leads to multiple balanced substrings","solution":"def balanced_substrings(s): Returns the maximum number of balanced substrings that can be obtained from the input string. Parameters: s (str): A string containing only the characters 'L' and 'R'. Returns: int: The count of the maximum number of balanced substrings. balance_count = 0 max_balanced_count = 0 for char in s: if char == 'L': balance_count += 1 elif char == 'R': balance_count -= 1 if balance_count == 0: max_balanced_count += 1 return max_balanced_count"},{"question":"def word_counter(paragraph: str) -> dict: Returns a dictionary with the count of each word in the paragraph. Punctuation is ignored and comparison is case-insensitive. >>> word_counter(\\"Hello, my name is hello world!\\") {'hello': 2, 'my': 1, 'name': 1, 'is': 1, 'world': 1} >>> word_counter(\\"Python testing is fun. Fun and testing with Python!\\") {'python': 2, 'testing': 2, 'is': 1, 'fun': 2, 'and': 1, 'with': 1} >>> word_counter(\\"One one TWO two TWO.\\") {'one': 2, 'two': 3} # Your implementation here import string def test_single_appearance(): assert word_counter(\\"Hello world\\") == {\\"hello\\": 1, \\"world\\": 1} def test_multiple_appearances(): assert word_counter(\\"Hello, hello, World!\\") == {\\"hello\\": 2, \\"world\\": 1} def test_ignore_punctuation(): assert word_counter(\\"Python testing is fun. Fun and testing with Python!\\") == { \\"python\\": 2, \\"testing\\": 2, \\"is\\": 1, \\"fun\\": 2, \\"and\\": 1, \\"with\\": 1 } def test_case_insensitivity(): assert word_counter(\\"One one ONE\\") == {\\"one\\": 3} def test_mix_of_cases_and_punctuation(): assert word_counter(\\"Hello, my name is hello world!\\") == { \\"hello\\": 2, \\"my\\": 1, \\"name\\": 1, \\"is\\": 1, \\"world\\": 1 } def test_numbers_in_string(): assert word_counter(\\"One 1 two 2 two 2\\") == {\\"one\\": 1, \\"1\\": 1, \\"two\\": 2, \\"2\\": 2} def test_empty_string(): assert word_counter(\\"\\") == {}","solution":"import string def word_counter(paragraph): Returns a dictionary with the count of each word in the paragraph. Punctuation is ignored and comparison is case-insensitive. translator = str.maketrans('', '', string.punctuation) cleaned_paragraph = paragraph.translate(translator).lower() words = cleaned_paragraph.split() word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths for a robot to reach the bottom-right corner of a grid with obstacles. :param grid: List[List[int]]: A 2D list representing the grid where 0 is an open space and 1 is a barrier :return: int: The number of unique paths from top-left to bottom-right of the grid # Your code goes here import pytest def test_example_case(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_no_obstacles(): grid = [ [0, 0], [0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_single_path(): grid = [ [0, 1], [0, 0] ] assert unique_paths_with_obstacles(grid) == 1 def test_large_grid_with_path(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 4 def test_full_blockage(): grid = [ [0, 1], [1, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_start_blocked(): grid = [ [1, 0], [0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_destination_blocked(): grid = [ [0, 0], [0, 1] ] assert unique_paths_with_obstacles(grid) == 0 def test_large_grid_no_obstacles(): grid = [[0] * 10 for _ in range(10)] assert unique_paths_with_obstacles(grid) == 48620 # This should be calculated beforehand def test_single_cell(): grid = [[0]] assert unique_paths_with_obstacles(grid) == 1 def test_single_row(): grid = [[0, 0, 0, 0]] assert unique_paths_with_obstacles(grid) == 1 def test_single_column(): grid = [ [0], [0], [0], [0] ] assert unique_paths_with_obstacles(grid) == 1","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths for a robot to reach the bottom-right corner of a grid with obstacles. :param grid: List[List[int]]: A 2D list representing the grid where 0 is an open space and 1 is a barrier :return: int: The number of unique paths from top-left to bottom-right of the grid N = len(grid) M = len(grid[0]) if grid[0][0] == 1 or grid[N-1][M-1] == 1: return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1]"},{"question":"def middle_or_average(lst: List[int]) -> List[int]: Returns a list containing the middle element if the length of the list is odd, or the average of the two middle elements if the length is even, rounded down if necessary. >>> middle_or_average([1, 2, 3, 4, 5]) [3] >>> middle_or_average([1, 2, 3, 4]) [2] >>> middle_or_average([10, 20, 30, 40, 50, 60]) [35]","solution":"def middle_or_average(lst): Returns a list containing the middle element if the length of the list is odd, or the average of the two middle elements if the length is even. n = len(lst) if n % 2 == 1: return [lst[n // 2]] else: middle1, middle2 = lst[n // 2 - 1], lst[n // 2] return [(middle1 + middle2) // 2]"},{"question":"from typing import List, Tuple def get_academic_ranks(n: int, gpas: List[Tuple[float, float]]) -> List[str]: Determines the academic rank for each student based on the final GPA. Parameters: n (int): Number of students gpas (List[Tuple[float, float]]): List of tuples where each tuple contains two GPAs for a student Returns: List[str]: List of academic ranks for each student >>> get_academic_ranks(4, [(9.2, 8.8), (7.0, 7.9), (6.0, 4.9), (1.0, 2.8)]) ['A', 'B', 'C', 'F'] >>> get_academic_ranks(3, [(9.5, 9.0), (10.0, 9.0), (9.0, 10.0)]) ['A', 'A', 'A'] >>> get_academic_ranks(2, [(7.0, 8.0), (8.5, 7.2)]) ['B', 'B'] >>> get_academic_ranks(2, [(5.0, 6.0), (6.5, 5.1)]) ['C', 'C'] >>> get_academic_ranks(3, [(3.0, 4.0), (4.8, 3.2), (3.5, 4.6)]) ['D', 'D', 'D'] >>> get_academic_ranks(2, [(2.5, 2.0), (1.0, 2.8)]) ['F', 'F'] >>> get_academic_ranks(5, [(9.2, 8.7), (6.5, 7.4), (3.1, 4.4), (2.0, 2.9), (7.0, 7.1)]) ['B', 'C', 'D', 'F', 'B']","solution":"def get_academic_ranks(n, gpas): Determines the academic rank for each student based on the final GPA. Parameters: n (int): Number of students gpas (List[Tuple[float, float]]): List of tuples where each tuple contains two GPAs for a student Returns: List[str]: List of academic ranks for each student ranks = [] for gpa1, gpa2 in gpas: final_gpa = (gpa1 + gpa2) / 2 if final_gpa >= 9.0: ranks.append('A') elif final_gpa >= 7.0: ranks.append('B') elif final_gpa >= 5.0: ranks.append('C') elif final_gpa >= 3.0: ranks.append('D') else: ranks.append('F') return ranks"},{"question":"def sum_of_products(lst: List[int]) -> int: Returns the sum of the product of each pair of integers in the list. >>> sum_of_products([1, 2, 3, 4]) 35 >>> sum_of_products([5]) 0 >>> sum_of_products([2, 3]) 6 >>> sum_of_products([1, 3, 5, 7]) 86 >>> sum_of_products([]) 0","solution":"def sum_of_products(lst): Returns the sum of the product of each pair of integers in the list. total_sum = 0 n = len(lst) for i in range(n): for j in range(i + 1, n): total_sum += lst[i] * lst[j] return total_sum"},{"question":"from typing import List def missing_number(nums: List[int]) -> int: Given an array nums containing n distinct numbers taken from the range 0 to n, find the one that is missing from the array. >>> missing_number([3, 0, 1]) 2 >>> missing_number([0, 1]) 2 >>> missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 >>> missing_number([0]) 1 def test_missing_number(): # provided test cases assert missing_number([3, 0, 1]) == 2 assert missing_number([0, 1]) == 2 assert missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) == 8 assert missing_number([0]) == 1 # additional test cases assert missing_number([]) == 0 # edge case, no elements in array assert missing_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0 # missing 0 assert missing_number([0, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1 # missing 1 assert missing_number([0, 1, 3, 4, 5, 6, 7, 8, 9, 10]) == 2 # missing 2 assert missing_number([0, 1, 2]) == 3 # missing number beyond range","solution":"def missing_number(nums): Given an array nums containing n distinct numbers taken from the range 0 to n, find the one that is missing from the array. n = len(nums) total_sum = (n * (n + 1)) // 2 array_sum = sum(nums) return total_sum - array_sum"},{"question":"from typing import List def can_rotate_to_match(gridA: List[List[int]], gridB: List[List[int]]) -> bool: Determines if gridA can be transformed into gridB by rotating it 90 degrees clockwise any number of times (0, 1, 2, or 3 times). >>> gridA = [ ... [1, 2], ... [3, 4] ... ] >>> gridB = [ ... [3, 1], ... [4, 2] ... ] >>> can_rotate_to_match(gridA, gridB) True >>> gridA = [ ... [1, 2], ... [3, 4] ... ] >>> gridB = [ ... [1, 2], ... [4, 3] ... ] >>> can_rotate_to_match(gridA, gridB) False def test_can_rotate_to_match(): gridA = [ [1, 2], [3, 4] ] gridB = [ [1, 2], [3, 4] ] assert can_rotate_to_match(gridA, gridB) == True gridA = [ [1, 2], [3, 4] ] gridB = [ [3, 1], [4, 2] ] assert can_rotate_to_match(gridA, gridB) == True gridA = [ [1, 2], [3, 4] ] gridB = [ [4, 3], [2, 1] ] assert can_rotate_to_match(gridA, gridB) == True gridA = [ [1, 2], [3, 4] ] gridB = [ [2, 4], [1, 3] ] assert can_rotate_to_match(gridA, gridB) == True gridA = [ [1, 2], [3, 4] ] gridB = [ [1, 2], [4, 3] ] assert can_rotate_to_match(gridA, gridB) == False gridA = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] gridB = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert can_rotate_to_match(gridA, gridB) == True","solution":"from typing import List def rotate_90_clockwise(grid: List[List[int]]) -> List[List[int]]: Rotates the grid 90 degrees clockwise. n = len(grid) new_grid = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_grid[j][n - 1 - i] = grid[i][j] return new_grid def can_rotate_to_match(gridA: List[List[int]], gridB: List[List[int]]) -> bool: Determines if gridA can be transformed into gridB by rotating it 90 degrees clockwise any number of times (0, 1, 2, or 3 times). if gridA == gridB: return True rotated = gridA for _ in range(3): rotated = rotate_90_clockwise(rotated) if rotated == gridB: return True return False"},{"question":"def longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring(\\"\\") == 0 >>> longest_substring(\\"a\\") == 1 >>> longest_substring(\\"abcabcbb\\") == 3 >>> longest_substring(\\"bbbbb\\") == 1 >>> longest_substring(\\"pwwkew\\") == 3 >>> longest_substring(\\"dvdf\\") == 3 >>> longest_substring(\\"anviaj\\") == 5","solution":"def longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Find the minimum cost path from the top-left corner to the bottom-right corner of the grid. You can only move to the right or down at any point in time. Args: grid (List[List[int]]): The grid containing non-negative integers representing the cost to move through each cell. Returns: int: The minimum cost path from the top-left to the bottom-right corner of the grid. Examples: >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathSum([[0]]) 0 >>> minPathSum([ ... [1, 2, 3] ... ]) 6 >>> minPathSum([ ... [1], ... [2], ... [3] ... ]) 6 >>> minPathSum([ ... [1000, 1000], ... [1000, 1000] ... ]) 3000 >>> minPathSum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21","solution":"from typing import List def minPathSum(grid: List[List[int]]) -> int: m = len(grid) n = len(grid[0]) # Initialize a 2D dp array where dp[i][j] is the minimum cost to reach (i, j) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"def count_palindromic_substrings(S: str) -> int: Returns the number of palindromic substrings in the given string S. >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"racecar\\") 10 def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns the number of palindromic substrings for each test case. >>> process_test_cases([\\"ababa\\", \\"racecar\\"]) [9, 10] >>> process_test_cases([\\"a\\"]) [1]","solution":"def count_palindromic_substrings(S): Returns the number of palindromic substrings in the given string S. n = len(S) count = 0 def is_palindrome(sub): return sub == sub[::-1] for i in range(n): for j in range(i, n): if is_palindrome(S[i:j+1]): count += 1 return count def process_test_cases(test_cases): results = [] for S in test_cases: results.append(count_palindromic_substrings(S)) return results"},{"question":"def evaluate_expression(s: str) -> int: Evaluates the mathematical expression given in the string \`s\` and returns the result as an integer. Division truncates toward zero. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5","solution":"def evaluate_expression(s): Evaluates the mathematical expression given in the string s and returns the result as an integer. Division truncates toward zero. # Remove all spaces from the string s = s.replace(' ', '') # Initialize stack, number and sign variables stack = [] num = 0 sign = \\"+\\" i = 0 while i < len(s): char = s[i] if char.isdigit(): num = num * 10 + int(char) if not char.isdigit() or i == len(s) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) sign = char num = 0 i += 1 return sum(stack)"},{"question":"def manage_water_flow(initial_list: List[int], requests: List[dict]) -> List[int]: Manage the water levels in the tanks based on the requests. >>> manage_water_flow([500, 200, 800], [{\\"tank\\": 0, \\"operation\\": \\"fill\\", \\"amount\\": 350}, {\\"tank\\": 2, \\"operation\\": \\"fill\\", \\"amount\\": 500}]) [850, 200, 1000] >>> manage_water_flow([600, 300, 700], [{\\"tank\\": 1, \\"operation\\": \\"drain\\", \\"amount\\": 350}, {\\"tank\\": 2, \\"operation\\": \\"drain\\", \\"amount\\": 800}]) [600, 0, 0] >>> manage_water_flow([500, 200, 800], [{\\"tank\\": 0, \\"operation\\": \\"fill\\", \\"amount\\": 350}, {\\"tank\\": 1, \\"operation\\": \\"drain\\", \\"amount\\": 250}, {\\"tank\\": 2, \\"operation\\": \\"fill\\", \\"amount\\": 500}, {\\"tank\\": 0, \\"operation\\": \\"drain\\", \\"amount\\": 1000}]) [0, 0, 1000] >>> manage_water_flow([1000, 50], [{\\"tank\\": 0, \\"operation\\": \\"fill\\", \\"amount\\": 100}, {\\"tank\\": 1, \\"operation\\": \\"drain\\", \\"amount\\": 100}]) [1000, 0] >>> manage_water_flow([100, 200, 300], []) [100, 200, 300]","solution":"def manage_water_flow(initial_list, requests): Manage the water levels in the tanks based on the requests. Parameters: initial_list: List[int] - Initial water levels of the tanks. requests: List[dict] - List of requests to either fill or drain the tanks. Returns: List[int] - The final water levels of the tanks after processing the requests. for request in requests: tank = request[\\"tank\\"] operation = request[\\"operation\\"] amount = request[\\"amount\\"] if operation == \\"fill\\": initial_list[tank] += amount if initial_list[tank] > 1000: initial_list[tank] = 1000 elif operation == \\"drain\\": initial_list[tank] -= amount if initial_list[tank] < 0: initial_list[tank] = 0 return initial_list"},{"question":"def book_filter(records: str, criteria: dict) -> list: Filters a list of books based on given criteria for genre and/or year of publication. Parameters: - records: A string containing all books' information separated by a semicolon. - criteria: A dictionary with optional keys 'genre' (str) and 'year' (int). Returns: - A list of book titles that match the provided criteria. Examples: >>> records = (\\"The Great Gatsby by F. Scott Fitzgerald in Fiction, published: 1925, pages: 218;\\" ... \\"To Kill a Mockingbird by Harper Lee in Fiction, published: 1960, pages: 281;\\" ... \\"The Art of Computer Programming by Donald Knuth in Non-fiction, published: 1968, pages: 672\\") >>> criteria1 = {\\"genre\\": \\"Fiction\\", \\"year\\": 1960} >>> book_filter(records, criteria1) [\\"To Kill a Mockingbird\\"] >>> criteria2 = {\\"genre\\": \\"Non-fiction\\"} >>> book_filter(records, criteria2) [\\"The Art of Computer Programming\\"] >>> criteria3 = {\\"year\\": 1925} >>> book_filter(records, criteria3) [\\"The Great Gatsby\\"] >>> criteria4 = {\\"genre\\": \\"Science Fiction\\"} >>> book_filter(records, criteria4) []","solution":"def book_filter(records, criteria): Filters a list of books based on given criteria for genre and/or year of publication. Parameters: - records: A string containing all books' information separated by a semicolon. - criteria: A dictionary with optional keys 'genre' (str) and 'year' (int). Returns: - A list of book titles that match the provided criteria. books = records.split(';') filtered_books = [] for book in books: title = book.split(\\" by \\")[0].strip() genre_match = True year_match = True if 'genre' in criteria: genre = book.split(\\" in \\")[1].split(\\",\\")[0].strip() if genre != criteria['genre']: genre_match = False if 'year' in criteria: year = int(book.split(\\"published: \\")[1].split(\\",\\")[0].strip()) if year != criteria['year']: year_match = False if genre_match and year_match: filtered_books.append(title) return filtered_books"},{"question":"def can_split_to_palindromes(s: str) -> str: Ingrid loves collecting flowers and wants to arrange them in a unique way. She represents each flower as a character and creates a string that describes her collection. Ingrid wants to make sure that any string she creates can be split into two non-empty strings such that one is a prefix and the other is a suffix. Both parts should be able to form a valid palindrome after rearranging their characters. You need to determine if it is possible to split the given string in such a way. >>> can_split_to_palindromes(\\"aabbcc\\") 'YES' >>> can_split_to_palindromes(\\"abc\\") 'NO'","solution":"def can_split_to_palindromes(s): from collections import Counter def can_form_palindrome(s): counts = Counter(s) odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 n = len(s) if n < 2: return \\"NO\\" for i in range(1, n): prefix = s[:i] suffix = s[i:] if can_form_palindrome(prefix) and can_form_palindrome(suffix): return \\"YES\\" return \\"NO\\" # Quick test for the function print(can_split_to_palindromes(\\"aabbcc\\")) # Expected output: YES print(can_split_to_palindromes(\\"abc\\")) # Expected output: NO"},{"question":"def follows_pattern(pattern: str, s: str) -> bool: Implement a function that determines whether a string follows a specified pattern. The pattern is given as a string of lowercase characters, and the string to be checked is composed of words separated by spaces. The relationship between the pattern and the string is defined as follows: - Each unique character in the pattern corresponds to a unique word in the string. - The order of the characters in the pattern matches the order of the words in the string. Your function should return \`True\` if the string follows the pattern and \`False\` otherwise. Examples: >>> follows_pattern(\\"abba\\", \\"dog cat cat dog\\") == True >>> follows_pattern(\\"abba\\", \\"dog cat cat fish\\") == False >>> follows_pattern(\\"aaaa\\", \\"dog dog dog dog\\") == True >>> follows_pattern(\\"abba\\", \\"dog dog dog dog\\") == False >>> follows_pattern(\\"abc\\", \\"dog cat\\") == False >>> follows_pattern(\\"abcd\\", \\"dog cat fish bird\\") == True >>> follows_pattern(\\"aaaaa\\", \\"dog dog dog dog\\") == False","solution":"def follows_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"def maxDiff(arr): Returns the maximum difference between any two elements such that the larger element comes after the smaller element. If the list has less than two elements, return 0. Examples: >>> maxDiff([2, 3, 10, 6, 4, 8, 1]) 8 >>> maxDiff([7, 9, 5, 6, 3, 2]) 2 >>> maxDiff([1]) 0","solution":"def maxDiff(arr): Returns the maximum difference between any two elements such that the larger element comes after the smaller element. If the list has less than two elements, return 0. if len(arr) < 2: return 0 min_element = arr[0] max_diff = 0 for i in range(1, len(arr)): if arr[i] - min_element > max_diff: max_diff = arr[i] - min_element if arr[i] < min_element: min_element = arr[i] return max_diff"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def leafSimilarity(rootA: TreeNode, rootB: TreeNode) -> bool: Determines whether the leaf nodes of both trees are exactly the same in terms of values and order. >>> # Example 1 >>> rootA1 = TreeNode(3) >>> rootA1.left = TreeNode(5) >>> rootA1.right = TreeNode(1) >>> rootA1.left.left = TreeNode(6) >>> rootA1.left.right = TreeNode(2) >>> rootA1.left.right.left = TreeNode(7) >>> rootA1.left.right.right = TreeNode(4) >>> rootA1.right.left = TreeNode(9) >>> rootA1.right.right = TreeNode(8) >>> >>> rootB1 = TreeNode(3) >>> rootB1.left = TreeNode(5) >>> rootB1.right = TreeNode(1) >>> rootB1.left.left = TreeNode(6) >>> rootB1.left.right = TreeNode(2) >>> rootB1.left.right.left = TreeNode(7) >>> rootB1.left.right.right = TreeNode(4) >>> rootB1.right.right = TreeNode(8) >>> >>> leafSimilarity(rootA1, rootB1) == False >>> >>> # Example 2 >>> rootA2 = TreeNode(1) >>> rootA2.left = TreeNode(2) >>> rootA2.right = TreeNode(3) >>> >>> rootB2 = TreeNode(1) >>> rootB2.left = TreeNode(2) >>> rootB2.right = TreeNode(3) >>> >>> leafSimilarity(rootA2, rootB2) == True","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def leafSimilarity(rootA: TreeNode, rootB: TreeNode) -> bool: # Helper function to find leaf nodes def find_leaves(root: TreeNode): if not root: return [] if not root.left and not root.right: return [root.value] return find_leaves(root.left) + find_leaves(root.right) # Get leaf sequences for both trees leavesA = find_leaves(rootA) leavesB = find_leaves(rootB) # Compare leaf sequences return leavesA == leavesB"},{"question":"def count_characters(s: str) -> dict: Takes a string and returns the count of each character as a dictionary. >>> count_characters('hello') {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_characters('') {} >>> count_characters('a') {'a': 1} >>> count_characters('a a a') {'a': 3, ' ': 2} >>> count_characters('a!a!a!') {'a': 3, '!': 3} >>> count_characters('123321') {'1': 2, '2': 2, '3': 2}","solution":"def count_characters(s): Returns a dictionary with the count of each character in the input string s. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"from typing import List def can_achieve_exact_quantity(quantities: List[int], target: int) -> bool: Determines if it is possible to achieve the target quantity by combining quantities. Args: quantities (List[int]): List of available product quantities. target (int): The target quantity to achieve. Returns: bool: True if the target quantity can be achieved, False otherwise. Examples: >>> can_achieve_exact_quantity([1, 2, 3], 5) True >>> can_achieve_exact_quantity([1, 2, 5], 11) True >>> can_achieve_exact_quantity([3, 6, 9], 10) False pass","solution":"def can_achieve_exact_quantity(quantities, target): Determines if it is possible to achieve the target quantity by combining quantities. # Initialize the dp array with False values dp = [False] * (target + 1) dp[0] = True # Base case: 0 quantity can always be achieved for i in range(1, target + 1): for quantity in quantities: if i >= quantity and dp[i - quantity]: dp[i] = True break return dp[target]"},{"question":"def longest_common_prefix(str_list: List[str]) -> str: Returns the longest common prefix from a list of strings. :param str_list: List[str], a list of strings consisting of lowercase alphabets only :return: str, the longest common prefix >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"interstellar\\", \\"internet\\", \\"internal\\", \\"intermediate\\"]) 'inter'","solution":"def longest_common_prefix(str_list): Returns the longest common prefix from a list of strings. :param str_list: List[str], a list of strings consisting of lowercase alphabets only :return: str, the longest common prefix if not str_list: return \\"\\" # Sort the list to get the min and max strings str_list.sort() # Taking the smallest and largest strings by lexicographical order first, last = str_list[0], str_list[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 # The longest common prefix would be the same between the smallest and largest strings in the sorted list return first[:i]"},{"question":"def is_fertile_sequence(sequence): Determines if a given sequence is fertile, meaning the sum of every two consecutive plants is even. Parameters: sequence (list): List of integers representing plants. Returns: str: \\"YES\\" if the sequence is fertile, \\"NO\\" otherwise. pass # Implement the function here. def analyze_plant_sequences(test_cases): Analyzes multiple test cases to determine if each plant sequence is fertile. Parameters: test_cases (list): List of tuples, each containing an integer N and a list of N integers representing plants. Returns: list: List of results for each test case, either \\"YES\\" or \\"NO\\". pass # Implement the function here. # Function to process input and produce output according to the given problem. def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) sequence = list(map(int, data[index + 1:index + 1 + N])) test_cases.append((N, sequence)) index += N + 1 results = analyze_plant_sequences(test_cases) for result in results: print(result) # Unit tests def test_is_fertile_sequence_even_sum(): assert is_fertile_sequence([2, 4, 6, 8]) == \\"YES\\" assert is_fertile_sequence([5, 3, 7]) == \\"YES\\" def test_is_fertile_sequence_odd_sum(): assert is_fertile_sequence([1, 2, 3, 4, 5]) == \\"NO\\" assert is_fertile_sequence([5, 1, 2, 7, 7]) == \\"NO\\" def test_is_fertile_sequence_single_element(): assert is_fertile_sequence([4]) == \\"YES\\" assert is_fertile_sequence([1]) == \\"YES\\" def test_analyze_plant_sequences_multiple_cases(): test_cases = [ (4, [2, 4, 6, 8]), (3, [5, 3, 7]), (5, [1, 2, 3, 4, 5]), ] assert analyze_plant_sequences(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [ (4, [1, 1, 1, 1]), (6, [2, 4, 2, 4, 2, 6]), (5, [9, 7, 5, 3, 1]), ] assert analyze_plant_sequences(test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def is_fertile_sequence(sequence): Determines if a given sequence is fertile, meaning the sum of every two consecutive plants is even. Parameters: sequence (list): List of integers representing plants. Returns: str: \\"YES\\" if the sequence is fertile, \\"NO\\" otherwise. for i in range(len(sequence) - 1): if (sequence[i] + sequence[i + 1]) % 2 != 0: return \\"NO\\" return \\"YES\\" def analyze_plant_sequences(test_cases): Analyzes multiple test cases to determine if each plant sequence is fertile. Parameters: test_cases (list): List of tuples, each containing an integer N and a list of N integers representing plants. Returns: list: List of results for each test case, either \\"YES\\" or \\"NO\\". results = [] for N, sequence in test_cases: results.append(is_fertile_sequence(sequence)) return results # Function to process input and produce output according to the given problem. def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) sequence = list(map(int, data[index + 1:index + 1 + N])) test_cases.append((N, sequence)) index += N + 1 results = analyze_plant_sequences(test_cases) for result in results: print(result)"},{"question":"from typing import List def trap(height: List[int]) -> int: Compute how much water it is able to trap after raining given a list of column heights. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([3, 3, 3, 3]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([5, 4, 3, 2, 1]) == 0 >>> trap([0, 1, 0, 3, 0, 1, 0]) == 2 >>> trap([2, 0, 2]) == 2 >>> trap([5, 0, 5, 0, 5]) == 10 >>> trap([5, 0, 0, 5]) == 10","solution":"from typing import List def trap(height: List[int]) -> int: n = len(height) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"class TrainSchedule: TrainSchedule class to manage train arrivals, departures, and cancellations. - scheduleArrival(int trainId, int time): Schedules a train's arrival - scheduleDeparture(int trainId, int time): Schedules a train's departure - cancelSchedule(int trainId): Cancels a train's schedule - getCurrentTrains(int currentTime): Returns a list of trains currently at the station, sorted by their arrival time. Example: >>> ts = TrainSchedule() >>> ts.scheduleArrival(1, 10) >>> ts.scheduleArrival(2, 15) >>> ts.scheduleDeparture(1, 20) >>> ts.scheduleDeparture(2, 25) >>> ts.cancelSchedule(2) >>> ts.getCurrentTrains(12) [1] >>> ts.getCurrentTrains(18) [1] >>> ts.getCurrentTrains(22) [] def __init__(self): pass def scheduleArrival(self, trainId, time): pass def scheduleDeparture(self, trainId, time): pass def cancelSchedule(self, trainId): pass def getCurrentTrains(self, currentTime): pass","solution":"class TrainSchedule: def __init__(self): self.arrivals = {} self.departures = {} def scheduleArrival(self, trainId, time): self.arrivals[trainId] = time def scheduleDeparture(self, trainId, time): self.departures[trainId] = time def cancelSchedule(self, trainId): if trainId in self.arrivals: del self.arrivals[trainId] if trainId in self.departures: del self.departures[trainId] def getCurrentTrains(self, currentTime): current_trains = [train for train in self.arrivals if self.arrivals[train] <= currentTime and (train not in self.departures or self.departures[train] > currentTime)] current_trains.sort(key=lambda train: self.arrivals[train]) return current_trains"},{"question":"from typing import List def can_form_word_square(words: List[str]) -> bool: Determines if the given list of words can form a word square. >>> can_form_word_square([\\"area\\", \\"lead\\", \\"wall\\", \\"lady\\", \\"ball\\"]) True >>> can_form_word_square([\\"abat\\", \\"baba\\", \\"atan\\", \\"atal\\"]) True >>> can_form_word_square([\\"xyz\\", \\"zyx\\", \\"yxw\\"]) False","solution":"def can_form_word_square(words): Determines if the given list of words can form a word square. if not words: return False n = len(words[0]) # check if all words are of the same length if not all(len(word) == n for word in words): return False def is_valid_square(square): for i in range(len(square)): for j in range(len(square)): if square[i][j] != square[j][i]: return False return True def build_square(square, words): if len(square) == n: return is_valid_square(square) for word in words: square.append(word) if build_square(square, words): return True square.pop() return False return build_square([], words)"},{"question":"def is_increasing_path(matrix: List[List[int]]) -> bool: Determine if there exists a strictly increasing path from the top-left to the bottom-right of the matrix. >>> is_increasing_path([ [1, 2, 3], [6, 5, 4], [7, 8, 9] ]) True >>> is_increasing_path([ [9, 8, 7], [6, 5, 4], [3, 2, 1] ]) False >>> is_increasing_path([ [0] ]) True >>> is_increasing_path([ [0, 1, 2], [2, 3, 1], [4, 2, 5] ]) False >>> is_increasing_path([ [1, 2, 3], [1, 6, 4], [1, 7, 8] ]) True pass","solution":"from typing import List def is_increasing_path(matrix: List[List[int]]) -> bool: def dfs(x, y, prev_value, visited): if x < 0 or x >= m or y < 0 or y >= n or (x, y) in visited or matrix[x][y] <= prev_value: return False if x == m-1 and y == n-1: return True visited.add((x, y)) result = (dfs(x + 1, y, matrix[x][y], visited) or dfs(x - 1, y, matrix[x][y], visited) or dfs(x, y + 1, matrix[x][y], visited) or dfs(x, y - 1, matrix[x][y], visited)) visited.remove((x, y)) return result m = len(matrix) n = len(matrix[0]) return dfs(0, 0, -1, set())"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_kth_element(head, k): Removes the k-th element from the end of the linked list in a single pass and returns the head of the modified list. pass # Implement the function here. # Helper function to convert linked list to list def linked_list_to_list(head): if not head: return [] result = [] current = head while current: result.append(current.val) current = current.next return result # Helper function to create a linked list from a list def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head # Example usage head = create_linked_list([1, 2, 3, 4, 5]) k = 2 new_head = remove_kth_element(head, k) print(linked_list_to_list(new_head)) # Output: [1, 2, 3, 5] head = create_linked_list([1]) k = 1 new_head = remove_kth_element(head, k) print(linked_list_to_list(new_head)) # Output: [] head = create_linked_list([1, 2, 3]) k = 4 new_head = remove_kth_element(head, k) print(linked_list_to_list(new_head)) # Output: [1, 2, 3]","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_kth_element(head, k): Removes the k-th element from the end of the linked list in a single pass and returns the head of the modified list. dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move first k+1 steps ahead for _ in range(k + 1): if not first: # k is larger than the length of the list return head first = first.next # Move first to the end, maintaining the gap while first: first = first.next second = second.next # Skip the k-th element second.next = second.next.next return dummy.next"},{"question":"def min_replacements_to_alternate(s): Given a string containing only the characters 'a' and 'b', determine the minimum number of 'a's that need to be replaced with 'b's (or vice versa) so that no two 'a's are adjacent and no two 'b's are adjacent in the resulting string. The function should return \`None\` for invalid input types. >>> min_replacements_to_alternate(\\"ab\\") == 0 >>> min_replacements_to_alternate(\\"aa\\") == 1 >>> min_replacements_to_alternate(\\"bb\\") == 1 >>> min_replacements_to_alternate(\\"ababab\\") == 0 >>> min_replacements_to_alternate(\\"bababab\\") == 0 >>> min_replacements_to_alternate(\\"aaaabbbb\\") == 4 >>> min_replacements_to_alternate(\\"abababababab\\") == 0 >>> min_replacements_to_alternate(\\"a\\") == 0 >>> min_replacements_to_alternate(\\"b\\") == 0 >>> min_replacements_to_alternate(\\"\\") == 0 >>> min_replacements_to_alternate(123) is None >>> min_replacements_to_alternate(None) is None >>> min_replacements_to_alternate([1, 2, 3]) is None >>> min_replacements_to_alternate(\\"abc\\") is None >>> min_replacements_to_alternate(\\"aabbcc\\") is None","solution":"def min_replacements_to_alternate(s): Determines the minimum number of 'a's that need to be replaced with 'b's (or vice versa) so that no two 'a's are adjacent and no two 'b's are adjacent in the resulting string. if not isinstance(s, str) or any(c not in 'ab' for c in s): return None n = len(s) if n < 2: return 0 # Initialize the cost counters change_start_a = 0 # Cost to make the string alternate starting with 'a' change_start_b = 0 # Cost to make the string alternate starting with 'b' # Check each character in the string for i in range(n): expected_a = 'a' if i % 2 == 0 else 'b' expected_b = 'b' if i % 2 == 0 else 'a' if s[i] != expected_a: change_start_a += 1 if s[i] != expected_b: change_start_b += 1 return min(change_start_a, change_start_b)"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to make the string a palindrome. >>> min_operations_to_palindrome(\\"racecar\\") == 0 >>> min_operations_to_palindrome(\\"aabb\\") == 2 >>> min_operations_to_palindrome(\\"abbab\\") == 1 >>> min_operations_to_palindrome(\\"abcd\\") == 3 >>> min_operations_to_palindrome(\\"a\\") == 0 >>> min_operations_to_palindrome(\\"aa\\") == 0 >>> min_operations_to_palindrome(\\"ab\\") == 1 >>> min_operations_to_palindrome(\\"abcba\\") == 0 >>> min_operations_to_palindrome(\\"abcbad\\") == 1 >>> min_operations_to_palindrome(\\"aabbaa\\") == 0","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to transform the string s into a palindrome. def is_palindrome(s): return s == s[::-1] # A string of length 1 is already a palindrome if len(s) == 1: return 0 # If the string is already a palindrome if is_palindrome(s): return 0 n = len(s) # To check how much prefix is already forming a palindrome with its suffix. for i in range(n): if is_palindrome(s[:n-i]): return i # In the worst case, it may take n-1 operations return n - 1"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: You are given a list of integers representing the price of a single share of a stock on different days. You need to find the maximum profit you can achieve if you are allowed to buy one share and sell one share of the stock. Note that you must buy before you sell and the transaction cannot happen instantaneously (i.e., you must wait at least one day after buying to sell). Example: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 def test_max_profit(): # Example tests assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 # Additional tests assert max_profit([1, 2, 3, 4, 5]) == 4 # Buy on day 1 and sell on day 5 assert max_profit([5, 4, 3, 2, 1]) == 0 # Prices are in descending order, no profit assert max_profit([2, 4, 1, 7]) == 6 # Buy on day 3 (price = 1) and sell on day 4 (price = 7) assert max_profit([1, 6, 2, 8, 4, 9]) == 8 # Buy on day 1 (price = 1) and sell on day 6 (price = 9) # Edge cases assert max_profit([1]) == 0 # Only one day, no transaction possible assert max_profit([]) == 0 # No prices given # Test large input performance assert max_profit([i for i in range(100000)]) == 99999 # Increasing prices every day def test_minimum_length_prices(): assert max_profit([1, 2]) == 1 # Only two days, simple profit assert max_profit([2, 1]) == 0 # Prices declining, no profit","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit from buying and selling one share of stock. Prices should be a list of integers representing the stock prices on different days. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price else: profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"def run_length_encode(input_string: str) -> str: Perform run-length encoding of a given string. If the input string is None or empty, return an empty string. The function should: 1. Iterate through the input string and replace sequences of the same character with the character followed by the count of its repetitions. 2. If a character appears only once consecutively, it should be followed by the number \`1\`. Examples: >>> run_length_encode(\\"aaaabbbccdaa\\") == \\"a4b3c2d1a2\\" >>> run_length_encode(\\"abc\\") == \\"a1b1c1\\" >>> run_length_encode(\\"\\") == \\"\\" >>> run_length_encode(\\"wwwwaaadexxxxxx\\") == \\"w4a3d1e1x6\\"","solution":"def run_length_encode(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] count = 1 prev_char = input_string[0] for char in input_string[1:]: if char == prev_char: count += 1 else: encoded_string.append(f\\"{prev_char}{count}\\") count = 1 prev_char = char encoded_string.append(f\\"{prev_char}{count}\\") return \\"\\".join(encoded_string)"},{"question":"def remove_numbers(input_string: str) -> str: Write a function that takes a string as input and returns the same string with all numbers (0-9) removed from it. >>> remove_numbers(\\"abc123xyz\\") 'abcxyz' >>> remove_numbers(\\"num8er5\\") 'numer' >>> remove_numbers(\\"abcdef\\") 'abcdef' >>> remove_numbers(\\"hello world\\") 'hello world' >>> remove_numbers(\\"1234567890\\") '' >>> remove_numbers(\\"\\") '' >>> remove_numbers(\\"pa33w0rd!\\") 'pawrd!' >>> remove_numbers(\\"!@#%^&*()_+1234567890\\") '!@#%^&*()_+'","solution":"def remove_numbers(input_string): Removes all numbers from the input string. Parameters: input_string (str): The string from which to remove numbers. Returns: str: The input string with all numbers removed. return ''.join(char for char in input_string if not char.isdigit())"},{"question":"import re def is_valid_code(code: str) -> bool: Validate the access code based on specific rules. The rules are: 1. The access code must be exactly 8 characters long. 2. It should start with 1 uppercase letter. 3. Followed by 5 digits (0-9). 4. Ends with 2 lowercase letters. Parameters: - code (str): The access code to be validated. Returns: - bool: True if the access code is valid, False otherwise. >>> is_valid_code(\\"A12345bc\\") True >>> is_valid_code(\\"A1234bc\\") False >>> is_valid_code(\\"a12345bc\\") False","solution":"import re def is_valid_code(code): Validate the access code based on specific rules. The rules are: 1. The access code must be exactly 8 characters long. 2. It should start with 1 uppercase letter. 3. Followed by 5 digits (0-9). 4. Ends with 2 lowercase letters. Parameters: - code (str): The access code to be validated. Returns: - bool: True if the access code is valid, False otherwise. pattern = r'^[A-Z][0-9]{5}[a-z]{2}' return bool(re.match(pattern, code))"},{"question":"import heapq def minCost(ropes): Given an array of rope lengths, returns the minimum cost to connect all ropes into one rope. Args: ropes (list): List of integers representing the lengths of ropes. Returns: int: Minimum cost to connect all ropes. pass # Test cases def test_example_case(): assert minCost([4, 3, 2, 6]) == 29 def test_single_rope(): assert minCost([5]) == 0 def test_two_ropes(): assert minCost([5, 5]) == 10 def test_multiple_identical_ropes(): assert minCost([1, 1, 1, 1]) == 8 def test_large_ropes(): assert minCost([10, 20, 30, 40, 50]) == 330 def test_empty_list(): assert minCost([]) == 0 def test_all_zeros(): assert minCost([0, 0, 0, 0]) == 0","solution":"import heapq def minCost(ropes): Given an array of rope lengths, returns the minimum cost to connect all ropes into one rope. Args: ropes (list): List of integers representing the lengths of ropes. Returns: int: Minimum cost to connect all ropes. if not ropes: return 0 # Create a min-heap from the list of ropes heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: # Pop two smallest ropes from heap first = heapq.heappop(ropes) second = heapq.heappop(ropes) # Cost to connect these two ropes cost = first + second total_cost += cost # Push the combined rope back to the heap heapq.heappush(ropes, cost) return total_cost"},{"question":"def total_articles_read(N: int, L: List[int], R: List[int]) -> List[int]: Computes how many articles Lina has read after reading each specified article in order. Parameters: N (int): the number of articles. L (list): a list containing the lengths of the articles. R (list): a list containing the order in which Lina reads the articles. Returns: list: a list containing the total number of articles read after each article in the order they were read. Example: >>> total_articles_read(5, [4, 1, 3, 2, 5], [5, 1, 3, 2, 4]) [1, 2, 3, 4, 5]","solution":"def total_articles_read(N, L, R): Computes how many articles Lina has read after reading each specified article in order. Parameters: N (int): the number of articles. L (list): a list containing the lengths of the articles. R (list): a list containing the order in which Lina reads the articles. Returns: list: a list containing the total number of articles read after each article in the order they were read. # Initialize an array to keep track of the read status read_status = [False] * N # To store the results results = [] for read_order in R: # Mark the article as read read_status[read_order - 1] = True # Count how many articles have been read so far total_read = read_status.count(True) # Append the count to the results results.append(total_read) return results"},{"question":"def second_largest(nums: List[int]) -> int: Returns the second largest integer in the list nums. Assumes that the list nums has at least two unique integers. >>> second_largest([34, 15, 88, 2]) == 34 >>> second_largest([34, -345, -1, 100]) == 34 >>> second_largest([-3, -1, -2]) == -2 >>> second_largest([-10, -20, -30]) == -20 >>> second_largest([10, 5, -1, 100]) == 10 >>> second_largest([1, -1, 0, 2]) == 1 >>> second_largest([1, 1, 1, 2, 2, 3]) == 2 >>> second_largest([5, 5, 5, 7, 7, 7, 8]) == 7 >>> second_largest([1, 2]) == 1 >>> second_largest([2, 1]) == 1 from typing import List def test_second_largest_standard_cases(): assert second_largest([34, 15, 88, 2]) == 34 assert second_largest([34, -345, -1, 100]) == 34 def test_second_largest_negative_numbers(): assert second_largest([-3, -1, -2]) == -2 assert second_largest([-10, -20, -30]) == -20 def test_second_largest_mixed_sign_numbers(): assert second_largest([10, 5, -1, 100]) == 10 assert second_largest([1, -1, 0, 2]) == 1 def test_second_largest_with_duplicates(): assert second_largest([1, 1, 1, 2, 2, 3]) == 2 assert second_largest([5, 5, 5, 7, 7, 7, 8]) == 7 def test_second_largest_minimal_case(): assert second_largest([1, 2]) == 1 assert second_largest([2, 1]) == 1","solution":"def second_largest(nums): Returns the second largest integer in the list nums. Assumes that the list nums has at least two unique integers. first = second = float('-inf') for num in nums: if num > first: second = first first = num elif first > num > second: second = num return second"},{"question":"def sunsetViews(buildings: List[int]) -> List[int]: A building can see the sunset if it is not blocked by a taller building to its right. This function returns a list of building heights that can see the sunset. Parameters: buildings (list of int): The heights of the buildings. Returns: list of int: The heights of the buildings that can see the sunset. >>> sunsetViews([3, 5, 4, 9, 7, 6]) == [3, 5, 9] >>> sunsetViews([1, 3, 2, 6, 4, 8, 7, 9]) == [1, 3, 6, 8, 9] >>> sunsetViews([]) == [] >>> sunsetViews([1]) == [1] >>> sunsetViews([4, 4, 4, 4]) == [4] >>> sunsetViews([10, 9, 8, 7]) == [10] >>> sunsetViews([7, 8, 9, 10]) == [7, 8, 9, 10]","solution":"def sunsetViews(buildings): Returns a list of building heights that can see the sunset. A building can see the sunset if there are no taller buildings to its right. Parameters: buildings (list of int): The heights of the buildings. Returns: list of int: The heights of the buildings that can see the sunset. if not buildings: return [] result = [] max_height = 0 for height in buildings: if height > max_height: result.append(height) max_height = height return result"},{"question":"from typing import List def rotate_list(nums: List[int], k: int) -> List[int]: Rotates the elements of the list 'nums' to the right by 'k' steps. >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([0, -1, -2, -3], 1) [-3, 0, -1, -2] >>> rotate_list([1], 10) [1]","solution":"def rotate_list(nums, k): Rotates the elements of the list 'nums' to the right by 'k' steps. if not nums: return [] n = len(nums) k %= n # In case k is greater than the length of the list return nums[-k:] + nums[:-k]"},{"question":"def reverseVowels(s: str) -> str: Given a string, reverse only all the vowels in the string. A vowel is any of the characters 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase). Non-vowel characters should remain in their original positions. >>> reverseVowels(\\"hello\\") == \\"holle\\" >>> reverseVowels(\\"leetcode\\") == \\"leotcede\\" >>> reverseVowels(\\"aA\\") == \\"Aa\\" from solution import reverseVowels def test_reverse_vowels_basic(): assert reverseVowels(\\"hello\\") == \\"holle\\" assert reverseVowels(\\"leetcode\\") == \\"leotcede\\" def test_reverse_vowels_with_uppercase(): assert reverseVowels(\\"aA\\") == \\"Aa\\" assert reverseVowels(\\"AEIOU\\") == \\"UOIEA\\" assert reverseVowels(\\"ApplE\\") == \\"EpplA\\" def test_reverse_vowels_no_vowels(): assert reverseVowels(\\"bcdfg\\") == \\"bcdfg\\" assert reverseVowels(\\"hjklm\\") == \\"hjklm\\" def test_reverse_vowels_with_mixed_characters(): assert reverseVowels(\\"h3ll0 w0rld!\\") == \\"h3ll0 w0rld!\\" assert reverseVowels(\\"R@nd0m Str1ng!\\") == \\"R@nd0m Str1ng!\\" def test_reverse_vowels_empty_string(): assert reverseVowels(\\"\\") == \\"\\"","solution":"def reverseVowels(s): vowels = \\"aeiouAEIOU\\" s = list(s) i, j = 0, len(s) - 1 while i < j: while i < j and s[i] not in vowels: i += 1 while i < j and s[j] not in vowels: j -= 1 if i < j: s[i], s[j] = s[j], s[i] i += 1 j -= 1 return \\"\\".join(s)"},{"question":"from typing import List def longestIncreasingPath(matrix: List[List[int]]) -> int: Given a matrix of size N x M filled with integers, find the length of the longest path of consecutive increasing numbers in the matrix. The path can start from any cell and you can move in four possible directions: left, right, up, or down. Diagonal movements are not allowed. Parameters: matrix (List[List[int]]): 2D list representing the matrix. Returns: int: Length of the longest increasing path. Examples: >>> longestIncreasingPath([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longestIncreasingPath([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) 4 Constraints: - 1 <= N, M <= 200 - -10^4 <= matrix[i][j] <= 10^4 from solution import longestIncreasingPath def test_example_1(): matrix = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] assert longestIncreasingPath(matrix) == 4 def test_example_2(): matrix = [ [3, 4, 5], [3, 2, 6], [2, 2, 1] ] assert longestIncreasingPath(matrix) == 4 def test_single_element_matrix(): matrix = [ [1] ] assert longestIncreasingPath(matrix) == 1 def test_all_equal_elements(): matrix = [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ] assert longestIncreasingPath(matrix) == 1 def test_general_case(): matrix = [ [7, 8, 9], [9, 4, 6], [6, 5, 4] ] assert longestIncreasingPath(matrix) == 4 def test_complex_case(): matrix = [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] assert longestIncreasingPath(matrix) == 16","solution":"from typing import List def longestIncreasingPath(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) dp[x][y] = max_length return max_length directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] dp = [[-1 for _ in range(len(matrix[0]))] for _ in range(len(matrix))] max_path_length = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): max_path_length = max(max_path_length, dfs(i, j)) return max_path_length"},{"question":"from typing import List def is_balanced(sequence: str) -> bool: Determine if the given sequence of parentheses is balanced. Args: sequence (str): A string containing the sequence of parentheses. Returns: bool: True if the sequence is balanced, False otherwise. >>> is_balanced(\\"()\\") True >>> is_balanced(\\"(())\\") True >>> is_balanced(\\"((()))\\") True >>> is_balanced(\\"(()\\") False >>> is_balanced(\\"())\\") False >>> is_balanced(\\")(\\") False >>> is_balanced(\\"\\") True","solution":"def is_balanced(sequence): Determine if the given sequence of parentheses is balanced. Args: sequence (str): A string containing the sequence of parentheses. Returns: bool: True if the sequence is balanced, False otherwise. stack = [] for char in sequence: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def game_of_life(grid): Creates the next generation grid of Conway's Game of Life based on the initial grid. The grid is a two-dimensional list of integers, where each element can be 1 (alive) or 0 (dead). Args: grid (List[List[int]]): A 2D list representing the initial state of the grid. Returns: List[List[int]]: A 2D list representing the state of the grid after one tick >>> game_of_life([[0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0]]) [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]] >>> game_of_life([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]]","solution":"def game_of_life(grid): rows, cols = len(grid), len(grid[0]) def count_live_neighbors(r, c): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: live_neighbors += grid[nr][nc] return live_neighbors next_gen = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): live_neighbors = count_live_neighbors(r, c) if grid[r][c] == 1: if live_neighbors < 2 or live_neighbors > 3: next_gen[r][c] = 0 else: next_gen[r][c] = 1 else: if live_neighbors == 3: next_gen[r][c] = 1 return next_gen"},{"question":"def max_total_rest_time(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum total rest time Chef can achieve for given series of marathons. Args: T : int : Number of test cases test_cases : List[Tuple[int, List[Tuple[int, int]]]] : List of tuples where the first element is the number of checkpoints and the second element is a list of tuples containing rest time and participant limit at each checkpoint. Returns: List[int] : List of maximum total rest time for each test case >>> max_total_rest_time(2, [(3, [(30, 2), (50, 1), (70, 3)]), (4, [(45, 3), (30, 4), (35, 2), (60, 2)])]) [150, 170] >>> max_total_rest_time(1, [(1, [(1, 1)])]) [1] pass # Implement the function here","solution":"def max_total_rest_time(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] checkpoints = test_cases[i][1:] total_rest_time = sum([checkpoint[0] for checkpoint in checkpoints]) results.append(total_rest_time) return results"},{"question":"def count_negatives(matrix: List[List[int]]) -> int: Returns the total number of negative numbers in the matrix. >>> count_negatives([[4, 3, 2, -1], [3, 2, 1, -2], [1, 1, -1, -3], [-1, -1, -2, -4]]) 8 >>> count_negatives([[3, 2], [1, 0]]) 0 from solution import count_negatives def test_count_negatives_case1(): assert count_negatives([[4, 3, 2, -1], [3, 2, 1, -2], [1, 1, -1, -3], [-1, -1, -2, -4]]) == 8 def test_count_negatives_case2(): assert count_negatives([[3, 2], [1, 0]]) == 0 def test_count_negatives_case3(): assert count_negatives([[-1, -1, -2], [-3, -4, -5], [-6, -7, -8]]) == 9 def test_count_negatives_case4(): assert count_negatives([[1]]) == 0 def test_count_negatives_case5(): assert count_negatives([[-1]]) == 1 def test_count_negatives_case6(): assert count_negatives([]) == 0 def test_count_negatives_case7(): assert count_negatives([[4, 3, 2, -1, -2], [3, 1, -3], [1, -1, -3], [0, -1, -4]]) == 7","solution":"def count_negatives(matrix): Returns the number of negative numbers in the matrix. count = 0 for row in matrix: for num in row: if num < 0: count += 1 return count"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number programmatically given the constraints. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Example 1: >>> fibonacci(4) 3 Example 2: >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a new array where each element is the product of all the elements in the original array except the one at the current position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24]","solution":"def product_except_self(nums): Returns a new array where each element is the product of all the elements in the original array except the one at the current position. n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n output = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"def step_paths(n: int) -> int: Calculate the number of different ways the player can reach the top of the nth step. >>> step_paths(1) == 1 >>> step_paths(2) == 2 >>> step_paths(3) == 3 >>> step_paths(4) == 5","solution":"def step_paths(n): Returns the number of different ways the player can reach the top of the nth step. if n <= 0: return 0 if n == 1: return 1 if n == 2: return 2 previous, current = 1, 2 for i in range(3, n + 1): next_step = previous + current previous = current current = next_step return current"},{"question":"def min_length_subarray(T, test_cases): Given an array A of N integers, find the length of the shortest contiguous subarray such that the sum of its elements is at least S. If there is no such subarray, return -1. >>> min_length_subarray(2, [([5, 11], [1, 2, 3, 4, 5]), ([4, 15], [1, 2, 3, 4])]) [3, -1] >>> min_length_subarray(1, [([6, 7], [2, 3, 1, 2, 4, 3])]) [2] if __name__ == \\"__main__\\": def test_min_length_subarray(): assert min_length_subarray(2, [([5, 11], [1, 2, 3, 4, 5]), ([4, 15], [1, 2, 3, 4])]) == [3, -1] assert min_length_subarray(1, [([6, 7], [2, 3, 1, 2, 4, 3])]) == [2] assert min_length_subarray(1, [([5, 15], [5, 1, 3, 5, 10])]) == [2] assert min_length_subarray(1, [([3, 3], [1, 1, 1])]) == [3] assert min_length_subarray(1, [([3, 4], [1, 1, 1])]) == [-1] test_min_length_subarray() print(\\"All tests passed.\\")","solution":"def min_length_subarray(T, test_cases): results = [] for t in range(T): N, S = test_cases[t][0] A = test_cases[t][1] n = len(A) min_len = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += A[end] while current_sum >= S: min_len = min(min_len, end - start + 1) current_sum -= A[start] start += 1 if min_len == n + 1: results.append(-1) else: results.append(min_len) return results"},{"question":"def minimum_coins(M: int, denominations: List[int]) -> int: Calculate minimum number of coins needed to make a given amount of change from a given set of coin denominations. Parameters: - M: the amount to make change for - denominations: list of the different coin denominations Returns: The minimum number of coins needed to make the change. >>> minimum_coins(11, [1, 2, 5, 10]) 2 >>> minimum_coins(10, [1]) 10 >>> minimum_coins(100000, [1, 5, 10, 25, 50, 100, 500, 1000, 5000, 10000]) 10 >>> minimum_coins(3, [2]) 1 >>> minimum_coins(1, [1]) 1 >>> minimum_coins(25, [5, 10, 25]) 1","solution":"def minimum_coins(M, denominations): Calculate minimum number of coins needed to make a given amount of change from a given set of coin denominations. Parameters: - M: the amount to make change for - denominations: list of the different coin denominations Returns: The minimum number of coins needed to make the change. denominations = sorted(denominations, reverse=True) count = 0 for coin in denominations: if M == 0: break count += M // coin M %= coin return count"},{"question":"def transpose(matrix): Returns the transpose of the given matrix. Arguments: matrix -- a 2-dimensional list of integers Returns: A 2-dimensional list representing the transpose of the given matrix Examples: >>> transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose([[1, 2, 3]]) [[1], [2], [3]] >>> transpose([[1], [2], [3]]) [[1, 2, 3]] >>> transpose([]) [] >>> transpose([[1, 2, 3, 4], [5, 6, 7, 8]]) [[1, 5], [2, 6], [3, 7], [4, 8]]","solution":"def transpose(matrix): Returns the transpose of the given matrix. Arguments: matrix -- a 2-dimensional list of integers Returns: A 2-dimensional list representing the transpose of the given matrix return [list(row) for row in zip(*matrix)]"},{"question":"def unique_paths(N: int, M: int, grid: List[str]) -> int: Given a grid with N rows and M columns, determine the number of unique paths from the top-left corner to the bottom-right corner of the grid. Each cell in the grid can be empty or contain an obstacle. You can move either down or right one step at a time, but you cannot move into a cell with an obstacle. Return the result modulo 10^9+7. >>> unique_paths(3, 3, ['...', '.#.', '...']) 2 >>> unique_paths(3, 3, ['#', '#', '#']) 0 >>> unique_paths(3, 3, ['#..', '...', '...']) 0 >>> unique_paths(3, 3, ['...', '...', '..#']) 0 >>> unique_paths(1000, 1000, ['.' * 1000 for _ in range(1000)]) > 0 >>> unique_paths(1000, 1000, ['.' * 999 + '#' for _ in range(1000)]) 0 >>> unique_paths(1, 1, ['.']) 1 >>> unique_paths(1, 1, ['#']) 0","solution":"MOD = 10**9 + 7 def unique_paths(N, M, grid): # Initialize a DP array with 0s. dp = [[0] * M for _ in range(N)] # If the start or end cell is blocked, return 0. if grid[0][0] == '#' or grid[N-1][M-1] == '#': return 0 # Starting point dp[0][0] = 1 # Fill the DP array for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[-1][-1]"},{"question":"def calculate_scores(scores: list, results: dict) -> dict: Calculate total scores for each participant based on the problems they solved. Parameters: scores (list of int): The score values for each problem. results (dict): A dictionary where each key is a participant's name and the value is a list of booleans. Returns: dict: A dictionary where each key is a participant's name and the value is their total score. >>> scores = [10, 20, 30, 40] >>> results = { >>> \\"Alice\\": [True, False, True, True], >>> \\"Bob\\": [True, True, False, False], >>> \\"Charlie\\": [False, False, False, True] >>> } >>> calculate_scores(scores, results) { \\"Alice\\": 80, \\"Bob\\": 30, \\"Charlie\\": 40 } from solution import calculate_scores def test_calculate_scores_all_solved(): scores = [10, 20, 30, 40] results = { \\"Alice\\": [True, True, True, True], \\"Bob\\": [True, True, True, True] } expected_output = { \\"Alice\\": 100, \\"Bob\\": 100 } assert calculate_scores(scores, results) == expected_output def test_calculate_scores_none_solved(): scores = [10, 20, 30, 40] results = { \\"Alice\\": [False, False, False, False], \\"Bob\\": [False, False, False, False] } expected_output = { \\"Alice\\": 0, \\"Bob\\": 0 } assert calculate_scores(scores, results) == expected_output def test_calculate_scores_mixed(): scores = [10, 20, 30, 40] results = { \\"Alice\\": [True, False, True, True], \\"Bob\\": [True, True, False, False], \\"Charlie\\": [False, False, False, True] } expected_output = { \\"Alice\\": 80, \\"Bob\\": 30, \\"Charlie\\": 40 } assert calculate_scores(scores, results) == expected_output def test_calculate_scores_single_participant(): scores = [10, 20, 30] results = { \\"Alice\\": [True, False, True] } expected_output = { \\"Alice\\": 40 } assert calculate_scores(scores, results) == expected_output def test_calculate_scores_empty_scores_and_results(): scores = [] results = { \\"Alice\\": [], \\"Bob\\": [] } expected_output = { \\"Alice\\": 0, \\"Bob\\": 0 } assert calculate_scores(scores, results) == expected_output","solution":"def calculate_scores(scores, results): Calculate total scores for each participant based on the problems they solved. Parameters: scores (list of int): The score values for each problem. results (dict): A dictionary where each key is a participant's name and the value is a list of booleans. Returns: dict: A dictionary where each key is a participant's name and the value is their total score. total_scores = {} for participant, solved_problems in results.items(): total_scores[participant] = sum(score for score, solved in zip(scores, solved_problems) if solved) return total_scores"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, return a new array where each element at index i of the new array is the product of all the numbers in the original array except the one at i. This must be done without using division and in O(n) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([10]) [1] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6] >>> product_except_self([1000, 100, 10, 1]) [1000, 10000, 100000, 1000000]","solution":"def product_except_self(nums): Given an array of integers, return a new array where each element at index i of the new array is the product of all the numbers in the original array except the one at i. This must be done without using division and in O(n) time complexity. length = len(nums) # Initialize the left and right product lists left_products = [1] * length right_products = [1] * length result = [1] * length # Compute the left products for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Compute the right products for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Compute the result array by multiplying left and right products for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"from typing import List, Tuple def most_frequent(text: str) -> List[Tuple[str, int]]: Determine the most frequently occurring characters in a given string and return the result as a list of tuples. If there are multiple characters that occur the same maximum number of times, the characters should be sorted in ascending order. Args: - text (str): The input string which can contain alphabets (both uppercase and lowercase), numbers, and other characters. Returns: - List[Tuple[str, int]]: A list of tuples where each tuple contains a character and its frequency, sorted in ascending order of characters. Examples: >>> most_frequent(\\"abBAc123c\\") [('1', 1), ('2', 1), ('3', 1), ('A', 1), ('B', 1), ('a', 1), ('b', 1), ('c', 2)] >>> most_frequent(\\"hello world!\\") [(' ', 1), ('!', 1), ('d', 1), ('e', 1), ('h', 1), ('l', 3), ('o', 2), ('r', 1), ('w', 1)]","solution":"from collections import Counter def most_frequent(text): Returns a list of tuples with the most frequent characters and their frequencies, sorted by characters in ascending order. # Count the frequency of each character in the string freq = Counter(text) # Convert the counter to a sorted list of tuples freq_list = sorted(freq.items()) return freq_list"},{"question":"def rotate_list(nums: List[int], k: int) -> List[int]: Rotates the list to the right by k steps. Args: nums (List[int]): A list of integers. k (int): The number of steps to rotate the list. Returns: List[int]: The list after rotating to the right by k steps. Examples: >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([0, 1, 2], 4) [2, 0, 1] >>> rotate_list([5, 6, 7, 8, 9], 1) [9, 5, 6, 7, 8]","solution":"from typing import List def rotate_list(nums: List[int], k: int) -> List[int]: Rotates the list to the right by k steps. Args: nums (List[int]): A list of integers. k (int): The number of steps to rotate the list. Returns: List[int]: The list after rotating to the right by k steps. if not nums or k <= 0: return nums n = len(nums) k = k % n # In case k is greater than the length of the list return nums[-k:] + nums[:-k]"},{"question":"def spiral_order(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in spiral order. Args: matrix (List[List[int]]): A list of lists of integers representing the MxN matrix. Returns: List[int]: A list of integers in spiral order. Examples: >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([ ... [1, 2, 3, 4] ... ]) [1, 2, 3, 4] >>> spiral_order([ ... [1], ... [2], ... [3], ... [4] ... ]) [1, 2, 3, 4] >>> spiral_order([]) [] >>> spiral_order([ ... [1] ... ]) [1] >>> spiral_order([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiral_order([ ... [1, 2], ... [3, 4], ... [5, 6], ... [7, 8] ... ]) [1, 2, 4, 6, 8, 7, 5, 3]","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] while matrix: # Take the first row result += matrix.pop(0) # Take the last element of each remaining row if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # Take the last row in reverse order if matrix: result += matrix.pop()[::-1] # Take the first element of each remaining row in reverse order if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"from typing import List, Tuple def min_tree_types(n: int, m: int, edges: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Determine the minimum number of different tree types required and the possible assignment of tree types to parks. >>> min_tree_types(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) (2, [1, 2, 1, 2]) >>> min_tree_types(3, 2, [(1, 2), (2, 3)]) (2, [1, 2, 1]) pass def solve_beautify_parks(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[Tuple[int, List[int]]]: Solve the beautify parks problem for each test case. >>> solve_beautify_parks([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (3, 2, [(1, 2), (2, 3)])]) [(2, [1, 2, 1, 2]), (2, [1, 2, 1])] pass def test_beautify_parks(): test_cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (3, 2, [(1, 2), (2, 3)]) ] expected_outputs = [ (2, [1, 2, 1, 2]), (2, [1, 2, 1]) ] results = solve_beautify_parks(test_cases) for result, expected in zip(results, expected_outputs): assert result[0] == expected[0] assert result[1] == expected[1] import pytest pytest.main(args=['-v']) if __name__ == \\"__main__\\": test_beautify_parks()","solution":"from collections import deque def min_tree_types(n, m, edges): graph = [[] for _ in range(n)] # Build the adjacency list for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) color = [-1] * n def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True # Check bipartiteness and color the graph for i in range(n): if color[i] == -1: if not bfs(i): return None # Graph is not bipartite # Convert color array from [0, 1] to [1, 2] min_tree_types = 2 tree_types = [c + 1 for c in color] return (min_tree_types, tree_types) def solve_beautify_parks(test_cases): results = [] for n, m, edges in test_cases: result = min_tree_types(n, m, edges) if result: results.append((result[0], result[1])) else: max_degree = max(len(adj) for adj in graph) tree_types = [0] * n result = (max_degree + 1, tree_types) results.append(result) return results"},{"question":"def find_pairs(nums, target): Given a list of integers and a target integer, find all unique pairs of integers in the list that sum up to the target integer. >>> find_pairs([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs([1, 2, 3, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> find_pairs([3, 3, 3, 3], 6) [(3, 3)]","solution":"def find_pairs(nums, target): Given a list of integers and a target integer, find all unique pairs of integers in the list that sum up to the target integer. nums.sort() seen = set() pairs = set() for num in nums: if target - num in seen: pairs.add((target - num, num)) seen.add(num) return list(pairs)"},{"question":"def find_kth_ancestor(n: int, values: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determine the k-th ancestor of a given node in a binary tree. Args: n (int): Number of nodes in the binary tree. values (List[int]): List of integers representing the values of the nodes in the binary tree. queries (List[Tuple[int, int]]): List of queries where each query is a tuple of node_index and k. Returns: List[int]: List of integers representing the value of the k-th ancestor for each query or -1 if it does not exist. Examples: >>> find_kth_ancestor(7, [3, 5, 8, 6, 2, 9, 7], [(4, 2)]) [3] >>> find_kth_ancestor(7, [3, 5, 8, 6, 2, 9, 7], [(6, 3)]) [-1] >>> find_kth_ancestor(7, [3, 5, 8, 6, 2, 9, 7], [(2, 1)]) [8] >>> find_kth_ancestor(7, [3, 5, 8, 6, 2, 9, 7], [(4, 2), (6, 3), (2, 1)]) [3, -1, 8] >>> find_kth_ancestor(5, [10, 20, 30, 40, 50], [(3, 1), (4, 2)]) [20, 10]","solution":"def find_kth_ancestor(n, values, queries): def get_ancestors(node_index): ancestors = [] while node_index > 0: node_index = (node_index - 1) // 2 ancestors.append(node_index) return ancestors results = [] for node_index, k in queries: ancestors = get_ancestors(node_index) if k > len(ancestors): results.append(-1) else: ancestor_index = ancestors[k - 1] results.append(values[ancestor_index]) return results"},{"question":"def top_n_students(students: List[Tuple[str, int]], n: int) -> List[Tuple[str, int]]: Returns the top n students based on their scores. Parameters: students (list of tuples): A list of tuples where each tuple contains a student name (str) and their score (int). n (int): The number of top students to return. Returns: list of tuples: A list of tuples containing top n students' names and scores sorted by their scores in descending order. >>> top_n_students([('Alice', 88), ('bob', 87), ('Charlie', 88), ('Diana', 85)], 2) [('Alice', 88), ('Charlie', 88)] >>> top_n_students([('alice', 90), ('Bob', 70), ('Charlie', 90), ('Dave', 85)], 1) [('alice', 90)] from typing import List, Tuple import functools def test_top_n_students_basic(): students = [('Alice', 88), ('bob', 87), ('Charlie', 88), ('Diana', 85)] n = 2 assert top_n_students(students, n) == [('Alice', 88), ('Charlie', 88)] def test_top_n_students_single_top(): students = [('alice', 90), ('Bob', 70), ('Charlie', 90), ('Dave', 85)] n = 1 assert top_n_students(students, n) == [('alice', 90)] def test_top_n_students_all_same_score(): students = [('alice', 90), ('Bob', 90), ('charlie', 90), ('dave', 90)] n = 3 assert top_n_students(students, n) == [('alice', 90), ('Bob', 90), ('charlie', 90)] def test_top_n_students_mixed_case_names(): students = [('alice', 90), ('BOB', 70), ('Charlie', 90), ('dave', 85)] n = 2 assert top_n_students(students, n) == [('alice', 90), ('Charlie', 90)] def test_top_n_students_less_than_n_students(): students = [('Alice', 88), ('bob', 87)] n = 3 assert top_n_students(students, n) == [('Alice', 88), ('bob', 87)] def test_top_n_students_zero_n(): students = [('Alice', 88), ('bob', 87), ('Charlie', 88), ('Diana', 85)] n = 0 assert top_n_students(students, n) == [] def test_top_n_students_empty_list(): students = [] n = 5 assert top_n_students(students, n) == [] def test_top_n_students_same_case_different_scores(): students = [('Alice', 70), ('alice', 90), ('Bob', 85), ('BOB', 95)] n = 2 assert top_n_students(students, n) == [('BOB', 95), ('alice', 90)]","solution":"def top_n_students(students, n): Returns the top n students based on their scores. Parameters: students (list of tuples): A list of tuples where each tuple contains a student name (str) and their score (int). n (int): The number of top students to return. Returns: list of tuples: A list of tuples containing top n students' names and scores sorted by their scores in descending order. # Sort students first by score (descending), then by name (alphabetically, case-insensitive) students_sorted = sorted(students, key=lambda student: (-student[1], student[0].lower())) # Return the top n students return students_sorted[:n]"},{"question":"from typing import List def count_interesting_subsequences(n: int, array: List[int]) -> int: Determine the number of interesting subsequences in the array. Parameters: n (int): Length of the array. array (List[int]): The array of integers. Returns: int: The number of interesting subsequences. >>> count_interesting_subsequences(5, [3, 4, 7, 11, 18]) 3 >>> count_interesting_subsequences(6, [1, 2, 3, 5, 8, 9]) 4 pass","solution":"def count_interesting_subsequences(n, array): Returns the number of interesting subsequences in the array. Parameters: n (int): Length of the array. array (List[int]): The array of integers. Returns: int: The number of interesting subsequences. # Number of interesting subsequences can be directly computed as n - 2 # since any subsequence starting from index 0 with at least 3 elements # forms an interesting subsequence. return n - 2"},{"question":"def can_form_palindrome(s: str) -> bool: Write a function \`can_form_palindrome()\` that takes a single argument: a string \`s\`. Your function should return \`True\` if it's possible to rearrange the characters of the string \`s\` to form a palindrome, and \`False\` otherwise. A palindrome is a string that reads the same forwards and backwards, e.g., \\"racecar\\" or \\"madam\\". To solve this problem, consider the properties that characters must have for such an arrangement to be possible. >>> can_form_palindrome('civic') True >>> can_form_palindrome('hello') False from solution import can_form_palindrome def test_can_form_palindrome_even_length(): assert can_form_palindrome('aabb') == True def test_can_form_palindrome_odd_length(): assert can_form_palindrome('civic') == True def test_cannot_form_palindrome_even_length(): assert can_form_palindrome('abcd') == False def test_cannot_form_palindrome_odd_length(): assert can_form_palindrome('hello') == False def test_single_character(): assert can_form_palindrome('a') == True def test_empty_string(): assert can_form_palindrome('') == True def test_repeated_characters(): assert can_form_palindrome('aabbcccc') == True assert can_form_palindrome('aabbcccd') == False def test_special_characters(): assert can_form_palindrome('!@@!!') == True assert can_form_palindrome('!@!!#') == False","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Returns True if string s can be rearranged to form a palindrome, else False. # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(count % 2 for count in char_count.values()) # For the string to be rearranged into a palindrome: # - If the length of the string is even, there should be no characters with an odd count. # - If the length of the string is odd, there should be exactly one character with an odd count. return odd_count <= 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root: TreeNode) -> int: Compute the length of the diameter of the binary tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Args: root (TreeNode): Root of the binary tree. Returns: int: The diameter of the binary tree. Example: >>> node4 = TreeNode(4) >>> node5 = TreeNode(5) >>> node2 = TreeNode(2, left=node4, right=node5) >>> node3 = TreeNode(3) >>> root = TreeNode(1, left=node2, right=node3) >>> diameterOfBinaryTree(root) 3 >>> node2 = TreeNode(2) >>> root = TreeNode(1, left=node2) >>> diameterOfBinaryTree(root) 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root: TreeNode) -> int: def depth(node): nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter"},{"question":"def get_top_n_players(n: int, t: int, scores: List[Tuple[int, int]]) -> List[int]: Given the number of top players to track (N), the number of score submissions (T), and a list of scores where each score is a tuple of playerID and score, return the player IDs of the top N players sorted by their scores in descending order. If there is a tie, sort by player ID in ascending order. >>> get_top_n_players(3, 5, [(1, 50), (2, 30), (3, 40), (2, 70), (4, 90)]) [4, 2, 1] >>> get_top_n_players(1, 1, [(1, 100)]) [1] >>> get_top_n_players(2, 4, [(1, 30), (1, 50), (2, 40), (2, 10)]) [1, 2] >>> get_top_n_players(2, 4, [(1, 50), (2, 50), (3, 40), (4, 30)]) [1, 2] >>> get_top_n_players(2, 6, [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)]) [6, 5] >>> get_top_n_players(3, 7, [(1, 20), (1, 30), (2, 25), (3, 35), (2, 15), (4, 40), (4, 40)]) [4, 3, 1]","solution":"def get_top_n_players(n, t, scores): from heapq import nlargest leaderboard = {} for playerID, score in scores: if playerID in leaderboard: leaderboard[playerID] = max(leaderboard[playerID], score) else: leaderboard[playerID] = score top_players = nlargest(n, leaderboard.items(), key=lambda item: (item[1], -item[0])) return [playerID for playerID, score in top_players]"},{"question":"def is_valid_ip(ip: str) -> bool: Checks if the provided string is a valid IPv4 address. An IPv4 address is valid if it is in the format \\"x.x.x.x\\" where x is an integer between 0 and 255 inclusive with no leading zeros. Returns: bool: True if the IP address is valid, False otherwise. >>> is_valid_ip(\\"192.168.1.1\\") True >>> is_valid_ip(\\"255.255.255.255\\") True >>> is_valid_ip(\\"256.255.255.255\\") False >>> is_valid_ip(\\"192.168.01.1\\") False >>> is_valid_ip(\\"192.168.1.1.1\\") False >>> is_valid_ip(\\"192.168.a.b\\") False","solution":"def is_valid_ip(ip): Checks if the provided string is a valid IPv4 address. parts = ip.split('.') # There must be exactly four parts if len(parts) != 4: return False for part in parts: # Each part must be numeric if not part.isdigit(): return False # Each part must be in the range 0-255 number = int(part) if number < 0 or number > 255: return False # Each part must not have leading zeros unless it's exactly \\"0\\" if len(part) > 1 and part[0] == '0': return False return True"},{"question":"def sum_two_smallest_numbers(arr): Returns the sum of the two smallest positive numbers in the given array. >>> sum_two_smallest_numbers([19, 5, 42, 2, 77]) == 7 >>> sum_two_smallest_numbers([10, 343, 5, 1000, 20, 7, 2]) == 7 >>> sum_two_smallest_numbers([345, 674, 121, 1000, 432, 608, 19, 42]) == 61 >>> sum_two_smallest_numbers([20, 50, 77, 1000, 5, 10, 3, 2]) == 5 >>> sum_two_smallest_numbers([1, 3, 6, 45, 7, 10, 2, 20]) == 3 >>> sum_two_smallest_numbers([2, 2, 2, 2]) == 4","solution":"def sum_two_smallest_numbers(arr): Returns the sum of the two smallest positive numbers in the given array. sorted_arr = sorted(arr) return sorted_arr[0] + sorted_arr[1]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_identical(tree1: TreeNode, tree2: TreeNode) -> bool: Check if two binary trees are identical. Two binary trees are considered identical if they are structurally identical and the nodes have the same value. >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree1.right = TreeNode(3) >>> tree2 = TreeNode(1) >>> tree2.left = TreeNode(2) >>> tree2.right = TreeNode(3) >>> is_identical(tree1, tree2) True >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree1.right = TreeNode(3) >>> tree2 = TreeNode(1) >>> tree2.left = TreeNode(3) >>> tree2.right = TreeNode(2) >>> is_identical(tree1, tree2) False from solution import TreeNode, is_identical def test_identical_trees(): tree1 = TreeNode(1) tree1.left = TreeNode(2) tree1.right = TreeNode(3) tree2 = TreeNode(1) tree2.left = TreeNode(2) tree2.right = TreeNode(3) assert is_identical(tree1, tree2) == True def test_different_trees(): tree1 = TreeNode(1) tree1.left = TreeNode(2) tree1.right = TreeNode(3) tree2 = TreeNode(1) tree2.left = TreeNode(3) tree2.right = TreeNode(2) assert is_identical(tree1, tree2) == False def test_one_empty_tree(): tree1 = TreeNode(1) tree1.left = TreeNode(2) tree1.right = TreeNode(3) tree2 = None assert is_identical(tree1, tree2) == False def test_both_empty_trees(): tree1 = None tree2 = None assert is_identical(tree1, tree2) == True def test_single_node_trees(): tree1 = TreeNode(1) tree2 = TreeNode(1) assert is_identical(tree1, tree2) == True def test_single_node_trees_different_values(): tree1 = TreeNode(1) tree2 = TreeNode(2) assert is_identical(tree1, tree2) == False","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_identical(tree1: TreeNode, tree2: TreeNode) -> bool: Returns True if the two binary trees are identical, otherwise False. # Both are None if not tree1 and not tree2: return True # One of them is None if not tree1 or not tree2: return False # Both values are same and subtrees are identical return (tree1.val == tree2.val and is_identical(tree1.left, tree2.left) and is_identical(tree1.right, tree2.right))"},{"question":"def validate_ip(ip: str) -> str: Validates whether the given string is a valid IP address. An IP address consists of four numbers (each between 0 and 255) separated by dots. Each number cannot have leading zeros, except the number 0 itself. >>> validate_ip(\\"192.168.0.1\\") \\"Valid\\" >>> validate_ip(\\"256.100.50.0\\") \\"Invalid\\" >>> validate_ip(\\"192.168.01.1\\") \\"Invalid\\" >>> validate_ip(\\"192.168.0\\") \\"Invalid\\" >>> validate_ip(\\"192.168.0.1.1\\") \\"Invalid\\" pass","solution":"def validate_ip(ip): Validates whether the given string is a valid IP address. Parameters: ip (str): The IP address string to validate. Returns: str: \\"Valid\\" if the IP address is valid, \\"Invalid\\" otherwise. parts = ip.split('.') if len(parts) != 4: return \\"Invalid\\" for part in parts: if not part.isdigit(): return \\"Invalid\\" if len(part) > 1 and part[0] == '0': # leading zero return \\"Invalid\\" if not (0 <= int(part) <= 255): return \\"Invalid\\" return \\"Valid\\""},{"question":"def can_form_single_group(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determines if all athletes can form a single group at some point in time. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of tuples where each tuple contains: - M (int): Number of athletes - R (int): Maximum distance for athletes to be considered in the same group - List[Tuple[int, int]]: List of tuples with initial position and speed of each athlete Returns: List[str]: Returns \\"YES\\" if all athletes can potentially form a single group, otherwise \\"NO\\". Example: >>> can_form_single_group(2, [ ... (3, 10, [(0, 2), (5, 3), (10, 1)]), ... (3, 5, [(0, 1), (5, 2), (10, 3)]) ... ]) [\\"YES\\", \\"NO\\"]","solution":"def can_form_single_group(T, test_cases): results = [] for i in range(T): M, R, athletes = test_cases[i] min_position = min(athlete[0] for athlete in athletes) max_position = max(athlete[0] for athlete in athletes) # Check if all athletes can potentially form a single group can_group = True for j in range(M): for k in range(M): if abs(athletes[j][1] - athletes[k][1]) != 0 and abs(athletes[j][0] - athletes[k][0]) > R: can_group = False break if not can_group: break if can_group: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def max_consecutive_sum(arr: List[int]) -> int: You are given an array of integers, which can contain both positive and negative numbers. Your task is to find the maximum sum of any consecutive subarray of the given array. A subarray is a contiguous part of an array. A single element is considered a valid subarray. >>> max_consecutive_sum([1, -3, 2, 1, -1]) == 3 >>> max_consecutive_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_consecutive_sum([5]) == 5 >>> max_consecutive_sum([-5]) == -5 >>> max_consecutive_sum([-2, -1, -3, -4]) == -1 >>> max_consecutive_sum([-1, 2, 3, -2, 5]) == 8 >>> max_consecutive_sum([1] * (10**6)) == 10**6 >>> max_consecutive_sum([]) == 0","solution":"def max_consecutive_sum(arr): Returns the maximum sum of any consecutive subarray of the given array. if not arr: return 0 # Initialize variables max_sum = current_sum = arr[0] # Iterate through the array for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def minimum_partition_diff(arr: List[int]) -> int: Function to find the minimum possible absolute difference between the sums of two subsets. >>> minimum_partition_diff([1, 6, 11, 5]) 1 >>> minimum_partition_diff([1, 2, 3]) 0 pass def solve(test_cases: List[List[int]]) -> List[int]: Function to handle multiple test cases for the minimum partition difference problem. >>> test_cases = [(4, [1, 6, 11, 5]), (3, [1, 2, 3])] >>> solve(test_cases) [1, 0] >>> test_cases = [(1, [10]), (2, [10, 90])] >>> solve(test_cases) [10, 80] pass def test_minimum_partition_diff(): assert minimum_partition_diff([1, 6, 11, 5]) == 1 assert minimum_partition_diff([1, 2, 3]) == 0 assert minimum_partition_diff([1, 2, 3, 9]) == 3 assert minimum_partition_diff([1, 1, 1, 1]) == 0 assert minimum_partition_diff([1, 2]) == 1 def test_solve(): test_cases = [ (4, [1, 6, 11, 5]), (3, [1, 2, 3]) ] assert solve(test_cases) == [1, 0] test_cases = [ (4, [1, 1, 1, 1]), (4, [1, 2, 3, 9]) ] assert solve(test_cases) == [0, 3] test_cases = [ (1, [10]), (2, [10, 90]) ] assert solve(test_cases) == [10, 80] if __name__ == \\"__main__\\": test_minimum_partition_diff() test_solve()","solution":"def minimum_partition_diff(arr): Function to find the minimum possible absolute difference between the sums of two subsets. :param arr: list of integers :return: the minimum possible absolute difference # Calculate total sum of the array total_sum = sum(arr) n = len(arr) # Initialize the DP table dp = [[False for _ in range(total_sum // 2 + 1)] for _ in range(n + 1)] # Empty subset has sum 0 for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): dp[i][j] = dp[i-1][j] if j >= arr[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j - arr[i-1]] diff = float('inf') for j in range(total_sum // 2, -1, -1): if dp[n][j]: diff = total_sum - 2 * j break return diff def solve(test_cases): results = [] for n, arr in test_cases: results.append(minimum_partition_diff(arr)) return results"},{"question":"def longest_increasing_path(grid: List[List[int]]) -> int: Returns the length of the longest increasing path in the given grid. >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longest_increasing_path([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) 4 >>> longest_increasing_path([ ... [1] ... ]) 1 >>> longest_increasing_path([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 1 >>> longest_increasing_path([ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 9] ... ]) 9","solution":"def longest_increasing_path(grid): Returns the length of the longest increasing path in the given grid. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] memo = [[-1 for _ in range(m)] for _ in range(n)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] > grid[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) memo[x][y] = max_length return max_length max_path = 0 for i in range(n): for j in range(m): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"def min_page_difference(n: int, pages: List[int]) -> int: Find the minimum possible difference between the total number of pages in two stacks of books. Parameters: n (int): The number of books. pages (List[int]): The number of pages in each book. Returns: int: The minimum possible difference. Example: >>> min_page_difference(5, [1, 2, 3, 4, 5]) 1 >>> min_page_difference(1, [10]) 10 >>> min_page_difference(4, [5, 5, 5, 5]) 0 >>> min_page_difference(2, [3, 7]) 4 >>> min_page_difference(6, [10, 20, 30, 40, 50, 60]) 10 >>> min_page_difference(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 1","solution":"def min_page_difference(n, pages): total_pages = sum(pages) half_pages = total_pages // 2 # Initialize DP table dp = [0] * (half_pages + 1) for page in pages: for j in range(half_pages, page - 1, -1): dp[j] = max(dp[j], dp[j - page] + page) stack_one = dp[half_pages] stack_two = total_pages - stack_one return abs(stack_one - stack_two)"},{"question":"def exist(grid: List[List[str]], word: str) -> bool: Determines if the target word exists in the grid moving in four possible directions (up, down, left, right) and cannot reuse the same letter cell. >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCCED\\") True >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"SEE\\") True >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCB\\") False","solution":"def exist(grid, word): Determines if the target word exists in the grid moving in four possible directions (up, down, left, right) and cannot reuse the same letter cell. def dfs(grid, word, i, j, k): if k == len(word): return True if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != word[k]: return False temp = grid[i][j] grid[i][j] = '#' # Mark the cell as visited with a special symbol # Explore all possible directions: up, down, left, right found = (dfs(grid, word, i+1, j, k+1) or dfs(grid, word, i-1, j, k+1) or dfs(grid, word, i, j+1, k+1) or dfs(grid, word, i, j-1, k+1)) grid[i][j] = temp # Restore the cell's original value return found for i in range(len(grid)): for j in range(len(grid[0])): if dfs(grid, word, i, j, 0): return True return False"},{"question":"def findCubics(m: int) -> List[Tuple[int, int]]: Returns all pairs of positive integers (a, b) such that a^3 + b^3 = m and a <= b. >>> findCubics(9) [(1, 2)] >>> findCubics(28) [(1, 3)] >>> findCubics(1729) [(1, 12), (9, 10)] >>> findCubics(1000) []","solution":"def findCubics(m): Returns all pairs of positive integers (a, b) such that a^3 + b^3 = m and a <= b. result = [] # We only need to check until the cube root of m a = 1 while a**3 <= m: b = 1 while b**3 <= m: if a**3 + b**3 == m and a <= b: result.append((a, b)) b += 1 a += 1 return result"},{"question":"def min_insertions_to_avoid_adjacent_duplicates(T: int, cases: List[str]) -> List[int]: Compute the minimum number of insertions needed to transform strings such that no two adjacent characters are the same. Parameters: T (int): The number of test cases. cases (List[str]): The list of strings for each test case. Returns: List[int]: A list of integers representing the minimum number of insertions for each test case. >>> min_insertions_to_avoid_adjacent_duplicates(3, [\\"aab\\", \\"aaaa\\", \\"abc\\"]) [1, 3, 0] >>> min_insertions_to_avoid_adjacent_duplicates(2, [\\"aaaaaaaa\\", \\"ababab\\"]) [7, 0]","solution":"def min_insertions_to_avoid_adjacent_duplicates(T, cases): Returns the minimum number of insertions needed to transform the strings in \`cases\` such that no two adjacent characters are the same. results = [] for S in cases: count_inserts = 0 for i in range(len(S) - 1): if S[i] == S[i + 1]: count_inserts += 1 results.append(count_inserts) return results"},{"question":"from typing import List def can_be_expressed_as_sum_of_consecutive_integers(N: int) -> bool: Determines if an integer N can be represented as the sum of two or more consecutive positive integers. >>> can_be_expressed_as_sum_of_consecutive_integers(9) == True >>> can_be_expressed_as_sum_of_consecutive_integers(15) == True >>> can_be_expressed_as_sum_of_consecutive_integers(8) == False >>> can_be_expressed_as_sum_of_consecutive_integers(1) == False >>> can_be_expressed_as_sum_of_consecutive_integers(2) == False >>> can_be_expressed_as_sum_of_consecutive_integers(3) == True >>> can_be_expressed_as_sum_of_consecutive_integers(16) == False >>> can_be_expressed_as_sum_of_consecutive_integers(21) == True pass def solve(T: int, test_cases: List[int]) -> List[str]: For each test case, determines if the given integer can be expressed as the sum of two or more consecutive positive integers. Args: T : int : the number of test cases test_cases : List[int] : a list of integers to be tested Returns: List[str] : a list of \\"YES\\" or \\"NO\\" for each test case >>> solve(3, [9, 15, 8]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> solve(4, [1, 2, 3, 5]) == [\\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\"] pass","solution":"def can_be_expressed_as_sum_of_consecutive_integers(N): Determines if an integer N can be represented as the sum of two or more consecutive positive integers. # N should not be a power of 2 to meet the condition return (N & (N - 1)) != 0 def solve(T, test_cases): results = [] for N in test_cases: if can_be_expressed_as_sum_of_consecutive_integers(N): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def intersection(list1: List[int], list2: List[int]) -> List[int]: Returns a new list containing only the elements that are present in both input lists. The order of elements in the output list follows their first occurrence in list2. >>> intersection([1, 2, 2, 3, 4, 5], [2, 3, 3, 6, 7, 1]) [2, 3, 1] >>> intersection([5, 6, 7, 8], [8, 7, 6, 5]) [8, 7, 6, 5] from solution import intersection def test_intersection_basic(): assert intersection([1, 2, 2, 3, 4, 5], [2, 3, 3, 6, 7, 1]) == [2, 3, 1] def test_intersection_empty_lists(): assert intersection([], []) == [] assert intersection([1, 2, 3], []) == [] assert intersection([], [1, 2, 3]) == [] def test_intersection_no_common_elements(): assert intersection([1, 4, 5], [2, 3, 6]) == [] def test_intersection_with_duplicates_in_both_lists(): assert intersection([1, 2, 2, 3, 4, 5, 3], [2, 3, 3, 6, 7, 1, 2]) == [2, 3, 1] def test_intersection_order_of_list2_preserved(): assert intersection([5, 6, 7, 8], [8, 7, 6, 5]) == [8, 7, 6, 5] assert intersection([8, 7, 6, 5], [8, 7, 6, 5]) == [8, 7, 6, 5]","solution":"def intersection(list1, list2): Returns a new list containing only the elements that are present in both input lists. The order of elements in the output list follows their first occurrence in list2. set1 = set(list1) result = [] for item in list2: if item in set1 and item not in result: result.append(item) return result"},{"question":"from typing import List, Tuple def exist(board: List[List[str]], word: str) -> bool: Given a grid of letters and a word, determine whether the word can be formed by sequentially adjacent letters in the grid (left, right, up, or down), without reusing any letter cell. pass def word_search(test_cases: List[Tuple[int, int, List[List[str], int, List[str]]]]) -> List[str]: Given multiple test cases with grids and words, find for each word if it can be formed in the corresponding grid. pass def parse_input(input_string: str) -> List[Tuple[int, int, List[List[str], int, List[str]]]]: Parse the input string into structured test cases. pass # Example test cases def test_single_case(): input_string = \\"1n3 4na b c ens f c sna d e en3nabcced see sexe\\" test_cases = parse_input(input_string) result = word_search(test_cases) assert result == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_multiple_cases(): input_string = ( \\"2n\\" \\"3 4na b c ens f c sna d e en2nsee sexen\\" \\"2 2na bnc dn2nabcd dcba\\" ) test_cases = parse_input(input_string) result = word_search(test_cases) assert result == [\\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"] def test_minimal_case(): input_string = \\"1n1 1nan1na\\" test_cases = parse_input(input_string) result = word_search(test_cases) assert result == [\\"YES\\"] def test_full_grid_usage(): input_string = \\"1n2 2na bnc dn1nabcd\\" test_cases = parse_input(input_string) result = word_search(test_cases) assert result == [\\"NO\\"] def test_no_words_found(): input_string = \\"1n3 3na b cnd e fng h in1njkl\\" test_cases = parse_input(input_string) result = word_search(test_cases) assert result == [\\"NO\\"]","solution":"def exist(board, word): def dfs(board, word, i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[word_index]: return False temp = board[i][j] board[i][j] = \\"#\\" found = (dfs(board, word, i + 1, j, word_index + 1) or dfs(board, word, i - 1, j, word_index + 1) or dfs(board, word, i, j + 1, word_index + 1) or dfs(board, word, i, j - 1, word_index + 1)) board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False def word_search(test_cases): results = [] for case in test_cases: m, n, grid, k, words = case for word in words: if exist(grid, word): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_string): lines = input_string.split(\\"n\\") T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): m, n = map(int, lines[idx].split()) idx += 1 grid = [] for _ in range(m): grid.append(list(lines[idx].split())) idx += 1 k = int(lines[idx]) idx += 1 words = lines[idx].split() idx += 1 test_cases.append((m, n, grid, k, words)) return test_cases"},{"question":"def sum_numbers(s: str) -> int: Given an alphanumeric string, returns the sum of the numbers embedded in the string. Args: s (str): An alphanumeric string containing both letters and digits. Returns: int: The sum of the numbers found within the input string. Examples: >>> sum_numbers(\\"abc123xyz\\") 123 >>> sum_numbers(\\"aa11b33\\") 44 >>> sum_numbers(\\"7abc98xy2z\\") 107 >>> sum_numbers(\\"abcdefgh\\") 0 >>> sum_numbers(\\"123abc456\\") 579 >>> sum_numbers(\\"\\") 0 >>> sum_numbers(\\"12abc34\\") 46","solution":"import re def sum_numbers(s): Returns the sum of all the numbers embedded in the alphanumeric string. numbers = re.findall(r'd+', s) return sum(int(num) for num in numbers)"},{"question":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest substring that can be rearranged to form a palindrome. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"a\\") 1","solution":"def longest_palindrome_length(s): Returns the length of the longest substring that can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character count = Counter(s) length = 0 odd_found = False for char, freq in count.items(): if freq % 2 == 0: length += freq else: length += (freq - 1) odd_found = True if odd_found: length += 1 return length"},{"question":"def evaluate_expression(expression: str) -> int: Receives a string representation of a mathematical expression and evaluates it. The expression can contain addition \`+\`, subtraction \`-\`, multiplication \`*\`, division \`/\` operators, and parentheses \`()\`. The division operator should perform integer division. Assume all the inputs are valid expressions and the result of the expression would fit in a 32-bit signed integer. >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\" 3/2 \\") == 1 >>> evaluate_expression(\\" 3+5 / 2 \\") == 5 from solution import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_simple_division(): assert evaluate_expression(\\"3/2\\") == 1 def test_mixed_operations(): assert evaluate_expression(\\"3+5/2\\") == 5 def test_with_parentheses(): assert evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 def test_complex_expression(): assert evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") == 21 def test_expression_with_spaces(): assert evaluate_expression(\\" 3 + 2 * 2 \\") == 7 def test_expression_only_parentheses(): assert evaluate_expression(\\"((2+3)*(5-2))/2\\") == 7 def test_large_numbers(): assert evaluate_expression(\\"1000000+2*1000\\") == 1002000 def test_expression_starting_with_parenthesis(): assert evaluate_expression(\\"(10+20)/5\\") == 6","solution":"def evaluate_expression(expression: str) -> int: Evaluates a string representation of a mathematical expression containing +, -, *, / operators and parentheses. def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a // b def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_operations(values, ops): right = values.pop() left = values.pop() op = ops.pop() values.append(operate(left, right, op)) # Remove spaces from the expression expression = expression.replace(' ', '') values = [] ops = [] i = 0 while i < len(expression): if expression[i].isdigit(): val = 0 while (i < len(expression)) and (expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == '(': ops.append(expression[i]) elif expression[i] == ')': while ops and ops[-1] != '(': apply_operations(values, ops) ops.pop() else: while ops and precedence(ops[-1]) >= precedence(expression[i]): apply_operations(values, ops) ops.append(expression[i]) i += 1 while ops: apply_operations(values, ops) return values[-1]"},{"question":"def sum_of_squares_of_digits(n: int) -> int: Given an integer number n, returns the sum of the squares of its digits. Args: n (int): The input integer number. Returns: int: The sum of the squares of the digits of n. Examples: >>> sum_of_squares_of_digits(234) 29 >>> sum_of_squares_of_digits(4421) 37","solution":"def sum_of_squares_of_digits(n): Given an integer number n, returns the sum of the squares of its digits. return sum(int(digit)**2 for digit in str(n))"},{"question":"def detect_language(text: str) -> str: Determines the language of the given text snippet by identifying the most common words in English, Spanish, and French. >>> detect_language(\\"I love the way you are. And it is awesome.\\") \\"English\\" >>> detect_language(\\"El amor es muy grande. La vida es bella.\\") \\"Spanish\\" >>> detect_language(\\"Le amour est magnifique. La joie de vivre.\\") \\"French\\" >>> detect_language(\\"Le el la est es the is and love amour\\") \\"Undetermined\\" >>> detect_language(\\"El amor es grande, and I love it very much.\\") \\"English\\" >>> detect_language(\\"The weather is nice, y el sol es brillante.\\") \\"Spanish\\" >>> detect_language(\\"The food is amazing, et le vin est bon.\\") \\"French\\"","solution":"def detect_language(text): Determines the language of the given text snippet by identifying the most common words in English, Spanish, and French. english_keywords = [\\"the\\", \\"is\\", \\"and\\", \\"love\\"] spanish_keywords = [\\"el\\", \\"la\\", \\"es\\", \\"amor\\"] french_keywords = [\\"le\\", \\"la\\", \\"est\\", \\"amour\\"] english_count = sum(text.count(word) for word in english_keywords) spanish_count = sum(text.count(word) for word in spanish_keywords) french_count = sum(text.count(word) for word in french_keywords) if english_count > spanish_count and english_count > french_count: return \\"English\\" elif spanish_count > english_count and spanish_count > french_count: return \\"Spanish\\" elif french_count > english_count and french_count > spanish_count: return \\"French\\" else: return \\"Undetermined\\""},{"question":"def get_active_users_with_friends(action_log: List[str]) -> List[int]: Identify all users who have at least one friend and have made status posts. Args: action_log (List[str]): List of actions performed on the website. Returns: List[int]: List of user IDs sorted in ascending order, who have at least one friend and have made status posts. Example: >>> get_active_users_with_friends([ \\"friend_request 1 2\\", \\"post 1\\", \\"friend_request 1 3\\", \\"friend_request 2 3\\", \\"post 3\\", \\"post 2\\", \\"friend_request 4 5\\", \\"post 5\\" ]) [1, 2, 3, 5] >>> get_active_users_with_friends([\\"post 1\\", \\"post 2\\", \\"post 3\\"]) [] >>> get_active_users_with_friends([\\"friend_request 1 2\\", \\"friend_request 3 4\\"]) [] # Your implementation here from solution import get_active_users_with_friends def test_example_case(): action_log = [ \\"friend_request 1 2\\", \\"post 1\\", \\"friend_request 1 3\\", \\"friend_request 2 3\\", \\"post 3\\", \\"post 2\\", \\"friend_request 4 5\\", \\"post 5\\" ] assert get_active_users_with_friends(action_log) == [1, 2, 3, 5] def test_no_friends_posted(): action_log = [ \\"post 1\\", \\"post 2\\", \\"post 3\\" ] assert get_active_users_with_friends(action_log) == [] def test_no_posts_but_friend_requests(): action_log = [ \\"friend_request 1 2\\", \\"friend_request 3 4\\" ] assert get_active_users_with_friends(action_log) == [] def test_some_users_with_friends_no_posts(): action_log = [ \\"friend_request 1 2\\", \\"post 1\\", \\"friend_request 2 3\\" ] assert get_active_users_with_friends(action_log) == [1] def test_single_action(): action_log = [ \\"post 1\\" ] assert get_active_users_with_friends(action_log) == [] action_log = [ \\"friend_request 1 2\\" ] assert get_active_users_with_friends(action_log) == [] def test_all_users_with_friends_and_posts(): action_log = [ \\"friend_request 1 2\\", \\"post 1\\", \\"post 2\\", \\"friend_request 2 3\\", \\"post 3\\", \\"friend_request 3 4\\", \\"post 4\\" ] assert get_active_users_with_friends(action_log) == [1, 2, 3, 4]","solution":"def get_active_users_with_friends(action_log): from collections import defaultdict # Dictionary to store friends of each user friends = defaultdict(set) # Set to store users who have made posts users_with_posts = set() for action in action_log: parts = action.split() if parts[0] == \\"friend_request\\": user1 = int(parts[1]) user2 = int(parts[2]) friends[user1].add(user2) friends[user2].add(user1) elif parts[0] == \\"post\\": user = int(parts[1]) users_with_posts.add(user) result = [] for user in users_with_posts: if friends[user]: result.append(user) result.sort() return result"},{"question":"def minPathSum(grid: List[List[int]]) -> int: Function to find the minimum travel cost from the top-left to the bottom-right of the grid. Parameters: grid (List[List[int]]): 2D list representing the cost grid. Returns: int: Minimum travel cost. Examples: >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 3]]) 6 >>> minPathSum([[1], [2], [3]]) 6 >>> minPathSum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> minPathSum([[100, 100], [100, 1]]) 201 >>> minPathSum([[5]]) 5 >>> minPathSum([[1]*200 for _ in range(200)]) 399 >>> minPathSum([[1, 2, 5], [3, 2, 1]]) 6","solution":"def minPathSum(grid): Function to find the minimum travel cost from the top-left to the bottom-right of the grid. :param grid: List[List[int]]: 2D list representing the cost grid. :return: int: Minimum travel cost. m, n = len(grid), len(grid[0]) # Create a DP table to store min cost for each cell dp = [[0] * n for _ in range(m)] # Initialize first cell dp[0][0] = grid[0][0] # Initialize first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize first row (can only come from left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"from typing import List def can_sort_by_reversing_one_subsequence(sequence: List[int]) -> bool: Determines if a sequence can be sorted by reversing exactly one sub-sequence (a contiguous section). :param sequence: List[int], the input sequence of integers. :return: bool, True if the sequence can be sorted by reversing one sub-sequence, otherwise False. >>> can_sort_by_reversing_one_subsequence([3, 5, 4, 9]) True >>> can_sort_by_reversing_one_subsequence([1, 3, 5, 4, 2, 6]) False from solution import can_sort_by_reversing_one_subsequence def test_example_cases(): assert can_sort_by_reversing_one_subsequence([3, 5, 4, 9]) == True assert can_sort_by_reversing_one_subsequence([1, 3, 5, 4, 2, 6]) == False def test_already_sorted(): assert can_sort_by_reversing_one_subsequence([1, 2, 3, 4, 5]) == True def test_reverse_whole_array(): assert can_sort_by_reversing_one_subsequence([5, 4, 3, 2, 1]) == True def test_single_element(): assert can_sort_by_reversing_one_subsequence([1]) == True def test_two_elements_sorted(): assert can_sort_by_reversing_one_subsequence([1, 2]) == True def test_two_elements_unsorted(): assert can_sort_by_reversing_one_subsequence([2, 1]) == True def test_multiple_disorder_segments(): assert can_sort_by_reversing_one_subsequence([1, 3, 2, 4, 5]) == True assert can_sort_by_reversing_one_subsequence([1, 3, 2, 5, 4]) == False def test_larger_example(): assert can_sort_by_reversing_one_subsequence([10, 20, 30, 25, 24, 40, 50]) == True def test_unrecoverable_sequence(): assert can_sort_by_reversing_one_subsequence([1, 5, 3, 4, 2, 6]) == False","solution":"def can_sort_by_reversing_one_subsequence(sequence): Determines if the sequence can be sorted by reversing exactly one sub-sequence. :param sequence: List[int], the input sequence of integers. :return: bool, True if the sequence can be sorted by reversing one sub-sequence, otherwise False. n = len(sequence) # Find the first segment that is not in order start = 0 while start < n - 1 and sequence[start] <= sequence[start + 1]: start += 1 # If the whole array is already sorted if start == n - 1: return True # Find the end of this descending sequence end = start while end < n - 1 and sequence[end] >= sequence[end + 1]: end += 1 # Reverse the found segment reversed_segment = sequence[start:end + 1][::-1] # Check if the modified sequence is sorted possible_sequence = sequence[:start] + reversed_segment + sequence[end + 1:] for i in range(1, n): if possible_sequence[i - 1] > possible_sequence[i]: return False return True"},{"question":"def remove_duplicates(nums): Removes duplicates from the input array in-place, ensuring each unique element appears only once. The relative order of elements is maintained. :param nums: List[int] - List of sorted integers. :return: int - The length of the modified list with unique elements. pass from solution import remove_duplicates def test_example_1(): nums = [1, 1, 2] length = remove_duplicates(nums) assert length == 2 assert nums[:length] == [1, 2] def test_example_2(): nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] length = remove_duplicates(nums) assert length == 5 assert nums[:length] == [0, 1, 2, 3, 4] def test_empty_array(): nums = [] length = remove_duplicates(nums) assert length == 0 assert nums == [] def test_single_element(): nums = [1] length = remove_duplicates(nums) assert length == 1 assert nums[:length] == [1] def test_all_unique(): nums = [1, 2, 3, 4, 5] length = remove_duplicates(nums) assert length == 5 assert nums[:length] == [1, 2, 3, 4, 5] def test_all_duplicates(): nums = [2, 2, 2, 2, 2, 2, 2] length = remove_duplicates(nums) assert length == 1 assert nums[:length] == [2]","solution":"def remove_duplicates(nums): Removes duplicates from the input array in-place, ensuring each unique element appears only once. The relative order of elements is maintained. :param nums: List[int] - List of sorted integers. :return: int - The length of the modified list with unique elements. if not nums: return 0 write_index = 1 # index to write the next unique value for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"def partitionLabels(s: str) -> List[int]: Given a string s, which consists of lowercase letters only, divide the string into as many parts as possible so that each letter appears in at most one part, and return all the parts' lengths in an array. Examples: >>> partitionLabels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partitionLabels(\\"eccbbbbdec\\") [10]","solution":"def partitionLabels(s): Divide the string into as many parts as possible so that each letter appears in at most one part. Return the lengths of each part in an array. # First, find the last occurrence of each character last_occurrence = {char: idx for idx, char in enumerate(s)} parts = [] start, end = 0, 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: parts.append(i - start + 1) start = i + 1 return parts"},{"question":"def two_sum(nums, target): Takes an array of integers and a target integer. Finds two distinct integers in the array that add up to the target and returns their indices as a tuple where index1 is less than index2. Args: nums: List of integers target: Integer target sum Returns: Tuple of two integers representing the indices of the two numbers. Examples: >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1) # Example unit tests def test_two_sum_example1(): nums = [2, 7, 11, 15] target = 9 assert two_sum(nums, target) == (0, 1) def test_two_sum_example2(): nums = [3, 2, 4] target = 6 assert two_sum(nums, target) == (1, 2) def test_two_sum_example3(): nums = [3, 3] target = 6 assert two_sum(nums, target) == (0, 1) def test_two_sum_negative_numbers(): nums = [-3, 4, 3, 90] target = 0 assert two_sum(nums, target) == (0, 2) def test_two_sum_multiple_solutions(): nums = [1, 2, 3, 4, 5] target = 9 assert two_sum(nums, target) == (3, 4) def test_two_sum_larger_numbers(): nums = [1000000, 2000000, 3000000, 4000000] target = 7000000 assert two_sum(nums, target) == (2, 3)","solution":"def two_sum(nums, target): Takes an array of integers and a target integer. Finds two distinct integers in the array that add up to the target and returns their indices as a tuple. Args: nums: List of integers target: Integer target sum Returns: Tuple of two integers representing the indices of the two numbers. indices_dict = {} for index, num in enumerate(nums): difference = target - num if difference in indices_dict: return (indices_dict[difference], index) indices_dict[num] = index"},{"question":"class Population: def __init__(self): self.birth_years = [] self.death_years = [] def addPerson(self, birthYear: int, deathYear: int): Adds a person's birth and death year to the records. >>> p = Population() >>> p.addPerson(1900, 1950) >>> p.addPerson(1920, 1960) >>> p.addPerson(1940, 1980) pass def findMaxAliveYear(self) -> int: Finds and returns the year with the maximum number of people alive. >>> p = Population() >>> p.addPerson(1900, 1950) >>> p.addPerson(1920, 1960) >>> p.addPerson(1940, 1980) >>> p.findMaxAliveYear() == 1940 True pass # Test cases def test_population_single_person(): p = Population() p.addPerson(1900, 1950) assert p.findMaxAliveYear() == 1900 def test_population_multiple_people(): p = Population() p.addPerson(1900, 1950) p.addPerson(1920, 1960) p.addPerson(1940, 1980) assert p.findMaxAliveYear() == 1940 def test_population_disjoint_years(): p = Population() p.addPerson(1900, 1910) p.addPerson(1920, 1930) p.addPerson(1940, 1950) assert p.findMaxAliveYear() == 1900 def test_population_edge_case_min_alive_year(): p = Population() p.addPerson(1900, 1905) assert p.findMaxAliveYear() == 1900 def test_population_no_people(): p = Population() assert p.findMaxAliveYear() is None def test_population_all_same_year(): p = Population() p.addPerson(1900, 1900) p.addPerson(1900, 1900) p.addPerson(1900, 1900) assert p.findMaxAliveYear() == 1900","solution":"class Population: def __init__(self): self.birth_years = [] self.death_years = [] def addPerson(self, birthYear: int, deathYear: int): self.birth_years.append(birthYear) self.death_years.append(deathYear) def findMaxAliveYear(self) -> int: if not self.birth_years or not self.death_years: return None min_year = min(self.birth_years) max_year = max(self.death_years) # Initialize timeline from the earliest birth to the latest death year years = [0] * (max_year - min_year + 1) # Increment the count of population for each birth year for birth in self.birth_years: years[birth - min_year] += 1 # Decrement the count of population for each death year + 1 for death in self.death_years: if death + 1 <= max_year: years[death + 1 - min_year] -= 1 # Calculate the population count year by year max_population = 0 current_population = 0 max_population_year = min_year for year in range(len(years)): current_population += years[year] if current_population > max_population: max_population = current_population max_population_year = year + min_year return max_population_year"},{"question":"def minimize_sum(arr: List[int]) -> int: Finds the minimum possible final sum of the array by repeatedly merging two adjacent elements into their sum until only one element remains. >>> minimize_sum([4, 3, 6]) 13 >>> minimize_sum([1, 2, 3]) 6","solution":"def minimize_sum(arr): Finds the minimum possible final sum of the array by repeatedly merging two adjacent elements into their sum until only one element remains. :param arr: List of integers :return: Minimum possible sum of the remaining element # The sum of the array using the twist mentioned would be the sum of the entire array # as merging two adjacent elements to their sum doesn't change the overall sum value. return sum(arr)"},{"question":"def find_max_and_index(numbers: List[int]) -> Tuple[int, int]: Find the maximum number in a given list of integers and return both the maximum number and its index. Parameters: numbers (list): A list of integers Returns: tuple: A tuple containing the maximum number and its index >>> find_max_and_index([10]) == (10, 0) >>> find_max_and_index([1, 2, 3, 4, 5]) == (5, 4) >>> find_max_and_index([-1, -2, -3, -4, -5]) == (-1, 0) >>> find_max_and_index([1, -2, 3, 0, 2]) == (3, 2) >>> find_max_and_index([1, 3, 3, 4, 4, 4, 2]) == (4, 3) >>> find_max_and_index([1, 2, 3, 5]) == (5, 3)","solution":"def find_max_and_index(numbers): Find the maximum number in a list and return it along with its index. Parameters: numbers (list): A list of integers Returns: tuple: A tuple containing the maximum number and its index max_number = numbers[0] max_index = 0 for index, number in enumerate(numbers): if number > max_number: max_number = number max_index = index return max_number, max_index"},{"question":"def searchInsert(nums: List[int], target: int) -> int: Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. >>> searchInsert([1, 3, 5, 6], 5) 2 >>> searchInsert([1, 3, 5, 6], 2) 1 >>> searchInsert([1, 3, 5, 6], 7) 4 >>> searchInsert([1, 3, 5, 6], 0) 0 >>> searchInsert([1], 0) 0","solution":"def searchInsert(nums, target): Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. :param nums: List[int] - a sorted list of integers :param target: int - the target integer to find or to insert :return: int - the index if the target is found, or the index where it should be inserted left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def is_palindrome(n: int) -> bool: Given an integer n, return a boolean indicating whether n is a palindrome. >>> is_palindrome(12321) True >>> is_palindrome(-12321) False >>> is_palindrome(12345) False >>> is_palindrome(5) True >>> is_palindrome(0) True >>> is_palindrome(123454321) True >>> is_palindrome(123456789) False","solution":"def is_palindrome(n): Returns True if n is a palindrome number, False otherwise. if n < 0: return False str_n = str(n) return str_n == str_n[::-1]"},{"question":"def sort_words(words: str) -> list: Takes a string of comma-separated words and returns a list of the words, sorted in alphabetical order. Parameters: words (str): A string of comma-separated words Returns: list: A list of words sorted in alphabetical order Examples: >>> sort_words(\\"banana,apple,cherry\\") ['apple', 'banana', 'cherry'] >>> sort_words(\\"banana\\") ['banana'] >>> sort_words(\\"\\") [''] >>> sort_words(\\"apple,banana,cherry\\") ['apple', 'banana', 'cherry'] >>> sort_words(\\"cherry,banana,apple\\") ['apple', 'banana', 'cherry'] >>> sort_words(\\"grape,orange,kiwi,banana\\") ['banana', 'grape', 'kiwi', 'orange'] >>> sort_words(\\"apple,apple,banana\\") ['apple', 'apple', 'banana']","solution":"def sort_words(words): Takes a string of comma-separated words and returns a list of the words, sorted in alphabetical order. Parameters: words (str): A string of comma-separated words Returns: list: A list of words sorted in alphabetical order words_list = words.split(',') return sorted(words_list)"},{"question":"def is_citrus(fruit: str) -> bool: Checks if the fruit is a citrus fruit. >>> is_citrus(\\"orange\\") True >>> is_citrus(\\"apple\\") False >>> is_citrus(\\"ORANGE\\") True # Testing case insensitivity def is_berry(fruit: str) -> bool: Checks if the fruit is a berry. >>> is_berry(\\"strawberry\\") True >>> is_berry(\\"banana\\") False >>> is_berry(\\"STRAWBERRY\\") True # Testing case insensitivity def is_tropical(fruit: str) -> bool: Checks if the fruit is a tropical fruit. >>> is_tropical(\\"mango\\") True >>> is_tropical(\\"lemon\\") False >>> is_tropical(\\"MANGO\\") True # Testing case insensitivity","solution":"def is_citrus(fruit): Checks if the fruit is a citrus fruit. citrus_fruits = [\\"orange\\", \\"lime\\", \\"lemon\\", \\"grapefruit\\", \\"mandarin\\"] return fruit.lower() in citrus_fruits def is_berry(fruit): Checks if the fruit is a berry. berry_fruits = [\\"strawberry\\", \\"blueberry\\", \\"raspberry\\", \\"blackberry\\", \\"cranberry\\"] return fruit.lower() in berry_fruits def is_tropical(fruit): Checks if the fruit is a tropical fruit. tropical_fruits = [\\"mango\\", \\"papaya\\", \\"pineapple\\", \\"banana\\", \\"coconut\\"] return fruit.lower() in tropical_fruits"},{"question":"import math from typing import Union def calculate_hypotenuse(a: Union[int, float], b: Union[int, float]) -> float: Returns the hypotenuse of a right-angled triangle given the lengths of the two shorter sides, a and b. >>> calculate_hypotenuse(3, 4) 5.00 >>> calculate_hypotenuse(1.5, 2.0) 2.50 >>> calculate_hypotenuse(0, 0) 0.00 >>> calculate_hypotenuse(0, 4) 4.00 >>> calculate_hypotenuse(3, 0) 3.00 >>> calculate_hypotenuse(300, 400) 500.00 >>> calculate_hypotenuse(1, math.sqrt(3)) 2.00","solution":"import math def calculate_hypotenuse(a, b): Returns the hypotenuse of a right-angled triangle given the lengths of the two shorter sides, a and b. hypotenuse = math.sqrt(a**2 + b**2) return round(hypotenuse, 2)"},{"question":"from typing import List def process_orders(order_list: List[str]) -> List[str]: Process a list of customer orders, returning each unique order in the sequence it was placed, followed by the count of how many times it was ordered. >>> process_orders([\\"espresso\\", \\"latte\\", \\"cappuccino\\", \\"espresso\\", \\"latte\\"]) [\\"espresso 2\\", \\"latte 2\\", \\"cappuccino 1\\"] >>> process_orders([\\"latte\\", \\"latte\\", \\"latte\\", \\"latte\\"]) [\\"latte 4\\"] >>> process_orders([\\"americano\\", \\"mocha\\", \\"flat white\\", \\"americano\\", \\"mocha\\", \\"flat white\\", \\"americano\\"]) [\\"americano 3\\", \\"mocha 2\\", \\"flat white 2\\"]","solution":"from collections import deque, defaultdict def process_orders(order_list): order_count = defaultdict(int) order_queue = deque() unique_orders = set() for order in order_list: order_count[order] += 1 if order not in unique_orders: unique_orders.add(order) order_queue.append(order) result = [] while order_queue: order = order_queue.popleft() result.append(f\\"{order} {order_count[order]}\\") return result"},{"question":"def min_contiguous_subarrays_to_sort(arr: List[int]) -> int: Returns the minimum number of contiguous subarrays required to be sorted so that the entire array, when concatenated back, becomes sorted in non-decreasing order. >>> min_contiguous_subarrays_to_sort([1]) 1 >>> min_contiguous_subarrays_to_sort([1, 2, 3, 4, 5, 6]) 1 >>> min_contiguous_subarrays_to_sort([1, 2, 4, 3, 5]) 2 >>> min_contiguous_subarrays_to_sort([5, 4, 3, 2, 1]) 5 >>> min_contiguous_subarrays_to_sort([1, 3, 2, 4, 3, 5]) 3","solution":"def min_contiguous_subarrays_to_sort(arr): Returns the minimum number of contiguous subarrays required to be sorted so that the entire array, when concatenated back, becomes sorted in non-decreasing order. n = len(arr) if n <= 1: return 1 count = 1 for i in range(1, n): if arr[i] < arr[i - 1]: count += 1 return count"},{"question":"def min_containers(test_cases): Find the minimum number of containers needed to store all the samples such that each container holds a sequence of samples with strictly increasing efficacy rates. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple consists of an integer N and a list of N integers representing the efficacy rates of the samples. Returns: List[int]: A list of integers where each integer represents the minimum number of containers needed for the corresponding test case. Example: >>> test_cases = [(6, [5, 1, 3, 6, 4, 7])] >>> min_containers(test_cases) [2] # Example test cases def test_min_containers(): test_cases = [ ((6, [5, 1, 3, 6, 4, 7]), [2]), ((3, [1, 2, 3]), [1]), ((3, [3, 2, 1]), [3]), ((5, [1, 3, 2, 4, 5]), [2]), ((4, [1, 5, 3, 6]), [2]), ((6, [6, 5, 4, 3, 2, 1]), [6]), ((1, [7]), [1]), ((10, [2, 1, 4, 3, 6, 5, 8, 7, 10, 9]), [2]) ] for (input_data, expected) in test_cases: assert min_containers([input_data]) == expected","solution":"def min_containers(test_cases): results = [] for n, samples in test_cases: containers = [] for sample in samples: placed = False for container in containers: if container[-1] < sample: container.append(sample) placed = True break if not placed: containers.append([sample]) results.append(len(containers)) return results"},{"question":"def isToeplitzMatrix(matrix) -> bool: Returns True if the given matrix is a Toeplitz matrix, else False. >>> isToeplitzMatrix([ ... [1, 2, 3, 4], ... [5, 1, 2, 3], ... [9, 5, 1, 2] ... ]) == True >>> isToeplitzMatrix([ ... [1, 2], ... [2, 2] ... ]) == False","solution":"def isToeplitzMatrix(matrix): Returns True if the given matrix is a Toeplitz matrix, else False. rows = len(matrix) cols = len(matrix[0]) for row in range(1, rows): for col in range(1, cols): if matrix[row][col] != matrix[row - 1][col - 1]: return False return True"},{"question":"from typing import List def minimize_max_sum(arr: List[int], k: int) -> int: Write a function that takes a list of integers and groups them into a specified number of contiguous sublists such that the maximum sum of any sublist is minimized. Your function should return this minimized maximum sum. Args: arr (List[int]): A list of integers where 1 ≤ len(arr) ≤ 1000, 1 ≤ arr[i] ≤ 1000. k (int): An integer denoting the number of sublists to split the list into (1 ≤ k ≤ len(arr)) Returns: int: the minimized maximum sum of the sublists. Example: >>> minimize_max_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_sum([1, 2, 3, 4, 5], 2) 9 pass def test_minimize_max_sum_example(): assert minimize_max_sum([7, 2, 5, 10, 8], 2) == 18 def test_minimize_max_sum_one_element(): assert minimize_max_sum([1], 1) == 1 def test_minimize_max_sum_all_equal_elements(): assert minimize_max_sum([5, 5, 5, 5], 2) == 10 assert minimize_max_sum([5, 5, 5, 5], 4) == 5 def test_minimize_max_sum_larger_list(): assert minimize_max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == 17 assert minimize_max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 15 def test_minimize_max_sum_single_split(): assert minimize_max_sum([1, 3, 100, 2, 8, 4], 1) == 118 assert minimize_max_sum([10, 20, 30, 40, 50], 1) == 150 def test_minimize_max_sum_max_sublists(): assert minimize_max_sum([1, 2, 3, 4, 5], 5) == 5 def test_minimize_max_sum_standard_case(): assert minimize_max_sum([1, 4, 4], 3) == 4","solution":"def can_split(nums, k, max_sum): current_sum = 0 needed_splits = 1 for num in nums: if current_sum + num > max_sum: needed_splits += 1 current_sum = num if needed_splits > k: return False else: current_sum += num return True def minimize_max_sum(arr, k): left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(arr, k, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def is_valid_necklace(necklace: str) -> bool: Check if a given string representing a necklace is valid based on the following rules: 1. No two adjacent beads can be of the same color. 2. The necklace must form a loop, meaning the first and last beads must also follow rule 1. :param necklace: A string representing the sequence of colored beads. :return: \\"True\\" if the necklace is valid, \\"False\\" otherwise. >>> is_valid_necklace(\\"RGBY\\") True >>> is_valid_necklace(\\"RBYG\\") True >>> is_valid_necklace(\\"RRGB\\") False >>> is_valid_necklace(\\"BBGY\\") False >>> is_valid_necklace(\\"RYR\\") False >>> is_valid_necklace(\\"RGBYRGB\\") True pass","solution":"def is_valid_necklace(necklace): Check if the given necklace is valid. :param necklace: A string representing the sequence of colored beads. :return: \\"True\\" if the necklace is valid, \\"False\\" otherwise. n = len(necklace) # Check all adjacent beads for i in range(n): if necklace[i] == necklace[(i + 1) % n]: return False return True"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Find the longest common prefix among a list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" def test_common_prefix_example1(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" def test_no_common_prefix(): assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" def test_common_prefix_example2(): assert longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" def test_no_common_prefix_example2(): assert longest_common_prefix([\\"throne\\", \\"dungeon\\"]) == \\"\\" def test_same_strings(): assert longest_common_prefix([\\"throne\\", \\"throne\\"]) == \\"throne\\" def test_single_string(): assert longest_common_prefix([\\"single\\"]) == \\"single\\" def test_empty_list(): assert longest_common_prefix([]) == \\"\\" def test_single_character_prefix(): assert longest_common_prefix([\\"a\\", \\"ab\\", \\"abc\\"]) == \\"a\\" def test_all_empty_strings(): assert longest_common_prefix([\\"\\", \\"\\", \\"\\"]) == \\"\\"","solution":"from typing import List def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" # Find the shortest string in the list min_length = min(len(s) for s in strs) # Initialize the prefix with the first string fully prefix = strs[0][:min_length] for i in range(min_length): # Get the current character to check char = prefix[i] # Compare it with the same position in all strings for s in strs: if s[i] != char: return prefix[:i] return prefix"},{"question":"def character_frequency(input_str): Calculate the frequency of each character in the given string. Characters are considered case-insensitively. :param input_str: The input string :return: Dictionary with characters as keys and their frequencies as values. >>> character_frequency('Hello World') {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_frequency('AABBCC') {'a': 2, 'b': 2, 'c': 2} >>> character_frequency('') {} >>> character_frequency(12345) {}","solution":"def character_frequency(input_str): Calculate the frequency of each character in the given string. Characters are considered case-insensitively. :param input_str: The input string :return: Dictionary with characters as keys and their frequencies as values. if not isinstance(input_str, str) or input_str == \\"\\": return {} frequency_dict = {} for char in input_str.lower(): if char.isalpha(): frequency_dict[char] = frequency_dict.get(char, 0) + 1 return frequency_dict"},{"question":"from typing import List def max_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three numbers from the array. The array will have at least three integers. Negative numbers and zeros are allowed. >>> max_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([-1, -2, -3, -4]) -6 def test_max_product_of_three_positive_numbers(): assert max_product_of_three([1, 10, 2, 6, 5, 3]) == 300 def test_max_product_of_three_mixed_numbers(): assert max_product_of_three([-10, -10, 5, 2]) == 500 def test_max_product_of_three_negative_numbers(): assert max_product_of_three([-1, -2, -3, -4]) == -6 def test_max_product_of_three_including_zero(): assert max_product_of_three([0, -1, 3, 100, 70]) == 21000 def test_max_product_of_three_large_numbers(): assert max_product_of_three([1000, 1000, 1000]) == 1000000000 def test_max_product_of_three_mixed_with_large_and_small_numbers(): assert max_product_of_three([-1000, -1000, 1, 2, 3]) == 3000000","solution":"def max_product_of_three(nums): Returns the maximum product of any three numbers from the array. nums.sort() # Considering the highest three numbers or the lowest two numbers with the highest one number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def largest_contiguous_planted_block(grid: List[List[int]]) -> int: Find the largest contiguous block of planted sections in a 2D grid. >>> largest_contiguous_planted_block([ ... [1, 1, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 1] ... ]) 5 >>> largest_contiguous_planted_block([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> largest_contiguous_planted_block([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9 >>> largest_contiguous_planted_block([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> largest_contiguous_planted_block([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) 1 >>> largest_contiguous_planted_block([ ... [1, 1, 1], ... [0, 0, 0], ... [0, 0, 0] ... ]) 3 >>> largest_contiguous_planted_block([ ... [1, 0, 0], ... [1, 0, 0], ... [1, 0, 0] ... ]) 3","solution":"from typing import List, Tuple def largest_contiguous_planted_block(grid: List[List[int]]) -> int: def dfs(x: int, y: int) -> int: if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark the cell as visited size = 1 # explore all 4 directions (up, down, left, right) size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def minimumBreaks(n: int, m: int) -> int: Returns the minimum number of breaks required to split an n by m chocolate bar into individual chunks. Parameters: n (int): Number of rows in the chocolate bar. m (int): Number of columns in the chocolate bar. Returns: int: The minimum number of breaks required. Examples: >>> minimumBreaks(2, 3) 5 >>> minimumBreaks(1, 1) 0 >>> minimumBreaks(4, 4) 15 >>> minimumBreaks(3, 1) 2 >>> minimumBreaks(1, 5) 4","solution":"def minimumBreaks(n, m): Returns the minimum number of breaks required to split an n by m chocolate bar into individual chunks. # The minimum number of breaks required to split an n * m chocolate bar into # individual pieces is (n * m) - 1 return (n * m) - 1"},{"question":"from typing import List def sort_by_frequency(arr: List[int]) -> List[int]: Write a function that takes an array of integers as input and returns the array sorted by the frequency of the numbers in descending order. In case of a tie, numbers with the same frequency should be sorted in ascending order. >>> sort_by_frequency([3, 3, 2, 1, 2, 2, 4]) [2, 2, 2, 3, 3, 1, 4] >>> sort_by_frequency([1]) [1] >>> sort_by_frequency([4, 4, 4, 3, 3, 2]) [4, 4, 4, 3, 3, 2]","solution":"from typing import List from collections import Counter def sort_by_frequency(arr: List[int]) -> List[int]: Sort the array by frequency of elements in descending order. In case of a tie, elements are sorted by value in ascending order. # Count the frequency of each element in the array freq = Counter(arr) # Sort by frequency (in descending order) and then by number (in ascending order) sorted_arr = sorted(arr, key=lambda x: (-freq[x], x)) return sorted_arr"},{"question":"def second_smallest(lst: List[int]) -> Optional[int]: Find the second smallest unique number in a list of integers. If the list has fewer than two unique numbers, return None. >>> second_smallest([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) # 2 >>> second_smallest([1, 1, 1, 1]) # None >>> second_smallest([0, -1, 3, 100]) # 0","solution":"def second_smallest(lst): Returns the second smallest unique number in the list. If the list contains fewer than two unique numbers, returns None. unique_numbers = sorted(set(lst)) if len(unique_numbers) < 2: return None return unique_numbers[1]"},{"question":"def find_islands(grid: List[List[int]]) -> int: Counts the number of islands in the given grid where 1 represents land and 0 represents water. >>> grid1 = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 1] ... ] >>> find_islands(grid1) 3 >>> grid2 = [ ... [1, 0, 0, 1], ... [0, 0, 1, 0], ... [0, 1, 0, 0], ... [1, 0, 1, 0] ... ] >>> find_islands(grid2) 6","solution":"def find_islands(grid): Counts the number of islands in the given grid. Args: grid: List[List[int]] - a 2D list of integers where 1 represents land and 0 represents water. Returns: int - the number of separate islands. if not grid: return 0 def dfs(row, col): # Check for boundary conditions and if the cell is land if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 0: return # Mark the cell as visited by setting it to 0 grid[row][col] = 0 # Visit all adjacent directions dfs(row + 1, col) dfs(row - 1, col) dfs(row, col + 1) dfs(row, col - 1) num_islands = 0 for row in range(len(grid)): for col in range(len(grid[0])): if grid[row][col] == 1: num_islands += 1 dfs(row, col) return num_islands"},{"question":"class Library: A class to manage a collection of books and perform various operations on it. - Each book should have a title, author, publication year, and genre. - The \`Library\` class should keep track of all books. - Users should be able to add books to the library. - Users should be able to remove books from the library. - Users should be able to search books by title, author, or genre. - Users should be able to sort books by title or publication year. >>> library = Library() # Adding books >>> library.add_book({\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"publication_year\\": 1960, \\"genre\\": \\"Fiction\\"}) >>> library.add_book({\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publication_year\\": 1949, \\"genre\\": \\"Dystopian\\"}) >>> library.add_book({\\"title\\": \\"Moby-Dick\\", \\"author\\": \\"Herman Melville\\", \\"publication_year\\": 1851, \\"genre\\": \\"Adventure\\"}) >>> library.add_book({\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publication_year\\": 1949, \\"genre\\": \\"Dystopian\\"}) # This should not be added again # Searching for books >>> library.search_books(title=\\"1984\\") # Returns list containing the book \\"1984\\" >>> library.search_books(author=\\"Harper Lee\\") # Returns list containing the book \\"To Kill a Mockingbird\\" >>> library.search_books(genre=\\"Adventure\\") # Returns list containing the book \\"Moby-Dick\\" # Removing a book >>> library.remove_book(\\"1984\\", \\"George Orwell\\") # Removes the book \\"1984\\" by George Orwell >>> library.remove_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") # Returns \\"Book not found\\" # Sorting books >>> library.sort_books_by_title() # Returns books sorted by title >>> library.sort_books_by_publication_year() # Returns books sorted by publication year def __init__(self): ... def add_book(self, book): ... def remove_book(self, title, author): ... def search_books(self, title=None, author=None, genre=None): ... def sort_books_by_title(self): ... def sort_books_by_publication_year(self): ... # Unit Test def test_add_book(): library = Library() book = {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"publication_year\\": 1960, \\"genre\\": \\"Fiction\\"} library.add_book(book) assert len(library.books) == 1 assert library.books[0] == book def test_add_duplicate_book(): library = Library() book = {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publication_year\\": 1949, \\"genre\\": \\"Dystopian\\"} library.add_book(book) library.add_book(book) assert len(library.books) == 1 def test_remove_book(): library = Library() book = {\\"title\\": \\"Moby-Dick\\", \\"author\\": \\"Herman Melville\\", \\"publication_year\\": 1851, \\"genre\\": \\"Adventure\\"} library.add_book(book) library.remove_book(\\"Moby-Dick\\", \\"Herman Melville\\") assert len(library.books) == 0 def test_remove_nonexistent_book(): library = Library() result = library.remove_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") assert result == \\"Book not found\\" def test_search_books_by_title(): library = Library() book = {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publication_year\\": 1949, \\"genre\\": \\"Dystopian\\"} library.add_book(book) results = library.search_books(title=\\"1984\\") assert len(results) == 1 assert results[0] == book def test_search_books_by_author(): library = Library() book = {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"publication_year\\": 1960, \\"genre\\": \\"Fiction\\"} library.add_book(book) results = library.search_books(author=\\"Harper Lee\\") assert len(results) == 1 assert results[0] == book def test_search_books_by_genre(): library = Library() book = {\\"title\\": \\"Moby-Dick\\", \\"author\\": \\"Herman Melville\\", \\"publication_year\\": 1851, \\"genre\\": \\"Adventure\\"} library.add_book(book) results = library.search_books(genre=\\"Adventure\\") assert len(results) == 1 assert results[0] == book def test_sort_books_by_title(): library = Library() book1 = {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publication_year\\": 1949, \\"genre\\": \\"Dystopian\\"} book2 = {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"publication_year\\": 1960, \\"genre\\": \\"Fiction\\"} library.add_book(book1) library.add_book(book2) sorted_books = library.sort_books_by_title() assert sorted_books == [book1, book2] def test_sort_books_by_publication_year(): library = Library() book1 = {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publication_year\\": 1949, \\"genre\\": \\"Dystopian\\"} book2 = {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"publication_year\\": 1960, \\"genre\\": \\"Fiction\\"} library.add_book(book2) library.add_book(book1) sorted_books = library.sort_books_by_publication_year() assert sorted_books == [book1, book2]","solution":"class Library: def __init__(self): self.books = [] def add_book(self, book): for b in self.books: if b['title'] == book['title'] and b['author'] == book['author']: return self.books.append(book) def remove_book(self, title, author): for b in self.books: if b['title'] == title and b['author'] == author: self.books.remove(b) return return \\"Book not found\\" def search_books(self, title=None, author=None, genre=None): results = [] for b in self.books: if (title and b['title'] == title) or (author and b['author'] == author) or (genre and b['genre'] == genre): results.append(b) return results def sort_books_by_title(self): return sorted(self.books, key=lambda x: x['title']) def sort_books_by_publication_year(self): return sorted(self.books, key=lambda x: x['publication_year'])"},{"question":"from typing import List, Dict, Tuple def longest_path_length(T: int, test_cases: List[Dict[str, List[Tuple[int, int, int]]]]) -> List[int]: Find the length of the longest path in the kingdom. >>> T = 1 >>> test_cases = [ ... { ... \\"N\\": 5, ... \\"edges\\": [ ... (1, 2, 3), ... (1, 3, 2), ... (3, 4, 4), ... (3, 5, 6) ... ] ... } ... ] >>> longest_path_length(T, test_cases) [11] >>> T = 2 >>> test_cases = [ ... { ... \\"N\\": 5, ... \\"edges\\": [ ... (1, 2, 3), ... (1, 3, 2), ... (3, 4, 4), ... (3, 5, 6) ... ] ... }, ... { ... \\"N\\": 3, ... \\"edges\\": [ ... (1, 2, 5), ... (2, 3, 7) ... ] ... } ... ] >>> longest_path_length(T, test_cases) [11, 12]","solution":"from collections import defaultdict, deque def longest_path_length(T, test_cases): def bfs(node): visited = {node} queue = deque([(node, 0)]) farthest_node, max_distance = node, 0 while queue: current_node, current_distance = queue.popleft() for neighbor, length in adj[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_distance + length)) if current_distance + length > max_distance: max_distance = current_distance + length farthest_node = neighbor return farthest_node, max_distance results = [] for test_case in test_cases: N = test_case[\\"N\\"] edges = test_case[\\"edges\\"] adj = defaultdict(list) for u, v, l in edges: adj[u].append((v, l)) adj[v].append((u, l)) # First BFS to find the farthest node from any node (let's pick node 1) farthest_node_from_start, _ = bfs(1) # Second BFS to find the maximum distance from the farthest node found above _, longest_path = bfs(farthest_node_from_start) results.append(longest_path) return results # Test input example. T = 1 test_cases = [ { \\"N\\": 5, \\"edges\\": [ (1, 2, 3), (1, 3, 2), (3, 4, 4), (3, 5, 6) ] } ] print(longest_path_length(T, test_cases)) # Output: [11]"},{"question":"def is_back_to_origin(commands: str) -> bool: Determines if the robot returns to the origin after executing all the commands. :param commands: String of commands consisting of 'U', 'D', 'L', 'R', 'S' :return: Boolean value indicating whether the robot returns to the origin >>> is_back_to_origin('') True >>> is_back_to_origin('UD') True >>> is_back_to_origin('LR') True >>> is_back_to_origin('LL') False >>> is_back_to_origin('URDL') True >>> is_back_to_origin('SSSS') True >>> is_back_to_origin('UUDDLLRR') True >>> is_back_to_origin('UDLRU') False >>> is_back_to_origin('UURRDDLLSS') True >>> is_back_to_origin('UURDL') False","solution":"def is_back_to_origin(commands): Determines if the robot returns to the origin after executing all the commands. :param commands: String of commands consisting of 'U', 'D', 'L', 'R', 'S' :return: Boolean value indicating whether the robot returns to the origin x, y = 0, 0 # Starting point for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 # 'S' means stay, so no action needed return x == 0 and y == 0"},{"question":"def max_total_points(skills: List[int]) -> int: Calculate the maximum total points by optimally grouping employees. The maximum points are achieved by having all employees in a single group. Args: skills (list of int): List of positive integers representing the skills of each employee. Returns: int: The maximum points that can be achieved. >>> max_total_points([4, 5, 6]) 45 >>> max_total_points([1, 2, 3, 4]) 40 >>> max_total_points([6, 2, 1]) 27 >>> max_total_points([10, 20]) 60 >>> max_total_points([5]) 5 >>> max_total_points([3, 3, 3]) 27 >>> max_total_points([1000] * 500) 250000000 >>> max_total_points([1] * 500) 250000","solution":"def max_total_points(skills): Calculate the maximum total points by optimally grouping employees. The maximum points are achieved by having all employees in a single group. Args: skills (list of int): List of positive integers representing the skills of each employee. Returns: int: The maximum points that can be achieved. total_sum = sum(skills) num_employees = len(skills) return total_sum * num_employees"},{"question":"class Grid: def __init__(self, n, m): Initialize a grid of size n x m filled with zeros. def update(self, r, c, x, op): Update the element at (r, c) in the grid by adding or subtracting x based on op ('+' or '-') def query(self, r1, c1, r2, c2): Find the sum of all elements in the subgrid defined by the corners (r1, c1) and (r2, c2) inclusive. def process_queries(n, m, queries): Process a list of queries on a n x m grid. The grid is initialized with zeros. Each query updates some element in the grid or asks for the sum of elements in a rectangular subgrid. Return the results of the sum queries in a list. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. queries (List[str]): The list of queries to process. Returns: List[int]: The results of the sum queries. # Example usage of the function: n, m, q = 3, 3, 8 queries = [ \\"+ 1 1 5\\", \\"+ 2 2 10\\", \\"? 1 1 2 2\\", \\"- 1 1 2\\", \\"? 1 1 2 2\\", \\"+ 3 3 7\\", \\"? 1 1 3 3\\", \\"? 2 2 3 3\\" ] print(process_queries(n, m, queries)) # Expected Output: [15, 13, 20, 17] # Test Cases def test_process_queries(): n, m, q = 3, 3, 8 queries = [ \\"+ 1 1 5\\", \\"+ 2 2 10\\", \\"? 1 1 2 2\\", \\"- 1 1 2\\", \\"? 1 1 2 2\\", \\"+ 3 3 7\\", \\"? 1 1 3 3\\", \\"? 2 2 3 3\\" ] result = process_queries(n, m, queries) assert result == [15, 13, 20, 17] def test_process_queries_empty_grid(): n, m, q = 2, 2, 1 queries = [\\"? 1 1 2 2\\"] result = process_queries(n, m, queries) assert result == [0] def test_process_queries_single_update(): n, m, q = 1, 1, 2 queries = [ \\"+ 1 1 5\\", \\"? 1 1 1 1\\" ] result = process_queries(n, m, queries) assert result == [5] def test_process_queries_negative_update(): n, m, q = 2, 2, 4 queries = [ \\"+ 1 1 5\\", \\"- 2 2 3\\", \\"? 1 1 2 2\\" ] result = process_queries(n, m, queries) assert result == [2] # (5 + (-3) + 0 + 0 = 2)","solution":"class Grid: def __init__(self, n, m): self.n = n self.m = m self.grid = [[0] * m for _ in range(n)] def update(self, r, c, x, op): if op == '+': self.grid[r][c] += x elif op == '-': self.grid[r][c] -= x def query(self, r1, c1, r2, c2): total = 0 for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): total += self.grid[i][j] return total def process_queries(n, m, queries): grid = Grid(n, m) results = [] for query in queries: parts = query.split() if parts[0] == '+' or parts[0] == '-': r, c, x = int(parts[1]) - 1, int(parts[2]) - 1, int(parts[3]) grid.update(r, c, x, parts[0]) elif parts[0] == '?': r1, c1, r2, c2 = int(parts[1]) - 1, int(parts[2]) - 1, int(parts[3]) - 1, int(parts[4]) - 1 result = grid.query(r1, c1, r2, c2) results.append(result) return results # Example usage n, m, q = 3, 3, 8 queries = [ \\"+ 1 1 5\\", \\"+ 2 2 10\\", \\"? 1 1 2 2\\", \\"- 1 1 2\\", \\"? 1 1 2 2\\", \\"+ 3 3 7\\", \\"? 1 1 3 3\\", \\"? 2 2 3 3\\" ] print(process_queries(n, m, queries)) # Output: [15, 13, 20, 17]"},{"question":"def find_missing_number(arr): Given a sorted array of unique integers from 1 to n with one number missing, return the missing number. >>> find_missing_number([1, 2, 4, 5, 6]) == 3 >>> find_missing_number([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]) == 15","solution":"def find_missing_number(arr): Given a sorted array of unique integers from 1 to n with one number missing, returns the missing number. n = len(arr) + 1 # Calculate the expected sum of first n natural numbers total_sum = n * (n + 1) // 2 # Calculate sum of given array actual_sum = sum(arr) # Missing number is the difference between expected sum and actual sum return total_sum - actual_sum"},{"question":"def can_accommodate_teams(test_cases): Determine whether it is possible to accommodate all the teams in the given rooms without exceeding their capacities. Args: test_cases (List[Tuple[int, List[int], int, List[int]]]): List of test cases with each test case consisting of - number of rooms - list of room capacities - number of teams - list of team sizes Returns: List[str]: List of results for each test case, either \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" >>> can_accommodate_teams([(3, [5, 10, 8], 4, [2, 5, 7, 8]), (2, [3, 2], 3, [3, 4, 1])]) [\\"POSSIBLE\\", \\"IMPOSSIBLE\\"] >>> can_accommodate_teams([(2, [10, 5], 3, [3, 5, 2])]) [\\"POSSIBLE\\"] >>> can_accommodate_teams([(1, [5], 2, [6, 3])]) [\\"IMPOSSIBLE\\"] pass def parse_input(input_str): Parse the input string into test cases. Args: input_str (str): Input string containing multiple test cases information. Returns: List[Tuple[int, List[int], int, List[int]]]: Parsed list of test cases >>> parse_input(\\"2n3n5 10 8n4n2 5 7 8n2n3 2n3n3 4 1\\") [(3, [5, 10, 8], 4, [2, 5, 7, 8]), (2, [3, 2], 3, [3, 4, 1])] >>> parse_input(\\"1n2n10 5n3n3 5 2\\") [(2, [10, 5], 3, [3, 5, 2])] pass","solution":"def can_accommodate_teams(test_cases): results = [] for case in test_cases: r, rooms, k, teams = case rooms.sort(reverse=True) teams.sort(reverse=True) possible = True for team in teams: accommodated = False for i in range(r): if rooms[i] >= team: rooms[i] -= team accommodated = True break if not accommodated: possible = False break if possible: results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): r = int(lines[index]) rooms = list(map(int, lines[index + 1].split())) k = int(lines[index + 2]) teams = list(map(int, lines[index + 3].split())) test_cases.append((r, rooms, k, teams)) index += 4 return test_cases"},{"question":"def findMaxLength(arr: List[int]) -> int: Given an array of integers arr, find the length of the longest subarray which contains an equal number of 0s and 1s. >>> findMaxLength([0, 1]) 2 >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 0, 1, 0, 0, 0, 1, 1]) 6 >>> findMaxLength([1, 1, 1, 1]) 0 >>> findMaxLength([0, 0, 0, 1, 1]) 4","solution":"def findMaxLength(nums): Given a binary array nums, returns the maximum length of a contiguous subarray with an equal number of 0 and 1. count = 0 max_length = 0 count_dict = {0: -1} for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length"},{"question":"def merge_intervals(intervals): Merge overlapping intervals and return a list of merged intervals. Intervals is a list of tuples (start, end). pass def calculate_total_hours(entries): Calculate the total working hours for each employee. Entries is a dictionary with employee names as keys and list of working intervals as values. Return a dictionary with employee names as keys and total working hours as values. Examples: >>> entries = { ... \\"Alice\\": [(9, 12), (14, 17), (11, 13)], ... \\"Bob\\": [(10, 13), (13, 16)], ... \\"Charlie\\": [(9, 10), (12, 14)] ... } >>> calculate_total_hours(entries) { \\"Alice\\": 7, \\"Bob\\": 6, \\"Charlie\\": 3, } >>> entries = { ... \\"Alice\\": [(9, 12)], ... \\"Bob\\": [(10, 13), (13, 14)], ... \\"Charlie\\": [(9, 10), (12, 14), (10, 12)] ... } >>> calculate_total_hours(entries) { \\"Alice\\": 3, \\"Bob\\": 4, \\"Charlie\\": 5, } >>> entries = { ... \\"Alice\\": [], ... \\"Bob\\": [], ... } >>> calculate_total_hours(entries) { \\"Alice\\": 0, \\"Bob\\": 0, } >>> entries = { ... \\"Daisy\\": [(8, 10), (12, 14), (13, 16), (15, 18)], ... } >>> calculate_total_hours(entries) { \\"Daisy\\": 8, } pass","solution":"def merge_intervals(intervals): Merge overlapping intervals and return a list of merged intervals. Intervals is a list of tuples (start, end). if not intervals: return [] # Sort intervals by start time intervals.sort() merged = [intervals[0]] for current in intervals[1:]: # If the current interval overlaps with the previous one, merge them last = merged[-1] if current[0] <= last[1]: # Overlap condition merged[-1] = (last[0], max(last[1], current[1])) else: merged.append(current) return merged def calculate_total_hours(entries): Calculate the total working hours for each employee. Entries is a dictionary with employee names as keys and list of working intervals as values. Return a dictionary with employee names as keys and total working hours as values. total_hours = {} for employee, intervals in entries.items(): # Merge overlapping intervals merged_intervals = merge_intervals(intervals) # Calculate total hours from merged intervals total_worked_hours = sum(end - start for start, end in merged_intervals) total_hours[employee] = total_worked_hours return total_hours"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns an array such that each element is the product of all the elements in the original array except the one at the current index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24]","solution":"def product_except_self(nums): Returns an array such that each element is the product of all the elements in the original array except the one at the current index. n = len(nums) if n <= 1: raise ValueError(\\"Array length must be at least 2\\") # Create two arrays to store the prefix and suffix products prefix_products = [1] * n suffix_products = [1] * n # Calculate the prefix products for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * nums[i - 1] # Calculate the suffix products for i in range(n - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * nums[i + 1] # Calculate the result by multiplying the prefix and suffix products result = [prefix_products[i] * suffix_products[i] for i in range(n)] return result"},{"question":"def reverse_words(s: str) -> str: Reverse the order of words in the sentence while preserving the whitespace and initial word positions. Parameters: s (str): The input string sentence. Returns: str: The sentence with the order of words reversed. >>> reverse_words(\\"the day is bright\\") \\"bright is day the\\" >>> reverse_words(\\" the day is bright \\") \\" bright is day the \\" >>> reverse_words(\\"the day is bright\\") \\"bright is day the\\" >>> reverse_words(\\" \\") \\" \\" >>> reverse_words(\\"bright\\") \\"bright\\" >>> reverse_words(\\" My Name is Alice \\") \\" Alice is Name My \\"","solution":"def reverse_words(s): Reverse the order of words in the sentence while preserving the whitespace and initial word positions. Parameters: s (str): The input string sentence. Returns: str: The sentence with the order of words reversed. # Split the string by spaces to get all the segments including empty ones segments = s.split(' ') # Filter out the empty segments to get the words words = [segment for segment in segments if segment] # Reverse the list of words words.reverse() # Initialize variables result = [] word_index = 0 # Reconstruct the sentence with reversed words and original spaces for segment in segments: if segment == '': result.append('') else: result.append(words[word_index]) word_index += 1 return ' '.join(result)"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of a subarray with at least one element. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([-2, -3, -1, -4]) -1 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([1, 2, -1, 2, -3, 4, -5, 4]) 5 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(nums): Returns the maximum sum of a subarray with at least one element. Parameters: nums (list): List of integers Returns: int: The maximum subarray sum if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def rotate_image(matrix: List[List[int]]) -> None: Rotates the given n x n matrix 90 degrees clockwise in-place. :param matrix: List[List[int]] - 2D list representing the image to be rotated :return: None >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate_image(matrix) >>> matrix [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] from typing import List","solution":"def rotate_image(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. :param matrix: List[List[int]] - 2D list representing the image to be rotated :return: None n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def sort_string(s: str) -> str: You are given a string as input that contains a mix of letters and digits. Your task is to sort the string such that all the digits come before the letters while preserving the relative order of the digits and letters in the original string. Examples: >>> sort_string('a1b2c3') '123abc' >>> sort_string('ab12cd34') '1234abcd' >>> sort_string('3a1b2c') '312abc'","solution":"def sort_string(s): This function takes a string with a mix of letters and digits. It returns a new string with all the digits coming before the letters, while preserving the relative order of the digits and letters in the original string. digits = [] letters = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(digits) + ''.join(letters)"},{"question":"def count_distinct_vowels(s: str) -> int: Returns the number of distinct vowels present in the string s. >>> count_distinct_vowels(\\"Hello World\\") == 2 >>> count_distinct_vowels(\\"aeiou\\") == 5 >>> count_distinct_vowels(\\"bcdfgh\\") == 0 >>> count_distinct_vowels(\\"\\") == 0","solution":"def count_distinct_vowels(s): Returns the number of distinct vowels in the string s. vowels = {'a', 'e', 'i', 'o', 'u'} found_vowels = set() for char in s.lower(): if char in vowels: found_vowels.add(char) return len(found_vowels)"},{"question":"def rearrange_list(nums: List[int], k: int) -> List[int]: Given a list of integers nums, and an integer k, rearrange the elements in the list such that every adjacent pair of elements has an absolute difference less than or equal to k. If it is possible to rearrange the list in such a way, return the modified list. If it is not possible, return an empty list. >>> rearrange_list([3, 1, 4, 2], 2) [1, 3, 2, 4] >>> rearrange_list([1, 5, 9], 3) [] >>> rearrange_list([10, 20, 30, 40], 15) [10, 20, 30, 40] >>> rearrange_list([1], 1) [1] >>> rearrange_list([-1, -2, -3, -4], 1) [-4, -3, -2, -1] >>> rearrange_list([1, 10000, -10000], 20000) [-10000, 1, 10000] >>> rearrange_list([5, 5, 5, 5], 0) [5, 5, 5, 5] >>> rearrange_list(list(range(1000, -1001, -1)), 1) list(range(-1000, 1001, 1))","solution":"def rearrange_list(nums, k): nums.sort() n = len(nums) for i in range(1, n): if abs(nums[i] - nums[i-1]) > k: return [] return nums"},{"question":"class ParkingLot: def __init__(self, capacity: int): Initialize the parking lot with a specified number of slots. pass def arrive(self, car_id: int) -> bool: Register the arrival of a car. If there's an available slot, park the car and return True. If the parking lot is full, return False. >>> parking_lot = ParkingLot(2) >>> parking_lot.arrive(101) True >>> parking_lot.arrive(102) True >>> parking_lot.arrive(103) False pass def depart(self, car_id: int) -> bool: Register the departure of a car. If the car is in the parking lot, free the slot and return True. If the car is not found, return False. >>> parking_lot = ParkingLot(2) >>> parking_lot.arrive(101) True >>> parking_lot.depart(101) True >>> parking_lot.depart(103) False pass def get_occupancy(self) -> int: Return the current number of occupied slots. >>> parking_lot = ParkingLot(2) >>> parking_lot.arrive(101) True >>> parking_lot.arrive(102) True >>> parking_lot.get_occupancy() 2 >>> parking_lot.depart(101) True >>> parking_lot.get_occupancy() 1 pass def get_parked_cars(self) -> list: Return a list of car IDs currently parked in the lot. >>> parking_lot = ParkingLot(2) >>> parking_lot.arrive(101) True >>> parking_lot.arrive(102) True >>> parking_lot.get_parked_cars() [101, 102] >>> parking_lot.depart(101) True >>> parking_lot.get_parked_cars() [102] pass # Unit tests def test_parking_lot_operations(): parking_lot = ParkingLot(2) assert parking_lot.arrive(101) == True assert parking_lot.arrive(102) == True assert parking_lot.arrive(103) == False # Parking lot is full assert parking_lot.get_occupancy() == 2 assert parking_lot.depart(101) == True assert parking_lot.depart(103) == False # Car 103 was never parked assert set(parking_lot.get_parked_cars()) == {102} assert parking_lot.arrive(104) == True assert set(parking_lot.get_parked_cars()) == {102, 104} assert parking_lot.get_occupancy() == 2 def test_parking_lot_extended_operations(): parking_lot = ParkingLot(3) assert parking_lot.arrive(201) == True assert parking_lot.arrive(202) == True assert parking_lot.arrive(203) == True assert parking_lot.arrive(204) == False # Parking lot is full assert set(parking_lot.get_parked_cars()) == {201, 202, 203} assert parking_lot.depart(202) == True assert parking_lot.arrive(204) == True assert set(parking_lot.get_parked_cars()) == {201, 203, 204} assert parking_lot.get_occupancy() == 3 def test_parking_lot_capacity_zero(): parking_lot = ParkingLot(0) assert parking_lot.arrive(301) == False assert parking_lot.get_occupancy() == 0 assert parking_lot.get_parked_cars() == [] assert parking_lot.depart(301) == False def test_parking_lot_depart_nonexistent_car(): parking_lot = ParkingLot(1) assert parking_lot.get_occupancy() == 0 assert parking_lot.depart(401) == False","solution":"class ParkingLot: def __init__(self, capacity: int): Initialize the parking lot with a maximum number of slots. self.capacity = capacity self.occupied_slots = 0 self.parked_cars = set() def arrive(self, car_id: int) -> bool: Register the arrival of a car. If there's an available slot, park the car and return True. If the parking lot is full, return False. if self.occupied_slots < self.capacity: self.parked_cars.add(car_id) self.occupied_slots += 1 return True return False def depart(self, car_id: int) -> bool: Register the departure of a car. If the car is in the parking lot, free the slot and return True. If the car is not found, return False. if car_id in self.parked_cars: self.parked_cars.remove(car_id) self.occupied_slots -= 1 return True return False def get_occupancy(self) -> int: Return the current number of occupied slots. return self.occupied_slots def get_parked_cars(self) -> list: Return a list of car IDs currently parked in the lot. return list(self.parked_cars)"},{"question":"from typing import List, Dict, Union def find_youngest(people: List[Dict[str, Union[str, int]]]) -> Union[str, List[str]]: Find the name of the youngest person in the list. If there are multiple people with the same youngest age, return all their names in a list. >>> find_youngest([ ... {\\"name\\": \\"Alice\\", \\"age\\": 25}, ... {\\"name\\": \\"Bob\\", \\"age\\": 23}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 30} ... ]) 'Bob' >>> find_youngest([ ... {\\"name\\": \\"Alice\\", \\"age\\": 25}, ... {\\"name\\": \\"Bob\\", \\"age\\": 23}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 23} ... ]) ['Bob', 'Charlie'] pass","solution":"from typing import List, Dict, Union def find_youngest(people: List[Dict[str, Union[str, int]]]) -> Union[str, List[str]]: if not people: return \\"\\" # Find the minimum age min_age = min(person['age'] for person in people) # Find all people with the minimum age youngest_people = [person['name'] for person in people if person['age'] == min_age] if len(youngest_people) == 1: return youngest_people[0] return youngest_people"},{"question":"def squared_numbers_matrix(n): Generates a square matrix of size 'n' where each element is the square of the difference between its row and column indices. If n is less than or equal to 0, returns an empty list. >>> squared_numbers_matrix(3) [[0, 1, 4], [1, 0, 1], [4, 1, 0]] >>> squared_numbers_matrix(4) [[0, 1, 4, 9], [1, 0, 1, 4], [4, 1, 0, 1], [9, 4, 1, 0]] >>> squared_numbers_matrix(0) [] >>> squared_numbers_matrix(-3) [] >>> squared_numbers_matrix(1) [[0]] >>> squared_numbers_matrix(2) [[0, 1], [1, 0]]","solution":"def squared_numbers_matrix(n): Generates a square matrix of size 'n' where each element is the square of the difference between its row and column indices. If n is less than or equal to 0, returns an empty list. if n <= 0: return [] return [[(i - j) ** 2 for j in range(n)] for i in range(n)]"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a new list where each element is the product of all the elements in the original list except the one at the current index. The function does not use division and has a time complexity of O(n). >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([42]) == [1] >>> product_except_self([3, 7]) == [7, 3] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([0, 4, 2, 0]) == [0, 0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] >>> product_except_self([0, 0, 0, 0]) == [0, 0, 0, 0] >>> product_except_self([0, 1, 2, 3, 0]) == [0, 0, 0, 0, 0] >>> product_except_self([]) == [] >>> product_except_self([1, 2, 3, 1]) == [6, 3, 2, 6]","solution":"def product_except_self(nums): Given a list of integers, returns a new list where each element is the product of all the elements in the original list except the one at the current index. The function does not use division and has a time complexity of O(n). n = len(nums) if n == 0: return [] # Initialize the output array with 1s output = [1] * n # Calculate the prefix products prefix = 1 for i in range(n): output[i] = prefix prefix *= nums[i] # Calculate the suffix products and multiply with the prefix products suffix = 1 for i in range(n - 1, -1, -1): output[i] *= suffix suffix *= nums[i] return output"},{"question":"def product_except_self(nums): Given an array nums, returns an array where each element at index i of the new array is the product of all the numbers in the original array except the one at i. Example: >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) [2, 3, 6]","solution":"def product_except_self(nums): Given an array nums, returns an array where each element at index i of the new array is the product of all the numbers in the original array except the one at i. length = len(nums) # Initialize arrays to hold the products from the left and right left_products = [1] * length right_products = [1] * length result = [1] * length # Calculate left products for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate the result for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def max_circle_radius(N: int, sides: List[int]) -> List[float]: Given N indicates number of test cases followed by a list sides which contains the side lengths of the square plots. This function returns the maximum radius of the circular flower bed for each square plot side. >>> max_circle_radius(3, [4, 7, 15]) [2.0, 3.5, 7.5] >>> max_circle_radius(1, [8]) [4.0] >>> max_circle_radius(1, [1]) [0.5] >>> max_circle_radius(1, [1000000000]) [500000000.0] >>> max_circle_radius(4, [2, 5, 9, 100]) [1.0, 2.5, 4.5, 50.0]","solution":"def max_circle_radius(N, sides): Given N indicates number of test cases followed by a list sides which contains the side lengths of the square plots. This function returns the maximum radius of the circular flower bed for each square plot side. radii = [] for S in sides: # The maximum radius of the circle to fit within the square plot is half the side length of the square radius = S / 2.0 radii.append(radius) return radii"},{"question":"class TextEditor: A simple text editor that supports typing, deleting, and undoing actions. Methods: - type_event(text): Takes a string \`text\` which represents the characters to be typed into the editor. - delete_event(count): Takes an integer \`count\`, representing the number of characters to be removed from the end of the current content. - undo_event(): Reverts the most recent change made by either \`type_event\` or \`delete_event\`. Example: >>> editor = TextEditor() >>> editor.type_event(\\"Hello\\") >>> editor.content 'Hello' >>> editor.type_event(\\" World\\") >>> editor.content 'Hello World' >>> editor.delete_event(5) >>> editor.content 'Hello' >>> editor.undo_event() >>> editor.content 'Hello World' >>> editor.undo_event() >>> editor.content 'Hello' >>> editor.undo_event() >>> editor.content '' # All changes have been undone. def __init__(self): Initialize the TextEditor with empty content and history. pass def type_event(self, text): Appends the given text to the editor content. pass def delete_event(self, count): Deletes the last \`count\` characters from the editor content. pass def undo_event(self): Reverts the editor content back to the state before the last event. pass # Unit Tests def test_initial_state(): editor = TextEditor() assert editor.content == \\"\\" def test_type_event(): editor = TextEditor() editor.type_event(\\"Hello\\") assert editor.content == \\"Hello\\" def test_type_event_multiple_times(): editor = TextEditor() editor.type_event(\\"Hello\\") editor.type_event(\\" World\\") assert editor.content == \\"Hello World\\" def test_delete_event(): editor = TextEditor() editor.type_event(\\"Hello\\") editor.delete_event(2) assert editor.content == \\"Hel\\" def test_delete_event_more_than_length(): editor = TextEditor() editor.type_event(\\"Hello\\") editor.delete_event(10) assert editor.content == \\"\\" def test_undo_event_after_type(): editor = TextEditor() editor.type_event(\\"Hello\\") editor.type_event(\\" World\\") editor.undo_event() assert editor.content == \\"Hello\\" def test_undo_event_after_delete(): editor = TextEditor() editor.type_event(\\"Hello\\") editor.delete_event(3) editor.undo_event() assert editor.content == \\"Hello\\" def test_undo_event_multiple_times(): editor = TextEditor() editor.type_event(\\"Hello\\") editor.type_event(\\" World\\") editor.delete_event(5) editor.undo_event() assert editor.content == \\"Hello World\\" editor.undo_event() assert editor.content == \\"Hello\\" editor.undo_event() assert editor.content == \\"\\" def test_undo_event_edge_case(): editor = TextEditor() editor.undo_event() assert editor.content == \\"\\" editor.type_event(\\"Hi\\") editor.undo_event() editor.undo_event() assert editor.content == \\"\\"","solution":"class TextEditor: def __init__(self): Initialize the TextEditor with empty content and history. self.content = \\"\\" self.history = [] def type_event(self, text): Appends the given text to the editor content. self.history.append(self.content) self.content += text def delete_event(self, count): Deletes the last \`count\` characters from the editor content. self.history.append(self.content) self.content = self.content[:-count] if count <= len(self.content) else \\"\\" def undo_event(self): Reverts the editor content back to the state before the last event. if self.history: self.content = self.history.pop()"},{"question":"def reverse_words(s: str) -> str: Reverses the characters of every word in the input string s. Parameters: s (str): The input string containing words separated by a single space. Returns: str: The modified string with each word's characters reversed, while preserving the original order of the words.","solution":"def reverse_words(s): Reverses the characters of every word in the input string s. Parameters: s (str): The input string containing words separated by a single space. Returns: str: The modified string with each word's characters reversed, while preserving the original order of the words. return ' '.join(word[::-1] for word in s.split())"},{"question":"from typing import List, Tuple def max_power(n: int, m: int, power_levels: List[int], edges: List[Tuple[int,int]]) -> int: Calculate the maximum total power that can be absorbed along any paths in the Mystic Forest. :param n: Number of trees :param m: Number of paths :param power_levels: List of power levels of the n trees :param edges: List of tuples representing the directed paths :return: Maximum magical power obtainable along any path >>> max_power(5, 6, [10, 20, 30, 40, 50], [(1, 2), (2, 3), (2, 4), (3, 5), (4, 5), (1, 3)]) 120 >>> max_power(1, 0, [100], []) 100 >>> max_power(3, 2, [10, 20, 30], [(1, 2), (2, 3)]) 60 >>> max_power(4, 4, [10, 20, 10, 40], [(1, 2), (1, 3), (2, 4), (3, 4)]) 70 >>> max_power(3, 0, [10, 20, 30], []) 30","solution":"from collections import defaultdict, deque def max_power(n, m, power_levels, edges): graph = defaultdict(list) in_degree = [0] * n # Build the graph for u, v in edges: graph[u - 1].append(v - 1) in_degree[v - 1] += 1 # Topological Sort using Kahn's Algorithm topo_order = [] zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Dynamic Programming to find the maximum path weight max_power_path = [0] * n for node in topo_order: max_power_path[node] = max(max_power_path[node], power_levels[node]) for neighbor in graph[node]: max_power_path[neighbor] = max(max_power_path[neighbor], max_power_path[node] + power_levels[neighbor]) return max(max_power_path)"},{"question":"def group_by_length(strings): Groups strings by their lengths into a dictionary. Parameters: strings (list): List of strings. Returns: dict: Dictionary with keys as lengths and values as lists of strings of that length. >>> group_by_length([\\"apple\\", \\"bat\\", \\"car\\", \\"dog\\", \\"elephant\\", \\"fox\\", \\"goat\\"]) == { 3: [\\"bat\\", \\"car\\", \\"dog\\", \\"fox\\"], 4: [\\"goat\\"], 5: [\\"apple\\"], 8: [\\"elephant\\"] } >>> group_by_length([]) == {} >>> group_by_length([\\"single\\"]) == {6: [\\"single\\"]} >>> group_by_length([\\"a\\", \\"b\\", \\"c\\", \\"abc\\", \\"xyz\\"]) == { 1: [\\"a\\", \\"b\\", \\"c\\"], 3: [\\"abc\\", \\"xyz\\"] } >>> group_by_length([\\"a\\", \\"to\\", \\"bat\\", \\"go\\", \\"listen\\", \\"apple\\"]) == { 1: [\\"a\\"], 2: [\\"to\\", \\"go\\"], 3: [\\"bat\\"], 5: [\\"apple\\"], 6: [\\"listen\\"] }","solution":"def group_by_length(strings): Groups strings by their lengths into a dictionary. Parameters: strings (list): List of strings. Returns: dict: Dictionary with keys as lengths and values as lists of strings of that length. length_dict = {} for string in strings: length = len(string) if length not in length_dict: length_dict[length] = [] length_dict[length].append(string) return length_dict"},{"question":"class FlightBooking: FlightBooking system to manage passengers. - add_passenger(flight_number: str, passenger_name: str): Adds a passenger to the flight. If the passenger is already added to the flight, do nothing. - remove_passenger(flight_number: str, passenger_name: str): Removes a passenger from the flight. If the passenger is not found in the flight, do nothing. - list_passengers(flight_number: str): Returns a list of names of passengers on the specified flight. If the flight has no passengers, return an empty list. Example: >>> booking_system = FlightBooking() >>> booking_system.add_passenger('AA123', 'John Doe') >>> booking_system.add_passenger('AA123', 'Jane Doe') >>> booking_system.list_passengers('AA123') ['John Doe', 'Jane Doe'] >>> booking_system.remove_passenger('AA123', 'John Doe') >>> booking_system.list_passengers('AA123') ['Jane Doe']","solution":"class FlightBooking: def __init__(self): self.flights = {} def add_passenger(self, flight_number: str, passenger_name: str): if flight_number not in self.flights: self.flights[flight_number] = set() self.flights[flight_number].add(passenger_name) def remove_passenger(self, flight_number: str, passenger_name: str): if flight_number in self.flights: self.flights[flight_number].discard(passenger_name) def list_passengers(self, flight_number: str): if flight_number in self.flights: return list(self.flights[flight_number]) return []"},{"question":"def reorder_by_frequency(nums: List[int]) -> List[int]: Reorder the array such that all occurrences of the most frequent element come first, followed by occurrences of the second most frequent element, and so on. The order of the elements within the same frequency should remain the same as the original order. >>> reorder_by_frequency([2, 3, 1, 3, 2, 4, 1, 2]) [2, 2, 2, 3, 3, 1, 1, 4] >>> reorder_by_frequency([5, 5, 2, 4, 3, 2, 3, 5]) [5, 5, 5, 2, 2, 3, 3, 4] >>> reorder_by_frequency([7, 7, 8, 8, 8, 9]) [8, 8, 8, 7, 7, 9] >>> reorder_by_frequency([1]) [1] >>> reorder_by_frequency([3, 1, 2, 4]) [3, 1, 2, 4] >>> reorder_by_frequency([1, 2, 3, 2, 1, 3, 1]) [1, 1, 1, 2, 2, 3, 3] >>> reorder_by_frequency([]) []","solution":"def reorder_by_frequency(nums): Reorder the array such that all occurrences of the most frequent element come first, followed by occurrences of the second most frequent element, and so on. The order of the elements within the same frequency should remain the same as the original order. from collections import Counter # Step 1: Count the frequency of each number freq_count = Counter(nums) # Step 2: Sort numbers by frequency (descending) and then by their first occurrence (ascending) sorted_nums = sorted(nums, key=lambda x: (-freq_count[x], nums.index(x))) return sorted_nums"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of character insertions required to make the string s a palindrome. >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"abc\\") 2 >>> min_insertions_to_palindrome(\\"a\\") 0 def test_min_insertions_to_palindrome(): assert min_insertions_to_palindrome(\\"race\\") == 3 assert min_insertions_to_palindrome(\\"abc\\") == 2 assert min_insertions_to_palindrome(\\"a\\") == 0 assert min_insertions_to_palindrome(\\"ab\\") == 1 assert min_insertions_to_palindrome(\\"aa\\") == 0 assert min_insertions_to_palindrome(\\"abcd\\") == 3 assert min_insertions_to_palindrome(\\"aaabbb\\") == 3 assert min_insertions_to_palindrome(\\"aaaa\\") == 0 assert min_insertions_to_palindrome(\\"abcba\\") == 0 assert min_insertions_to_palindrome(\\"abcdefgh\\") == 7 # To run the tests, you can use: # if __name__ == \\"__main__\\": # test_min_insertions_to_palindrome()","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of insertions required to make the string s a palindrome. n = len(s) # Create a DP table to store results of subproblems dp = [[0 for i in range(n)] for j in range(n)] # Fill the table for gap in range(1, n): for l in range(n - gap): h = l + gap if s[l] == s[h]: dp[l][h] = dp[l + 1][h - 1] else: dp[l][h] = min(dp[l][h - 1], dp[l + 1][h]) + 1 # dp[0][n-1] contains the minimum number of insertions for s[0..n-1] return dp[0][n-1]"},{"question":"def move_zeroes(nums: List[int]) -> None: Moves all zeroes to the end of the list while preserving the order of the other elements. The function modifies the list in place and returns nothing. :param nums: List of integers >>> nums = [0, 1, 0, 3, 12] >>> move_zeroes(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [1, 2, 3, 4, 5] >>> move_zeroes(nums) >>> nums [1, 2, 3, 4, 5] >>> nums = [0, 0, 0, 0, 0] >>> move_zeroes(nums) >>> nums [0, 0, 0, 0, 0] >>> nums = [1, 3, 5, 0, 0] >>> move_zeroes(nums) >>> nums [1, 3, 5, 0, 0] >>> nums = [0, 0, 1, 2, 3, 0, 4] >>> move_zeroes(nums) >>> nums [1, 2, 3, 4, 0, 0, 0]","solution":"def move_zeroes(nums): Moves all zeroes to the end of the list while preserving the order of other elements. The function modifies the list in place and returns nothing. :param nums: List of integers last_non_zero_index = 0 for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_index] = nums[i] last_non_zero_index += 1 for i in range(last_non_zero_index, len(nums)): nums[i] = 0"},{"question":"import re from typing import List from collections import defaultdict def most_frequent_word(s: str, banned: List[str]) -> str: Find the most frequent word in the string that is not in the banned list. Words are compared in a case-insensitive manner. If there is a tie, return the lexicographically smallest word. Args: s (str): The input string containing the text. banned (List[str]): List of words to be ignored. Returns: str: The most frequent non-banned word. Examples: >>> s = \\"Jack and Jill went up the hill, to fetch a pail of water. Jack fell down and broke his crown, and Jill came tumbling after.\\" >>> banned = [\\"and\\", \\"the\\", \\"to\\", \\"a\\", \\"of\\"] >>> most_frequent_word(s, banned) \\"jack\\" >>> s = \\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness.\\" >>> banned = [\\"it\\", \\"was\\", \\"the\\", \\"of\\"] >>> most_frequent_word(s, banned) \\"age\\" >>> s = \\"The quick brown fox jumps over the lazy dog.\\" >>> banned = [\\"the\\"] >>> most_frequent_word(s, banned) \\"brown\\"","solution":"import re from collections import defaultdict from typing import List def most_frequent_word(s: str, banned: List[str]) -> str: # Normalize the string to lower case and remove punctuation s = s.lower() words = re.findall(r'bw+b', s) # Create a set of banned words for quicker lookup banned_set = set(banned) # Dictionary to keep count of non-banned words word_count = defaultdict(int) # Count frequency of each word that is not banned for word in words: if word not in banned_set: word_count[word] += 1 # Find the most frequent word (lexicographically smallest in case of a tie) most_frequent = '' highest_count = 0 for word, count in word_count.items(): if count > highest_count or (count == highest_count and word < most_frequent): most_frequent = word highest_count = count return most_frequent"},{"question":"def max_sequence_length(N: int, M: int, cards: List[int]) -> int: Returns the length of the longest sequence of consecutive card values that can be formed from the given hand. >>> max_sequence_length(10, 6, [1, 3, 5, 4, 2, 6]) 6 >>> max_sequence_length(15, 5, [1, 5, 9, 3, 12]) 1 >>> max_sequence_length(20, 4, [10, 11, 13, 14]) 2 >>> max_sequence_length(10, 0, []) 0 >>> max_sequence_length(10, 1, [5]) 1 >>> max_sequence_length(10, 6, [1, 1, 2, 2, 3, 3]) 3 >>> max_sequence_length(10, 4, [6, 7, 8, 9]) 4 >>> max_sequence_length(10, 3, [2, 5, 8]) 1 >>> max_sequence_length(10, 4, [1, 2, 8, 9]) 2 >>> max_sequence_length(15, 7, [1, 2, 3, 10, 11, 12, 15]) 3 pass","solution":"def max_sequence_length(N, M, cards): Returns the length of the longest sequence of consecutive card values that can be formed from the given hand. if M == 0: return 0 cards = sorted(set(cards)) # Remove duplicates and sort the cards max_len = 1 current_len = 1 for i in range(1, len(cards)): if cards[i] == cards[i - 1] + 1: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) # Update max_len for the last sequence return max_len"},{"question":"def remove_duplicates(lst): Takes a list of integers and returns a new list with all duplicate numbers removed, preserving the order of the original list. If the input is not a list or contains non-integer elements, return 'Invalid input!'. >>> remove_duplicates([1, 2, 3, 2, 1, 4]) [1, 2, 3, 4] >>> remove_duplicates([1, 1, 1, 1, 1, 1]) [1] >>> remove_duplicates([5, 10, 5, 5, 7]) [5, 10, 7] >>> remove_duplicates([]) [] >>> remove_duplicates('not a list') 'Invalid input!' >>> remove_duplicates([1, 2, 3, 'a']) 'Invalid input!' >>> remove_duplicates(['a', 'b', 'c']) 'Invalid input!' >>> remove_duplicates(1234) 'Invalid input!' >>> remove_duplicates([1, 2, 3, 4.5]) 'Invalid input!' >>> remove_duplicates([1, 'a', 2]) 'Invalid input!' >>> remove_duplicates(['a', 1, 2]) 'Invalid input!'","solution":"def remove_duplicates(lst): Takes a list of integers and returns a new list with all duplicate numbers removed, preserving the order of the original list. If the input is not a list or contains non-integer elements, return 'Invalid input!'. if not isinstance(lst, list): return 'Invalid input!' if any(not isinstance(x, int) for x in lst): return 'Invalid input!' seen = set() result = [] for num in lst: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"import re from typing import List def convert_snake_to_camel(snake_str: str) -> str: Converts a snake_case string to camelCase string. >>> convert_snake_to_camel(\\"create_user\\") \\"createUser\\" >>> convert_snake_to_camel(\\"get_user_details\\") \\"getUserDetails\\" >>> convert_snake_to_camel(\\"update\\") \\"update\\" >>> convert_snake_to_camel(\\"save_user_data_locally\\") \\"saveUserDataLocally\\" def refactor_script(script_lines: List[str]) -> List[str]: Refactors the given list of script lines by converting all method invocations to camelCase. >>> script = [ \\"def create_user():\\", \\" pass\\", \\"\\", \\"def get_user_details():\\", \\" pass\\", \\"\\", \\"user = create_user()\\", \\"user_details = get_user_details()\\" ] >>> refactor_script(script) [ \\"def createUser():\\", \\" pass\\", \\"\\", \\"def getUserDetails():\\", \\" pass\\", \\"\\", \\"user = createUser()\\", \\"user_details = getUserDetails()\\" ] def refactor_scripts(test_cases: List[List[str]]) -> List[str]: Applies refactor_script to each test case provided. >>> test_cases = [ [ \\"def create_user():\\", \\" pass\\", \\"def get_user_details():\\", \\" pass\\", \\"user = create_user()\\", \\"user_details = get_user_details()\\" ], [ \\"def update_records():\\", \\" pass\\", \\"def get_all_records():\\", \\" pass\\", \\"update_records()\\", \\"all_records = get_all_records()\\" ] ] >>> refactor_scripts(test_cases) [ \\"def createUser():n passndef getUserDetails():n passnuser = createUser()nuser_details = getUserDetails()\\", \\"def updateRecords():n passndef getAllRecords():n passnupdateRecords()nall_records = getAllRecords()\\" ] def test_convert_snake_to_camel(): assert convert_snake_to_camel(\\"create_user\\") == \\"createUser\\" assert convert_snake_to_camel(\\"get_user_details\\") == \\"getUserDetails\\" assert convert_snake_to_camel(\\"update\\") == \\"update\\" assert convert_snake_to_camel(\\"save_user_data_locally\\") == \\"saveUserDataLocally\\" def test_refactor_script(): script = [ \\"def create_user():\\", \\" pass\\", \\"\\", \\"def get_user_details():\\", \\" pass\\", \\"\\", \\"user = create_user()\\", \\"user_details = get_user_details()\\" ] expected = [ \\"def createUser():\\", \\" pass\\", \\"\\", \\"def getUserDetails():\\", \\" pass\\", \\"\\", \\"user = createUser()\\", \\"user_details = getUserDetails()\\" ] assert refactor_script(script) == expected def test_refactor_scripts(): test_cases = [ [ \\"def create_user():\\", \\" pass\\", \\"def get_user_details():\\", \\" pass\\", \\"user = create_user()\\", \\"user_details = get_user_details()\\" ], [ \\"def update_records():\\", \\" pass\\", \\"def get_all_records():\\", \\" pass\\", \\"update_records()\\", \\"all_records = get_all_records()\\" ] ] expected_output = [ \\"def createUser():n passndef getUserDetails():n passnuser = createUser()nuser_details = getUserDetails()\\", \\"def updateRecords():n passndef getAllRecords():n passnupdateRecords()nall_records = getAllRecords()\\" ] assert refactor_scripts(test_cases) == expected_output test_convert_snake_to_camel() test_refactor_script() test_refactor_scripts()","solution":"import re def convert_snake_to_camel(snake_str): Converts a snake_case string to camelCase string. parts = snake_str.split('_') camel_str = parts[0] + ''.join(word.capitalize() for word in parts[1:]) return camel_str def refactor_script(script_lines): Refactors the given list of script lines by converting all method invocations to camelCase. method_pattern = re.compile(r'bdefs+(w+)|b(w+)s*(') def replacer(match): method_name = match.group(1) or match.group(2) return match.group(0).replace(method_name, convert_snake_to_camel(method_name)) refactored_lines = [] for line in script_lines: refactored_line = method_pattern.sub(replacer, line) refactored_lines.append(refactored_line) return refactored_lines def refactor_scripts(test_cases): Applies refactor_script to each test case provided. results = [] for script_lines in test_cases: results.append('n'.join(refactor_script(script_lines))) return results"},{"question":"def find_longest_consecutive_sequence(arr: List[int], t: int) -> int: Finds the length of the longest consecutive sequence of a given target integer \`t\` in the array \`arr\`. >>> find_longest_consecutive_sequence([1, 1, 2, 2, 2, 3, 3], 2) 3 >>> find_longest_consecutive_sequence([1, 2, 2, 3, 3, 3, 3, 3], 3) 5 >>> find_longest_consecutive_sequence([4, 4, 4, 5, 4, 4, 4], 4) 3 >>> find_longest_consecutive_sequence([7, 8, 8, 8, 7, 8, 9], 8) 3","solution":"def find_longest_consecutive_sequence(arr, t): Finds the length of the longest consecutive sequence of a given target integer \`t\` in the array \`arr\`. max_count = 0 current_count = 0 for num in arr: if num == t: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 return max_count"},{"question":"from datetime import datetime, timedelta def adjust_segments(input_text: str) -> str: Adjusts the segments for a virtual event so that no two segments overlap and every segment retains the maximum possible length by adjusting the start and end times. >>> adjust_segments(\\"3njohn 10:00 11:00njane 10:30 11:30ndoe 11:00 12:00\\") \\"john 10:00 11:00njane 11:00 12:00ndoe 12:00 13:00\\" >>> adjust_segments(\\"2nalice 09:00 10:00nbob 09:30 10:30\\") \\"alice 09:00 10:00nbob 10:00 11:00\\" >>> adjust_segments(\\"4nanna 08:00 09:00ndanny 08:30 09:30neve 09:00 10:00nbob 10:00 11:00\\") \\"anna 08:00 09:00ndanny 09:00 10:00neve 10:00 11:00nbob 11:00 12:00\\" >>> adjust_segments(\\"3nmax 13:00 14:00njohn 13:30 14:30ndoe 14:00 15:00\\") \\"max 13:00 14:00njohn 14:00 15:00ndoe 15:00 16:00\\" >>> adjust_segments(\\"1nalice 07:00 08:00\\") \\"alice 07:00 08:00\\"","solution":"from datetime import datetime, timedelta def adjust_segments(segments): # Convert time to datetime objects for easier manipulation time_format = \\"%H:%M\\" for segment in segments: segment[\\"start\\"] = datetime.strptime(segment[\\"start\\"], time_format) segment[\\"end\\"] = datetime.strptime(segment[\\"end\\"], time_format) # Sort the segments by their original start times, breaking ties alphabetically by name segments.sort(key=lambda x: (x[\\"start\\"], x[\\"name\\"])) adjusted_segments = [] last_end_time = None for segment in segments: if last_end_time is None: adjusted_segments.append(segment) last_end_time = segment[\\"end\\"] else: if segment[\\"start\\"] < last_end_time: diff = last_end_time - segment[\\"start\\"] duration = segment[\\"end\\"] - segment[\\"start\\"] segment[\\"start\\"] = last_end_time segment[\\"end\\"] = segment[\\"start\\"] + duration adjusted_segments.append(segment) last_end_time = segment[\\"end\\"] # Convert the times back to hh:mm format for segment in adjusted_segments: segment[\\"start\\"] = segment[\\"start\\"].strftime(time_format) segment[\\"end\\"] = segment[\\"end\\"].strftime(time_format) return adjusted_segments def parse_input(input_text): lines = input_text.strip().split(\\"n\\") n = int(lines[0]) segments = [] for i in range(1, n + 1): parts = lines[i].split() name = parts[0] start = parts[1] end = parts[2] segments.append({\\"name\\": name, \\"start\\": start, \\"end\\": end}) return segments def format_output(segments): return \\"n\\".join([f\\"{segment['name']} {segment['start']} {segment['end']}\\" for segment in segments]) # Main function to handle input and output. def main(input_text): segments = parse_input(input_text) adjusted_segments = adjust_segments(segments) return format_output(adjusted_segments)"},{"question":"def restock_item(item: dict, units: int) -> None: Updates the stock level of the given item by adding the specified number of units. :param item: Dictionary representing the item with keys: 'id', 'category', 'stock', 'min_stock' :param units: Number of units to add to the stock pass def get_low_stock_items(items: list) -> list: Returns a list of item ids that are considered low stock from the given list of items. :param items: List of dictionaries, each representing an item with keys: 'id', 'category', 'stock', 'min_stock' :return: List of item ids with stock level below their minimum stock level pass","solution":"def restock_item(item: dict, units: int) -> None: Updates the stock level of the given item by adding the specified number of units. :param item: Dictionary representing the item with keys: 'id', 'category', 'stock', 'min_stock' :param units: Number of units to add to the stock item['stock'] += units def get_low_stock_items(items: list) -> list: Returns a list of item ids that are considered low stock from the given list of items. :param items: List of dictionaries, each representing an item with keys: 'id', 'category', 'stock', 'min_stock' :return: List of item ids with stock level below their minimum stock level return [item['id'] for item in items if item['stock'] < item['min_stock']]"},{"question":"def canPartitionKSubsets(nums: List[int], k: int) -> bool: Write a function \`canPartitionKSubsets(nums, k)\` that takes an array of integers \`nums\` and an integer \`k\` as input and returns \`True\` if it is possible to divide the array into \`k\` non-empty subsets whose sums are all equal, otherwise returns \`False\`. >>> canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> canPartitionKSubsets([1, 2, 3, 4], 3) False","solution":"def canPartitionKSubsets(nums, k): Determines if it is possible to divide the array \`nums\` into \`k\` non-empty subsets with equal sum. total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k nums.sort(reverse=True) used = [False] * len(nums) def backtrack(index, k, current_sum): if k == 1: return True if current_sum == target: return backtrack(0, k - 1, 0) for i in range(index, len(nums)): if not used[i] and current_sum + nums[i] <= target: used[i] = True if backtrack(i + 1, k, current_sum + nums[i]): return True used[i] = False return False return backtrack(0, k, 0)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root: TreeNode) -> int: Given a binary tree, return the sum of values of its deepest leaves. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.left.left.left = TreeNode(7) >>> root.right.right.left = TreeNode(8) >>> root.right.right.right = TreeNode(9) >>> deepestLeavesSum(root) 24 from solution import TreeNode, deepestLeavesSum def test_deepestLeavesSum_single_node(): # Tree: 1 root = TreeNode(1) assert deepestLeavesSum(root) == 1 def test_deepestLeavesSum_multiple_levels(): # Tree: # 1 # / # 2 3 # / # 4 5 6 # / / # 7 8 9 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.left.left.left = TreeNode(7) root.right.right.left = TreeNode(8) root.right.right.right = TreeNode(9) assert deepestLeavesSum(root) == 7 + 8 + 9 def test_deepestLeavesSum_unbalanced_tree(): # Tree: # 1 # / # 2 # / # 3 # / # 4 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert deepestLeavesSum(root) == 4 def test_deepestLeavesSum_all_right(): # Tree: # 1 # # 2 # # 3 # # 4 root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert deepestLeavesSum(root) == 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): def dfs(node, depth): if not node: return if depth == len(deepest_levels): deepest_levels.append([node.val]) else: deepest_levels[depth].append(node.val) dfs(node.left, depth + 1) dfs(node.right, depth + 1) deepest_levels = [] dfs(root, 0) return sum(deepest_levels[-1])"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a new list containing the product of all the integers in the original list except for the integer at the current position. >>> product_except_self([1,2,3,4]) == [24, 12, 8, 6] >>> product_except_self([2,3,4,5]) == [60, 40, 30, 24] >>> product_except_self([10]) == [1] >>> product_except_self([1, 10]) == [10, 1] >>> product_except_self([4, 0, 2]) == [0, 8, 0] >>> product_except_self([0, 0, 2]) == [0, 0, 0] >>> product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0]","solution":"def product_except_self(nums): Returns a list such that, at each index i, the element is the product of all the elements of nums except nums[i]. length = len(nums) # Step 1: Calculate prefix product array prefix_products = [1] * length for i in range(1, length): prefix_products[i] = prefix_products[i - 1] * nums[i - 1] # Step 2: Calculate suffix product array and final result in a single pass suffix_product = 1 for i in range(length - 1, -1, -1): prefix_products[i] *= suffix_product suffix_product *= nums[i] return prefix_products"},{"question":"def find_unique_integer(nums: List[int]) -> int: Finds the integer that appears only once in the list while every other integer appears exactly three times. >>> find_unique_integer([2, 2, 3, 2]) 3 >>> find_unique_integer([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def find_unique_integer(nums): Finds the integer that appears only once in the list while every other integer appears exactly three times. :param nums: List[int] :return: int ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"def diagonal_sum(matrix: List[List[int]]) -> int: Returns the sum of the elements on the primary diagonal of a square matrix. :param matrix: List of lists representing the square matrix :return: Sum of the primary diagonal elements >>> diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 15 >>> diagonal_sum([[10, 2], [3, 4]]) 14 >>> diagonal_sum([[100]]) 100 >>> diagonal_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) -15 >>> diagonal_sum([ ... [1, -2, 3], ... [-4, 5, -6], ... [7, -8, 9] ... ]) 15 >>> diagonal_sum([ ... [1000000000, 2, 3], ... [4, 2000000000, 6], ... [7, 8, 3000000000] ... ]) 6000000000","solution":"def diagonal_sum(matrix): Returns the sum of the elements on the primary diagonal of a square matrix. :param matrix: List of lists representing the square matrix :return: Sum of the primary diagonal elements return sum(matrix[i][i] for i in range(len(matrix)))"},{"question":"def findPair(nums: list[int], target: int) -> bool: Determines if any two distinct integers in the array sum up to the target value. Args: nums (list[int]): List of integers. target (int): Target sum. Returns: bool: True if there exists at least one pair of distinct integers that sum to the target, False otherwise. Examples: >>> findPair([1, 2, 3, 4], 5) == True >>> findPair([1, 2, 3, 4], 8) == False >>> findPair([3, 1, 5, 7, -8], -7) == True >>> findPair([], 3) == False >>> findPair([1], 1) == False >>> findPair([1, 1], 2) == True","solution":"def findPair(nums: list[int], target: int) -> bool: Determines if any two distinct integers in the array sum up to the target value. Args: nums (list[int]): List of integers. target (int): Target sum. Returns: bool: True if there exists at least one pair of distinct integers that sum to the target, False otherwise. seen_numbers = set() for num in nums: if target - num in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"def max_difference(arr: List[int]) -> int: Finds the maximum difference between any two elements where the larger element comes after the smaller one in the list. :param arr: List of integers :return: Maximum difference if found, otherwise 0 Examples: >>> max_difference([2, 3, 10, 2, 4, 8, 1]) == 8 >>> max_difference([7, 9, 5, 6, 3, 2]) == 2 >>> max_difference([10, 8, 7, 6, 5]) == 0","solution":"def max_difference(arr): Finds the maximum difference between any two elements where the larger element comes after the smaller one in the list. :param arr: List of integers :return: Maximum difference if found, otherwise 0 if not arr or len(arr) < 2: return 0 min_element = arr[0] max_diff = 0 for num in arr[1:]: if num - min_element > max_diff: max_diff = num - min_element if num < min_element: min_element = num return max_diff"},{"question":"def calculate_min_loading_time(box_weights, truck_capacity, loading_time): Calculates the minimum total loading time required to transport all the boxes. Parameters: - box_weights: a list of integers representing the weights of the boxes - truck_capacity: an integer representing the maximum capacity of a truck per trip - loading_time: an integer representing the time it takes to load and transport one truckload of boxes Returns: - \\"error\\" if a box's weight exceeds the truck capacity - Minimum total loading time as an integer rounded to the nearest whole number Examples: >>> calculate_min_loading_time([5, 8, 2, 9, 6], 10, 3) 12 >>> calculate_min_loading_time([5, 8, 12, 3], 10, 3) 'error' >>> calculate_min_loading_time([5, 3], 10, 3) 3 >>> calculate_min_loading_time([], 10, 3) 0 from solution import calculate_min_loading_time def test_overweight_box(): assert calculate_min_loading_time([5, 8, 12, 3], 10, 3) == \\"error\\" def test_single_trip(): assert calculate_min_loading_time([5, 3], 10, 3) == 3 def test_multiple_trips(): assert calculate_min_loading_time([5, 8, 2, 9, 6], 10, 3) == 12 assert calculate_min_loading_time([5, 8, 2, 9, 6], 10, 1) == 4 def test_empty_box_weights(): assert calculate_min_loading_time([], 10, 3) == 0 def test_boxes_that_fit_together(): assert calculate_min_loading_time([1, 1, 1, 1, 2, 2, 2], 5, 2) == 6 def test_exact_fit_trips(): assert calculate_min_loading_time([3, 3, 3, 3, 3], 3, 1) == 5 assert calculate_min_loading_time([4, 4, 4, 4], 4, 1) == 4","solution":"def calculate_min_loading_time(box_weights, truck_capacity, loading_time): Returns the minimum total loading time required to transport all the boxes. Parameters: - box_weights: list of integers representing weights of the boxes - truck_capacity: integer representing maximum capacity of a truck per trip - loading_time: integer representing time to load and transport one truckload of boxes Returns: - \\"error\\" if a box's weight exceeds truck capacity. - Minimum total loading time as an integer. # Check if any box weight exceeds the truck capacity for weight in box_weights: if weight > truck_capacity: return \\"error\\" # Sort the box weights in ascending order box_weights.sort() # Initialize the total loading time total_loading_time = 0 while box_weights: current_load = 0 # Load the truck while the remaining capacity allows for weight in box_weights[:]: if current_load + weight <= truck_capacity: current_load += weight box_weights.remove(weight) # Increment the total loading time total_loading_time += loading_time return total_loading_time"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sort_primes_first(lst: List[int]) -> List[int]: Sort the list such that all prime numbers appear before non-prime numbers while maintaining relative order of both from the original list. Args: lst (List[int]): List of integers to be sorted. Returns: List[int]: List of integers with primes first and non-primes later. Examples: >>> sort_primes_first([10, 3, 5, 2, 8, 13, 4, 6]) [3, 5, 2, 13, 10, 8, 4, 6] >>> sort_primes_first([4, 6, 8, 9, 10]) [4, 6, 8, 9, 10] primes = [x for x in lst if is_prime(x)] non_primes = [x for x in lst if not is_prime(x)] return primes + non_primes","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sort_primes_first(lst): Sort the list such that all prime numbers appear before non-prime numbers while maintaining relative order of both from the original list. primes = [x for x in lst if is_prime(x)] non_primes = [x for x in lst if not is_prime(x)] return primes + non_primes"},{"question":"def longest_string_with_vowel(strings: List[str]) -> int: Returns the length of the longest string from the list that contains at least one vowel. Ignores case in both vowel checking and counting the length of the string. Examples: >>> longest_string_with_vowel([\\"apple\\", \\"BanAnA\\", \\"GRAPE\\", \\"Plum\\"]) 6 >>> longest_string_with_vowel([\\"sky\\", \\"nimbus\\", \\"Flight\\", \\"xyz\\"]) 6 >>> longest_string_with_vowel([\\"bcd\\", \\"fgh\\", \\"jkl\\"]) 0","solution":"def longest_string_with_vowel(strings): Returns the length of the longest string from the list that contains at least one vowel. Ignores case in both vowel checking and counting the length of the string. vowels = set('aeiou') max_length = 0 for string in strings: # Check if the string contains at least one vowel if any(char.lower() in vowels for char in string): # Update max_length if this string is longer max_length = max(max_length, len(string)) return max_length"},{"question":"def longest_unique_substring_length(s: str) -> int: Determines the number of unique characters in the longest substring without repeating characters. >>> longest_unique_substring_length(\\"abcabcbb\\") == 3 # \\"abc\\" >>> longest_unique_substring_length(\\"bbbbb\\") == 1 # \\"b\\" >>> longest_unique_substring_length(\\"pwwkew\\") == 3 # \\"wke\\" >>> longest_unique_substring_length(\\"abcde\\") == 5 # \\"abcde\\" >>> longest_unique_substring_length(\\"a\\") == 1 # \\"a\\" >>> longest_unique_substring_length(\\"\\") == 0 # \\"\\" >>> longest_unique_substring_length(\\"dvdf\\") == 3 # \\"vdf\\" >>> longest_unique_substring_length(\\"anviaj\\") == 5 # \\"nviaj\\" >>> longest_unique_substring_length(\\"aabbcc\\") == 2 # \\"ab\\" >>> longest_unique_substring_length(\\"abac\\") == 3 # \\"bac\\" >>> longest_unique_substring_length(\\"aabbccddeeffgg\\") == 2 # \\"ab\\" >>> longest_unique_substring_length(\\"abcdefgabcdefg\\") == 7 # \\"abcdefg\\" pass","solution":"def longest_unique_substring_length(s: str) -> int: Determines the length of the longest substring without repeating characters. char_index_map = {} start = max_length = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Given a list of daily stock prices for a certain company, calculate the maximum possible profit from buying and selling the stock. You can only complete one transaction: buy one day and sell one another day in the future. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 def test_max_profit_example1(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 def test_max_profit_example2(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_empty(): assert max_profit([]) == 0 def test_max_profit_single_price(): assert max_profit([5]) == 0 def test_max_profit_with_profitable_days(): assert max_profit([3, 2, 6, 5, 0, 3]) == 4 def test_max_profit_all_increasing(): assert max_profit([1, 2, 3, 4, 5, 6, 7]) == 6 def test_max_profit_all_decreasing(): assert max_profit([7, 6, 5, 4, 3, 2, 1]) == 0 def test_max_profit_mixed(): assert max_profit([6, 1, 3, 2, 4, 7]) == 6","solution":"def max_profit(prices): Returns the maximum profit from a single buy-sell transaction. if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def min_steps_to_empty_string(s: str) -> int: Given a string s containing only lowercase English letters, determine the minimum number of steps to make s empty. In each step, you can select any one palindrome substring and remove it from s. >>> min_steps_to_empty_string(\\"ababa\\") 1 >>> min_steps_to_empty_string(\\"abb\\") 2 >>> min_steps_to_empty_string(\\"abc\\") 2","solution":"def min_steps_to_empty_string(s): Returns the minimum number of steps to make the string s empty by removing palindromic substrings. if s == s[::-1]: return 1 else: return 2 # Explanation: # If the string is a palindrome, we can remove it in one step. # If the string is not a palindrome, the minimum steps to remove a non-palindromic # sequence will be 2. One way to think about this is: # In the worst case scenario for a non-palindromic string, it can always be divided # into two parts such that each part can be removed individually in 2 steps."},{"question":"from typing import List, Tuple def min_time_units(t: int, test_cases: List[Tuple[int, int, List[List[str]]]]) -> List[int]: Determine the minimum number of time units required to complete all tasks given the constraints of dependencies and the maximum number of concurrent tasks. Args: t: Number of test cases. test_cases: List of test cases, each with the number of tasks, max concurrent tasks, and a list of tasks with their dependencies. Returns: A list of integers, each representing the minimum time units required for each test case. >>> min_time_units(2, [(4, 2, [['a'], ['b', 'a'], ['c', 'a'], ['d', 'b', 'c']]), (3, 2, [['x'], ['y', 'x'], ['z', 'y']])]) [3, 3] >>> min_time_units(1, [(4, 2, [['a'], ['b'], ['c'], ['d']])]) [2]","solution":"from collections import defaultdict, deque def min_time_units(t, test_cases): results = [] for N, K, tasks in test_cases: # Step 1: Initialize the graph and in-degrees graph = defaultdict(list) in_degrees = {task[0]: 0 for task in tasks} for task in tasks: u = task[0] dependencies = task[1:] in_degrees[u] = len(dependencies) for dep in dependencies: graph[dep].append(u) # Step 2: Topological sort using K kahn's algorithm zero_in_degree_queue = deque([task for task in in_degrees if in_degrees[task] == 0]) time_units = 0 while zero_in_degree_queue: task_batch = [] for _ in range(min(K, len(zero_in_degree_queue))): task = zero_in_degree_queue.popleft() task_batch.append(task) for task in task_batch: for neighbor in graph[task]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: zero_in_degree_queue.append(neighbor) time_units += 1 results.append(time_units) return results"},{"question":"import re from typing import List, Tuple def validate_login_attempts(n: int, attempts: List[Tuple[str, str, str]]) -> List[str]: Validates multiple login attempts according to specific criteria for username, password, and code. A username must: 1. Be between 5 and 15 characters long, inclusive. 2. Only contain lowercase letters and numbers. 3. Not start with a number. A password must: 1. Be between 8 and 20 characters long, inclusive. 2. Contain at least one uppercase letter. 3. Contain at least one lowercase letter. 4. Contain at least one number. 5. Contain at least one special character from the set {!@#%^&*()}. A code must: 1. Be exactly 6 characters long. 2. Only contain numbers or uppercase letters. Args: n (int): number of login attempts attempts (List[Tuple[str, str, str]]): List of tuples where each tuple contains (username, password, code) Returns: List[str]: List of \\"VALID\\" or \\"INVALID\\" for each login attempt based on criteria. >>> validate_login_attempts(3, [(\\"alice123\\", \\"Super@Pass123\\", \\"G4THJK\\"), (\\"bob\\", \\"12345678\\", \\"Ab12CD\\"), (\\"eve123\\", \\"Eve1234@\\", \\"1A2B3C\\")]) ['VALID', 'INVALID', 'VALID'] # Here are some test cases def test_validate_login_attempts(): input_data = [ (\\"alice123\\", \\"Super@Pass123\\", \\"G4THJK\\"), (\\"bob\\", \\"12345678\\", \\"Ab12CD\\"), (\\"eve123\\", \\"Eve1234@\\", \\"1A2B3C\\"), ] expected_output = [\\"VALID\\", \\"INVALID\\", \\"VALID\\"] assert validate_login_attempts(3, input_data) == expected_output def test_invalid_username(): input_data = [ (\\"a1\\", \\"Super@Pass123\\", \\"G4THJK\\"), (\\"12345\\", \\"Super@Pass123\\", \\"G4THJK\\"), (\\"a!ice123\\", \\"Super@Pass123\\", \\"G4THJK\\"), ] expected_output = [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] assert validate_login_attempts(3, input_data) == expected_output def test_invalid_password(): input_data = [ (\\"alice123\\", \\"superpass123\\", \\"G4THJK\\"), (\\"alice123\\", \\"SUPERPASS123\\", \\"G4THJK\\"), (\\"alice123\\", \\"Super@pass\\", \\"G4THJK\\"), (\\"alice123\\", \\"Super123\\", \\"G4THJK\\"), (\\"alice123\\", \\"Super@P123\\" * 3, \\"G4THJK\\"), ] expected_output = [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] assert validate_login_attempts(5, input_data) == expected_output def test_invalid_code(): input_data = [ (\\"alice123\\", \\"Super@Pass123\\", \\"G4THJ\\"), (\\"alice123\\", \\"Super@Pass123\\", \\"G4THJK7\\"), (\\"alice123\\", \\"Super@Pass123\\", \\"g4thjk\\"), ] expected_output = [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] assert validate_login_attempts(3, input_data) == expected_output def test_all_valid(): input_data = [ (\\"alice123\\", \\"Super@Pass123\\", \\"G4THJK\\"), (\\"bob123\\", \\"B0b@123456\\", \\"1A2B3C\\"), (\\"eve123\\", \\"Eve24@word\\", \\"ABCDE3\\"), ] expected_output = [\\"VALID\\", \\"VALID\\", \\"VALID\\"] assert validate_login_attempts(3, input_data) == expected_output","solution":"import re def validate_login_attempts(n, attempts): def validate_username(username): return len(username) >= 5 and len(username) <= 15 and username.isalnum() and not username[0].isdigit() def validate_password(password): if len(password) < 8 or len(password) > 20: return False if not re.search(r'[A-Z]', password): return False if not re.search(r'[a-z]', password): return False if not re.search(r'[0-9]', password): return False if not re.search(r'[!@#%^&*()]', password): return False return True def validate_code(code): return len(code) == 6 and code.isalnum() and code.isupper() results = [] for attempt in attempts: username, password, code = attempt if validate_username(username) and validate_password(password) and validate_code(code): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"from typing import List def max_trapped_water(heights: List[int]) -> int: Determine the maximum amount of water that can be trapped between the buildings after a heavy rain. Parameters: heights (List[int]): A list of positive integers representing the heights of buildings. Returns: int: The maximum amount of water that can be trapped. Examples: >>> max_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> max_trapped_water([4, 2, 0, 3, 2, 5]) 9","solution":"from typing import List def max_trapped_water(heights: List[int]) -> int: if not heights or len(heights) < 2: return 0 left = 0 right = len(heights) - 1 left_max = heights[left] right_max = heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(18) == False def filter_prime_numbers(lst: List[int]) -> List[int]: Given a list of integers, return a new list containing only the prime numbers found in the original list, maintaining their original order. >>> filter_prime_numbers([2, 3, 4, 5, 6]) == [2, 3, 5] >>> filter_prime_numbers([10, 11, 12, 13, 14]) == [11, 13] >>> filter_prime_numbers([4, 6, 8, 9, 10, 12]) == [] >>> filter_prime_numbers([2, 3, 5, 7, 11, 13]) == [2, 3, 5, 7, 11, 13] >>> filter_prime_numbers([1, 2, 3, 4, 5]) == [2, 3, 5]","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def filter_prime_numbers(lst): Returns a list containing only the prime numbers from the original list. return [number for number in lst if is_prime(number)]"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Determine the minimum number of characters needed to make the given string a palindrome. >>> min_insertions_to_palindrome(\\"abca\\") 1 >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"a\\") 0 >>> min_insertions_to_palindrome(\\"aa\\") 0 >>> min_insertions_to_palindrome(\\"aaa\\") 0 >>> min_insertions_to_palindrome(\\"abcba\\") 0 >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"abc\\") 2 >>> min_insertions_to_palindrome(\\"abcd\\") 3 >>> min_insertions_to_palindrome(\\"abcde\\") 4 >>> min_insertions_to_palindrome(\\"aabb\\") 2 >>> min_insertions_to_palindrome(\\"\\") 0","solution":"def min_insertions_to_palindrome(s): def lcs(X, Y): m = len(X) n = len(Y) L = [[0] * (n + 1) for i in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) return L[m][n] rev = s[::-1] lcs_len = lcs(s, rev) return len(s) - lcs_len"},{"question":"def subset_sum(arr, target): Given an array of n integers, determine if there exists a subset that sums to a given target value. Return \`true\` if such a subset exists, otherwise return \`false\`. Examples: >>> subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> subset_sum([3, 34, 4, 12, 5, 2], 30) False >>> subset_sum([1, 2, 3], 6) True >>> subset_sum([2, 4, 6, 8], 5) False","solution":"def subset_sum(arr, target): Returns True if there exists a subset of \`arr\` such that the subset sums to \`target\`, otherwise False. n = len(arr) dp = [[False for _ in range(target + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if j < arr[i - 1]: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] return dp[n][target]"},{"question":"def uniquePaths(m: int, n: int) -> int: Returns the number of unique paths from the top-left to the bottom-right corner of a m x n grid. >>> uniquePaths(3, 7) 28 >>> uniquePaths(3, 2) 3 >>> uniquePaths(1, 1) 1 >>> uniquePaths(5, 5) 70 >>> uniquePaths(7, 3) 28 >>> uniquePaths(100, 100) 22750883079422934966181954039568885395604168260154104734000","solution":"def uniquePaths(m, n): Returns the number of unique paths from the top-left to the bottom-right corner of a m x n grid. # Create a 2D array to store the number of unique paths to each cell dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def min_jumps(arr: List[int]) -> int: Determine the minimum number of jumps to reach the end of the list. Parameters: arr (list): A list of non-negative integers where each element represents the maximum number of steps that can be jumped forward from that element. Returns: int: The minimum number of jumps required to reach the end of the list, or -1 if it is not possible. pass def test_min_jumps(): assert min_jumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3 assert min_jumps([1, 1, 1, 1, 1]) == 4 assert min_jumps([1, 0, 1, 0, 1]) == -1 assert min_jumps([0]) == 0 assert min_jumps([]) == 0 assert min_jumps([0, 2, 3]) == -1 assert min_jumps([2, 3, 1, 1, 4]) == 2 assert min_jumps([7, 0, 0, 0, 0, 0, 0, 1]) == 1 assert min_jumps([1, 0, 0, 0, 0, 0]) == -1 assert min_jumps([2, 0]) == 1","solution":"def min_jumps(arr): Determine the minimum number of jumps to reach the end of the list. Parameters: arr (list): A list of non-negative integers where each element represents the maximum number of steps that can be jumped forward from that element. Returns: int: The minimum number of jumps required to reach the end of the list, or -1 if it is not possible. if len(arr) <= 1: return 0 # No steps can be taken if the first element is 0 if arr[0] == 0: return -1 jumps = 1 max_reach = arr[0] steps = arr[0] for i in range(1, len(arr)): if i == len(arr) - 1: return jumps max_reach = max(max_reach, i + arr[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Given a grid where each cell has a positive integer value, this function returns the minimum sum of a path from the top-left to the bottom-right corner of the grid, where you can only move right or down at each step. >>> minPathSum([[1,3,1],[1,5,1],[4,2,1]]) 7 >>> minPathSum([[1,2,3],[4,5,6]]) 12 def test_example_1(): grid = [[1,3,1],[1,5,1],[4,2,1]] assert minPathSum(grid) == 7 def test_example_2(): grid = [[1,2,3],[4,5,6]] assert minPathSum(grid) == 12 def test_single_row(): grid = [[1, 2, 3, 4]] assert minPathSum(grid) == 10 def test_single_column(): grid = [[1], [2], [3], [4]] assert minPathSum(grid) == 10 def test_minimum_size_grid(): grid = [[5]] assert minPathSum(grid) == 5 def test_large_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert minPathSum(grid) == 21","solution":"def minPathSum(grid): Given a grid where each cell has a positive integer value, this function returns the minimum sum of a path from the top-left to the bottom-right corner of the grid, where you can only move right or down at each step. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"def character_counts(s: str) -> dict: Returns a dictionary with the counts of each character in the string. The function ignores spaces and is case-insensitive. >>> character_counts(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_counts(\\"\\") {} >>> character_counts(\\" \\") {} >>> character_counts(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> character_counts(\\"!@# %^\\") {'!': 1, '@': 1, '#': 1, '': 1, '%': 1, '^': 1}","solution":"def character_counts(s): Returns a dictionary with the counts of each character in the string. The function ignores spaces and is case-insensitive. count_dict = {} for char in s.replace(\\" \\", \\"\\").lower(): if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. Examples: >>> are_anagrams('listen', 'silent') True >>> are_anagrams('hello', 'billion') False >>> are_anagrams('evil', 'vile') True >>> are_anagrams('triangle', 'integral') True >>> are_anagrams('example', 'samples') False pass","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. return sorted(s1) == sorted(s2)"},{"question":"from typing import List def count_smaller(nums: List[int]) -> List[int]: Takes a list of non-negative integers and returns a new list where each element is replaced by the number of elements to the right that are smaller than the current element. >>> count_smaller([5, 2, 6, 1]) [2, 1, 1, 0] >>> count_smaller([1, 2, 3]) [0, 0, 0] >>> count_smaller([3, 2, 1]) [2, 1, 0] >>> count_smaller([1, 1, 1]) [0, 0, 0] >>> count_smaller([]) [] def test_count_smaller(): assert count_smaller([5, 2, 6, 1]) == [2, 1, 1, 0] assert count_smaller([1, 2, 3]) == [0, 0, 0] assert count_smaller([3, 2, 1]) == [2, 1, 0] assert count_smaller([1, 1, 1]) == [0, 0, 0] assert count_smaller([]) == [] assert count_smaller([42]) == [0] assert count_smaller([1, 3, 2, 3, 1]) == [0, 2, 1, 1, 0] assert count_smaller([2, 2, 2, 2]) == [0, 0, 0, 0]","solution":"from typing import List def count_smaller(nums: List[int]) -> List[int]: Returns a list where each element is replaced by the number of elements to the right that are smaller than the current element. result = [] for i in range(len(nums)): count = sum(1 for j in range(i + 1, len(nums)) if nums[j] < nums[i]) result.append(count) return result"},{"question":"def max_packages(drones: List[int], packages: List[int]) -> int: Determines the maximum number of packages that can be delivered by the drones. :param drones: list of integers representing the capacities of the drones :param packages: list of integers representing the weights of the packages :return: maximum number of packages that can be delivered >>> max_packages([10, 5, 7], [8, 5, 6, 7]) 3 >>> max_packages([1, 2, 3], [4, 5, 6]) 0 >>> max_packages([10, 10, 10], [1, 2, 3]) 3 >>> max_packages([10, 9, 8], [8, 8, 8, 7, 7, 7]) 3 >>> max_packages([10, 9, 8, 7], [8, 7, 6]) 3 >>> max_packages([10, 9], [8, 8, 8]) 2","solution":"def max_packages(drones, packages): Determines the maximum number of packages that can be delivered by the drones :param drones: list of integers representing the capacities of the drones :param packages: list of integers representing the weights of the packages :return: maximum number of packages that can be delivered drones.sort(reverse=True) packages.sort(reverse=True) i = 0 j = 0 delivered_packages = 0 while i < len(drones) and j < len(packages): if drones[i] >= packages[j]: delivered_packages += 1 i += 1 j += 1 return delivered_packages"},{"question":"[Completion Task in Python] def longest_substring_with_two_distinct(s: str) -> int: Given a string \`s\`, return the length of the longest substring containing exactly two distinct characters. The substring should only consist of alphabetic characters and no spaces. >>> longest_substring_with_two_distinct(\\"eceba\\") == 3 >>> longest_substring_with_two_distinct(\\"ccaabbb\\") == 5 >>> longest_substring_with_two_distinct(\\"a\\") == 1 >>> longest_substring_with_two_distinct(\\"abcabcabc\\") == 2 >>> longest_substring_with_two_distinct(\\"abaccc\\") == 4 >>> longest_substring_with_two_distinct(\\"aaaa\\") == 4 >>> longest_substring_with_two_distinct(\\"\\") == 0 >>> longest_substring_with_two_distinct(\\"abcde\\") == 2","solution":"def longest_substring_with_two_distinct(s: str) -> int: from collections import defaultdict if not s: return 0 # Dictionary to store frequency of characters in the current window char_count = defaultdict(int) left = 0 max_length = 0 for right in range(len(s)): char_count[s[right]] += 1 # If we have more than 2 distinct characters, reduce the window size while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def is_beautiful_number(n: int) -> str: Determines if the given number is a Beautiful Number. A Beautiful Number is defined as a number that: 1. Remains the same when reversed (a palindrome). 2. Has an even sum of its digits. Parameters: - n: Integer (0 <= n <= 10^6) Returns: - \\"Beautiful\\" if n is a Beautiful Number, otherwise \\"Not Beautiful\\". >>> is_beautiful_number(1221) 'Beautiful' >>> is_beautiful_number(1234) 'Not Beautiful' >>> is_beautiful_number(4) 'Beautiful' >>> is_beautiful_number(12321) 'Not Beautiful' >>> is_beautiful_number(0) 'Beautiful' >>> is_beautiful_number(244442) 'Beautiful' >>> is_beautiful_number(244443) 'Not Beautiful'","solution":"def is_beautiful_number(n): Determines if the given number is a Beautiful Number. A Beautiful Number is defined as a number that: 1. Remains the same when reversed (a palindrome). 2. Has an even sum of its digits. Parameters: - n: Integer (0 <= n <= 10^6) Returns: - \\"Beautiful\\" if n is a Beautiful Number, otherwise \\"Not Beautiful\\". n_str = str(n) if n_str != n_str[::-1]: return \\"Not Beautiful\\" digit_sum = sum(int(digit) for digit in n_str) if digit_sum % 2 == 0: return \\"Beautiful\\" else: return \\"Not Beautiful\\""},{"question":"def rotateArray(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): The input array of integers. k (int): The number of steps to rotate the array. Returns: list: The rotated array. >>> rotateArray([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotateArray([0, 0, 0], 1) == [0, 0, 0] >>> rotateArray([1, 2], 3) == [2, 1] >>> rotateArray([], 5) == []","solution":"def rotateArray(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): The input array of integers. k (int): The number of steps to rotate the array. Returns: list: The rotated array. if not arr: return [] n = len(arr) k = k % n # In case k is larger than the array length return arr[-k:] + arr[:-k]"},{"question":"from typing import List def n_most_frequent_characters(s: str, n: int) -> List[str]: Given a string s and an integer n, return the n most frequent characters in the string in descending order of their frequency. If there are multiple characters with the same frequency, return them in alphabetical order. >>> n_most_frequent_characters(\\"aabbbcc\\", 2) ['b', 'a'] >>> n_most_frequent_characters(\\"abcabcabc\\", 1) ['a']","solution":"from collections import Counter def n_most_frequent_characters(s, n): Returns the n most frequent characters in the string s in descending order of their frequency. If there are multiple characters with the same frequency, they are returned in alphabetical order. # Count the frequency of each character frequency = Counter(s) # Sort characters primarily by frequency in descending order, and secondarily by alphabetical order sorted_characters = sorted(frequency.keys(), key=lambda x: (-frequency[x], x)) # Return the top n characters return sorted_characters[:n]"},{"question":"def square_digits(num: int) -> int: Takes an integer as input and returns an integer where each digit of the input number has been squared and concatenated to form a new number. >>> square_digits(9119) 811181 >>> square_digits(1234) 14916 >>> square_digits(0) 0 >>> square_digits(5) 25 >>> square_digits(86) 6436 >>> square_digits(100) 100 >>> square_digits(999) 818181 >>> square_digits(123456789) 149162536496481 >>> [square_digits(i) for i in range(10)] [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]","solution":"def square_digits(num: int) -> int: Takes an integer as input and returns an integer where each digit of the input number has been squared and concatenated to form a new number. squared_digits = [str(int(digit) ** 2) for digit in str(num)] result = int(''.join(squared_digits)) return result"},{"question":"def translate_to_dial_pad(s: str) -> str: Translates a given string into a dial pad sequence. >>> translate_to_dial_pad(\\"HELLO WORLD123\\") == \\"43556 96753123\\" >>> translate_to_dial_pad(\\"HELLO WORLD\\") == \\"43556 96753\\" >>> translate_to_dial_pad(\\"Hello World\\") == \\"43556 96753\\" >>> translate_to_dial_pad(\\"HELLO123\\") == \\"43556123\\" >>> translate_to_dial_pad(\\"1234567890\\") == \\"1234567890\\" >>> translate_to_dial_pad(\\"\\") == \\"\\" >>> translate_to_dial_pad(\\"Call Me @ 123!\\") == \\"2255 63 @ 123!\\" >>> translate_to_dial_pad(\\"hello\\") == \\"43556\\" pass","solution":"def translate_to_dial_pad(s): Translates a given string into a dial pad sequence. Parameters: s (str): The input string with alphabetic characters and digits. Returns: str: The translated dial pad sequence string. dial_pad_mapping = { 'A': '2', 'B': '2', 'C': '2', 'D': '3', 'E': '3', 'F': '3', 'G': '4', 'H': '4', 'I': '4', 'J': '5', 'K': '5', 'L': '5', 'M': '6', 'N': '6', 'O': '6', 'P': '7', 'Q': '7', 'R': '7', 'S': '7', 'T': '8', 'U': '8', 'V': '8', 'W': '9', 'X': '9', 'Y': '9', 'Z': '9' } result = [] for char in s: if char.isdigit(): result.append(char) else: result.append(dial_pad_mapping.get(char.upper(), char)) # Use .upper() to handle lowercase letters return ''.join(result)"},{"question":"from typing import List def temperature_alert(temperatures: List[int], T: int) -> bool: Returns True if any room's temperature deviates from the average by more than T. >>> temperature_alert([21, 23, 22, 20, 24], 2) False >>> temperature_alert([21, 23, 22, 20, 30], 6) True >>> temperature_alert([25, 25, 25, 25, 25], 0) False >>> temperature_alert([25], 0) False >>> temperature_alert([], 0) False >>> temperature_alert([10, 20, 30, 40, 50], 100) False >>> temperature_alert([10, 10, 10, 10, 9], 0) True >>> temperature_alert([-10, -12, -13, -14, -11], 1) True","solution":"from typing import List def temperature_alert(temperatures: List[int], T: int) -> bool: Returns True if any room's temperature deviates from the average by more than T. if not temperatures: return False average_temp = sum(temperatures) / len(temperatures) for temp in temperatures: if abs(temp - average_temp) > T: return True return False"},{"question":"def greater_than_average(nums: List[int]) -> List[int]: Returns a new list containing elements from the input list 'nums' that are greater than the average value of the elements in 'nums'. Preserves the order of elements. Args: nums (list of int): The input list of integers. Returns: list of int: A new list with only the elements greater than the average value. Examples: >>> greater_than_average([1, 2, 3, 4, 5]) [4, 5] >>> greater_than_average([10, 10, 10, 10]) [] >>> greater_than_average([]) [] >>> greater_than_average([5]) [] >>> greater_than_average([-2, 0, 2, 4]) [2, 4] >>> greater_than_average([1, 3, 3, 2, 4, 3, 9]) [4, 9] >>> greater_than_average([-1, -2, -3, -4, -5]) [-1, -2] >>> greater_than_average([-10, 0, 10, 20, 30]) [20, 30]","solution":"def greater_than_average(nums): Returns a new list containing elements from the input list 'nums' that are greater than the average value of the elements in 'nums'. Preserves the order of elements. Args: nums (list of int): The input list of integers. Returns: list of int: A new list with only the elements greater than the average value. if not nums: return [] average = sum(nums) / len(nums) result = [num for num in nums if num > average] return result"},{"question":"def is_item_available(vending_machine_stock, item_name): Check if a vending machine has the desired item in stock. >>> vending_machine_stock = [ ... {'name': 'Soda', 'quantity': 10}, ... {'name': 'Chips', 'quantity': 0}, ... {'name': 'Candy', 'quantity': 5} ... ] >>> is_item_available(vending_machine_stock, 'Soda') == True True >>> is_item_available(vending_machine_stock, 'Chips') == False True >>> is_item_available(vending_machine_stock, 'Water') == False True","solution":"def is_item_available(vending_machine_stock, item_name): Returns True if the vending machine has the desired item in stock, otherwise False. Parameters: vending_machine_stock (list of dict): The stock of the vending machine, each item being a dictionary with 'name' and 'quantity' keys. item_name (str): The name of the item to check for availability. Returns: bool: True if the item is in stock (quantity > 0), otherwise False. for item in vending_machine_stock: if item['name'] == item_name and item['quantity'] > 0: return True return False"},{"question":"def all_paths(matrix): Returns all possible paths from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. >>> all_paths([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[1, 2, 3, 6, 9], [1, 2, 5, 6, 9], [1, 2, 5, 8, 9], [1, 4, 5, 6, 9], [1, 4, 5, 8, 9], [1, 4, 7, 8, 9]] >>> all_paths([ ... [1] ... ]) [[1]] >>> all_paths([ ... [1, 2], ... [3, 4] ... ]) [[1, 2, 4], [1, 3, 4]] >>> all_paths([]) [] >>> all_paths([ ... [1, 2, 3] ... ]) [[1, 2, 3]] >>> all_paths([ ... [1], ... [2], ... [3] ... ]) [[1, 2, 3]]","solution":"def all_paths(matrix): Returns all paths from top-left to bottom-right in a given matrix. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] def backtrack(path, i, j): path.append(matrix[i][j]) if i == m - 1 and j == n - 1: result.append(list(path)) if i + 1 < m: backtrack(path, i + 1, j) if j + 1 < n: backtrack(path, i, j + 1) path.pop() backtrack([], 0, 0) return result"},{"question":"def manage_inventory(N: int, M: int, shipments: List[List[int]], orders: List[List[int]]) -> int: Simulate inventory management in a warehouse and report the number of days the warehouse can fulfill all the orders without running out of any items. Args: - N: int: Number of different items in the warehouse. - M: int: Number of days for which records of shipments and orders are provided. - shipments: List[List[int]]: List of lists where each list represents quantities of items received in a shipment for that day. - orders: List[List[int]]: List of lists where each list represents quantities of items required to fulfill orders for that day. Returns: - int: The total number of days the warehouse can fulfill all the orders without any shortage of items. Example: >>> manage_inventory(3, 4, [[10, 0, 20], [5, 10, 0], [15, 5, 5], [0, 0, 10]], [[5, 0, 10], [5, 5, 0], [10, 2, 3], [1, 0, 15]]) 4 >>> manage_inventory(3, 3, [[3, 2, 1], [1, 1, 1], [2, 2, 2]], [[2, 1, 1], [1, 2, 1], [1, 3, 1]]) 2 >>> manage_inventory(2, 2, [[0, 0], [10, 10]], [[1, 1], [5, 5]]) 0 >>> manage_inventory(2, 2, [[5, 5], [5, 5]], [[3, 2], [2, 3]]) 2 >>> manage_inventory(3, 3, [[1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000]], [[500, 500, 500], [500, 500, 500], [500, 500, 500]]) 3","solution":"def manage_inventory(N, M, shipments, orders): # Initialize inventory with zeros inventory = [0] * N fulfilled_days = 0 for day in range(M): # Add shipment items to inventory for i in range(N): inventory[i] += shipments[day][i] # Check if orders can be fulfilled can_fulfill = True for i in range(N): if inventory[i] < orders[day][i]: can_fulfill = False break if can_fulfill: # Fulfill the orders for i in range(N): inventory[i] -= orders[day][i] fulfilled_days += 1 else: break return fulfilled_days"},{"question":"def max_non_overlapping_rectangles(M, N, grid): Find the maximum number of non-overlapping rectangles that can be placed in the given grid such that each rectangle covers at least one artifact. Args: M (int): The number of rows in the grid. N (int): The number of columns in the grid. grid (List[str]): The grid matrix, with each character either '.' (empty cell) or 'A' (artifact). Returns: int: The maximum number of non-overlapping rectangles. Examples: >>> max_non_overlapping_rectangles(5, 6, [\\"......\\", \\".AAA..\\", \\"......\\", \\"....A.\\", \\"..AAAA\\"]) 4 >>> max_non_overlapping_rectangles(5, 5, [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"]) 0 >>> max_non_overlapping_rectangles(2, 2, [\\"AA\\", \\"AA\\"]) 1 >>> max_non_overlapping_rectangles(4, 4, [\\"A...\\", \\"..A.\\", \\"...A\\", \\"A...\\"]) 4 >>> max_non_overlapping_rectangles(3, 3, [\\"AAA\\", \\"AAA\\", \\"AAA\\"]) 1","solution":"def max_non_overlapping_rectangles(M, N, grid): def find_rectangles(grid): visited = [[False] * N for _ in range(M)] rectangles = [] for i in range(M): for j in range(N): if grid[i][j] == 'A' and not visited[i][j]: top, left = i, j # Find the bottom row of the rectangle bottom = top while bottom + 1 < M and grid[bottom + 1][j] == 'A' and not visited[bottom + 1][j]: bottom += 1 # Find the right column of the rectangle right = left while right + 1 < N and grid[i][right + 1] == 'A' and not visited[i][right + 1]: right += 1 # Mark all cells in this rectangle as visited for r in range(top, bottom + 1): for c in range(left, right + 1): visited[r][c] = True rectangles.append((top, bottom, left, right)) return rectangles rectangles = find_rectangles(grid) return len(rectangles)"},{"question":"from typing import List def find_longest_word(words: List[str]) -> str: Implement a function that takes a list of words and finds the longest word that can be made from the combination of other words in the list. Each word in the list can only be used once and it cannot be constructed from the current word itself. Args: words (List[str]): A list of non-empty strings. Returns: str: The longest word that can be constructed from the combination of other words in the list. If there are multiple words of the same length, return the one which appears first in the list. If no such word exists, return an empty string. >>> find_longest_word([\\"rat\\", \\"cat\\", \\"cats\\", \\"dog\\", \\"catsdog\\"]) 'catsdog' >>> find_longest_word([\\"apple\\", \\"banana\\", \\"cherry\\"]) '' >>> find_longest_word([\\"a\\", \\"bb\\", \\"cc\\", \\"abc\\", \\"bbcc\\"]) 'bbcc' >>> find_longest_word([\\"cat\\", \\"cats\\", \\"rat\\", \\"dog\\", \\"dogcat\\"]) 'dogcat' >>> find_longest_word([]) ''","solution":"def can_construct(word, word_set, original_word): if word in word_set and word != original_word: return True for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in word_set and can_construct(suffix, word_set, original_word): return True return False def find_longest_word(words): word_set = set(words) longest_word = \\"\\" for word in words: if can_construct(word, word_set, word) and len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"def generate_parentheses(n): Generates all combinations of well-formed parentheses for n pairs. Parameters: n (int): Number of pairs of parentheses. Returns: List[str]: List of all combinations of well-formed parentheses. Examples: >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]","solution":"def generate_parentheses(n): Generates all combinations of well-formed parentheses for n pairs. Parameters: n (int): Number of pairs of parentheses. Returns: List[str]: List of all combinations of well-formed parentheses. def backtrack(s, left, right): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \\"(\\", left + 1, right) if right < left: backtrack(s + \\")\\", left, right + 1) result = [] backtrack(\\"\\", 0, 0) return result"},{"question":"def who_wins(t: int, test_cases: List[Tuple[Tuple[int, int, int], List[int], List[int]]]) -> List[str]: Determine who will win the game, assuming both play optimally. >>> who_wins(2, [((2, 1, 1), [2], [1]), ((3, 2, 1), [3, 1], [2])]) [\\"Alice\\", \\"Alice\\"] >>> who_wins(1, [((3, 1, 2), [1], [2, 3])]) [\\"Bob\\"] # Unit Tests from solution import who_wins def test_case_1(): t = 2 test_cases = [ [(2, 1, 1), [2], [1]], [(3, 2, 1), [3, 1], [2]] ] assert who_wins(t, test_cases) == [\\"Alice\\", \\"Alice\\"] def test_case_2(): t = 1 test_cases = [ [(3, 1, 2), [1], [2, 3]] ] assert who_wins(t, test_cases) == [\\"Bob\\"] def test_case_3(): t = 1 test_cases = [ [(5, 3, 2), [3, 4, 5], [1, 2]] ] assert who_wins(t, test_cases) == [\\"Alice\\"] def test_case_4(): t = 3 test_cases = [ [(2, 1, 1), [1], [2]], [(4, 2, 2), [1, 3], [2, 4]], [(4, 3, 1), [1, 3, 4], [2]] ] assert who_wins(t, test_cases) == [\\"Bob\\", \\"Bob\\", \\"Alice\\"]","solution":"def who_wins(t, test_cases): results = [] for i in range(t): n, m_a, m_b = test_cases[i][0] a = test_cases[i][1] b = test_cases[i][2] # Determine who has the highest token if max(a) > max(b): results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results"},{"question":"def string_operations(): def to_upper(s): Convert all lowercase characters to uppercase. >>> to_upper('hello') 'HELLO' >>> to_upper('') '' def count_vowels(s): Count the number of vowels in the string. >>> count_vowels('hello') 2 >>> count_vowels('bcdfg') 0 def is_palindrome(s): Check if the string is a palindrome. >>> is_palindrome('racecar') True >>> is_palindrome('hello') False","solution":"def to_upper(s): Convert all lowercase characters to uppercase. >>> to_upper('hello') 'HELLO' >>> to_upper('') '' return s.upper() def count_vowels(s): Count the number of vowels in the string. >>> count_vowels('hello') 2 >>> count_vowels('bcdfg') 0 vowels = \\"aeiouAEIOU\\" return sum(1 for char in s if char in vowels) def is_palindrome(s): Check if the string is a palindrome. >>> is_palindrome('racecar') True >>> is_palindrome('hello') False if s == \\"\\": return False return s == s[::-1]"},{"question":"from typing import List def generate_strings(s: str) -> List[str]: Generates all possible strings by replacing '*' with lowercase alphabet letters. Parameters: s (str): The input string containing lowercase alphabets and '*'. Returns: List[str]: A list of all possible strings obtained by replacing '*' with lowercase alphabets. >>> generate_strings(\\"a*b\\") ['aab', 'abb', 'acb', 'adb', 'aeb', 'afb', 'agb', 'ahb', 'aib', 'ajb', 'akb', 'alb', 'amb', 'anb', 'aob', 'apb', 'aqb', 'arb', 'asb', 'atb', 'aub', 'avb', 'awb', 'axb', 'ayb', 'azb']","solution":"from itertools import product def generate_strings(s): Generates all possible strings by replacing '*' with lowercase alphabet letters. Parameters: s (str): The input string containing lowercase alphabets and '*'. Returns: List[str]: A list of all possible strings obtained by replacing '*' with lowercase alphabets. positions = [i for i, char in enumerate(s) if char == '*'] options = product('abcdefghijklmnopqrstuvwxyz', repeat=len(positions)) results = [] for option in options: temp_list = list(s) for index, pos in enumerate(positions): temp_list[pos] = option[index] results.append(\\"\\".join(temp_list)) return results"},{"question":"from typing import List import random def tournament_brackets(players: List[str]) -> List[List[List[str]]]: Simulate tournament rounds until a single winner is determined. >>> tournament_brackets([\\"Alice\\", \\"Bob\\"]) [[[\\"Alice\\", \\"Bob\\"]], [[\\"Alice\\"]]] >>> tournament_brackets([\\"Alice\\", \\"Bob\\", \\"Charlie\\"]) [[[\\"Alice\\", \\"Bob\\"], [\\"Charlie\\"]], [[\\"Alice\\", \\"Charlie\\"]], [[\\"Alice\\"]]] >>> tournament_brackets([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Diana\\"]) [[[\\"Alice\\", \\"Charlie\\"], [\\"Bob\\", \\"Diana\\"]], [[\\"Charlie\\", \\"Bob\\"]], [[\\"Charlie\\"]]] >>> tournament_brackets([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Diana\\", \\"Eve\\"]) [[[\\"Alice\\", \\"Bob\\"], [\\"Charlie\\", \\"Diana\\"], [\\"Eve\\"]], [[\\"Alice\\", \\"Charlie\\"], [\\"Eve\\"]], [[\\"Alice\\", \\"Eve\\"]], [[\\"Alice\\"]]]","solution":"from typing import List import random def tournament_brackets(players: List[str]) -> List[List[List[str]]]: rounds = [] while len(players) > 1: round_matches = [] random.shuffle(players) while len(players) > 1: round_matches.append([players.pop(), players.pop()]) if players: round_matches.append([players.pop()]) rounds.append(round_matches) next_round_players = [] for match in round_matches: winner = random.choice(match) next_round_players.append(winner) players = next_round_players rounds.append([[players[0]]]) return rounds"},{"question":"def unique_letters_count(s: str) -> dict: Returns a dictionary with the count of unique letters in the string. Non-letter characters are ignored. >>> unique_letters_count(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1}","solution":"def unique_letters_count(s): Returns a dictionary with the count of unique letters in the string. Non-letter characters are ignored. from collections import defaultdict count = defaultdict(int) for char in s: if char.isalpha(): char = char.lower() count[char] += 1 return dict(count)"},{"question":"def count_distinct_letters(s: str, queries: List[Tuple[int, int]]) -> List[int]: Given a string s and a list of queries, each containing two integers l and r, this function returns a list of counts of distinct letters in the substring s[l:r] for each query. >>> count_distinct_letters(\\"abcba\\", [(1, 3)]) == [3] >>> count_distinct_letters(\\"abcba\\", [(1, 3), (2, 5), (1, 5)]) == [3, 3, 3]","solution":"def count_distinct_letters(s, queries): Given a string s and a list of queries, each containing two integers l and r, this function returns a list of counts of distinct letters in the substring s[l:r] for each query. results = [] for l, r in queries: substring = s[l-1:r] # Convert 1-indexed to 0-indexed distinct_count = len(set(substring)) results.append(distinct_count) return results"},{"question":"import heapq from typing import List, Tuple def min_max_diff(grid: List[List[int]], n: int, m: int) -> int: Determine the minimum possible maximum absolute difference in heights between any two consecutive cells for a path from (1, 1) to (n, m). >>> min_max_diff([[1, 3], [4, 2]], 2, 2) 2 >>> min_max_diff([[8, 5, 9], [7, 3, 6], [2, 4, 1]], 3, 3) 3 directions = [(0, 1), (1, 0)] max_diff = [[float('inf')] * m for _ in range(n)] max_diff[0][0] = 0 heap = [(0, 0, 0)] while heap: diff, x, y = heapq.heappop(heap) if (x, y) == (n - 1, m - 1): return diff for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_diff = max(diff, abs(grid[nx][ny] - grid[x][y])) if new_diff < max_diff[nx][ny]: max_diff[nx][ny] = new_diff heapq.heappush(heap, (new_diff, nx, ny)) return -1 def solve(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: results = [] for case in test_cases: n, m, grid = case results.append(min_max_diff(grid, n, m)) return results def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, List[List[int]]]]]: data = input_string.split() index = 0 t = int(data[index]) index += 1 test_cases = [] for _ in range(t): n = int(data[index]) m = int(data[index + 1]) index += 2 grid = [] for i in range(n): grid.append(list(map(int, data[index:index + m]))) index += m test_cases.append((n, m, grid)) return t, test_cases","solution":"import heapq def min_max_diff(grid, n, m): directions = [(0, 1), (1, 0)] max_diff = [[float('inf')] * m for _ in range(n)] max_diff[0][0] = 0 heap = [(0, 0, 0)] while heap: diff, x, y = heapq.heappop(heap) if (x, y) == (n - 1, m - 1): return diff for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_diff = max(diff, abs(grid[nx][ny] - grid[x][y])) if new_diff < max_diff[nx][ny]: max_diff[nx][ny] = new_diff heapq.heappush(heap, (new_diff, nx, ny)) return -1 def solve(t, test_cases): results = [] for case in test_cases: n, m, grid = case results.append(min_max_diff(grid, n, m)) return results # Parsing input def parse_input(input_string): data = input_string.split() index = 0 t = int(data[index]) index += 1 test_cases = [] for _ in range(t): n = int(data[index]) m = int(data[index + 1]) index += 2 grid = [] for i in range(n): grid.append(list(map(int, data[index:index + m]))) index += m test_cases.append((n, m, grid)) return t, test_cases input_string = 2 2 2 1 3 4 2 3 3 8 5 9 7 3 6 2 4 1 t, test_cases = parse_input(input_string) output = solve(t, test_cases) for result in output: print(result)"},{"question":"def count_vowel_permutations(n: int) -> int: Count how many permutations of vowels of length n are possible under the given rules. The answer may be large, so return it modulo 10^9 + 7. >>> count_vowel_permutations(1) # should return 5 >>> count_vowel_permutations(2) # should return 10 >>> count_vowel_permutations(5) # should return 68","solution":"def count_vowel_permutations(n): MOD = 10**9 + 7 # Vowel indices: a -> 0, e -> 1, i -> 2, o -> 3, u -> 4 # dp state representing count of permutations ending in a, e, i, o, u dp = [[0]*5 for _ in range(n)] # Initial state: length 1, each vowel can be on its own for j in range(5): dp[0][j] = 1 # Transition rules for i in range(1, n): dp[i][0] = dp[i-1][1] % MOD # a can only follow e dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % MOD # e can follow a or i dp[i][2] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][3] + dp[i-1][4]) % MOD # i can follow a, e, o, u dp[i][3] = (dp[i-1][2] + dp[i-1][4]) % MOD # o can follow i or u dp[i][4] = dp[i-1][0] % MOD # u can follow a return sum(dp[n-1]) % MOD"},{"question":"def max_profit(prices): Determines the maximum profit that can be achieved from one transaction. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Determines the maximum profit that can be achieved from one transaction. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List import math def magnitude(complex_number: str) -> float: Calculates the magnitude of a complex number represented as a string. Args: complex_number (str): The complex number in the form 'a + bi' Returns: float: The magnitude of the complex number Example: >>> magnitude(\\"3 + 4i\\") 5.0 >>> magnitude(\\"1 + 1i\\") 1.4142135623730951 >>> magnitude(\\"0 + 0i\\") 0.0 pass from solution import magnitude def test_magnitude_positive_numbers(): assert magnitude(\\"3 + 4i\\") == 5.0 def test_magnitude_same_numbers(): assert magnitude(\\"1 + 1i\\") == 1.4142135623730951 def test_magnitude_zero(): assert magnitude(\\"0 + 0i\\") == 0.0 def test_magnitude_negative_numbers(): assert magnitude(\\"-3 + -4i\\") == 5.0 def test_magnitude_large_numbers(): assert magnitude(\\"3000 + 4000i\\") == 5000.0 def test_magnitude_with_spaces(): assert magnitude(\\" 3 + 4i \\") == 5.0 def test_magnitude_with_complex_signs(): assert magnitude(\\"-12 + 5i\\") == 13.0 assert magnitude(\\"3 + -3i\\") == 4.242640687119285","solution":"import math def magnitude(complex_number): Calculates the magnitude of a complex number represented as a string. Args: complex_number (str): The complex number in the form 'a + bi' Returns: float: The magnitude of the complex number # Remove the 'i' and split the string to extract 'a' and 'b' complex_number = complex_number.replace(\\"i\\", \\"\\") a_part, b_part = complex_number.split(\\"+\\") # Convert to integers a = int(a_part.strip()) b = int(b_part.strip()) # Calculate magnitude return math.sqrt(a**2 + b**2)"},{"question":"from typing import List def checkMatrixDiagonal(matrix: List[List[int]]) -> bool: Verify if all diagonals in a given MxN matrix contain the same value. >>> checkMatrixDiagonal([ ... [1, 2, 3], ... [4, 1, 2], ... [5, 4, 1] ... ]) True >>> checkMatrixDiagonal([ ... [1, 2, 3], ... [4, 1, 2], ... [5, 3, 1] ... ]) False >>> checkMatrixDiagonal([[1]]) True >>> checkMatrixDiagonal([ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ]) True >>> checkMatrixDiagonal([ ... [1, 2, 3, 4], ... [5, 1, 2, 3], ... [6, 5, 1, 2] ... ]) True >>> checkMatrixDiagonal([ ... [1, 2, 3, 4], ... [5, 1, 2, 3], ... [6, 5, 0, 2] ... ]) False >>> checkMatrixDiagonal([ ... [1, 2, 3, 4, 5], ... [6, 1, 2, 3, 4], ... [7, 6, 1, 2, 3], ... [8, 7, 6, 1, 2], ... [9, 8, 7, 6, 1] ... ]) True >>> checkMatrixDiagonal([ ... [1, 2, 3, 4, 5], ... [6, 1, 2, 3, 4], ... [7, 6, 2, 2, 3], ... [8, 7, 6, 1, 2], ... [9, 8, 7, 6, 1] ... ]) False","solution":"from typing import List def checkMatrixDiagonal(matrix: List[List[int]]) -> bool: def check_diagonal(i, j): value = matrix[i][j] while i < len(matrix) and j < len(matrix[0]): if matrix[i][j] != value: return False i += 1 j += 1 return True # Check diagonals starting from the first row for j in range(len(matrix[0])): if not check_diagonal(0, j): return False # Check diagonals starting from the first column (excluding the top-left element as it was already checked) for i in range(1, len(matrix)): if not check_diagonal(i, 0): return False return True"},{"question":"class Player: Represents a player in a sports league with a name and points scored. Attributes: name (str): The player's name. points (int): The points scored by the player. Must be non-negative. Methods: score_points(points: int): Adds the specified points to the player's total points. - Raises ValueError if points are negative. - Returns a string with the player's name and updated points. def __init__(self, name: str, points: int): # Initialize player with name and points pass def score_points(self, points: int) -> str: # Add points to player's total and return updated score message pass class Team: Represents a team in a sports league with a name and a roster of players. Attributes: name (str): The team's name. players (List[Player]): The list of players in the team. Methods: add_player(player: Player): Adds a player to the team's roster. - Returns a string confirming the player has been added. total_points() -> int: Calculates the total points scored by all players. top_scorer() -> Player: Finds and returns the player with the highest points. - Raises ValueError if there are no players. get_team_roster() -> List[str]: Lists all players' names in the team's roster. def __init__(self, name: str): # Initialize team with name and empty player list pass def add_player(self, player: Player) -> str: # Add player to team and return confirmation message pass def total_points(self) -> int: # Calculate and return total points of team pass def top_scorer(self) -> Player: # Find and return player with the highest score pass def get_team_roster(self) -> List[str]: # Return list of player names in team pass","solution":"class Player: def __init__(self, name, points): self.name = name if points < 0: raise ValueError(\\"Points cannot be negative\\") self.points = points def score_points(self, points): if points < 0: raise ValueError(\\"Points to score cannot be negative\\") self.points += points return f'{self.name} now has {self.points} points.' class Team: def __init__(self, name): self.name = name self.players = [] def add_player(self, player): self.players.append(player) return f'{player.name} has been added to the team {self.name}.' def total_points(self): return sum(player.points for player in self.players) def top_scorer(self): if not self.players: raise ValueError(\\"No players in the team\\") return max(self.players, key=lambda player: player.points) def get_team_roster(self): return [player.name for player in self.players]"},{"question":"[Completion Task in Python] from typing import List def top_k_frequent_words(words: List[str], k: int) -> List[str]: Given a list of words and a number k, return the k most frequently occurring words. If two words have the same frequency, return the words with the lower alphabetical order first. >>> top_k_frequent_words([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) ['i', 'love'] >>> top_k_frequent_words([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) ['the', 'is', 'sunny', 'day'] def test_top_k_frequent_words_example1(): assert top_k_frequent_words([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) == [\\"i\\", \\"love\\"] def test_top_k_frequent_words_example2(): assert top_k_frequent_words([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) == [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"] def test_top_k_frequent_words_tiebreaker(): assert top_k_frequent_words([\\"b\\", \\"a\\", \\"c\\", \\"b\\", \\"a\\", \\"b\\"], 2) == [\\"b\\", \\"a\\"] def test_top_k_frequent_words_single_word(): assert top_k_frequent_words([\\"word\\"], 1) == [\\"word\\"] def test_top_k_frequent_words_all_unique(): assert top_k_frequent_words([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 2) == [\\"a\\", \\"b\\"] def test_top_k_frequent_words_mixed(): assert top_k_frequent_words([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"kiwi\\", \\"kiwi\\", \\"kiwi\\", \\"banana\\"], 3) == [\\"banana\\", \\"kiwi\\", \\"apple\\"]","solution":"from typing import List from collections import Counter def top_k_frequent_words(words: List[str], k: int) -> List[str]: Returns the k most frequently occurring words in the input list 'words'. If two words have the same frequency, they are ordered lexicographically. counts = Counter(words) # Sort by frequency first (descending) then by alphabetical order (ascending) sorted_words = sorted(counts.keys(), key=lambda word: (-counts[word], word)) return sorted_words[:k]"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequently occurring character in the string s. In case of a tie, returns the character which appears first in the string. >>> most_frequent_character(\\"character\\") 'c' >>> most_frequent_character(\\"aabbcc\\") 'a' >>> most_frequent_character(\\"abcdefg\\") 'a' >>> most_frequent_character(\\"abacabad\\") 'a' >>> most_frequent_character(\\"a\\") 'a'","solution":"def most_frequent_character(s): Returns the most frequently occurring character in the string s. In case of a tie, returns the character which appears first in the string. from collections import Counter # count the frequency of each character counts = Counter(s) # find the character with maximum frequency max_count = max(counts.values()) # iterate over the string to find the first character with the maximum frequency for char in s: if counts[char] == max_count: return char"},{"question":"def max_difference(arr: List[int]) -> int: Finds the maximum difference between any two elements in the list such that the larger element comes after the smaller element. :param arr: List of integers :return: Maximum difference or -1 if no such elements exist Example: >>> max_difference([1, 2, 90, 10, 110, 5]) 109 >>> max_difference([4, 3, 2, 1, 0]) -1","solution":"def max_difference(arr): Finds the maximum difference between any two elements in the list such that the larger element comes after the smaller element. :param arr: List of integers :return: Maximum difference or -1 if no such elements exist if not arr or len(arr) < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"from typing import Tuple def sum_of_two_numbers(a: int, b: int) -> int: Accepts two integers a and b, and returns their sum. >>> sum_of_two_numbers(12, 34) 46 >>> sum_of_two_numbers(0, 50) 50 >>> sum_of_two_numbers(100000, 100000) 200000 >>> sum_of_two_numbers(1, 2) 3 >>> sum_of_two_numbers(0, 0) 0 pass","solution":"def sum_of_two_numbers(a, b): Accepts two integers a and b, and returns their sum. return a + b"},{"question":"def find_missing_number(arr): Finds the missing number in an array containing integers ranging from 1 to n (inclusive) with one missing number. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 3, 4, 5, 6, 7]) 8 >>> find_missing_number([2, 3, 4, 5, 6, 7, 8]) 1 def test_missing_number_middle(): arr = [3, 7, 1, 2, 8, 4, 5] assert find_missing_number(arr) == 6 def test_missing_number_last(): arr = [1, 2, 3, 4, 5, 6, 7] assert find_missing_number(arr) == 8 def test_missing_number_first(): arr = [2, 3, 4, 5, 6, 7, 8] assert find_missing_number(arr) == 1 def test_single_element_missing(): arr = [] assert find_missing_number(arr) == 1 def test_two_element_missing(): arr = [1] assert find_missing_number(arr) == 2 def test_large_numbers(): arr = list(range(1, 100001)) # Missing last element arr.remove(99999) assert find_missing_number(arr) == 99999","solution":"def find_missing_number(arr): Finds the missing number in an array containing integers ranging from 1 to n (inclusive) with one missing number. Parameters: arr (list): The input array containing n-1 integers from 1 to n Returns: int: The missing integer n = len(arr) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(arr) missing_number = total_sum - actual_sum return missing_number"},{"question":"def find_smallest_largest_subarray_sums(arr): Returns the smallest and largest subarray sums for a given array. Args: arr (List[int]): The array of integers. Returns: Tuple[int, int]: A tuple containing the smallest and the largest subarray sums. Examples: >>> find_smallest_largest_subarray_sums([1, 2, 3]) (1, 6) >>> find_smallest_largest_subarray_sums([-1, -2, -3, -4, -5]) (-15, -1) def process_test_cases(T, test_cases): Processes multiple test cases and returns the results. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing the size of the array and the array itself. Returns: List[str]: A list containing the results for each test case in the format \\"smallest_sum largest_sum\\". Examples: >>> process_test_cases(2, [(3, [1, 2, 3]), (5, [-1, -2, -3, -4, -5])]) [\\"1 6\\", \\"-15 -1\\"] >>> process_test_cases(1, [(4, [0, 0, 0, 0])]) [\\"0 0\\"]","solution":"def find_smallest_largest_subarray_sums(arr): Returns the smallest and largest subarray sums for a given array. min_sum = float('inf') max_sum = float('-inf') current_min_sum = 0 current_max_sum = 0 for num in arr: current_min_sum += num if current_min_sum < min_sum: min_sum = current_min_sum if current_min_sum > 0: current_min_sum = 0 current_max_sum += num if current_max_sum > max_sum: max_sum = current_max_sum if current_max_sum < 0: current_max_sum = 0 return min_sum, max_sum def process_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] min_sum, max_sum = find_smallest_largest_subarray_sums(arr) results.append(f\\"{min_sum} {max_sum}\\") return results"},{"question":"def min_operations_to_unify_string(n: int, S: str) -> int: Determine the minimum number of operations required to make all characters of the string the same. >>> min_operations_to_unify_string(4, \\"abba\\") 2 >>> min_operations_to_unify_string(5, \\"aabaa\\") 1 >>> min_operations_to_unify_string(10, \\"abcdefghij\\") 9","solution":"def min_operations_to_unify_string(n, S): Determine the minimum number of operations required to make all characters of the string the same. max_char_count = max(S.count(char) for char in set(S)) return n - max_char_count"},{"question":"def longest_substring_without_repeating_characters(s: str) -> int: Takes a string \`s\` of length \`n\` (2 ≤ n ≤ 1000) as input and returns the length of the longest substring without repeating characters. You may assume that all characters in the string are ASCII characters. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_characters(\\"au\\") 2 >>> longest_substring_without_repeating_characters(\\"aab\\") 2 >>> longest_substring_without_repeating_characters(\\"abcdef\\") 6 >>> longest_substring_without_repeating_characters(\\"abba\\") 2 >>> longest_substring_without_repeating_characters(\\"abcdefghijklmnopqrstuvwxyz\\" * 10) 26 >>> longest_substring_without_repeating_characters(\\"dvdf\\") 3 pass","solution":"def longest_substring_without_repeating_characters(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string of length n (2 ≤ n ≤ 1000). Returns: int: The length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"def k_rotation(arr: List[int], k: int) -> List[int]: Returns the k-rotated version of the array. >>> k_rotation([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> k_rotation([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> k_rotation([1, 2, 3, 4, 5], 12) [4, 5, 1, 2, 3]","solution":"from typing import List def k_rotation(arr: List[int], k: int) -> List[int]: Returns the k-rotated version of the array. n = len(arr) k = k % n # Optimize k to be within the length of the array return arr[-k:] + arr[:-k]"},{"question":"def move(direction: str, steps: int) -> tuple: Given a direction (\\"N\\", \\"S\\", \\"E\\", \\"W\\") and a step size, calculates and returns the new coordinates (x, y) on a Cartesian plane starting from the origin (0, 0). >>> move(\\"N\\", 3) == (0, 3) >>> move(\\"S\\", 2) == (0, -2) >>> move(\\"E\\", 5) == (5, 0) >>> move(\\"W\\", 4) == (-4, 0)","solution":"def move(direction, steps): Given a direction (\\"N\\", \\"S\\", \\"E\\", \\"W\\") and a step size, calculates and returns the new coordinates (x, y) on a Cartesian plane starting from the origin (0, 0). if direction == \\"N\\": return (0, steps) elif direction == \\"S\\": return (0, -steps) elif direction == \\"E\\": return (steps, 0) elif direction == \\"W\\": return (-steps, 0) else: raise ValueError(\\"Invalid direction\\")"},{"question":"def primes_less_than(n: int) -> List[int]: Returns an array of all prime numbers less than n. Examples: >>> primes_less_than(10) [2, 3, 5, 7] >>> primes_less_than(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes_less_than(2) []","solution":"def primes_less_than(n): Returns an array of all prime numbers less than n. if n <= 2: return [] primes = [] is_prime = [True] * n is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers for i in range(2, n): if is_prime[i]: primes.append(i) for j in range(i * i, n, i): is_prime[j] = False return primes"},{"question":"def min_subarray_len(nums: List[int], k: int) -> int: Finds the minimal length of a contiguous subarray for which the sum is greater than or equal to k. If no such subarray exists, returns -1. Args: nums: List of integers. k: The target sum. Returns: The minimal length of a contiguous subarray for which the sum is greater than or equal to k, or -1 if no such subarray exists. Examples: >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) -1","solution":"def min_subarray_len(nums, k): Finds the minimal length of a contiguous subarray for which the sum is greater than or equal to k. If no such subarray exists, returns -1. n = len(nums) start = 0 current_sum = 0 min_length = float('inf') for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def canFormPalindrome(s: str) -> bool: Returns True if the string's characters can be rearranged to form a palindrome, and False otherwise. >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"hello\\") False >>> canFormPalindrome(\\"\\") True >>> canFormPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> canFormPalindrome(\\"No 'x' in Nixon\\") True >>> canFormPalindrome(\\"?a?a?\\") True >>> canFormPalindrome(\\"!@@!\\") True","solution":"def canFormPalindrome(s): Returns True if the string's characters can be rearranged to form a palindrome, and False otherwise. s = s.lower() char_count = {} for char in s: if char.isalnum(): # ignore non-alphanumeric characters char_count[char] = char_count.get(char, 0) + 1 odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return False return True"},{"question":"def count_characters(s: str) -> list: Function to count the frequency of characters in the input string and return a list of tuples where each tuple contains a character and its frequency in the order they first appear in the string. Parameters: s (str): Input string Returns: list: List of tuples with character and its frequency >>> count_characters(\\"abracadabra\\") [('a', 5), ('b', 2), ('r', 2), ('c', 1), ('d', 1)] >>> count_characters(\\"aaaa\\") [('a', 4)] >>> count_characters(\\"\\") [] >>> count_characters(\\"abc\\") [('a', 1), ('b', 1), ('c', 1)] >>> count_characters(\\"abca\\") [('a', 2), ('b', 1), ('c', 1)] >>> count_characters(\\"a b c a\\") [('a', 2), (' ', 3), ('b', 1), ('c', 1)] from collections import Counter def test_count_characters_example(): assert count_characters(\\"abracadabra\\") == [('a', 5), ('b', 2), ('r', 2), ('c', 1), ('d', 1)] def test_count_characters_single_char(): assert count_characters(\\"aaaa\\") == [('a', 4)] def test_count_characters_empty(): assert count_characters(\\"\\") == [] def test_count_characters_unique_chars(): assert count_characters(\\"abc\\") == [('a', 1), ('b', 1), ('c', 1)] def test_count_characters_mixed_chars(): assert count_characters(\\"abca\\") == [('a', 2), ('b', 1), ('c', 1)] def test_count_characters_with_spaces(): assert count_characters(\\"a b c a\\") == [('a', 2), (' ', 3), ('b', 1), ('c', 1)]","solution":"def count_characters(s): Function to count the frequency of characters in the input string and return a list of tuples where each tuple contains a character and its frequency in the order they first appear in the string. Parameters: s (str): Input string Returns: list: List of tuples with character and its frequency from collections import Counter counter = Counter(s) seen = set() result = [] for char in s: if char not in seen: result.append((char, counter[char])) seen.add(char) return result"},{"question":"def decode_cryptic_note(encoded_message: str) -> str: Decodes a caesar cipher encoded message with a shift of 3 positions. >>> decode_cryptic_note('d') 'a' >>> decode_cryptic_note('g') 'd' >>> decode_cryptic_note('z') 'w' >>> decode_cryptic_note('D') 'A' >>> decode_cryptic_note('G') 'D' >>> decode_cryptic_note('Z') 'W' >>> decode_cryptic_note('Khoor') 'Hello' >>> decode_cryptic_note('Zruog') 'World' >>> decode_cryptic_note('Khoor, Zruog!') 'Hello, World!' >>> decode_cryptic_note('Khoor zruog') 'Hello world' >>> decode_cryptic_note('') ''","solution":"def decode_cryptic_note(encoded_message): Decodes a caesar cipher encoded message with a shift of 3 positions. shift = 3 decoded_message = [] for char in encoded_message: if char.isalpha(): # Shift character shifted_char = chr((ord(char) - shift - 97) % 26 + 97) if char.islower() else chr((ord(char) - shift - 65) % 26 + 65) decoded_message.append(shifted_char) else: # Non-alphabetic characters remain the same decoded_message.append(char) return ''.join(decoded_message)"},{"question":"from typing import List def find_two_sum(numbers: List[int], target: int) -> List[int]: Complete the function that takes a list of integers and a target integer as input, and returns the indices of the two numbers such that they add up to the target. >>> find_two_sum([2, 7, 11, 15], 9) == [0, 1] >>> find_two_sum([3, 2, 4], 6) == [1, 2] >>> find_two_sum([3, 3], 6) == [0, 1]","solution":"from typing import List def find_two_sum(numbers: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to the target. num_dict = {} for i, num in enumerate(numbers): complement = target - num if complement in num_dict: return [num_dict[complement], i] num_dict[num] = i return []"},{"question":"from typing import List def extract_primes(arr: List[int]) -> List[int]: Write a function that accepts an array of integers and returns a new array containing only the prime numbers from the input array, preserving the original order. A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. >>> extract_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> extract_primes([11, 13, 17, 19, 22, 23, 25, 28, 29]) [11, 13, 17, 19, 23, 29] >>> extract_primes([4, 6, 8, 9, 10, 12]) [] >>> extract_primes([1, 2, 3, 4, 5, 0, -1, -3, 11, 13]) [2, 3, 5, 11, 13] >>> extract_primes([2]) [2] >>> extract_primes([4]) [] >>> extract_primes([101, 103, 107, 109, 113]) [101, 103, 107, 109, 113]","solution":"from typing import List def is_prime(n: int) -> bool: Check if a given number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n ** 0.5) + 1 for divisor in range(3, max_divisor, 2): if n % divisor == 0: return False return True def extract_primes(arr: List[int]) -> List[int]: Returns a list of prime numbers from the input array. return [num for num in arr if is_prime(num)]"},{"question":"def factorial(n: int) -> str: Returns the factorial of the given non-negative integer \`n\` as a string. >>> factorial(0) '1' >>> factorial(5) '120' >>> factorial(10) '3628800'","solution":"def factorial(n): Returns the factorial of the given non-negative integer \`n\` as a string. if n == 0: return \\"1\\" result = 1 for i in range(1, n + 1): result *= i return str(result)"},{"question":"import pytest from typing import List, Tuple def detect_cycles_in_graphs(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determines whether each test case contains any cycles in its graph. Parameters: T (int): Number of test cases test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List containing the details of each test case. Returns: List[str]: List containing either \\"YES\\" if the graph contains a cycle, or \\"NO\\" if it does not. >>> detect_cycles_in_graphs(3, [(3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 2, [(1, 2), (3, 4)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) ['YES', 'NO', 'NO'] >>> detect_cycles_in_graphs(2, [(3, 0, []), (4, 0, [])]) ['NO', 'NO'] pass def test_sample_cases(): T = 3 test_cases = [ (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 2, [(1, 2), (3, 4)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) ] expected = [\\"YES\\", \\"NO\\", \\"NO\\"] assert detect_cycles_in_graphs(T, test_cases) == expected def test_no_edges(): T = 2 test_cases = [ (3, 0, []), (4, 0, []) ] expected = [\\"NO\\", \\"NO\\"] assert detect_cycles_in_graphs(T, test_cases) == expected def test_single_cycle(): T = 1 test_cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) ] expected = [\\"YES\\"] assert detect_cycles_in_graphs(T, test_cases) == expected def test_disconnected_components(): T = 2 test_cases = [ (6, 4, [(1, 2), (1, 3), (4, 5), (5, 6)]), (6, 5, [(1, 2), (1, 3), (2, 3), (4, 5), (5, 6)]) ] expected = [\\"NO\\", \\"YES\\"] assert detect_cycles_in_graphs(T, test_cases) == expected def test_complete_graph(): T = 1 V = 4 E = 6 edges = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] test_cases = [(V, E, edges)] expected = [\\"YES\\"] assert detect_cycles_in_graphs(T, test_cases) == expected","solution":"def has_cycle_in_graph(V, adjacency_list): visited = [False] * V def dfs(current, parent): visited[current] = True for neighbor in adjacency_list[current]: if not visited[neighbor]: if dfs(neighbor, current): return True elif neighbor != parent: return True return False for vertex in range(V): if not visited[vertex]: if dfs(vertex, -1): return True return False def detect_cycles_in_graphs(T, test_cases): results = [] for V, E, edges in test_cases: adjacency_list = [[] for _ in range(V)] for u, v in edges: adjacency_list[u - 1].append(v - 1) adjacency_list[v - 1].append(u - 1) if has_cycle_in_graph(V, adjacency_list): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def character_frequencies(s: str): Given a string consisting of lowercase alphabets and spaces, find the frequency of each distinct character in the string. Return the frequencies as a dictionary where the keys are the characters and the values are the respective counts. Additionally, find the character(s) with the highest frequency. If multiple characters have the same maximum frequency, return them all in sorted order. >>> character_frequencies(\\"the quick brown fox jumps over the lazy dog\\") ( { 't': 2, 'h': 2, 'e': 3, 'q': 1, 'u': 2, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 2, 'o': 4, 'w': 1, 'n': 1, 'f': 1, 'x': 1, 'j': 1, 'm': 1, 'p': 1, 's': 1, 'v': 1, 'l': 1, 'a': 1, 'z': 1, 'y': 1, 'd': 1, 'g': 1 }, ['o'] ) >>> character_frequencies(\\"banana\\") ( { 'b': 1, 'a': 3, 'n': 2 }, ['a'] ) >>> character_frequencies(\\"aabbcc\\") ( { 'a': 2, 'b': 2, 'c': 2 }, ['a', 'b', 'c'] )","solution":"def character_frequencies(s): Returns a tuple containing: - A dictionary with the frequencies of each character in the string - A list of characters with the highest frequency in sorted order frequencies = {} for char in s: if char != ' ': # Ignore spaces if char in frequencies: frequencies[char] += 1 else: frequencies[char] = 1 if not frequencies: return frequencies, [] max_freq = max(frequencies.values()) max_chars = [char for char, count in frequencies.items() if count == max_freq] return frequencies, sorted(max_chars)"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list where each integer is replaced by the product of all the integers in the original list except the integer at that position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 6, 7, 8]) [336, 280, 240, 210] >>> product_except_self([2, 3, 4]) [12, 8, 6] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([]) []","solution":"def product_except_self(nums): Takes a list of integers and returns a new list where each integer is replaced by the product of all the integers in the original list except the integer at that position. if not nums: return [] length = len(nums) result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def modify_list(int_list: List[int], x: int) -> List[int]: This function takes a list of integers and a multiplier x. It returns a new list where each even integer is multiplied by x. Odd integers remain unchanged. >>> modify_list([1, 2, 3, 4], 2) [1, 4, 3, 8] >>> modify_list([7, 8, 10, 13], 3) [7, 24, 30, 13] >>> modify_list([0, -2, -3, 5], 5) [0, -10, -3, 5] from typing import List def test_modify_list_example_cases(): assert modify_list([1, 2, 3, 4], 2) == [1, 4, 3, 8] assert modify_list([7, 8, 10, 13], 3) == [7, 24, 30, 13] assert modify_list([0, -2, -3, 5], 5) == [0, -10, -3, 5] def test_modify_list_with_all_even_numbers(): assert modify_list([2, 4, 6, 8], 2) == [4, 8, 12, 16] assert modify_list([-2, -4, -6, -8], 2) == [-4, -8, -12, -16] def test_modify_list_with_all_odd_numbers(): assert modify_list([1, 3, 5, 7], 2) == [1, 3, 5, 7] assert modify_list([-1, -3, -5, -7], 2) == [-1, -3, -5, -7] def test_modify_list_with_zero_multiplier(): assert modify_list([2, 4, 6], 0) == [0, 0, 0] assert modify_list([1, 3, 5], 0) == [1, 3, 5] def test_modify_list_with_empty_list(): assert modify_list([], 10) == [] def test_modify_list_with_mixed_numbers(): assert modify_list([10, -5, 20, 1], 3) == [30, -5, 60, 1] assert modify_list([0, 2, -4, 5], 4) == [0, 8, -16, 5]","solution":"def modify_list(int_list, x): This function takes a list of integers and a multiplier x. It returns a new list where each even integer is multiplied by x. Odd integers remain unchanged. return [num * x if num % 2 == 0 else num for num in int_list]"},{"question":"def combination_sum2(candidates: List[int], target: int) -> List[List[int]]: Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. Each number in candidates may only be used once in the combination. >>> combination_sum2([10,1,2,7,6,1,5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combination_sum2([2,5,2,1,2], 5) [[1, 2, 2], [5]] >>> combination_sum2([2, 3, 5], 8) [[3, 5]]","solution":"def combination_sum2(candidates, target): candidates.sort() res = [] def backtrack(start, target, path): if target == 0: res.append(path) return for i in range(start, len(candidates)): if i > start and candidates[i] == candidates[i-1]: continue if candidates[i] > target: break backtrack(i + 1, target - candidates[i], path + [candidates[i]]) backtrack(0, target, []) return res"},{"question":"def count_derangements(n: int) -> int: Returns the number of derangements for n friends. >>> count_derangements(0) 1 >>> count_derangements(1) 0 >>> count_derangements(2) 1 >>> count_derangements(3) 2 >>> count_derangements(4) 9","solution":"def count_derangements(n): Returns the number of derangements for n friends. if n == 0: return 1 elif n == 1: return 0 derangements = [0] * (n + 1) derangements[0] = 1 derangements[1] = 0 for i in range(2, n + 1): derangements[i] = (i - 1) * (derangements[i - 1] + derangements[i - 2]) return derangements[n]"},{"question":"def find_closest_product(products: List[int], query: int) -> int: Finds the product identifier closest to the query. If multiple identifiers are equidistant to the query, return the smallest one. :param products: List[int] - A sorted list of unique product identifiers. :param query: int - The target query. :return: int - The product identifier closest to the query. Examples: >>> find_closest_product([1, 2, 4, 5, 6, 8, 9], 7) 6 >>> find_closest_product([1, 3, 5, 8, 10], 6) 5 >>> find_closest_product([2, 4, 6, 8], 5) 4 >>> find_closest_product([100, 200, 300, 400], 250) 200 left, right = 0, len(products) - 1 while left < right: mid = (left + right) // 2 if products[mid] == query: return products[mid] elif products[mid] < query: left = mid + 1 else: right = mid closest = products[left] if left > 0 and abs(products[left - 1] - query) <= abs(closest - query): closest = products[left - 1] return closest","solution":"def find_closest_product(products, query): Finds the product identifier closest to the query. If multiple identifiers are equidistant to the query, return the smallest one. :param products: List[int] - A sorted list of unique product identifiers. :param query: int - The target query. :return: int - The product identifier closest to the query. left, right = 0, len(products) - 1 while left < right: mid = (left + right) // 2 if products[mid] == query: return products[mid] elif products[mid] < query: left = mid + 1 else: right = mid # After binary search, left is the best candidate index. closest = products[left] # Check the candidate and its predecessor (if exists) if left > 0 and abs(products[left - 1] - query) <= abs(closest - query): closest = products[left - 1] return closest"},{"question":"def find(parent, node): Helper function to find the root of the node in the disjoint set. pass def union(parent, rank, node1, node2): Helper function to union two subsets in the disjoint set. pass def kruskal(N, edges): Function to calculate the cost of the Minimum Spanning Tree using Kruskal's algorithm. pass def is_connected_after_removal(N, edges, remove_edge): Function to check if the graph remains connected after removing a specified edge. pass def solve(): Function to solve the problem as per the given input and output format. pass from io import StringIO import sys def test_sample_case(): input = StringIO(1 4 5 1 2 3 1 3 4 2 3 2 3 4 5 2 4 6 3 1 2 2 3 3 4 ) sys.stdin = input solve() def test_another_case(): input = StringIO(1 4 4 1 2 1 2 3 1 3 4 1 4 1 1 2 1 2 3 4 ) sys.stdin = input solve()","solution":"from heapq import heappop, heappush from collections import defaultdict, deque def find(parent, node): if parent[node] == node: return node root = find(parent, parent[node]) parent[node] = root return root def union(parent, rank, node1, node2): root1 = find(parent, node1) root2 = find(parent, node2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 def kruskal(N, edges): edges.sort(key=lambda x: x[2]) parent = list(range(N)) rank = [0] * N mst_cost = 0 for u, v, w in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w return mst_cost def is_connected_after_removal(N, edges, remove_edge): graph = defaultdict(list) for u, v, w in edges: if (u, v) != remove_edge and (v, u) != remove_edge: graph[u].append(v) graph[v].append(u) # BFS to check connectivity visited = set() queue = deque([0]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == N def solve(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): N = int(data[index]) M = int(data[index + 1]) index += 2 edges = [] for _ in range(M): u = int(data[index]) - 1 v = int(data[index + 1]) - 1 w = int(data[index + 2]) edges.append((u, v, w)) index += 3 Q = int(data[index]) index += 1 queries = [] for _ in range(Q): u = int(data[index]) - 1 v = int(data[index + 1]) - 1 queries.append((u, v)) index += 2 # Minimum Spanning Tree (MST) cost mst_cost = kruskal(N, edges) results.append(str(mst_cost)) for u, v in queries: if is_connected_after_removal(N, edges, (u, v)): results.append(\\"Connected\\") else: results.append(\\"Disconnected\\") print(\\"n\\".join(results))"},{"question":"def transform_words(s: str) -> str: Create a string where each word is replaced by its length, and words alternate between lowercase and uppercase. >>> transform_words(\\"hello world\\") \\"5 5\\" >>> transform_words(\\"Code Assessments Are Fun\\") \\"4 11 3 3\\" >>> transform_words(\\"I love Coding\\") \\"1 4 6\\"","solution":"def transform_words(s: str) -> str: words = s.split() transformed_words = [] for i, word in enumerate(words): length_word = str(len(word)) if i % 2 == 0: transformed_words.append(length_word.lower()) else: transformed_words.append(length_word.upper()) return ' '.join(transformed_words)"},{"question":"def canWaterPlants(plantNeeds: List[int], availableWater: int) -> str: Determines if it's possible to water all the plants with the available water. Args: plantNeeds (list): List of integers where each integer represents the water requirement of a particular plant. availableWater (int): Total water available for the week. Returns: str: \\"Possible\\" if the available water is enough to water all the plants, otherwise \\"Impossible\\". Examples: >>> canWaterPlants([10, 20, 30], 60) \\"Possible\\" >>> canWaterPlants([10, 20, 30], 50) \\"Impossible\\"","solution":"def canWaterPlants(plantNeeds, availableWater): Determines if it's possible to water all the plants with the available water. Args: plantNeeds (list): List of integers where each integer represents the water requirement of a particular plant. availableWater (int): Total water available for the week. Returns: str: \\"Possible\\" if the available water is enough to water all the plants, otherwise \\"Impossible\\". totalWaterRequired = sum(plantNeeds) if totalWaterRequired <= availableWater: return \\"Possible\\" else: return \\"Impossible\\""},{"question":"def filter_long_strings(strings: List[str], n: int) -> List[str]: Filters the list of strings to only include strings with length greater than or equal to n. Parameters: strings (list of str): The list of strings to filter. n (int): The minimum length of string to include in the result. Returns: list of str: A new list with strings of length greater than or equal to n. >>> filter_long_strings([\\"apple\\", \\"bat\\", \\"car\\", \\"doghouse\\"], 4) ['apple', 'doghouse']","solution":"def filter_long_strings(strings, n): Filters the list of strings to only include strings with length greater than or equal to n. Parameters: strings (list of str): The list of strings to filter. n (int): The minimum length of string to include in the result. Returns: list of str: A new list with strings of length greater than or equal to n. return [string for string in strings if len(string) >= n]"},{"question":"import re def isPalindrome(s: str) -> bool: Write a function isPalindrome that takes a string as input and returns a boolean indicating whether the string is a palindrome (a word, phrase, or sequence that reads the same backwards as forwards, ignoring spaces, punctuation, and capitalization). >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> isPalindrome(\\"Hello, World!\\") False","solution":"import re def isPalindrome(s): Returns True if s is a palindrome, False otherwise. Ignores spaces, punctuation, and capitalization. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def fibonacci(n): Returns the nth Fibonacci number. If the input is not an integer or is less than or equal to 0, returns \\"Invalid input\\". >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(10) 55 >>> fibonacci(-1) \\"Invalid input\\" >>> fibonacci(0) \\"Invalid input\\" >>> fibonacci(\\"a\\") \\"Invalid input\\"","solution":"def fibonacci(n): Returns the nth Fibonacci number. If the input is not an integer or is less than or equal to 0, returns \\"Invalid input\\". if not isinstance(n, int) or n <= 0: return \\"Invalid input\\" if n == 1 or n == 2: return 1 a, b = 1, 1 for _ in range(3, n + 1): a, b = b, a + b return b"},{"question":"def sum_of_digits_of_power(a: int, b: int) -> int: Returns the sum of the digits of a raised to the power of b. >>> sum_of_digits_of_power(2, 3) 8 >>> sum_of_digits_of_power(10, 2) 1 def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Process a list of test cases and return the results. >>> process_test_cases([(2, 3), (10, 2)]) [8, 1] >>> process_test_cases([(3, 3), (5, 3)]) [9, 8]","solution":"def sum_of_digits_of_power(a, b): Returns the sum of the digits of a raised to the power of b. power_result = a ** b digits_sum = sum(map(int, str(power_result))) return digits_sum def process_test_cases(test_cases): Process a list of test cases and return the results. results = [] for a, b in test_cases: results.append(sum_of_digits_of_power(a, b)) return results"},{"question":"from typing import List def palindromic_permutations_count(t: int, cases: List[str]) -> List[int]: Returns the number of distinct palindromic permutations for each input string in cases. >>> palindromic_permutations_count(2, ['aabb', 'abc']) [2, 0] >>> palindromic_permutations_count(1, ['abccba']) [6] # You can use test cases to verify your implementation from solution import palindromic_permutations_count def test_single_character(): assert palindromic_permutations_count(1, ['a']) == [1] def test_two_same_characters(): assert palindromic_permutations_count(1, ['aa']) == [1] def test_no_palindromic_permutations(): assert palindromic_permutations_count(1, ['abc']) == [0] def test_two_palindromic_permutations(): assert palindromic_permutations_count(1, ['aabb']) == [2] assert palindromic_permutations_count(1, ['abab']) == [2] def test_multiple_test_cases(): assert palindromic_permutations_count(2, ['aabb', 'abc']) == [2, 0] def test_complex_case(): assert palindromic_permutations_count(1, ['aabcc']) == [2] assert palindromic_permutations_count(1, ['aaabbbbccc']) == [0] def test_odd_count_permutations(): assert palindromic_permutations_count(1, ['aabbc']) == [2] assert palindromic_permutations_count(1, ['abccba']) == [6]","solution":"from collections import Counter from math import factorial from functools import reduce from operator import mul def num_palindromic_permutations(S): Returns the number of distinct palindromic permutations of the input string S. # Count the occurrences of each character char_count = Counter(S) # Count how many characters have an odd number of appearances odd_count_chars = sum(1 for count in char_count.values() if count % 2 != 0) # If more than one character has an odd count, we cannot form a palindrome if odd_count_chars > 1: return 0 # Calculating the number of permutations # Divide the counts by 2 (since each palindrome half will reflect the other) half_counts = [count // 2 for count in char_count.values()] # Number of characters in the \\"half\\" string half_len = sum(half_counts) # The number of palindromic permutations is calculated by permutations formula divided by factorials of each count numerator = factorial(half_len) denominator = reduce(mul, (factorial(count) for count in half_counts if count > 0), 1) return numerator // denominator def palindromic_permutations_count(t, cases): results = [] for s in cases: results.append(num_palindromic_permutations(s)) return results"},{"question":"def sudoku_validator(grid): Function to validate a 9x9 Sudoku grid. The grid must be valid so that each row, each column, and each 3x3 sub-grid contain the numbers 1 to 9 with no duplicates. Args: grid (List[List[int]]): A 9x9 Sudoku grid represented as a list of lists. Returns: bool: True if the grid is valid, False otherwise. Examples: >>> sudoku_validator([[5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9]]) == True >>> sudoku_validator([[8, 3, 5, 4, 1, 6, 9, 2, 7], [2, 9, 6, 8, 5, 7, 4, 3, 1], [4, 1, 7, 9, 3, 2, 5, 8, 6], [5, 6, 9, 1, 2, 3, 7, 4, 8], [7, 2, 3, 6, 8, 4, 1, 9, 5], [1, 8, 4, 5, 7, 9, 6, 3, 2], [9, 7, 1, 3, 6, 8, 2, 5, 4], [3, 5, 2, 7, 4, 1, 8, 6, 9], [6, 4, 8, 2, 9, 5, 3, 7, 1]]) == False","solution":"def sudoku_validator(grid): def is_valid_line(line): elements = [num for num in line if num != 0] return len(elements) == len(set(elements)) def is_valid_subgrid(grid, start_row, start_col): elements = [] for i in range(3): for j in range(3): num = grid[start_row + i][start_col + j] if num != 0: elements.append(num) return len(elements) == len(set(elements)) for row in grid: if not is_valid_line(row): return False for col in range(9): if not is_valid_line([grid[row][col] for row in range(9)]): return False for row in range(0, 9, 3): for col in range(0, 9, 3): if not is_valid_subgrid(grid, row, col): return False return True"},{"question":"def dailyTemperatures(temperatures): Returns an array of integers answer where answer[i] is the number of days until a warmer temperature or 0 if there is none, given an array of integers temperatures representing the daily temperatures. >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> dailyTemperatures([30, 20, 10, 5]) [0, 0, 0, 0] from solution import dailyTemperatures def test_example_cases(): assert dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] assert dailyTemperatures([30, 40, 50, 60]) == [1, 1, 1, 0] assert dailyTemperatures([30, 20, 10, 5]) == [0, 0, 0, 0] def test_mix_cases(): assert dailyTemperatures([30, 60, 90, 30, 60, 30, 90]) == [1, 1, 0, 1, 2, 1, 0] assert dailyTemperatures([70, 71, 76, 78, 76, 79, 80]) == [1, 1, 1, 2, 1, 1, 0] def test_all_same_temperature(): assert dailyTemperatures([70, 70, 70, 70]) == [0, 0, 0, 0] def test_single_element(): assert dailyTemperatures([70]) == [0]","solution":"def dailyTemperatures(temperatures): Returns an array of integers answer where answer[i] is the number of days until a warmer temperature or 0 if there is none, given an array of integers temperatures representing the daily temperatures. answer = [0] * len(temperatures) stack = [] # pairs: (index, temperature) for i, temp in enumerate(temperatures): while stack and temp > stack[-1][1]: index, _ = stack.pop() answer[index] = i - index stack.append((i, temp)) return answer"},{"question":"def daily_temperatures(temps: List[int]) -> List[int]: Given a list of daily temperatures, return a list of how many days you would have to wait until a warmer temperature. If there is no such day, put 0. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([73]) [0] >>> daily_temperatures([70, 72, 75, 78, 80]) [1, 1, 1, 1, 0] >>> daily_temperatures([80, 78, 75, 72, 70]) [0, 0, 0, 0, 0] >>> daily_temperatures([70, 70, 70, 70, 70]) [0, 0, 0, 0, 0] >>> daily_temperatures([73, 71, 70, 74, 76]) [3, 2, 1, 1, 0] >>> daily_temperatures([70, 72, 70, 72, 70, 72]) [1, 0, 1, 0, 1, 0] >>> daily_temperatures([-10, -20, -30, -40, 0]) [4, 3, 2, 1, 0]","solution":"def daily_temperatures(temps): Given a list of daily temperatures, return a list of how many days you would have to wait until a warmer temperature. If there is no such day, put 0. n = len(temps) result = [0] * n stack = [] for i in range(n): while stack and temps[i] > temps[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing non-negative integers, addition (+), subtraction (-), multiplication (*), and division (/) operators, and respecting the standard order of operations (PEMDAS/BODMAS). >>> evaluate_expression(\\"2+3*4\\") # returns 14 >>> evaluate_expression(\\"10+2*6\\") # returns 22 >>> evaluate_expression(\\"100*2+12\\") # returns 212 >>> evaluate_expression(\\"100*(2+12)\\") # returns 1400 >>> evaluate_expression(\\"100*(2+12)/14\\") # returns 100 >>> evaluate_expression(\\"4+18/2*3\\") # returns 31 >>> evaluate_expression(\\"3+5/2\\") # returns 5 >>> evaluate_expression(\\"20/(3+2)\\") # returns 4 >>> evaluate_expression(\\"3*(4+5)\\") # returns 27 >>> evaluate_expression(\\"10/(5-3)\\") # returns 5","solution":"def evaluate_expression(expression: str) -> int: def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(expression)"},{"question":"import re from typing import List, Dict def word_frequency(words: List[str]) -> Dict[str, int]: Takes an array of strings as input and returns a dictionary representing the frequency of each unique word, ignoring case and punctuation. >>> word_frequency([\\"Hello!\\", \\"world.\\", \\"hello,\\", \\"WORLD\\", \\"hello\\"]) {'hello': 3, 'world': 2} >>> word_frequency([\\"This\\", \\"is\\", \\"a\\", \\"test.\\", \\"This\\", \\"test\\", \\"is\\", \\"only\\", \\"a\\", \\"TEST\\"]) {'this': 2, 'is': 2, 'a': 2, 'test': 3, 'only': 1}","solution":"import re from collections import defaultdict def word_frequency(words): Takes an array of strings as input and returns a dictionary representing the frequency of each unique word, ignoring case and punctuation. frequency = defaultdict(int) for word in words: # Remove punctuation and convert to lowercase cleaned_word = re.sub(r'[^ws]', '', word).lower() if cleaned_word: frequency[cleaned_word] += 1 return dict(frequency)"},{"question":"from typing import List def minimize_max_pages(pages: List[int], people: int) -> int: Redistribute books among people to minimize the maximum number of pages any single person has to read. Each person gets a contiguous block of books. Args: pages (List[int]): List of integers where each integer represents the number of pages in a book. people (int): Number of people to distribute the books to. Returns: int: The minimum possible maximum number of pages any single person has to read. Example: >>> minimize_max_pages([100, 200, 300, 400, 500], 2) 900 >>> minimize_max_pages([10, 20, 30, 40, 50, 60], 3) 90 >>> minimize_max_pages([12, 34, 67, 90], 2) 113","solution":"from typing import List def can_allocate(pages: List[int], people: int, max_pages_limit: int) -> bool: required_people = 1 current_pages = 0 for page in pages: if current_pages + page > max_pages_limit: required_people += 1 current_pages = page if required_people > people: return False else: current_pages += page return True def minimize_max_pages(pages: List[int], people: int) -> int: low, high = max(pages), sum(pages) result = high while low <= high: mid = (low + high) // 2 if can_allocate(pages, people, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def can_be_almost_palindrome(arr: List[int]) -> str: Check whether a given integer array can be converted into a palindrome by modifying at most one digit. >>> can_be_almost_palindrome([1, 2, 3, 2, 1]) \\"YES\\" >>> can_be_almost_palindrome([1, 2, 3, 4, 1]) \\"YES\\" >>> can_be_almost_palindrome([1, 2, 3, 1, 2]) \\"NO\\"","solution":"def can_be_almost_palindrome(arr): Returns \\"YES\\" if the array can be converted into a palindrome by modifying at most one digit, otherwise returns \\"NO\\". left = 0 right = len(arr) - 1 modifications = 0 while left < right: if arr[left] != arr[right]: modifications += 1 if modifications > 1: return \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"def has_distinct_digits(number): Checks whether the given number has all distinct digits. >>> has_distinct_digits(102) True >>> has_distinct_digits(112) False >>> has_distinct_digits(12345) True >>> has_distinct_digits(122345) False pass def books_with_distinct_digits(n, m): Returns a list of book identifiers within the range [n, m] with distinct digits. >>> books_with_distinct_digits(1, 20) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20] >>> books_with_distinct_digits(105, 120) [105, 106, 107, 108, 109, 120] >>> books_with_distinct_digits(50, 55) [50, 51, 52, 53, 54] >>> books_with_distinct_digits(120, 125) [120, 123, 124, 125] pass def solve(inputString): Processes the input and returns the results for all test cases. >>> solve(\\"2n1 20n105 120n\\") [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20], [105, 106, 107, 108, 109, 120]] >>> solve(\\"1n50 55n\\") [[50, 51, 52, 53, 54]] >>> solve(\\"1n123 125n\\") [[123, 124, 125]] pass","solution":"def has_distinct_digits(number): Checks whether the given number has all distinct digits. digits = str(number) return len(set(digits)) == len(digits) def books_with_distinct_digits(n, m): Returns a list of book identifiers within the range [n, m] with distinct digits. result = [] for i in range(n, m + 1): if has_distinct_digits(i): result.append(i) return result def solve(inputString): Processes the input and returns the results for all test cases. input_lines = inputString.strip().split('n') t = int(input_lines[0]) results = [] for i in range(1, t + 1): n, m = map(int, input_lines[i].split()) result = books_with_distinct_digits(n, m) results.append(result) return results"},{"question":"from typing import List def find_peaks(numbers: List[int]) -> List[int]: Returns a list of peaks from the given list of integers. A peak is defined as an element that is strictly greater than its neighbours. Examples: >>> find_peaks([1, 2, 3, 1]) [3] >>> find_peaks([1, 3, 2, 3, 4, 6, 5]) [3, 6] >>> find_peaks([1, 2, 1, 3, 5, 6, 4]) [2, 6]","solution":"from typing import List def find_peaks(numbers: List[int]) -> List[int]: Returns a list of peaks from the given list of integers. A peak is defined as an element that is strictly greater than its neighbours. peaks = [] n = len(numbers) if n == 0: return peaks for i in range(n): if i == 0 and n > 1 and numbers[i] > numbers[i + 1]: peaks.append(numbers[i]) elif i == n - 1 and n > 1 and numbers[i] > numbers[i - 1]: peaks.append(numbers[i]) elif 0 < i < n - 1 and numbers[i] > numbers[i - 1] and numbers[i] > numbers[i + 1]: peaks.append(numbers[i]) elif n == 1: peaks.append(numbers[i]) return peaks"},{"question":"def reverse_words(s: str) -> str: Returns a new string by reversing the order of the words in the original string. Args: s (str): The original string with words separated by exactly one space. Returns: str: A new string with the words in reverse order. >>> reverse_words(\\"hello world example\\") == \\"example world hello\\" >>> reverse_words(\\"hello\\") == \\"hello\\" >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"this is a test\\") == \\"test a is this\\" >>> reverse_words(\\"repeat repeat repeat\\") == \\"repeat repeat repeat\\"","solution":"def reverse_words(s): Returns a new string by reversing the order of the words in the original string. Args: s (str): The original string with words separated by exactly one space. Returns: str: A new string with the words in reverse order. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Determine if one string is a permutation of another. Arguments: str1 -- the first string str2 -- the second string Returns: True -- if str1 is a permutation of str2 False -- otherwise >>> is_permutation('god', 'dog') True >>> is_permutation('Hello, World!', 'World! Hello,') True >>> is_permutation('test', 'ttew') False >>> is_permutation('Abc', 'abc') False >>> is_permutation('aabbcc', 'baccab') True >>> is_permutation('abc', 'def') False >>> is_permutation('', '') True >>> is_permutation('abc', '') False","solution":"def is_permutation(str1, str2): Returns True if str1 is a permutation of str2, otherwise, returns False. return sorted(str1) == sorted(str2)"},{"question":"def count_divisors(arr: List[int]) -> List[int]: Takes an array of integers and returns a new array in which each element is the count of its divisors. >>> count_divisors([4, 5, 6]) == [3, 2, 4] >>> count_divisors([10, 15, 21]) == [4, 4, 4] >>> count_divisors([2, 3, 5, 7, 11]) == [2, 2, 2, 2, 2] >>> count_divisors([12, 16, 23]) == [6, 5, 2]","solution":"def count_divisors(arr): Takes an array of integers and returns a new array in which each element is the count of its divisors. def divisors(n): if n == 1: return 1 count = 0 for i in range(1, n + 1): if n % i == 0: count += 1 return count return [divisors(x) for x in arr]"},{"question":"from typing import List def apples(tree_apples: List[int]) -> int: Given a list of integers representing the number of apples each tree in an orchard has, this function returns the number of apples to be redistributed to ensure all trees have at least as many apples as the tree with the least apples. Parameters: tree_apples (List[int]): A list of integers where each integer represents the apples on a tree. Returns: int: Total number of apples to be redistributed. Examples: >>> apples([5, 6, 2, 3]) 8 >>> apples([4, 4, 4]) 0 >>> apples([3, 8]) 5 >>> apples([]) 0 >>> apples([4]) 0","solution":"def apples(tree_apples): Given a list of integers representing the number of apples each tree in an orchard has, this function returns the number of apples to be redistributed to ensure all trees have at least as many apples as the tree with the least apples. Parameters: tree_apples (list of int): A list of integers where each integer represents the apples on a tree. Returns: int: Total number of apples to be redistributed. if not tree_apples or len(tree_apples) <= 1: return 0 min_apples = min(tree_apples) total_redistribution = sum(apples - min_apples for apples in tree_apples) return total_redistribution"},{"question":"def maxPower(artifacts: List[int]) -> int: Determine the maximum power a player can achieve by collecting non-adjacent artifacts. >>> maxPower([5, 5, 10, 100, 10, 5]) 110 >>> maxPower([3, 2, 5, 10, 7]) 15 >>> maxPower([10]) 10 >>> maxPower([10, 15]) 15 >>> maxPower([15, 10]) 15 >>> maxPower([5, 1, 1, 5]) 10 >>> maxPower([5, 5, 5, 5, 5, 5]) 15 >>> maxPower([i for i in range(1, 101)]) 2550","solution":"def maxPower(artifacts): if not artifacts: return 0 n = len(artifacts) if n == 1: return artifacts[0] if n == 2: return max(artifacts[0], artifacts[1]) dp = [0] * n dp[0] = artifacts[0] dp[1] = max(artifacts[0], artifacts[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + artifacts[i]) return dp[-1] # Example usage print(maxPower([5, 5, 10, 100, 10, 5])) # Output: 110 print(maxPower([3, 2, 5, 10, 7])) # Output: 15"},{"question":"def reverse_letters_in_words(s: str) -> str: Reverses the letters in each word of the string while maintaining the order of words in the string. Parameters: s (str): The input string containing words separated by a single whitespace. Returns: str: The string with each word's letters reversed. >>> reverse_letters_in_words(\\"hello world\\") 'olleh dlrow' >>> reverse_letters_in_words(\\"The quick brown fox\\") 'ehT kciuq nworb xof' >>> reverse_letters_in_words(\\"Coding is fun\\") 'gnidoC si nuf' >>> reverse_letters_in_words(\\"A B C D E\\") 'A B C D E' >>> reverse_letters_in_words(\\"Reverse me\\") 'esreveR em' >>> reverse_letters_in_words(\\"Palindrome racecar\\") 'emordnilaP racecar'","solution":"def reverse_letters_in_words(s): Reverses the letters in each word of the string while maintaining the order of words in the string. Parameters: s (str): The input string containing words separated by a single whitespace. Returns: str: The string with each word's letters reversed. return ' '.join([word[::-1] for word in s.split()])"},{"question":"def cumulative_triangle(nums: List[int]) -> int: Constructs a cumulative sum triangle and returns the apex value. Args: nums (list of int/float): The base list to start constructing the triangle. Returns: int/float: The apex value of the cumulative sum triangle. pass # Test cases def test_cumulative_triangle_case1(): assert cumulative_triangle([1, 2, 3, 4, 5]) == 48 def test_cumulative_triangle_case2(): assert cumulative_triangle([1, 2, 3]) == 8 def test_cumulative_triangle_case3(): assert cumulative_triangle([-1, -1, -1]) == -4 def test_cumulative_triangle_case4(): assert cumulative_triangle([1, 2, 3, 4]) == 20 def test_cumulative_triangle_single_element(): assert cumulative_triangle([7]) == 7 def test_cumulative_triangle_two_elements(): assert cumulative_triangle([5, 10]) == 15 def test_cumulative_triangle_negative_numbers(): assert cumulative_triangle([-1, -2, -3, -4, -5]) == -48 def test_cumulative_triangle_mixed_numbers(): assert cumulative_triangle([-1, 1, -1, 1]) == 0","solution":"def cumulative_triangle(nums): Constructs a cumulative sum triangle and returns the apex value. Args: nums (list of int/float): The base list to start constructing the triangle. Returns: int/float: The apex value of the cumulative sum triangle. # Process until the list is reduced to a single number while len(nums) > 1: # Generate the next row by summing adjacent pairs nums = [nums[i] + nums[i+1] for i in range(len(nums)-1)] # The last remaining number is the apex number return nums[0]"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, return an array such that each element at index \`i\` is the product of all the numbers in the original array except the one at \`i\`. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([3, 2, 1]) [2, 3, 6] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([100, 1, 1, 1]) [1, 100, 100, 100]","solution":"def product_except_self(nums): Given an array of integers, return an array such that each element at index \`i\` is the product of all the numbers in the original array except the one at \`i\`. length = len(nums) result = [1] * length # Calculate left products left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate right products and combine with left products right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def has_proper_parentheses(s: str) -> str: Determines if the string s has proper parentheses matching. Parameters: s (str): The string to be checked. Returns: str: \\"YES\\" if the string has proper parentheses matching, otherwise \\"NO\\". >>> has_proper_parentheses(\\"()\\") \\"YES\\" >>> has_proper_parentheses(\\"(())\\") \\"YES\\" >>> has_proper_parentheses(\\"(()))\\") \\"NO\\" >>> has_proper_parentheses(\\")(\\") \\"NO\\" pass def process_test_cases(T: int, test_cases: list) -> list: Processes multiple test cases and returns their results. Parameters: T (int): The number of test cases. test_cases (list of str): The test cases to be processed. Returns: list of str: The results of the test cases. >>> process_test_cases(3, [\\"(())\\", \\"()()\\", \\"(()))\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"()\\", \\"(()()(()))\\"]) [\\"YES\\", \\"YES\\"] >>> process_test_cases(4, [\\"()\\", \\"((()))\\", \\"(()())\\", \\"((())())\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases(2, [\\"()\\", \\"(()))\\"]) [\\"YES\\", \\"NO\\"] pass","solution":"def has_proper_parentheses(s): Determines if the string s has proper parentheses matching. Parameters: s (str): The string to be checked. Returns: str: \\"YES\\" if the string has proper parentheses matching, otherwise \\"NO\\". stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if stack: stack.pop() else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\" def process_test_cases(T, test_cases): Processes multiple test cases and returns their results. Parameters: T (int): The number of test cases. test_cases (list of str): The test cases to be processed. Returns: list of str: The results of the test cases. results = [] for case in test_cases: results.append(has_proper_parentheses(case)) return results"},{"question":"def num_islands(grid: List[List[str]]) -> int: Count the number of islands in a given 2D grid map of '1's (land) and '0's (water). >>> num_islands([ ... ['1','1','0','0','0'], ... ['1','1','0','0','0'], ... ['0','0','1','0','0'], ... ['0','0','0','1','1'] ... ]) 3 >>> num_islands([ ... ['1','0','1','0'], ... ['0','1','0','1'], ... ['1','0','1','0'] ... ]) 6","solution":"def num_islands(grid): if not grid: return 0 def dfs(i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != '1': return grid[i][j] = '0' # Mark as visited dfs(i + 1, j) # Down dfs(i - 1, j) # Up dfs(i, j + 1) # Right dfs(i, j - 1) # Left num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': num_islands += 1 dfs(i, j) return num_islands"},{"question":"def min_path_sum(grid): Returns the minimum path sum from the top-left corner to the bottom-right corner of the grid. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) 3 def solve(test_cases): Solves multiple test cases, finding the minimum path sum for each. >>> solve([ ... [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ], ... [ ... [1, 2], ... [1, 1] ... ] ... ]) [7, 3]","solution":"def min_path_sum(grid): Returns the minimum path sum from the top-left corner to the bottom-right corner of the grid. n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1] def solve(test_cases): results = [] for grid in test_cases: results.append(min_path_sum(grid)) return results"},{"question":"from typing import List, Optional def second_largest_unique(nums: List[int]) -> Optional[int]: Returns the second largest unique number from the list of integers. If no such number exists, return None. >>> second_largest_unique([10, 20, 10, 30, 20, 30, 40]) 30 >>> second_largest_unique([10, 10]) None >>> second_largest_unique([-1, -2, -3]) -2 >>> second_largest_unique([-10, -20, 0, 10, 20]) 10 >>> second_largest_unique([]) None >>> second_largest_unique([1, 1]) None >>> second_largest_unique([10]) None >>> second_largest_unique([10, 20]) 10","solution":"def second_largest_unique(nums): Returns the second largest unique number from the list of integers. If no such number exists, return None. if not nums or len(nums) < 2: return None # Remove duplicates and sort the unique numbers in descending order unique_nums = sorted(set(nums), reverse=True) # If there are fewer than 2 unique numbers, return None if len(unique_nums) < 2: return None return unique_nums[1]"},{"question":"from itertools import permutations def generate_permutations(s: str, k: int): This function prints all possible size k permutations of the string s in lexicographic sorted order. Args: s (str): The input string containing only uppercase characters. k (int): The size of the permutations. Returns: None: Prints the permutations on separate lines. >>> generate_permutations(\\"HACK\\", 2) AC AH AK CA CH CK HA HC HK KA KC KH >>> generate_permutations(\\"A\\", 1) A >>> generate_permutations(\\"ABC\\", 3) ABC ACB BAC BCA CAB CBA >>> generate_permutations(\\"AAA\\", 2) AA AA AA AA AA AA","solution":"from itertools import permutations def generate_permutations(s, k): This function prints all possible size k permutations of the string s in lexicographic sorted order. Args: s (str): The input string containing only uppercase characters. k (int): The size of the permutations. Returns: None: Prints the permutations on separate lines. perms = permutations(sorted(s), k) for perm in perms: print(''.join(perm))"},{"question":"def can_form_with_one_extra(s: str, t: str) -> bool: Determines if string t can be formed by rearranging the letters of s and adding at most one additional letter. Example: >>> can_form_with_one_extra(\\"abc\\", \\"cba\\") True >>> can_form_with_one_extra(\\"abc\\", \\"abcd\\") True >>> can_form_with_one_extra(\\"abc\\", \\"abcde\\") False >>> can_form_with_one_extra(\\"ab\\", \\"a\\") False def test_example1(): assert can_form_with_one_extra(\\"abc\\", \\"cba\\") == True def test_example2(): assert can_form_with_one_extra(\\"abc\\", \\"abcd\\") == True def test_example3(): assert can_form_with_one_extra(\\"abc\\", \\"abcde\\") == False def test_example4(): assert can_form_with_one_extra(\\"ab\\", \\"a\\") == False def test_exact_match(): assert can_form_with_one_extra(\\"xyz\\", \\"xyz\\") == True def test_one_extra_letter(): assert can_form_with_one_extra(\\"xyz\\", \\"xyza\\") == True def test_multiple_extra_letters(): assert can_form_with_one_extra(\\"xyz\\", \\"xyzaa\\") == False def test_length_difference(): assert can_form_with_one_extra(\\"abcd\\", \\"abc\\") == False def test_empty_s(): assert can_form_with_one_extra(\\"\\", \\"a\\") == True assert can_form_with_one_extra(\\"\\", \\"aa\\") == False def test_empty_t(): assert can_form_with_one_extra(\\"a\\", \\"\\") == False","solution":"def can_form_with_one_extra(s: str, t: str) -> bool: Determines if string t can be formed by rearranging the letters of s and adding at most one additional letter. from collections import Counter # If t is shorter than s, it's not possible to form t by just adding one letter. if len(t) < len(s): return False # Count the frequency of characters in both strings s_counter = Counter(s) t_counter = Counter(t) # Calculate the number of excess characters in t not present or insufficient in s extra_chars = 0 for char in t_counter: if t_counter[char] > s_counter[char]: extra_chars += t_counter[char] - s_counter[char] # We can add only one extra character return extra_chars <= 1"},{"question":"def can_place_irrigation_systems(grid, m): Determines if m irrigation systems can be placed in the grid such that each tree (1) has at least one adjacent irrigation system (2). >>> can_place_irrigation_systems([[1, 0, 0], [0, 0, 0], [0, 1, 0]], 2) True >>> can_place_irrigation_systems([[1, 0, 0], [0, 0, 0], [0, 1, 0]], 1) False pass","solution":"def can_place_irrigation_systems(grid, m): Determines if m irrigation systems can be placed in the grid such that each tree (1) has at least one adjacent irrigation system (2). rows, cols = len(grid), len(grid[0]) # Helper method to check if we can place a 2 and it would help a tree def is_valid_placement(x, y): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: return True return False empty_spots = [] for i in range(rows): for j in range(cols): if grid[i][j] == 0 and is_valid_placement(i, j): empty_spots.append((i, j)) if len(empty_spots) < m: return False irrigated = set() for i in range(rows): for j in range(cols): if grid[i][j] == 1: # It's a tree irrigated_adj = False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = i + dx, j + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 2: irrigated_adj = True break if not irrigated_adj: irrigated.add((i, j)) if len(irrigated) > m: return False return True"},{"question":"def starting_letters_of_chapters(N): Returns a string where each character represents the starting letter of each chapter, given the number of chapters N. >>> starting_letters_of_chapters(3) 'abc' >>> starting_letters_of_chapters(28) 'abcdefghijklmnopqrstuvwxyza' >>> starting_letters_of_chapters(52) 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'","solution":"def starting_letters_of_chapters(N): Returns a string where each character represents the starting letter of each chapter, given the number of chapters N. alphabet = 'abcdefghijklmnopqrstuvwxyz' result = [] for i in range(N): result.append(alphabet[i % 26]) return ''.join(result)"},{"question":"def find_race_winner(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[str]: Find out which car won the race based on the speed records provided. >>> find_race_winner(2, [ (3, [ [5, 100, 150, 200], [3, 120, 140, 100], [2, 110, 160, 130] ]), (2, [ [1, 200, 250, 300], [2, 100, 100, 300] ]) ]) [\\"Case #1: 5\\", \\"Case #2: 1\\"] >>> find_race_winner(1, [ (3, [ [1, 200, 200, 200], [2, 200, 200, 200], [3, 200, 200, 200] ]) ]) [\\"Case #1: 1\\"]","solution":"def find_race_winner(T, test_cases): results = [] for t in range(T): M, cars = test_cases[t] max_avg_speed = -1 winner = float('inf') for car in cars: participant_number = car[0] speeds = car[1:] avg_speed = sum(speeds) / len(speeds) if (avg_speed > max_avg_speed) or (avg_speed == max_avg_speed and participant_number < winner): max_avg_speed = avg_speed winner = participant_number results.append(f\\"Case #{t+1}: {winner}\\") return results"},{"question":"def max_gcd_subsequence_length(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum length of a subsequence whose GCD is equal to G, or return -1 if no such subsequence exists. Args: t (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of test cases, each containing: - A tuple with two integers, N (number of elements) and G (specified GCD value). - A list of N integers representing the array of elements. Returns: List[int]: A list of integers representing the maximum length of a subsequence whose GCD is equal to G for each test case, or -1 if no such subsequence exists. Example: >>> max_gcd_subsequence_length(1, [((5, 2), [2, 4, 6, 8, 10])]) [5] >>> max_gcd_subsequence_length(1, [((5, 3), [2, 4, 6, 8, 10])]) [-1]","solution":"from math import gcd from functools import reduce def max_gcd_subsequence_length(t, test_cases): results = [] for i in range(t): n, g = test_cases[i][0] a = test_cases[i][1] # Select all numbers that are multiples of g multiples_of_g = [num for num in a if num % g == 0] if not multiples_of_g: results.append(-1) else: # Compute the GCD of the selected numbers current_gcd = reduce(gcd, multiples_of_g) if current_gcd == g: results.append(len(multiples_of_g)) else: results.append(-1) return results"},{"question":"from typing import List, Tuple def maximum_profit(prices: List[int]) -> int: Returns the maximum possible profit from a single buy and sell operation on given stock prices. :param prices: List of integers representing stock prices. :return: Integer, maximum possible profit. >>> maximum_profit([7, 1, 5, 3, 6, 4]) 5 >>> maximum_profit([7, 6, 4, 3, 1]) 0 >>> maximum_profit([1, 2, 100, 0]) 99 def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases for the stock profit problem. :param test_cases: List of tuples, each containing the number of days and the stock prices. :return: List of integers representing the maximum profit for each test case. >>> process_test_cases([(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1]), (4, [1, 2, 100, 0])]) [5, 0, 99] >>> process_test_cases([(3, [2, 3, 1]), (4, [1, 5, 2, 3]), (2, [3, 3])]) [1, 4, 0]","solution":"def maximum_profit(prices): Returns the maximum possible profit from a single buy and sell operation on given stock prices. :param prices: List of integers representing stock prices. :return: Integer, maximum possible profit. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit def process_test_cases(test_cases): Processes multiple test cases for the stock profit problem. :param test_cases: List of tuples, each containing the number of days and the stock prices. :return: List of integers representing the maximum profit for each test case. results = [] for days, prices in test_cases: results.append(maximum_profit(prices)) return results"},{"question":"def max_balls_collected(M, N, grid): Determine the maximum number of balls collected in a path from the top-left to the bottom-right of the grid. >>> max_balls_collected(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_balls_collected(2, 2, [[1, 1000], [1000, 1]]) 1002 >>> max_balls_collected(1, 5, [[1, 2, 3, 4, 5]]) 15 >>> max_balls_collected(3, 1, [[1], [2], [3]]) 6 >>> max_balls_collected(2, 2, [[1, 1], [1, 1]]) 3","solution":"def max_balls_collected(M, N, grid): dp = [[0] * N for _ in range(M)] dp[0][0] = grid[0][0] for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[M-1][N-1]"},{"question":"from typing import List def find_pair(nums: List[int], target: int) -> List[int]: Returns indices of the two numbers in the list that add up to the target, otherwise returns an empty list. >>> find_pair([2, 7, 11, 15], 9) == [0, 1] >>> find_pair([3, 2, 4], 6) == [1, 2] >>> find_pair([3, 3], 6) == [0, 1] >>> find_pair([1, 2, 3], 7) == [] pass def test_find_pair_example1(): assert find_pair([2, 7, 11, 15], 9) == [0, 1] def test_find_pair_example2(): assert find_pair([3, 2, 4], 6) == [1, 2] def test_find_pair_example3(): assert find_pair([3, 3], 6) == [0, 1] def test_find_pair_no_pair_exists(): assert find_pair([1, 2, 3], 7) == [] def test_find_pair_single_element(): assert find_pair([1], 1) == [] def test_find_pair_negative_numbers(): assert find_pair([-1, -2, -3, -4], -6) == [1, 3] def test_find_pair_mixed_numbers(): assert find_pair([-3, 4, 3, 90], 0) == [0, 2] def test_find_pair_duplicate_numbers(): assert find_pair([1, 2, 2, 4], 4) == [1, 2]","solution":"def find_pair(nums, target): Returns indices of the two numbers in the list that add up to the target, otherwise returns an empty list. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def summarize_runs(lst: List[int]) -> List[Tuple[int, int]]: Summarizes a list of integers by counting consecutive runs of the same value. Parameters: - lst: List of integers Returns: - List of tuples, where each tuple contains an integer and the count of its consecutive appearances. Example: >>> summarize_runs([2, 2, 3, 3, 3, 2, 2, 2]) [(2, 2), (3, 3), (2, 3)] >>> summarize_runs([1, 2, 3, 4, 5]) [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)] ... from typing import List, Tuple def test_single_run(): assert summarize_runs([2, 2, 2, 2]) == [(2, 4)] def test_multiple_runs(): assert summarize_runs([2, 2, 3, 3, 3, 2, 2, 2]) == [(2, 2), (3, 3), (2, 3)] def test_no_runs(): assert summarize_runs([1, 2, 3, 4, 5]) == [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)] def test_empty_list(): assert summarize_runs([]) == [] def test_single_element_list(): assert summarize_runs([1]) == [(1, 1)] def test_alternating_elements(): assert summarize_runs([1, 2, 1, 2, 1, 2]) == [(1, 1), (2, 1), (1, 1), (2, 1), (1, 1), (2, 1)]","solution":"def summarize_runs(lst): Summarizes a list of integers by counting consecutive runs of the same value. Parameters: - lst: List of integers Returns: - List of tuples, where each tuple contains an integer and the count of its consecutive appearances. if not lst: return [] summary = [] current_value = lst[0] count = 1 for num in lst[1:]: if num == current_value: count += 1 else: summary.append((current_value, count)) current_value = num count = 1 summary.append((current_value, count)) # Add the last run return summary"},{"question":"from typing import List def is_prime(num: int) -> bool: Return True if num is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def is_palindrome(num: int) -> bool: Return True if num is a palindrome number, otherwise False. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(101) True def palindrome_primes(n: int) -> List[int]: Return a list containing the first n palindrome prime numbers. >>> palindrome_primes(3) [2, 3, 5] >>> palindrome_primes(5) [2, 3, 5, 7, 11] >>> palindrome_primes(10) [2, 3, 5, 7, 11, 101, 131, 151, 181, 191] # If you wish to test the functions, you can use the following test cases: def test_is_prime(): # Testing prime numbers assert is_prime(2) == True assert is_prime(3) == True assert is_prime(5) == True assert is_prime(13) == True # Testing non-prime numbers assert is_prime(1) == False assert is_prime(4) == False assert is_prime(9) == False def test_is_palindrome(): # Testing palindrome numbers assert is_palindrome(121) == True assert is_palindrome(131) == True assert is_palindrome(7) == True # Testing non-palindrome numbers assert is_palindrome(123) == False assert is_palindrome(10) == False assert is_palindrome(1001) == True def test_palindrome_primes(): assert palindrome_primes(3) == [2, 3, 5] assert palindrome_primes(5) == [2, 3, 5, 7, 11] assert palindrome_primes(10) == [2, 3, 5, 7, 11, 101, 131, 151, 181, 191] assert palindrome_primes(1) == [2] assert palindrome_primes(20) == [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929]","solution":"def is_prime(num): Return True if num is a prime number, otherwise False. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def is_palindrome(num): Return True if num is a palindrome number, otherwise False. return str(num) == str(num)[::-1] def palindrome_primes(n): Return a list containing the first n palindrome prime numbers. result = [] candidate = 2 while len(result) < n: if is_prime(candidate) and is_palindrome(candidate): result.append(candidate) candidate += 1 return result"},{"question":"def is_palindrome(n: int) -> bool: Check if the number n is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1221) True >>> is_palindrome(1) True >>> is_palindrome(10) False def check_palindromes(test_cases: List[int]) -> List[str]: For each number in test_cases, check if it is a palindrome and return 'YES' or 'NO'. >>> check_palindromes([121, 123, 1221]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_palindromes([101, 202, 303]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> check_palindromes([1212, 45654, 78987]) [\\"NO\\", \\"YES\\", \\"YES\\"] >>> check_palindromes([9, 22, 33, 12321]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> check_palindromes([90, 120, 44444]) [\\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def is_palindrome(n): Checks if the number n is a palindrome. str_n = str(n) return str_n == str_n[::-1] def check_palindromes(test_cases): For each number in test_cases, check if it is a palindrome and return 'YES' or 'NO'. results = [] for n in test_cases: if is_palindrome(n): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_unique_elements(lst: List[int]) -> List[int]: Write a function named \`find_unique_elements\` that takes a single list of integers as input and returns a new list containing only the distinct elements from the original list in the order they first appeared. The returned list should not have any duplicates. Use a set to keep track of seen elements to ensure the uniqueness in the output list. The function should handle an empty list by returning an empty list. Parameters: - lst: List of integers Returns: - List of distinct integers >>> find_unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> find_unique_elements([7, 8, 8, 8, 9, 10, 10]) [7, 8, 9, 10] >>> find_unique_elements([]) [] from solution import find_unique_elements def test_find_unique_elements_with_duplicates(): assert find_unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] def test_find_unique_elements_no_duplicates(): assert find_unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_find_unique_elements_all_duplicates(): assert find_unique_elements([1, 1, 1, 1]) == [1] def test_find_unique_elements_empty_list(): assert find_unique_elements([]) == [] def test_find_unique_elements_mixed(): assert find_unique_elements([7, 8, 8, 9, 10, 10, 7]) == [7, 8, 9, 10]","solution":"def find_unique_elements(lst): Returns a list of unique elements in the order they first appeared. Parameters: - lst: List of integers Returns: - List of distinct integers seen = set() unique_elements = [] for element in lst: if element not in seen: unique_elements.append(element) seen.add(element) return unique_elements"},{"question":"def simulate_waterfall(matrix): Simulates the waterfall effect on a given matrix. Arguments: matrix -- 2D list with 0 representing empty cells and 1 representing obstacles. Returns: 2D list with 'O' representing water, 'X' representing obstacles, and '.' representing empty cells. Example: >>> simulate_waterfall([ ... [0, 0, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 0, 0] ... ]) [['O', 'O', 'O', 'O'], ['O', 'X', 'O', 'X'], ['O', 'O', 'O', 'O'], ['O', 'X', 'O', 'O']] >>> simulate_waterfall([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) [['O', 'X', 'O'], ['O', 'X', 'O'], ['O', 'O', 'O']]","solution":"def simulate_waterfall(matrix): Simulates the waterfall effect on a given matrix. Arguments: matrix -- 2D list with 0 representing empty cells and 1 representing obstacles. Returns: 2D list with 'O' representing water, 'X' representing obstacles, and '.' representing empty cells. m, n = len(matrix), len(matrix[0]) result = [['.' for _ in range(n)] for _ in range(m)] # Initialize obstacles in the result matrix for i in range(m): for j in range(n): if matrix[i][j] == 1: result[i][j] = 'X' # Helper function to fill water using DFS def fill_water(i, j): if i < 0 or i >= m or j < 0 or j >= n: return if result[i][j] == 'O' or result[i][j] == 'X': return result[i][j] = 'O' fill_water(i + 1, j) # downwards if j > 0: fill_water(i + 1, j - 1) # left-downwards if j < n - 1: fill_water(i + 1, j + 1) # right-downwards # Start filling water from the top row for j in range(n): if matrix[0][j] == 0: fill_water(0, j) return result"},{"question":"from typing import List, Tuple def find_longest_word(words: List[str]) -> Tuple[str, int]: Finds the longest word in the list and returns it along with its length. If there are multiple words with the same maximum length, the function returns the word that comes first in the list. >>> find_longest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) ('banana', 6) >>> find_longest_word([\\"this\\", \\"is\\", \\"a\\", \\"test\\"]) ('this', 4) >>> find_longest_word([\\"longword\\", \\"short\\", \\"longwordagain\\", \\"longword\\"]) ('longwordagain', 13)","solution":"from typing import List, Tuple def find_longest_word(words: List[str]) -> Tuple[str, int]: Finds the longest word in the list and returns it along with its length. If there are multiple words with the same maximum length, the function returns the word that comes first in the list. if not words: return \\"\\", 0 longest_word = words[0] max_length = len(longest_word) for word in words: if len(word) > max_length: longest_word = word max_length = len(word) return longest_word, max_length"},{"question":"import ast from typing import List def sum_nested_list(input_str: str) -> int: Returns the sum of all integers in a nested list represented by a string. >>> sum_nested_list(\\"[[1, 2, [-1]], [3, [4, [-5, [6]]]]]\\") 10 >>> sum_nested_list(\\"[1, 2, [3, 4, [5, 6]], 7, 8]\\") 36 >>> sum_nested_list(\\"[[]]\\") 0 >>> sum_nested_list(\\"[[[-1]], -2, 3, [4]]\\") 4 >>> sum_nested_list(\\"[[[[0]]], 0]\\") 0","solution":"import ast def sum_nested_list(input_str): Returns the sum of all integers in a nested list represented by a string. if not input_str: return 0 nested_list = ast.literal_eval(input_str) def sum_list(lst): total = 0 for item in lst: if isinstance(item, list): total += sum_list(item) else: total += item return total return sum_list(nested_list)"},{"question":"def schedule_meeting(start: str, duration: int) -> bool: Determines if a meeting can be scheduled within work hours (09:00 to 18:00) Args: start (str): Start time in HH:MM format duration (int): Duration of the meeting in minutes Returns: bool: True if the meeting can be scheduled, False otherwise >>> schedule_meeting(\\"08:30\\", 60) False >>> schedule_meeting(\\"17:30\\", 60) False >>> schedule_meeting(\\"10:00\\", 480) True >>> schedule_meeting(\\"09:00\\", 60) True >>> schedule_meeting(\\"13:00\\", 120) True >>> schedule_meeting(\\"18:00\\", 30) False >>> schedule_meeting(\\"17:00\\", 60) True >>> schedule_meeting(\\"17:59\\", 1) True","solution":"def schedule_meeting(start, duration): Determines if a meeting can be scheduled within work hours (09:00 to 18:00) Args: start (str): Start time in HH:MM format duration (int): Duration of the meeting in minutes Returns: bool: True if the meeting can be scheduled, False otherwise start_hour, start_minute = map(int, start.split(\\":\\")) if start_hour < 9 or (start_hour == 18 and start_minute > 0): return False total_start_minutes = start_hour * 60 + start_minute total_end_minutes = total_start_minutes + duration if total_end_minutes > 18 * 60: return False start_work_minutes = 9 * 60 end_work_minutes = 18 * 60 return start_work_minutes <= total_start_minutes < end_work_minutes and total_start_minutes < total_end_minutes <= end_work_minutes"},{"question":"def is_reversed_palindrome(n: int) -> bool: Checks if the given number is a Reversed Palindrome. Parameters: n (int): The input number to check. Returns: bool: True if the number is a Reversed Palindrome, False otherwise. >>> is_reversed_palindrome(1089) True >>> is_reversed_palindrome(21) False >>> is_reversed_palindrome(181) False >>> is_reversed_palindrome(420) False >>> is_reversed_palindrome(1) False >>> is_reversed_palindrome(100000) False","solution":"def is_reversed_palindrome(n): Checks if the given number is a Reversed Palindrome. Parameters: n (int): The input number to check. Returns: bool: True if the number is a Reversed Palindrome, False otherwise. reversed_n = int(str(n)[::-1]) for i in range(2, 10): if reversed_n == n * i: return True return False"},{"question":"def longest_x_sequence_length(N: int, A: List[int], T: int) -> int: Returns the length of the longest possible X-sequence that can be created following the rules. :param N: int, the length of the array A :param A: List[int], the array of integers :param T: int, the threshold for the prefix sum :return: int, the length of the longest possible X-sequence >>> longest_x_sequence_length(6, [4, 2, 5, 3, 1, 6], 11) == 4 >>> longest_x_sequence_length(1, [10], 5) == 0 >>> longest_x_sequence_length(1, [10], 10) == 1 >>> longest_x_sequence_length(5, [1, 2, 3, 4, 5], 15) == 5 >>> longest_x_sequence_length(5, [10, 20, 30, 40, 50], 5) == 0 >>> longest_x_sequence_length(6, [7, 5, 3, 8, 2, 4], 10) == 3 >>> longest_x_sequence_length(1000, [i for i in range(1, 1001)], 5000) == 99","solution":"def longest_x_sequence_length(N, A, T): Returns the length of the longest possible X-sequence :param N: int, the length of the array A :param A: List[int], the array of integers :param T: int, the threshold for the prefix sum :return: int, the length of the longest possible X-sequence A.sort() current_sum = 0 length = 0 for number in A: if current_sum + number <= T: current_sum += number length += 1 else: break return length"},{"question":"def trap(height): Computes the amount of trapped water given the height of each section of terrain. :param height: List of non-negative integers. :return: The amount of trapped water. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([0, 0, 0, 0]) 0 >>> trap([]) 0 >>> trap([1, 1, 1, 1]) 0 >>> trap([3, 0, 2]) 2 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1]) 0 >>> trap([4, 1, 1, 0, 2, 3]) 8","solution":"def trap(height): Computes the amount of trapped water given the height of each section of terrain. :param height: List of non-negative integers. :return: The amount of trapped water. if not height: return 0 n = len(height) left_max = right_max = 0 left = 0 right = n - 1 total_water = 0 while left < right: if height[left] < height[right]: if height[left] >= left_max: left_max = height[left] else: total_water += (left_max - height[left]) left += 1 else: if height[right] >= right_max: right_max = height[right] else: total_water += (right_max - height[right]) right -= 1 return total_water"},{"question":"def is_palindrome(s: str) -> bool: Helper function to check if a string is a palindrome. return s == s[::-1] def is_almost_palindrome(input_string: str) -> bool: A palindrome is a string that reads the same forward and backward, while an almost palindrome is a string that would be a palindrome if at most one character were deleted. Given a string, determine whether it is almost palindrome. Returns True if the input string is an almost palindrome, False otherwise. >>> is_almost_palindrome(\\"racecar\\") True >>> is_almost_palindrome(\\"radkar\\") True >>> is_almost_palindrome(\\"hello\\") False pass","solution":"def is_palindrome(s): Helper function to check if a string is a palindrome. return s == s[::-1] def is_almost_palindrome(input_string): Returns True if the input string is an almost palindrome, False otherwise. if is_palindrome(input_string): return True length = len(input_string) for i in range(length): # Create a new string with the ith character removed temp_string = input_string[:i] + input_string[i+1:] if is_palindrome(temp_string): return True return False"},{"question":"def longestUniqueSubstring(s: str) -> int: Given a string that contains a mixture of lowercase and uppercase letters, identify the longest substring that contains unique characters and return the length of that substring. >>> longestUniqueSubstring(\\"abcabcbb\\") == 3 >>> longestUniqueSubstring(\\"bbbbb\\") == 1 >>> longestUniqueSubstring(\\"pwwkew\\") == 3 >>> longestUniqueSubstring(\\"aAaAaA\\") == 2","solution":"def longestUniqueSubstring(s): Returns the length of the longest substring with all unique characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def print_fibonacci(n): Prints the first n lines of the Fibonacci sequence. >>> print_fibonacci(1) 0 >>> print_fibonacci(2) 0 1 >>> print_fibonacci(5) 0 1 1 2 3","solution":"def print_fibonacci(n): Prints the first n lines of the Fibonacci sequence. a, b = 0, 1 for _ in range(n): print(a) a, b = b, a + b"},{"question":"def fizz_buzz(n: int) -> str: Returns the string representation of a non-negative integer n with a twist: - Returns \\"Fizz\\" for multiples of 3 - Returns \\"Buzz\\" for multiples of 5 - Returns \\"FizzBuzz\\" for multiples of both 3 and 5 - Otherwise, returns the integer as a string >>> fizz_buzz(3) \\"Fizz\\" >>> fizz_buzz(5) \\"Buzz\\" >>> fizz_buzz(15) \\"FizzBuzz\\" >>> fizz_buzz(4) \\"4\\"","solution":"def fizz_buzz(n: int) -> str: Returns the string representation of a non-negative integer n with a twist: - Returns \\"Fizz\\" for multiples of 3 - Returns \\"Buzz\\" for multiples of 5 - Returns \\"FizzBuzz\\" for multiples of both 3 and 5 - Otherwise, returns the integer as a string if n % 3 == 0 and n % 5 == 0: return \\"FizzBuzz\\" elif n % 3 == 0: return \\"Fizz\\" elif n % 5 == 0: return \\"Buzz\\" else: return str(n)"},{"question":"def is_k_palindromic(s: str, k: int) -> bool: Determines if a given string can be transformed into a palindrome by removing at most k characters. >>> is_k_palindromic(\\"abcdeca\\", 2) True >>> is_k_palindromic(\\"abcdef\\", 3) False","solution":"def is_k_palindromic(s, k): Determines if a given string can be transformed into a palindrome by removing at most k characters. Parameters: s (str): The input string. k (int): The maximum number of characters that can be removed. Returns: bool: True if the string can be transformed into a palindrome by removing at most k characters, False otherwise. n = len(s) def longest_palindromic_subsequence(x): dp = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): if x[i] == x[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] lps = longest_palindromic_subsequence(s) return (n - lps) <= k"},{"question":"def find_missing_letter(chars: List[str]) -> str: This function takes a list of consecutive (increasing) letters with one letter missing and returns the missing letter. >>> find_missing_letter(['a','b','c','d','f']) 'e' >>> find_missing_letter(['O','Q','R','S']) 'P'","solution":"def find_missing_letter(chars): This function takes a list of consecutive (increasing) letters with one letter missing and returns the missing letter. :param chars: List of consecutive characters with one missing :type chars: list of str :return: The missing character :rtype: str for i in range(len(chars) - 1): if ord(chars[i+1]) - ord(chars[i]) > 1: return chr(ord(chars[i]) + 1)"},{"question":"def longest_sorted_subsequence_length(S: str) -> int: Returns the length of the longest subsequence of S such that the characters of the subsequence are in sorted order alphabetically. >>> longest_sorted_subsequence_length(\\"abcbdab\\") 4 >>> longest_sorted_subsequence_length(\\"zyx\\") 1","solution":"def longest_sorted_subsequence_length(S): Returns the length of the longest subsequence of S such that the characters of the subsequence are in sorted order alphabetically. n = len(S) # lis[i] will be the length of the longest increasing subsequence that ends with S[i] lis = [1] * n for i in range(1, n): for j in range(i): if S[i] >= S[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determines if the given string is a permutation of a palindrome. Arguments: s -- string containing only lowercase letters Returns: bool -- True if the string is a palindrome permutation, False otherwise >>> is_palindrome_permutation('tactcoa') True >>> is_palindrome_permutation('abc') False >>> is_palindrome_permutation('aabbccdd') True","solution":"def is_palindrome_permutation(s): Determines if the given string is a permutation of a palindrome. Arguments: s -- string containing only lowercase letters Returns: bool -- True if the string is a palindrome permutation, False otherwise # A string can be permuted to a palindrome if and only if # at most one character has an odd count. char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the number of characters with an odd count odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A palindrome can tolerate at most one odd-count character return odd_count <= 1"},{"question":"from typing import List, Tuple def longest_same_value_subarray(arr: List[int]) -> Tuple[int, int]: Given an array of integers, find the longest contiguous subarray such that all elements in the subarray have the same value. >>> longest_same_value_subarray([1, 2, 2, 3, 3, 3, 2, 2, 2, 2, 1]) (4, 2) >>> longest_same_value_subarray([7, 7, 7, 7]) (4, 7)","solution":"from typing import List, Tuple def longest_same_value_subarray(arr: List[int]) -> Tuple[int, int]: Given an array of integers, find the longest contiguous subarray such that all elements in the subarray have the same value. if not arr: return (0, None) max_length = 1 current_length = 1 max_value = arr[0] current_value = arr[0] for i in range(1, len(arr)): if arr[i] == current_value: current_length += 1 else: if current_length > max_length: max_length = current_length max_value = current_value current_value = arr[i] current_length = 1 if current_length > max_length: max_length = current_length max_value = current_value return (max_length, max_value)"},{"question":"def cave_explorers_winner(n: int, m: int) -> str: Determines the winner between Max and Lucas in a cave represented by an n x m grid. >>> cave_explorers_winner(3, 3) 'Max' >>> cave_explorers_winner(2, 2) 'Draw'","solution":"def cave_explorers_winner(n, m): Determines the winner between Max and Lucas in a cave represented by an n x m grid. # The mathematical observation is that if one of n or m is odd, Max wins, # if both n and m are even, it is a draw. if (n % 2 == 1) or (m % 2 == 1): return \\"Max\\" else: return \\"Draw\\""},{"question":"class Robot: A class to simulate a robot moving in a 2D grid. The robot can move in four directions: \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\". The robot starts at the origin (0,0) and can keep track of its position, path history, total distance traveled, and unique positions visited. Example usage: >>> r2d2 = Robot() >>> r2d2.move(\\"UP\\") >>> r2d2.move(\\"RIGHT\\") >>> r2d2.get_position() (1, 1) >>> r2d2.get_path_history() [(0, 0), (0, 1), (1, 1)] >>> r2d2.get_distance_traveled() 4 >>> r2d2.get_unique_positions_count() 3 def __init__(self): self.x = 0 self.y = 0 self.history = set() self.history.add((self.x, self.y)) self.steps = 0 def move(self, direction): Moves the robot in the specified direction. >>> r2d2 = Robot() >>> r2d2.move(\\"UP\\") >>> r2d2.get_position() (0, 1) pass def get_position(self): Returns the current position of the robot as a tuple (x, y). >>> r2d2 = Robot() >>> r2d2.get_position() (0, 0) pass def get_path_history(self): Returns a list of all unique positions visited by the robot. >>> r2d2 = Robot() >>> r2d2.move(\\"UP\\") >>> r2d2.get_path_history() [(0, 0), (0, 1)] pass def get_distance_traveled(self): Returns the total number of steps taken by the robot. >>> r2d2 = Robot() >>> r2d2.move(\\"UP\\") >>> r2d2.get_distance_traveled() 1 pass def get_unique_positions_count(self): Returns the total number of unique positions visited by the robot. >>> r2d2 = Robot() >>> r2d2.move(\\"UP\\") >>> r2d2.get_unique_positions_count() 2 pass","solution":"class Robot: def __init__(self): self.x = 0 self.y = 0 self.history = set() self.history.add((self.x, self.y)) self.steps = 0 def move(self, direction): if direction == \\"UP\\": self.y += 1 elif direction == \\"DOWN\\": self.y -= 1 elif direction == \\"LEFT\\": self.x -= 1 elif direction == \\"RIGHT\\": self.x += 1 self.steps += 1 self.history.add((self.x, self.y)) def get_position(self): return (self.x, self.y) def get_path_history(self): return list(self.history) def get_distance_traveled(self): return self.steps def get_unique_positions_count(self): return len(self.history)"},{"question":"def accumulate_sums(arr): Given an array of integers, returns a new array where each element is the sum of itself and all previous elements in the array. >>> accumulate_sums([1, 2, 3, 4, 5]) [1, 3, 6, 10, 15] >>> accumulate_sums([4, -1, 2, 1, 6]) [4, 3, 5, 6, 12] >>> accumulate_sums([1, 1, 1, 1, 1]) [1, 2, 3, 4, 5] >>> accumulate_sums([]) [] >>> accumulate_sums([5]) [5] >>> accumulate_sums([-1, -2, -3, -4, -5]) [-1, -3, -6, -10, -15] >>> accumulate_sums([0, 0, 0, 0]) [0, 0, 0, 0]","solution":"def accumulate_sums(arr): Given an array of integers, returns a new array where each element is the sum of itself and all previous elements in the array. if not arr: return [] accumulated = [arr[0]] for i in range(1, len(arr)): accumulated.append(accumulated[-1] + arr[i]) return accumulated"},{"question":"def containsNearbyDuplicate(nums: List[int], k: int) -> bool: Determines whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Args: nums (List[int]): List of integers. k (int): An integer representing the maximum allowed difference between indices. Returns: bool: True if such elements exist, otherwise False. Examples: >>> containsNearbyDuplicate([1, 2, 3, 1], 3) True >>> containsNearbyDuplicate([1, 0, 1, 1], 1) True >>> containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2) False # Below are the unit test cases def test_containsNearbyDuplicate_case1(): assert containsNearbyDuplicate([1, 2, 3, 1], 3) == True def test_containsNearbyDuplicate_case2(): assert containsNearbyDuplicate([1, 0, 1, 1], 1) == True def test_containsNearbyDuplicate_case3(): assert containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2) == False def test_containsNearbyDuplicate_no_duplicates(): assert containsNearbyDuplicate([1, 2, 3, 4, 5], 3) == False def test_containsNearbyDuplicate_large_k(): assert containsNearbyDuplicate([1, 1, 1, 1], 100) == True def test_containsNearbyDuplicate_k_zero(): assert containsNearbyDuplicate([1, 2, 3, 1], 0) == False def test_containsNearbyDuplicate_duplicates_but_out_of_range(): assert containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 1) == False def test_containsNearbyDuplicate_large_list(): assert containsNearbyDuplicate(list(range(1000000)) + [0], 1000000) == True","solution":"from typing import List def containsNearbyDuplicate(nums: List[int], k: int) -> bool: Determines whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Args: nums (List[int]): List of integers. k (int): An integer representing the maximum allowed difference between indices. Returns: bool: True if such elements exist, otherwise False. index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\" \\") == 1 >>> length_of_longest_substring(\\"au\\") == 2 >>> length_of_longest_substring(\\"dvdf\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] class Tree: def __init__(self, values): self.nodes = [None] + [TreeNode(v) for v in values] def add_edge(self, u, v): Adds an edge between node u and node v in the tree. self.nodes[u].children.append(self.nodes[v]) self.nodes[v].children.append(self.nodes[u]) def preprocess(self): Preprocess the tree to calculate subtree sums for all nodes. def get_subtree_sum(self, r): Returns the maximum path sum in the subtree rooted at vertex r. def process_queries(n, values, edges, queries): Processes the queries to find the maximum path sum in subtree rooted at the given vertex coordinates. Parameters: n (int): Number of vertices in the tree. values (List[int]): List of values associated with the vertices. edges (List[Tuple[int, int]]): List of edges defining the tree. queries (List[int]): List of queries containing the vertex IDs. Returns: List[int]: List of results for each query. tree = Tree(values) for u, v in edges: tree.add_edge(u, v) tree.preprocess() return [tree.get_subtree_sum(r) for r in queries] # Unit Tests def test_example_case(): n = 5 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [1, 3, 4] expected = [15, 12, 4] assert process_queries(n, values, edges, queries) == expected def test_single_node_tree(): n = 1 values = [1] edges = [] queries = [1] expected = [1] assert process_queries(n, values, edges, queries) == expected def test_star_shaped_tree(): n = 4 values = [10, 20, 30, 40] edges = [(1, 2), (1, 3), (1, 4)] queries = [1, 2, 3, 4] expected = [100, 20, 30, 40] assert process_queries(n, values, edges, queries) == expected def test_line_shaped_tree(): n = 3 values = [1, 2, 3] edges = [(1, 2), (2, 3)] queries = [1, 2, 3] expected = [6, 5, 3] assert process_queries(n, values, edges, queries) == expected def test_complex_case(): n = 6 values = [3, 2, 1, 10, 5, -1] edges = [(1, 2), (1, 3), (3, 4), (4, 5), (4, 6)] queries = [1, 3, 4, 5, 6] expected = [20, 15, 14, 5, -1] assert process_queries(n, values, edges, queries) == expected","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] class Tree: def __init__(self, values): self.nodes = [None] + [TreeNode(v) for v in values] def add_edge(self, u, v): self.nodes[u].children.append(self.nodes[v]) self.nodes[v].children.append(self.nodes[u]) def _dfs(self, node, parent): max_sum = node.value for child in node.children: if child != parent: max_sum += self._dfs(child, node) node.value = max_sum return max_sum def preprocess(self): root = self.nodes[1] self._dfs(root, None) def get_subtree_sum(self, r): return self.nodes[r].value def process_queries(n, values, edges, queries): tree = Tree(values) for u, v in edges: tree.add_edge(u, v) tree.preprocess() results = [tree.get_subtree_sum(r) for r in queries] return results"},{"question":"class Inventory: A class to manage an inventory of items for a store. The class should allow adding items, retrieving the quantity of a specific item, and removing items. Additionally, it should be able to provide a list of all items sorted by their name in alphabetical order. >>> inventory = Inventory() >>> inventory.add_item('apple', 50) >>> inventory.add_item('banana', 30) >>> inventory.add_item('orange', 40) >>> inventory.get_quantity('banana') 30 >>> inventory.remove_item('apple', 20) >>> inventory.get_quantity('apple') 30 >>> inventory.get_all_items() ['apple', 'banana', 'orange'] def __init__(self): pass def add_item(self, item_name, quantity): pass def get_quantity(self, item_name): pass def remove_item(self, item_name, quantity): pass def get_all_items(self): pass","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_name, quantity): if item_name in self.items: self.items[item_name] += quantity else: self.items[item_name] = quantity def get_quantity(self, item_name): # Return the quantity of the item or 0 if the item does not exist return self.items.get(item_name, 0) def remove_item(self, item_name, quantity): if item_name in self.items: if self.items[item_name] > quantity: self.items[item_name] -= quantity elif self.items[item_name] == quantity: del self.items[item_name] else: raise ValueError(\\"Not enough quantity to remove\\") else: raise KeyError(\\"Item does not exist\\") def get_all_items(self): # Return the list of items sorted by their name in alphabetical order return sorted(self.items.keys())"},{"question":"from typing import List def minimum_operations_to_equalize(T: int, test_cases: List[List[int]]) -> List[int]: Determine the minimum number of operations required to make all elements in the array equal. Args: - T: an integer representing the number of test cases - test_cases: a list of test cases, each containing an integer N followed by N space-separated integers representing the array elements. Returns: A list of integers where each integer represents the minimum number of operations required to make all array elements equal. >>> minimum_operations_to_equalize(2, [[5, 1, 2, 3, 4, 5], [3, 10, 10, 10]]) [6, 0] >>> minimum_operations_to_equalize(3, [[1, 100], [1, 200], [1, 300]]) [0, 0, 0]","solution":"def minimum_operations_to_equalize(T, test_cases): results = [] for case in test_cases: N = case[0] arr = case[1:] arr.sort() median = arr[N // 2] operations = sum(abs(x - median) for x in arr) results.append(operations) return results"},{"question":"from typing import List def find_duplicates(lst: List[int]) -> List[int]: Given a list of integers, returns a list of all the values that appear more than once in the input list in ascending order. If no value appears more than once, the function should return an empty list. >>> find_duplicates([1, 2, 3, 2, 1, -4, -4, 6, 7]) [-4, 1, 2] >>> find_duplicates([5, 3, 9, 0, 7]) [] >>> find_duplicates([1, 1, 1, 2, 2, 3, 3, 4, 5]) [1, 2, 3]","solution":"def find_duplicates(lst): Returns a list of values that appear more than once in the input list in ascending order. from collections import Counter counts = Counter(lst) duplicates = [item for item, count in counts.items() if count > 1] return sorted(duplicates)"},{"question":"def find_primes(start: int, end: int) -> List[int]: Returns a list of all prime numbers within the range [start, end]. >>> find_primes(10, 30) [11, 13, 17, 19, 23, 29] >>> find_primes(0, 10) [2, 3, 5, 7] >>> find_primes(-10, 10) [2, 3, 5, 7] >>> find_primes(13, 13) [13] >>> find_primes(14, 16) [] >>> find_primes(30, 10) [] >>> find_primes(-10, -1) [] >>> find_primes(1, 100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def find_primes(start, end): Returns a list of all prime numbers within the range [start, end]. if end < start: return [] def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True primes = [] for num in range(start, end + 1): if is_prime(num): primes.append(num) return primes"},{"question":"def total_gifts_exchanged(T: int, test_cases: List[int]) -> List[int]: Determine how many total gifts need to be exchanged to complete the game. Parameters: - T: Number of test cases. - test_cases: List of integers where each integer represents the number of friends (N) in each test case. Returns: List of integers representing the total number of gifts exchanged for each test case. >>> total_gifts_exchanged(2, [1, 4]) [0, 4] >>> total_gifts_exchanged(3, [1, 4, 10]) [0, 4, 10] results = [] for i in range(T): N = test_cases[i] if N == 1: results.append(0) else: results.append(N) return results def test_single_friend(): assert total_gifts_exchanged(1, [1]) == [0] def test_multiple_friends(): assert total_gifts_exchanged(1, [4]) == [4] assert total_gifts_exchanged(1, [2]) == [2] assert total_gifts_exchanged(1, [10]) == [10] def test_mixed_cases(): assert total_gifts_exchanged(3, [1, 4, 10]) == [0, 4, 10] def test_large_numbers(): assert total_gifts_exchanged(1, [1000000000]) == [1000000000] def test_multiple_test_cases(): assert total_gifts_exchanged(2, [1, 4]) == [0, 4] assert total_gifts_exchanged(5, [1, 100, 1000, 10000, 100000]) == [0, 100, 1000, 10000, 100000]","solution":"def total_gifts_exchanged(T, test_cases): results = [] for i in range(T): N = test_cases[i] if N == 1: results.append(0) else: results.append(N) return results"},{"question":"def merge_dictionaries(dict_list: list) -> dict: Merge multiple dictionaries into a single dictionary. For overlapping keys, store values as a list in the merged dictionary. :param dict_list: List of dictionaries to be merged :return: Merged dictionary >>> merge_dictionaries([{\\"a\\": 1}, {\\"b\\": 2}]) {'a': 1, 'b': 2} >>> merge_dictionaries([{\\"a\\": 1, \\"b\\": 2}, {\\"b\\": 3, \\"c\\": 4}]) {'a': 1, 'b': [2, 3], 'c': 4} >>> merge_dictionaries([{\\"a\\": 1, \\"b\\": 2}, {\\"a\\": 3, \\"c\\": 4}, {\\"a\\": 5}]) {'a': [1, 3, 5], 'b': 2, 'c': 4} >>> merge_dictionaries([{\\"a\\": 1, \\"b\\": 2, \\"c\\": 3, \\"d\\": 4, \\"e\\": 5, \\"f\\": 6, \\"g\\": 7, \\"h\\": 8, \\"i\\": 9, \\"j\\": 10}]) {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10}","solution":"def merge_dictionaries(dict_list): Merge multiple dictionaries into a single dictionary. For overlapping keys, store values as a list in the merged dictionary. :param dict_list: List of dictionaries to be merged :return: Merged dictionary merged_dict = {} for d in dict_list: for key, value in d.items(): if key in merged_dict: if isinstance(merged_dict[key], list): merged_dict[key].append(value) else: merged_dict[key] = [merged_dict[key], value] else: merged_dict[key] = value return merged_dict"},{"question":"class MyQueue: Implement a queue using two stacks. Methods: - __init__(): Initializes an empty queue. - push(x: int): Adds element x to the end of the queue. - pop() -> int: Removes and returns the element from the front of the queue. - peek() -> int: Returns the front element of the queue without removing it. - empty() -> bool: Returns True if the queue is empty, otherwise False. Example: >>> queue = MyQueue() >>> queue.push(1) >>> queue.push(2) >>> queue.peek() # returns 1 >>> queue.pop() # returns 1 >>> queue.empty() # returns False def __init__(self): pass def push(self, x: int): pass def pop(self) -> int: pass def peek(self) -> int: pass def empty(self) -> bool: pass # Unit tests def test_queue_initially_empty(): queue = MyQueue() assert queue.empty() == True def test_queue_push(): queue = MyQueue() queue.push(1) assert queue.empty() == False def test_queue_peek(): queue = MyQueue() queue.push(1) queue.push(2) assert queue.peek() == 1 assert queue.empty() == False def test_queue_pop(): queue = MyQueue() queue.push(1) queue.push(2) assert queue.pop() == 1 assert queue.peek() == 2 def test_queue_pop_until_empty(): queue = MyQueue() queue.push(1) queue.push(2) queue.push(3) assert queue.pop() == 1 assert queue.pop() == 2 assert queue.pop() == 3 assert queue.empty() == True","solution":"class MyQueue: def __init__(self): Initialize two stacks to simulate queue operations. self.input_stack = [] self.output_stack = [] def push(self, x: int): Add element x to the end of the queue. self.input_stack.append(x) def pop(self) -> int: Removes the element from the front of the queue and returns it. self._move_input_to_output() return self.output_stack.pop() def peek(self) -> int: Returns the element at the front of the queue without removing it. self._move_input_to_output() return self.output_stack[-1] def empty(self) -> bool: Returns True if the queue is empty, otherwise False. return not self.input_stack and not self.output_stack def _move_input_to_output(self): Move elements from input stack to output stack if output stack is empty. if not self.output_stack: while self.input_stack: self.output_stack.append(self.input_stack.pop())"},{"question":"def common_elements(list_of_lists): Finds the common elements among multiple lists of integers. Parameters: list_of_lists (list of list of int): A list of lists of integers. Returns: list of int: A list of integers that are present in every sublist. Examples: >>> common_elements([ ... [1, 2, 3, 4], ... [3, 4, 5, 6], ... [4, 3, 6, 7] ... ]) [3, 4] >>> common_elements([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [] >>> common_elements([ ... [1, 2, 3], ... [1, 2, 3], ... [1, 2, 3] ... ]) [1, 2, 3] # Your implementation here","solution":"def common_elements(list_of_lists): Finds the common elements among multiple lists of integers. Parameters: list_of_lists (list of list of int): A list of lists of integers. Returns: list of int: A list of integers that are present in every sublist. if not list_of_lists: return [] common_set = set(list_of_lists[0]) for lst in list_of_lists[1:]: common_set.intersection_update(lst) return list(common_set)"},{"question":"from typing import Dict, List def commonEmployees(projects: Dict[int, List[int]], proj1: int, proj2: int) -> List[int]: Returns a list of employee IDs that are common to both projects proj1 and proj2. The returned list is sorted in ascending order. Args: projects: Dictionary where keys are project IDs and values are lists of employee IDs. proj1: The first project ID. proj2: The second project ID. Returns: A list of common employee IDs sorted in ascending order. If no common employees, returns an empty list. >>> projects = { >>> 101: [1, 2, 3, 9, 10], >>> 102: [2, 3, 7, 8, 9], >>> 103: [3, 4, 9, 10] >>> } >>> commonEmployees(projects, 101, 103) [3, 9, 10] >>> commonEmployees(projects, 102, 103) [3, 9]","solution":"from typing import Dict, List def commonEmployees(projects: Dict[int, List[int]], proj1: int, proj2: int) -> List[int]: Returns a list of employee IDs that are common to both projects proj1 and proj2. The returned list is sorted in ascending order. Args: projects: Dictionary where keys are project IDs and values are lists of employee IDs. proj1: The first project ID. proj2: The second project ID. Returns: A list of common employee IDs sorted in ascending order. If no common employees, returns an empty list. if proj1 not in projects or proj2 not in projects: return [] employees_proj1 = set(projects.get(proj1, [])) employees_proj2 = set(projects.get(proj2, [])) common_employees = sorted(list(employees_proj1 & employees_proj2)) return common_employees"},{"question":"def mps_length(s: str) -> int: Finds the length of the Maximum Palindrome Substring (MPS) in the given string s. If no such palindrome exists, returns -1. Examples: >>> mps_length(\\"ababa\\") 3 >>> mps_length(\\"abcde\\") -1 pass def test_example_1(): assert mps_length(\\"ababa\\") == 3 def test_example_2(): assert mps_length(\\"abcde\\") == -1 def test_long_string_no_repeats(): assert mps_length(\\"abcdefghij\\") == -1 def test_single_character(): assert mps_length(\\"a\\") == -1 def test_large_string_with_palindromes(): assert mps_length(\\"aabbaa\\") == 2 def test_duplicate_character_palindrome(): assert mps_length(\\"aa\\") == 1 def test_complex_case(): assert mps_length(\\"racecarannakayakracecar\\") == 7 def test_all_same_characters(): assert mps_length(\\"aaaaa\\") == 4","solution":"def mps_length(s): Finds the length of the Maximum Palindrome Substring (MPS) in the given string s. If no such palindrome exists, returns -1. n = len(s) if n <= 1: return -1 # Helper function to check if a string is a palindrome def is_palindrome(sub): return sub == sub[::-1] found = False max_length = 0 seen = {} for length in range(1, n): for start in range(n - length + 1): substr = s[start:start + length] if is_palindrome(substr): if substr in seen and seen[substr] != start: max_length = max(max_length, len(substr)) found = True seen[substr] = start return max_length if found else -1"},{"question":"def get_top_student(students: str) -> str: Returns the name of the student with the highest score. If there is a tie, returns the name of the student who appears first in the string. :param students: A string containing names and scores in the format \\"Name1:Score1, Name2:Score2, ...\\" :return: The name of the student with the highest score >>> get_top_student(\\"Alice:95\\") \\"Alice\\" >>> get_top_student(\\"Alice:87, Bob:92, Charlie:87, David:92\\") \\"Bob\\" >>> get_top_student(\\"Alice:87, Bob:92, Charlie:87, David:92, Eve:92\\") \\"Bob\\" >>> get_top_student(\\"Alice:90, Bob:90, Charlie:90, David:90\\") \\"Alice\\" >>> get_top_student(\\"Alice:1, Bob:2, Charlie:0, David:2\\") \\"Bob\\"","solution":"def get_top_student(students: str) -> str: Returns the name of the student with the highest score. If there is a tie, returns the name of the student who appears first in the string. :param students: A string containing names and scores in the format \\"Name1:Score1, Name2:Score2, ...\\" :return: The name of the student with the highest score # Split the input string by ', ' to get individual student details student_details = students.split(', ') # Initialize variables to store the top student name and highest score found top_student = \\"\\" highest_score = -1 # Iterate through each student detail for detail in student_details: name, score = detail.split(':') score = int(score) # Convert score to an integer # Check if the score of the current student is higher than the highest score found so far if score > highest_score: highest_score = score top_student = name # If there is a tie, the first student with the highest score (already encountered) remains the top student return top_student"},{"question":"from typing import List def race_winner(lanes: List[List[int]]) -> int: Determine the winner of the race by calculating the total time of each lane and returning the 1-based index of the lane with the least total time. >>> race_winner([[5, 3, 6], [4, 8, 2], [7, 1, 3]]) 3 >>> race_winner([[10, 10, 10], [9, 9, 9]]) 2 >>> race_winner([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) 1 >>> race_winner([[5], [4], [6]]) 2 >>> race_winner([[1000, 1000], [2000, 1], [0, 3000]]) 1 >>> race_winner([[5, 5, 5], [6, 5, 5], [5, 6, 5]]) 1","solution":"from typing import List def race_winner(lanes: List[List[int]]) -> int: Returns the 1-based index of the winning lane with the least total time. min_time = float('inf') winning_lane = -1 for i, lane in enumerate(lanes): total_time = sum(lane) if total_time < min_time: min_time = total_time winning_lane = i + 1 return winning_lane"},{"question":"def calculate_level(xp: int) -> int: Calculates the player's level based on their total experience points. Levels are defined as follows: - Level 1: 0-999 XP - Level 2: 1000-2999 XP - Level 3: 3000-5999 XP - Level 4: 6000-9999 XP - Level 5: 10000-14999 XP - Level 6: 15000-20999 XP - Level 7: 21000-27999 XP - Level 8: 28000-35999 XP - Level 9: 36000-44999 XP - Level 10: 45000+ XP Args: xp (int): The player's accumulated experience points. Returns: int: The player's level. Raises: ValueError: If XP is negative. >>> calculate_level(500) == 1 >>> calculate_level(1500) == 2 >>> calculate_level(3200) == 3 >>> calculate_level(10000) == 5 >>> calculate_level(45000) == 10","solution":"def calculate_level(xp): Calculates the player's level based on their experience points. Parameters: xp (int): The player's accumulated experience points. Returns: int: The player's level. if xp < 0: raise ValueError(\\"XP cannot be negative.\\") if xp < 1000: return 1 elif xp < 3000: return 2 elif xp < 6000: return 3 elif xp < 10000: return 4 elif xp < 15000: return 5 elif xp < 21000: return 6 elif xp < 28000: return 7 elif xp < 36000: return 8 elif xp < 45000: return 9 else: return 10"},{"question":"def count_subarrays_with_sum_k(nums: List[int], k: int) -> int: Counts the number of contiguous subarrays within \`nums\` which sum up to \`k\`. :param nums: List[int] - The list of integers. :param k: int - The target sum. :return: int - The count of subarrays that sum to \`k\`. pass def test_example1(): nums = [1, 1, 1] k = 2 assert count_subarrays_with_sum_k(nums, k) == 2 def test_example2(): nums = [-1, -1, 1] k = 0 assert count_subarrays_with_sum_k(nums, k) == 1 def test_example3(): nums = [4, -2, -2, 1, 3, -1, 2] k = 3 assert count_subarrays_with_sum_k(nums, k) == 4 def test_zero_target(): nums = [0, 0, 0, 0] k = 0 assert count_subarrays_with_sum_k(nums, k) == 10 def test_empty_array(): nums = [] k = 0 assert count_subarrays_with_sum_k(nums, k) == 0 def test_single_element(): nums = [3] k = 3 assert count_subarrays_with_sum_k(nums, k) == 1 assert count_subarrays_with_sum_k(nums, 4) == 0 def test_all_negative_elements(): nums = [-1, -2, -3, -4] k = -3 assert count_subarrays_with_sum_k(nums, k) == 2 def test_all_positive_elements(): nums = [1, 2, 3, 4] k = 6 assert count_subarrays_with_sum_k(nums, k) == 1","solution":"def count_subarrays_with_sum_k(nums, k): Counts the number of contiguous subarrays within \`nums\` which sum up to \`k\`. :param nums: List[int] - The list of integers. :param k: int - The target sum. :return: int - The count of subarrays that sum to \`k\`. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if current_sum - k in prefix_sums: count += prefix_sums[current_sum - k] if current_sum not in prefix_sums: prefix_sums[current_sum] = 1 else: prefix_sums[current_sum] += 1 return count"},{"question":"def rotate_matrix(matrix): Rotates the given square matrix 90 degrees clockwise. The input to the function will be a 2D list where each sublist represents a row in the matrix. The function should return a new 2D list representing the rotated matrix. Args: matrix (list of list of int): The input square matrix. Returns: list of list of int: The rotated matrix. Examples: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[5]]) [[5]] pass def test_rotate_matrix_3x3(): input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(input_matrix) == rotated_matrix def test_rotate_matrix_2x2(): input_matrix = [ [1, 2], [3, 4] ] rotated_matrix = [ [3, 1], [4, 2] ] assert rotate_matrix(input_matrix) == rotated_matrix def test_rotate_matrix_1x1(): input_matrix = [ [5] ] rotated_matrix = [ [5] ] assert rotate_matrix(input_matrix) == rotated_matrix def test_rotate_matrix_4x4(): input_matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotated_matrix = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(input_matrix) == rotated_matrix def test_rotate_matrix_5x5(): input_matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotated_matrix = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert rotate_matrix(input_matrix) == rotated_matrix","solution":"def rotate_matrix(matrix): Rotates the given square matrix 90 degrees clockwise. Args: matrix (list of list of int): The input square matrix. Returns: list of list of int: The rotated matrix. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)]"},{"question":"def min_operations_to_magic_sequence(n: int, sequence: List[int]) -> int: Determine the minimum number of operations needed to transform the given sequence into a magic sequence. >>> min_operations_to_magic_sequence(4, [4, 3, 2, 1]) 0 >>> min_operations_to_magic_sequence(4, [1, 3, 6, 2]) 6","solution":"def min_operations_to_magic_sequence(n, sequence): operations = 0 for i in range(1, n): operations += abs(sequence[i] - sequence[i-1]) - 1 return operations"},{"question":"def min_lamp_posts(N: int, M: int, ranges: List[int]) -> int: Determine the minimum number of lamp posts required to fully illuminate a road of length N. Args: N (int): The length of the road. M (int): The number of types of lamp posts available. ranges (list of int): The list of ranges for each type of lamp post. Returns: int: The minimum number of lamp posts required to fully illuminate the road. Examples: >>> min_lamp_posts(10, 3, [1, 3, 4]) 3 >>> min_lamp_posts(8, 1, [2]) 4 >>> min_lamp_posts(15, 2, [5, 10]) 2 >>> min_lamp_posts(1, 1, [1]) 1 >>> min_lamp_posts(500, 2, [100, 200]) 3","solution":"def min_lamp_posts(N, M, ranges): Determine the minimum number of lamp posts required to fully illuminate a road of length N. Args: N (int): The length of the road. M (int): The number of types of lamp posts available. ranges (list of int): The list of ranges for each type of lamp post. Returns: int: The minimum number of lamp posts required to fully illuminate the road. # Sort the ranges in descending order ranges.sort(reverse=True) # The maximum range to consider max_range = ranges[0] # Calculate the minimum number of lamp posts needed num_lamps = (N + max_range - 1) // max_range return num_lamps"},{"question":"def bacteria_count(hours: int) -> int: Returns the count of bacteria after the given number of hours. Parameters: hours (int): The number of hours the bacteria have been multiplying. Returns: int: The total number of bacteria present after the given number of hours. Example: >>> bacteria_count(5) 32 >>> bacteria_count(10) 1024","solution":"def bacteria_count(hours): Returns the count of bacteria after the given number of hours. Parameters: hours (int): The number of hours the bacteria have been multiplying. Returns: int: The total number of bacteria present after the given number of hours. return 2 ** hours"},{"question":"class CipherDecoder: @staticmethod def decode_message(message: str) -> str: Decodes the given message by reversing the words back to their normal order while retaining the spaces between them. Parameters: message (str): A string that contains lowercase letters and spaces. Returns: str: The decoded message. Example: >>> CipherDecoder.decode_message(\\"sihT si a tset egassem\\") == \\"This is a test message\\" >>> CipherDecoder.decode_message(\\"olleh\\") == \\"hello\\" import unittest class TestCipherDecoder(unittest.TestCase): def test_decode_message_single_word(self): self.assertEqual(CipherDecoder.decode_message(\\"olleh\\"), \\"hello\\") def test_decode_message_multiple_words(self): self.assertEqual(CipherDecoder.decode_message(\\"sihT si a tset egassem\\"), \\"This is a test message\\") def test_decode_message_with_multiple_spaces(self): self.assertEqual(CipherDecoder.decode_message(\\"sihT si a tset egassem\\"), \\"This is a test message\\") def test_decode_message_empty_string(self): self.assertEqual(CipherDecoder.decode_message(\\"\\"), \\"\\") def test_decode_message_only_spaces(self): self.assertEqual(CipherDecoder.decode_message(\\" \\"), \\" \\") if __name__ == \\"__main__\\": unittest.main()","solution":"class CipherDecoder: @staticmethod def decode_message(message): Decodes the given message by reversing the words back to their normal order while retaining the spaces between them. Parameters: message (str): A string that contains lowercase letters and spaces. Returns: str: The decoded message. return ' '.join(word[::-1] for word in message.split(' '))"},{"question":"def maxTile(tiles): Given a list of integers representing the numbers on the tiles, this function returns the maximum number possible on a single tile after performing merges from left to right. >>> maxTile([2, 2]) 4 >>> maxTile([2, 2, 4, 8, 2, 2]) 16 >>> maxTile([1, 2, 4]) 4 >>> maxTile([2, 2, 2, 2]) 8 >>> maxTile([32, 32, 64, 64, 128]) 256 >>> maxTile([]) 0 >>> maxTile([4]) 4 >>> maxTile([2, 2, 2, 2, 2, 2]) 8 >>> maxTile([2, 4, 8, 16]) 16","solution":"def maxTile(tiles): Given a list of integers representing the numbers on the tiles, this function returns the maximum number possible on a single tile after performing merges from left to right. while True: merged = False new_tiles = [] i = 0 while i < len(tiles): if i + 1 < len(tiles) and tiles[i] == tiles[i + 1]: new_tiles.append(tiles[i] * 2) i += 2 merged = True else: new_tiles.append(tiles[i]) i += 1 tiles = new_tiles if not merged: break return max(tiles) if tiles else 0"},{"question":"def trap_rainwater(heights): Calculate the total amount of rainwater that can be trapped between buildings using a two-pointer approach. :param heights: List of non-negative integers representing the heights of buildings. :return: Total amount of trapped rainwater. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([1, 1, 1, 1, 1]) 0 >>> trap_rainwater([1, 2, 3, 4, 5]) 0 >>> trap_rainwater([5, 4, 3, 2, 1]) 0 >>> trap_rainwater([2, 0, 2]) 2 >>> trap_rainwater([3, 0, 1, 3, 0, 5]) 8 >>> trap_rainwater([0]) 0 >>> trap_rainwater([]) 0","solution":"def trap_rainwater(heights): Calculate the total amount of rainwater that can be trapped between buildings. :param heights: List of non-negative integers representing the heights of buildings. :return: Total amount of trapped rainwater. if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = 0, 0 water_trapped = 0 while left < right: if heights[left] < heights[right]: if heights[left] >= left_max: left_max = heights[left] else: water_trapped += left_max - heights[left] left += 1 else: if heights[right] >= right_max: right_max = heights[right] else: water_trapped += right_max - heights[right] right -= 1 return water_trapped"},{"question":"def find_min_sum_distance_index(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array a consisting of n integers numbered from 1 to n, this function finds the smallest index k (1 <= k <= n) such that the \\"sum distance\\" of a_k is minimized. The \\"sum distance\\" of an element x is defined as the sum of absolute differences between x and all other elements in the array: S(x) = sum(|x - a_i| for all i in range(1, n+1)) Parameters: - t (int): the number of test cases. - test_cases (List[Tuple[int, List[int]]]): a list of test cases, where each test case is a tuple consisting of an integer n and a list of n integers. Returns: - List[int]: A list of smallest indices k for each test case. Example: >>> find_min_sum_distance_index(2, [(3, [1, 2, 3]), (4, [5, 3, 1, 2])]) [2, 4]","solution":"def find_min_sum_distance_index(t, test_cases): results = [] for case in test_cases: n, arr = case arr_sorted = sorted(arr) median_index = (n - 1) // 2 median_value = arr_sorted[median_index] for i in range(n): if arr[i] == median_value: results.append(i + 1) break return results"},{"question":"def summarize_types(data_list): Returns a dictionary summarizing the count of each data type in the list. >>> summarize_types([1, 2.5, \\"hello\\", 3, \\"world\\", 4.0, 5]) {'int': 3, 'float': 2, 'str': 2} >>> summarize_types([\\"apple\\", \\"banana\\", 7, 8.2, 3.14]) {'int': 1, 'float': 2, 'str': 2} >>> summarize_types([True, \\"False\\", 3, 2.0, True]) {'int': 1, 'float': 1, 'str': 1, 'bool': 2} pass","solution":"def summarize_types(data_list): Returns a dictionary summarizing the count of each data type in the list. type_counts = {} for item in data_list: item_type = type(item).__name__ if item_type in type_counts: type_counts[item_type] += 1 else: type_counts[item_type] = 1 return type_counts"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in a given string without reversing the letters within each word. :param s: The string to reverse the words in :return: A string with the words in reversed order >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"Python is fun\\") \\"fun is Python\\" >>> reverse_words(\\"keep calm and code on\\") \\"on code and calm keep\\" >>> reverse_words(\\"open source contributions rock\\") \\"rock contributions source open\\"","solution":"def reverse_words(s): Reverses the order of words in a given string without reversing the letters within each word. :param s: The string to reverse the words in :return: A string with the words in reversed order return ' '.join(s.split()[::-1])"},{"question":"def department_counts(employees): Returns a dictionary with the count of employees in each department. Args: employees (list): List of dictionaries, each representing an employee with keys 'name' and 'department'. Returns: dict: A dictionary where keys are department names and values are the count of employees in those departments. Examples: >>> employees = [ {'name': 'Alice', 'department': 'HR'}, {'name': 'Bob', 'department': 'Engineering'}, {'name': 'Charlie', 'department': 'HR'}, {'name': 'David', 'department': 'Engineering'}, {'name': 'Eve', 'department': 'Marketing'} ] >>> department_counts(employees) {'HR': 2, 'Engineering': 2, 'Marketing': 1} >>> employees = [ {'name': 'Alice', 'department': 'Sales'}, {'name': 'Carlos', 'department': 'Sales'}, {'name': 'Dana', 'department': 'HR'}, {'name': 'Eve', 'department': 'Sales'}, {'name': 'Bob', 'department': 'Engineering'}, {'name': 'David', 'department': 'Engineering'} ] >>> department_counts(employees) {'Sales': 3, 'HR': 1, 'Engineering': 2} pass","solution":"def department_counts(employees): Returns a dictionary with the count of employees in each department. department_count = {} for employee in employees: department = employee['department'] if department in department_count: department_count[department] += 1 else: department_count[department] = 1 return department_count"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"a\\" * 50000) 1 >>> length_of_longest_substring(\\"abba\\") 2 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 start, max_length = 0, 0 char_index_map = {} for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def compare_temperatures(data: List[int]) -> List[str]: Compares each day's temperature to the first day's temperature and describes whether it was \\"hotter,\\" \\"colder,\\" or \\"the same.\\" Parameters: - data (List[int]): A list of integers representing daily temperatures. Returns: - List[str]: A list of strings describing the relative temperature to the first day's temperature. Examples: >>> compare_temperatures([70, 74, 68, 70, 72]) ['the same', 'hotter', 'colder', 'the same', 'hotter'] >>> compare_temperatures([70, 70, 70, 70]) ['the same', 'the same', 'the same', 'the same']","solution":"from typing import List def compare_temperatures(data: List[int]) -> List[str]: Compares each day's temperature to the first day's temperature and describes whether it was \\"hotter,\\" \\"colder,\\" or \\"the same.\\" Parameters: - data (List[int]): A list of integers representing daily temperatures. Returns: - List[str]: A list of strings describing the relative temperature to the first day's temperature. if not data: return [] first_day_temp = data[0] result = [] for temp in data: if temp > first_day_temp: result.append('hotter') elif temp < first_day_temp: result.append('colder') else: result.append('the same') return result"},{"question":"def max_profit_in_a_day(profits): This function returns the maximum sum of a contiguous subarray representing the highest profit that can be achieved in a continuous period of hours. >>> max_profit_in_a_day([5]) == 5 >>> max_profit_in_a_day([-5]) == -5 >>> max_profit_in_a_day([4, -1, 2, 1, -5, 4]) == 6 >>> max_profit_in_a_day([1, 2, 3, 4, 5]) == 15 >>> max_profit_in_a_day([-3, -4, -1, -2]) == -1 >>> max_profit_in_a_day([2, 3, -6, 4, 2]) == 6 >>> max_profit_in_a_day([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6","solution":"def max_profit_in_a_day(profits): This function returns the maximum sum of a contiguous subarray representing the highest profit that can be achieved in a continuous period of hours. It implements Kadane's algorithm. current_max = total_max = profits[0] for profit in profits[1:]: current_max = max(profit, current_max + profit) total_max = max(total_max, current_max) return total_max"},{"question":"def is_subsequence(N: int, M: int, A: List[int], B: List[int]) -> bool: Check if sequence B is a subsequence of sequence A. >>> is_subsequence(5, 3, [1, 2, 3, 4, 5], [2, 4, 5]) True >>> is_subsequence(5, 2, [1, 2, 3, 4, 5], [4, 6]) False i, j = 0, 0 while i < N and j < M: if A[i] == B[j]: j += 1 i += 1 return j == M def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[str]: Process multiple test cases to determine if B is a subsequence of A for each case. Args: - T: The number of test cases. - test_cases: List containing tuples of the form (N, M, A, B) where: - N: Length of sequence A. - M: Length of sequence B. - A: The list of integers forming sequence A. - B: The list of integers forming sequence B. Returns: - A list of strings \\"YES\\" or \\"NO\\" for each test case. results = [] for test_case in test_cases: N, M, A, B = test_case if is_subsequence(N, M, A, B): results.append(\\"YES\\") else: results.append(\\"NO\\") return results","solution":"def is_subsequence(N, M, A, B): i, j = 0, 0 while i < N and j < M: if A[i] == B[j]: j += 1 i += 1 return j == M def process_test_cases(T, test_cases): results = [] for test_case in test_cases: N, M, A, B = test_case if is_subsequence(N, M, A, B): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def sumOfDigits(n: int) -> int: Returns the single-digit sum of the digits of the absolute value of the integer n. >>> sumOfDigits(1234) 1 >>> sumOfDigits(987) 6 >>> sumOfDigits(-493) 7 >>> sumOfDigits(9999) 9 >>> sumOfDigits(0) 0","solution":"def sumOfDigits(n): Returns the single-digit sum of the digits of the absolute value of the integer n. n = abs(n) # Consider only the absolute value of the input integer while n >= 10: # Continue until n becomes a single-digit number n = sum(int(digit) for digit in str(n)) # Compute the sum of the digits return n"},{"question":"from typing import List, Dict, Tuple, Union def studentManager(records: List[Dict[str, Union[int, str, float]]], operations: List[Tuple[str, Union[Tuple[int, str, float], Tuple[int, float], int]]]) -> List[Dict[str, Union[int, str, float]]]: Manages student records according to the given operations. :param records: List of dictionaries with keys 'id', 'name', and 'score'. :param operations: List of operations to perform on the records. :return: Updated list of student records after performing all operations. >>> records = [{'id': 1, 'name': 'Alice', 'score': 85}, {'id': 2, 'name': 'Bob', 'score': 90}] >>> operations = [('add', (3, 'Charlie', 78))] >>> studentManager(records, operations) [{'id': 1, 'name': 'Alice', 'score': 85}, {'id': 2, 'name': 'Bob', 'score': 90}, {'id': 3, 'name': 'Charlie', 'score': 78}] >>> records = [{'id': 1, 'name': 'Alice', 'score': 85}, {'id': 2, 'name': 'Bob', 'score': 90}] >>> operations = [('remove', 1)] >>> studentManager(records, operations) [{'id': 2, 'name': 'Bob', 'score': 90}] >>> records = [{'id': 1, 'name': 'Alice', 'score': 85}, {'id': 2, 'name': 'Bob', 'score': 90}] >>> operations = [('update', (2, 95))] >>> studentManager(records, operations) [{'id': 1, 'name': 'Alice', 'score': 85}, {'id': 2, 'name': 'Bob', 'score': 95}] >>> records = [{'id': 1, 'name': 'Alice', 'score': 85}, {'id': 2, 'name': 'Bob', 'score': 90}, {'id': 3, 'name': 'Charlie', 'score': 78}] >>> operations = [('average', 80)] >>> studentManager(records, operations) [{'id': 1, 'name': 'Alice', 'score': 85}, {'id': 2, 'name': 'Bob', 'score': 90}, {'id': 3, 'name': 'Charlie', 'score': 78}, {'average': 87.5}]","solution":"def studentManager(records, operations): Manages student records according to the given operations. :param records: List of dictionaries with keys 'id', 'name', and 'score'. :param operations: List of operations to perform on the records. :return: Updated list of student records after performing all operations. record_dict = {record['id']: record for record in records} for operation in operations: op_type = operation[0] if op_type == \\"add\\": student_id, student_name, student_score = operation[1] record_dict[student_id] = {'id': student_id, 'name': student_name, 'score': student_score} elif op_type == \\"remove\\": student_id = operation[1] if student_id in record_dict: del record_dict[student_id] elif op_type == \\"update\\": student_id, new_score = operation[1] if student_id in record_dict: record_dict[student_id]['score'] = new_score elif op_type == \\"average\\": threshold = operation[1] scores = [record['score'] for record in record_dict.values() if record['score'] >= threshold] average_score = round(sum(scores) / len(scores), 2) if scores else 0 record_dict['average'] = {'average': average_score} # Convert back to list format result = list(record_dict.values()) # Ensure 'average' dictionary remains at the end if exists if 'average' in record_dict: result.append(record_dict['average']) result.remove({'average': record_dict['average']['average']}) return result"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given NxN matrix 90 degrees clockwise in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix) >>> print(matrix) [ [3, 1], [4, 2] ] pass # Unit tests def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_matrix_2x2(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_matrix_4x4(): matrix = [ [ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] expected = [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_matrix_1x1(): matrix = [ [1] ] expected = [ [1] ] rotate_matrix(matrix) assert matrix == expected","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def count_differing_characters(s1: str, s2: str) -> int: Returns the number of characters that differ between s1 and s2 at the same positions. >>> count_differing_characters(\\"abcde\\", \\"abcde\\") 0 >>> count_differing_characters(\\"abcdef\\", \\"abcfgh\\") 3","solution":"def count_differing_characters(s1, s2): Returns the number of characters that differ between s1 and s2 at the same positions. return sum(1 for a, b in zip(s1, s2) if a != b)"},{"question":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to the target. Assumes that there's exactly one solution. >>> find_two_sum([2, 7, 11, 15], 9) [0, 1] >>> find_two_sum([3, 2, 4], 6) [1, 2] >>> find_two_sum([3, 3], 6) [0, 1]","solution":"def find_two_sum(nums, target): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to the target. Assumes that there's exactly one solution. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def should_door_open(T: int, N: int, D: int, distances: List[int]) -> str: Determines if the door should remain open based on distances measured. Parameters: T (int): Total number of intervals checked. N (int): Number of continuous intervals needed to keep the door open. D (int): Threshold distance. distances (list of int): List of distances measured at each interval. Returns: str: \\"Open\\" if there are more than N continuous intervals with distances less than or equal to D, otherwise \\"Closed\\". >>> should_door_open(10, 3, 5, [1, 2, 3, 6, 7, 2, 1, 3, 4, 5]) \\"Open\\" >>> should_door_open(10, 3, 5, [6, 7, 8, 9, 10, 6, 7, 8, 9, 10]) \\"Closed\\" >>> should_door_open(1, 1, 5, [4]) \\"Open\\" >>> should_door_open(1, 1, 5, [6]) \\"Closed\\" >>> should_door_open(8, 2, 5, [1, 5, 6, 2, 3, 6, 4, 3]) \\"Open\\" >>> should_door_open(5, 5, 10, [9, 8, 9, 10, 7]) \\"Open\\" >>> should_door_open(6, 2, 3, [1, 2, 3, 2, 2, 3]) \\"Open\\"","solution":"def should_door_open(T, N, D, distances): Determines if the door should remain open based on distances measured. Parameters: T (int): Total number of intervals checked. N (int): Number of continuous intervals needed to keep the door open. D (int): Threshold distance. distances (list of int): List of distances measured at each interval. Returns: str: \\"Open\\" if there are more than N continuous intervals with distances less than or equal to D, otherwise \\"Closed\\". continuous_count = 0 for distance in distances: if distance <= D: continuous_count += 1 if continuous_count >= N: return \\"Open\\" else: continuous_count = 0 return \\"Closed\\" # Example usage: # T = 10, N = 3, D = 5 # Distances: [1, 2, 3, 6, 7, 2, 1, 3, 4, 5] # should_door_open(10, 3, 5, [1, 2, 3, 6, 7, 2, 1, 3, 4, 5]) -> \\"Open\\""},{"question":"def add_seconds(time: str, n: int) -> str: Adds n seconds to the given time. Parameters: time (str): A string representing the time in \\"HH:MM:SS\\" format. n (int): The number of seconds to add. Returns: str: The resulting time in \\"HH:MM:SS\\" format. Examples: >>> add_seconds(\\"12:34:56\\", 10) \\"12:35:06\\" >>> add_seconds(\\"23:59:59\\", 1) \\"00:00:00\\" >>> add_seconds(\\"00:00:00\\", 3661) \\"01:01:01\\"","solution":"def add_seconds(time: str, n: int) -> str: Adds n seconds to the given time. Parameters: time (str): A string representing the time in \\"HH:MM:SS\\" format. n (int): The number of seconds to add. Returns: str: The resulting time in \\"HH:MM:SS\\" format. # Parse the input time hh, mm, ss = map(int, time.split(':')) # Convert the total time to seconds total_seconds = hh * 3600 + mm * 60 + ss + n # Calculate the new hours, minutes, and seconds new_hh = (total_seconds // 3600) % 24 total_seconds %= 3600 new_mm = total_seconds // 60 new_ss = total_seconds % 60 # Format the results as \\"HH:MM:SS\\" return f\\"{new_hh:02}:{new_mm:02}:{new_ss:02}\\""},{"question":"def longest_consecutive_sequence(s: str) -> dict: Identify the longest consecutive sequence of a single character within a given string, and return an object with the character and the length of the sequence. >>> longest_consecutive_sequence(\\"aaabbcaaa\\") {'char': 'a', 'length': 3} >>> longest_consecutive_sequence(\\"aabbbccccccddddd\\") {'char': 'c', 'length': 6} >>> longest_consecutive_sequence(\\"abcd\\") {'char': 'a', 'length': 1} >>> longest_consecutive_sequence(\\"\\") {'char': '', 'length': 0}","solution":"def longest_consecutive_sequence(s): if not s: return {'char': '', 'length': 0} max_char = s[0] max_len = 1 current_char = s[0] current_len = 1 for i in range(1, len(s)): if s[i] == current_char: current_len += 1 else: if current_len > max_len: max_len = current_len max_char = current_char current_char = s[i] current_len = 1 if current_len > max_len: max_len = current_len max_char = current_char return {'char': max_char, 'length': max_len}"},{"question":"def can_form_by_circular_shift(A: str, B: str) -> str: Determines if string B can be formed by any number of circular shifts of string A. >>> can_form_by_circular_shift(\\"abcde\\", \\"cdeab\\") == \\"YES\\" >>> can_form_by_circular_shift(\\"abcde\\", \\"abced\\") == \\"NO\\" >>> can_form_by_circular_shift(\\"abc\\", \\"abc\\") == \\"YES\\" >>> can_form_by_circular_shift(\\"a\\", \\"a\\") == \\"YES\\" >>> can_form_by_circular_shift(\\"abc\\", \\"bac\\") == \\"NO\\" >>> can_form_by_circular_shift(\\"abc\\", \\"abcd\\") == \\"NO\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process multiple test cases for the circular shift problem. >>> process_test_cases(3, [\\"abcde\\", \\"cdeab\\", \\"abcde\\", \\"abced\\", \\"abc\\", \\"abc\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [\\"a\\", \\"a\\", \\"aa\\", \\"aa\\"]) == [\\"YES\\", \\"YES\\"]","solution":"def can_form_by_circular_shift(A, B): Determines if string B can be formed by any number of circular shifts of string A. if len(A) != len(B): return \\"NO\\" return \\"YES\\" if B in (A + A) else \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): A = test_cases[i * 2] B = test_cases[i * 2 + 1] results.append(can_form_by_circular_shift(A, B)) return results"},{"question":"class Inventory: A class to keep track of car inventory. Supports adding and removing cars, querying by VIN, and retrieving all cars manufactured in a specific year. def __init__(self): # Initializes the inventory storage. pass def add_car(self, vin, model, year): Adds a car to the inventory. Args: vin (str): The unique identifier for the car. model (str): The model name of the car. year (int): The year the car was manufactured. pass def remove_car(self, vin): Removes the car associated with the given VIN from the inventory. Args: vin (str): The unique identifier for the car to be removed. If the car doesn't exist, do nothing. pass def get_car(self, vin): Returns details of the car with the given VIN. Args: vin (str): The unique identifier for the car. Returns: tuple: A tuple (vin, model, year) if the car exists, else None. pass def get_cars_by_year(self, year): Returns a list of cars manufactured in the specified year. Args: year (int): The year of manufacturing. Returns: list: A list of tuples (vin, model, year) for all cars in the specified year. Returns an empty list if no cars are found. pass from solution import Inventory def test_add_and_get_car(): inventory = Inventory() inventory.add_car(\\"1HGCM82633A123456\\", \\"Honda Accord\\", 2003) assert inventory.get_car(\\"1HGCM82633A123456\\") == (\\"1HGCM82633A123456\\", \\"Honda Accord\\", 2003) def test_remove_car(): inventory = Inventory() inventory.add_car(\\"1HGCM82633A123456\\", \\"Honda Accord\\", 2003) inventory.remove_car(\\"1HGCM82633A123456\\") assert inventory.get_car(\\"1HGCM82633A123456\\") == None def test_get_cars_by_year(): inventory = Inventory() inventory.add_car(\\"1HGCM82633A123456\\", \\"Honda Accord\\", 2003) inventory.add_car(\\"1FTFW1EFXEKF51234\\", \\"Ford F-150\\", 2014) inventory.add_car(\\"2HNYD28263H123456\\", \\"Acura MDX\\", 2003) assert inventory.get_cars_by_year(2003) == [ (\\"1HGCM82633A123456\\", \\"Honda Accord\\", 2003), (\\"2HNYD28263H123456\\", \\"Acura MDX\\", 2003)] assert inventory.get_cars_by_year(2014) == [ (\\"1FTFW1EFXEKF51234\\", \\"Ford F-150\\", 2014)] assert inventory.get_cars_by_year(2000) == [] def test_remove_car_updates_year_list(): inventory = Inventory() inventory.add_car(\\"1HGCM82633A123456\\", \\"Honda Accord\\", 2003) inventory.add_car(\\"2HNYD28263H123456\\", \\"Acura MDX\\", 2003) inventory.remove_car(\\"1HGCM82633A123456\\") assert inventory.get_cars_by_year(2003) == [ (\\"2HNYD28263H123456\\", \\"Acura MDX\\", 2003)]","solution":"class Inventory: def __init__(self): self.cars_by_vin = {} self.cars_by_year = {} def add_car(self, vin, model, year): if vin not in self.cars_by_vin: self.cars_by_vin[vin] = (vin, model, year) if year not in self.cars_by_year: self.cars_by_year[year] = [] self.cars_by_year[year].append((vin, model, year)) def remove_car(self, vin): car = self.cars_by_vin.pop(vin, None) if car: self.cars_by_year[car[2]].remove(car) if not self.cars_by_year[car[2]]: del self.cars_by_year[car[2]] def get_car(self, vin): return self.cars_by_vin.get(vin, None) def get_cars_by_year(self, year): return self.cars_by_year.get(year, [])"},{"question":"from datetime import datetime from typing import List, Tuple def totalTimeSpent(movements: List[Tuple[str, str]]) -> int: Calculate the total time spent in the building by all residents. >>> totalTimeSpent([('08:00', '12:00')]) 240 >>> totalTimeSpent([('08:00', '12:00'), ('14:00', '18:00'), ('09:30', '10:30')]) 540 >>> totalTimeSpent([('08:00', '12:00'), ('11:00', '13:00')]) 360 >>> totalTimeSpent([('00:00', '23:59')]) 1439 >>> totalTimeSpent([('10:00', '10:00')]) 0 >>> totalTimeSpent([]) 0","solution":"from datetime import datetime def totalTimeSpent(movements): total_minutes = 0 for entry, exit in movements: fmt = '%H:%M' entry_time = datetime.strptime(entry, fmt) exit_time = datetime.strptime(exit, fmt) diff = exit_time - entry_time total_minutes += diff.total_seconds() // 60 return int(total_minutes)"},{"question":"def can_accommodate_booking(existing_bookings, new_booking): Determines if a new booking can be accommodated without conflicts. Parameters: existing_bookings (list of tuple): List of tuples where each tuple contains start and end time of an existing booking. new_booking (tuple): A tuple containing start and end time of the new booking request. Returns: str: \\"YES\\" if the new booking can be accommodated, otherwise \\"NO\\". pass def manage_bookings(test_cases): Manages multiple test cases of booking requests. Parameters: test_cases (list): List of test cases, where each test case is a tuple with existing bookings and new booking. Returns: list: List of results for each test case. pass def test_can_accommodate_booking(): assert can_accommodate_booking([(9, 11), (13, 15), (18, 21)], (12, 13)) == \\"YES\\" assert can_accommodate_booking([(10, 14)], (12, 16)) == \\"NO\\" assert can_accommodate_booking([(10, 14)], (14, 16)) == \\"YES\\" assert can_accommodate_booking([], (9, 11)) == \\"YES\\" assert can_accommodate_booking([(9, 11)], (10, 12)) == \\"NO\\" def test_manage_bookings(): test_cases = [ ([(9, 11), (13, 15), (18, 21)], (12, 13)), ([(10, 14)], (12, 16)), ([(10, 14)], (14, 16)), ] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert manage_bookings(test_cases) == expected test_cases = [ ([], (9, 11)), ([(9, 11)], (10, 12)) ] expected = [\\"YES\\", \\"NO\\"] assert manage_bookings(test_cases) == expected","solution":"def can_accommodate_booking(existing_bookings, new_booking): Determines if a new booking can be accommodated without conflicts. Parameters: existing_bookings (list of tuple): List of tuples where each tuple contains start and end time of an existing booking. new_booking (tuple): A tuple containing start and end time of the new booking request. Returns: str: \\"YES\\" if the new booking can be accommodated, otherwise \\"NO\\". start_new, end_new = new_booking for start_existing, end_existing in existing_bookings: if start_new < end_existing and end_new > start_existing: return \\"NO\\" return \\"YES\\" def manage_bookings(test_cases): Manages multiple test cases of booking requests. Parameters: test_cases (list): List of test cases, where each test case is a tuple with existing bookings and new booking. Returns: list: List of results for each test case. results = [] for existing_bookings, new_booking in test_cases: result = can_accommodate_booking(existing_bookings, new_booking) results.append(result) return results"},{"question":"def count_vowels_consonants(s: str) -> str: Returns a formatted string specifying the number of vowels and consonants in the input string. >>> count_vowels_consonants('Hello World') 'The string \\"Hello World\\" contains 3 vowels and 7 consonants.' >>> count_vowels_consonants('Python Programming') 'The string \\"Python Programming\\" contains 4 vowels and 13 consonants.'","solution":"def count_vowels_consonants(s): Returns a formatted string specifying the number of vowels and consonants in the input string. vowels = set(\\"aeiouAEIOU\\") vowel_count = sum(1 for char in s if char in vowels) consonant_count = sum(1 for char in s if char.isalpha() and char not in vowels) return f'The string \\"{s}\\" contains {vowel_count} vowels and {consonant_count} consonants.'"},{"question":"def common_words(titles: List[str]) -> List[str]: Returns a list of words that are common in all the given book titles. Only whole words should be considered, and the case should be ignored. The returned list should be sorted in ascending alphabetical order. >>> common_words([\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"Gone with the Wind\\", \\"The Catcher in the Rye\\"]) [] >>> common_words([\\"Brave New World\\", \\"A Brave New Era\\", \\"Brave New Universe\\"]) ['brave', 'new'] >>> common_words([\\"Pride and Prejudice\\", \\"Prejudice and Pride\\"]) ['and', 'prejudice', 'pride'] pass","solution":"def common_words(titles): Returns a list of words that are common in all the given book titles. if not titles: return [] # Convert each title to a set of lowercase words sets_of_words = [set(title.lower().split()) for title in titles] # Intersect all sets to find common words common = set.intersection(*sets_of_words) # Return the sorted list of common words return sorted(common)"},{"question":"def concatenate_strings(strings_list): Concatenates a list of strings to a single string separated by commas. Parameters: strings_list (list): A list of strings to concatenate. Returns: str: A single string containing all list elements separated by commas. >>> concatenate_strings([\\"apple\\", \\"banana\\", \\"cherry\\"]) 'apple,banana,cherry' >>> concatenate_strings([]) '' >>> concatenate_strings([\\"one\\"]) 'one' >>> concatenate_strings([\\"hi\\", \\" \\", \\"there\\"]) 'hi, ,there' >>> concatenate_strings([\\"one\\", \\"\\", \\"three\\"]) 'one,,three'","solution":"def concatenate_strings(strings_list): Concatenates a list of strings to a single string separated by commas. Parameters: strings_list (list): A list of strings to concatenate. Returns: str: A single string containing all list elements separated by commas. return ','.join(strings_list)"},{"question":"def walls_and_gates(rooms: List[List[int]]) -> None: Fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it remains filled with INF. Args: rooms (List[List[int]]): 2D grid initialized with -1 (wall), 0 (gate), and INF (empty room). Example: >>> grid = [ ... [2**31 - 1, -1, 0, 2**31 - 1], ... [2**31 - 1, 2**31 - 1, 2**31 - 1, -1], ... [2**31 - 1, -1, 2**31 - 1, -1], ... [0, -1, 2**31 - 1, 2**31 - 1] ... ] >>> walls_and_gates(grid) >>> grid [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]] from solution import walls_and_gates def test_walls_and_gates(): grid = [ [2**31 - 1, -1, 0, 2**31 - 1], [2**31 - 1, 2**31 - 1, 2**31 - 1, -1], [2**31 - 1, -1, 2**31 - 1, -1], [0, -1, 2**31 - 1, 2**31 - 1] ] expected = [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] walls_and_gates(grid) assert grid == expected def test_empty_grid(): grid = [] expected = [] walls_and_gates(grid) assert grid == expected def test_single_gate(): grid = [[0]] expected = [[0]] walls_and_gates(grid) assert grid == expected def test_single_wall(): grid = [[-1]] expected = [[-1]] walls_and_gates(grid) assert grid == expected def test_only_infs(): grid = [[2**31 - 1, 2**31 - 1], [2**31 - 1, 2**31 - 1]] expected = [[2**31 - 1, 2**31 - 1], [2**31 - 1, 2**31 - 1]] walls_and_gates(grid) assert grid == expected","solution":"from collections import deque def walls_and_gates(rooms): if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) INF = 2**31 - 1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque() for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) while queue: i, j = queue.popleft() for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and rooms[ni][nj] == INF: rooms[ni][nj] = rooms[i][j] + 1 queue.append((ni, nj))"},{"question":"def longest_non_consecutive_subsequence(s: str) -> int: Returns the length of the longest subsequence of s such that no two consecutive characters are the same. >>> longest_non_consecutive_subsequence(\\"aaabbbccc\\") 3 >>> longest_non_consecutive_subsequence(\\"abcd\\") 4 >>> longest_non_consecutive_subsequence(\\"aabbcc\\") 3 >>> longest_non_consecutive_subsequence(\\"a\\") 1 >>> longest_non_consecutive_subsequence(\\"abcabc\\") 6","solution":"def longest_non_consecutive_subsequence(s): Returns the length of the longest subsequence of s such that no two consecutive characters are the same. if not s: return 0 longest_length = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: longest_length += 1 return longest_length"},{"question":"def create_cactus_garden(rows, cols, cactus_positions): Creates a 2D list representing a rectangular garden with cacti. Args: - rows (int): Number of rows in the garden. - cols (int): Number of columns in the garden. - cactus_positions (list of tuples): List of (row, col) tuples representing cactus positions. Returns: - list of lists: 2D list representing the garden. >>> create_cactus_garden(3, 4, [(0, 1), (1, 2), (2, 3)]) [['.', 'C', '.', '.'], ['.', '.', 'C', '.'], ['.', '.', '.', 'C']] >>> create_cactus_garden(2, 2, [(0, 0), (1, 1), (2, 2)]) [['C', '.'], ['.', 'C']] >>> create_cactus_garden(0, 3, [(0, 0), (1, 1)]) []","solution":"def create_cactus_garden(rows, cols, cactus_positions): Creates a 2D list representing a rectangular garden with cacti. Args: - rows (int): Number of rows in the garden. - cols (int): Number of columns in the garden. - cactus_positions (list of tuples): List of (row, col) tuples representing cactus positions. Returns: - list of lists: 2D list representing the garden. if rows <= 0 or cols <= 0: return [] # Initialize garden with empty cells garden = [['.' for _ in range(cols)] for _ in range(rows)] # Place cacti in the garden for r, c in cactus_positions: if 0 <= r < rows and 0 <= c < cols: garden[r][c] = 'C' return garden"},{"question":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number. :param n: A non-negative integer. :return: The nth Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(6) 8 >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the nth Fibonacci number. :param n: A non-negative integer. :return: The nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def can_plant_crops(t: int, dimensions: List[Tuple[int, int]]) -> List[str]: Determine if it is possible to plant crops in WxH field such that no two adjacent cells contain the same type of crop. >>> can_plant_crops(3, [(4, 4), (3, 5), (1, 10)]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_plant_crops(2, [(1, 1), (1, 2)]) [\\"NO\\", \\"YES\\"] >>> can_plant_crops(1, [(100, 100)]) [\\"YES\\"] >>> can_plant_crops(1, [(1, 1)]) [\\"NO\\"] >>> can_plant_crops(4, [(2, 2), (5, 5), (7, 3), (1, 100)]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_plant_crops(t, dimensions): results = [] for i in range(t): W, H = dimensions[i] # It is always possible to plant crops with an alternating pattern (checkerboard) # as long as either W > 1 or H > 1. The only case where it is not possible is # when both W == 1 and H == 1. if W > 1 or H > 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_operations_to_make_equal(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum number of operations required to make all elements of the sequence equal for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains two elements - an integer N and a list of N integers. Returns: list of int: Minimum number of operations for each test case Example: >>> min_operations_to_make_equal(3, [(3, [1, 2, 3]), (2, [10, 10]), (4, [1, 3, 3, 7])]) [2, 0, 6] >>> min_operations_to_make_equal(1, [(1, [5])]) [0] from solution import min_operations_to_make_equal def test_sample_input_1(): T = 3 test_cases = [(3, [1, 2, 3]), (2, [10, 10]), (4, [1, 3, 3, 7])] expected = [2, 0, 6] assert min_operations_to_make_equal(T, test_cases) == expected def test_single_element(): T = 1 test_cases = [(1, [5])] expected = [0] assert min_operations_to_make_equal(T, test_cases) == expected def test_equal_elements(): T = 1 test_cases = [(4, [4, 4, 4, 4])] expected = [0] assert min_operations_to_make_equal(T, test_cases) == expected def test_large_range(): T = 1 test_cases = [(5, [1, 100, 50, 50, 75])] expected = [124] assert min_operations_to_make_equal(T, test_cases) == expected def test_negative_test_case(): T = 1 test_cases = [(3, [4, 6, 8])] expected = [4] assert min_operations_to_make_equal(T, test_cases) == expected","solution":"def min_operations_to_make_equal(T, test_cases): Calculate the minimum number of operations required to make all elements of the sequence equal for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains two elements - an integer N and a list of N integers. Returns: list of int: Minimum number of operations for each test case results = [] for i in range(T): N, A = test_cases[i] median = sorted(A)[N // 2] operations = sum(abs(x - median) for x in A) results.append(operations) return results"},{"question":"def count_unique_keywords(n: int, lines_of_code: List[str]) -> int: Returns the number of unique keywords across all lines of code. Parameters: n (int): The number of lines of code. lines_of_code (list of str): The list containing each line of code. Returns: int: The number of unique keywords. >>> count_unique_keywords(3, [\\"hello world\\", \\"hello universe\\", \\"world code\\"]) 4 >>> count_unique_keywords(1, [\\"hello\\"]) 1 >>> count_unique_keywords(0, []) 0","solution":"def count_unique_keywords(n, lines_of_code): Returns the number of unique keywords across all lines of code. Parameters: n (int): The number of lines of code. lines_of_code (list of str): The list containing each line of code. Returns: int: The number of unique keywords. unique_keywords = set() for line in lines_of_code: keywords = line.split() unique_keywords.update(keywords) return len(unique_keywords) # Example usage: # n = 3 # lines_of_code = [\\"hello world\\", \\"hello universe\\", \\"world code\\"] # print(count_unique_keywords(n, lines_of_code)) # Output: 4"},{"question":"def find_pair(numbers_str: str, target: int) -> tuple: Create a function that takes a string containing a series of comma-separated integers and a target integer. The function should find and return a pair of integers from the string that sum up to the target. If no such pair exists, return an empty tuple. >>> find_pair(\\"1,2,3,4,5\\", 7) in [(2, 5), (3, 4)] True >>> find_pair(\\"10,20,30,40,50\\", 90) (40, 50) >>> find_pair(\\"1,2,3,4\\", 8) () >>> find_pair(\\"5,1,2,4,3,6\\", 7) in [(1, 6), (3, 4), (2, 5)] True","solution":"def find_pair(numbers_str, target): Finds a pair of integers from the comma-separated input string that sum up to the target. :param numbers_str: A string of comma-separated integers. :param target: The target sum we want to achieve. :return: A tuple containing the pair of integers that sum to the target, or an empty tuple if no such pair exists. numbers = list(map(int, numbers_str.split(','))) seen = set() for number in numbers: complement = target - number if complement in seen: return (complement, number) seen.add(number) return ()"},{"question":"def min_operations(s1: str, s2: str) -> int: Calculate the minimum number of operations needed to transform s1 into s2. Operations include insertion, deletion, and replacement of characters. >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"abc\\", \\"abcdef\\") 3 >>> min_operations(\\"abcdef\\", \\"abc\\") 3 >>> min_operations(\\"abcdef\\", \\"azced\\") 3 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"a\\" * 50 + \\"b\\" * 50, \\"a\\" * 50) 50","solution":"def min_operations(s1: str, s2: str) -> int: Calculate the minimum number of operations needed to transform s1 into s2. Operations include insertion, deletion, and replacement of characters. m, n = len(s1), len(s2) # Create a 2D array to store the minimum number of operations for each subproblem dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill in the base cases # If s1 is empty, we need to insert all characters of s2 for j in range(n + 1): dp[0][j] = j # If s2 is empty, we need to remove all characters of s1 for i in range(m + 1): dp[i][0] = i # Fill the dp array using the previously computed states for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed else: dp[i][j] = min(dp[i - 1][j], # Remove from s1 dp[i][j - 1], # Insert into s1 dp[i - 1][j - 1] # Replace in s1 ) + 1 return dp[m][n]"},{"question":"def character_frequency(S: str) -> str: Determine the frequency of each character (excluding spaces) in the string and print the characters in ascending order of frequency. If two characters have the same frequency, print the characters in alphabetical order. >>> character_frequency(\\"examples string\\") a 1 g 1 i 1 l 1 m 1 n 1 p 1 r 1 t 1 x 1 e 2 s 2 >>> character_frequency(\\"abcdef\\") a 1 b 1 c 1 d 1 e 1 f 1","solution":"def character_frequency(S): Determine the frequency of each character (excluding spaces) in the string and print the characters in ascending order of frequency. If two characters have the same frequency, print the characters in alphabetical order. from collections import Counter # Remove spaces cleaned_string = S.replace(\\" \\", \\"\\") # Get frequencies of each character freq = Counter(cleaned_string) # Sort characters primarily by frequency and secondarily by alphabet sorted_characters = sorted(freq.items(), key=lambda x: (x[1], x[0])) # Print the result in the specified format result = [\\"{} {}\\".format(char, count) for char, count in sorted_characters] return \\"n\\".join(result)"},{"question":"def is_transfer_possible(n: int, A: List[int], B: List[int]) -> str: Checks if there exists a unique integer k such that for every element in A, adding k results in the corresponding element in B. >>> is_transfer_possible(3, [1, 2, 3], [4, 5, 6]) \\"YES\\" >>> is_transfer_possible(4, [10, 12, 14, 16], [20, 22, 24, 26]) \\"YES\\" >>> is_transfer_possible(5, [1, 2, 3, 4, 5], [5, 6, 7, 8, 10]) \\"NO\\" def solve(test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Process each test case to determine if the transfer is possible. >>> solve([(3, [1, 2, 3], [4, 5, 6]), (4, [10, 12, 14, 16], [20, 22, 24, 26]), (5, [1, 2, 3, 4, 5], [5, 6, 7, 8, 10])]) [\\"YES\\", \\"YES\\", \\"NO\\"] def test_is_transfer_possible(): assert is_transfer_possible(3, [1, 2, 3], [4, 5, 6]) == \\"YES\\" assert is_transfer_possible(4, [10, 12, 14, 16], [20, 22, 24, 26]) == \\"YES\\" assert is_transfer_possible(5, [1, 2, 3, 4, 5], [5, 6, 7, 8, 10]) == \\"NO\\" # Additional test cases assert is_transfer_possible(1, [0], [0]) == \\"YES\\" assert is_transfer_possible(2, [300, 600], [400, 700]) == \\"YES\\" assert is_transfer_possible(3, [5, 10, 15], [8, 13, 18]) == \\"YES\\" assert is_transfer_possible(3, [1, 1, 1], [2, 2, 3]) == \\"NO\\" def test_solve(): test_cases = [ (3, [1, 2, 3], [4, 5, 6]), (4, [10, 12, 14, 16], [20, 22, 24, 26]), (5, [1, 2, 3, 4, 5], [5, 6, 7, 8, 10]) ] assert solve(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] if __name__ == \\"__main__\\": test_is_transfer_possible() test_solve() print(\\"All tests passed!\\") # Example usage: def main(input_data: str): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(input_lines[index]) A = list(map(int, input_lines[index + 1].strip().split())) B = list(map(int, input_lines[index + 2].strip().split())) test_cases.append((n, A, B)) index += 3 results = solve(test_cases) for result in results: print(result) # Example input to test the main function input_data = 3 3 1 2 3 4 5 6 4 10 12 14 16 20 22 24 26 5 1 2 3 4 5 5 6 7 8 10 main(input_data)","solution":"def is_transfer_possible(n, A, B): Checks if there exists an integer k such that B[i] = A[i] + k for all 0 ≤ i < n. # Calculate the potential k using the first elements of A and B k = B[0] - A[0] # Check if the same k applies to all elements for i in range(n): if B[i] != A[i] + k: return \\"NO\\" return \\"YES\\" def solve(test_cases): Process each test case to determine if the transfer is possible. results = [] for case in test_cases: n, A, B = case results.append(is_transfer_possible(n, A, B)) return results # Example usage: # Input should be provided in a structured format for multiple test cases processing def main(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(input_lines[index]) A = list(map(int, input_lines[index + 1].strip().split())) B = list(map(int, input_lines[index + 2].strip().split())) test_cases.append((n, A, B)) index += 3 results = solve(test_cases) for result in results: print(result) # Example input to test the main function input_data = 3 3 1 2 3 4 5 6 4 10 12 14 16 20 22 24 26 5 1 2 3 4 5 5 6 7 8 10 main(input_data)"},{"question":"def minimumTrips(n: int, weights: List[int], capacity: int) -> int: Given the number of containers, their weights and the shelf capacity, find the minimum number of trips needed to place all containers on the shelves without exceeding the weight capacity. >>> minimumTrips(5, [2, 3, 4, 5, 1], 5) 3 >>> minimumTrips(1, [10], 10) 1 >>> minimumTrips(1, [10], 5) 1 >>> minimumTrips(4, [1, 2, 2, 1], 6) 2 >>> minimumTrips(4, [3, 3, 3, 3], 3) 4 >>> minimumTrips(5, [2, 2, 2, 2, 2], 4) 3 >>> minimumTrips(100000, [1] * 100000, 2) 50000 >>> minimumTrips(7, [7, 2, 3, 9, 4, 6, 2], 10) 4 >>> minimumTrips(6, [9, 8, 7, 6, 5, 4], 10) 5","solution":"def minimumTrips(n, weights, capacity): Returns the minimum number of trips required to place all containers on the shelves. Parameters: n (int): The number of containers. weights (list): A list of integers representing the weights of the containers. capacity (int): The maximum weight capacity of each shelf. Returns: int: The minimum number of trips required. weights.sort() left = 0 right = n - 1 trips = 0 while left <= right: if weights[left] + weights[right] <= capacity: left += 1 right -= 1 trips += 1 return trips"},{"question":"def fibonacci(n: int) -> List[int]: Returns a list of the first n numbers in the Fibonacci sequence. >>> fibonacci(1) [0] >>> fibonacci(2) [0, 1] >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list of the first n numbers in the Fibonacci sequence. if n <= 0: return [] fib_sequence = [0] if n == 1: return fib_sequence fib_sequence.append(1) for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"class ArrayQueries: def __init__(self, arr): self.arr = arr def update(self, x, y): Update the x-th element (1-based index) of the array to the value y. self.arr[x - 1] = y def query_max(self, l, r): Find and return the maximum integer in the array from index l to index r (inclusive) (1-based index). return max(self.arr[l - 1:r]) def process_queries(n, q, arr, queries): Process the queries on the array. Args: n (int): Size of the array. q (int): Number of queries. arr (List[int]): Array of integers. queries (List[List[int]]): List of queries to process. Returns: List[int]: Results of the range maximum queries. result = [] array_queries = ArrayQueries(arr) for query in queries: if query[0] == 1: x, y = query[1], query[2] array_queries.update(x, y) elif query[0] == 2: l, r = query[1], query[2] result.append(array_queries.query_max(l, r)) return result from solution import process_queries def test_basic_operations(): n, q = 6, 5 arr = [1, 3, 2, 7, 9, 11] queries = [ [2, 2, 5], [1, 3, 10], [2, 2, 5], [1, 6, 4], [2, 1, 6] ] assert process_queries(n, q, arr, queries) == [9, 10, 10] def test_all_updates(): n, q = 3, 3 arr = [1, 2, 3] queries = [ [1, 1, 10], [1, 2, 20], [1, 3, 30] ] assert process_queries(n, q, arr, queries) == [] def test_all_queries(): n, q = 3, 3 arr = [1, 2, 3] queries = [ [2, 1, 3], [2, 1, 2], [2, 2, 3] ] assert process_queries(n, q, arr, queries) == [3, 2, 3] def test_combined_operations(): n, q = 4, 4 arr = [4, 5, 6, 7] queries = [ [1, 2, 8], [2, 1, 4], [1, 4, 2], [2, 2, 3] ] assert process_queries(n, q, arr, queries) == [8, 8] def test_large_numbers(): n, q = 2, 2 arr = [10**9, 10**9 - 1] queries = [ [2, 1, 2], [1, 2, 10**9] ] assert process_queries(n, q, arr, queries) == [10**9]","solution":"class ArrayQueries: def __init__(self, arr): self.arr = arr def update(self, x, y): Update the x-th element (1-based index) of the array to the value y. self.arr[x - 1] = y def query_max(self, l, r): Find and return the maximum integer in the array from index l to index r (inclusive) (1-based index). return max(self.arr[l - 1:r]) def process_queries(n, q, arr, queries): result = [] array_queries = ArrayQueries(arr) for query in queries: if query[0] == 1: x, y = query[1], query[2] array_queries.update(x, y) elif query[0] == 2: l, r = query[1], query[2] result.append(array_queries.query_max(l, r)) return result"},{"question":"from typing import Tuple, List class Warehouse: A class to manage packages in a warehouse. Each package has a unique ID, a weight, and a destination city. Methods: - add_package(id: int, weight: int, destination: str) -> None: Adds a new package. - remove_package(id: int) -> None: Removes the package with the given ID. - get_max_weight_package() -> Tuple[int, int, str]: Returns the package with the maximum weight. - get_packages_by_city(destination: str) -> List[Tuple[int, int]]: Returns the packages for a specific city, sorted by weight. Example: >>> warehouse = Warehouse() >>> warehouse.add_package(1, 10, \\"New York\\") >>> warehouse.add_package(2, 15, \\"Boston\\") >>> warehouse.get_max_weight_package() == (2, 15, \\"Boston\\") >>> warehouse.get_packages_by_city(\\"New York\\") == [(1, 10)] >>> warehouse.remove_package(1) >>> warehouse.get_packages_by_city(\\"New York\\") == [] def __init__(self): Initializes an empty dictionary to store packages. pass def add_package(self, id: int, weight: int, destination: str) -> None: Adds a new package with the specified ID, weight, and destination. pass def remove_package(self, id: int) -> None: Removes the package with the given ID. If the package does not exist, do nothing. pass def get_max_weight_package(self) -> Tuple[int, int, str]: Returns a tuple with the ID, weight, and destination of the package with the maximum weight. If there are multiple packages with the same maximum weight, return any one of them. If no packages are present, return None. pass def get_packages_by_city(self, destination: str) -> List[Tuple[int, int]]: Returns a list of tuples where each tuple contains the ID and weight of packages destined for the given city, sorted by weight in descending order. If there are no packages for the given city, return an empty list. pass","solution":"from typing import Tuple, List class Warehouse: def __init__(self): self.packages = {} def add_package(self, id: int, weight: int, destination: str) -> None: self.packages[id] = (weight, destination) def remove_package(self, id: int) -> None: if id in self.packages: del self.packages[id] def get_max_weight_package(self) -> Tuple[int, int, str]: if not self.packages: return None max_weight_id = max(self.packages, key=lambda id: self.packages[id][0]) return (max_weight_id, self.packages[max_weight_id][0], self.packages[max_weight_id][1]) def get_packages_by_city(self, destination: str) -> List[Tuple[int, int]]: filtered_packages = [(id, weight) for id, (weight, dest) in self.packages.items() if dest == destination] return sorted(filtered_packages, key=lambda pkg: pkg[1], reverse=True)"},{"question":"def rearrange_list(arr): Rearranges a list of integers such that each number appears to the right of all previous occurrences of the same number, maintaining the relative order of the first occurrences. >>> rearrange_list([4, 1, 2, 1, 2, 3, 4]) == [4, 1, 2, 3, 4, 1, 2] >>> rearrange_list([1, 2, 1, 2, 1, 2]) == [1, 2, 1, 2, 1, 2] >>> rearrange_list([1, 1, 1, 1]) == [1, 1, 1, 1] >>> rearrange_list([1, 2, 3, 4]) == [1, 2, 3, 4] >>> rearrange_list([-1, -2, -1, -2, -3]) == [-1, -2, -3, -1, -2] >>> rearrange_list([-1, 2, -1, 2, -3, 2]) == [-1, 2, -3, -1, 2, 2]","solution":"def rearrange_list(arr): Rearranges a list of integers such that each number appears to the right of all previous occurrences of the same number, maintaining the relative order of the first occurrences. first_occurrences = [] remaining_occurrences = [] seen = set() for num in arr: if num not in seen: first_occurrences.append(num) seen.add(num) else: remaining_occurrences.append(num) return first_occurrences + remaining_occurrences"},{"question":"def min_poles_needed(T, test_cases): Determine the minimum number of utility poles needed to provide electricity to all the buildings. Arguments: T -- the number of test cases test_cases -- a list of tuples, each containing: - N: the number of buildings - M: the number of utility poles - buildings: a list of integers representing the positions of the buildings - poles: a list of integers representing the positions of the utility poles - D: the maximum distance a building can be from a utility pole Returns: A list of integers representing the minimum number of utility poles needed for each test case. If it is not possible to cover all buildings with the given utility poles and distance, returns -1 for that test case. Example: >>> T = 2 >>> test_cases = [ ... (3, 3, [2, 5, 8], [1, 5, 9], 3), ... (4, 2, [1, 4, 7, 10], [2, 6], 2) ... ] >>> min_poles_needed(T, test_cases) [2, -1] pass import pytest def test_sample_case_1(): T = 2 test_cases = [ (3, 3, [2, 5, 8], [1, 5, 9], 3), (4, 2, [1, 4, 7, 10], [2, 6], 2) ] assert min_poles_needed(T, test_cases) == [2, -1] def test_case_with_no_poles(): T = 1 test_cases = [ (3, 0, [2, 5, 8], [], 3) ] assert min_poles_needed(T, test_cases) == [-1] def test_all_buildings_covered_by_one_pole(): T = 1 test_cases = [ (3, 1, [2, 5, 8], [5], 5) ] assert min_poles_needed(T, test_cases) == [1] def test_not_possible_to_cover_any_buildings(): T = 1 test_cases = [ (3, 2, [1000, 2000, 3000], [4000, 5000], 100) ] assert min_poles_needed(T, test_cases) == [-1] def test_case_with_distinct_building_and_pole_positions(): T = 1 test_cases = [ (5, 3, [1, 3, 5, 7, 9], [2, 6, 10], 1) ] assert min_poles_needed(T, test_cases) == [3] def test_case_with_exactly_mapped_poles(): T = 1 test_cases = [ (4, 4, [1, 2, 3, 4], [1, 2, 3, 4], 0) ] assert min_poles_needed(T, test_cases) == [4]","solution":"def min_poles_needed(T, test_cases): results = [] for i in range(T): N, M, buildings, poles, D = test_cases[i] buildings.sort() poles.sort() used_poles = set() current_pole_index = 0 def within_distance(building, pole): return abs(building - pole) <= D for building in buildings: while current_pole_index < M and not within_distance(building, poles[current_pole_index]): current_pole_index += 1 if current_pole_index == M: results.append(-1) break used_poles.add(poles[current_pole_index]) if len(results) == i: results.append(len(used_poles)) return results"},{"question":"def is_prime(num: int) -> bool: Returns True if num is a prime number, otherwise False. def prime_factors(n: int) -> List[int]: Given a positive integer n, returns a list of all prime factors of n in ascending order. Each prime factor appears in the list as many times as it divides n. >>> prime_factors(28) [2, 2, 7] >>> prime_factors(315) [3, 3, 5, 7]","solution":"def is_prime(num): Returns True if num is a prime number, otherwise False. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def prime_factors(n): Returns a list of all prime factors of the given integer n in ascending order. Each prime factor appears in the list as many times as it divides n. factors = [] # Check for number of 2s in n while n % 2 == 0: factors.append(2) n //= 2 # Check for odd factors from 3 to sqrt(n) for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n //= i if n > 2: factors.append(n) return factors"},{"question":"def is_happy_number(n: int) -> bool: Determine if a number is a happy number. >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(100) True >>> is_happy_number(1) True >>> is_happy_number(7) True def determine_happy_numbers(numbers: List[int]) -> List[str]: Determine if each number in a list is a happy number. >>> determine_happy_numbers([19, 2, 100]) ['YES', 'NO', 'YES'] >>> determine_happy_numbers([1, 2, 7, 20]) ['YES', 'NO', 'YES', 'NO'] >>> determine_happy_numbers([4, 16, 37, 58, 89]) ['NO', 'NO', 'NO', 'NO', 'NO'] def process_input(data: List[str]) -> List[str]: Process input data for multiple test cases. >>> input_data = [\\"3\\", \\"19\\", \\"2\\", \\"100\\"] >>> process_input(input_data) ['YES', 'NO', 'YES'] >>> input_data = [\\"4\\", \\"7\\", \\"20\\", \\"1\\", \\"4\\"] >>> process_input(input_data) ['YES', 'NO', 'YES', 'NO'] >>> input_data = [\\"2\\", \\"16\\", \\"37\\"] >>> process_input(input_data) ['NO', 'NO']","solution":"def is_happy_number(n): def get_next(number): return sum(int(ch)**2 for ch in str(number)) seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1 def determine_happy_numbers(numbers): results = [] for num in numbers: if is_happy_number(num): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def process_input(data): T = int(data[0]) numbers = [int(n) for n in data[1:T+1]] return determine_happy_numbers(numbers)"},{"question":"def arrayIntersection(arr1, arr2): Returns the intersection of two arrays including the duplicates. >>> arrayIntersection([1, 2, 2, 1], [2, 2]) [2, 2] >>> arrayIntersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] >>> arrayIntersection([1, 2, 3], [4, 5, 6]) [] >>> arrayIntersection([], [9, 4, 9, 8, 4]) [] >>> arrayIntersection([1, 2, 3], []) [] >>> arrayIntersection([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> arrayIntersection([4, 5, 5, 4], [5, 4, 5, 4, 5]) [4, 5, 5, 4] >>> arrayIntersection([1, 3, 5, 7], [2, 4, 6, 8]) []","solution":"def arrayIntersection(arr1, arr2): Returns the intersection of two arrays including the duplicates. result = [] arr2_copy = arr2[:] for num in arr1: if num in arr2_copy: result.append(num) arr2_copy.remove(num) return result"},{"question":"def max_subarray_sum(arr): Function to find the sum of the contiguous subarray with the largest sum. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-8, -3, -6, -2, -5, -4]) -2 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([10]) 10 >>> max_subarray_sum([-10]) -10 >>> max_subarray_sum([1000] * 100000) 100000000 >>> max_subarray_sum([-10**9, 10**9, -10**9, 10**9]) 10**9 >>> max_subarray_sum([-3, -2, -1, 5, 6, 2]) 13","solution":"def max_subarray_sum(arr): Function to find the sum of the contiguous subarray with the largest sum. max_sum = float('-inf') current_sum = 0 for num in arr: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"import collections class HitCounter: A class to track the number of hits received in the past 5 minutes (300 seconds). Methods: - hit(timestamp): Records a hit that happened at \`timestamp\` (in seconds). - getHits(timestamp): Returns the number of hits received in the past 5 minutes from \`timestamp\`. Example: >>> counter = HitCounter() >>> counter.hit(1) >>> counter.hit(2) >>> counter.hit(3) >>> counter.getHits(4) 3 >>> counter.hit(300) >>> counter.getHits(301) 4 def __init__(self): Initializes the hit counter with default values. self.hits = collections.deque() def hit(self, timestamp: int): Records a hit that happened at \`timestamp\` (in seconds). :param timestamp: int self.hits.append(timestamp) def getHits(self, timestamp: int) -> int: Returns the number of hits received in the past 5 minutes from \`timestamp\`. :param timestamp: int :return: int pass def test_hit_counter_initialization(): counter = HitCounter() assert counter.getHits(1) == 0 def test_single_hit(): counter = HitCounter() counter.hit(1) assert counter.getHits(1) == 1 assert counter.getHits(2) == 1 assert counter.getHits(300) == 1 assert counter.getHits(301) == 0 def test_multiple_hits_within_5_minutes(): counter = HitCounter() counter.hit(1) counter.hit(2) counter.hit(3) assert counter.getHits(4) == 3 assert counter.getHits(300) == 3 assert counter.getHits(301) == 2 def test_hits_more_than_5_minutes_old(): counter = HitCounter() counter.hit(1) counter.hit(2) counter.hit(3) counter.hit(300) assert counter.getHits(300) == 4 assert counter.getHits(301) == 3 def test_no_hits(): counter = HitCounter() assert counter.getHits(1) == 0 def test_hits_exactly_5_minutes_apart(): counter = HitCounter() counter.hit(1) counter.hit(300) assert counter.getHits(300) == 2 assert counter.getHits(301) == 1","solution":"import collections class HitCounter: def __init__(self): Initializes the hit counter with default values. self.hits = collections.deque() def hit(self, timestamp: int): Records a hit that happened at \`timestamp\` (in seconds). :param timestamp: int self.hits.append(timestamp) def getHits(self, timestamp: int) -> int: Returns the number of hits received in the past 5 minutes from \`timestamp\`. :param timestamp: int :return: int # Remove hits that are older than 5 minutes (300 seconds) while self.hits and self.hits[0] <= timestamp - 300: self.hits.popleft() # The remaining hits are within the past 5 minutes return len(self.hits)"},{"question":"def flatten_dictionary(d: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested dictionary. The keys in the flattened dictionary are concatenated with a period or the given separator. :param d: The dictionary to flatten. :param parent_key: The base key to use for nested items. :param sep: The separator to use for key concatenation. Default is '.'. :return: A flattened dictionary. >>> flatten_dictionary({ ... \\"key1\\": \\"1\\", ... \\"key2\\": { ... \\"key3\\": \\"2\\", ... \\"key4\\": { ... \\"key5\\": \\"3\\" ... } ... } ... }) {\\"key1\\": \\"1\\", \\"key2.key3\\": \\"2\\", \\"key2.key4.key5\\": \\"3\\"} >>> flatten_dictionary({\\"a\\": {\\"b\\": \\"c\\"}}, sep='-') {\\"a-b\\": \\"c\\"} from solution import flatten_dictionary def test_flatten_simple(): data = {\\"key1\\": \\"1\\", \\"key2\\": {\\"key3\\": \\"2\\"}} expected = {\\"key1\\": \\"1\\", \\"key2.key3\\": \\"2\\"} assert flatten_dictionary(data) == expected def test_multiple_nested_levels(): data = { \\"key1\\": \\"1\\", \\"key2\\": { \\"key3\\": \\"2\\", \\"key4\\": { \\"key5\\": \\"3\\" } } } expected = { \\"key1\\": \\"1\\", \\"key2.key3\\": \\"2\\", \\"key2.key4.key5\\": \\"3\\" } assert flatten_dictionary(data) == expected def test_empty_dictionary(): data = {} expected = {} assert flatten_dictionary(data) == expected def test_empty_nested_dictionaries(): data = {\\"key1\\": \\"1\\", \\"key2\\": {\\"key3\\": {}}} expected = {\\"key1\\": \\"1\\", \\"key2.key3\\": {}} assert flatten_dictionary(data) == expected def test_key_with_empty_string_value(): data = {\\"key1\\": \\"\\", \\"key2\\": {\\"key3\\": \\"2\\"}} expected = {\\"key1\\": \\"\\", \\"key2.key3\\": \\"2\\"} assert flatten_dictionary(data) == expected def test_complex_nested_structure(): data = { \\"a\\": { \\"b\\": { \\"c\\": \\"d\\" }, \\"e\\": \\"f\\" }, \\"g\\": \\"h\\", \\"i\\": { \\"j\\": { \\"k\\": { \\"l\\": \\"m\\" } } } } expected = { \\"a.b.c\\": \\"d\\", \\"a.e\\": \\"f\\", \\"g\\": \\"h\\", \\"i.j.k.l\\": \\"m\\" } assert flatten_dictionary(data) == expected def test_custom_separator(): data = {\\"a\\": {\\"b\\": \\"c\\"}} expected = {\\"a-b\\": \\"c\\"} assert flatten_dictionary(data, sep='-') == expected","solution":"def flatten_dictionary(d, parent_key='', sep='.'): Flattens a nested dictionary. The keys in the flattened dictionary are concatenated with a period or the given separator. :param d: The dictionary to flatten. :param parent_key: The base key to use for nested items. :param sep: The separator to use for key concatenation. Default is '.'. :return: A flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict) and v: items.extend(flatten_dictionary(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"import numpy as np def process_arrays(array1, array2): Concatenate two 2x2 arrays along the second axis (axis=1) and stack them horizontally. Parameters: array1 (list of list of int): The first 2x2 array. array2 (list of list of int): The second 2x2 array. Returns: numpy.ndarray: The resulting array after concatenation and horizontal stacking. >>> process_arrays([[1, 2], [3, 4]], [[5, 6], [7, 8]]) array([[1, 2, 5, 6, 1, 2, 5, 6], [3, 4, 7, 8, 3, 4, 7, 8]]) >>> process_arrays([[1, 0], [0, 1]], [[1, 0], [0, 1]]) array([[1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1]]) >>> process_arrays([[-1, -2], [-3, -4]], [[-5, -6], [-7, -8]]) array([[-1, -2, -5, -6, -1, -2, -5, -6], [-3, -4, -7, -8, -3, -4, -7, -8]])","solution":"import numpy as np def process_arrays(array1, array2): Concatenate two 2x2 arrays along the second axis (axis=1) and stack them horizontally. Parameters: array1 (list of list of int): The first 2x2 array. array2 (list of list of int): The second 2x2 array. Returns: numpy.ndarray: The resulting array after concatenation and horizontal stacking. arr1 = np.array(array1) arr2 = np.array(array2) # Concatenating along the second axis which is axis=1 concatenated = np.concatenate((arr1, arr2), axis=1) # Stack them horizontally stacked_result = np.hstack((concatenated, concatenated)) return stacked_result"},{"question":"from typing import List, Dict def calculate_averages(students: List[Dict[str, List[int]]]) -> Dict[str, int]: Accepts a list of dictionaries, each containing the keys 'name' (a string) and 'grades' (a list of integers). Returns a new dictionary where each key is a student's name and the value is the average of their grades (rounded to the nearest integer). >>> calculate_averages([{'name': 'Alice', 'grades': [90, 80, 85]}, {'name': 'Bob', 'grades': [70, 75, 85]}]) {'Alice': 85, 'Bob': 77} >>> calculate_averages([{'name': 'Charlie', 'grades': [100, 100, 100]}]) {'Charlie': 100}","solution":"from typing import List, Dict def calculate_averages(students: List[Dict[str, List[int]]]) -> Dict[str, int]: Returns a dictionary with student names as keys and their average grades (rounded to the nearest integer) as values. averages = {} for student in students: name = student['name'] grades = student['grades'] average = round(sum(grades) / len(grades)) averages[name] = average return averages"},{"question":"def factorial(n: int) -> int: Computes the factorial of a given positive integer n. The factorial of a positive integer n is the product of all positive integers less than or equal to n. >>> factorial(1) 1 >>> factorial(2) 2 >>> factorial(3) 6 >>> factorial(5) 120 >>> factorial(6) 720 >>> factorial(10) 3628800","solution":"def factorial(n): Returns the factorial of a given positive integer n. if n == 1: return 1 return n * factorial(n - 1)"},{"question":"from typing import List def k_closest(points: List[List[int]], K: int) -> List[List[int]]: Finds K closest points to the origin (0, 0). Parameters: points (List[List[int]]): List of points in the form [[x, y], ...]. K (int): Number of closest points to find. Returns: List[List[int]]: K closest points. Example: >>> k_closest([[1, 3], [-2, 2], [5, 8]], 1) [[-2, 2]] >>> k_closest([[3, 3], [5, -1], [-2, 4]], 2) [[3, 3], [-2, 4]] pass from solution import k_closest def test_k_closest_example_1(): points = [[1,3],[-2,2],[5,8]] K = 1 result = k_closest(points, K) assert result == [[-2,2]] or result == [[-2,2]] def test_k_closest_example_2(): points = [[3,3],[5,-1],[-2,4]] K = 2 result = k_closest(points, K) assert result == [[3,3],[-2,4]] or result == [[-2,4],[3,3]] def test_k_closest_all_points(): points = [[10, -10], [0, 1], [2, 3], [4, 5]] K = 4 result = k_closest(points, K) assert len(result) == 4 def test_k_closest_K_larger_than_length(): points = [[10, -10], [0, 1], [2, 3], [4, 5]] K = 5 result = k_closest(points, K) assert len(result) == 4 def test_k_closest_negative_coords(): points = [[-5, -12], [-1, -1], [-10, 5], [0, 0]] K = 2 result = k_closest(points, K) assert result == [[0, 0], [-1, -1]] def test_k_closest_same_distance(): points = [[1,1],[1,1],[1,1]] K = 2 result = k_closest(points, K) assert len(result) == 2 assert result == [[1, 1], [1, 1]] or result == [[1, 1], [1, 1]]","solution":"from heapq import nlargest from math import sqrt def k_closest(points, K): Finds K closest points to the origin (0, 0). Parameters: points (List[List[int]]): List of points in the form [[x, y], ...]. K (int): Number of closest points to find. Returns: List[List[int]]: K closest points. # Calculate the Euclidean distance for each point points_with_distance = [(sqrt(x**2 + y**2), [x, y]) for x, y in points] # Get the K smallest distances with corresponding points k_closest_points = nlargest(K, points_with_distance, key=lambda x: -x[0]) # Extract the points from the list of tuples return [point for distance, point in k_closest_points]"},{"question":"from typing import List, Union def square_numbers(lst: List[Union[int, float, str]]) -> List[Union[int, float]]: Takes a list of numbers and strings, and returns a new list containing only the numbers, each squared. >>> square_numbers([1, 2, 'a', 'b']) [1, 4] >>> square_numbers([1, 'a', 'b', 0, 15]) [1, 0, 225] >>> square_numbers([1, 2, 'aasf', '1', '123', 123]) [1, 4, 15129] # Test Cases def test_square_numbers_with_mixed_list(): assert square_numbers([1, 2, 'a', 'b']) == [1, 4] assert square_numbers([1, 'a', 'b', 0, 15]) == [1, 0, 225] assert square_numbers([1, 2, 'aasf', '1', '123', 123]) == [1, 4, 15129] def test_square_numbers_with_only_numbers(): assert square_numbers([1, 2, 3]) == [1, 4, 9] assert square_numbers([0, -1, 4.5]) == [0, 1, 20.25] def test_square_numbers_with_only_strings(): assert square_numbers(['a', 'b', 'c']) == [] assert square_numbers(['1', '2', '3']) == [] def test_square_numbers_with_empty_list(): assert square_numbers([]) == [] def test_square_numbers_with_no_strings(): assert square_numbers([0, -1, 2]) == [0, 1, 4]","solution":"def square_numbers(lst): Takes a list of numbers and strings, and returns a new list containing only the numbers, each squared. return [x**2 for x in lst if isinstance(x, (int, float))]"},{"question":"from typing import List def longest_zigzag_subarray(arr: List[int]) -> int: Find the length of the longest zigzag subarray in a given number sequence. A zigzag subarray is defined as a subarray where elements alternate between greater and lesser values. Example: >>> longest_zigzag_subarray([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag_subarray([1, 4, 7, 2, 5]) 4 >>> longest_zigzag_subarray([10, 20, 10, 20, 10]) 5 >>> longest_zigzag_subarray([1, 2, 3, 4, 5]) 2 # Implement the function here def test_example_cases(): assert longest_zigzag_subarray([1, 7, 4, 9, 2, 5]) == 6 assert longest_zigzag_subarray([1, 4, 7, 2, 5]) == 4 assert longest_zigzag_subarray([10, 20, 10, 20, 10]) == 5 assert longest_zigzag_subarray([1, 2, 3, 4, 5]) == 2 def test_edge_cases(): assert longest_zigzag_subarray([1]) == 1 assert longest_zigzag_subarray([]) == 0 def test_zigzag_start_middle_end(): assert longest_zigzag_subarray([1, 2, 1, 2, 1]) == 5 assert longest_zigzag_subarray([5, 1, 5, 1, 5]) == 5 assert longest_zigzag_subarray([3, 1, 4, 2, 5]) == 5 def test_no_zigzag(): assert longest_zigzag_subarray([5, 5, 5, 5, 5]) == 1 assert longest_zigzag_subarray([2, 2, 2, 2]) == 1 assert longest_zigzag_subarray([1, 1, 1]) == 1 def test_alternating_patterns(): assert longest_zigzag_subarray([1, 1000, -1000, 1000, -1000]) == 5 assert longest_zigzag_subarray([-1000, 1000, -1000, 1000, -1000]) == 5 assert longest_zigzag_subarray([0, -1, 1, -1, 1]) == 5","solution":"from typing import List def longest_zigzag_subarray(arr: List[int]) -> int: if len(arr) < 2: return len(arr) # Initialize counters. up = down = max_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: up = down + 1 max_length = max(max_length, up) elif arr[i] < arr[i - 1]: down = up + 1 max_length = max(max_length, down) return max_length"},{"question":"class SmartTV: A class to simulate the operations of a smart television with apps and channels def __init__(self): Initializes an empty smart TV with no apps installed. pass def installApp(self, appName): Installs an app with the name appName. If already installed, state remains unchanged. pass def uninstallApp(self, appName): Uninstalls an app with the name appName. If not installed, state remains unchanged. pass def changeChannel(self, appName, channelNumber): Changes to a specific channelNumber on the app named appName. Returns: str: \\"App not installed\\" if app is not installed. \\"Channel changed to X on appName\\" otherwise. def test_install_app(): tv = SmartTV() tv.installApp(\\"Netflix\\") assert \\"Netflix\\" in tv.installed_apps tv.installApp(\\"Netflix\\") # trying to install already installed app assert len(tv.installed_apps) == 1 def test_uninstall_app(): tv = SmartTV() tv.installApp(\\"YouTube\\") assert \\"YouTube\\" in tv.installed_apps tv.uninstallApp(\\"YouTube\\") assert \\"YouTube\\" not in tv.installed_apps def test_change_channel_app_installed(): tv = SmartTV() tv.installApp(\\"Netflix\\") assert tv.changeChannel(\\"Netflix\\", 5) == \\"Channel changed to 5 on Netflix\\" def test_change_channel_app_not_installed(): tv = SmartTV() assert tv.changeChannel(\\"Hulu\\", 10) == \\"App not installed\\" def test_change_channel_after_uninstall(): tv = SmartTV() tv.installApp(\\"YouTube\\") tv.uninstallApp(\\"YouTube\\") assert tv.changeChannel(\\"YouTube\\", 2) == \\"App not installed\\"","solution":"class SmartTV: def __init__(self): Initializes an empty smart TV with no apps installed. self.installed_apps = set() def installApp(self, appName): Installs an app with the name appName. If already installed, state remains unchanged. self.installed_apps.add(appName) def uninstallApp(self, appName): Uninstalls an app with the name appName. If not installed, state remains unchanged. self.installed_apps.discard(appName) def changeChannel(self, appName, channelNumber): Changes to a specific channelNumber on the app named appName. if appName not in self.installed_apps: return \\"App not installed\\" return f\\"Channel changed to {channelNumber} on {appName}\\""},{"question":"def correct_spelling(words: List[str]) -> Dict[str, List[str]]: Takes an array of strings (words) and returns a dictionary where: - The key is the original, correctly spelled word. - The value is a list of common variations or misspellings of that word that you need to correct. >>> correct_spelling([\\"definately\\", \\"seperate\\", \\"accomodate\\", \\"thier\\", \\"occurrance\\"]) {'definitely': ['definately'], 'separate': ['seperate'], 'accommodate': ['accomodate'], 'their': ['thier'], 'occurrence': ['occurrance']} >>> correct_spelling([\\"occurence\\", \\"ther\\", \\"definatly\\"]) {'definitely': ['definatly'], 'their': ['ther'], 'occurrence': ['occurence']} >>> correct_spelling([\\"excellent\\", \\"beautiful\\", \\"amazing\\"]) {} >>> correct_spelling([]) {} >>> correct_spelling([\\"definately\\", \\"definately\\", \\"seperate\\", \\"seperate\\"]) {'definitely': ['definately', 'definately'], 'separate': ['seperate', 'seperate']}","solution":"def correct_spelling(words): Takes an array of strings (words) and returns a dictionary where: - The key is the original, correctly spelled word. - The value is a list of common variations or misspellings of that word that you need to correct. common_misspellings = { \\"definitely\\": [\\"definately\\", \\"definatly\\", \\"definatley\\"], \\"separate\\": [\\"seperate\\", \\"seperete\\"], \\"accommodate\\": [\\"acommodate\\", \\"acomodate\\", \\"accomodate\\", \\"acoommodate\\"], \\"their\\": [\\"thier\\", \\"ther\\"], \\"occurrence\\": [\\"occurance\\", \\"occurrance\\", \\"occurence\\"], } corrected_dict = {key: [] for key in common_misspellings} for word in words: for correct, misspellings in common_misspellings.items(): if word in misspellings: corrected_dict[correct].append(word) break # Remove empty lists corrected_dict = {key: val for key, val in corrected_dict.items() if val} return corrected_dict"},{"question":"from typing import List def max_rob(nums: List[int]) -> int: Returns the maximum amount of money that can be robbed without robbing two consecutive houses. :param nums: List[int] - list of non-negative integers representing money in each house. :return: int - maximum amount of money that can be robbed. >>> max_rob([1, 2, 3, 1]) 4 >>> max_rob([2, 7, 9, 3, 1]) 12 from solution import max_rob def test_max_rob_example1(): assert max_rob([1, 2, 3, 1]) == 4 def test_max_rob_example2(): assert max_rob([2, 7, 9, 3, 1]) == 12 def test_max_rob_empty(): assert max_rob([]) == 0 def test_max_rob_single_house(): assert max_rob([5]) == 5 def test_max_rob_two_houses(): assert max_rob([3, 10]) == 10 assert max_rob([10, 3]) == 10 def test_max_rob_multiple_houses(): assert max_rob([2, 1, 1, 2]) == 4 assert max_rob([5, 5, 10, 100, 10, 5]) == 110 assert max_rob([10, 20, 30, 40, 50]) == 90","solution":"def max_rob(nums): Returns the maximum amount of money that can be robbed without robbing two consecutive houses. :param nums: List[int] - list of non-negative integers representing money in each house. :return: int - maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"from typing import List, Tuple def max_files_stored(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum number of files that can be stored without exceeding the server's capacity. >>> max_files_stored(2, [(4, 10, [2, 3, 5, 8]), (3, 5, [4, 2, 3])]) [3, 2] >>> max_files_stored(1, [(1, 5, [5])]) [1] >>> max_files_stored(1, [(3, 1, [2, 3, 4])]) [0] >>> max_files_stored(1, [(3, 6, [1, 2, 3])]) [3] >>> max_files_stored(3, [(4, 10, [2, 3, 5, 8]), (3, 5, [4, 2, 3]), (5, 5, [1, 1, 1, 1, 1])]) [3, 2, 5] >>> max_files_stored(1, [(4, 10, [1, 2, 3, 4])]) [4] >>> max_files_stored(1, [(10, 20, [1]*10)]) [10] >>> max_files_stored(1, [(5, 1000000, [1000000, 1000000, 1000000, 1000000, 1000000])]) [1]","solution":"def max_files_stored(T, test_cases): results = [] for case in test_cases: N, C, file_sizes = case file_sizes.sort() current_sum, count = 0, 0 for size in file_sizes: if current_sum + size <= C: current_sum += size count += 1 else: break results.append(count) return results"},{"question":"from typing import List def k_combinations(n: int, k: int) -> List[List[int]]: Returns the number of unique k-combinations of the integers from 1 to n. >>> k_combinations(4, 2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> k_combinations(3, 1) [[1], [2], [3]] >>> k_combinations(5, 3) [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]] >>> k_combinations(4, 4) [[1, 2, 3, 4]] >>> k_combinations(5, 0) [[]] >>> k_combinations(1, 1) [[1]]","solution":"from itertools import combinations def k_combinations(n, k): Returns the list of unique k-combinations of the integers from 1 to n. # Generate all combinations of k numbers from the range 1 to n comb = combinations(range(1, n+1), k) # Convert iterator to list and return it return [list(c) for c in comb]"},{"question":"from typing import List def most_frequent_product(transactions: List[List[str]]) -> str: Write a function called \`most_frequent_product\` that takes a list of transactions as input and returns the product that appears the most frequently across all transactions. Each transaction is represented as a list of product names. For example: >>> transactions = [ [\\"apple\\", \\"banana\\", \\"orange\\"], [\\"banana\\", \\"apple\\", \\"apple\\"], [\\"kiwi\\", \\"banana\\", \\"apple\\", \\"apple\\"], ] >>> most_frequent_product(transactions) 'apple' Specifications: 1. You can assume all transactions will contain at least one product. 2. The product names are case-sensitive, i.e., \\"Apple\\" and \\"apple\\" are considered different products. 3. Aim for an efficient solution in terms of both time and space complexity. 4. The function should handle an empty list of transactions by returning \`None\`. Args: transactions (List[List[str]]): A list of transactions where each transaction is a list of product names. Returns: str: The most frequent product. If the list of transactions is empty, return None.","solution":"from collections import Counter def most_frequent_product(transactions): Returns the product that appears most frequently across all transactions. In case of a tie, return any one of the most frequent products. Args: transactions (List[List[str]]): A list of transactions where each transaction is a list of product names. Returns: str: The most frequent product. If the list of transactions is empty, return None. if not transactions: return None product_counter = Counter() for transaction in transactions: product_counter.update(transaction) most_common_product, _ = product_counter.most_common(1)[0] return most_common_product"},{"question":"def index_of_smallest(arr): Returns the index of the element with the smallest value. If there are multiple elements with the same smallest value, returns the index of the first occurrence. >>> index_of_smallest([5]) == 0 >>> index_of_smallest([4, 4, 4, 4]) == 0 >>> index_of_smallest([5, 4, 3, 2, 1]) == 4 >>> index_of_smallest([1, 2, 3, 4, 5]) == 0 >>> index_of_smallest([4, 2, 1, 5, 1]) == 2 >>> index_of_smallest([-1, -3, -2, 0, 1]) == 1 >>> index_of_smallest([2, 1, 1, 1, 1]) == 1 >>> index_of_smallest([]) # Raises ValueError(\\"Array is empty\\")","solution":"def index_of_smallest(arr): Returns the index of the element with the smallest value. If there are multiple elements with the same smallest value, returns the index of the first occurrence. if not arr: raise ValueError(\\"Array is empty\\") min_value = arr[0] min_index = 0 for i in range(1, len(arr)): if arr[i] < min_value: min_value = arr[i] min_index = i return min_index"},{"question":"from typing import List, Tuple def min_steps(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Determine if there exists a path for the robot to move from the start to the end point without hitting any obstacle. If a path exists, return the steps taken; otherwise, return -1. - The grid is represented by a 2D array where '0' indicates an open cell and '1' denotes an obstacle. - The robot can only move vertically or horizontally, not diagonally. Examples: >>> min_steps([[0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 1, 0], [0, 0, 0, 0]], (0, 0), (3, 3)) 6 >>> min_steps([[0, 1, 0, 0], [0, 1, 0, 1], [1, 1, 1, 0], [0, 0, 0, 0]], (0, 0), (3, 3)) -1","solution":"from collections import deque def min_steps(grid, start, end): Returns the minimum number of steps required to reach from the start to the end point in the grid. If no path exists, return -1. rows = len(grid) cols = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set() visited.add((start[0], start[1])) while queue: r, c, steps = queue.popleft() if (r, c) == end: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], k: int) -> bool: Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k. :param arr: List of integers. :param k: Target sum integer. :return: True if such a pair exists, False otherwise. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([10, 15, 3, 7], 20) False >>> has_pair_with_sum([1, 2, 3, 4, 4], 8) True >>> has_pair_with_sum([-1, 1, -2, 4], 3) True >>> has_pair_with_sum([], 0) False >>> has_pair_with_sum([1], 2) False >>> has_pair_with_sum([10**5, 10**5 - 1], 2 * 10**5 - 1) True","solution":"from typing import List def has_pair_with_sum(arr: List[int], k: int) -> bool: Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k. :param arr: List of integers. :param k: Target sum integer. :return: True if such a pair exists, False otherwise. seen = set() for number in arr: if k - number in seen: return True seen.add(number) return False"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in the input string s while maintaining the order of characters within each word. Parameters: s (str): The input string containing words separated by spaces. Returns: str: The input string with the order of words reversed. Examples: >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\"a b c d\\") \\"d c b a\\"","solution":"def reverse_words(s: str) -> str: Reverses the order of words in the input string s. Parameters: s (str): The input string containing words separated by spaces. Returns: str: The input string with the order of words reversed. words = [] word_start = 0 for i in range(len(s)): if s[i] == ' ': words.append(s[word_start:i]) word_start = i + 1 words.append(s[word_start:]) # Append the last word return ' '.join(reversed(words))"},{"question":"def largest_plateau(matrix: List[List[int]]) -> int: Determine the maximum size of a uniform plateau in the matrix. A uniform plateau is a contiguous region of cells with the same height. Args: matrix (List[List[int]]): A 2-dimensional array representing the field height matrix. Returns: int: The size of the largest uniform plateau. Example: >>> largest_plateau([[1, 2, 2], [3, 2, 2], [4, 4, 4]]) 4","solution":"def largest_plateau(matrix): if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(x, y, height): stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() if visited[cx][cy]: continue visited[cx][cy] = True size += 1 for nx, ny in ((cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)): if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and matrix[nx][ny] == height: stack.append((nx, ny)) return size max_size = 0 for i in range(rows): for j in range(cols): if not visited[i][j]: size = dfs(i, j, matrix[i][j]) max_size = max(max_size, size) return max_size"},{"question":"class Theater: def __init__(self, rows: int, columns: int) -> None: Initializes a theater with the given number of rows and columns. All seats are initially empty. pass def reserve_seat(self, row: int, column: int) -> bool: Attempts to reserve the seat at the specified row and column. Returns True if the reservation is successful, and False if the seat is already occupied. pass def release_seat(self, row: int, column: int) -> bool: Releases the seat at the specified row and column. Returns True if the seat was successfully released, and False if the seat was already empty. pass def is_seat_occupied(self, row: int, column: int) -> bool: Returns True if the seat at the specified row and column is occupied, and False otherwise. pass from solution import Theater def test_initial_state(): theater = Theater(3, 3) assert not theater.is_seat_occupied(1, 1) def test_reserve_seat(): theater = Theater(3, 3) assert theater.reserve_seat(1, 1) == True assert theater.is_seat_occupied(1, 1) == True assert theater.reserve_seat(1, 1) == False def test_release_seat(): theater = Theater(3, 3) theater.reserve_seat(1, 1) assert theater.release_seat(1, 1) == True assert not theater.is_seat_occupied(1, 1) assert theater.release_seat(1, 1) == False def test_reserve_and_release_multiple_seats(): theater = Theater(3, 3) assert theater.reserve_seat(0, 0) == True assert theater.reserve_seat(0, 1) == True assert theater.reserve_seat(0, 2) == True assert theater.is_seat_occupied(0, 0) == True assert theater.is_seat_occupied(0, 1) == True assert theater.is_seat_occupied(0, 2) == True assert theater.release_seat(0, 0) == True assert not theater.is_seat_occupied(0, 0) assert theater.is_seat_occupied(0, 1) == True assert theater.is_seat_occupied(0, 2) == True def test_boundaries(): theater = Theater(3, 3) assert theater.reserve_seat(2, 2) == True assert theater.is_seat_occupied(2, 2) == True assert theater.release_seat(2, 2) == True assert not theater.is_seat_occupied(2, 2) def test_invalid_indexes(): theater = Theater(3, 3) try: theater.reserve_seat(-1, 1) except IndexError: pass try: theater.reserve_seat(1, -1) except IndexError: pass try: theater.reserve_seat(3, 1) except IndexError: pass try: theater.reserve_seat(1, 3) except IndexError: pass","solution":"class Theater: def __init__(self, rows: int, columns: int) -> None: Initializes a theater with the given number of rows and columns. All seats are initially empty. self.rows = rows self.columns = columns # Create a grid of the given size, initialized to False (empty) self.seats = [[False for _ in range(columns)] for _ in range(rows)] def reserve_seat(self, row: int, column: int) -> bool: Attempts to reserve the seat at the specified row and column. Returns True if the reservation is successful, and False if the seat is already occupied. if self.seats[row][column]: return False self.seats[row][column] = True return True def release_seat(self, row: int, column: int) -> bool: Releases the seat at the specified row and column. Returns True if the seat was successfully released, and False if the seat was already empty. if not self.seats[row][column]: return False self.seats[row][column] = False return True def is_seat_occupied(self, row: int, column: int) -> bool: Returns True if the seat at the specified row and column is occupied, and False otherwise. return self.seats[row][column]"},{"question":"def sort_string(s: str) -> str: Returns a new string with the characters of the input string sorted in alphabetical order. :param s: input string consisting of lowercase letters :return: sorted string in alphabetical order >>> sort_string(\\"python\\") 'hnopty' >>> sort_string(\\"a\\") 'a' >>> sort_string(\\"\\") '' >>> sort_string(\\"banana\\") 'aaabnn' >>> sort_string(\\"zyxwvutsrqponmlkjihgfedcba\\") 'abcdefghijklmnopqrstuvwxyz'","solution":"def sort_string(s): Returns a new string with the characters of the input string sorted in alphabetical order. :param s: str : input string consisting of lowercase letters :return: str : sorted string in alphabetical order return ''.join(sorted(s))"},{"question":"def is_valid_IP(ip: str) -> bool: Returns True if ip is a valid IPv4 address, and False otherwise. >>> is_valid_IP(\\"192.168.0.1\\") -> True >>> is_valid_IP(\\"0.0.0.0\\") -> True >>> is_valid_IP(\\"255.255.255.255\\") -> True >>> is_valid_IP(\\"192.168.0.256\\") -> False >>> is_valid_IP(\\"192.168.0\\") -> False >>> is_valid_IP(\\"192.168.0.01\\") -> False","solution":"def is_valid_IP(ip): Returns True if ip is a valid IPv4 address, and False otherwise. parts = ip.split('.') # There must be exactly four parts if len(parts) != 4: return False for part in parts: # Each part must only be digits if not part.isdigit(): return False # Convert part to integer and check range num = int(part) if num < 0 or num > 255: return False # Leading zeros are not allowed if part != str(num): return False return True"},{"question":"def find_magic_row(grid: List[List[int]]) -> Tuple[int, int, int]: Finds the Magic Row in the given grid, which is the row with the highest sum of integers. Returns the index of the Magic Row, the start column index of the subarray with the maximum sum, and the sum itself. >>> find_magic_row([[1, -2, 3, 4], [-1, -2, 3, 4], [5, 6, -3, -2]]) (2, 0, 11) >>> find_magic_row([[-1, -2, -3, -4], [-5, -6, -7, -8], [-9, -10, -11, -12]]) (0, 0, -1) >>> find_magic_row([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) (0, 0, 0) >>> find_magic_row([[42]]) (0, 0, 42) >>> find_magic_row([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) (0, 0, 6) >>> find_magic_row([[1]*1000]*1000) (0, 0, 1000)","solution":"def find_magic_row(grid): Finds the Magic Row in the given grid, which is the row with the highest sum of integers. Returns the index of the Magic Row, the start column index of the subarray with the maximum sum, and the sum itself. def max_subarray_sum(arr): Helper function to find the maximum subarray sum using Kadane's Algorithm max_sum = float('-inf') current_sum = 0 start = end = temp_start = 0 for index, value in enumerate(arr): if current_sum <= 0: temp_start = index current_sum = value else: current_sum += value if current_sum > max_sum: max_sum = current_sum start = temp_start end = index return max_sum, start, end N = len(grid) M = len(grid[0]) if N > 0 else 0 max_row_sum = float('-inf') magic_row_index = 0 magic_start_col = 0 for i in range(N): row_sum, start_col, end_col = max_subarray_sum(grid[i]) if row_sum > max_row_sum: max_row_sum = row_sum magic_row_index = i magic_start_col = start_col elif row_sum == max_row_sum and i < magic_row_index: magic_row_index = i magic_start_col = start_col return magic_row_index, magic_start_col, max_row_sum"},{"question":"def isStrictlyIncreasing(arr): Returns True if the input array is strictly increasing, and False otherwise. An array with fewer than two elements is considered to be strictly increasing. Parameters: arr (list of int): The input array of integers. Returns: bool: True if the array is strictly increasing, False otherwise. >>> isStrictlyIncreasing([]) == True >>> isStrictlyIncreasing([1]) == True >>> isStrictlyIncreasing([1, 2, 3, 4, 5]) == True >>> isStrictlyIncreasing([1, 2, 2, 4, 5]) == False >>> isStrictlyIncreasing([5, 3, 2, 1]) == False >>> isStrictlyIncreasing([-3, -2, 0, 2, 6]) == True >>> isStrictlyIncreasing([1, 1, 1, 1, 1]) == False","solution":"def isStrictlyIncreasing(arr): Returns True if the input array is strictly increasing, and False otherwise. An array with fewer than two elements is considered to be strictly increasing. Parameters: arr (list of int): The input array of integers. Returns: bool: True if the array is strictly increasing, False otherwise. if len(arr) < 2: return True for i in range(1, len(arr)): if arr[i] <= arr[i - 1]: return False return True"},{"question":"def count_unique_books_read(test_cases): Determine the total number of unique books read by Alex given the logs of his reading activity. Args: test_cases: List[Tuple[int, List[str]]] : A list where each element is a tuple. Each tuple consists of an integer 'N' (number of log entries) and a list of strings (log entries). Returns: List[int]: A list of integers representing the number of unique books read by Alex for each test case. pass def parse_input(input_string: str): Parse the input string to extract the number of test cases and logs details. Args: input_string: str : The input string which contains all test case data. Returns: List[Tuple[int, List[str]]]: Parsed test cases. pass def formatted_output(results): Format and print the results. Args: results: List[int] : The results to be printed. for result in results: print(result) # Example usage with sample input input_string = 2 6 BUY TheHobbit READ TheHobbit BUY HarryPotter BUY GOT READ GOT READ HarryPotter 4 BUY Book1 BUY Book2 READ Book1 READ Book3 test_cases = parse_input(input_string) results = count_unique_books_read(test_cases) formatted_output(results)","solution":"def count_unique_books_read(test_cases): results = [] for test_case in test_cases: n, logs = test_case bought_books = set() read_books = set() for log in logs: action, book = log.split(maxsplit=1) if action == \\"BUY\\": bought_books.add(book) elif action == \\"READ\\" and book in bought_books: read_books.add(book) results.append(len(read_books)) return results # Parsing input (for illustrative purpose) def parse_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) logs = input_lines[index + 1: index + 1 + N] test_cases.append((N, logs)) index += N + 1 return test_cases def formatted_output(results): for result in results: print(result) # Example usage input_string = 2 6 BUY TheHobbit READ TheHobbit BUY HarryPotter BUY GOT READ GOT READ HarryPotter 4 BUY Book1 BUY Book2 READ Book1 READ Book3 test_cases = parse_input(input_string) results = count_unique_books_read(test_cases) formatted_output(results)"},{"question":"def max_nesting_depth(s: str) -> int: Returns the maximum depth of nested parentheses in the input string s. >>> max_nesting_depth('(1+(2*3)+((8)/4))+1') 3 >>> max_nesting_depth('(1)+((2))+(((3)))') 3 >>> max_nesting_depth('1+(2*3)/(2-1)') 1 >>> max_nesting_depth('1') 0 >>> max_nesting_depth('') 0 >>> max_nesting_depth('()') 1 >>> max_nesting_depth('(()(()))') 3 >>> max_nesting_depth('((())(()))') 3 >>> max_nesting_depth('((())())') 3 >>> max_nesting_depth('(())()') 2","solution":"def max_nesting_depth(s): Returns the maximum depth of nested parentheses in the input string s. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def longest_decreasing_subsequence(arr: List[int], d: int) -> int: Function to return the longest length of a strictly decreasing subsequence where the absolute difference between any two consecutive elements in the subsequence does not exceed \`d\`. >>> longest_decreasing_subsequence([9, 4, 3, 2, 5, 4, 3, 2], 1) 4 >>> longest_decreasing_subsequence([5, 4, 7, 6, 5, 1, 0], 2) 3 >>> longest_decreasing_subsequence([1, 2, 3, 4, 5], 1) 1 from typing import List def test_example_1(): arr = [9, 4, 3, 2, 5, 4, 3, 2] d = 1 assert longest_decreasing_subsequence(arr, d) == 4 def test_example_2(): arr = [5, 4, 7, 6, 5, 1, 0] d = 2 assert longest_decreasing_subsequence(arr, d) == 3 def test_example_3(): arr = [1, 2, 3, 4, 5] d = 1 assert longest_decreasing_subsequence(arr, d) == 1 def test_edge_case_minimum_length(): arr = [0] d = 1 assert longest_decreasing_subsequence(arr, d) == 1 def test_all_elements_equal(): arr = [3, 3, 3, 3, 3] d = 1 assert longest_decreasing_subsequence(arr, d) == 1 def test_no_possible_decreasing_subsequence(): arr = [4, 10, 8, 5, 2] d = 1 assert longest_decreasing_subsequence(arr, d) == 1 def test_large_d_value(): arr = [10, 9, 5, 4, 3, 7, 6, 2, 1] d = 3 assert longest_decreasing_subsequence(arr, d) == 5","solution":"def longest_decreasing_subsequence(arr, d): Function to return the longest length of a strictly decreasing subsequence where the absolute difference between any two consecutive elements in the subsequence does not exceed \`d\`. n = len(arr) dp = [1] * n max_length = 1 for i in range(1, n): for j in range(i): if arr[j] > arr[i] and arr[j] - arr[i] <= d: dp[i] = max(dp[i], dp[j] + 1) max_length = max(max_length, dp[i]) return max_length"},{"question":"def is_palindrome(inputStr: str) -> bool: Checks if the given inputStr is a palindrome. Args: inputStr (str): The string to be checked. Returns: bool: True if inputStr is a palindrome, False otherwise. >>> is_palindrome(\\"Racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True >>> is_palindrome(\\"Hello\\") False","solution":"def is_palindrome(inputStr): Checks if the given inputStr is a palindrome. Args: inputStr (str): The string to be checked. Returns: bool: True if inputStr is a palindrome, False otherwise. # Convert the string to lower case to make the function case insensitive inputStr = inputStr.lower() # Check if the string reads the same forwards and backwards return inputStr == inputStr[::-1]"},{"question":"def first_non_repeating_element_index(nums: List[int]) -> int: Returns the index of the first non-repeating element in a list of integers. If there is no such element, returns -1. >>> first_non_repeating_element_index([2, 3, 4, 2, 3, 5, 4]) == 5 >>> first_non_repeating_element_index([2, 2, 2, 2, 2, 2, 2]) == -1 >>> first_non_repeating_element_index([10]) == 0 >>> first_non_repeating_element_index([1, 2, 3, 4, 5]) == 0 >>> first_non_repeating_element_index([1, 2, 3, 4, 2, 1, 5, 4]) == 2 >>> first_non_repeating_element_index([2, 2, 3, 3, 4]) == 4","solution":"def first_non_repeating_element_index(nums): Returns the index of the first non-repeating element in a list of integers. If there is no such element, returns -1. element_count = {} for num in nums: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 for index, num in enumerate(nums): if element_count[num] == 1: return index return -1"},{"question":"from collections import deque from typing import List def remove_invalid_parentheses(s: str) -> List[str]: Remove the minimum number of invalid parentheses to make the input string valid. Return all possible results. Examples: >>> remove_invalid_parentheses(\\"()())()\\") [\\"()()()\\", \\"(())()\\"] >>> remove_invalid_parentheses(\\"(a)())()\\") [\\"(a)()()\\", \\"(a())()\\"] >>> remove_invalid_parentheses(\\")(\\") [\\"\\"] def test_remove_invalid_parentheses_example1(): assert set(remove_invalid_parentheses(\\"()())()\\")) == {\\"()()()\\", \\"(())()\\"} def test_remove_invalid_parentheses_example2(): assert set(remove_invalid_parentheses(\\"(a)())()\\")) == {\\"(a)()()\\", \\"(a())()\\"} def test_remove_invalid_parentheses_example3(): assert set(remove_invalid_parentheses(\\")(\\")) == {\\"\\"} def test_remove_invalid_parentheses_no_invalid(): assert set(remove_invalid_parentheses(\\"(abc)\\")) == {\\"(abc)\\"} def test_remove_invalid_parentheses_only_letters(): assert set(remove_invalid_parentheses(\\"abc\\")) == {\\"abc\\"} def test_remove_invalid_parentheses_empty(): assert set(remove_invalid_parentheses(\\"\\")) == {\\"\\"}","solution":"from collections import deque def remove_invalid_parentheses(s): Remove the minimum number of invalid parentheses to make the input string valid. Return all possible results. def is_valid(string): counter = 0 for char in string: if char == '(': counter += 1 elif char == ')': counter -= 1 if counter < 0: return False return counter == 0 if not s: return [\\"\\"] visited = set() queue = deque([s]) found = False result = [] while queue: current = queue.popleft() if is_valid(current): result.append(current) found = True if found: continue for i in range(len(current)): if current[i].isalpha(): continue next_state = current[:i] + current[i+1:] if next_state not in visited: visited.add(next_state) queue.append(next_state) return result"},{"question":"def product_except_self(arr): Given an array of integers, return a new array where each element at index \`i\` is the product of all the numbers in the original array except the one at \`i\`. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([1]) [1] >>> product_except_self([3, 4]) [4, 3] >>> product_except_self([0, 4, 2]) [8, 0, 0] >>> product_except_self([]) []","solution":"def product_except_self(arr): Returns a new array where each element at index i is the product of all the numbers in the original array except the one at i. if not arr: return [] length = len(arr) result = [1] * length # Calculate left products left_product = 1 for i in range(length): result[i] = left_product left_product *= arr[i] # Calculate right products and combine with left products right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"def min_operations_to_non_negative(arr): Return the minimum number of operations to make all elements in the array non-negative. >>> min_operations_to_non_negative([-1, 2, -3, 4, -5]) 3 >>> min_operations_to_non_negative([-1, -2, -3, -4]) 4 >>> min_operations_to_non_negative([1, 1, 1]) 0 import pytest from solution import min_operations_to_non_negative def test_single_operation_segments(): assert min_operations_to_non_negative([-1, 2, -3, 4, -5]) == 3 def test_all_negative(): assert min_operations_to_non_negative([-1, -2, -3, -4]) == 4 def test_all_positive(): assert min_operations_to_non_negative([1, 1, 1]) == 0 def test_mixed_values(): assert min_operations_to_non_negative([-1, 0, 1, -2, 2, -3, 3]) == 3 def test_no_negatives(): assert min_operations_to_non_negative([0, 2, 5, 8]) == 0 def test_alternating_signs(): assert min_operations_to_non_negative([-1, 1, -1, 1]) == 2 def test_large_values(): assert min_operations_to_non_negative([-1000000000, 1000000000]) == 1 def test_equal_positive_and_negative(): assert min_operations_to_non_negative([1, -1, 1, -1, 1, -1]) == 3","solution":"def min_operations_to_non_negative(arr): Return the minimum number of operations to make all elements in the array non-negative. operations = 0 is_negative_segment = False for num in arr: if num < 0 and not is_negative_segment: operations += 1 is_negative_segment = True elif num >= 0: is_negative_segment = False return operations"},{"question":"def is_transform_possible(M: int, S: str, T: str) -> str: Determines if it is possible to transform string S into string T using at most M operations (swap or reverse). >>> is_transform_possible(3, \\"abcdef\\", \\"abcfed\\") 'YES' >>> is_transform_possible(1, \\"abcd\\", \\"abdc\\") 'YES' >>> is_transform_possible(1, \\"abcd\\", \\"abcd\\") 'YES' >>> is_transform_possible(1, \\"abcd\\", \\"abce\\") 'NO' >>> is_transform_possible(3, \\"abcdef\\", \\"ghijkl\\") 'NO' ... def process_queries(queries: list) -> list: Processes multiple queries to determine if each transformation is possible. >>> queries = [ ... (3, \\"abcdef\\", \\"abcfed\\"), ... (1, \\"abcd\\", \\"abdc\\"), ... (2, \\"abcd\\", \\"dcba\\"), ... (1, \\"abcd\\", \\"abcd\\"), ... (1, \\"abcd\\", \\"abce\\"), ... ] >>> process_queries(queries) ['YES', 'YES', 'YES', 'YES', 'NO'] ... def test_is_transform_possible(): assert is_transform_possible(3, \\"abcdef\\", \\"abcfed\\") == \\"YES\\" assert is_transform_possible(1, \\"abcd\\", \\"abdc\\") == \\"YES\\" assert is_transform_possible(2, \\"abcd\\", \\"dcba\\") == \\"YES\\" assert is_transform_possible(1, \\"abcd\\", \\"abcd\\") == \\"YES\\" assert is_transform_possible(0, \\"abcd\\", \\"abcd\\") == \\"YES\\" assert is_transform_possible(1, \\"abcd\\", \\"abce\\") == \\"NO\\" assert is_transform_possible(5, \\"abcde\\", \\"edbca\\") == \\"YES\\" assert is_transform_possible(3, \\"abcdef\\", \\"ghijkl\\") == \\"NO\\" assert is_transform_possible(4, \\"aabbaacca\\", \\"ccaabbaaa\\") == \\"YES\\" assert is_transform_possible(4, \\"abcdefg\\", \\"gfedcba\\") == \\"YES\\" def test_process_queries(): queries = [ (3, \\"abcdef\\", \\"abcfed\\"), (1, \\"abcd\\", \\"abdc\\"), (2, \\"abcd\\", \\"dcba\\"), (1, \\"abcd\\", \\"abcd\\"), (1, \\"abcd\\", \\"abce\\"), ] expected_results = [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] assert process_queries(queries) == expected_results","solution":"def is_transform_possible(M, S, T): Determines if it is possible to transform string S into string T using at most M operations (swap or reverse). # Check if S and T are already equal if S == T: return \\"YES\\" # If sorting both results in different strings, it's impossible if sorted(S) != sorted(T): return \\"NO\\" # Check if the difference can be made in at most M operations # Consider each mismatch and count the required operations def get_mismatches(S, T): mismatches = [] for i in range(len(S)): if S[i] != T[i]: mismatches.append(i) return mismatches def required_operations(mismatches): if len(mismatches) == 0: return 0 # For each mismatch, counting pairs for swap swaps_needed = len(mismatches) // 2 # Plus remaining one-sided mismatches extra_operations = len(mismatches) % 2 return swaps_needed + extra_operations mismatches = get_mismatches(S, T) operations = required_operations(mismatches) return \\"YES\\" if operations <= M else \\"NO\\" def process_queries(queries): results = [] for M, S, T in queries: results.append(is_transform_possible(M, S, T)) return results"},{"question":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: Determine the minimum cost required to move from the top-left corner to the bottom-right corner of a grid. >>> min_cost_path([ ... [1, 3, 1], ... [1, 2, 3], ... [1, 3, 2] ... ]) == 8","solution":"def min_cost_path(grid): N = len(grid) M = len(grid[0]) # Initialize a 2D list to store the minimum cost to reach each cell dp = [[0]*M for _ in range(N)] # Set the cost for the starting cell dp[0][0] = grid[0][0] # Fill out the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill out the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill out the rest of the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer is the minimum cost to reach the bottom-right corner return dp[N-1][M-1]"},{"question":"from typing import List def is_path_exists(grid: List[str]) -> bool: Determine if there is a path from the top-left corner to the bottom-right corner of a grid. The grid is represented as a list of strings, where each string is a row of the grid and each character is either: '#' representing a wall, or '.' representing an open space. Movements are allowed up, down, left, or right, but not through walls. >>> is_path_exists([ ... \\"....\\", ... \\"..\\", ... \\"...#\\", ... \\"#...\\" ... ]) True >>> is_path_exists([ ... \\"....\\", ... \\"\\", ... \\"....\\", ... \\"#...\\" ... ]) False","solution":"from typing import List def is_path_exists(grid: List[str]) -> bool: n = len(grid) visited = [[False] * n for _ in range(n)] def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= n or grid[x][y] == '#' or visited[x][y]: return False if x == n-1 and y == n-1: return True visited[x][y] = True if (dfs(x+1, y) or dfs(x-1, y) or dfs(x, y+1) or dfs(x, y-1)): return True return False return dfs(0, 0)"},{"question":"from typing import List def minimize_weight(stones: List[int], k: int) -> int: Minimize the total weight of the remaining stones after optimal sequence of removals. >>> minimize_weight([4, 3, 6, 7], 2) 0 >>> minimize_weight([1], 1) 1 >>> minimize_weight([1, 5, 9, 15], 2) 30 >>> minimize_weight([2, 4, 6, 8], 2) 0 >>> minimize_weight([1, 3, 5, 7, 9], 2) 9 >>> minimize_weight([100, 200, 300, 400], 150) 0","solution":"from typing import List def minimize_weight(stones: List[int], k: int) -> int: # Sort stones to easily find pairs with weight differences less than or equal to k stones.sort() while len(stones) > 1: found_pair = False for i in range(len(stones) - 1): if abs(stones[i] - stones[i + 1]) <= k: del stones[i:i + 2] found_pair = True break if not found_pair: break return sum(stones)"},{"question":"def min_moves(arr: list[int]) -> int: Find the minimum number of moves required to make all array elements equal. In one move, you can increment or decrement an element of the array by 1. >>> min_moves([1, 2, 3]) 2 >>> min_moves([10, 2, 5, 7]) 10 >>> min_moves([7]) 0 >>> min_moves([2, 4]) 2 >>> min_moves([-1, 1, -2, 2, -3, 3]) 12 >>> min_moves([5, 5, 5, 5]) 0 >>> min_moves([1, 1000000]) 999999 >>> min_moves([-1, -2, -3, -4, -5]) 6 pass","solution":"from typing import List def min_moves(arr: List[int]) -> int: Finds the minimum number of moves required to make all array elements equal. In one move, you can increment or decrement an element of the array by 1. The optimal way to make all elements equal is to move them to the median of the array. arr.sort() median = arr[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"def reverse_words(s: str) -> str: Create a function reverse_words that takes a string of one or more words and returns the string with the words in reverse order. >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\"Coding is fun\\") \\"fun is Coding\\"","solution":"def reverse_words(s): Returns the string with the order of words reversed. :param s: A string of one or more words separated by spaces. # Split the string on spaces to get a list of words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words back into a single string with spaces return ' '.join(reversed_words)"},{"question":"def generate_trigrams(text: str) -> list: Generate all possible trigrams from the given text string. Args: text (str): The input alphanumeric, spaceless string. Returns: List[str]: A list containing all the trigrams in the order they appear. Examples: >>> generate_trigrams(\\"hello\\") [\\"hel\\", \\"ell\\", \\"llo\\"] >>> generate_trigrams(\\"abcdef\\") [\\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\"] >>> generate_trigrams(\\"abc\\") [\\"abc\\"] >>> generate_trigrams(\\"ab\\") [] >>> generate_trigrams(\\"a\\") [] >>> generate_trigrams(\\"\\") [] >>> generate_trigrams(\\"aaa\\") [\\"aaa\\"] >>> generate_trigrams(\\"aaaa\\") [\\"aaa\\", \\"aaa\\"] >>> generate_trigrams(\\"12345\\") [\\"123\\", \\"234\\", \\"345\\"] >>> generate_trigrams(\\"11122\\") [\\"111\\", \\"112\\", \\"122\\"] >>> generate_trigrams(\\"a1b2c3\\") [\\"a1b\\", \\"1b2\\", \\"b2c\\", \\"2c3\\"]","solution":"def generate_trigrams(text): Generate all possible trigrams from the given text string. Args: text (str): The input string. Returns: List[str]: A list containing all the trigrams in the order they appear. trigrams = [] for i in range(len(text) - 2): trigrams.append(text[i:i+3]) return trigrams"},{"question":"def longest_consecutive_subsequence(lst: List[int]) -> int: Determine the length of the longest consecutive subsequence in the list. >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([5]) == 1 >>> longest_consecutive_subsequence([1, 2]) == 2 >>> longest_consecutive_subsequence([1, 3]) == 1 >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_subsequence([1, 9, 3, 10, 4, 20, 2]) == 4 >>> longest_consecutive_subsequence([10, 5, 12, 3, 55, 11, 14, 4, 13]) == 5 >>> longest_consecutive_subsequence([10, 30, 40, 20, 50]) == 1 >>> longest_consecutive_subsequence([1, 2, 2, 3, 3, 4, 5, 5]) == 5","solution":"def longest_consecutive_subsequence(lst): if not lst: return 0 num_set = set(lst) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def duplicate_counter(lst): Returns a dictionary with each element in the list as the key and the number of times that element appears in the list as the value. >>> duplicate_counter(['a', 'b', 'b', 'c', 'a', 'c', 'c', 'a']) {'a': 3, 'b': 2, 'c': 3} >>> duplicate_counter([1, 2, 2, 3, 1, 3, 3, 1]) {1: 3, 2: 2, 3: 3} >>> duplicate_counter([1, 'a', 'a', 2, 1, 'b', 'b', 2]) {1: 2, 'a': 2, 2: 2, 'b': 2} >>> duplicate_counter([]) {} >>> duplicate_counter(['x']) {'x': 1}","solution":"def duplicate_counter(lst): Returns a dictionary with each element in the list as the key and the number of times that element appears in the list as the value. counter = {} for item in lst: if item in counter: counter[item] += 1 else: counter[item] = 1 return counter"},{"question":"class Library: A class used to represent a Library Methods ------- add_book(title: str, author: str, year: int) -> None Adds a book with the given title, author, and publication year to the library. remove_book(title: str) -> None Removes a book with the specified title from the library. search_by_title(title: str) -> List[Dict[str, Union[str, int]]] Searches for books with titles containing the given substring (case-insensitive) and returns a list of matching books sorted by title. search_by_author(author: str) -> List[Dict[str, Union[str, int]]] Searches for books by the specified author and returns a list of matching books sorted by title. list_books_by_year(year: int) -> List[Dict[str, Union[str, int]]] Lists all books published in the given year, sorted by title. def __init__(self): self.books = [] def add_book(self, title, author, year): Adds a book to the library. pass def remove_book(self, title): Removes a book with the specified title from the library. pass def search_by_title(self, title): Searches for books with titles containing the given substring. pass def search_by_author(self, author): Searches for books by the specified author. pass def list_books_by_year(self, year): Lists all books published in the given year. pass # Example usage library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) library.add_book(\\"1984\\", \\"George Orwell\\", 1949) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) print(library.search_by_title(\\"The\\")) # returns [{\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"year\\": 1951}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925}] print(library.search_by_author(\\"George Orwell\\")) # returns [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}] print(library.list_books_by_year(1925)) # returns [{\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925}] library.remove_book(\\"1984\\") print(library.search_by_author(\\"George Orwell\\")) # returns [] # Unit Tests def test_library_add_book(): library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) assert len(library.books) == 1 assert library.books[0] == {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925} def test_library_remove_book(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949) library.remove_book(\\"1984\\") assert len(library.books) == 0 def test_library_search_by_title(): library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) library.add_book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) result = library.search_by_title(\\"The\\") expected = [ {\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"year\\": 1951}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925} ] assert result == expected def test_library_search_by_author(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949) result = library.search_by_author(\\"George Orwell\\") expected = [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}] assert result == expected def test_library_list_books_by_year(): library = Library() library.add_book(\\"Sapiens\\", \\"Yuval Noah Harari\\", 2011) result = library.list_books_by_year(2011) expected = [{\\"title\\": \\"Sapiens\\", \\"author\\": \\"Yuval Noah Harari\\", \\"year\\": 2011}] assert result == expected def test_library_search_by_title_case_insensitive(): library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) result = library.search_by_title(\\"the great gatsby\\") expected = [{\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925}] assert result == expected def test_library_remove_nonexistent_book(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949) library.remove_book(\\"Animal Farm\\") assert len(library.books) == 1 assert library.books[0] == {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949} def test_library_search_by_author_case_insensitive(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949) result = library.search_by_author(\\"george orwell\\") expected = [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}] assert result == expected","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title, author, year): Adds a book to the library. book = {\\"title\\": title, \\"author\\": author, \\"year\\": year} self.books.append(book) def remove_book(self, title): Removes a book with the specified title from the library. self.books = [book for book in self.books if book[\\"title\\"].lower() != title.lower()] def search_by_title(self, title): Searches for books with titles containing the given substring. matches = [book for book in self.books if title.lower() in book[\\"title\\"].lower()] return sorted(matches, key=lambda x: x['title']) def search_by_author(self, author): Searches for books by the specified author. matches = [book for book in self.books if author.lower() in book[\\"author\\"].lower()] return sorted(matches, key=lambda x: x['title']) def list_books_by_year(self, year): Lists all books published in the given year. matches = [book for book in self.books if book[\\"year\\"] == year] return sorted(matches, key=lambda x: x['title'])"},{"question":"def is_closed_loop(moves: str) -> bool: Determines if a series of moves in a 2D grid forms a closed loop. >>> is_closed_loop(\\"UD\\") True >>> is_closed_loop(\\"LL\\") False >>> is_closed_loop(\\"LDRRUULD\\") True >>> is_closed_loop(\\"UDLR\\") True >>> is_closed_loop(\\"RRRR\\") False","solution":"def is_closed_loop(moves: str) -> bool: Determines if a series of moves in a 2D grid forms a closed loop. x, y = 0, 0 for move in moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return x == 0 and y == 0"},{"question":"def is_power_of_two(x: int) -> bool: Returns True if x is a power of 2, otherwise returns False. >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(4) True >>> is_power_of_two(16) True >>> is_power_of_two(18) False >>> is_power_of_two(0) False >>> is_power_of_two(-1) False pass","solution":"def is_power_of_two(x): Returns True if x is a power of 2, otherwise returns False. if x <= 0: return False return (x & (x - 1)) == 0"},{"question":"def binaryArrayToDecimalAndBack(binary_array): Convert a binary array to its equivalent decimal number and back to binary array format. Returns a dictionary with 'decimal' and 'binary' keys. >>> binaryArrayToDecimalAndBack([1, 0, 1, 1]) == {'decimal': 11, 'binary': [1, 0, 1, 1]} >>> binaryArrayToDecimalAndBack([0, 0, 0, 0]) == {'decimal': 0, 'binary': [0]} >>> binaryArrayToDecimalAndBack([1, 1, 1, 0]) == {'decimal': 14, 'binary': [1, 1, 1, 0]} >>> binaryArrayToDecimalAndBack([1, 0, 1, 0, 1, 0]) == {'decimal': 42, 'binary': [1, 0, 1, 0, 1, 0]} >>> binaryArrayToDecimalAndBack([1]) == {'decimal': 1, 'binary': [1]} >>> binaryArrayToDecimalAndBack([0]) == {'decimal': 0, 'binary': [0]}","solution":"def binaryArrayToDecimalAndBack(binary_array): Convert a binary array to its equivalent decimal number and back to binary array format. Returns a dictionary with 'decimal' and 'binary' keys. # Convert binary array to decimal number decimal_number = sum(val * (2 ** idx) for idx, val in enumerate(reversed(binary_array))) # Convert decimal number back to binary array binary_array_back = [int(digit) for digit in bin(decimal_number)[2:]] return { 'decimal': decimal_number, 'binary': binary_array_back }"},{"question":"def max_digit_product(n: int) -> int: Returns the maximum product of the digits of any number that can be made with n digits. >>> max_digit_product(3) == 729 >>> max_digit_product(2) == 81 >>> max_digit_product(1) == 9 >>> max_digit_product(0) == 0 >>> max_digit_product(-5) == 0 >>> max_digit_product(10) == 3486784401","solution":"def max_digit_product(n): Returns the maximum product of the digits of any number that can be made with n digits. if n < 1: return 0 # The maximum product is obtained by using the digit '9' as many times as possible. max_product = 9 ** n return max_product"},{"question":"def reverse_words(input_string: str) -> str: Reverses each word in the input string while keeping the order of the words the same. Args: input_string (str): The input string containing alphabetic characters and spaces. Returns: str: A string with each word reversed. pass def test_single_word(): assert reverse_words(\\"hello\\") == \\"olleh\\" def test_multiple_words(): assert reverse_words(\\"hello world\\") == \\"olleh dlrow\\" def test_words_with_different_lengths(): assert reverse_words(\\"a ab abc abcd\\") == \\"a ba cba dcba\\" def test_all_caps(): assert reverse_words(\\"ABC DEF GHI\\") == \\"CBA FED IHG\\" def test_mixed_case(): assert reverse_words(\\"Hello World\\") == \\"olleH dlroW\\"","solution":"def reverse_words(input_string): Reverses each word in the input string while keeping the order of the words the same. Args: input_string (str): The input string containing alphabetic characters and spaces. Returns: str: A string with each word reversed. words = input_string.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def convertTemperature(celsius): Converts a temperature in Celsius to Fahrenheit and adds respective labels if necessary. Args: celsius (float or int): Temperature in Celsius Returns: str: Converted temperature in Fahrenheit with appropriate labels Examples: >>> convertTemperature(25) \\"77.0\\" >>> convertTemperature(-10) \\"14.0 Freezing\\" >>> convertTemperature(101) \\"213.8 Boiling\\" >>> convertTemperature(0) \\"32.0\\" >>> convertTemperature(100) \\"212.0\\" >>> convertTemperature(-30) \\"-22.0 Freezing\\"","solution":"def convertTemperature(celsius): Converts a temperature in Celsius to Fahrenheit and adds respective labels if necessary. Args: celsius (float or int): Temperature in Celsius Returns: str: Converted temperature in Fahrenheit with appropriate labels fahrenheit = (celsius * 9/5) + 32 result = f\\"{fahrenheit:.1f}\\" if celsius < 0: result += \\" Freezing\\" elif celsius > 100: result += \\" Boiling\\" return result"},{"question":"def min_deletions_to_palindrome(n: int, s: str) -> int: This function returns the minimum number of deletions required to make a given string a palindrome. pass def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: This function processes multiple test cases and returns the minimum deletions for each case. >>> process_test_cases(3, [(3, \\"abc\\"), (5, \\"ababa\\"), (4, \\"abca\\")]) [2, 0, 1] >>> process_test_cases(2, [(6, \\"abcdef\\"), (7, \\"racecar\\")]) [5, 0] pass def test_min_deletions_to_palindrome(): assert min_deletions_to_palindrome(3, \\"abc\\") == 2 assert min_deletions_to_palindrome(5, \\"ababa\\") == 0 assert min_deletions_to_palindrome(4, \\"abca\\") == 1 assert min_deletions_to_palindrome(1, \\"a\\") == 0 assert min_deletions_to_palindrome(2, \\"aa\\") == 0 assert min_deletions_to_palindrome(2, \\"ab\\") == 1 def test_process_test_cases(): assert process_test_cases(3, [(3, \\"abc\\"), (5, \\"ababa\\"), (4, \\"abca\\")]) == [2, 0, 1] assert process_test_cases(2, [(6, \\"abcdef\\"), (7, \\"racecar\\")]) == [5, 0] assert process_test_cases(1, [(4, \\"aabb\\")]) == [2] def test_edge_cases(): assert min_deletions_to_palindrome(6, \\"aaaaaa\\") == 0 assert min_deletions_to_palindrome(7, \\"abacaba\\") == 0 assert min_deletions_to_palindrome(8, \\"abcdefgh\\") == 7","solution":"def min_deletions_to_palindrome(n, s): This function returns the minimum number of deletions required to make a given string a palindrome. def longest_palindromic_subsequence(s): Helper function to calculate the length of the longest palindromic subsequence in s. m = len(s) dp = [[0] * m for _ in range(m)] for i in range(m): dp[i][i] = 1 for cl in range(2, m + 1): for i in range(m - cl + 1): j = i + cl - 1 if s[i] == s[j]: if cl == 2: dp[i][j] = 2 else: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][m - 1] lps = longest_palindromic_subsequence(s) return n - lps def process_test_cases(t, test_cases): This function processes multiple test cases and returns the minimum deletions for each case. result = [] for i in range(t): n, s = test_cases[i] result.append(min_deletions_to_palindrome(n, s)) return result"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Find the maximum profit achievable with a single transaction. :param prices: List[int] stock prices over consecutive days. :return: int maximum profit possible. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"def maxProfit(prices): Returns the maximum profit with a single buy-sell transaction. :param prices: List[int] stock prices over consecutive days. :return: int maximum profit possible. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def longest_substring_with_k_distinct_characters(S: str, K: int) -> int: Find the length of the longest substring of S which contains at most K distinct characters. >>> longest_substring_with_k_distinct_characters(\\"abaccc\\", 2) 4 >>> longest_substring_with_k_distinct_characters(\\"a\\", 1) 1 >>> longest_substring_with_k_distinct_characters(\\"a\\", 0) 0 >>> longest_substring_with_k_distinct_characters(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct_characters(\\"aa\\", 1) 2 >>> longest_substring_with_k_distinct_characters(\\"aaabb\\", 1) 3 >>> longest_substring_with_k_distinct_characters(\\"aaabb\\", 2) 5 >>> longest_substring_with_k_distinct_characters(\\"aabacbebebe\\", 3) 7","solution":"def longest_substring_with_k_distinct_characters(S, K): from collections import defaultdict n = len(S) if n * K == 0: return 0 left, right = 0, 0 hashmap = defaultdict(int) max_length = 1 while right < n: hashmap[S[right]] += 1 right += 1 while len(hashmap) > K: hashmap[S[left]] -= 1 if hashmap[S[left]] == 0: del hashmap[S[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"def alphabet_position(text: str) -> str: Replace each letter in a given string with its position in the alphabet. Non-alphabet characters are ignored, and the function is case-insensitive. Arguments: text -- the input string Returns: A new string where each letter is replaced by its position in the alphabet. Examples: >>> alphabet_position(\\"abc\\") '1 2 3' >>> alphabet_position(\\"aBcDeF\\") '1 2 3 4 5 6' >>> alphabet_position(\\"hello\\") '8 5 12 12 15' pass # Test cases def test_alphabet_position_all_lowercase(): assert alphabet_position(\\"abc\\") == \\"1 2 3\\" def test_alphabet_position_mixed_case(): assert alphabet_position(\\"aBcDeF\\") == \\"1 2 3 4 5 6\\" def test_alphabet_position_hello(): assert alphabet_position(\\"hello\\") == \\"8 5 12 12 15\\" def test_alphabet_position_with_non_alpha_chars(): assert alphabet_position(\\"hello!\\") == \\"8 5 12 12 15\\" assert alphabet_position(\\"123abc!\\") == \\"1 2 3\\" assert alphabet_position(\\"abc123abc!\\") == \\"1 2 3 1 2 3\\" def test_alphabet_position_empty_string(): assert alphabet_position(\\"\\") == \\"\\" def test_alphabet_position_all_non_alpha_chars(): assert alphabet_position(\\"123!@#\\") == \\"\\"","solution":"def alphabet_position(text): Replace each letter in a given string with its position in the alphabet. Non-alphabet characters are ignored, and the function is case-insensitive. Arguments: text -- the input string Returns: A new string where each letter is replaced by its position in the alphabet. positions = [] for char in text.lower(): if char.isalpha(): position = ord(char) - ord('a') + 1 positions.append(str(position)) return ' '.join(positions)"},{"question":"def is_balanced(n: int, m: int) -> bool: Check if a given grid of size n x m can be transformed into a balanced grid. >>> is_balanced(2, 3) True >>> is_balanced(4, 5) True >>> is_balanced(3, 3) True >>> is_balanced(2, 2) False >>> is_balanced(4, 4) False >>> is_balanced(1, 1) True >>> is_balanced(3, 2) True >>> is_balanced(2, 1) True def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[str]: Process multiple test cases of grid sizes to determine if they can be transformed into balanced grids. >>> process_test_cases([(2, 3), (4, 5), (3, 3), (2, 2)]) ['Balanced', 'Balanced', 'Balanced', 'Not Balanced'] >>> process_test_cases([(4, 4), (2, 2)]) ['Not Balanced', 'Not Balanced'] >>> process_test_cases([(1, 1), (3, 2), (2, 1)]) ['Balanced', 'Balanced', 'Balanced']","solution":"def is_balanced(n, m): Check if a given grid of size n x m can be transformed into a balanced grid. return (n % 2 == 1) or (m % 2 == 1) def process_test_cases(test_cases): results = [] for n, m in test_cases: if is_balanced(n, m): results.append(\\"Balanced\\") else: results.append(\\"Not Balanced\\") return results"},{"question":"def findSingleElement(arr: list) -> int: Finds the single element that appears only once in an array where each other element appears twice. :param arr: List of integers :return: The integer that appears only once Examples: >>> findSingleElement([2, 2, 3, 2]) 3 >>> findSingleElement([0, 1, 0, 1, 0, 1, 99]) 99 >>> findSingleElement([7, 3, 5, 4, 5, 3, 4]) 7","solution":"def findSingleElement(arr): Finds the single element that appears only once in an array where each other element appears twice. Uses XOR to achieve linear runtime complexity and constant space complexity. :param arr: List of integers :return: The integer that appears only once result = 0 for num in arr: result ^= num return result"},{"question":"def is_balanced_brackets(s: str) -> bool: Determines if the sequence of brackets is balanced. A sequence is balanced if all opening brackets have corresponding closing brackets in the correct order. The function should return \\"invalid input\\" if there are characters other than the specified brackets. Brackets include the following characters: - () - {} - [] Args: s (str): The input string representing a sequence of brackets. Returns: bool: True if the sequence is balanced, False otherwise, and \\"invalid input\\" for any non-valid characters. >>> is_balanced_brackets(\\"{[()]}\\") True >>> is_balanced_brackets(\\"{[(])}\\") False >>> is_balanced_brackets(\\"{[a]}\\") \\"invalid input\\" >>> is_balanced_brackets(\\"\\") True >>> is_balanced_brackets(\\"{{{\\") False >>> is_balanced_brackets(\\"}}}\\") False","solution":"def is_balanced_brackets(s: str) -> bool: Returns True if the sequence of brackets in the string is balanced, False otherwise. If the string contains characters other than the specified brackets, it returns \\"invalid input\\". bracket_pairs = { '(': ')', '{': '}', '[': ']' } # Stack to keep track of the opening brackets stack = [] for char in s: if char in bracket_pairs: # If it's an opening bracket stack.append(char) elif char in bracket_pairs.values(): # If it's a closing bracket if stack and bracket_pairs[stack[-1]] == char: stack.pop() else: return False else: return \\"invalid input\\" # If there are no leftover opening brackets, it's balanced return not stack"},{"question":"from typing import List def longest_path(matrix: List[List[int]]) -> int: Implement a function that takes a 2D matrix of integers as input and returns the length of the longest increasing path in the matrix. >>> matrix = [ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ] >>> longest_path(matrix) 4 >>> matrix = [ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ] >>> longest_path(matrix) 4 >>> matrix = [ ... [1] ... ] >>> longest_path(matrix) 1","solution":"from typing import List def longest_path(matrix: List[List[int]]) -> int: if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) cache = [[-1 for _ in range(cols)] for _ in range(rows)] def dfs(x: int, y: int) -> int: if cache[x][y] != -1: return cache[x][y] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) cache[x][y] = max_length return max_length max_path_length = 0 for i in range(rows): for j in range(cols): max_path_length = max(max_path_length, dfs(i, j)) return max_path_length"},{"question":"def missing_number(nums: List[int]) -> int: Returns the missing number in the range [0, n] from the list nums. >>> missing_number([3, 0, 1]) 2 >>> missing_number([0, 1]) 2 >>> missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8","solution":"def missing_number(nums): Returns the missing number in the range [0, n] from the list nums. n = len(nums) expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"from typing import List, Tuple def sectors_above_average(T: int, snapshots: List[Tuple[int, List[int]]]) -> List[int]: Determine the number of sectors that have energy levels greater than the average energy level within each snapshot. >>> sectors_above_average(2, [(5, [10, 20, 30, 40, 50]), (4, [5, 9, 8, 7])]) [2, 2] >>> sectors_above_average(1, [(3, [1, 1, 1])]) [0] >>> sectors_above_average(1, [(4, [5, 5, 5, 5])]) [0] >>> sectors_above_average(1, [(1, [10])]) [0] >>> sectors_above_average(1, [(4, [1000000000, 1000000000, 1000000000, 1000000000])]) [0] >>> sectors_above_average(1, [(6, [100, 200, 50, 300, 150, 250])]) [3] >>> sectors_above_average(1, [(0, [])]) [0] results = [] for snapshot in snapshots: N, energy_levels = snapshot if N == 0: results.append(0) continue average = sum(energy_levels) / N count_above_average = sum(1 for energy in energy_levels if energy > average) results.append(count_above_average) return results","solution":"def sectors_above_average(T, snapshots): results = [] for snapshot in snapshots: N, energy_levels = snapshot if N == 0: results.append(0) continue average = sum(energy_levels) / N count_above_average = sum(1 for energy in energy_levels if energy > average) results.append(count_above_average) return results"},{"question":"def is_palindrome(num: int) -> bool: Check if the number is a palindrome. return str(num) == str(num)[::-1] def find_palindrome_steps(number: int) -> int: Returns the number of steps required to reach a palindrome according to the transformation rules. If the number does not become a palindrome within 1000 steps, return -1 to indicate it gets stuck in a loop. >>> find_palindrome_steps(87) 4 >>> find_palindrome_steps(121) 0 >>> find_palindrome_steps(196) -1","solution":"def is_palindrome(num): Check if the number is a palindrome. return str(num) == str(num)[::-1] def find_palindrome_steps(number): Returns the number of steps required to reach a palindrome. If the number does not become a palindrome within 1000 steps, returns -1. steps = 0 while steps < 1000: if is_palindrome(number): return steps reversed_number = int(str(number)[::-1]) number += reversed_number steps += 1 return -1"},{"question":"def daily_temperatures(temperatures): Returns an array indicating the number of days to wait until a warmer temperature for each day. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([70, 71, 72, 73, 74]) [1, 1, 1, 1, 0] >>> daily_temperatures([76, 75, 74, 73, 72]) [0, 0, 0, 0, 0] >>> daily_temperatures([30, 31, 30, 30, 35, 32]) [1, 3, 2, 1, 0, 0] >>> daily_temperatures([30]) [0] >>> daily_temperatures([30, 35]) [1, 0] >>> daily_temperatures([35, 30]) [0, 0]","solution":"def daily_temperatures(temperatures): Returns an array indicating the number of days to wait until a warmer temperature for each day. n = len(temperatures) answer = [0] * n stack = [] # stack to store indexes of 'temperatures' we are considering for i in range(n): # While the stack is not empty and the current temperature is greater than the temperature at the index stored in the top of stack while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"def longest_substring_without_repeating_chars(s: str) -> int: Find the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_chars(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_chars(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_chars(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_chars(\\"\\") 0","solution":"def longest_substring_without_repeating_chars(s): Returns the length of the longest substring without repeating characters in the given string. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def min_time_to_move(t: int, test_cases: List[Tuple[int, int, int, int]]) -> List[int]: Determine the minimum amount of time the gardener needs to bring the wheelbarrow from (x1, y1) to (x2, y2). >>> min_time_to_move(2, [(1, 2, 2, 3), (1, 1, 1, 5)]) [2, 4] >>> min_time_to_move(1, [(3, 3, 3, 5)]) [2] >>> min_time_to_move(1, [(3, 3, 7, 3)]) [4] >>> min_time_to_move(1, [(2, 3, 5, 7)]) [7] >>> min_time_to_move(1, [(1, 1, 1, 1)]) [0] >>> min_time_to_move(1, [(1000000000, 1000000000, 999999999, 999999999)]) [2] >>> min_time_to_move(1, [(1, 2, 1000000000, 1000000000)]) [1999999997]","solution":"def min_time_to_move(t, test_cases): results = [] for case in test_cases: x1, y1, x2, y2 = case time = abs(x2 - x1) + abs(y2 - y1) results.append(time) return results"},{"question":"from typing import List def sortBooks(book_ids: List[int]) -> List[int]: Returns the list of book identifiers sorted in ascending order. Parameters: book_ids (list): A list of integers where each integer represents the unique identifier of a book. Returns: list: A list of integers sorted in ascending order. >>> sortBooks([9, 3, 5, 1, 7]) [1, 3, 5, 7, 9] >>> sortBooks([15, 23, 4, 42, 8]) [4, 8, 15, 23, 42] >>> sortBooks([5, 3, 1]) [1, 3, 5]","solution":"def sortBooks(book_ids): Returns the list of book identifiers sorted in ascending order. Parameters: book_ids (list): A list of integers where each integer represents the unique identifier of a book. Returns: list: A list of integers sorted in ascending order. return sorted(book_ids)"},{"question":"def compress_string(s: str) -> str: Compresses the string by replacing sequences of the same character with that character followed by the count of occurrences. If the compressed string is not shorter than the original string, returns the original string. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcd\\") \\"abcd\\" >>> compress_string(\\"aaabbbcccaaa\\") \\"a3b3c3a3\\" >>> compress_string(\\"a\\") \\"a\\"","solution":"def compress_string(s): Compresses the string by replacing sequences of the same character with that character followed by the count of occurrences. If the compressed string is not shorter than the original string, returns the original string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Append the last set of characters compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def merge_and_sort(list1, list2): Merges two lists and returns a sorted version of the merged list. If either of the arguments is not a list, returns None. >>> merge_and_sort([3, 1, 4], [2, 5, 0]) [0, 1, 2, 3, 4, 5] >>> merge_and_sort([3, 1, 4], \\"string\\") None","solution":"def merge_and_sort(list1, list2): Merges two lists and returns a sorted version of the merged list. If either of the arguments is not a list, returns None. if not isinstance(list1, list) or not isinstance(list2, list): return None merged_list = list1 + list2 return sorted(merged_list)"},{"question":"def is_valid_IP(ip_str: str) -> bool: Returns True if the input string is a valid IPv4 address, else returns False. An IPv4 address should be in the format x.x.x.x where x is a number from 0 to 255 (inclusive) and there are no leading zeros. >>> is_valid_IP(\\"192.168.0.1\\") True >>> is_valid_IP(\\"255.255.255.255\\") True >>> is_valid_IP(\\"0.0.0.0\\") True >>> is_valid_IP(\\"192.168.0.256\\") False >>> is_valid_IP(\\"192.168.01.1\\") False >>> is_valid_IP(\\"192.168.1.abc\\") False >>> is_valid_IP(\\"12.34.56.78a\\") False","solution":"def is_valid_IP(ip_str): Returns True if the input string is a valid IPv4 address, else returns False. An IPv4 address should be in the format x.x.x.x where x is a number from 0 to 255 (inclusive) and there are no leading zeros. parts = ip_str.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit() or not 0 <= int(part) <= 255 or (part[0] == '0' and len(part) > 1): return False return True"},{"question":"def matrix_sum(input_data: str) -> str: Reads two matrices from the given input string and outputs their element-wise sum. >>> matrix_sum(\\"2 3n1 2 3n4 5 6n7 8 9n10 11 12\\") '8 10 12n14 16 18' >>> matrix_sum(\\"1 2n-1000 -1000n1000 1000\\") '0 0' >>> matrix_sum(\\"3 3n1 1 1n1 1 1n1 1 1n1 1 1n1 1 1n1 1 1\\") '2 2 2n2 2 2n2 2 2' >>> matrix_sum(\\"2 2n-1 -2n-3 -4n1 2n3 4\\") '0 0n0 0' >>> matrix_sum(\\"3 1n1n2n3n4n5n6\\") '5n7n9'","solution":"def read_matrix(n, m, matrix_input): Reads a matrix of size n by m from the given input list. matrix = [] for i in range(n): row = matrix_input[i].split() matrix.append([int(num) for num in row]) return matrix def sum_matrices(matrix_a, matrix_b): Returns the summation of two matrices. n, m = len(matrix_a), len(matrix_a[0]) result_matrix = [] for i in range(n): row = [] for j in range(m): row.append(matrix_a[i][j] + matrix_b[i][j]) result_matrix.append(row) return result_matrix # Input format parsing from raw input for testing purposes def parse_input(input_data): lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) matrix_a_input = lines[1:n+1] matrix_b_input = lines[n+1:] return n, m, matrix_a_input, matrix_b_input # Main processing function combining everything def matrix_sum(input_data): n, m, matrix_a_input, matrix_b_input = parse_input(input_data) matrix_a = read_matrix(n, m, matrix_a_input) matrix_b = read_matrix(n, m, matrix_b_input) result_matrix = sum_matrices(matrix_a, matrix_b) return 'n'.join(' '.join(map(str, row)) for row in result_matrix)"},{"question":"from typing import List def merge_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two lists of integers and returns them in a sorted order without using built-in sort functions. :param list1: List of integers. :param list2: List of integers. :return: A list containing all elements from list1 and list2, sorted in ascending order. pass def test_merge_lists_regular_case(): assert merge_lists([3, 1, 4], [2, 5, 6]) == [1, 2, 3, 4, 5, 6] def test_merge_lists_one_empty_list(): assert merge_lists([], [2, 5, 6]) == [2, 5, 6] assert merge_lists([1, 3, 4], []) == [1, 3, 4] def test_merge_lists_both_empty_lists(): assert merge_lists([], []) == [] def test_merge_lists_with_duplicates(): assert merge_lists([1, 3, 3], [2, 2, 5]) == [1, 2, 2, 3, 3, 5] def test_merge_lists_with_negative_numbers(): assert merge_lists([-3, -1, 4], [2, -5, 6]) == [-5, -3, -1, 2, 4, 6] def test_merge_lists_with_single_element_lists(): assert merge_lists([1], [2]) == [1, 2] assert merge_lists([5], [2]) == [2, 5]","solution":"from typing import List def merge_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two lists of integers and returns them in a sorted order without using built-in sort functions. :param list1: List of integers. :param list2: List of integers. :return: A list containing all elements from list1 and list2, sorted in ascending order. def merge_two_sorted_lists(l1, l2): result = [] i = j = 0 while i < len(l1) and j < len(l2): if l1[i] < l2[j]: result.append(l1[i]) i += 1 else: result.append(l2[j]) j += 1 # Append the rest of the elements from l1 or l2 while i < len(l1): result.append(l1[i]) i += 1 while j < len(l2): result.append(l2[j]) j += 1 return result # Sort both lists using merge sort (recursively divide and merge) def merge_sort(lst): if len(lst) <= 1: return lst mid = len(lst) // 2 left = merge_sort(lst[:mid]) right = merge_sort(lst[mid:]) return merge_two_sorted_lists(left, right) # Merge and sort list1 and list2 return merge_sort(list1 + list2)"},{"question":"from typing import List def findWords(board: List[List[str]], words: List[str]) -> List[str]: Given a 2D board and a list of words, find all the words that can be formed by sequentially adjacent letters of the board. The same letter cell may not be used more than once in a word. >>> board = [ ... ['o','a','a','n'], ... ['e','t','a','e'], ... ['i','h','k','r'], ... ['i','f','l','v'] ... ] >>> words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] >>> findWords(board, words) [\\"oath\\", \\"eat\\"] pass # Unit tests def test_find_words(): board1 = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] words1 = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] assert set(findWords(board1, words1)) == set([\\"oath\\", \\"eat\\"]) board2 = [ ['a', 'b'], ['c', 'd'] ] words2 = [\\"abcd\\"] assert findWords(board2, words2) == [] board3 = [ ['a','a'], ['a','a'] ] words3 = [\\"aaaa\\", \\"aa\\"] assert set(findWords(board3, words3)) == set([\\"aaaa\\", \\"aa\\"]) board4 = [ ['a'] ] words4 = [\\"a\\", \\"b\\"] assert findWords(board4, words4) == [\\"a\\"] def test_no_matches(): board5 = [['x','y'],['z','w']] words5 = [\\"a\\", \\"b\\", \\"c\\"] assert findWords(board5, words5) == [] def test_empty_board(): assert findWords([], [\\"a\\", \\"b\\"]) == [] def test_empty_words(): board6 = [['a','b'],['c','d']] assert findWords(board6, []) == []","solution":"from typing import List, Set class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for letter in word: if letter not in node.children: node.children[letter] = TrieNode() node = node.children[letter] node.is_word = True def findWords(board: List[List[str]], words: List[str]) -> List[str]: def backtrack(x: int, y: int, node: TrieNode, path: str): if node.is_word: result.add(path) node.is_word = False # Avoid duplicate entries if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] == '#': return temp, board[x][y] = board[x][y], '#' # Mark as visited if temp in node.children: for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: backtrack(x + dx, y + dy, node.children[temp], path + temp) board[x][y] = temp # Reset the cell after backtracking # Build Trie from words trie = Trie() for word in words: trie.insert(word) result = set() # Using set to prevent duplicates for i in range(len(board)): for j in range(len(board[0])): backtrack(i, j, trie.root, \\"\\") return list(result)"},{"question":"def restore_request_counters(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[List[int]]: Restore the request counters for each book based on the request log. >>> restore_request_counters(2, [(5, 7, [1, 2, 3, 3, 2, 1, 5]), (4, 5, [1, 1, 2, 2, 3])]) [[2, 2, 2, 0, 1], [2, 2, 1, 0]] >>> restore_request_counters(1, [(3, 0, [])]) [[0, 0, 0]] >>> restore_request_counters(1, [(4, 4, [1, 1, 1, 1])]) [[4, 0, 0, 0]] >>> restore_request_counters(3, [(3, 3, [3, 3, 3]), (2, 1, [2]), (5, 9, [1, 2, 3, 4, 5, 1, 2, 3, 4])]) [[0, 0, 3], [0, 1], [2, 2, 2, 2, 1]]","solution":"def restore_request_counters(T, test_cases): results = [] for i in range(T): N, Q, requests = test_cases[i] counters = [0] * N for request in requests: counters[request - 1] += 1 results.append(counters) return results"},{"question":"def reverseWords(s: str) -> str: Reverses the order of words in a given string s. >>> reverseWords(\\"The sky is blue\\") \\"blue is sky The\\" >>> reverseWords(\\" The sky is blue \\") \\"blue is sky The\\" >>> reverseWords(\\"hello\\") \\"hello\\" >>> reverseWords(\\"\\") \\"\\" >>> reverseWords(\\" \\") \\"\\" >>> reverseWords(\\" The sky is blue \\") \\"blue is sky The\\" >>> reverseWords(\\"Hello world this is Python\\") \\"Python is this world Hello\\"","solution":"def reverseWords(s): Reverses the order of words in a given string s. Args: s (str): Input string. Returns: str: String with the order of words reversed. # Split the string by spaces and filter out empty strings words = list(filter(lambda x: x != '', s.split(' '))) # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space return ' '.join(reversed_words)"},{"question":"def find_min_radius(n: int, heaters: List[int]) -> int: Given an integer n representing the positions of houses along a street and an array of integers heaters representing the positions of heaters along the street, find the minimum radius of a heater such that all houses can be covered by at least one heater. >>> find_min_radius(5, [2]) 3 >>> find_min_radius(5, [1, 4]) 1 >>> find_min_radius(7, [2, 4, 6]) 1 >>> find_min_radius(3, [1]) 2 from solution import find_min_radius def test_example1(): assert find_min_radius(5, [2]) == 3 def test_example2(): assert find_min_radius(5, [1, 4]) == 1 def test_example3(): assert find_min_radius(7, [2, 4, 6]) == 1 def test_example4(): assert find_min_radius(3, [1]) == 2 def test_large_input_coverage(): assert find_min_radius(100, [50]) == 50 def test_multiple_heaters(): assert find_min_radius(10, [1, 5, 10]) == 2 def test_consecutive_heaters(): assert find_min_radius(7, [1, 2, 3, 4, 5, 6, 7]) == 0","solution":"def find_min_radius(n, heaters): heaters.sort() max_radius = 0 # Coverage for houses before the first heater if heaters[0] > 1: max_radius = heaters[0] - 1 # Coverage for houses after the last heater if heaters[-1] < n: max_radius = max(max_radius, n - heaters[-1]) # Coverage for houses between heaters for i in range(1, len(heaters)): max_radius = max(max_radius, (heaters[i] - heaters[i - 1]) // 2) return max_radius"},{"question":"def convert_to_markdown(text: str) -> str: Converts a given text into markdown-styled bullet lists. Parameters: text (str): The input text with each line representing a separate item. Returns: str: The text converted into markdown-styled bullet lists with hyphens. Examples: >>> convert_to_markdown(\\"Item onenItem twonItem three\\") '- Item onen- Item twon- Item three' >>> convert_to_markdown(\\"Item onennItem threenItem four\\") '- Item onenn- Item threen- Item four' >>> convert_to_markdown(\\"First itemnSecond itemnnnFifth item\\") '- First itemn- Second itemnnn- Fifth item' >>> convert_to_markdown(\\"\\") '' >>> convert_to_markdown(\\"nn\\") 'nn'","solution":"def convert_to_markdown(text): Converts a given text into markdown-styled bullet lists. Parameters: text (str): The input text with each line representing a separate item. Returns: str: The text converted into markdown-styled bullet lists with hyphens. if text == \\"\\": return \\"\\" lines = text.split('n') result = [] for line in lines: if line.strip(): result.append(f\\"- {line}\\") else: result.append(\\"\\") return 'n'.join(result)"},{"question":"def max_subtree_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: You are given a tree with n nodes. Each node has a value associated with it. A subtree is defined as any connected component that includes a given node and all its descendants. Let's define the sum of a subtree rooted at node u as the sum of values of all nodes in that subtree. Your task is to find a node u such that the sum of the values in the subtree rooted at u is maximum. >>> max_subtree_sum(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)]) 15 >>> max_subtree_sum(3, [1, 2, 3], [(1, 2), (1, 3)]) 6","solution":"def max_subtree_sum(n, values, edges): from collections import defaultdict def dfs(node, parent): subtree_sum = values[node - 1] for neighbor in tree[node]: if neighbor != parent: subtree_sum += dfs(neighbor, node) max_sums[node] = subtree_sum return subtree_sum tree = defaultdict(list) for a, b in edges: tree[a].append(b) tree[b].append(a) max_sums = [0] * (n + 1) dfs(1, -1) return max(max_sums[1:]) # Example usage: n = 5 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] print(max_subtree_sum(n, values, edges)) # Output: 15"},{"question":"def has_pair_with_sum(arr: list, target: int) -> bool: Returns true if there are two distinct elements in the array that sum up to the target number. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([1, 2, 2, 4], 4) True >>> has_pair_with_sum([-1, -2, -3, -4], -6) True >>> has_pair_with_sum([-1, -2, -3, -4], -8) False","solution":"def has_pair_with_sum(arr: list, target: int) -> bool: Returns true if there are two distinct elements in the array that sum up to the target number. seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def maxSubarraySumWithReorder(arr: List[int], K: int) -> int: Determine the maximum sum of a subarray of length at most K where the subarray can be made by rearranging the elements within K contiguous elements. >>> maxSubarraySumWithReorder([1, 2, 3, 4, 5], 2) 9 >>> maxSubarraySumWithReorder([1, 5, 2, 6, 3], 3) 13 >>> maxSubarraySumWithReorder([4, 4, 4, 4, 4], 1) 4 >>> maxSubarraySumWithReorder([10, 9, 8, 7], 4) 34","solution":"def maxSubarraySumWithReorder(arr, K): Function to find the maximum sum of a subarray of length at most K, where the subarray can be made by rearranging elements within K contiguous elements. n = len(arr) max_sum = 0 for i in range(n - K + 1): # Extract the current subarray of length K subarray = arr[i:i+K] # Sort the subarray in descending order sorted_subarray = sorted(subarray, reverse=True) # Calculate the sum of the sorted subarray current_sum = sum(sorted_subarray) # Update max_sum if current_sum is larger max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_longest_substring_with_k_distinct_chars(s: str, k: int) -> str: Create a function that finds the longest substring of a given string \`s\` containing up to \`k\` distinct characters. If there are multiple substrings with the same length, return the one that appears first in the string \`s\`. >>> find_longest_substring_with_k_distinct_chars(\\"eceba\\", 2) \\"ece\\" >>> find_longest_substring_with_k_distinct_chars(\\"abcdef\\", 0) \\"\\" >>> find_longest_substring_with_k_distinct_chars(\\"\\", 2) \\"\\" >>> find_longest_substring_with_k_distinct_chars(\\"aaaa\\", 1) \\"aaaa\\" >>> find_longest_substring_with_k_distinct_chars(\\"araaci\\", 2) \\"araa\\" >>> find_longest_substring_with_k_distinct_chars(\\"araaci\\", 1) \\"aa\\" >>> find_longest_substring_with_k_distinct_chars(\\"araaci\\", 10) \\"araaci\\" >>> find_longest_substring_with_k_distinct_chars(\\"abcadcacacaca\\", 3) \\"cadcacacaca\\"","solution":"def find_longest_substring_with_k_distinct_chars(s: str, k: int) -> str: if k == 0 or not s: return \\"\\" n = len(s) left = 0 right = 0 max_length = 0 max_substring = \\"\\" char_frequency = {} while right < n: char_frequency[s[right]] = char_frequency.get(s[right], 0) + 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 if right - left + 1 > max_length: max_length = right - left + 1 max_substring = s[left:right + 1] right += 1 return max_substring"},{"question":"def eligible_for_bonus(attendance_rate: float, performance_score: float) -> bool: Determines if an employee is eligible for a year-end bonus based on their attendance rate and performance score. Args: attendance_rate (float): The employee's attendance rate as a percentage. performance_score (float): The employee's overall performance score as a percentage. Returns: bool: True if the employee is eligible for a bonus, False otherwise. pass # Test cases def test_eligible_for_bonus_high_attendance_and_performance(): assert eligible_for_bonus(95, 85) == True def test_eligible_for_bonus_moderate_attendance_high_performance(): assert eligible_for_bonus(80, 95) == True def test_not_eligible_for_bonus_lower_attendance_and_performance(): assert eligible_for_bonus(85, 75) == False def test_not_eligible_for_bonus_low_attendance_high_performance(): assert eligible_for_bonus(70, 100) == False def test_eligible_for_bonus_perfect_attendance_min_performance(): assert eligible_for_bonus(100, 80) == True def test_not_eligible_for_bonus_edge_case_attendance(): assert eligible_for_bonus(89.99, 80) == False def test_not_eligible_for_bonus_edge_case_performance(): assert eligible_for_bonus(90, 79.99) == False def test_eligible_for_bonus_edge_case_conditions_met(): assert eligible_for_bonus(90, 80) == True assert eligible_for_bonus(75, 90) == True def test_not_eligible_for_bonus_failing_both_criteria(): assert eligible_for_bonus(74, 89) == False","solution":"def eligible_for_bonus(attendance_rate, performance_score): Determines if an employee is eligible for a year-end bonus based on their attendance rate and performance score. Args: attendance_rate (float): The employee's attendance rate as a percentage. performance_score (float): The employee's overall performance score as a percentage. Returns: bool: True if the employee is eligible for a bonus, False otherwise. return (attendance_rate >= 90 and performance_score >= 80) or (attendance_rate >= 75 and performance_score >= 90)"},{"question":"def is_prime(num: int) -> bool: Determines if a number is a prime number. >>> is_prime(1) == False >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(9) == False # Your code here def sum_of_three_primes(n: int) -> tuple: Determines if n can be expressed as the sum of three distinct prime numbers. >>> sum_of_three_primes(20) in [(2, 3, 15), (3, 5, 12), (2, 7, 11)] >>> sum_of_three_primes(30) in [(2, 5, 23), (3, 7, 20), (5, 11, 14)] >>> sum_of_three_primes(5) == () # Your code here","solution":"def is_prime(num): Determines if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sum_of_three_primes(n): Determines if n can be expressed as the sum of three distinct prime numbers. if n < 6: # The smallest sum of three distinct primes is 6 (2 + 3 + 1, but here we're looking for distinct primes) return () primes = [num for num in range(2, n) if is_prime(num)] prime_set = set(primes) for i in range(len(primes)): for j in range(i + 1, len(primes)): for k in range(j + 1, len(primes)): if primes[i] + primes[j] + primes[k] == n: return (primes[i], primes[j], primes[k]) return ()"},{"question":"def min_cost_to_build_bridges(N: int, depths: List[int]) -> int: Determine the minimum total cost to build bridges to cover all sections with depth 0. Parameters: N (int): Number of sections in the river. depths (list of int): List of depths at each section. Returns: int: Minimum total cost to build bridges. >>> min_cost_to_build_bridges(5, [0, 1, 0, 0, 1]) 1 >>> min_cost_to_build_bridges(6, [1, 1, 0, 0, 0, 1]) 4 >>> min_cost_to_build_bridges(4, [1, 2, 3, 4]) 0 >>> min_cost_to_build_bridges(5, [0, 0, 0, 0, 0]) 16 >>> min_cost_to_build_bridges(5, [0, 1, 0, 1, 0]) 0","solution":"def min_cost_to_build_bridges(N, depths): Determine the minimum total cost to build bridges to cover all sections with depth 0. Parameters: N (int): Number of sections in the river. depths (list of int): List of depths at each section. Returns: int: Minimum total cost to build bridges. min_cost = 0 i = 0 while i < N: if depths[i] == 0: start = i while i < N and depths[i] == 0: i += 1 length = i - start - 1 min_cost += length ** 2 else: i += 1 return min_cost"},{"question":"def longest_contiguous_subarray(arr): Returns the length of the longest contiguous subarray with all elements equal. Parameters: arr (List[int]): A list of integers. Returns: int: The length of the longest contiguous subarray where all elements are equal. Examples: >>> longest_contiguous_subarray([1, 1, 2, 3, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1]) 6 >>> longest_contiguous_subarray([1, 2, 2, 2, 3, 3, 3, 3, 3, 2, 1, 1]) 5 >>> longest_contiguous_subarray([5, 5, 5, 5, 5]) 5 >>> longest_contiguous_subarray([1, 2, 3, 4]) 1 >>> longest_contiguous_subarray([]) 0","solution":"def longest_contiguous_subarray(arr): Returns the length of the longest contiguous subarray with all elements equal. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def max_songs(durations: List[int], t: int) -> int: Returns the maximum number of songs that can be included in the setlist without exceeding the total duration t. >>> max_songs([4, 3, 2, 5], 10) 3 >>> max_songs([1, 2, 3, 4], 5) 2 pass def test_examples(): assert max_songs([4, 3, 2, 5], 10) == 3 assert max_songs([1, 2, 3, 4], 5) == 2 def test_edge_cases(): assert max_songs([100], 100) == 1 assert max_songs([100], 99) == 0 assert max_songs([1, 1, 1, 1], 4) == 4 assert max_songs([50, 50, 50], 100) == 2 def test_no_songs(): assert max_songs([], 10) == 0 def test_all_songs_same_duration(): assert max_songs([2, 2, 2, 2, 2, 2], 10) == 5 assert max_songs([3, 3, 3], 6) == 2 def test_same_duration_as_time(): assert max_songs([3, 3, 3], 3) == 1 assert max_songs([5, 5, 5], 5) == 1","solution":"def max_songs(durations, t): Returns the maximum number of songs that can be included in the setlist without exceeding the total duration t. durations.sort() total_duration = 0 song_count = 0 for duration in durations: if total_duration + duration <= t: total_duration += duration song_count += 1 else: break return song_count"},{"question":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Given a grid represented as an \`m x n\` matrix filled with non-negative integers, find the minimum sum of a path from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 3], [4, 5, 6]]) 12 >>> minPathSum([[1, 2], [1, 1]]) 3 >>> minPathSum([[5]]) 5 >>> minPathSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 def test_minPathSum(): grid1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert minPathSum(grid1) == 7 grid2 = [ [1, 2, 3], [4, 5, 6] ] assert minPathSum(grid2) == 12 grid3 = [ [1, 2], [1, 1] ] assert minPathSum(grid3) == 3 grid4 = [ [5] ] assert minPathSum(grid4) == 5 grid5 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert minPathSum(grid5) == 21","solution":"from typing import List def minPathSum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) for i in range(1, m): grid[i][0] += grid[i-1][0] for j in range(1, n): grid[0][j] += grid[0][j-1] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"def power_restoration(n, edges, initial_powered): Restore power to as many regions as possible using the given power lines. >>> power_restoration(6, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]], [0, 2]) 6 >>> power_restoration(6, [[0, 1], [1, 2], [3, 4], [4, 5]], [0, 3]) 6 >>> power_restoration(6, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]], []) 0 >>> power_restoration(1, [], [0]) 1 >>> power_restoration(7, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 5], [4, 5], [5, 6]], [2]) 7","solution":"def power_restoration(n, edges, initial_powered): from collections import deque, defaultdict # Create adjacency list for the undirected graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Use a deque for BFS queue = deque(initial_powered) # Track visited nodes (i.e., powered regions) visited = set(initial_powered) # Perform BFS while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return len(visited)"},{"question":"def trailing_zeroes(n: int) -> int: Returns the number of trailing zeros in the factorial of a given number n. >>> trailing_zeroes(5) 1 >>> trailing_zeroes(10) 2","solution":"def trailing_zeroes(n): Returns the number of trailing zeros in the factorial of n. count = 0 while n >= 5: n //= 5 count += n return count"},{"question":"def update_inventory(products: List[Dict[str, any]], updates: List[Dict[str, any]]) -> List[Dict[str, any]]: Update the inventory of products based on the provided updates. Each product and update is represented as a dictionary. If an update product ID matches an existing product ID, update the existing product's quantity and price with the values from the update. If the product ID does not exist in the list of products, add the new product to the list. If the quantity or price in the update is negative or zero, the update should be ignored. Args: products (List[Dict[str, any]]): A list of product dictionaries to be updated. updates (List[Dict[str, any]]): A list of update dictionaries. Returns: List[Dict[str, any]]: The updated list of product dictionaries. Example: >>> products = [ ... {\\"id\\": 1, \\"name\\": \\"Laptop\\", \\"quantity\\": 10, \\"price\\": 999.99}, ... {\\"id\\": 2, \\"name\\": \\"Mouse\\", \\"quantity\\": 50, \\"price\\": 19.99} ... ] >>> updates = [ ... {\\"id\\": 2, \\"name\\": \\"Mouse\\", \\"quantity\\": 60, \\"price\\": 18.99}, ... {\\"id\\": 3, \\"name\\": \\"Keyboard\\", \\"quantity\\": 100, \\"price\\": 49.99}, ... {\\"id\\": 1, \\"name\\": \\"Laptop\\", \\"quantity\\": 0, \\"price\\": 999.99} ... ] >>> update_inventory(products, updates) [ {\\"id\\": 1, \\"name\\": \\"Laptop\\", \\"quantity\\": 10, \\"price\\": 999.99}, {\\"id\\": 2, \\"name\\": \\"Mouse\\", \\"quantity\\": 60, \\"price\\": 18.99}, {\\"id\\": 3, \\"name\\": \\"Keyboard\\", \\"quantity\\": 100, \\"price\\": 49.99} ]","solution":"def update_inventory(products, updates): # Create a dictionary of product ID to product for quick lookup product_dict = {product['id']: product for product in products} for update in updates: product_id = update['id'] quantity = update['quantity'] price = update['price'] if product_id in product_dict: # Update existing product if the update is valid if quantity > 0 and price > 0: product_dict[product_id]['quantity'] = quantity product_dict[product_id]['price'] = price else: # Add new product if the update is valid if quantity > 0 and price > 0: product_dict[product_id] = update # Convert dictionary back to list return list(product_dict.values())"},{"question":"from typing import List def sum_with_neighbors(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list where each element is the sum of its neighbors and itself. For elements at the edges of the list, consider only the available neighbors. >>> sum_with_neighbors([1, 2, 3, 4, 5]) [3, 6, 9, 12, 9] >>> sum_with_neighbors([10]) [10] >>> sum_with_neighbors([10, 20]) [30, 30] >>> sum_with_neighbors([1, 2, 3]) [3, 6, 5] >>> sum_with_neighbors([]) [] >>> sum_with_neighbors([-1, 0, 1]) [-1, 0, 1] >>> sum_with_neighbors([10, -10, 10, -10, 10]) [0, 10, -10, 10, 0] >>> sum_with_neighbors([1000, 2000, 3000]) [3000, 6000, 5000]","solution":"def sum_with_neighbors(lst): Takes a list of integers and returns a new list where each element is the sum of its neighbors and itself. For elements at the edges of the list, consider only the available neighbors. if not lst: return [] n = len(lst) if n == 1: return lst result = [] for i in range(n): if i == 0: result.append(lst[i] + lst[i + 1]) elif i == n - 1: result.append(lst[i] + lst[i - 1]) else: result.append(lst[i - 1] + lst[i] + lst[i + 1]) return result"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Given a string s, determines if it can be rearranged to form a palindrome. :param s: Input string containing lowercase letters :type s: str :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\" :rtype: str pass # Your implementation here def test_sample_input_1(): assert can_form_palindrome(\\"civic\\") == \\"YES\\" def test_sample_input_2(): assert can_form_palindrome(\\"ivicc\\") == \\"YES\\" def test_sample_input_3(): assert can_form_palindrome(\\"hello\\") == \\"NO\\" def test_single_character_string(): assert can_form_palindrome(\\"a\\") == \\"YES\\" def test_even_length_palindrome(): assert can_form_palindrome(\\"aabb\\") == \\"YES\\" def test_odd_length_non_palindrome(): assert can_form_palindrome(\\"abc\\") == \\"NO\\" def test_mixed_characters(): assert can_form_palindrome(\\"aabbccdd\\") == \\"YES\\" def test_no_repeating_characters(): assert can_form_palindrome(\\"abcdefg\\") == \\"NO\\"","solution":"from collections import Counter def can_form_palindrome(s): Given a string s, determines if it can be rearranged to form a palindrome. :param s: Input string containing lowercase letters :type s: str :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\" :rtype: str # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with an odd frequency if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of merged intervals. Args: intervals (list of tuple): A list where each element is a tuple (start, end) describing an interval. Returns: list of tuple: A list of merged intervals sorted by the start value. Examples: >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_intervals([(1, 10), (2, 6), (8, 10), (15, 18)]) [(1, 10), (15, 18)]","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of merged intervals. Args: intervals (list of tuple): A list where each element is a tuple (start, end) describing an interval. Returns: list of tuple: A list of merged intervals sorted by the start value. if not intervals: return [] # Sort intervals by their start value intervals.sort(key=lambda x: x[0]) merged = [] start, end = intervals[0] for i in range(1, len(intervals)): current_start, current_end = intervals[i] if current_start <= end: # There is an overlap, so we merge the intervals end = max(end, current_end) else: # No overlap, so we add the previously merged interval and start a new one merged.append((start, end)) start, end = current_start, current_end # Add the last merged interval merged.append((start, end)) return merged"},{"question":"def calculate_weekly_wage(T: int, hours_rates: List[Tuple[int, int]]) -> List[int]: Calculate the weekly wage for each employee based on their worked hours and hourly rate. Parameters: T (int): Number of employees hours_rates (list of tuples): Each tuple contains two integers: hours worked (H) and hourly rate (R) for each employee Returns: list of int: Weekly wages for each employee >>> calculate_weekly_wage(4, [(35, 20), (40, 15), (45, 30), (50, 25)]) [700, 600, 1425, 1375] >>> calculate_weekly_wage(1, [(0, 500)]) [0] >>> calculate_weekly_wage(1, [(168, 1000)]) [220000] >>> calculate_weekly_wage(3, [(30, 10), (40, 20), (50, 30)]) [300, 800, 1650]","solution":"def calculate_weekly_wage(T, hours_rates): Calculate the weekly wage for each employee based on their worked hours and hourly rate. Parameters: T (int): Number of employees hours_rates (list of tuples): Each tuple contains two integers: hours worked (H) and hourly rate (R) for each employee Returns: list of int: Weekly wages for each employee wages = [] for H, R in hours_rates: if H <= 40: wage = H * R else: wage = 40 * R + (H - 40) * 1.5 * R wages.append(wage) return wages"},{"question":"def sliding_window_sum(n: int, k: int, expenses: List[int]) -> List[int]: Returns the list of sums of expenses for every window of size k. Parameters: n (int): number of days k (int): window size expenses (list of int): list of daily expenses Returns: list of int: sums of each window of size k Examples: >>> sliding_window_sum(7, 3, [100, 200, 300, 400, 500, 600, 700]) [600, 900, 1200, 1500, 1800] >>> sliding_window_sum(5, 1, [10, 20, 30, 40, 50]) [10, 20, 30, 40, 50]","solution":"def sliding_window_sum(n, k, expenses): Returns the list of sums of expenses for every window of size k. Parameters: n (int): number of days k (int): window size expenses (list of int): list of daily expenses Returns: list of int: sums of each window of size k if k > n: return [] window_sums = [] current_sum = sum(expenses[:k]) window_sums.append(current_sum) for i in range(n - k): current_sum = current_sum - expenses[i] + expenses[i + k] window_sums.append(current_sum) return window_sums"},{"question":"def roman_to_integer(s: str) -> int: Convert a Roman numeral to an integer. >>> roman_to_integer(\\"III\\") == 3 >>> roman_to_integer(\\"IV\\") == 4 >>> roman_to_integer(\\"IX\\") == 9 >>> roman_to_integer(\\"LVIII\\") == 58 >>> roman_to_integer(\\"MCMXCIV\\") == 1994","solution":"def roman_to_integer(s): Convert a Roman numeral to an integer. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_values[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"def is_sum_greater(x: List[int], y: List[int]) -> bool: Calculate the sum of all integers in each list x and y. Return a boolean indicating whether the sum of the integers in x is greater than the sum of the integers in y. >>> is_sum_greater([1, 2, 3], [3, 3, 1]) == False >>> is_sum_greater([5, 5, 5], [1, 1, 1]) == True >>> is_sum_greater([1, 1, 1], [5, 5, 5]) == False >>> is_sum_greater([2, 2, 2], [3, 3, 0]) == False >>> is_sum_greater([7, 8, 9], [10, 10, 0]) == True","solution":"def is_sum_greater(x, y): Returns True if the sum of the integers in list x is greater than the sum of integers in list y, False otherwise. return sum(x) > sum(y)"},{"question":"def daily_calories(activity_level: str, age: int, gender: str, weight: int) -> int: Calculate the daily caloric intake for a person based on their activity level, age, gender, and weight. >>> daily_calories(\\"sedentary\\", 25, \\"male\\", 70) # 2100 >>> daily_calories(\\"moderately active\\", 45, \\"female\\", 60) # 1980 >>> daily_calories(\\"very active\\", 75, \\"male\\", 80) # 3200 >>> daily_calories(\\"lightly active\\", 65, \\"female\\", 55) # 1375","solution":"def daily_calories(activity_level, age, gender, weight): if gender == \\"male\\": if age < 30: if activity_level == \\"sedentary\\": return weight * 30 elif activity_level == \\"lightly active\\": return weight * 35 elif activity_level == \\"moderately active\\": return weight * 40 elif activity_level == \\"very active\\": return weight * 45 elif 30 <= age <= 60: if activity_level == \\"sedentary\\": return weight * 28 elif activity_level == \\"lightly active\\": return weight * 33 elif activity_level == \\"moderately active\\": return weight * 38 elif activity_level == \\"very active\\": return weight * 43 else: # age > 60 if activity_level == \\"sedentary\\": return weight * 25 elif activity_level == \\"lightly active\\": return weight * 30 elif activity_level == \\"moderately active\\": return weight * 35 elif activity_level == \\"very active\\": return weight * 40 else: # gender == \\"female\\" if age < 30: if activity_level == \\"sedentary\\": return weight * 25 elif activity_level == \\"lightly active\\": return weight * 30 elif activity_level == \\"moderately active\\": return weight * 35 elif activity_level == \\"very active\\": return weight * 40 elif 30 <= age <= 60: if activity_level == \\"sedentary\\": return weight * 23 elif activity_level == \\"lightly active\\": return weight * 28 elif activity_level == \\"moderately active\\": return weight * 33 elif activity_level == \\"very active\\": return weight * 38 else: # age > 60 if activity_level == \\"sedentary\\": return weight * 20 elif activity_level == \\"lightly active\\": return weight * 25 elif activity_level == \\"moderately active\\": return weight * 30 elif activity_level == \\"very active\\": return weight * 35"},{"question":"def trap(height: List[int]) -> int: Compute the amount of water it is able to trap after raining. :param height: List[int] - List of non-negative integers representing the elevation map :return: int - Total amount of trapped water >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,3]) 1","solution":"def trap(height): Calculate the amount of trapped water given the heights of bars. :param height: List[int] - List of non-negative integers :return: int - Total amount of trapped water if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate total trapped water for i in range(n): water += min(left_max[i], right_max[i]) - height[i] return water"},{"question":"def move(instructions: str) -> tuple: Takes an input string describing moves in a grid and returns the final coordinates. Parameters: instructions (str): A string of instructions in the format \\"direction X\\". Returns: tuple: Final coordinates after making the moves. Examples: >>> move(\\"up 5, down 3, left 2, right 4\\") (2, 2) >>> move(\\"up 1, down 1, left 1, right 1\\") (0, 0) >>> move(\\"right 3, right 1, up 2\\") (4, 2) >>> move(\\"down 3, up 3, left 2\\") (-2, 0)","solution":"def move(instructions): Takes an input string describing moves in a grid and returns the final coordinates. Parameters: instructions (str): A string of instructions in the format \\"direction X\\". Returns: tuple: Final coordinates after making the moves. x, y = 0, 0 moves = instructions.split(', ') for move in moves: direction, steps = move.split() steps = int(steps) if direction == \\"up\\": y += steps elif direction == \\"down\\": y -= steps elif direction == \\"left\\": x -= steps elif direction == \\"right\\": x += steps return (x, y)"},{"question":"class TimeMap: Design a class TimeMap that supports two functions, set(key, value, timestamp) and get(key, timestamp). - set(key, value, timestamp) stores the key and value, along with the given timestamp. - get(key, timestamp) retrieves the value associated with the key at the highest timestamp that is less than or equal to the given timestamp. If there are no values, it returns an empty string (\\"\\"). Examples: t = TimeMap() t.set(\\"foo\\", \\"bar\\", 1) # stores the key \\"foo\\" and value \\"bar\\" along with timestamp = 1 assert t.get(\\"foo\\", 1) == \\"bar\\" # returns \\"bar\\" assert t.get(\\"foo\\", 3) == \\"bar\\" # returns \\"bar\\", since the timestamp 1 is the highest timestamp that is <= 3 t.set(\\"foo\\", \\"bar2\\", 4) assert t.get(\\"foo\\", 4) == \\"bar2\\" # returns \\"bar2\\" assert t.get(\\"foo\\", 5) == \\"bar2\\" # returns \\"bar2\\" def __init__(self): pass def set(self, key: str, value: str, timestamp: int) -> None: pass def get(self, key: str, timestamp: int) -> str: pass def test_timemap_set_and_get(): t = TimeMap() t.set(\\"foo\\", \\"bar\\", 1) assert t.get(\\"foo\\", 1) == \\"bar\\" assert t.get(\\"foo\\", 3) == \\"bar\\" t.set(\\"foo\\", \\"bar2\\", 4) assert t.get(\\"foo\\", 4) == \\"bar2\\" assert t.get(\\"foo\\", 5) == \\"bar2\\" def test_timemap_non_existing_key(): t = TimeMap() assert t.get(\\"nonexistent\\", 1) == \\"\\" def test_timemap_no_values(): t = TimeMap() t.set(\\"foo\\", \\"bar\\", 1) t.set(\\"foo\\", \\"bar2\\", 4) assert t.get(\\"foo\\", 0) == \\"\\" def test_timemap_multiple_entries(): t = TimeMap() t.set(\\"key\\", \\"value1\\", 5) t.set(\\"key\\", \\"value2\\", 10) t.set(\\"key\\", \\"value3\\", 15) assert t.get(\\"key\\", 5) == \\"value1\\" assert t.get(\\"key\\", 8) == \\"value1\\" assert t.get(\\"key\\", 10) == \\"value2\\" assert t.get(\\"key\\", 12) == \\"value2\\" assert t.get(\\"key\\", 15) == \\"value3\\"","solution":"import collections class TimeMap: def __init__(self): self.store = collections.defaultdict(list) def set(self, key, value, timestamp): Stores the key and value along with the given timestamp :param key: str :param value: str :param timestamp: int :return: None self.store[key].append((timestamp, value)) def get(self, key, timestamp): Retrieves the value associated with the key at the highest timestamp that is less than or equal to the given timestamp. If there are no values, it returns an empty string. :param key: str :param timestamp: int :return: str if key not in self.store: return \\"\\" values = self.store[key] low, high = 0, len(values) - 1 while low <= high: mid = (low + high) // 2 if values[mid][0] <= timestamp: low = mid + 1 else: high = mid - 1 return values[high][1] if high >= 0 else \\"\\""},{"question":"def evaluateExpression(expression: str) -> int: Evaluates a mathematical expression with single-digit integers and addition or subtraction operators. >>> evaluateExpression(\\"3+5\\") == 8 >>> evaluateExpression(\\"5-3\\") == 2 >>> evaluateExpression(\\"3+5-2+8\\") == 14 >>> evaluateExpression(\\"9-1-1-1\\") == 6 >>> evaluateExpression(\\"1+2+3+4\\") == 10 >>> evaluateExpression(\\"-1+2+3\\") == 4","solution":"def evaluateExpression(expression): Evaluates a mathematical expression with single-digit integers and addition or subtraction operators. total = 0 current_num = 0 sign = 1 for char in expression: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '+': total += current_num * sign current_num = 0 sign = 1 elif char == '-': total += current_num * sign current_num = 0 sign = -1 total += current_num * sign return total"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Finds the maximum profit that can be achieved from buying and selling a single stock. :param prices: List of stock prices over several days. :return: The maximum profit that can be achieved. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 def test_max_profit_sample_cases(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_no_prices(): assert max_profit([]) == 0 def test_max_profit_only_increasing_prices(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_max_profit_single_price(): assert max_profit([5]) == 0 def test_max_profit_fluctuating_prices(): assert max_profit([7, 1, 5, 3, 6, 4, 8, 2, 10]) == 9 def test_max_profit_large_decrease_then_increase(): assert max_profit([100, 180, 260, 310, 40, 535, 695]) == 655","solution":"from typing import List def max_profit(prices: List[int]) -> int: Finds the maximum profit that can be achieved from buying and selling a single stock. :param prices: List of stock prices over several days. :return: The maximum profit that can be achieved. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: # Update the minimum price we've seen so far if price < min_price: min_price = price # Calculate the potential profit with the current price potential_profit = price - min_price # Update the maximum profit if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"def pattern_count(text: str, pattern: str) -> int: Returns the number of times the pattern appears in text, including overlapping patterns. >>> pattern_count(\\"ababa\\", \\"aba\\") 2 >>> pattern_count(\\"aaaa\\", \\"aa\\") 3 >>> pattern_count(\\"abc\\", \\"d\\") 0","solution":"def pattern_count(text: str, pattern: str) -> int: Returns the number of times the pattern appears in text, including overlapping patterns. count = 0 pat_len = len(pattern) for i in range(len(text) - pat_len + 1): if text[i:i + pat_len] == pattern: count += 1 return count"},{"question":"def custom_fibonacci(a: int, b: int, n: int) -> list: Generate the first n numbers in a custom Fibonacci sequence starting with a and b. >>> custom_fibonacci(1, 2, 5) == [1, 2, 3, 5, 8] >>> custom_fibonacci(0, 1, 6) == [0, 1, 1, 2, 3, 5] >>> custom_fibonacci(-1, -1, 5) == [-1, -1, -2, -3, -5] >>> custom_fibonacci(2, -3, 5) == [2, -3, -1, -4, -5] >>> custom_fibonacci(5, 3, 2) == [5, 3] >>> custom_fibonacci(1, 1, 10) == [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> custom_fibonacci(3, 2, 7) == [3, 2, 5, 7, 12, 19, 31] def test_custom_fibonacci(): assert custom_fibonacci(1, 2, 5) == [1, 2, 3, 5, 8] assert custom_fibonacci(0, 1, 6) == [0, 1, 1, 2, 3, 5] assert custom_fibonacci(-1, -1, 5) == [-1, -1, -2, -3, -5] assert custom_fibonacci(2, -3, 5) == [2, -3, -1, -4, -5] assert custom_fibonacci(5, 3, 2) == [5, 3] assert custom_fibonacci(1, 1, 10) == [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] assert custom_fibonacci(3, 2, 7) == [3, 2, 5, 7, 12, 19, 31]","solution":"def custom_fibonacci(a, b, n): Generate the first n numbers in a custom Fibonacci sequence starting with a and b. Parameters: a (int): The first number in the sequence. b (int): The second number in the sequence. n (int): The number of elements to generate in the sequence. Returns: list: The first n numbers in the custom Fibonacci sequence. if n == 1: return [a] elif n == 2: return [a, b] fib_sequence = [a, b] for _ in range(2, n): next_number = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_number) return fib_sequence"},{"question":"def can_transform(a: str, b: str) -> str: Determines if the identification codes can be transformed into one another using any allowed sequence of operations. >>> can_transform(\\"abc\\", \\"bca\\") 'YES' >>> can_transform(\\"xyz\\", \\"yxz\\") 'YES' >>> can_transform(\\"abc\\", \\"def\\") 'NO' pass def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes the test cases for transformation checks. >>> process_test_cases(3, [\\"abc\\", \\"bca\\", \\"abcd\\", \\"abdc\\", \\"xyz\\", \\"yxz\\"]) ['YES', 'YES', 'YES'] >>> process_test_cases(2, [\\"abc\\", \\"def\\", \\"aabbcc\\", \\"ccbbaa\\"]) ['NO', 'YES'] pass # Unit tests def test_can_transform(): assert can_transform(\\"abc\\", \\"bca\\") == \\"YES\\" assert can_transform(\\"abcd\\", \\"abdc\\") == \\"YES\\" assert can_transform(\\"xyz\\", \\"yxz\\") == \\"YES\\" assert can_transform(\\"abc\\", \\"def\\") == \\"NO\\" assert can_transform(\\"aabbcc\\", \\"ccbbaa\\") == \\"YES\\" assert can_transform(\\"a\\", \\"b\\") == \\"NO\\" assert can_transform(\\"z\\", \\"z\\") == \\"YES\\" def test_process_test_cases(): t = 3 test_cases = [ \\"abc\\", \\"bca\\", \\"abcd\\", \\"abdc\\", \\"xyz\\", \\"yxz\\" ] expected_output = [\\"YES\\", \\"YES\\", \\"YES\\"] assert process_test_cases(t, test_cases) == expected_output t = 2 test_cases = [ \\"abc\\", \\"def\\", \\"aabbcc\\", \\"ccbbaa\\", ] expected_output = [\\"NO\\", \\"YES\\"] assert process_test_cases(t, test_cases) == expected_output","solution":"def can_transform(a, b): Determines if string a can be transformed into string b using the allowed operations. # Transformation is possible if both strings have the same sorted characters return \\"YES\\" if sorted(a) == sorted(b) else \\"NO\\" def process_test_cases(t, test_cases): Processes test cases and returns transformation results. results = [] for i in range(0, 2 * t, 2): a = test_cases[i] b = test_cases[i + 1] result = can_transform(a, b) results.append(result) return results"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False","solution":"def are_anagrams(s1, s2): Determines if two strings are anagrams of each other. Args: s1 (str): First string to be compared. s2 (str): Second string to be compared. Returns: bool: True if both strings are anagrams, False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"def combine_dicts(dict1, dict2): Combines two dictionaries into a new dictionary. If a key is present in both dictionaries, the value in the new dictionary is the sum of the values from the input dictionaries. Examples: >>> dict1 = {'a': 1, 'b': 2, 'c': 3} >>> dict2 = {'b': 3, 'c': 4, 'd': 5} >>> combine_dicts(dict1, dict2) {'a': 1, 'b': 5, 'c': 7, 'd': 5} >>> dict1 = {'a': 1, 'b': 2} >>> dict2 = {} >>> combine_dicts(dict1, dict2) {'a': 1, 'b': 2} >>> dict1 = {'a': 1, 'b': 2} >>> dict2 = {'c': 3, 'd': 4} >>> combine_dicts(dict1, dict2) {'a': 1, 'b': 2, 'c': 3, 'd': 4}","solution":"def combine_dicts(dict1, dict2): Combines two dictionaries into a new dictionary. If a key is present in both dictionaries, the value in the new dictionary is the sum of the values from the input dictionaries. combined_dict = dict(dict1) # Make a copy of the first dictionary for key, value in dict2.items(): if key in combined_dict: combined_dict[key] += value # Sum the values if the key exists in both dictionaries else: combined_dict[key] = value # Add the key-value pair if it doesn't exist in the first dictionary return combined_dict"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_unival_tree(root: TreeNode) -> bool: Given the root of a binary tree, returns true if and only if all the binary tree nodes have the same value. >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> is_unival_tree(root) True >>> root = TreeNode(2) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(2) >>> is_unival_tree(root) False >>> root = TreeNode(1) >>> is_unival_tree(root) True >>> root = None >>> is_unival_tree(root) True >>> root = TreeNode(4) >>> root.left = TreeNode(4) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(4) >>> root.left.right = TreeNode(5) # Different value here >>> is_unival_tree(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_unival_tree(root: TreeNode) -> bool: def dfs(node, value): if not node: return True if node.val != value: return False return dfs(node.left, value) and dfs(node.right, value) if not root: return True return dfs(root, root.val)"},{"question":"def max_rings_visited(N: int, heights: List[int], D: int) -> int: Determine the maximum number of rings a participant can visit starting from the first ring. >>> max_rings_visited(4, [1, 2, 3, 4], 1) 4 >>> max_rings_visited(5, [1, 10, 15, 12, 20], 5) 3 def tower_of_rings(T: int, cases: List[Tuple[int, List[int], int]]) -> List[int]: For each test case, determine the maximum number of rings that can be visited. >>> T = 2 >>> cases = [ ... (4, [1, 2, 3, 4], 1), ... (5, [1, 10, 15, 12, 20], 5) ... ] >>> tower_of_rings(T, cases) [4, 3] results = [] for i in range(T): N, heights, D = cases[i] result = max_rings_visited(N, heights, D) results.append(result) return results","solution":"def max_rings_visited(N, heights, D): dp = [1] * N for i in range(1, N): for j in range(i): if heights[j] < heights[i] and heights[i] - heights[j] <= D: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def tower_of_rings(T, cases): results = [] for i in range(T): N = cases[i][0] heights = cases[i][1] D = cases[i][2] result = max_rings_visited(N, heights, D) results.append(result) return results"},{"question":"def extend_list_to_length(target_length: int, initial_list: List[int]) -> List[int]: Extends the given list by repeatedly appending the last element until it reaches the target length. Args: target_length (int): The target length of the list. initial_list (List[int]): The initial list of integers. Returns: List[int]: The extended list. Examples: >>> extend_list_to_length(7, [1, 2, 3]) [1, 2, 3, 3, 3, 3, 3] >>> extend_list_to_length(3, [1, 2, 3]) [1, 2, 3] >>> extend_list_to_length(4, [0, 1, 2]) [0, 1, 2, 2] >>> extend_list_to_length(5, [1]) [1, 1, 1, 1, 1] >>> extend_list_to_length(100, [1, 2, 3]) [1, 2, 3] + [3] * 97","solution":"def extend_list_to_length(target_length, initial_list): Extends the given list by repeatedly appending the last element until it reaches the target length. while len(initial_list) < target_length: initial_list.append(initial_list[-1]) return initial_list"},{"question":"from typing import List def is_balanced_string(S: str) -> bool: Returns whether the string S is balanced or not. >>> is_balanced_string(\\"aabbcc\\") True >>> is_balanced_string(\\"abcabcabc\\") True >>> is_balanced_string(\\"aabbccdde\\") False >>> is_balanced_string(\\"abcd\\") True pass def check_balanced_strings(T: int, strings: List[str]) -> List[str]: Returns a list indicating whether each string in strings is balanced. >>> check_balanced_strings(4, [\\"aabbcc\\", \\"abcabcabc\\", \\"aabbccdde\\", \\"abcd\\"]) ['YES', 'YES', 'NO', 'YES'] >>> check_balanced_strings(4, [\\"aaaa\\", \\"aaaabbbb\\", \\"abcabcabc\\", \\"abcdabcd\\"]) ['YES', 'YES', 'YES', 'YES'] >>> check_balanced_strings(4, [\\"a\\", \\"bb\\", \\"ccc\\", \\"ddddee\\"]) ['YES', 'YES', 'YES', 'NO'] >>> check_balanced_strings(1, [\\"xxxyyyzzz\\"]) ['YES'] >>> check_balanced_strings(2, [\\"aabb\\", \\"abcdef\\"]) ['YES', 'YES'] pass","solution":"def is_balanced_string(S): Returns whether the string S is balanced or not. from collections import Counter # Count frequency of each character freq = Counter(S) # Get all the frequency values values = list(freq.values()) # Check if all frequency values are the same return all(v == values[0] for v in values) def check_balanced_strings(T, strings): Returns a list indicating whether each string in strings is balanced. results = [] for S in strings: if is_balanced_string(S): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # The input-output for function can be handled as needed in an external part, here we just focus on logic # For example: # input_strings = [\\"aabbcc\\", \\"abcabcabc\\", \\"aabbccdde\\", \\"abcd\\"] # check_balanced_strings(4, input_strings)"},{"question":"from typing import List def count_palindromic_subarrays(arr: List[int]) -> int: Given a list of integers, count the number of subarrays (contiguous elements) that form a palindrome. A palindrome is a sequence that reads the same backward as forward. >>> count_palindromic_subarrays([1, 2, 3, 2, 1]) 7 >>> count_palindromic_subarrays([1, 1, 1]) 6 >>> count_palindromic_subarrays([1, 2, 3]) 3 def test_single_element_lists(): assert count_palindromic_subarrays([1]) == 1 assert count_palindromic_subarrays([2]) == 1 def test_two_element_lists(): assert count_palindromic_subarrays([1, 2]) == 2 assert count_palindromic_subarrays([1, 1]) == 3 def test_multiple_element_lists(): assert count_palindromic_subarrays([1, 2, 3, 2, 1]) == 7 assert count_palindromic_subarrays([1, 2, 1, 2, 1]) == 9 assert count_palindromic_subarrays([1, 1, 1]) == 6 def test_non_palindromic_list(): assert count_palindromic_subarrays([1, 2, 3]) == 3 def test_mixed_numbers(): assert count_palindromic_subarrays([3, 4, 4, 3, 5]) == 7 def test_empty_list(): assert count_palindromic_subarrays([]) == 0 def test_large_numbers(): assert count_palindromic_subarrays([10**5] * 3) == 6","solution":"def is_palindrome(subarray): Helper function to check if a subarray is a palindrome. return subarray == subarray[::-1] def count_palindromic_subarrays(arr): Returns the count of palindromic subarrays in the given list. count = 0 n = len(arr) for start in range(n): for end in range(start, n): if is_palindrome(arr[start:end+1]): count += 1 return count"},{"question":"from typing import List from collections import Counter import heapq def reorganize_string(s: str) -> str: Reorganize the input string such that no two adjacent characters are the same. If it is not possible, return the string \\"IMPOSSIBLE\\". >>> reorganize_string(\\"aab\\") \\"aba\\" >>> reorganize_string(\\"aaab\\") \\"IMPOSSIBLE\\" pass def solve_puzzles(T: int, test_cases: List[str]) -> List[str]: Solve the string rearrangement puzzle for multiple test cases. Args: T (int): The number of test cases. test_cases (List[str]): List of strings for each test case. Returns: List[str]: List of results with either a valid rearranged string or \\"IMPOSSIBLE\\" for each test case. >>> solve_puzzles(3, [\\"aab\\", \\"aaab\\", \\"geeksforgeeks\\"]) [\\"aba\\", \\"IMPOSSIBLE\\", \\"gksrfoegskeeg\\"] pass","solution":"from collections import Counter import heapq def reorganize_string(s): counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged = ''.join(result) if len(rearranged) != len(s): return \\"IMPOSSIBLE\\" return rearranged def solve_puzzles(T, test_cases): results = [] for s in test_cases: results.append(reorganize_string(s)) return results"},{"question":"from typing import List def max_travel_time(travelTime: List[int], maxStay: List[int]) -> int: Calculate the maximum time the traveler can spend in total on their journey. :param travelTime: List of travel times between locations. :param maxStay: List of maximum stay times at each location. :return: The maximum time spent on the journey, including travel and stay times, or -1 if it's impossible. >>> max_travel_time([5, 10, 15], [20, 25, 30]) 105 >>> max_travel_time([1], [10]) 11 >>> max_travel_time([5, 5, 5], [1, 1, 1]) -1 >>> max_travel_time([4, 4, 4], [4, 4, 4]) 24 >>> max_travel_time([10000], [10000]) 20000","solution":"def max_travel_time(travelTime, maxStay): Calculate the maximum time the traveler can spend in total on their journey. :param travelTime: List of travel times between locations. :param maxStay: List of maximum stay times at each location. :return: The maximum time spent on the journey, including travel and stay times, or -1 if it's impossible. total_travel_time = sum(travelTime) total_stay_time = sum(maxStay) # Since the traveler needs to return to the starting point, the full journey includes all travel times twice. # The total available time must be less than the sum of all max stays and total travel times. if total_travel_time > total_stay_time: return -1 return total_travel_time + total_stay_time"},{"question":"def increment_by_position(lst): Takes a list of integers and returns a new list with each element incremented by its position. Parameters: lst (list): A list of integers Returns: list: a new list where each element is incremented by its position in the list Examples: >>> increment_by_position([10, 20, 30]) [10, 21, 32] >>> increment_by_position([0, -1, -2]) [0, 0, 0] >>> increment_by_position([0, 0, 0, 0]) [0, 1, 2, 3] >>> increment_by_position([5]) [5] >>> increment_by_position([]) [] >>> increment_by_position([-5, 0, 5, 10]) [-5, 1, 7, 13] >>> increment_by_position([1000000, 2000000]) [1000000, 2000001]","solution":"def increment_by_position(lst): Takes a list of integers and returns a new list with each element incremented by its position. Parameters: lst (list): A list of integers Returns: list: a new list where each element is incremented by its position in the list return [elem + idx for idx, elem in enumerate(lst)]"},{"question":"def find_smallest_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that is missing from the list. >>> find_smallest_missing_positive([3, 4, -1, 1]) == 2 >>> find_smallest_missing_positive([1, 2, 0]) == 3 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) == 1 >>> find_smallest_missing_positive([]) == 1 >>> find_smallest_missing_positive([-3, -2, -1]) == 1 >>> find_smallest_missing_positive([1, 1, 1, 1]) == 2 >>> find_smallest_missing_positive([1, 2, 3, 4, 5]) == 6 >>> find_smallest_missing_positive([1, 2, 3, 4, 6, 7]) == 5 >>> find_smallest_missing_positive([1, 3, 4, 5, 6, 8]) == 2 >>> find_smallest_missing_positive([2, 3, 4]) == 1 >>> find_smallest_missing_positive([1, 2, 3, 3, 6, 6, 7]) == 4","solution":"def find_smallest_missing_positive(nums): Returns the smallest positive integer that is missing from the list. nums = [num for num in nums if num > 0] n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: pos = nums[i] - 1 nums[i], nums[pos] = nums[pos], nums[i] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def count_palindromic_substrings(S: str) -> int: This function receives a string S and counts the number of palindromic substrings within it. >>> count_palindromic_substrings(\\"a\\") == 1 >>> count_palindromic_substrings(\\"ab\\") == 2 >>> count_palindromic_substrings(\\"aa\\") == 3 >>> count_palindromic_substrings(\\"ababa\\") == 9 >>> count_palindromic_substrings(\\"racecar\\") == 10 >>> count_palindromic_substrings(\\"abcdefg\\") == 7 >>> count_palindromic_substrings(\\"aaaa\\") == 10","solution":"def count_palindromic_substrings(S): This function receives a string S and counts the number of palindromic substrings within it. N = len(S) count = 0 # Initial dp table to store palindrome status dp = [[False] * N for _ in range(N)] # Single letters are palindromes for i in range(N): dp[i][i] = True count += 1 # Check two-letter palindromes for i in range(N-1): if S[i] == S[i+1]: dp[i][i+1] = True count += 1 # Check palindromes of length 3 and more for length in range(3, N+1): for start in range(N-length+1): end = start + length - 1 if S[start] == S[end] and dp[start+1][end-1]: dp[start][end] = True count += 1 return count"},{"question":"def find_non_decreasing_sequences(arr: List[int]) -> List[List[int]]: Takes in a list of integers \`arr\` and returns a list of lists where each sublist contains the start and end indices of the consecutive elements in \`arr\` that form a non-decreasing sequence. >>> find_non_decreasing_sequences([2, 3, 5, 4, 6, 9, 8]) [[0, 2], [3, 5], [6, 6]] >>> find_non_decreasing_sequences([10, 9, 8, 7]) [[0, 0], [1, 1], [2, 2], [3, 3]] from typing import List def test_no_sequences(): assert find_non_decreasing_sequences([]) == [] def test_single_element(): assert find_non_decreasing_sequences([1]) == [[0, 0]] def test_non_decreasing(): assert find_non_decreasing_sequences([1, 2, 3]) == [[0, 2]] def test_all_decreasing(): assert find_non_decreasing_sequences([3, 2, 1]) == [[0, 0], [1, 1], [2, 2]] def test_mixed_sequences(): assert find_non_decreasing_sequences([2, 3, 5, 4, 6, 9, 8]) == [[0, 2], [3, 5], [6, 6]] def test_all_same(): assert find_non_decreasing_sequences([2, 2, 2]) == [[0, 2]] def test_alternating_sequences(): assert find_non_decreasing_sequences([1, 2, 1, 2, 1, 2]) == [[0, 1], [2, 3], [4, 5]]","solution":"def find_non_decreasing_sequences(arr): Takes in a list of integers \`arr\` and returns a list of lists where each sublist contains the start and end indices of the consecutive elements in \`arr\` that form a non-decreasing sequence. if not arr: return [] result = [] start = 0 for i in range(1, len(arr)): if arr[i] < arr[i - 1]: result.append([start, i - 1]) start = i result.append([start, len(arr) - 1]) return result"},{"question":"def find_dominating_points(points: List[List[int]]) -> List[List[int]]: You are given a collection of points in a 2D plane, where points[i] = [xi, yi]. A point p is considered \\"dominating\\" if there are no points that have both higher x and y coordinates. Your goal is to find all the dominating points from the collection. A point pi = [xi, yi] is considered dominating if for any other point pj = [xj, yj], it is not true that xi < xj and yi < yj. Return the list of all dominating points sorted in increasing order first by x-coordinate and then by y-coordinate. >>> find_dominating_points([[1, 2], [2, 3], [3, 4], [5, 1], [2, 5]]) [[2, 5], [3, 4], [5, 1]] >>> find_dominating_points([[4, 4], [2, 3], [3, 2], [1, 5], [5, 5]]) [[5, 5]] >>> find_dominating_points([[1, 1], [2, 2], [3, 3]]) [[3, 3]] >>> find_dominating_points([]) [] >>> find_dominating_points([[1, 1], [1, 1], [1, 1]]) [[1, 1]] >>> find_dominating_points([[1, 10**9], [10**9, 1], [10**9, 10**9]]) [[10**9, 10**9]]","solution":"def find_dominating_points(points): Returns the list of dominating points sorted in increasing order first by x-coordinate and then by y-coordinate. if not points: return [] # Sort points in descending order first by x then by y points.sort(key=lambda x: (x[0], x[1]), reverse=True) dominating_points = [] max_y = float('-inf') for x, y in points: if y > max_y: dominating_points.append([x, y]) max_y = y # Sort the result in increasing order first by x-coordinate and then by y-coordinate dominating_points.sort(key=lambda x: (x[0], x[1])) return dominating_points"},{"question":"def initial_candies(final_candies: List[int]) -> List[int]: Returns the initial number of candies collected by each kid given the total amount of candies each kid ended up with. >>> initial_candies([10, 15, 20]) == [9, 14, 19] >>> initial_candies([8, 12, 7]) == [7, 11, 6]","solution":"def initial_candies(final_candies): Returns the initial number of candies collected by each kid given the total amount of candies each kid ended up with. # Kids must have given at least 1 candy to each other initial_distribution = [candies - 1 for candies in final_candies] return initial_distribution"},{"question":"def is_valid_isbn_10(isbn): Check if the given ISBN-10 is valid pass def is_valid_isbn_13(isbn): Check if the given ISBN-13 is valid pass def find_isbn(text): Extract and validate an ISBN from the given text. >>> find_isbn(\\"This text contains an ISBN-10 like 0-306-40615-2 somewhere.\\") == '0-306-40615-2' >>> find_isbn(\\"And this one has an ISBN-13: 978-0-306-40615-7 in it.\\") == '978-0-306-40615-7' >>> find_isbn(\\"No ISBNs here!\\") == None >>> find_isbn(\\"Invalid ISBN-10: 0-306-40615-X and Invalid ISBN-13: 978-0-306-40615-8 in this text.\\") == None >>> find_isbn(\\"Multiple ISBNs 0-306-40615-2 and 978-0-306-40615-7 in this text, but the first should be returned.\\") == '0-306-40615-2' pass","solution":"import re def is_valid_isbn_10(isbn): Check if the given ISBN-10 is valid isbn = isbn.replace('-', '') if len(isbn) != 10 or not isbn[:-1].isdigit() or (isbn[-1] not in '0123456789X'): return False total = 0 for i, char in enumerate(isbn): if char == 'X': total += 10 * (10 - i) else: total += int(char) * (10 - i) return total % 11 == 0 def is_valid_isbn_13(isbn): Check if the given ISBN-13 is valid isbn = isbn.replace('-', '') if len(isbn) != 13 or not isbn.isdigit(): return False total = 0 for i, char in enumerate(isbn): if i % 2 == 0: total += int(char) * 1 else: total += int(char) * 3 return total % 10 == 0 def find_isbn(text): Extract and validate an ISBN from the given text isbn_10_pattern = r'b(d[-d]{8,12}d|X)b' isbn_13_pattern = r'b(d[-d]{12,16}d)b' # Find all potential ISBN-10s and ISBN-13s, interleaved candidates = re.findall(f\\"({isbn_13_pattern })|({isbn_10_pattern})\\", text) if not candidates: return None # Flatten the list and filter out empty strings candidates = [item for sublist in candidates for item in sublist if item] for candidate in candidates: if re.match(isbn_13_pattern, candidate) and is_valid_isbn_13(candidate): return candidate if re.match(isbn_10_pattern, candidate) and is_valid_isbn_10(candidate): return candidate return None"},{"question":"def isBalancedBST(tree): Determines if a given binary search tree (BST) is balanced. A balanced binary search tree is defined as a tree in which the depth of the two subtrees of every node never differ by more than 1. Args: tree (list): The binary search tree represented as a nested list. Returns: bool: True if the tree is balanced, False otherwise. Examples: >>> isBalancedBST([5, [3, [1, None, None], [4, None, None]], [8, None, [9, None, None]]]) True >>> isBalancedBST([5, [3, [1, None, [2, None, None]], None], [8, None, None]]) False >>> isBalancedBST(None) True >>> isBalancedBST([1, None, None]) True >>> isBalancedBST([5, [4, [3, [2, None, None], None], None], None]) False >>> isBalancedBST([1, None, [2, None, [3, None, [4, None, None]]]]) False >>> isBalancedBST([1, [2, [3, None, None], None], [4, None, [5, None, None]]]) True","solution":"def isBalancedBST(tree): def check_height(node): if not node: return 0 left_height = check_height(node[1]) right_height = check_height(node[2]) if left_height == -1 or right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(tree) != -1"},{"question":"from typing import List, Tuple def maximize_compatibility(n: int, m: int, C: List[List[int]]) -> List[int]: Finds an optimal assignment of chemicals to containers that maximizes the total compatibility value. Parameters: n (int): Number of chemicals. m (int): Number of containers. C (List[List[int]]): Compatibility matrix where C[i][j] represents the compatibility between the i-th chemical and the j-th container. Returns: List[int]: List of integers representing the index of the container assigned to each chemical. Example: >>> maximize_compatibility(3, 3, [ [3, 2, 1], [5, 4, 3], [1, 2, 3] ]) [2, 3, 1] >>> maximize_compatibility(2, 2, [ [10, 50], [60, 20] ]) [2, 1] pass def solve(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[str]: Solves multiple test cases of the maximize_compatibility function. Parameters: test_cases (List[Tuple[int, int, List[List[int]]]]): A list of tuples where each tuple contains n (int): number of chemicals, m (int): number of containers, C (List[List[int]]): compatibility matrix. Returns: List[str]: A list of strings representing the result for each test case. Example: >>> solve([(3, 3, [ [3, 2, 1], [5, 4, 3], [1, 2, 3] ]), (2, 2, [ [10, 50], [60, 20] ])]) [\\"2 3 1\\", \\"2 1\\"] pass def main(input_data: str) -> str: Main function to parse input data and return output. Parameters: input_data (str): Input data as a single string. Returns: str: Output data as a single string. Example: >>> main('2n3 3n3 2 1n5 4 3n1 2 3n2 2n10 50n60 20n') \\"2 3 1n2 1\\" pass","solution":"from itertools import permutations def maximize_compatibility(n, m, C): This function finds an optimal assignment of chemicals to containers that maximizes the total compatibility value. max_value = 0 best_assignment = [] for perm in permutations(range(m), n): current_value = sum(C[i][perm[i]] for i in range(n)) if current_value > max_value: max_value = current_value best_assignment = perm return [x + 1 for x in best_assignment] # +1 to convert zero-indexed container to one-indexed def solve(test_cases): results = [] for test in test_cases: n, m, C = test result = maximize_compatibility(n, m, C) results.append(' '.join(map(str, result))) return results def main(input_data): input_lines = input_data.strip().split(\\"n\\") t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, input_lines[index].split()) index += 1 C = [] for i in range(n): C.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append((n, m, C)) results = solve(test_cases) return 'n'.join(results)"},{"question":"def solve(s: str) -> int: Returns the minimum number of changes needed to convert the string into a palindrome. >>> solve(\\"abca\\") 1 >>> solve(\\"race\\") 1 >>> solve(\\"abcdcba\\") 0 >>> solve(\\"ab\\") 1 >>> solve(\\"abcdef\\") 3","solution":"def solve(s): Returns the minimum number of changes needed to convert the string into a palindrome. l, r = 0, len(s) - 1 changes = 0 while l < r: if s[l] != s[r]: changes += 1 l += 1 r -= 1 return changes"},{"question":"def reorder_array(arr): Reorders the array such that every second element of the array is greater than its left and right elements, if possible. :param arr: List[int], the array to reorder :return: List[int] or str, the reordered array or \\"Not Possible\\" >>> reorder_array([3, 1, 2]) [1, 3, 2] >>> reorder_array([5, 3, 1, 2, 3]) \\"Not Possible\\" >>> reorder_array([1, 3, 2, 2, 7]) [1, 7, 2, 3, 2] >>> reorder_array([5, 9, 1, 3, 6, 2]) [1, 9, 2, 6, 3, 5] >>> reorder_array([1]) [1] >>> reorder_array([1, 2]) [1, 2] >>> reorder_array([2, 2, 2]) \\"Not Possible\\" pass def process_test_cases(test_cases): Processes multiple test cases. :param test_cases: List[Tuple[int, List[int]]], list of test cases where each test case is a tuple of the size of the array and the array itself. :return: List[Union[List[int], str]], the reordered arrays or \\"Not Possible\\" for each test case. >>> process_test_cases([ ... (3, [3, 1, 2]), ... (5, [5, 3, 1, 2, 3]), ... (1, [1]), ... (6, [6, 2, 5, 3, 1, 4]) ... ]) [ [1, 3, 2], \\"Not Possible\\", [1], [1, 6, 2, 5, 3, 4] ] pass","solution":"def reorder_array(arr): Reorders the array such that every second element of the array is greater than its left and right elements. n = len(arr) if n < 3: if n == 1 or (n == 2 and arr[0] != arr[1]): return arr else: return \\"Not Possible\\" arr.sort() result = [0] * n left, right = 0, n - 1 for i in range(n): if i % 2 == 0: result[i] = arr[left] left += 1 else: result[i] = arr[right] right -= 1 # Check the condition for i in range(1, n-1, 2): if not (result[i] > result[i-1] and result[i] > result[i+1]): return \\"Not Possible\\" return result def process_test_cases(test_cases): results = [] for n, arr in test_cases: result = reorder_array(arr) results.append(result) return results # To read input # Uncomment and use below lines in actual runtime environment # import sys # input = sys.stdin.read # data = input().split() # T = int(data[0]) # index = 1 # test_cases = [(int(data[index]), [int(x) for x in data[index+1:index+1+int(data[index])]]) for i in range(T)] # index += int(data[index])+1 # results = process_test_cases(test_cases) # for result in results: # if isinstance(result, str): # print(result) # else: # print(' '.join(map(str, result)))"},{"question":"def countDistinctSubstrings(s: str) -> int: Write a function that takes in a string and returns the number of distinct substrings of the string. The string consists only of lowercase English letters. >>> countDistinctSubstrings(\\"abc\\") # \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\" 6 >>> countDistinctSubstrings(\\"aaa\\") # \\"a\\", \\"aa\\", \\"aaa\\" 3 # Your code here pass def test_count_distinct_substrings(): assert countDistinctSubstrings(\\"abc\\") == 6 # \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\" assert countDistinctSubstrings(\\"aaa\\") == 3 # \\"a\\", \\"aa\\", \\"aaa\\" assert countDistinctSubstrings(\\"ababa\\") == 9 # \\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"aba\\", \\"bab\\", \\"ab\\", \\"aba\\", \\"ababa\\" assert countDistinctSubstrings(\\"abcd\\") == 10 # \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"ab\\", \\"bc\\", \\"cd\\", \\"abc\\", \\"bcd\\", \\"abcd\\" assert countDistinctSubstrings(\\"a\\") == 1 # \\"a\\" assert countDistinctSubstrings(\\"aa\\") == 2 # \\"a\\", \\"aa\\" assert countDistinctSubstrings(\\"ab\\") == 3 # \\"a\\", \\"b\\", \\"ab\\" # Run the tests test_count_distinct_substrings()","solution":"def countDistinctSubstrings(s: str) -> int: Returns the number of distinct substrings of the input string s. # Set to store all distinct substrings substrings = set() # Generate all substrings and add them to the set for i in range(len(s)): for j in range(i+1, len(s)+1): substrings.add(s[i:j]) return len(substrings)"},{"question":"from typing import List def unique_events(events: List[int]) -> List[int]: Returns a list of unique event timestamps in the order of their first occurrence. >>> unique_events([4, 5, 4, 6, 7, 4, 7, 8, 6]) [4, 5, 6, 7, 8] >>> unique_events([1, 2, 3, 1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] def test_unique_events(): assert unique_events([4, 5, 4, 6, 7, 4, 7, 8, 6]) == [4, 5, 6, 7, 8] assert unique_events([1, 2, 3, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert unique_events([1, 1, 1, 1, 1]) == [1] assert unique_events([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] assert unique_events([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == [1, 2, 3, 4, 5]","solution":"from typing import List def unique_events(events: List[int]) -> List[int]: Returns a list of unique event timestamps in the order of their first occurrence. seen = set() unique = [] for event in events: if event not in seen: unique.append(event) seen.add(event) return unique"},{"question":"def check_subarray_sum(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if there exists a contiguous subarray whose sum is exactly equal to a given integer S. Parameters: t : int : The number of test cases. test_cases : List[Tuple[Tuple[int, int], List[int]]] : A list of test cases, each containing a tuple with the length of the array and target sum, and a list of integers representing the elements of the array. Returns: List[str] : A list of \\"yes\\" or \\"no\\" for each test case indicating whether a contiguous subarray with the target sum exists. >>> check_subarray_sum(3, [((5, 12), [1, 2, 3, 7, 5]), ((5, 15), [1, 2, 3, 7, 5]), ((5, 5), [1, 2, 3, 7, 5])]) [\\"yes\\", \\"yes\\", \\"yes\\"] >>> check_subarray_sum(1, [((5, 20), [1, 2, 3, 7, 5])]) [\\"no\\"]","solution":"def check_subarray_sum(t, test_cases): results = [] for i in range(t): n, S = test_cases[i][0] array = test_cases[i][1] current_sum = 0 start = 0 found = False for end in range(n): current_sum += array[end] while current_sum > S and start <= end: current_sum -= array[start] start += 1 if current_sum == S: found = True break if found: results.append(\\"yes\\") else: results.append(\\"no\\") return results"},{"question":"def can_transform(s: str, t: str) -> str: Determines whether string s can be transformed into string t by performing any number of append or remove-the-last-character operations. >>> can_transform(\\"abc\\", \\"abcd\\") \\"Yes\\" >>> can_transform(\\"apple\\", \\"apl\\") \\"No\\" >>> can_transform(\\"hello\\", \\"oll\\") \\"No\\" def process_queries(queries: List[Tuple[str, str]]) -> List[str]: Takes a list of queries, where each query is a tuple (s, t), and returns a list of results for each query. >>> process_queries([(\\"abc\\", \\"abcd\\"), (\\"apple\\", \\"apl\\"), (\\"hello\\", \\"oll\\")]) [\\"Yes\\", \\"No\\", \\"No\\"]","solution":"def can_transform(s, t): Determines whether string s can be transformed into string t by performing any number of append or remove-the-last-character operations. # Check if s is a prefix of t if t.startswith(s): return \\"Yes\\" return \\"No\\" def process_queries(queries): Takes a list of queries, where each query is a tuple (s, t), and returns a list of results for each query. results = [] for s, t in queries: results.append(can_transform(s, t)) return results"},{"question":"def flatten_array(n, m, array_2d): Flattens a 2D array into a 1D array. Args: n - Number of rows m - Number of columns array_2d - 2D list of integers (list of lists format) Returns: A list of integers representing the flattened array. array = np.array(array_2d) return array.flatten().tolist() # Sample Usage >>> flatten_array(2, 3, [[1, 2, 3], [4, 5, 6]]) [1, 2, 3, 4, 5, 6] # Unit Tests def test_flatten_array_sample(): n, m = 2, 3 array_2d = [ [1, 2, 3], [4, 5, 6] ] assert flatten_array(n, m, array_2d) == [1, 2, 3, 4, 5, 6] def test_flatten_array_single_row(): n, m = 1, 4 array_2d = [ [7, 8, 9, 10] ] assert flatten_array(n, m, array_2d) == [7, 8, 9, 10] def test_flatten_array_single_column(): n, m = 4, 1 array_2d = [ [1], [2], [3], [4] ] assert flatten_array(n, m, array_2d) == [1, 2, 3, 4] def test_flatten_array_large(): n, m = 3, 3 array_2d = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert flatten_array(n, m, array_2d) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_flatten_array_variable_elements(): n, m = 3, 2 array_2d = [ [1, 2], [3, 4], [5, 6] ] assert flatten_array(n, m, array_2d) == [1, 2, 3, 4, 5, 6]","solution":"import numpy as np def flatten_array(n, m, array_2d): Flattens a 2D array into a 1D array. Args: n - Number of rows m - Number of columns array_2d - 2D list of integers (list of lists format) Returns: A list of integers representing the flattened array. array = np.array(array_2d) return array.flatten().tolist()"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Compute the area of the largest possible rectangle that can be formed within the bounds of the histogram. Examples: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([1, 1, 1, 1, 1]) 5","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed within the bounds of the given histogram heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def max_contiguous_subarray_sum(arr: List[int]) -> int: Returns the maximum possible sum of its contiguous subarrays. >>> max_contiguous_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_contiguous_subarray_sum([1]) 1 >>> max_contiguous_subarray_sum([-1]) -1 >>> max_contiguous_subarray_sum([1, 2, 3, 4]) 10 >>> max_contiguous_subarray_sum([-1, -2, -3, -4]) -1 >>> max_contiguous_subarray_sum([3, -1, 2, -1]) 4 >>> max_contiguous_subarray_sum([]) 0 >>> max_contiguous_subarray_sum([10**6, -10**5, 10**6]) 1900000","solution":"from typing import List def max_contiguous_subarray_sum(arr: List[int]) -> int: Returns the sum of the maximum sum of contiguous subarray. if not arr: # handle empty array return 0 max_so_far = arr[0] current_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) max_so_far = max(max_so_far, current_max) return max_so_far"},{"question":"def min_distance(s: str, t: str) -> int: Compute the minimum number of operations required to convert string s into string t. Operations allowed: insert a character, delete a character, replace a character. >>> min_distance(\\"horse\\", \\"ros\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5 >>> min_distance(\\"abc\\", \\"yabd\\") 2","solution":"def min_distance(s, t): Compute the minimum number of operations required to convert string s into string t. Operations allowed: insert a character, delete a character, replace a character. m, n = len(s), len(t) # If one of the strings is empty if m == 0: return n if n == 0: return m # Create a DP table to store results of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Initialize dp table for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill dp table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If current characters match, no new operation required else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete from s dp[i][j - 1], # Insert into s dp[i - 1][j - 1]) # Replace in s return dp[m][n]"},{"question":"from typing import List from collections import Counter import heapq def rearrange_string(S: str) -> str: Determine whether a string S is a perfect string and print the rearranged string or \\"Not possible\\". >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"aaab\\") 'Not possible' # Write your solution here # Unit Tests def test_example_1(): assert rearrange_string(\\"aabb\\") == \\"abab\\" def test_example_2(): assert rearrange_string(\\"aaab\\") == \\"Not possible\\" def test_single_character(): assert rearrange_string(\\"a\\") == \\"a\\" def test_all_same_characters(): assert rearrange_string(\\"aaaaa\\") == \\"Not possible\\" def test_valid_mixed_string(): assert rearrange_string(\\"aabbcc\\") in [\\"abcabc\\", \\"abccba\\"] def test_large_input(): assert rearrange_string(\\"a\\"*500 + \\"b\\"*500) == \\"ab\\" * 500 def test_no_repeated_characters(): assert rearrange_string(\\"abcdef\\") in [\\"abcdef\\", \\"abcfed\\", \\"acdbef\\", \\"acdfeb\\", \\"acebdf\\", \\"acedfb\\", \\"adbecf\\", \\"adbefc\\", \\"adbcef\\", \\"adbcef\\", \\"adecbf\\", \\"adefcb\\", \\"aecbdf\\", \\"aecdbf\\", \\"aebcfd\\", \\"aebdfc\\", \\"aefdcb\\", \\"afbcde\\"] def test_two_characters(): assert rearrange_string(\\"aa\\") == \\"Not possible\\" assert rearrange_string(\\"ab\\") == \\"ab\\" def test_large_valid_input(): input_str = \\"a\\"*300 + \\"b\\"*300 + \\"c\\"*300 + \\"d\\"*100 output = rearrange_string(input_str) assert len(output) == 1000 for i in range(1, len(output)): assert output[i] != output[i - 1]","solution":"from collections import Counter import heapq def rearrange_string(S): char_count = Counter(S) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char, prev_count = None, 0 result = [] while max_heap or prev_count < 0: if prev_count < 0: if not max_heap: return \\"Not possible\\" count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char, prev_count = char, count + 1 else: count, char = heapq.heappop(max_heap) result.append(char) prev_count = count + 1 prev_char = char return ''.join(result)"},{"question":"def decode_message(symbols: str, lengths: List[int]) -> List[str]: Decodes the symbols string into segments based on the provided lengths. >>> decode_message(\\"abcde12345xyz\\", [5, 5, 3]) ['abcde', '12345', 'xyz'] >>> decode_message(\\"hellopython\\", [5, 6]) ['hello', 'python'] result = [] # Example Usage: symbols = \\"abcde12345xyz\\" lengths = [5, 5, 3] print(decode_message(symbols, lengths)) # Outputs: ['abcde', '12345', 'xyz'] Unit Tests: from solution import decode_message def test_decode_single_segment(): assert decode_message(\\"hello\\", [5]) == [\\"hello\\"] def test_decode_multiple_segments(): assert decode_message(\\"abcde12345xyz\\", [5, 5, 3]) == [\\"abcde\\", \\"12345\\", \\"xyz\\"] def test_decode_two_segments(): assert decode_message(\\"hellopython\\", [5, 6]) == [\\"hello\\", \\"python\\"] def test_decode_three_segments(): assert decode_message(\\"catdogbird\\", [3, 3, 4]) == [\\"cat\\", \\"dog\\", \\"bird\\"] def test_decode_segments_with_varied_lengths(): assert decode_message(\\"concatenationexample\\", [3, 6, 6, 5]) == [\\"con\\", \\"catena\\", \\"tionex\\", \\"ample\\"]","solution":"def decode_message(symbols, lengths): Decodes the symbols string into segments based on the provided lengths. :param symbols: str, a string representing a sequence of symbols :param lengths: list of int, lengths of each segment that form words :return: list of str, decoded message as list of words result = [] start = 0 for length in lengths: end = start + length result.append(symbols[start:end]) start = end return result"},{"question":"def char_frequency(test_cases): Given a list of strings, calculate the frequency of each character in each string. results = [] for string in test_cases: # Create a dictionary to count frequencies frequency = {} for char in string: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Sort the dictionary by key (character) and prepare the result in sorted order sorted_frequency = dict(sorted(frequency.items())) results.append(sorted_frequency) return results def process_frequencies(test_cases): Given a list of frequency dictionaries, print the frequency of each character in required format. for frequencies in test_cases: for char, count in frequencies.items(): print(f\\"{char}: {count}\\") from solution import char_frequency, process_frequencies def test_char_frequency_single_string(): input_data = [\\"hello\\"] expected_output = [{'e': 1, 'h': 1, 'l': 2, 'o': 1}] assert char_frequency(input_data) == expected_output def test_char_frequency_multiple_strings(): input_data = [\\"hello\\", \\"world\\"] expected_output = [ {'e': 1, 'h': 1, 'l': 2, 'o': 1}, {'d': 1, 'l': 1, 'o': 1, 'r': 1, 'w': 1} ] assert char_frequency(input_data) == expected_output def test_process_frequencies_single_string(capsys): input_data = [ {'e': 1, 'h': 1, 'l': 2, 'o': 1} ] process_frequencies(input_data) captured = capsys.readouterr() expected_output = \\"e: 1nh: 1nl: 2no: 1n\\" assert captured.out == expected_output def test_process_frequencies_multiple_strings(capsys): input_data = [ {'e': 1, 'h': 1, 'l': 2, 'o': 1}, {'d': 1, 'l': 1, 'o': 1, 'r': 1, 'w': 1} ] process_frequencies(input_data) captured = capsys.readouterr() expected_output = \\"e: 1nh: 1nl: 2no: 1n\\" expected_output += \\"d: 1nl: 1no: 1nr: 1nw: 1n\\" assert captured.out == expected_output","solution":"def char_frequency(test_cases): Given a list of strings, calculate the frequency of each character in each string. results = [] for string in test_cases: # Create a dictionary to count frequencies frequency = {} for char in string: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Sort the dictionary by key (character) and prepare the result in sorted order sorted_frequency = dict(sorted(frequency.items())) results.append(sorted_frequency) return results def process_frequencies(test_cases): Given a list of frequency dictionaries, print the frequency of each character in required format. for frequencies in test_cases: for char, count in frequencies.items(): print(f\\"{char}: {count}\\")"},{"question":"def has_pair_with_sum(nums: list, target: int) -> bool: Check if there is a pair of distinct elements in the list that add up to the specified target sum. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([5, -1, 4, 0, -5], -6) True >>> has_pair_with_sum([], 1) False >>> has_pair_with_sum([3, 3], 6) True","solution":"def has_pair_with_sum(nums: list, target: int) -> bool: Returns True if there is a pair of distinct elements in \`nums\` that add up to \`target\`. Returns False otherwise. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"from typing import List def rarest_word(words: List[str]) -> str: Returns the rarest word in the list of words. If there are multiple words with the same lowest frequency, the lexicographically smallest word is returned. Input: words (List[str]): A list of words Returns: str: The rarest word in the list Examples: >>> rarest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"apple\\", \\"banana\\", \\"durian\\"]) 'cherry' >>> rarest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"apple\\", \\"banana\\", \\"cherry\\"]) 'apple' >>> rarest_word([\\"a\\"]) 'a' >>> rarest_word([\\"banana\\", \\"cherry\\", \\"banana\\", \\"durian\\", \\"apple\\", \\"cherry\\"]) 'apple' # Implement the function here pass # Sample Test cases assert rarest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"apple\\", \\"banana\\", \\"durian\\"]) == \\"cherry\\" assert rarest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"apple\\" assert rarest_word([\\"a\\"]) == \\"a\\" assert rarest_word([\\"banana\\", \\"cherry\\", \\"banana\\", \\"durian\\", \\"apple\\", \\"cherry\\"]) == \\"apple\\"","solution":"from typing import List from collections import Counter def rarest_word(words: List[str]) -> str: Returns the rarest word in the list of words. If there are multiple words with the same lowest frequency, the lexicographically smallest word is returned. word_counts = Counter(words) min_count = min(word_counts.values()) rarest_words = [word for word, count in word_counts.items() if count == min_count] return min(rarest_words)"},{"question":"def is_palindrome(s): Check if the given string is a palindrome. :param s: The input string or other type to check :return: True if the string is a palindrome, False if it's not, None for non-string inputs >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(12321) None >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"!!!\\") True","solution":"import re def is_palindrome(s): Check if the given string is a palindrome. :param s: The input string or other type to check :return: True if the string is a palindrome, False if it's not, None for non-string inputs if not isinstance(s, str): return None s = re.sub(r'[^A-Za-z0-9]', '', s).lower() return s == s[::-1]"},{"question":"def unique_digits(s: str) -> bool: Checks whether the given string is a valid integer and all its digits are unique. Returns True if the integer has no repeated digits, and False otherwise. >>> unique_digits(\\"12345\\") == True >>> unique_digits(\\"11234\\") == False >>> unique_digits(\\"-12345\\") == True >>> unique_digits(\\"102345\\") == True >>> unique_digits(\\"1234a5\\") == False >>> unique_digits(\\"003\\") == False","solution":"def unique_digits(s): Checks whether the given string is a valid integer and all its digits are unique. Returns True if the integer has no repeated digits, and False otherwise. if not s.lstrip('-').isdigit(): return False digit_set = set() for char in s.lstrip('-'): if char in digit_set: return False digit_set.add(char) # Check for leading zeros if s != '0' and s.lstrip('-')[0] == '0': return False return True"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing addition and multiplication, ensuring that multiplication is evaluated first. Args: expression (str): The input string containing the expression. Returns: int: The result of evaluating the expression. Examples: >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"10+2*5+3\\") 23","solution":"import re def evaluate_expression(expression): Evaluate a mathematical expression containing addition and multiplication, ensuring that multiplication is evaluated first. Args: expression (str): The input string containing the expression. Returns: int: The result of evaluating the expression. # Match multi-digit numbers and operators tokens = re.findall(r'd+|*|+', expression) # First evaluate all the multiplication parts i = 0 while i < len(tokens): if tokens[i] == '*': result = int(tokens[i - 1]) * int(tokens[i + 1]) tokens = tokens[:i - 1] + [str(result)] + tokens[i + 2:] i -= 1 i += 1 # Now evaluate the remaining addition parts result = 0 for token in tokens: if token != '+': result += int(token) return result"},{"question":"def findLongestPalindromicSubstring(s: str) -> str: Write a function that takes a string s and returns the longest palindromic substring in s. A palindromic substring is a substring which reads the same backwards as forwards. If there are multiple longest palindromic substrings of the same length, return the one which appears first. >>> findLongestPalindromicSubstring(\\"babad\\") in {\\"bab\\", \\"aba\\"} True >>> findLongestPalindromicSubstring(\\"cbbd\\") == \\"bb\\" True >>> findLongestPalindromicSubstring(\\"a\\") == \\"a\\" True >>> findLongestPalindromicSubstring(\\"ac\\") in {\\"a\\", \\"c\\"} True # Your code here","solution":"def findLongestPalindromicSubstring(s): def expandAroundCenter(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 start = 0 end = 0 for i in range(len(s)): len1 = expandAroundCenter(s, i, i) # Odd length palindromes len2 = expandAroundCenter(s, i, i + 1) # Even length palindromes max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end + 1]"},{"question":"def longest_unique_substring(s: str) -> int: Determine the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 def test_example_cases(): assert longest_unique_substring(\\"abcabcbb\\") == 3 assert longest_unique_substring(\\"bbbbb\\") == 1 assert longest_unique_substring(\\"pwwkew\\") == 3 def test_empty_input(): assert longest_unique_substring(\\"\\") == 0 def test_single_character(): assert longest_unique_substring(\\"a\\") == 1 def test_repeating_sequence(): assert longest_unique_substring(\\"aaaaa\\") == 1 def test_unique_characters(): assert longest_unique_substring(\\"abcdef\\") == 6 def test_mixed_characters(): assert longest_unique_substring(\\"aabbccddeeffgghh\\") == 2 def test_punctuation_and_spaces(): assert longest_unique_substring(\\"a b c!d@e#fg%\\") == 12 def test_long_input(): long_input = \\"a\\" * 1000 + \\"b\\" assert longest_unique_substring(long_input) == 2","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def length_of_longest_substring(s: str) -> int: Determine the length of the longest substring without repeating characters. Args: s (str): A string consisting of lowercase English letters. Returns: int: The length of the longest substring without repeating characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"abcabcabc\\") 3 >>> length_of_longest_substring(\\"abcdefghijk\\" * 10) 11 >>> length_of_longest_substring(\\"abcd!@#%\\") 9","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"class QueueViaStacks: Queue implementation using two stacks. Methods: - enqueue(value): Adds \`value\` to the end of the queue. - dequeue(): Removes the element from the front of the queue and returns its value. If the queue is empty when \`dequeue\` is called, return \`None\`. Example: >>> q = QueueViaStacks() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.dequeue() 1 >>> q.dequeue() 2 >>> q.dequeue() None def __init__(self): pass def enqueue(self, value): pass def dequeue(self): pass","solution":"class QueueViaStacks: def __init__(self): self.stack_in = [] self.stack_out = [] def enqueue(self, value): self.stack_in.append(value) def dequeue(self): if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop()) return self.stack_out.pop() if self.stack_out else None"},{"question":"def check_water_distribution(N, M, water_requirements, daily_water_distribution): Checks if each plant has received the required amount of water by the end of the month. Args: N : int : number of types of plants. M : int : number of days in the month. water_requirements : list of int : amount of water required by each type of plant over the month. daily_water_distribution : list of list of int : water given to each plant on each day. Returns: str : \\"YES\\" if each plant has received the required amount of water, otherwise \\"NO\\". pass def test_check_water_distribution(): # Test case with sample input N = 3 M = 4 water_requirements = [50, 30, 40] daily_water_distribution = [ [10, 10, 10], [10, 5, 10], [20, 5, 10], [10, 10, 10] ] assert check_water_distribution(N, M, water_requirements, daily_water_distribution) == \\"YES\\" # Test case where not enough water is given N = 3 M = 4 water_requirements = [50, 30, 40] daily_water_distribution = [ [10, 10, 10], [10, 5, 10], [20, 5, 5], [10, 10, 10] ] assert check_water_distribution(N, M, water_requirements, daily_water_distribution) == \\"NO\\" # Test case where extra water is given N = 2 M = 2 water_requirements = [20, 15] daily_water_distribution = [ [10, 10], [15, 10] ] assert check_water_distribution(N, M, water_requirements, daily_water_distribution) == \\"NO\\" # Test case with exact water requirements given N = 2 M = 2 water_requirements = [20, 20] daily_water_distribution = [ [10, 10], [10, 10] ] assert check_water_distribution(N, M, water_requirements, daily_water_distribution) == \\"YES\\" import pytest pytest.main([\\"-v\\", \\"-s\\", \\"solution_test.py\\"]) # Assuming you name the test file solution_test.py","solution":"def check_water_distribution(N, M, water_requirements, daily_water_distribution): Checks if each plant has received the required amount of water by the end of the month. Args: N : int : number of types of plants. M : int : number of days in the month. water_requirements : list of int : amount of water required by each type of plant over the month. daily_water_distribution : list of list of int : water given to each plant on each day. Returns: str : \\"YES\\" if each plant has received the required amount of water, otherwise \\"NO\\". total_water_given = [0] * N for day in daily_water_distribution: for i in range(N): total_water_given[i] += day[i] for i in range(N): if total_water_given[i] != water_requirements[i]: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def smallest_special_prime_sequence(K: int) -> List[int]: Generate the smallest special prime sequence of length K. >>> smallest_special_prime_sequence(3) [2, 3, 5] >>> smallest_special_prime_sequence(5) [2, 3, 5, 7, 11]","solution":"def smallest_special_prime_sequence(K): # Helper function to generate prime numbers using Sieve of Eratosthenes def generate_primes(n): sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for i in range(2, int(n**0.5) + 1): if sieve[i]: for j in range(i*i, n + 1, i): sieve[j] = False return [x for x in range(n + 1) if sieve[x]] # Ensure reasonable upper limit for prime generation upper_limit = 1000 primes = generate_primes(upper_limit) return primes[:K] # Example: Handling multiple test cases def process_test_cases(test_cases): results = [] for K in test_cases: results.append(smallest_special_prime_sequence(K)) return results"},{"question":"from typing import List def diagonal_sum_difference(matrix: List[List[int]]) -> int: Returns the absolute difference between the sums of the primary and secondary diagonals of a square matrix. >>> diagonal_sum_difference([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 0 >>> diagonal_sum_difference([ ... [5, 3, 1], ... [3, 6, 2], ... [9, 8, 3] ... ]) 2 >>> diagonal_sum_difference([ ... [42] ... ]) 0 >>> diagonal_sum_difference([ ... [1, 2, -3], ... [-4, -5, 6], ... [7, 8, 9] ... ]) 6 >>> diagonal_sum_difference([ ... [100, -100, 100], ... [-100, 100, -100], ... [100, -100, 100] ... ]) 0","solution":"def diagonal_sum_difference(matrix): Returns the absolute difference between the sums of the primary and secondary diagonals of a square matrix. n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n-1-i] return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"def calculate(expression: str) -> int: Evaluates a mathematical expression containing positive integers and the operators +, -, *, and /. Returns the computed result as an integer or \\"Error\\" in case of divide by zero. >>> calculate(\\"3 + 4\\") 7 >>> calculate(\\"10 - 5\\") 5 >>> calculate(\\"6 * 3\\") 18 >>> calculate(\\"8 / 2\\") 4 >>> calculate(\\"3 + 5 * 2\\") 13 >>> calculate(\\"10 - 6 / 2\\") 7 >>> calculate(\\"8 + 2 * 3 / 2 - 1\\") 10 >>> calculate(\\"2 + 3 * 2\\") 8 >>> calculate(\\"20 / 4 + 3 * 2\\") 11 >>> calculate(\\"10 / 0\\") \\"Error\\" >>> calculate(\\"5 + 3 / 0\\") \\"Error\\" >>> calculate(\\"1000000 * 1000000\\") 1000000000000 >>> calculate(\\"12345678 + 87654321\\") 99999999 >>> calculate(\\"5\\") 5 >>> calculate(\\"9999\\") 9999","solution":"def calculate(expression): Evaluates a mathematical expression containing positive integers and the operators +, -, *, and /. Returns the computed result as an integer or \\"Error\\" in case of divide by zero. try: # Replace all integer divisions with float divisions and evaluate the expression result = eval(expression.replace('/', '//')) return result except ZeroDivisionError: return \\"Error\\""},{"question":"def longest_unique_subsequence(s: str) -> str: Determines the longest subsequence of unique characters in the input string. Args: s (str): The input string. Returns: str: The longest subsequence of unique characters. Examples: >>> longest_unique_subsequence(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_subsequence(\\"bbbbb\\") == \\"b\\" >>> longest_unique_subsequence(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_subsequence(\\"abcdefg\\") == \\"abcdefg\\"","solution":"def longest_unique_subsequence(s): Determines the longest subsequence of unique characters. Args: s (str): The input string. Returns: str: The longest subsequence of unique characters. if not s: return \\"\\" max_subseq = \\"\\" start = 0 seen = {} for end in range(len(s)): if s[end] in seen and seen[s[end]] >= start: start = seen[s[end]] + 1 seen[s[end]] = end current_subseq = s[start:end + 1] if len(current_subseq) > len(max_subseq): max_subseq = current_subseq return max_subseq"},{"question":"def unique_paths_with_obstacles(m, n, grid): Find the number of unique paths from the top-left to the bottom-right corner of a grid, avoiding blocked cells. Args: m: int - the number of rows in the grid. n: int - the number of columns in the grid. grid: List[List[str]] - the grid representation with '.' as open cells and '#' as blocked cells. Returns: int - the number of unique paths. >>> unique_paths_with_obstacles(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> unique_paths_with_obstacles(3, 3, [['#', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 0 >>> unique_paths_with_obstacles(3, 3, [['.', '.', '#'], ['.', '.', '.'], ['.', '#', '.']]) 1","solution":"def unique_paths_with_obstacles(m, n, grid): # Initializing the dp table with 0s dp = [[0] * n for _ in range(m)] # If the start or end point is blocked, return 0 if grid[0][0] == '#' or grid[m-1][n-1] == '#': return 0 # Initializing the starting position dp[0][0] = 1 # Filling the dp table for i in range(m): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] # The result is in the bottom-right corner return dp[m-1][n-1]"},{"question":"def longest_equal_subarray(arr): Given an array of integers, find the length of the longest subarray that contains equal numbers of 0s and 1s. >>> longest_equal_subarray([0, 1, 0, 1, 0]) 4 >>> longest_equal_subarray([0, 0, 0, 1, 1, 1, 1]) 6 >>> longest_equal_subarray([]) 0 >>> longest_equal_subarray([1, 1, 1, 1]) 0 >>> longest_equal_subarray([0, 0, 0, 0]) 0 >>> longest_equal_subarray([0]) 0 >>> longest_equal_subarray([1]) 0 >>> longest_equal_subarray([0, 1, 1, 0, 1, 0, 0, 1]) 8 >>> longest_equal_subarray([0, 1, 0, 1, 1, 0, 0, 1, 1, 0]) 10","solution":"def longest_equal_subarray(arr): Returns the length of the longest subarray where the number of 0s equals the number of 1s. count_map = {0: -1} max_len = 0 count = 0 for i, num in enumerate(arr): count += -1 if num == 0 else 1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len"},{"question":"def poly_multiply(p1, p2): Multiplies two polynomials p1 and p2 and returns resulting polynomial. Args: p1 (list): Coefficients of the first polynomial. p2 (list): Coefficients of the second polynomial. Returns: list: Coefficients of the resulting polynomial. >>> poly_multiply([1, 2], [1, 3]) == [1, 5, 6] >>> poly_multiply([0], [1, 2, 3]) == [0, 0, 0] >>> poly_multiply([1, 2, 3], [0]) == [0, 0, 0] >>> poly_multiply([2], [3]) == [6] >>> poly_multiply([0], [0]) == [0] >>> poly_multiply([1, 1, 1], [1, 1, 1]) == [1, 2, 3, 2, 1] >>> poly_multiply([2, 0, 3], [1, 4]) == [2, 8, 3, 12]","solution":"def poly_multiply(p1, p2): Multiplies two polynomials p1 and p2 and returns resulting polynomial. Args: p1 (list): Coefficients of the first polynomial. p2 (list): Coefficients of the second polynomial. Returns: list: Coefficients of the resulting polynomial. # Initialize an array to store the result with necessary size result_size = len(p1) + len(p2) - 1 result = [0] * result_size # Multiply the polynomials term by term for i in range(len(p1)): for j in range(len(p2)): result[i + j] += p1[i] * p2[j] return result"},{"question":"import typing def min_path_sum(grid: typing.List[typing.List[int]]) -> int: You are given a grid of size MxN, represented as a 2D list of integers, where each cell contains a non-negative integer representing the cost of stepping into that cell. You are currently standing at the top-left corner of the grid (cell (0, 0)), and you want to travel to the bottom-right corner of the grid (cell (M-1, N-1)). You can only move one step to the right (to (i, j+1)) or one step down (to (i+1, j)) at a time. You need to find the minimal path sum from the top-left to the bottom-right corner. Args: grid (List[List[int]]): 2D list representing the cost grid. Returns: int: The minimal path sum from top-left to bottom-right corner. Examples: >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_path_sum(grid) 7 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> min_path_sum(grid) 21 def test_min_path_sum_example(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_sum(grid) == 7 def test_min_path_sum_single_cell(): grid = [[5]] assert min_path_sum(grid) == 5 def test_min_path_sum_single_row(): grid = [[1, 2, 3, 4]] assert min_path_sum(grid) == 10 def test_min_path_sum_single_column(): grid = [[1], [2], [3], [4]] assert min_path_sum(grid) == 10 def test_min_path_sum_large_values(): grid = [ [1000, 1000], [1000, 1000] ] assert min_path_sum(grid) == 3000 def test_min_path_sum_zeroes(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert min_path_sum(grid) == 0 def test_min_path_sum_mixed_values(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_path_sum(grid) == 21","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 M = len(grid) N = len(grid[0]) # Initialize the dp table with the same dimensions as grid dp = [[0] * N for _ in range(M)] dp[0][0] = grid[0][0] # Initialize the first column of the dp table for i in range(1, M): dp[i][0] = dp[i - 1][0] + grid[i][0] # Initialize the first row of the dp table for j in range(1, N): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[M-1][N-1]"},{"question":"def get_monitorless_participants(row: str): Given a string representing a row of participants, return a list of indices of participants who need a monitor. If everyone has a monitor, return 'Everyone has a monitor!'. >>> get_monitorless_participants(\\"MMMMM\\") 'Everyone has a monitor!' >>> get_monitorless_participants(\\"NMNNM\\") [0, 2, 3] >>> get_monitorless_participants(\\"NMMN\\") [0, 3] >>> get_monitorless_participants(\\"NNNN\\") [0, 1, 2, 3] >>> get_monitorless_participants(\\"MNMNMN\\") [1, 3, 5] >>> get_monitorless_participants(\\"M\\") 'Everyone has a monitor!' >>> get_monitorless_participants(\\"N\\") [0]","solution":"def get_monitorless_participants(row): Given a string representing a row of participants, return a list of indices of participants who need a monitor. If everyone has a monitor, return 'Everyone has a monitor!'. monitorless_indices = [index for index, seat in enumerate(row) if seat == 'N'] return monitorless_indices if monitorless_indices else 'Everyone has a monitor!'"},{"question":"def is_palindrome(s: str) -> str: Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == \\"YES\\" True >>> is_palindrome(\\"No 'x' in Nixon\\") == \\"YES\\" True >>> is_palindrome(\\"hello\\") == \\"NO\\" True >>> is_palindrome(\\"world\\") == \\"NO\\" True >>> is_palindrome(\\"12321\\") == \\"YES\\" True >>> is_palindrome(\\"123451\\") == \\"NO\\" True >>> is_palindrome(\\"\\") == \\"YES\\" True >>> is_palindrome(\\"a\\") == \\"YES\\" True >>> is_palindrome(\\"1\\") == \\"YES\\" True Args: s (str): The input string. Returns: str: 'YES' if the input string is a palindrome, 'NO' otherwise.","solution":"import re def is_palindrome(s: str) -> str: Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s (str): The input string. Returns: str: 'YES' if the input string is a palindrome, 'NO' otherwise. # Remove all non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse if cleaned_s == cleaned_s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_unique_pairs(arr: List[int], target: int) -> int: Determine the number of unique pairs of elements that sum up to a specific target value. >>> count_unique_pairs([1, 2, 3, 4, 3], 6) 2 >>> count_unique_pairs([1, 2, 3, 4], 10) 0 >>> count_unique_pairs([-1, -2, -3, -4, -3], -6) 2 >>> count_unique_pairs([-1, 1, 2, 3, -2, 4, 0], 2) 3 >>> count_unique_pairs([1, 2, 2, 2, 3, 4], 5) 2 >>> count_unique_pairs([1000000000, -1000000000, 500000000, -500000000], 0) 2","solution":"def count_unique_pairs(arr, target): Returns the number of unique pairs of elements in the array that sum up to the target value. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def max_seats(n: int) -> int: Returns the maximum number of seats that can be placed on an n x n grid such that no two seats are adjacent horizontally, vertically, or diagonally. >>> max_seats(1) 1 >>> max_seats(2) 2 >>> max_seats(3) 5 >>> max_seats(4) 8 >>> max_seats(5) 13 >>> max_seats(10) 50 >>> max_seats(11) 61 def test_max_seats_1x1(): assert max_seats(1) == 1 def test_max_seats_2x2(): assert max_seats(2) == 2 def test_max_seats_3x3(): assert max_seats(3) == 5 def test_max_seats_4x4(): assert max_seats(4) == 8 def test_max_seats_5x5(): assert max_seats(5) == 13 def test_max_seats_even_grid(): assert max_seats(10) == 50 def test_max_seats_odd_grid(): assert max_seats(11) == 61","solution":"def max_seats(n): Returns the maximum number of seats that can be placed on an n x n grid such that no two seats are adjacent horizontally, vertically, or diagonally. if n == 1: return 1 return (n * n + 1) // 2"},{"question":"def convert_to_base26(n: int) -> str: Converts a positive integer n to a string representing the number in base 26 using the letters 'A' to 'Z'. >>> convert_to_base26(1) \\"A\\" >>> convert_to_base26(27) \\"AA\\" >>> convert_to_base26(703) \\"AAA\\" >>> convert_to_base26(702) \\"ZZ\\"","solution":"def convert_to_base26(n): Converts a positive integer n to a string representing the number in base 26 using the letters 'A' to 'Z'. if n <= 0: raise ValueError(\\"Input must be a positive integer\\") base26 = [] while n > 0: n -= 1 # Adjust for 0-indexed calculation base26.append(chr((n % 26) + ord('A'))) n //= 26 return ''.join(reversed(base26))"},{"question":"def min_coins(amount, coins): Returns the minimum number of coins needed to make the given amount with the provided coin denominations. If it is not possible to make the exact amount, returns -1. >>> min_coins(11, [1, 2, 5]) 3 >>> min_coins(3, [2]) -1","solution":"def min_coins(amount, coins): Returns the minimum number of coins needed to make the given amount with the provided coin denominations. If it is not possible to make the exact amount, returns -1. # Initialize the dp array with amount+1 (since this is more than any possible number of coins needed) dp = [amount + 1] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"def draw_triangle(h: int, c: str) -> str: Draws a right-aligned triangle with height \`h\` using character \`c\`. Parameters: h (int): The height of the triangle. c (str): The character used to draw the triangle. Returns: str: The drawn triangle as a string. Examples: >>> draw_triangle(4, '*') ' *n **n ***n****n' >>> draw_triangle(5, '#') ' #n n #n n#n' >>> draw_triangle(0, '@') '' >>> draw_triangle(1, '@') '@n' >>> draw_triangle(3, '') ' n nn' >>> draw_triangle(2, '*') ' *n**n' >>> draw_triangle(3, '#') ' #n n#n' >>> draw_triangle(-2, '*') ''","solution":"def draw_triangle(h: int, c: str) -> str: Draws a right-aligned triangle with height \`h\` using character \`c\`. Parameters: h (int): The height of the triangle. c (str): The character used to draw the triangle. Returns: str: The drawn triangle as a string. if h <= 0: return \\"\\" result = \\"\\" for i in range(1, h + 1): spaces = \\" \\" * (h - i) characters = c * i result += spaces + characters + \\"n\\" return result"},{"question":"from typing import List def find_substring_indices(s: str, words: List[str]) -> List[int]: Write a function that takes a string \`s\` and a list of words \`words\`, and returns the starting indices of all substrings in \`s\` that are the concatenation of each word in \`words\` exactly once. The order of words in the concatenation does not matter. >>> find_substring_indices(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) == [0, 9] >>> find_substring_indices(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) == [] >>> find_substring_indices(\\"barfoofoobarthefoobarman\\", [\\"bar\\", \\"foo\\", \\"the\\"]) == [6, 9, 12] >>> find_substring_indices(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"]) == [8] >>> find_substring_indices(\\"abcabcabc\\", [\\"abc\\", \\"abc\\"]) == [0, 3] >>> find_substring_indices(\\"aaaaaaaa\\", [\\"aa\\", \\"aa\\", \\"aa\\"]) == [0, 1, 2] >>> find_substring_indices(\\"\\", [\\"foo\\", \\"bar\\"]) == [] >>> find_substring_indices(\\"foobar\\", []) == []","solution":"def find_substring_indices(s, words): from collections import Counter if not s or not words or not words[0]: return [] word_length = len(words[0]) num_words = len(words) substring_length = word_length * num_words word_count = Counter(words) result = [] for i in range(len(s) - substring_length + 1): substring = s[i:i + substring_length] seen_words = [substring[j:j + word_length] for j in range(0, substring_length, word_length)] if Counter(seen_words) == word_count: result.append(i) return result"},{"question":"def common_elements(list1, list2): Write a function common_elements(list1, list2) that takes two lists as input and returns a list containing all the elements that appear in both lists. The returned list should have no duplicates and the elements can be in any order. Do not use any built-in Python set functions to solve this problem. Examples: >>> common_elements([1, 2, 2, 3, 4], [2, 3, 5]) [2, 3] >>> common_elements([5, 5, 5, 8, 8], [5, 8, 8, 8, 9]) [5, 8] >>> common_elements([1, 2, 3], [4, 5, 6]) [] pass # Your implementation here","solution":"def common_elements(list1, list2): Returns a list containing all the elements that appear in both lists without duplicates. result = [] seen = set() for item in list1: if item in list2 and item not in seen: result.append(item) seen.add(item) return result"},{"question":"class Matrix: A class representing a 2x2 matrix with elements a, b, c, and d. The matrix is represented as: | a b | | c d | Methods: multiply(self, other): Returns the product of this matrix and another matrix. Example: >>> m1 = Matrix(1, 2, 3, 4) >>> m2 = Matrix(5, 6, 7, 8) >>> m3 = m1.multiply(m2) >>> m3.a 19 >>> m3.b 22 >>> m3.c 43 >>> m3.d 50 def __init__(self, a, b, c, d): self.a = a self.b = b self.c = c self.d = d def multiply(self, other): pass # Implement matrix multiplication here # Unit tests def test_multiply_with_identity_matrix(): m1 = Matrix(1, 2, 3, 4) identity = Matrix(1, 0, 0, 1) result = m1.multiply(identity) assert result.a == 1 assert result.b == 2 assert result.c == 3 assert result.d == 4 def test_multiply_two_matrices(): m1 = Matrix(1, 2, 3, 4) m2 = Matrix(5, 6, 7, 8) result = m1.multiply(m2) assert result.a == 1*5 + 2*7 assert result.b == 1*6 + 2*8 assert result.c == 3*5 + 4*7 assert result.d == 3*6 + 4*8 def test_multiply_zero_matrix(): m1 = Matrix(1, 2, 3, 4) zero_matrix = Matrix(0, 0, 0, 0) result = m1.multiply(zero_matrix) assert result.a == 0 assert result.b == 0 assert result.c == 0 assert result.d == 0","solution":"class Matrix: def __init__(self, a, b, c, d): self.a = a self.b = b self.c = c self.d = d def multiply(self, other): a = self.a * other.a + self.b * other.c b = self.a * other.b + self.b * other.d c = self.c * other.a + self.d * other.c d = self.c * other.b + self.d * other.d return Matrix(a, b, c, d)"},{"question":"def find_pairs(nums: List[int], target: int) -> List[List[int]]: Find all unique pairs of integers in the list that sum up to the given target. Args: nums: A list of integers. target: An integer to which pairs of integers from nums should sum. Returns: A list of lists where each sublist contains a pair of integers that sum up to the given target. Examples: >>> find_pairs([1, 2, 3, 4, 5], 6) [[1, 5], [2, 4]] >>> find_pairs([3, 3, 3, 3], 6) [[3, 3]] >>> find_pairs([1, 1, 1, 2, 2, 3, 3], 4) [[1, 3], [2, 2]] >>> find_pairs([-1, 0, 1, 2, -1, -4], 1) [[-1, 2], [0, 1]]","solution":"def find_pairs(nums, target): Returns a list of unique pairs [a, b] such that a + b equals the given target. nums.sort() seen_pairs = set() result = [] left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: if (nums[left], nums[right]) not in seen_pairs: result.append([nums[left], nums[right]]) seen_pairs.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, else returns False. A prime number is a number that is greater than 1 and has no positive divisors other than 1 and itself. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def extract_sorted_primes(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list containing all the prime numbers from the original list. The returned list is sorted in ascending order.","solution":"def is_prime(n): Returns True if n is a prime number, else returns False. A prime number is a number that is greater than 1 and has no positive divisors other than 1 and itself. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False # other even numbers are not primes for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def extract_sorted_primes(lst): Takes a list of integers and returns a new list containing all the prime numbers from the original list. The returned list is sorted in ascending order. primes = [num for num in lst if is_prime(num)] return sorted(primes)"},{"question":"from typing import List def max_profit(prices: List[int]) -> List[int]: Write a function that receives a list of possible stock prices of a given item over a period of time, and decides the best day to buy and the best day to sell to maximize profit. The function should return a list containing the following information: - buy_day: the day to buy the stock (index in the list). - sell_day: the day to sell the stock (index in the list). - max_profit: the maximum possible profit (if no profit is possible, return 0). >>> max_profit([7, 1, 5, 3, 6, 4]) [1, 4, 5] >>> max_profit([7, 6, 4, 3, 1]) [0, 0, 0] >>> max_profit([2, 4, 1, 7, 5, 3, 6]) [2, 3, 6] pass # Test cases def test_max_profit_example1(): assert max_profit([7, 1, 5, 3, 6, 4]) == [1, 4, 5] def test_max_profit_example2(): assert max_profit([7, 6, 4, 3, 1]) == [0, 0, 0] def test_max_profit_example3(): assert max_profit([2, 4, 1, 7, 5, 3, 6]) == [2, 3, 6] def test_max_profit_all_increasing(): assert max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [0, 8, 8] def test_max_profit_all_decreasing(): assert max_profit([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [0, 0, 0] def test_max_profit_single_element(): assert max_profit([5]) == [0, 0, 0] def test_max_profit_two_elements_profit(): assert max_profit([1, 5]) == [0, 1, 4] def test_max_profit_no_possible_profit(): assert max_profit([5, 4, 3, 2, 1, 6]) == [4, 5, 5]","solution":"def max_profit(prices): n = len(prices) if n < 2: # You need at least two days for a valid transaction return [0, 0, 0] min_price = prices[0] buy_day = 0 sell_day = 0 max_profit = 0 for i in range(1, n): if prices[i] - min_price > max_profit: max_profit = prices[i] - min_price buy_day = prices.index(min_price) sell_day = i if prices[i] < min_price: min_price = prices[i] if max_profit == 0: return [0, 0, 0] return [buy_day, sell_day, max_profit]"},{"question":"import random def shuffle_deck(N: int) -> list: Shuffles a deck of cards numbered 1 to N using the Fisher-Yates shuffle algorithm. Args: N : int The number of cards in the deck. Returns: list : The shuffled deck of cards. # Your implementation here # Unit test cases def test_shuffle_deck_length(): N = 52 shuffled_deck = shuffle_deck(N) assert len(shuffled_deck) == N def test_shuffle_deck_contains_all_elements(): N = 52 shuffled_deck = shuffle_deck(N) assert set(shuffled_deck) == set(range(1, N + 1)) def test_shuffle_deck_randomness(): N = 52 shuffled_deck1 = shuffle_deck(N) shuffled_deck2 = shuffle_deck(N) # It's highly unlikely that two different shuffles are the same assert shuffled_deck1 != shuffled_deck2 def test_shuffle_deck_edge_case_1(): N = 1 shuffled_deck = shuffle_deck(N) assert shuffled_deck == [1] def test_shuffle_deck_edge_case_2(): N = 2 shuffled_deck = shuffle_deck(N) assert set(shuffled_deck) == {1, 2} assert len(shuffled_deck) == 2","solution":"import random def shuffle_deck(N: int) -> list: Shuffles a deck of cards numbered 1 to N using the Fisher-Yates shuffle algorithm. Args: N : int The number of cards in the deck. Returns: list : The shuffled deck of cards. deck = list(range(1, N + 1)) for i in range(N - 1, 0, -1): j = random.randint(0, i) deck[i], deck[j] = deck[j], deck[i] return deck"},{"question":"def move_robot(start, direction, steps): Moves the robot from its starting coordinates in the given direction by the given steps. Ensures the robot stops at the grid boundary if it tries to move outside the grid. Parameters: start (tuple): A tuple representing the starting coordinates of the robot (row, column). direction (str): A string representing the direction the robot should move (\\"up\\", \\"down\\", \\"left\\", \\"right\\"). steps (int): An integer representing the number of steps the robot should take in the given direction. Returns: tuple: The new coordinates of the robot after moving the given number of steps in the specified direction. >>> move_robot((2, 2), \\"up\\", 1) (1, 2) >>> move_robot((0, 0), \\"down\\", 3) (3, 0) >>> move_robot((4, 4), \\"left\\", 2) (4, 2) >>> move_robot((1, 1), \\"up\\", 3) (0, 1) >>> move_robot((3, 3), \\"right\\", 5) (3, 4)","solution":"def move_robot(start, direction, steps): Moves the robot from its starting coordinates in the given direction by the given steps. Ensures the robot stops at the grid boundary if it tries to move outside the grid. row, col = start if direction == \\"up\\": row = max(0, row - steps) elif direction == \\"down\\": row = min(4, row + steps) elif direction == \\"left\\": col = max(0, col - steps) elif direction == \\"right\\": col = min(4, col + steps) return (row, col)"},{"question":"from typing import List, Dict, Any def recommend_products(purchase_history: List[int], catalog: List[Dict[str, Any]]) -> List[int]: Creates a list of recommended product IDs based on a user’s purchase history and a catalog of products. Args: purchase_history (List[int]): List of product IDs that the user has already purchased. catalog (List[Dict[str, Any]]): List of products in the catalog, where each product is a dictionary containing: - product_id (int): ID of the product. - product_name (str): Name of the product. - recommended (List[int]): List of recommended product IDs. Returns: List[int]: List of recommended product IDs the user has not yet purchased. >>> recommend_products([101, 204, 305], [ ... {\\"product_id\\": 101, \\"product_name\\": \\"Olive Oil\\", \\"recommended\\": [102, 201]}, ... {\\"product_id\\": 204, \\"product_name\\": \\"Truffle Chips\\", \\"recommended\\": [301, 107]}, ... {\\"product_id\\": 305, \\"product_name\\": \\"Gourmet Chocolate\\", \\"recommended\\": [401, 102]} ... ]) [102, 201, 301, 107, 401] >>> recommend_products([101], [ ... {\\"product_id\\": 101, \\"product_name\\": \\"Olive Oil\\", \\"recommended\\": [101]} ... ]) [] # Your code here # Unit tests def test_recommend_products(): purchase_history = [101, 204, 305] catalog = [ {\\"product_id\\": 101, \\"product_name\\": \\"Olive Oil\\", \\"recommended\\": [102, 201]}, {\\"product_id\\": 204, \\"product_name\\": \\"Truffle Chips\\", \\"recommended\\": [301, 107]}, {\\"product_id\\": 305, \\"product_name\\": \\"Gourmet Chocolate\\", \\"recommended\\": [401, 102]} ] expected = [102, 201, 301, 107, 401] result = recommend_products(purchase_history, catalog) assert sorted(result) == sorted(expected) def test_no_recommendations(): purchase_history = [101] catalog = [ {\\"product_id\\": 101, \\"product_name\\": \\"Olive Oil\\", \\"recommended\\": [101]} ] expected = [] result = recommend_products(purchase_history, catalog) assert result == expected def test_no_purchase_history(): purchase_history = [] catalog = [ {\\"product_id\\": 101, \\"product_name\\": \\"Olive Oil\\", \\"recommended\\": [102, 201]}, {\\"product_id\\": 204, \\"product_name\\": \\"Truffle Chips\\", \\"recommended\\": [301, 107]}, {\\"product_id\\": 305, \\"product_name\\": \\"Gourmet Chocolate\\", \\"recommended\\": [401, 102]} ] expected = [] result = recommend_products(purchase_history, catalog) assert result == expected def test_recommend_duplicate_removal(): purchase_history = [101, 204] catalog = [ {\\"product_id\\": 101, \\"product_name\\": \\"Olive Oil\\", \\"recommended\\": [102, 201, 301]}, {\\"product_id\\": 204, \\"product_name\\": \\"Truffle Chips\\", \\"recommended\\": [301, 107]}, ] expected = [102, 201, 301, 107] result = recommend_products(purchase_history, catalog) assert sorted(result) == sorted(expected) def test_all_recommendations_purchased(): purchase_history = [101, 102, 201, 204] catalog = [ {\\"product_id\\": 101, \\"product_name\\": \\"Olive Oil\\", \\"recommended\\": [102, 201]}, {\\"product_id\\": 204, \\"product_name\\": \\"Truffle Chips\\", \\"recommended\\": [102, 201]}, ] expected = [] result = recommend_products(purchase_history, catalog) assert result == expected","solution":"from typing import List, Dict, Any def recommend_products(purchase_history: List[int], catalog: List[Dict[str, Any]]) -> List[int]: recommended_set = set() for product in catalog: if product['product_id'] in purchase_history: for recommendation in product['recommended']: if recommendation not in purchase_history: recommended_set.add(recommendation) return list(recommended_set)"},{"question":"def find_unsorted_subarray(nums: List[int]) -> int: Given a list of integers nums, find the length of the shortest subarray, that when sorted, makes the entire list sorted in non-decreasing order. Return the length of the shortest subarray. >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) == 5 >>> find_unsorted_subarray([1, 2, 3, 4]) == 0 >>> find_unsorted_subarray([1, 3, 2, 2, 2]) == 4 from solution import find_unsorted_subarray def test_sorted_list(): assert find_unsorted_subarray([1, 2, 3, 4]) == 0 def test_example_1(): assert find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) == 5 def test_example_2(): assert find_unsorted_subarray([1, 3, 2, 2, 2]) == 4 def test_single_element(): assert find_unsorted_subarray([1]) == 0 def test_reversed_list(): assert find_unsorted_subarray([5, 4, 3, 2, 1]) == 5 def test_partially_sorted_list(): assert find_unsorted_subarray([1, 2, 3, 5, 4]) == 2 def test_already_sorted_list_with_duplicates(): assert find_unsorted_subarray([1, 1, 1, 1]) == 0 def test_unsorted_middle(): assert find_unsorted_subarray([1, 3, 5, 4, 2, 6, 7]) == 4","solution":"def find_unsorted_subarray(nums): Returns the length of the shortest subarray, that when sorted, makes the entire list sorted in non-decreasing order. n = len(nums) if n <= 1: return 0 start, end = -1, -1 max_val, min_val = float('-inf'), float('inf') for i in range(n): if nums[i] < max_val: end = i else: max_val = nums[i] for i in range(n-1, -1, -1): if nums[i] > min_val: start = i else: min_val = nums[i] if start == -1: return 0 else: return end - start + 1"},{"question":"def longest_subarray_with_sum_at_most_x(n, arr, x): Returns the length of the longest subarray with sum less than or equal to x. >>> longest_subarray_with_sum_at_most_x(5, [1, 2, 3, 4, 5], 10) 4 >>> longest_subarray_with_sum_at_most_x(4, [1, 2, 3, 4], 10) 4 >>> longest_subarray_with_sum_at_most_x(5, [6, 7, 8, 9, 10], 5) 0 >>> longest_subarray_with_sum_at_most_x(5, [1, 2, 3, 4, 5], 1) 1 >>> longest_subarray_with_sum_at_most_x(6, [4, 1, 1, 1, 2, 3], 5) 4 >>> longest_subarray_with_sum_at_most_x(1, [10000], 10000) 1 >>> longest_subarray_with_sum_at_most_x(1, [10000], 9999) 0 pass def solve(subarrays): Processes all the test cases and returns the results. >>> test_cases = [ ... (5, [1, 2, 3, 4, 5], 10), ... (4, [1, 2, 3, 4], 10), ... (5, [6, 7, 8, 9, 10], 5), ... (5, [1, 2, 3, 4, 5], 1), ... (6, [4, 1, 1, 1, 2, 3], 5) ... ] >>> results = solve(test_cases) >>> expected_results = [4, 4, 0, 1, 4] >>> assert results == expected_results pass","solution":"def longest_subarray_with_sum_at_most_x(n, arr, x): Returns the length of the longest subarray with sum less than or equal to x. start = 0 current_sum = 0 max_length = 0 for end in range(n): current_sum += arr[end] while current_sum > x and start <= end: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length def solve(subarrays): Processes all the test cases and returns the results. results = [] for case in subarrays: n, arr, x = case results.append(longest_subarray_with_sum_at_most_x(n, arr, x)) return results"},{"question":"def factorial(n: int) -> int: Calculate the factorial of a non-negative integer n. If the input is negative, return None. >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(-3) None","solution":"def factorial(n): Returns the factorial of a non-negative integer n. If n is negative, returns None. if n < 0: return None elif n == 0: return 1 else: result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"from typing import List, Optional def first_recurring_number(arr: List[int]) -> Optional[int]: Returns the first recurring number in the array. If no recurring number is found, return None. >>> first_recurring_number([1, 2, 3, 4, 5]) == None >>> first_recurring_number([1, 1, 2, 3, 4]) == 1 >>> first_recurring_number([1, 2, 3, 2, 1]) == 2 >>> first_recurring_number([3, 5, 4, 3]) == 3 >>> first_recurring_number([2, 5, 1, 2, 3, 5, 1]) == 2 >>> first_recurring_number([]) == None >>> first_recurring_number([1]) == None >>> first_recurring_number([1, 2, 1, 2, 1, 2]) == 1 pass # Your implementation goes here","solution":"def first_recurring_number(arr): Returns the first recurring number in the array. If no recurring number is found, return None. seen = set() for num in arr: if num in seen: return num seen.add(num) return None"},{"question":"def expandString(s: str) -> str: Expands a compressed string where characters are followed by digits indicating repetitions. >>> expandString('a3b2c4d1') == 'aaabbccccd' >>> expandString('x1y5z2a3') == 'xyyyyyzzaaa' >>> expandString('a1') == 'a' >>> expandString('b5') == 'bbbbb' >>> expandString('a5a2a1') == 'aaaaaaa' >>> expandString('a10b12') == 'a' * 10 + 'b' * 12 >>> expandString('x100z1000') == 'x' * 100 + 'z' * 1000 >>> expandString('a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z1') == 'abcdefghijklmnopqrstuvwxyz' >>> expandString('a1b2c3d4') == 'abbcccdddd' >>> expandString('a2b1c3d2') == 'aabcccdd'","solution":"def expandString(s): Expands a compressed string where characters are followed by digits indicating repetitions. Args: s (str): The compressed string in the format \\"char_digit\\". Returns: str: The expanded string. expanded_string = [] i = 0 while i < len(s): char = s[i] num = 0 # Move to the next character which should be a digit i += 1 while i < len(s) and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 expanded_string.append(char * num) return \\"\\".join(expanded_string)"},{"question":"def findLongestWord(s: str) -> str: Returns the longest word in a given string of space-separated words. If multiple words have the maximum length, the first one encountered is returned. >>> findLongestWord(\\"The quick brown fox jumped over the lazy dogs\\") \\"jumped\\" >>> findLongestWord(\\"To be or not to be that is the question\\") \\"question\\"","solution":"def findLongestWord(s): Returns the longest word in a given string of space-separated words. If multiple words have the maximum length, the first one encountered is returned. words = s.split() longest_word = \\"\\" max_length = 0 for word in words: if len(word) > max_length: longest_word = word max_length = len(word) return longest_word"},{"question":"def is_palindrome(s: str) -> str: Write a function that takes a string as input and determines whether it is a valid palindrome, ignoring non-alphanumeric characters and case sensitivity. A palindrome is a string that reads the same backward as forward. Parameters: s (str): Input string Returns: str: \\"YES\\" if the string is a palindrome, otherwise \\"NO\\" >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") \\"YES\\" >>> is_palindrome(\\"Hello, World!\\") \\"NO\\"","solution":"def is_palindrome(s): Checks if the input string is a palindrome, ignoring non-alphanumeric characters and case sensitivity. Parameters: s (str): Input string Returns: str: \\"YES\\" if the string is a palindrome, otherwise \\"NO\\" # Removing non-alphanumeric characters and converting to lower case filtered_str = ''.join(char.lower() for char in s if char.isalnum()) # Checking if the filtered string is equal to its reverse return \\"YES\\" if filtered_str == filtered_str[::-1] else \\"NO\\""},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Function to return the length of the longest increasing subsequence in an array of integers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1","solution":"def longest_increasing_subsequence(arr): Function to return the length of the longest increasing subsequence in an array of integers. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] represents the length of LIS ending at index i for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def has_pair_with_sum(lst: List[int], target: int) -> str: Determines if there are two distinct numbers in the list that add up to the target sum. >>> has_pair_with_sum([2, 7, 11, 15, 1], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 10) \\"NO\\" >>> has_pair_with_sum([-1, -2, 3, 5], 1) \\"YES\\" >>> has_pair_with_sum([-1, -2, -3, -4], -10) \\"NO\\" >>> has_pair_with_sum([0, 1, 2, 3, -1], 0) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 0) \\"NO\\" >>> has_pair_with_sum([10**9, 10**9, -10**9], 0) \\"YES\\" >>> has_pair_with_sum([10**9], 10**9) \\"NO\\" >>> has_pair_with_sum([1, 1, 1, 1], 2) \\"YES\\" >>> has_pair_with_sum([1, 1, 1, 1], 3) \\"NO\\"","solution":"def has_pair_with_sum(lst, target): Determines if there are two distinct numbers in the list that add up to the target sum. Parameters: lst (list of int): List of integers. target (int): The target sum. Returns: str: \\"YES\\" if a pair exists that adds up to the target sum, otherwise \\"NO\\". seen = set() for number in lst: if target - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def calculate_total_value(coins: List[str]) -> int: Calculate the total value of a collection of coins. The rules are: 1. Each Bronze coin is worth 1 point. 2. Each Silver coin is worth 4 points. 3. Each Gold coin is worth 10 points. 4. For every 3 Bronze coins, one additional point is added to the total. 5. For every 2 Silver coins, one additional point is added to the total. 6. For every Gold coin, 2 additional points are added to the total. Input: coins : List[str] : An array of strings representing a type of coin. Case insensitive. Output: int : The total value of the coins. Example: >>> calculate_total_value(['Gold', 'Bronze', 'Silver', 'Bronze', 'Gold', 'Silver', 'Bronze']) 37 >>> calculate_total_value([]) 0 >>> calculate_total_value(['Gold', 'Gold', 'Gold', 'Gold', 'Gold']) 60 >>> calculate_total_value(['Silver', 'Silver', 'Silver', 'Silver', 'Silver']) 22 >>> calculate_total_value(['bronze', 'silver', 'gold']) 17","solution":"def calculate_total_value(coins): bronze_count = sum(1 for coin in coins if coin.lower() == 'bronze') silver_count = sum(1 for coin in coins if coin.lower() == 'silver') gold_count = sum(1 for coin in coins if coin.lower() == 'gold') # Points calculation bronze_points = bronze_count + (bronze_count // 3) silver_points = silver_count * 4 + (silver_count // 2) gold_points = gold_count * 10 + gold_count * 2 return bronze_points + silver_points + gold_points"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Returns True if the array contains duplicate elements within k distance of each other. Example 1: >>> contains_nearby_duplicate([1, 2, 3, 1], 3) True Example 2: >>> contains_nearby_duplicate([1, 0, 1, 1], 1) True Example 3: >>> contains_nearby_duplicate([1, 2, 3, 4], 2) False Arg: nums (list of int): List of integers. k (int): The maximum distance. Returns: bool: True if there are duplicates within k distance, False otherwise.","solution":"def contains_nearby_duplicate(nums, k): Returns True if the array contains duplicate elements within k distance of each other. Args: nums (list of int): List of integers. k (int): The maximum distance. Returns: bool: True if there are duplicates within k distance, False otherwise. seen = {} for i, num in enumerate(nums): if num in seen and i - seen[num] <= k: return True seen[num] = i return False"},{"question":"def letter_histogram(text: str) -> dict: Takes a string input and returns a dictionary with the count of each letter. The function ignores case and only counts alphabetic characters. >>> letter_histogram(\\"Hello World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> letter_histogram(\\"Python 3.8\\") {'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1} >>> letter_histogram(\\"LooK! At The Cats\\") {'l': 1, 'o': 2, 'k': 1, 'a': 2, 't': 3, 'h': 1, 'e': 1, 'c': 1, 's': 1} >>> letter_histogram(\\"\\") {} >>> letter_histogram(\\"123456!@#%\\") {} >>> letter_histogram(\\"aaaAAA\\") {'a': 6} >>> letter_histogram(\\"The quick brown fox jumps over the lazy dog\\") { 't': 2, 'h': 2, 'e': 3, 'q': 1, 'u': 2, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 2, 'o': 4, 'w': 1, 'n': 1, 'f': 1, 'x': 1, 'j': 1, 'm': 1, 'p': 1, 's': 1, 'v': 1, 'l': 1, 'a': 1, 'z': 1, 'y': 1, 'd': 1, 'g': 1 }","solution":"def letter_histogram(text): Takes a string input and returns a dictionary with the count of each letter. The function ignores case and only counts alphabetic characters. histogram = {} for char in text.lower(): if char.isalpha(): if char in histogram: histogram[char] += 1 else: histogram[char] = 1 return histogram"},{"question":"def trap_water(height): Given an array of positive integers representing the elevation map where the width of each bar is 1, computes the total water trapped after raining. >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_water([1,2,3,4,5]) 0 >>> trap_water([5,4,3,2,1]) 0 >>> trap_water([3, 0, 3]) 3 >>> trap_water([3, 3, 3, 3]) 0 >>> trap_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_water([1]) 0 >>> trap_water([1, 2]) 0 >>> trap_water([1, 0, 1]) 1","solution":"def trap_water(height): Given an array of positive integers representing the elevation map where the width of each bar is 1, computes the total water trapped after raining. :param height: List[int] : A list of positive integers representing elevation levels :return: int : The total units of water that can be trapped if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def reverse_string(s): Returns the reverse of the input string s. If the input is not a string, returns None. >>> reverse_string(\\"hello\\") == \\"olleh\\" >>> reverse_string(\\"\\") == \\"\\" >>> reverse_string(\\"a\\") == \\"a\\" >>> reverse_string(\\"12345\\") == \\"54321\\" >>> reverse_string(\\"!@#%\\") == \\"%#@!\\" >>> reverse_string(\\"a1b2c3\\") == \\"3c2b1a\\" >>> reverse_string(12345) == None >>> reverse_string(['a', 'b', 'c']) == None >>> reverse_string({'key': 'value'}) == None >>> reverse_string(None) == None","solution":"def reverse_string(s): Returns the reverse of the input string s. If the input is not a string, returns None. if not isinstance(s, str): return None return s[::-1]"},{"question":"def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string \`s\`. Args: s (str): A string consisting of lowercase English letters. Returns: str: The longest palindromic substring in \`s\`. Examples: >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"ac\\") in [\\"a\\", \\"c\\"]","solution":"def longest_palindromic_substring(s): Finds the longest palindromic substring in the given string \`s\`. Args: s (str): A string consisting of lowercase English letters. Returns: str: The longest palindromic substring in \`s\`. if not s: return \\"\\" n = len(s) start = 0 end = 0 def expand_from_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): # Odd length palindromes left1, right1 = expand_from_center(i, i) if right1 - left1 > end - start: start, end = left1, right1 # Even length palindromes left2, right2 = expand_from_center(i, i+1) if right2 - left2 > end - start: start, end = left2, right2 return s[start:end+1]"},{"question":"def move_zeros(nums: list) -> list: Reorganize the list such that all zeros are moved to the end while keeping the order of non-zero elements the same. >>> move_zeros([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeros([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> move_zeros([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0] >>> move_zeros([1, 2, 3, 0, 0]) [1, 2, 3, 0, 0] >>> move_zeros([0, 0, 1, 2, 0, 3, 0, 4, 0]) [1, 2, 3, 4, 0, 0, 0, 0, 0] >>> move_zeros([7, 8, 9, 10]) [7, 8, 9, 10]","solution":"def move_zeros(nums): Reorganize the list such that all zeros are moved to the end while keeping the order of non-zero elements the same. Parameters: nums (list): A list of integers. Returns: list: The reordered list. non_zero_elements = [num for num in nums if num != 0] zero_count = nums.count(0) return non_zero_elements + [0] * zero_count"},{"question":"def remove_duplicates_and_sort(nums: List[int]) -> List[int]: Returns a new list that contains the elements of the original list sorted in non-decreasing order, with all duplicate elements removed. >>> remove_duplicates_and_sort([4, 2, 5, 1, 3, 2, 4]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([10, 9, 8, 10, 9, 9, 7]) [7, 8, 9, 10] >>> remove_duplicates_and_sort([1]) [1]","solution":"def remove_duplicates_and_sort(nums): Returns a new sorted list with duplicates removed from the original list. def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) sorted_nums = quicksort(nums) unique_sorted_nums = [] for num in sorted_nums: if not unique_sorted_nums or unique_sorted_nums[-1] != num: unique_sorted_nums.append(num) return unique_sorted_nums"},{"question":"def max_time_difference(production_times): Returns the maximum time difference between the fastest and slowest widget in the batch. >>> max_time_difference([3, 8, 1, 9, 7]) == 8 >>> max_time_difference([15, 22, 11, 23, 16]) == 12 >>> max_time_difference([5]) == 0 >>> max_time_difference([1, 1000]) == 999 >>> max_time_difference([5, 5, 5]) == 0 >>> max_time_difference([1, 2, 3, 4, 5]) == 4 >>> max_time_difference([5, 4, 3, 2, 1]) == 4 >>> max_time_difference([]) == 0","solution":"def max_time_difference(production_times): Returns the maximum time difference between the fastest and slowest widget in the batch. if not production_times: return 0 # if the list is empty, return 0 as there is no time difference min_time = min(production_times) max_time = max(production_times) return max_time - min_time"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") == 3 >>> longest_unique_substring(\\"bbbbb\\") == 1 >>> longest_unique_substring(\\"pwwkew\\") == 3 >>> longest_unique_substring(\\" \\") == 1 >>> longest_unique_substring(\\"\\") == 0 >>> longest_unique_substring(\\"abcdef\\") == 6 >>> longest_unique_substring(\\"a!b@c#d\\") == 8 >>> longest_unique_substring(\\"abccbaabccba\\") == 3","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest_length = max(longest_length, i - start + 1) return longest_length"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Calculate the largest rectangle in a histogram given by the heights array. :param heights: List[int], heights representing the histogram bars. :return: int, the area of the largest rectangle. >>> largestRectangleArea([2,1,5,6,2,3]) 10 >>> largestRectangleArea([2,4]) 4 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([3,3,3,3,3]) 15 >>> largestRectangleArea([5,4,3,2,1]) 9 >>> largestRectangleArea([1,2,3,4,5]) 9 >>> largestRectangleArea([2,1,2,3,1]) 5","solution":"def largestRectangleArea(heights): Calculate the largest rectangle in a histogram given by the heights array. :param heights: List[int], heights representing the histogram bars. :return: int, the area of the largest rectangle. stack = [] # stack will store the indices of the heights array max_area = 0 # variable to store the maximum area index = 0 # index to traverse the heights array while index < len(heights): # If stack is empty or the new height is greater than or equal to the height at stack top if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Calculate area with heights[stack.pop()] as the smallest height top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def cumulative_sum(nums: List[int]) -> List[int]: Takes a list of integers as input, and returns a new list where each integer is replaced by the sum of itself and all previous integers in the list. >>> cumulative_sum([1, 2, 3]) [1, 3, 6] >>> cumulative_sum([4, -1, 2]) [4, 3, 5] >>> cumulative_sum([0, 0, 0]) [0, 0, 0] >>> cumulative_sum([]) [] >>> cumulative_sum([5]) [5] >>> cumulative_sum([1, -1, 1, -1]) [1, 0, 1, 0]","solution":"def cumulative_sum(nums): Returns a new list where each integer is replaced by the sum of itself and all previous integers in the list. result = [] current_sum = 0 for num in nums: current_sum += num result.append(current_sum) return result"},{"question":"def subarray_with_sum_exists(N, S, beauty_scores): Determines if there exists a contiguous subarray with a sum equals to S. Parameters: N (int): Number of paintings. S (int): Desired sum of beauty scores. beauty_scores (list of int): List of integers representing the beauty scores. Returns: str: 'YES' if such a subarray exists, otherwise 'NO'. >>> subarray_with_sum_exists(5, 7, [1, 2, 3, 4, 5]) \\"YES\\" >>> subarray_with_sum_exists(4, 10, [-1, 3, 5, -3]) \\"NO\\"","solution":"def subarray_with_sum_exists(N, S, beauty_scores): Determines if there exists a contiguous subarray with a sum equals to S. Parameters: N (int): Number of paintings. S (int): Desired sum of beauty scores. beauty_scores (list of int): List of integers representing the beauty scores. Returns: str: 'YES' if such a subarray exists, otherwise 'NO'. current_sum = 0 prefix_sums = {0} for score in beauty_scores: current_sum += score if (current_sum - S) in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\""},{"question":"def numDistinctIslands(grid): Returns the number of distinct islands in a binary matrix grid. >>> grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1] ] >>> numDistinctIslands(grid) == 1 >>> grid = [ [1, 1, 0, 0, 1], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1] ] >>> numDistinctIslands(grid) == 2","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in a binary matrix grid. def dfs(x, y, direction): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 shape_signature.append(direction) dfs(x + 1, y, 'd') # down dfs(x - 1, y, 'u') # up dfs(x, y + 1, 'r') # right dfs(x, y - 1, 'l') # left shape_signature.append('b') # backtracking distinct_shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape_signature = [] dfs(i, j, 'o') # origin distinct_shapes.add(tuple(shape_signature)) return len(distinct_shapes)"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, False otherwise. A palindrome reads the same forward and backward, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"!!!@@@\\") == True","solution":"def is_palindrome(s): Returns True if the input string s is a palindrome, False otherwise. A palindrome reads the same forward and backward, ignoring spaces, punctuation, and capitalization. import re # Remove non-alphanumeric characters and convert to lower case clean_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return clean_s == clean_s[::-1]"},{"question":"from typing import List, Tuple def count_ways_to_reach_calories(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the number of ways Chef can achieve the target calorie count using the given ingredients. The inputs are as follows: T: The number of test cases. test_cases: A list of tuples where each tuple contains: - A tuple with two integers: N (number of ingredients) and C (target calorie count). - A list of N integers representing the calorie values of the ingredients. Returns: - A list of integers, where each value represents the number of ways to reach the target calorie count for each test case. >>> count_ways_to_reach_calories(2, [((3, 7), [2, 3, 5]), ((4, 10), [2, 5, 3, 6])]) [2, 5] >>> count_ways_to_reach_calories(1, [((1, 10), [2])]) [1] >>> count_ways_to_reach_calories(1, [((3, 10), [1, 5, 10])]) [4] >>> count_ways_to_reach_calories(1, [((3, 0), [1, 2, 3])]) [1] >>> count_ways_to_reach_calories(1, [((4, 1000), [1, 2, 5, 10])]) # This example will have a large output value. [positive number greater than 0]","solution":"def count_ways_to_reach_calories(T, test_cases): def count_ways(N, C, calories): dp = [0] * (C + 1) dp[0] = 1 # There's one way to make 0 calories, by choosing no ingredients. for cal in calories: for i in range(cal, C + 1): dp[i] += dp[i - cal] return dp[C] results = [] for i in range(T): N, C = test_cases[i][0] calories = test_cases[i][1] result = count_ways(N, C, calories) results.append(result) return results"},{"question":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2 to 9 inclusive, return all possible letter combinations that the number could represent following the mapping of digits to letters on a telephone keypad. 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" The function should return all possible combinations in lexicographical order. You may assume that the input string is non-empty and the digits are valid. >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"92\\") [\\"wa\\", \\"wb\\", \\"wc\\", \\"xa\\", \\"xb\\", \\"xc\\", \\"ya\\", \\"yb\\", \\"yc\\", \\"za\\", \\"zb\\", \\"zc\\"] pass def test_letter_combinations_empty_input(): assert letter_combinations(\\"\\") == [] def test_letter_combinations_single_digit(): assert letter_combinations(\\"2\\") == [\\"a\\", \\"b\\", \\"c\\"] def test_letter_combinations_two_digits(): assert letter_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] def test_letter_combinations_three_digits(): assert letter_combinations(\\"234\\") == [ \\"adg\\", \\"adh\\", \\"adi\\", \\"aeg\\", \\"aeh\\", \\"aei\\", \\"afg\\", \\"afh\\", \\"afi\\", \\"bdg\\", \\"bdh\\", \\"bdi\\", \\"beg\\", \\"beh\\", \\"bei\\", \\"bfg\\", \\"bfh\\", \\"bfi\\", \\"cdg\\", \\"cdh\\", \\"cdi\\", \\"ceg\\", \\"ceh\\", \\"cei\\", \\"cfg\\", \\"cfh\\", \\"cfi\\" ] def test_letter_combinations_four_digits(): assert letter_combinations(\\"5678\\") == [ \\"jmpt\\", \\"jmpu\\", \\"jmpv\\", \\"jmqt\\", \\"jmqu\\", \\"jmqv\\", \\"jmrt\\", \\"jmru\\", \\"jmrv\\", \\"jmst\\", \\"jmsu\\", \\"jmsv\\", \\"jnpt\\", \\"jnpu\\", \\"jnpv\\", \\"jnqt\\", \\"jnqu\\", \\"jnqv\\", \\"jnrt\\", \\"jnru\\", \\"jnrv\\", \\"jnst\\", \\"jnsu\\", \\"jnsv\\", \\"jopt\\", \\"jopu\\", \\"jopv\\", \\"joqt\\", \\"joqu\\", \\"joqv\\", \\"jort\\", \\"joru\\", \\"jorv\\", \\"jost\\", \\"josu\\", \\"josv\\", \\"kmpt\\", \\"kmpu\\", \\"kmpv\\", \\"kmqt\\", \\"kmqu\\", \\"kmqv\\", \\"kmrt\\", \\"kmru\\", \\"kmrv\\", \\"kmst\\", \\"kmsu\\", \\"kmsv\\", \\"knpt\\", \\"knpu\\", \\"knpv\\", \\"knqt\\", \\"knqu\\", \\"knqv\\", \\"knrt\\", \\"knru\\", \\"knrv\\", \\"knst\\", \\"knsu\\", \\"knsv\\", \\"kopt\\", \\"kopu\\", \\"kopv\\", \\"koqt\\", \\"koqu\\", \\"koqv\\", \\"kort\\", \\"koru\\", \\"korv\\", \\"kost\\", \\"kosu\\", \\"kosv\\", \\"lmpt\\", \\"lmpu\\", \\"lmpv\\", \\"lmqt\\", \\"lmqu\\", \\"lmqv\\", \\"lmrt\\", \\"lmru\\", \\"lmrv\\", \\"lmst\\", \\"lmsu\\", \\"lmsv\\", \\"lnpt\\", \\"lnpu\\", \\"lnpv\\", \\"lnqt\\", \\"lnqu\\", \\"lnqv\\", \\"lnrt\\", \\"lnru\\", \\"lnrv\\", \\"lnst\\", \\"lnsu\\", \\"lnsv\\", \\"lopt\\", \\"lopu\\", \\"lopv\\", \\"loqt\\", \\"loqu\\", \\"loqv\\", \\"lort\\", \\"loru\\", \\"lorv\\", \\"lost\\", \\"losu\\", \\"losv\\" ] def test_letter_combinations_mixed_digits(): assert letter_combinations(\\"92\\") == [\\"wa\\", \\"wb\\", \\"wc\\", \\"xa\\", \\"xb\\", \\"xc\\", \\"ya\\", \\"yb\\", \\"yc\\", \\"za\\", \\"zb\\", \\"zc\\"] if __name__ == \\"__main__\\": test_letter_combinations_empty_input() test_letter_combinations_single_digit() test_letter_combinations_two_digits() test_letter_combinations_three_digits() test_letter_combinations_four_digits() test_letter_combinations_mixed_digits()","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: if not digits: return [] mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return possible_letters = mapping[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"def reverseWords(sentence: str) -> str: Reverse the order of words in a given sentence while preserving the original spacing. Args: sentence (str): The input sentence containing words separated by spaces. Returns: str: The sentence with the words reversed in order, preserving the original spacing. Examples: >>> reverseWords(\\"Hello world!\\") \\"world! Hello\\" >>> reverseWords(\\" The sky is blue \\") \\" blue is sky The \\" >>> reverseWords(\\"Hello world!\\") \\"world! Hello\\" >>> reverseWords(\\"\\") \\"\\" >>> reverseWords(\\"Hello\\") \\"Hello\\" >>> reverseWords(\\" This is a test \\") \\" test a is This \\" >>> reverseWords(\\" Hello world! \\") \\" world! Hello \\" >>> reverseWords(\\"Hello, World!\\") \\"World! Hello,\\" >>> reverseWords(\\"Is it rainy today? No, it's sunny!\\") \\"sunny! it's No, today? rainy it Is\\"","solution":"def reverseWords(sentence): Reverse the order of words in a given sentence while preserving the original spacing. words = sentence.split(' ') reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def calculate_power_sums(n: int) -> int: Write a function \`calculate_power_sums(n)\` that takes a positive integer \`n\` and returns the number of distinct sums obtained by adding the cubes of any two distinct positive integers such that both integers are less than or equal to \`n\`. For example: >>> calculate_power_sums(2) -----> 1 >>> calculate_power_sums(3) ------> 3 >>> calculate_power_sums(4) ------> 6","solution":"def calculate_power_sums(n): distinct_sums = set() for i in range(1, n): for j in range(i + 1, n + 1): power_sum = i**3 + j**3 distinct_sums.add(power_sum) return len(distinct_sums)"},{"question":"from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Given an integer array nums and an integer k, return the k-th largest element in the array. Note that it is the k-th largest element in sorted order, not the k-th distinct element. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([1, 2, 3, 4, 5, 6, 7], 5) 3 >>> find_kth_largest([7, 6, 5, 4, 3, 2, 1], 1) 7 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([10, 9, 8, 7, 6, 5], 6) 5 >>> find_kth_largest([-1, -2, -3, -4, -5], 3) -3","solution":"def find_kth_largest(nums, k): Finds the k-th largest element in the array nums. nums.sort(reverse=True) return nums[k-1]"},{"question":"def highest_uniqueness_score(n: int, m: int, cells: List[List[int]]) -> int: Finds the cell type with the highest uniqueness score. Args: n (int): The number of properties each cell type has. m (int): The number of cell types. cells (list of list of int): A list of cell types, each represented by a list of properties. Returns: int: The 1-based index of the cell type with the highest uniqueness score. Examples: >>> highest_uniqueness_score(4, 3, [[1, 2, 3, 4], [3, 3, 3, 3], [0, 1, 2, 1]]) 1 >>> highest_uniqueness_score(5, 2, [[0, 0, 0, 0, 0], [0, 1, 2, 3, 4]]) 2 # Unit test for the function def test_highest_uniqueness_score(): assert highest_uniqueness_score(4, 3, [[1, 2, 3, 4], [3, 3, 3, 3], [0, 1, 2, 1]]) == 1 assert highest_uniqueness_score(5, 2, [[0, 0, 0, 0, 0], [0, 1, 2, 3, 4]]) == 2 assert highest_uniqueness_score(3, 3, [[1, 1, 1], [2, 2, 2], [3, 3, 3]]) == 1 assert highest_uniqueness_score(3, 3, [[3, 1, 2], [1, 2, 3], [0, 0, 0]]) == 1 assert highest_uniqueness_score(4, 4, [[1, 2, 2, 3], [3, 3, 3, 3], [1, 2, 1, 2], [0, 0, 1, 1]]) == 1 # Running the tests test_highest_uniqueness_score()","solution":"def highest_uniqueness_score(n, m, cells): Finds the cell type with the highest uniqueness score. Args: n (int): The number of properties each cell type has. m (int): The number of cell types. cells (list of list of int): A list of cell types, each represented by a list of properties. Returns: int: The 1-based index of the cell type with the highest uniqueness score. max_unique_score = -1 best_cell_index = -1 for index, cell in enumerate(cells): unique_score = len(set(cell)) if unique_score > max_unique_score: max_unique_score = unique_score best_cell_index = index + 1 return best_cell_index"},{"question":"def num_ways_to_paint_fence(n: int, k: int) -> int: Returns the number of ways to paint the fence such that no more than two adjacent fence posts have the same color. Parameters: n (int): Number of fence posts k (int): Number of colors Returns: int: Number of ways to paint the fence >>> num_ways_to_paint_fence(3, 2) 6 >>> num_ways_to_ppaint_fence(4, 3) 66","solution":"def num_ways_to_paint_fence(n, k): Returns the number of ways to paint the fence such that no more than two adjacent fence posts have the same color. Parameters: n (int): Number of fence posts k (int): Number of colors Returns: int: Number of ways to paint the fence if n == 0 or k == 0: return 0 if n == 1: return k if n == 2: return k * k same_color_ways = k diff_color_ways = k * (k - 1) total_ways = same_color_ways + diff_color_ways for i in range(3, n + 1): same_color_ways = diff_color_ways diff_color_ways = total_ways * (k - 1) total_ways = same_color_ways + diff_color_ways return total_ways"},{"question":"def replace_mugwump(sequence: str, m: str, n: str) -> str: Replaces every occurrence of the digit 'm' in the 'sequence' with the digit 'n'. Parameters: sequence (str): The original sequence of digits as a string. m (str): The digit to be replaced. n (str): The digit to replace with. Returns: str: The modified sequence with all occurrences of 'm' replaced with 'n'. Examples: >>> replace_mugwump(\\"356783\\", \\"3\\", \\"9\\") \\"956789\\" >>> replace_mugwump(\\"556091\\", \\"5\\", \\"2\\") \\"226091\\" >>> replace_mugwump(\\"123456\\", \\"0\\", \\"8\\") \\"123456\\"","solution":"def replace_mugwump(sequence: str, m: str, n: str) -> str: Replaces every occurrence of the digit 'm' in the 'sequence' with the digit 'n'. Parameters: sequence (str): The original sequence of digits as a string. m (str): The digit to be replaced. n (str): The digit to replace with. Returns: str: The modified sequence with all occurrences of 'm' replaced with 'n'. return sequence.replace(m, n)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in the string s. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 pass def process_test_cases(test_cases: List[str]) -> List[int]: Process a list of test case strings and return the results as a list of integers. >>> process_test_cases([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases([\\"abca\\", \\"abcdef\\", \\"\\", \\"a\\"]) [3, 6, 0, 1] pass","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters in the string s. char_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_map: start = max(start, char_map[char] + 1) char_map[char] = end longest = max(longest, end - start + 1) return longest def process_test_cases(test_cases): results = [] for s in test_cases: results.append(length_of_longest_substring(s)) return results"},{"question":"def max_digit_sum(a: List[int]) -> int: Given an array of integers \`a\`, for each integer \`x\` in the array, calculate the sum of its digits and return the maximum sum obtained. >>> max_digit_sum([29, 34, 10009, 12345, 77]) 15 >>> max_digit_sum([5]) 5 >>> max_digit_sum([123456789]) 45 >>> max_digit_sum([111, 111, 111]) 3 >>> max_digit_sum([0, 0, 0]) 0 >>> max_digit_sum([987654321, 123456789]) 45 >>> max_digit_sum([12, 123, 1234, 12345]) 15 >>> max_digit_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9","solution":"def max_digit_sum(a): Given an array of integers \`a\`, for each integer \`x\` in the array, calculate the sum of its digits and return the maximum sum obtained. Parameters: a (list): An array of integers. Returns: int: The maximum sum of the digits in the array \`a\`. def sum_of_digits(x): return sum(int(digit) for digit in str(x)) return max(sum_of_digits(x) for x in a)"},{"question":"def find_unique_pairs(nums, target): Returns a list of all unique pairs of integers from nums that sum up to target. Each pair is represented as a tuple in non-decreasing order. >>> find_unique_pairs([1, 2, 3, 4, 3, 5], 6) [(1, 5), (2, 4), (3, 3)] >>> find_unique_pairs([0, -1, 2, -3, 1], -2) [(-3, 1)] >>> find_unique_pairs([4, 4, 4, 4], 8) [(4, 4)] >>> find_unique_pairs([5, -2, 4, 0, -2, 7], 3) [(-2, 5)]","solution":"def find_unique_pairs(nums, target): Returns a list of all unique pairs of integers from nums that sum up to target. Each pair is represented as a tuple in non-decreasing order. nums.sort() pairs_set = set() left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pairs_set.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return list(pairs_set)"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Checks whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. >>> contains_nearby_duplicate([1, 2, 3, 1], 3) == True >>> contains_nearby_duplicate([1, 0, 1, 1], 1) == True >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) == False","solution":"def contains_nearby_duplicate(nums, k): Checks whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Args: nums: List[int] - an array of integers. k: int - the maximum allowed index difference. Returns: bool - True if such elements exist, otherwise False. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"from typing import List def first_non_repeating_character(s: str) -> str: Given a string of characters, find out the first non-repeating character in it. If there is no non-repeating character, return an underscore ('_'). >>> first_non_repeating_character(\\"abracadabra\\") 'c' >>> first_non_repeating_character(\\"aabbcc\\") '_' >>> first_non_repeating_character(\\"swiss\\") 'w'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the given string. If all characters repeat, returns an underscore ('_'). from collections import Counter # Count the occurrences of each character in the string char_count = Counter(s) # Iterate through the string and return the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return '_' return '_'"},{"question":"from typing import List, Tuple def min_operations(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases, where each test case is a tuple containing the number of elements and the array of positive integers, return a list of integers representing the minimum number of operations needed to make all the elements of the array equal. >>> min_operations([(3, [3, 1, 2])]) == [3] >>> min_operations([(5, [4, 3, 3, 4, 2])]) == [6] >>> min_operations([(4, [1, 1, 1, 1])]) == [0] pass def process_input(input_string: str) -> List[Tuple[int, List[int]]]: Process the input string to extract the number of test cases and the test cases themselves. >>> process_input(\\"3n3n3 1 2n5n4 3 3 4 2n4n1 1 1 1\\") == [ (3, [3, 1, 2]), (5, [4, 3, 3, 4, 2]), (4, [1, 1, 1, 1]) ] pass def process_output(results: List[int]) -> str: Convert the list of results into the required output format string. >>> process_output([3, 6, 0]) == \\"3n6n0\\" pass","solution":"def min_operations(test_cases): results = [] for case in test_cases: n, array = case min_val = min(array) operations = sum(x - min_val for x in array) results.append(operations) return results def process_input(input_string): input_lines = input_string.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] line_number = 1 for _ in range(T): n = int(input_lines[line_number]) array = list(map(int, input_lines[line_number + 1].split())) test_cases.append((n, array)) line_number += 2 return test_cases def process_output(results): return \\"n\\".join(map(str, results))"},{"question":"from typing import List def frequency_sort(lst: List[int]) -> List[int]: Sort elements of the given list based on their frequency of occurrence. Elements with the same frequency are sorted by their natural order. Parameters: lst (List[int]): List of integers to be sorted Returns: List[int]: New list of integers sorted by frequency and natural order >>> frequency_sort([1,1,2,2,2,3]) [2, 2, 2, 1, 1, 3] >>> frequency_sort([4,5,6,5,4,3]) [4, 4, 5, 5, 3, 6] >>> frequency_sort([9,2,5,6,9,9,2,2,2,8]) [2, 2, 2, 2, 9, 9, 9, 5, 6, 8]","solution":"from collections import Counter def frequency_sort(lst): Sort elements of the given list based on their frequency of occurrence. Elements with the same frequency are sorted by their natural order. Parameters: lst (List[int]): List of integers to be sorted Returns: List[int]: New list of integers sorted by frequency and natural order frequency = Counter(lst) return sorted(lst, key=lambda x: (-frequency[x], x))"},{"question":"def findBook(max_duration: int, books: List[dict]) -> str: Finds the title of the book with the longest reading time that does not exceed the given maximum duration in minutes. Parameters: max_duration (int): The maximum reading duration in minutes. books (list of dicts): A list of dictionary objects representing books with keys 'author', 'title', and 'reading_time'. Returns: str: The title of the book with the longest reading time under the max_duration. Returns None if no such book exists. from typing import List, Dict def test_findBook_no_books(): assert findBook(200, []) == None def test_findBook_one_matching_book(): books = [{'author': 'Author A', 'title': 'Book A', 'reading_time': 150}] assert findBook(200, books) == 'Book A' def test_findBook_no_matching_books(): books = [{'author': 'Author A', 'title': 'Book A', 'reading_time': 250}] assert findBook(200, books) == None def test_findBook_multiple_matching_books(): books = [ {'author': 'Author A', 'title': 'Book A', 'reading_time': 180}, {'author': 'Author B', 'title': 'Book B', 'reading_time': 160}, {'author': 'Author C', 'title': 'Book C', 'reading_time': 200} ] assert findBook(200, books) == 'Book C' def test_findBook_multiple_books_with_same_duration(): books = [ {'author': 'Author A', 'title': 'Book A', 'reading_time': 180}, {'author': 'Author B', 'title': 'Book B', 'reading_time': 160}, {'author': 'Author C', 'title': 'Book C', 'reading_time': 180} ] result = findBook(180, books) assert result in {'Book A', 'Book C'} # Either of the two matching books with the same duration is acceptable def test_findBook_multiple_books_some_exceeding_duration(): books = [ {'author': 'Author A', 'title': 'Book A', 'reading_time': 250}, {'author': 'Author B', 'title': 'Book B', 'reading_time': 160}, {'author': 'Author C', 'title': 'Book C', 'reading_time': 150} ] assert findBook(200, books) == 'Book B' def test_findBook_exactly_on_limit(): books = [ {'author': 'Author A', 'title': 'Book A', 'reading_time': 200}, {'author': 'Author B', 'title': 'Book B', 'reading_time': 180}, {'author': 'Author C', 'title': 'Book C', 'reading_time': 150} ] assert findBook(200, books) == 'Book A'","solution":"def findBook(max_duration, books): Finds the title of the book with the longest reading time that does not exceed the given maximum duration in minutes. Parameters: max_duration (int): The maximum reading duration in minutes. books (list of dicts): A list of dictionary objects representing books with keys 'author', 'title', and 'reading_time'. Returns: str: The title of the book with the longest reading time under the max_duration. Returns None if no such book exists. longest_book = None for book in books: if book['reading_time'] <= max_duration: if longest_book is None or book['reading_time'] > longest_book['reading_time']: longest_book = book return longest_book['title'] if longest_book else None"},{"question":"def daily_temperatures(T): Returns a list of days to wait for a warmer temperature. :param T: List[int] - list of daily temperatures :return: List[int] - list of days to wait for a warmer temperature >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) == [1, 1, 1, 0] >>> daily_temperatures([30, 60, 90]) == [1, 1, 0] >>> daily_temperatures([30, 30, 30]) == [0, 0, 0]","solution":"def daily_temperatures(T): Returns a list of days to wait for a warmer temperature. :param T: List[int] - list of daily temperatures :return: List[int] - list of days to wait for a warmer temperature n = len(T) answer = [0] * n stack = [] for i in range(n): while stack and T[i] > T[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"from typing import List def count_beautiful_substrings(s: str) -> int: Returns the number of beautiful substrings in the string s. A beautiful substring has only one distinct character, and its length is a palindrome. >>> count_beautiful_substrings(\\"banana\\") 6 >>> count_beautiful_substrings(\\"abccba\\") 6 >>> count_beautiful_substrings(\\"foobar\\") 6 def solve(queries: List[str]) -> List[int]: Takes a list of strings and returns a list of integers representing the number of beautiful substrings in each string. >>> solve([\\"banana\\", \\"abccba\\", \\"foobar\\"]) [6, 6, 6] >>> solve([\\"aaaa\\", \\"aabbaa\\"]) [4, 6] >>> solve([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\", \\"aaaaa\\"]) [1, 2, 3, 4, 5]","solution":"def count_beautiful_substrings(s): Returns the number of beautiful substrings in the string s. A beautiful substring has only one distinct character, and its length is a palindrome. beautiful_count = 0 n = len(s) i = 0 while i < n: char = s[i] start = i while i < n and s[i] == char: i += 1 length = i - start # Beautiful substrings will be of every length from 1 to 'length' beautiful_count += length return beautiful_count def solve(queries): results = [] for s in queries: results.append(count_beautiful_substrings(s)) return results"},{"question":"def pairwise_distance(lst: List[int]) -> Tuple[int, int]: Returns a tuple consisting of the smallest and largest pairwise absolute difference among all pairs of the list elements. Args: lst (List[int]): A list of n distinct integers. Returns: Tuple[int, int]: A tuple containing the smallest and largest pairwise absolute differences. Example: >>> pairwise_distance([3, 8, 10, 17]) (2, 14) pass from typing import List, Tuple def test_pairwise_distance_example(): assert pairwise_distance([3, 8, 10, 17]) == (2, 14) def test_pairwise_distance_smallest_edge_case(): assert pairwise_distance([1, 2]) == (1, 1) def test_pairwise_distance_negative_numbers(): assert pairwise_distance([-10, -5, 0, 5, 10]) == (5, 20) def test_pairwise_distance_mixed_sign_numbers(): assert pairwise_distance([-2, 0, 2, 4]) == (2, 6) def test_pairwise_distance_all_positive(): assert pairwise_distance([1, 9, 3, 4]) == (1, 8)","solution":"def pairwise_distance(lst): Returns the smallest and largest pairwise absolute differences in the list. min_diff = float('inf') max_diff = float('-inf') for i in range(len(lst)): for j in range(i + 1, len(lst)): diff = abs(lst[i] - lst[j]) if diff < min_diff: min_diff = diff if diff > max_diff: max_diff = diff return (min_diff, max_diff)"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any non-empty contiguous subarray within the list nums. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any non-empty contiguous subarray within the list nums. This is solved using Kadane's Algorithm. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def three_sum(nums: List[int]) -> List[List[int]]: Finds all unique triplets in the list that sum up to zero. Args: nums (List[int]): List of unique integers. Returns: List[List[int]]: List of unique triplets that sum up to zero. Example: >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([]) [] >>> three_sum([0]) []","solution":"def three_sum(nums): Finds all unique triplets in the list that sum up to zero. Args: nums (List[int]): List of unique integers. Returns: List[List[int]]: List of unique triplets that sum up to zero. nums.sort() # Sort the array to use two-pointer technique result = [] n = len(nums) for i in range(n): # Avoid duplicates for the first element if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total_sum = nums[i] + nums[left] + nums[right] if total_sum == 0: result.append([nums[i], nums[left], nums[right]]) # Avoid duplicates for the second and third elements while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total_sum < 0: left += 1 else: right -= 1 return result"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a string can be reordered to form a palindrome. Args: s (str): A string consisting of lowercase English letters. Returns: bool: True if the string can be reordered to form a palindrome, otherwise False. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aaabbbb\\") True from solution import can_form_palindrome def test_palindrome_even_length(): assert can_form_palindrome(\\"aabb\\") == True def test_palindrome_odd_length(): assert can_form_palindrome(\\"civic\\") == True assert can_form_palindrome(\\"ivicc\\") == True def test_non_palindrome(): assert can_form_palindrome(\\"hello\\") == False def test_repeating_characters(): assert can_form_palindrome(\\"aaabbbb\\") == True def test_single_character_string(): assert can_form_palindrome(\\"a\\") == True def test_double_character_string(): assert can_form_palindrome(\\"ab\\") == False def test_multiple_characters_with_one_odd_count(): assert can_form_palindrome(\\"aabbc\\") == True def test_no_repeating_characters(): assert can_form_palindrome(\\"abcdef\\") == False def test_large_input(): assert can_form_palindrome(\\"a\\" * 500 + \\"b\\" * 500) == True assert can_form_palindrome(\\"a\\" * 499 + \\"b\\" * 500) == True assert can_form_palindrome(\\"a\\" * 499 + \\"b\\" * 501) == False","solution":"def can_form_palindrome(s): Determines if a string can be reordered to form a palindrome. Args: s (str): A string consisting of lowercase English letters. Returns: bool: True if the string can be reordered to form a palindrome, otherwise False. from collections import Counter count = Counter(s) odd_count = sum(1 for value in count.values() if value % 2 != 0) return odd_count <= 1"},{"question":"def rotateArray(arr, k): Rotates the array arr to the right by k positions. Parameters: arr (list of int): The array to rotate. k (int): The number of positions to rotate the array by. Returns: list of int: The rotated array. >>> rotateArray([1, 2, 3, 4, 5], 2) # returns [4, 5, 1, 2, 3] >>> rotateArray([1, 2, 3, 4, 5], -2) # returns [3, 4, 5, 1, 2] >>> rotateArray([], 3) # returns [] >>> rotateArray([7], 5) # return [7]","solution":"def rotateArray(arr, k): Rotates the array arr to the right by k positions. Parameters: arr (list of int): The array to rotate. k (int): The number of positions to rotate the array by. Returns: list of int: The rotated array. n = len(arr) if n == 0: return arr k = k % n # Normalize k to ensure it's within the bounds of the array length return arr[-k:] + arr[:-k]"},{"question":"def generate_pairs(list1, list2): Generates all possible pairs of elements from two given lists. Args: list1 (list): First list of elements. list2 (list): Second list of elements. Returns: list: A list of tuples, where each tuple contains one element from list1 and one element from list2. >>> generate_pairs([1, 2], ['a', 'b']) [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')] >>> generate_pairs([3], [4]) [(3, 4)] >>> generate_pairs(['x', 'y'], [10, 20, 30]) [('x', 10), ('x', 20), ('x', 30), ('y', 10), ('y', 20), ('y', 30)] >>> generate_pairs([], [1, 2, 3]) [] >>> generate_pairs([7, 8], []) []","solution":"def generate_pairs(list1, list2): Generates all possible pairs of elements from two given lists. Args: list1 (list): First list of elements. list2 (list): Second list of elements. Returns: list: A list of tuples, where each tuple contains one element from list1 and one element from list2. return [(a, b) for a in list1 for b in list2]"},{"question":"from typing import List def min_transfer_time(n: int, rootID: int, parent: List[int], dataTransfer: List[int]) -> int: Calculate the minimum time required for the main server to transfer a data chunk to all servers in the network. >>> min_transfer_time(1, 0, [-1], [0]) == 0 >>> min_transfer_time(4, 0, [-1, 0, 0, 1], [1, 2, 2, 1]) == 3 >>> min_transfer_time(5, 1, [1, -1, 1, 2, 3], [3, 5, 2, 3, 1]) == 6 >>> min_transfer_time(6, 0, [-1, 0, 0, 1, 1, 2], [1, 2, 2, 2, 2, 1]) == 4 >>> min_transfer_time(3, 0, [-1, 0, 0], [0, 0, 0]) == 0 >>> min_transfer_time(4, 0, [-1, 0, 1, 2], [1, 1, 1, 1]) == 3 >>> min_transfer_time(5, 0, [-1, 0, 0, 0, 0], [1, 1, 1, 1, 1]) == 1","solution":"def min_transfer_time(n, rootID, parent, dataTransfer): from collections import defaultdict def dfs(server): max_time = 0 for child in tree[server]: child_time = dfs(child) + dataTransfer[child] max_time = max(max_time, child_time) return max_time tree = defaultdict(list) for i in range(n): if parent[i] != -1: tree[parent[i]].append(i) return dfs(rootID)"},{"question":"def solve(grid): Given a grid of size m x n containing only 0s and 1s, return a grid of same dimensions where each cell containing 1 is replaced by the size of the connected region it belongs to. Regions are connected horizontally or vertically. Cells with 0 remain unchanged. >>> solve([ [1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1], [1, 0, 1, 1] ]) [ [4, 4, 0, 0], [0, 4, 4, 0], [0, 0, 0, 3], [1, 0, 3, 3] ] >>> solve([[1]]) [[1]] >>> solve([[1, 0, 1, 1, 0, 1]]) [[1, 0, 2, 2, 0, 1]]","solution":"def solve(grid): if not grid or not grid[0]: return grid m, n = len(grid), len(grid[0]) result = [[0] * n for _ in range(m)] visited = [[False] * n for _ in range(m)] def dfs(x, y): stack = [(x, y)] region_size = 0 positions = [] while stack: ix, iy = stack.pop() if ix < 0 or ix >= m or iy < 0 or iy >= n or visited[ix][iy] or grid[ix][iy] == 0: continue visited[ix][iy] = True region_size += 1 positions.append((ix, iy)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: stack.append((ix + dx, iy + dy)) for px, py in positions: result[px][py] = region_size for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: dfs(i, j) return result"},{"question":"def final_coordinates(directions: str) -> tuple: Calculate the final coordinates after following a sequence of directions. Args: directions (str): A string representing a sequence of directions. Returns: tuple: The final coordinates after following all directions. >>> final_coordinates('') == (0, 0) >>> final_coordinates('N') == (0, 1) >>> final_coordinates('S') == (0, -1) >>> final_coordinates('E') == (1, 0) >>> final_coordinates('W') == (-1, 0) >>> final_coordinates('NESW') == (0, 0) >>> final_coordinates('NNN') == (0, 3) >>> final_coordinates('EEWWN') == (0, 1) >>> final_coordinates('NNSS') == (0, 0) >>> final_coordinates('NNEE') == (2, 2) >>> final_coordinates('SSWW') == (-2, -2)","solution":"def final_coordinates(directions): Calculate the final coordinates after following a sequence of directions. Args: directions (str): A string representing a sequence of directions. Returns: tuple: The final coordinates after following all directions. x, y = 0, 0 for direction in directions: if direction == 'N': y += 1 elif direction == 'S': y -= 1 elif direction == 'E': x += 1 elif direction == 'W': x -= 1 return (x, y)"},{"question":"def bbq_planner(guests: int) -> dict: Calculates the amount of food and drinks needed for a BBQ based on the number of guests. Args: guests (int): The number of guests expected. Returns: dict: A dictionary containing the total number of sausages, cans of soda, and grams of salad. Examples: >>> bbq_planner(4) {'sausages': 12, 'soda': 8, 'salad': 800} >>> bbq_planner(10) {'sausages': 30, 'soda': 20, 'salad': 2000}","solution":"def bbq_planner(guests: int) -> dict: Calculates the amount of food and drinks needed for a BBQ based on the number of guests. Args: guests (int): The number of guests expected. Returns: dict: A dictionary containing the total number of sausages, cans of soda, and grams of salad. sausages_per_guest = 3 soda_per_guest = 2 salad_per_guest = 200 total_sausages = guests * sausages_per_guest total_soda = guests * soda_per_guest total_salad = guests * salad_per_guest return { 'sausages': total_sausages, 'soda': total_soda, 'salad': total_salad }"},{"question":"def basic_calculator(expression: str) -> int: Simulates a basic calculator performing addition and subtraction only. >>> basic_calculator(\\"12+5-3\\") 14 >>> basic_calculator(\\"100-50+25\\") 75 >>> basic_calculator(\\"0+0-0\\") 0 >>> basic_calculator(\\"1+2+3+4\\") 10 >>> basic_calculator(\\"10-5-2-3\\") 0 >>> basic_calculator(\\"0\\") 0 >>> basic_calculator(\\"9\\") 9 >>> basic_calculator(\\"1000000-1\\") 999999 >>> basic_calculator(\\"100+1-1000+999\\") 100 >>> basic_calculator(\\"123456789+987654321\\") 1111111110 >>> basic_calculator(\\"999999999-1\\") 999999998 >>> basic_calculator(\\"5+4+3-2-1\\") 9 >>> basic_calculator(\\"10+20-5-15+0\\") 10","solution":"def basic_calculator(expression): Simulates a basic calculator performing addition and subtraction only. total = 0 current_number = '' current_operator = '+' for char in expression: if char.isdigit(): current_number += char else: if current_operator == '+': total += int(current_number) elif current_operator == '-': total -= int(current_number) current_number = '' current_operator = char # Handle the last number in the expression if current_operator == '+': total += int(current_number) elif current_operator == '-': total -= int(current_number) return total"},{"question":"def next_palindrome(n: int) -> int: Returns the smallest palindrome greater than n. Example Usage: >>> next_palindrome(123) 131 >>> next_palindrome(808) 818 >>> next_palindrome(999) 1001 >>> next_palindrome(132) 141","solution":"def next_palindrome(n): Returns the smallest palindrome greater than n. # Helper function to check if a number is a palindrome def is_palindrome(num): return str(num) == str(num)[::-1] n += 1 # Start checking from the next number while not is_palindrome(n): n += 1 return n"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate the amount of water that can be trapped between buildings. Args: height: List[int] -- a list of non-negative integers representing the height of buildings Returns: int -- the total units of trapped water >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 pass def test_trap_example1(): assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_example2(): assert trap([4,2,0,3,2,5]) == 9 def test_trap_no_building(): assert trap([]) == 0 def test_trap_single_building(): assert trap([4]) == 0 def test_trap_two_buildings(): assert trap([4, 2]) == 0 def test_trap_flat_terrain(): assert trap([1, 1, 1, 1, 1]) == 0 def test_trap_ascending_terrain(): assert trap([1, 2, 3, 4, 5]) == 0 def test_trap_descending_terrain(): assert trap([5, 4, 3, 2, 1]) == 0 def test_trap_peaks_and_valleys(): assert trap([3, 0, 2, 0, 4]) == 7 def test_trap_large_numbers(): assert trap([100000, 0, 100000]) == 100000 # Edge case with large numbers","solution":"from typing import List def trap(height: List[int]) -> int: Calculate the amount of water that can be trapped between buildings. Args: height: List[int] -- a list of non-negative integers representing the height of buildings Returns: int -- the total units of trapped water if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill the left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill the right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List, Tuple def find_peak(grid: List[List[int]]) -> Tuple[int, int]: Find a peak element in a 2D grid and return its coordinates. An element is a peak if it is greater than its neighbors. Treat elements outside the bounds of the grid as negative infinity. >>> find_peak([[10, 20, 15], [21, 30, 14], [7, 16, 32]]) in [(1, 1), (2, 2)] True >>> find_peak([[42]]) == (0, 0) True >>> find_peak([[1, 1, 1], [1, 2, 1], [1, 1, 1]]) == (1, 1) True >>> find_peak([[5, 2], [1, 4]]) in [(0, 0), (1, 1)] True >>> find_peak([[10, 15, 20, 25], [30, 35, 40, 45], [50, 55, 60, 65], [70, 75, 80, 85]]) in [(0, 3), (1, 3), (2, 3), (3, 3)] True pass","solution":"from typing import List, Tuple def find_peak(grid: List[List[int]]) -> Tuple[int, int]: Find a peak element in a 2D grid and return its coordinates. An element is a peak if it is greater than its neighbors. Treat elements outside the bounds of the grid as negative infinity. rows = len(grid) cols = len(grid[0]) def is_peak(i: int, j: int) -> bool: Checks if the grid[i][j] is a peak element. current = grid[i][j] # Check top if i > 0 and grid[i-1][j] >= current: return False # Check bottom if i < rows - 1 and grid[i+1][j] >= current: return False # Check left if j > 0 and grid[i][j-1] >= current: return False # Check right if j < cols - 1 and grid[i][j+1] >= current: return False return True for i in range(rows): for j in range(cols): if is_peak(i, j): return (i, j) # Should not reach here as there should be at least one peak in the grid. return (-1, -1)"},{"question":"def swap_dictionary(input_dict): Takes a dictionary as input and returns a new dictionary with the keys and values swapped. Args: input_dict (dict): The input dictionary to be processed. Returns: dict: The dictionary with keys and values swapped. >>> swap_dictionary({'a': 1, 'b': 2, 'c': 3}) == {1: 'a', 2: 'b', 3: 'c'} >>> swap_dictionary({'name': 'Alice', 'age': 30, 'city': 'New York'}) == {'Alice': 'name', 30: 'age', 'New York': 'city'} >>> swap_dictionary({1: 'one', 2: 'two', 3: 'three'}) == {'one': 1, 'two': 2, 'three': 3} >>> swap_dictionary({'key': 'value'}) == {'value': 'key'} >>> swap_dictionary({}) == {}","solution":"def swap_dictionary(input_dict): Takes a dictionary as input and returns a new dictionary with the keys and values swapped. Args: input_dict (dict): The input dictionary to be processed. Returns: dict: The dictionary with keys and values swapped. return {v: k for k, v in input_dict.items()}"},{"question":"def is_power_of_two(n): Check if a number is a power of two. >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(4) True pass def longest_power_of_two_subsequence(test_cases): For each test case, return the length of the longest subsequence that consists of powers of two. >>> longest_power_of_two_subsequence([(5, [1, 2, 3, 4, 8])]) [4] >>> longest_power_of_two_subsequence([(4, [8, 10, 12, 16])]) [2] >>> longest_power_of_two_subsequence([(6, [2, 4, 6, 8, 10, 32])]) [4] >>> longest_power_of_two_subsequence([(3, [3, 5, 7])]) [0] >>> longest_power_of_two_subsequence([(5, [1, 2, 3, 4, 8]), (4, [8, 10, 12, 16]), (6, [2, 4, 6, 8, 10, 32])]) [4, 2, 4] pass","solution":"def is_power_of_two(n): Check if a number is a power of two. return n > 0 and (n & (n - 1)) == 0 def longest_power_of_two_subsequence(test_cases): For each test case, return the length of the longest subsequence that consists of powers of two. results = [] for test in test_cases: n, array = test count = sum(1 for x in array if is_power_of_two(x)) results.append(count) return results"},{"question":"def intersection(arr1, arr2): Returns the intersection of two sorted arrays as a sorted list of unique integers. Example 1: >>> intersection([1, 3, 4, 5, 7], [2, 3, 5, 6]) [3, 5] Example 2: >>> intersection([2, 3, 4, 7, 9], [1, 2, 3, 4, 8, 10]) [2, 3, 4] Example 3: >>> intersection([1, 2, 9, 10, 11, 12], [0, 1, 3, 4, 5, 11]) [1, 11] Example 4: >>> intersection([3, 6, 7, 8, 20], [1, 2, 3, 8, 9]) [3, 8]","solution":"def intersection(arr1, arr2): Returns the intersection of two sorted arrays as a sorted list of unique integers. i, j = 0, 0 result = [] while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: if not result or result[-1] != arr1[i]: result.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return result"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise returns False. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(10) == False >>> is_prime(11) == True >>> is_prime(1) == False >>> is_prime(-7) == False >>> is_prime(1_000_000_033) == True","solution":"def is_prime(n): Returns True if n is a prime number, otherwise returns False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"from typing import List def max_non_consecutive_power(consumptions: List[int]) -> int: Calculate the maximum power consumption under the constraint that no two lights can be on for two consecutive days. >>> max_non_consecutive_power([3, 2, 5, 10, 7]) 15 >>> max_non_consecutive_power([3, 2, 7, 10]) 13 from solution import max_non_consecutive_power def test_single_element(): assert max_non_consecutive_power([5]) == 5 def test_two_elements(): assert max_non_consecutive_power([5, 1]) == 5 assert max_non_consecutive_power([1, 5]) == 5 def test_example_cases(): assert max_non_consecutive_power([3, 2, 5, 10, 7]) == 15 assert max_non_consecutive_power([3, 2, 7, 10]) == 13 def test_all_elements_same(): assert max_non_consecutive_power([4, 4, 4, 4, 4]) == 12 assert max_non_consecutive_power([6, 6, 6, 6, 6, 6]) == 18 def test_alternate_elements_optimal(): assert max_non_consecutive_power([10, 1, 10, 1, 10]) == 30 assert max_non_consecutive_power([5, 5, 5, 5, 5]) == 15 def test_large_input(): large_input = [1] * 1000 assert max_non_consecutive_power(large_input) == 500 large_input = [1000] * 1000 assert max_non_consecutive_power(large_input) == 500000","solution":"from typing import List def max_non_consecutive_power(consumptions: List[int]) -> int: Calculate the maximum power consumption under the constraint that no two lights can be on for two consecutive days. if not consumptions: return 0 n = len(consumptions) if n == 1: return consumptions[0] # We use two variables to store the maximum power up to two previous days include = consumptions[0] # Choosing the current element exclude = 0 # Not choosing the current element for i in range(1, n): # current max excluding i (either exclude[i-1] or include[i-1]) new_exclude = max(include, exclude) # current max including i include = exclude + consumptions[i] exclude = new_exclude return max(include, exclude)"},{"question":"def min_operations_to_balance_crops(test_cases): Given the number of fields and the units of crops in each field, returns the minimum number of operations required to achieve the smallest possible difference between the maximum and minimum units of crops. Parameters: test_cases: List of tuples, where each tuple contains number of fields and a list of integers representing the units of crops in each field. Returns: List of integers where each integer represents the minimum operations needed for each test case. pass def handle_input(input_data): Parses the input data to extract the number of test cases and their details. Parameters: input_data: A string with the input data. Returns: A list of tuples, where each tuple contains the number of fields and a list of integers representing the units of crops in each field. pass def main(input_data): test_cases = handle_input(input_data) results = min_operations_to_balance_crops(test_cases) for result in results: print(result)","solution":"def min_operations_to_balance_crops(test_cases): Given the number of fields and the units of crops in each field, returns the minimum number of operations required to achieve the smallest possible difference between the maximum and minimum units of crops. Parameters: test_cases: List of tuples, where each tuple contains number of fields and a list of integers representing the units of crops in each field. Returns: List of integers where each integer represents the minimum operations needed for each test case. results = [] for num_fields, crops in test_cases: max_crop = max(crops) min_crop = min(crops) result = max_crop - min_crop results.append(result) return results # Example Input Handling def handle_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] line_index = 1 for _ in range(T): N = int(lines[line_index]) crops = list(map(int, lines[line_index + 1].split())) test_cases.append((N, crops)) line_index += 2 return test_cases def main(input_data): test_cases = handle_input(input_data) results = min_operations_to_balance_crops(test_cases) for result in results: print(result) # Sample Input input_data = \\"2n4n4 9 7 3n3n1 1 1\\" main(input_data)"},{"question":"from typing import List, Tuple def find_clusters(connections: List[Tuple[str, str]]) -> List[List[str]]: Identify clusters of directly or indirectly connected nodes. Each cluster is represented as a sorted list of node names. The returned list of clusters is sorted lexicographically by the first node in each cluster. >>> find_clusters([(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"D\\", \\"E\\")]) [['A', 'B', 'C'], ['D', 'E']] >>> find_clusters([]) [] >>> find_clusters([(\\"A\\", \\"B\\"), (\\"C\\", \\"D\\"), (\\"E\\", \\"F\\")]) [['A', 'B'], ['C', 'D'], ['E', 'F']] >>> find_clusters([(\\"A\\", \\"A\\")]) [['A']] >>> find_clusters([ (\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"E\\", \\"F\\"), (\\"F\\", \\"G\\"), (\\"G\\", \\"H\\"), (\\"I\\", \\"J\\"), (\\"J\\", \\"K\\"), (\\"K\\", \\"L\\"), (\\"M\\", \\"N\\"), (\\"N\\", \\"O\\"), (\\"O\\", \\"P\\"), (\\"A\\", \\"C\\"), (\\"E\\", \\"G\\"), (\\"I\\", \\"K\\"), (\\"M\\", \\"O\\") ]) [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L'], ['M', 'N', 'O', 'P']] >>> find_clusters([(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"A\\"), (\\"D\\", \\"E\\"), (\\"E\\", \\"F\\"), (\\"F\\", \\"D\\")]) [['A', 'B', 'C'], ['D', 'E', 'F']] pass","solution":"from typing import List, Tuple from collections import defaultdict def find_clusters(connections: List[Tuple[str, str]]) -> List[List[str]]: # Create a graph as an adjacency list graph = defaultdict(list) for node1, node2 in connections: graph[node1].append(node2) graph[node2].append(node1) # Function to perform DFS and find all nodes in a cluster def dfs(node, visited, cluster): visited.add(node) cluster.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, cluster) visited = set() clusters = [] # Traverse all nodes and form clusters using DFS for node in graph.keys(): if node not in visited: cluster = [] dfs(node, visited, cluster) clusters.append(sorted(cluster)) return sorted(clusters, key=lambda x: x[0])"},{"question":"def is_harshad(number: int) -> str: Checks if a number is a Harshad number. Args: - number (int): positive integer to check Returns: - str: \\"Harshad number\\" if the number is a Harshad number, \\"Not Harshad number\\" otherwise >>> is_harshad(18) 'Harshad number' >>> is_harshad(19) 'Not Harshad number' >>> is_harshad(21) 'Harshad number' >>> is_harshad(25) 'Not Harshad number' >>> is_harshad(1) 'Harshad number' >>> is_harshad(1001) 'Not Harshad number'","solution":"def is_harshad(number): Checks if a number is a Harshad number. Args: - number (int): positive integer to check Returns: - str: \\"Harshad number\\" if the number is a Harshad number, \\"Not Harshad number\\" otherwise digit_sum = sum(int(digit) for digit in str(number)) if number % digit_sum == 0: return \\"Harshad number\\" else: return \\"Not Harshad number\\""},{"question":"def can_form_sequence(blocks, sequence): Determines if the sequence can be formed using the given blocks. >>> can_form_sequence([\\"1\\", \\"101\\", \\"11\\"], \\"11011\\") True >>> can_form_sequence([\\"1\\", \\"101\\", \\"11\\"], \\"10101\\") False def check_sequences(n, blocks, t, sequences): Check multiple sequences for their validity based on the list of blocks. >>> check_sequences(3, [\\"1\\", \\"101\\", \\"11\\"], 2, [\\"11011\\", \\"10101\\"]) [\\"YES\\", \\"NO\\"] >>> check_sequences(1, [\\"1\\"], 1, [\\"1\\"]) [\\"YES\\"]","solution":"def can_form_sequence(blocks, sequence): Determines if the sequence can be formed using the given blocks. n = len(sequence) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for block in blocks: if i >= len(block) and sequence[i-len(block):i] == block: dp[i] = dp[i] or dp[i-len(block)] return dp[-1] def check_sequences(n, blocks, t, sequences): results = [] for seq in sequences: if can_form_sequence(blocks, seq): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def reverseWords(sentence: str) -> str: Reverses the words in the input sentence. Parameters: sentence (str): A string of words separated by spaces. Returns: str: A new string with the words in reverse order and multiple spaces reduced to a single space. >>> reverseWords(\\"hello\\") == \\"hello\\" >>> reverseWords(\\"hello world\\") == \\"world hello\\" >>> reverseWords(\\" hello world \\") == \\"world hello\\" >>> reverseWords(\\"\\") == \\"\\" >>> reverseWords(\\" hello world \\") == \\"world hello\\" >>> reverseWords(\\" \\") == \\"\\"","solution":"def reverseWords(sentence): Reverses the words in the input sentence. Parameters: sentence (str): A string of words separated by spaces. Returns: str: A new string with the words in reverse order and multiple spaces reduced to a single space. # Splitting the sentence into words and filtering out any empty words from multiple spaces words = list(filter(None, sentence.split(' '))) # Reversing the list of words words.reverse() # Joining the reversed list of words with a single space and returning return ' '.join(words)"},{"question":"def can_form_palindrome(string: str) -> str: Determine whether the string containing only lowercase letters and the character \\"*\\" can be rearranged to form a palindrome. Output \\"YES\\" if it is possible to form a palindrome, otherwise output \\"NO\\". >>> can_form_palindrome(\\"aab*\\") \\"YES\\" >>> can_form_palindrome(\\"abc*\\") \\"NO\\"","solution":"def can_form_palindrome(string): Determines if the given string can be rearranged to form a palindrome by replacing wildcards. from collections import Counter # Count frequency of each character freq = Counter(char for char in string if char != '*') # Count the number of odd frequency characters odd_count = sum(1 for count in freq.values() if count % 2 != 0) # In a palindrome, we can have at most one odd frequency character # The wildcard '*' can be used to balance the odd frequency characters wildcards = string.count('*') # Check if the number of odd frequency characters can be balanced with wildcards if odd_count <= wildcards + 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def top_three_scores(scores: List[int]) -> List[int]: Returns the top 3 scores in descending order. If there are fewer than 3 scores, returns them sorted in descending order. >>> top_three_scores([87, 56, 99, 40, 78, 64, 90, 100, 67, 83]) == [100, 99, 90] >>> top_three_scores([45, 82]) == [82, 45] >>> top_three_scores([99, 25, 88]) == [99, 88, 25] >>> top_three_scores([50, 50, 50, 50, 50]) == [50, 50, 50] >>> top_three_scores([87, 56, 99, 87, 99, 100, 56, 78, 64]) == [100, 99, 99]","solution":"def top_three_scores(scores): Returns the top 3 scores in descending order. If there are fewer than 3 scores, returns them sorted in descending order. # Sort scores in descending order sorted_scores = sorted(scores, reverse=True) # Return the top 3 scores return sorted_scores[:3]"},{"question":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotate the array of integers by a given number of positions and return the resulting array. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([0, 1, 2], 4) [2, 0, 1] pass def test_rotate_array_empty(): assert rotate_array([], 3) == [] def test_rotate_array_zero_k(): assert rotate_array([1, 2, 3], 0) == [1, 2, 3] def test_rotate_array_k_greater_than_length(): assert rotate_array([1, 2, 3], 4) == [3, 1, 2] def test_rotate_array_normal(): assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([0, 1, 2], 4) == [2, 0, 1] assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_array([1, 2, 3, 4, 5], 1) == [5, 1, 2, 3, 4] assert rotate_array([1, 2, 3, 4, 5], 11) == [5, 1, 2, 3, 4]","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: length = len(arr) if length == 0: return arr k = k % length # Ensure k is within the bounds of the array length return arr[-k:] + arr[:-k]"},{"question":"def count_characters(s: str) -> dict: Determine how many times each character appears in the string. Args: s (str): The input string consisting of only uppercase and lowercase letters. Returns: dict: A dictionary with characters as keys and their counts as values. Examples: >>> count_characters(\\"aAbBcC\\") {'a': 1, 'A': 1, 'b': 1, 'B': 1, 'c': 1, 'C': 1} >>> count_characters(\\"zzzZZZ\\") {'z': 3, 'Z': 3} >>> count_characters(\\"HelloWorld\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1}","solution":"def count_characters(s): Returns a dictionary with the counts of each character in the string s. The characters are case-sensitive, i.e., 'A' and 'a' are counted separately. Parameters: s (str): The input string. Returns: dict: A dictionary with characters as keys and their counts as values. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. Given a positive integer within the range 1 to 3999, convert it to its Roman numeral representation. The solution should correctly implement the rules and symbols of Roman numerals. Parameters: num (int): The integer to be converted. Returns: str: The Roman numeral representation of the integer. Example: >>> int_to_roman(3) \\"III\\" >>> int_to_roman(4) \\"IV\\" >>> int_to_roman(9) \\"IX\\" >>> int_to_roman(58) \\"LVIII\\" >>> int_to_roman(1994) \\"MCMXCIV\\" from solution import int_to_roman def test_single_digit_numbers(): assert int_to_roman(1) == \\"I\\" assert int_to_roman(4) == \\"IV\\" assert int_to_roman(5) == \\"V\\" assert int_to_roman(9) == \\"IX\\" def test_double_digit_numbers(): assert int_to_roman(10) == \\"X\\" assert int_to_roman(40) == \\"XL\\" assert int_to_roman(50) == \\"L\\" assert int_to_roman(90) == \\"XC\\" def test_triple_digit_numbers(): assert int_to_roman(100) == \\"C\\" assert int_to_roman(400) == \\"CD\\" assert int_to_roman(500) == \\"D\\" assert int_to_roman(900) == \\"CM\\" def test_large_numbers(): assert int_to_roman(1000) == \\"M\\" assert int_to_roman(1987) == \\"MCMLXXXVII\\" assert int_to_roman(3999) == \\"MMMCMXCIX\\" def test_mixed_numbers(): assert int_to_roman(58) == \\"LVIII\\" assert int_to_roman(99) == \\"XCIX\\" assert int_to_roman(144) == \\"CXLIV\\" assert int_to_roman(399) == \\"CCCXCIX\\" assert int_to_roman(2020) == \\"MMXX\\"","solution":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. # Define the values and their corresponding symbols values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] symbols = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(values)): while num >= values[i]: num -= values[i] roman_numeral += symbols[i] return roman_numeral"},{"question":"def sortedSquares(nums: List[int]) -> List[int]: Write a function that takes an array of integers and returns a new array with each element squared and sorted in non-decreasing order. >>> sortedSquares([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sortedSquares([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121]","solution":"def sortedSquares(nums): Returns a new array with each element squared and sorted in non-decreasing order. :param nums: List[int] - the input array of integers :return: List[int] - new array with squared elements sorted in non-decreasing order n = len(nums) left, right = 0, n - 1 result = [0] * n pos = n - 1 while left <= right: left_square = nums[left] ** 2 right_square = nums[right] ** 2 if left_square > right_square: result[pos] = left_square left += 1 else: result[pos] = right_square right -= 1 pos -= 1 return result"},{"question":"from typing import List def num_ways_to_traverse(matrix: List[List[int]]) -> int: Calculate the number of ways to traverse from the top-left corner to the bottom-right corner of a matrix, considering blocked cells. :param matrix: A 2D list of integers where 0 represents an open cell and 1 represents a blocked cell. :return: An integer representing the number of valid paths. >>> matrix = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> num_ways_to_traverse(matrix) 2 >>> matrix = [[0]] >>> num_ways_to_traverse(matrix) 1 >>> matrix = [ ... [1, 0], ... [0, 0] ... ] >>> num_ways_to_traverse(matrix) 0 >>> matrix = [ ... [0, 0], ... [0, 1] ... ] >>> num_ways_to_traverse(matrix) 0 >>> matrix = [[0]*100 for _ in range(100)] >>> num_ways_to_traverse(matrix) > 0 True >>> matrix = [[0]*100 for _ in range(100)] >>> matrix[99][99] = 1 >>> num_ways_to_traverse(matrix) 0","solution":"def num_ways_to_traverse(matrix): N = len(matrix) M = len(matrix[0]) if matrix[0][0] == 1 or matrix[N-1][M-1] == 1: return 0 dp = [[0]*M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if matrix[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1]"},{"question":"def reverse_vowels(s: str) -> str: Reverses the vowels in the input string s. >>> reverse_vowels(\\"hello\\") == \\"holle\\" >>> reverse_vowels(\\"world\\") == \\"world\\" >>> reverse_vowels(\\"hello world\\") == \\"hollo werld\\" >>> reverse_vowels(\\"HELLO\\") == \\"HOLLE\\" >>> reverse_vowels(\\"LeetCode\\") == \\"LeotCede\\" >>> reverse_vowels(\\"aA\\") == \\"Aa\\" >>> reverse_vowels(\\"bcdfg\\") == \\"bcdfg\\" >>> reverse_vowels(\\"\\") == \\"\\"","solution":"def reverse_vowels(s): Reverses the vowels in the input string s. vowels = \\"aeiouAEIOU\\" s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] not in vowels: left += 1 continue if s_list[right] not in vowels: right -= 1 continue # Swap vowels s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return ''.join(s_list)"},{"question":"def filter_strings_starting_with_vowel(strings: List[str]) -> List[str]: Returns a new array containing only the strings that start with a vowel. Ensure the function does not use any loops (including for, for/in, while, and do/while loops). >>> filter_strings_starting_with_vowel(['apple', 'orange', 'umbrella', 'Elephant']) ['apple', 'orange', 'umbrella', 'Elephant'] >>> filter_strings_starting_with_vowel(['banana', 'carrot', 'melon']) [] >>> filter_strings_starting_with_vowel(['apple', 'banana', 'orange', 'carrot']) ['apple', 'orange'] >>> filter_strings_starting_with_vowel([]) [] >>> filter_strings_starting_with_vowel(['Apple', 'Banana', 'eagle', 'Owl', 'iron', 'Under']) ['Apple', 'eagle', 'Owl', 'iron', 'Under'] >>> filter_strings_starting_with_vowel(['a', 'e', 'i', 'o', 'u', 'b', 'c']) ['a', 'e', 'i', 'o', 'u']","solution":"def filter_strings_starting_with_vowel(strings): Returns a new array containing only the strings that start with a vowel. return list(filter(lambda s: s[0].lower() in 'aeiou', strings))"},{"question":"def pig_latin(word: str) -> str: Converts a given word to its Pig Latin equivalent. >>> pig_latin(\\"apple\\") \\"appleway\\" >>> pig_latin(\\"banana\\") \\"ananabay\\" >>> pig_latin(\\"sphinx\\") \\"inxphay\\" >>> pig_latin(\\"rhythm\\") \\"rhythm\\" >>> pig_latin(\\"Test\\") \\"estTay\\" >>> pig_latin(\\"PyThOn\\") \\"OnPyThay\\"","solution":"def pig_latin(word: str) -> str: Converts a given word to its Pig Latin equivalent. Parameters: word (str): The word to be converted. Returns: str: The Pig Latin version of the word. vowels = 'aeiou' # Check if the word starts with a vowel if word[0].lower() in vowels: return word + \\"way\\" # Find the index of the first vowel for i, char in enumerate(word): if char.lower() in vowels: return word[i:] + word[:i] + \\"ay\\" # If no vowels are found, return the word as is return word"},{"question":"def longest_uncommon_subsequence_length(t: int, cases: List[Tuple[str, str]]) -> List[int]: Returns the length of the longest uncommon subsequence between pairs of strings. Parameters: t (int): Number of test cases. cases (List[Tuple[str, str]]): Each tuple contains two strings x and y. Returns: List[int]: Length of the longest uncommon subsequence for each test case. Examples: >>> longest_uncommon_subsequence_length(1, [(\\"abcd\\", \\"abcd\\")]) [-1] >>> longest_uncommon_subsequence_length(1, [(\\"aba\\", \\"cad\\")]) [3] >>> longest_uncommon_subsequence_length(3, [(\\"aba\\", \\"cad\\"), (\\"abcd\\", \\"abcd\\"), (\\"abcdefg\\", \\"hi\\")]) [3, -1, 7] >>> longest_uncommon_subsequence_length(1, [(\\"a\\", \\"b\\")]) [1] >>> longest_uncommon_subsequence_length(2, [(\\"a\\", \\"a\\"), (\\"b\\", \\"b\\")]) [-1, -1] >>> longest_uncommon_subsequence_length(2, [(\\"abcd\\", \\"a\\"), (\\"abc\\", \\"b\\")]) [4, 3]","solution":"def longest_uncommon_subsequence_length(t, cases): Returns the length of the longest uncommon subsequence between pairs of strings. Parameters: t (int): Number of test cases. cases (list of tuples): Each tuple contains two strings x and y. Returns: list: Length of the longest uncommon subsequence for each test case. result = [] for x, y in cases: if x == y: result.append(-1) else: result.append(max(len(x), len(y))) return result"},{"question":"def unique_in_order(sequence): Returns a list of items without any elements with the same value next to each other and preserving the original order of elements. Arguments: sequence -- a string or list of characters/numbers Returns: list -- a list of items with adjacent duplicates removed >>> unique_in_order('AAAABBBCCDAABBB') ['A', 'B', 'C', 'D', 'A', 'B'] >>> unique_in_order('ABBCcAD') ['A', 'B', 'C', 'c', 'A', 'D'] >>> unique_in_order([1, 2, 2, 3, 3]) [1, 2, 3] >>> unique_in_order([1, 1, 2, 3, 3, 2]) [1, 2, 3, 2] >>> unique_in_order('') [] >>> unique_in_order([]) []","solution":"def unique_in_order(sequence): Returns a list of items without any elements with the same value next to each other and preserving the original order of elements. Arguments: sequence -- a string or list of characters/numbers Returns: list -- a list of items with adjacent duplicates removed if not sequence: return [] result = [sequence[0]] for item in sequence[1:]: if item != result[-1]: result.append(item) return result"},{"question":"def can_rearrange_to_peak_pattern(n, problems): Determines if the problems can be rearranged to form a peak pattern. Args: n (int): The number of days Alisa plans to practice problems. problems (list of int): The number of problems planned for each day. Returns: str: \\"YES\\" if it is possible to rearrange the problems to form a peak pattern, \\"NO\\" otherwise. import pytest def test_case_1(): assert can_rearrange_to_peak_pattern(5, [3, 1, 5, 2, 4]) == \\"YES\\" def test_case_2(): assert can_rearrange_to_peak_pattern(4, [2, 2, 2, 2]) == \\"NO\\" def test_case_3(): assert can_rearrange_to_peak_pattern(3, [1, 0, 3]) == \\"YES\\" def test_case_4(): assert can_rearrange_to_peak_pattern(1, [0]) == \\"YES\\" def test_case_5(): assert can_rearrange_to_peak_pattern(6, [1, 2, 3, 1, 2, 3]) == \\"YES\\" def test_case_6(): assert can_rearrange_to_peak_pattern(5, [5, 9, 9, 9, 9]) == \\"NO\\" def test_case_7(): assert can_rearrange_to_peak_pattern(5, [1, 1, 1, 1, 1]) == \\"NO\\" def test_case_8(): assert can_rearrange_to_peak_pattern(3, [2, 2, 1]) == \\"YES\\"","solution":"def can_rearrange_to_peak_pattern(n, problems): Determines if the problems can be rearranged to form a peak pattern. Args: n (int): The number of days Alisa plans to practice problems. problems (list of int): The number of problems planned for each day. Returns: str: \\"YES\\" if it is possible to rearrange the problems to form a peak pattern, \\"NO\\" otherwise. problems.sort() # We need to count the maximum occurrence of any single element max_count = 0 current_count = 0 current_value = None for p in problems: if p == current_value: current_count += 1 else: current_value = p current_count = 1 if current_count > max_count: max_count = current_count # To form a peak, no element should be repeated more than (n // 2 + 1) times if max_count > (n + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"[Completion Task in Python] def int_to_roman(n: int) -> str: Converts an integer to a Roman numeral string representation. Args: n (int): The integer to convert, must be between 1 and 3999, inclusive. Returns: str: The Roman numeral representation of the integer. Examples: >>> int_to_roman(1) 'I' >>> int_to_roman(4) 'IV' >>> int_to_roman(9) 'IX' >>> int_to_roman(58) 'LVIII' >>> int_to_roman(1994) 'MCMXCIV' >>> int_to_roman(2021) 'MMXXI' >>> int_to_roman(3999) 'MMMCMXCIX' pass","solution":"def int_to_roman(n): Converts an integer to a Roman numeral string representation. Args: n (int): The integer to convert, must be between 1 and 3999, inclusive. Returns: str: The Roman numeral representation of the integer. if not isinstance(n, int) or n < 1 or n > 3999: return \\"\\" val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(val)): while n >= val[i]: roman_numeral += syms[i] n -= val[i] return roman_numeral"},{"question":"def min_operations(grid_size, m_full, n_full): Returns the minimum number of 1's needed to fill m_full rows and n_full columns. Args: grid_size (list): Size of the grid as [m, n]. m_full (int): Number of fully filled rows. n_full (int): Number of fully filled columns. Returns: int: Minimum number of 1's needed. pass # Test Cases def test_example1(): assert min_operations([3, 3], 1, 1) == 1 def test_example2(): assert min_operations([3, 5], 2, 2) == 4 def test_example3(): assert min_operations([4, 4], 3, 2) == 6 def test_zero_full_rows(): assert min_operations([5, 5], 0, 2) == 0 def test_zero_full_columns(): assert min_operations([5, 5], 2, 0) == 0 def test_max_full_rows_and_columns(): assert min_operations([5, 5], 5, 5) == 25","solution":"def min_operations(grid_size, m_full, n_full): Returns the minimum number of 1's needed to fill m_full rows and n_full columns. Args: grid_size (list): Size of the grid as [m, n]. m_full (int): Number of fully filled rows. n_full (int): Number of fully filled columns. Returns: int: Minimum number of 1's needed. m, n = grid_size return m_full * n_full"},{"question":"def pairwise_sum(nums: List[int]) -> List[int]: Returns a list where each element is the sum of its adjacent elements from the original list. The first and last elements of the new list are the same as the original list. >>> pairwise_sum([1, 2, 3, 4]) [1, 3, 5, 4] >>> pairwise_sum([10, -2, 5]) [10, 8, 5] >>> pairwise_sum([7]) [7] >>> pairwise_sum([]) [] >>> pairwise_sum([5, 10]) [5, 10]","solution":"def pairwise_sum(nums): Returns a list where each element is the sum of its adjacent elements from the original list. The first and last elements of the new list are the same as the original list. if len(nums) < 2: return nums result = [nums[0]] for i in range(1, len(nums)-1): result.append(nums[i-1] + nums[i]) result.append(nums[-1]) return result"},{"question":"def highest_total_expense(expenses_for_each_day): Identify which day had the highest total expense from the given records. Parameters: expenses_for_each_day (list of list of int): A list containing n lists of expenses. Returns: int: The highest total expense among all given days. >>> highest_total_expense([[120, 450, 230, 40], [500, 700], [300, 200, 100, 400]]) 1200 >>> highest_total_expense([[100, 100, 100], [100, 100, 100], [100, 100, 100]]) 300","solution":"def highest_total_expense(expenses_for_each_day): This function takes a list where each element is a list of positive integers representing the expenses of a particular day and returns the highest total expense across all given days. Parameters: expenses_for_each_day (list of list of int): A list containing n lists of expenses. Returns: int: The highest total expense among all given days. return max(sum(day) for day in expenses_for_each_day)"},{"question":"def unique_paths(M: int, N: int) -> int: Calculate the number of unique paths one can take to travel from the top-left corner to the bottom-right corner of a grid with dimensions M (rows) and N (columns). You can only move either down or right at any point in time. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Given multiple test cases with grid dimensions, return the number of unique paths for each test case. >>> solve([(3, 7), (3, 2)]) [28, 3] >>> solve([(1, 1), (2, 2)]) [1, 2] pass","solution":"def unique_paths(M, N): Calculate the number of unique paths in an MxN grid. :param M: int, number of rows :param N: int, number of columns :return: int, number of unique paths # Create a 2D list to store the number of ways to reach each cell dp = [[1]*N for _ in range(M)] # Fill the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = dp[i-1][j] + dp[i][j-1] # Return the number of ways to reach the bottom-right corner return dp[-1][-1] def solve(test_cases): results = [] for M, N in test_cases: results.append(unique_paths(M, N)) return results"},{"question":"from collections import Counter from typing import List def is_balanced(s: str) -> bool: Checks if the input string is balanced. A string is considered to be \\"balanced\\" if all characters in the string appear the same number of times. >>> is_balanced(\\"aabbcc\\") True >>> is_balanced(\\"aabbccd\\") False # Your code here # Unit Tests def test_balanced_strings(): assert is_balanced(\\"aabbcc\\") == True assert is_balanced(\\"abcabc\\") == True assert is_balanced(\\"abcabcabc\\") == True def test_unbalanced_strings(): assert is_balanced(\\"aabbccd\\") == False assert is_balanced(\\"xyzxyyz\\") == False def test_single_char_string(): assert is_balanced(\\"a\\") == True def test_empty_string(): assert is_balanced(\\"\\") == True def test_varied_length_strings(): assert is_balanced(\\"xxyyzz\\") == True assert is_balanced(\\"xxyyzzx\\") == False assert is_balanced(\\"zzxxzzxx\\") == True assert is_balanced(\\"aabbccddeeffgg\\") == True assert is_balanced(\\"aabbccddeeffggz\\") == False assert is_balanced(\\"a\\"*500 + \\"b\\"*500) == True assert is_balanced(\\"a\\"*500 + \\"b\\"*499) == False","solution":"def is_balanced(s): This function checks if the input string s is balanced. A string is considered to be \\"balanced\\" if all characters in the string appear the same number of times. from collections import Counter if not s: return True count = Counter(s) values = list(count.values()) return all(v == values[0] for v in values)"},{"question":"def sum_factors(n: int) -> int: Returns the sum of all unique factors of n, excluding n itself. >>> sum_factors(12) # The factors of 12 (excluding 12) are: 1, 2, 3, 4, 6 16 >>> sum_factors(28) # The factors of 28 (excluding 28) are: 1, 2, 4, 7, 14 28 >>> sum_factors(7) # The factors of 7 (excluding 7) are: 1 1","solution":"def sum_factors(n: int) -> int: Returns the sum of all unique factors of n, excluding n itself. factors_sum = 0 for i in range(1, n): if n % i == 0: factors_sum += i return factors_sum"},{"question":"def can_distribute_evenly(potions: List[int], k: int) -> bool: Determines if the potions can be evenly distributed among exactly \`k\` wizards. >>> can_distribute_evenly([1, 2, 3, 4, 5, 6], 3) True >>> can_distribute_evenly([1, 2, 3, 4, 5], 2) False","solution":"from typing import List def can_distribute_evenly(potions: List[int], k: int) -> bool: Determines if the potions can be evenly distributed among exactly \`k\` wizards. total_sum = sum(potions) if total_sum % k != 0: return False target = total_sum // k if max(potions) > target: return False def can_partition(start, count, current_sum): if count == 0: return True if current_sum == target: return can_partition(0, count-1, 0) if current_sum > target: return False for i in range(start, len(potions)): if not taken[i]: taken[i] = True if can_partition(i + 1, count, current_sum + potions[i]): return True taken[i] = False return False taken = [False] * len(potions) return can_partition(0, k, 0)"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, performs a level-order traversal on the tree and returns a list of lists, where each nested list represents the nodes at each level of the tree. >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) >>> level_order_traversal(root) [[1], [2, 3], [4, 5, 6]] # Unit Tests def test_level_order_traversal_single_node(): root = TreeNode(1) assert level_order_traversal(root) == [[1]] def test_level_order_traversal_complete_tree(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert level_order_traversal(root) == [[1], [2, 3]] def test_level_order_traversal_skewed_tree(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) assert level_order_traversal(root) == [[1], [2], [3]] def test_level_order_traversal_mixed_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) assert level_order_traversal(root) == [[1], [2, 3], [4, 5, 6]] def test_level_order_traversal_empty_tree(): assert level_order_traversal(None) == [] def test_level_order_deeper_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(7))), TreeNode(3, TreeNode(5), TreeNode(6))) assert level_order_traversal(root) == [[1], [2, 3], [4, 5, 6], [7]] def test_level_order_complex_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(7), TreeNode(8)), TreeNode(5)), TreeNode(3, None, TreeNode(6, TreeNode(9), TreeNode(10)))) assert level_order_traversal(root) == [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level = [] level_length = len(queue) for i in range(level_length): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"from typing import List MOD = 10**9 + 7 def solve_puzzle(n: int, A: List[int]) -> List[int]: Simona is given an integer n and a sequence A of n integers. She needs to create a new sequence B derived from sequence A that satisfies the following condition: For each element B_i in sequence B, B_i should be the product of all elements in A except for A_i. The results should be computed using a modulo 10**9 + 7. Args: n: int - the number of elements in sequence A A: List[int] - the sequence of integers Returns: List[int] - sequence B Example: >>> solve_puzzle(4, [1, 2, 3, 4]) [24, 12, 8, 6]","solution":"from typing import List MOD = 10**9 + 7 def solve_puzzle(n: int, A: List[int]) -> List[int]: if n == 1: return [0] # If there is only one element, the product of all except that element is 0 # Step 1: Compute prefix products prefix_products = [1] * n for i in range(1, n): prefix_products[i] = (prefix_products[i-1] * A[i-1]) % MOD # Step 2: Compute suffix products suffix_products = [1] * n for i in range(n-2, -1, -1): suffix_products[i] = (suffix_products[i+1] * A[i+1]) % MOD # Step 3: Compute the result B using prefix and suffix B = [1] * n for i in range(n): B[i] = (prefix_products[i] * suffix_products[i]) % MOD return B"},{"question":"def manage_inventory(current_inventory, transactions): Manage an inventory system for a shop. Args: current_inventory (dict): A dictionary with item names as keys and quantities as values. transactions (list): A list of transactions, each being a dictionary with 'item', 'type' (either 'add' or 'remove'), and 'quantity'. Returns: tuple: The updated inventory (a dictionary) and a list of failed transactions where items were not removed due to insufficient stock. Examples: >>> current_inventory = {'apple': 10, 'banana': 5, 'orange': 7} >>> transactions = [ >>> {'item': 'apple', 'type': 'remove', 'quantity': 3}, >>> {'item': 'banana', 'type': 'add', 'quantity': 2}, >>> {'item': 'orange', 'type': 'remove', 'quantity': 10}, >>> {'item': 'pear', 'type': 'add', 'quantity': 1} >>> ] >>> manage_inventory(current_inventory, transactions) ({'apple': 7, 'banana': 7, 'orange': 7, 'pear': 1}, [{'item': 'orange', 'quantity': 10}]) # Your code here from solution import manage_inventory def test_manage_inventory_basic(): current_inventory = {'apple': 10, 'banana': 5, 'orange': 7} transactions = [ {'item': 'apple', 'type': 'remove', 'quantity': 3}, {'item': 'banana', 'type': 'add', 'quantity': 2}, {'item': 'orange', 'type': 'remove', 'quantity': 10}, {'item': 'pear', 'type': 'add', 'quantity': 1} ] updated_inventory, failed_transactions = manage_inventory(current_inventory, transactions) assert updated_inventory == {'apple': 7, 'banana': 7, 'orange': 7, 'pear': 1} assert failed_transactions == [{'item': 'orange', 'quantity': 10}] def test_remove_more_than_exists(): current_inventory = {'apple': 5} transactions = [{'item': 'apple', 'type': 'remove', 'quantity': 10}] updated_inventory, failed_transactions = manage_inventory(current_inventory, transactions) assert updated_inventory == {'apple': 5} assert failed_transactions == [{'item': 'apple', 'quantity': 10}] def test_add_new_item(): current_inventory = {} transactions = [{'item': 'apple', 'type': 'add', 'quantity': 10}] updated_inventory, failed_transactions = manage_inventory(current_inventory, transactions) assert updated_inventory == {'apple': 10} assert failed_transactions == [] def test_multiple_transactions(): current_inventory = {'apple': 15, 'banana': 10} transactions = [ {'item': 'apple', 'type': 'remove', 'quantity': 5}, {'item': 'banana', 'type': 'remove', 'quantity': 3}, {'item': 'apple', 'type': 'add', 'quantity': 2}, {'item': 'banana', 'type': 'remove', 'quantity': 10} ] updated_inventory, failed_transactions = manage_inventory(current_inventory, transactions) assert updated_inventory == {'apple': 12, 'banana': 7} assert failed_transactions == [{'item': 'banana', 'quantity': 10}] def test_empty_transactions(): current_inventory = {'apple': 10} transactions = [] updated_inventory, failed_transactions = manage_inventory(current_inventory, transactions) assert updated_inventory == {'apple': 10} assert failed_transactions == []","solution":"def manage_inventory(current_inventory, transactions): failed_transactions = [] for transaction in transactions: item = transaction['item'] type_ = transaction['type'] quantity = transaction['quantity'] if type_ == 'add': if item in current_inventory: current_inventory[item] += quantity else: current_inventory[item] = quantity elif type_ == 'remove': if item in current_inventory and current_inventory[item] >= quantity: current_inventory[item] -= quantity else: failed_transactions.append({'item': item, 'quantity': quantity}) return current_inventory, failed_transactions"},{"question":"def check_parentheses(s: str) -> bool: Check if the parentheses in the input string are balanced. >>> check_parentheses(\\"(())\\") == True >>> check_parentheses(\\"(()\\") == False >>> check_parentheses(\\")(\\") == False >>> check_parentheses(\\"((()))\\") == True >>> check_parentheses(\\"()\\") == True >>> check_parentheses(\\"((()())\\") == False >>> check_parentheses(\\"\\") == True >>> check_parentheses(\\"(\\") == False","solution":"def check_parentheses(s): Checks if the parentheses in the input string are balanced. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Group words that are anagrams of each other. :param words: List of words (all lowercase English letters) :type words: List[str] :return: List of groups where each group contains anagrams :rtype: List[List[str]] pass # Unit tests def test_group_anagrams_example(): words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] result = group_anagrams(words) expected = [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_group_anagrams_empty_list(): words = [] result = group_anagrams(words) expected = [] assert result == expected def test_group_anagrams_no_anagrams(): words = [\\"abc\\", \\"def\\", \\"ghi\\"] result = group_anagrams(words) expected = [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_group_anagrams_all_anagrams(): words = [\\"abc\\", \\"bca\\", \\"cab\\"] result = group_anagrams(words) expected = [[\\"abc\\", \\"bca\\", \\"cab\\"]] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_group_anagrams_mixed_anagrams_and_non_anagrams(): words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\"] result = group_anagrams(words) expected = [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"google\\", \\"gogole\\"]] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected])","solution":"from collections import defaultdict def group_anagrams(words): Group words that are anagrams of each other. :param words: List of words (all lowercase English letters) :type words: List[str] :return: List of groups where each group contains anagrams :rtype: List[List[str]] anagrams = defaultdict(list) for word in words: # Sort the word and use it as a key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def min_subarrays_to_remove(arr): Given an array of integers, find the minimal number of continuous subarrays that need to be removed to make the remaining array strictly increasing. A strictly increasing array is one where every element is strictly greater than the one before it. >>> min_subarrays_to_remove([3, 5, 2, 6, 4, 8, 7]) 2 >>> min_subarrays_to_remove([1, 2, 3, 4, 5]) 0 from solution import min_subarrays_to_remove def test_small_array_already_increasing(): assert min_subarrays_to_remove([1, 2, 3, 4, 5]) == 0 def test_small_array_one_element(): assert min_subarrays_to_remove([1]) == 0 def test_array_needs_two_removals(): assert min_subarrays_to_remove([3, 5, 2, 6, 4, 8, 7]) == 2 def test_array_complete_non_increasing(): assert min_subarrays_to_remove([5, 4, 3, 2, 1]) == 1 def test_array_with_some_non_increasing_parts(): assert min_subarrays_to_remove([1, 3, 5, 4, 6, 2, 8]) == 2 def test_mixed_array_with_no_removal_needed(): assert min_subarrays_to_remove([1, 2, 5, 7, 8]) == 0","solution":"def min_subarrays_to_remove(arr): n = len(arr) if n <= 1: return 0 def is_strictly_increasing(arr): return all(arr[i] < arr[i+1] for i in range(len(arr)-1)) # Check if the array is already strictly increasing if is_strictly_increasing(arr): return 0 # Track the first and last non-increasing elements first_non_increasing = -1 last_non_increasing = -1 for i in range(n - 1): if arr[i] >= arr[i + 1]: if first_non_increasing == -1: first_non_increasing = i last_non_increasing = i # If complete array is non-increasing then we need entire array to be removed if first_non_increasing == 0 and last_non_increasing == n - 2: return 1 # The minimum number of subarrays to remove is either removing the prefix or suffix return 2 if first_non_increasing != -1 else 0"},{"question":"def longest_common_prefix(s: str, t: str) -> str: Find the longest common prefix of two strings s and t. >>> longest_common_prefix(\\"algorithm\\", \\"algebra\\") \\"alg\\" >>> longest_common_prefix(\\"abc\\", \\"xyz\\") \\"\\" >>> longest_common_prefix(\\"apple\\", \\"application\\") \\"appl\\" import pytest def test_longest_common_prefix_example1(): assert longest_common_prefix(\\"algorithm\\", \\"algebra\\") == \\"alg\\" def test_longest_common_prefix_example2(): assert longest_common_prefix(\\"abc\\", \\"xyz\\") == \\"\\" def test_longest_common_prefix_example3(): assert longest_common_prefix(\\"apple\\", \\"application\\") == \\"appl\\" def test_longest_common_prefix_no_common(): assert longest_common_prefix(\\"dog\\", \\"cat\\") == \\"\\" def test_longest_common_prefix_same_string(): assert longest_common_prefix(\\"same\\", \\"same\\") == \\"same\\" def test_longest_common_prefix_one_empty_string(): assert longest_common_prefix(\\"\\", \\"nonempty\\") == \\"\\" assert longest_common_prefix(\\"nonempty\\", \\"\\") == \\"\\" def test_longest_common_prefix_prefix_same(): assert longest_common_prefix(\\"prefix\\", \\"pre\\") == \\"pre\\" assert longest_common_prefix(\\"pre\\", \\"prefix\\") == \\"pre\\"","solution":"def longest_common_prefix(s: str, t: str) -> str: min_length = min(len(s), len(t)) for i in range(min_length): if s[i] != t[i]: return s[:i] return s[:min_length]"},{"question":"def is_path(grid): Determines if there is a path from the top-left corner to the bottom-right corner of the grid. >>> grid = [ ... [0, 0, 1], ... [1, 0, 0], ... [0, 0, 0] ... ] >>> is_path(grid) True >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> is_path(grid) False","solution":"def is_path(grid): Determines if there is a path from the top-left corner to the bottom-right corner of the grid. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False rows, cols = len(grid), len(grid[0]) from collections import deque queue = deque([(0, 0)]) visited = set((0, 0)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y = queue.popleft() if (x, y) == (rows-1, cols-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, edges: List[Tuple[int, int, int]], source: int, target: int) -> int: Find the shortest path from the source node to the target node in a graph. Parameters: n (int): Number of nodes in the graph. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w) with u and v being the nodes connected by an edge and w being the travel time. source (int): The source node. target (int): The target node. Returns: int: The total travel time of the shortest path from source to target. Returns -1 if no path exists. Examples: >>> dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1), (1, 5, 5)], 1, 5) 5 >>> dijkstra(4, [(1, 2, 6), (2, 3, 2), (3, 4, 5)], 1, 4) 13","solution":"import heapq def dijkstra(n, edges, source, target): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) min_heap = [(0, source)] distances = {i: float('inf') for i in range(1, n + 1)} distances[source] = 0 while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_node == target: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1"},{"question":"def square_and_sort(nums): Function to square each integer in the list and return a new list with the squares sorted in ascending order. :param nums: List of integers :return: List of integers squared and sorted pass # Test cases def test_square_and_sort_positive_numbers(): assert square_and_sort([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25] def test_square_and_sort_mixed_numbers(): assert square_and_sort([-4, -1, 0, 3, 10]) == [0, 1, 9, 16, 100] def test_square_and_sort_mixed_numbers_with_duplicates(): assert square_and_sort([-7, -3, 2, 3, 11]) == [4, 9, 9, 49, 121] def test_square_and_sort_all_negative(): assert square_and_sort([-5, -3, -1]) == [1, 9, 25] def test_square_and_sort_all_positive(): assert square_and_sort([1, 3, 6]) == [1, 9, 36] def test_square_and_sort_zero_inclusion(): assert square_and_sort([-2, 0, 2]) == [0, 4, 4] def test_square_and_sort_single_element(): assert square_and_sort([5]) == [25] assert square_and_sort([-5]) == [25]","solution":"def square_and_sort(nums): Function to square each integer in the list and return a new list with the squares sorted in ascending order. :param nums: List of integers :return: List of integers squared and sorted squared_nums = [num ** 2 for num in nums] return sorted(squared_nums)"},{"question":"def calculate_final_total(purchase_amounts): This function takes a list of purchase amounts and returns a corresponding list of final amounts after applying the discount. def apply_discounts(N, amounts): Given the number of customers and a list of purchase amounts, calculate the final total for each customer after applying discounts. This function prints the final totals correct to 2 decimal places. if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split('n') N = int(data[0]) amounts = [float(amount) for amount in data[1:N+1]] apply_discounts(N, amounts) # Sample test cases def test_calculate_final_total_no_discount(): assert calculate_final_total([45.50]) == [45.50] assert calculate_final_total([50.00]) == [50.00] def test_calculate_final_total_ten_percent_discount(): assert calculate_final_total([75.00]) == [67.50] assert calculate_final_total([100.00]) == [90.00] def test_calculate_final_total_twenty_percent_discount(): assert calculate_final_total([120.00]) == [96.00] assert calculate_final_total([200.00]) == [160.00] def test_apply_discounts(capsys): apply_discounts(3, [45.50, 120.00, 75.00]) captured = capsys.readouterr() assert captured.out == \\"45.50n96.00n67.50n\\" def test_case_mixed_discounts(capsys): apply_discounts(4, [45.50, 90.00, 150.00, 50.00]) captured = capsys.readouterr() assert captured.out == \\"45.50n81.00n120.00n50.00n\\" def test_case_edge_cases(capsys): apply_discounts(3, [50.00, 50.01, 100.00]) captured = capsys.readouterr() assert captured.out == \\"50.00n45.01n90.00n\\"","solution":"def calculate_final_total(purchase_amounts): This function takes a list of purchase amounts and returns a corresponding list of final amounts after applying the discount. final_amounts = [] for amount in purchase_amounts: if amount <= 50: final_amounts.append(round(amount, 2)) elif 50 < amount <= 100: final_amounts.append(round(amount * 0.90, 2)) else: final_amounts.append(round(amount * 0.80, 2)) return final_amounts def apply_discounts(N, amounts): Given the number of customers and a list of purchase amounts, calculating the final total for each customer after applying discounts. This function prints the final totals correct to 2 decimal places. final_totals = calculate_final_total(amounts) for total in final_totals: print(format(total, \\".2f\\"))"},{"question":"def find_largest_square_subgrid(grid): Finds the size of the largest square subgrid where all the panels produce the same amount of energy. Args: grid: A 2D list of integers representing the energy produced by the solar panels. Returns: An integer representing the size of the largest square region where all the panels produce the same amount of energy. >>> find_largest_square_subgrid([[1, 1, 1, 1, 2, 2], [1, 1, 1, 3, 4, 4], [1, 1, 1, 3, 4, 4], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5]]) 3 >>> find_largest_square_subgrid([[2, 2, 2, 2], [2, 2, 1, 1], [2, 2, 1, 1], [3, 3, 3, 3]]) 2 def largest_square_subgrid(T, test_cases): Finds the sizes of the largest square subgrids for multiple test cases. Args: T: An integer representing the number of test cases. test_cases: A list of tuples, where each tuple contains the dimensions of the grid and the grid itself. Returns: A list of integers representing the sizes of the largest square regions for each test case. >>> largest_square_subgrid(2, [(5, 6, [[1, 1, 1, 1, 2, 2], [1, 1, 1, 3, 4, 4], [1, 1, 1, 3, 4, 4], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5]]), (4, 4, [[2, 2, 2, 2], [2, 2, 1, 1], [2, 2, 1, 1], [3, 3, 3, 3]])]) [3, 2] def test_find_largest_square_subgrid(): grid1 = [ [1, 1, 1, 1, 2, 2], [1, 1, 1, 3, 4, 4], [1, 1, 1, 3, 4, 4], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5] ] assert find_largest_square_subgrid(grid1) == 3 grid2 = [ [2, 2, 2, 2], [2, 2, 1, 1], [2, 2, 1, 1], [3, 3, 3, 3] ] assert find_largest_square_subgrid(grid2) == 2 grid3 = [ [1] ] assert find_largest_square_subgrid(grid3) == 1 grid4 = [ [1, 1], [1, 1] ] assert find_largest_square_subgrid(grid4) == 2 def test_largest_square_subgrid(): test_cases = [ (5, 6, [ [1, 1, 1, 1, 2, 2], [1, 1, 1, 3, 4, 4], [1, 1, 1, 3, 4, 4], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5] ]), (4, 4, [ [2, 2, 2, 2], [2, 2, 1, 1], [2, 2, 1, 1], [3, 3, 3, 3] ]) ] T = 2 expected_results = [3, 2] assert largest_square_subgrid(T, test_cases) == expected_results","solution":"def find_largest_square_subgrid(grid): N = len(grid) M = len(grid[0]) dp = [[0] * M for _ in range(N)] max_side = 0 for i in range(N): for j in range(M): if i == 0 or j == 0: dp[i][j] = 1 else: if grid[i][j] == grid[i-1][j] == grid[i][j-1] == grid[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side = max(max_side, dp[i][j]) return max_side def largest_square_subgrid(T, test_cases): results = [] for case in test_cases: N, M, grid = case results.append(find_largest_square_subgrid(grid)) return results"},{"question":"def rearrange_queue(visitor_ids): Rearrange the visitor ID numbers such that all the priority ID numbers (even) are served before all the regular ID numbers (odd). The order of arrival is maintained within each group. Parameters: visitor_ids (list): A list of integers representing visitor ID numbers. Returns: list: A list of visitor ID numbers rearranged according to the rules. Example: >>> rearrange_queue([5, 3, 2, 4, 1]) [2, 4, 5, 3, 1] >>> rearrange_queue([7, 8, 6, 3, 11, 10]) [8, 6, 10, 7, 3, 11] from solution import rearrange_queue def test_rearrange_queue_mixed(): assert rearrange_queue([5, 3, 2, 4, 1]) == [2, 4, 5, 3, 1] assert rearrange_queue([7, 8, 6, 3, 11, 10]) == [8, 6, 10, 7, 3, 11] def test_rearrange_queue_priority_only(): assert rearrange_queue([2, 4, 6, 8]) == [2, 4, 6, 8] def test_rearrange_queue_regular_only(): assert rearrange_queue([1, 3, 5, 7]) == [1, 3, 5, 7] def test_rearrange_queue_empty(): assert rearrange_queue([]) == [] def test_rearrange_queue_one_element(): assert rearrange_queue([2]) == [2] assert rearrange_queue([1]) == [1] def test_rearrange_queue_all_same_priority(): assert rearrange_queue([4, 2, 6, 8]) == [4, 2, 6, 8] assert rearrange_queue([1, 3, 5, 7]) == [1, 3, 5, 7]","solution":"def rearrange_queue(visitor_ids): Rearrange the visitor ID numbers such that all the priority ID numbers (even) are served before all the regular ID numbers (odd). The order of arrival is maintained within each group. Parameters: visitor_ids (list): A list of integers representing visitor ID numbers. Returns: list: A list of visitor ID numbers rearranged according to the rules. priority_queue = [vid for vid in visitor_ids if vid % 2 == 0] regular_queue = [vid for vid in visitor_ids if vid % 2 != 0] return priority_queue + regular_queue"},{"question":"def longest_increasing_playlist(history: List[int]) -> int: Returns the length of the longest contiguous playlist of sequentially increasing song IDs. >>> longest_increasing_playlist([3, 4, 5, 1, 2, 3, 7, 8, 9, 10]) 4 >>> longest_increasing_playlist([1, 2, 3, 4, 5]) 5 >>> longest_increasing_playlist([10, 15, 20]) 1 >>> longest_increasing_playlist([3, 4, 2, 1, 2, 3, 4, 1, 2, 3, 4, 5]) 5","solution":"def longest_increasing_playlist(history): Returns the length of the longest contiguous playlist of sequentially increasing song IDs. if not history: return 0 max_length = 1 current_length = 1 for i in range(1, len(history)): if history[i] == history[i - 1] + 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def sum_of_primes(array): Function to calculate the sum of all prime numbers in an array. >>> sum_of_primes([2, 3, 4, 5, 6]) 10 >>> sum_of_primes([4, 6, 8, 10, 12]) 0 >>> sum_of_primes([1, 1, 2, 2, 2]) 6","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def sum_of_primes(array): Function to calculate the sum of all prime numbers in an array. return sum(num if is_prime(num) else 0 for num in array)"},{"question":"def countDistinctSubstrings(s: str) -> int: Given a string, determine the number of distinct substrings (including single character substrings) that can be formed from it. >>> countDistinctSubstrings(\\"ab\\") 3 >>> countDistinctSubstrings(\\"aaa\\") 3 >>> countDistinctSubstrings(\\"abc\\") 6","solution":"def countDistinctSubstrings(s): substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def find_nth_term(a, d, n): Returns the n-th term of an arithmetic sequence given the initial term a, the common difference d, and the position n. >>> find_nth_term(2, 3, 4) 11 >>> find_nth_term(1, -5, 10) -44 >>> find_nth_term(7, 0, 5) 7 def process_test_cases(T, test_cases): Processes multiple test cases for finding the n-th term in arithmetic sequences. >>> T = 3 >>> test_cases = [(2, 3, 4), (1, -5, 10), (7, 0, 5)] >>> process_test_cases(T, test_cases) [11, -44, 7]","solution":"def find_nth_term(a, d, n): Returns the n-th term of an arithmetic sequence given the initial term a, the common difference d, and the position n. return a + (n - 1) * d def process_test_cases(T, test_cases): Processes multiple test cases for finding the n-th term in arithmetic sequences. results = [] for a, d, n in test_cases: results.append(find_nth_term(a, d, n)) return results"},{"question":"def formattedDate(): Return the current date and time in \\"YYYY-MM-DD HH:MM:SS\\" format.","solution":"from datetime import datetime def formattedDate(): Returns the current date and time in \\"YYYY-MM-DD HH:MM:SS\\" format. now = datetime.now() return now.strftime(\\"%Y-%m-%d %H:%M:%S\\")"},{"question":"def distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the given string. >>> distinct_substrings(\\"abcd\\") 10 >>> distinct_substrings(\\"aaa\\") 3 >>> distinct_substrings(\\"abcb\\") 9 >>> distinct_substrings(\\"abab\\") 7 from unittest import TestCase class TestDistinctSubstrings(TestCase): def test_distinct_substrings_basic(self): self.assertEqual(distinct_substrings(\\"abcd\\"), 10) def test_distinct_substrings_repeated_chars(self): self.assertEqual(distinct_substrings(\\"aaa\\"), 3) def test_distinct_substrings_mixed_chars(self): self.assertEqual(distinct_substrings(\\"abcb\\"), 9) def test_distinct_substrings_alternating_chars(self): self.assertEqual(distinct_substrings(\\"abab\\"), 7) def test_distinct_substrings_single_char(self): self.assertEqual(distinct_substrings(\\"a\\"), 1) def test_distinct_substrings_double_char_same(self): self.assertEqual(distinct_substrings(\\"aa\\"), 2) def test_distinct_substrings_double_char_different(self): self.assertEqual(distinct_substrings(\\"ab\\"), 3) def test_distinct_substrings_longer_string(self): s = \\"abcdef\\" expected = 21 # 1+2+3+4+5+6 = 21 distinct substrings self.assertEqual(distinct_substrings(s), expected) if __name__ == \\"__main__\\": unittest.main()","solution":"def distinct_substrings(s): Returns the number of distinct substrings of the given string s. n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def cumulative_sum(numbers: List[int]) -> List[int]: Given a list of integers, return the cumulative sum of the elements at each index. Example: >>> cumulative_sum([1, 2, 3, 4]) # => [1, 3, 6, 10] >>> cumulative_sum([4, 3, 2, 1]) # => [4, 7, 9, 10]","solution":"def cumulative_sum(numbers): Given a list of integers, return the cumulative sum of the elements at each index. Parameters: numbers (list): A list of integers. Returns: list: A list containing the cumulative sum at each index. result = [] total = 0 for number in numbers: total += number result.append(total) return result"},{"question":"def is_path_possible(maze: List[str]) -> str: Determine whether it is possible to start from the top-left corner of the maze and reach the bottom-right corner. >>> is_path_possible([\\"..\\", \\"..\\"]) \\"YES\\" >>> is_path_possible([\\"#.\\", \\"..\\"]) \\"NO\\" >>> is_path_possible([\\"..#.\\", \\".#..\\", \\"..#.\\", \\"#.\\"]) \\"NO\\" >>> is_path_possible([\\"...\\", \\"#.#\\", \\"...\\"]) \\"YES\\" def solve_mazes(test_cases: List[List[str]]) -> List[str]: For each test case, determine if there is a path from the top-left to the bottom-right corner. >>> solve_mazes([[\\"..#.\\", \\".#..\\", \\"..#.\\", \\"#.\\"], [\\"...\\", \\"#.#\\", \\"...\\"]]) [\\"NO\\", \\"YES\\"]","solution":"def is_path_possible(maze): N = len(maze) visited = [[False]*N for _ in range(N)] def dfs(x, y): if x == N-1 and y == N-1: return True visited[x][y] = True directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny] and maze[nx][ny] == '.': if dfs(nx, ny): return True return False if maze[0][0] == '#' or maze[N-1][N-1] == '#': return \\"NO\\" return \\"YES\\" if dfs(0, 0) else \\"NO\\" def solve_mazes(test_cases): results = [] for maze in test_cases: results.append(is_path_possible(maze)) return results"},{"question":"from typing import List def generate_combinations(n: int, k: int) -> List[List[int]]: Generate all possible combinations of k colors from a palette of n colors. Args: n (int): The number of colors in the palette. k (int): The number of colors in each combination. Returns: list of list of int: A list of all possible k-color combinations from the n-color palette. >>> generate_combinations(4, 2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> generate_combinations(5, 3) [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]] >>> generate_combinations(3, 1) [[1], [2], [3]] >>> generate_combinations(5, 5) [[1, 2, 3, 4, 5]] >>> generate_combinations(2, 2) [[1, 2]]","solution":"from itertools import combinations def generate_combinations(n, k): Generate all possible combinations of k colors from a palette of n colors. Args: n (int): The number of colors in the palette. k (int): The number of colors in each combination. Returns: list of list of int: A list of all possible k-color combinations from the n-color palette. return [list(c) for c in combinations(range(1, n + 1), k)]"},{"question":"import heapq class SpecialPriorityQueue: def __init__(self): self.heap = [] def insert(self, element): Inserts an element into the priority queue. :param element: An integer to be inserted into the priority queue. pass def remove_max(self): Removes and returns the maximum element from the priority queue. :return: The maximum element in the priority queue, or \\"Error!\\" if the queue is empty. pass def get_max(self): Returns the maximum element from the priority queue without removing it. :return: The maximum element in the priority queue, or \\"Error!\\" if the queue is empty. pass def get_kth_largest(self, k): Returns the k-th largest element from the priority queue. :param k: The rank of the element to be retrieved. :return: The k-th largest element in the priority queue, or \\"Error!\\" if k is out of bounds. pass def test_insert_and_get_max(): spq = SpecialPriorityQueue() spq.insert(3) spq.insert(5) spq.insert(1) assert spq.get_max() == 5 def test_remove_max(): spq = SpecialPriorityQueue() spq.insert(3) spq.insert(5) spq.insert(1) assert spq.remove_max() == 5 assert spq.get_max() == 3 def test_get_max_empty_queue(): spq = SpecialPriorityQueue() assert spq.get_max() == \\"Error!\\" def test_remove_max_empty_queue(): spq = SpecialPriorityQueue() assert spq.remove_max() == \\"Error!\\" def test_get_kth_largest(): spq = SpecialPriorityQueue() spq.insert(3) spq.insert(5) spq.insert(1) spq.insert(7) spq.insert(2) assert spq.get_kth_largest(3) == 3 assert spq.get_kth_largest(1) == 7 assert spq.get_kth_largest(5) == 1 def test_get_kth_largest_out_of_bounds(): spq = SpecialPriorityQueue() spq.insert(3) spq.insert(5) assert spq.get_kth_largest(0) == \\"Error!\\" assert spq.get_kth_largest(3) == \\"Error!\\"","solution":"import heapq class SpecialPriorityQueue: def __init__(self): self.heap = [] def insert(self, element): # We use a negative value to simulate a max-heap heapq.heappush(self.heap, -element) def remove_max(self): if not self.heap: return \\"Error!\\" return -heapq.heappop(self.heap) def get_max(self): if not self.heap: return \\"Error!\\" return -self.heap[0] def get_kth_largest(self, k): if k < 1 or k > len(self.heap): return \\"Error!\\" # Create a copy of the heap to pop elements without affecting the original heap temp_heap = self.heap[:] max_elements = [] for _ in range(k): max_elements.append(-heapq.heappop(temp_heap)) return max_elements[-1]"},{"question":"def unique_paths(N: int, M: int, X: int, Y: int) -> int: Calculate the number of unique paths from (X, Y) to (N, M) in a grid of size N x M where only moves to the right or down are allowed. Parameters: N (int): number of rows M (int): number of columns X (int): starting row Y (int): starting column Returns: int: number of unique paths from (X, Y) to (N, M) # Implementation here # Test cases def test_unique_paths_3x3_start_1_1(): assert unique_paths(3, 3, 1, 1) == 6 def test_unique_paths_3x3_start_1_2(): assert unique_paths(3, 3, 1, 2) == 3 def test_unique_paths_3x3_start_2_1(): assert unique_paths(3, 3, 2, 1) == 3 def test_unique_paths_4x4_start_1_1(): assert unique_paths(4, 4, 1, 1) == 20 def test_unique_paths_2x2_start_1_1(): assert unique_paths(2, 2, 1, 1) == 2 def test_unique_paths_edge_case_same_start_end(): assert unique_paths(5, 5, 5, 5) == 1 def test_unique_paths_minimum_grid(): assert unique_paths(1, 1, 1, 1) == 1 def test_unique_paths_large_grid(): assert unique_paths(20, 20, 1, 1) == 35345263800","solution":"def unique_paths(N, M, X, Y): Calculate the number of unique paths from (X, Y) to (N, M) in a grid of size N x M where only moves to the right or down are allowed. Parameters: N (int): number of rows M (int): number of columns X (int): starting row Y (int): starting column Returns: int: number of unique paths from (X, Y) to (N, M) # Initialize a table to store the number of paths to each cell dp = [[0] * (M + 1) for _ in range(N + 1)] # Set the starting position dp[X][Y] = 1 # Fill the dp table for i in range(X, N + 1): for j in range(Y, M + 1): if i > X: dp[i][j] += dp[i-1][j] # Move from top if j > Y: dp[i][j] += dp[i][j-1] # Move from left return dp[N][M]"},{"question":"def sort_tasks(n, tasks, criteria, order): Sorts the tasks based on the given criteria and order. Args: n : int : Number of tasks tasks : List[Tuple] : List of tasks where each task is represented as a tuple criteria : str : The criteria to sort by (\\"time\\", \\"duration\\", or \\"priority\\") order : str : The order to sort by (\\"asc\\" or \\"desc\\") Returns: List[Tuple] : Sorted list of tasks pass # Test cases from solution import sort_tasks def test_sort_by_time_asc(): tasks = [('t1', 'Fix bug', '09:00', 2, 3), ('t2', 'Develop feature', '14:00', 5, 2), ('t3', 'Write tests', '11:00', 3, 1)] sorted_tasks = sort_tasks(3, tasks, 'time', 'asc') assert sorted_tasks == [ ('t1', 'Fix bug', '09:00', 2, 3), ('t3', 'Write tests', '11:00', 3, 1), ('t2', 'Develop feature', '14:00', 5, 2) ] def test_sort_by_time_desc(): tasks = [('t1', 'Fix bug', '09:00', 2, 3), ('t2', 'Develop feature', '14:00', 5, 2), ('t3', 'Write tests', '11:00', 3, 1)] sorted_tasks = sort_tasks(3, tasks, 'time', 'desc') assert sorted_tasks == [ ('t2', 'Develop feature', '14:00', 5, 2), ('t3', 'Write tests', '11:00', 3, 1), ('t1', 'Fix bug', '09:00', 2, 3) ] def test_sort_by_duration_asc(): tasks = [('t1', 'Fix bug', '09:00', 2, 3), ('t2', 'Develop feature', '14:00', 5, 2), ('t3', 'Write tests', '11:00', 3, 1)] sorted_tasks = sort_tasks(3, tasks, 'duration', 'asc') assert sorted_tasks == [ ('t1', 'Fix bug', '09:00', 2, 3), ('t3', 'Write tests', '11:00', 3, 1), ('t2', 'Develop feature', '14:00', 5, 2) ] def test_sort_by_duration_desc(): tasks = [('t1', 'Fix bug', '09:00', 2, 3), ('t2', 'Develop feature', '14:00', 5, 2), ('t3', 'Write tests', '11:00', 3, 1)] sorted_tasks = sort_tasks(3, tasks, 'duration', 'desc') assert sorted_tasks == [ ('t2', 'Develop feature', '14:00', 5, 2), ('t3', 'Write tests', '11:00', 3, 1), ('t1', 'Fix bug', '09:00', 2, 3) ] def test_sort_by_priority_asc(): tasks = [('t1', 'Fix bug', '09:00', 2, 3), ('t2', 'Develop feature', '14:00', 5, 2), ('t3', 'Write tests', '11:00', 3, 1)] sorted_tasks = sort_tasks(3, tasks, 'priority', 'asc') assert sorted_tasks == [ ('t3', 'Write tests', '11:00', 3, 1), ('t2', 'Develop feature', '14:00', 5, 2), ('t1', 'Fix bug', '09:00', 2, 3) ] def test_sort_by_priority_desc(): tasks = [('t1', 'Fix bug', '09:00', 2, 3), ('t2', 'Develop feature', '14:00', 5, 2), ('t3', 'Write tests', '11:00', 3, 1)] sorted_tasks = sort_tasks(3, tasks, 'priority', 'desc') assert sorted_tasks == [ ('t1', 'Fix bug', '09:00', 2, 3), ('t2', 'Develop feature', '14:00', 5, 2), ('t3', 'Write tests', '11:00', 3, 1) ]","solution":"def sort_tasks(n, tasks, criteria, order): Sorts the tasks based on the given criteria and order. Args: n : int : Number of tasks tasks : List[Tuple] : List of tasks where each task is represented as a tuple criteria : str : The criteria to sort by (\\"time\\", \\"duration\\", or \\"priority\\") order : str : The order to sort by (\\"asc\\" or \\"desc\\") Returns: List[Tuple] : Sorted list of tasks # Define sorting key based on criteria if criteria == \\"time\\": key_func = lambda x: x[2] elif criteria == \\"duration\\": key_func = lambda x: x[3] elif criteria == \\"priority\\": key_func = lambda x: x[4] else: raise ValueError(\\"Invalid sorting criteria\\") # Sort based on the key function and order reverse = (order == \\"desc\\") sorted_tasks = sorted(tasks, key=key_func, reverse=reverse) return sorted_tasks"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_trees(n: int) -> List[Optional[TreeNode]]: Create a list of all structurally unique BSTs with n nodes of unique values from 1 to n. >>> len(generate_trees(3)) 5 >>> len(generate_trees(1)) 1 pass def serialize_tree(root: TreeNode): Serialize the tree for level order traversal with 'null' for empty nodes. >>> serialize_tree(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) [1, 'null', 2, 'null', 3] >>> serialize_tree(TreeNode(2, TreeNode(1, TreeNode(3)))) [2, 1, 'null', 3] pass def generate_and_serialize_trees(n: int) -> List[List[Optional[int]]]: >>> generate_and_serialize_trees(1) [[1]] >>> generate_and_serialize_trees(2) [[1, 'null', 2], [2, 1]] pass from solution import generate_and_serialize_trees def test_generate_trees_case_1(): result = generate_and_serialize_trees(1) expected = [[1]] assert result == expected def test_generate_trees_case_2(): result = generate_and_serialize_trees(2) expected = [ [1, \\"null\\", 2], [2, 1] ] assert result == expected def test_generate_trees_case_3(): result = generate_and_serialize_trees(3) expected = [ [1, \\"null\\", 2, \\"null\\", 3], [1, \\"null\\", 3, 2], [2, 1, 3], [3, 1, \\"null\\", \\"null\\", 2], [3, 2, \\"null\\", 1] ] assert(result) == expected def test_generate_trees_case_4(): result = generate_and_serialize_trees(0) expected = [] assert result == expected def test_generate_trees_case_large(): result = generate_and_serialize_trees(4) assert len(result) == 14 # There are 14 unique BSTs for n=4","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_trees(n: int) -> List[Optional[TreeNode]]: if n == 0: return [] def generate_trees_range(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate_trees_range(start, i - 1) right_trees = generate_trees_range(i + 1, end) for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees return generate_trees_range(1, n) def serialize_tree(root: TreeNode): Serialize the tree for level order traversal with 'null' for empty nodes. from collections import deque if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(\\"null\\") # Remove trailing nulls while result and result[-1] == \\"null\\": result.pop() return result def generate_and_serialize_trees(n: int) -> List[List[Optional[int]]]: trees = generate_trees(n) return [serialize_tree(tree) for tree in trees]"},{"question":"from typing import List def all_unique(arr: List[int]) -> bool: Determines if all elements in the array are unique. Args: arr (List[int]): A list of integers. Returns: bool: True if all elements are unique, False otherwise. >>> all_unique([1, 2, 3, 4, 5]) True >>> all_unique([1, 2, 2, 4, 5]) False >>> all_unique([0]) True >>> all_unique([]) True >>> all_unique([-1, -2, -3, -4, -5]) True >>> all_unique([1, -1, 2, -2, 0]) True >>> all_unique([1000000000, -1000000000]) True >>> all_unique([1000000000, 1000000000]) False","solution":"from typing import List def all_unique(arr: List[int]) -> bool: Determines if all elements in the array are unique. Args: arr (List[int]): A list of integers. Returns: bool: True if all elements are unique, False otherwise. return len(arr) == len(set(arr))"},{"question":"def reorder_elements(input_string: str) -> str: Reorders elements of the input string such that all numbers come first in ascending order followed by all words in lexicographical order (case-insensitive). :param input_string: str, a space-separated string of numbers and words :return: str, a new string with numbers sorted at the front followed by words sorted in lexicographical order >>> reorder_elements(\\"apple 2 banana 1 orange 10 5\\") '1 2 5 10 apple banana orange' >>> reorder_elements(\\"10 3 5 1 2\\") '1 2 3 5 10' >>> reorder_elements(\\"banana apple orange\\") 'apple banana orange' >>> reorder_elements(\\"\\") '' >>> reorder_elements(\\"10 5 5 1 1 2 2\\") '1 1 2 2 5 5 10' >>> reorder_elements(\\"Apple apple Banana banana Orange orange\\") 'Apple apple Banana banana Orange orange' >>> reorder_elements(\\"1 apple 3 banana-2 orange\\") '1 3 apple banana-2 orange'","solution":"def reorder_elements(input_string): Reorders elements of the input string such that all numbers come first in ascending order followed by all words in lexicographical order (case-insensitive). :param input_string: str, a space-separated string of numbers and words :return: str, a new string with numbers sorted at the front followed by words sorted in lexicographical order elements = input_string.split() numbers = sorted([int(e) for e in elements if e.isdigit()]) words = sorted([e for e in elements if not e.isdigit()], key=lambda s: s.lower()) sorted_numbers = ' '.join(map(str, numbers)) sorted_words = ' '.join(words) return f\\"{sorted_numbers} {sorted_words}\\".strip()"},{"question":"def length_of_longest_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with no repeating elements. >>> length_of_longest_subarray([1, 2, 3, 4, 5]) 5 >>> length_of_longest_subarray([2, 6, 4, 2, 3, 4, 5, 6, 7, 8]) 7 >>> length_of_longest_subarray([1]) 1 >>> length_of_longest_subarray([1, 1, 1, 1]) 1 >>> length_of_longest_subarray([1, 2, 1, 3, 4, 3, 5]) 4 >>> length_of_longest_subarray([]) 0","solution":"def length_of_longest_subarray(arr): Returns the length of the longest contiguous subarray with no repeating elements. n = len(arr) if n == 0: return 0 max_length = 0 start = 0 seen = {} for end in range(n): if arr[end] in seen and seen[arr[end]] >= start: start = seen[arr[end]] + 1 seen[arr[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def max_subsequence_sum(nums: List[int]) -> int: Returns the maximum subsequence sum. >>> max_subsequence_sum([1, 2, 3, 4, 5]) == 15 >>> max_subsequence_sum([1, -2, 3, 4, -1, 2]) == 10 >>> max_subsequence_sum([-2, -3, -1, -4]) == -1 >>> max_subsequence_sum([5]) == 5 >>> max_subsequence_sum([-5]) == -5 >>> max_subsequence_sum([0, 1, 2, 0, 3]) == 6 >>> max_subsequence_sum([0, 0, 0]) == 0 pass","solution":"from typing import List def max_subsequence_sum(nums: List[int]) -> int: Returns the maximum subsequence sum. If the list contains only negative numbers, return the maximum single element. # If all numbers are non-positive, return the least negative number (which is the highest among them) if all(num <= 0 for num in nums): return max(nums) # Initialize sum max_sum = 0 # Sum all positive numbers for num in nums: if num > 0: max_sum += num return max_sum"},{"question":"def mostFrequentCharacter(s: str) -> str: Returns the character that appears most frequently in the string \`s\`. If there are multiple characters with the same highest frequency, returns the one that appears first in the string. Spaces are ignored. >>> mostFrequentCharacter(\\"a\\") \\"a\\" >>> mostFrequentCharacter(\\"abac\\") \\"a\\" >>> mostFrequentCharacter(\\"a b c a\\") \\"a\\" >>> mostFrequentCharacter(\\"aabbccdd\\") \\"a\\" >>> mostFrequentCharacter(\\"aAA\\") \\"A\\" >>> mostFrequentCharacter(\\"abcd\\") \\"a\\" >>> mostFrequentCharacter(\\"a b a b c c c\\") \\"c\\"","solution":"def mostFrequentCharacter(s): Returns the character that appears most frequently in the string \`s\`. If there are multiple characters with the same highest frequency, returns the one that appears first in the string. Spaces are ignored. :param s: input string :return: character that appears most frequently frequency = {} max_count = 0 most_frequent_char = None for char in s: if char == ' ': continue if char in frequency: frequency[char] += 1 else: frequency[char] = 1 if frequency[char] > max_count or (frequency[char] == max_count and most_frequent_char is None): max_count = frequency[char] most_frequent_char = char return most_frequent_char"},{"question":"class TimeMap: A class to store and retrieve key-value pairs with associated timestamps. def __init__(self): Initialize the data structure here. def set(self, key: str, value: str, timestamp: int) -> None: Stores the key with the value and timestamp. def get(self, key: str, timestamp: int) -> str: Retrieves the value associated with the key at the largest timestamp less than or equal to the given timestamp. # Unit tests def test_time_map(): kv = TimeMap() kv.set(\\"foo\\", \\"bar\\", 1) kv.set(\\"foo\\", \\"bar2\\", 4) assert kv.get(\\"foo\\", 1) == \\"bar\\" assert kv.get(\\"foo\\", 3) == \\"bar\\" kv.set(\\"foo\\", \\"bar3\\", 7) assert kv.get(\\"foo\\", 5) == \\"bar2\\" assert kv.get(\\"foo\\", 10) == \\"bar3\\" def test_empty_key(): kv = TimeMap() assert kv.get(\\"foo\\", 1) == \\"\\" def test_multiple_keys(): kv = TimeMap() kv.set(\\"foo\\", \\"bar1\\", 1) kv.set(\\"foo2\\", \\"bar2\\", 2) kv.set(\\"foo\\", \\"bar3\\", 3) assert kv.get(\\"foo\\", 2) == \\"bar1\\" assert kv.get(\\"foo2\\", 2) == \\"bar2\\" assert kv.get(\\"foo\\", 4) == \\"bar3\\" def test_same_timestamp(): kv = TimeMap() kv.set(\\"foo\\", \\"bar1\\", 1) kv.set(\\"foo\\", \\"bar2\\", 1) assert kv.get(\\"foo\\", 1) == \\"bar2\\"","solution":"class TimeMap: def __init__(self): Initialize the data structure here. self.store = {} def set(self, key: str, value: str, timestamp: int) -> None: Stores the key with the value and timestamp. if key not in self.store: self.store[key] = [] self.store[key].append((timestamp, value)) def get(self, key: str, timestamp: int) -> str: Retrieves the value associated with the key at the largest timestamp less than or equal to the given timestamp. if key not in self.store: return \\"\\" values = self.store[key] # Binary search to find the right timestamp left, right = 0, len(values) - 1 while left <= right: mid = (left + right) // 2 if values[mid][0] <= timestamp: left = mid + 1 else: right = mid - 1 return values[right][1] if right >= 0 else \\"\\""},{"question":"def longest_prefix_suffix(S: str) -> str: Returns the longest prefix of the string which is also a suffix. >>> longest_prefix_suffix(\\"abcd\\") == \\"\\" >>> longest_prefix_suffix(\\"aaa\\") == \\"aa\\" >>> longest_prefix_suffix(\\"ababcab\\") == \\"ab\\" >>> longest_prefix_suffix(\\"abcab\\") == \\"ab\\" >>> longest_prefix_suffix(\\"a\\") == \\"\\" >>> longest_prefix_suffix(\\"abc\\") == \\"\\" >>> longest_prefix_suffix(\\"aabcaabc\\") == \\"aabc\\"","solution":"def longest_prefix_suffix(S): Returns the longest prefix of the string which is also a suffix. n = len(S) lps = [0] * n # lps array to hold the longest prefix suffix values # Preprocess the pattern (calculate lps array) length = 0 # length of the previous longest prefix suffix i = 1 while i < n: if S[i] == S[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 # The lps[n-1] will contain the length of the longest prefix which is also suffix longest = lps[n-1] # Checking if the length is not equal to n, since prefix and suffix should not overlap if longest > 0 and longest < n: return S[:longest] else: return \\"\\""},{"question":"from typing import List def unique_permutations(s: str) -> List[str]: Returns all unique permutations of the input string, sorted in lexicographic order. >>> unique_permutations(\\"aabc\\") [\\"aabc\\", \\"aacb\\", \\"abac\\", \\"abca\\", \\"acab\\", \\"acba\\", \\"baac\\", \\"baca\\", \\"bcaa\\", \\"caab\\", \\"caba\\", \\"cbaa\\"] >>> unique_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> unique_permutations(\\"aaa\\") [\\"aaa\\"]","solution":"from itertools import permutations def unique_permutations(s): Returns all unique permutations of the input string, sorted in lexicographic order. # Generate all permutations all_perms = set(permutations(s)) # Convert tuples to strings and sort the result unique_perms = sorted([''.join(p) for p in all_perms]) return unique_perms"},{"question":"from typing import List def swap_toys(toys: List[str]) -> List[str]: Redistribute toys so that no child ends up with the toy they brought. Args: toys (List[str]): List of strings representing the toys brought by children. Returns: List[str]: List of strings where the toys have been swapped according to the given rules. Example: >>> swap_toys([\\"doll\\", \\"car\\", \\"blocks\\", \\"ball\\"]) [\\"car\\", \\"blocks\\", \\"ball\\", \\"doll\\"] >>> swap_toys([\\"car\\", \\"doll\\"]) [\\"doll\\", \\"car\\"] >>> swap_toys([\\"doll\\"]) [\\"doll\\"] pass","solution":"from typing import List def swap_toys(toys: List[str]) -> List[str]: n = len(toys) # If there's only one toy, its impossible to swap if n == 1: return toys # Create a new array for holding the result swapped_toys = toys[:] # Simple rotating shift for i in range(n): # Move each toy to the next position, wrapping around at the end swapped_toys[i] = toys[(i + 1) % n] return swapped_toys"},{"question":"def valid_chains(C: int, L: int) -> int: Returns the number of valid chains of length L using C different colors. >>> valid_chains(3, 3) 12 >>> valid_chains(2, 4) 2 pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Generates the number of valid chains for multiple test cases. >>> solve([(3, 3), (2, 4), (1, 5), (4, 1)]) [12, 2, 0, 4] >>> solve([(1, 1), (100, 1), (100, 100)]) [1, 100, 100 * 99**99] pass import pytest def test_valid_chains_basic(): assert valid_chains(3, 3) == 12 assert valid_chains(2, 4) == 2 assert valid_chains(1, 5) == 0 assert valid_chains(4, 1) == 4 def test_valid_chains_edge_cases(): assert valid_chains(1, 1) == 1 assert valid_chains(100, 1) == 100 assert valid_chains(100, 100) == 100 * 99**99 def test_solve(): assert solve([(3, 3), (2, 4), (1, 5), (4, 1)]) == [12, 2, 0, 4] assert solve([(1, 1), (100, 1), (100, 100)]) == [1, 100, 100 * 99**99] if __name__ == \\"__main__\\": pytest.main()","solution":"def valid_chains(C, L): Returns the number of valid chains of length L using C different colors. if L == 1: return C if C == 1: return 0 return C * (C - 1)**(L - 1) def solve(test_cases): results = [] for C, L in test_cases: results.append(valid_chains(C, L)) return results"},{"question":"def min_powers_of_2(n: int) -> int: Given a positive integer n, return the minimum number of distinct powers of 2 whose sum is equal to n. >>> min_powers_of_2(7) 3 >>> min_powers_of_2(10) 2 >>> min_powers_of_2(22) 3","solution":"def min_powers_of_2(n): Returns the minimum number of distinct powers of 2 whose sum is equal to n. count = 0 while n > 0: highest_power_of_2 = 1 << (n.bit_length() - 1) n -= highest_power_of_2 count += 1 return count"},{"question":"def four_sum(nums, target): Given an array of integers and a target sum, find all unique quadruplets in the array which gives the sum of the target. Each quadruplet should be listed only once, and all quadruplets should be presented in ascending order. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [ [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1] ] >>> four_sum([2, 2, 2, 2, 2], 8) [ [2, 2, 2, 2] ]","solution":"def four_sum(nums, target): nums.sort() result = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: sum_ = nums[i] + nums[j] + nums[left] + nums[right] if sum_ == target: result.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_ < target: left += 1 else: right -= 1 return result"},{"question":"def isSudokuValid(board): Write a function, isSudokuValid, that takes in a 9x9 2D list representing a Sudoku board and returns true if the board is a valid Sudoku solution. A Sudoku board is valid if: 1. Each row contains the digits from 1 to 9 without repetition. 2. Each column contains the digits from 1 to 9 without repetition. 3. Each of the 9, 3x3 sub-boxes of the grid contains the digits from 1 to 9 without repetition. The function should return false for invalid arguments (e.g., input is not a 9x9 grid, contains non-digit characters, or the digits are not in the range from 1 to 9). >>> isSudokuValid([ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ]) == True >>> isSudokuValid([ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 9, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ]) == False >>> isSudokuValid([ [5, 3, 4, 6, 7, 8, '9', 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ]) == False","solution":"def isSudokuValid(board): def is_valid_group(group): Helper function to check if a group contains digits 1-9 without repetition return sorted(group) == list(range(1, 10)) def extract_sub_boxes(board): Extract all 3x3 sub-boxes from the board sub_boxes = [] for i in range(0, 9, 3): for j in range(0, 9, 3): sub_box = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] sub_boxes.append(sub_box) return sub_boxes if len(board) != 9 or any(len(row) != 9 for row in board): return False for row in board: if any(not isinstance(cell, int) or not (1 <= cell <= 9) for cell in row): return False # Check rows and columns for i in range(9): row = board[i] column = [board[j][i] for j in range(9)] if not is_valid_group(row) or not is_valid_group(column): return False # Check 3x3 sub-boxes sub_boxes = extract_sub_boxes(board) for sub_box in sub_boxes: if not is_valid_group(sub_box): return False return True"},{"question":"from typing import List def find_missing_books(inventory_list: List[int], current_shelves: List[int]) -> List[int]: Determine the list of missing books that should be on the shelves but are currently not present. Args: inventory_list (List[int]): List of all books that should be in the library. current_shelves (List[int]): List of books currently found on the shelves. Returns: List[int]: Sorted list of books missing from the shelves. Examples: >>> find_missing_books([101, 202, 303, 404, 505], [202, 303, 505]) [101, 404] >>> find_missing_books([101, 202, 303], [101, 202, 303]) [] pass # Unit Tests def test_find_missing_books_no_missing(): assert find_missing_books([101, 202, 303], [101, 202, 303]) == [] def test_find_missing_books_some_missing(): assert find_missing_books([101, 202, 303, 404, 505], [202, 303, 505]) == [101, 404] def test_find_missing_books_all_missing(): assert find_missing_books([101, 202, 303], []) == [101, 202, 303] def test_find_missing_books_empty_inventory(): assert find_missing_books([], [101, 202, 303]) == [] def test_find_missing_books_with_duplicates(): assert find_missing_books([101, 202, 101, 303, 404], [101, 202]) == [303, 404]","solution":"def find_missing_books(inventory_list, current_shelves): This function takes in two lists: inventory_list and current_shelves, and returns a sorted list of books that are missing in the current_shelves. inventory_set = set(inventory_list) current_set = set(current_shelves) missing_books = list(inventory_set - current_set) missing_books.sort() return missing_books"},{"question":"def minimum_distinct_words(n, words): Returns the minimum number of distinct words Maria can obtain by rearranging the letters within each word. Args: n : int : number of words words : list of str : list containing the words Returns: int : minimum number of distinct words pass # Example Test Cases def test_example_1(): words = [\\"hello\\", \\"world\\", \\"test\\", \\"sett\\"] assert minimum_distinct_words(4, words) == 3 def test_example_2(): words = [\\"aaaa\\"] assert minimum_distinct_words(1, words) == 1 def test_example_3(): words = [\\"abc\\", \\"bca\\", \\"cab\\", \\"abc\\", \\"cba\\"] assert minimum_distinct_words(5, words) == 1 def test_single_character_words(): words = [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] assert minimum_distinct_words(5, words) == 5 def test_identical_words(): words = [\\"same\\", \\"same\\", \\"same\\", \\"same\\"] assert minimum_distinct_words(4, words) == 1 def test_anagrams(): words = [\\"listen\\", \\"silent\\", \\"enlist\\"] assert minimum_distinct_words(3, words) == 1 def test_empty_list(): words = [] assert minimum_distinct_words(0, words) == 0 def test_all_letters_the_same(): words = [\\"aa\\", \\"aa\\", \\"aa\\"] assert minimum_distinct_words(3, words) == 1 def test_different_lengths(): words = [\\"a\\", \\"ab\\", \\"abc\\"] assert minimum_distinct_words(3, words) == 3 def test_mixed_inputs(): words = [\\"abc\\", \\"def\\", \\"ghi\\", \\"cab\\", \\"fed\\", \\"ihg\\"] assert minimum_distinct_words(6, words) == 3","solution":"def minimum_distinct_words(n, words): Returns the minimum number of distinct words Maria can obtain by rearranging the letters within each word. Args: n : int : number of words words : list of str : list containing the words Returns: int : minimum number of distinct words # Use a set to keep track of unique sorted words unique_words = set() for word in words: # Sort the characters of the word and add the sorted word to the set sorted_word = ''.join(sorted(word)) unique_words.add(sorted_word) # The size of the set is the number of unique words return len(unique_words)"},{"question":"from typing import List def compute_values(lines: List[str]) -> List[str]: Write a program that reads multiple lines of input, each containing a list of integers separated by spaces, until an empty line is encountered. For each line of input, compute two values: - The sum of all the negative numbers, S. - The maximum difference between any two numbers in the list, D. >>> compute_values([\\"3 4 -1 -5 12\\", \\"7 -3 -4 5 8\\", \\"\\"]) [\\"-6 17\\", \\"-7 12\\"] >>> compute_values([\\"1 2 3 4 5\\", \\"\\"]) [\\"0 4\\"] >>> compute_values([\\"-1 -2 -3 -4 -5\\", \\"\\"]) [\\"-15 4\\"]","solution":"def compute_values(lines): results = [] for line in lines: if line.strip() == \\"\\": break numbers = list(map(int, line.split())) S = sum(n for n in numbers if n < 0) D = max(numbers) - min(numbers) if len(numbers) > 1 else 0 results.append(f\\"{S} {D}\\") return results"},{"question":"from typing import List def custom_sort(arr: List[int]) -> List[int]: Sorts the array such that even numbers are placed at the beginning in ascending order, followed by odd numbers in descending order. Parameters: arr (list): A list of integers Returns: list: A sorted list with even numbers first in ascending order followed by odd numbers in descending order. Examples: >>> custom_sort([5, 3, 2, 8, 1, 4]) [2, 4, 8, 5, 3, 1] >>> custom_sort([9, 7, 4, 6, 3, 2]) [2, 4, 6, 9, 7, 3] >>> custom_sort([]) [] >>> custom_sort([4, 2, 6, 8]) [2, 4, 6, 8] >>> custom_sort([5, 3, 7, 1]) [7, 5, 3, 1] >>> custom_sort([1]) [1] >>> custom_sort([2]) [2] >>> custom_sort([2, 3, 2, 3, 4, 5]) [2, 2, 4, 5, 3, 3] >>> custom_sort([5, 4, 5, 4]) [4, 4, 5, 5]","solution":"def custom_sort(arr): Sorts the array such that even numbers are placed at the beginning in ascending order, followed by odd numbers in descending order. Parameters: arr (list): A list of integers Returns: list: A sorted list with even numbers first in ascending order followed by odd numbers in descending order. evens = sorted([x for x in arr if x % 2 == 0]) odds = sorted([x for x in arr if x % 2 != 0], reverse=True) return evens + odds"},{"question":"def can_arrange(heights: List[int], D: int) -> bool: Determines if it's possible to arrange flowers such that the height difference between any two adjacent flowers is at most D. Parameters: heights (list): List of flower heights. D (int): Maximum allowed difference in height between two adjacent flowers. Returns: bool: True if such arrangement is possible, False otherwise. >>> can_arrange([5, 1, 7, 3, 9], 4) == True >>> can_arrange([5, 1, 7, 3, 9], 1) == False","solution":"def can_arrange(heights, D): Determines if it's possible to arrange flowers such that the height difference between any two adjacent flowers is at most D. Parameters: heights (list): List of flower heights. D (int): Maximum allowed difference in height between two adjacent flowers. Returns: bool: True if such arrangement is possible, False otherwise. # Sort the heights in ascending order heights.sort() # Check the difference of all adjacent elements in the sorted list for i in range(1, len(heights)): if heights[i] - heights[i-1] > D: return False return True"},{"question":"import pytest from typing import List, Dict, Optional def weatherReport(data: List[Dict[str, Optional[int]]]) -> Dict[str, Optional[str]]: This function returns a dictionary with the cities having the highest and lowest temperatures, the city with the highest and lowest humidity and the average temperature among all cities. :param data: list of dictionaries with keys \\"city\\" (str), \\"temperature\\" (int), \\"humidity\\" (int) :return: a dictionary with keys \\"hottest_city\\", \\"coldest_city\\", \\"average_temperature\\", \\"most_humid_city\\" and \\"least_humid_city\\". >>> weatherReport([{\\"city\\": \\"CityA\\", \\"temperature\\": 30, \\"humidity\\": 70}, {\\"city\\": \\"CityB\\", \\"temperature\\": 25, \\"humidity\\": 60}, {\\"city\\": \\"CityC\\", \\"temperature\\": 35, \\"humidity\\": 80}, {\\"city\\": \\"CityD\\", \\"temperature\\": 20, \\"humidity\\": 50}]) {\\"hottest_city\\": \\"CityC\\", \\"coldest_city\\": \\"CityD\\", \\"average_temperature\\": 27.5, \\"most_humid_city\\": \\"CityC\\", \\"least_humid_city\\": \\"CityD\\"} >>> weatherReport([]) {\\"hottest_city\\": None, \\"coldest_city\\": None, \\"average_temperature\\": None, \\"most_humid_city\\": None, \\"least_humid_city\\": None} >>> weatherReport([{\\"city\\": \\"CityA\\", \\"temperature\\": 30, \\"humidity\\": 70}, {\\"city\\": \\"CityB\\", \\"temperature\\": 25}, {\\"city\\": \\"CityC\\", \\"temperature\\": 35, \\"humidity\\": 80}]) {\\"hottest_city\\": \\"CityC\\", \\"coldest_city\\": \\"CityA\\", \\"average_temperature\\": 32.5, \\"most_humid_city\\": \\"CityC\\", \\"least_humid_city\\": \\"CityA\\"} def test_weatherReport_normal_case(): input_data = [ {\\"city\\": \\"CityA\\", \\"temperature\\": 30, \\"humidity\\": 70}, {\\"city\\": \\"CityB\\", \\"temperature\\": 25, \\"humidity\\": 60}, {\\"city\\": \\"CityC\\", \\"temperature\\": 35, \\"humidity\\": 80}, {\\"city\\": \\"CityD\\", \\"temperature\\": 20, \\"humidity\\": 50} ] expected_output = { \\"hottest_city\\": \\"CityC\\", \\"coldest_city\\": \\"CityD\\", \\"average_temperature\\": 27.5, \\"most_humid_city\\": \\"CityC\\", \\"least_humid_city\\": \\"CityD\\" } assert weatherReport(input_data) == expected_output def test_weatherReport_empty_list(): input_data = [] expected_output = { \\"hottest_city\\": None, \\"coldest_city\\": None, \\"average_temperature\\": None, \\"most_humid_city\\": None, \\"least_humid_city\\": None } assert weatherReport(input_data) == expected_output def test_weatherReport_missing_keys(): input_data = [ {\\"city\\": \\"CityA\\", \\"temperature\\": 30, \\"humidity\\": 70}, {\\"city\\": \\"CityB\\", \\"temperature\\": 25}, {\\"city\\": \\"CityC\\", \\"temperature\\": 35, \\"humidity\\": 80} ] expected_output = { \\"hottest_city\\": \\"CityC\\", \\"coldest_city\\": \\"CityA\\", \\"average_temperature\\": 32.5, \\"most_humid_city\\": \\"CityC\\", \\"least_humid_city\\": \\"CityA\\" } assert weatherReport(input_data) == expected_output def test_weatherReport_all_entries_missing_keys(): input_data = [ {\\"city\\": \\"CityB\\", \\"temperature\\": 25}, {\\"city\\": \\"CityB\\", \\"humidity\\": 60}, {\\"city\\": \\"CityC\\", \\"humidity\\": 80} ] expected_output = { \\"hottest_city\\": None, \\"coldest_city\\": None, \\"average_temperature\\": None, \\"most_humid_city\\": None, \\"least_humid_city\\": None } assert weatherReport(input_data) == expected_output def test_weatherReport_one_city(): input_data = [ {\\"city\\": \\"CityA\\", \\"temperature\\": 30, \\"humidity\\": 70} ] expected_output = { \\"hottest_city\\": \\"CityA\\", \\"coldest_city\\": \\"CityA\\", \\"average_temperature\\": 30.0, \\"most_humid_city\\": \\"CityA\\", \\"least_humid_city\\": \\"CityA\\" } assert weatherReport(input_data) == expected_output","solution":"def weatherReport(data): This function returns a dictionary with the cities having the highest and lowest temperatures, the city with the highest and lowest humidity and the average temperature among all cities. :param data: list of dictionaries with keys \\"city\\" (str), \\"temperature\\" (int), \\"humidity\\" (int) :return: a dictionary with keys \\"hottest_city\\", \\"coldest_city\\", \\"average_temperature\\", \\"most_humid_city\\" and \\"least_humid_city\\". if not data: return { \\"hottest_city\\": None, \\"coldest_city\\": None, \\"average_temperature\\": None, \\"most_humid_city\\": None, \\"least_humid_city\\": None } valid_entries = [entry for entry in data if {\\"city\\", \\"temperature\\", \\"humidity\\"}.issubset(entry.keys())] if not valid_entries: return { \\"hottest_city\\": None, \\"coldest_city\\": None, \\"average_temperature\\": None, \\"most_humid_city\\": None, \\"least_humid_city\\": None } hottest_city = max(valid_entries, key=lambda x: x[\\"temperature\\"])[\\"city\\"] coldest_city = min(valid_entries, key=lambda x: x[\\"temperature\\"])[\\"city\\"] average_temperature = round(sum(entry[\\"temperature\\"] for entry in valid_entries) / len(valid_entries), 1) most_humid_city = max(valid_entries, key=lambda x: x[\\"humidity\\"])[\\"city\\"] least_humid_city = min(valid_entries, key=lambda x: x[\\"humidity\\"])[\\"city\\"] return { \\"hottest_city\\": hottest_city, \\"coldest_city\\": coldest_city, \\"average_temperature\\": average_temperature, \\"most_humid_city\\": most_humid_city, \\"least_humid_city\\": least_humid_city }"},{"question":"def convert_to_american(text: str) -> str: Converts British English spellings to American English spellings in the given text. >>> convert_to_american('She has a great favour to ask.') 'She has a great favor to ask.' >>> convert_to_american('The centre of town is beautiful.') 'The center of town is beautiful.' >>> convert_to_american('We should honour their defence tactics.') 'We should honor their defense tactics.' >>> convert_to_american('Does she realize that colour and favour are British spellings?') 'Does she realize that color and favor are British spellings?'","solution":"def convert_to_american(text): Converts British English spellings to American English spellings in the given text. Parameters: text (str): The input string containing British English spellings. Returns: str: The input string with British spellings replaced by American spellings. british_to_american = { 'colour': 'color', 'honour': 'honor', 'favour': 'favor', 'realise': 'realize', 'defence': 'defense', 'centre': 'center' } # Replace each British spelling with its American counterpart for british, american in british_to_american.items(): text = text.replace(british, american).replace(british.capitalize(), american.capitalize()) return text"},{"question":"def merge_integers(gen1, gen2): Merges two sorted generators of integers into a single sorted generator. >>> list(merge_integers((n for n in [1, 3, 5]), (n for n in [2, 4, 6]))) [1, 2, 3, 4, 5, 6] >>> list(merge_integers((n for n in [1, 3, 5]), (n for n in []))) [1, 3, 5] >>> list(merge_integers((n for n in []), (n for n in []))) [] >>> list(merge_integers((n for n in [1, 3, 5]), (n for n in [1, 2, 3]))) [1, 1, 2, 3, 3, 5] >>> list(merge_integers((n for n in [1, 5, 10]), (n for n in [2, 7, 12]))) [1, 2, 5, 7, 10, 12]","solution":"def merge_integers(gen1, gen2): Merges two sorted generators of integers into a single sorted generator. v1 = next(gen1, None) v2 = next(gen2, None) while v1 is not None or v2 is not None: if v1 is None: yield v2 v2 = next(gen2, None) elif v2 is None: yield v1 v1 = next(gen1, None) elif v1 <= v2: yield v1 v1 = next(gen1, None) else: yield v2 v2 = next(gen2, None)"},{"question":"from typing import List def min_partition_difference(nums: List[int]) -> List[int]: Given a list of integers, partitions the list into two subsets such that the difference between the sums of the subsets is minimized. Returns a list of two integers representing the sums of the two subsets. >>> min_partition_difference([1, 6, 11, 5]) [11, 12] >>> min_partition_difference([10]) [0, 10] >>> min_partition_difference([2, 2, 2, 2]) [4, 4] >>> min_partition_difference([3, 1, 4, 2, 2]) [6, 6] >>> min_partition_difference([100, 100, 100, 100]) [200, 200] >>> min_partition_difference([]) [0, 0]","solution":"from typing import List def min_partition_difference(nums: List[int]) -> List[int]: total_sum = sum(nums) n = len(nums) # DP Table to store boolean values dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] # Initialization of DP table for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if nums[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] # Finding the maximum value that can be achieved close to total_sum / 2 for j in range(total_sum // 2, -1, -1): if dp[n][j] == True: sum1 = j break sum2 = total_sum - sum1 return [sum1, sum2]"},{"question":"def positive_product(lst: List[int]) -> int: Returns the product of all positive integers in the list. If there are no positive integers, returns 1. >>> positive_product([1, -2, 3, -4, 5]) 15 >>> positive_product([-1, -2, -3, -4]) 1","solution":"from functools import reduce def positive_product(lst): Returns the product of all positive integers in the list. If there are no positive integers, returns 1. positive_integers = [x for x in lst if x > 0] if not positive_integers: return 1 return reduce(lambda x, y: x * y, positive_integers)"},{"question":"from typing import List, Tuple def max_distinct_in_subsequence(n: int, k: int, array: List[int]) -> int: This function returns the maximum number of distinct integers in any subsequence of length k of the given array. n : int : length of the array k : int : length of the subsequence array : list[int] : list of integers representing the array pass def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: This function processes multiple test cases to find the maximum number of distinct integers in any subsequence of length k for each case. t : int : number of test cases test_cases : list[tuple[int, int, list[int]]] : list of tuples representing each test case with (n, k, array) pass def test_max_distinct_in_subsequence(): assert max_distinct_in_subsequence(6, 3, [1, 2, 2, 3, 3, 4]) == 3 assert max_distinct_in_subsequence(5, 4, [5, 5, 5, 5, 5]) == 1 assert max_distinct_in_subsequence(7, 5, [1, 2, 3, 4, 2, 3, 4]) == 4 assert max_distinct_in_subsequence(6, 2, [1, 1, 1, 2, 2, 2]) == 2 assert max_distinct_in_subsequence(8, 6, [1, 2, 3, 4, 5, 6, 7, 8]) == 6 def test_process_test_cases(): test_cases = [ (6, 3, [1, 2, 2, 3, 3, 4]), (5, 4, [5, 5, 5, 5, 5]), (7, 5, [1, 2, 3, 4, 2, 3, 4]) ] assert process_test_cases(3, test_cases) == [3, 1, 4] if __name__ == \\"__main__\\": test_max_distinct_in_subsequence() test_process_test_cases() print(\\"All tests passed.\\")","solution":"def max_distinct_in_subsequence(n, k, array): This function returns the maximum number of distinct integers in any subsequence of length k of the given array. n : int : length of the array k : int : length of the subsequence array : list[int] : list of integers representing the array from collections import Counter # Count the frequency of each element in the array freq = Counter(array) # Number of distinct elements in original array distinct_count = len(freq) # The result cannot be more than the number of distinct elements return min(distinct_count, k) def process_test_cases(t, test_cases): results = [] for case in test_cases: n, k, array = case results.append(max_distinct_in_subsequence(n, k, array)) return results"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generates an n x n matrix filled with elements from 1 to n^2 in spiral order. >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[ 1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] pass def test_generate_spiral_matrix_1(): expected = [[1]] assert generate_spiral_matrix(1) == expected def test_generate_spiral_matrix_2(): expected = [[1, 2], [4, 3]] assert generate_spiral_matrix(2) == expected def test_generate_spiral_matrix_3(): expected = [[1, 2, 3], [8, 9, 4], [7, 6, 5]] assert generate_spiral_matrix(3) == expected def test_generate_spiral_matrix_4(): expected = [[ 1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] assert generate_spiral_matrix(4) == expected def test_generate_spiral_matrix_5(): expected = [[ 1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] assert generate_spiral_matrix(5) == expected","solution":"def generate_spiral_matrix(n): Generates an n x n matrix filled with elements from 1 to n^2 in spiral order. matrix = [[0] * n for _ in range(n)] curr_num = 1 left, right = 0, n - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = curr_num curr_num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = curr_num curr_num += 1 right -= 1 for i in range(right, left - 1, -1): matrix[bottom][i] = curr_num curr_num += 1 bottom -= 1 for i in range(bottom, top - 1, -1): matrix[i][left] = curr_num curr_num += 1 left += 1 return matrix"},{"question":"def circularLeftShift(arr, n): Performs a circular left shift on the array \`arr\` exactly \`n\` times. :param arr: List of integers :param n: Number of times the array should be circular left shifted :return: Array after performing the circular left shifts >>> circularLeftShift([1, 2, 3, 4], 1) [2, 3, 4, 1] >>> circularLeftShift([1, 2, 3, 4], 3) [4, 1, 2, 3] >>> circularLeftShift([], 5) []","solution":"def circularLeftShift(arr, n): Performs a circular left shift on the array \`arr\` exactly \`n\` times. :param arr: List of integers :param n: Number of times the array should be circular left shifted :return: Array after performing the circular left shifts if not arr: return [] n = n % len(arr) # To handle cases where n is larger than the array length return arr[n:] + arr[:n]"},{"question":"def extract_events(log, keyword): Processes the log, filters the events containing a specific keyword in their messages, and returns a list of event IDs for the filtered events. Parameters: log (list of str): The list of event strings. keyword (str): The term that should be present in an event's message for it to be included. Returns: list of str: The list of event IDs corresponding to the events that contain the keyword. Example: >>> log = [ ... \\"event1 Server started successfully\\", ... \\"event2 User login failed\\", ... \\"event3 Disk space low\\", ... \\"event4 User login succeeded\\", ... \\"event5 Server shutdown initiated\\" ... ] >>> extract_events(log, \\"User\\") [\\"event2\\", \\"event4\\"] >>> extract_events(log, \\"SERVER\\") [\\"event1\\", \\"event5\\"] >>> extract_events(log, \\"disk\\") [\\"event3\\"] >>> extract_events(log, \\"login\\") [\\"event2\\", \\"event4\\"] pass # Example test cases def test_extract_events_with_keyword(): log = [ \\"event1 Server started successfully\\", \\"event2 User login failed\\", \\"event3 Disk space low\\", \\"event4 User login succeeded\\", \\"event5 Server shutdown initiated\\" ] assert extract_events(log, \\"User\\") == [\\"event2\\", \\"event4\\"] assert extract_events(log, \\"SERVER\\") == [\\"event1\\", \\"event5\\"] assert extract_events(log, \\"disk\\") == [\\"event3\\"] assert extract_events(log, \\"login\\") == [\\"event2\\", \\"event4\\"] def test_extract_events_case_insensitive(): log = [ \\"event6 Server Rebooted\\", \\"event7 Database backed up\\", \\"event8 server under maintenance\\" ] assert extract_events(log, \\"server\\") == [\\"event6\\", \\"event8\\"] assert extract_events(log, \\"SERVER\\") == [\\"event6\\", \\"event8\\"] def test_extract_events_empty_log(): log = [] assert extract_events(log, \\"keyword\\") == [] def test_extract_events_no_matching_keyword(): log = [ \\"event9 No relevant data\\", \\"event10 Operation completed\\" ] assert extract_events(log, \\"keyword\\") == [] def test_extract_events_empty_keyword(): log = [ \\"event11 Some event message\\", \\"event12 Another event message\\" ] assert extract_events(log, \\"\\") == [\\"event11\\", \\"event12\\"]","solution":"def extract_events(log, keyword): Processes the log, filters the events containing a specific keyword in their messages, and returns a list of event IDs for the filtered events. Parameters: log (list of str): The list of event strings. keyword (str): The term that should be present in an event's message for it to be included. Returns: list of str: The list of event IDs corresponding to the events that contain the keyword. keyword = keyword.lower() result = [] for event in log: event_id, message = event.split(' ', 1) if keyword in message.lower(): result.append(event_id) return result"},{"question":"from typing import List def is_valid_sudoku(grid: List[List[int]]) -> bool: Determine if a 9x9 Sudoku grid is a valid solution. Args: grid (List[List[int]]): A 9x9 list of integers representing the Sudoku grid. Returns: bool: True if the grid is a valid Sudoku solution, False otherwise. Examples: >>> is_valid_sudoku([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ]) == True >>> is_valid_sudoku([ ... [8, 3, 5, 4, 1, 6, 9, 2, 7], ... [2, 9, 6, 8, 5, 7, 4, 3, 1], ... [4, 1, 7, 2, 9, 3, 6, 5, 8], ... [5, 6, 9, 1, 3, 4, 7, 8, 2], ... [1, 2, 3, 6, 7, 8, 5, 4, 9], ... [7, 4, 8, 5, 2, 9, 1, 6, 3], ... [6, 5, 2, 7, 8, 1, 3, 9, 4], ... [9, 8, 1, 3, 4, 5, 2, 7, 6], ... [3, 7, 4, 9, 6, 2, 8, 1, 5] ... ]) == False >>> is_valid_sudoku([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 1] ... ]) == False >>> is_valid_sudoku([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 9, 9] ... ]) == False >>> is_valid_sudoku([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 1, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ]) == False","solution":"from typing import List def is_valid_sudoku(grid: List[List[int]]) -> bool: def is_valid_set(elements) -> bool: return len(elements) == 9 and len(set(elements)) == 9 # Check rows for row in grid: if not is_valid_set(row): return False # Check columns for col in range(9): if not is_valid_set([grid[row][col] for row in range(9)]): return False # Check 3x3 sub-grids for box_row in range(3): for box_col in range(3): subgrid = [] for row in range(box_row * 3, box_row * 3 + 3): for col in range(box_col * 3, box_col * 3 + 3): subgrid.append(grid[row][col]) if not is_valid_set(subgrid): return False return True"},{"question":"def can_form_teams(n: int, k: int) -> str: Determines if it is possible to evenly distribute n students into k teams. If possible, returns \\"Yes\\" followed by the number of students in each team. If not possible, returns \\"No\\". Parameters: n (int): Number of students. k (int): Number of teams. Returns: str: \\"Yes\\" followed by number of students in each team, or \\"No\\". >>> can_form_teams(20, 4) 'Yes 5' >>> can_form_teams(20, 3) 'No' >>> can_form_teams(20, 1) 'Yes 20' >>> can_form_teams(1, 1) 'Yes 1' >>> can_form_teams(5, 5) 'Yes 1' >>> can_form_teams(4, 5) 'No'","solution":"def can_form_teams(n, k): Determines if it is possible to evenly distribute n students into k teams. If possible, returns \\"Yes\\" followed by the number of students in each team. If not possible, returns \\"No\\". Parameters: n (int): Number of students. k (int): Number of teams. Returns: str: \\"Yes\\" followed by number of students in each team, or \\"No\\". if n % k == 0: students_per_team = n // k return f\\"Yes {students_per_team}\\" else: return \\"No\\""},{"question":"def balancedBrackets(s: str) -> bool: Returns True if the string containing brackets is valid, otherwise returns False. >>> balancedBrackets(\\"\\") == True >>> balancedBrackets(\\"()\\") == True >>> balancedBrackets(\\"[]\\") == True >>> balancedBrackets(\\"{}\\") == True >>> balancedBrackets(\\"(\\") == False >>> balancedBrackets(\\"[\\") == False >>> balancedBrackets(\\"{\\") == False >>> balancedBrackets(\\"()[]{}\\") == True >>> balancedBrackets(\\"([{}])\\") == True >>> balancedBrackets(\\"([)]\\") == False >>> balancedBrackets(\\"({[)})\\") == False >>> balancedBrackets(\\"{[()]}\\") == True >>> balancedBrackets(\\"{[(])}\\") == False >>> balancedBrackets(\\"[({})]\\") == True >>> balancedBrackets(\\"[({)}]\\") == False >>> balancedBrackets(\\"{[\\") == False >>> balancedBrackets(\\"[}\\") == False >>> balancedBrackets(\\"({[})\\") == False >>> balancedBrackets(\\"{[()]}([]{})\\") == True >>> balancedBrackets(\\"(({{[[]]}}))\\") == True >>> balancedBrackets(\\"({[()]}})\\") == False","solution":"def balancedBrackets(s): Returns True if the string containing brackets is valid, otherwise returns False. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def firstNonRepeatingChar(s: str) -> str: Returns the first non-repeating character in the given string. If all characters are repeating, returns an empty string. >>> firstNonRepeatingChar(\\"abcab\\") \\"c\\" >>> firstNonRepeatingChar(\\"abab\\") \\"\\"","solution":"def firstNonRepeatingChar(s: str) -> str: Returns the first non-repeating character in the given string. If all characters are repeating, returns an empty string. char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"def secure_transform(message: str, key: int) -> str: In the kingdom of XYZ, the royal court heavily relies on coded communications for passing important messages. Each letter in a message is represented by its corresponding position in the alphabet (A=1, B=2, ..., Z=26). In an effort to further secure these messages, the court decides to add a unique transformation. The transformation involves adding a numeric key to each letter's position value, wrapping around if necessary. Given an original message and a numeric key, help the court transform the message using the described method. -----Input Format----- - The original message, a string consisting of uppercase English letters. - The numeric key, a positive integer. -----Output Format----- - Output the transformed message as a string of uppercase English letters. >>> secure_transform(\\"HELLO\\", 3) \\"KHOOR\\" >>> secure_transform(\\"XYZ\\", 3) \\"ABC\\"","solution":"def secure_transform(message, key): def char_to_number(char): return ord(char) - ord('A') + 1 def number_to_char(num): return chr(((num - 1) % 26) + ord('A')) transformed_message = \\"\\" for char in message: original_number = char_to_number(char) transformed_number = (original_number + key - 1) % 26 + 1 transformed_message += number_to_char(transformed_number) return transformed_message"},{"question":"def is_balanced(S: str) -> str: Checks if the parentheses in the given string S are balanced. Parameters: S (str): The input string consisting of alphanumeric characters and parentheses. Returns: str: \\"YES\\" if the parentheses are balanced, \\"NO\\" otherwise. >>> is_balanced(\\"(ab)c(d)\\") 'YES' >>> is_balanced(\\"(a(b)c)d)\\") 'NO' >>> is_balanced(\\"((a)b(c)d\\") 'NO' >>> is_balanced(\\"\\") 'YES' >>> is_balanced(\\"abc\\") 'YES' >>> is_balanced(\\")abc(d)\\") 'NO' >>> is_balanced(\\"a(b(c)d)e(f(g)h)i\\") 'YES' >>> is_balanced(\\"a(b(c)d)e(f(g))h)i\\") 'NO'","solution":"def is_balanced(S): Checks if the parentheses in the given string S are balanced. Parameters: S (str): The input string consisting of alphanumeric characters and parentheses. Returns: str: \\"YES\\" if the parentheses are balanced, \\"NO\\" otherwise. stack = [] for char in S: if char == '(': stack.append(char) elif char == ')': if len(stack) == 0: return \\"NO\\" stack.pop() return \\"YES\\" if len(stack) == 0 else \\"NO\\""},{"question":"def dict_operations(n, commands): Perform a series of operations on a dictionary based on the given commands. Args: n (int): number of commands commands (List[str]): list of commands to execute Returns: List: result of executed commands for exists, get, keys, and values types Examples: >>> dict_operations(3, [\\"add name Alice\\", \\"get name\\", \\"get age\\"]) [\\"Alice\\", None] >>> dict_operations(4, [\\"add name Alice\\", \\"remove name\\", \\"exists name\\", \\"exists age\\"]) [False, False] >>> dict_operations(3, [\\"add name Alice\\", \\"add age 25\\", \\"exists age\\"]) [True] >>> dict_operations(4, [\\"add name Alice\\", \\"add age 25\\", \\"keys\\", \\"values\\"]) [[\\"name\\", \\"age\\"], [\\"Alice\\", 25]] >>> dict_operations(5, [\\"add name Alice\\", \\"add age 25\\", \\"clear\\", \\"keys\\", \\"values\\"]) [[], []]","solution":"def dict_operations(n, commands): dictionary = {} result = [] for command in commands: command_parts = command.split() action = command_parts[0] if action == 'add': key, value = command_parts[1], command_parts[2] if value.isdigit(): value = int(value) dictionary[key] = value elif action == 'remove': key = command_parts[1] if key in dictionary: del dictionary[key] elif action == 'exists': key = command_parts[1] result.append(key in dictionary) elif action == 'get': key = command_parts[1] result.append(dictionary.get(key)) elif action == 'keys': result.append(list(dictionary.keys())) elif action == 'values': result.append(list(dictionary.values())) elif action == 'clear': dictionary.clear() return result"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in the array that add up to the target. Parameters: nums (list of int): The array of integers. target (int): The target integer. Returns: list of int: The indices of the two numbers that add up to the target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1, -2, 3, 4], 2) [1, 3] >>> two_sum([10**9, -10**9, 3, 4], 7) [2, 3] >>> two_sum([5, 5, 11, 15], 10) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the array that add up to the target. Parameters: nums (list of int): The array of integers. target (int): The target integer. Returns: list of int: The indices of the two numbers that add up to the target. num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return [num_dict[complement], i] num_dict[num] = i"},{"question":"def min_operations_to_make_equal(nums: List[int]) -> int: This function takes a list of integers and returns the minimum number of operations needed to make all elements in the list the same. >>> min_operations_to_make_equal([1, 2, 3]) == 6 >>> min_operations_to_make_equal([5, 7, 9]) == 6 >>> min_operations_to_make_equal([10]) == 2 >>> min_operations_to_make_equal([4, 4, 4, 4]) == 8 >>> min_operations_to_make_equal([10000, 10000, 10000]) == 6 >>> min_operations_to_make_equal([1, 1, 1, 1, 1, 1]) == 12","solution":"def min_operations_to_make_equal(nums): This function takes a list of integers and returns the minimum number of operations needed to make all elements in the list the same. # To make all elements equal, first, we need to find the GCD of all numbers. from math import gcd from functools import reduce # Find GCD of the entire array array_gcd = reduce(gcd, nums) # Count how many elements are in the array n = len(nums) # The formula for the number of operations is derived from the problem constraint. # each replace operation essentially doubles the sum of two elements, # so to bring down all elements to the gcd point we can directly # multiply length of array(n) by 2 return n * 2"},{"question":"def smallest_non_representable_integer(arr): Returns the smallest positive integer that cannot be represented as the sum of any subset of the array. def process_test_cases(test_cases): Process multiple test cases and return the results. >>> process_test_cases([[1, 2, 2], [1, 2, 5, 10]]) == [6, 4] # Example test cases if __name__ == \\"__main__\\": test_cases = [ [1, 2, 2], [1, 2, 5, 10] ] print(process_test_cases(test_cases)) # Output should be [6, 4]","solution":"def smallest_non_representable_integer(arr): Returns the smallest positive integer that cannot be represented as the sum of any subset of the array. arr.sort() smallest_unreachable = 1 for num in arr: if num > smallest_unreachable: break smallest_unreachable += num return smallest_unreachable def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(smallest_non_representable_integer(arr)) return results"},{"question":"def sort_expressions(expressions: List[str]) -> List[str]: Write a function that takes in a list of strings, each representing a mathematical expression. The function should return a list of the expressions sorted by their numerical value in non-decreasing order. If two expressions evaluate to the same value, maintain their original relative order from the input list. >>> sort_expressions([\\"3+2*2\\", \\"3/2\\", \\"3+5/2\\"]) == [\\"3/2\\", \\"3+5/2\\", \\"3+2*2\\"] >>> sort_expressions([\\"6/3*2\\", \\"1+2*3/2\\", \\"4-2*2\\"]) == [\\"4-2*2\\", \\"6/3*2\\", \\"1+2*3/2\\"] >>> sort_expressions([\\"2-1*5+4/2\\", \\"4*(3+2)\\", \\"6-7/3\\", \\"2+2*2\\"]) == [\\"2-1*5+4/2\\", \\"6-7/3\\", \\"2+2*2\\", \\"4*(3+2)\\"] >>> sort_expressions([\\"\\"]) raises ValueError >>> sort_expressions([\\" 2 + 3 * 4 \\", \\" 6/ 3 \\"]) == [\\" 6/ 3 \\", \\" 2 + 3 * 4 \\"]","solution":"from typing import List import re def sort_expressions(expressions: List[str]) -> List[str]: def evaluate(expr: str) -> float: Evaluates the mathematical expression to a float value try: return eval(expr) except: raise ValueError(f\\"Invalid expression: {expr}\\") # Evaluate each expression and pair it with its evaluated value evaluated_expressions = [(expr, evaluate(expr)) for expr in expressions] # Sort based on the numerical evaluated value sorted_expressions = sorted(evaluated_expressions, key=lambda x: x[1]) # Extract sorted original expressions return [expr for expr, value in sorted_expressions]"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the given integer n. The function works correctly for both positive and negative numbers. >>> sum_of_digits(12345) 15 >>> sum_of_digits(-12345) 15 >>> sum_of_digits(0) 0","solution":"def sum_of_digits(n): Returns the sum of the digits of the given integer n. The function works correctly for both positive and negative numbers. n = abs(n) return sum(int(digit) for digit in str(n))"},{"question":"def removeDuplicates(s: str) -> str: Given a string, return another string without any duplicate characters while maintaining the order of their first occurrence. >>> removeDuplicates(\\"programming\\") == \\"progamin\\" >>> removeDuplicates(\\"abacabad\\") == \\"abcd\\" >>> removeDuplicates(\\"python\\") == \\"python\\" >>> removeDuplicates(\\"aaaaaa\\") == \\"a\\" >>> removeDuplicates(\\"abcabc\\") == \\"abc\\"","solution":"def removeDuplicates(s): Given a string, return another string without any duplicate characters while maintaining the order of their first occurrence. Parameters: s (str): input string Returns: str: string without duplicate characters seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def has_adjacent_plants(m: int, n: int, grid: List[str]) -> str: Return \\"Yes\\" if there are any adjacent plants in the grid, otherwise return \\"No\\". >>> has_adjacent_plants(2, 2, [\\"P.\\", \\".P\\"]) \\"No\\" >>> has_adjacent_plants(3, 3, [\\"P..\\", \\"..P\\", \\"P..\\"]) \\"No\\" >>> has_adjacent_plants(2, 2, [\\"PP\\", \\".P\\"]) \\"Yes\\" >>> has_adjacent_plants(3, 3, [\\"P.P\\", \\"...\\", \\"PPP\\"]) \\"Yes\\" >>> has_adjacent_plants(2, 2, [\\"P.\\", \\"P.\\"]) \\"Yes\\" >>> has_adjacent_plants(3, 3, [\\"P..\\", \\"P..\\", \\"...\\"]) \\"Yes\\" >>> has_adjacent_plants(3, 3, [\\"PPP\\", \\"P.P\\", \\"PPP\\"]) \\"Yes\\" >>> has_adjacent_plants(3, 4, [\\"P..P\\", \\"..P.\\", \\"P.P.\\"]) \\"Yes\\" >>> has_adjacent_plants(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) \\"No\\" >>> has_adjacent_plants(1, 1, [\\".\\"]) \\"No\\" pass","solution":"def has_adjacent_plants(m, n, grid): Return \\"Yes\\" if there are any adjacent plants in the grid, otherwise return \\"No\\". for i in range(m): for j in range(n): if grid[i][j] == 'P': # Check Right if j + 1 < n and grid[i][j + 1] == 'P': return \\"Yes\\" # Check Down if i + 1 < m and grid[i + 1][j] == 'P': return \\"Yes\\" return \\"No\\""},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of characters needed to be inserted into the string so that it becomes a palindrome. >>> min_insertions_to_palindrome(\\"abca\\") == 1 >>> min_insertions_to_palindrome(\\"race\\") == 3 >>> min_insertions_to_palindrome(\\"a\\") == 0 >>> min_insertions_to_palindrome(\\"racecar\\") == 0 >>> min_insertions_to_palindrome(\\"aaabaaa\\") == 0 >>> min_insertions_to_palindrome(\\"\\") == 0 >>> min_insertions_to_palindrome(\\"abcdef\\") == 5","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of characters needed to be inserted to make the string a palindrome. n = len(s) # Reverse the string rev_s = s[::-1] # Initialize DP array dp = [[0] * (n + 1) for _ in range(n + 1)] # Fill the DP array for i in range(n): for j in range(n): if s[i] == rev_s[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) # The result is the length of the string minus the length of the longest palindromic subsequence return n - dp[n][n]"},{"question":"def leafaltron_exchanges(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[List[int]]: This function takes in the number of test cases T and the test cases as input, and returns the final energy levels of Leafaltrons after the leaf exchanges in each region. >>> leafaltron_exchanges(1, [(3, [(1, 30), (1, 50), (1, 10)])]) == [[30, 30, 30]] >>> leafaltron_exchanges(2, [(3, [(1, 30), (1, 50), (1, 10)]), (4, [(2, 25), (2, 75), (3, 20), (3, 30)])]) == [[30, 30, 30], [50, 50, 25, 25]] >>> leafaltron_exchanges(1, [(3, [(1, 10), (2, 20), (3, 30)])]) == [[10, 20, 30]] >>> leafaltron_exchanges(1, [(2, [(1, 40), (1, 60)])]) == [[50, 50]] >>> leafaltron_exchanges(1, [(3, [(1, 10), (1, 10), (1, 11)])]) == [[10, 10, 11]] >>> leafaltron_exchanges(1, [(4, [(1, 25), (1, 25), (1, 50), (1, 100)])]) == [[50, 50, 50, 50]]","solution":"def leafaltron_exchanges(T, test_cases): This function takes in the number of test cases T and the test cases as input, and returns the final energy levels of Leafaltrons after the leaf exchanges in each region. result = [] for i in range(T): N = test_cases[i][0] leafaltrons = test_cases[i][1] regions = {} for region, energy in leafaltrons: if region not in regions: regions[region] = [] regions[region].append(energy) final_energies = [] for region, energies in regions.items(): total_energy = sum(energies) num_leafaltrons = len(energies) average_energy = total_energy // num_leafaltrons remainder = total_energy % num_leafaltrons balanced_energies = [average_energy] * num_leafaltrons for j in range(remainder): balanced_energies[j] += 1 regions[region] = sorted(balanced_energies) for region, energy in leafaltrons: final_energies.append(regions[region].pop(0)) result.append(final_energies) return result"},{"question":"def even_squares(lst: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are the even numbers from the list and the values are the squares of these even numbers. >>> even_squares([1, 2, 3, 4, 5]) == {2: 4, 4: 16} >>> even_squares([10, 22, 35, 47, 50]) == {10: 100, 22: 484, 50: 2500} >>> even_squares([7, 11, 13, 19]) == {}","solution":"def even_squares(lst): Returns a dictionary where the keys are the even numbers from the list and the values are the squares of these even numbers. Parameters: lst (list): A list of integers. Returns: dict: A dictionary with even numbers and their squares. return {num: num**2 for num in lst if num % 2 == 0}"},{"question":"def max_product_pair(arr): Returns a pair of integers in the array whose product is larger than any other pair of integers in the array. >>> max_product_pair([-10, -3, 5, 6, -2]) in [(-10, -3), (5, 6)] True >>> max_product_pair([1, 4, 3, 6, 7, 0]) in [(6, 7), (7, 6)] True","solution":"def max_product_pair(arr): Returns a pair of integers in the array whose product is larger than any other pair of integers in the array. if len(arr) < 2: raise ValueError(\\"The array must contain at least two integers.\\") max_product = float('-inf') pair = (arr[0], arr[1]) for i in range(len(arr)): for j in range(i + 1, len(arr)): product = arr[i] * arr[j] if product > max_product: max_product = product pair = (arr[i], arr[j]) return pair"},{"question":"def custom_chessboard(char1, char2, dimension): Create a chessboard of given dimensions that alternates between two characters. Args: char1 (str): The first character. char2 (str): The second character. dimension (int): The dimension of the board (NxN). Returns: str: The chessboard as a string separated by newline characters, or False if inputs are invalid. Examples: >>> custom_chessboard('O', 'X', 5) 'OXOXOnXOXOXnOXOXOnXOXOXnOXOXO' >>> custom_chessboard('A', 'B', 3) 'ABAnBABnABA' >>> custom_chessboard('1', '0', 4) '1010n0101n1010n0101' >>> custom_chessboard('*', '-', 6) '*-*-*-n-*-*-*n*-*-*-n-*-*-*n*-*-*-n-*-*-*' >>> custom_chessboard('@', '#', -3) # invalid dimension False >>> custom_chessboard('A', 'ZZ', 4) # invalid second character False","solution":"def custom_chessboard(char1, char2, dimension): if not isinstance(dimension, int) or dimension < 1: return False if not (isinstance(char1, str) and isinstance(char2, str) and len(char1) == 1 and len(char2) == 1): return False dimension = max(1, dimension) # Ensure minimum dimension is 1 board = [] for i in range(dimension): row = [] for j in range(dimension): if (i + j) % 2 == 0: row.append(char1) else: row.append(char2) board.append(''.join(row)) return 'n'.join(board)"},{"question":"import typing def can_form_target(source: str, target: str) -> bool: Determines if \`target\` can be formed from \`source\` by deleting characters. Args: source (str): The source string. target (str): The target string. Returns: bool: True if \`target\` can be formed, False otherwise. >>> can_form_target(\\"abcdef\\", \\"abc\\") True >>> can_form_target(\\"coding\\", \\"loop\\") False >>> can_form_target(\\"hello\\", \\"hello\\") True >>> can_form_target(\\"xyz\\", \\"xz\\") True >>> can_form_target(\\"ab\\", \\"abc\\") False >>> can_form_target(\\"axbycz\\", \\"abc\\") True >>> can_form_target(\\"\\", \\"a\\") False >>> can_form_target(\\"a\\", \\"a\\") True >>> can_form_target(\\"spaghetti\\", \\"bat\\") False def process_test_cases(test_cases: typing.List[typing.Tuple[str, str]]) -> typing.List[str]: Processes multiple test cases. Args: test_cases (List[Tuple[str, str]]): A list of test cases where each test case is a tuple of (source, target). Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases([(\\"abcdef\\", \\"abc\\"), (\\"coding\\", \\"loop\\"), (\\"hello\\", \\"hello\\")]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases([(\\"xyz\\", \\"xz\\"), (\\"ab\\", \\"abc\\"), (\\"axbycz\\", \\"abc\\"), (\\"\\", \\"a\\"), (\\"a\\", \\"a\\"), (\\"spaghetti\\", \\"bat\\")]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"]","solution":"def can_form_target(source, target): Determines if \`target\` can be formed from \`source\` by deleting characters. target_index = 0 for char in source: if target_index < len(target) and char == target[target_index]: target_index += 1 return target_index == len(target) def process_test_cases(test_cases): results = [] for source, target in test_cases: if can_form_target(source, target): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def combine(n: int, k: int) -> List[List[int]]: Returns all possible combinations of k numbers out of the range 1 to n inclusive. >>> combine(4, 2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> combine(3, 1) [[1], [2], [3]] >>> combine(5, 5) [[1, 2, 3, 4, 5]] >>> combine(4, 1) [[1], [2], [3], [4]] >>> combine(1, 1) [[1]] >>> combine(5, 3) [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]]","solution":"from itertools import combinations def combine(n, k): Returns all possible combinations of k numbers out of the range 1 to n inclusive. return [list(c) for c in combinations(range(1, n + 1), k)]"},{"question":"from typing import List, Tuple def shortest_cycle_length(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Consider an undirected and unweighted graph with \`n\` nodes and \`m\` edges. We want to find the length of the shortest cycle (if any) present in the graph. A cycle is a path of edges and vertices wherein a vertex is reachable from itself. The length of a cycle is the number of edges it contains. If no cycle exists, the length should be considered infinite. >>> shortest_cycle_length(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4)]) 3 >>> shortest_cycle_length(4, 2, [(1, 2), (3, 4)]) -1 >>> shortest_cycle_length(6, 7, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5), (5, 6)]) 3","solution":"from collections import deque, defaultdict def shortest_cycle_length(n, m, edges): def bfs(start): distance = [-1] * (n + 1) queue = deque([(start, -1)]) distance[start] = 0 min_cycle_length = float('inf') while queue: node, parent = queue.popleft() for neighbor in graph[node]: if distance[neighbor] == -1: distance[neighbor] = distance[node] + 1 queue.append((neighbor, node)) elif neighbor != parent: min_cycle_length = min(min_cycle_length, distance[node] + distance[neighbor] + 1) return min_cycle_length graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) shortest_cycle = float('inf') for i in range(1, n + 1): shortest_cycle = min(shortest_cycle, bfs(i)) if shortest_cycle == float('inf'): return -1 else: return shortest_cycle"},{"question":"def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix 90 degrees clockwise. >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] pass","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a square matrix 90 degrees clockwise. n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][n - 1 - i] = matrix[i][j] return result"},{"question":"def determine_winner(team1_points, team2_points): Given two arrays representing the points scored by each team in different quarters, determine which team won the game. Args: team1_points (list): A list of four positive integers representing points scored by the first team. team2_points (list): A list of four positive integers representing points scored by the second team. Returns: int: 1 if the first team won, 2 if the second team won, or 0 if the game ended in a draw. >>> determine_winner([25, 18, 20, 22], [20, 22, 21, 21]) 1 >>> determine_winner([15, 16, 18, 20], [21, 19, 22, 17]) 2 >>> determine_winner([23, 19, 22, 21], [21, 22, 23, 19]) 0","solution":"def determine_winner(team1_points, team2_points): Given two arrays representing the points scored by each team in different quarters, determine which team won the game. Args: team1_points (list): A list of four positive integers representing points scored by the first team. team2_points (list): A list of four positive integers representing points scored by the second team. Returns: int: 1 if the first team won, 2 if the second team won, or 0 if the game ended in a draw. total_team1 = sum(team1_points) total_team2 = sum(team2_points) if total_team1 > total_team2: return 1 elif total_team2 > total_team1: return 2 else: return 0"},{"question":"def max_excitement(N: int, excitements: List[int]) -> int: Determine the maximum total excitement value by choosing songs following the rules. Parameters: N : int : number of songs excitements : list of int : excitement values of the songs Returns: int : maximum excitement value >>> max_excitement(5, [10, 20, 30, 40, 10]) 100 >>> max_excitement(4, [7, 7, 7, 7]) 7 >>> max_excitement(7, [1, 2, 2, 3, 4, 4, 5]) 15","solution":"def max_excitement(N, excitements): Determine the maximum total excitement value by choosing songs following the rules. Parameters: N : int : number of songs excitements : list of int : excitement values of the songs Returns: int : maximum excitement value # Use a set to keep track of unique excitement values unique_excitements = set(excitements) # Sum up the unique excitement values max_excitement_value = sum(unique_excitements) return max_excitement_value"},{"question":"from typing import List def find_subsets(nums: List[int]) -> List[List[int]]: Implement a function that takes a list of unique integers and returns all possible subsets (the power set). The solution must not include duplicate subsets and should be sorted in non-descending order. >>> find_subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> find_subsets([4, 1]) [[], [1], [1, 4], [4]] >>> find_subsets([]) [[]] >>> find_subsets([1]) [[], [1]] >>> find_subsets([5, 3, 9]) [[], [3], [3, 5], [3, 5, 9], [3, 9], [5], [5, 9], [9]] pass","solution":"from typing import List def find_subsets(nums: List[int]) -> List[List[int]]: nums.sort() result = [] def backtrack(start=0, current=[]): result.append(current[:]) for i in range(start, len(nums)): current.append(nums[i]) backtrack(i + 1, current) current.pop() backtrack() return result"},{"question":"def is_well_formed(parentheses: str) -> bool: Determines if the input string of parentheses is well-formed. Args: parentheses (str): The input string containing only '(' and ')'. Returns: bool: True if the string is well-formed, False otherwise. >>> is_well_formed(\\"((()))\\") True >>> is_well_formed(\\")()(\\") False >>> is_well_formed(\\"()()\\") True >>> is_well_formed(\\"((())\\") False >>> is_well_formed(\\"\\") True","solution":"def is_well_formed(parentheses: str) -> bool: Determines if the input string of parentheses is well-formed. Args: parentheses (str): The input string containing only '(' and ')'. Returns: bool: True if the string is well-formed, False otherwise. balance = 0 for char in parentheses: if char == '(': balance += 1 elif char == ')': balance -= 1 # If balance is negative, parentheses are not well-formed if balance < 0: return False # A well-formed string will end with balance = 0 return balance == 0"},{"question":"def has_subset_sum_zero(arr: List[int]) -> bool: Determines if there is a subset of integers in arr that sums to zero. Parameters: arr (list of int): The array of integers. Returns: bool: True if there is a subset that sums to zero, False otherwise. >>> has_subset_sum_zero([4, 3, -3, 1, 8]) True >>> has_subset_sum_zero([1, 2, 3]) False from solution import has_subset_sum_zero def test_empty_array(): assert not has_subset_sum_zero([]) def test_single_zero_element(): assert has_subset_sum_zero([0]) def test_no_zero_subset(): assert not has_subset_sum_zero([1, 2, 3]) def test_subset_sums_to_zero_two_elements(): assert has_subset_sum_zero([4, 3, -3, 1, 8]) # subset [3, -3] def test_subset_sums_to_zero_multiple_elements(): assert has_subset_sum_zero([3, -1, -7, 2, 8]) # subset [-1, -7, 8] def test_subset_sums_to_zero_large_positive_and_negative(): assert has_subset_sum_zero([5, 7, -2, -2, -3, 2, 0]) # subset [2, -2] def test_subset_sums_to_zero_contains_zero(): assert has_subset_sum_zero([4, 0, 5, -5]) # subset [0] def test_no_subset(): assert not has_subset_sum_zero([1, 3, 6, 8, 10])","solution":"def has_subset_sum_zero(arr): Determines if there is a subset of integers in arr that sums to zero. Parameters: arr (list of int): The array of integers. Returns: bool: True if there is a subset that sums to zero, False otherwise. if not arr: return False # Use a set to store the sum of subsets sum_set = set() sum_set.add(0) for num in arr: current_sums = list(sum_set) for s in current_sums: if s + num == 0: return True sum_set.add(s + num) return False"},{"question":"def capitalize_words_and_double_numbers(input_string: str) -> str: This function takes a string containing a mix of words and numbers, and returns a new string where every word is capitalized and every number is doubled. >>> capitalize_words_and_double_numbers(\\"hello 3 world 5\\") \\"Hello 6 World 10\\" >>> capitalize_words_and_double_numbers(\\"test 1 string 2\\") \\"Test 2 String 4\\" >>> capitalize_words_and_double_numbers(\\"this is a test\\") \\"This Is A Test\\" >>> capitalize_words_and_double_numbers(\\"1 2 3 4\\") \\"2 4 6 8\\" >>> capitalize_words_and_double_numbers(\\"python 8 is 4 cool 2\\") \\"Python 16 Is 8 Cool 4\\" >>> capitalize_words_and_double_numbers(\\"word 10\\") \\"Word 20\\" >>> capitalize_words_and_double_numbers(\\"hello 100\\") \\"Hello 200\\" >>> capitalize_words_and_double_numbers(\\"\\") \\"\\" >>> capitalize_words_and_double_numbers(\\" leading 3 \\") \\"Leading 6\\" >>> capitalize_words_and_double_numbers(\\"trailing 4 \\") \\"Trailing 8\\"","solution":"def capitalize_words_and_double_numbers(input_string): This function takes a string containing a mix of words and numbers, and returns a new string where every word is capitalized and every number is doubled. words = input_string.split() result = [] for word in words: if word.isdigit(): result.append(str(int(word) * 2)) else: result.append(word.capitalize()) return ' '.join(result)"},{"question":"def rank_teams(teams: List[str], results: List[Tuple[str, int, str, int]]) -> List[Tuple[str, int]]: Ranks teams based on their performance in a round-robin tournament. Args: teams (list): List of team names. results (list): List of tuples representing match results in the format (team1, score1, team2, score2). Returns: list: Sorted list of tuples where each tuple is (team_name, points). >>> teams = [\\"Red\\", \\"Green\\", \\"Blue\\"] >>> results = [(\\"Red\\", 3, \\"Green\\", 1), (\\"Green\\", 2, \\"Blue\\", 2), (\\"Blue\\", 4, \\"Red\\", 1)] >>> rank_teams(teams, results) [(\\"Blue\\", 4), (\\"Red\\", 3), (\\"Green\\", 1)] >>> teams = [\\"A\\", \\"B\\", \\"C\\"] >>> results = [(\\"A\\", 1, \\"B\\", 1), (\\"A\\", 2, \\"C\\", 2), (\\"B\\", 3, \\"C\\", 3)] >>> rank_teams(teams, results) [(\\"A\\", 2), (\\"B\\", 2), (\\"C\\", 2)] >>> teams = [\\"X\\", \\"Y\\", \\"Z\\"] >>> results = [(\\"X\\", 1, \\"Y\\", 0), (\\"X\\", 2, \\"Z\\", 0), (\\"Y\\", 1, \\"Z\\", 0)] >>> rank_teams(teams, results) [(\\"X\\", 6), (\\"Y\\", 3), (\\"Z\\", 0)] >>> teams = [\\"B\\", \\"A\\"] >>> results = [(\\"B\\", 1, \\"A\\", 1)] >>> rank_teams(teams, results) [(\\"A\\", 1), (\\"B\\", 1)] >>> teams = [\\"Cat\\", \\"Dog\\", \\"Mouse\\"] >>> results = [(\\"Cat\\", 0, \\"Dog\\", 1), (\\"Cat\\", 0, \\"Mouse\\", 2), (\\"Dog\\", 3, \\"Mouse\\", 1)] >>> rank_teams(teams, results) [(\\"Dog\\", 6), (\\"Mouse\\", 3), (\\"Cat\\", 0)]","solution":"def rank_teams(teams, results): Ranks teams based on their performance in a round-robin tournament. Args: teams (list): List of team names. results (list): List of tuples representing match results in the format (team1, score1, team2, score2). Returns: list: Sorted list of tuples where each tuple is (team_name, points). points = {team: 0 for team in teams} for team1, score1, team2, score2 in results: if score1 > score2: points[team1] += 3 elif score2 > score1: points[team2] += 3 else: points[team1] += 1 points[team2] += 1 ranked_teams = sorted(points.items(), key=lambda x: (-x[1], x[0])) return ranked_teams"},{"question":"def max_subarray_sum_not_exceeding_m(N: int, M: int, A: List[int]) -> int: Finds the maximum possible sum of a consecutive subarray such that the sum does not exceed M. Parameters: - N: length of the array A - M: maximum allowed sum for a subarray - A: list of integers representing the array Returns: - A single integer which is the maximum sum not exceeding M. >>> max_subarray_sum_not_exceeding_m(5, 10, [1, 2, 3, 4, 5]) 10 >>> max_subarray_sum_not_exceeding_m(3, 1, [2, 2, 2]) 0 >>> max_subarray_sum_not_exceeding_m(1, 5, [5]) 5 >>> max_subarray_sum_not_exceeding_m(4, 10, [1, 2, 3, 4]) 10 >>> max_subarray_sum_not_exceeding_m(5, 7, [1, 2, 8, 3, 4]) 7 >>> max_subarray_sum_not_exceeding_m(5, 1000, [100, 200, 300, 400, 500]) 1000 >>> max_subarray_sum_not_exceeding_m(4, 4, [-1, -1, -1, -1]) 0 >>> max_subarray_sum_not_exceeding_m(6, 3, [1, 2, -1, -2, 3, -3]) 3 pass","solution":"def max_subarray_sum_not_exceeding_m(N, M, A): Finds the maximum possible sum of a consecutive subarray such that the sum does not exceed M. Parameters: - N: length of the array A - M: maximum allowed sum for a subarray - A: list of integers representing the array Returns: - A single integer which is the maximum sum not exceeding M. max_sum = 0 current_sum = 0 start = 0 for end in range(N): current_sum += A[end] while current_sum > M and start <= end: current_sum -= A[start] start += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def departments_to_notify(test_cases: List[Dict]) -> List[List[str]]: Determine which departments should receive a notification based on the number of employees. >>> departments_to_notify([{\\"limits\\": (3, 10), \\"departments\\": [(\\"Sales\\", 5), (\\"Engineering\\", 15), (\\"HR\\", 8)]}]) [['Engineering']] >>> departments_to_notify([{\\"limits\\": (2, 20), \\"departments\\": [(\\"Marketing\\", 22), (\\"Support\\", 18)]}]) [['Marketing']] >>> departments_to_notify([{\\"limits\\": (3, 100), \\"departments\\": [(\\"Logistics\\", 50), (\\"Production\\", 30), (\\"R&D\\", 20)]}]) [['NO DEPARTMENTS']] >>> departments_to_notify([{\\"limits\\": (4, 20), \\"departments\\": [(\\"Admin\\", 25), (\\"Finance\\", 30), (\\"Legal\\", 15), (\\"IT\\", 25)]}]) [['Admin', 'Finance', 'IT']] >>> departments_to_notify([{\\"limits\\": (3, 15), \\"departments\\": [(\\"Research\\", 15), (\\"Operations\\", 20), (\\"Support\\", 15)]}]) [['Operations']]","solution":"def departments_to_notify(test_cases): results = [] for test in test_cases: D, K = test[\\"limits\\"] departments = test[\\"departments\\"] eligible_departments = [name for name, num in departments if num > K] if eligible_departments: results.append(eligible_departments) else: results.append([\\"NO DEPARTMENTS\\"]) return results"},{"question":"from typing import List, Dict def prime_factors(n: int) -> List[int]: Returns a list of prime factors of the given integer n. >>> prime_factors(10) [2, 5] >>> prime_factors(15) [3, 5] def solution(lst: List[int]) -> Dict[int, List[int]]: Returns a dictionary with integers as keys and their prime factors as values. >>> solution([10, 15, 21]) {10: [2, 5], 15: [3, 5], 21: [3, 7]} >>> solution([13, 18]) {13: [13], 18: [2, 3]} Unit Test: from solution import solution, prime_factors def test_prime_factors_single(): assert prime_factors(10) == [2, 5] assert prime_factors(15) == [3, 5] assert prime_factors(21) == [3, 7] def test_prime_factors_prime_number(): assert prime_factors(13) == [13] assert prime_factors(7) == [7] def test_prime_factors_composite_number(): assert prime_factors(18) == [2, 3] assert prime_factors(100) == [2, 5] def test_solution_multiple_numbers(): assert solution([10, 15, 21]) == {10: [2, 5], 15: [3, 5], 21: [3, 7]} assert solution([13, 18]) == {13: [13], 18: [2, 3]} def test_solution_empty_list(): assert solution([]) == {} def test_solution_single_element_list(): assert solution([29]) == {29: [29]}","solution":"def prime_factors(n): Returns a list of prime factors of the given integer n. i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i if i not in factors: factors.append(i) if n > 1 and n not in factors: factors.append(n) return factors def solution(lst): Returns a dictionary with integers as keys and their prime factors as values. return {num: prime_factors(num) for num in lst}"},{"question":"from typing import List def group_anagrams(nums: List[int]) -> List[List[int]]: Groups integers that are permutations of each other. :param nums: List of integers. :return: List of lists, where each sublist contains integers that are permutations of each other. >>> group_anagrams([123, 231, 312, 456, 564, 645, 789, 897]) [[123, 231, 312], [456, 564, 645], [789, 897]] >>> group_anagrams([]) [] >>> group_anagrams([123]) [[123]] >>> group_anagrams([111, 222, 333]) [[111], [222], [333]] >>> group_anagrams([112, 121, 211, 34, 43, 21, 12]) [[112, 121, 211], [34, 43], [21, 12]]","solution":"from collections import defaultdict from typing import List def group_anagrams(nums: List[int]) -> List[List[int]]: Groups integers that are permutations of each other. :param nums: List of integers. :return: List of lists, where each sublist contains integers that are permutations of each other. anagram_groups = defaultdict(list) for num in nums: key = tuple(sorted(str(num))) anagram_groups[key].append(num) return list(anagram_groups.values())"},{"question":"from typing import List def longest_word(words: List[str]) -> str: Find the longest word in the list that can be constructed one character at a time by other words in the list. If multiple words have the same length, return the smallest lexicographical word. >>> longest_word([\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"]) 'apple' >>> longest_word([\\"w\\",\\"wo\\",\\"wor\\",\\"worl\\",\\"world\\"]) 'world' pass def test_longest_word_example1(): words = [\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"] assert longest_word(words) == \\"apple\\" def test_longest_word_example2(): words = [\\"w\\",\\"wo\\",\\"wor\\",\\"worl\\",\\"world\\"] assert longest_word(words) == \\"world\\" def test_longest_word_single_word(): words = [\\"a\\"] assert longest_word(words) == \\"a\\" def test_longest_word_multiple_same_length(): words = [\\"a\\", \\"ab\\", \\"abc\\", \\"abd\\"] assert longest_word(words) == \\"abc\\" def test_longest_word_non_continuous(): words = [\\"a\\", \\"abc\\", \\"abd\\"] assert longest_word(words) == \\"a\\" def test_longest_word_large_input(): words = [\\"a\\"] + [\\"a\\" * i for i in range(2, 31)] + [\\"b\\" * i for i in range(2, 31)] assert longest_word(words) == \\"a\\" * 30","solution":"def longest_word(words): Returns the longest word in the list that can be constructed one character at a time by other words in the list. If multiple words have the same length, returns the smallest lexicographical word. words_set = set(words) longest = \\"\\" for word in words: if all(word[:i] in words_set for i in range(1, len(word) + 1)): if len(word) > len(longest) or (len(word) == len(longest) and word < longest): longest = word return longest"},{"question":"def determine_winner(sequence): Determines the winner of the game where Alice picks the largest remaining even number and Bob picks the largest remaining odd number. Parameters: sequence (list): List of integers representing the sequence. Returns: str: \\"ALICE\\" if Alice wins, \\"BOB\\" if Bob wins, \\"TIE\\" if neither can make a move from the start. import pytest from solution import determine_winner def test_no_evens(): assert determine_winner([1, 3, 5]) == \\"BOB\\" def test_no_odds(): assert determine_winner([2, 4, 6]) == \\"ALICE\\" def test_mixed_numbers1(): assert determine_winner([1, 2, 3, 5, 7, 8]) == \\"BOB\\" def test_mixed_numbers2(): assert determine_winner([1, 2, 3, 4, 5, 6]) == \\"BOB\\" def test_single_even_number(): assert determine_winner([2]) == \\"ALICE\\" def test_single_odd_number(): assert determine_winner([1]) == \\"BOB\\" def test_alternate_numbers(): assert determine_winner([1, 2, 3, 4]) == \\"BOB\\" def test_all_negatives(): assert determine_winner([-1, -2, -3, -4, -5, -6]) == \\"BOB\\" def test_large_numbers(): assert determine_winner([10000000, 999999, 999998]) == \\"ALICE\\" # Run the tests pytest.main()","solution":"def determine_winner(sequence): Determines the winner of the game where Alice picks the largest remaining even number and Bob picks the largest remaining odd number. Parameters: sequence (list): List of integers representing the sequence. Returns: str: \\"ALICE\\" if Alice wins, \\"BOB\\" if Bob wins, \\"TIE\\" if neither can make a move from the start. evens = sorted([num for num in sequence if num % 2 == 0], reverse=True) odds = sorted([num for num in sequence if num % 2 != 0], reverse=True) turn = 'ALICE' while True: if turn == 'ALICE': if evens: evens.pop(0) else: return 'BOB' turn = 'BOB' else: if odds: odds.pop(0) else: return 'ALICE' turn = 'ALICE' # Examples for verification print(determine_winner([1, 2, 3, 5, 7, 8])) # Output: \\"BOB\\" print(determine_winner([2, 4, 6])) # Output: \\"ALICE\\" print(determine_winner([1, 3, 5])) # Output: \\"BOB\\" print(determine_winner([1, 2, 3, 4, 5, 6])) # Output: \\"BOB\\" print(determine_winner([1])) # Output: \\"BOB\\""},{"question":"def count_adjacent_swaps_to_sort(arr): Counts the minimum number of adjacent swaps required to sort the array in non-decreasing order. :param arr: A list of distinct integers. :return: The minimum number of adjacent swaps required to sort the array. from solution import count_adjacent_swaps_to_sort def test_pre_sorted_array(): assert count_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) == 0 def test_reverse_sorted_array(): assert count_adjacent_swaps_to_sort([5, 4, 3, 2, 1]) == 10 def test_unsorted_array_1(): assert count_adjacent_swaps_to_sort([3, 1, 2]) == 2 def test_unsorted_array_2(): assert count_adjacent_swaps_to_sort([4, 3, 2, 1]) == 6 def test_empty_array(): assert count_adjacent_swaps_to_sort([]) == 0 def test_single_element_array(): assert count_adjacent_swaps_to_sort([42]) == 0 def test_large_sorted_array(): assert count_adjacent_swaps_to_sort(list(range(1000))) == 0 def test_large_reverse_sorted_array(): assert count_adjacent_swaps_to_sort(list(range(999, -1, -1))) == 499500","solution":"def count_adjacent_swaps_to_sort(arr): Counts the minimum number of adjacent swaps required to sort the array in non-decreasing order. :param arr: A list of distinct integers. :return: The minimum number of adjacent swaps required to sort the array. if not arr or len(arr) <= 1: return 0 # Implementing using the count of inversions logic def count_inversions(arr): # Helper function to use merge sort to count inversions def merge_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0] * len(arr) return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1) return count_inversions(arr)"},{"question":"def title_to_number(column_title: str) -> int: Given a string that represents a column title as it appears in an Excel sheet, return its corresponding column number. >>> title_to_number(\\"A\\") 1 >>> title_to_number(\\"AB\\") 28 >>> title_to_number(\\"ZY\\") 701","solution":"def title_to_number(column_title): Given a string that represents a column title as it appears in an Excel sheet, return its corresponding column number. result = 0 for char in column_title: result = result * 26 + (ord(char) - ord('A') + 1) return result"},{"question":"def longest_vowel_substring(str1: str, str2: str) -> int: Determines the length of the longest substring made up of only vowels common in both input strings. Args: str1 (str): First input string. str2 (str): Second input string. Returns: int: Length of the longest common vowel substring. >>> longest_vowel_substring(\\"aeiouxxaeiou\\", \\"xxaeiouxx\\") 5 >>> longest_vowel_substring(\\"aeiox\\", \\"bdfgh\\") 0 >>> longest_vowel_substring(\\"a\\", \\"a\\") 1 >>> longest_vowel_substring(\\"aeiouaeiou\\", \\"eiou\\") 4 >>> longest_vowel_substring(\\"aeixou\\", \\"oeiaou\\") 2 >>> longest_vowel_substring(\\"aaaaaaaaaaa\\", \\"aaaaaa\\") 6","solution":"def is_vowel(char): Check if a character is a vowel. return char in 'aeiou' def longest_vowel_substring(str1, str2): Determines the longest substring made up of only vowels common in both input strings. Params: str1 (str): First input string. str2 (str): Second input string. Returns: int: Length of the longest common vowel substring. len1, len2 = len(str1), len(str2) # Initialize a 2D list to store lengths of longest common suffixes of substrings dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_length = 0 for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1] and is_vowel(str1[i - 1]): dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_length: max_length = dp[i][j] else: dp[i][j] = 0 return max_length"},{"question":"def find_shortest_gap(events): Returns the shortest gap between two consecutive events. If there are no gaps, return 0. Parameters: events (List[Tuple[int, int]]): List of tuples representing the events. Returns: int: The shortest gap between two consecutive events. Examples: >>> find_shortest_gap([(540, 600), (630, 700), (720, 780)]) 20 >>> find_shortest_gap([(540, 600), (600, 660), (660, 720)]) 0 pass def test_find_shortest_gap_with_gaps(): events = [(540, 600), (630, 700), (720, 780)] assert find_shortest_gap(events) == 20 def test_find_shortest_gap_no_gaps(): events = [(540, 600), (600, 660), (660, 720)] assert find_shortest_gap(events) == 0 def test_find_shortest_gap_single_gap(): events = [(0, 1), (2, 3)] assert find_shortest_gap(events) == 1 def test_find_shortest_gap_large_input(): events = [(i, i + 10) for i in range(0, 1440, 20)] assert find_shortest_gap(events) == 10 def test_find_shortest_gap_large_gap(): events = [(0, 1), (1000, 1001)] assert find_shortest_gap(events) == 999","solution":"def find_shortest_gap(events): Returns the shortest gap between two consecutive events. If there are no gaps, return 0. shortest_gap = float('inf') for i in range(1, len(events)): gap = events[i][0] - events[i - 1][1] if gap < shortest_gap: shortest_gap = gap return shortest_gap if shortest_gap != float('inf') else 0"},{"question":"def longest_non_decreasing_subsequence(arr: List[int]) -> int: Takes a list of integers and returns the length of the longest contiguous subsequence that consists of non-decreasing elements. >>> longest_non_decreasing_subsequence([5]) 1 >>> longest_non_decreasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_non_decreasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_subsequence([1, 3, 2, 3, 4, 8, 3, 3, 5, 6]) 4 >>> longest_non_decreasing_subsequence([1, 3, 3, 2, 2, 1]) 3 >>> longest_non_decreasing_subsequence([10, 20, 10, 30, 40]) 3 >>> longest_non_decreasing_subsequence([2, 2, 2, 2, 2]) 5 >>> longest_non_decreasing_subsequence([1, 2, 0, 1, 2, 3, 4, 1]) 5","solution":"def longest_non_decreasing_subsequence(arr): Takes a list of integers and returns the length of the longest contiguous subsequence that consists of non-decreasing elements. if not arr: return 0 longest = 1 current_length = 1 for i in range(1, arr.length): if arr[i] >= arr[i - 1]: current_length += 1 longest = max(longest, current_length) else: current_length = 1 return longest"},{"question":"def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest consecutive subsequence in the list of numbers. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_subsequence([10, 5, 12, 3, 55, 4, 13, 6, 11]) == 4 >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([1]) == 1 >>> longest_consecutive_subsequence([10, 30, 20, 50]) == 1 >>> longest_consecutive_subsequence([5, 1, 2, 3, 4]) == 5 >>> longest_consecutive_subsequence([1, 2, 2, 3, 4]) == 4","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest consecutive subsequence in the list of numbers. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def highest_product_of_three(nums_str: str) -> int: Returns the highest product of any three distinct integers from the sequence of space-separated integers. >>> highest_product_of_three(\\"1 10 2 6 5 3\\") 300 >>> highest_product_of_three(\\"4 5 -1 8 -6 10\\") 400 >>> highest_product_of_three(\\"-10 -10 5 2\\") 500","solution":"def highest_product_of_three(nums_str): Returns the highest product of any three distinct integers from the sequence of space-separated integers. nums = list(map(int, nums_str.split())) nums.sort() # Consider the largest three numbers and the two smallest numbers with the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def find_words_ending_with_e(s: str) -> str: Finds all unique words ending with 'e' and returns them sorted in alphabetical order. :param s: A string consisting of lowercase letters and spaces. :return: A string with unique words ending with 'e', sorted alphabetically. >>> find_words_ending_with_e(\\"the quick brown fox jumps over the lazy dog before time\\") 'before the time' >>> find_words_ending_with_e(\\"the\\") 'the' >>> find_words_ending_with_e(\\"time\\") 'time' >>> find_words_ending_with_e(\\"apple\\") 'apple' >>> find_words_ending_with_e(\\"banana\\") '' >>> find_words_ending_with_e(\\"quick brown fox\\") '' >>> find_words_ending_with_e(\\"lazy dog jumps\\") '' >>> find_words_ending_with_e(\\"the the the time time before\\") 'before the time' >>> find_words_ending_with_e(\\"apple banana apple grape\\") 'apple grape' >>> find_words_ending_with_e(\\"\\") ''","solution":"def find_words_ending_with_e(s): Finds all unique words ending with 'e' and returns them sorted in alphabetical order. :param s: A string consisting of lowercase letters and spaces. :return: A string with unique words ending with 'e', sorted alphabetically. words = s.split() e_words = {word for word in words if word.endswith('e')} sorted_e_words = sorted(e_words) return ' '.join(sorted_e_words)"},{"question":"from typing import List, Tuple def max_virtual_objects(n: int, m: int, d: int, k: int, potential_positions: List[Tuple[int, int]]) -> int: Determine the maximum number of virtual objects that can be placed on the grid while maintaining the minimum distance. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. d (int): Minimum distance that must be maintained between any two objects. k (int): Number of potential virtual object placements. potential_positions (List[Tuple[int, int]]): List of tuples representing the coordinates of the potential placements on the grid. Returns: int: Maximum number of virtual objects that can be placed on the grid while maintaining the minimum distance. Examples: >>> max_virtual_objects(5, 5, 2, 5, [(1, 1), (2, 3), (4, 4), (3, 3), (5, 5)]) 3 >>> max_virtual_objects(1, 1, 1, 1, [(1, 1)]) 1 >>> max_virtual_objects(20, 20, 100, 1, [(10, 10)]) 1 >>> max_virtual_objects(5, 5, 3, 4, [(1, 1), (1, 5), (5, 1), (5, 5)]) 4 def process_input(test_cases: List[dict]) -> List[int]: Process multiple test cases and return the results for each. Parameters: test_cases (List[dict]): List of dictionaries where each dictionary contains grid_size (tuple), min_distance (int), num_positions (int), and positions (list of tuples). Returns: List[int]: List of results for each test case. # Unit testing functions def test_single_case(): test_cases = [ { 'grid_size': (5, 5), 'min_distance': 2, 'num_positions': 5, 'positions': [(1, 1), (2, 3), (4, 4), (3, 3), (5, 5)] } ] results = process_input(test_cases) assert results == [3] # The expected result should be 3 def test_minimum_input(): test_cases = [ { 'grid_size': (1, 1), 'min_distance': 1, 'num_positions': 1, 'positions': [(1, 1)] } ] results = process_input(test_cases) assert results == [1] # Only one object can be placed def test_no_possible_placement(): test_cases = [ { 'grid_size': (20, 20), 'min_distance': 100, 'num_positions': 1, 'positions': [(10, 10)] } ] results = process_input(test_cases) assert results == [1] # Only one object can be placed because of high distance def test_multiple_possible_placements(): test_cases = [ { 'grid_size': (5, 5), 'min_distance': 3, 'num_positions': 4, 'positions': [(1, 1), (1, 5), (5, 1), (5, 5)] } ] results = process_input(test_cases) assert results == [4] # All objects are sufficiently spaced def test_multiple_cases(): test_cases = [ { 'grid_size': (5, 5), 'min_distance': 2, 'num_positions': 5, 'positions': [(1, 1), (2, 3), (4, 4), (3, 3), (5, 5)] }, { 'grid_size': (4, 4), 'min_distance': 2, 'num_positions': 3, 'positions': [(1, 1), (2, 2), (4, 4)] } ] results = process_input(test_cases) assert results == [3, 2] # Result for first case should be 3, and for the second case should be 2","solution":"def max_virtual_objects(n, m, d, k, potential_positions): def dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5 def can_place(position): for i, placed in enumerate(placed_positions): if dist(position[0], position[1], placed[0], placed[1]) < d: return False return True placed_positions = [] for i in range(k): x, y = potential_positions[2*i], potential_positions[2*i + 1] if can_place((x, y)): placed_positions.append((x, y)) return len(placed_positions) def process_input(test_cases): results = [] for tc in test_cases: n, m = tc['grid_size'] d = tc['min_distance'] k = tc['num_positions'] potential_positions = tc['positions'] result = max_virtual_objects(n, m, d, k, potential_positions) results.append(result) return results"},{"question":"class MealLog: A class to log meals and categorize them as healthy or unhealthy. Methods: add_meal(name: str, calories: int, is_healthy: bool) total_calories() get_meals(show_healthy: bool=None) def __init__(self): self.meals = [] def add_meal(self, name: str, calories: int, is_healthy: bool): Add a meal with its name, calorie count, and a boolean indicating if it's healthy. pass def total_calories(self): Calculate the total number of calories consumed. pass def get_meals(self, show_healthy: bool=None): Retrieve a list of all meals, optionally filtered to show only healthy meals or only unhealthy meals. pass # Example usage meal_log = MealLog() meal_log.add_meal(\\"Salad\\", 150, True) meal_log.add_meal(\\"Burger\\", 500, False) meal_log.add_meal(\\"Smoothie\\", 200, True) assert meal_log.total_calories() == 850 # Total calories are 150 + 500 + 200 all_meals = meal_log.get_meals() # Expected: [{'name': 'Salad', 'calories': 150, 'is_healthy': True}, {'name': 'Burger', 'calories': 500, 'is_healthy': False}, {'name': 'Smoothie', 'calories': 200, 'is_healthy': True}] healthy_meals = meal_log.get_meals(show_healthy=True) # Expected: [{'name': 'Salad', 'calories': 150, 'is_healthy': True}, {'name': 'Smoothie', 'calories': 200, 'is_healthy': True}] unhealthy_meals = meal_log.get_meals(show_healthy=False) # Expected: [{'name': 'Burger', 'calories': 500, 'is_healthy': False}]","solution":"class MealLog: def __init__(self): self.meals = [] def add_meal(self, name: str, calories: int, is_healthy: bool): meal = { \\"name\\": name, \\"calories\\": calories, \\"is_healthy\\": is_healthy } self.meals.append(meal) def total_calories(self): return sum(meal[\\"calories\\"] for meal in self.meals) def get_meals(self, show_healthy: bool=None): if show_healthy is None: return self.meals return [meal for meal in self.meals if meal[\\"is_healthy\\"] == show_healthy]"},{"question":"def length_of_lis(nums: list) -> int: Returns the length of the longest increasing subsequence in a list of integers. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([10]) 1 >>> length_of_lis([1, 2, 3, 4, 5, 6, 7]) 7 >>> length_of_lis([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> length_of_lis([3, 10, 2, 1, 20]) 3 >>> length_of_lis([50, 3, 10, 7, 40, 80]) 4 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6","solution":"import bisect def length_of_lis(nums: list) -> int: Returns the length of the longest increasing subsequence in a list of integers. if not nums: return 0 lis = [] for num in nums: pos = bisect.bisect_left(lis, num) # If num is greater than all elements in lis, append it. if pos == len(lis): lis.append(num) # Otherwise, replace the first element in lis that is # greater than or equal to num. else: lis[pos] = num return len(lis)"},{"question":"def generateTags(title: str) -> List[str]: Returns a list of tags generated from the book title. Tags are in lowercase and exclude common stop words. >>> generateTags(\\"The Chronicles of Narnia\\") ['chronicles', 'narnia'] >>> generateTags(\\"Harry Potter and the Chamber of Secrets\\") ['harry', 'potter', 'chamber', 'secrets'] >>> generateTags(\\"A Brief History of Time\\") ['brief', 'history', 'time'] >>> generateTags(\\"\\") [] >>> generateTags(\\"And The Of To A In For On With As By At An\\") [] >>> generateTags(\\"Magic Spells Enchantments\\") ['magic', 'spells', 'enchantments'] >>> generateTags(\\"Lorem Ipsum And DOLOR Sit AMET\\") ['lorem', 'ipsum', 'dolor', 'sit', 'amet'] >>> generateTags(\\"The Chronicles, of Narnia!\\") ['chronicles,', 'narnia!']","solution":"def generateTags(title): Returns a list of tags generated from the book title. Tags are in lowercase and exclude common stop words. stop_words = {\\"and\\", \\"the\\", \\"of\\", \\"to\\", \\"a\\", \\"in\\", \\"for\\", \\"on\\", \\"with\\", \\"as\\", \\"by\\", \\"at\\", \\"an\\"} words = title.lower().split() tags = [word for word in words if word not in stop_words] return tags"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Write a function that takes an integer \`n\` as input and returns a list of the first \`n\` numbers in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - The first two numbers are 0 and 1. - Each subsequent number is the sum of the previous two numbers. For example, if \`n\` is 5, the function should return \`[0, 1, 1, 2, 3]\`. If \`n\` is 10, the function should return \`[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\`. Your function should handle cases where \`n\` is 0 (return an empty list) or 1 (return a list with only the first Fibonacci number). >>> fibonacci_sequence(0) == [] True >>> fibonacci_sequence(1) == [0] True >>> fibonacci_sequence(2) == [0, 1] True >>> fibonacci_sequence(5) == [0, 1, 1, 2, 3] True >>> fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] True","solution":"def fibonacci_sequence(n): Returns a list of the first n numbers in the Fibonacci sequence. if n == 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] while len(fib_sequence) < n: next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) return fib_sequence"},{"question":"def compress_string(s: str) -> str: Compresses the string by replacing consecutive duplicate characters with the character followed by the number of occurrences. If the compressed string is not smaller than the original string, return the original string. >>> compress_string('aabcccccaaa') == 'a2b1c5a3' >>> compress_string('abcd') == 'abcd' >>> compress_string('aabbccdd') == 'aabbccdd'","solution":"def compress_string(s): Compresses the string by replacing consecutive duplicate characters with the character followed by the number of occurrences. Parameters: s (str): The input string. Returns: str: The compressed string or the original string if the compressed version is not smaller. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def shortest_path(maze: List[List[int]], teleporters: Dict[Tuple[int, int], Tuple[int, int]]) -> int: Finds the shortest path in a maze from the top-left corner (0, 0) to the bottom-right corner (N-1, N-1) considering teleporters. >>> maze = [ ... [0, 1, 1, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 1], ... [1, 1, 0, 0] ... ] >>> teleporters = {} >>> shortest_path(maze, teleporters) 6 >>> maze = [ ... [0, 1, 1, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 1], ... [1, 1, 0, 0] ... ] >>> teleporters = { ... (0, 0): (2, 1) ... } >>> shortest_path(maze, teleporters) 4 >>> maze = [ ... [0, 1, 1, 1], ... [0, 0, 1, 0], ... [1, 0, 0, 1], ... [1, 1, 0, 0] ... ] >>> teleporters = { ... (0, 0): (2, 1), ... (1, 3): (3, 3) ... } >>> shortest_path(maze, teleporters) 4 >>> maze = [ ... [0, 1, 1, 1], ... [0, 1, 1, 0], ... [1, 0, 0, 1], ... [1, 1, 0, 0] ... ] >>> teleporters = {} >>> shortest_path(maze, teleporters) -1 >>> maze = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> teleporters = {} >>> shortest_path(maze, teleporters) 6 pass","solution":"from typing import List, Dict, Tuple from collections import deque def shortest_path(maze: List[List[int]], teleporters: Dict[Tuple[int, int], Tuple[int, int]]) -> int: Finds the shortest path in a maze from the top-left corner (0, 0) to the bottom-right corner (N-1, N-1) considering teleporters. N = len(maze) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up queue = deque([(0, 0, 0)]) # (Row, Column, Distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if (r, c) == (N-1, N-1): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < N and maze[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) if (r, c) in teleporters and teleporters[(r, c)] not in visited: tr, tc = teleporters[(r, c)] visited.add((tr, tc)) queue.append((tr, tc, dist + 1)) return -1 # If no path is found (which shouldn't happen per problem statement)"},{"question":"def find_pair(sequence, target_sum): Returns a pair of numbers from the sequence that add up to the target sum. If no such pair exists, returns None. >>> find_pair([2, 7, 11, 15], 9) [2, 7] >>> find_pair([1, 2, 3, 4, 5], 10) None >>> find_pair([3, 8, 12, 5, 1, 6], 14) [8, 6]","solution":"def find_pair(sequence, target_sum): Returns a pair of numbers from the sequence that add up to the target sum. If no such pair exists, returns None. num_set = set() for num in sequence: complement = target_sum - num if complement in num_set: return [complement, num] num_set.add(num) return None"},{"question":"def arraySumAndSort(A: List[int], B: List[int]) -> List[int]: Computes a new array C where each element C[i] is the sum of A[i] and B[i], then sorts C in non-descending order and returns it. :param A: List[int], first input array :param B: List[int], second input array :return: List[int], sorted array C >>> arraySumAndSort([3, 1, 4], [1, 5, 9]) [4, 6, 13] >>> arraySumAndSort([-1, -2, -3], [1, 2, 3]) [0, 0, 0]","solution":"def arraySumAndSort(A, B): Computes a new array C where each element C[i] is the sum of A[i] and B[i], then sorts C in non-descending order and returns it. :param A: List[int], first input array :param B: List[int], second input array :return: List[int], sorted array C C = [A[i] + B[i] for i in range(len(A))] C.sort() return C"},{"question":"def max_sum_consecutive_elements(arr: List[int], k: int) -> int: Returns the maximum sum of \`k\` consecutive elements in the list \`arr\`. If the length of the list is less than \`k\`, returns None. >>> max_sum_consecutive_elements([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> max_sum_consecutive_elements([5, 2, -1, 0, 3], 3) 6 >>> max_sum_consecutive_elements([2, 3], 3) None","solution":"def max_sum_consecutive_elements(arr, k): Returns the maximum sum of \`k\` consecutive elements in the list \`arr\`. If the length of the list is less than \`k\`, returns None. n = len(arr) if n < k: return None # Calculate the sum of the first 'k' elements max_sum = current_sum = sum(arr[:k]) # Use the sliding window technique to find the maximum sum for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def generate_sequence(a, b, m, n): Generates the first \`n\` numbers of a modified Fibonacci sequence. Parameters: a (int): The first number of the sequence. b (int): The second number of the sequence. m (int): The modulo to be applied for computing each subsequent number. n (int): The number of elements to generate. Returns: List[int]: The list containing the first \`n\` elements of the modified Fibonacci sequence. from typing import List def test_generate_sequence_example1(): assert generate_sequence(5, 7, 10, 5) == [5, 7, 2, 9, 1] def test_generate_sequence_example2(): assert generate_sequence(0, 1, 100, 10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def test_generate_sequence_example3(): assert generate_sequence(4, 9, 3, 7) == [4, 9, 1, 1, 2, 0, 2] def test_generate_sequence_small_values(): assert generate_sequence(1, 1, 2, 4) == [1, 1, 0, 1] def test_generate_sequence_large_modulo(): assert generate_sequence(1, 1, 1000, 6) == [1, 1, 2, 3, 5, 8] def test_generate_sequence_only_first_value(): assert generate_sequence(2, 3, 4, 1) == [2] def test_generate_sequence_no_elements(): assert generate_sequence(2, 3, 4, 0) == [] def test_generate_sequence_single_element(): assert generate_sequence(2, 3, 4, 1) == [2] def test_generate_sequence_two_elements(): assert generate_sequence(2, 3, 4, 2) == [2, 3] def test_generate_sequence_large_n(): assert generate_sequence(1, 2, 10, 15) == [1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7]","solution":"def generate_sequence(a, b, m, n): Generates the first \`n\` numbers of a modified Fibonacci sequence. Parameters: a (int): The first number of the sequence. b (int): The second number of the sequence. m (int): The modulo to be applied for computing each subsequent number. n (int): The number of elements to generate. Returns: List[int]: The list containing the first \`n\` elements of the modified Fibonacci sequence. if n == 0: return [] elif n == 1: return [a] sequence = [a, b] for _ in range(2, n): next_num = (sequence[-1] + sequence[-2]) % m sequence.append(next_num) return sequence"},{"question":"def duplicate(s: str, n: int) -> str: Duplicate each character in the string exactly n times and return the result. Args: s: A string consisting of lowercase latin letters. n: An integer indicating the number of times each character should be duplicated. Returns: A string with each character in the input string duplicated n times. Examples: >>> duplicate(\\"abc\\", 3) 'aaabbbccc' >>> duplicate(\\"xyz\\", 2) 'xxyyzz' >>> duplicate(\\"hello\\", 1) 'hello'","solution":"def duplicate(s, n): Returns a string where each character in s is duplicated exactly n times. return ''.join(char * n for char in s)"},{"question":"def canRearrangeToPalindrome(s: str) -> bool: Determine if the characters of string \`s\` can be rearranged to form a palindrome. >>> canRearrangeToPalindrome(\\"civic\\") == True >>> canRearrangeToPalindrome(\\"ivicc\\") == True >>> canRearrangeToPalindrome(\\"hello\\") == False >>> canRearrangeToPalindrome(\\"a\\") == True >>> canRearrangeToPalindrome(\\"aa\\") == True >>> canRearrangeToPalindrome(\\"ab\\") == False >>> canRearrangeToPalindrome(\\"aabb\\") == True >>> canRearrangeToPalindrome(\\"aabbc\\") == True >>> canRearrangeToPalindrome(\\"abcde\\") == False","solution":"from collections import Counter def canRearrangeToPalindrome(s: str) -> bool: Determine if the characters of string \`s\` can be rearranged to form a palindrome. Parameters: - s (str): Input string consisting of lowercase English letters. Returns: - bool: True if the string can be rearranged to form a palindrome, False otherwise. char_counts = Counter(s) odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def adjacent_sum(lst): Takes a list of integers and returns a new list where each integer is the sum of its adjacent elements in the original list. For the first and last elements, consider the missing neighbor as 0. >>> adjacent_sum([1, 2, 3, 4, 5]) == [3, 6, 9, 12, 9] >>> adjacent_sum([7, -2, 5, 10, -3]) == [5, 10, 13, 12, 7] # Implement your solution here.","solution":"def adjacent_sum(lst): Takes a list of integers and returns a new list where each integer is the sum of its adjacent elements in the original list. For the first and last elements, consider the missing neighbor as 0. if not lst: return [] n = len(lst) if n == 1: return [2 * lst[0]] result = [] for i in range(n): if i == 0: result.append(lst[i] + lst[i+1]) elif i == n-1: result.append(lst[i] + lst[i-1]) else: result.append(lst[i-1] + lst[i] + lst[i+1]) return result"},{"question":"from typing import List, Tuple def order_seats(n: int, edges: List[Tuple[int, int]]) -> int: Returns the minimum number of rows needed to seat \`n\` people in an auditorium based on the friendship constraints given as edges in an undirected graph. >>> order_seats(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> order_seats(4, [(1, 2), (3, 4)]) 2 >>> order_seats(6, [(1, 2), (2, 3), (4, 5), (5, 6)]) 2 >>> order_seats(1, []) 1 >>> order_seats(5, []) 5 >>> order_seats(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 1 >>> order_seats(6, [(1, 2), (2, 3), (4, 5)]) 3 >>> order_seats(4, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 1 pass","solution":"def order_seats(n, edges): Returns the minimum number of rows needed to seat \`n\` people in an auditorium based on the friendship constraints given as edges in an undirected graph. from collections import defaultdict, deque # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Function to perform BFS and mark all reachable nodes def bfs(start, visited): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) visited = [False] * (n + 1) component_count = 0 # Find all connected components for person in range(1, n + 1): if not visited[person]: component_count += 1 visited[person] = True bfs(person, visited) return component_count"},{"question":"def reverse_digits(nums): Takes a list of unique, non-negative integers and returns a new list with the digits of each integer reversed. Args: nums: list of int - a list of unique, non-negative integers. Returns: list of int - a new list with the digits of each integer reversed. >>> reverse_digits([123, 456, 789]) [321, 654, 987] >>> reverse_digits([103, 200, 305]) [301, 2, 503] >>> reverse_digits([500, 70, 80, 9]) [5, 7, 8, 9] >>> reverse_digits([]) []","solution":"def reverse_digits(nums): Takes a list of unique, non-negative integers and returns a new list with the digits of each integer reversed. Args: nums: list of int - a list of unique, non-negative integers. Returns: list of int - a new list with the digits of each integer reversed. def reverse_number(n): return int(str(n)[::-1]) return [reverse_number(num) for num in nums]"},{"question":"def longest_zero_sum_subarray(arr: List[int]) -> int: Given an array of integers, find the length of the longest subarray that has the sum of its elements equal to zero. >>> longest_zero_sum_subarray([15, -2, 2, -8, 1, 7, 10, 23]) 5 >>> longest_zero_sum_subarray([1, 2, 3]) 0 >>> longest_zero_sum_subarray([0]) 1 >>> longest_zero_sum_subarray([0, 0, 0, 0]) 4","solution":"def longest_zero_sum_subarray(arr): Returns the length of the longest subarray with a sum of zero. sum_index_map = {} max_len = 0 curr_sum = 0 for i in range(len(arr)): curr_sum += arr[i] if curr_sum == 0: max_len = i + 1 if curr_sum in sum_index_map: subarray_len = i - sum_index_map[curr_sum] max_len = max(max_len, subarray_len) else: sum_index_map[curr_sum] = i return max_len"},{"question":"def flattenArray(arr: list) -> list: Flatten a nested list. Args: arr (list): A list that may contain nested lists. Returns: list: A flattened list containing all the elements in arr. >>> flattenArray([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flattenArray([1, [], [2, [3]], 4]) [1, 2, 3, 4] >>> flattenArray([[1, 2], [3, 4, [5]]]) [1, 2, 3, 4, 5] >>> flattenArray([[], [], [[]]]) [] >>> flattenArray([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> flattenArray([1, 'a', [2, [3, 'b'], [4, 'c']], 5]) [1, 'a', 2, 3, 'b', 4, 'c', 5]","solution":"def flattenArray(arr): Flatten a nested list. Args: arr (list): A list that may contain nested lists. Returns: list: A flattened list containing all the elements in arr. result = [] def flatten(sub_arr): for item in sub_arr: if isinstance(item, list): flatten(item) else: result.append(item) flatten(arr) return result"},{"question":"def max_water_trapped(height: List[int]) -> int: Given a list of non-negative integers where each integer represents the height of a vertical line drawn on a coordinate plane, find the pair of lines that can trap the most water between them. Args: height (List[int]): A list of non-negative integers representing the heights. Returns: int: The maximum amount of water that can be trapped between any two lines. Example: >>> max_water_trapped([1,8,6,2,5,4,8,3,7]) 49","solution":"def max_water_trapped(height): Returns the maximum amount of water that can be trapped between any two lines left, right = 0, len(height) - 1 max_area = 0 while left < right: width = right - left h = min(height[left], height[right]) max_area = max(max_area, width * h) if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"from typing import List def most_popular_menu(votes: List[List[str]]) -> str: Determine the most frequently voted for menu item. >>> most_popular_menu([[\\"pizza\\", \\"burger\\"], [\\"burger\\", \\"taco\\"], [\\"pizza\\"]]) 'burger' >>> most_popular_menu([[\\"pizza\\"], [\\"burger\\"], [\\"sushi\\"], [\\"roll\\"], [\\"taco\\"]]) 'burger'","solution":"def most_popular_menu(votes): from collections import Counter # Create a flat list of all votes all_votes = [item for sublist in votes for item in sublist] # Count the frequency of each menu item vote_count = Counter(all_votes) # Find the most common vote count max_count = max(vote_count.values()) # Filter items that have the max count and return the alphabetically first one most_popular_items = [item for item, count in vote_count.items() if count == max_count] return min(most_popular_items)"},{"question":"def generate_pattern(N: int, S: str) -> List[str]: Generates a pattern based on the number of sections in the packaging and the string given. Parameters: - N (int): Number of sections - S (str): String of length N Returns: - List of strings representing the pattern. >>> generate_pattern(3, 'aba') ['a', 'ab', 'aba'] >>> generate_pattern(1, 'a') ['a'] >>> generate_pattern(4, 'aaaa') ['a', 'aa', 'aaa', 'aaaa'] >>> generate_pattern(5, 'bbbbb') ['b', 'bb', 'bbb', 'bbbb', 'bbbbb'] >>> generate_pattern(6, 'ababab') ['a', 'ab', 'aba', 'abab', 'ababa', 'ababab'] >>> generate_pattern(2, 'ab') ['a', 'ab'] >>> generate_pattern(4, 'abba') ['a', 'ab', 'abb', 'abba']","solution":"def generate_pattern(N, S): Generates a pattern based on the number of sections in the packaging and the string given. Parameters: - N (int): Number of sections - S (str): String of length N Returns: - List of strings representing the pattern. pattern = [] for i in range(1, N + 1): pattern.append(S[:i]) return pattern"},{"question":"def determine_winner(player1_scores, player2_scores): Determines the winner of a two-player dice game based on the average score. Parameters: player1_scores (list of int): List of dice throws for player 1. player2_scores (list of int): List of dice throws for player 2. Returns: str: A string indicating the winner (\\"Player 1 wins!\\", \\"Player 2 wins!\\" or \\"It's a draw!\\"). from solution import determine_winner def test_player1_wins(): assert determine_winner([6, 5, 6], [3, 4, 5]) == \\"Player 1 wins!\\" def test_player2_wins(): assert determine_winner([1, 2, 3], [4, 5, 6]) == \\"Player 2 wins!\\" def test_draw(): assert determine_winner([2, 3, 4], [4, 3, 2]) == \\"It's a draw!\\" assert determine_winner([1, 1, 1, 1], [1, 1, 1, 1]) == \\"It's a draw!\\" def test_single_element(): assert determine_winner([6], [5]) == \\"Player 1 wins!\\" assert determine_winner([3], [6]) == \\"Player 2 wins!\\" assert determine_winner([4], [4]) == \\"It's a draw!\\" def test_varied_counts(): assert determine_winner([1, 1, 1], [2, 2]) == \\"Player 2 wins!\\" assert determine_winner([3, 3], [2, 2, 2]) == \\"Player 1 wins!\\" def test_same_averages(): assert determine_winner([1, 3, 5], [2, 4, 3]) == \\"It's a draw!\\"","solution":"def determine_winner(player1_scores, player2_scores): Determines the winner of a two-player dice game based on the average score. Parameters: player1_scores (list of int): List of dice throws for player 1. player2_scores (list of int): List of dice throws for player 2. Returns: str: A string indicating the winner (\\"Player 1 wins!\\", \\"Player 2 wins!\\" or \\"It's a draw!\\"). player1_avg = sum(player1_scores) / len(player1_scores) player2_avg = sum(player2_scores) / len(player2_scores) if player1_avg > player2_avg: return \\"Player 1 wins!\\" elif player2_avg > player1_avg: return \\"Player 2 wins!\\" else: return \\"It's a draw!\\""},{"question":"def parse_expression(expression: str) -> float: Evaluates a mathematical expression in Reverse Polish Notation (RPN). Parameters: expression (str): A string containing a RPN expression. Returns: float or int: The evaluated result of the expression. >>> parse_expression(\\"3 4 +\\") 7 >>> parse_expression(\\"3 4 2 * +\\") 11 >>> parse_expression(\\"10 5 /\\") 2.0 >>> parse_expression(\\"5 1 2 + 4 * + 3 -\\") 14 >>> parse_expression(\\"42\\") 42 >>> parse_expression(\\"9 4 /\\") 2.25 >>> parse_expression(\\"5.5 2 * 7 / 3 +\\") 4.571428571428571","solution":"def parse_expression(expression): Evaluates a mathematical expression in Reverse Polish Notation (RPN). Parameters: expression (str): A string containing a RPN expression. Returns: float or int: The evaluated result of the expression. stack = [] tokens = expression.split() for token in tokens: if token in ['+', '-', '*', '/']: b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': result = a / b stack.append(result) else: stack.append(float(token) if '.' in token else int(token)) return stack[0]"},{"question":"def canBePalindrome(s: str) -> bool: Given a string \`s\`, check if it can be rearranged into a palindrome. Return \`True\` if it can, otherwise return \`False\`. A string is considered a palindrome if it reads the same backward as forward. >>> canBePalindrome(\\"carrace\\") True >>> canBePalindrome(\\"hello\\") False >>> canBePalindrome(\\"aabbcc\\") True >>> canBePalindrome(\\"abcde\\") False","solution":"def canBePalindrome(s): Checks if the given string can be rearranged into a palindrome. from collections import Counter count = Counter(s) # We can have at most one odd character for the string to be a palindrome odd_count = sum(1 for char, freq in count.items() if freq % 2 != 0) return odd_count <= 1"},{"question":"def shortest_path(graph: dict, start: str, end: str) -> int: Returns the length of the shortest simple path between start and end nodes. If no path exists, returns -1. >>> graph = { ... 'A': ['B', 'C'], ... 'B': ['A', 'D', 'E'], ... 'C': ['A', 'F'], ... 'D': ['B'], ... 'E': ['B', 'F'], ... 'F': ['C', 'E'] ... } >>> shortest_path(graph, 'A', 'F') 2 >>> graph = { ... 'A': ['B'], ... 'B': ['C'], ... 'C': ['A'] ... } >>> shortest_path(graph, 'A', 'C') 2 >>> graph = { ... 'A': ['B'], ... 'B': ['C'], ... 'C': [] ... } >>> shortest_path(graph, 'C', 'A') -1","solution":"from collections import deque def shortest_path(graph, start, end): Returns the length of the shortest simple path between start and end nodes. If no path exists, returns -1. if start == end: return 0 visited = set() queue = deque([(start, 0)]) while queue: current_node, current_distance = queue.popleft() if current_node not in visited: visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return current_distance + 1 if neighbor not in visited: queue.append((neighbor, current_distance + 1)) return -1"},{"question":"def is_palindrome(input_str: str) -> bool: Check if the given string is a palindrome. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"level\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"world\\") False >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"aba\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"ab\\") False >>> is_palindrome(\\"noon\\") True","solution":"def is_palindrome(input_str): Returns true if the input string is a palindrome, and false otherwise. return input_str == input_str[::-1]"},{"question":"from typing import List def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements from the list nums. :param nums: List of integers. :param k: Number of top frequent elements to return. :return: List of k most frequent elements sorted by their frequency. >>> top_k_frequent_elements([1,1,1,2,2,3], 2) [1, 2] >>> top_k_frequent_elements([1], 1) [1] from collections import Counter def test_single_element(): assert top_k_frequent_elements([1], 1) == [1] def test_multiple_elements(): assert top_k_frequent_elements([1,1,1,2,2,3], 2) == [1, 2] def test_more_than_k_elements(): assert top_k_frequent_elements([1,1,1,2,2,3,3,3,4,4,4,4], 3) == [4, 1, 3] def test_all_elements_same_frequency(): assert top_k_frequent_elements([1,2,3,4], 2) in [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] def test_k_equals_length_of_nums(): assert top_k_frequent_elements([1,2,3,4,5], 5) == [1, 2, 3, 4, 5]","solution":"from collections import Counter def top_k_frequent_elements(nums, k): Returns the k most frequent elements from the list nums. :param nums: List of integers. :param k: Number of top frequent elements to return. :return: List of k most frequent elements sorted by their frequency. # Count the frequency of each element in nums frequency_counter = Counter(nums) # Get the k most common elements most_common_elements = frequency_counter.most_common(k) # Extract the elements from the tuples returned by most_common return [element for element, count in most_common_elements]"},{"question":"def find_park_sequence(T: int, test_cases: List[int]) -> List[List[int]]: Find the sequence of parks visited by a visitor moving two steps ahead in a circular park list. Args: T (int): Number of test cases. test_cases (List[int]): A list containing the number of parks for each test case. Returns: List[List[int]]: A list of sequences, where each sequence represents the parks visited in order. Example: >>> find_park_sequence(3, [3, 5, 7]) [[0, 2, 1, 0], [0, 2, 4, 1, 3, 0], [0, 2, 4, 6, 1, 3, 5, 0]] >>> find_park_sequence(1, [6]) [[0, 2, 4, 0]]","solution":"def find_park_sequence(T, test_cases): results = [] for N in test_cases: sequence = [] current_park = 0 visited = set() while current_park not in visited: sequence.append(current_park) visited.add(current_park) current_park = (current_park + 2) % N sequence.append(0) # End with park 0 results.append(sequence) return results"},{"question":"def max_subarray_sum(arr): Implementing Kadane's Algorithm to find the maximum sum of a contiguous subarray. if not arr: return 0 max_current = max_global = arr[0] for number in arr[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current return max_global def solve(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): N = int(data[index]) index += 1 array = list(map(int, data[index:index + N])) index += N results.append(max_subarray_sum(array)) for result in results: print(result) Unit Tests def test_max_subarray_sum(): assert max_subarray_sum([-2, 1, -3, 4, -1]) == 4 assert max_subarray_sum([1, 2, 3, 4, 5, -10]) == 15 assert max_subarray_sum([-1, -2, -3, -4]) == -1 assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 assert max_subarray_sum([1]) == 1 assert max_subarray_sum([-1]) == -1 assert max_subarray_sum([-10, -2, -3, -4, -5]) == -2 assert max_subarray_sum([]) == 0 assert max_subarray_sum([1, 1, 1, 1, 1]) == 5 def test_solve(monkeypatch, capsys): input_data = \\"2n5n-2 1 -3 4 -1n6n1 2 3 4 5 -10n\\" monkeypatch.setattr('sys.stdin.read', lambda: input_data) solve() captured = capsys.readouterr() assert captured.out == \\"4n15n\\" input_data = \\"1n4n-1 -2 -3 -4n\\" monkeypatch.setattr('sys.stdin.read', lambda: input_data) solve() captured = capsys.readouterr() assert captured.out == \\"-1n\\"","solution":"def max_subarray_sum(arr): Implementing Kadane's Algorithm to find the maximum sum of a contiguous subarray. if not arr: return 0 max_current = max_global = arr[0] for number in arr[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current return max_global def solve(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): N = int(data[index]) index += 1 array = list(map(int, data[index:index + N])) index += N results.append(max_subarray_sum(array)) for result in results: print(result)"},{"question":"def trap(height: List[int]) -> int: Given a list of n non-negative integers representing the amount of water trapped in each unit-width block after a rainfall, compute how much water it could trap after raining. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(height): if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def schedule_event(device_schedule, device, event_time): Schedules a new event time for the specified device if possible. Parameters: - device_schedule (dict): A dictionary where keys are device names and values are lists of scheduled times in \\"HH:MM\\" 24-hour format. - device (str): The name of the device to schedule the event for. - event_time (str): The event time in \\"HH:MM\\" 24-hour format. Returns: - dict/str: The updated device schedule if the event is successfully added. Returns \\"Unable to schedule event\\" if the device already has 10 events, or if the time is invalid. Returns \\"Event already scheduled\\" if the event time is already scheduled. Examples: >>> schedule_event({\\"light\\": [\\"08:30\\", \\"12:00\\"]}, \\"light\\", \\"18:00\\") {\\"light\\": [\\"08:30\\", \\"12:00\\", \\"18:00\\"]} >>> schedule_event({\\"heater\\": [\\"06:30\\", \\"07:30\\", \\"08:30\\", \\"09:30\\", \\"10:30\\", \\"11:30\\", \\"12:30\\", \\"13:30\\", \\"14:30\\", \\"15:30\\"]}, \\"heater\\", \\"16:30\\") \\"Unable to schedule event\\" >>> schedule_event({\\"fan\\": [\\"08:30\\", \\"12:00\\"]}, \\"fan\\", \\"08:30\\") \\"Event already scheduled\\" >>> schedule_event({\\"fan\\": [\\"08:30\\", \\"12:00\\"]}, \\"fan\\", \\"25:30\\") \\"Unable to schedule event\\" >>> schedule_event({}, \\"fan\\", \\"08:30\\") {\\"fan\\": [\\"08:30\\"]}","solution":"def schedule_event(device_schedule, device, event_time): Schedules a new event time for the specified device if possible. Parameters: - device_schedule (dict): A dictionary where keys are device names and values are lists of scheduled times in \\"HH:MM\\" 24-hour format. - device (str): The name of the device to schedule the event for. - event_time (str): The event time in \\"HH:MM\\" 24-hour format. Returns: - dict/str: The updated device schedule if the event is successfully added. Returns \\"Unable to schedule event\\" if the device already has 10 events, or if the time is invalid. Returns \\"Event already scheduled\\" if the event time is already scheduled. # Validate event_time try: hour, minute = event_time.split(\\":\\") hour = int(hour) minute = int(minute) if hour < 0 or hour > 23 or minute < 0 or minute > 59: return \\"Unable to schedule event\\" except ValueError: return \\"Unable to schedule event\\" # Check if device already has 10 events scheduled if device in device_schedule: if len(device_schedule[device]) >= 10: return \\"Unable to schedule event\\" # Check if event_time is already scheduled if event_time in device_schedule[device]: return \\"Event already scheduled\\" # Add event_time to the device's schedule device_schedule[device].append(event_time) else: # Add new device with event_time device_schedule[device] = [event_time] return device_schedule"},{"question":"def find_duplicates(data_list): This function takes a list of integers and returns a new list containing the integers that appear at least twice in the input list, with each integer appearing only once in the result. The order of integers in the returned list is the same as their first occurrence in the input list. >>> find_duplicates([1, 3, 2, 1, 4, 3, 5, 3]) == [1, 3] >>> find_duplicates([1, 2, 3, 4, 5]) == [] >>> find_duplicates([1, 2, 2, 3, 4]) == [2] pass","solution":"def find_duplicates(data_list): This function takes a list of integers and returns a new list containing the integers that appear at least twice in the input list, with each integer appearing only once in the result. The order of integers in the returned list is the same as their first occurrence in the input list. seen = set() duplicates = set() result = [] for num in data_list: if num in seen: duplicates.add(num) else: seen.add(num) for num in data_list: if num in duplicates: if num not in result: result.append(num) return result"},{"question":"def shift_alphabet(s: str) -> str: Returns a string where each letter in the input string s is replaced by the next letter in the alphabet. If the letter is 'z', it wraps around to 'a'. >>> shift_alphabet(\\"abcdz\\") 'bcdea' >>> shift_alphabet(\\"xyz\\") 'yza' >>> shift_alphabet(\\"zaza\\") 'abzb'","solution":"def shift_alphabet(s): Returns a string where each letter in the input string s is replaced by the next letter in the alphabet. If the letter is 'z', it wraps around to 'a'. result = [] for char in s: if char == 'z': result.append('a') else: result.append(chr(ord(char) + 1)) return ''.join(result)"},{"question":"def find_zero_sum_subarray(arr): Finds a zero sum subarray and returns the indices of the first and last elements. If no such subarray is found, returns None. >>> find_zero_sum_subarray([1, 2, -3, 4, 5]) # -> (0, 2) >>> find_zero_sum_subarray([1, 2, 3, 4, 5]) # -> None >>> find_zero_sum_subarray([1, -1, 3, -3, 4, -4]) # -> (0, 1) >>> find_zero_sum_subarray([0, 1, 2, -2, -1]) # -> (3, 4)","solution":"def find_zero_sum_subarray(arr): Finds a zero sum subarray and returns the indices of the first and last elements. If no such subarray is found, returns None. prefix_sum = 0 sum_indices = {} for i in range(len(arr)): prefix_sum += arr[i] if prefix_sum == 0: return (0, i) if prefix_sum in sum_indices: return (sum_indices[prefix_sum] + 1, i) sum_indices[prefix_sum] = i return None"},{"question":"def merge_sorted_lists(T: int, test_cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[List[int]]: Merges two sorted lists for each test case into a single sorted list. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int], List[int]]]): A list of tuples, where each tuple contains: - a tuple of two integers, the sizes of the two lists, - a list of integers representing the first sorted list, - a list of integers representing the second sorted list. Returns: List[List[int]]: A list of lists, each containing the merged sorted list for the corresponding test case. Example: >>> merge_sorted_lists(2, [((3, 4), [1, 3, 5], [2, 4, 6, 8]), ((5, 3), [1, 2, 3, 4, 5], [6, 7, 8])]) [[1, 2, 3, 4, 5, 6, 8], [1, 2, 3, 4, 5, 6, 7, 8]]","solution":"def merge_sorted_lists(T, test_cases): Merges two sorted lists for each test case and returns the result as a list of lists. results = [] for case in test_cases: N, M = case[0] list1 = case[1] list2 = case[2] merged_list = [] i = j = 0 while i < N and j < M: if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < N: merged_list.append(list1[i]) i += 1 while j < M: merged_list.append(list2[j]) j += 1 results.append(merged_list) return results"},{"question":"def knapsack(nums: List[int], weights: List[int], limit: int) -> int: Return the maximum total value you can achieve without exceeding the weight limit. >>> knapsack([60, 100, 120], [10, 20, 30], 50) 220 >>> knapsack([10, 20, 30], [1, 1, 1], 2) 50 >>> knapsack([10], [5], 3) 0 pass # Test cases def test_knapsack(): assert knapsack([60, 100, 120], [10, 20, 30], 50) == 220 assert knapsack([10, 20, 30], [1, 1, 1], 2) == 50 assert knapsack([10], [5], 3) == 0 assert knapsack([50], [10], 10) == 50 assert knapsack([20, 30, 40], [1, 2, 3], 5) == 70 assert knapsack([], [], 10) == 0 assert knapsack([10, 20, 30], [1, 2, 3], 0) == 0 assert knapsack([1000, 2000, 3000], [100, 200, 300], 300) == 3000","solution":"def knapsack(nums, weights, limit): n = len(nums) # dp[i] will be the maximum value achievable with weight limit i dp = [0] * (limit + 1) for i in range(n): for w in range(limit, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + nums[i]) return dp[limit]"},{"question":"from typing import List from collections import Counter def is_anagram_substring(s1: str, s2: str) -> str: Determine if s2 is an anagram substring of s1. >>> is_anagram_substring(\\"aabb\\", \\"ab\\") \\"YES\\" >>> is_anagram_substring(\\"abc\\", \\"d\\") \\"NO\\" >>> is_anagram_substring(\\"abcdef\\", \\"fed\\") \\"YES\\" pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes T pairs of test cases to determine if s2 is an anagram substring of s1 and returns the result for each pair. >>> process_test_cases(3, [\\"aabb\\", \\"ab\\", \\"abc\\", \\"d\\", \\"abcdef\\", \\"fed\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass def test_is_anagram_substring_simple_cases(): assert is_anagram_substring(\\"aabb\\", \\"ab\\") == \\"YES\\" assert is_anagram_substring(\\"abc\\", \\"d\\") == \\"NO\\" assert is_anagram_substring(\\"abcdef\\", \\"fed\\") == \\"YES\\" def test_is_anagram_substring_edge_cases(): assert is_anagram_substring(\\"a\\", \\"a\\") == \\"YES\\" assert is_anagram_substring(\\"abc\\", \\"abcd\\") == \\"NO\\" assert is_anagram_substring(\\"aaa\\", \\"aa\\") == \\"YES\\" assert is_anagram_substring(\\"abcd\\", \\"aabcd\\") == \\"NO\\" def test_process_test_cases(): test_cases = [ (\\"aabb\\", \\"ab\\"), (\\"abc\\", \\"d\\"), (\\"abcdef\\", \\"fed\\") ] flat_test_cases = [item for sublist in test_cases for item in sublist] assert process_test_cases(3, flat_test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"from collections import Counter def is_anagram_substring(s1, s2): Determine if s2 is an anagram substring of s1. :param s1: First string. :param s2: Second string. :return: \\"YES\\" if s2 is an anagram substring of s1, otherwise \\"NO\\". len_s1 = len(s1) len_s2 = len(s2) if len_s2 > len_s1: return \\"NO\\" s2_counter = Counter(s2) window_counter = Counter(s1[:len_s2]) if window_counter == s2_counter: return \\"YES\\" for i in range(1, len_s1 - len_s2 + 1): window_counter[s1[i + len_s2 - 1]] += 1 window_counter[s1[i - 1]] -= 1 if window_counter[s1[i - 1]] == 0: del window_counter[s1[i - 1]] if window_counter == s2_counter: return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): s1 = test_cases[i*2] s2 = test_cases[i*2 + 1] results.append(is_anagram_substring(s1, s2)) return results"},{"question":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: Determine the starting and ending position of a given target value in a sorted array of integers nums. If target is not found in the array, return [-1, -1]. >>> search_range([5,7,7,8,8,10], 8) [3, 4] >>> search_range([5,7,7,8,8,10], 6) [-1, -1] >>> search_range([], 0) [-1, -1]","solution":"def search_range(nums, target): Returns the starting and ending position of a given target value in a sorted array of integers nums. If target is not found, returns [-1, -1]. def binary_search_left(nums, target): left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid return left def binary_search_right(nums, target): left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid return left start = binary_search_left(nums, target) end = binary_search_right(nums, target) - 1 if start <= end < len(nums) and nums[start] == target and nums[end] == target: return [start, end] else: return [-1, -1]"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Examples: >>> length_of_longest_substring('aaaa') 1 >>> length_of_longest_substring('abcdef') 6 >>> length_of_longest_substring('abcabcbb') 3 >>> length_of_longest_substring('pwwkew') 3 >>> length_of_longest_substring('dvdf') 3 >>> length_of_longest_substring('') 0 >>> length_of_longest_substring('anviaj') 5","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: Input string composed of lowercase English letters. :return: Length of the longest substring without repeating characters. char_index = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"def transform_to_palindrome(s: str) -> int: Determine if it's possible to make a given string into a palindrome by adding exactly one character. If possible, return the position to add the character to make the string a palindrome, if there are multiple positions, return the smallest index, otherwise return -1. >>> transform_to_palindrome(\\"abca\\") == 1 >>> transform_to_palindrome(\\"racecar\\") == 0 >>> transform_to_palindrome(\\"abcdef\\") == -1","solution":"def transform_to_palindrome(s: str) -> int: Determine the position to insert a character to make \`s\` a palindrome by adding exactly one character. :param s: The input string :return: The position to insert the character, or -1 if not possible def is_palindrome_range(s, left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True n = len(s) for i in range(n // 2): if s[i] != s[n - i - 1]: if is_palindrome_range(s, i + 1, n - i - 1): return i if is_palindrome_range(s, i, n - i - 2): return n - i - 1 return -1 return 0 if n % 2 == 1 else -1"},{"question":"def most_frequent_word(text: str) -> (str, int): Returns the most frequent word in the given text along with its frequency. If multiple words have the same highest frequency, the word that appears first alphabetically is returned. >>> most_frequent_word(\\"hello world hello\\") (\\"hello\\", 2) >>> most_frequent_word(\\"test test test go go\\") (\\"test\\", 3)","solution":"def most_frequent_word(text): Returns the most frequent word in the given text along with its frequency. If multiple words have the same highest frequency, the word that appears first alphabetically is returned. words = text.split() word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 max_frequency = max(word_count.values()) most_frequent_words = [word for word, count in word_count.items() if count == max_frequency] most_frequent_words.sort() return most_frequent_words[0], max_frequency"},{"question":"def coin_combinations(amount): Determines the number of unique ways to make the exact amount using pennies (1 cent), nickels (5 cents), dimes (10 cents), and quarters (25 cents). Parameters: amount (int): The amount in cents. Returns: int: Number of unique ways to make the specified amount. pass # Test cases def test_coin_combinations_case_1(): assert coin_combinations(5) == 2 # 5 pennies or 1 nickel def test_coin_combinations_case_2(): assert coin_combinations(10) == 4 # 10 pennies, 2 nickels, 1 nickel + 5 pennies, 1 dime def test_coin_combinations_case_3(): assert coin_combinations(15) == 6 # 15 pennies, 3 nickels, 1 dime + 5 pennies, etc. def test_coin_combinations_case_4(): assert coin_combinations(25) == 13 # Various combinations using 25 pennies, 1 quarter, etc. def test_coin_combinations_large_amount(): assert coin_combinations(100) == 242 # Example of a larger case def test_edge_case_1_cent(): assert coin_combinations(1) == 1 # Only 1 penny","solution":"def coin_combinations(amount): Determines the number of unique ways to make the exact amount using pennies (1 cent), nickels (5 cents), dimes (10 cents), and quarters (25 cents). Parameters: amount (int): The amount in cents. Returns: int: Number of unique ways to make the specified amount. # List of coin values coins = [1, 5, 10, 25] # Initialize a list to store the number of ways to make each amount from 0 to \`amount\` dp = [0] * (amount + 1) # There is one way to make 0 amount: use no coins dp[0] = 1 # Loop through each coin for coin in coins: # Update the dp array for each amount >= coin for x in range(coin, amount + 1): dp[x] += dp[x - coin] # The value at dp[amount] is the number of ways to make the specified amount return dp[amount]"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\" \\") 1 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 >>> length_of_longest_substring(\\"tmmzuxt\\") 5 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"abba\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index = {} max_length = 0 start = 0 # Start index of current window for end in range(n): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def alice_bob_game(arr): Alice and Bob are playing a game where they take turns to pick numbers from a list and add them to their scores. Alice always starts first. Each player can pick a number only from the end of the list (either the leftmost or the rightmost number). The game ends when there are no more numbers left to pick, at which point the player with the higher score wins. Both Alice and Bob follow an optimal strategy to maximize their score. Your task is to determine the final scores of both players and declare the winner. >>> alice_bob_game([4, 5]) (5, 4, 'Alice') >>> alice_bob_game([1, 2, 3, 4]) (6, 4, 'Alice') # Implement the function def process_input(input_str): Processes the input string and returns the test cases. def main(input_str): Main function to process the input and return the results. test_cases = process_input(input_str) results = [] for arr in test_cases: alice_score, bob_score, winner = alice_bob_game(arr) results.append(f\\"{alice_score} {bob_score} {winner}\\") return \\"n\\".join(results) def test_alice_bob_game_case1(): input_str = \\"2n4 5n0\\" expected_output = \\"5 4 Alice\\" assert main(input_str).strip() == expected_output def test_alice_bob_game_case2(): input_str = \\"4n1 2 3 4n0\\" expected_output = \\"6 4 Alice\\" assert main(input_str).strip() == expected_output def test_alice_bob_game_case3(): input_str = \\"3n7 5 2n0\\" expected_output = \\"9 5 Alice\\" assert main(input_str).strip() == expected_output def test_alice_bob_game_case4(): input_str = \\"3n2 2 2n0\\" expected_output = \\"4 2 Alice\\" assert main(input_str).strip() == expected_output def test_alice_bob_game_edge_case(): input_str = \\"1n1n0\\" expected_output = \\"1 0 Alice\\" assert main(input_str).strip() == expected_output","solution":"def alice_bob_game(arr): alice_score, bob_score = 0, 0 turn = True left = 0 right = len(arr) - 1 while left <= right: if arr[left] > arr[right]: chosen = arr[left] left += 1 else: chosen = arr[right] right -= 1 if turn: # Alice's turn alice_score += chosen else: # Bob's turn bob_score += chosen turn = not turn winner = \\"Alice\\" if alice_score > bob_score else \\"Bob\\" return alice_score, bob_score, winner def process_input(input_str): input_lines = input_str.strip().split(\\"n\\") test_cases = [] i = 0 while i < len(input_lines): N = int(input_lines[i]) if N == 0: break array = list(map(int, input_lines[i + 1].strip().split())) test_cases.append(array) i += 2 return test_cases def main(input_str): test_cases = process_input(input_str) results = [] for arr in test_cases: alice_score, bob_score, winner = alice_bob_game(arr) results.append(f\\"{alice_score} {bob_score} {winner}\\") return \\"n\\".join(results) # Example usage: input_str = \\"2n4 5n4n1 2 3 4n0\\" output_str = main(input_str) print(output_str)"},{"question":"from typing import List def buildings_with_view(heights: List[int]) -> int: Returns the number of buildings that have a view of the horizon. >>> buildings_with_view([4, 3, 2, 1]) 4 >>> buildings_with_view([1, 2, 3, 4]) 1 >>> buildings_with_view([4, 3, 2, 3]) 2 >>> buildings_with_view([]) 0 >>> buildings_with_view([10]) 1 >>> buildings_with_view([3, 3, 3, 3]) 1 >>> buildings_with_view([1, 3, 2, 4, 2]) 2","solution":"def buildings_with_view(heights): Returns the number of buildings that have a view of the horizon. n = len(heights) if n == 0: return 0 max_height = heights[-1] view_count = 1 for i in range(n-2, -1, -1): if heights[i] > max_height: view_count += 1 max_height = heights[i] return view_count"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Given a list of words, group the words that are anagrams of each other. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Return the list of groups of anagrams in any order. :param words: List of words :return: List of groups of anagrams >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_anagrams([\\"word\\"]) [['word']] >>> group_anagrams([]) [] >>> group_anagrams([\\"bob\\", \\"bob\\", \\"bob\\"]) [['bob', 'bob', 'bob']]","solution":"from collections import defaultdict def group_anagrams(words): Groups words that are anagrams of each other. :param words: List of words :return: List of groups of anagrams anagrams = defaultdict(list) for word in words: # Use sorted tuple of the word as the key key = tuple(sorted(word)) anagrams[key].append(word) # Return the values of the dictionary as a list return list(anagrams.values())"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring that contains at most k distinct characters. >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aa\\", 1) 2","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. :param s: input string :param k: number of distinct characters allowed in the substring :return: length of the longest such substring if k == 0 or not s: return 0 n = len(s) left = 0 right = 0 char_count = {} max_len = 0 while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def employeeAvailability(slots): Takes in an array of strings representing your availability times for a week, and returns an object with the days of the week as keys, and an array of available time slots as values for each corresponding day. >>> employeeAvailability([\\"Monday 09:00_AM - 05:00_PM\\", \\"Wednesday 01:00_PM - 06:00_PM\\", \\"Friday 09:00_AM - 12:00_PM\\"]) { \\"Monday\\": [\\"09:00_AM - 05:00_PM\\"], \\"Tuesday\\": [], \\"Wednesday\\": [\\"01:00_PM - 06:00_PM\\"], \\"Thursday\\": [], \\"Friday\\": [\\"09:00_AM - 12:00_PM\\"], \\"Saturday\\": [], \\"Sunday\\": [] } >>> employeeAvailability([\\"Saturday 02:00_PM - 04:00_PM\\", \\"Sunday 10:00_AM - 01:00_PM\\"]) { \\"Monday\\": [], \\"Tuesday\\": [], \\"Wednesday\\": [], \\"Thursday\\": [], \\"Friday\\": [], \\"Saturday\\": [\\"02:00_PM - 04:00_PM\\"], \\"Sunday\\": [\\"10:00_AM - 01:00_PM\\"] } >>> employeeAvailability([]) { \\"Monday\\": [], \\"Tuesday\\": [], \\"Wednesday\\": [], \\"Thursday\\": [], \\"Friday\\": [], \\"Saturday\\": [], \\"Sunday\\": [] }","solution":"def employeeAvailability(slots): days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] availability = {day: [] for day in days_of_week} for slot in slots: day, time = slot.split(' ', 1) if day in availability: availability[day].append(time) return availability"},{"question":"def maximalSquare(matrix: List[List[str]]) -> int: Given a matrix of size m x n, find the largest square containing only '1's and return its area. >>> maximalSquare([ ... ['1', '0', '1', '0', '0'], ... ['1', '0', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '0', '0', '1', '0'] ... ]) == 4 >>> maximalSquare([['1']]) == 1 >>> maximalSquare([['0']]) == 0","solution":"def maximalSquare(matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i-1][j-1] == '1': dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def highestTripletProduct(arr): Returns the highest product of any triplet in the array. >>> highestTripletProduct([1, 2, 3, 4, 5]) == 60 >>> highestTripletProduct([-10, -10, 5, 2, 3]) == 500 >>> highestTripletProduct([-10, -10, -5, -2, -3]) == -30 >>> highestTripletProduct([-10, 1, 2, 3, 4, 5]) == 60 >>> highestTripletProduct([-10, -10, 1]) == 100 >>> highestTripletProduct([x for x in range(-1000, 1001)]) == 999000000 >>> highestTripletProduct([-1, 0, 0, 2, 3]) == 0 >>> highestTripletProduct([0, 0, 0, 0, 0]) == 0","solution":"def highestTripletProduct(arr): Returns the highest product of any triplet in the array. arr.sort() n = len(arr) return max(arr[0] * arr[1] * arr[n-1], arr[n-3] * arr[n-2] * arr[n-1])"},{"question":"def find_pairs(arr: List[int], k: int) -> List[Tuple[int, int]]: Given an array of integers and a number \`k\`, returns all unique pairs of integers in the array whose sum is equal to \`k\`. Each pair should be returned as a tuple \`(a, b)\`, where \`a <= b\`. The list of pairs should be sorted in ascending order by the first element of the tuple and then by the second element. >>> find_pairs([1, 5, 7, -1, 5], 6) [(-1, 7), (1, 5)] >>> find_pairs([1, 5, 7, -1, 5], 10) [(5, 5)] >>> find_pairs([1, 1, 1, 1], 2) [(1, 1)] >>> find_pairs([1, 3, 2, 2], 4) [(1, 3), (2, 2)]","solution":"def find_pairs(arr, k): Returns all unique pairs of integers in the array whose sum is equal to k, sorted in ascending order by the first element of the tuple and then by the second element. seen = set() pairs = set() for num in arr: target = k - num if target in seen: pairs.add((min(num, target), max(num, target))) seen.add(num) return sorted(pairs)"},{"question":"def is_valid_expression(expr: str) -> bool: Determines if a given string is a valid representation of an arithmetic expression. >>> is_valid_expression(\\"\\") False >>> is_valid_expression(\\"3+(4*5)-7\\") True >>> is_valid_expression(\\"10/2+(3*2)\\") True >>> is_valid_expression(\\"(1+(2*3)-4)/5\\") True >>> is_valid_expression(\\"3+(4*5))-7\\") False >>> is_valid_expression(\\"10//2+(3*2)\\") False >>> is_valid_expression(\\"(1+(2*3)-)/5\\") False >>> is_valid_expression(\\"***\\") False >>> is_valid_expression(\\"3+((4*5)-7\\") False >>> is_valid_expression(\\"+3+(4*5)\\") False >>> is_valid_expression(\\"3+abc-2\\") False","solution":"def is_valid_expression(expr: str) -> bool: Determines if a given string is a valid representation of an arithmetic expression. if not expr: return False valid_chars = set(\\"0123456789+-*/() \\") for char in expr: if char not in valid_chars: return False def is_operator(c): return c in '+-*/' def is_operand(c): return c.isdigit() balance = 0 prev_char = '' for i, char in enumerate(expr): if char == '(': balance += 1 elif char == ')': balance -= 1 if balance < 0: return False if i > 0 and is_operator(prev_char): return False elif is_operator(char): if prev_char == '' or is_operator(prev_char) or prev_char == '(' or i == len(expr) - 1: return False elif char.isdigit(): if prev_char == ')': return False prev_char = char if balance != 0: return False return not (is_operator(expr[0]) or is_operator(expr[-1]))"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Returns a new list with duplicates removed and order preserved. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([4, 4, 4, 3, 2, 1]) == [4, 3, 2, 1] >>> remove_duplicates([5, 1, 5, 3, 7, 3, 1]) == [5, 1, 3, 7] >>> remove_duplicates([10, 20, 10, 30, 20]) == [10, 20, 30] >>> remove_duplicates([]) == []","solution":"def remove_duplicates(lst): Returns a new list with duplicates removed and order preserved. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def is_path_possible(grid: List[List[str]], R: int, C: int) -> str: Determine if there is a path from the top-left cell to the bottom-right cell in a 2D grid. The player can only move right or down and cannot move through obstacles ('#'). Args: grid (List[List[str]]): The grid representation of the game. R (int): Number of rows. C (int): Number of columns. Returns: str: \\"YES\\" if there is a path, \\"NO\\" otherwise. >>> is_path_possible([\\"...\\", \\".#.\\", \\"...\\"], 3, 3) 'YES' >>> is_path_possible([\\"..#\\", \\".#.\\", \\".#.\\"], 3, 3) 'NO' def solve_all_test_cases(test_cases: List[Tuple[List[List[str]], int, int]]) -> List[str]: Solve multiple test cases for the pathfinding problem. Args: test_cases (List of tuples): List of test cases where each test case is a tuple (grid, R, C). Returns: List[str]: List of results for each test case. >>> solve_all_test_cases([([\\"...\\", \\".#.\\", \\"...\\"], 3, 3), ([\\"..#\\", \\".#.\\", \\".#.\\"], 3, 3)]) ['YES', 'NO'] def parse_input(input_data: str) -> List[Tuple[List[List[str]], int, int]]: Parse the provided input data into the required format. Args: input_data (str): The raw string input containing multiple test cases. Returns: List[Tuple[List[List[str]], int, int]]: Parsed test cases. >>> parse_input(\\"2n3 3n...n.#.n...n3 3n..#n.#.n.#.\\") [([\\"...\\", \\".#.\\", \\"...\\"], 3, 3), ([\\"..#\\", \\".#.\\", \\".#.\\"], 3, 3)] def main(input_data: str): Main function to handle input and output for the pathfinding problem. Args: input_data (str): The raw string input containing multiple test cases. >>> main(\\"2n3 3n...n.#.n...n3 3n..#n.#.n.#.\\") YES NO","solution":"def is_path_possible(grid, R, C): def dfs(row, col, visited): if row == R - 1 and col == C - 1: return True if row < 0 or row >= R or col < 0 or col >= C or grid[row][col] == '#' or visited[row][col]: return False visited[row][col] = True if dfs(row + 1, col, visited) or dfs(row, col + 1, visited): return True visited[row][col] = False return False visited = [[False for _ in range(C)] for _ in range(R)] return \\"YES\\" if dfs(0, 0, visited) else \\"NO\\" def solve_all_test_cases(test_cases): results = [] for grid, R, C in test_cases: results.append(is_path_possible(grid, R, C)) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(T): R, C = map(int, lines[index].strip().split()) grid = [lines[index + 1 + i].strip() for i in range(R)] test_cases.append((grid, R, C)) index += R + 1 return test_cases def main(input_data): test_cases = parse_input(input_data) results = solve_all_test_cases(test_cases) for result in results: print(result)"},{"question":"def closest_sum(nums, target): Finds a pair of integers in the array nums whose sum is closest to the target. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: list of int: The pair of integers whose sum is closest to the target. pass from solution import closest_sum def test_example_case(): assert closest_sum([10, 22, 28, 29, 30, 40], 54) == [22, 30] def test_case_with_multiple_closest_pairs(): assert closest_sum([1, 2, 3, 4, 5, 6], 10) == [4, 6] def test_small_array(): assert closest_sum([1, 2], 3) == [1, 2] def test_negative_numbers(): assert closest_sum([-1, -2, 3, 4, 5, 6], 1) == [-2, 3] assert closest_sum([-5, -4, -2, -1], -6) == [-5, -1] def test_no_valid_pair(): assert closest_sum([1], 3) == [] def test_case_closest_sum_smallest(): assert closest_sum([1, 3, 4, 7, 10], 15) == [4, 10] assert closest_sum([10, 22, 28, 30], 30) == [10, 22]","solution":"def closest_sum(nums, target): Finds a pair of integers in the array nums whose sum is closest to the target. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: list of int: The pair of integers whose sum is closest to the target. nums.sort() closest_pair = [] closest_diff = float('inf') left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_pair = [nums[left], nums[right]] if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return [nums[left], nums[right]] return closest_pair"},{"question":"def get_index(position: str) -> int: This function takes a string with the format 'Item N in the list' and returns the corresponding 0-based index as an integer. Args: position (str): The string describing the item position. Returns: int: The 0-based index of the item. Examples: >>> get_index(\\"Item 1 in the list\\") == 0 >>> get_index(\\"Item 4 in the list\\") == 3 >>> get_index(\\"Item 10 in the list\\") == 9","solution":"def get_index(position: str) -> int: This function takes a string with the format 'Item N in the list' and returns the corresponding 0-based index. Args: position (str): The string describing the item position. Returns: int: The 0-based index of the item. # Extracting the number N from the string start = position.find(' ') + 1 end = position.find(' in the list') # Convert the extracted part to an integer and subtract 1 to get 0-based index index = int(position[start:end]) - 1 return index"},{"question":"from typing import List, Dict, Any def build_directory_tree(paths: List[str]) -> Dict[str, Any]: Convert a list of file paths to a nested dictionary representing the directory tree. >>> build_directory_tree([\\"file.txt\\"]) == {\\"file.txt\\": {}} >>> build_directory_tree([\\"folder/file.txt\\"]) == {\\"folder\\": {\\"file.txt\\": {}}} >>> build_directory_tree([\\"folder/file1.txt\\", \\"folder/file2.txt\\"]) == {\\"folder\\": {\\"file1.txt\\": {}, \\"file2.txt\\": {}}} >>> build_directory_tree([ ... \\"folder1/folder2/file1.txt\\", ... \\"folder1/folder2/file2.txt\\", ... \\"folder1/folder3/file3.txt\\", ... \\"folder2/file4.txt\\" ... ]) == { ... \\"folder1\\": { ... \\"folder2\\": { ... \\"file1.txt\\": {}, ... \\"file2.txt\\": {} ... }, ... \\"folder3\\": { ... \\"file3.txt\\": {} ... } ... }, ... \\"folder2\\": { ... \\"file4.txt\\": {} ... } ... } >>> build_directory_tree([ ... \\"root/branch1/leaf1.txt\\", ... \\"root/branch1/leaf2.txt\\", ... \\"root/branch2/leaf3.txt\\", ... \\"root/branch2/subbranch/leaf4.txt\\", ... \\"root2/leaf5.txt\\" ... ]) == { ... \\"root\\": { ... \\"branch1\\": { ... \\"leaf1.txt\\": {}, ... \\"leaf2.txt\\": {} ... }, ... \\"branch2\\": { ... \\"leaf3.txt\\": {}, ... \\"subbranch\\": { ... \\"leaf4.txt\\": {} ... } ... } ... }, ... \\"root2\\": { ... \\"leaf5.txt\\": {} ... } ... }","solution":"from typing import List, Dict, Any def build_directory_tree(paths: List[str]) -> Dict[str, Any]: def insert_path(tree: Dict[str, Any], parts: List[str]) -> None: if not parts: return head, *tail = parts if head not in tree: tree[head] = {} insert_path(tree[head], tail) directory_tree = {} for path in paths: parts = path.split('/') insert_path(directory_tree, parts) return directory_tree"},{"question":"from typing import List, Tuple def shortest_travel_times(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], int]]) -> List[List[int]]: Determine the shortest travel time from the starting town to every other town. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int, int]], int]]): A list of test cases, each containing: - The number of towns (N) - The number of roads (M) - A list of M tuples, each containing: (U, V, W), a one-way road from town U to town V with travel time W - The starting town (S) Returns: List[List[int]]: A list of results, each containing N space-separated integers representing the shortest travel times from the starting town to each of the N towns. If a town is unreachable, \\"-1\\" is indicated. Example: >>> test_cases = [ ... (4, 4, [(1, 2, 4), (1, 3, 2), (2, 4, 1), (3, 4, 5)], 1), ... (4, 2, [(2, 3, 2), (3, 4, 3)], 2) ... ] >>> shortest_travel_times(test_cases) [[0, 4, 2, 5], [-1, 0, 2, 5]] results = [] # Your implementation starts here return results def test_single_case(): test_cases = [ (4, 4, [(1, 2, 4), (1, 3, 2), (2, 4, 1), (3, 4, 5)], 1) ] expected = [ [0, 4, 2, 5] ] assert shortest_travel_times(test_cases) == expected def test_unreachable_town(): test_cases = [ (4, 2, [(1, 2, 4), (1, 3, 2)], 1) ] expected = [ [0, 4, 2, -1] ] assert shortest_travel_times(test_cases) == expected def test_multiple_cases(): test_cases = [ (4, 4, [(1, 2, 4), (1, 3, 2), (2, 4, 1), (3, 4, 5)], 1), (4, 2, [(2, 3, 2), (3, 4, 3)], 2) ] expected = [ [0, 4, 2, 5], [-1, 0, 2, 5] ] assert shortest_travel_times(test_cases) == expected def test_no_edges(): test_cases = [ (4, 0, [], 1) ] expected = [ [0, -1, -1, -1] ] assert shortest_travel_times(test_cases) == expected def test_edge_case_small_graph(): test_cases = [ (2, 1, [(1, 2, 1)], 1) ] expected = [ [0, 1] ] assert shortest_travel_times(test_cases) == expected def test_edge_case_large_graph(): test_cases = [ (1000, 1, [(1, 2, 1)], 1) ] expected = [ [0] + [1] + [-1]*998 ] assert shortest_travel_times(test_cases) == expected","solution":"import heapq def dijkstra(n, graph, start): # Initialize distances with infinity distances = [float('inf')] * (n + 1) distances[start] = 0 # Priority queue, storing (distance, node) pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) # If the distance is not optimal, skip it if current_distance > distances[current_node]: continue # Explore neighbours and update distances for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return [-1 if distances[i] == float('inf') else distances[i] for i in range(1, n + 1)] def shortest_travel_times(test_cases): results = [] for num_towns, roads, edges, start in test_cases: graph = [[] for _ in range(num_towns + 1)] for u, v, w in edges: graph[u].append((v, w)) results.append(dijkstra(num_towns, graph, start)) return results"},{"question":"from typing import List def is_prime(num: int) -> bool: Returns True if num is a prime number, else False. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(11) == True >>> is_prime(15) == False >>> is_prime(1) == False def prime_triangle(n: int) -> str: Returns a pattern of prime numbers up to \`n\` rows. >>> prime_triangle(0) == \\"\\" >>> prime_triangle(-5) == \\"\\" >>> prime_triangle(1) == \\"2\\" >>> prime_triangle(6) == \\"2n3n5n7n11n13\\" >>> prime_triangle(3) == \\"2n3n5\\"","solution":"def is_prime(num): Returns True if num is a prime number, else False. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def prime_triangle(n): Returns a pattern of prime numbers up to \`n\` rows. if n <= 0: return \\"\\" prime_numbers = [] num = 2 while len(prime_numbers) < n: if is_prime(num): prime_numbers.append(str(num)) num += 1 return \\"n\\".join(prime_numbers)"},{"question":"from typing import List, Tuple def max_parks_visited(N: int, M: int, P: int, roads: List[Tuple[int, int]]) -> int: Returns the maximum number of parks that can be visited starting from park P. Args: N : int : Number of parks M : int : Number of roads P : int : Starting park number roads : List[Tuple[int, int]] : List of roads where each road is represented by a tuple (U, V) Returns: int : Maximum number of parks that can be visited starting from park P >>> max_parks_visited(5, 6, 1, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 5)]) 5 >>> max_parks_visited(2, 1, 1, [(1, 2)]) 2 >>> max_parks_visited(4, 2, 1, [(1, 2), (3, 4)]) 2 >>> max_parks_visited(6, 7, 1, [(1, 2), (1, 3), (2, 4), (3, 4), (2, 5), (4, 6), (5, 6)]) 6 >>> max_parks_visited(10, 9, 1, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]) 10","solution":"from collections import deque, defaultdict def max_parks_visited(N, M, P, roads): Returns the maximum number of parks that can be visited starting from park P. graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) def bfs(start): visited = set() queue = deque([start]) visited.add(start) while queue: park = queue.popleft() for neighbor in graph[park]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return len(visited) return bfs(P) # Example usage N = 5 M = 6 P = 1 roads = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 5)] print(max_parks_visited(N, M, P, roads))"},{"question":"def unique_in_order(lst: List[int]) -> List[int]: Returns a list of distinct integers while maintaining their original order of appearance. Args: lst (list): List of integers. Returns: list: List of distinct integers in their original order. >>> unique_in_order([1, 2, 2, 3, 2, 1]) == [1, 2, 3] >>> unique_in_order([5, 5, 4, 4, 4, 5]) == [5, 4]","solution":"def unique_in_order(lst): Returns a list of distinct integers while maintaining their original order of appearance. Args: lst (list): List of integers. Returns: list: List of distinct integers in their original order. seen = set() unique_list = [] for item in lst: if item not in seen: seen.add(item) unique_list.append(item) return unique_list"},{"question":"def is_valid_snake_pattern(pattern: list) -> bool: Return True if the list of integers follows a snake pattern, False otherwise. A \\"snake pattern\\" is defined as a sequence of integers that alternately increases and decreases in value by exactly 1. Args: pattern (list): List of integers representing the sequence. Returns: bool: True if the sequence follows the snake pattern, False otherwise. Examples: >>> is_valid_snake_pattern([1, 2, 1, 2, 1]) True >>> is_valid_snake_pattern([3, 4, 5, 4, 3]) False >>> is_valid_snake_pattern([10, 11, 10, 9, 10]) False >>> is_valid_snake_pattern([5]) True","solution":"def is_valid_snake_pattern(pattern): Return True if the list of integers follows a snake pattern, False otherwise. A \\"snake pattern\\" is defined as a sequence of integers that alternately increases and decreases in value by exactly 1. Args: pattern (list): List of integers representing the sequence. Returns: bool: True if the sequence follows the snake pattern, False otherwise. if len(pattern) <= 1: return True for i in range(1, len(pattern)): diff = pattern[i] - pattern[i-1] if i % 2 == 1: # Odd index: number should increase by 1 if diff != 1: return False else: # Even index: number should decrease by 1 if diff != -1: return False return True"},{"question":"def find_in_matrix(matrix: List[List[int]], target: int) -> Union[Tuple[int, int], int]: Find the target number in the matrix and return its position as a tuple (row, col). If not found, return -1. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> find_in_matrix(matrix, 16) == (2, 3) >>> find_in_matrix(matrix, 20) == -1","solution":"def find_in_matrix(matrix, target): Finds the target number in the matrix and returns its position as a tuple (row, col). If not found, returns -1. n = len(matrix) if n == 0: return -1 for row in range(n): for col in range(n): if matrix[row][col] == target: return (row, col) return -1"},{"question":"from typing import List def intToRoman(num: int) -> str: Convert an integer to a Roman numeral. Parameters: num (int): The integer to convert (1 <= num <= 3999). Returns: str: The Roman numeral representation of the integer. Examples: >>> intToRoman(3) 'III' >>> intToRoman(58) 'LVIII' >>> intToRoman(1994) 'MCMXCIV'","solution":"def intToRoman(num: int) -> str: Convert an integer to a Roman numeral. Parameters: num (int): The integer to convert (1 <= num <= 3999). Returns: str: The Roman numeral representation of the integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \\"\\" i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"def manhattan_distance(point1: tuple, point2: tuple) -> int: Returns the Manhattan Distance between two points. Parameters: point1 (tuple): A tuple representing the coordinates of the first point (x1, y1). point2 (tuple): A tuple representing the coordinates of the second point (x2, y2). Returns: int: The Manhattan Distance between the two points. >>> manhattan_distance((1, 2), (4, 6)) 7 >>> manhattan_distance((1, 1), (1, 1)) 0 >>> manhattan_distance((0, 0), (3, 4)) 7 >>> manhattan_distance((-1, -2), (-4, -6)) 7 >>> manhattan_distance((2, 3), (-2, -3)) 10 import pytest def test_manhattan_distance_basic(): assert manhattan_distance((1, 2), (4, 6)) == 7 assert manhattan_distance((1, 1), (1, 1)) == 0 assert manhattan_distance((0, 0), (3, 4)) == 7 assert manhattan_distance((-1, -2), (-4, -6)) == 7 assert manhattan_distance((2, 3), (-2, -3)) == 10 def test_manhattan_distance_edge_cases(): assert manhattan_distance((0, 0), (0, 0)) == 0 assert manhattan_distance((10**6, 10**6), (-10**6, -10**6)) == 4 * 10**6 assert manhattan_distance((-10**6, -10**6), (10**6, 10**6)) == 4 * 10**6 def test_manhattan_distance_large_coordinates(): assert manhattan_distance((500000, 500000), (-500000, -500000)) == 2000000 assert manhattan_distance((10**6, -10**6), (-10**6, 10**6)) == 4 * 10**6 assert manhattan_distance((-10**6, 10**6), (10**6, -10**6)) == 4 * 10**6","solution":"def manhattan_distance(point1: tuple, point2: tuple) -> int: Returns the Manhattan Distance between two points. Parameters: point1 (tuple): A tuple representing the coordinates of the first point (x1, y1). point2 (tuple): A tuple representing the coordinates of the second point (x2, y2). Returns: int: The Manhattan Distance between the two points. return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])"},{"question":"def arrange_soldiers(T: int, test_cases: List[Tuple[int, int]]) -> List[List[int]]: Chef Bob is in charge of arranging a line of soldiers for an upcoming parade at the Institute of Soldiers Technology. He has N soldiers, each with a given rank represented by a unique integer from 1 to N. Chef Bob wants to arrange them in such a way that each soldier is followed by either a soldier with a higher rank or by no soldier at all, and this pattern should repeat M times. Args: T: Number of test cases. test_cases: A list of tuples where each tuple contains 2 space-separated integers N and M. Returns: For each test case, returns a list of N integers representing the ranks of soldiers in one possible order that satisfies the condition. >>> arrange_soldiers(1, [(6, 2)]) [[2, 1, 4, 3, 5, 6]] >>> arrange_soldiers(2, [(6, 2), (5, 1)]) [[2, 1, 4, 3, 5, 6], [2, 1, 3, 4, 5]] >>> arrange_soldiers(1, [(6, 0)]) [[1, 2, 3, 4, 5, 6]] >>> arrange_soldiers(1, [(2, 1)]) [[2, 1]] >>> arrange_soldiers(2, [(4, 0), (4, 3)]) [[1, 2, 3, 4], [2, 1, 4, 3]]","solution":"def arrange_soldiers(T, test_cases): results = [] for N, M in test_cases: soldiers = list(range(1, N + 1)) for i in range(0, 2 * M, 2): if i + 1 < N: soldiers[i], soldiers[i + 1] = soldiers[i + 1], soldiers[i] results.append(soldiers) return results"},{"question":"def min_operations_to_equalize(heights: List[int]) -> int: Returns the minimum number of operations required to make all the heights equal. >>> min_operations_to_equalize([1, 5, 9]) == 8 >>> min_operations_to_equalize([4, 7, 4, 3]) == 4 >>> min_operations_to_equalize([10, 10, 10]) == 0","solution":"def min_operations_to_equalize(heights): Returns the minimum number of operations required to make all the heights equal. median = sorted(heights)[len(heights) // 2] return sum(abs(h - median) for h in heights)"},{"question":"def validate_jwt(token, current_time, role): Validates JWT for expiration and role presence. Args: token (dict): The JWT payload. current_time (int): The current Unix timestamp. role (str): The role to validate against the token's roles. Returns: str: The validation result as a message. >>> token = { ... \\"user_id\\": \\"user123\\", ... \\"roles\\": [\\"admin\\", \\"editor\\"], ... \\"exp\\": 1672531199 ... } >>> validate_jwt(token, 1672531200, \\"admin\\") \\"Token expired\\" >>> validate_jwt(token, 1672531100, \\"admin\\") \\"Role admin is present\\" >>> validate_jwt(token, 1672531100, \\"viewer\\") \\"Role viewer is not present\\"","solution":"def validate_jwt(token, current_time, role): Validates JWT for expiration and role presence. Args: token (dict): The JWT payload. current_time (int): The current Unix timestamp. role (str): The role to validate against the token's roles. Returns: str: The validation result as a message. if current_time >= token[\\"exp\\"]: return \\"Token expired\\" if role in token[\\"roles\\"]: return f\\"Role {role} is present\\" else: return f\\"Role {role} is not present\\""},{"question":"def reading_order(test_cases): Given multiple test cases, where each test case contains the number of books and their return days, determine the order in which the books should be read to return them just before their due days. :param test_cases: List of tuples, where each tuple contains: - N (int): number of books - return_days (list of int): list of return days for each book :return: List of lists, where each list contains the indices representing the reading order of books. >>> test_cases = [(5, [10, 3, 7, 5, 15])] >>> reading_order(test_cases) [[2, 4, 3, 1, 5]] >>> test_cases = [(3, [1, 2, 3]), (4, [8, 3, 2, 6])] >>> reading_order(test_cases) [[1, 2, 3], [3, 2, 4, 1]] >>> test_cases = [(1, [5])] >>> reading_order(test_cases) [[1]] >>> test_cases = [(5, [5, 5, 5, 5, 5])] >>> reading_order(test_cases) [[1, 2, 3, 4, 5]] pass def parse_input(input_string): Parse the input string into a list of test cases. :param input_string: Multiline string containing the number of test cases, and for each test case, the number of books and their respective return days. :return: List of tuples representing the test cases. >>> input_string = \\"1n5n10 3 7 5 15\\" >>> parse_input(input_string) [(5, [10, 3, 7, 5, 15])] pass def format_output(result): Format the result into a string suitable for output. :param result: List of lists, where each list contains the indices representing the reading order of books. :return: Formatted string. >>> result = [[2, 4, 3, 1, 5]] >>> format_output(result) '2 4 3 1 5' >>> result = [[1, 2, 3], [3, 2, 4, 1]] >>> format_output(result) '1 2 3n3 2 4 1' pass","solution":"def reading_order(test_cases): result = [] for case in test_cases: N, return_days = case indexed_books = list(enumerate(return_days, start=1)) indexed_books.sort(key=lambda x: x[1]) result.append([idx for idx, _ in indexed_books]) return result def parse_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) return_days = list(map(int, input_lines[index + 1].split())) test_cases.append((N, return_days)) index += 2 return test_cases def format_output(result): return 'n'.join(' '.join(map(str, order)) for order in result)"},{"question":"import itertools import math from typing import List def is_perfect_square(x: int) -> bool: Checks if a number x is a perfect square. s = int(math.sqrt(x)) return s * s == x def reorder_to_perfect_squares(n: int, nums: List[int]) -> List[int]: Reorders the array so that the sum of every pair of adjacent elements is a perfect square. If there are multiple ways to reorder the array, return any of them, otherwise, return an empty array if no such reordering is possible. >>> reorder_to_perfect_squares(3, [1, 17, 8]) [17, 8, 1] >>> reorder_to_perfect_squares(4, [2, 2, 2, 2]) [2, 2, 2, 2] >>> reorder_to_perfect_squares(3, [2, 3, 5]) [] >>> reorder_to_perfect_squares(4, [1, 3, 5, 7]) [] >>> reorder_to_perfect_squares(2, [16, 9]) [16, 9] pass def reorder_to_perfect_squares_from_input(input_string: str) -> List[int]: input_data = list(map(int, input_string.split())) n = input_data[0] nums = input_data[1:] return reorder_to_perfect_squares(n, nums)","solution":"import itertools import math def is_perfect_square(x): Checks if a number x is a perfect square. s = int(math.sqrt(x)) return s * s == x def reorder_to_perfect_squares(n, nums): Reorders the array so that the sum of every pair of adjacent elements is a perfect square. If there are multiple ways to reorder the array, return any of them, otherwise, return an empty array if no such reordering is possible. # Generate all permutations of nums for permutation in itertools.permutations(nums): if all(is_perfect_square(permutation[i] + permutation[i + 1]) for i in range(n - 1)): return list(permutation) return [] # Function to ingest the input def reorder_to_perfect_squares_from_input(input_string): input_data = list(map(int, input_string.split())) n = input_data[0] nums = input_data[1:] return reorder_to_perfect_squares(n, nums)"},{"question":"def insertion_sort(arr): Perform insertion sort on the input list and return a list of snapshots after each change. Examples: >>> insertion_sort([4, 2, 8, 3]) [[2, 4, 8, 3], [2, 3, 4, 8]] >>> insertion_sort([1, 3, 2, 4]) [[1, 2, 3, 4]] >>> insertion_sort([4, 3, 2, 1]) [[3, 4, 2, 1], [2, 3, 4, 1], [1, 2, 3, 4]] >>> insertion_sort([1, 2, 3, 4]) [] >>> insertion_sort([]) [] >>> insertion_sort([1]) [] >>> insertion_sort([2, 2, 2, 2]) [] pass","solution":"def insertion_sort(arr): Perform insertion sort on the input list and return a list of snapshots after each change. snapshots = [] for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if j + 1 != i: # Only record a snapshot if there was a change snapshots.append(arr.copy()) return snapshots"},{"question":"def maxProfit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying on one day and selling on a later day. If no profit can be achieved, returns 0. >>> maxProfit([7, 1, 5, 3, 6, 4]) == 5 >>> maxProfit([7, 6, 4, 3, 1]) == 0","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved by buying on one day and selling on a later day. If no profit can be achieved, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"import heapq from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Given an array of integers nums and an integer k, return the kth largest element in the array. Example: >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 def test_kth_largest_example1(): nums = [3, 2, 1, 5, 6, 4] k = 2 assert find_kth_largest(nums, k) == 5 def test_kth_largest_example2(): nums = [3, 2, 3, 1, 2, 4, 5, 5, 6] k = 4 assert find_kth_largest(nums, k) == 4 def test_kth_largest_single_element(): nums = [1] k = 1 assert find_kth_largest(nums, k) == 1 def test_kth_largest_larger_array(): nums = [7, 10, 4, 3, 20, 15] k = 3 assert find_kth_largest(nums, k) == 10 def test_kth_largest_with_duplicates(): nums = [3, 2, 3, 1, 2, 4, 5, 5, 6, 6] k = 5 assert find_kth_largest(nums, k) == 4","solution":"import heapq def find_kth_largest(nums, k): Returns the kth largest element in the array nums. # Use a min heap to find the kth largest element return heapq.nlargest(k, nums)[-1]"},{"question":"def is_balanced(sequence: str) -> bool: Determines if the input string consisting of parentheses and brackets is balanced. Args: sequence (str): The string containing the sequence of parentheses and brackets. Returns: bool: Returns True if the string is balanced, False otherwise. Examples: >>> is_balanced(\\"()\\") True >>> is_balanced(\\"[]\\") True >>> is_balanced(\\"()[]\\") True >>> is_balanced(\\"([])\\") True >>> is_balanced(\\"([)]\\") False pass def test_balanced_sequences(): assert is_balanced(\\"()\\") == True assert is_balanced(\\"[]\\") == True assert is_balanced(\\"()[]\\") == True assert is_balanced(\\"([])\\") == True assert is_balanced(\\"([()])\\") == True def test_unbalanced_sequences(): assert is_balanced(\\"(\\") == False assert is_balanced(\\")\\") == False assert is_balanced(\\"(()\\") == False assert is_balanced(\\"([)]\\") == False assert is_balanced(\\"([][\\") == False assert is_balanced(\\"([)]\\") == False def test_empty_sequence(): assert is_balanced(\\"\\") == True def test_mixed_characters(): assert is_balanced(\\"(a+b)\\") == True assert is_balanced(\\"{[()]}\\") == True assert is_balanced(\\"{[(])}\\") == False","solution":"def is_balanced(sequence): Determines if the input string consisting of parentheses and brackets is balanced. Args: sequence (str): The string containing the sequence of parentheses and brackets. Returns: bool: Returns True if the string is balanced, False otherwise. stack = [] matching_bracket = {')':'(', ']':'['} for char in sequence: if char in '([': stack.append(char) elif char in ')]': if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return len(stack) == 0"},{"question":"def filter_and_average_salary(employees: List[dict], min_age: int, max_age: int, min_salary: int, max_salary: int) -> float: Filters employees based on the given age and salary ranges and returns the average salary of employees who meet the criteria. If no employee meets the criteria, returns 0. Parameters: - employees (list of dict): List of employee records. - min_age (int): Minimum age (inclusive). - max_age (int): Maximum age (inclusive). - min_salary (int): Minimum salary (inclusive). - max_salary (int): Maximum salary (inclusive). Returns: - float: Average salary of employees who meet the criteria or 0 if none do. >>> employees = [ ... {'id': 1, 'name': 'Alice', 'age': 30, 'salary': 5000}, ... {'id': 2, 'name': 'Bob', 'age': 45, 'salary': 7000}, ... {'id': 3, 'name': 'Charlie', 'age': 35, 'salary': 6000}, ... {'id': 4, 'name': 'David', 'age': 32, 'salary': 4000}, ... {'id': 5, 'name': 'Eve', 'age': 28, 'salary': 8000} ... ] >>> filter_and_average_salary(employees, 30, 40, 4000, 6000) 5000.0 >>> filter_and_average_salary(employees, 20, 25, 2000, 3000) 0 >>> filter_and_average_salary(employees, 30, 35, 4500, 7000) 5500.0 >>> filter_and_average_salary(employees, 32, 32, 4000, 4000) 4000.0 >>> filter_and_average_salary([], 25, 35, 3000, 5000) 0","solution":"def filter_and_average_salary(employees, min_age, max_age, min_salary, max_salary): Filters employees based on the given age and salary ranges and returns the average salary of employees who meet the criteria. If no employee meets the criteria, returns 0. Parameters: - employees (list of dict): List of employee records. - min_age (int): Minimum age (inclusive). - max_age (int): Maximum age (inclusive). - min_salary (int): Minimum salary (inclusive). - max_salary (int): Maximum salary (inclusive). Returns: - float: Average salary of employees who meet the criteria or 0 if none do. filtered_salaries = [ emp['salary'] for emp in employees if min_age <= emp['age'] <= max_age and min_salary <= emp['salary'] <= max_salary ] if not filtered_salaries: return 0 return sum(filtered_salaries) / len(filtered_salaries)"},{"question":"from typing import Dict, List def find_route(map: Dict[str, List[str]], start: str, end: str) -> List[str]: Write a function \`find_route(map, start, end)\` that finds the shortest path between two nodes in a given map. The map is represented as an adjacency list, and the nodes will be represented as strings. The path should be returned as a list of nodes showing the path from start to end. If no path exists, the function should return an empty list. >>> find_route({ ... 'A': ['B', 'C'], ... 'B': ['A', 'D', 'E'], ... 'C': ['A', 'F'], ... 'D': ['B'], ... 'E': ['B', 'F'], ... 'F': ['C', 'E'] ... }, 'A', 'F') ['A', 'C', 'F'] >>> find_route({ ... 'A': ['B'], ... 'B': ['A'], ... 'C': ['D'], ... 'D': ['C'] ... }, 'A', 'D') [] >>> find_route({ ... 'A': ['B'], ... 'B': ['A', 'C'], ... 'C': ['B'] ... }, 'A', 'A') ['A']","solution":"from collections import deque def find_route(map, start, end): Finds the shortest path between two nodes in a given map. if start == end: return [start] queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: current_node, path = queue.popleft() for neighbor in map.get(current_node, []): if neighbor in visited: continue if neighbor == end: return path + [neighbor] visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"def compress_string(s: str) -> str: Compress a string using the counts of repeated characters. If the compressed version would not be smaller than the original string, return the original string. >>> compress_string('aabcccccaaa') 'a2b1c5a3' >>> compress_string('abcdef') 'abcdef' >>> compress_string('aabbcc') 'aabbcc' >>> compress_string('aaAAaa') 'aaAAaa' >>> compress_string('aaabbbccc') 'a3b3c3'","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # append the last character and its count compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"from typing import List def minimumDifference(nums: List[int]) -> int: You are given an array of integers nums, where each element represents a stone's weight. You want to split the stones into two groups such that the absolute difference between the sum of weights in the two groups is minimized. Return the minimum possible difference between the sum of the weights of the two groups. >>> minimumDifference([2,7,4,1,8,1]) 1 >>> minimumDifference([31,26,33,21,40]) 5","solution":"def minimumDifference(nums): total_sum = sum(nums) n = len(nums) dp = [0] * (total_sum // 2 + 1) for num in nums: for i in range(total_sum // 2, num - 1, -1): dp[i] = max(dp[i], dp[i - num] + num) sum1 = dp[total_sum // 2] sum2 = total_sum - sum1 return abs(sum1 - sum2)"},{"question":"def find_kth_largest(arr: List[int], k: int) -> int: Returns the kth largest element in the list arr. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([2, 2, 2, 2], 1) 2 >>> find_kth_largest([7, 10, 4, 3, 20, 15], 3) 10 >>> find_kth_largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) 1 >>> find_kth_largest([-1, -2, -3, -4, -5], 2) -2 pass","solution":"import heapq from typing import List def find_kth_largest(arr: List[int], k: int) -> int: Returns the kth largest element in the list arr. # Create a min-heap with the first k elements of the array heap = arr[:k] heapq.heapify(heap) # Iterate over the remaining elements in the array for num in arr[k:]: # If the current number is larger than the smallest number in the heap if num > heap[0]: heapq.heappop(heap) heapq.heappush(heap, num) # The root of the heap is the kth largest element return heap[0]"},{"question":"def organize_books(books: List[int], limit: int) -> List[int]: Organizes the book collection based on the given limit per genre. Parameters: books (list): A list of integers representing the books. limit (int): An integer representing the maximum number of books per genre. Returns: list: A list representing the organized collection with no genre exceeding the given limit. >>> organize_books([1, 3, 3, 2, 1, 5, 6, 1, 3, 2], 2) [1, 3, 3, 2, 1, 5, 6, 2] >>> organize_books([4, 4, 4, 4, 4], 1) [4] >>> organize_books([], 3) [] >>> organize_books([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0) [] >>> organize_books([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"def organize_books(books, limit): Organizes the book collection based on the given limit per genre. Parameters: books (list): A list of integers representing the books. limit (int): An integer representing the maximum number of books per genre. Returns: list: A list representing the organized collection with no genre exceeding the given limit. genre_count = {i: 0 for i in range(1, 11)} organized_books = [] for book in books: if genre_count[book] < limit: organized_books.append(book) genre_count[book] += 1 return organized_books"},{"question":"def count_consecutive_digits(sequence: List[int]) -> str: Return a string that represents the count of consecutive digits in the input sequence. >>> count_consecutive_digits([1]) '11' >>> count_consecutive_digits([1, 1, 1]) '31' >>> count_consecutive_digits([1, 1, 2, 2, 2, 3, 1]) '21321311' >>> count_consecutive_digits([1, 2, 3, 4, 5]) '1112131415' >>> count_consecutive_digits([4, 4, 4, 4, 4]) '54' >>> count_consecutive_digits([1, 2, 1, 2, 1]) '1112111211' >>> count_consecutive_digits([2]*1000) '10002'","solution":"def count_consecutive_digits(sequence): Return a string that represents the count of consecutive digits in the input sequence. if not sequence: return '' result = '' current_digit = sequence[0] current_count = 1 for digit in sequence[1:]: if digit == current_digit: current_count += 1 else: result += str(current_count) + str(current_digit) current_digit = digit current_count = 1 result += str(current_count) + str(current_digit) return result"},{"question":"def fibonacci(n: int) -> int: Calculates the nth Fibonacci number using an iterative approach. This method is efficient and can handle large values of n. :param n: Index in the Fibonacci sequence. :return: The nth Fibonacci number. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(7) == 13 >>> fibonacci(10) == 55","solution":"def fibonacci(n): Calculates the nth Fibonacci number using an iterative approach. This method is efficient and can handle large values of n. :param n: Index in the Fibonacci sequence. :return: The nth Fibonacci number. if n < 0: raise ValueError(\\"Index cannot be negative\\") elif n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deepestLevelSum(root: TreeNode) -> int: Given the root node of a binary tree, returns the sum of the values of all nodes located at the deepest level. Args: root: TreeNode: The root node of the binary tree. Returns: int: Sum of node values at the deepest level in the binary tree. Example: >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> deepestLevelSum(root) 9 >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, right=TreeNode(5, right=TreeNode(6)))) >>> deepestLevelSum(root) 6","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deepestLevelSum(root): if not root: return 0 queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.value if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"def check_laptops_eligibility(laptops: List[dict], requirement: dict) -> List[str]: Checks whether each laptop model satisfies the customer requirement. Args: laptops (list of dict): A list of dictionaries where each dictionary represents a laptop model. requirement (dict): A dictionary representing the customer requirements. Returns: list of str: A list containing \\"Eligible\\" or \\"Ineligible\\" for each laptop model. >>> check_laptops_eligibility( ... [{\\"CPU\\": 4, \\"RAM\\": 16, \\"Storage\\": 512, \\"GPU\\": 8}, ... {\\"CPU\\": 6, \\"RAM\\": 8, \\"Storage\\": 256, \\"GPU\\": 4}, ... {\\"CPU\\": 2, \\"RAM\\": 32, \\"Storage\\": 1024, \\"GPU\\": 2}], ... {\\"CPU\\": 4, \\"RAM\\": 8, \\"Storage\\": 256} ... ) ['Eligible', 'Eligible', 'Ineligible']","solution":"def check_laptops_eligibility(laptops, requirement): Checks whether each laptop model satisfies the customer requirement. Args: laptops (list of dict): A list of dictionaries where each dictionary represents a laptop model. requirement (dict): A dictionary representing the customer requirements. Returns: list of str: A list containing \\"Eligible\\" or \\"Ineligible\\" for each laptop model. results = [] for laptop in laptops: eligible = True for key, value in requirement.items(): if key in laptop: if laptop[key] < value: eligible = False break else: eligible = False break if eligible: results.append(\\"Eligible\\") else: results.append(\\"Ineligible\\") return results"},{"question":"def averageRatingByGenre(books): Computes the average rating for each genre in the list of books. :param books: List of dictionaries, each representing a book with keys \\"title\\", \\"genre\\", and \\"rating\\". :return: Dictionary where keys are genres and values are average ratings. Example: >>> books = [ >>> {\\"title\\": \\"Book A\\", \\"genre\\": \\"Fantasy\\", \\"rating\\": 4}, >>> {\\"title\\": \\"Book B\\", \\"genre\\": \\"Science Fiction\\", \\"rating\\": 5}, >>> {\\"title\\": \\"Book C\\", \\"genre\\": \\"Fantasy\\", \\"rating\\": 3}, >>> {\\"title\\": \\"Book D\\", \\"genre\\": \\"Science Fiction\\", \\"rating\\": 2}, >>> {\\"title\\": \\"Book E\\", \\"genre\\": \\"Mystery\\", \\"rating\\": 4} >>> ] >>> averageRatingByGenre(books) { \\"Fantasy\\": 3.5, \\"Science Fiction\\": 3.5, \\"Mystery\\": 4.0 } >>> books = [] >>> averageRatingByGenre(books) {}","solution":"def averageRatingByGenre(books): Computes the average rating for each genre in the list of books. :param books: List of dictionaries, each representing a book with keys \\"title\\", \\"genre\\", and \\"rating\\". :return: Dictionary where keys are genres and values are average ratings. genre_totals = {} genre_counts = {} for book in books: genre = book[\\"genre\\"] rating = book[\\"rating\\"] if genre not in genre_totals: genre_totals[genre] = 0 genre_counts[genre] = 0 genre_totals[genre] += rating genre_counts[genre] += 1 average_ratings = {genre: genre_totals[genre] / genre_counts[genre] for genre in genre_totals} return average_ratings"},{"question":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers 'nums' and an integer 'target', return indices of the two numbers such that they add up to 'target'. Each input will have exactly one solution, and you may not use the same element twice. Examples: >>> find_two_sum([2, 7, 11, 15], 9) [0, 1] >>> find_two_sum([3, 2, 4], 6) [1, 2] >>> find_two_sum([3, 3], 6) [0, 1]","solution":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers 'nums' and an integer 'target', return indices of the two numbers such that they add up to 'target'. Each input will have exactly one solution, and you may not use the same element twice. :param nums: List[int] - List of integers :param target: int - Target sum :return: List[int] - Indices of the two numbers that add up to target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def largest_empty_component_size(N: int, M: int, grid: List[str]) -> int: You are given a grid with N rows and M columns. Each cell in the grid is either empty or blocked. You can start at any empty cell and you want to find the size of the largest empty connected component in the grid. An empty cell is considered connected if it shares a side with another empty cell. Input: - The first line contains two integers N and M denoting the number of rows and columns of the grid, respectively. - The next N lines each contain M characters, where each character is either \`.\` for an empty cell or \`#\` for a blocked cell. Output: - Print a single integer ― the size of the largest empty connected component in the grid. pass def test_largest_component_basic(): grid = [ \\".#..\\", \\"..#.\\", \\"#.\\" ] assert largest_empty_component_size(3, 4, grid) == 4 def test_all_blocked(): grid = [ \\"\\", \\"\\", \\"\\" ] assert largest_empty_component_size(3, 4, grid) == 0 def test_all_empty(): grid = [ \\"....\\", \\"....\\", \\"....\\" ] assert largest_empty_component_size(3, 4, grid) == 12 def test_single_empty_cell(): grid = [ \\"#\\", \\".\\", \\"#\\" ] assert largest_empty_component_size(3, 1, grid) == 1 def test_multiple_components(): grid = [ \\".#.\\", \\"#.#\\", \\"...\\" ] assert largest_empty_component_size(3, 3, grid) == 4 def test_edge_blocked(): grid = [ \\".\\", \\".#.\\", \\"..#\\" ] assert largest_empty_component_size(3, 3, grid) == 3","solution":"def largest_empty_component_size(N, M, grid): from collections import deque def bfs(start_i, start_j): queue = deque([(start_i, start_j)]) visited.add((start_i, start_j)) component_size = 0 while queue: i, j = queue.popleft() component_size += 1 for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= x < N and 0 <= y < M and (x, y) not in visited and grid[x][y] == '.': visited.add((x, y)) queue.append((x, y)) return component_size visited = set() max_component_size = 0 for i in range(N): for j in range(M): if grid[i][j] == '.' and (i, j) not in visited: max_component_size = max(max_component_size, bfs(i, j)) return max_component_size"},{"question":"def four_sum(arr: List[int], num: int) -> List[List[int]]: Finds all unique quadruplets in the list \`arr\` that sum up to \`num\`. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] Args: arr (List[int]): The input list of integers. num (int): The target sum for the quadruplets. Returns: List[List[int]]: The list of unique quadruplets that sum up to \`num\`. from typing import List def test_example_1(): arr = [1, 0, -1, 0, -2, 2] num = 0 expected = [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] assert four_sum(arr, num) == expected def test_example_2(): arr = [2, 2, 2, 2, 2] num = 8 expected = [[2, 2, 2, 2]] assert four_sum(arr, num) == expected def test_no_quadruplets(): arr = [1, 2, 3, 4] num = 100 expected = [] assert four_sum(arr, num) == expected def test_multiple_solutions(): arr = [1, 1, 1, 1, 1, 1, 1, 1] num = 4 expected = [[1, 1, 1, 1]] assert four_sum(arr, num) == expected def test_negative_numbers(): arr = [-1, 2, 2, -5, 0, -1, 4] num = 3 expected = [[-5, 2, 2, 4], [-1, 0, 2, 2]] result = four_sum(arr, num) for quad in expected: assert quad in result assert len(result) == len(expected)","solution":"def four_sum(arr, num): Finds all unique quadruplets in the list \`arr\` that sum up to \`num\`. arr.sort() quadruplets = set() for i in range(len(arr) - 3): for j in range(i + 1, len(arr) - 2): left, right = j + 1, len(arr) - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == num: quadruplets.add((arr[i], arr[j], arr[left], arr[right])) left += 1 right -= 1 elif total < num: left += 1 else: right -= 1 return [list(quad) for quad in sorted(quadruplets)]"},{"question":"def spiral_traverse(matrix): Write a function \`spiral_traverse(matrix)\` that takes in a 2-dimensional list (a matrix) of arbitrary size and returns a list of its elements in spiral order. Spiral order starts at the top-left corner and traverses the matrix in a clockwise direction, progressively working its way inward. Args: matrix (List[List[int]]): 2-dimensional list of integers representing the matrix Returns: List[int]: List of integers representing the matrix elements in spiral order Examples: >>> spiral_traverse([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] >>> spiral_traverse([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... [10, 11, 12] ... ]) [1, 2, 3, 6, 9, 12, 11, 10, 7, 4, 5, 8] >>> spiral_traverse([ ... [1] ... ]) [1] >>> spiral_traverse([]) [] # Solution to be implemented here def test_spiral_traverse_square_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert spiral_traverse(matrix) == [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] def test_spiral_traverse_single_row(): matrix = [ [1, 2, 3, 4] ] assert spiral_traverse(matrix) == [1, 2, 3, 4] def test_spiral_traverse_single_column(): matrix = [ [1], [2], [3], [4] ] assert spiral_traverse(matrix) == [1, 2, 3, 4] def test_spiral_traverse_rectangle_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12] ] assert spiral_traverse(matrix) == [1, 2, 3, 6, 9, 12, 11, 10, 7, 4, 5, 8] def test_spiral_traverse_empty(): matrix = [] assert spiral_traverse(matrix) == [] def test_spiral_traverse_one_element(): matrix = [ [1] ] assert spiral_traverse(matrix) == [1]","solution":"def spiral_traverse(matrix): if not matrix or not matrix[0]: return [] result = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def longestUniqueSubstring(s: str) -> int: Given a string of lowercase English letters, finds the length of the longest substring without repeating characters. Args: s (str): The input string Returns: int: The length of the longest substring without repeating characters Examples: >>> longestUniqueSubstring(\\"abcabcbb\\") 3 >>> longestUniqueSubstring(\\"bbbbb\\") 1 >>> longestUniqueSubstring(\\"pwwkew\\") 3 >>> longestUniqueSubstring(\\"\\") 0","solution":"def longestUniqueSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def countConsonants(s: str) -> int: Complete the function that counts the number of consonants in the given string and returns the count. Note: - Consider consonants to be all alphabetic characters except 'a', 'e', 'i', 'o', 'u', both uppercase and lowercase. - Ignore any non-alphabetic characters present in the string. >>> countConsonants(\\"Hello World!\\") == 7 >>> countConsonants(\\"This is a test.\\") == 6 >>> countConsonants(\\"AEIOU aeioU\\") == 0 >>> countConsonants(\\"12345!\\") == 0 >>> countConsonants(\\"Coding is fun!\\") == 7","solution":"def countConsonants(s): Returns the number of consonants in the given string. consonants = \\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\\" return sum(1 for char in s if char in consonants)"},{"question":"def word_transformer(string: str, transformations: List[Tuple[str, str]]) -> str: Transforms the given string by applying a series of transformations. Each transformation is represented as a tuple (old, new), where the substring 'old' in the string should be replaced with the substring 'new'. >>> word_transformer(\\"hello world\\", []) \\"hello world\\" >>> word_transformer(\\"hello world\\", [('e', '3')]) \\"h3llo world\\" >>> word_transformer(\\"hello world\\", [('e', '3'), ('o', '0'), ('l', '1')]) \\"h3110 w0r1d\\" >>> word_transformer(\\"Hello World\\", [('H', 'h'), ('W', 'w')]) \\"hello world\\" >>> word_transformer(\\"hello world\\", [('hello', 'hi'), ('world', 'earth')]) \\"hi earth\\" >>> word_transformer(\\"The quick brown fox jumps over the lazy dog\\", [('quick', 'slow'), ('brown', 'white'), ('fox', 'rabbit')]) \\"The slow white rabbit jumps over the lazy dog\\"","solution":"def word_transformer(string, transformations): Transforms the given string by applying a series of transformations. Each transformation is represented as a tuple (old, new), where the substring 'old' in the string should be replaced with the substring 'new'. :param string: The input string to be transformed. :param transformations: A list of tuples (old, new) representing transformations. :return: The transformed string. for old, new in transformations: string = string.replace(old, new) return string"},{"question":"def find_unique_element(arr: list) -> int: Find the element that appears only once in an array where every element appears twice except for one. Args: arr (list of integers): An array of integers where each integer appears exactly twice, except for one integer which appears only once. Length of the array will always be an odd number. Returns: int: The integer that appears only once. >>> find_unique_element([2, 3, 2, 4, 4]) 3 >>> find_unique_element([1, 1, 2, 3, 2, 5, 5]) 3 # Your code here from solution import find_unique_element def test_find_unique_element_all_positive(): assert find_unique_element([2, 3, 2, 4, 4]) == 3 def test_find_unique_element_mixed_numbers(): assert find_unique_element([1, 1, 2, 3, 2, 5, 5]) == 3 def test_find_unique_element_all_negative(): assert find_unique_element([-1, -2, -2, -3, -3]) == -1 def test_find_unique_element_single_element(): assert find_unique_element([99]) == 99 def test_find_unique_element_large_array(): assert find_unique_element([i for i in range(1, 10001)] + [5000] + [i for i in range(1, 10001)]) == 5000","solution":"def find_unique_element(arr): Finds the unique element in the array where every other element appears twice. Args: arr (list): A list of integers where exactly one element appears once and all others appear twice. Returns: int: The element that appears only once. unique = 0 for num in arr: unique ^= num return unique"},{"question":"def numDistinct(s: str, t: str) -> int: Returns the number of distinct subsequences of s which equals t. >>> numDistinct(\\"rabbbit\\", \\"rabbit\\") 3 >>> numDistinct(\\"babgbag\\", \\"bag\\") 5 >>> numDistinct(\\"abcdef\\", \\"xyz\\") 0 >>> numDistinct(\\"abcd\\", \\"abcd\\") 1 >>> numDistinct(\\"abcdef\\", \\"\\") 1 >>> numDistinct(\\"\\", \\"abc\\") 0 >>> numDistinct(\\"abc\\", \\"abcd\\") 0","solution":"def numDistinct(s, t): Returns the number of distinct subsequences of s which equals t. # Initializing a 2D dp array where dp[i][j] represents the number of ways to form the substring t[:j] using the substring s[:i]. dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)] # Any string has exactly one way to create an empty subsequence. for i in range(len(s) + 1): dp[i][0] = 1 # Filling the dp table for i in range(1, len(s) + 1): for j in range(1, len(t) + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] return dp[-1][-1]"},{"question":"def validSudoku(board: List[List[str]]) -> bool: Determine if a given 9x9 Sudoku board is valid. The board is represented by a 2D array, where each entry is a character: '1'-'9' representing a digit, or '.' representing an empty space. Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3x3 sub-boxes must contain the digits 1-9 without repetition. >>> board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> validSudoku(board) True >>> board = [ ... [\\"8\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> validSudoku(board) False def test_valid_sudoku(): board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] assert validSudoku(board) == True def test_invalid_sudoku_row_duplication(): board = [ [\\"8\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] assert validSudoku(board) == False def test_invalid_sudoku_column_duplication(): board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"8\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], # Duplicate '8' in the same column [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] assert validSudoku(board) == False def test_invalid_sudoku_subbox_duplication(): board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\"8\\",\\"6\\"], # Duplicate '8' in the bottom-right 3x3 sub-box [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] assert validSudoku(board) == False","solution":"def validSudoku(board): def is_valid_block(block): block = [i for i in block if i != '.'] return len(block) == len(set(block)) def get_block(board, start_row, start_col): block = [] for i in range(3): for j in range(3): block.append(board[start_row + i][start_col + j]) return block # Check rows for row in board: if not is_valid_block(row): return False # Check columns for col in range(9): column = [board[row][col] for row in range(9)] if not is_valid_block(column): return False # Check 3x3 sub-boxes for row in range(0, 9, 3): for col in range(0, 9, 3): block = get_block(board, row, col) if not is_valid_block(block): return False return True"},{"question":"def split_even_odd(lst: List[int]) -> List[List[int]]: Create a function that accepts a list of integers and returns a new list with two elements: the first element is a sublist of all the even numbers in the original list, and the second element is a sublist of all the odd numbers in the original list. Both sublists should be ordered in the same sequence as they appeared in the input list. >>> split_even_odd([1, 2, 3, 4, 5]) [[2, 4], [1, 3, 5]] >>> split_even_odd([10, 15, 20, 25, 30]) [[10, 20, 30], [15, 25]] >>> split_even_odd([7, 8, 9, 10, 11]) [[8, 10], [7, 9, 11]]","solution":"def split_even_odd(lst): Splits a list of integers into two sublists: even numbers and odd numbers. Arguments: lst : list of int The list of integers to split. Returns: list of lists A list containing two sublists: the first sublist contains all even numbers, and the second sublist contains all odd numbers. even_numbers = [num for num in lst if num % 2 == 0] odd_numbers = [num for num in lst if num % 2 != 0] return [even_numbers, odd_numbers]"},{"question":"def from_decimal_to_base(number: int, base: int) -> str: Converts a given decimal (base 10) number to its representation in a specified base (between 2 and 36). :param number: An integer in decimal form. :param base: An integer representing the base to which you need to convert the decimal number. :return: A string that represents the number in the specified base. >>> from_decimal_to_base(10, 2) \\"1010\\" >>> from_decimal_to_base(255, 16) \\"FF\\" >>> from_decimal_to_base(1234, 36) \\"YA\\" >>> from_decimal_to_base(0, 2) \\"0\\" >>> from_decimal_to_base(-10, 2) \\"-1010\\"","solution":"def from_decimal_to_base(number, base): Converts a decimal number to its representation in a specified base (between 2 and 36). :param number: The decimal number to convert. :param base: The base to convert the number to. :return: The number represented in the specified base as a string. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if number == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" is_negative = number < 0 number = abs(number) while number > 0: result = digits[number % base] + result number //= base if is_negative: result = \\"-\\" + result return result"},{"question":"def marathon_standings(times: List[int]) -> Tuple[int, int, int]: Returns a tuple with the fastest time, the slowest time, and the average time. Parameters: times (list of int): List of times taken by participants. Returns: tuple: (fastest time, slowest time, average time (rounded to the nearest whole number)) Examples: >>> marathon_standings([120, 130, 150, 160, 140]) (120, 160, 140) >>> marathon_standings([125]) (125, 125, 125) >>> marathon_standings([]) (0, 0, 0) >>> marathon_standings([130, 130, 130, 130]) (130, 130, 130) >>> marathon_standings([100, 102, 104, 106, 108]) (100, 108, 104) >>> marathon_standings([100, 101, 102]) (100, 102, 101) >>> marathon_standings([59, 160, 120, 90, 140]) (59, 160, 114)","solution":"def marathon_standings(times): Returns a tuple with the fastest time, the slowest time, and the average time. Parameters: times (list of int): List of times taken by participants. Returns: tuple: (fastest time, slowest time, average time (rounded to the nearest whole number)) if not times: return (0, 0, 0) # Handle the case when the list is empty fastest_time = min(times) slowest_time = max(times) average_time = round(sum(times) / len(times)) return (fastest_time, slowest_time, average_time)"},{"question":"def sort_student_names(names: List[str]) -> str: Takes a list of student names and returns a string containing the names in sorted order, separated by a comma and space. :param names: List of student names :type names: List[str] :return: Sorted names as a string :rtype: str >>> sort_student_names([\\"John\\", \\"Alice\\", \\"Bob\\"]) == \\"Alice, Bob, John\\" >>> sort_student_names([]) == \\"\\" >>> sort_student_names([\\"John\\"]) == \\"John\\" >>> sort_student_names([\\"John\\", \\"Alice\\", \\"Alice\\"]) == \\"Alice, Alice, John\\" >>> sort_student_names([\\"John\\", \\"John\\", \\"John\\"]) == \\"John, John, John\\" >>> sort_student_names([\\"john\\", \\"Alice\\", \\"bob\\"]) == \\"Alice, bob, john\\"","solution":"def sort_student_names(names): Takes a list of student names and returns a string containing the names in sorted order, separated by a comma and space. :param names: List of student names :type names: list[str] :return: Sorted names as a string :rtype: str if not names: return \\"\\" sorted_names = sorted(names) return \\", \\".join(sorted_names)"},{"question":"def isIsomorphic(s: str, t: str) -> bool: Determine if two strings s and t are isomorphic. >>> isIsomorphic(\\"egg\\", \\"add\\") True >>> isIsomorphic(\\"foo\\", \\"bar\\") False >>> isIsomorphic(\\"paper\\", \\"title\\") True >>> isIsomorphic(\\"ab\\", \\"aa\\") False >>> isIsomorphic(\\"\\", \\"\\") True >>> isIsomorphic(\\"a\\", \\"a\\") True >>> isIsomorphic(\\"a\\", \\"b\\") True >>> isIsomorphic(\\"abcdefghijklmnopqrstuvwxyz\\", \\"zyxwvutsrqponmlkjihgfedcba\\") True >>> isIsomorphic(\\"abb\\", \\"cdd\\") True >>> isIsomorphic(\\"abb\\", \\"cbc\\") False","solution":"def isIsomorphic(s: str, t: str) -> bool: Determine if two strings s and t are isomorphic. if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False else: mapping_s_to_t[char_s] = char_t if char_t in mapping_t_to_s: if mapping_t_to_s[char_t] != char_s: return False else: mapping_t_to_s[char_t] = char_s return True"},{"question":"def process_subarray_sums(n: int, array: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Consider an array of integers and a set of queries. For each query, find the sum of a subarray given by the range in the query. If the sum is odd, increment it by 1; if it is even, decrement it by 1. Return the results for all the queries. Args: n (int): The number of elements in the array. array (List[int]): The elements of the array. q (int): The number of queries. queries (List[Tuple[int, int]]): The range for each query. Returns: List[int]: The results of the queries. Example: >>> n = 5 >>> array = [1, 2, 3, 4, 5] >>> q = 3 >>> queries = [(1, 3), (2, 5), (1, 5)] >>> process_subarray_sums(n, array, q, queries) [5, 13, 16] pass","solution":"def process_subarray_sums(n, array, q, queries): # Calculate prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + array[i - 1] results = [] for l, r in queries: subarray_sum = prefix_sums[r] - prefix_sums[l - 1] if subarray_sum % 2 == 0: results.append(subarray_sum - 1) else: results.append(subarray_sum + 1) return results"},{"question":"def complex_add_subtract(c1, c2, operation): Performs addition or subtraction on two complex numbers based on the specified operation. The complex numbers are given as tuples (real, imaginary). Args: c1 (tuple): A tuple (real, imaginary) representing the first complex number. c2 (tuple): A tuple (real, imaginary) representing the second complex number. operation (str): A string that can be either \\"add\\" or \\"subtract\\". Returns: tuple: A tuple (result_real, result_imaginary) representing the result complex number. pass # Sample test cases assert complex_add_subtract((3, 4), (1, 2), \\"add\\") == (4, 6) assert complex_add_subtract((-1, -1), (1, 1), \\"add\\") == (0, 0) assert complex_add_subtract((0, 0), (0, 0), \\"add\\") == (0, 0) assert complex_add_subtract((3, 4), (1, 2), \\"subtract\\") == (2, 2) assert complex_add_subtract((5, -3), (2, 4), \\"subtract\\") == (3, -7) assert complex_add_subtract((0, 0), (1, 1), \\"subtract\\") == (-1, -1) try: complex_add_subtract((3, 4), (1, 2), \\"multiply\\") except ValueError as e: assert str(e) == \\"The operation must be 'add' or 'subtract'\\"","solution":"def complex_add_subtract(c1, c2, operation): Performs addition or subtraction on two complex numbers based on the specified operation. The complex numbers are given as tuples (real, imaginary). Args: c1 (tuple): A tuple (real, imaginary) representing the first complex number. c2 (tuple): A tuple (real, imaginary) representing the second complex number. operation (str): A string that can be either \\"add\\" or \\"subtract\\". Returns: tuple: A tuple (result_real, result_imaginary) representing the result complex number. if operation == \\"add\\": result_real = c1[0] + c2[0] result_imaginary = c1[1] + c2[1] elif operation == \\"subtract\\": result_real = c1[0] - c2[0] result_imaginary = c1[1] - c2[1] else: raise ValueError(\\"The operation must be 'add' or 'subtract'\\") return (result_real, result_imaginary)"},{"question":"def find_triplet(lst: List[int]) -> bool: Determines if there exists a triplet (a, b, c) in the list such that a^2 + b^2 = c^2. Parameters: lst (list): A list of integers Returns: bool: True if such a triplet exists, False otherwise. >>> find_triplet([3, 1, 4, 6, 5]) True >>> find_triplet([10, 4, 6, 12, 5]) False from solution import find_triplet def test_find_triplet_true_case(): assert find_triplet([3, 1, 4, 6, 5]) == True def test_find_triplet_false_case(): assert find_triplet([10, 4, 6, 12, 5]) == False def test_find_triplet_empty_list(): assert find_triplet([]) == False def test_find_triplet_single_element(): assert find_triplet([5]) == False def test_find_triplet_two_elements(): assert find_triplet([3, 4]) == False def test_find_triplet_multiple_triplets(): assert find_triplet([5, 12, 13, 9, 15, 3, 4]) == True def test_find_triplet_negative_values(): assert find_triplet([-3, -4, -5]) == True def test_find_triplet_mixed_sign_values(): assert find_triplet([3, -4, 5, -6]) == True def test_find_triplet_all_zeroes(): assert find_triplet([0, 0, 0]) == True def test_find_triplet_duplicates(): assert find_triplet([3, 3, 4, 5, 5, 6]) == True def test_find_triplet_large_numbers(): assert find_triplet([3000, 4000, 5000]) == True","solution":"def find_triplet(lst): Determines if there exists a triplet (a, b, c) in the list such that a^2 + b^2 = c^2. Parameters: lst (list): A list of integers Returns: bool: True if such a triplet exists, False otherwise. lst = [x ** 2 for x in lst] # Square all elements lst.sort() # Sort the squared elements n = len(lst) for c in range(n - 1, 1, -1): # Let lst[c] be the largest number a = 0 b = c - 1 while a < b: if lst[a] + lst[b] == lst[c]: return True elif lst[a] + lst[b] < lst[c]: a += 1 else: b -= 1 return False"},{"question":"def is_prime(n: int) -> bool: Determine if the input number is a prime number. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(1) False >>> is_prime(-3) False def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([-1, 0, 1, 2]) [2] >>> filter_primes([]) [] >>> filter_primes([15, 23, 31, 44, 55]) [23, 31]","solution":"def is_prime(n): Determine if the input number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a list of prime numbers from the given list. return [n for n in numbers if is_prime(n)]"},{"question":"[Completion Task in Python] from typing import List def count_packages(weights: List[int]) -> List[int]: Determine the number of packages in each category based on their weight. The categories are light (less than 5kg), medium (5kg to 10kg), and heavy (more than 10kg). >>> count_packages([3, 7, 12, 1, 5, 9, 11]) [2, 3, 2] >>> count_packages([1, 2, 3, 4]) [4, 0, 0] >>> count_packages([5, 6, 7, 8, 9, 10]) [0, 6, 0] >>> count_packages([11, 12, 13, 14, 15]) [0, 0, 5] >>> count_packages([]) [0, 0, 0] >>> count_packages([5, 10, 5, 10, 4, 11]) [1, 4, 1] >>> count_packages([3]) [1, 0, 0] >>> count_packages([6]) [0, 1, 0] >>> count_packages([12]) [0, 0, 1] >>> count_packages([4, 5, 6, 15]) [1, 2, 1]","solution":"from typing import List def count_packages(weights: List[int]) -> List[int]: light, medium, heavy = 0, 0, 0 for weight in weights: if weight < 5: light += 1 elif 5 <= weight <= 10: medium += 1 else: heavy += 1 return [light, medium, heavy]"},{"question":"def max_packages(n: int, h: int, packages: List[int]) -> int: Calculate the maximum number of packages John can deliver in h hours. Parameters: n (int): Number of locations. h (int): Number of hours John can work in a day. packages (list of int): List of integers representing the number of packages at each location. Returns: int: Maximum number of packages John can deliver in h hours. >>> max_packages(5, 3, [2, 3, 1, 4, 6]) 13 >>> max_packages(4, 4, [5, 2, 3, 1]) 11 >>> max_packages(6, 2, [7, 1, 5, 3, 2, 4]) 12","solution":"def max_packages(n, h, packages): Calculate the maximum number of packages John can deliver in h hours. Parameters: n (int): Number of locations. h (int): Number of hours John can work in a day. packages (list of int): List of integers representing the number of packages at each location. Returns: int: Maximum number of packages John can deliver in h hours. # Sort the list of packages in descending order packages.sort(reverse=True) # Calculate the sum of the largest 'h' values in the sorted list return sum(packages[:h])"},{"question":"def evaluate_sales_team(sales: list[int], targets: list[int]) -> list[str]: This function determines the status of each salesperson based on their sales figures against their targets. Returns 'Successful' if the salesperson meets or exceeds the target, otherwise returns 'Unsuccessful'. >>> evaluate_sales_team([120, 80, 100, 150], [100, 90, 100, 140]) ['Successful', 'Unsuccessful', 'Successful', 'Successful'] >>> evaluate_sales_team([100, 200, 300], [50, 100, 150]) ['Successful', 'Successful', 'Successful'] >>> evaluate_sales_team([50, 60, 70], [80, 90, 100]) ['Unsuccessful', 'Unsuccessful', 'Unsuccessful'] >>> evaluate_sales_team([50, 75, 100], [50, 75, 100]) ['Successful', 'Successful', 'Successful'] >>> evaluate_sales_team([], []) []","solution":"def evaluate_sales_team(sales, targets): This function determines the status of each salesperson. Returns 'Successful' if the salesperson meets or exceeds the target, otherwise returns 'Unsuccessful'. :param sales: List of integers representing sales made by each salesperson. :param targets: List of integers representing sales targets for each salesperson. :return: List of strings indicating 'Successful' or 'Unsuccessful'. return ['Successful' if sales[i] >= targets[i] else 'Unsuccessful' for i in range(len(sales))]"},{"question":"def int_to_roman(num): Convert an integer to a Roman numeral. :param num: Integer value to convert to Roman numeral (1 <= num <= 3999) :type num: int :return: Roman numeral as a string representation of the integer :rtype: str >>> int_to_roman(3) 'III' >>> int_to_roman(1994) 'MCMXCIV' # Your code goes here pass","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :param num: Integer value to convert to Roman numeral (1 <= num <= 3999) :type num: int :return: Roman numeral as a string representation of the integer :rtype: str >>> int_to_roman(3) 'III' >>> int_to_roman(1994) 'MCMXCIV' val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"def find_indices(nums: List[int], target: int) -> Union[Tuple[int, int], None]: Given a list of integers and a target integer, returns the indices of the two numbers that add up to the target integer. >>> find_indices([2, 7, 11, 15], 9) (0, 1) >>> find_indices([3, 2, 4], 6) (1, 2) >>> find_indices([3, 3], 6) (0, 1) >>> find_indices([1, 2, 3, 4], 8) None >>> find_indices([-1, -2, -3, -4], -6) (1, 3) >>> find_indices([1, -2, 3, 4, 5], 3) (1, 4) >>> find_indices([5, 75, 25, 9, 14], 100) (1, 2) >>> find_indices([1, 1], 2) (0, 1)","solution":"def find_indices(nums, target): Given a list of integers and a target integer, returns the indices of the two numbers that add up to the target integer. num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return (num_dict[complement], i) num_dict[num] = i return None"},{"question":"def replace_elements(elements: List[int], threshold: int) -> List[str]: Replaces elements in the array based on the threshold. Args: elements (list of int): Array of integers. threshold (int): The threshold value. Returns: list: New array with elements replaced by 'above' or 'below' based on the threshold. Examples: >>> replace_elements([5, 3, 10, 1, 4], 4) #=> ['above', 'below', 'above', 'below', 'above'] >>> replace_elements([1, 2, 3], 4) #=> ['below', 'below', 'below'] >>> replace_elements([5, 6, 7], 4) #=> ['above', 'above', 'above'] >>> replace_elements([3, 4, 5], 4) #=> ['below', 'above', 'above'] >>> replace_elements([4, 4, 4], 4) #=> ['above', 'above', 'above'] >>> replace_elements([], 4) #=> [] >>> replace_elements([-1, -2, -3, 0], -2) #=> ['above', 'above', 'below', 'above']","solution":"def replace_elements(elements, threshold): Replaces elements in the array based on the threshold. Args: elements (list of int): Array of integers. threshold (int): The threshold value. Returns: list: New array with elements replaced by 'above' or 'below' based on the threshold. return ['above' if x >= threshold else 'below' for x in elements]"},{"question":"def dijkstra(graph: dict, start: any, end: any) -> tuple: Function to find the shortest path using Dijkstra's algorithm. Parameters: graph (dict): A dictionary representing the graph where keys are nodes and values are lists of tuples (neighbor, weight). start (any): The starting node. end (any): The destination node. Returns: tuple: A tuple containing the shortest distance and the path taken as a list. Example: >>> graph = { ... 'A': [('B', 1), ('C', 4)], ... 'B': [('A', 1), ('C', 2), ('D', 5)], ... 'C': [('A', 4), ('B', 2), ('D', 1)], ... 'D': [('B', 5), ('C', 1)] ... } >>> dijkstra(graph, 'A', 'D') (4, ['A', 'B', 'C', 'D'])","solution":"import heapq def dijkstra(graph: dict, start: any, end: any) -> tuple: Function to find the shortest path using Dijkstra's algorithm. Parameters: graph (dict): A dictionary representing the graph where keys are nodes and values are lists of tuples (neighbor, weight). start (any): The starting node. end (any): The destination node. Returns: tuple: A tuple containing the shortest distance and the path taken as a list. # Priority queue to hold nodes to be explored priority_queue = [(0, start, [])] # Dictionary to store the shortest known distance to each node distances = {start: 0} # Set of visited nodes to avoid cycles visited = set() while priority_queue: current_distance, current_node, path = heapq.heappop(priority_queue) # If we visit the end node, return the result if current_node == end: return current_distance, path + [current_node] # Skip visited nodes if current_node in visited: continue # Mark the current node as visited visited.add(current_node) path = path + [current_node] # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path)) return float('inf'), []"},{"question":"def is_alternating_case(word: str) -> str: Returns \\"YES\\" if the word alternates between uppercase and lowercase letters starting with a lowercase letter. Otherwise, returns \\"NO\\". >>> is_alternating_case(\\"aBcDeF\\") \\"YES\\" >>> is_alternating_case(\\"AbCdEf\\") \\"NO\\" >>> is_alternating_case(\\"aBcDe\\") \\"YES\\" >>> is_alternating_case(\\"aBCdEf\\") \\"NO\\" >>> is_alternating_case(\\"a\\") \\"YES\\" >>> is_alternating_case(\\"A\\") \\"NO\\" >>> is_alternating_case(\\"\\") \\"NO\\" >>> is_alternating_case(\\"abcdef\\") \\"NO\\" >>> is_alternating_case(\\"ABCDEF\\") \\"NO\\" >>> is_alternating_case(\\"aBcDeFgHiJkLmNoPqRsTuVwXyZ\\") \\"YES\\" >>> is_alternating_case(\\"aBcDeFgHiJkLmNoPqRsTuVwXyz\\") \\"NO\\"","solution":"def is_alternating_case(word): Returns \\"YES\\" if the word alternates between uppercase and lowercase letters starting with a lowercase letter. Otherwise, returns \\"NO\\". # Check if the string is empty if not word: return \\"NO\\" # Check if the string starts with lowercase if not word[0].islower(): return \\"NO\\" # Check alternating pattern for i in range(1, len(word)): if word[i].islower() == word[i-1].islower(): return \\"NO\\" return \\"YES\\""},{"question":"def rotate_string(s: str, k: int) -> str: Rotate the characters of a given string \`s\` by \`k\` positions to the right. >>> rotate_string(\\"abcdef\\", 2) # \\"efabcd\\" >>> rotate_string(\\"abcdef\\", 4) # \\"cdefab\\" >>> rotate_string(\\"abcdef\\", 6) # \\"abcdef\\" # Rotating by the length of the string results in the same string >>> rotate_string(\\"abcdef\\", 8) # \\"efabcd\\" # Equivalent to rotating by 2 positions (8 % 6) def test_rotate_string_basic(): assert rotate_string(\\"abcdef\\", 2) == \\"efabcd\\" def test_rotate_string_same_length(): assert rotate_string(\\"abcdef\\", 6) == \\"abcdef\\" def test_rotate_string_greater_than_length(): assert rotate_string(\\"abcdef\\", 8) == \\"efabcd\\" # Equivalent to rotating by 2 def test_rotate_string_with_zero(): assert rotate_string(\\"abcdef\\", 0) == \\"abcdef\\" def test_rotate_string_by_one(): assert rotate_string(\\"abcdef\\", 1) == \\"fabcde\\" def test_rotate_string_longer_than_length(): assert rotate_string(\\"hello\\", 7) == \\"lohel\\" # Equivalent to rotating by 2 def test_rotate_string_single_character(): assert rotate_string(\\"x\\", 10) == \\"x\\" # Any k on single character string should return the same string def test_rotate_string_full_rotation(): assert rotate_string(\\"world\\", 5) == \\"world\\" # Rotating by the length of the string def test_rotate_string_repeated_patterns(): assert rotate_string(\\"ababab\\", 2) == \\"ababab\\" # Rotating even repeated patterns by even number","solution":"def rotate_string(s: str, k: int) -> str: Rotate the characters of a given string \`s\` by \`k\` positions to the right. n = len(s) k = k % n # Handle cases where k is greater than length of string return s[-k:] + s[:-k]"},{"question":"def findTwoSum(nums, target): You are given an array of integers \`nums\` and an integer \`target\`. Your task is to return indices of any two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. The order of the indices does not matter for the output. Examples: >>> findTwoSum([2, 7, 11, 15], 9) (0, 1) >>> findTwoSum([-3, 4, 3, 90], 0) (0, 2) >>> findTwoSum([1, 2, 3, 4, 5], 8) (2, 4)","solution":"def findTwoSum(nums, target): Returns indices of the two numbers in \`nums\` that add up to the \`target\`. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None # In case no solution is found, though the problem guarantees one solution."},{"question":"def determine_winner(x: int) -> str: Determines the winner of the game given the initial integer x (2 ≤ x ≤ 10^9). Alice always goes first. They play optimally. :param x: Initial integer x :return: \\"Alice\\" if Alice wins, otherwise \\"Bob\\" >>> determine_winner(2) \\"Alice\\" >>> determine_winner(3) \\"Bob\\" >>> determine_winner(10) \\"Alice\\"","solution":"def determine_winner(x): Determines the winner of the game given the initial integer x (2 ≤ x ≤ 10^9). Alice always goes first. They play optimally. :param x: Initial integer x :return: \\"Alice\\" if Alice wins, otherwise \\"Bob\\" # If x is even, Alice can always subtract an odd divisor to eventually leave an odd number for Bob who will lose # If x is odd, Bob will win because Alice will have to subtract an odd number and leave an even one for Bob who can follow the same strategy if x % 2 == 1: return \\"Bob\\" else: return \\"Alice\\""},{"question":"from typing import List def min_subarray_length(arr: List[int], S: int) -> int: Returns the length of the smallest contiguous subarray, the sum of whose elements is greater than or equal to S. >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) == 2 >>> min_subarray_length([1, 4, 4], 4) == 1","solution":"from typing import List def min_subarray_length(arr: List[int], S: int) -> int: Returns the length of the smallest contiguous subarray, the sum of whose elements is greater than or equal to S. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= S: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"def wave_generator(text: str) -> list: Create a function that generates a wave-like list of strings from the input text. Each string in the list has exactly one character capitalized, moving from left to right, excluding spaces or punctuation from being capitalized. >>> wave_generator(\\"hello\\") ['Hello', 'hEllo', 'heLlo', 'helLo', 'hellO'] >>> wave_generator(\\"wave here\\") ['Wave here', 'wAve here', 'waVe here', 'wavE here', 'wave Here', 'wave hEre', 'wave heRe', 'wave herE'] from solution import wave_generator def test_wave_generator_basic(): assert wave_generator(\\"hello\\") == ['Hello', 'hEllo', 'heLlo', 'helLo', 'hellO'] def test_wave_generator_with_space(): assert wave_generator(\\"wave here\\") == [ 'Wave here', 'wAve here', 'waVe here', 'wavE here', 'wave Here', 'wave hEre', 'wave heRe', 'wave herE' ] def test_wave_generator_with_punctuation(): assert wave_generator(\\"he!llo\\") == ['He!llo', 'hE!llo', 'he!Llo', 'he!lLo', 'he!llO'] def test_wave_generator_with_only_punctuation(): assert wave_generator(\\"!!!\\") == [] def test_wave_generator_empty_string(): assert wave_generator(\\"\\") == []","solution":"def wave_generator(text): Creates a wave from the input text where each element in the list has one letter capitalized, moving from left to right, excluding spaces. Parameters: text (str): The input string to generate the wave from. Returns: list: A list of strings representing the wave. wave = [] for i in range(len(text)): if text[i].isalpha(): # Ensure we only capitalize alphabet characters wave.append(text[:i] + text[i].upper() + text[i + 1:]) return wave"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers \`nums\` and an integer \`target\`, return the indices of the two numbers such that they add up to target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] pass def test_two_sum_normal_case(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] def test_two_sum_with_duplicates(): assert two_sum([3, 3], 6) == [0, 1] def test_two_sum_middle_elements(): assert two_sum([3, 2, 4], 6) == [1, 2] def test_two_sum_large_numbers(): assert two_sum([10, 20, 30, 40, 50], 90) == [3, 4] def test_two_sum_negatives(): assert two_sum([-10, 20, 10, -20, 30], 0) == [0, 2] def test_two_sum_single_solution(): assert two_sum([1, 2, 3, 4, 5, 6], 11) == [4, 5]","solution":"def two_sum(nums, target): Given an array of integers \`nums\` and an integer \`target\`, return the indices of the two numbers such that they add up to target. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i"},{"question":"def most_frequent_word(s: str) -> str: Returns the word that appears the maximum number of times in the string. If there is a tie, it returns the word that appears first in the sequence. >>> most_frequent_word('cat dog dog bird cat dog cat') 'cat' >>> most_frequent_word('alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta') 'gamma'","solution":"def most_frequent_word(s): Returns the word that appears the maximum number of times in the string. If there is a tie, it returns the word that appears first in the sequence. words = s.split() word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 max_count = 0 max_word = None for word in words: if word_count[word] > max_count: max_count = word_count[word] max_word = word return max_word"},{"question":"import heapq from collections import Counter def rearrange_string(s: str, k: int) -> str: Rearrange the characters of the string s such that the same characters are at least k distance apart. :param s: string consisting of uppercase English letters :param k: integer that indicates the minimum distance apart for the same chars :return: rearranged string or empty string if not possible >>> rearrange_string(\\"AABB\\", 2) in [\\"ABAB\\", \\"BABA\\"] >>> rearrange_string(\\"AABBB\\", 2) == \\"BABAB\\" >>> rearrange_string(\\"ABCABC\\", 3) in [\\"ABCABC\\", \\"ACBABC\\", \\"CABACB\\", \\"BACBAC\\", \\"BCABCA\\", \\"BCAACB\\"] >>> rearrange_string(\\"AAAB\\", 2) == \\"\\" >>> rearrange_string(\\"AA\\", 2) == \\"\\" >>> rearrange_string(\\"AAAA\\", 3) == \\"\\" >>> rearrange_string(\\"AABB\\", 1) == \\"AABB\\" >>> rearrange_string(\\"A\\", 1) == \\"A\\" >>> rearrange_string(\\"AAA\\", 1) == \\"AAA\\" >>> rearrange_string(\\"A\\", 2) == \\"A\\" >>> rearrange_string(\\"B\\", 1) == \\"B\\" >>> rearrange_string(\\"AAA\\", 2) == \\"\\" >>> rearrange_string(\\"AAAA\\", 1) == \\"AAAA\\" >>> rearrange_string(\\"BBBBBBB\\", 3) == \\"\\"","solution":"import heapq from collections import Counter def rearrange_string(s, k): Rearrange the characters of the string s such that the same characters are at least k distance apart. :param s: string consisting of uppercase English letters :param k: integer that indicates the minimum distance apart for the same chars :return: rearranged string or empty string if not possible if k == 1: return s # If k is 1, no rearrangement needed. counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((freq + 1, char)) if len(wait_queue) >= k: front = wait_queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) return ''.join(result) if len(result) == len(s) else ''"},{"question":"def generate_invoice(customer_name: str, year: int, date: str, serial_number: int) -> str: Generates an invoice number based on customer name, year, date (MMDD format), and serial number. Args: customer_name (str): The name of the customer. year (int): The year in YYYY format. date (str): The date in MMDD format. serial_number (int): The unique serial number. Returns: str: The generated invoice number. Example: >>> generate_invoice(\\"JohnDoe\\", 2023, \\"0101\\", 12345) 'JohnDoe-20230101-12345' >>> generate_invoice(\\"AliceSmith\\", 2021, \\"1220\\", 6789) 'AliceSmith-20211220-6789' >>> generate_invoice(\\"JaneDoe\\", 2020, \\"0309\\", 45) 'JaneDoe-20200309-45'","solution":"def generate_invoice(customer_name, year, date, serial_number): Generates an invoice number based on customer name, year, date (MMDD format), and serial number. Args: customer_name (str): The name of the customer. year (int): The year in YYYY format. date (str): The date in MMDD format. serial_number (int): The unique serial number. Returns: str: The generated invoice number. return f\\"{customer_name}-{year}{date}-{serial_number}\\""},{"question":"def two_sum(arr: list, target: int) -> list: Returns the indices of the two numbers such that they add up to target. Parameters: arr (list): The list of integers. target (int): The target sum. Returns: list: List containing the indices of the two numbers adding up to the target. pass # Unit tests def test_example_case(): arr = [2, 7, 11, 15] target = 9 assert two_sum(arr, target) == [0, 1] def test_positive_numbers(): arr = [1, 2, 3, 4, 5] target = 9 assert two_sum(arr, target) == [3, 4] def test_negative_numbers(): arr = [-3, 4, 3, 90] target = 0 assert two_sum(arr, target) == [0, 2] def test_mixed_sign_numbers(): arr = [-10, 15, 7, -3] target = 5 assert two_sum(arr, target) == [0, 1] def test_same_element_twice(): arr = [3, 2, 4] target = 6 assert two_sum(arr, target) == [1, 2] def test_large_target(): arr = [1, 5, 11, 7] target = 18 assert two_sum(arr, target) == [2, 3]","solution":"def two_sum(arr, target): Returns the indices of the two numbers such that they add up to target. Parameters: arr (list): The list of integers. target (int): The target sum. Returns: list: List containing the indices of the two numbers adding up to the target. num_to_index = {} for index, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"class EventScheduler: def __init__(self): Initializes the EventScheduler. def schedule_event(self, date: str, description: str): Schedules a new event on the specified date with the given description. If there is already an event on that date, append the description to the existing event. >>> scheduler = EventScheduler() >>> scheduler.schedule_event('2024-12-25', 'Christmas Party') >>> scheduler.schedule_event('2024-12-25', 'Gift Exchange') >>> scheduler.view_event('2024-12-25') 'Christmas Party; Gift Exchange' def cancel_event(self, date: str): Cancels the event on the specified date. If there is no event on that date, raise a \`ValueError\`. >>> scheduler = EventScheduler() >>> scheduler.schedule_event('2024-12-25', 'Christmas Party') >>> scheduler.cancel_event('2024-12-25') >>> scheduler.view_event('2024-12-25') 'No event scheduled' def view_event(self, date: str): Returns the event description on the specified date. If there is no event on that date, return \\"No event scheduled\\". >>> scheduler = EventScheduler() >>> scheduler.view_event('2024-11-22') 'No event scheduled' def list_events(self): Returns a list of all scheduled events ordered by date in ascending order. >>> scheduler = EventScheduler() >>> scheduler.schedule_event('2024-12-25', 'Christmas Party') >>> scheduler.schedule_event('2025-01-01', 'New Year Celebration') >>> scheduler.list_events() [('2024-12-25', 'Christmas Party'), ('2025-01-01', 'New Year Celebration')]","solution":"class EventScheduler: def __init__(self): # Initialize an empty dictionary to store events self.events = {} def schedule_event(self, date, description): Schedules a new event on the specified date with the given description. If there is already an event on that date, append the description to the existing event. if date in self.events: self.events[date] += f\\"; {description}\\" else: self.events[date] = description def cancel_event(self, date): Cancels the event on the specified date. If there is no event on that date, raise a \`ValueError\`. if date in self.events: del self.events[date] else: raise ValueError(\\"No event to cancel\\") def view_event(self, date): Returns the event description on the specified date. If there is no event on that date, return \\"No event scheduled\\". return self.events.get(date, \\"No event scheduled\\") def list_events(self): Returns a list of all scheduled events ordered by date in ascending order. return sorted(self.events.items())"},{"question":"def max_triplet_sum(lst): Returns the largest sum that can be obtained by summing up exactly three of the integers in the list. If the list has fewer than three integers, returns \\"Not enough elements\\". >>> max_triplet_sum([2, 1, 3, 4]) # returns 9 >>> max_triplet_sum([3, 8, 1, -5, 6]) # returns 17 >>> max_triplet_sum([1, 2]) # returns \\"Not enough elements\\"","solution":"def max_triplet_sum(lst): Returns the largest sum that can be obtained by summing up exactly three of the integers in the list. If the list has fewer than three integers, returns \\"Not enough elements\\". if len(lst) < 3: return \\"Not enough elements\\" lst.sort(reverse=True) return sum(lst[:3])"},{"question":"from typing import List def run_length_encoding(s: str) -> str: Returns the run-length encoded version of the input string s. >>> run_length_encoding(\\"aabbbccccddd\\") == \\"a2b3c4d3\\" >>> run_length_encoding(\\"abc\\") == \\"a1b1c1\\" >>> run_length_encoding(\\"aaAAaA\\") == \\"a2A2a1A1\\" def test_run_length_encoding_single_char(): assert run_length_encoding(\\"a\\") == \\"a1\\" def test_run_length_encoding_all_unique_chars(): assert run_length_encoding(\\"abc\\") == \\"a1b1c1\\" def test_run_length_encoding_identical_chars(): assert run_length_encoding(\\"aaaaa\\") == \\"a5\\" def test_run_length_encoding_mixed_case(): assert run_length_encoding(\\"aaAAaA\\") == \\"a2A2a1A1\\" def test_run_length_encoding_regular_case(): assert run_length_encoding(\\"aabbbccccddd\\") == \\"a2b3c4d3\\" def test_run_length_encoding_empty_string(): assert run_length_encoding(\\"\\") == \\"\\" def test_run_length_encoding_alternating_chars(): assert run_length_encoding(\\"ababab\\") == \\"a1b1a1b1a1b1\\"","solution":"def run_length_encoding(s: str) -> str: Returns the run-length encoded version of the input string s. if not s: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: encoded_str.append(f\\"{s[i-1]}{count}\\") count = 1 # Append the last run encoded_str.append(f\\"{s[-1]}{count}\\") return ''.join(encoded_str)"},{"question":"from typing import List def find_median(numbers: List[int]) -> int: Returns the median of a list of integers. The list will always contain an odd number of elements. Examples: >>> find_median([1, 3, 4, 2, 5]) 3 >>> find_median([7, 1, 5, 3, 9]) 5 >>> find_median([99, -2, 56, 100, 4]) 56 >>> find_median([42]) 42 >>> find_median([1, 1000, 500, -100, 50]) 50","solution":"def find_median(numbers): Returns the median of a list of integers. The list will always contain an odd number of elements. sorted_numbers = sorted(numbers) middle_index = len(sorted_numbers) // 2 return sorted_numbers[middle_index]"},{"question":"def calculate_expense_percentages(test_cases): Calculate the percentage of total expenses for each category rounded to 2 decimal places. Parameters: test_cases (list): A list of test case dictionaries. Each dictionary contains: - 'n' (int): Number of expense records. - 'expenses' (list of tuples): List of expense records, each represented by a tuple (amount, category). Returns: list of tuples: A list of tuples where each tuple represents a category and its percentage of total expenses, rounded to 2 decimal places. Example: >>> calculate_expense_percentages( [ { 'n': 5, 'expenses': [ (200, 'Food'), (100, 'Transport'), (300, 'Food'), (400, 'Entertainment'), (100, 'Transport') ] } ] ) [('Food', 45.45), ('Transport', 18.18), ('Entertainment', 36.36)] # Implement your solution here from solution import calculate_expense_percentages def test_single_case(): test_cases = [ { 'n': 5, 'expenses': [ (200, 'Food'), (100, 'Transport'), (300, 'Food'), (400, 'Entertainment'), (100, 'Transport') ] } ] result = calculate_expense_percentages(test_cases) expected = [('Food', 45.45), ('Transport', 18.18), ('Entertainment', 36.36)] assert result == expected def test_multiple_cases(): test_cases = [ { 'n': 5, 'expenses': [ (200, 'Food'), (100, 'Transport'), (300, 'Food'), (400, 'Entertainment'), (100, 'Transport') ] }, { 'n': 3, 'expenses': [ (150, 'Groceries'), (200, 'Rent'), (150, 'Groceries') ] }, { 'n': 2, 'expenses': [ (500, 'Utilities'), (500, 'Utilities') ] } ] result = calculate_expense_percentages(test_cases) expected = [ ('Food', 45.45), ('Transport', 18.18), ('Entertainment', 36.36), ('Groceries', 60.00), ('Rent', 40.00), ('Utilities', 100.00) ] assert result == expected def test_single_expense_multiple_occurrences(): test_cases = [ { 'n': 2, 'expenses': [ (500, 'Utilities'), (500, 'Utilities') ] } ] result = calculate_expense_percentages(test_cases) expected = [('Utilities', 100.00)] assert result == expected def test_single_expense_single_occurrence(): test_cases = [ { 'n': 1, 'expenses': [ (500, 'Utilities') ] } ] result = calculate_expense_percentages(test_cases) expected = [('Utilities', 100.00)] assert result == expected def test_several_categories(): test_cases = [ { 'n': 6, 'expenses': [ (100, 'A'), (100, 'B'), (100, 'A'), (100, 'B'), (100, 'A'), (100, 'B') ] } ] result = calculate_expense_percentages(test_cases) expected = [('A', 50.00), ('B', 50.00)] assert result == expected","solution":"def calculate_expense_percentages(test_cases): results = [] for case in test_cases: n = case['n'] expenses = case['expenses'] category_totals = {} total_expense = 0 for amount, category in expenses: if category not in category_totals: category_totals[category] = 0 category_totals[category] += amount total_expense += amount for category in category_totals: percentage = (category_totals[category] / total_expense) * 100 results.append((category, round(percentage, 2))) return results"},{"question":"def filter_even(lst): Returns a list of even numbers >>> filter_even([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> filter_even([]) [] def string_lengths(lst): Returns lengths of each string in the list >>> string_lengths(['hello', 'world']) [5, 5] >>> string_lengths([]) [] def concat_strings(lst): Concatenates a list of strings with a space >>> concat_strings(['hello', 'world']) 'hello world' >>> concat_strings([]) ''","solution":"def filter_even(lst): Returns a list of even numbers :param lst: List of integers :return: List of even integers return [num for num in lst if num % 2 == 0] def string_lengths(lst): Returns lengths of each string in the list :param lst: List of strings :return: List of lengths of the strings return [len(s) for s in lst] def concat_strings(lst): Concatenates a list of strings with a space :param lst: List of strings :return: A single concatenated string return \\" \\".join(lst)"},{"question":"def letterFrequency(s: str) -> dict: Returns a dictionary where the keys are the letters from the string and the values are the number of times each letter appears in the string. The function is case-insensitive and ignores non-alphabetical characters. >>> letterFrequency(\\"Hello, World!\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> letterFrequency(\\"Python Programming!\\") == {'p': 2, 'y': 1, 't': 1, 'h': 1, 'o': 2, 'n': 2, 'r': 2, 'g': 2, 'a': 1, 'm': 2, 'i': 1} pass from solution import letterFrequency def test_letter_frequency_simple(): assert letterFrequency(\\"Hello\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} def test_letter_frequency_with_case_insensitivity(): assert letterFrequency(\\"HeLLo\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} def test_letter_frequency_with_non_alphabetical_chars(): assert letterFrequency(\\"Hello, World!\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} def test_letter_frequency_complex(): assert letterFrequency(\\"Python Programming!\\") == {'p': 2, 'y': 1, 't': 1, 'h': 1, 'o': 2, 'n': 2, 'r': 2, 'g': 2, 'a': 1, 'm': 2, 'i': 1} def test_letter_frequency_empty_string(): assert letterFrequency(\\"\\") == {} def test_letter_frequency_long_string(): assert letterFrequency(\\"A\\" * 1000 + \\"b\\" * 1000) == {'a': 1000, 'b': 1000}","solution":"def letterFrequency(s): Returns a dictionary with the frequency of each letter in the string. The function is case-insensitive and ignores non-alphabetical characters. frequency = {} s = s.lower() for char in s: if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def count_palindromic_substrings(s: str) -> int: Count the number of non-empty substrings of s that are palindromes. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 pass def test_single_character_string(): assert count_palindromic_substrings(\\"a\\") == 1 def test_two_different_characters(): assert count_palindromic_substrings(\\"ab\\") == 2 def test_two_same_characters(): assert count_palindromic_substrings(\\"aa\\") == 3 def test_no_palindromic_substrings(): assert count_palindromic_substrings(\\"abc\\") == 3 def test_all_characters_same(): assert count_palindromic_substrings(\\"aaa\\") == 6 def test_mixed_palindromes(): assert count_palindromic_substrings(\\"aabaa\\") == 9 def test_longer_string(): assert count_palindromic_substrings(\\"racecar\\") == 10 def test_repeating_patterns(): assert count_palindromic_substrings(\\"abababa\\") == 16","solution":"def count_palindromic_substrings(s): n = len(s) count = 0 # Function to expand around the center def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 # Consider each character and each pair of consecutive characters as centers for i in range(n): expand_around_center(i, i) # odd length palindromes expand_around_center(i, i + 1) # even length palindromes return count"},{"question":"def dropped_requests(m: int, n: int) -> int: Returns the number of requests that will be dropped every second. Parameters: m (int): Number of servers. n (int): Number of requests per second. Returns: int: Number of requests dropped per second. Example Usage: >>> dropped_requests(3, 5) 2 >>> dropped_requests(4, 4) 0","solution":"def dropped_requests(m, n): Returns the number of requests that will be dropped every second. Parameters: m (int): Number of servers. n (int): Number of requests per second. Returns: int: Number of requests dropped per second. if n <= m: return 0 else: return n - m"},{"question":"def is_palindromic_street_name(street_name: str) -> bool: Returns True if the street name is a palindrome, False otherwise. >>> is_palindromic_street_name('level') True >>> is_palindromic_street_name('madam') True >>> is_palindromic_street_name('street') False >>> is_palindromic_street_name('racecar') True >>> is_palindromic_street_name('abcba') True >>> is_palindromic_street_name('hello') False","solution":"def is_palindromic_street_name(street_name): Returns True if the street name is a palindrome, False otherwise. return street_name == street_name[::-1]"},{"question":"def invite_buildings(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determines invited buildings based on the IDs and step value K for each test case. Args: t : int : number of test cases test_cases : list : list of tuples, each containing: - N : int : total number of buildings - K : int : step value - ids : list : list of building IDs in the order they are numbered Returns: list : list of strings : each string contains invited building IDs for the corresponding test case","solution":"def invite_buildings(t, test_cases): Determines invited buildings based on the IDs and step value K for each test case. Args: t : int : number of test cases test_cases : list : list of tuples, each containing: - N : int : total number of buildings - K : int : step value - ids : list : list of building IDs in the order they are numbered Returns: list : list of strings : each string contains invited building IDs for the corresponding test case result = [] for case in test_cases: N, K, ids = case invited = [ids[i] for i in range(0, N, K)] result.append(\\" \\".join(map(str, invited))) return result # Example usage: t = 2 test_cases = [ (5, 2, [3, 1, 4, 5, 2]), (6, 3, [6, 3, 2, 1, 4, 5]) ] print(invite_buildings(t, test_cases)) # Output: [\\"3 4 2\\", \\"6 1\\"]"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an integer array nums, return an array where each element at index i is the product of all the numbers in the array except nums[i]. This function solves the problem without using division and in O(n) time complexity, using constant extra space (excluding the output array). >>> product_except_self([1, 2, 3, 4]) -> [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) -> [60, 40, 30, 24] >>> product_except_self([1, 0, 3, 4]) -> [0, 12, 0, 0]","solution":"def product_except_self(nums): Given an integer array nums, return an array where each element at index i is the product of all the numbers in the array except nums[i]. This function solves the problem without using division and in O(n) time complexity, using constant extra space (excluding the output array). n = len(nums) result = [1] * n # Calculate prefix products prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product *= nums[i] # Calculate suffix products and multiply with prefix products suffix_product = 1 for i in range(n-1, -1, -1): result[i] *= suffix_product suffix_product *= nums[i] return result"},{"question":"from collections import deque, defaultdict from typing import List def min_subway_lines(lines: List[List[int]], S: int, D: int) -> int: Determine the least number of subway lines needed to travel from station S to station D. >>> min_subway_lines([[1, 3, 5, 7], [2, 3, 6, 8], [1, 5, 9]], 1, 8) 2 >>> min_subway_lines([[1, 2, 3], [4, 5, 6]], 1, 4) -1 >>> min_subway_lines([[1, 2, 3, 4], [2, 5, 6, 7]], 3, 7) 2","solution":"from collections import deque, defaultdict def min_subway_lines(lines, S, D): if S == D: return 0 station_to_lines = defaultdict(set) for idx, line in enumerate(lines): for station in line: station_to_lines[station].add(idx) queue = deque([(S, 0)]) visited_stations = set([S]) visited_lines = set() while queue: station, transfers = queue.popleft() for line in station_to_lines[station]: if line in visited_lines: continue visited_lines.add(line) for next_station in lines[line]: if next_station == D: return transfers + 1 if next_station not in visited_stations: visited_stations.add(next_station) queue.append((next_station, transfers + 1)) return -1"},{"question":"def triangle_pattern(n: int) -> str: Generates a triangle pattern based on the given integer n. Args: n: An integer Returns: A string representing the triangle pattern. Returns an empty string if n <= 3. Examples: >>> triangle_pattern(4) '1n12n123' >>> triangle_pattern(6) '1n12n123n1234n12345'","solution":"def triangle_pattern(n): Generates a triangle pattern based on the given integer n. Args: n: An integer Returns: A string representing the triangle pattern. Returns an empty string if n <= 3. if n <= 3: return \\"\\" lines = [] for i in range(1, n): lines.append(\\"\\".join(str(x) for x in range(1, i+1))) return \\"n\\".join(lines)"},{"question":"def remove_consecutive_duplicates(s: str) -> str: Removes consecutive duplicate characters from the given string \`s\`. It is case-sensitive. Parameters: s (str): Input string of alphabets. Returns: str: String with consecutive duplicates removed. >>> remove_consecutive_duplicates(\\"aabbccdd\\") \\"abcd\\" >>> remove_consecutive_duplicates(\\"abABabAB\\") \\"abABabAB\\" >>> remove_consecutive_duplicates(\\"AAAaaaBBBccc\\") \\"AaBc\\"","solution":"def remove_consecutive_duplicates(s): Removes consecutive duplicate characters from the given string \`s\`. It is case-sensitive. Parameters: s (str): Input string of alphabets. Returns: str: String with consecutive duplicates removed. if not s: return s result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return ''.join(result)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression consisting of positive integers, '+', '*', and parentheses. :param expression: str, a string representing the mathematical expression :return: int, the result of the evaluated expression >>> evaluate_expression(\\"1+2\\") == 3 >>> evaluate_expression(\\"2*3\\") == 6 >>> evaluate_expression(\\"1+2*3\\") == 7 >>> evaluate_expression(\\"2*(3+4)\\") == 14 >>> evaluate_expression(\\"2*(3+(2*2))\\") == 14 >>> evaluate_expression(\\"2*(3+(2*2))*3\\") == 42 >>> evaluate_expression(\\"42\\") == 42","solution":"def evaluate_expression(expression): Evaluates a mathematical expression consisting of positive integers, '+', '*', and parentheses. :param expression: str, a string representing the mathematical expression :return: int, the result of the evaluated expression def helper(s, index): stack = [] num = 0 sign = \\"+\\" while index < len(s): ch = s[index] if ch.isdigit(): num = num * 10 + int(ch) if ch == '(': num, index = helper(s, index + 1) if ch in \\"+*)\\" or index == len(s) - 1: if sign == '+': stack.append(num) elif sign == '*': stack[-1] = stack[-1] * num if ch == ')': return sum(stack), index sign = ch num = 0 index += 1 return sum(stack), index return helper(expression, 0)[0]"},{"question":"def min_jumps_to_cross_river(stones): Given an array of integers representing the stepping stones, returns the minimum number of jumps needed to reach the last stone, or -1 if it is impossible. >>> min_jumps_to_cross_river([2, 3, 1, 1, 4, 0]) 3 >>> min_jumps_to_cross_river([3, 2, 1, 0, 4]) -1 >>> min_jumps_to_cross_river([0]) 0 >>> min_jumps_to_cross_river([1, 0]) 1 >>> min_jumps_to_cross_river([1000] * 1000) 1 >>> min_jumps_to_cross_river([1] * 1000) 999 >>> min_jumps_to_cross_river([10, 20, 30, 40, 50]) 1 >>> min_jumps_to_cross_river([0, 1, 1, 1, 1]) -1 >>> min_jumps_to_cross_river([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) 3","solution":"def min_jumps_to_cross_river(stones): Given an array of integers representing the stepping stones, returns the minimum number of jumps needed to reach the last stone, or -1 if it is impossible. n = len(stones) if n == 1: return 0 max_reach = 0 # The farthest point that can be reached jump_count = 0 # Count of jumps needed to reach the farthest point current_end = 0 # End of the range that can currently be reached with the current jump count for i in range(n): if i > max_reach: return -1 # If the current position is beyond the farthest reachable point, it's impossible # Update the farthest point that can be reached max_reach = max(max_reach, i + stones[i]) if i == current_end: # When reaching the end of the current reachable range if current_end != n-1: # If not yet at the last stone jump_count += 1 current_end = max_reach if current_end >= n-1: # If the farthest reach exceeds or meets the last stone break return jump_count if current_end >= n-1 else -1"},{"question":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: Move from the top-left corner of the grid to the bottom-right corner, collecting numbers from the cells along the way to maximize the total sum. You are only allowed to move right or down at each step. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_path_sum(grid) 29 >>> grid = [[5]] >>> max_path_sum(grid) 5 >>> grid = [ ... [1, 2], ... [1, 3] ... ] >>> max_path_sum(grid) 6 >>> grid = [ ... [1, 100, 1], ... [1, 1, 100], ... [100, 1, 1] ... ] >>> max_path_sum(grid) 203 >>> N = 1000 >>> grid = [[1] * N for _ in range(N)] >>> max_path_sum(grid) 1999 pass","solution":"def max_path_sum(grid): n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1] # Reading input from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) grid = [] index = 1 for i in range(N): row = list(map(int, data[index:index + N])) grid.append(row) index += N print(max_path_sum(grid))"},{"question":"def generate_product_list(x: int, y: int, n: int) -> list: Generates a list of n integers where each integer is equal to the product of x and y. :param x: First integer. :param y: Second integer. :param n: Number of times to repeat the product of x and y in a list. :return: A list of n integers, each being the product of x and y. >>> generate_product_list(4, 2, 5) [8, 8, 8, 8, 8] >>> generate_product_list(3, 3, 0) [] >>> generate_product_list(0, 2, 3) [0, 0, 0] >>> generate_product_list(5, 2, 1) [10] >>> generate_product_list(-3, 2, 4) [-6, -6, -6, -6] >>> generate_product_list(3, -2, 4) [-6, -6, -6, -6] >>> generate_product_list(-3, -2, 4) [6, 6, 6, 6]","solution":"def generate_product_list(x, y, n): Generates a list of n integers where each integer is equal to the product of x and y. :param x: First integer. :param y: Second integer. :param n: Number of times to repeat the product of x and y in a list. :return: A list of n integers, each being the product of x and y. product = x * y return [product] * n"},{"question":"def perform_operations(n: int, operations: List[List[int]]) -> List[List[int]]: Perform a series of operations on an n x n grid where each operation increments the values of all cells in a given rectangle by 1. The rectangle is defined by its top-left and bottom-right corners. Args: n (int): The size of the grid. operations (List[List[int]]): A list of operations, where each operation is represented as a list of four integers [x1, y1, x2, y2]. Returns: List[List[int]]: The grid after all operations have been performed. >>> perform_operations(3, [[0, 0, 1, 1], [1, 1, 2, 2]]) [[1, 1, 0], [1, 2, 1], [0, 1, 1]] >>> perform_operations(4, [[1, 1, 3, 3], [0, 0, 2, 2], [2, 2, 3, 3]]) [[1, 1, 1, 0], [1, 2, 2, 1], [1, 2, 3, 2], [0, 1, 2, 1]]","solution":"def perform_operations(n, operations): # Initialize the grid with zeros grid = [[0] * n for _ in range(n)] # Perform each operation for x1, y1, x2, y2 in operations: for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): grid[i][j] += 1 return grid"},{"question":"def solve(arr: List[int]) -> int: Returns the smallest integer that is not present in the list and is larger than all the integers in the list. :param arr: List of sorted, unique integers :return: Smallest integer not present and larger than the largest integer in arr >>> solve([1, 2, 3, 6, 7, 9]) 10 >>> solve([1, 2, 3, 4, 5]) 6 >>> solve([100, 101, 102]) 103 >>> solve([]) 1 >>> solve([-3, -2, -1]) 0 >>> solve([0]) 1 >>> solve([5]) 6 >>> solve([-1]) 0 >>> solve(list(range(1, 100))) 100 >>> solve(list(range(-50, 50))) 50","solution":"def solve(arr): Returns the smallest integer that is not present in the list and is larger than all the integers in the list. :param arr: List of sorted, unique integers :return: Smallest integer not present and larger than the largest integer in arr if not arr: return 1 return max(arr) + 1"},{"question":"def find_intersection(set1, set2): Write a function that calculates the intersection of two given sets of coordinates represented by two lists of tuples. Each tuple contains two elements representing the x and y coordinates. The result should be a list of tuples with coordinates that appear in both sets. Parameters: set1 (list of tuples): First set of coordinates. set2 (list of tuples): Second set of coordinates. Returns: list of tuples: Coordinates that appear in both sets. >>> find_intersection([(1, 2), (3, 4), (5, 6)], [(3, 4), (5, 6), (7, 8)]) [(3, 4), (5, 6)] >>> find_intersection([(1, 2)], [(3, 4)]) [] >>> find_intersection([(1, 2), (3, 4)], [(1, 2), (3, 4)]) [(1, 2), (3, 4)] >>> find_intersection([], [(3, 4), (5, 6)]) [] >>> find_intersection([(1, 2), (3, 4)], []) [] >>> find_intersection([], []) []","solution":"def find_intersection(set1, set2): Returns the intersection of two sets of coordinates. Each input is a list of tuples (x, y). Parameters: set1 (list of tuples): First set of coordinates. set2 (list of tuples): Second set of coordinates. Returns: list of tuples: Coordinates that appear in both sets. # Convert lists to sets to leverage set intersection set1 = set(set1) set2 = set(set2) # Find intersection intersection = set1.intersection(set2) # Convert the result back to a list return list(intersection)"},{"question":"from collections import defaultdict def aggregate_notifications(N: int, employees: List[Tuple[str, str]], M: int, notifications: List[Tuple[str, str]]) -> Dict[str, List[str]]: Aggregates notifications into departments based on employee IDs. >>> N = 3 >>> employees = [('E101', 'Sales'), ('E102', 'HR'), ('E103', 'Sales')] >>> M = 5 >>> notifications = [ ... ('E101', 'Meeting at 3 PM'), ... ('E103', 'Report deadline'), ... ('E102', 'New HR policy'), ... ('E101', 'Lunch at 12 PM'), ... ('E103', 'Quarterly results') ... ] >>> aggregate_notifications(N, employees, M, notifications) {'Sales': ['Meeting at 3 PM', 'Report deadline', 'Lunch at 12 PM', 'Quarterly results'], 'HR': ['New HR policy']} >>> aggregate_notifications(0, [], 0, []) {} pass def format_output(dept_messages: Dict[str, List[str]]) -> str: Formats the aggregated notifications into the required string output. >>> dept_messages = { ... 'Sales': ['Meeting at 3 PM', 'Report deadline', 'Lunch at 12 PM', 'Quarterly results'], ... 'HR': ['New HR policy'] ... } >>> format_output(dept_messages) Sales 4 Meeting at 3 PM Report deadline Lunch at 12 PM Quarterly results HR 1 New HR policy >>> format_output({}) '' pass def test_aggregate_notifications(): N = 3 employees = [('E101', 'Sales'), ('E102', 'HR'), ('E103', 'Sales')] M = 5 notifications = [ ('E101', 'Meeting at 3 PM'), ('E103', 'Report deadline'), ('E102', 'New HR policy'), ('E101', 'Lunch at 12 PM'), ('E103', 'Quarterly results') ] expected_output = { 'Sales': ['Meeting at 3 PM', 'Report deadline', 'Lunch at 12 PM', 'Quarterly results'], 'HR': ['New HR policy'] } result = aggregate_notifications(N, employees, M, notifications) assert result == expected_output def test_aggregate_notifications_no_messages(): N = 3 employees = [('E101', 'Sales'), ('E102', 'HR'), ('E103', 'Sales')] M = 0 notifications = [] expected_output = {} result = aggregate_notifications(N, employees, M, notifications) assert result == expected_output def test_format_output(): dept_messages = { 'Sales': ['Meeting at 3 PM', 'Report deadline', 'Lunch at 12 PM', 'Quarterly results'], 'HR': ['New HR policy'] } expected_output = ( \\"Salesn\\" + \\"4n\\" + \\"Meeting at 3 PMn\\" + \\"Report deadlinen\\" + \\"Lunch at 12 PMn\\" + \\"Quarterly resultsn\\" + \\"HRn\\" + \\"1n\\" + \\"New HR policy\\" ) result = format_output(dept_messages) assert result == expected_output def test_format_output_no_depts(): dept_messages = {} expected_output = \\"\\" result = format_output(dept_messages) assert result == expected_output","solution":"def aggregate_notifications(N, employees, M, notifications): Aggregates notifications into departments based on employee IDs. Parameters: N (int): Number of employees. employees (list): List of tuples where each tuple contains employee ID and department. M (int): Number of notifications. notifications (list): List of tuples where each tuple contains employee ID and message. Returns: dict: Dictionary where key is the department name and value is a list of messages. from collections import defaultdict emp_to_dept = {} dept_messages = defaultdict(list) # Map employee IDs to departments for emp_id, dept in employees: emp_to_dept[emp_id] = dept # Aggregate messages to respective departments for emp_id, message in notifications: department = emp_to_dept[emp_id] dept_messages[department].append(message) return dept_messages def format_output(dept_messages): result = [] for dept, messages in dept_messages.items(): result.append(dept) result.append(str(len(messages))) result.extend(messages) return \\"n\\".join(result)"},{"question":"def min_difference_partition(tasks: List[int]) -> int: You have a list of tasks you need to accomplish, each with a specific duration. You've decided to divide these tasks into two groups to be completed by two coworkers such that the difference in the total duration between the two groups is minimized. Args: tasks (List[int]): List of task durations. Returns: int: The minimum possible difference between the two groups' total duration times. >>> min_difference_partition([5, 3, 8, 1, 4, 2]) 1 >>> min_difference_partition([7]) 7 >>> min_difference_partition([5, 5]) 0 >>> min_difference_partition([5, 3]) 2 >>> min_difference_partition([1, 1, 1, 1, 1, 1]) 0 >>> min_difference_partition([100, 200, 300, 400, 500]) 100 >>> min_difference_partition([1, 2, 3, 9]) 3 >>> min_difference_partition([]) 0","solution":"def min_difference_partition(tasks): S = sum(tasks) n = len(tasks) dp = [False] * (S//2 + 1) dp[0] = True for task in tasks: for j in range(S//2, task - 1, -1): dp[j] = dp[j] or dp[j - task] for j in range(S//2, -1, -1): if dp[j]: return S - 2 * j"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the string s can be rearranged to form a palindrome. A palindrome is a word that reads the same backward as forward. >>> can_form_palindrome(\\"code\\") False >>> can_form_palindrome(\\"aab\\") True >>> can_form_palindrome(\\"carerac\\") True from collections import Counter def test_single_character(): assert can_form_palindrome(\\"a\\") == True def test_even_characters_palindrome(): assert can_form_palindrome(\\"aabbcc\\") == True def test_odd_characters_one_odd(): assert can_form_palindrome(\\"aabbccd\\") == True def test_odd_characters_multiple_odds(): assert can_form_palindrome(\\"aabbccde\\") == False def test_no_possible_palindrome(): assert can_form_palindrome(\\"abcde\\") == False def test_all_identical_characters(): assert can_form_palindrome(\\"aaaaa\\") == True def test_mixed_characters_palindrome_possible(): assert can_form_palindrome(\\"aab\\") == True def test_long_palindrome_possible(): assert can_form_palindrome(\\"carerac\\") == True def test_long_palindrome_not_possible(): assert can_form_palindrome(\\"carraceb\\") == False def test_empty_string(): assert can_form_palindrome(\\"\\") == True # A bizarre edge case.","solution":"from collections import Counter def can_form_palindrome(s): Determines if the string s can be rearranged to form a palindrome. # Count the frequency of each character in the string char_count = Counter(s) # Count characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"def first_non_repeated_character(s: str) -> str: Create a function that takes a string and returns the first non-repeated character. If there is no such character, return an empty string. >>> first_non_repeated_character(\\"swiss\\") \\"w\\" >>> first_non_repeated_character(\\"aabbcc\\") \\"\\" >>> first_non_repeated_character(\\"alphabet\\") \\"l\\"","solution":"def first_non_repeated_character(s): Returns the first non-repeated character in the string s. If there is no such character, returns an empty string. # Dictionary to store count of each character char_count = {} # Iterate through the string and count characters for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Iterate through the string again to find the first non-repeated character for char in s: if char_count[char] == 1: return char # If no non-repeated character is found, return an empty string return \\"\\""},{"question":"def min_delivery_vehicles(n, k, capacities, weights): Determine the minimum number of delivery vehicles needed to deliver all packages. Each vehicle can only make one trip and must not exceed its maximum capacity. Return -1 if it is not possible to deliver all packages. Args: n (int): The number of vehicles. k (int): The number of packages. capacities (List[int]): The list of maximum capacities of the vehicles. weights (List[int]): The list of weights of the packages. Returns: int: The minimum number of vehicles needed, or -1 if not possible. Example: >>> min_delivery_vehicles(3, 4, [10, 15, 20], [5, 12, 8, 6]) 2 >>> min_delivery_vehicles(2, 3, [5, 5], [6, 6, 6]) -1","solution":"def min_delivery_vehicles(n, k, capacities, weights): weights.sort(reverse=True) # Sort weights in descending order capacities.sort(reverse=True) # Sort capacities in descending order if weights[0] > capacities[0]: return -1 vehicles_used = 0 while weights: vehicles_used += 1 current_capacity = capacities.pop(0) # Take the largest available vehicle capacity new_weights = [] for weight in weights: if weight <= current_capacity: current_capacity -= weight else: new_weights.append(weight) weights = new_weights return vehicles_used"},{"question":"def find_anagrams(array1: List[str], array2: List[str]) -> List[str]: Returns a new array containing only the strings that are anagrams of each other from the two input arrays. The output array has no duplicate strings and is sorted in alphabetical order. >>> find_anagrams([\\"listen\\", \\"triangle\\", \\"apple\\", \\"silent\\"], [\\"enlist\\", \\"integral\\", \\"banana\\", \\"paw\\"]) [\\"enlist\\", \\"integral\\", \\"listen\\", \\"silent\\", \\"triangle\\"] >>> find_anagrams([\\"a\\", \\"b\\", \\"c\\"], [\\"d\\", \\"e\\", \\"f\\"]) [] >>> find_anagrams([\\"listen\\", \\"listen\\", \\"apple\\"], [\\"silent\\", \\"enlist\\"]) [\\"enlist\\", \\"listen\\", \\"silent\\"] >>> find_anagrams([\\"aAb\\", \\"abc\\"], [\\"bAa\\", \\"cab\\"]) [\\"aAb\\", \\"abc\\", \\"bAa\\", \\"cab\\"] >>> find_anagrams([\\"dormitory\\", \\"dirtyroom\\"], [\\"dirtyroom\\", \\"dormitory\\"]) [\\"dirtyroom\\", \\"dormitory\\"]","solution":"def find_anagrams(array1, array2): Returns a sorted array of unique strings that are anagrams of each other from the two input arrays. def is_anagram(str1, str2): return sorted(str1) == sorted(str2) result = set() for word1 in array1: for word2 in array2: if is_anagram(word1, word2): result.add(word1) result.add(word2) return sorted(result)"},{"question":"from typing import List, Tuple def minimum_difference_partition(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given a list of integers, and you need to divide this list into two non-empty subsets such that the absolute difference between the sums of the elements in those subsets is minimized. Write a function that returns the minimum possible absolute difference. Note: The input format is slightly different for testing purposes. Input: - The first line contains an integer T, denoting the number of test cases. - The first line of each test case contains an integer n, the size of the list. - The second line contains n integers, the elements of the list. Output: For each test case, output a single integer representing the minimum possible absolute difference. Constraints: - 1 ≤ T ≤ 10 - 2 ≤ n ≤ 20 - 1 ≤ elements of the list ≤ 1000 Examples: >>> minimum_difference_partition(2, [(3, [1, 6, 11]), (4, [1, 2, 3, 9])]) [4, 3] >>> minimum_difference_partition(1, [(5, [3, 1, 4, 2, 2])]) [0]","solution":"from itertools import combinations def minimum_difference_partition(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] elements = test_cases[i][1] total_sum = sum(elements) min_diff = float('inf') # Generate all possible subsets for r in range(1, n): for subset in combinations(elements, r): subset_sum = sum(subset) diff = abs(total_sum - 2 * subset_sum) min_diff = min(min_diff, diff) results.append(min_diff) return results"},{"question":"def generate_pattern(N): Generates the exercise pattern based on input number N. >>> generate_pattern(1) ['A'] >>> generate_pattern(2) ['A', 'ABA'] >>> generate_pattern(3) ['A', 'ABA', 'ABCBA'] >>> generate_pattern(4) ['A', 'ABA', 'ABCBA', 'ABCDCBA'] pass def solve_exercise_patterns(test_cases): Solves multiple exercise patterns for given test cases. >>> solve_exercise_patterns([1, 2]) ['A', 'A', 'ABA'] >>> solve_exercise_patterns([2, 3]) ['A', 'ABA', 'A', 'ABA', 'ABCBA'] >>> solve_exercise_patterns([4]) ['A', 'ABA', 'ABCBA', 'ABCDCBA'] pass","solution":"def generate_pattern(N): Generates the exercise pattern based on input number N start_char = 'A' end_char = chr(ord(start_char) + N - 1) pattern = [] for i in range(N): part = [] # Add the initial increasing part part.extend([chr(ord(start_char) + j) for j in range(i + 1)]) # Add the decreasing part part.extend([chr(ord(start_char) + j) for j in range(i + 1)][::-1][1:]) pattern.append(''.join(part)) return pattern def solve_exercise_patterns(test_cases): results = [] for N in test_cases: results.extend(generate_pattern(N)) return results"},{"question":"from typing import List def min_distinct_sum(arr: List[int], k: int) -> int: Returns the smallest number of distinct integers from the list such that their sum is greater than or equal to k. >>> min_distinct_sum([3, 7, 2, 5, 8, -1], 10) == 2 >>> min_distinct_sum([1, 2, 3, 4, 5], 15) == 5 >>> min_distinct_sum([0, 0, 0, 0, 10], 10) == 1 >>> min_distinct_sum([], 10) == -1 >>> min_distinct_sum([1, 2, 3], 10) == -1 >>> min_distinct_sum([1, 2, 3, 10, 20], 22) == 2 >>> min_distinct_sum([1, 1, 2, 2, 3, 3, 4, 4], 6) == 2","solution":"from typing import List def min_distinct_sum(arr: List[int], k: int) -> int: Returns the smallest number of distinct integers from the list such that their sum is greater than or equal to k. if not arr: return -1 # Removing duplicates and sort the list in descending order distinct_numbers = sorted(set(arr), reverse=True) current_sum = 0 count = 0 for num in distinct_numbers: current_sum += num count += 1 if current_sum >= k: return count # If the sum of all distinct numbers is still less than k return -1"},{"question":"def is_valid_email(email: str) -> bool: Check if the given string is a valid email address according to the specified rules. Rules: 1. It must contain exactly one \\"@\\". 2. It must contain at least one \\".\\". 3. The \\".\\" must be after the \\"@\\" and not immediately adjacent to it. 4. Neither the local part (the part before the \\"@\\") nor the domain part (the part after the \\"@\\") can be empty. >>> is_valid_email(\\"example@example.com\\") == True >>> is_valid_email(\\"invalid-email.com\\") == False >>> is_valid_email(\\"invalid-email@com@\\") == False >>> is_valid_email(\\"@example.com\\") == False >>> is_valid_email(\\"example@com.\\") == False >>> is_valid_email(\\"example@.com\\") == False >>> is_valid_email(\\"example@sub.example.com\\") == True from solution import is_valid_email def test_valid_email(): assert is_valid_email(\\"example@example.com\\") == True def test_missing_at(): assert is_valid_email(\\"invalid-email.com\\") == False def test_multiple_at(): assert is_valid_email(\\"invalid-email@com@\\") == False def test_empty_local_part(): assert is_valid_email(\\"@example.com\\") == False def test_dot_immediately_after_at(): assert is_valid_email(\\"example@.com\\") == False def test_dot_at_end_of_domain(): assert is_valid_email(\\"example@com.\\") == False def test_valid_email_with_subdomain(): assert is_valid_email(\\"example@sub.example.com\\") == True def test_empty_domain_part(): assert is_valid_email(\\"example@\\") == False def test_adjacent_dots(): assert is_valid_email(\\"example@sub..example.com\\") == False def test_missing_dot_in_domain(): assert is_valid_email(\\"example@examplecom\\") == False def test_valid_email_with_single_letter_local_part(): assert is_valid_email(\\"e@sub.example.com\\") == True","solution":"def is_valid_email(email): Returns True if the input string is a valid email address according to the specified rules, otherwise False. if \\"@\\" not in email or email.count(\\"@\\") != 1: return False local_part, domain_part = email.split(\\"@\\") if not local_part or not domain_part: return False if \\".\\" not in domain_part or \\"..\\" in email or domain_part.startswith(\\".\\"): return False if domain_part.find('.') == len(domain_part) - 1: return False return True"},{"question":"def max_gold_coins(T, testcases): Given a number of test cases with grid dimensions and grid values, return a list of the maximum number of gold coins that can be collected for each testcase. results = [] for case in testcases: R, C, grid = case dp = [[0] * C for _ in range(R)] dp[0][0] = grid[0][0] for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] for i in range(1, R): for j in range(1, C): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) results.append(dp[R-1][C-1]) return results # Test cases def test_single_case_small_grid(): T = 1 testcases = [(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ])] assert max_gold_coins(T, testcases) == [12] def test_multiple_cases(): T = 2 testcases = [ (3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), (2, 2, [ [1, 2], [1, 3] ]) ] assert max_gold_coins(T, testcases) == [12, 6] def test_smallest_grid(): T = 1 testcases = [(1, 1, [ [5] ])] assert max_gold_coins(T, testcases) == [5] def test_row_grid(): T = 1 testcases = [(1, 3, [ [1, 2, 3] ])] assert max_gold_coins(T, testcases) == [6] def test_column_grid(): T = 1 testcases = [(3, 1, [ [1], [2], [3] ])] assert max_gold_coins(T, testcases) == [6] def test_zero_row_column(): T = 0 testcases = [] assert max_gold_coins(T, testcases) == []","solution":"def max_gold_coins(T, testcases): Given a number of test cases with grid dimensions and grid values, return a list of the maximum number of gold coins that can be collected for each testcase. results = [] for case in testcases: R, C, grid = case # Initializing a dp table with the same dimensions as the grid dp = [[0] * C for _ in range(R)] # Base case: start at the top-left cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, R): for j in range(1, C): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) # The value in the bottom-right cell is the answer for this grid results.append(dp[R-1][C-1]) return results"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(101) True >>> is_prime(102) False","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False # any other even number is not a prime for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers \`nums\`, return a list where each integer is replaced by the product of all the integers in the original list except the integer at that position. Args: nums: List of integers Returns: List of integers Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([7, 3, 5]) [15, 35, 21] >>> product_except_self([2, 2, 2]) [4, 4, 4] >>> product_except_self([0, 0, 0]) [0, 0, 0] >>> product_except_self([1, 0, 1]) [0, 1, 0] >>> product_except_self([0]) [1] >>> product_except_self([]) [] >>> product_except_self([10]) [1]","solution":"def product_except_self(nums): Given a list of integers \`nums\`, return a list such that each element at index \`i\` is the product of all the numbers in the original array except \`nums[i]\`. Args: nums: List of integers Returns: List of integers if not nums: return [] n = len(nums) output = [1] * n # Calculate left product for each element left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] # Calculate right product for each element and multiply with left product right_product = 1 for i in range(n - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def generate_sequence(n): Generates the first n numbers of the sequence where each number is the sum of the previous number and the next consecutive odd number, starting with 1. >>> generate_sequence(1) == [1] >>> generate_sequence(2) == [1, 4] >>> generate_sequence(3) == [1, 4, 9] >>> generate_sequence(4) == [1, 4, 9, 16] >>> generate_sequence(5) == [1, 4, 9, 16, 25] >>> generate_sequence(0) == [] >>> generate_sequence(-5) == [] >>> generate_sequence(10) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] # Your code here return []","solution":"def generate_sequence(n): Generates the first n numbers of the sequence where each number is the sum of the previous number and the next consecutive odd number, starting with 1. if n < 1: return [] sequence = [1] current_value = 1 next_odd_number = 3 for _ in range(1, n): current_value += next_odd_number sequence.append(current_value) next_odd_number += 2 return sequence"},{"question":"def calc_st(n: int) -> int: Returns the number of remaining smaller triangles in a Sierpinski Triangle after n iterations. >>> calc_st(0) == 1 >>> calc_st(1) == 3 >>> calc_st(2) == 9 >>> calc_st(3) == 27 >>> calc_st(4) == 81 >>> calc_st(5) == 243 >>> calc_st(10) == 59049","solution":"def calc_st(n): Returns the number of remaining smaller triangles in a Sierpinski Triangle after n iterations. return 3**n"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. :param s: Input string :return: The length of the longest substring without repeating characters Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. :param s: Input string :return: The length of the longest substring without repeating characters char_index_map = {} start = max_length = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index max_length = max(max_length, index - start + 1) return max_length"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\" \\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123456\\") False","solution":"def is_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. # Filter alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered string is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"MOD = 1000000007 def count_lucky_collections(N): Returns the count of valid lucky collections of length N where the first and last characters are different. pass def process_test_cases(T, test_cases): Processes multiple test cases and returns the results. pass # Sample Unit Tests from solution import count_lucky_collections, process_test_cases def test_count_lucky_collections(): assert count_lucky_collections(1) == 0 assert count_lucky_collections(2) == 2 assert count_lucky_collections(3) == 4 assert count_lucky_collections(4) == 8 def test_process_test_cases(): assert process_test_cases(2, [1, 2]) == [0, 2] assert process_test_cases(3, [1, 2, 3]) == [0, 2, 4] assert process_test_cases(2, [4, 5]) == [8, 16] assert process_test_cases(2, [6, 7]) == [32, 64]","solution":"MOD = 1000000007 def count_lucky_collections(N): Returns the count of valid lucky collections of length N where the first and last characters are different. if N == 1: return 0 if N == 2: return 2 # Start and end different case can be filled in 2 ways (AB or BA) # Each remaining N-2 spots can be either A or B, hence 2^(N-2) combinations return pow(2, N-2, MOD) * 2 % MOD def process_test_cases(T, test_cases): results = [] for N in test_cases: result = count_lucky_collections(N) results.append(result) return results"},{"question":"def unscramble(sentence: str) -> str: Given a string that represents a scrambled sentence - where the order of characters in each word is jumbled, but words are separated by spaces - returns the sentence with the characters in each word sorted in alphabetical order while maintaining the word order. >>> unscramble(\\"hlleo wlrdo\\") 'ehllo dlorw' >>> unscramble(\\"pytnohn is luaov\\") 'hnnopty is alouv' >>> unscramble(\\"abc cba\\") 'abc abc' >>> unscramble(\\"abcd dcba\\") 'abcd abcd'","solution":"def unscramble(sentence: str) -> str: Returns the sentence with the characters in each word sorted in alphabetical order while maintaining the word order. words = sentence.split() sorted_words = [''.join(sorted(word)) for word in words] return ' '.join(sorted_words)"},{"question":"def merge_sorted_arrays(nums1: List[int], nums2: List[int]) -> List[int]: Merges two sorted arrays into one sorted array in non-decreasing order without using built-in sort functions. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([5, 8], [1, 2, 3, 7, 9]) [1, 2, 3, 5, 7, 8, 9]","solution":"def merge_sorted_arrays(nums1, nums2): Merges two sorted arrays into one sorted array in non-decreasing order without using built-in sort functions. Parameters: nums1 (list): First sorted array. nums2 (list): Second sorted array. Returns: list: Merged sorted array. merged_array = [] i = 0 j = 0 # Merge the arrays until one of them is exhausted while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: merged_array.append(nums1[i]) i += 1 else: merged_array.append(nums2[j]) j += 1 # Add remaining elements of nums1, if any while i < len(nums1): merged_array.append(nums1[i]) i += 1 # Add remaining elements of nums2, if any while j < len(nums2): merged_array.append(nums2[j]) j += 1 return merged_array"},{"question":"def maxProfit(prices): Determine the maximum profit you can achieve by buying one share of the stock and then selling it at a later date. If no profit can be made, return 0. Args: prices (List[int]): List of stock prices where each element represents a day's price. Returns: int: The maximum profit possible. If no profit is possible, return 0. Examples: >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([1, 2, 3, 4, 5]) 4 pass # Unit tests for maxProfit function def test_max_profit_example_1(): assert maxProfit([7, 1, 5, 3, 6, 4]) == 5 def test_max_profit_example_2(): assert maxProfit([7, 6, 4, 3, 1]) == 0 def test_max_profit_example_3(): assert maxProfit([1, 2, 3, 4, 5]) == 4 def test_max_profit_all_same(): assert maxProfit([5, 5, 5, 5, 5]) == 0 def test_max_profit_empty(): assert maxProfit([]) == 0 def test_max_profit_two_elements(): assert maxProfit([1, 2]) == 1 assert maxProfit([2, 1]) == 0 def test_max_profit_fluctuating(): assert maxProfit([2, 4, 1, 7, 5, 3, 10]) == 9 def test_max_profit_large_list(): prices = list(range(10000, 0, -1)) # Always decreasing prices assert maxProfit(prices) == 0 prices = list(range(1, 10001)) # Always increasing prices assert maxProfit(prices) == 9999","solution":"def maxProfit(prices): Returns the maximum profit that can be made by buying and then selling one share of the stock. If no profit is possible, returns 0. if not prices: # If the list is empty return 0 min_price = float('inf') max_profit = 0 for price in prices: # Update the minimum price if the current price is lower if price < min_price: min_price = price # Calculate the current profit if we sell at the current price current_profit = price - min_price # Update the maximum profit if the current profit is higher if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def factorial(n: int) -> int: Returns the factorial of the given integer n. Factorial of n (n!) is defined as the product of all positive integers up to n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(4) 24 >>> factorial(5) 120 def test_factorial_of_zero(): assert factorial(0) == 1 def test_factorial_of_one(): assert factorial(1) == 1 def test_factorial_of_small_numbers(): assert factorial(2) == 2 assert factorial(3) == 6 def test_factorial_of_medium_numbers(): assert factorial(4) == 24 assert factorial(5) == 120 assert factorial(6) == 720 def test_factorial_of_upper_bound(): assert factorial(12) == 479001600 def test_factorial_of_random_valid_numbers(): assert factorial(7) == 5040 assert factorial(10) == 3628800","solution":"def factorial(n): Returns the factorial of the given integer n. Factorial of n (n!) is defined as the product of all positive integers up to n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def find_winners(N: int, M: int, scores: List[List[int]]) -> List[int]: Determine the participant(s) with the highest total score. Args: N (int): The number of participants. M (int): The number of rounds. scores (list of list of int): The scores of participants for each round. Returns: list of int: The ID(s) of the participant(s) with the highest total score. pass # Example usage if __name__ == \\"__main__\\": N = 3 M = 4 scores = [ [10, 15, 20], [5, 10, 15], [20, 10, 10], [5, 15, 25] ] print(find_winners(N, M, scores)) # Output: [3]","solution":"def find_winners(N, M, scores): Determine the participant(s) with the highest total score. Args: N (int): The number of participants. M (int): The number of rounds. scores (list of list of int): The scores of participants for each round. Returns: list of int: The ID(s) of the participant(s) with the highest total score. total_scores = [0] * N # Calculate total scores for each participant for round_scores in scores: for i in range(N): total_scores[i] += round_scores[i] # Find the highest score max_score = max(total_scores) # Find all participants with the max score winners = [i + 1 for i in range(N) if total_scores[i] == max_score] return winners # Example usage if __name__ == \\"__main__\\": N = 3 M = 4 scores = [ [10, 15, 20], [5, 10, 15], [20, 10, 10], [5, 15, 25] ] print(find_winners(N, M, scores)) # Output: [3]"},{"question":"def find_indices(nums: List[int], target: int) -> List[int]: Returns indices of the two numbers in the list that add up to the target. Args: nums: List of integers. target: Integer target value. Returns: List of two indices. >>> find_indices([2, 7, 11, 15], 9) [0, 1] >>> find_indices([3, 2, 4], 6) [1, 2] >>> find_indices([3, 3], 6) [0, 1] >>> find_indices([2, 5, 5, 11], 10) [1, 2]","solution":"def find_indices(nums, target): Returns indices of the two numbers in the list that add up to the target. Args: nums: List of integers. target: Integer target value. Returns: List of two indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def min_cameras(buildings: List[Tuple[int, int]]) -> int: Determine the minimum number of cameras required such that every building is monitored by at least one camera. >>> min_cameras([(1, 3), (2, 5), (8, 10)]) 2 >>> min_cameras([(1, 4), (2, 3), (10, 12), (6, 9)]) 3 >>> min_cameras([(0, 2), (1, 3), (4, 6), (5, 7), (8, 10)]) 3","solution":"def min_cameras(buildings): # Sort buildings by their end points buildings.sort(key=lambda x: x[1]) cameras = 0 last_camera_position = -1 for start, end in buildings: if start > last_camera_position: # Place a new camera at the end of the current building last_camera_position = end cameras += 1 return cameras"},{"question":"def generate_garden_pattern(T: int, test_cases: List[int]) -> List[str]: Generates the garden pattern for T test cases. Parameters: T (int): Number of test cases. test_cases (list of int): List of integers representing the number of rows for each test case. Returns: list: A list of strings, each representing the garden pattern for a test case. >>> generate_garden_pattern(3, [2, 3, 4]) [\\"1n22\\", \\"1n22n333\\", \\"1n22n333n4444\\"] >>> generate_garden_pattern(1, [1]) [\\"1\\"]","solution":"def generate_garden_pattern(T, test_cases): Generates the garden pattern for T test cases. Parameters: T (int): Number of test cases. test_cases (list of int): List of integers representing the number of rows for each test case. Returns: list: A list of strings, each representing the garden pattern for a test case. result = [] for N in test_cases: pattern = [] for i in range(1, N + 1): pattern.append(str(i) * i) result.append('n'.join(pattern)) return result"},{"question":"def evaluate(expression: str) -> int: Evaluates a string mathematical expression and returns the computed result. The expression contains only integers and operators +, -, *, /, and parentheses. It respects operator precedence. >>> evaluate(\\"3+5*2\\") 13 >>> evaluate(\\"10+2*6\\") 22 >>> evaluate(\\"100*2+12\\") 212 >>> evaluate(\\"100*(2+12)\\") 1400 >>> evaluate(\\"100*(2+12)/14\\") 100","solution":"def evaluate(expression): Evaluates a string mathematical expression and returns the computed result. import re import operator def parse_expression(expression): return re.findall(r'd+|+|-|*|/|(|)', expression) def apply_op(operators, values): right = values.pop() left = values.pop() op = operators.pop() operators_func = { '+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.floordiv } values.append(operators_func[op](left, right)) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def evaluate_tokens(tokens): values = [] operators = [] i = 0 while i < len(tokens): token = tokens[i] if token.isdigit(): values.append(int(token)) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': apply_op(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(token)): apply_op(operators, values) operators.append(token) i += 1 while operators: apply_op(operators, values) return values[-1] tokens = parse_expression(expression) return evaluate_tokens(tokens)"},{"question":"from typing import List, Tuple def minimum_cost_to_install_cameras(n: int, roads: List[Tuple[int, int, int]]) -> int: Function to return the minimum cost required to monitor all the roads in the city. The cost is based on the travel time of each road. Args: n (int): The number of intersections in the city. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple represents (intersection1, intersection2, travel_time). Returns: int: The minimum cost required to install security cameras on all roads. Examples: >>> minimum_cost_to_install_cameras(4, [(1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 1)]) 8 >>> minimum_cost_to_install_cameras(3, [(1, 2, 4), (1, 3, 6), (2, 3, 1)]) 5 # Unit tests def test_example_1(): n = 4 roads = [(1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 1)] assert minimum_cost_to_install_cameras(n, roads) == 8 def test_example_2(): n = 3 roads = [(1, 2, 4), (1, 3, 6), (2, 3, 1)] assert minimum_cost_to_install_cameras(n, roads) == 5 def test_single_road(): n = 2 roads = [(1, 2, 10)] assert minimum_cost_to_install_cameras(n, roads) == 10 def test_more_complex_scenario(): n = 5 roads = [(1, 2, 1), (1, 3, 2), (2, 3, 3), (2, 4, 4), (3, 5, 6)] assert minimum_cost_to_install_cameras(n, roads) == 13 def test_no_roads(): n = 3 roads = [] assert minimum_cost_to_install_cameras(n, roads) == 0 def test_disconnected_graph(): n = 4 roads = [(1, 2, 3), (3, 4, 4)] assert minimum_cost_to_install_cameras(n, roads) == 7","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_cost_to_install_cameras(n, roads): Function to return the minimum cost required to monitor all the roads in the city. The cost is based on the travel time of each road. # Sort roads based on the travel_time roads.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n + 1): parent.append(node) rank.append(0) result = 0 # Store the total minimum cost e = 0 # Count number of edges in MST i = 0 # Initial index of sorted edges # Number of edges in MST will be equal to n-1 while e < n - 1: if i >= len(roads): break (u, v, w) = roads[i] i = i + 1 x = find(parent, u) y = find(parent, v) # If they are in different sets, include this edge in the result if x != y: e = e + 1 result = result + w union(parent, rank, x, y) return result"},{"question":"def rotate_matrix_90_degrees(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix by 90 degrees clockwise. >>> rotate_matrix_90_degrees([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_degrees([ ... [1, 2], ... [3, 4]]) [[3, 1], [4, 2]]","solution":"def rotate_matrix_90_degrees(matrix): Rotates a given NxN matrix by 90 degrees clockwise. :param matrix: List[List[int]], 2D list representing a NxN matrix. :return: List[List[int]], 2D list representing the rotated matrix. # Number of rows (or columns) since it's an NxN matrix N = len(matrix) # Creating an empty NxN matrix for the result rotated_matrix = [[0] * N for _ in range(N)] # Transposing and then reversing each row for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def min_operations_to_empty_string(s: str) -> int: Returns the minimum number of operations required to make the string empty by removing palindromic substrings. >>> min_operations_to_empty_string(\\"ababa\\") 1 >>> min_operations_to_empty_string(\\"aabb\\") 2 >>> min_operations_to_empty_string(\\"abcd\\") 2 >>> min_operations_to_empty_string(\\"a\\") 1 >>> min_operations_to_empty_string(\\"racecar\\") 1 >>> min_operations_to_empty_string(\\"ab\\") 2 >>> min_operations_to_empty_string(\\"xy\\") 2 >>> min_operations_to_empty_string(\\"ba\\") 2","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations required to make the string empty by removing palindromic substrings. if s == s[::-1]: return 1 # If the entire string is a palindrome, remove it in one operation return 2 # If the string is not a palindrome, at most two operations are needed: one for non-palindromic part"},{"question":"def has_pair_with_sum(nums, target_sum): Determines if there are two distinct elements in the array such that their sum is equal to the required sum. :param nums: List of integers. :param target_sum: The required sum. :return: True if such a pair exists, otherwise False. Examples: >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False from solution import has_pair_with_sum def test_has_pair_with_sum_exists(): assert has_pair_with_sum([10, 15, 3, 7], 17) == True assert has_pair_with_sum([1, 2, 3, 4], 5) == True assert has_pair_with_sum([-1, -2, -3, -4], -5) == True assert has_pair_with_sum([-10, 20, 10, -20], 0) == True def test_has_pair_with_sum_no_pair(): assert has_pair_with_sum([1, 2, 3, 4], 8) == False assert has_pair_with_sum([10, 20, 30, 40], 100) == False assert has_pair_with_sum([-5, -3, -1], 2) == False assert has_pair_with_sum([], 10) == False def test_has_pair_with_sum_boundary_conditions(): assert has_pair_with_sum([1, 99999, -99998, 2], 100000) == True assert has_pair_with_sum([100000, 200000, -100000], 0) == True assert has_pair_with_sum([0], 0) == False assert has_pair_with_sum([1, 1], 2) == True # even though elements are the same, distinct indices make it valid","solution":"def has_pair_with_sum(nums, target_sum): Determines if there are two distinct elements in nums such that their sum is equal to target_sum. :param nums: List of integers. :param target_sum: The required sum. :return: True if such a pair exists, otherwise False. seen = set() for num in nums: if target_sum - num in seen: return True seen.add(num) return False"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Returns the area of the largest rectangle containing only 1s in a 2D binary matrix. >>> maximalRectangle([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]) == 6 >>> maximalRectangle([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0 >>> maximalRectangle([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 9 >>> maximalRectangle([[1, 1, 0, 1]]) == 2 >>> maximalRectangle([ [1], [1], [0], [1] ]) == 2 >>> maximalRectangle([]) == 0","solution":"def maximalRectangle(matrix): Returns the area of the largest rectangle containing only 1s in a 2D binary matrix. if not matrix: return 0 max_area = 0 row_len = len(matrix[0]) height = [0] * (row_len + 1) # Include an extra element to handle the last histogram bar for row in matrix: for i in range(row_len): if row[i] == 0: height[i] = 0 else: height[i] += 1 stack = [-1] for i in range(row_len + 1): while height[i] < height[stack[-1]]: h = height[stack.pop()] w = i - 1 - stack[-1] max_area = max(max_area, h * w) stack.append(i) return max_area # Example usage: # m, n = 4, 5 # grid = [ # [1, 0, 1, 0, 0], # [1, 0, 1, 1, 1], # [1, 1, 1, 1, 1], # [1, 0, 0, 1, 0] # ] # print(maximalRectangle(grid)) # Output: 6"},{"question":"[Completion Task in Python] from typing import List def min_cost_path(m: int, n: int, grid: List[List[int]]) -> int: Calculates the minimum cost required to reach the bottom right corner from the top left corner of the grid. >>> m = 3 >>> n = 3 >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_cost_path(m, n, grid) 7 >>> m = 2 >>> n = 2 >>> grid = [ ... [1, 2], ... [1, 1] ... ] >>> min_cost_path(m, n, grid) 3 def test_min_cost_path_example_1(): m = 3 n = 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost_path(m, n, grid) == 7 def test_min_cost_path_example_2(): m = 2 n = 2 grid = [ [1, 2], [1, 1] ] assert min_cost_path(m, n, grid) == 3 def test_min_cost_path_single_cell(): m = 1 n = 1 grid = [ [5] ] assert min_cost_path(m, n, grid) == 5 def test_min_cost_path_row(): m = 1 n = 4 grid = [ [1, 2, 5, 1] ] assert min_cost_path(m, n, grid) == 9 def test_min_cost_path_column(): m = 4 n = 1 grid = [ [3], [2], [5], [1] ] assert min_cost_path(m, n, grid) == 11 def test_min_cost_path_complex_grid(): m = 4 n = 4 grid = [ [1, 3, 1, 5], [2, 1, 2, 1], [4, 2, 1, 3], [5, 2, 2, 1] ] assert min_cost_path(m, n, grid) == 10","solution":"def min_cost_path(m, n, grid): Calculates the minimum cost path from the top-left to the bottom-right corner of the grid. # Create a 2D list to keep track of the minimum cost to reach each cell dp = [[0] * n for _ in range(m)] # Initialize the cost for the top-left cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(root): Determines whether the given binary tree is a binary search tree (BST). >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> is_bst(root) True >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4, TreeNode(3), TreeNode(6)) >>> is_bst(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(root): Determines whether the given binary tree is a binary search tree (BST). def validate(node, low=float('-inf'), high=float('inf')): # An empty tree is a valid BST if node is None: return True # The current node's value must be within the given range if node.val <= low or node.val >= high: return False # The left subtree must be valid and its values should be less than the current node's value # The right subtree must be valid and its values should be greater than the current node's value return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"def findMedianSortedArrays(arr1: List[int], arr2: List[int]) -> float: Find the median of two sorted arrays of integers. >>> findMedianSortedArrays([1, 3, 8], [7, 9, 10, 12]) 8 >>> findMedianSortedArrays([1, 2], [3, 4]) 2.5 >>> findMedianSortedArrays([1, 2, 3], [4, 5, 6, 7]) 4 >>> findMedianSortedArrays([0, 0], [0, 0]) 0 >>> findMedianSortedArrays([], [1]) 1 >>> findMedianSortedArrays([2], []) 2 >>> findMedianSortedArrays([1, 5, 9], [2, 4, 6, 8]) 5 >>> findMedianSortedArrays([1], [2, 3, 4]) 2.5","solution":"def findMedianSortedArrays(arr1, arr2): Finds the median of two sorted arrays by merging them and then calculating the median. Parameters: arr1 (list): First sorted list of integers arr2 (list): Second sorted list of integers Returns: float: The median of the merged arrays # Merging the two sorted arrays merged = arr1 + arr2 merged.sort() # Calculating the median n = len(merged) if n % 2 == 1: # Odd number of elements median = merged[n // 2] else: # Even number of elements median = (merged[n // 2 - 1] + merged[n // 2]) / 2.0 return median"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all numbers in the input list except the one at that position. Args: nums: List[int] - list of integers. Returns: List[int] - list of products. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([4, 5, 1, 8, 2]) [80, 64, 320, 40, 160] >>> product_except_self([3, 6, 9]) [54, 27, 18] >>> product_except_self([5]) [1] >>> product_except_self([]) [] >>> product_except_self([1, 0, 3, 0]) [0, 0, 0, 0] >>> product_except_self([-1, -2, -3]) [6, 3, 2] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6]","solution":"def product_except_self(nums): Returns a list where each element is the product of all numbers in the input list except the one at that position. n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for j in range(n - 2, -1, -1): right_products[j] = right_products[j + 1] * nums[j + 1] # Calculate the result by multiplying left and right products for k in range(n): result[k] = left_products[k] * right_products[k] return result"},{"question":"from typing import List def min_adjacent_swaps(words: List[str], target: str) -> int: Returns the minimum number of adjacent swaps required to bring the target string to the front of the array. If the target is not present in the array, return -1. >>> min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"cherry\\") 2 >>> min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"banana\\") 1 >>> min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"date\\") 3 >>> min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"apple\\") 0 >>> min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"fig\\") -1 >>> min_adjacent_swaps([\\"apple\\"], \\"apple\\") 0 >>> min_adjacent_swaps([], \\"apple\\") -1 def test_min_adjacent_swaps(): assert min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"cherry\\") == 2 assert min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"banana\\") == 1 assert min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"date\\") == 3 assert min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"apple\\") == 0 assert min_adjacent_swaps([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"fig\\") == -1 assert min_adjacent_swaps([\\"apple\\"], \\"apple\\") == 0 assert min_adjacent_swaps([], \\"apple\\") == -1 def test_min_adjacent_swaps_large(): words = [\\"word\\" + str(i) for i in range(1000)] assert min_adjacent_swaps(words, \\"word500\\") == 500 assert min_adjacent_swaps(words, \\"word999\\") == 999 assert min_adjacent_swaps(words, \\"not_in_list\\") == -1 def test_min_adjacent_swaps_edge_cases(): assert min_adjacent_swaps([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"a\\") == 0 assert min_adjacent_swaps([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"b\\") == 1 assert min_adjacent_swaps([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"d\\") == 3 assert min_adjacent_swaps([\\"unique\\"], \\"unique\\") == 0 assert min_adjacent_swaps([\\"unique\\"], \\"not_in_list\\") == -1","solution":"def min_adjacent_swaps(words, target): Returns the minimum number of adjacent swaps required to bring the target string to the front of the array. If the target is not present in the array, return -1. if target not in words: return -1 target_index = words.index(target) return target_index"},{"question":"def dynamic_sequence(m: int, operations: List[str]) -> List[Union[int, str]]: Manage a dynamic number sequence based on a series of operations. The operations include: - add x: Add integer \`x\` at the end of the sequence. - remove: Remove the last element from the sequence. - sum: Compute the sum of all elements in the sequence. - max: Find the maximum element in the sequence. Perform the operations on the sequence and return the results for \\"sum\\" and \\"max\\" operations. Args: m (int): The number of operations. operations (List[str]): The list of operations to perform. Returns: List[Union[int, str]]: The results of \\"sum\\" and \\"max\\" operations. >>> m = 6 >>> operations = [\\"add 3\\", \\"add 7\\", \\"sum\\", \\"add -2\\", \\"max\\", \\"remove\\"] >>> dynamic_sequence(m, operations) [10, 7] >>> m = 0 >>> operations = [] >>> dynamic_sequence(m, operations) [] >>> m = 3 >>> operations = [\\"add 5\\", \\"add 10\\", \\"sum\\"] >>> dynamic_sequence(m, operations) [15] >>> m = 4 >>> operations = [\\"add -3\\", \\"add 4\\", \\"remove\\", \\"max\\"] >>> dynamic_sequence(m, operations) [-3] pass","solution":"def dynamic_sequence(m, operations): sequence = [] results = [] for operation in operations: op = operation.split() if op[0] == \\"add\\": sequence.append(int(op[1])) elif op[0] == \\"remove\\": if sequence: sequence.pop() elif op[0] == \\"sum\\": results.append(sum(sequence)) elif op[0] == \\"max\\": results.append(max(sequence) if sequence else \\"EMPTY\\") return results"},{"question":"def max_rectangle_area(matrix: List[List[int]]) -> int: Write a function max_rectangle_area(matrix) that takes a 2D binary matrix filled with 0's and 1's and returns the area of the largest rectangle containing only 1's. >>> matrix = [ ... [1, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 1, 1, 0], ... [0, 1, 1, 1] ... ] >>> max_rectangle_area(matrix) 6 >>> matrix = [ ... [0, 1, 0, 0, 1], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 0], ... [0, 0, 1, 0, 0], ... [0, 1, 1, 1, 1] ... ] >>> max_rectangle_area(matrix) 8","solution":"def max_histogram_area(heights): Helper function to find the maximum rectangular area under a histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def max_rectangle_area(matrix): if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) heights = [0] * cols max_area = 0 for i in range(rows): for j in range(cols): heights[j] = heights[j] + 1 if matrix[i][j] == 1 else 0 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Given an array of integers and an integer k, find the maximum sum of a subarray of size k. Args: arr: List of integers k: Size of the subarray Returns: Maximum sum of a subarray of size k. Examples: >>> max_sum_subarray([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 pass def test_example_1(): arr = [1, 4, 2, 10, 23, 3, 1, 0, 20] k = 4 assert max_sum_subarray(arr, k) == 39 def test_example_2(): arr = [2, 1, 5, 1, 3, 2] k = 3 assert max_sum_subarray(arr, k) == 9 def test_small_array(): arr = [1, 2, 3] k = 1 assert max_sum_subarray(arr, k) == 3 def test_all_negative_numbers(): arr = [-1, -2, -3, -4, -5] k = 2 assert max_sum_subarray(arr, k) == -3 def test_k_equals_array_length(): arr = [5, 2, -1, 0, 3] k = 5 assert max_sum_subarray(arr, k) == 9 def test_empty_array(): arr = [] k = 3 assert max_sum_subarray(arr, k) == None def test_array_with_zeros(): arr = [0, 0, 0, 0, 0, 0] k = 3 assert max_sum_subarray(arr, k) == 0 def test_single_element_in_array(): arr = [10] k = 1 assert max_sum_subarray(arr, k) == 10","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of a subarray of size k. # Edge case: if array is empty or k is greater than array length if not arr or k > len(arr): return None # Initialize the maximum sum with the sum of the first subarray of size k max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window from left to right over the array for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def first_non_repeating_character(s: str) -> str: Create a function that takes a string containing only lowercase English letters and returns the first non-repeating character. If there is no non-repeating character, return an underscore '_'. >>> first_non_repeating_character(\\"abacabad\\") == 'c' >>> first_non_repeating_character(\\"aabbccdde\\") == 'e' >>> first_non_repeating_character(\\"abacabaabacaba\\") == '_' >>> first_non_repeating_character(\\"aabbcc\\") == '_' >>> first_non_repeating_character(\\"z\\") == 'z' >>> first_non_repeating_character(\\"\\") == '_' >>> first_non_repeating_character(\\"abcabcddde\\") == 'e' >>> first_non_repeating_character(\\"abcdefghija\\") == 'b' >>> first_non_repeating_character(\\"aabbccddeeaf\\") == 'f'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns '_'. char_count = {} # Count the occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that has a count of 1 for char in s: if char_count[char] == 1: return char return '_'"},{"question":"from typing import List, Tuple def max_books(N: int, W: int, thicknesses: List[int]) -> int: Finds the maximum number of books that can be placed on the shelf such that their total thickness does not exceed W. >>> max_books(5, 10, [1, 2, 3, 4, 5]) == 4 >>> max_books(4, 7, [3, 1, 6, 1]) == 3 >>> max_books(6, 15, [5, 3, 8, 2, 7, 4]) == 4 pass def process_input(input_str: str) -> List[Tuple[int, int, List[int]]]: Processes the input string to extract test cases. >>> process_input(\\"3n5 10n1 2 3 4 5n4 7n3 1 6 1n6 15n5 3 8 2 7 4\\") == [ (5, 10, [1, 2, 3, 4, 5]), (4, 7, [3, 1, 6, 1]), (6, 15, [5, 3, 8, 2, 7, 4]) ] pass def main(input_str: str) -> List[int]: Main function to process input and produce output for all test cases. >>> main(\\"3n5 10n1 2 3 4 5n4 7n3 1 6 1n6 15n5 3 8 2 7 4\\") == [4, 3, 4] pass def test_max_books(): assert max_books(5, 10, [1, 2, 3, 4, 5]) == 4 assert max_books(4, 7, [3, 1, 6, 1]) == 3 assert max_books(6, 15, [5, 3, 8, 2, 7, 4]) == 4 assert max_books(3, 5, [3, 5, 4]) == 1 assert max_books(5, 0, [1, 2, 3, 4, 5]) == 0 assert max_books(1, 100, [99]) == 1 assert max_books(2, 10, [5, 7]) == 1 def test_process_input(): input_str = \\"3n5 10n1 2 3 4 5n4 7n3 1 6 1n6 15n5 3 8 2 7 4\\" expected_output = [ (5, 10, [1, 2, 3, 4, 5]), (4, 7, [3, 1, 6, 1]), (6, 15, [5, 3, 8, 2, 7, 4]) ] assert process_input(input_str) == expected_output def test_main(): input_str = \\"3n5 10n1 2 3 4 5n4 7n3 1 6 1n6 15n5 3 8 2 7 4\\" expected_output = [4, 3, 4] assert main(input_str) == expected_output","solution":"def max_books(N, W, thicknesses): Finds the maximum number of books that can be placed on the shelf such that their total thickness does not exceed W. Args: N (int): Total number of books. W (int): Maximum allowed total thickness. thicknesses (list): List of integers representing the thicknesses of the books. Returns: int: The maximum number of books that can be placed on the shelf. thicknesses.sort() # Sort books by their thicknesses total_thickness = 0 # Initialize total thickness book_count = 0 # Initialize book count for thickness in thicknesses: if total_thickness + thickness <= W: total_thickness += thickness # Add book to the shelf book_count += 1 # Increment book count else: break # Stop if the total thickness exceeds W return book_count def process_input(input_str): Processes the input string to extract test cases. Args: input_str (str): Multi-line input string. Returns: list of tuples: Each tuple contains (N, W, thicknesses). lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, W = map(int, lines[index].split()) index += 1 thicknesses = list(map(int, lines[index].split())) index += 1 test_cases.append((N, W, thicknesses)) return test_cases def main(input_str): Main function to process input and produce output for all test cases. Args: input_str (str): Multi-line input string. Returns: list of int: List of results for each test case. test_cases = process_input(input_str) results = [max_books(N, W, thicknesses) for N, W, thicknesses in test_cases] return results"},{"question":"def plant_trees(L, distances): Plants trees along a path ensuring the distance from previous trees as given in input. Parameters: L (int): Length of the path. distances (list): List of integers representing the minimum distances between trees. Returns: list: List of tuples, with each tuple indicating the start and end positions of each tree. Examples: >>> plant_trees(10, [2, 3, 5]) [(0, 2), (2, 5), (5, 10)] >>> plant_trees(5, [3, 3]) [] >>> plant_trees(5, [2]) [(0, 2)] pass","solution":"def plant_trees(L, distances): Plants trees along a path ensuring the distance from previous trees as given in input. Parameters: L (int): Length of the path. distances (list): List of integers representing the minimum distances between trees. Returns: list: List of tuples, with each tuple indicating the start and end positions of each tree. positions = [] current_position = 0 for distance in distances: if current_position + distance > L or current_position + distance > L: return [] start_position = current_position end_position = current_position + distance positions.append((start_position, end_position)) current_position = end_position return positions"},{"question":"def calculate_even_sum_and_odd_product(numbers): Calculates the sum of all even numbers and the product of all odd numbers in the given list. Parameters: numbers (list): List of integers. Returns: tuple: A tuple containing the sum of all even numbers and the product of all odd numbers. >>> calculate_even_sum_and_odd_product([2, 3, 4, 5, 6]) (12, 15) >>> calculate_even_sum_and_odd_product([1, 2, 3, 4, 5, 6]) (12, 15) >>> calculate_even_sum_and_odd_product([10, 15, 20, 25, 30]) (60, 375) >>> calculate_even_sum_and_odd_product([100, 101, 102, 103, 104]) (306, 10403) >>> calculate_even_sum_and_odd_product([44, 21, 34, 55, 70]) (148, 1155)","solution":"def calculate_even_sum_and_odd_product(numbers): Calculates the sum of all even numbers and the product of all odd numbers in the given list. Parameters: numbers (list): List of integers. Returns: tuple: A tuple containing the sum of all even numbers and the product of all odd numbers. even_sum = 0 odd_product = 1 for num in numbers: if num % 2 == 0: even_sum += num else: odd_product *= num return even_sum, odd_product"},{"question":"def adjust_schedule(schedules: list[tuple[str, str]], dst: bool) -> list[tuple[str, str]]: Adjusts the device schedules according to daylight savings. Parameters: schedules (list of tuples): list of device schedules (device_id, \\"HH:MM\\") dst (bool): True if daylight savings is active, otherwise False Returns: list of tuples: Adjusted schedules Examples: >>> adjust_schedule([(\\"Heater\\", \\"13:45\\"), (\\"Lights\\", \\"06:30\\"), (\\"Sprinkler\\", \\"05:00\\")], True) [(\\"Heater\\", \\"14:45\\"), (\\"Lights\\", \\"07:30\\"), (\\"Sprinkler\\", \\"06:00\\")] >>> adjust_schedule([(\\"Heater\\", \\"23:30\\"), (\\"Lights\\", \\"22:15\\")], True) [(\\"Heater\\", \\"00:30\\"), (\\"Lights\\", \\"23:15\\")] >>> adjust_schedule([(\\"Heater\\", \\"23:30\\"), (\\"Lights\\", \\"22:15\\")], False) [(\\"Heater\\", \\"23:30\\"), (\\"Lights\\", \\"22:15\\")]","solution":"def adjust_schedule(schedules, dst): Adjusts the device schedules according to daylight savings. Parameters: schedules (list of tuples): list of device schedules (device_id, \\"HH:MM\\") dst (bool): True if daylight savings is active, otherwise False Returns: list of tuples: Adjusted schedules if not dst: return schedules adjusted_schedules = [] for device, time in schedules: hours, minutes = map(int, time.split(':')) new_hours = (hours + 1) % 24 adjusted_schedules.append((device, f\\"{new_hours:02}:{minutes:02}\\")) return adjusted_schedules"},{"question":"def word_search(T: int, cases: List[Tuple[List[List[str]], str]]) -> List[str]: Given a 2D grid of characters and a word, determine if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Returns a list of \\"YES\\" or \\"NO\\" for each test case indicating if the word exists in the grid. >>> T = 2 >>> cases = [ ... ([ ... [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], ... [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], ... [\\"A\\", \\"D\\", \\"E\\", \\"E\\"] ... ], \\"ABCCED\\"), ... ([ ... [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], ... [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], ... [\\"A\\", \\"D\\", \\"E\\", \\"E\\"] ... ], \\"ABCB\\")] >>> word_search(T, cases) [\\"YES\\", \\"NO\\"] # Your code here","solution":"def exist(grid, word): rows, cols = len(grid), len(grid[0]) def dfs(r, c, idx): if idx == len(word): return True if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != word[idx]: return False temp = grid[r][c] grid[r][c] = '#' # mark visited found = (dfs(r + 1, c, idx + 1) or dfs(r - 1, c, idx + 1) or dfs(r, c + 1, idx + 1) or dfs(r, c - 1, idx + 1)) grid[r][c] = temp # unmark visited return found for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, 0): return \\"YES\\" return \\"NO\\" def word_search(T, cases): results = [] for grid, word in cases: results.append(exist(grid, word)) return results"},{"question":"from typing import List def sum_of_squares(numbers: List[int]) -> int: Returns the sum of the squares of the elements in the numbers list. >>> sum_of_squares([1, 2, 3]) 14 >>> sum_of_squares([-1, -2, -3]) 14 >>> sum_of_squares([0, 0, 0]) 0 >>> sum_of_squares([1]) 1 >>> sum_of_squares([]) 0","solution":"from typing import List def sum_of_squares(numbers: List[int]) -> int: Returns the sum of the squares of the elements in the numbers list. return sum(x**2 for x in numbers)"},{"question":"from typing import List from collections import Counter import heapq def top_k_frequent(arr: List[int], k: int) -> List[int]: Write a function that takes an array of integers and an integer k as arguments. The function should return the k most frequent elements in the array. If there are multiple elements with the same frequency, prioritize the smaller number. Try to find a solution with a time complexity better than O(n log n). >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([1, 1, 1, 2, 2, 2, 3], 1) [1] >>> top_k_frequent([1, 1, 2, 2, 3, 3], 2) [1, 2] >>> top_k_frequent([1], 1) [1] >>> top_k_frequent([], 0) [] >>> top_k_frequent([4, 3, 4, 2, 3, 2, 1], 2) [2, 3]","solution":"from collections import Counter import heapq def top_k_frequent(arr, k): Returns the k most frequent elements in the array. If there are multiple elements with the same frequency, prioritize the smaller number. # Count the frequency of each element frequency = Counter(arr) # Create a min-heap based on frequency and if frequencies are equal, prioritize the smaller number heap = [(-freq, num) for num, freq in frequency.items()] heapq.heapify(heap) # Extract k elements from the heap top_k_elements = [heapq.heappop(heap)[1] for _ in range(k)] return sorted(top_k_elements, key=lambda x: (-frequency[x], x))"},{"question":"def navigate(n: int, start: tuple, end: tuple, obstacles: list) -> list: Help the robot find the correct sequence of commands to move from a given starting position to a destination position on a grid with obstacles. >>> navigate(5, (0, 0), (4, 4), [(0, 2), (2, 2), (3, 3)]) # Possible output: ['D', 'D', 'R', 'R', 'R', 'R', 'D', 'D', 'D']","solution":"def navigate(n, start, end, obstacles): from collections import deque directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)} def is_valid(x, y): return 0 <= x < n and 0 <= y < n and (x, y) not in obstacle_set start_x, start_y = start end_x, end_y = end obstacle_set = set(obstacles) queue = deque([(start_x, start_y, [])]) visited = set([(start_x, start_y)]) while queue: x, y, path = queue.popleft() if (x, y) == end: return path for direction, (dx, dy) in directions.items(): nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, path + [direction])) visited.add((nx, ny)) return None"},{"question":"def rotate_sequence(N: int, sequence: List[int], R: int) -> List[int]: Rotates the given sequence R times where each rotation moves the last element to the front. Parameters: N (int): The number of integers in the sequence. sequence (list of int): The sequence of integers. R (int): The number of rotations to be performed. Returns: list of int: The sequence after performing R rotations. >>> rotate_sequence(5, [1, 2, 3, 4, 5], 1) [5, 1, 2, 3, 4] >>> rotate_sequence(6, [7, 8, 9, 10, 11, 12], 3) [10, 11, 12, 7, 8, 9] >>> rotate_sequence(4, [1, 2, 3, 4], 0) [1, 2, 3, 4] >>> rotate_sequence(4, [1, 2, 3, 4], 4) [1, 2, 3, 4] >>> rotate_sequence(4, [1, 2, 3, 4], 6) [3, 4, 1, 2] >>> rotate_sequence(1, [7], 3) [7] >>> rotate_sequence(0, [], 3) []","solution":"def rotate_sequence(N, sequence, R): Rotates the given sequence R times where each rotation moves the last element to the front. Parameters: N (int): The number of integers in the sequence. sequence (list of int): The sequence of integers. R (int): The number of rotations to be performed. Returns: list of int: The sequence after performing R rotations. if N == 0: return [] R = R % N # Effective rotations needed when R >= N return sequence[-R:] + sequence[:-R]"},{"question":"def modified_fibonacci(N: int, M: int) -> List[int]: Generate the first N numbers of the modified Fibonacci sequence where each number is the sum of the two preceding ones, followed by taking the remainder when divided by M. >>> modified_fibonacci(5, 3) [0, 1, 1, 2, 0] >>> modified_fibonacci(6, 4) [0, 1, 1, 2, 3, 1] >>> modified_fibonacci(10, 2) [0, 1, 1, 0, 1, 1, 0, 1, 1, 0] >>> modified_fibonacci(8, 5) [0, 1, 1, 2, 3, 0, 3, 3] def process_cases(cases: List[Tuple[int, int]]) -> List[str]: Given multiple test cases, process each case and return results in the specified format. >>> process_cases([(5, 3), (6, 4)]) [\\"Case #1: 0 1 1 2 0\\", \\"Case #2: 0 1 1 2 3 1\\"] >>> process_cases([(10, 2), (8, 5)]) [\\"Case #1: 0 1 1 0 1 1 0 1 1 0\\", \\"Case #2: 0 1 1 2 3 0 3 3\\"]","solution":"def modified_fibonacci(N, M): Generate the first N numbers of the modified Fibonacci sequence where each number is the sum of the two preceding ones, followed by taking the remainder when divided by M. fibonacci_list = [0, 1] for i in range(2, N): new_value = (fibonacci_list[-1] + fibonacci_list[-2]) % M fibonacci_list.append(new_value) return fibonacci_list[:N] def process_cases(cases): Given multiple test cases, process each case and return results in the specified format. results = [] for i, (N, M) in enumerate(cases): result = modified_fibonacci(N, M) results.append(f\\"Case #{i + 1}: {' '.join(map(str, result))}\\") return results"},{"question":"def canTransform(y: int, z: int) -> bool: Determines if it's possible to transform integer y to integer z using the operations: increment by 7 or divide by 4 (if divisible by 4). >>> canTransform(14, 7) True >>> canTransform(10, 5) False","solution":"def canTransform(y, z): Determines if it's possible to transform integer y to integer z using the operations: increment by 7 or divide by 4 (if divisible by 4). if y < z: return False while y >= z: if y == z: return True if y % 4 == 0 and y > z: y //= 4 else: y -= 7 return False"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner of a grid. The grid cells can be either open (0) or blocked (1). Movement is allowed only in four directions: up, down, left, and right. Args: grid (List[List[int]]): The grid represented as a list of lists of integers where 0 is an open cell and 1 is a blocked cell. Returns: int: The length of the shortest path if such a path exists, otherwise return -1. Examples: >>> shortest_path([ ... [0, 0, 0, 0, 1], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) 9 >>> shortest_path([ ... [0, 1], ... [1, 0] ... ]) -1 import pytest def test_example_case(): grid = [ [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert shortest_path(grid) == 9 def test_no_path(): grid = [ [0, 1], [1, 0] ] assert shortest_path(grid) == -1 def test_single_cell_open(): grid = [ [0] ] assert shortest_path(grid) == 1 def test_single_row(): grid = [ [0, 0, 0, 0, 0] ] assert shortest_path(grid) == 5 def test_single_column(): grid = [ [0], [0], [0], [0], [0] ] assert shortest_path(grid) == 5 def test_larger_grid_with_path(): grid = [ [0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 1], [0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0] ] assert shortest_path(grid) == 10 def test_larger_grid_no_path(): grid = [ [0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 1], [0, 0, 0, 1, 1, 1], [1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1] ] assert shortest_path(grid) == -1","solution":"from collections import deque def shortest_path(grid): if grid[0][0] == 1 or grid[-1][-1] == 1: return -1 N = len(grid) M = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(0, 0, 1)]) # (row, col, current_length) visited = set((0, 0)) while queue: row, col, length = queue.popleft() if row == N-1 and col == M-1: return length for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < N and 0 <= new_col < M and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: queue.append((new_row, new_col, length + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def reverse_words(s: str) -> str: Returns a new string with the words in reverse order. Handles leading or trailing spaces and multiple spaces between words. >>> reverse_words(\\" hello world \\") == \\"world hello\\" >>> reverse_words(\\"a good example\\") == \\"example good a\\" >>> reverse_words(\\" Bob Loves Alice \\") == \\"Alice Loves Bob\\" >>> reverse_words(\\"Alice does not even like bob\\") == \\"bob like even not does Alice\\" pass def test_reverse_words(): assert reverse_words(\\" hello world \\") == \\"world hello\\" assert reverse_words(\\"a good example\\") == \\"example good a\\" assert reverse_words(\\" Bob Loves Alice \\") == \\"Alice Loves Bob\\" assert reverse_words(\\"Alice does not even like bob\\") == \\"bob like even not does Alice\\" assert reverse_words(\\"\\") == \\"\\" assert reverse_words(\\"singleword\\") == \\"singleword\\" assert reverse_words(\\" trailing and leading spaces \\") == \\"spaces leading and trailing\\" # Uncomment below to run tests with pytest # if __name__ == '__main__': # pytest.main()","solution":"def reverse_words(s: str) -> str: Returns a new string with the words in reverse order. Handles leading or trailing spaces and multiple spaces between words. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): Computes the sum of all left leaves in a binary tree. A leaf is a node with no children. A left leaf is a leaf that is the left child of its parent. >>> root1 = TreeNode(3) >>> root1.left = TreeNode(9) >>> root1.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> sum_of_left_leaves(root1) 24 >>> root2 = TreeNode(1) >>> sum_of_left_leaves(root2) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): Computes the sum of all left leaves in a binary tree if not root: return 0 sum_left_leaves = 0 if root.left: # Check if the left node is a leaf if not root.left.left and not root.left.right: sum_left_leaves += root.left.val else: sum_left_leaves += sum_of_left_leaves(root.left) if root.right: sum_left_leaves += sum_of_left_leaves(root.right) return sum_left_leaves"},{"question":"def sort_words_by_length(s: str) -> str: Rearranges the given string so that all words are sorted in ascending order based on their lengths. If two words have the same length, their original order is preserved. :param s: Input string consisting of lowercase letters and spaces. :return: Rearranged string with words sorted by length. >>> sort_words_by_length(\\"hello world in a frame\\") \\"a in hello world frame\\" >>> sort_words_by_length(\\"keep calm and code on\\") \\"on and keep calm code\\"","solution":"def sort_words_by_length(s: str) -> str: Rearranges the given string so that all words are sorted in ascending order based on their lengths. If two words have the same length, their original order is preserved. :param s: Input string consisting of lowercase letters and spaces. :return: Rearranged string with words sorted by length. words = s.split() sorted_words = sorted(words, key=len) return ' '.join(sorted_words)"},{"question":"class ServiceQueue: Implement a service that processes customer requests in a queue with the following operations: 1. enqueue(name: str) -> None: Adds a customer's request to the end of the queue. 2. process() -> str: Processes the next customer's request from the front of the queue and returns the name. If the queue is empty, returns \\"Queue is empty\\". 3. size() -> int: Returns the current number of requests in the queue. 4. peek() -> str: Returns the name of the customer at the front of the queue without removing it, or \\"Queue is empty\\" if the queue is empty. Example Usage: >>> sq = ServiceQueue() >>> sq.enqueue(\\"Alice\\") >>> sq.enqueue(\\"Bob\\") >>> sq.size() 2 >>> sq.peek() \\"Alice\\" >>> sq.process() \\"Alice\\" >>> sq.process() \\"Bob\\" >>> sq.process() \\"Queue is empty\\" def enqueue(self, name: str) -> None: pass def process(self) -> str: pass def size(self) -> int: pass def peek(self) -> str: pass","solution":"class ServiceQueue: def __init__(self): self.queue = [] def enqueue(self, name: str) -> None: self.queue.append(name) def process(self) -> str: if not self.queue: return \\"Queue is empty\\" return self.queue.pop(0) def size(self) -> int: return len(self.queue) def peek(self) -> str: if not self.queue: return \\"Queue is empty\\" return self.queue[0]"},{"question":"def trailing_zeroes(n: int) -> int: Returns the number of trailing zeroes in the factorial of n. >>> trailing_zeroes(0) 0 >>> trailing_zeroes(5) 1 >>> trailing_zeroes(10) 2 >>> trailing_zeroes(25) 6 >>> trailing_zeroes(50) 12 >>> trailing_zeroes(100) 24 >>> trailing_zeroes(30) 7 >>> trailing_zeroes(7) 1 >>> trailing_zeroes(15) 3 >>> trailing_zeroes(20) 4 >>> trailing_zeroes(1000) 249 >>> trailing_zeroes(10000) 2499 >>> trailing_zeroes(100000) 24999","solution":"def trailing_zeroes(n): Returns the number of trailing zeroes in the factorial of n. count = 0 current_div = 5 while n >= current_div: count += n // current_div current_div *= 5 return count"},{"question":"def largest_permutation(N): Returns the lexicographically largest permutation of numbers from 1 to N. >>> largest_permutation(1) \\"1\\" >>> largest_permutation(3) \\"321\\" >>> largest_permutation(5) \\"54321\\" def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list. >>> process_test_cases([1, 3, 5]) [\\"1\\", \\"321\\", \\"54321\\"] >>> process_test_cases([10]) [\\"10987654321\\"] >>> process_test_cases([20, 1, 12]) [\\"\\".join(map(str, range(20, 0, -1))), \\"1\\", \\"\\".join(map(str, range(12, 0, -1)))]","solution":"def largest_permutation(N): Returns the lexicographically largest permutation of numbers from 1 to N. return ''.join(map(str, range(N, 0, -1))) def process_test_cases(test_cases): results = [] for N in test_cases: results.append(largest_permutation(N)) return results"},{"question":"def primes_up_to(n: int) -> List[int]: Returns all prime numbers between 1 and n (inclusive). >>> primes_up_to(1) == [] >>> primes_up_to(2) == [2] >>> primes_up_to(10) == [2, 3, 5, 7] >>> primes_up_to(11) == [2, 3, 5, 7, 11] >>> primes_up_to(15) == [2, 3, 5, 7, 11, 13] >>> primes_up_to(20) == [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def primes_up_to(n): Returns all prime numbers between 1 and n (inclusive). if n < 2: return [] primes = [] for num in range(2, n + 1): is_prime = True for i in range(2, int(num**0.5) + 1): if num % i == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"def count_motif_occurrences(dna_sequence: str, motif: str) -> int: Returns the number of times the motif appears in the DNA sequence. >>> count_motif_occurrences(\\"ACGTACGTACGT\\", \\"CGT\\") == 3 >>> count_motif_occurrences(\\"AAGTCGAAGTCA\\", \\"AAG\\") == 2 >>> count_motif_occurrences(\\"TTTTT\\", \\"TT\\") == 4 >>> count_motif_occurrences(\\"AAAA\\", \\"AA\\") == 3 >>> count_motif_occurrences(\\"ACGTACGTACGT\\", \\"ACGT\\") == 3 >>> count_motif_occurrences(\\"GTGTGTGT\\", \\"GTG\\") == 3 >>> count_motif_occurrences(\\"AAAAAAAAAA\\", \\"AA\\") == 9 >>> count_motif_occurrences(\\"GATTACA\\", \\"TACA\\") == 1 >>> count_motif_occurrences(\\"CCCCC\\", \\"CC\\") == 4 def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Process multiple test cases to find motif occurrences in DNA sequences. >>> test_cases = [(\\"ACGTACGTACGT\\", \\"CGT\\"), (\\"AAGTCGAAGTCA\\", \\"AAG\\"), (\\"TTTTT\\", \\"TT\\")] >>> process_test_cases(test_cases) == [3, 2, 4]","solution":"def count_motif_occurrences(dna_sequence, motif): Returns the number of times the motif appears in the DNA sequence. count = 0 motif_length = len(motif) for i in range(len(dna_sequence) - motif_length + 1): if dna_sequence[i:i+motif_length] == motif: count += 1 return count def process_test_cases(test_cases): results = [] for dna_sequence, motif in test_cases: results.append(count_motif_occurrences(dna_sequence, motif)) return results"},{"question":"def kth_smallest_element(T, test_cases): Find the Kth smallest element in an unsorted list for multiple test cases. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list of tuples, where each tuple has: - an integer N: the number of elements in the array - an integer K: the Kth position - a list of N positive integers: the elements of the array Returns: List[int]: A list of integers, each being the Kth smallest element for the corresponding test case. >>> kth_smallest_element(3, [(5, 3, [7, 10, 4, 3, 20]), (6, 2, [1, 2, 3, 4, 5, 6]), (4, 1, [10, 2, 8, 6])]) [7, 2, 2] >>> kth_smallest_element(1, [(1, 1, [9])]) [9] >>> kth_smallest_element(1, [(3, 2, [2, 2, 2])]) [2] >>> kth_smallest_element(1, [(5, 5, [5, 4, 3, 2, 1])]) [5] >>> kth_smallest_element(1, [(4, 1, [4, 3, 2, 1])]) [1] >>> kth_smallest_element(1, [(4, 3, [1, 2, 3, 4])]) [3]","solution":"def kth_smallest_element(T, test_cases): results = [] for i in range(T): N, K, array = test_cases[i] sorted_array = sorted(array) results.append(sorted_array[K-1]) return results # Example usage: kth_smallest_element(3, [(5, 3, [7, 10, 4, 3, 20]), (6, 2, [1, 2, 3, 4, 5, 6]), (4, 1, [10, 2, 8, 6])])"},{"question":"def can_form_palindrome(s: str) -> bool: Write a function that takes a string as input and returns \`True\` if the string can be rearranged to form a palindrome, and \`False\` otherwise. A palindrome is a word that reads the same backward as forward. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abc\\") False # Add your code here","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter # Count the frequencies of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be rearranged into a palindrome # There must be at most one character with an odd frequency return odd_count <= 1"},{"question":"from typing import List def calculate_volume(heights: List[int]) -> int: Given a list of integers representing the height of hills and valleys in a landscape, compute the total volume of water that would be trapped between the hills after it rains. :param heights: List of non-negative integers representing the height of hills and valleys :return: Integer representing the total volume of water trapped Examples: >>> calculate_volume([2, 0, 2]) 2 >>> calculate_volume([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> calculate_volume([3, 0, 1, 3, 0, 5]) 8 >>> calculate_volume([]) 0 >>> calculate_volume([4,2,0,3,2,5]) 9 pass","solution":"def calculate_volume(heights): Calculate the total volume of water that can be trapped between the hills. :param heights: List of integers representing the height of hills and valleys :return: Integer representing the total volume of water trapped if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] volume = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) volume += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) volume += max(0, right_max - heights[right]) return volume"},{"question":"def max_books_on_shelf(num_cases: int, cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum number of books Julia can place on the shelf without exceeding the weight limit. Args: num_cases (int): Number of test cases. cases (List[Tuple[Tuple[int, int], List[int]]]): List of tuples where each tuple contains: - (N, W): A tuple of two integers where N is the number of books and W is the maximum load capacity of the shelf. - List of integers representing the thickness of each book. Returns: List[int]: List of integers where each integer represents the maximum number of books that can be placed on the shelf for each test case. >>> max_books_on_shelf(2, [[(5, 50), [10, 20, 30, 40, 15]], [(4, 100), [40, 50, 75, 20]]]) [3, 2] >>> max_books_on_shelf(1, [[(3, 10), [3, 3, 3]]]) [3] pass # Example usage: # num_cases = 2 # cases = [ # [(5, 50), [10, 20, 30, 40, 15]], # [(4, 100), [40, 50, 75, 20]] # ] # print(max_books_on_shelf(num_cases, cases)) # Output: [3, 2]","solution":"def max_books_on_shelf(num_cases, cases): results = [] for case in cases: N, W = case[0] thicknesses = case[1] thicknesses.sort() # Sort the books by thickness to optimize the number of books total_thickness = 0 count = 0 for thickness in thicknesses: if total_thickness + thickness <= W: total_thickness += thickness count += 1 else: break results.append(count) return results # Example usage: # num_cases = 2 # cases = [ # [(5, 50), [10, 20, 30, 40, 15]], # [(4, 100), [40, 50, 75, 20]] # ] # print(max_books_on_shelf(num_cases, cases)) # Output: [3, 2]"},{"question":"def square_even_numbers(nums: List[int]) -> List[int]: Takes a list of integers, filters out the odd numbers, and returns a new list with the squares of the remaining even numbers. Args: nums (list): List of integers Returns: list: List of squares of even numbers >>> square_even_numbers([1, 2, 3, 4, 5, 6]) [4, 16, 36] >>> square_even_numbers([2, 4, 6, 8]) [4, 16, 36, 64] >>> square_even_numbers([1, 3, 5, 7]) [] >>> square_even_numbers([]) [] >>> square_even_numbers([2]) [4] >>> square_even_numbers([1]) []","solution":"def square_even_numbers(nums): Takes a list of integers, filters out the odd numbers, and returns a new list with the squares of the remaining even numbers. Args: nums (list): List of integers Returns: list: List of squares of even numbers return [num ** 2 for num in nums if num % 2 == 0]"},{"question":"from typing import List, Tuple def preprocess_sum_matrix(n: int, m: int, R: List[List[int]]) -> List[List[int]]: Preprocess the rainfall matrix to create a prefix sum matrix. pass # Implement the function def compute_submatrix_sum(prefix_sum: List[List[int]], iL: int, iR: int, jL: int, jR: int) -> int: Calculate the sum for the submatrix using the prefix sum matrix. pass # Implement the function def solve_rainfall_queries(n: int, m: int, R: List[List[int]], queries: List[Tuple[int, int, int, int]], questions: List[Tuple[int, int, int, int]]) -> List[int]: Answer the questions about the sum of rainfall in specific submatrices. >>> n, m, q = 3, 3, 5 >>> rainfall_matrix = [ >>> [9, 5, 4], >>> [2, 6, 7], >>> [1, 9, 3] >>> ] >>> queries = [ >>> (1, 2, 1, 3), >>> (1, 3, 1, 1), >>> (2, 3, 1, 2), >>> (1, 1, 2, 2), >>> (2, 3, 3, 3) >>> ] >>> questions = [ >>> (1, 2, 1, 3), >>> (1, 3, 1, 1) >>> ] >>> solve_rainfall_queries(n, m, rainfall_matrix, queries, questions) [33, 12] pass # Implement the function","solution":"def preprocess_sum_matrix(n, m, R): # Create prefix sum matrix prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n+1): for j in range(1, m+1): prefix_sum[i][j] = R[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] return prefix_sum def compute_submatrix_sum(prefix_sum, iL, iR, jL, jR): # Calculate sum for the submatrix using the prefix sum matrix return ( prefix_sum[iR][jR] - prefix_sum[iL-1][jR] - prefix_sum[iR][jL-1] + prefix_sum[iL-1][jL-1] ) def solve_rainfall_queries(n, m, R, queries, questions): results = [] # Preprocess the matrix to get the prefix sum matrix prefix_sum = preprocess_sum_matrix(n, m, R) # Process each question for question in questions: iL, iR, jL, jR = question result = compute_submatrix_sum(prefix_sum, iL, iR, jL, jR) results.append(result) return results # Given input data n, m, q = 3, 3, 5 rainfall_matrix = [ [9, 5, 4], [2, 6, 7], [1, 9, 3] ] queries = [ (1, 2, 1, 3), (1, 3, 1, 1), (2, 3, 1, 2), (1, 1, 2, 2), (2, 3, 3, 3) ] questions = [ (1, 2, 1, 3), (1, 3, 1, 1) ] # Execute the function output = solve_rainfall_queries(n, m, rainfall_matrix, queries, questions) print(output)"},{"question":"from typing import List, Tuple def range_pow_sum(powers: List[int], queries: List[Tuple[int, int]]) -> List[int]: Help Captain Marvel by summing her powers in an efficient algorithm. Given a list of powers and multiple queries, returns the sum of powers for each specified range. Args: powers (List[int]): A list of integers where the i-th element represents Captain Marvel's power in the i-th battle. queries (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers (l, r) representing the start and end battle indices. Returns: List[int]: A list of integers where the i-th element is the sum of powers from the l-th to r-th battle for the i-th query. Examples: >>> range_pow_sum([3, 2, 5, 10, 7], [(1, 3), (2, 5), (4, 4), (1, 5)]) [10, 24, 10, 27] >>> range_pow_sum([1, 2, 3, 4, 5], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) [1, 2, 3, 4, 5] pass def test_range_pow_sum_example(): powers = [3, 2, 5, 10, 7] queries = [(1, 3), (2, 5), (4, 4), (1, 5)] expected = [10, 24, 10, 27] assert range_pow_sum(powers, queries) == expected def test_range_pow_sum_single_element(): powers = [1, 2, 3, 4, 5] queries = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] expected = [1, 2, 3, 4, 5] assert range_pow_sum(powers, queries) == expected def test_range_pow_sum_entire_range(): powers = [1, 2, 3, 4, 5] queries = [(1, 5)] expected = [15] assert range_pow_sum(powers, queries) == expected def test_range_pow_sum_multiple_same_range(): powers = [1, 1, 1, 1, 1] queries = [(1, 3), (1, 3), (1, 3)] expected = [3, 3, 3] assert range_pow_sum(powers, queries) == expected def test_range_pow_sum_large_values(): powers = [10**9, 10**9, 10**9, 10**9, 10**9] queries = [(1, 3), (2, 4), (3, 5), (1, 5)] expected = [3*10**9, 3*10**9, 3*10**9, 5*10**9] assert range_pow_sum(powers, queries) == expected def test_range_pow_sum_single_query(): powers = [7, 8, 9, 10] queries = [(2, 4)] expected = [27] assert range_pow_sum(powers, queries) == expected","solution":"from typing import List, Tuple def range_pow_sum(powers: List[int], queries: List[Tuple[int, int]]) -> List[int]: # Compute a prefix sum array n = len(powers) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + powers[i - 1] result = [] for l, r in queries: # Adjust for 1-based index sum_power = prefix_sums[r] - prefix_sums[l - 1] result.append(sum_power) return result"},{"question":"def kthSmallestInSubarray(N: int, Q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Returns the k-th smallest numbers for given subarrays based on the provided queries. Parameters: - N (int): Number of elements in the array - Q (int): Number of queries - array (list of int): The array of integers - queries (list of tuple): Each tuple contains three integers (L, R, K) Returns: - list of int: The k-th smallest elements for each query, or -1 if K is larger than subarray length. pass from solution import kthSmallestInSubarray def test_sample_case_1(): assert kthSmallestInSubarray(6, 3, [5, 3, 8, 6, 2, 7], [(1, 4, 3), (2, 5, 2), (1, 6, 5)]) == [6, 3, 7] def test_single_element_subarray(): assert kthSmallestInSubarray(5, 2, [1, 2, 3, 4, 5], [(2, 2, 1), (1, 1, 1)]) == [2, 1] def test_k_too_large(): assert kthSmallestInSubarray(5, 1, [1, 2, 3, 4, 5], [(1, 3, 5)]) == [-1] def test_entire_array_query(): assert kthSmallestInSubarray(4, 1, [4, 3, 2, 1], [(1, 4, 2)]) == [2] def test_multiple_queries(): assert kthSmallestInSubarray(7, 4, [10, 20, 30, 40, 50, 60, 70], [(1, 7, 4), (1, 5, 1), (2, 4, 2), (3, 7, 3)]) == [40, 10, 30, 50]","solution":"def kthSmallestInSubarray(N, Q, array, queries): Returns the k-th smallest numbers for given subarrays based on the provided queries. Parameters: - N (int): Number of elements in the array - Q (int): Number of queries - array (list of int): The array of integers - queries (list of tuple): Each tuple contains three integers (L, R, K) Returns: - list of int: The k-th smallest elements for each query, or -1 if K is larger than subarray length. results = [] for L, R, K in queries: subarray = array[L-1:R] subarray.sort() if K > len(subarray): results.append(-1) else: results.append(subarray[K-1]) return results"},{"question":"def unique_in_order(lst): Returns a new list with only the unique integers from the original list, preserving their order. >>> unique_in_order([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_in_order([1, 1, 1, 1]) [1] >>> unique_in_order([4, 3, 2, 1]) [4, 3, 2, 1] >>> unique_in_order([]) [] >>> unique_in_order([7]) [7] >>> unique_in_order([1, 2, 2, 'a', 'a', 'b']) [1, 2, 'a', 'b'] >>> unique_in_order([-1, -2, -2, 3, 4, -1, 5]) [-1, -2, 3, 4, 5] >>> unique_in_order([1, \\"1\\", 1]) [1, '1']","solution":"def unique_in_order(lst): Returns a new list with only the unique integers from the original list, preserving their order. seen = set() unique_list = [] for item in lst: if item not in seen: unique_list.append(item) seen.add(item) return unique_list"},{"question":"def rob(nums): Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. The houses are arranged in a circle, so the first and last houses are also adjacent. >>> rob([2,3,2]) 3 >>> rob([1,2,3,1]) 4 >>> rob([0]) 0 >>> rob([]) 0 >>> rob([5]) 5 >>> rob([2, 3]) 3 >>> rob([1, 1, 1, 1]) 2 >>> rob([6,7,1,30,8,2,4]) 41","solution":"def rob(nums): Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. The houses are arranged in a circle, so the first and last houses are also adjacent. if not nums: return 0 if len(nums) == 1: return nums[0] def rob_linear(nums): prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr # Compare the results of two scenarios: # 1. Rob houses from the first to the second-last # 2. Rob houses from the second to the last return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def extract_subsequence(sequence: str, subsequence: str) -> list: Evaluates whether a given subsequence exists in a given sequence, and if it does, returns the starting and ending indices of the first occurrence of the subsequence. If the subsequence does not exist, returns [-1, -1]. Examples: >>> extract_subsequence(\\"abracadabra\\", \\"cada\\") -> [4, 7] >>> extract_subsequence(\\"hello world\\", \\"world\\") -> [6, 10] >>> extract_subsequence(\\"coding is fun\\", \\"is\\") -> [7, 8] >>> extract_subsequence(\\"coding is fun\\", \\"xyz\\") -> [-1, -1] pass from solution import extract_subsequence def test_subsequence_exists(): assert extract_subsequence(\\"abracadabra\\", \\"cada\\") == [4, 7] assert extract_subsequence(\\"hello world\\", \\"world\\") == [6, 10] assert extract_subsequence(\\"coding is fun\\", \\"is\\") == [7, 8] def test_subsequence_not_exists(): assert extract_subsequence(\\"coding is fun\\", \\"xyz\\") == [-1, -1] assert extract_subsequence(\\"hello\\", \\"hellos\\") == [-1, -1] def test_empty_strings(): assert extract_subsequence(\\"\\", \\"\\") == [0, -1] assert extract_subsequence(\\"coding\\", \\"\\") == [0, -1] assert extract_subsequence(\\"\\", \\"code\\") == [-1, -1] def test_subsequence_longer_than_sequence(): assert extract_subsequence(\\"short\\", \\"longerthan\\") == [-1, -1] def test_subsequence_at_the_start(): assert extract_subsequence(\\"abcdef\\", \\"abc\\") == [0, 2] def test_subsequence_at_the_end(): assert extract_subsequence(\\"abcdef\\", \\"def\\") == [3, 5]","solution":"def extract_subsequence(sequence: str, subsequence: str) -> list: Finds the starting and ending indices of the first occurrence of subsequence in sequence. If the subsequence is not found, returns [-1, -1]. # Find the starting index of the subsequence start_index = sequence.find(subsequence) # If the subsequence is not found, return [-1, -1] if start_index == -1: return [-1, -1] # Calculate the ending index end_index = start_index + len(subsequence) - 1 return [start_index, end_index]"},{"question":"def reverse_words_in_sentence(s: str) -> str: Reverses the words in the sentence while preserving whitespace and initial word order. Parameters: s (str): A sentence consisting of words separated by single spaces. Returns: str: A sentence where each word has been reversed but the order of words is preserved. >>> reverse_words_in_sentence(\\"I love programming\\") 'I evol gnimmargorp' >>> reverse_words_in_sentence(\\"Hello world!\\") 'olleH !dlrow' >>> reverse_words_in_sentence(\\"Python is Amazing\\") 'nohtyP si gnizamA' >>> reverse_words_in_sentence(\\"\\") '' >>> reverse_words_in_sentence(\\"a b c\\") 'a b c' >>> reverse_words_in_sentence(\\"madam racecar\\") 'madam racecar'","solution":"def reverse_words_in_sentence(s): Reverses the words in the sentence while preserving whitespace and initial word order. Parameters: s (str): A sentence consisting of words separated by single spaces. Returns: str: A sentence where each word has been reversed but the order of words is preserved. return ' '.join(word[::-1] for word in s.split())"},{"question":"from typing import List def find_peaks(arr: List[int]) -> List[int]: Finds all peak elements in the given array of integers. A peak is defined as an element greater than both its neighbors. For the elements at the edges, only one neighbor is considered. >> find_peaks([1, 3, 7, 1, 2, 6, 3, 2, 7, 10]) [7, 6, 10] >> find_peaks([10, 20, 15, 2, 23, 90, 67]) [20, 90] >> find_peaks([]) []","solution":"from typing import List def find_peaks(arr: List[int]) -> List[int]: Finds all peak elements in the given array of integers. A peak is defined as an element greater than both its neighbors. if not arr: return [] n = len(arr) peaks = [] # Check for leftmost element if n == 1 or arr[0] > arr[1]: peaks.append(arr[0]) # Check for middle elements for i in range(1, n - 1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: peaks.append(arr[i]) # Check for rightmost element if n > 1 and arr[n-1] > arr[n-2]: peaks.append(arr[n-1]) return peaks"},{"question":"def is_valid_sudoku(grid): Validate if a given 9x9 Sudoku grid is valid. The Sudoku grid must be a 9x9 list of lists containing integers from 0 to 9, where 0 represents an empty cell. >>> grid = [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> is_valid_sudoku(grid) True >>> grid = [ ... [5, 5, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> is_valid_sudoku(grid) False","solution":"def is_valid_sudoku(grid): def is_valid_block(block): nums = [num for num in block if num != 0] return len(nums) == len(set(nums)) def get_subgrid(grid, row, col): return [grid[r][c] for r in range(row, row + 3) for c in range(col, col + 3)] # Check rows and columns for i in range(9): if not is_valid_block(grid[i]): # Check row return False if not is_valid_block([grid[r][i] for r in range(9)]): # Check column return False # Check 3x3 sub-grids for row in range(0, 9, 3): for col in range(0, 9, 3): if not is_valid_block(get_subgrid(grid, row, col)): return False return True"},{"question":"def find_duplicates(lst: List[int]) -> List[int]: Returns the duplicates in the list in ascending order. >>> find_duplicates([1, 2, 3, 2, 3, 4, 5]) == [2, 3] >>> find_duplicates([4, 5, 6, 7, 8, 5, 6, 9]) == [5, 6] >>> find_duplicates([10, 20, 20, 30, 10, 30, 40]) == [10, 20, 30] >>> find_duplicates([1, 2, 3, 4, 5]) == [] >>> find_duplicates([-5, -4, -3, -2, -1]) == [] >>> find_duplicates([-1, -2, -3, -2, -3, -4, -5]) == [-3, -2] >>> find_duplicates([0, -1, -1, 0, 1, 1]) == [-1, 0, 1] >>> find_duplicates([10, 20, -20, 30, 40, -20, 20]) == [-20, 20] >>> find_duplicates([-10, -20, -30, -40, -50, -10, -50]) == [-50, -10]","solution":"def find_duplicates(lst): Returns the duplicates in the list in ascending order. from collections import Counter counts = Counter(lst) duplicates = [item for item, count in counts.items() if count > 1] return sorted(duplicates)"},{"question":"import heapq def shortest_transmission_time(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, d: int) -> int: Determines the shortest transmission time from node \`s\` to node \`d\` in a network described by \`n\` nodes and \`m\` edges using Dijkstra's algorithm. Parameters: - n : int : Number of nodes - m : int : Number of edges - edges : List[Tuple[int, int, int]] : List of tuples representing the edges and their weights - s : int : Source node - d : int : Destination node Returns: int : The shortest transmission time; if no path exists returns -1 Example Usage: >>> shortest_transmission_time(5, 6, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 5, 3), (4, 5, 1)], 1, 5) 6 >>> shortest_transmission_time(4, 2, [(1, 2, 3), (3, 4, 4)], 1, 4) -1 from solution import shortest_transmission_time def test_example_case(): n = 5 m = 6 edges = [ (1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 5, 3), (4, 5, 1) ] s, d = 1, 5 assert shortest_transmission_time(n, m, edges, s, d) == 6 def test_no_path(): n = 4 m = 3 edges = [ (1, 2, 4), (2, 3, 1), (3, 4, 5) ] s, d = 1, 4 assert shortest_transmission_time(n, m, edges, s, d) == 10 def test_disconnected_node(): n = 4 m = 2 edges = [ (1, 2, 3), (3, 4, 4) ] s, d = 1, 4 assert shortest_transmission_time(n, m, edges, s, d) == -1 def test_single_edge(): n = 2 m = 1 edges = [ (1, 2, 1) ] s, d = 1, 2 assert shortest_transmission_time(n, m, edges, s, d) == 1 def test_same_start_and_end(): n = 3 m = 3 edges = [ (1, 2, 2), (2, 3, 3), (1, 3, 6) ] s, d = 1, 1 assert shortest_transmission_time(n, m, edges, s, d) == 0","solution":"import heapq def shortest_transmission_time(n, m, edges, s, d): Finds the shortest transmission time from node \`s\` to node \`d\` using Dijkstra's algorithm. # Create a graph representation graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Priority queue for Dijkstra's algorithm pq = [(0, s)] # Distance table, initialized to infinity distances = {i: float('inf') for i in range(1, n+1)} distances[s] = 0 while pq: current_dist, current_node = heapq.heappop(pq) if current_node == d: return current_dist for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[d] == float('inf') else distances[d]"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise returns False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def filter_primes(arr: List[int]) -> List[int]: Returns a list of prime numbers from the given list of positive integers. >>> filter_primes([2, 3, 4, 5, 10, 11, 13, 14, 17]) [2, 3, 5, 11, 13, 17] >>> filter_primes([1, 2, 3, 4, 5]) [2, 3, 5]","solution":"def is_prime(n): Returns True if n is a prime number, otherwise returns False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(arr): Returns a list of prime numbers from the given list of positive integers. return [x for x in arr if is_prime(x)]"},{"question":"from typing import List def temperature_trend(temps: List[int]) -> List[str]: Returns a list of trends representing temperature changes. >>> temperature_trend([72, 74, 73, 73, 75, 78]) [\\"START\\", \\"UP\\", \\"DOWN\\", \\"SAME\\", \\"UP\\", \\"UP\\"] >>> temperature_trend([60]) [\\"START\\"] >>> temperature_trend([45, 45, 45]) [\\"START\\", \\"SAME\\", \\"SAME\\"] >>> temperature_trend([]) [] >>> temperature_trend([32, 31, 30, 33]) [\\"START\\", \\"DOWN\\", \\"DOWN\\", \\"UP\\"]","solution":"def temperature_trend(temps): Returns a list of trends representing temperature changes. if not temps: return [] trends = [\\"START\\"] for i in range(1, len(temps)): if temps[i] > temps[i - 1]: trends.append(\\"UP\\") elif temps[i] < temps[i - 1]: trends.append(\\"DOWN\\") else: trends.append(\\"SAME\\") return trends"},{"question":"def three_sum(nums: List[int], k: int) -> bool: Determine if there are three integers in the list whose sum is equal to k. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([1, 2, 4, 5, 6], 10) True >>> three_sum([1, 2, 4, 5, 6], 20) False","solution":"def three_sum(nums, k): Determine if there are three integers in the list whose sum is equal to k. :param nums: List[int] - A list of integers :param k: int - The target sum :return: bool - True if there are three integers that sum up to k, otherwise False nums.sort() for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == k: return True elif total < k: left += 1 else: right -= 1 return False"},{"question":"def repeat_string(s: str, n: int) -> str: Returns a new string that is a repeated version of the input string s. The number n determines how many times the string should be repeated. If n is zero or negative, return an empty string. Examples: >>> repeat_string('abc', 3) 'abcabcabc' >>> repeat_string('hello', 2) 'hellohello' >>> repeat_string('test', 0) '' >>> repeat_string('sample', -1) ''","solution":"def repeat_string(s, n): Returns a new string that is a repeated version of the input string s. The number n determines how many times the string should be repeated. If n is zero or negative, return an empty string. if n <= 0: return \\"\\" return s * n"},{"question":"def findHiddenWords(strings: List[str], minLength: int) -> List[str]: Finds hidden words of at least minLength in the given list of strings. :param strings: List of strings to search for hidden words. :param minLength: Minimum length of the hidden words. :return: List of all hidden words meeting or exceeding the specified length. >>> findHiddenWords(['hello'], 2) ['he', 'hel', 'hell', 'hello', 'el', 'ell', 'ello', 'll', 'llo', 'lo'] >>> findHiddenWords(['abcd'], 3) ['abc', 'abcd', 'bcd'] >>> findHiddenWords([''], 2) [] >>> findHiddenWords(['a', 'b'], 1) ['a', 'b'] >>> findHiddenWords(['abc'], 4) []","solution":"def findHiddenWords(strings, minLength): Finds hidden words of at least minLength in the given list of strings. :param strings: List of strings to search for hidden words. :param minLength: Minimum length of the hidden words. :return: List of all hidden words meeting or exceeding the specified length. hidden_words = [] for string in strings: for i in range(len(string) - minLength + 1): for length in range(minLength, len(string) - i + 1): hidden_words.append(string[i:i+length]) return hidden_words"},{"question":"def apply_operations(operations: List[str]) -> str: Apply a sequence of operations on an empty document and return the final state of the document. Operations can be one of the following types: - \\"insert pos char\\": Insert character 'char' at position 'pos' - \\"delete pos\\": Delete character at position 'pos' >>> apply_operations([\\"insert 0 a\\", \\"insert 1 b\\", \\"delete 1\\"]) 'a' >>> apply_operations([\\"insert 0 a\\", \\"insert 1 b\\", \\"insert 1 c\\", \\"delete 0\\"]) 'cb' pass def final_documents(test_cases: List[List[str]]) -> List[str]: Given a list of test cases, where each test case is a list of operations, return the final state of the document for each test case. >>> final_documents([[\\"insert 0 a\\", \\"insert 1 b\\", \\"delete 1\\"], [\\"insert 0 a\\", \\"insert 1 b\\", \\"insert 1 c\\", \\"delete 0\\"]]) ['a', 'cb'] pass","solution":"def apply_operations(operations): document = [] for op in operations: parts = op.split() if parts[0] == \\"insert\\": pos = int(parts[1]) char = parts[2] document.insert(pos, char) elif parts[0] == \\"delete\\": pos = int(parts[1]) if 0 <= pos < len(document): document.pop(pos) return ''.join(document) def final_documents(test_cases): results = [] for case in test_cases: results.append(apply_operations(case)) return results"},{"question":"from typing import List def find_concatenated_strings(words: List[str]) -> List[str]: Given a list of strings, find all the strings that can be formed by concatenating the given strings in the list (including themselves) a certain number of times. Returns the list of these concatenated strings in alphabetical order. >>> find_concatenated_strings([\\"cat\\", \\"dog\\", \\"catdog\\"]) [\\"catdog\\"] >>> find_concatenated_strings([\\"ab\\", \\"abc\\", \\"abcd\\", \\"abab\\"]) [\\"abab\\"] >>> find_concatenated_strings([\\"one\\", \\"two\\", \\"onetwoone\\"]) [\\"onetwoone\\"] >>> find_concatenated_strings([\\"apple\\", \\"banana\\", \\"cherry\\"]) [] >>> find_concatenated_strings([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) [\\"aa\\", \\"aaa\\", \\"aaaa\\"] >>> find_concatenated_strings([\\"abc\\", \\"abcabc\\", \\"abc\\", \\"def\\"]) [\\"abcabc\\"]","solution":"def find_concatenated_strings(words): Given a list of strings, find all the strings that can be formed by concatenating the given strings in the list (including themselves) a certain number of times. Returns the list of these concatenated strings in alphabetical order. word_set = set(words) concatenated_words = [] for word in words: n = len(word) dp = [False] * (n + 1) # dp[i] = True means word[:i] can be formed by concatenating other words dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and word[j:i] in word_set and word[j:i] != word: dp[i] = True break if dp[n]: concatenated_words.append(word) return sorted(concatenated_words)"},{"question":"def final_position(start_x: int, start_y: int, instructions: str) -> tuple: Calculate the final coordinates after executing a series of movement instructions. Args: start_x (int): Starting x-coordinate start_y (int): Starting y-coordinate instructions (str): A string of movement instructions which can be 'U', 'D', 'L', 'R' Returns: tuple: Final coordinates (end_x, end_y) after performing all the movements Example: >>> final_position(0, 0, \\"UURLD\\") (0, 1) >>> final_position(-2, 3, \\"RRDDLU\\") (-1, 2) >>> final_position(5, 5, \\"\\") (5, 5) from solution import final_position def test_final_position_basic(): assert final_position(0, 0, \\"UURLD\\") == (0, 1) def test_final_position_with_negative_start(): assert final_position(-2, 3, \\"RRDDLU\\") == (-1, 2) def test_final_position_no_movements(): assert final_position(5, 5, \\"\\") == (5, 5) def test_final_position_all_directions(): assert final_position(0, 0, \\"UDLR\\") == (0, 0) assert final_position(1, 1, \\"RLUD\\") == (1, 1) def test_final_position_only_ups(): assert final_position(0, 0, \\"UUU\\") == (0, 3) def test_final_position_only_downs(): assert final_position(0, 0, \\"DDD\\") == (0, -3) def test_final_position_only_lefts(): assert final_position(0, 0, \\"LLL\\") == (-3, 0) def test_final_position_only_rights(): assert final_position(0, 0, \\"RRR\\") == (3, 0)","solution":"def final_position(start_x, start_y, instructions): Calculate the final coordinates after executing a series of movement instructions. Args: start_x (int): Starting x-coordinate start_y (int): Starting y-coordinate instructions (str): A string of movement instructions which can be 'U', 'D', 'L', 'R' Returns: tuple: Final coordinates (end_x, end_y) after performing all the movements x, y = start_x, start_y for instruction in instructions: if instruction == 'U': y += 1 elif instruction == 'D': y -= 1 elif instruction == 'L': x -= 1 elif instruction == 'R': x += 1 return (x, y)"},{"question":"def convert_to_seconds(time_str: str) -> int: Converts a time string in the format hh:mm:ss to the total number of seconds. def median_finish_times(times: List[str]) -> Union[str, List[str]]: Given a list of participants' finish times in the format hh:mm:ss, returns the participants whose finish times are in the median of the list when ordered. >>> median_finish_times([\\"03:15:30\\", \\"02:45:20\\", \\"04:20:50\\", \\"03:10:15\\", \\"01:50:40\\"]) == \\"03:10:15\\" >>> median_finish_times([\\"04:05:20\\", \\"03:35:10\\", \\"06:45:30\\", \\"03:25:40\\", \\"02:15:50\\", \\"05:30:25\\"]) == [\\"03:35:10\\", \\"04:05:20\\"] pass","solution":"def convert_to_seconds(time_str): Converts a time string in the format hh:mm:ss to the total number of seconds. h, m, s = map(int, time_str.split(':')) return h * 3600 + m * 60 + s def median_finish_times(times): Given a list of participants' finish times in the format hh:mm:ss, returns the participants whose finish times are in the median of the list when ordered. # Convert each time string to total seconds times_in_seconds = [(time, convert_to_seconds(time)) for time in times] # Sort the list by the total seconds times_in_seconds.sort(key=lambda x: x[1]) n = len(times_in_seconds) if n % 2 == 1: # If odd, return the middle element return times_in_seconds[n // 2][0] else: # If even, return the two middle elements return [ times_in_seconds[n // 2 - 1][0], times_in_seconds[n // 2][0] ]"},{"question":"import re from collections import defaultdict from typing import Dict def wordFrequency(sentence: str) -> Dict[str, int]: Returns a dictionary with each unique word as keys and their frequency of occurrence as values. The function is case insensitive. >>> wordFrequency(\\"The quick brown fox jumps over the lazy dog. The fox was quick.\\") {'the': 3, 'quick': 2, 'brown': 1, 'fox': 2, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1, 'was': 1} >>> wordFrequency(\\"\\") {} >>> wordFrequency(\\"Apple apple APPLE aPPle\\") {'apple': 4} >>> wordFrequency(\\"Hello, world! Hello world?\\") {'hello': 2, 'world': 2} >>> wordFrequency(\\"123 test 123 TEST test\\") {'123': 2, 'test': 3} >>> wordFrequency(\\"Testing, testing! One, 1, two, 2.\\") {'testing': 2, 'one': 1, '1': 1, 'two': 1, '2': 1}","solution":"import re from collections import defaultdict def wordFrequency(sentence): Returns a dictionary with each word as keys and their frequency of occurrence as values. The function is case insensitive. # Convert to lowercase sentence = sentence.lower() # Find all words using regex words = re.findall(r'bw+b', sentence) # Create a default dictionary to store word frequencies frequency_dict = defaultdict(int) # Count frequencies for word in words: frequency_dict[word] += 1 return dict(frequency_dict)"},{"question":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest possible sequence where each character appears at most once. Example: >>> longest_unique_substring_length(\\"abac\\") 3 >>> longest_unique_substring_length(\\"aaabbbccc\\") 3 >>> longest_unique_substring_length(\\"abcabcbb\\") 3","solution":"def longest_unique_substring_length(s): Returns the length of the longest possible sequence where each character appears at most once. return len(set(s))"},{"question":"def sequence_type(nums): Create a function that accepts a list of integers and returns a string indicating the type of sequence the numbers form. The possible return values should be: - \\"Arithmetic\\": if the numbers form an arithmetic sequence. - \\"Geometric\\": if the numbers form a geometric sequence. - \\"Neither\\": if the numbers do not form either an arithmetic or geometric sequence. An arithmetic sequence is a sequence of numbers such that the difference between subsequent numbers is constant. A geometric sequence is a sequence of numbers such that the ratio between subsequent numbers is constant. You can assume the list will have at least two integers. >>> sequence_type([2, 4, 6, 8]) == \\"Arithmetic\\" >>> sequence_type([3, 9, 27]) == \\"Geometric\\" >>> sequence_type([1, 2, 4, 8]) == \\"Geometric\\" >>> sequence_type([1, 5, 10, 15]) == \\"Neither\\" def test_sequence_arithmetic(): assert sequence_type([2, 4, 6, 8]) == \\"Arithmetic\\" assert sequence_type([0, 5, 10, 15]) == \\"Arithmetic\\" assert sequence_type([7, 7, 7, 7]) == \\"Arithmetic\\" def test_sequence_geometric(): assert sequence_type([3, 9, 27]) == \\"Geometric\\" assert sequence_type([1, 2, 4, 8]) == \\"Geometric\\" assert sequence_type([5, 25, 125]) == \\"Geometric\\" def test_sequence_neither(): assert sequence_type([1, 5, 10, 15]) == \\"Neither\\" assert sequence_type([2, 3, 5, 8]) == \\"Neither\\" assert sequence_type([0, 2, 4, 8]) == \\"Neither\\" def test_sequence_mixed(): assert sequence_type([2, 4, 6, 8, 16]) == \\"Neither\\" assert sequence_type([1, 2, 4, 7]) == \\"Neither\\" test_sequence_arithmetic() test_sequence_geometric() test_sequence_neither() test_sequence_mixed()","solution":"def sequence_type(nums): if len(nums) < 2: return \\"Neither\\" is_arithmetic = True is_geometric = True # Check for arithmetic sequence common_difference = nums[1] - nums[0] for i in range(1, len(nums)): if nums[i] - nums[i - 1] != common_difference: is_arithmetic = False break # Check for geometric sequence if nums[0] == 0: is_geometric = False else: common_ratio = nums[1] / nums[0] for i in range(1, len(nums)): if nums[i] == 0 or nums[i] / nums[i - 1] != common_ratio: is_geometric = False break if is_arithmetic: return \\"Arithmetic\\" elif is_geometric: return \\"Geometric\\" else: return \\"Neither\\""},{"question":"def find_anagram_indices(s: str, p: str) -> List[int]: Write a function that takes two parameters: a string \`s\` and a string \`p\`. The function should return a list of starting indices of the anagrams of \`p\` present in \`s\`. >>> find_anagram_indices(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagram_indices(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagram_indices(\\"abcdef\\", \\"gh\\") [] >>> find_anagram_indices(\\"aaabbb\\", \\"a\\") [0, 1, 2] >>> find_anagram_indices(\\"abc\\", \\"abc\\") [0] >>> find_anagram_indices(\\"aaa\\", \\"aa\\") [0, 1]","solution":"def find_anagram_indices(s, p): from collections import Counter p_len = len(p) s_len = len(s) result = [] if p_len > s_len: return result p_count = Counter(p) s_count = Counter(s[:p_len-1]) for i in range(p_len - 1, s_len): s_count[s[i]] += 1 if s_count == p_count: result.append(i - p_len + 1) s_count[s[i - p_len + 1]] -= 1 if s_count[s[i - p_len + 1]] == 0: del s_count[s[i - p_len + 1]] return result"},{"question":"class TreeNode: def __init__(self, index): self.index = index self.left = None self.right = None def build_tree(n, nodes_info): tree = {} for i in range(n): u, v, w = nodes_info[i] if u not in tree: tree[u] = TreeNode(u) if v != -1: tree[v] = TreeNode(v) tree[u].left = tree[v] if w != -1: tree[w] = TreeNode(w) tree[u].right = tree[w] return tree[1] # return the root node def compare_trees(t1, t2): if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False if t1.index != t2.index: return False return compare_trees(t1.left, t2.left) and compare_trees(t1.right, t2.right) def swap_children(tree, node_index): node = find_node(tree, node_index) if node: node.left, node.right = node.right, node.left def find_node(tree, node_index): if tree is None: return None if tree.index == node_index: return tree left_result = find_node(tree.left, node_index) if left_result: return left_result return find_node(tree.right, node_index) def play_game(n, nodes_info, q, queries): Determine if the binary tree will be the same as the original after performing a given sequence of swaps. Parameters: n (int): number of nodes in the binary tree. nodes_info (List[Tuple[int, int, int]]): a list of tuples representing the node and its children. q (int): number of queries. queries (List[int]): a list of queries where each query is the index of the node for which to swap the children. Returns: List[str]: a list of \\"YES\\" or \\"NO\\" indicating if the tree matches the original after each query. >>> play_game(5, [(1, 2, 3), (2, 4, 5), (3, -1, -1), (4, -1, -1), (5, -1, -1)], 3, [2, 3, 2]) ['NO', 'NO', 'YES'] >>> play_game(3, [(1, 2, 3), (2, -1, -1), (3, -1, -1)], 1, [1]) ['NO']","solution":"class TreeNode: def __init__(self, index): self.index = index self.left = None self.right = None def build_tree(n, nodes_info): tree = {} for i in range(n): u, v, w = nodes_info[i] if u not in tree: tree[u] = TreeNode(u) if v != -1: tree[v] = TreeNode(v) tree[u].left = tree[v] if w != -1: tree[w] = TreeNode(w) tree[u].right = tree[w] return tree[1] # return the root node def compare_trees(t1, t2): if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False if t1.index != t2.index: return False return compare_trees(t1.left, t2.left) and compare_trees(t1.right, t2.right) def swap_children(tree, node_index): node = find_node(tree, node_index) if node: node.left, node.right = node.right, node.left def find_node(tree, node_index): if tree is None: return None if tree.index == node_index: return tree left_result = find_node(tree.left, node_index) if left_result: return left_result return find_node(tree.right, node_index) def play_game(n, nodes_info, q, queries): original_tree = build_tree(n, nodes_info) current_tree = build_tree(n, nodes_info) results = [] for query in queries: swap_children(current_tree, query) if compare_trees(original_tree, current_tree): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def flatten_nested_list(nested_list): Flattens a nested list into a single list of integers, preserving order. >>> flatten_nested_list([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_nested_list([[1, 2, [3]], 4, [5, 6]]) [1, 2, 3, 4, 5, 6]","solution":"def flatten_nested_list(nested_list): Flattens a nested list into a single list of integers, preserving order. :param nested_list: List containing integers or nested lists :return: Flattened list of integers flat_list = [] def flatten(sublist): for item in sublist: if isinstance(item, list): flatten(item) else: flat_list.append(item) flatten(nested_list) return flat_list"},{"question":"def is_palindrome(num: int) -> bool: Determines if the digits of a given integer form a palindrome when read in reverse order. Args: num (int): A non-negative integer. 0 <= num <= 10^7 Returns: bool: True if the digits of num form a palindrome, otherwise False. Examples: >>> is_palindrome(12321) True >>> is_palindrome(12345) False >>> is_palindrome(0) True >>> is_palindrome(10000001) True >>> is_palindrome(100001) True","solution":"def is_palindrome(num): Determines if the digits of a given integer form a palindrome when read in reverse order. Args: num (int): A non-negative integer. 0 <= num <= 10^7 Returns: bool: True if the digits of num form a palindrome, otherwise False. str_num = str(num) return str_num == str_num[::-1]"},{"question":"def reverse_list(lst: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list with the elements in reverse order. Examples: >>> reverse_list([1, 2, 3]) [3, 2, 1] >>> reverse_list([7, 8, 9, 10]) [10, 9, 8, 7] >>> reverse_list([]) [] >>> reverse_list([-1, -2, -3]) [-3, -2, -1] >>> reverse_list([1, -2, 3, -4]) [-4, 3, -2, 1] pass # implement this function from typing import List def test_reverse_list_normal_case(): assert reverse_list([1, 2, 3]) == [3, 2, 1] def test_reverse_list_empty(): assert reverse_list([]) == [] def test_reverse_list_single_element(): assert reverse_list([42]) == [42] def test_reverse_list_negative_numbers(): assert reverse_list([-1, -2, -3]) == [-3, -2, -1] def test_reverse_list_mixed_numbers(): assert reverse_list([1, -2, 3, -4]) == [-4, 3, -2, 1]","solution":"def reverse_list(lst): Returns a new list with the elements of the original list in reverse order. Parameters: lst (list): A list of integers. Returns: list: A new list with elements in reverse order. return lst[::-1]"},{"question":"def greatest_contiguous_sum(arr: List[int]) -> int: Given a list of integers, find the greatest contiguous subarray sum. A contiguous subarray is a subarray made up of consecutive elements within the array. >>> greatest_contiguous_sum([1, -2, 3, 4, -5, 8]) == 10 >>> greatest_contiguous_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> greatest_contiguous_sum([1]) == 1 >>> greatest_contiguous_sum([5, 4, -1, 7, 8]) == 23 pass","solution":"from typing import List def greatest_contiguous_sum(arr: List[int]) -> int: # Initialize variables to store the maximum sum and current sum max_sum = current_sum = arr[0] for num in arr[1:]: # Update current_sum to be the maximum of the current number itself or the current sum plus the current number current_sum = max(num, current_sum + num) # Update max_sum to be the maximum of max_sum and current_sum max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_contiguous_subsequence(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest contiguous subsequence with an absolute difference of at most k between any two of its elements. >>> longest_contiguous_subsequence(5, 3, [1, 3, 5, 8, 6]) 3 >>> longest_contiguous_subsequence(5, 5, [1, 2, 3, 4, 5]) 5 >>> longest_contiguous_subsequence(5, 1, [1, 10, 20, 30, 40]) 1 >>> longest_contiguous_subsequence(1, 0, [5]) 1 >>> longest_contiguous_subsequence(5, 0, [7, 7, 7, 7, 7]) 5 >>> longest_contiguous_subsequence(5, 10000, [1, 5, 10, 100, 1000]) 5 >>> longest_contiguous_subsequence(5, 3, [1, 2, 10, 12, 2]) 2 >>> longest_contiguous_subsequence(4, 0, [5, 5, 5, 5]) 4","solution":"def longest_contiguous_subsequence(n, k, arr): Returns the length of the longest contiguous subsequence with an absolute difference of at most k between any two of its elements. if n == 0: return 0 max_len = 1 start = 0 for end in range(1, n): if abs(arr[end] - arr[start]) <= k: max_len = max(max_len, end - start + 1) else: start = end return max_len"},{"question":"def count_attendees(n): Returns the number of attendees at the event in the nth week. Parameters: n (int): The number of weeks from now. Returns: int: The total number of attendees at the event. >>> count_attendees(1) 10 >>> count_attendees(2) 15 >>> count_attendees(3) 30 >>> count_attendees(4) 60 >>> count_attendees(5) 78 >>> count_attendees(6) 101 >>> count_attendees(0) == None True >>> count_attendees(-1) == None True >>> count_attendees(\\"three\\") == None True pass","solution":"def count_attendees(n): Returns the number of attendees at the event in the nth week. if not isinstance(n, int) or n <= 0: return None attendees = 10 for week in range(1, n): if week == 1: attendees *= 1.5 elif week == 2 or week == 3: attendees *= 2 else: attendees *= 1.3 return int(attendees)"},{"question":"def duplicateExists(arr: List[int]) -> bool: Checks if any value appears at least twice in the array. >>> duplicateExists([1, 2, 3, 4, 5]) == False >>> duplicateExists([1, 2, 3, 4, 4]) == True >>> duplicateExists([]) == False >>> duplicateExists([1]) == False >>> duplicateExists([0, -1, -1, 2]) == True","solution":"def duplicateExists(arr): Checks if any value appears at least twice in the array. seen = set() for number in arr: if number in seen: return True seen.add(number) return False"},{"question":"def sieve_of_eratosthenes(n: int) -> List[bool]: Creates a list of boolean values representing whether numbers are prime up to n. >>> sieve_of_eratosthenes(10) [False, False, True, True, False, True, False, True, False, False, False] >>> sieve_of_eratosthenes(1) [False, False] def count_prime_pairs(limit: int) -> int: Counts prime pairs up to a given limit. >>> count_prime_pairs(10) 2 >>> count_prime_pairs(20) 4 >>> count_prime_pairs(50) 6 >>> count_prime_pairs(2) 0 def prime_pairs(test_cases: List[int]) -> List[int]: Counts prime pairs for a list of test cases. >>> prime_pairs([10, 20, 50]) [2, 4, 6] >>> prime_pairs([2]) [0] >>> prime_pairs([11]) [2] >>> prime_pairs([100]) [8]","solution":"def sieve_of_eratosthenes(n): Creates a list of boolean values representing whether numbers are prime up to n. is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return is_prime def count_prime_pairs(limit): primes = sieve_of_eratosthenes(limit) prime_pairs_count = 0 for i in range(2, limit - 1): if primes[i] and primes[i + 2]: prime_pairs_count += 1 return prime_pairs_count def prime_pairs(test_cases): results = [] for n in test_cases: results.append(count_prime_pairs(n)) return results"},{"question":"def can_book_all_tickets(num_of_tickets: int, bookings: List[Tuple[int, int]]) -> bool: Determine whether all bookings can be honored without any overlap. >>> can_book_all_tickets(10, [(1, 3), (5, 7), (8, 10)]) True >>> can_book_all_tickets(10, [(1, 5), (4, 6), (7, 9)]) False >>> can_book_all_tickets(5, [(1, 2), (2, 3), (4, 5)]) False >>> can_book_all_tickets(5, [(1, 1), (2, 2), (3, 3)]) True from solution import can_book_all_tickets def test_all_bookings_within_limit(): assert can_book_all_tickets(10, [(1, 3), (5, 7), (8, 10)]) == True def test_overlapping_bookings(): assert can_book_all_tickets(10, [(1, 5), (4, 6), (7, 9)]) == False assert can_book_all_tickets(5, [(1, 2), (2, 3), (4, 5)]) == False def test_edge_case_no_bookings(): assert can_book_all_tickets(10, []) == True def test_non_overlapping_bookings(): assert can_book_all_tickets(5, [(1, 1), (2, 2), (3, 3)]) == True def test_out_of_range_bookings(): assert can_book_all_tickets(10, [(0, 1)]) == False assert can_book_all_tickets(10, [(1, 11)]) == False assert can_book_all_tickets(10, [(10, 12)]) == False def test_invalid_bookings(): assert can_book_all_tickets(10, [(3, 2)]) == False def test_single_large_booking(): assert can_book_all_tickets(10, [(1, 10)]) == True def test_complex_case(): assert can_book_all_tickets(10, [(1, 2), (3, 4), (5, 6), (6, 7), (8, 10)]) == False assert can_book_all_tickets(4, [(1, 2), (3, 4), (4, 4)]) == False","solution":"from typing import List, Tuple def can_book_all_tickets(num_of_tickets: int, bookings: List[Tuple[int, int]]) -> bool: if not bookings: return True # Create a list to keep track of booked tickets booked = [0] * (num_of_tickets + 1) for start, end in bookings: if start < 1 or end > num_of_tickets or start > end: return False for i in range(start, end + 1): if booked[i] == 1: return False booked[i] = 1 return True"},{"question":"import heapq from typing import List, Tuple def find_min_cost(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Returns the minimum cost in gold coins required to travel from castle 1 to castle N using Dijkstra's algorithm. If there is no way to reach the last castle from the first castle, returns -1. >>> find_min_cost(4, 5, [(1, 2, 10), (1, 3, 20), (2, 3, 5), (2, 4, 30), (3, 4, 10)]) 25 >>> find_min_cost(4, 2, [(1, 2, 10), (3, 4, 20)]) -1 >>> find_min_cost(2, 1, [(1, 2, 5)]) 5 >>> find_min_cost(4, 5, [(1, 2, 10), (1, 3, 10), (2, 4, 10), (3, 4, 10), (2, 3, 5)]) 20 >>> find_min_cost(5, 2, [(1, 2, 10), (3, 4, 20)]) -1 >>> find_min_cost(4, 4, [(1, 2, 50), (2, 4, 50), (1, 3, 100), (3, 4, 50)]) 100","solution":"import heapq def find_min_cost(N, M, roads): Returns the minimum cost in gold coins required to travel from castle 1 to castle N using Dijkstra's algorithm. If there is no way to reach the last castle from the first castle, returns -1. # Create adjacency list graph = [[] for _ in range(N + 1)] for U, V, G in roads: graph[U].append((V, G)) graph[V].append((U, G)) # Dijkstra's algorithm min_cost = [float('inf')] * (N + 1) min_cost[1] = 0 pq = [(0, 1)] # (cost, node) while pq: current_cost, node = heapq.heappop(pq) if node == N: return current_cost for neighbor, toll in graph[node]: new_cost = current_cost + toll if new_cost < min_cost[neighbor]: min_cost[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return -1 if min_cost[N] == float('inf') else min_cost[N] # Example usage N = 4 M = 5 roads = [ (1, 2, 10), (1, 3, 20), (2, 3, 5), (2, 4, 30), (3, 4, 10) ] print(find_min_cost(N, M, roads)) # Output: 25"},{"question":"def max_gold(grid: List[List[int]]) -> int: Given a grid of dimensions n x m where each cell contains an integer value representing the amount of gold in that cell, find the maximum amount of gold one can collect by starting from any cell in the first column and moving to any cell in the last column. From a given cell, you can only move to the right (→), right-upwards (↗), or right-downwards (↘) to the next column. >>> max_gold([ ... [1, 3, 1, 5], ... [2, 2, 4, 1], ... [5, 0, 2, 3], ... [0, 6, 1, 2] ... ]) == 16 >>> max_gold([ ... [1, 3, 3], ... [2, 1, 4], ... [0, 6, 4] ... ]) == 12 >>> max_gold([ ... [10, 33, 13, 15], ... [22, 21, 4, 1], ... [5, 0, 2, 3], ... [0, 6, 14, 2] ... ]) == 83 >>> max_gold([ ... [10] ... ]) == 10 >>> max_gold([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ]) == 4","solution":"def max_gold(grid): n = len(grid) m = len(grid[0]) # Initialize a table to store the maximum gold that can be collected up to each cell dp = [[0 for _ in range(m)] for _ in range(n)] for i in range(n): dp[i][0] = grid[i][0] for j in range(1, m): for i in range(n): if i > 0: up_right = dp[i-1][j-1] else: up_right = 0 right = dp[i][j-1] if i < n-1: down_right = dp[i+1][j-1] else: down_right = 0 dp[i][j] = grid[i][j] + max(up_right, right, down_right) # Find the maximum value in the last column max_gold_collected = 0 for i in range(n): max_gold_collected = max(max_gold_collected, dp[i][m-1]) return max_gold_collected # Example input n, m = 4, 4 grid = [ [1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2] ] print(max_gold(grid))"},{"question":"def opposite_director(n, badge_number): Returns the badge number of the director sitting directly opposite to the given director. :param n: total number of directors (even integer greater than 2) :param badge_number: the badge number of the given director (integer from 0 to n-1) :return: the badge number of the director sitting directly opposite >>> opposite_director(4, 0) == 2 >>> opposite_director(6, 1) == 4 >>> opposite_director(8, 3) == 7 pass","solution":"def opposite_director(n, badge_number): Returns the badge number of the director sitting directly opposite to the given director. :param n: total number of directors (even integer greater than 2) :param badge_number: the badge number of the given director (integer from 0 to n-1) :return: the badge number of the director sitting directly opposite return (badge_number + n // 2) % n"},{"question":"def process_warehouse(m: int, q: int, grid: List[List[int]], queries: List[Tuple[int, int, int, int, int]]) -> List[Union[str, int]]: Processes warehouse inventory movements. Arguments: m -- grid dimensions (1 ≤ m ≤ 100) q -- number of queries (1 ≤ q ≤ 100) grid -- initial grid of goods with m rows and m columns queries -- list of queries specifying goods movement Returns a list of responses for each query and the final total number of goods in the warehouse. Example: >>> m = 3 >>> q = 2 >>> grid = [[10, 15, 5], [7, 6, 8], [9, 4, 2]] >>> queries = [(1, 1, 2, 3, 10), (3, 3, 2, 2, 3)] >>> process_warehouse(m, q, grid, queries) ['Goods moved', 'Insufficient goods', 66] pass # Unit tests def test_process_warehouse_basic(): m = 3 q = 2 grid = [ [10, 15, 5], [7, 6, 8], [9, 4, 2] ] queries = [ (1, 1, 2, 3, 10), (3, 3, 2, 2, 3) ] expected_results = [\\"Goods moved\\", \\"Insufficient goods\\", 66] assert process_warehouse(m, q, grid, queries) == expected_results def test_process_with_no_moves(): m = 2 q = 0 grid = [ [1, 2], [3, 4] ] queries = [] expected_results = [10] assert process_warehouse(m, q, grid, queries) == expected_results def test_insufficient_goods(): m = 2 q = 1 grid = [ [1, 2], [3, 4] ] queries = [ (1, 1, 2, 2, 5) ] expected_results = [\\"Insufficient goods\\", 10] assert process_warehouse(m, q, grid, queries) == expected_results def test_move_and_update_total(): m = 2 q = 2 grid = [ [5, 5], [5, 5] ] queries = [ (1, 1, 2, 2, 5), (2, 1, 1, 2, 5) ] expected_results = [\\"Goods moved\\", \\"Goods moved\\", 20] assert process_warehouse(m, q, grid, queries) == expected_results","solution":"def process_warehouse(m, q, grid, queries): results = [] for query in queries: r1, c1, r2, c2, x = query if grid[r1-1][c1-1] >= x: grid[r1-1][c1-1] -= x grid[r2-1][c2-1] += x results.append(\\"Goods moved\\") else: results.append(\\"Insufficient goods\\") total_goods = sum(sum(row) for row in grid) results.append(total_goods) return results"},{"question":"import itertools def print_permutations(s: str, k: int): Prints all k-length permutations of the characters in the string s in lexicographic order. ====Input Format===== The first line contains a string of distinct characters. The second line contains an integer k. =====Constraints===== 0 < len(s) ≤ 10 1 ≤ k ≤ len(s) =====Output Format===== Print each permutation as a tuple in lexicographical order. #Sample Input# abc 2 #Sample Output# ('a', 'b') ('a', 'c') ('b', 'a') ('b', 'c') ('c', 'a') ('c', 'b') def test_permutations_example(): s = \\"abc\\" k = 2 expected_output = [ ('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b') ] # Redirect stdout old_stdout = sys.stdout sys.stdout = StringIO() print_permutations(s, k) # Collect printed output output = sys.stdout.getvalue().strip().split('n') # Convert printed output back to tuple list output_tuples = [eval(item) for item in output] # Reset stdout sys.stdout = old_stdout assert output_tuples == expected_output def test_permutations_single_character(): s = \\"x\\" k = 1 expected_output = [ ('x',) ] old_stdout = sys.stdout sys.stdout = StringIO() print_permutations(s, k) output = sys.stdout.getvalue().strip().split('n') output_tuples = [eval(item) for item in output] sys.stdout = old_stdout assert output_tuples == expected_output def test_permutations_entire_length(): s = \\"ab\\" k = 2 expected_output = [ ('a', 'b'), ('b', 'a') ] old_stdout = sys.stdout sys.stdout = StringIO() print_permutations(s, k) output = sys.stdout.getvalue().strip().split('n') output_tuples = [eval(item) for item in output] sys.stdout = old_stdout assert output_tuples == expected_output def test_permutations_three_characters_k_3(): s = \\"xyz\\" k = 3 expected_output = [ ('x', 'y', 'z'), ('x', 'z', 'y'), ('y', 'x', 'z'), ('y', 'z', 'x'), ('z', 'x', 'y'), ('z', 'y', 'x') ] old_stdout = sys.stdout sys.stdout = StringIO() print_permutations(s, k) output = sys.stdout.getvalue().strip().split('n') output_tuples = [eval(item) for item in output] sys.stdout = old_stdout assert output_tuples == expected_output","solution":"import itertools def print_permutations(s, k): Prints all k-length permutations of the characters in the string s in lexicographic order. permutations_list = sorted(itertools.permutations(s, k)) for perm in permutations_list: print(perm)"},{"question":"def update_team_a(team_a_ids: set, team_b_ids: set) -> set: Updates team_a_ids with the symmetric difference of team_a_ids and team_b_ids. Parameters: team_a_ids (set): A set of integers representing team A's member IDs team_b_ids (set): A set of integers representing team B's member IDs Returns: set: The updated team A member IDs after the symmetric difference update >>> update_team_a({1, 2, 3}, {3, 4, 5}) {1, 2, 4, 5} >>> update_team_a({1, 2, 3}, []) {1, 2, 3} >>> update_team_a({}, {1, 2, 3}) {1, 2, 3} team_a_ids.symmetric_difference_update(team_b_ids) return team_a_ids","solution":"def update_team_a(team_a_ids, team_b_ids): Updates team_a_ids with the symmetric difference of team_a_ids and team_b_ids. Parameters: team_a_ids (set): A set of integers representing team A's member IDs team_b_ids (set): A set of integers representing team B's member IDs Returns: set: The updated team A member IDs after the symmetric difference update team_a_ids.symmetric_difference_update(team_b_ids) return team_a_ids"},{"question":"def transform_list(lst: List[Tuple[int, str]]) -> str: Transforms a list of tuples into a single string, where each string element from the tuples appears the number of times specified by its corresponding integer. :param lst: List[Tuple[int, str]] - A list of tuples, where each tuple consists of an integer (1 <= int <= 5) and a single character string (a-z) :return: str - A single string with characters repeated according to their corresponding integer value. pass # Test cases to validate the solution def test_transform_list_example(): assert transform_list([(2, 'a'), (3, 'b'), (1, 'c')]) == 'aabbbc' def test_transform_list_single_tuple(): assert transform_list([(5, 'z')]) == 'zzzzz' def test_transform_list_multiple_tuples(): assert transform_list([(1, 'a'), (2, 'b'), (3, 'c')]) == 'abbccc' def test_transform_list_empty_list(): assert transform_list([]) == '' def test_transform_list_minimum_repetitions(): assert transform_list([(1, 'x')]) == 'x' def test_transform_list_combined_repetitions(): assert transform_list([(1, 'k'), (5, 'm'), (2, 'n')]) == 'kmmmmmnn' def test_transform_list_same_characters(): assert transform_list([(2, 'a'), (3, 'a'), (1, 'a')]) == 'aaaaaa'","solution":"def transform_list(lst): Transforms a list of tuples into a single string, where each string element from the tuples appears the number of times specified by its corresponding integer. :param lst: List[Tuple[int, str]] - A list of tuples, where each tuple consists of an integer (1 <= int <= 5) and a single character string (a-z) :return: str - A single string with characters repeated according to their corresponding integer value. result = \\"\\" for count, char in lst: result += char * count return result"},{"question":"def uniqueElementCount(matrix) -> int: Given a two-dimensional array (matrix) of integers, determine the number of unique elements in the matrix. >>> uniqueElementCount([[1, 2, 2], [3, 1, 4]]) 2 >>> uniqueElementCount([[5, 5, 5], [5, 5, 5]]) 0 >>> uniqueElementCount([[0], [1, -1], [2, 2, -1]]) 2 >>> uniqueElementCount([[10, 15], [15, -20], [-20, 10, 30]]) 1 >>> uniqueElementCount([[42]]) 1 >>> uniqueElementCount([[1, 2, 3], [4, 5, 6]]) 6 >>> uniqueElementCount([[1, 1], [1, 1]]) 0 >>> uniqueElementCount([[-1, -2, -2], [-3, -1, -4]]) 2 >>> uniqueElementCount([[3, -3], [0, 3, -3]]) 1","solution":"def uniqueElementCount(matrix): Returns the number of unique elements in the given matrix. from collections import Counter # Flatten the matrix into a single list flattened_matrix = [item for sublist in matrix for item in sublist] # Count the occurrences of each element element_count = Counter(flattened_matrix) # Count the number of elements that appear exactly once unique_elements = [elem for elem, count in element_count.items() if count == 1] return len(unique_elements)"},{"question":"from typing import List, Tuple def travel_distance(distances: List[Tuple[str, str, float]], cities: List[str]) -> float: Calculate the shortest travel distance to cover all cities exactly once and return to the start. Arguments: distances -- list of tuples each containing (city1, city2, distance) cities -- list of cities to be visited Returns: float -- total minimum travel distance >>> travel_distance([('A', 'B', 10), ('A', 'C', 15), ('B', 'C', 20)], ['A', 'B', 'C']) 45.0 >>> travel_distance([ ('A', 'B', 10), ('A', 'C', 15), ('A', 'D', 20), ('B', 'C', 35), ('B', 'D', 25), ('C', 'D', 30) ], ['A', 'B', 'C', 'D']) 80.0 >>> travel_distance([ ('A', 'B', 10), ('A', 'C', 10), ('B', 'C', 10) ], ['A', 'B', 'C']) 30.0 >>> travel_distance([ ('A', 'B', 10), ('B', 'C', 15), ('C', 'A', 20) ], ['A', 'B', 'C']) 45.0 >>> travel_distance([ ('A', 'B', 5) ], ['A', 'B']) 10.0","solution":"import itertools def travel_distance(distances, cities): Calculate the shortest travel distance to cover all cities exactly once and return to the start. Arguments: distances -- list of tuples each containing (city1, city2, distance) cities -- list of cities to be visited Returns: float -- total minimum travel distance # Create a dictionary for distances for quick lookup distance_dict = {} for city1, city2, dist in distances: distance_dict[(city1, city2)] = dist distance_dict[(city2, city1)] = dist def total_distance(route): return sum(distance_dict[(route[i], route[i + 1])] for i in range(len(route) - 1)) all_city_orders = itertools.permutations(cities) min_distance = float('inf') for order in all_city_orders: route = list(order) + [order[0]] dist = total_distance(route) if dist < min_distance: min_distance = dist return min_distance"},{"question":"def generateSpiralMatrix(n): Generates an n x n matrix filled with integers from 1 to n^2 in a clockwise spiral order. >>> generateSpiralMatrix(1) [[1]] >>> generateSpiralMatrix(2) [[1, 2], [4, 3]] >>> generateSpiralMatrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generateSpiralMatrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generateSpiralMatrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] >>> generateSpiralMatrix(6) [[1, 2, 3, 4, 5, 6], [20, 21, 22, 23, 24, 7], [19, 32, 33, 34, 25, 8], [18, 31, 36, 35, 26, 9], [17, 30, 29, 28, 27, 10], [16, 15, 14, 13, 12, 11]] # Your implementation goes here.","solution":"def generateSpiralMatrix(n): Generates an n x n matrix filled with integers from 1 to n^2 in a clockwise spiral order. matrix = [[0] * n for _ in range(n)] num = 1 left, right = 0, n - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: for col in range(left, right + 1): matrix[top][col] = num num += 1 top += 1 for row in range(top, bottom + 1): matrix[row][right] = num num += 1 right -= 1 for col in range(right, left - 1, -1): matrix[bottom][col] = num num += 1 bottom -= 1 for row in range(bottom, top - 1, -1): matrix[row][left] = num num += 1 left += 1 return matrix"},{"question":"from typing import Dict, List def get_all_subcomponents(components: Dict[str, List[str]], product: str) -> List[str]: Given a dictionary mapping components to their sub-components, and a product, this function returns a sorted list of all unique sub-components required to build the product. Example: >>> components = { ... \\"ProductA\\": [\\"Component1\\", \\"Component2\\"], ... \\"Component1\\": [\\"Component3\\", \\"Component4\\"], ... \\"Component2\\": [\\"Component3\\", \\"Component5\\"], ... \\"Component3\\": [], ... \\"Component4\\": [], ... \\"Component5\\": [] ... } >>> product = \\"ProductA\\" >>> get_all_subcomponents(components, product) ['Component1', 'Component2', 'Component3', 'Component4', 'Component5'] pass def test_simple_case(): components = { \\"ProductA\\": [\\"Component1\\", \\"Component2\\"], \\"Component1\\": [\\"Component3\\", \\"Component4\\"], \\"Component2\\": [\\"Component3\\", \\"Component5\\"], \\"Component3\\": [], \\"Component4\\": [], \\"Component5\\": [] } assert get_all_subcomponents(components, \\"ProductA\\") == [\\"Component1\\", \\"Component2\\", \\"Component3\\", \\"Component4\\", \\"Component5\\"] def test_another_case(): components = { \\"Widget\\": [\\"Panel\\", \\"Battery\\"], \\"Panel\\": [\\"Button\\", \\"Display\\"], \\"Battery\\": [], \\"Button\\": [], \\"Display\\": [] } assert get_all_subcomponents(components, \\"Widget\\") == [\\"Battery\\", \\"Button\\", \\"Display\\", \\"Panel\\"] def test_no_subcomponents(): components = { \\"ProductX\\": [] } assert get_all_subcomponents(components, \\"ProductX\\") == [] def test_nested_components(): components = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } assert get_all_subcomponents(components, \\"A\\") == [\\"B\\", \\"C\\", \\"D\\"] def test_shared_components(): components = { \\"Product\\": [\\"Part1\\", \\"Part2\\"], \\"Part1\\": [\\"Part3\\"], \\"Part2\\": [\\"Part3\\", \\"Part4\\"], \\"Part3\\": [], \\"Part4\\": [] } assert get_all_subcomponents(components, \\"Product\\") == [\\"Part1\\", \\"Part2\\", \\"Part3\\", \\"Part4\\"]","solution":"def get_all_subcomponents(components, product): Given a dictionary mapping components to their sub-components, and a product, this function returns a sorted list of all unique sub-components required to build the product. def collect_subcomponents(component, subcomponents): for sub in components.get(component, []): if sub not in subcomponents: subcomponents.add(sub) collect_subcomponents(sub, subcomponents) subcomponents = set() collect_subcomponents(product, subcomponents) return sorted(subcomponents)"},{"question":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise. Parameters: matrix (list of list of int): 2D list representing the matrix Returns: list of list of int: 2D list representing the rotated matrix >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([]) []","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise. Parameters: matrix (list of list of int): 2D list representing the matrix Returns: list of list of int: 2D list representing the rotated matrix if not matrix: return [] n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"}]`),C={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},j={class:"card-container"},E={key:0,class:"empty-state"},D=["disabled"],I={key:0},P={key:1};function z(n,e,u,m,i,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",j,[(s(!0),r(y,null,w(a.displayedPoems,(o,p)=>(s(),x(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",E,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",P,"Loading...")):(s(),r("span",I,"See more"))],8,D)):l("",!0)])}const B=c(C,[["render",z],["__scopeId","data-v-b9777266"]]),Y=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/61.md","filePath":"grok/61.md"}'),M={name:"grok/61.md"},G=Object.assign(M,{setup(n){return(e,u)=>(s(),r("div",null,[v(B)]))}});export{Y as __pageData,G as default};
