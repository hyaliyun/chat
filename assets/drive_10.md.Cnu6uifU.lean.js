import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},A={class:"review-title"},E={class:"review-content"};function I(r,e,l,m,s,a){return n(),i("div",T,[t("div",q,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",I],["__scopeId","data-v-ba754bfb"]]),S=JSON.parse('[{"question":"# Coding Assessment Question **Problem Statement:** A text editor features a find-and-replace function where you can find all occurrences of a word in a given text and replace them with another word. Implementing this function involves two main operations: finding all occurrences of a word and then replacing them. This can be particularly challenging when trying to efficiently handle large texts and numerous replacements. **Objective:** Write a function `find_and_replace` that takes a list of operations where each operation involves finding and replacing words in a text. **Function Signature:** ```python def find_and_replace(operations: List[Tuple[str, str, str]]) -> List[str]: ``` **Input:** * `operations`: A list of tuples where each tuple contains: - A string representing the current text. - A string representing the word to find. - A string representing the word to replace it with. **Output:** * A list of strings where each string is the text after performing the find-and-replace operation. **Constraints:** * Each text in the operations list may contain spaces and punctuation marks. * Words will be case-sensitive. * No word will be a substring of another word (i.e., each occurrence of a word is a full word separated by non-alphanumeric characters). **Example:** ```python operations = [ (\\"the quick brown fox jumps over the lazy dog\\", \\"the\\", \\"a\\"), (\\"hello world, hello everyone\\", \\"hello\\", \\"hi\\"), (\\"find the needle in the haystack\\", \\"needle\\", \\"pin\\") ] result = find_and_replace(operations) print(result) # Output: [\\"a quick brown fox jumps over a lazy dog\\", \\"hi world, hi everyone\\", \\"find the pin in the haystack\\"] ``` **Requirements:** 1. Implement the function `find_and_replace`. 2. Ensure efficient handling and replacement within the text. 3. Handle edge cases such as punctuations, multiple spaces, and case sensitivity. 4. Thoroughly test the function with various inputs representing different edge cases.","solution":"import re from typing import List, Tuple def find_and_replace(operations: List[Tuple[str, str, str]]) -> List[str]: This function takes a list of tuples where each tuple contains a string (text), a string to find, and a string to replace it with, and returns a list of strings where each string is the text after performing the find-and-replace operation. outputs = [] for text, find_word, replace_word in operations: # Using regex to find whole words pattern = r\'b{}b\'.format(re.escape(find_word)) replaced_text = re.sub(pattern, replace_word, text) outputs.append(replaced_text) return outputs"},{"question":"# Coding Assessment Question Graph traversal algorithms are crucial for understanding the structure and properties of graph-based systems, like social networks, transportation grids, and web crawlers. Depth-First Search (DFS) is one such algorithm that explores as far as possible along each branch before backtracking. **Objective**: Implement a recursive Depth-First Search (DFS) algorithm to traverse a graph starting from a given node. Demonstrate your solution by finding the connected components in an undirected graph. Requirements: 1. **Graph Representation**: * Represent the graph using an adjacency list. * Assume the input graph is undirected and connected. 2. **DFS Implementation**: * Define a recursive function that performs the DFS traversal. * Ensure that your implementation correctly handles edge cases (e.g., cycles and disjoint subsets of a graph). 3. **Connected Components**: * Extend your DFS function to identify all connected components in the graph. * Return the list of connected components, where each component is represented as a list of nodes. Function Signature ```python from typing import List, Dict def depth_first_search(graph: Dict[int, List[int]], start: int, visited: set) -> List[int]: pass def find_connected_components(graph: Dict[int, List[int]]) -> List[List[int]]: pass ``` Example Usage: ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4, 5], 4: [3], 5: [3, 6, 7], 6: [5], 7: [5] } connected_components = find_connected_components(graph) print(connected_components) # Output: [[0, 1, 3, 2, 4, 5, 6, 7]] since the graph is fully connected ``` Constraints: 1. The graph is represented as a dictionary where keys are node labels (integers) and values are lists of adjacent nodes. 2. The graph can have up to 10^3 nodes. 3. Ensure the implementation can handle graphs with cycles and small isolated components. 4. Adhere to the principles of recursion and handle large graphs efficiently in terms of time and space complexity. Context: Understandably handling graph traversal algorithms like DFS is fundamental in computer science for exploring the structure of graphs and solving problems related to connectivity and pathfinding. Implementing DFS recursively emphasizes understanding both the algorithm and recursion principles, essential for solving complex graph-related problems.","solution":"from typing import List, Dict, Set def depth_first_search(graph: Dict[int, List[int]], start: int, visited: Set[int]) -> List[int]: visited.add(start) components = [start] for neighbor in graph[start]: if neighbor not in visited: components.extend(depth_first_search(graph, neighbor, visited)) return components def find_connected_components(graph: Dict[int, List[int]]) -> List[List[int]]: visited = set() connected_components = [] for node in graph: if node not in visited: component = depth_first_search(graph, node, visited) connected_components.append(component) return connected_components"},{"question":"# Data Processing and Analytics Pipeline Development You are to design and implement a data processing pipeline that ingests raw data from a CSV file, processes it to extract meaningful insights, and outputs a summarized report. You need to demonstrate your ability to handle various data processing tasks including data cleaning, transformation, and summarization using Python. Specific Requirements 1. **Input**: A CSV file containing raw data. The CSV file has columns: `timestamp`, `value`, `category`. 2. **Output**: A summarized report in the form of a dictionary with the following structure: * `total_entries`: Total number of data entries. * `average_value`: Average of the `value` column. * `max_value`: Maximum value in the `value` column and its associated timestamp. * `min_value`: Minimum value in the `value` column and its associated timestamp. * `entries_per_category`: A dictionary with categories as keys and the count of entries per category as values. 3. **Constraints**: * The `timestamp` column should be parsed as datetime objects. * Handle missing or malformed data appropriately. * Ensure the results are accurate and efficiently calculated. Performance Requirements * The script should handle large CSV files efficiently. * Use appropriate data structures and libraries (e.g., pandas) to optimize performance. Scenario Your organization has accumulated a large dataset in a CSV format. You are tasked with developing a robust data processing pipeline to transform this raw data into a summarized report for decision-making purposes. You are tasked with implementing the following function: ```python def process_data(file_path: str) -> dict: Given the file path to a CSV file containing raw data, process the data and return a summarized report. Parameters: file_path (str): The path to the CSV file. Returns: dict: A dictionary containing the summarized report. pass ``` **Example Usage:** ```python report = process_data(\\"data.csv\\") print(report) # Output: # { # \'total_entries\': 1000, # \'average_value\': 50.5, # \'max_value\': {\'timestamp\': \'2023-01-01 12:00:00\', \'value\': 100.0}, # \'min_value\': {\'timestamp\': \'2023-01-01 12:00:00\', \'value\': 0.0}, # \'entries_per_category\': {\'A\': 300, \'B\': 500, \'C\': 200} # } ``` Ensure your solution handles the CSV file appropriately, processes the data efficiently, and returns the summarized report accurately.","solution":"import pandas as pd def process_data(file_path: str) -> dict: Given the file path to a CSV file containing raw data, process the data and return a summarized report. Parameters: file_path (str): The path to the CSV file. Returns: dict: A dictionary containing the summarized report. # Read the CSV file data = pd.read_csv(file_path, parse_dates=[\'timestamp\']) # Drop rows with missing or malformed data data.dropna(subset=[\'timestamp\', \'value\', \'category\'], inplace=True) # Total number of data entries total_entries = data.shape[0] # Average of the `value` column average_value = data[\'value\'].mean() # Maximum value in the `value` column and its associated timestamp max_row = data.loc[data[\'value\'].idxmax()] max_value = {\'timestamp\': max_row[\'timestamp\'], \'value\': max_row[\'value\']} # Minimum value in the `value` column and its associated timestamp min_row = data.loc[data[\'value\'].idxmin()] min_value = {\'timestamp\': min_row[\'timestamp\'], \'value\': min_row[\'value\']} # Count of entries per category entries_per_category = data[\'category\'].value_counts().to_dict() # Return the summarized report return { \'total_entries\': total_entries, \'average_value\': average_value, \'max_value\': max_value, \'min_value\': min_value, \'entries_per_category\': entries_per_category }"},{"question":"# Sum of Powers Given a positive integer `n`, your task is to determine whether `n` can be expressed as the sum of two distinct integers (a) and (b), where both (a) and (b) are powers of 2. Return a list containing the tuple ((a, b)), or an empty list if no such pair exists. The integers (a) and (b) must satisfy (a < b). Input: - A single integer `n` (1 ≤ n ≤ 10^6). Output: - A list containing a single tuple ((a, b)) such that (a) and (b) are powers of 2 and (a + b = n). Return an empty list if no such pair exists. Constraints: - Both (a) and (b) must be distinct powers of 2. - Ensure the solution checks possible pairs efficiently. Example: ```python >>> find_sum_of_powers(10) [(2, 8)] >>> find_sum_of_powers(18) [(2, 16)] >>> find_sum_of_powers(15) [] ``` > **Scenario**: > Your younger sibling is learning about powers of 2 in their math class and wants to practice recognizing which numbers can be represented as the sum of two powers of 2. Assist them by implementing a function that helps identify these pairs. Function Signature ```python def find_sum_of_powers(n: int) -> list: pass ```","solution":"def find_sum_of_powers(n: int) -> list: Determines whether n can be expressed as the sum of two distinct integers a and b, where both a and b are powers of 2. Parameters: n (int): A positive integer to be represented as a sum of two distinct powers of 2. Returns: list: A list containing a single tuple (a, b) such that a and b are distinct powers of 2 and a + b = n, or an empty list if no such pair exists. # Generate powers of 2 that are less than n powers_of_2 = [] power = 1 while power < n: powers_of_2.append(power) power *= 2 # Check pairs of powers of 2 to see if their sum equals n power_set = set(powers_of_2) for a in powers_of_2: if n - a in power_set and n - a != a: return [(a, n - a)] return []"},{"question":"# Unique Characters Detection Develop a utility to determine if all characters in a given string are unique without using any additional data structures. # Problem Statement Create a function `has_all_unique_chars` that checks if all characters in a given string are unique. # Function Signature ```python def has_all_unique_chars(s: str) -> bool: pass ``` # Detailed Requirements 1. **Function Method**: * **Input**: A string `s` (1 ≤ len(s) ≤ 1000) consisting of lowercase and uppercase letters. * **Output**: Return `True` if all characters in the string are unique, otherwise return `False`. 2. **Constraints**: * Do not use any additional data structures. * The function should be case-sensitive (\'a\' and \'A\' are considered distinct characters). # Edge Cases to Handle 1. String of length 1. 2. Strings with repeated characters at various positions. 3. Edge length cases such as the shortest string (length 1) and longer strings (length exactly 1000). # Example ```python print(has_all_unique_chars(\\"abcdef\\")) # Expected Output: True print(has_all_unique_chars(\\"aabcdef\\")) # Expected Output: False print(has_all_unique_chars(\\"AaBbCcDd\\")) # Expected Output: True print(has_all_unique_chars(\\"AaBbCcAa\\")) # Expected Output: False ``` # Performance Requirements Your solution should aim to achieve a time complexity of O(n^2) in the worst case, where n is the length of the string, as additional data structures are not permitted.","solution":"def has_all_unique_chars(s: str) -> bool: This function checks if all characters in the string are unique. It does not use additional data structures. :param s: input string :return: True if all characters are unique, False otherwise n = len(s) for i in range(n): for j in range(i + 1, n): if s[i] == s[j]: return False return True"},{"question":"# Problem: Efficient Graph Traversal and Connectivity Check You are tasked with implementing an efficient graph traversal algorithm to determine the connectivity of a graph. Specifically, your function will check if a graph is fully connected, i.e., if there is a path between any two nodes. Function Specification: - **Function Name**: `is_graph_connected` - **Input**: - `n`: An integer representing the number of nodes in the graph, where nodes are labeled from 0 to `n-1`. - `edges`: A list of tuples, where each tuple `(u, v)` represents an undirected edge between nodes `u` and `v`. - **Output**: - A boolean value. `True` indicates that the graph is fully connected. `False` indicates the graph is not connected. Constraints: 1. Ensure the function handles edge cases such as an empty graph (no nodes) or a graph with nodes but no edges. 2. The graph is undirected and may be disconnected. 3. Focus on efficiency: Aim for an O(n + m) complexity, where n is the number of nodes and m is the number of edges. 4. Utilize appropriate graph traversal techniques such as Depth-First Search (DFS) or Breadth-First Search (BFS). # Task Description: Implement the function `is_graph_connected` to determine the connectivity of the graph, adhering to the requirements and constraints. Example: ```python def is_graph_connected(n: int, edges: list) -> bool: # Implementation here ``` Examples of how the function should behave: ```python assert is_graph_connected(5, [(0, 1), (1, 2), (2, 3), (3, 4)]) == True # Fully connected graph assert is_graph_connected(5, [(0, 1), (2, 3), (3, 4)]) == False # Not fully connected assert is_graph_connected(1, []) == True # Single node graph assert is_graph_connected(0, []) == True # Empty graph assert is_graph_connected(6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]) == False # Disconnected graph ``` # Requirements - Implement the `is_graph_connected` function efficiently. - Perform rigorous testing covering all edge cases, including different sizes and structures of graphs. Good luck and happy coding!","solution":"def is_graph_connected(n, edges): Determines if an undirected graph is fully connected. Args: - n: int, the number of nodes in the graph - edges: list of tuples, each tuple (u, v) represents an undirected edge between nodes u and v Returns: - bool, True if the graph is fully connected, False otherwise if n == 0: return True # An empty graph is considered fully connected if n == 1: return True # A single node graph is trivially connected from collections import deque, defaultdict # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Perform BFS to check connectivity visited = set() queue = deque([0]) # Start BFS from node 0 while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) # If visited contains all nodes, the graph is fully connected return len(visited) == n"},{"question":"# Coding Assessment Question Create a function that reads data from a CSV file, analyzes the contents, and then simulates processing the data with a predefined set of conditions. You are also required to write accompanying tests to ensure the function operates accurately under various scenarios. Scenario You need to write a function `process_csv_data` which reads a CSV file and processes its contents to return specific aggregates. Additionally, write test cases to validate the functionality using mock data. Implementation Details **Function: process_csv_data(file_path: str) -> dict** * **Inputs**: - `file_path` (str): The file path to the CSV file. * **Outputs**: - A dictionary containing: - `average_age` (float): The average age of all records in the CSV. - `total_salary` (float): The sum of all salaries in the CSV. - `unique_departments` (int): The number of unique departments listed in the CSV. **CSV Format** - The CSV file contains the following columns: `name`, `age`, `salary`, `department`. **Test Function** - Write a function `test_process_csv_data` that uses mock CSV content to test `process_csv_data`. - Use Python\'s `io.StringIO` to simulate file reading. Example: ```python import csv import io def process_csv_data(file_path: str) -> dict: total_age = 0 total_salary = 0 department_set = set() record_count = 0 with open(file_path) as csvfile: reader = csv.DictReader(csvfile) for row in reader: total_age += int(row[\'age\']) total_salary += float(row[\'salary\']) department_set.add(row[\'department\']) record_count += 1 average_age = total_age / record_count if record_count else 0 return { \\"average_age\\": average_age, \\"total_salary\\": total_salary, \\"unique_departments\\": len(department_set) } def test_process_csv_data(monkeypatch): csv_content = name,age,salary,department Alice,30,70000,Engineering Bob,25,50000,HR Carol,35,90000,Engineering Dave,40,120000,Management def mock_open(file_path, mode=\'r\', *args, **kwargs): return io.StringIO(csv_content) monkeypatch.setattr(\'builtins.open\', mock_open) result = process_csv_data(\'fake_path.csv\') assert result[\'average_age\'] == 32.5 assert result[\'total_salary\'] == 330000.0 assert result[\'unique_departments\'] == 3 ``` In the above example, you need to ensure the correctness of `process_csv_data` by developing appropriate mock setups and assertions. **Constraints**: * The CSV content is assumed to be correct and no need for extensive error handling. * Use Python\'s `csv` library for CSV file parsing and `io.StringIO` for mocking file content. * Validate edge cases such as empty CSV files and single record files.","solution":"import csv def process_csv_data(file_path: str) -> dict: total_age = 0 total_salary = 0 department_set = set() record_count = 0 with open(file_path) as csvfile: reader = csv.DictReader(csvfile) for row in reader: total_age += int(row[\'age\']) total_salary += float(row[\'salary\']) department_set.add(row[\'department\']) record_count += 1 average_age = total_age / record_count if record_count else 0 return { \\"average_age\\": average_age, \\"total_salary\\": total_salary, \\"unique_departments\\": len(department_set) }"},{"question":"# Problem Statement You are required to implement a String Compression utility. Given a string, perform run-length encoding on the string and return the compressed string. If the compressed string is longer than the original string, return the original string. Function Signature ```python def compress_string(s: str) -> str: Compresses the string \'s\' using run-length encoding. If the compressed string is longer than the original string, returns the original string. Parameters: s (str): The string to be compressed. Returns: str: The compressed string or the original string if compression is not effective. pass ``` # Specifications - **Input Format**: A single string `s` to be compressed. - **Output Format**: A single string which is either the original string or the compressed string. - **Constraints**: - `1 <= len(s) <= 1000` - The string `s` consists only of uppercase and lowercase English letters. # Example ```python print(compress_string(\\"aabcccccaaa\\")) # Output: \\"a2b1c5a3\\" print(compress_string(\\"abc\\")) # Output: \\"abc\\" print(compress_string(\\"aabbccd\\")) # Output: \\"aabbccd\\" ``` # Notes 1. Each character in the compressed string should be followed by the count of consecutive appearances. 2. The compressed string should only be returned if its length is shorter than the original string; otherwise, return the original string. 3. Ensure that the solution handles edge cases such as single-character strings or the maximum length of the string boundary condition.","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = \\"\\".join(compressed) if len(compressed_str) >= len(s): return s return compressed_str"},{"question":"# Problem Description You are given a string `input_string` representing a mathematical expression that contains addition and subtraction operations, but no parentheses. Your task is to write a function `calculate_expression` that evaluates the expression and returns the result as an integer. # Input * `input_string` (str): A non-empty string that represents a valid mathematical expression containing integers and the characters `+` and `-` for addition and subtraction, respectively. There will be no spaces in the input string. # Output * The function should return the integer result of evaluating the expression. # Constraints * The numbers involved will be non-negative integers. * The length of the string will not exceed 100 characters. * The input string will contain at least one operator (`+` or `-`). # Example ```python >>> calculate_expression(\\"3+5-2\\") 6 >>> calculate_expression(\\"10-4+2\\") 8 >>> calculate_expression(\\"100\\") 100 >>> calculate_expression(\\"2-3+4\\") 3 ``` # Requirements * Implement the function `calculate_expression` that meets the specifications. * Ensure the code correctly handles all edge cases and efficiently evaluates the expression. ```python def calculate_expression(input_string): current_number = \\"\\" total = 0 sign = 1 # 1 for positive, -1 for negative for char in input_string: if char.isdigit(): current_number += char else: total += sign * int(current_number) current_number = \\"\\" sign = 1 if char == \'+\' else -1 # Add the last number in the string total += sign * int(current_number) return total ```","solution":"def calculate_expression(input_string): current_number = \\"\\" total = 0 sign = 1 # 1 for positive, -1 for negative for char in input_string: if char.isdigit(): current_number += char else: total += sign * int(current_number) current_number = \\"\\" sign = 1 if char == \'+\' else -1 # Add the last number in the string total += sign * int(current_number) return total"},{"question":"# Problem Statement You need to implement a function that generates all possible substrings of a given string and returns the list of these substrings sorted in lexicographical order. **Function Signature**: ```python def generate_substrings(s: str) -> List[str]: pass ``` **Input**: - A single string `s` containing only lowercase English letters. **Output**: - A list of strings which are all the substrings of `s` sorted in lexicographical order. **Constraints**: - The string will contain at most (100) characters. - The characters in the input string will all be lowercase English letters from `a` to `z`. **Performance Requirements**: - The function should handle the constraints efficiently. - The implementation should consider edge cases, such as an empty input string. # Example ```python assert generate_substrings(\\"abc\\") == [\\"\\", \\"a\\", \\"ab\\", \\"abc\\", \\"b\\", \\"bc\\", \\"c\\"] assert generate_substrings(\\"banana\\") == [\\"\\", \\"a\\", \\"a\\", \\"a\\", \\"an\\", \\"ana\\", \\"anan\\", \\"anana\\", \\"b\\", \\"ba\\", \\"ban\\", \\"bana\\", \\"banan\\", \\"banana\\", \\"n\\", \\"na\\", \\"nan\\", \\"nana\\"] assert generate_substrings(\\"\\") == [\\"\\"] ``` # Explanation The function should generate each possible substring of the given input string `s`. Substrings of a string are all possible contiguous sequences of characters from the string. After generating all substrings, the function should sort them in lexicographical order and return the list. For example, the string `\\"abc\\"` has the substrings `[\\"a\\", \\"ab\\", \\"abc\\", \\"b\\", \\"bc\\", \\"c\\"]`, which when sorted in lexicographical order become `[\\"\\", \\"a\\", \\"ab\\", \\"abc\\", \\"b\\", \\"bc\\", \\"c\\"]`.","solution":"from typing import List def generate_substrings(s: str) -> List[str]: This function generates all possible substrings of a given string `s` and returns the list of these substrings sorted in lexicographical order. substrings = set() # Generate all possible substrings for i in range(len(s)): for j in range(i+1, len(s)+1): substrings.add(s[i:j]) # Convert the set to a list and sort lexicographically sorted_substrings = sorted(list(substrings)) # Add the empty string sorted_substrings.insert(0, \\"\\") return sorted_substrings"},{"question":"# Coding Assessment Question: Context: You are developing a system that helps users manage their personal expenses. Part of this system requires the extraction and processing of financial data from various sources such as bank statements in CSV format. You need to ensure the reliability and correctness of the data extracted, and efficiently compute summary statistics for the users. Task: Implement a function called `process_expense_data` that combines the following operations: 1. Read a CSV file containing transaction data. 2. Parse the data to extract relevant information such as date, description, and amount. 3. Identify and handle any missing or malformed data entries. 4. Categorize expenses based on predefined rules. 5. Compute and return a summary of expenses by category, including total amounts and counts of transactions. 6. Ensure the function is resilient to changes in the CSV format, such as different column orders or additional columns. Requirements: 1. Use the `csv` module to read and parse the CSV file. 2. Implement error-handling mechanisms for missing or malformed data entries. 3. Optimize the function for large datasets by minimizing memory usage and computation time. 4. Write clear docstrings and comments to explain the code. Expected Input and Output: **Input**: - `file_path` (String): Path to the CSV file containing transaction data. **CSV File Format**: The CSV file will have columns such as `Date`, `Description`, `Amount`, `Category`, etc. **Output**: - A dictionary summarizing total expenses and counts of transactions by category. Constraints: - The CSV file may have variations in column order or additional columns not relevant to the task. - Handle up to 10,000 transactions efficiently. Example: ```python # Simplified example of CSV content: # Date,Description,Amount,Category # 2023-01-01,Groceries,50.5,Food # 2023-01-02,Electric Bill,75,Utilities # ... Expected Output: { \'Food\': {\'total\': 200.5, \'count\': 4}, \'Utilities\': {\'total\': 150, \'count\': 2}, ... } ``` Implementation Notes: - Use a `defaultdict` to handle categories automatically. - Normalize data (e.g., trimming whitespace) to ensure consistency. - Implement a check for required columns and handle missing columns gracefully. - Use efficient data structures and algorithms to handle large datasets within the constraints. ```python import csv from collections import defaultdict def process_expense_data(file_path): Process financial data from a CSV file and return a summary of expenses by category. Args: file_path (str): Path to the CSV file containing transaction data. Returns: dict: A dictionary summarizing total expenses and counts of transactions by category. summary = defaultdict(lambda: {\'total\': 0.0, \'count\': 0}) try: with open(file_path, \'r\') as csvfile: reader = csv.DictReader(csvfile) if not set([\'Date\', \'Description\', \'Amount\', \'Category\']).issubset(reader.fieldnames): raise ValueError(\\"CSV file missing required columns\\") for row in reader: try: date = row[\'Date\'].strip() description = row[\'Description\'].strip() amount = float(row[\'Amount\']) category = row[\'Category\'].strip() if not category: category = \'Uncategorized\' summary[category][\'total\'] += amount summary[category][\'count\'] += 1 except ValueError as e: # Handle malformed data (e.g., invalid amount) print(f\\"Warning: Skipping malformed data {row}. Error: {e}\\") except FileNotFoundError: print(f\\"Error: File not found - {file_path}\\") except Exception as e: print(f\\"An unexpected error occurred: {e}\\") return dict(summary) # Example usage: file_path = \'path/to/your/transactions.csv\' expense_summary = process_expense_data(file_path) print(expense_summary) ```","solution":"import csv from collections import defaultdict def process_expense_data(file_path): Process financial data from a CSV file and return a summary of expenses by category. Args: file_path (str): Path to the CSV file containing transaction data. Returns: dict: A dictionary summarizing total expenses and counts of transactions by category. summary = defaultdict(lambda: {\'total\': 0.0, \'count\': 0}) try: with open(file_path, \'r\') as csvfile: reader = csv.DictReader(csvfile) if not set([\'Date\', \'Description\', \'Amount\', \'Category\']).issubset(reader.fieldnames): raise ValueError(\\"CSV file missing required columns\\") for row in reader: try: date = row[\'Date\'].strip() description = row[\'Description\'].strip() amount = float(row[\'Amount\']) # This will raise ValueError if the amount is not a number category = row[\'Category\'].strip() if not category: category = \'Uncategorized\' summary[category][\'total\'] += amount summary[category][\'count\'] += 1 except ValueError as e: # Handle malformed data (e.g., invalid amount) print(f\\"Warning: Skipping malformed data {row}. Error: {e}\\") except FileNotFoundError: print(f\\"Error: File not found - {file_path}\\") except Exception as e: print(f\\"An unexpected error occurred: {e}\\") return dict(summary) # Example usage: # file_path = \'path/to/your/transactions.csv\' # expense_summary = process_expense_data(file_path) # print(expense_summary)"},{"question":"# Substring Anagram Search You are required to analyze two strings and determine if one string\'s any permutation is a substring of the other string. This type of problem is common in text processing and can often be solved using sliding window techniques along with frequency counting. # Definitions * **Permutation**: A rearrangement of the elements of an ordered list. For example, \\"abc\\" and \\"bca\\" are permutations of the string \\"abc\\". * **Substring**: A sequence of characters that is contiguous within another string. For example, \\"cat\\" is a substring of \\"concatenate\\". # Problem Statement 1. Implement the function `is_permutation_in_string(s1: str, s2: str) -> bool` that determines if any permutation of string `s1` is a substring of string `s2`. # Function Signature: ```python def is_permutation_in_string(s1: str, s2: str) -> bool: Returns True if any permutation of s1 is a substring of s2, False otherwise. ``` # Requirements: * The `is_permutation_in_string` function should handle input validation, ensuring the inputs are non-empty strings and `s1`\'s length is less than or equal to `s2`\'s length. * The function should run efficiently to handle large string inputs within a reasonable runtime using appropriate algorithmic techniques. # Examples: ```python >>> is_permutation_in_string(\\"ab\\", \\"eidbaooo\\") True >>> is_permutation_in_string(\\"ab\\", \\"eidboaoo\\") False >>> is_permutation_in_string(\\"abc\\", \\"cbaebabacd\\") True >>> is_permutation_in_string(\\"abc\\", \\"ab\\") False ``` # Constraints: * All characters will be lowercase English letters. * The length of `s1` and `s2` will be between 1 and 10^4. Use these guidelines to implement your solution, ensuring you accurately check for permutations and efficiently match substrings.","solution":"def is_permutation_in_string(s1: str, s2: str) -> bool: if len(s1) > len(s2): return False from collections import Counter s1_count = Counter(s1) window_count = Counter(s2[:len(s1)]) if s1_count == window_count: return True for i in range(len(s1), len(s2)): window_count[s2[i]] += 1 window_count[s2[i - len(s1)]] -= 1 if window_count[s2[i - len(s1)]] == 0: del window_count[s2[i - len(s1)]] if s1_count == window_count: return True return False"},{"question":"# Problem Statement You are tasked with implementing a function to generate a list of Fibonacci numbers up to the nth term. The Fibonacci sequence is defined as follows: [ F(0) = 0, quad F(1) = 1 F(n) = F(n-1) + F(n-2) quad text{for} quad n geq 2 ] # Functional Requirements - **Function Name**: `fibonacci_series` - **Input**: - An integer (`n_term`), which represents the nth term of the Fibonacci Series. - **Output**: - A list of integers, where each integer represents a Fibonacci number from 0 to the nth term. - **Constraints**: - If `n_term` is less than 0, return an empty list. - Handle non-integer and floating-point inputs by converting them to their integer part. - The input conversion should discard any fractional part. # Non-Functional Requirements - **Error Handling**: Ensure the function gracefully handles empty, null, and non-numeric inputs by returning an appropriate empty list. - **Performance**: The solution should efficiently handle large `n` values without significant time or memory overhead. # Example Input/Output ```python >>> fibonacci_series(5) [0, 1, 1, 2, 3] >>> fibonacci_series(1) [0] >>> fibonacci_series(-1) [] >>> fibonacci_series(0) [0] >>> fibonacci_series(2.5) [0, 1] >>> fibonacci_series(\'5\') [0, 1, 1, 2, 3] >>> fibonacci_series(\'\') [] ``` # Implementation Implement the function `fibonacci_series` based on the requirements specified above.","solution":"def fibonacci_series(n_term): Generates a list of Fibonacci numbers up to the nth term. Parameters: n_term (int): The nth term of the Fibonacci series. Returns: list: A list of Fibonacci numbers from 0 to the nth term. try: n_term = int(float(n_term)) except (ValueError, TypeError): return [] if n_term < 0: return [] fib_list = [] a, b = 0, 1 for _ in range(n_term + 1): fib_list.append(a) a, b = b, a + b return fib_list"},{"question":"# Coding Assessment Question A company needs a utility function to properly organize and format a document that contains multiple lines of text. The text in each line can contain varying amounts of white spaces, alignment issues, and undesired symbols at the beginning or end. Your task is to implement a function `format_document` that will clean up each line by ensuring proper alignment, trimming undesired symbols, and removing extra white spaces. Function Definition **format_document(lines: List[str], trim_symbols: Set[str]) -> List[str** * **Input**: - `lines` (List[str]): A list where each element is a string representing a line of text. - `trim_symbols` (Set[str]): A set containing characters that need to be trimmed from the beginning and end of each line. * **Output**: - Returns a list of strings where every element is a properly formatted line. * **Constraints**: - `lines` must be a non-empty list of non-empty strings. - `trim_symbols` can be an empty set or contain multiple character symbols. # Examples Input Example ```python lines = [ \\" Hello, World! \\", \\"***Python: The best@ \\", \\"tLearning@#Algorithms***\\" ] trim_symbols = {\'*\', \'@\', \'#\', \'!\', \'t\', \' \'} ``` Output Example ```python format_document(lines, trim_symbols) # should return # [\\"Hello, World\\", # \\"Python: The best\\", # \\"Learning@#Algorithms\\" #] ``` # Requirements - Trim all specified symbols from the beginning and end of each line. - Remove extra white spaces from the beginning and end of each line. - Preserve the text content and internal white spaces within each line. - Ensure input validations are handled appropriately. This utility function will help maintain consistency in the document by proper trimming and alignment of lines.","solution":"def format_document(lines, trim_symbols): Returns a list of strings where every element is a properly formatted line. Args: lines (List[str]): A list of strings representing lines of text. trim_symbols (Set[str]): A set of characters to be trimmed from the beginning and end of each line. Returns: List[str]: A list of formatted strings. formatted_lines = [] for line in lines: # Strip the trim symbols from the beginning and end of the line trimmed_line = line.strip(\'\'.join(trim_symbols)) # Append cleaned line to result list formatted_lines.append(trimmed_line) return formatted_lines"},{"question":"# Coding Assessment Question: Sales Data Analysis **Problem Statement**: You need to design a program for analyzing monthly sales data for a retail store. The store management wants to understand the monthly trends, identify the month with the highest sales, and calculate the average sales across all months. Your task is to implement a function `sales_analysis` that accepts a list of sales figures for 12 months and performs the following operations: 1. **Calculate the Total Sales**: Sum of sales for all 12 months. 2. **Identify the Month with Highest Sales**: The function should return the month (1 to 12) where the sales were the highest. 3. **Calculate the Average Sales**: Compute the average monthly sales. The function should return these three values in a tuple. **Function Signature**: ```python def sales_analysis(sales: list) -> tuple: pass ``` **Expected Inputs**: - `sales` (`list[float]`): A list of 12 float values representing the sales figures for each month. **Expected Outputs**: - Returns a tuple `(total_sales, highest_sales_month, average_sales)`: - `total_sales` (`float`): The total sales for the year. - `highest_sales_month` (`int`): The month (1 to 12) with the highest sales. - `average_sales` (`float`): The average sales per month. **Constraints**: - The length of the `sales` list should be exactly 12. - All sales figures should be non-negative floats. **Examples**: 1. `sales_analysis([1000.0, 2000.0, 3000.0, 4000.0, 5000.0, 6000.0, 7000.0, 8000.0, 9000.0, 10000.0, 11000.0, 12000.0])` should return `(78000.0, 12, 6500.0)`. 2. `sales_analysis([1200.0, 1500.0, 1100.0, 1600.0, 1800.0, 1700.0, 2000.0, 2200.0, 2100.0, 2300.0, 2400.0, 2500.0])` should return `(22400.0, 12, 1866.67)`. **Requirements**: - Ensure that the function is tested with various test cases, including edge cases where all sales are the same. - Handle any incorrect inputs gracefully, raising appropriate exceptions when required. # Solution ```python def sales_analysis(sales: list) -> tuple: if len(sales) != 12: raise ValueError(\\"Sales list must contain exactly 12 months.\\") if any(s < 0 for s in sales): raise ValueError(\\"Sales figures must be non-negative.\\") total_sales = sum(sales) highest_sales_month = sales.index(max(sales)) + 1 average_sales = total_sales / 12 return (total_sales, highest_sales_month, average_sales) # Example Usage print(sales_analysis([1000.0, 2000.0, 3000.0, 4000.0, 5000.0, 6000.0, 7000.0, 8000.0, 9000.0, 10000.0, 11000.0, 12000.0])) print(sales_analysis([1200.0, 1500.0, 1100.0, 1600.0, 1800.0, 1700.0, 2000.0, 2200.0, 2100.0, 2300.0, 2400.0, 2500.0])) ``` In this solution, we handle invalid inputs by raising appropriate exceptions and use basic list operations to compute the required metrics: total sales, the month with the highest sales, and average sales. This solution is in line with the style, complexity, and scope of the provided sample question.","solution":"def sales_analysis(sales: list) -> tuple: if len(sales) != 12: raise ValueError(\\"Sales list must contain exactly 12 months.\\") if any(s < 0 for s in sales): raise ValueError(\\"Sales figures must be non-negative.\\") total_sales = sum(sales) highest_sales_month = sales.index(max(sales)) + 1 average_sales = total_sales / 12 return (total_sales, highest_sales_month, average_sales)"},{"question":"**Context**: You are developing a social media platform where users can follow each other. You need to implement a function that determines the shortest path (in terms of the number of connections) between two users in the network. If there is no possible path, the function should return -1. Users are represented as nodes and follows as edges in a directed graph. **Task**: Implement the function `shortest_path(connections: List[Tuple[int, int]], start: int, end: int) -> int` that returns the shortest path between two users if a path exists, otherwise returns -1. # Input * `connections`: A list of tuples representing directed follows between users (1 <= len(connections) <= 10^5). * `start`: An integer representing the starting user node. * `end`: An integer representing the ending user node. # Output * Return the shortest number of connections from `start` to `end`, or -1 if no path exists. # Constraints * Each user is represented by a unique integer (0 <= user <= 10^4). * Connections represent directed edges in the form `(a, b)` meaning user `a` follows user `b`. # Example Example 1 ```python connections = [(0, 1), (1, 2), (2, 3), (3, 4)] start = 0 end = 4 assert shortest_path(connections, start, end) == 4 ``` Example 2 ```python connections = [(0, 1), (1, 2), (2, 3), (3, 4)] start = 0 end = 5 assert shortest_path(connections, start, end) == -1 ``` Example 3 ```python connections = [(2, 3), (3, 4), (4, 5), (5, 6), (1, 2), (0, 1), (3, 0)] start = 0 end = 6 assert shortest_path(connections, start, end) == 6 ```","solution":"from typing import List, Tuple from collections import deque, defaultdict def shortest_path(connections: List[Tuple[int, int]], start: int, end: int) -> int: if start == end: return 0 graph = defaultdict(list) for a, b in connections: graph[a].append(b) queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: current_node, steps = queue.popleft() for neighbor in graph[current_node]: if neighbor == end: return steps + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) return -1"},{"question":"# Question Objective Write a function `find_anagram_groups` that identifies and groups anagrams from a list of strings. An anagram is a string that can be formed by rearranging the letters of another, using all the original letters exactly once. Algorithm Explanation The function should: 1. Sort each string in the list to determine the anagram key. 2. Use the sorted string as a key to group the original strings in a dictionary. 3. Return the grouped anagrams as a list of lists, where each sublist contains strings that are anagrams of each other. Input and Output * **Input**: A list of strings `words`. * **Output**: A list of lists of strings, where each sublist contains anagrams. Constraints * Ensure the function has a time complexity of O(n * m * log(m)) where n is the number of strings and m is the maximum length of a string. * The function signature should be: `def find_anagram_groups(words: list) -> list`. Scenario Imagine managing a collection of item codes in a warehouse. Grouping them based on anagram matches can help in certain inventory management and analysis tasks. Example ```python >>> words = [\\"tea\\", \\"ate\\", \\"eat\\", \\"bat\\", \\"tab\\", \\"cat\\"] >>> find_anagram_groups(words) [[\'tea\', \'ate\', \'eat\'], [\'bat\', \'tab\'], [\'cat\']] >>> words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"tinsel\\"] >>> find_anagram_groups(words) [[\'listen\', \'silent\', \'enlist\', \'inlets\', \'tinsel\']] >>> words = [\\"abc\\", \\"cab\\", \\"bca\\", \\"xyz\\", \\"zyx\\"] >>> find_anagram_groups(words) [[\'abc\', \'cab\', \'bca\'], [\'xyz\', \'zyx\']] >>> words = [\\"abcd\\"] >>> find_anagram_groups(words) [[\'abcd\']] ``` Develop the `find_anagram_groups` function to accurately group anagrams according to the specified guidelines.","solution":"def find_anagram_groups(words): Groups anagrams from a list of strings. Parameters: words (list): List of strings to be grouped as anagrams. Returns: list: List of lists, where each sublist contains anagrams. from collections import defaultdict anagram_dict = defaultdict(list) for word in words: # Sort the word to form the key sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"# Coding Challenge: Reverse Words in a Sentence You are tasked with writing a function to reverse the words in a given sentence. This exercise will test your understanding of string manipulation, iteration, and basic data structures in Python. Problem Description Implement a function named `reverse_words` that takes a string as input and returns a new string with the words in reverse order. Function Signature: ```python def reverse_words(sentence: str) -> str: ``` Input: * `sentence`: A single string containing words separated by spaces. The string will not contain any special characters or punctuation. Output: * Returns a new string with the words in reverse order, maintaining the original spacing between words. Example: ```python assert reverse_words(\\"hello world\\") == \\"world hello\\" assert reverse_words(\\"coding is fun\\") == \\"fun is coding\\" assert reverse_words(\\"a b c d\\") == \\"d c b a\\" assert reverse_words(\\"singleword\\") == \\"singleword\\" assert reverse_words(\\"\\") == \\"\\" ``` Constraints: * The words in the sentence will be separated by single spaces. * There will be no leading or trailing spaces. * The sentence may contain an arbitrary number of words (including none). Additional Considerations: Ensure to handle cases with different word counts effectively, including an empty string and single-word sentences. Use efficient and straightforward methods to reverse the words to keep the implementation clear and easy to read.","solution":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence. Parameters: sentence (str): The sentence with words to reverse. Returns: str: A new string with the words in reverse order. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Objective Design a system to manage a virtual cinema booking and seat allocation mechanism that efficiently handles reservations and cancellations. # Scenario In this problem, you need to create a class `VirtualCinema` that can manage seat bookings and cancellations for a virtual cinema auditorium. This will test the understanding of data structures, algorithms, and efficient management of resources. # Task - Implement the `VirtualCinema` class with the following methods: 1. `__init__(self, rows: int, seats_per_row: int) -> None`: Initializes the cinema with a specified number of rows and seats per row. 2. `book_seat(self, row: int, seat: int) -> str`: Attempts to book a specified seat. 3. `cancel_booking(self, row: int, seat: int) -> str`: Cancels a booking for the specified seat. 4. `check_seat_status(self, row: int, seat: int) -> str`: Checks if a seat is booked or available. # Implementation Details 1. **Characteristics**: - Each seat is uniquely identified by its row and seat number within that row. - Operations should efficiently handle checking, booking, and canceling seats. 2. **Input/Output**: - `__init__`: Initializes the cinema object. - Input: rows (int), seats_per_row (int) - Output: None - `book_seat`: Books a specified seat, if available. - Input: row: int, seat: int - Output: status message: str - `cancel_booking`: Cancels a booking for the specified seat, if booked. - Input: row: int, seat: int - Output: status message: str - `check_seat_status`: Checks the booking status of the specified seat. - Input: row: int, seat: int - Output: seat status: str 3. **Constraints**: - Rows and seats per row should be within realistic theatre limits (e.g., 1-30 rows, 1-50 seats per row). # Example ```python cinema = VirtualCinema(rows=5, seats_per_row=10) print(cinema.book_seat(3, 5)) # \\"Seat at row 3, seat 5 has been booked.\\" print(cinema.check_seat_status(3, 5)) # \\"Seat at row 3, seat 5 is booked.\\" print(cinema.cancel_booking(3, 5)) # \\"Booking for seat at row 3, seat 5 has been canceled.\\" print(cinema.check_seat_status(3, 5)) # \\"Seat at row 3, seat 5 is available.\\" print(cinema.book_seat(1, 11)) # \\"Invalid seat selection.\\" print(cinema.cancel_booking(1, 11)) # \\"Invalid seat selection.\\" ``` 4. **Performance Requirements**: - The solution should be optimized for both time and space, ensuring quick seat status checks and updates even for large auditoriums.","solution":"class VirtualCinema: def __init__(self, rows: int, seats_per_row: int) -> None: Initialize the cinema with the number of rows and seats per row. self.rows = rows self.seats_per_row = seats_per_row self.bookings = [[False] * seats_per_row for _ in range(rows)] def book_seat(self, row: int, seat: int) -> str: Attempts to book the specified seat. if row < 1 or row > self.rows or seat < 1 or seat > self.seats_per_row: return \\"Invalid seat selection.\\" if self.bookings[row - 1][seat - 1]: return \\"Seat is already booked.\\" self.bookings[row - 1][seat - 1] = True return f\\"Seat at row {row}, seat {seat} has been booked.\\" def cancel_booking(self, row: int, seat: int) -> str: Cancels the booking for the specified seat. if row < 1 or row > self.rows or seat < 1 or seat > self.seats_per_row: return \\"Invalid seat selection.\\" if not self.bookings[row - 1][seat - 1]: return \\"Seat is not booked.\\" self.bookings[row - 1][seat - 1] = False return f\\"Booking for seat at row {row}, seat {seat} has been canceled.\\" def check_seat_status(self, row: int, seat: int) -> str: Checks the booking status of the specified seat. if row < 1 or row > self.rows or seat < 1 or seat > self.seats_per_row: return \\"Invalid seat selection.\\" if self.bookings[row - 1][seat - 1]: return f\\"Seat at row {row}, seat {seat} is booked.\\" else: return f\\"Seat at row {row}, seat {seat} is available.\\""},{"question":"# Problem Statement You are tasked with implementing a simple text-based file system that supports creating files and directories, as well as listing the contents. The system should be able to parse and respond to specific commands provided as input. # Specific Requirements 1. **Input**: - A list of strings, where each string is a command to the file system. 2. **Output**: - A list of strings representing the output of each command where applicable. # Commands - `\\"CREATE <path>\\"`: Creates a file or directory at the specified path. - `\\"LIST <path>\\"`: Lists the contents of the directory at the specified path. # Example Consider the following list of commands: ```python [\\"CREATE /a\\", \\"CREATE /a/b\\", \\"CREATE /a/c\\", \\"CREATE /a/b/d\\", \\"LIST /a\\"] ``` The corresponding output would be: ```python [\\"b\\", \\"c\\"] ``` # Constraints - Paths are provided in Unix-like format, i.e., `/a/b` represents a file or directory `b` inside directory `a`. - The system should reject creating a directory or file if any part of the path does not exist. - The file and directory names consist of alphanumeric characters only. - All commands are well-formed. # Function Implementation You are required to implement the function `file_system(commands: List[str]) -> List[str]` that processes the commands and returns the output for each list command. # Additional Guidance Ensure to handle the following cases: - Commands are processed in the order they are given. - The system should manage the file structure appropriately to allow correct listing. - Proper error handling when trying to list non-existent directories or create in non-existent paths. # Example Implementation ```python from collections import defaultdict class FileSystem: def __init__(self): self.fs = defaultdict(list) def create(self, path): parts = path.strip(\\"/\\").split(\'/\') for i in range(1, len(parts)): parent = \'/\' + \'/\'.join(parts[:i]) if parent not in self.fs: return self.fs[(\'/\' + \'/\'.join(parts[:-1]))].append(parts[-1]) self.fs[path] = [] def list_dir(self, path): return self.fs[path] def file_system(commands): fs = FileSystem() results = [] for command in commands: cmd, path = command.split(\' \') if cmd == \\"CREATE\\": fs.create(path) elif cmd == \\"LIST\\": results.extend(fs.list_dir(path)) return results if __name__ == \\"__main__\\": commands = [\\"CREATE /a\\", \\"CREATE /a/b\\", \\"CREATE /a/c\\", \\"CREATE /a/b/d\\", \\"LIST /a\\"] print(file_system(commands)) ``` # Instructions for Users - Implement the file system to respond correctly to the given commands. - Ensure `CREATE` operations correctly modify the file system structure. - Ensure `LIST` operations return the expected directory contents. - Handle edge cases accurately to align with typical file system behaviors.","solution":"from collections import defaultdict class FileSystem: def __init__(self): self.fs = defaultdict(list) def create(self, path): parts = path.strip(\\"/\\").split(\'/\') for i in range(1, len(parts)): parent = \'/\' + \'/\'.join(parts[:i]) if parent not in self.fs: return self.fs[\'/\' + \'/\'.join(parts[:-1])].append(parts[-1]) self.fs[path] = [] def list_dir(self, path): if path in self.fs: return sorted(self.fs[path]) return [] def file_system(commands): fs = FileSystem() results = [] for command in commands: cmd, path = command.split(\' \') if cmd == \\"CREATE\\": fs.create(path) elif cmd == \\"LIST\\": results.extend(fs.list_dir(path)) return results"},{"question":"# Coding Assessment Question Context You are part of a team that is developing a new feature for analyzing textual data, specifically focusing on counting unique characters in a given string. Your task is to implement a function that counts the number of unique characters in a given string. Task Write a Python function `count_unique_characters` that performs the following operations: 1. Count all unique characters in the given string, ignoring the case (i.e., treat \'a\' and \'A\' as the same character). 2. Return the total count of these unique characters. Function Signature ```python def count_unique_characters(s: str) -> int: ``` Input * `s` (a string): The input string containing alphanumeric characters and punctuation marks. Output * An integer representing the total count of unique characters ignoring case sensitivity. Constraints 1. The input string `s` will contain at most `10000` characters. 2. Ignore case (i.e., \'A\' and \'a\' are considered the same). 3. The string can be empty. Example ```python # Example 1 s = \\"Hello World!\\" print(count_unique_characters(s)) # Output: 9 # Example 2 s = \\"AaBbCc\\" print(count_unique_characters(s)) # Output: 3 # Example 3 s = \\"\\" print(count_unique_characters(s)) # Output: 0 # Example 4 s = \\"1234567890\\" print(count_unique_characters(s)) # Output: 10 ``` Notes * Ensure that all comparisons are case insensitive. * Handle any edge cases where the input string might be empty. * Consider all characters, including punctuation and numbers, in the count.","solution":"def count_unique_characters(s: str) -> int: Returns the count of unique characters in the given string, ignoring case. # Convert the string to lowercase s = s.lower() # Use a set to track unique characters unique_chars = set(s) # Return the number of unique characters return len(unique_chars)"},{"question":"# Coding Question: Prime Number and Factorial Analysis Objective: You are given two functions: one that checks if a number is prime, and another that computes the factorial of a number. Your task is to enhance these functions and write a new function that works with both to solve a given problem. Problem Statement: Write a function `analyze_number(number: int) -> tuple` that takes as input an integer. This function should return a tuple containing: 1. A boolean indicating whether the number is prime. 2. The factorial of the number if it is less than or equal to 10, otherwise return `None` for the factorial. Function Signature: ```python def analyze_number(number: int) -> tuple: pass ``` Expected Input and Output: - **Input**: An integer (e.g., 5) - **Output**: A tuple (boolean, int or None) where the first element is True if the number is prime and False otherwise, and the second element is the factorial of the number if it is less than or equal to 10, otherwise `None`. Constraints: - The input number will be a non-negative integer. Performance Requirements: - Prime check time complexity should be O(sqrt(n)). - Factorial computation time complexity should be O(n). Example: ```python >>> analyze_number(5) (True, 120) >>> analyze_number(10) (False, 3628800) >>> analyze_number(12) (False, None) >>> analyze_number(7) (True, 5040) ``` Additional Requirements: - Reuse and enhance the provided functions `is_prime` and `compute_factorial`. - Handle improper input by raising an appropriate ValueError with a descriptive message.","solution":"import math def is_prime(number): Check if a number is a prime number. if number < 2: return False for i in range(2, int(math.sqrt(number)) + 1): if number % i == 0: return False return True def compute_factorial(number): Compute the factorial of a number. if number == 0: return 1 factorial = 1 for i in range(1, number + 1): factorial *= i return factorial def analyze_number(number): Analyze the given number to determine if it is prime and to compute its factorial if it is less than or equal to 10. if not isinstance(number, int) or number < 0: raise ValueError(\\"Number must be a non-negative integer.\\") prime_status = is_prime(number) factorial_result = compute_factorial(number) if number <= 10 else None return (prime_status, factorial_result)"},{"question":"# Problem Statement Write a function `filter_even_squares` that takes a list of integers and returns a new list containing the squares of the even numbers from the original list, sorted in descending order. # Function Signature ```python def filter_even_squares(numbers: List[int]) -> List[int]: ``` # Parameters - `numbers` (List[int]): A list of integers. # Returns - `List[int]`: A new list containing the squares of the even numbers from the original list, sorted in descending order. # Example ```python filter_even_squares([1, 2, 3, 4, 5]) # Output: [16, 4] filter_even_squares([10, 15, 20, 25]) # Output: [400, 100] ``` # Constraints - The input list will have at least one integer. - The function should handle both positive and negative integers. - Consider the time complexity to ensure the function runs efficiently for larger inputs.","solution":"from typing import List def filter_even_squares(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list containing the squares of the even numbers from the original list, sorted in descending order. even_squares = [x**2 for x in numbers if x % 2 == 0] return sorted(even_squares, reverse=True)"},{"question":"Most Frequent Character You are tasked with developing a function that identifies the most frequent character in a given string. In case of a tie, the earliest occurring character in the string should be returned. **Function Signature**: ```python def most_frequent_char(input_str: str) -> str: ``` **Input**: - A single string `input_str` containing a sequence of characters. **Output**: - A single character which is the most frequent in the string. In case of a tie, return the character that appears first in the string. **Constraints**: - The input string can be up to 10^5 characters long. - The input string will only contain printable ASCII characters. **Performance Requirements**: - The solution should be efficient, with an expected complexity of O(n) where `n` is the length of the input string. **Scenario**: Suppose you are tasked with analyzing large amounts of text data and need to identify the most frequent character in order to optimize storage encoding strategies by prioritizing frequently occurring characters. **Example**: ```python >>> most_frequent_char(\\"abracadabra\\") \'a\' >>> most_frequent_char(\\"mississippi\\") \'i\' >>> most_frequent_char(\\" \\") \' \' >>> most_frequent_char(\\"aabbcc\\") \'a\' ``` Your task is to implement the `most_frequent_char` function as outlined above.","solution":"def most_frequent_char(input_str: str) -> str: Identify the most frequent character in a given string. If there\'s a tie, return the earliest occurring character in the string. char_frequency = {} max_freq = 0 max_char = input_str[0] if input_str else \'\' for char in input_str: if char in char_frequency: char_frequency[char] += 1 else: char_frequency[char] = 1 if char_frequency[char] > max_freq: max_freq = char_frequency[char] max_char = char elif char_frequency[char] == max_freq: # retain the max_char as is if char occurs later in the input_str if input_str.index(max_char) > input_str.index(char): max_char = char return max_char"},{"question":"# Coding Question: Implement a Circular Queue Context: Bob is designing a data processing system that requires a fixed-size, efficient, circular queue data structure. He needs a function that can perform enqueue and dequeue operations while maintaining the circular nature of the queue. Your task is to implement a circular queue class with specified methods. Task: Write a class `CircularQueue` that initializes a circular queue with a fixed capacity and provides methods to enqueue and dequeue elements, as well as to check if the queue is empty or full. Class Methods: - `__init__(self, capacity: int) -> None`: Initializes the circular queue with the given capacity. - `enqueue(self, value: int) -> bool`: Adds a value to the queue. Returns `True` if the operation is successful, or `False` if the queue is full. - `dequeue(self) -> Optional[int]`: Removes and returns the front element from the queue. Returns `None` if the queue is empty. - `is_empty(self) -> bool`: Checks if the queue is empty. Returns `True` if empty, `False` otherwise. - `is_full(self) -> bool`: Checks if the queue is full. Returns `True` if full, `False` otherwise. Input and Output Format: * **Input**: * An initial call to instantiate the `CircularQueue` with a given `capacity`. * Subsequent calls to `enqueue` and `dequeue` methods. * Capacity constraint: (1 leq text{capacity} leq 10^6) * Values to enqueue and dequeue are integers within the range of standard 32-bit integers. * **Output**: * The `enqueue` method returns `True` or `False`. * The `dequeue` method returns the dequeued integer or `None`. Example Cases: ```python # Initialize a circular queue with capacity 3 cq = CircularQueue(3) # Enqueue elements cq.enqueue(10) # returns True cq.enqueue(20) # returns True cq.enqueue(30) # returns True cq.enqueue(40) # returns False, queue is full # Dequeue elements cq.dequeue() # returns 10 cq.dequeue() # returns 20 # Check if queue is empty or full cq.is_empty() # returns False cq.is_full() # returns False # Enqueue another element cq.enqueue(50) # returns True # Dequeue remaining elements cq.dequeue() # returns 30 cq.dequeue() # returns 50 cq.dequeue() # returns None, queue is empty ``` Constraints: * Implement the circular queue using a fixed-size array. * Ensure all operations have amortized O(1) time complexity. Good luck and ensure your code passes the provided example cases!","solution":"from typing import Optional class CircularQueue: def __init__(self, capacity: int) -> None: self.capacity = capacity self.queue = [0] * capacity self.head = -1 self.tail = -1 self.size = 0 def enqueue(self, value: int) -> bool: if self.is_full(): return False if self.is_empty(): self.head = 0 self.tail = (self.tail + 1) % self.capacity self.queue[self.tail] = value self.size += 1 return True def dequeue(self) -> Optional[int]: if self.is_empty(): return None value = self.queue[self.head] self.queue[self.head] = 0 # Optional: Reset the value for debugging purposes if self.head == self.tail: # Queue becomes empty self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.capacity self.size -= 1 return value def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity"},{"question":"# Problem Statement You are given a grid with obstacles, and you need to find a path from the top-left corner to the bottom-right corner. The grid is represented as a list of list of integers where `0` represents an empty cell and `1` represents an obstacle. You can only move right or down at each step. Your task is to write a function to implement a Depth-First Search (DFS) algorithm to find a path from the top-left corner `(0, 0)` to the bottom-right corner `(n-1, m-1)`. If there are multiple paths, return any one of them. If there is no path, return an empty list. # Function Signature ```python def find_path_dfs(grid: list[list[int]]) -> list[tuple[int, int]]: ``` # Input Format A single argument: * `grid` (list of list of ints, 0 <= len(grid) <= 1000, 0 <= len(grid[0]) <= 1000) - the grid to navigate. The grid can be an empty list or contain multiple rows and columns. # Output Format * Return a list of tuples where each tuple represents a cell `(row, col)` in the path from the top-left corner to the bottom-right corner. If no path exists, return an empty list. # Constraints * The elements in `grid` will have values within range `[0,1]` * The grid matrix dimensions will be within `[0, 1000]` # Example ```python Input find_path_dfs([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) Output [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] ``` # Notes * You must properly handle edge cases, such as when the input grid is empty or the path cannot be found. * Ensure the DFS explores all possible paths until it either finds a valid one or determines none exist. * Do not use any built-in pathfinding functions. # Implementation Advice * Use a recursive approach for the DFS. * Keep track of visited cells to prevent infinite loops. * Construct the path by backtracking once the destination is reached.","solution":"def find_path_dfs(grid): if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return [] n, m = len(grid), len(grid[0]) path = [] visited = set() def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 1 or (x, y) in visited: return False visited.add((x, y)) path.append((x, y)) if (x, y) == (n - 1, m - 1): return True if dfs(x + 1, y) or dfs(x, y + 1): return True path.pop() return False if dfs(0, 0): return path else: return []"},{"question":"# Coding Assessment Question Context You are developing a reporting tool for a sales department that tracks daily sales figures. One important feature requested is the ability to determine the longest streak of consecutive days of increasing sales. Task Write a function `longest_increasing_streak(sales: List[int]) -> int` that takes a list of integers representing daily sales figures and returns the length of the longest streak of consecutive days where each day\'s sales are higher than the previous day\'s sales. Input * A list of integers `sales`, where `0 <= len(sales) <= 10^5` and each element represents the sales figure for a day (0 <= sales[i] <= 10^9). Output * An integer representing the length of the longest streak of consecutive days of increasing sales. If there is no increasing streak, return 0. Constraints * The implementation should be optimized for performance, aiming for O(n) time complexity. Examples ```python assert longest_increasing_streak([10, 20, 30, 10, 20, 30, 40]) == 4 assert longest_increasing_streak([10, 50, 30, 40, 20, 60, 70]) == 2 assert longest_increasing_streak([5, 4, 3, 2, 1]) == 0 assert longest_increasing_streak([1, 2, 3, 4, 5]) == 4 assert longest_increasing_streak([10]) == 0 assert longest_increasing_streak([]) == 0 ``` **Note**: The consecutive days with increasing sales should reset when a day does not meet the increasing sales criteria. For handling edge cases, consider scenarios like a single day of sales or no sales data at all.","solution":"def longest_increasing_streak(sales): if not sales or len(sales) == 1: return 0 longest_streak = 0 current_streak = 0 for i in range(1, len(sales)): if sales[i] > sales[i - 1]: current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 0 longest_streak = max(longest_streak, current_streak) # Check the final streak return longest_streak"},{"question":"# Coding Assessment Question Scenario As part of a file system optimization task, you are required to write a function that determines if two given file paths point to the same file. The file paths may contain Unix-style symbolic links (`.` and `..`), which should be resolved to their absolute paths before comparison. This feature is crucial in preventing redundant operations on what is effectively the same file. Task Implement a function `are_paths_same(path1: str, path2: str) -> bool`, following the signature: ```python def are_paths_same(path1: str, path2: str) -> bool: pass ``` Your implementation should resolve the symbolic links and return `True` if the paths lead to the same file, and `False` otherwise. Constraints * The input paths, `path1` and `path2`, are non-empty strings. * Each path may have multiple segments separated by forward slashes (`/`). * Each path segment can contain alphabets, digits, or the symbolic links `.` and `..`. * You may assume absolute paths, i.e., paths will start from the root directory (`/`). Input/Output Format * **Input**: Two strings, `path1` and `path2`. * **Output**: A boolean value – `True` if the resolved paths point to the same file, `False` otherwise. Examples ```python are_paths_same(\\"/a/b/c\\", \\"/a/b/c/\\") -> True are_paths_same(\\"/a/b/./c\\", \\"/a/b/c\\") -> True are_paths_same(\\"/a/b/c/../d\\", \\"/a/b/d\\") -> True are_paths_same(\\"/a/b/c\\", \\"/a/b/../c\\") -> False are_paths_same(\\"/a/b/c\\", \\"/a/b/c/../../..\\") -> False ``` Edge cases to consider * Handling root directory as the only element. * Handling multiple consecutive symbolic links. * Paths with extra slashes. * Ensuring no traversal above the root directory (`..` leading out of bounds). Performance Requirements * Time complexity should be O(n), where n is the number of segments in the path. * Space complexity should be O(n), due to the need for supplemental data structures to resolve paths. Implementation Write a solution that resolves symbolic links and normalized file paths, ensuring thorough edge case handling according to the described constraints and examples.","solution":"def are_paths_same(path1: str, path2: str) -> bool: def resolve_path(path): parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack) return resolve_path(path1) == resolve_path(path2)"},{"question":"**Problem Statement: Data Center Load Calculation** You are responsible for calculating the cumulative load of a data center based on given server load values. Implement a function that processes the load values of multiple servers and determines the average load, the maximum load, and the minimum load across these servers. # Function Signature ```python def data_center_loads(loads: list[int]) -> tuple[float, int, int]: Calculate the average, maximum, and minimum loads from a list of integer load values. Parameters: loads (list[int]): A list of server loads (each being a non-negative integer). Returns: tuple[float, int, int]: A tuple containing (average load as a float, maximum load as an int, minimum load as an int). ``` # Requirements 1. The function should return the average load with enhanced precision. 2. It should correctly calculate the maximum and minimum loads. 3. The function must efficiently handle lists with large numbers of servers. 4. Provide documentation and at least 5 test cases demonstrating the correctness, including edge cases. # Input Format - A list of non-negative integers representing server loads. The length of the list can be between 1 and (10^6). # Output Format - A tuple containing: - The average load as a floating-point number. - The maximum load as an integer. - The minimum load as an integer. # Constraints - The function should work within typical integer limits of Python. # Example ```python >>> data_center_loads([10, 20, 30, 40]) (25.0, 40, 10) >>> data_center_loads([1]) (1.0, 1, 1) >>> data_center_loads([1000, 5000, 2000, 3000, 7000]) (3600.0, 7000, 1000) >>> data_center_loads([0, 0, 0, 0]) (0.0, 0, 0) >>> data_center_loads([7, 2, 9, 3, 2, 8]) (5.166666666666667, 9, 2) ``` Ensure to clearly document your function to elucidate your approach and edge cases considered.","solution":"def data_center_loads(loads): Calculate the average, maximum, and minimum loads from a list of integer load values. Parameters: loads (list[int]): A list of server loads (each being a non-negative integer). Returns: tuple[float, int, int]: A tuple containing (average load as a float, maximum load as an int, minimum load as an int). if not loads: raise ValueError(\\"The list of loads should not be empty.\\") total_load = sum(loads) num_servers = len(loads) average_load = total_load / num_servers max_load = max(loads) min_load = min(loads) return average_load, max_load, min_load # Example usage: # loads = [10, 20, 30, 40] # print(data_center_loads(loads)) # Expected output: (25.0, 40, 10)"},{"question":"# Sales Data Analysis You have been provided with a list of sales records for different products in a store. Each sales record contains the product name, number of units sold, and the price per unit. Your task is to write a function to analyze this data and generate a summary report. Requirements 1. Write a function `sales_summary` that accepts a list of sales records. 2. Each sales record is represented as a dictionary with keys: `product_name`, `units_sold`, and `unit_price`. 3. The function should return a dictionary with the following summary information: - `total_revenue`: The total revenue generated from all sales (sum of `units_sold * unit_price` for all records). - `products_sold`: A dictionary where the keys are product names and the values are the total units sold for each product. 4. Implement error handling to handle cases where the input data might be missing required fields or contains invalid data types. If such an error occurs in a record, skip that record and continue processing the remaining records. Input A list of sales records, where each record is a dictionary with keys: - `product_name` (str): Name of the product sold. - `units_sold` (int): Number of units sold. - `unit_price` (float): Price per unit sold. Output A dictionary with the following keys: - `total_revenue` (float): Total revenue from all sales. - `products_sold` (dict): Dictionary mapping product names to total units sold. Example Input: ```python sales_records = [ {\\"product_name\\": \\"Widget\\", \\"units_sold\\": 10, \\"unit_price\\": 9.99}, {\\"product_name\\": \\"Gadget\\", \\"units_sold\\": 5, \\"unit_price\\": 19.99}, {\\"product_name\\": \\"Widget\\", \\"units_sold\\": 7, \\"unit_price\\": 9.99}, {\\"product_name\\": \\"InvalidRecord\\", \\"units_sold\\": \\"abc\\", \\"unit_price\\": 9.99}, ] ``` Output: ```python { \\"total_revenue\\": 249.8, \\"products_sold\\": { \\"Widget\\": 17, \\"Gadget\\": 5 } } ``` # Implementation Implement the following function: ```python def sales_summary(sales_records: list[dict[str, Any]]) -> dict[str, Any]: Generate a summary report from sales data. Parameters: sales_records (list[dict[str, Any]]): A list of sales records where each record is a dictionary containing \'product_name\', \'units_sold\', and \'unit_price\'. Returns: dict[str, Any]: A dictionary with \'total_revenue\' and \'products_sold\'. total_revenue = 0.0 products_sold = {} for record in sales_records: try: product_name = record[\\"product_name\\"] units_sold = int(record[\\"units_sold\\"]) unit_price = float(record[\\"unit_price\\"]) total_revenue += units_sold * unit_price if product_name in products_sold: products_sold[product_name] += units_sold else: products_sold[product_name] = units_sold except (KeyError, ValueError): continue return { \\"total_revenue\\": total_revenue, \\"products_sold\\": products_sold } ```","solution":"def sales_summary(sales_records): Generate a summary report from sales data. Parameters: sales_records (list[dict[str, Any]]): A list of sales records where each record is a dictionary containing \'product_name\', \'units_sold\', and \'unit_price\'. Returns: dict[str, Any]: A dictionary with \'total_revenue\' and \'products_sold\'. total_revenue = 0.0 products_sold = {} for record in sales_records: try: product_name = record[\\"product_name\\"] units_sold = int(record[\\"units_sold\\"]) unit_price = float(record[\\"unit_price\\"]) total_revenue += units_sold * unit_price if product_name in products_sold: products_sold[product_name] += units_sold else: products_sold[product_name] = units_sold except (KeyError, ValueError): continue return { \\"total_revenue\\": total_revenue, \\"products_sold\\": products_sold }"},{"question":"# Sum of Squares Challenge Context You are developing a statistical analysis tool that needs to compute various metrics efficiently. One essential metric is the sum of squares, which is fundamental in many statistical formulas. Objective Write two functions: 1. `sum_of_squares(series: list) -> int`: This function computes the sum of the squares of each number in the given series. 2. `is_perfect_square(n: int) -> bool`: This function checks if a given integer is a perfect square. Detailed Requirements 1. **Function 1: sum_of_squares** * **Input**: A list of integers. * **Output**: An integer representing the sum of the squares. * **Constraints**: - The series should be a non-empty list of integers. - Raise a `ValueError` for invalid input (non-list or empty list). * **Description**: - The function computes and returns the sum of the squares of all integers in the input list. 2. **Function 2: is_perfect_square** * **Input**: A single integer. * **Output**: A boolean value. * **Constraints**: - Input should be a non-negative integer. - Raise a `ValueError` for invalid input (negative integers). * **Description**: - The function checks and returns `True` if the input integer is a perfect square, `False` otherwise. Example Usage ```python # Calculating sum of squares print(sum_of_squares([1, 2, 3, 4])) # 30 print(sum_of_squares([0, 5, 6])) # 61 # Checking perfect square print(is_perfect_square(16)) # True print(is_perfect_square(20)) # False ``` Constraints * You must handle edge cases such as invalid types or empty lists for sum_of_squares, and negative integers for is_perfect_square. * Ensure the performance and accuracy of the implementation. * The solution should be self-contained without any additional libraries. Good luck!","solution":"def sum_of_squares(series): Returns the sum of the squares of each number in the given series. Args: series (list): A list of integers. Returns: int: The sum of the squares of the elements in the list. Raises: ValueError: If the input series is not a list or if it is empty. if not isinstance(series, list) or len(series) == 0: raise ValueError(\\"Invalid input: series must be a non-empty list.\\") return sum(x ** 2 for x in series) def is_perfect_square(n): Checks if the given integer is a perfect square. Args: n (int): A non-negative integer. Returns: bool: True if n is a perfect square, else False. Raises: ValueError: If the input n is a negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Invalid input: n must be a non-negative integer.\\") return int(n ** 0.5) ** 2 == n"},{"question":"# Coding Challenge: Reversing Letters in Words You are tasked with writing a function that reverses the letters of each word in a given sentence, while maintaining the original order of the words. This exercise will test your understanding of string manipulation and efficient handling of text data. Problem Description Implement a function named `reverse_letters` that takes a single string as input and returns a new string where each word\'s letters are reversed, but the words appear in their original order. Function Signature: ```python def reverse_letters(sentence: str) -> str: ``` Input: * `sentence`: A string consisting of one or more words separated by spaces. Output: * Returns a new string where each word\'s letters are reversed, and words are separated by a single space. Example: ```python assert reverse_letters(\\"hello world\\") == \\"olleh dlrow\\" assert reverse_letters(\\"python coding challenge\\") == \\"nohtyp gnidoc egnellahc\\" assert reverse_letters(\\"reverse the letters\\") == \\"esrever eht srettel\\" assert reverse_letters(\\"a b c\\") == \\"a b c\\" assert reverse_letters(\\"I am done\\") == \\"I ma enod\\" ``` Constraints: * The input string will not contain any leading, trailing, or multiple spaces between words. * All words are separated by a single space. * The input string can be upper or lowercase, or a mix of both. Additional Considerations: Ensure the function handles varying cases and inputs efficiently, considering edge cases such as single-letter words and mixed capitalization.","solution":"def reverse_letters(sentence: str) -> str: This function takes a string sentence, and reverses each word in the sentence, while maintaining the original word order. words = sentence.split(\\" \\") reversed_words = [word[::-1] for word in words] return \\" \\".join(reversed_words)"},{"question":"# Chessboard Pattern Detection Develop a function that identifies a chessboard pattern in a given 2D binary array. Each element in the array can either be `0` or `1`, representing black and white squares, respectively. A valid chessboard pattern alternates between 0 and 1 both row-wise and column-wise. # Function Signature ```python def is_chessboard_pattern(arr: List[List[int]]) -> bool: pass ``` # Input - `arr`: A 2D list of integers where each element is either `0` or `1` and all sublists are of the same length. # Output - Return `True` if the input array forms a valid chessboard pattern, otherwise return `False`. # Example Scenario Consider the following array: ```python [[0, 1, 0], [1, 0, 1], [0, 1, 0]] ``` This array forms a valid chessboard pattern, so the function should return `True`. # Constraints - The array will have a minimum size of 2x2 and a maximum size of 100x100. - Each row will have the same number of elements. # Sample Test Cases ```python # Test Case 1 arr = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert is_chessboard_pattern(arr) == True # Test Case 2 arr = [ [1, 1, 0], [1, 0, 1], [0, 1, 0] ] assert is_chessboard_pattern(arr) == False # Test Case 3 arr = [ [0, 1], [1, 0] ] assert is_chessboard_pattern(arr) == True # Test Case 4 arr = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] assert is_chessboard_pattern(arr) == True # Test Case 5 arr = [ [0, 1, 0], [1, 0, 0], [0, 1, 0] ] assert is_chessboard_pattern(arr) == False ``` # Tips - Pay attention to the alternating pattern in both directions. - Consider edge cases where smaller arrays (e.g., 2x2) should still be checked thoroughly. - Optimize for readability and efficiency given the constraints on the input size.","solution":"from typing import List def is_chessboard_pattern(arr: List[List[int]]) -> bool: Checks if the given 2D binary array forms a valid chessboard pattern. rows = len(arr) cols = len(arr[0]) def valid_neighbors(r, c): Helper function to check if the current cell alternates correctly with its neighbors. if r > 0 and arr[r][c] == arr[r-1][c]: return False if c > 0 and arr[r][c] == arr[r][c-1]: return False return True # Check each cell in the grid: for r in range(rows): for c in range(cols): if not valid_neighbors(r, c): return False return True"},{"question":"# Reverse Order of Substrings Given a string, reverse the characters in each word within the string while maintaining the order of the words. **Task**: Implement a function that takes a string as input, reverses the characters in each word of the string, and returns the transformed string. Function Signature ```python def reverse_substrings(s: str) -> str: pass ``` Implementation Requirements: 1. Split the input string by spaces to get the words. 2. Reverse each word individually. 3. Join the reversed words with single spaces to form the final string. Input - A string `s` consisting of words separated by single spaces. Output - A string with each word\'s characters reversed, preserving the original order of words. Example ```python >>> reverse_substrings(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_substrings(\\"coding is fun\\") \\"gnidoc si nuf\\" ``` Constraints - The input string `s` will have at least one word. - Words are defined as sequences of non-space characters. - Words are separated by single spaces only. Note - Use Python string manipulation techniques for splitting, reversing, and joining. - Ensure the function correctly handles cases with multiple words. Scenario You are working on a text processing application that requires encrypted outputs for each word while maintaining sentence structure. Developing this function will aid in verifying correct word-level manipulation without changing word order, ensuring data integrity when passing through different stages of text encryption.","solution":"def reverse_substrings(s: str) -> str: This function takes a string `s`, reverses each word in the string while preserving the order of the words, and returns the resulting string. Parameters: s (str): The input string consisting of words separated by single spaces. Returns: str: A string with each word\'s characters reversed, maintaining the original order of words. # Split the input string into words words = s.split() # Reverse each word reversed_words = [word[::-1] for word in words] # Join the reversed words with single spaces return \' \'.join(reversed_words)"},{"question":"# Problem Statement You are developing a data processing application and need to implement a function that filters and processes a list of tuples. Each tuple represents a product with a name, price, and quantity in stock. Write a program that: 1. Takes a list of tuples as input, where each tuple contains three elements: - A string representing the product name. - A floating-point number representing the product price. - An integer representing the quantity in stock. 2. Computes two results: - A new list of tuples where only products with a price greater than a specified threshold are included. - The total value of the stock for all products, where the stock value of a product is calculated as the price multiplied by the quantity. # Input Format * A list of tuples, where each tuple consists of a string, a floating-point number, and an integer. * A floating-point number representing the price threshold. # Output Format * Print the filtered list of tuples. * Print the total stock value as a floating-point number. # Constraints * All prices and quantities are non-negative. * The list contains at least one product. # Example Input ```python products = [(\\"Widget\\", 30.0, 5), (\\"Gadget\\", 55.5, 2), (\\"Thingamajig\\", 10.0, 15)] threshold = 25.0 ``` Output ``` Filtered Products: [(\'Widget\', 30.0, 5), (\'Gadget\', 55.5, 2)] Total Stock Value: 832.5 ``` # Function Signature The implementation should include one distinct function: ```python def process_products(products: list[tuple[str, float, int]], threshold: float) -> tuple[list[tuple[str, float, int]], float]: pass ``` # Requirements 1. Ensure that your function handles non-negative constraints for prices and quantities appropriately. 2. Use the provided input format and constraints to ensure correctness. 3. Ensure that your functions are efficient and optimize for performance. # Notes * Carefully handle products with prices that exactly match the threshold based on the filtering criteria. * Make sure the output is formatted correctly.","solution":"def process_products(products, threshold): Filters the list of products based on the price threshold and calculates the total stock value. Args: products (list): A list of tuples, each containing the product name (str), price (float), and quantity in stock (int). threshold (float): The price threshold for filtering products. Returns: tuple: A tuple containing: - A list of filtered products (only those with price greater than threshold). - The total stock value for all products. # Filtered products with price greater than threshold filtered_products = [product for product in products if product[1] > threshold] # Calculate the total stock value total_value = sum(product[1] * product[2] for product in products) return filtered_products, total_value # Example usage: products = [(\\"Widget\\", 30.0, 5), (\\"Gadget\\", 55.5, 2), (\\"Thingamajig\\", 10.0, 15)] threshold = 25.0 result = process_products(products, threshold) print(\\"Filtered Products:\\", result[0]) print(\\"Total Stock Value:\\", result[1])"},{"question":"# Question: Real-time Weather Information Aggregator You are required to build a real-time weather information aggregator tool. This tool should fetch the current weather details for a specified city from a popular weather service API. Requirements: 1. Write a function `current_weather` which accepts a city name (e.g., \\"New York\\", \\"Tokyo\\") and returns the current weather information. 2. Use a commonly available weather API, such as [OpenWeatherMap](https://openweathermap.org/) or [WeatherAPI](https://www.weatherapi.com/). 3. The returned information should include: - Temperature - Weather condition (e.g., Clear, Rain) 4. If the information cannot be found or an error occurs, the function should return \\"Weather data not available\\". Function Signature: ```python def current_weather(city: str) -> str: pass ``` Constraints: - You must use the `requests` library for HTTP requests. - Parse the JSON response to extract the required information. - Handle scenarios where the data may not be available or the API may return errors. Input: - `city` (str): The name of the city for which the weather information is to be fetched, e.g., \\"New York\\". Output: - `str`: The current weather information of the specified city formatted as: \\"Temperature: X°C, Condition: Y\\". If the data cannot be found, return \\"Weather data not available\\". Example: ```python weather_info = current_weather(\\"New York\\") print(f\\"Current weather: {weather_info}\\") ``` Expected output if data is available: ``` Current weather: Temperature: 15°C, Condition: Clear ``` Expected output if the data is not available: ``` Current weather: Weather data not available ``` Performance Requirements: - Ensure the function executes promptly and handles network timeouts or API call limits gracefully. - Implement appropriate error-handling mechanisms and retries if necessary. Additional Notes: - Make sure your implementation respects the terms of service of the selected API. - Consider any required API keys and handle their usage securely. - Ensure the returned values are in Celsius and have appropriate rounding.","solution":"import requests def current_weather(city: str) -> str: API_KEY = \'your_api_key_here\' # Replace with your actual API key BASE_URL = \'http://api.openweathermap.org/data/2.5/weather\' try: params = { \'q\': city, \'appid\': API_KEY, \'units\': \'metric\' } response = requests.get(BASE_URL, params=params, timeout=10) response.raise_for_status() # This will raise an HTTPError if the HTTP request returned an unsuccessful status code data = response.json() if data[\'cod\'] == 200: temperature = data[\'main\'][\'temp\'] condition = data[\'weather\'][0][\'description\'] return f\\"Temperature: {temperature}°C, Condition: {condition.capitalize()}\\" else: return \\"Weather data not available\\" except (requests.RequestException, KeyError, ValueError): return \\"Weather data not available\\""},{"question":"# Problem Statement: You are required to implement a function that takes an integer `n` and returns a list of distinct elements that sum up to `n`. If there are multiple ways to achieve this, return any valid list. # Function Signature ```python def distinct_sum(n: int) -> List[int]: pass ``` # Input - An integer `n` (1 ≤ n ≤ 10^9) # Output - A list of distinct positive integers that sum up to `n`. # Constraints - Each element in the list must be a unique positive integer. - The list should have the smallest possible number of elements such that their sum equals `n`. # Examples ```python >>> distinct_sum(4) [1, 3] >>> distinct_sum(5) [1, 4] >>> distinct_sum(7) [1, 2, 4] ``` # Additional Notes - Ensure the sum of elements in the returned list equals `n`. - Handle large values of `n` efficiently. - Make sure there are no duplicate elements in the output list.","solution":"def distinct_sum(n: int) -> list: Returns a list of distinct positive integers that sum up to n. If there are multiple ways to achieve this, return any valid list. result = [] current_sum = 0 next_number = 1 while current_sum + next_number <= n: result.append(next_number) current_sum += next_number next_number += 1 if current_sum < n: result[-1] += (n - current_sum) return result"},{"question":"# Integer Square Root Implement a function to compute the integer square root of a non-negative integer `n`. The integer square root of a number `n` is the largest integer `m` such that `m^2` is less than or equal to `n`. Input: * An integer `n`. Output: * An integer representing the integer square root of `n`. Constraints: * 0 <= n <= 10^12 Performance Requirements: * Optimize your solution to handle the upper limits of `n` efficiently. # Example: ```python n = 15 ``` **Expected Output**: ```python 3 ``` # Example: ```python n = 26 ``` **Expected Output**: ```python 5 ``` # Implementation: ```python def integer_square_root(n): if n == 0: return 0 start, end = 1, n while start <= end: mid = (start + end) // 2 if mid * mid == n: return mid elif mid * mid < n: start = mid + 1 else: end = mid - 1 return end # Test the integer square root function print(integer_square_root(15)) # Expected output: 3 print(integer_square_root(26)) # Expected output: 5 ```","solution":"def integer_square_root(n): Returns the largest integer m such that m^2 <= n. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 start, end = 1, n while start <= end: mid = (start + end) // 2 mid_squared = mid * mid if mid_squared == n: return mid elif mid_squared < n: start = mid + 1 else: end = mid - 1 return end"},{"question":"# Network Optimization As a network administrator, you are tasked with optimizing the network routes within a large corporation. The corporation\'s network can be represented as a directed graph where nodes represent devices, and edges represent the direct communication links between them. You need to identify the optimal routes to ensure efficient data transfer and to minimize the communication delay across the network. Task 1. **Implement a function `shortest_path` that utilizes Dijkstra\'s algorithm to find the shortest path between two devices.** 2. **Implement a function `detect_cycles` that uses Depth-First Search (DFS) to detect if there are any cycles in the network.** 3. **Implement a function `optimize_network` to return a boolean indicating whether the network can be optimized by removing cycles.** Requirements 1. Implement the following functions: - `shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]`: This function should return a list representing the shortest path from the start node to the end node. - `detect_cycles(graph: Dict[int, List[int]]) -> bool`: This function should return `True` if there are cycles in the graph, and `False` otherwise. - `optimize_network(graph: Dict[int, List[int]]) -> bool`: This function should remove cycles if detected, and return `True` if the network can be optimized, and `False` if there are no cycles to remove. 2. **Constraints**: - The graph is represented as an adjacency list where keys are node IDs and values are lists of tuples `(neighbor_id, weight)` for `shortest_path`, and lists of neighbor IDs for `detect_cycles` and `optimize_network`. - The node IDs are non-negative integers, and weights are positive integers. - The network consists of up to 1000 nodes and 5000 edges. 3. **Performance Requirements**: - Efficient use of memory and computational resources, given typical network sizes. - Adequate handling of large graphs with up to 1000 nodes and 5000 edges without significant performance degradation. Input - `graph` (Dict[int, List[Tuple[int, int]]]): Adjacency list representing the network. - `start` (int): The starting device ID for finding the shortest path. - `end` (int): The ending device ID for finding the shortest path. Output - `shortest_path` returns a list of integers representing the device IDs in the path. - `detect_cycles` returns a boolean indicating if cycles exist in the network. - `optimize_network` returns a boolean indicating if the network has been optimized by removing cycles. Example ```python network = { 0: [(1, 2), (2, 4)], 1: [(2, 1), (3, 7)], 2: [(4, 3)], 3: [(4, 1)], 4: [] } start_device = 0 end_device = 4 shortest_path_result = shortest_path(network, start_device, end_device) # Expected: [0, 1, 2, 4] or similar shortest path from 0 to 4 network_with_cycles = { 0: [1, 2], 1: [2, 3], 2: [0], 3: [4], 4: [] } cycles_detected = detect_cycles(network_with_cycles) # Expected: True optimized_network = optimize_network(network_with_cycles) # Expected: True if cycles are removed, False if no cycles are detected ```","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]: Returns the shortest path from start to end node using Dijkstra\'s algorithm. # Priority queue for Dijkstra\'s algorithm pq = [(0, start)] distances = {start: 0} predecessors = {start: None} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == end: # Reconstruct path from end to start path = [] while current_node is not None: path.append(current_node) current_node = predecessors[current_node] return path[::-1] for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances.get(neighbor, float(\'inf\')): distances[neighbor] = distance predecessors[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) return [] def detect_cycles(graph: Dict[int, List[int]]) -> bool: Returns True if there is a cycle in the graph, else False. def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False def optimize_network(graph: Dict[int, List[int]]) -> bool: Returns True if the network is optimized by removing cycles, else False. if detect_cycles(graph): # Logic to optimize and remove cycles is assumed to be abstracted # since the problem does not provide a clear way to remove them. return True return False"},{"question":"# **Problem Statement:** You are tasked with developing functions to manage and analyze a user’s playlist in a music streaming application. This will involve creating new playlists, adding songs to them, and retrieving playlist details. # **Function Specification:** 1. **`create_playlist(playlist_name: str) -> dict`** * **Input**: `playlist_name` (a string containing the name of the playlist). * **Output**: A dictionary representing the newly created playlist with the playlist name as the key and an empty list of songs as the value. Example: ```python >>> create_playlist(\'Road Trip\') {\'Road Trip\': []} ``` 2. **`add_song_to_playlist(playlist: dict, song_name: str) -> dict`** * **Input**: `playlist` (a dictionary representing the playlist returned by `create_playlist`), `song_name` (a string containing the name of the song to add). * **Output**: An updated dictionary with the song added to the playlist. Example: ```python >>> playlist = create_playlist(\'Road Trip\') >>> add_song_to_playlist(playlist, \'Song A\') {\'Road Trip\': [\'Song A\']} ``` 3. **`remove_song_from_playlist(playlist: dict, song_name: str) -> dict`** * **Input**: `playlist` (a dictionary representing a playlist), `song_name` (a string containing the name of the song to remove). * **Output**: An updated dictionary with the song removed from the playlist. Example: ```python >>> playlist = create_playlist(\'Road Trip\') >>> playlist = add_song_to_playlist(playlist, \'Song A\') >>> remove_song_from_playlist(playlist, \'Song A\') {\'Road Trip\': []} ``` 4. **`get_playlist_length(playlist: dict) -> int`** * **Input**: `playlist` (a dictionary representing a playlist). * **Output**: An integer representing the number of songs in the playlist. Example: ```python >>> playlist = create_playlist(\'Road Trip\') >>> add_song_to_playlist(playlist, \'Song A\') >>> add_song_to_playlist(playlist, \'Song B\') >>> get_playlist_length(playlist) 2 ``` 5. **`find_song_in_playlists(playlists: list[dict], song_name: str) -> list[str]`** * **Input**: `playlists` (a list of dictionaries, where each dictionary represents a playlist), `song_name` (a string containing the name of the song to find). * **Output**: A list of playlist names which contain the specified song. Example: ```python >>> playlist1 = add_song_to_playlist(create_playlist(\'Road Trip\'), \'Song A\') >>> playlist2 = add_song_to_playlist(create_playlist(\'Workout\'), \'Song A\') >>> playlist3 = add_song_to_playlist(create_playlist(\'Chill\'), \'Song B\') >>> find_song_in_playlists([playlist1, playlist2, playlist3], \'Song A\') [\'Road Trip\', \'Workout\'] ``` # **Implementation Notes:** * For `create_playlist`, `playlist_name` should be treated case-sensitively. * For `add_song_to_playlist` and `remove_song_from_playlist`, assume the `song_name` is unique within the playlist. If a song is added that already exists, do nothing. If a song is removed that does not exist, do nothing. * For `find_song_in_playlists`, return list of playlist names in the order they are given in the input list. # **Constraints:** * 1 ≤ length of `playlist_name` ≤ 100 * 1 ≤ length of `song_name` ≤ 100 * 0 ≤ number of songs in a playlist ≤ 1000 * 0 ≤ length of `playlists` list ≤ 100 # **Performance Requirements:** * All operations (adding, removing, retrieving playlist length, and finding song) should be efficient, ensuring they run within acceptable time limits for the given constraints. Good luck!","solution":"def create_playlist(playlist_name: str) -> dict: Create a new playlist with the specified name. return {playlist_name: []} def add_song_to_playlist(playlist: dict, song_name: str) -> dict: Add a song to the specified playlist. playlist_name = list(playlist.keys())[0] if song_name not in playlist[playlist_name]: playlist[playlist_name].append(song_name) return playlist def remove_song_from_playlist(playlist: dict, song_name: str) -> dict: Remove a song from the specified playlist. playlist_name = list(playlist.keys())[0] if song_name in playlist[playlist_name]: playlist[playlist_name].remove(song_name) return playlist def get_playlist_length(playlist: dict) -> int: Return the number of songs in the playlist. playlist_name = list(playlist.keys())[0] return len(playlist[playlist_name]) def find_song_in_playlists(playlists: list[dict], song_name: str) -> list[str]: Find playlists that contain the specified song. result = [] for playlist in playlists: playlist_name = list(playlist.keys())[0] if song_name in playlist[playlist_name]: result.append(playlist_name) return result"},{"question":"# Coding Question You are provided with a list of integers and a target integer `k`. Your task is to determine whether there exist two distinct indices `i` and `j` in the list such that the sum of the integers at these indices is equal to `k`. If such indices exist, return `True`; otherwise, return `False`. **Function Signature**: ```python def has_pair_with_sum(nums: list[int], k: int) -> bool: pass ``` **Input**: * `nums` (list of int): A list of integers. * `k` (int): An integer representing the target sum. **Output**: * Returns a boolean value: `True` if there are two distinct indices `i` and `j` in the list such that `nums[i] + nums[j] = k`, otherwise `False`. **Examples**: ```python assert has_pair_with_sum([10, 15, 3, 7], 17) == True # 10 + 7 is 17 assert has_pair_with_sum([1, 2, 3, 4, 5], 10) == False # No pairs sum up to 10 assert has_pair_with_sum([-2, 1, 2, 4, 7], 6) == True # 2 + 4 is 6 assert has_pair_with_sum([3, -1, 0, 2, 5], 4) == True # 3 + 1 is 4, with indices checked appropriately assert has_pair_with_sum([], 5) == False # No pairs in an empty list ``` **Constraints**: * The list `nums` can contain a large number of integers, and the solution should be efficient. * The integers within the list can be negative, zero, or positive. * You should ensure that there are no repeated pairs and only distinct pairs are considered. Write an efficient algorithm to solve this problem.","solution":"def has_pair_with_sum(nums, k): Determines if there are two distinct indices in the list `nums` such that the sum of the elements at these indices is equal to `k`. # Using a set to store the complements we need to find seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"# Calculate Package Delivery Time Context: You are tasked with designing a function to estimate the delivery time for packages based on the distance to the destination and the speed of the delivery vehicle. The expected delivery time calculation is crucial for optimizing delivery schedules in a logistics company. Task: Write a function `estimate_delivery_time` that takes the distance to the destination and the speed of the vehicle as input parameters and calculates the estimated delivery time. Delivery time should be calculated using the formula: [ text{time} = frac{text{distance}}{text{speed}} ] # Function Signature ```python def estimate_delivery_time(distance: float, speed: float) -> float: ``` # Parameters: * `distance` (float): The distance to the destination in kilometers. Must be a positive value. * `speed` (float): The speed of the delivery vehicle in kilometers per hour. Must be a positive value. # Returns: * A float representing the estimated delivery time in hours. # Constraints: 1. Both parameters must be positive floats. 2. Raise a `ValueError` if any of the parameters are non-positive. # Examples: ```python >>> estimate_delivery_time(100, 50) 2.0 >>> estimate_delivery_time(200, 100) 2.0 >>> estimate_delivery_time(-150, 50) Traceback (most recent call last): ... ValueError: Distance must be a positive value >>> estimate_delivery_time(150, -50) Traceback (most recent call last): ... ValueError: Speed must be a positive value ``` **Note**: Your function should handle incorrect inputs robustly by raising appropriate `ValueError` exceptions.","solution":"def estimate_delivery_time(distance: float, speed: float) -> float: Calculate the estimated delivery time in hours. Args: distance (float): The distance to the destination in kilometers. Must be a positive value. speed (float): The speed of the delivery vehicle in kilometers per hour. Must be a positive value. Returns: float: The estimated delivery time in hours. Raises: ValueError: If distance or speed is not a positive value. if distance <= 0: raise ValueError(\\"Distance must be a positive value\\") if speed <= 0: raise ValueError(\\"Speed must be a positive value\\") return distance / speed"},{"question":"# Problem Statement You are tasked with implementing a function that will check whether the order of characters in a given word can be rearranged to form a palindrome. For the purposes of this problem, a palindrome is a string that reads the same backward as forward. # Function Signature ```python def can_form_palindrome(word: str) -> bool: pass ``` # Input/Output Requirements * **Input**: A single argument: - `word` (str): A string containing only lowercase alphabetic characters, with a length of at most 10^5. * **Output**: - Returns a boolean value: `True` if the characters of the word can be rearranged to form a palindrome, and `False` otherwise. # Constraints - The function should run in O(n) time complexity, where n is the length of the string. - The space complexity should be O(1) (i.e., constant space excluding the input size due to the fixed number of characters in the character set). # Scenario Consider you\'re developing an algorithm for a cryptographic application that needs to identify potential palindromic sequences efficiently. This function will be a core part of the preprocessing step to check if any potential encryption keys could form a palindrome when rearranged. # Example ```python >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbcc\\") True ``` # Solution Requirements - Implement the `can_form_palindrome` function following the above specifications. - Ensure the solution is efficient and can handle the upper constraints effectively. - Make sure to consider edge cases, such as the empty string and single-character strings.","solution":"def can_form_palindrome(word: str) -> bool: Checks if the characters of the word can be rearranged to form a palindrome. # Create a dictionary to count the occurrences of each character char_count = {} for char in word: char_count[char] = char_count.get(char, 0) + 1 # To form a palindrome, at most one character can have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Infix to Postfix Conversion Problem Statement You are tasked with converting an infix expression to a postfix expression (Reverse Polish Notation). Implement a function that takes an infix expression as input and outputs the corresponding postfix expression. Function Signature ```python def infix_to_postfix(expression: str) -> str: ``` Input * `expression`: A string representing the infix expression. Output * Returns a string representing the corresponding postfix expression. Constraints * The input expression contains only the characters: * Uppercase English letters (A-Z) * Digits (0-9) * Operators (`+`, `-`, `*`, `/`, `^`) * Parentheses (`(`, `)`) * The input expression is a valid infix expression with balanced parentheses. Example ```python infix_to_postfix(\\"A+B*(C^D-E)\\") # Output: \\"ABCD^E-*+\\" infix_to_postfix(\\"(A-B/C)*(A/K-L)\\") # Output: \\"ABC/-AK/L-*\\" ``` Instructions 1. Implement the Shunting Yard algorithm to convert the infix expression to postfix. 2. Consider operator precedence and associativity: * `^` has the highest precedence and is right associative. * `*` and `/` have higher precedence than `+` and `-`, and are left associative. * `+` and `-` have the lowest precedence and are left associative. 3. Handle parentheses to ensure proper grouping of operations. Additional Notes * You may assume the input expression is always non-empty and does not contain any spaces. * Ensure your implementation is efficient and correctly handles the precedence and associativity rules of operators. * Consider edge cases such as expressions without any operators, or nested parentheses.","solution":"def infix_to_postfix(expression: str) -> str: precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2, \'^\': 3} output = [] stack = [] def precedence_of(op): return precedence[op] if op in precedence else -1 for char in expression: if char.isalnum(): # Character is an operand (A-Z, 0-9) output.append(char) elif char == \'(\': # Left parenthesis stack.append(char) elif char == \')\': # Right parenthesis while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() # Pop the left parenthesis \'(\' else: # Operator while stack and precedence_of(stack[-1]) >= precedence_of(char): output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) # Pop all the operators left in the stack return \'\'.join(output)"},{"question":"# Coding Assessment Task: Optimizing a Hospital\'s Room Allocation System Context You are a software engineer working at a hospital. The administration has tasked you with developing an efficient room allocation system to accommodate patients. The hospital has a fixed number of rooms, and each room can house a certain number of patients depending on the room\'s capacity. Task Write a Python class `HospitalRoomAllocator` that: 1. Initializes with the total number of rooms and their respective capacities. 2. Provides a method `allocate_rooms(patients: int) -> Dict[int, int]` that determines the distribution of patients across the available rooms. 3. Ensures the patients are allocated in such a way that rooms are filled to capacity before opening a new one. Input Format - A list of integers, where each integer represents the capacity of a room. - An integer representing the total number of patients to be allocated. Output Format - A dictionary where keys are room numbers (starting from 1) and values are the number of patients assigned to that room. Constraints - Assume all input capacities and patient numbers are positive integers. - The total number of patients will not exceed the sum of the room capacities. Example ```python rooms = [3, 4, 2, 5] allocator = HospitalRoomAllocator(rooms) allocation = allocator.allocate_rooms(8) ``` Output: ```python { 1: 3, 2: 4, 3: 1 } ``` Performance Requirements - The allocation should be determined efficiently, even for a high number of rooms and patients. - Ensure that the system handles edge cases gracefully, such as more patients than room capacities can handle. Notes - Use appropriate data structures to ensure an optimal solution. - Consider writing helper methods to keep the code clean and modular. - Proper error handling should be implemented for unexpected inputs.","solution":"from typing import List, Dict class HospitalRoomAllocator: def __init__(self, rooms: List[int]): self.rooms = rooms def allocate_rooms(self, patients: int) -> Dict[int, int]: allocation = {} room_number = 1 for capacity in self.rooms: if patients <= 0: break allocated_to_room = min(patients, capacity) allocation[room_number] = allocated_to_room patients -= allocated_to_room room_number += 1 return allocation"},{"question":"# Efficient String Reversal with Memory Constraints Develop a function, `reverse_string_in_place`, that reverses a given string in place without requiring extra space for another string buffer. You are allowed to use a small, constant amount of additional space for variables, but your solution should work efficiently on large input strings by reversing them using in-place swaps. # Function Signature ```python def reverse_string_in_place(s: List[str]) -> None: pass ``` # Input 1. `s`: A list of characters representing the string to be reversed. This list can be modified in place. # Output * The function does not return anything; it modifies the input list `s` in place. # Constraints * The input list, `s`, will contain 1 to 10<sup>5</sup> characters. * You must reverse the list in place, meaning you cannot use any additional lists or strings for storage. # Example ```python input_list = [\'h\', \'e\', \'l\', \'l\', \'o\'] reverse_string_in_place(input_list) print(input_list) # Output should be [\'o\', \'l\', \'l\', \'e\', \'h\'] ``` # Note 1. Use a two-pointer approach to reverse the string. 2. Your solution should handle strings of various lengths within the specified constraints. 3. Ensure the time complexity averages O(n), where n is the length of the string. This problem assesses your understanding of memory management, string manipulation, and efficiency in algorithm design.","solution":"def reverse_string_in_place(s: list) -> None: Reverses the list of characters in place. Parameters: s (list): A list of characters to be reversed in place. Returns: None: The input list `s` is modified in place. left, right = 0, len(s) - 1 while left < right: # Swap the characters at positions left and right s[left], s[right] = s[right], s[left] # Move the pointers towards the center left += 1 right -= 1"},{"question":"Problem Statement # Objective Write a function `decode_run_length(encoded_string: str) -> str` that decodes a string that has been encoded using run-length encoding. # Constraints - The function must take a single string `encoded_string` that follows the run-length encoding format. - The function should raise a `ValueError` if `encoded_string` does not conform to the run-length encoding format. - It is guaranteed that the input string `encoded_string` will not be empty. # Input - `encoded_string` (str): A string encoded with run-length encoding, where characters are followed by a numeric value representing the number of times the character repeats. # Output - The function should return a string that is the decoded version of the `encoded_string`. # Examples ```python >>> decode_run_length(\\"a3b2c4\\") \\"aaabbcccc\\" >>> decode_run_length(\\"x1y12z3\\") \\"xyyyyyyyyyyyyzzz\\" >>> decode_run_length(\\"h5\\") \\"hhhhh\\" >>> decode_run_length(\\"a\\") Traceback (most recent call last): ... ValueError: Input value of [encoded_string=\'a\'] is not a valid run-length encoded string >>> decode_run_length(\\"abc\\") Traceback (most recent call last): ... ValueError: Input value of [encoded_string=\'abc\'] is not a valid run-length encoded string >>> decode_run_length(\\"a0b1\\") Traceback (most recent call last): ... ValueError: Input value of [encoded_string=\'a0b1\'] is not a valid run-length encoded string ``` # Performance Requirements - The function should operate in O(n) time complexity, where n is the length of the `encoded_string`. - The function should use O(n) additional space for the decoded string. # Task Implement the `decode_run_length` function in Python, ensuring that you handle edge cases appropriately and validate the input.","solution":"import re def decode_run_length(encoded_string: str) -> str: Decodes a run-length encoded string into its original form. Parameters: encoded_string (str): The run-length encoded string. Returns: str: The decoded string. Raises: ValueError: If the input string is not a valid run-length encoded string. if not encoded_string: raise ValueError(\\"Input string is empty\\") pattern = re.compile(r\'([a-zA-Z])(d+)\') matches = pattern.findall(encoded_string) if not matches or \'\'.join([\'\'.join(match) for match in matches]) != encoded_string: raise ValueError(f\\"Input value of [encoded_string=\'{encoded_string}\'] is not a valid run-length encoded string\\") decoded_string = [] for char, count in matches: count = int(count) if count <= 0: raise ValueError(f\\"Input value of [encoded_string=\'{encoded_string}\'] is not a valid run-length encoded string\\") decoded_string.append(char * count) return \'\'.join(decoded_string)"},{"question":"# Problem Statement You are given a non-negative integer `n`. Your task is to write a function `number_of_ones(n: int) -> int` that returns the number of \'1\'s in the binary representation of `n`. # Input Format - A single integer `n` (0 ≤ n ≤ 10^9). # Output Format - An integer representing the number of \'1\'s in the binary representation of `n`. # Example Input ```python n = 29 ``` Output ```python 4 ``` Explanation - The binary representation of `29` is `11101`, which contains four \'1\'s. # Constraints 1. The given integer `n` will be in the range of 0 to (10^9). # Detailed Explanation - The binary representation of `29` is `11101`: 1. The first \'1\' appears at the 2^4 place. 2. The second \'1\' appears at the 2^3 place. 3. The third \'1\' appears at the 2^2 place. 4. The fourth \'1\' appears at the 2^0 place. - Thus, there are four \'1\'s in the binary representation of `29`. # Function Signature ```python def number_of_ones(n: int) -> int: pass ``` # Requirements 1. You must implement the function `number_of_ones` to compute the number of \'1\'s in the binary representation efficiently. Good luck!","solution":"def number_of_ones(n: int) -> int: Returns the number of \'1\'s in the binary representation of n. # Use bin() to get the binary representation of n and count \'1\'s return bin(n).count(\'1\')"},{"question":"# Coding Assessment Question Scenario A company has a system that tracks employee sales data across different departments. Each department logs sales using a code that starts with a department-specific prefix followed by a unique number. For example, the Sales department uses \\"SAL\\" (e.g., \\"SAL123\\"), Marketing uses \\"MAR\\" (e.g., \\"MAR456\\"), and Support uses \\"SUP\\" (e.g., \\"SUP789\\"). Your task is to write a function that extracts all sales codes from a given list of strings that belong to a specific department. Task Implement a function `extract_sales_codes` that takes a list of strings and a department prefix as input, and returns a list of sales codes that start with the given prefix. The sales codes consist only of alphanumeric characters. Input - A list of strings `logs` containing sales data entries. - A string `prefix` specifying the department prefix. Output - A list of strings containing all sales codes starting with the given prefix. Constraints - The input list `logs` contains between 0 and 100 strings, each with a length between 1 and 1000 characters. - The `prefix` is a string of uppercase letters with length between 1 and 10 characters. - Sales codes only contain uppercase letters and digits (A-Z, 0-9). Examples ```python >>> extract_sales_codes([\\"SAL1234\\", \\"MAR5678\\", \\"SUP9101\\", \\"SAL4321\\", \\"MAR8765\\"], \\"SAL\\") [\'SAL1234\', \'SAL4321\'] >>> extract_sales_codes([\\"SAL1234\\", \\"MAR5678\\", \\"SUP9101\\", \\"SAL4321\\", \\"MAR8765\\"], \\"MAR\\") [\'MAR5678\', \'MAR8765\'] >>> extract_sales_codes([\\"SAL1234\\", \\"MAR5678\\", \\"SUP9101\\", \\"SAL4321\\", \\"MAR8765\\"], \\"SUP\\") [\'SUP9101\'] >>> extract_sales_codes([\\"SAL1234\\", \\"MAR5678\\", \\"SUP9101\\", \\"SAL4321\\", \\"MAR8765\\"], \\"FIN\\") [] >>> extract_sales_codes([], \\"SAL\\") [] ``` Implementation ```python def extract_sales_codes(logs, prefix): Extract sales codes that start with the given prefix. # Your code here # Sample test cases to validate your function assert extract_sales_codes([\\"SAL1234\\", \\"MAR5678\\", \\"SUP9101\\", \\"SAL4321\\", \\"MAR8765\\"], \\"SAL\\") == [\'SAL1234\', \'SAL4321\'] assert extract_sales_codes([\\"SAL1234\\", \\"MAR5678\\", \\"SUP9101\\", \\"SAL4321\\", \\"MAR8765\\"], \\"MAR\\") == [\'MAR5678\', \'MAR8765\'] assert extract_sales_codes([\\"SAL1234\\", \\"MAR5678\\", \\"SUP9101\\", \\"SAL4321\\", \\"MAR8765\\"], \\"SUP\\") == [\'SUP9101\'] assert extract_sales_codes([\\"SAL1234\\", \\"MAR5678\\", \\"SUP9101\\", \\"SAL4321\\", \\"MAR8765\\"], \\"FIN\\") == [] assert extract_sales_codes([], \\"SAL\\") == [] print(\\"All tests passed!\\") ```","solution":"def extract_sales_codes(logs, prefix): Extract sales codes that start with the given prefix. :param logs: List of strings containing sales data entries. :param prefix: String specifying the department prefix. :return: List of strings containing all sales codes starting with the given prefix. return [log for log in logs if log.startswith(prefix)]"},{"question":"Question: Smallest Window in String Containing All Characters of Another String Given two strings `s` and `p`, write a function to find the smallest window in `s` that contains all characters of `p`. If no such window exists, return an empty string. If multiple such windows exist, return the one which starts first. # Function Signature ```python def smallest_window(s: str, p: str) -> str: Find the smallest window in string `s` that contains all the characters of string `p`. Parameters: s (str): The main string. p (str): The string containing characters to be present in the window. Returns: str: The smallest window in `s` that contains all characters in `p`, or an empty string if no such window exists. ``` # Constraints - Both strings `s` and `p` will only contain lowercase English letters. - The length of the string `s`, `n`, will satisfy `1 <= n <= 10^5`. - The length of the string `p`, `m`, will satisfy `1 <= m <= 10^5`. # Input Example ```python s = \\"this is a test string\\" p = \\"tist\\" ``` # Output Example ```python \\"t stri\\" ``` # Additional Examples Example 1: **Input**: ```python s = \\"ADOBECODEBANC\\" p = \\"ABC\\" ``` **Output**: ```python \\"BANC\\" ``` Example 2: **Input**: ```python s = \\"a\\" p = \\"a\\" ``` **Output**: ```python \\"a\\" ``` Example 3: **Input**: ```python s = \\"a\\" p = \\"aa\\" ``` **Output**: ```python \\"\\" ``` # Scenario/Context The function can be used in text-processing tools where extracting specific patterns or substrings is necessary. This is helpful in applications related to search algorithms, highlighting key terms, and data filtering. # Notes - Focus on an efficient solution, possibly using a sliding window technique, to handle the worst-case input sizes. - Consider edge cases like when `s` or `p` is empty and when characters in `p` do not exist in `s`.","solution":"def smallest_window(s: str, p: str) -> str: from collections import Counter # Edge case: if p is longer than s, no such window can exist if not s or not p or len(p) > len(s): return \\"\\" # Dictionary to keep a count of all the unique characters in p needed_chars = Counter(p) # Number of unique characters in p that need to be present in the window required = len(needed_chars) # Left and right pointer l, r = 0, 0 # Formed is used to keep track of how many unique characters in p # are present in the current window in their required frequency formed = 0 # Dictionary to keep a count of all the unique characters in the current window window_counts = {} # (window_length, left, right) ans = float(\\"inf\\"), None, None while r < len(s): # Add one character from the right to the window char = s[r] window_counts[char] = window_counts.get(char, 0) + 1 # If the frequency of the current character added matches the desired count in p if char in needed_chars and window_counts[char] == needed_chars[char]: formed += 1 # Try to contract the window till the point where it ceases to be \'desirable\' while l <= r and formed == required: char = s[l] # Save the smallest window until now if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) # The character at the position pointed by the `left` pointer is no longer part of the window window_counts[char] -= 1 if char in needed_chars and window_counts[char] < needed_chars[char]: formed -= 1 # Move the left pointer ahead l += 1 # Keep expanding the window once we are done contracting r += 1 return \\"\\" if ans[1] is None else s[ans[1]:ans[2] + 1]"},{"question":"# Context You have been tasked with implementing a simplified version of a Tic-Tac-Toe game. Your focus is on the game board management, with particular emphasis on determining winning conditions. # Task 1. Implement the `TicTacToe` class to simulate a 3x3 Tic-Tac-Toe game board. 2. Create methods to place markers on the board, check for a winner, and print the board state. 3. Ensure that the winner checking algorithm is efficient and covers all possible winning conditions (rows, columns, and diagonals). # Expected Input and Output * **place_marker(row: int, col: int, marker: str) -> bool**: Takes a row number, a column number, and a marker (\'X\' or \'O\'), places the marker on the board at the specified position. Returns `True` if the marker was placed successfully, or `False` if the position is already occupied. * **check_winner() -> str**: Checks the board for a winner and returns \'X\' if \'X\' wins, \'O\' if \'O\' wins, or \'None\' if there\'s no winner yet. * **display_board() -> None**: Prints the current state of the board. # Constraints * Markers are either \'X\' or \'O\'. * Assume all inputs to `place_marker` are within the valid range (0-2 for rows and columns). * The game concludes when all positions are filled or a winner is found. # Example ```python game = TicTacToe() game.place_marker(0, 0, \'X\') game.place_marker(1, 1, \'O\') game.place_marker(0, 1, \'X\') game.place_marker(2, 2, \'O\') game.place_marker(0, 2, \'X\') print(game.check_winner()) # Output: \'X\' game.display_board() # Output: # X X X # O # O ``` # Performance Requirements * Ensure the winner checking is efficient and handles all win conditions (horizontal, vertical, and diagonal) in O(1) time for each move.","solution":"class TicTacToe: def __init__(self): self.board = [[\' \' for _ in range(3)] for _ in range(3)] self.current_winner = None def place_marker(self, row, col, marker) -> bool: if self.board[row][col] == \' \': self.board[row][col] = marker self.check_winner() return True return False def check_winner(self) -> str: # Check rows for a winner for row in self.board: if row[0] == row[1] == row[2] != \' \': self.current_winner = row[0] return self.current_winner # Check columns for a winner for col in range(3): if self.board[0][col] == self.board[1][col] == self.board[2][col] != \' \': self.current_winner = self.board[0][col] return self.current_winner # Check diagonals for a winner if self.board[0][0] == self.board[1][1] == self.board[2][2] != \' \': self.current_winner = self.board[0][0] return self.current_winner if self.board[0][2] == self.board[1][1] == self.board[2][0] != \' \': self.current_winner = self.board[0][2] return self.current_winner return None def display_board(self) -> None: for row in self.board: print(\' \'.join(row))"},{"question":"# Circular Array Rotation You are given an array of integers and a number of rotations, k. Your task is to rotate the array to the right by k steps and return the result. This process should be efficient even for large arrays. # Objective: Write a Python function to rotate the elements of a given array to the right by a specified number of steps. # Function Signature Requirements: ```python def rotate_array(arr: list[int], k: int) -> list[int]: ``` # Parameters: 1. **arr**: (list of int) The array to rotate. 2. **k**: (int) The number of steps to rotate the array to the right. # Returns: - A list of integers representing the array after rotating it `k` steps to the right. # Constraints: - The length of the array, `n`, will be between 1 and 10^5. - Each element of the array will be an integer between -10^9 and 10^9. - `k` will be a non-negative integer less than or equal to 10^9. # Examples: ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1, 2], 3) [2, 1] >>> rotate_array([1], 1) [1] ``` **Hint:** To avoid excessive computations, you can use the modulus operator to determine the effective number of rotations needed. For instance, rotating an array of size `n` by `k` steps is equivalent to rotating it by `k % n` steps. # Solution: Implement and test your function to ensure correctness. Make sure your function is efficient and handles all edge cases appropriately.","solution":"def rotate_array(arr: list[int], k: int) -> list[int]: Rotate the array to the right by k steps. Parameters: arr (list of int): The array to rotate. k (int): The number of steps to rotate the array to the right. Returns: list of int: The rotated array. n = len(arr) if n == 0 or k % n == 0: return arr k = k % n # Effective rotations return arr[-k:] + arr[:-k]"},{"question":"# Coding Question Context You are given a string and a positive integer k. Your task is to rearrange the string such that the same characters are at least distance k from each other. If it is not possible to rearrange the string in such a way, return an empty string. Problem Statement Implement the function `rearrange_string` that takes a string `s` and an integer `k`, and returns a new string arranged in such a way that the same characters are at least k distances apart. ```python def rearrange_string(s, k): Rearranges the given string `s` so that the same characters are at least k distance apart. If it is not possible, returns an empty string. Parameters: s (str): The input string. k (int): The distance each same character must be apart. Returns: str: The rearranged string or an empty string if the rearrangement is not possible. pass ``` Constraints 1. The string consists of lowercase English letters. 2. The length of the string is between 1 and 10000. 3. The integer k is between 1 and 50. Example ```python assert rearrange_string(\\"aabbcc\\", 3) == \\"abcabc\\" # The order could be any valid one with the condition met assert rearrange_string(\\"aaabc\\", 2) == \\"abaca\\" # Multiple valid outputs possible as long as they meet the condition assert rearrange_string(\\"aaadbbcc\\", 2) == \\"abacadbc\\" # One possible valid output assert rearrange_string(\\"aa\\", 2) == \\"\\" # It\'s not possible to rearrange the string ``` Explanation In the first example, one possible valid rearrangement is \\"abcabc\\" as each character `a`, `b`, and `c` are separated by at least 3 places. In the fourth example, it\'s impossible to rearrange `\\"aa\\"` with `k=2` as there\'s no way to place the two \'a\'s at least 2 places apart. # Performance Requirements Your function should aim for an efficient solution around O(n log n) time complexity where n is the size of the string. This is important to handle the upper constraint of the problem.","solution":"from heapq import heappush, heappop from collections import deque, Counter def rearrange_string(s, k): if k <= 1: return s # When k is less than or equal to 1, any arrangement is valid # Counter to count frequency of each character char_count = Counter(s) max_heap = [] # Push all characters along with their frequencies into the max heap for char, freq in char_count.items(): heappush(max_heap, (-freq, char)) queue = deque() result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) queue.append((char, freq + 1)) # Reduce frequency if len(queue) >= k: # Maintain a window of size k front_char, front_freq = queue.popleft() if front_freq < 0: # If still pending tasks for this char heappush(max_heap, (front_freq, front_char)) rearranged_string = \'\'.join(result) # Check if rearranged string meets the requirement return rearranged_string if len(rearranged_string) == len(s) else \\"\\""},{"question":"# Words Counter Your task is to create a function that counts the number of occurrences of each word in a given list of strings. The function should return the count of each word in a dictionary format. Requirements: 1. Implement a function that accepts a list of strings. 2. The function should return a dictionary where each key is a unique word from the list, and the value is the count of its occurrences. 3. The function should handle case-insensitive words, treating \'Word\' and \'word\' as the same. 4. Ignore punctuation (such as \'!\', \'?\', \',\'). 5. Ensure the function performs efficiently, even for large lists of strings. Input: * A list of strings where each string can contain multiple words separated by spaces. Output: * A dictionary with words as keys and their counts as values. Example: Input: ```python sentences = [ \\"The quick brown fox jumps over the lazy dog!\\", \\"Is the quick brown fox quick?\\", \\"The quick, lazy dog sleeps soundly.\\" ] ``` Output: ```python { \\"the\\": 4, \\"quick\\": 4, \\"brown\\": 2, \\"fox\\": 2, \\"jumps\\": 1, \\"over\\": 1, \\"lazy\\": 2, \\"dog\\": 2, \\"is\\": 1, \\"sleeps\\": 1, \\"soundly\\": 1 } ``` # Implementation Implement the following function: ```python import string def count_words(sentences: list[str]) -> dict[str, int]: Count the occurrences of each word in the given list of sentences. Parameters: sentences (list[str]): A list of strings containing sentences. Returns: dict[str, int]: A dictionary mapping each unique word to its count. word_count = {} translator = str.maketrans(\'\', \'\', string.punctuation) for sentence in sentences: words = sentence.translate(translator).lower().split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count ```","solution":"import string def count_words(sentences: list[str]) -> dict[str, int]: Count the occurrences of each word in the given list of sentences. Parameters: sentences (list[str]): A list of strings containing sentences. Returns: dict[str, int]: A dictionary mapping each unique word to its count. word_count = {} translator = str.maketrans(\'\', \'\', string.punctuation) for sentence in sentences: words = sentence.translate(translator).lower().split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"# Array Manipulation and Querying Problem Statement You are given an array of integers `arr` and a series of queries. Each query can be either an update query or a range sum query. Your task is to implement a function to perform these operations efficiently. 1. Update query: Replace the value at a specified index with a new value. 2. Range sum query: Compute the sum of elements in a specified range. Implement the function that can handle both types of queries. Function Signature ```python def handle_queries(arr: List[int], queries: List[Tuple[str, int, int]]) -> List[int]: ``` Input - `arr` (List[int]): An array of integers. (1 <= len(arr) <= 100,000) - `queries` (List[Tuple[str, int, int]]): A list of queries. Each query is a tuple: - If it\'s an update query: (\'update\', index, new_value) - If it\'s a range sum query: (\'sum\', start_index, end_index) Queries are valid and consistent with the constraints. Output - A list of integers representing results of each \'sum\' query in the order they appear. Constraints - The algorithm should handle large inputs efficiently in the given complexity constraints. - Queries will be valid and within the range of the array. Examples ```python arr = [1, 3, 5, 7, 9, 11] queries = [(\'sum\', 1, 3), (\'update\', 2, 10), (\'sum\', 1, 3), (\'update\', 4, 6), (\'sum\', 0, 5)] # Explanation of queries: # First \'sum\' query: Sum of elements from index 1 to 3 -> 3 + 5 + 7 = 15 # \'update\' query: Update element at index 2 to 10 -> arr becomes [1, 3, 10, 7, 9, 11] # Second \'sum\' query: Sum of elements from index 1 to 3 -> 3 + 10 + 7 = 20 # \'update\' query: Update element at index 4 to 6 -> arr becomes [1, 3, 10, 7, 6, 11] # Third \'sum\' query: Sum of elements from index 0 to 5 -> 1 + 3 + 10 + 7 + 6 + 11 = 38 assert handle_queries(arr, queries) == [15, 20, 38] arr = [4, 6, 8, 3] queries = [(\'sum\', 0, 2), (\'update\', 1, 5), (\'sum\', 0, 2)] # Explanation of queries: # First \'sum\' query: Sum of elements from index 0 to 2 -> 4 + 6 + 8 = 18 # \'update\' query: Update element at index 1 to 5 -> arr becomes [4, 5, 8, 3] # Second \'sum\' query: Sum of elements from index 0 to 2 -> 4 + 5 + 8 = 17 assert handle_queries(arr, queries) == [18, 17] ``` # Notes - Utilize data structures that offer efficient updates and queries, such as segment trees or Fenwick trees. - Handle all edge cases appropriately, particularly with the query and index ranges.","solution":"from typing import List, Tuple class SegmentTree: def __init__(self, data): n = len(data) self.n = n self.tree = [0] * (2 * n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx >>= 1 self.tree[idx] = self.tree[idx << 1] + self.tree[idx << 1 | 1] def query(self, left, right): result = 0 left += self.n right += self.n + 1 while left < right: if left & 1: result += self.tree[left] left += 1 if right & 1: right -= 1 result += self.tree[right] left >>= 1 right >>= 1 return result def handle_queries(arr: List[int], queries: List[Tuple[str, int, int]]) -> List[int]: segment_tree = SegmentTree(arr) results = [] for query in queries: if query[0] == \'update\': _, index, new_value = query segment_tree.update(index, new_value) elif query[0] == \'sum\': _, start_index, end_index = query results.append(segment_tree.query(start_index, end_index)) return results"},{"question":"# Coding Assessment Question: Matrix Diagonal Sum **Scenario**: You are working with matrix operations in numerical computations and often need to sum the diagonal elements of a matrix. Your task is to write a function that, given a square matrix, returns the sum of its main diagonal (the diagonal from the top-left to the bottom-right). **Objective**: Write a function called `diagonal_sum` that accepts a 2-dimensional NumPy array representing a square matrix and returns an integer representing the sum of its main diagonal elements. **Function Signature**: ```python def diagonal_sum(matrix: np.ndarray) -> int: pass ``` **Input**: - `matrix` (ndarray): A 2-dimensional NumPy array of integers, where the number of rows is equal to the number of columns. **Output**: - `int`: The sum of the main diagonal elements of the matrix. **Constraints**: - You must use NumPy for numerical operations. - Assume the input matrix will be at least (1 times 1) and up to (1000 times 1000) elements. - Values of the matrix elements will range between (-1000) and (1000). **Performance Requirements**: - The implementation should efficiently handle the upper limit of the matrix size. **Example**: ```python import numpy as np matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(diagonal_sum(matrix)) # Expected output: 15 matrix = np.array([[2, 5], [7, 11]]) print(diagonal_sum(matrix)) # Expected output: 13 ``` Additionally, ensure your implementation passes the following test: ```python import numpy as np matrix = np.ones((1000, 1000), dtype=int) expected_output = 1000 assert diagonal_sum(matrix) == expected_output ```","solution":"import numpy as np def diagonal_sum(matrix: np.ndarray) -> int: Returns the sum of the main diagonal elements of a square matrix. Args: matrix (np.ndarray): A 2-dimensional NumPy array of integers where the number of rows equals the number of columns. Returns: int: The sum of the main diagonal elements. return np.trace(matrix)"},{"question":"Given that the original question set included tasks that centered on algorithm efficiency, edge case handling, and logical problem-solving skills, I have crafted a new question that incorporates these elements. This new question maintains the same level of complexity, clear guidelines for function implementation, and similar structure for consistency. # Problem Statement You are tasked with implementing a function to determine if a list of integers contains any duplicates. The function should leverage a set data structure to achieve an efficient solution. Consider edge cases such as an empty list, single-element lists, and lists with all duplicate elements. # Function Signature ```python def contains_duplicates(nums: list[int]) -> bool: Determines if the given list contains any duplicates using a set data structure. :param nums: A list of integers to check. :return: True if there are duplicates in the list, False otherwise. Example: >>> contains_duplicates([1, 2, 3, 4, 5]) False >>> contains_duplicates([1, 2, 3, 4, 1]) True >>> contains_duplicates([]) False >>> contains_duplicates([7]) False >>> contains_duplicates([2, 2, 2, 2, 2]) True ``` # Constraints * You must only use a set data structure for the solution. * Your function should be efficient, operating within O(n) time complexity, where n is the length of the list. * Handle edge cases gracefully, ensuring the function does not raise any exceptions. # Additional Notes * An empty list should return `False` since there are no elements to duplicate. * A single-element list should return `False` as well, as one element cannot have duplicates. * The function should not raise any exceptions. * Think about edge cases and test your implementation carefully to ensure the function works as expected under various scenarios. Write and test your implementation carefully, adhering to the provided constraints and ensuring efficient performance.","solution":"def contains_duplicates(nums: list[int]) -> bool: Determines if the given list contains any duplicates using a set data structure. :param nums: A list of integers to check. :return: True if there are duplicates in the list, False otherwise. Example: >>> contains_duplicates([1, 2, 3, 4, 5]) False >>> contains_duplicates([1, 2, 3, 4, 1]) True >>> contains_duplicates([]) False >>> contains_duplicates([7]) False >>> contains_duplicates([2, 2, 2, 2, 2]) True seen = set() for num in nums: if num in seen: return True seen.add(num) return False"},{"question":"# Assessment Question **Q2**: Write a function `categorize_vehicles_by_speed` that categorizes vehicles based on their respective speeds. The input to the function is a list of tuples, where each tuple contains a string representing the vehicle type and an integer representing the speed of the vehicle in kilometers per hour. The function should return a dictionary where the keys are strings representing speed categories (\\"slow\\", \\"medium\\", \\"fast\\") and the values are lists of vehicle types that fall into those categories. A vehicle with a speed less than 60 km/h should be considered \\"slow\\", a speed between 60 km/h (inclusive) and 120 km/h should be considered \\"medium\\", and a speed greater than 120 km/h should be considered \\"fast\\". ```python def categorize_vehicles_by_speed(vehicle_data: list[tuple[str, int]]) -> dict[str, list[str]]: Categorize vehicles based on their speed. Args: vehicle_data (list[tuple[str, int]]): List of tuples where each tuple contains a vehicle type (string) and its speed (integer in km/h). Returns: dict[str, list[str]]: Dictionary with keys \\"slow\\", \\"medium\\", \\"fast\\" and values are lists of vehicle types. Example: >>> categorize_vehicles_by_speed([(\\"bicycle\\", 15), (\\"car\\", 80), (\\"motorbike\\", 120), (\\"train\\", 130)]) {\'slow\': [\'bicycle\'], \'medium\': [\'car\', \'motorbike\'], \'fast\': [\'train\']} >>> categorize_vehicles_by_speed([(\\"scooter\\", 50), (\\"jet\\", 900), (\\"horse\\", 30), (\\"plane\\", 890)]) {\'slow\': [\'scooter\', \'horse\'], \'medium\': [], \'fast\': [\'jet\', \'plane\']} pass ``` **Constraints and Notes**: - The input list will not be empty. - Each vehicle type in the input list will be unique. - The speed of a vehicle is always a non-negative integer. **Expected Input and Output**: ```python assert categorize_vehicles_by_speed([(\\"bicycle\\", 15), (\\"car\\", 80), (\\"motorbike\\", 120), (\\"train\\", 130)]) == {\'slow\': [\'bicycle\'], \'medium\': [\'car\', \'motorbike\'], \'fast\': [\'train\']} assert categorize_vehicles_by_speed([(\\"scooter\\", 50), (\\"jet\\", 900), (\\"horse\\", 30), (\\"plane\\", 890)]) == {\'slow\': [\'scooter\', \'horse\'], \'medium\': [], \'fast\': [\'jet\', \'plane\']} assert categorize_vehicles_by_speed([(\\"skateboard\\", 10), (\\"bus\\", 65), (\\"sports car\\", 200)]) == {\'slow\': [\'skateboard\'], \'medium\': [\'bus\'], \'fast\': [\'sports car\']} ```","solution":"def categorize_vehicles_by_speed(vehicle_data): Categorize vehicles based on their speed. Args: vehicle_data (list of tuple): List of tuples where each tuple contains a vehicle type (string) and its speed (integer in km/h). Returns: dict: Dictionary with keys \\"slow\\", \\"medium\\", \\"fast\\" and values are lists of vehicle types. categories = {\\"slow\\": [], \\"medium\\": [], \\"fast\\": []} for vehicle, speed in vehicle_data: if speed < 60: categories[\\"slow\\"].append(vehicle) elif speed < 120: categories[\\"medium\\"].append(vehicle) else: categories[\\"fast\\"].append(vehicle) return categories"},{"question":"# Question: Filter and Sort Dictionary Based on Custom Criteria You are tasked with writing a function that filters and sorts a dictionary based on specified criteria. Scenario Imagine you have a dictionary called `data_dict` where keys are strings representing item names and values are integers representing the item quantity. You are required to implement a function `filter_and_sort_dict(data_dict: dict, min_quantity: int) -> list` that filters out items with quantities less than `min_quantity` and returns a sorted list of item names in descending order of their quantities. Specification * **Function Name:** `filter_and_sort_dict` * **Input:** * `data_dict` - a dictionary with item names (strings) as keys and their quantities (integers) as values. * `min_quantity` - an integer specifying the minimum quantity to filter items. * **Output:** * A list of item names (strings) sorted in descending order of their quantities. Constraints: * All dictionaries will have unique keys. * All quantities in the dictionary will be positive integers. * The dictionary will contain at least one element. * If no items meet the filtering criteria, return an empty list. Example Usage: ```python # Example 1: data_dict = {\'apple\': 50, \'banana\': 20, \'cherry\': 30, \'date\': 10} min_quantity = 15 print(filter_and_sort_dict(data_dict, min_quantity)) # Should output [\'apple\', \'cherry\', \'banana\'] # Example 2: data_dict = {\'item1\': 5, \'item2\': 10, \'item3\': 3, \'item4\': 12} min_quantity = 6 print(filter_and_sort_dict(data_dict, min_quantity)) # Should output [\'item4\', \'item2\'] # Example 3: data_dict = {\'pen\': 5, \'pencil\': 3, \'eraser\': 2} min_quantity = 6 print(filter_and_sort_dict(data_dict, min_quantity)) # Should output [] ``` Performance Requirements: * Your implementation should be efficient, ideally running in O(n log n) time due to sorting, where n is the number of items in the dictionary. You should account for potential edge cases and ensure your function is robust against improper uses.","solution":"def filter_and_sort_dict(data_dict, min_quantity): Filters and sorts a dictionary based on the specified minimum quantity, returning a sorted list of item names in descending order of their quantities. Args: - data_dict (dict): The dictionary with item names as keys and quantities as values. - min_quantity (int): The minimum quantity to filter items. Returns: - list: A list of item names sorted in descending order of their quantities. # Filter items that meet the minimum quantity requirement filtered_items = {key: value for key, value in data_dict.items() if value >= min_quantity} # Sort the filtered items based on quantity in descending order sorted_items = sorted(filtered_items.items(), key=lambda item: item[1], reverse=True) # Extract and return only the item names return [item[0] for item in sorted_items]"},{"question":"# Problem Statement: Sum of Subset Sums Given a positive integer ( n ), write a function that returns the sum of all subset sums of the set {1, 2, ..., n}. The sum of subset sums is defined as the sum of all the sums of the subsets of the set. Function Signature ```python def sum_of_subset_sums(n: int) -> int: ``` Input * A single integer ( n ) where ( 1 leq n leq 1000 ). Output * An integer representing the sum of all subset sums of the set {1, 2, ..., n}. Examples ```python print(sum_of_subset_sums(3)) # Output: 24 print(sum_of_subset_sums(4)) # Output: 80 ``` Constraints * The function should raise a `ValueError` if the input is not a positive integer. * Optimize the time complexity to match the input size constraint effectively. # Explanation 1. For ( n = 3 ), the subsets of {1, 2, 3} are [{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}]. The sums of these subsets are 0, 1, 2, 3, 3, 4, 5, 6 respectively. Thus, the sum of subset sums is 0 + 1 + 2 + 3 + 3 + 4 + 5 + 6 = 24. 2. For ( n = 4 ), the subsets of {1, 2, 3, 4} are [{}, {1}, {2}, {3}, {4}, {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}, {1, 2, 3}, {1, 2, 4}, {1, 3, 4}, {2, 3, 4}, {1, 2, 3, 4}]. The sums of these subsets add up to 80. Implement the function so that it effectively computes the sum of all subset sums for the given ( n ) and passes additional hidden test cases.","solution":"def sum_of_subset_sums(n: int) -> int: Function to calculate the sum of all subset sums of the set {1, 2, ..., n}. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer.\\") # Each element i (1 <= i <= n) appears in half of the subsets of {1, 2, ..., n} # As there are 2^(n-1) such subsets for each i subset_count = 2 ** (n - 1) # Sum of the subset sums is given by the sum of each element i multiplied by its occurrences total_sum = sum(i * subset_count for i in range(1, n + 1)) return total_sum"},{"question":"# Connected Components in an Undirected Graph An undirected graph is represented using an adjacency list, where each vertex has a list of its neighbors. Your task is to extend the functionality of the Graph class to include methods for finding all connected components and determining whether the graph is connected. Function Specifications 1. **find_connected_components(self) -> list[list[int]]**: - Finds all connected components in the graph. - Returns a list of connected components, where each component is represented as a list of vertex indices. 2. **is_connected(self) -> bool**: - Determines if the graph is connected. - Returns a boolean value: `True` if the graph is connected, `False` otherwise. Input and Output - Both functions are member functions of the `Graph` class. - The `add_edge(start: int, end: int)` function is used to build the graph before these methods are called. - The `Graph` class has the following attributes: - `num_vertices`: An integer representing the number of vertices in the graph. - `adj_list`: A list of lists where each sub-list represents the neighbors of a vertex. Example ```python class Graph: def __init__(self, num_vertices: int): self.num_vertices = num_vertices self.adj_list = [[] for _ in range(num_vertices)] def add_edge(self, start: int, end: int): self.adj_list[start].append(end) self.adj_list[end].append(start) def find_connected_components(self) -> list[list[int]]: # Implementation here. pass def is_connected(self) -> bool: # Implementation here. pass # Example Usage graph = Graph(6) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(3, 4) assert graph.find_connected_components() == [[0, 1, 2], [3, 4], [5]] assert graph.is_connected() == False graph.add_edge(2, 3) assert graph.find_connected_components() == [[0, 1, 2, 3, 4], [5]] assert graph.is_connected() == False graph.add_edge(0, 5) assert graph.is_connected() == True ``` Constraints - The number of vertices `num_vertices` will not exceed 10^3. - The number of edges will not exceed 10^4. - Each vertex index ranges between `0` and `num_vertices - 1`. **Note**: Do not change the existing methods\' signatures in the `Graph` class. Only add new methods or helper functions as required.","solution":"class Graph: def __init__(self, num_vertices: int): self.num_vertices = num_vertices self.adj_list = [[] for _ in range(num_vertices)] def add_edge(self, start: int, end: int): self.adj_list[start].append(end) self.adj_list[end].append(start) def find_connected_components(self) -> list[list[int]]: visited = [False] * self.num_vertices components = [] def dfs(v: int, component: list[int]): visited[v] = True component.append(v) for neighbor in self.adj_list[v]: if not visited[neighbor]: dfs(neighbor, component) for v in range(self.num_vertices): if not visited[v]: component = [] dfs(v, component) components.append(component) return components def is_connected(self) -> bool: if self.num_vertices == 0: return True visited = [False] * self.num_vertices def dfs(v: int): stack = [v] while stack: node = stack.pop() for neighbor in self.adj_list[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) # Start from the first vertex and mark all reachable vertices visited[0] = True dfs(0) # If all vertices are visited, the graph is connected return all(visited[:self.num_vertices])"},{"question":"# Problem Statement You are given an `n` by `m` matrix filled with integers representing elevations on a terrain map. Your task is to write a function `lowest_valley` that finds the minimum elevation within a \\"valley\\", where a \\"valley\\" is defined as a region of connected cells where each cell\'s elevation is lower than any cell adjacent to its border that is not part of the valley. Connections are determined by the four main directions: up, down, left, right. # Function Signature ```python def lowest_valley(elevation_map: List[List[int]]) -> int: ``` # Input - `elevation_map`: A list of lists (2D array) of integers representing elevations. The dimensions of the matrix can be any values where 1 ≤ n, m ≤ 100. # Output - An integer representing the minimum elevation within the lowest valley. # Constraints - The elevation of each cell is between -1000 and 1000 (inclusive). - The matrix is non-empty (i.e., n and m are at least 1). # Example ```python elevation_map = [ [1, 2, 1, 3], [3, 4, 5, 2], [2, 2, 3, 1], [3, 1, 2, 1] ] print(lowest_valley(elevation_map)) # Output should be 1 ``` # Notes - The solution should handle cells near the boundaries of the matrix correctly. - Ensure that connected valleys are identified and the minimum elevation is computed accurately. - A valley is not necessarily confined by rows and columns but by elevation comparisons. # Additional Context This problem tests your ability to understand and implement graph traversal algorithms, such as Depth First Search (DFS) or Breadth First Search (BFS). You will need to consider edge cases such as valleys extending to the matrix boundaries and handling larger matrices efficiently.","solution":"from typing import List def lowest_valley(elevation_map: List[List[int]]) -> int: def dfs(x, y, visited, boundary_values): stack = [(x, y)] min_elevation = elevation_map[x][y] while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m: if elevation_map[nx][ny] < elevation_map[cx][cy]: boundary_values.append(elevation_map[nx][ny]) elif not visited[nx][ny] and (nx, ny) not in boundary_values: visited[nx][ny] = True stack.append((nx, ny)) min_elevation = min(min_elevation, elevation_map[nx][ny]) return min_elevation n, m = len(elevation_map), len(elevation_map[0]) visited = [[False] * m for _ in range(n)] min_valley_elevation = float(\'inf\') for i in range(n): for j in range(m): if not visited[i][j]: boundary_values = [] visited[i][j] = True valley_elevation = dfs(i, j, visited, boundary_values) if all(val >= elevation_map[i][j] for val in boundary_values): min_valley_elevation = min(min_valley_elevation, valley_elevation) return min_valley_elevation"},{"question":"# Question: Array Rotation by K Positions You are given an array of integers, and your task is to rotate the array by `k` positions to the right. That is, the element at the last position will move to the first position, the second last element will move to the second position, and so on. **Function Signature:** ```python def rotate_array(arr: [int], k: int) -> [int]: pass ``` # Input * `arr` ([int]): An array of integers. * `k` (int): The number of positions to rotate the array. # Output * A new array that represents the original array after being rotated `k` positions to the right. # Constraints * The integer values in the array can range between `-10^9` and `10^9`. * The length of the array `n` is between 1 and `10^5`. * `0 <= k <= 10^5` # Requirements 1. Implement an efficient array rotation algorithm. 2. Handle edge cases where: * The array is empty. * `k` is zero, in which case the array should remain unchanged. * `k` is greater than or equal to the length of the array. # Example ```python arr = [1, 2, 3, 4, 5] k = 2 print(rotate_array(arr, k)) # [4, 5, 1, 2, 3] arr = [1, 2, 3, 4, 5] k = 5 print(rotate_array(arr, k)) # [1, 2, 3, 4, 5] arr = [1, 2, 3] k = 4 print(rotate_array(arr, k)) # [3, 1, 2] ``` # Notes * Consider edge cases where `k` might be a multiple of the length of the array. * Aim for an efficient solution with minimal additional space usage.","solution":"def rotate_array(arr, k): Rotates the array arr by k positions to the right. n = len(arr) if n == 0 or k % n == 0: return arr k = k % n # in case k is larger than the length of the array return arr[-k:] + arr[:-k]"},{"question":"# Coding Question Problem Statement You are given a string `s` consisting of lowercase alphabets and a string `p` also consisting of lowercase alphabets. Write a function to find the smallest substring in `s` that contains all the characters of `p`. Your task is to implement the function: ```python def smallest_substring_with_pattern(s: str, p: str) -> str: ... ``` # Input - A string `s` with 0 ≤ len(s) ≤ 10^5. - A string `p` with 0 ≤ len(p) ≤ 10^5. # Output - A string representing the smallest substring in `s` that contains all characters in `p`. If no such substring exists, return an empty string. # Constraints - Characters in the strings are limited to lowercase English letters. # Example ```python >>> smallest_substring_with_pattern(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> smallest_substring_with_pattern(\\"a\\", \\"aa\\") \\"\\" >>> smallest_substring_with_pattern(\\"ab\\", \\"b\\") \\"b\\" >>> smallest_substring_with_pattern(\\"abc\\", \\"ac\\") \\"abc\\" >>> smallest_substring_with_pattern(\\"a\\", \\"a\\") \\"a\\" ``` # Additional Context To optimize the solution for large inputs, consider using a sliding window approach to minimize the time complexity. Using a dictionary to keep track of character counts can be useful to efficiently check if the current window meets the required conditions.","solution":"from collections import defaultdict, Counter def smallest_substring_with_pattern(s: str, p: str) -> str: if not s or not p or len(p) > len(s): return \\"\\" p_count = Counter(p) required = len(p_count) window_counts = defaultdict(int) left, right = 0, 0 formed = 0 min_len = float(\\"inf\\") min_window = \\"\\" while right < len(s): char = s[right] window_counts[char] += 1 if char in p_count and window_counts[char] == p_count[char]: formed += 1 while left <= right and formed == required: char = s[left] if right - left + 1 < min_len: min_len = right - left + 1 min_window = s[left:right+1] window_counts[char] -= 1 if char in p_count and window_counts[char] < p_count[char]: formed -= 1 left += 1 right += 1 return min_window"},{"question":"# Longest Increasing Subsequence: Dynamic Programming Approach **Scenario**: Given a sequence of integers, determine the length of the longest increasing subsequence (LIS). **Function Specifications**: Function 1: `naive_lis_recursive(sequence: list) -> int` 1. **Input**: * `sequence` (list): A list of integers representing the sequence. 2. **Output**: * Returns the length of the longest increasing subsequence. Function 2: `top_down_lis(sequence: list) -> int` 1. **Input**: * Same as Function 1. 2. **Output**: * Same as Function 1. Function 3: `bottom_up_lis(sequence: list) -> int` 1. **Input**: * Same as Function 1. 2. **Output**: * Same as Function 1. **Tasks**: 1. Implement the three functions as specified. Verify the correctness of each through test cases. 2. Analyze the time and space complexity of each function. 3. Compare the performance of the naive and dynamic programming approaches. **Constraints**: * For each function, ensure the sequence is a list of integers where 1 ≤ len(sequence) ≤ 2500. **Performance Requirements**: * Verify that the dynamic programming solutions perform significantly better than the naive approach as the length of the sequence increases. ```python def naive_lis_recursive(sequence): def _lis_ending_at(sequence, n): if n == 1: return 1 max_ending_here = 1 for i in range(1, n): res = _lis_ending_at(sequence, i) if sequence[i-1] < sequence[n-1]: max_ending_here = max(max_ending_here, res + 1) return max_ending_here return max(_lis_ending_at(sequence, i) for i in range(1, len(sequence)+1)) def top_down_lis(sequence): memo = {} def _lis_ending_at(sequence, n): if n in memo: return memo[n] if n == 1: memo[n] = 1 return 1 max_ending_here = 1 for i in range(1, n): res = _lis_ending_at(sequence, i) if sequence[i-1] < sequence[n-1]: max_ending_here = max(max_ending_here, res + 1) memo[n] = max_ending_here return max_ending_here return max(_lis_ending_at(sequence, i) for i in range(1, len(sequence)+1)) def bottom_up_lis(sequence): n = len(sequence) lis = [1] * n for i in range(1, n): for j in range(0, i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) def main(): sequence = [3, 10, 2, 1, 20] # Test the functions with varying sequences assert naive_lis_recursive([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 assert top_down_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 assert bottom_up_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 assert naive_lis_recursive(sequence) == 3 assert top_down_lis(sequence) == 3 assert bottom_up_lis(sequence) == 3 print(\\"All test cases passed!\\") if __name__ == \\"__main__\\": main() ``` This question aligns with the provided one in terms of style, complexity, scope, and topic focus on dynamic programming techniques.","solution":"def naive_lis_recursive(sequence): def _lis_ending_at(sequence, n): if n == 1: return 1 max_ending_here = 1 for i in range(1, n): res = _lis_ending_at(sequence, i) if sequence[i-1] < sequence[n-1]: max_ending_here = max(max_ending_here, res + 1) return max_ending_here return max(_lis_ending_at(sequence, i) for i in range(1, len(sequence)+1)) def top_down_lis(sequence): memo = {} def _lis_ending_at(sequence, n): if n in memo: return memo[n] if n == 1: memo[n] = 1 return 1 max_ending_here = 1 for i in range(1, n): res = _lis_ending_at(sequence, i) if sequence[i-1] < sequence[n-1]: max_ending_here = max(max_ending_here, res + 1) memo[n] = max_ending_here return max_ending_here return max(_lis_ending_at(sequence, i) for i in range(1, len(sequence)+1)) def bottom_up_lis(sequence): n = len(sequence) lis = [1] * n for i in range(1, n): for j in range(0, i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"# Problem Statement You are given a string `s` representing a mathematical expression with the following characteristics: - It contains only digits (`0-9`), operators (`+`, `-`, `*`, `/`), and parentheses (`(`, `)`). - The operators and parentheses follow the standard precedence rules. - The string is guaranteed to be a valid expression. Your task is to evaluate the mathematical expression and return the integer result. Implement the function: 1. `evaluate_expression(s: str) -> int` * **Input**: A string `s` representing the mathematical expression. * **Output**: An integer representing the evaluated result of the expression. # Constraints: * The length of the string `s` is in the range `[1, 10^4]`. * `s` contains only valid characters as described. # Examples 1. `evaluate_expression(\\"3+2*2\\")` should return `7`. 2. `evaluate_expression(\\"3/2\\")` should return `1`. 3. `evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\")` should return `23`. # Directions: * Implement the function as described. * Properly handle operator precedence and parentheses. * Consider edge cases such as the absence of operators or nested parentheses. # Additional Notes: * You may assume that intermediate results will fit within the range of a 32-bit integer.","solution":"def evaluate_expression(s: str) -> int: Evaluates a given mathematical expression string and returns the result as an integer. Args: s (str): A string containing a valid mathematical expression. Returns: int: The evaluated result of the expression. def operate(operators, operands): right = operands.pop() left = operands.pop() op = operators.pop() if op == \'+\': operands.append(left + right) elif op == \'-\': operands.append(left - right) elif op == \'*\': operands.append(left * right) elif op == \'/\': operands.append(int(left / right)) # Python division truncate toward negative infinity def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operators = [] operands = [] i = 0 while i < len(s): if s[i] == \' \': i += 1 continue if s[i] == \'(\': operators.append(s[i]) elif s[i].isdigit(): val = 0 while i < len(s) and s[i].isdigit(): val = (val * 10) + int(s[i]) i += 1 operands.append(val) i -= 1 elif s[i] == \')\': while operators[-1] != \'(\': operate(operators, operands) operators.pop() # remove \'(\' else: while (operators and precedence(operators[-1]) >= precedence(s[i])): operate(operators, operands) operators.append(s[i]) i += 1 while operators: operate(operators, operands) return operands[0]"},{"question":"# Problem Statement You are given a string `s` consisting of characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', representing an expression. Your task is to write a function `is_valid_expression` that checks whether the given expression is valid. An expression is considered valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. # Function Signature ```python def is_valid_expression(s: str) -> bool: ``` # Input - `s`: A string representing the expression (1 ≤ len(s) ≤ 10^4). # Output - A boolean value indicating whether the given expression is valid (`True` if valid, `False` otherwise). # Constraints - The length of the string `s` will be between 1 and 10^4. - The string `s` contains only characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. # Examples ```python print(is_valid_expression(\\"()\\")) # Output: True print(is_valid_expression(\\"()[]{}\\")) # Output: True print(is_valid_expression(\\"(]\\")) # Output: False print(is_valid_expression(\\"([)]\\")) # Output: False print(is_valid_expression(\\"{[]}\\")) # Output: True ``` # Notes Consider using a stack to keep track of the opening and closing brackets. This problem tests your understanding of stack data structures, string manipulation, and basic problem-solving skills related to expressions and validity checks. # Additional Context To solve this problem efficiently, you need to use a stack to manage the order of opening and closing brackets. Pay special attention to edge cases such as unmatched brackets or incorrect ordering, and ensure that your solution runs within the given constraints.","solution":"def is_valid_expression(s: str) -> bool: Checks if the given expression is valid by ensuring that open brackets are properly closed in the correct order by the same type of brackets. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Coding Task: Efficient Fibonacci Series Calculation and Analysis **Objective**: Implement a module that performs efficient Fibonacci series calculations, including generating the nth Fibonacci number, checking if a number belongs to the Fibonacci series, and generating a list of the first `m` Fibonacci numbers using dynamic programming. Functions to Implement: 1. **`fibonacci(n: int) -> int`**: - **Input**: - `n` (Integer): The position (1-based) in the Fibonacci sequence. - **Output**: - Returns the nth Fibonacci number (Integer). - **Constraints**: - `n` must be a positive integer greater than 0. - **Exception Handling**: - Raise `ValueError` if `n <= 0`. - Raise `TypeError` if `n` is not an integer. 2. **`is_fibonacci(number: int) -> bool`**: - **Input**: - `number` (Integer): The number to check if it is a Fibonacci number. - **Output**: - Returns `True` if the given number is a Fibonacci number, otherwise `False`. - **Constraints**: - `number` must be a non-negative integer. - **Exception Handling**: - Raise `ValueError` if `number < 0`. - Raise `TypeError` if `number` is not an integer. 3. **`list_fibonacci(m: int) -> list`**: - **Input**: - `m` (Integer): The number of Fibonacci numbers to list starting from the first Fibonacci number. - **Output**: - Returns a list of the first `m` Fibonacci numbers. - **Constraints**: - `m` must be a positive integer greater than 0. - **Exception Handling**: - Raise `ValueError` if `m <= 0`. - Raise `TypeError` if `m` is not an integer. **Example Usages**: ```python assert fibonacci(6) == 8 assert is_fibonacci(8) == True assert is_fibonacci(7) == False assert list_fibonacci(6) == [0, 1, 1, 2, 3, 5] ``` **Notes**: - Ensure that your code handles large input efficiently through dynamic programming. - Provide appropriate documentation and doctests for each function. - Optimize the implementation to achieve O(n) time complexity for series generation.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. :param n: int - The position (1-based) in the Fibonacci sequence. :return: int - The nth Fibonacci number. :raises ValueError: If n <= 0. :raises TypeError: If n is not an integer. if not isinstance(n, int): raise TypeError(\\"Value of n must be an integer.\\") if n <= 0: raise ValueError(\\"Value of n must be a positive integer greater than 0.\\") if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 for _ in range(3, n+1): a, b = b, a + b return b def is_fibonacci(number: int) -> bool: Check if the given number is a Fibonacci number. :param number: int - The number to check. :return: bool - True if the number is a Fibonacci number, else False. :raises ValueError: If number < 0. :raises TypeError: If number is not an integer. if not isinstance(number, int): raise TypeError(\\"Value of number must be an integer.\\") if number < 0: raise ValueError(\\"Value of number must be a non-negative integer.\\") if number == 0: return True a, b = 0, 1 while b < number: a, b = b, a + b return b == number def list_fibonacci(m: int) -> list: Returns a list of the first m Fibonacci numbers. :param m: int - The number of Fibonacci numbers to list starting from the first Fibonacci number. :return: list - List of the first m Fibonacci numbers. :raises ValueError: If m <= 0. :raises TypeError: If m is not an integer. if not isinstance(m, int): raise TypeError(\\"Value of m must be an integer.\\") if m <= 0: raise ValueError(\\"Value of m must be a positive integer greater than 0.\\") if m == 1: return [0] fibs = [0, 1] for _ in range(2, m): fibs.append(fibs[-1] + fibs[-2]) return fibs"},{"question":"# Problem Statement: You are given a 2D grid of characters, where each cell contains a lowercase letter. Your task is to implement a function that finds the longest sequence of letters in the grid that form a valid word from a given list of words. The sequence of letters can be constructed by moving horizontally, vertically, or diagonally in any direction, but you cannot revisit a cell. The output should be the longest word found and its length. # Requirements: 1. Implement a method `find_longest_word` that takes the following parameters: - `grid`: A list of lists representing the 2D grid of characters. - `words`: A set of valid words. 2. The method should find the longest word from the list that can be constructed in the grid. 3. Validate the grid and set of words and raise appropriate exceptions for invalid inputs (e.g., empty grid, invalid characters). # Constraints: - **Grid size**: The grid will have at most dimensions (20 times 20). - **Word length**: The total length of all words combined will not exceed 10000 characters. - **Valid words**: The set of words will contain only lowercase alphabetic characters. # Function Signature: ```python def find_longest_word(grid: list[list[str]], words: set[str]) -> Tuple[str, int]: pass ``` # Example: ```python grid = [ [\'c\', \'a\', \'t\'], [\'h\', \'a\', \'t\'], [\'r\', \'a\', \'t\'] ] words = {\\"cat\\", \\"hat\\", \\"rat\\", \\"that\\", \\"chat\\", \\"charm\\"} result = find_longest_word(grid, words) print(result) # (\'chat\', 4) ``` # Note: - Handle edge cases such as multiple longest words by lexicographical order. - Implement an efficient algorithm to navigate through all possible valid word formations in the grid.","solution":"def find_longest_word(grid, words): if not grid or not words: raise ValueError(\\"Grid and words cannot be empty.\\") if any(not row for row in grid): raise ValueError(\\"Grid rows cannot be empty.\\") if any(len(row) != len(grid[0]) for row in grid): raise ValueError(\\"Grid rows must have the same length.\\") rows, cols = len(grid), len(grid[0]) longest_word = \\"\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] def dfs(x, y, path, visited): nonlocal longest_word path += grid[x][y] visited.add((x, y)) if path in words and (len(path) > len(longest_word) or (len(path) == len(longest_word) and path < longest_word)): longest_word = path for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: dfs(nx, ny, path, visited) visited.remove((x, y)) for r in range(rows): for c in range(cols): dfs(r, c, \\"\\", set()) return (longest_word, len(longest_word))"},{"question":"# Sort the K Elements in a List Given an unsorted list of integers and an integer `k`, write a function `sort_k_elements(nums: List[int], k: int) -> List[int]` that returns the list with the first `k` elements sorted in ascending order. The rest of the elements should remain in their original positions. # Function Signature ```python def sort_k_elements(nums: List[int], k: int) -> List[int]: pass ``` # Input - `nums`: A list of integers. - `k`: An integer indicating the number of elements to sort from the start of the list. # Output - A list with the first `k` elements sorted and the remaining elements unmodified. # Constraints - The length of the list `nums` will be between 1 and 10^4. - `0 <= k <= len(nums)`. - Each integer in the list `nums` will be between -10^6 and 10^6. # Example ```python nums = [3, 1, 4, 1, 5, 9, 2, 6, 5] k = 5 print(sort_k_elements(nums, k)) # Output: [1, 1, 3, 4, 5, 9, 2, 6, 5] ``` # Explanation - The first 5 elements `[3, 1, 4, 1, 5]` are sorted to `[1, 1, 3, 4, 5]`. - The rest of the elements `[9, 2, 6, 5]` remain unchanged. # Implementation Details - Utilize Python\'s built-in sorting function to sort the first `k` elements. - Construct the final output list by combining the sorted part and the unsorted remainder. - Handle edge cases where `k` is 0 or equals the length of the list.","solution":"from typing import List def sort_k_elements(nums: List[int], k: int) -> List[int]: Sorts the first k elements of the given list in ascending order and returns the modified list. Parameters: nums (List[int]): List of integers to be processed. k (int): Number of elements from the start to be sorted. Returns: List[int]: List with the first k elements sorted. # If k is 0, just return the original list as no sorting needed if k == 0: return nums # Sort the first k elements sorted_part = sorted(nums[:k]) # Combine the sorted part with the rest of the list result = sorted_part + nums[k:] return result"},{"question":"# Coding Assessment Question **Context**: A permutation of integers is called a derangement if no element appears in its original position. Additionally, it can be noted that there are no fixed points, meaning for any index `i`, the element at the i-th position of the permutation is not equal to `i`. **Problem**: Given an integer `n`, implement the `count_derangements` function that calculates the number of derangements of `n` items. **Function Signature**: ```python def count_derangements(n: int) -> int: ``` **Input**: * n: Integer where 1 ≤ n ≤ 20. **Output**: * The function should return an integer which is the number of derangements of `n` items. **Constraints**: * The solution should utilize a Dynamic Programming approach to ensure optimal performance. * The use of in-built functions or libraries to calculate factorials directly is not allowed. **Performance Requirements**: * The algorithm should execute with a time complexity of O(n). **Examples**: 1. `count_derangements(2)` should return `1` 2. `count_derangements(3)` should return `2` 3. `count_derangements(4)` should return `9` 4. `count_derangements(5)` should return `44` **Edge Cases**: 1. Handle the smallest permissible value: `count_derangements(1)` should return `0` (since there\'s no way to arrange one item such that it does not occupy its original position). 2. Handle a typical mid-range value: `count_derangements(6)` should return `265`. **Explanation**: Derangements can be derived from a recursive relation: - D[0] = 1 (by convention) - D[1] = 0 - D[n] = (n - 1) * (D[n - 1] + D[n - 2]) Utilize this relation to build up the solution using Dynamic Programming.","solution":"def count_derangements(n: int) -> int: if n == 1: return 0 # Derangement array D where D[i] represents the number of derangements of i items D = [0] * (n + 1) # Base cases D[0] = 1 # by convention D[1] = 0 # there are no derangements for 1 item # Fill in the dynamic programming table based on the recurrence for i in range(2, n + 1): D[i] = (i - 1) * (D[i - 1] + D[i - 2]) return D[n]"},{"question":"**Problem Statement**: Write a function that finds the smallest positive integer missing from an unsorted integer array. The function should consider only the positive integers starting from 1, and it must run in O(n) time and use constant space. # Function Signature: ```python def find_missing_positive(nums: List[int]) -> int: ``` # Input: * `nums` (List[int]): A list of integers which may contain both positive and negative numbers, including duplicates. # Output: * Returns the smallest positive integer that is missing from the input list. # Constraints: * The size of the list will be between 0 and 100000 inclusive. * The elements of the list will be between -1000000 and 1000000 inclusive. # Examples: ```python assert find_missing_positive([]) == 1 assert find_missing_positive([1, 2, 0]) == 3 assert find_missing_positive([3, 4, -1, 1]) == 2 assert find_missing_positive([7, 8, 9, 11, 12]) == 1 assert find_missing_positive([1, 2, 3]) == 4 assert find_missing_positive([-1, -2, -3]) == 1 ``` # Scenario/Context: You are building a data validation tool that ensures a dataset includes all necessary identifiers. Missing identifiers can cause issues in data processing and analysis. This function can be part of a larger validation module that checks the integrity and completeness of the dataset by identifying gaps in the sequence of expected positive integers. # Additional Notes: * Do not use extra space to store missing numbers; perform the calculations in-place. * Be mindful of edge cases such as empty lists and lists that contain only negative numbers.","solution":"from typing import List def find_missing_positive(nums: List[int]) -> int: Finds the smallest positive integer missing from an unsorted integer array. The function runs in O(n) time and uses constant space. n = len(nums) # Base case: if array is empty, return 1 if n == 0: return 1 # First pass: move every positive number <= n to its correct index position for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap nums[i] with the element at its target position target_idx = nums[i] - 1 nums[i], nums[target_idx] = nums[target_idx], nums[i] # Second pass: find first index where the number is not the index + 1 for i in range(n): if nums[i] != i + 1: return i + 1 # If all numbers are in their correct positions, return n + 1 return n + 1"},{"question":"Context In data processing, one common technique is the normalization of data. Min-Max normalization, also known as feature scaling, is a technique where the values in a dataset are rescaled such that they fall within a specified range, typically [0, 1]. This can help improve the performance and convergence speed of learning algorithms. Problem You are given a vector of numeric values (integers or floats), and you need to implement the Min-Max normalization function as described: **Input**: - A vector of numeric values (integers or floats). The input is a one-dimensional numpy array. **Output**: - An array of the same size, where each element has been normalized to fall within the range [0, 1]. **Function Signature**: ```python import numpy as np def min_max_normalize(vector: np.ndarray) -> np.ndarray: # your code here ``` # Constraints: 1. The input vector can be empty. 2. The input vector may contain duplicate values. 3. The input vector can be very large, so the solution should be efficient. 4. You may use NumPy functions to aid in the computation. # Example: ```python >>> vector = np.array([1, 2, 3, 4, 5]) >>> min_max_normalize(vector) array([0. , 0.25, 0.5 , 0.75, 1. ]) >>> vector = np.array([-10, 0, 10, 20]) >>> min_max_normalize(vector) array([0., 0.33333333, 0.66666667, 1.]) ``` Implement the `min_max_normalize` function to return the expected output.","solution":"import numpy as np def min_max_normalize(vector: np.ndarray) -> np.ndarray: Normalize a vector to the range [0, 1] using Min-Max normalization. Parameters: vector (np.ndarray): Input vector of numeric values. Returns: np.ndarray: Normalized vector with values in the range [0, 1]. if vector.size == 0: return vector min_val = np.min(vector) max_val = np.max(vector) if min_val == max_val: return np.zeros_like(vector) normalized_vector = (vector - min_val) / (max_val - min_val) return normalized_vector"},{"question":"# Coding Assessment Question **Context**: Given a string of lowercase alphabets, you are required to transform it such that no two adjacent characters are identical by replacing characters with any other lowercase alphabet. Minimize the total number of replacements to achieve this goal. **Task**: Write a function `min_adjacent_replacements(s: str) -> int` that: 1. Receives a string `s` (1 ≤ len(s) ≤ 100,000) consisting of only lowercase English letters. 2. Returns an integer representing the minimum number of replacements needed to ensure no two adjacent characters are the same. **Input**: - A string `s` consisting of lowercase English letters. **Output**: - An integer indicating the minimum number of character replacements needed. **Constraints**: - The function should efficiently handle the string with the maximum length of 100,000. **Example**: ```python print(min_adjacent_replacements(\\"aab\\")) # Output: 1 print(min_adjacent_replacements(\\"aaaa\\")) # Output: 2 print(min_adjacent_replacements(\\"abac\\")) # Output: 0 ``` **Function Signature**: ```python def min_adjacent_replacements(s: str) -> int: pass ``` Ensure your solution identifies adjacent identical characters and replaces one of them with a different character to achieve the goal while minimizing the total replacements.","solution":"def min_adjacent_replacements(s: str) -> int: Returns the minimum number of replacements needed to ensure no two adjacent characters are the same. # Convert string to list for mutability s = list(s) replacements = 0 # Iterate through the string for i in range(1, len(s)): if s[i] == s[i-1]: # Need to replace s[i] with a different character replacements += 1 # Choose a character that is not the same as s[i-1] or s[i+1] (if exists) for c in \'abcdefghijklmnopqrstuvwxyz\': if c != s[i-1] and (i+1 >= len(s) or c != s[i+1]): s[i] = c break return replacements"},{"question":"# Problem Statement You are tasked with writing a function that finds the shortest distance between two words in a list of words. The distance is defined as the number of words between the two given words in the list. If the words are identical, the function should return `0` as the distance. Your function should be named `shortest_distance(words: List[str], word1: str, word2: str) -> int`. # Input - A list of strings `words` (1 ≤ len(words) ≤ 10000), containing lowercase letters only. - Two strings `word1` and `word2`, which are guaranteed to be present in the list. # Output - An integer representing the shortest distance between the two given words in the list. # Constraints - The function should handle the case where word1 and word2 are the same. - Ensure the function runs efficiently, targeting a time complexity of O(n) where n is the length of the list, and space complexity of O(1). - If word1 or word2 is not found in the list (although they must be), raise a `ValueError`. # Example ```python >>> shortest_distance([\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"makes\\"], \\"coding\\", \\"practice\\") 3 >>> shortest_distance([\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"makes\\"], \\"makes\\", \\"coding\\") 1 >>> shortest_distance([\\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"a\\"], \\"a\\", \\"b\\") 1 >>> shortest_distance([\\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"a\\"], \\"a\\", \\"a\\") 0 >>> shortest_distance([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"w\\", \\"x\\") ValueError: Words not found in the list ``` # Notes - The words in the list are all lowercase. - Your function should handle edge cases such as when word1 and word2 are adjacent or identical. - Be prepared to handle invalid inputs appropriately.","solution":"def shortest_distance(words, word1, word2): Returns the shortest distance between the two given words in the list. If the words are the same, the distance is 0. if word1 == word2: return 0 index1, index2 = -1, -1 min_distance = float(\\"inf\\") for i, word in enumerate(words): if word == word1: index1 = i if index2 != -1: min_distance = min(min_distance, abs(index1 - index2)) if word == word2: index2 = i if index1 != -1: min_distance = min(min_distance, abs(index1 - index2)) if index1 == -1 or index2 == -1: raise ValueError(\\"Words not found in the list\\") return min_distance"},{"question":"# Problem Statement Create a function to determine if a robot, starting at the origin of a 2D plane, returns to the origin after a given sequence of moves. The robot can move up, down, left, or right. Your task is to write a function that interprets a sequence of these moves and determines whether the robot returns to its starting point. # Requirements Implement a function `does_return_to_origin(moves: str) -> bool` that returns `True` if the robot returns to the origin after executing all the moves, and `False` otherwise. # Input * A string `moves` representing the sequence of robot movements (1 ≤ len(moves) ≤ 10^5). - The string will only contain characters \'U\', \'D\', \'L\', and \'R\' where: - \'U\' means moving up (positive Y direction) - \'D\' means moving down (negative Y direction) - \'L\' means moving left (negative X direction) - \'R\' means moving right (positive X direction) # Output * A boolean value: `True` if the robot returns to the origin, `False` otherwise. # Constraints * The length of the string will be between 1 and 100,000 inclusive. * The string will only contain the characters \'U\', \'D\', \'L\', and \'R\'. # Example ```python def does_return_to_origin(moves: str) -> bool: x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0 print(does_return_to_origin(\\"UDLR\\")) # Output: True print(does_return_to_origin(\\"UULLDDRR\\")) # Output: True print(does_return_to_origin(\\"UUDDL\\")) # Output: False ``` # Explanation * For the sequence \\"UDLR\\", the robot moves up, down, left, and right, and returns to the origin (0,0). * For the sequence \\"UULLDDRR\\", the robot moves up twice, left twice, down twice, and right twice, returning to the origin. * For the sequence \\"UUDDL\\", the robot moves up twice, down twice, and left once, ending at position (-1,1), not the origin. # Note * Ensure efficiency in handling large input sizes. * Consider edge cases such as sequences where the robot never moves out of the origin (\\"\\") or where moves cancel each other directly.","solution":"def does_return_to_origin(moves: str) -> bool: Determine if a robot returns to the origin after a sequence of moves. Parameters: moves (str): A sequence of characters representing the moves of the robot (\'U\', \'D\', \'L\', \'R\'). Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Coding Assessment Question Context: You are developing a tool to help logistics companies manage their delivery schedules. One important feature is to ensure that delivery drivers are assigned non-overlapping time slots. This helps in reducing delays and preventing scheduling conflicts. Task: Write a function `merge_time_slots` that takes a list of time intervals `time_slots`, where each interval is represented as a list of two integers `[start, end]`. The function should merge all overlapping intervals and return a list of the merged intervals, sorted by start time. Function Signature: ```python def merge_time_slots(time_slots: list[list[int]]) -> list[list[int]]: ``` Input: * `time_slots`: A list of lists, where each inner list contains two integers representing the start and end times of a delivery slot. Output: * A list of lists containing the merged delivery time slots. Constraints: * The start time will always be less than the end time. * The intervals are not sorted in any particular order. * All time values are non-negative integers. Examples: ```python merge_time_slots([[1, 3], [2, 6], [8, 10], [15, 18]]) => [[1, 6], [8, 10], [15, 18]] merge_time_slots([[1, 4], [4, 5]]) => [[1, 5]] merge_time_slots([[5, 10], [3, 7], [15, 20], [18, 22]]) => [[3, 10], [15, 22]] merge_time_slots([[1, 2], [2, 3], [3, 4]]) => [[1, 4]] merge_time_slots([[1, 3], [5, 7], [2, 6]]) => [[1, 7]] merge_time_slots([[1, 4], [2, 3]]) => [[1, 4]] ``` Scenario: As a logistics manager, you want to minimize the driving time and conflicts for your delivery drivers. Utilize your function to merge overlapping delivery slots effectively and allow for efficient scheduling.","solution":"def merge_time_slots(time_slots: list[list[int]]) -> list[list[int]]: if not time_slots: return [] # Sort the time slots based on the start time time_slots.sort(key=lambda x: x[0]) merged = [] for slot in time_slots: if not merged or merged[-1][1] < slot[0]: merged.append(slot) else: merged[-1][1] = max(merged[-1][1], slot[1]) return merged"},{"question":"**Problem Statement**: You are required to implement a function that finds the k-th smallest number in the Cartesian product of two given lists of integers. The Cartesian product of two lists `A` and `B` is the list of all possible pairs `(a, b)` where `a` is an element of `A` and `b` is an element of `B`. The k-th smallest number is defined as the k-th smallest value in the union of all sums `a + b` for each `(a, b)` pair. The signature of the function is as follows: ```python def kth_smallest_cartesian_sum(A: list, B: list, k: int) -> int: pass ``` # Input: * A list of integers `A` where 1 <= len(A) <= 1000. * A list of integers `B` where 1 <= len(B) <= 1000. * An integer `k`, 1 <= k <= len(A) * len(B), the position of the smallest number to find. # Output: * An integer representing the k-th smallest sum from the Cartesian product of the two lists. # Constraints: * The input lists `A` and `B` will always contain at least one element. * Both lists can contain negative and positive integers. * The input integer `k` will always be a valid position within the range of all possible sums. # Example: ```python >>> kth_smallest_cartesian_sum([1, 7, 11], [2, 4, 6], 3) 7 >>> kth_smallest_cartesian_sum([1, 7, 11], [2, 4, 6], 9) 17 >>> kth_smallest_cartesian_sum([1, 2], [3, 4], 4) 6 ``` **Your task is to implement the function `kth_smallest_cartesian_sum` that adheres to the above specifications.** # Performance Requirements: Your implementation should be efficient enough to handle the Cartesian product with input lists of sizes up to 1000.","solution":"import heapq def kth_smallest_cartesian_sum(A: list, B: list, k: int) -> int: Finds the k-th smallest sum from the Cartesian product of lists A and B. Args: A (list): A list of integers. B (list): A list of integers. k (int): The position of the smallest number to find. Returns: int: The k-th smallest sum. # Min-heap to store tuples (sum, i, j) and corresponding positions min_heap = [] # Initialize the min-heap with the smallest elements (using the smallest element of A) for j in range(len(B)): heapq.heappush(min_heap, (A[0] + B[j], 0, j)) # Extract the k-th smallest sum from the min-heap count = 0 while min_heap: current_sum, i, j = heapq.heappop(min_heap) count += 1 if count == k: return current_sum # If there are remaining elements in A to be paired with B[j] if i + 1 < len(A): heapq.heappush(min_heap, (A[i + 1] + B[j], i + 1, j))"},{"question":"# Sum of Unique Elements in List You need to implement a function that takes a list of integers and returns the sum of all unique elements. If an integer appears more than once, it should not be included in the sum. Function Signature ```python def sum_of_unique_elements(nums: list) -> int: Returns the sum of the unique elements in the given list. Args: nums (list): A list of integers. Returns: int: The sum of unique integers in the list. ``` Example ```python >>> sum_of_unique_elements([1, 2, 3, 2, 1, 4]) 7 # 3 + 4 >>> sum_of_unique_elements([10, 10, 20, 30]) 50 # 20 + 30 >>> sum_of_unique_elements([7, 8, 7, 8, 7, 8]) 0 # No unique elements ``` # Requirements 1. **Unique Elements**: - The function should only sum elements that occur exactly once in the input list. 2. **Constraints**: - The input list will only contain integers (positive, negative, or zero). - The function should handle both empty lists and lists where no unique elements are present, returning 0 in both cases. # Objective This question tests the student\'s understanding of: - Iteration and conditional checks. - Use of Python\'s collection types to filter unique elements. - Summation and returning the correct result. - Efficiently managing duplicates within lists.","solution":"def sum_of_unique_elements(nums): Returns the sum of the unique elements in the given list. Args: nums (list): A list of integers. Returns: int: The sum of unique integers in the list. from collections import Counter # Count the occurrence of each number in the list num_counts = Counter(nums) # Sum the elements that occur exactly once unique_sum = sum(num for num, count in num_counts.items() if count == 1) return unique_sum"},{"question":"# Question: Frequent Character Finder Write a function that finds the most frequently occurring character in a given string. If there are multiple characters with the same highest frequency, return the one that appears first in the string. # Requirements: 1. Write a function `most_frequent_char(s: str) -> str` that takes a single string input and returns the most frequent character. 2. The function should be case-sensitive, meaning \'A\' and \'a\' are considered different characters. 3. If the input string is empty, return an empty string. # Constraints: * The input string length will be between 0 and 200,000 characters. # Expected Input and Output: **Input**: A string `s` **Output**: The single character that appears most frequently in the string ```python def most_frequent_char(s: str) -> str: >>> most_frequent_char(\\"aabbbcccc\\") \'c\' >>> most_frequent_char(\\"a1!?1!?\\") \'1\' >>> most_frequent_char(\\"\\") \'\' >>> most_frequent_char(\\"Hello, World!\\") \'l\' pass ``` # Performance Requirement: * Ensure that the solution runs efficiently within the provided constraints. # Explanation: - You need to demonstrate a clear understanding of string manipulation, dictionaries or similar data structures for counting characters, and efficient ways to traverse and compare elements. - The function should be optimized for performance, considering the potential length of the input.","solution":"def most_frequent_char(s: str) -> str: Finds the most frequently occurring character in a given string. if not s: return \'\' char_count = {} max_count = 0 max_char = None for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 if char_count[char] > max_count: max_count = char_count[char] max_char = char return max_char"},{"question":"# Problem: Data Structure for Efficient Interval Queries Context You are tasked with implementing a data structure that supports efficient insertion of intervals and querying the total length of the union of these intervals. This can be useful in applications like booking systems, scheduling, and event management where overlapping intervals need to be processed. Task Write a Python class `IntervalManager` to manage and query intervals efficiently. Requirements 1. **Methods**: * `add_interval(start: int, end: int) -> None`: Adds a new interval [start, end). * `get_total_covered_length() -> int`: Returns the total length covered by the union of all intervals stored. 2. **Constraints**: * End is always greater than start. * Intervals can overlap, and overlapping intervals should be merged. * The number of add_interval operations is large, so the implementation should be optimized for performance. **Class Specification**: ```python class IntervalManager: def __init__(self): # Initialize the data structure def add_interval(self, start: int, end: int) -> None: # Add code to insert an interval and merge if necessary def get_total_covered_length(self) -> int: # Calculate and return the total length covered by the union of intervals ``` Example ```python im = IntervalManager() im.add_interval(1, 5) im.add_interval(6, 10) im.add_interval(3, 7) length = im.get_total_covered_length() print(length) # Expected output: 9 ``` Hints 1. Consider using a balanced tree structure or a list with merging strategies to manage intervals efficiently. 2. When querying the total length, consider the merged intervals instead of the individual ones. Notes * Focus on ensuring that the intervals are merged correctly when added. * Optimize both the insertion and querying operations for large numbers of intervals. * Ensure the solution handles edge cases like adding intervals that are completely overlapping or non-overlapping.","solution":"class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: new_interval = (start, end) self.intervals.append(new_interval) self._merge_intervals() def get_total_covered_length(self) -> int: merged_intervals = self._merge_intervals() total_length = 0 for interval in merged_intervals: total_length += interval[1] - interval[0] return total_length def _merge_intervals(self): if not self.intervals: return [] # Sort intervals by start time self.intervals.sort() merged_intervals = [self.intervals[0]] for current in self.intervals[1:]: last = merged_intervals[-1] if current[0] <= last[1]: # Overlapping intervals, merge them merged_intervals[-1] = (last[0], max(last[1], current[1])) else: # No overlap, add the interval to the list merged_intervals.append(current) self.intervals = merged_intervals return merged_intervals"},{"question":"# Problem Statement You are tasked with implementing a function to find the longest common subsequence (LCS) between two strings using dynamic programming. This function should return the length of the LCS and should be implemented using memoization for optimization. # Requirements 1. **Dynamic Programming Implementation with Memoization**: - Function Name: `longest_common_subsequence` - Input: Two strings, `str1` and `str2` - Output: Integer representing the length of the LCS - Constraints: * Both inputs should be strings containing only lowercase alphabets. * Return 0 if either of the strings is empty. 2. Use Python\'s `functools.lru_cache` for memoization within the function. # Example For example, the implementation should yield the following outputs: ```python assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 assert longest_common_subsequence(\\"\\", \\"abc\\") == 0 assert longest_common_subsequence(\\"abc\\", \\"\\") == 0 ``` # Function Definition **Dynamic Programming Implementation with Memoization** ```python from functools import lru_cache def longest_common_subsequence(str1: str, str2: str) -> int: @lru_cache(None) def lcs(x, y): if x == 0 or y == 0: return 0 elif str1[x-1] == str2[y-1]: return 1 + lcs(x-1, y-1) else: return max(lcs(x-1, y), lcs(x, y-1)) return lcs(len(str1), len(str2)) ``` Implement this function and ensure it passes the provided example cases.","solution":"from functools import lru_cache def longest_common_subsequence(str1: str, str2: str) -> int: @lru_cache(None) def lcs(x, y): if x == 0 or y == 0: return 0 elif str1[x-1] == str2[y-1]: return 1 + lcs(x-1, y-1) else: return max(lcs(x-1, y), lcs(x, y-1)) return lcs(len(str1), len(str2))"},{"question":"# Question Write a function `find_minimum_spanning_tree` that takes an undirected graph represented as an adjacency list and returns the total weight of its Minimum Spanning Tree (MST) using Kruskal\'s algorithm. **Function Signature**: ```python def find_minimum_spanning_tree(n: int, edges: list[tuple[int, int, int]]) -> int: ``` **Input**: - `n` (int): The number of vertices in the graph. - `edges` (list of tuples): Each tuple `(u, v, w)` represents an undirected edge between vertex `u` and vertex `v` with weight `w`. **Output**: - The total weight of the MST. **Constraints**: - 1 <= n <= 10^5 - 0 <= len(edges) <= 2 * 10^5 - Vertex indices are 0-based. # Examples ```python # Example 1 n = 4 edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] print(find_minimum_spanning_tree(n, edges)) # Output: 19 # Example 2 n = 3 edges = [(0, 1, 1), (1, 2, 2), (0, 2, 3)] print(find_minimum_spanning_tree(n, edges)) # Output: 3 # Example 3 n = 5 edges = [(0, 1, 2), (0, 2, 3), (1, 3, 4), (2, 3, 2)] print(find_minimum_spanning_tree(n, edges)) # Output: 9 ``` **Notes**: - Use Kruskal\'s algorithm which leverages sorting of edges and union-find data structure to efficiently find the MST. - Ensure to handle scenarios where the graph might be disconnected by checking the components. - The order of the edges in the output does not matter as long as the total weight of the MST is correct. - If the graph is disconnected, return the sum of the weights of the MSTs for all components.","solution":"def find_minimum_spanning_tree(n, edges): Finds the total weight of the Minimum Spanning Tree (MST) using Kruskal\'s algorithm. Parameters: - n (int): The number of vertices in the graph. - edges (list of tuples): Each tuple (u, v, w) represents an undirected edge between vertex u and vertex v with weight w. Returns: - int: The total weight of the MST. edges.sort(key=lambda x: x[2]) # Sort edges based on weight parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 minimum_cost = 0 for u, v, w in edges: if find(u) != find(v): union(u, v) minimum_cost += w return minimum_cost"},{"question":"# Problem Statement You are given a list of integers representing the heights of walls with uniform width. Your task is to identify the amount of water that can be trapped between the walls after it rains. # Requirements 1. **Input**: A list of integers `heights` representing the heights of the walls. 2. **Output**: An integer representing the total amount of water trapped between the walls. # Constraints * `1 <= len(heights) <= 100000` * `0 <= heights[i] <= 1000` # Example ```python assert trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trapped_water([4, 2, 0, 3, 2, 5]) == 9 assert trapped_water([1, 1, 1, 1]) == 0 assert trapped_water([5, 4, 1, 2]) == 1 assert trapped_water([3, 0, 0, 2, 0, 4]) == 10 ``` # Performance Considerations Your implementation should aim to efficiently handle the input size specified. Consider utilizing two-pointer technique to achieve optimal time complexity. # Implementation ```python def trapped_water(heights: list[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped # Example usage: print(trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])) # Output: 6 ```","solution":"def trapped_water(heights: list[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped # Example usage: print(trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])) # Output: 6"},{"question":"# Question: You are given an array of integers where each element represents the maximum number of steps you can jump going forward from that position. Your task is to determine the minimum number of jumps required to reach the end of the array starting from the first element. Implement a function that returns this minimum count. Function Signature: ```python def min_jumps(arr: List[int]) -> int: pass ``` Input: * `arr` (List[int]): The array of integers representing the maximum jump lengths. (1 leq text{len(arr)} leq 10^5). Output: * (int): The minimum number of jumps required to reach the end of the array. Constraints: * The input array will always have at least one element. * The last element of the array is considered the end, and you do not need to jump from it. * It is guaranteed that you can always reach the end of the array. Example: ```python assert min_jumps([2, 3, 1, 1, 4]) == 2 assert min_jumps([1, 1, 1, 1, 1]) == 4 assert min_jumps([1, 4, 3, 7, 1, 2, 6, 7, 6, 10]) == 3 ``` Scenario: You are developing a feature in a game where characters must jump across platforms to navigate different levels. The input array represents the layout of a level, where each integer is the maximum number of platforms that can be skipped from that position. To optimize gameplay, you need to determine the minimum number of jumps the character must make to reach the end of the level efficiently. Additional Context: * Ensure your implementation is optimized for large input sizes. * Consider edge cases such as when the array contains the minimum number of elements. * Note the importance of making strategic jumps to minimize the total count.","solution":"from typing import List def min_jumps(arr: List[int]) -> int: n = len(arr) if n == 1: return 0 jumps = 0 current_end = 0 farthest = 0 for i in range(n): farthest = max(farthest, i + arr[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= n - 1: break return jumps"},{"question":"# Sorting It All Together Given a list of integers, you need to perform multiple sorting operations based on the given criteria and then concatenate the results. Function Signature ```python def custom_sort(lst: list, criteria: list) -> list: ``` Input * **lst**: A list of integers. Each element in the list is an integer `x` where `1 <= x <= 10^5`. * **criteria**: A list of `n` tuples, where each tuple contains: - `start_index` (int): The starting index of the sublist to be sorted. - `end_index` (int): The ending index of the sublist to be sorted. - `ascending` (bool): If `True`, the sublist should be sorted in ascending order; if `False`, in descending order. (0-based inclusive indices) Output * A single list of integers that is the concatenation of all the sorted sublists according to the given criteria. Example ```python lst = [4, 5, 3, 2, 8, 1, 7] criteria = [(1, 3, True), (0, 4, False), (5, 6, True)] print(custom_sort(lst, criteria)) # Output: [2, 3, 5, 8, 4, 3, 2, 5, 1, 7] ``` Explanation 1. **First Tuple**: `criteria[0] = (1, 3, True)` indicates sorting the sublist from index 1 to 3 in ascending order. Result: [2, 3, 5]. 2. **Second Tuple**: `criteria[1] = (0, 4, False)` indicates sorting the sublist from index 0 to 4 in descending order. Result: [8, 5, 4, 3, 2]. 3. **Third Tuple**: `criteria[2] = (5, 6, True)` indicates sorting the sublist from index 5 to 6 in ascending order. Result: [1, 7]. Finally, concatenate these results: [2, 3, 5] + [8, 5, 4, 3, 2] + [1, 7] -> [2, 3, 5, 8, 4, 3, 2, 5, 1, 7]. Constraints * Each sublist defined by `start_index` and `end_index` will always be valid and within the bounds of `lst`. * The `start_index` and `end_index` indices will always be such that `0 <= start_index <= end_index < len(lst)`. * The criteria list will contain at least one tuple and at most 1000 tuples. Implement the function that takes the list and the criteria and returns the concatenated sorted sublists.","solution":"def custom_sort(lst: list, criteria: list) -> list: sorted_sublists = [] for start_index, end_index, ascending in criteria: sublist = lst[start_index:end_index+1] sublist.sort(reverse=not ascending) sorted_sublists.extend(sublist) return sorted_sublists"},{"question":"# Context Working with strings is essential in programming, as strings are used to represent text. Efficient manipulation and processing of strings are vital for various applications in data processing, text analysis, and general programming tasks. # Problem Statement You are required to extend the `StringProcessor` class with the following capabilities: 1. **Palindrome Check**: Implement a method `is_palindrome` to check if a provided string is a palindrome. 2. **Anagram Check**: Implement a method `is_anagram` to check if two given strings are anagrams of each other. # Function Specifications: Palindrome Check: **Input**: - `s` (string): The string to be checked. **Output**: - Returns `True` if the string is a palindrome, otherwise `False`. # Anagram Check: **Input**: - `s1` (string): The first string. - `s2` (string): The second string. **Output**: - Returns `True` if the strings are anagrams of each other, otherwise `False`. # Example: ```python sp = StringProcessor() # Should print True, as \'racecar\' is a palindrome print(sp.is_palindrome(\\"racecar\\")) # Output: True # Should print False, as \'hello\' is not a palindrome print(sp.is_palindrome(\\"hello\\")) # Output: False # Should print True, as \'listen\' and \'silent\' are anagrams print(sp.is_anagram(\\"listen\\", \\"silent\\")) # Output: True # Should print False, as \'hello\' and \'world\' are not anagrams print(sp.is_anagram(\\"hello\\", \\"world\\")) # Output: False ``` # Constraints: - The input strings for both methods consist only of lowercase English letters. - For the anagram check, the two input strings will always have the same length. # Additional Notes: - A palindrome is a string that reads the same forwards as backwards, e.g., \\"madam\\", \\"racecar\\". - Two strings are anagrams if they contain the same characters with the same frequencies, e.g., \\"listen\\" and \\"silent\\". # Implementation: You need to define a class `StringProcessor` with the specified methods to handle the string manipulations as described.","solution":"class StringProcessor: @staticmethod def is_palindrome(s): Checks if the given string is a palindrome. Args: s (str): The string to be checked. Returns: bool: True if the string is a palindrome, False otherwise. return s == s[::-1] @staticmethod def is_anagram(s1, s2): Checks if the two given strings are anagrams of each other. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. return sorted(s1) == sorted(s2)"},{"question":"# Scenario You are developing a text-processing tool that analyzes email content to extract useful information. One of the features involves identifying and extracting email addresses from the body of the text. Your task is to implement this capability efficiently. # Task 1. Implement a function `extract_emails` that takes a string containing the body of an email as input and returns a list of all unique email addresses found within the text. 2. Write unit tests to verify the accuracy of your function in different scenarios, including edge cases. # Requirements **Function Signature**: ```python def extract_emails(body: str) -> list: # Your implementation here ``` # Example ```python # Example of input body = Hello John, Please contact us at support@example.com for further assistance. Also, you might want to cc your response to manager@example.com and hr@example.com. Best regards, Jane # Example of return value extract_emails(body) # Expected output: [\'support@example.com\', \'manager@example.com\', \'hr@example.com\'] ``` # Constraints - The email addresses should follow the standard format: `local-part@domain`, where `local-part` can include letters, numbers, dots, hyphens, and underscores. - The function should be case-insensitive when detecting email addresses. - The result must be unique email addresses sorted alphabetically. # Testing - Test with bodies containing multiple email addresses. - Test with email bodies containing no email addresses. - Test with mixed case email addresses to ensure case insensitivity. - Test with varying formats of local-parts and domains. # Additional Information - Use regular expressions for efficient pattern matching to identify email addresses. - Ensure the function handles edge cases like email addresses at the start or end of the body, and invalid email-like texts.","solution":"import re def extract_emails(body: str) -> list: Extracts all unique email addresses from the given string and returns them sorted alphabetically. Parameters: - body (str): The body of text containing email addresses. Returns: - list: A list of unique, sorted email addresses. # Regex pattern for matching email addresses email_pattern = r\'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\' # Find all matches in the text emails = re.findall(email_pattern, body) # Get unique emails unique_emails = list(set(emails)) # Sort the emails alphabetically unique_emails.sort() return unique_emails"},{"question":"Coding Assessment: Optimize List Processing Function Context You have been using various methods to process lists in Python through your coursework. Now, you will optimize a given list processing function to improve its efficiency and handle various edge cases effectively. Problem Statement Refactor the function `find_max_negative` to improve efficiency and provide input validation to handle a wider range of scenarios. Function to Be Optimized ```python def find_max_negative(numbers: list) -> int: Find the maximum negative number in a list of integers. >>> find_max_negative([-1, -2, -3, 4, 2, -6]) -1 >>> find_max_negative([5, 3, 2, 1]) None >>> find_max_negative([-7, -1, -5, -3]) -1 max_negative = None for num in numbers: if num < 0 and (max_negative is None or num > max_negative): max_negative = num return max_negative ``` Requirements 1. **Input Validation**: - Ensure `numbers` is a list of integers. - Raise a `TypeError` with an appropriate message for invalid inputs. 2. **Edge Case Handling**: - Handle the case where the list is empty by returning `None`. - If no negative number exists, return `None`. 3. **Optimization**: - Implement an efficient approach to find the maximum negative number. Input/Output Format * **Input**: - `numbers`: A list of integers. May include both positive and negative integers. The list must not be empty. * **Output**: - An integer representing the maximum negative number in the list. If no negative number exists, return `None`. Constraints 1. The input list should contain at least one integer. 2. You should not use built-in functions that directly solve the problem. Example ```python try: print(find_max_negative([-1, -2, -3, 4, 2, -6])) # Outputs: -1 print(find_max_negative([5, 3, 2, 1])) # Outputs: None print(find_max_negative([])) # Outputs: None print(find_max_negative([-7, -1, -5, -3])) # Outputs: -1 print(find_max_negative(\\"invalid input\\")) # Raises TypeError except TypeError as te: print(f\\"TypeError: {te}\\") ``` ```python def find_max_negative(numbers: list) -> int: Find the maximum negative number in a list of integers. Parameters: numbers (list): A list of integers. Returns: int: Maximum negative number in the list, or None if no negative number exists. Raises: TypeError: If the input is not a list of integers. if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers): raise TypeError(\\"Input must be a list of integers.\\") max_negative = None for num in numbers: if num < 0 and (max_negative is None or num > max_negative): max_negative = num return max_negative # Example usage try: print(find_max_negative([-1, -2, -3, 4, 2, -6])) # Outputs: -1 print(find_max_negative([5, 3, 2, 1])) # Outputs: None print(find_max_negative([])) # Outputs: None print(find_max_negative([-7, -1, -5, -3])) # Outputs: -1 print(find_max_negative(\\"invalid input\\")) # Raises TypeError except TypeError as te: print(f\\"TypeError: {te}\\") ```","solution":"def find_max_negative(numbers: list) -> int: Find the maximum negative number in a list of integers. Parameters: numbers (list): A list of integers. Returns: int: Maximum negative number in the list, or None if no negative number exists. Raises: TypeError: If the input is not a list of integers. if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers): raise TypeError(\\"Input must be a list of integers.\\") max_negative = None for num in numbers: if num < 0 and (max_negative is None or num > max_negative): max_negative = num return max_negative"},{"question":"# String Compression Algorithm Scenario: You are tasked with implementing a function to compress a string to its abbreviation by counting the repeating sequence of characters in it. This technique is often used in data compression algorithms. For instance, the string \\"aaabccddd\\" would be compressed to \\"a3bc2d3\\". Task: Implement a function `compress_string` that takes a non-empty string and returns its compressed form. It should append the character count only if the count is greater than 1. Handle edge cases such as a single character string or non-repeating characters. Function Signature: ```python def compress_string(s: str) -> str: Compress the input string by counting consecutive repeating characters. :param str s: Input string to be compressed. :return str: The compressed string. Example: >>> compress_string(\\"aaabccddd\\") \'a3bc2d3\' >>> compress_string(\\"abcd\\") \'abcd\' >>> compress_string(\\"a\\") \'a\' >>> compress_string(\\"aabbcc\\") \'a2b2c2\' >>> compress_string(\\"\\") Traceback (most recent call last): ... ValueError: Input string must not be empty. # Your implementation goes here ``` Constraints: - The input string will consist of only English alphabet characters (both uppercase and lowercase). - Raise a `ValueError` for an empty input with the message: \\"Input string must not be empty.\\" - The function should be efficient and handle long strings gracefully. Performance Requirement: - The function should run in linear time (O(n)), where (n) is the length of the input string. Test your implementation with provided examples and additional test cases to ensure its correctness and performance.","solution":"def compress_string(s: str) -> str: if len(s) == 0: raise ValueError(\\"Input string must not be empty.\\") compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return \\"\\".join(compressed)"},{"question":"# Problem Statement You are given an integer array `arr` of length `n` and an integer `target`. Your task is to write a function `two_sum(arr: List[int], target: int) -> List[int]` that returns the indices of the two numbers in the array such that they add up to `target`. # Input Format - An integer array `arr` where `1 ≤ n ≤ 10^6` and each element `-10^9 ≤ arr[i] ≤ 10^9`. - An integer `target` where `-10^9 ≤ target ≤ 10^9`. # Output Format - A list of two integers representing the indices of the two numbers that add up to `target`. If no such numbers exist, return an empty list. # Constraints - Each input would have exactly one solution, and you may not use the same element twice. # Performance Requirements - Your solution should ideally have a linear runtime complexity, i.e., O(n). # Example ```python >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] ``` # Analysis Analyze the given problem and consider using a hash map (dictionary) to record the indices of the numbers you have seen so far and check on each iteration to see if the complement exists in the map. # Constraints & Edge Cases 1. Ensure the indices are returned in the correct order. 2. Handle cases where `arr` contains negative numbers or if elements are repeated. Implement the function `two_sum` below: ```python from typing import List def two_sum(arr: List[int], target: int) -> List[int]: index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: return [index_map[complement], i] index_map[num] = i return [] # You may write your own test cases to validate your solution if __name__ == \\"__main__\\": print(two_sum([2, 7, 11, 15], 9)) # Should output [0, 1] print(two_sum([3, 2, 4], 6)) # Should output [1, 2] print(two_sum([3, 3], 6)) # Should output [0, 1] ```","solution":"from typing import List def two_sum(arr: List[int], target: int) -> List[int]: Returns the indices of the two numbers in the array that add up to the target. Parameters: arr (List[int]): The input array of integers. target (int): The target sum. Returns: List[int]: A list with the indices of the two numbers adding up to target. index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: return [index_map[complement], i] index_map[num] = i return []"},{"question":"# Question Context You are tasked with creating a function that generates and returns all possible permutations of a given string. This will test your understanding of recursion and the use of Python\'s itertools library. # Problem Statement Implement a function called `string_permutations` in Python, which takes a string `s` and returns a list of all possible permutations of the characters in the string. Ensure the function handles typical issues with permutations efficiently. # Requirements 1. **Function Definition**: ```python def string_permutations(s: str) -> list: pass ``` 2. **Behavior**: - The function should generate all permutations of the input string `s`. - For simplicity, you may assume the input string contains unique characters. 3. **Testing Requirements**: - Use Python\'s `unittest` framework to write comprehensive tests. - Verify that the output contains all expected permutations and has the correct number of permutations. - Ensure the function handles edge cases like an empty string and a single character string. # Expected Input and Output Formats - **Input**: - `s`: A string containing unique characters. - **Output**: - A list of strings representing all possible permutations of the input. # Constraints - The length of the input string `s` will be in the range `[0, 10]`. - The characters in the string `s` will be unique. # Performance Requirements - The function should efficiently generate permutations even for the upper limits of input size. # Implementation You are required to implement the `string_permutations` function and a comprehensive unit test following the outlined specifications. # Example ```python s = \\"abc\\" string_permutations(s) ``` **Expected Output**: ```python [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] ```","solution":"from itertools import permutations def string_permutations(s: str) -> list: Returns a list of all possible permutations of the characters in the input string s. :param s: Input string with unique characters :return: List of all permutations of the input string return [\'\'.join(p) for p in permutations(s)]"},{"question":"# Question: Movie Recommendations Based on Genre Preferences Objective: Develop a movie recommendation system based on user-defined genre preferences. The system should be able to store movies\' data, users\' preferences, and recommend movies that fit the preferred genres. Part 1: Storing Movies Data 1. **Class: `MovieDatabase`** * Store information about movies. Each movie contains a title and a set of genres. ```python class MovieDatabase: def __init__(self): Initialize the MovieDatabase with an empty collection of movies. self.movies = [] def add_movie(self, title: str, genres: set): Add a movie to the database with the given title and genres. Parameters: title (str): The title of the movie. genres (set): A set of genres associated with the movie. pass # Your implementation ``` Part 2: Storing Users Preferences 2. **Class: `UserPreferences`** * Store information about users\' genre preferences. ```python class UserPreferences: def __init__(self): Initialize the UserPreferences with an empty collection of users\' preferences. self.preferences = {} def set_preference(self, user: str, genres: set): Set the preferred genres for a user. Parameters: user (str): The user for whom to set the preferences. genres (set): A set of preferred genres. pass # Your implementation ``` Part 3: Recommending Movies 3. **Function: `recommend_movies`** * Recommend movies from the database that match the user\'s preferred genres. ```python def recommend_movies(movie_db: MovieDatabase, user_prefs: UserPreferences, user: str) -> list: Recommend movies for a user based on their genre preferences. Parameters: movie_db (MovieDatabase): The database of movies. user_prefs (UserPreferences): The users\' genre preferences. user (str): The user for whom to recommend movies. Returns: list: A list of movie titles that match the user\'s preferred genres. pass # Your implementation ``` Constraints & Requirements: * A movie may belong to multiple genres. * A genre is represented as a string (e.g., \\"Action\\", \\"Comedy\\"). * The movie recommendation should return movies containing any of the user\'s preferred genres. * Users may have multiple preferred genres. * If a user has no preferences set, an empty list should be returned. Example: ```python mdb = MovieDatabase() mdb.add_movie(\\"Inception\\", {\\"Action\\", \\"Sci-Fi\\"}) mdb.add_movie(\\"Toy Story\\", {\\"Animation\\", \\"Family\\"}) mdb.add_movie(\\"The Matrix\\", {\\"Action\\", \\"Sci-Fi\\"}) mdb.add_movie(\\"The Godfather\\", {\\"Crime\\", \\"Drama\\"}) up = UserPreferences() up.set_preference(\\"Alice\\", {\\"Drama\\", \\"Action\\"}) up.set_preference(\\"Bob\\", {\\"Sci-Fi\\", \\"Animation\\"}) up.set_preference(\\"Charlie\\", {\\"Horror\\"}) print(recommend_movies(mdb, up, \\"Alice\\")) # Example Output: [\\"Inception\\", \\"The Matrix\\", \\"The Godfather\\"] print(recommend_movies(mdb, up, \\"Bob\\")) # Example Output: [\\"Inception\\", \\"Toy Story\\", \\"The Matrix\\"] print(recommend_movies(mdb, up, \\"Charlie\\")) # Output: [] ``` Ensure your implementation is efficient, handles edge cases, and maintains consistent output format.","solution":"class MovieDatabase: def __init__(self): Initialize the MovieDatabase with an empty collection of movies. self.movies = {} def add_movie(self, title: str, genres: set): Add a movie to the database with the given title and genres. Parameters: title (str): The title of the movie. genres (set): A set of genres associated with the movie. self.movies[title] = genres class UserPreferences: def __init__(self): Initialize the UserPreferences with an empty collection of users\' preferences. self.preferences = {} def set_preference(self, user: str, genres: set): Set the preferred genres for a user. Parameters: user (str): The user for whom to set the preferences. genres (set): A set of preferred genres. self.preferences[user] = genres def recommend_movies(movie_db: MovieDatabase, user_prefs: UserPreferences, user: str) -> list: Recommend movies for a user based on their genre preferences. Parameters: movie_db (MovieDatabase): The database of movies. user_prefs (UserPreferences): The users\' genre preferences. user (str): The user for whom to recommend movies. Returns: list: A list of movie titles that match the user\'s preferred genres. if user not in user_prefs.preferences: return [] preferred_genres = user_prefs.preferences[user] recommended_movies = [ title for title, genres in movie_db.movies.items() if genres.intersection(preferred_genres) ] return recommended_movies"},{"question":"# Problem Statement You are given a set of positive integers and your task is to find the smallest positive integer that is missing from the set. This is the smallest positive integer that cannot be represented using any of the numbers in the set. Write a function `smallest_missing_positive(nums: List[int]) -> int` that returns the smallest positive integer not present in the input list. # Input - `nums`: A list of positive integers (1 ≤ length of nums ≤ 1000, 1 ≤ nums[i] ≤ 10^6) # Output - Returns the smallest positive integer that is missing from the list. # Constraints - Although the values in the list can be quite large, you only need to consider the smallest positive integers starting from 1. # Example ```python def smallest_missing_positive(nums: List[int]) -> int: # Your code here # Testing the function print(smallest_missing_positive([1, 2, 3, 4, 6])) # Expected output: 5 print(smallest_missing_positive([1, 3, 6, 4, 1, 2])) # Expected output: 5 print(smallest_missing_positive([7, 8, 9, 11, 12])) # Expected output: 1 ``` # Explanation The function needs to determine the smallest positive integer that is not present in the given list of integers. The list can contain duplicates and numbers not in a contiguous sequence. The task is to identify the gap in the sequence of positive integers starting from 1. For example, in the first test case `[1, 2, 3, 4, 6]`, the smallest missing positive integer is `5`. Ensure your solution is efficient and handles the given constraints properly.","solution":"from typing import List def smallest_missing_positive(nums: List[int]) -> int: num_set = set(nums) smallest_missing = 1 while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"# Problem Statement: You are tasked with writing a function that calculates the number of unique ways to climb to the top of a staircase with `n` steps, where at each step you can either climb 1 or 2 stairs. This is a common dynamic programming problem often referred to as the \'staircase problem\'. # Background: In this problem, you need to determine how many distinct ways you can climb a staircase if you can go up either 1 step or 2 steps at a time. This problem is related to the Fibonacci sequence, where the number of ways to reach a particular step is the sum of the ways to reach the two preceding steps. # Function Requirements: Implement the following function: ```python def climb_stairs(n: int) -> int: Calculates the number of unique ways to climb a staircase with `n` steps where you can take either 1 or 2 steps at a time. :param n: The total number of steps in the staircase :return: Number of distinct ways to climb to the top Example: >>> climb_stairs(5) 8 # Your implementation here ``` # Constraints: * (1 leq n leq 10^5) # Expected Input and Output: * **Input**: An integer (n) * **Output**: An integer representing the number of distinct ways to climb the staircase. # Examples: ```python # Example 1 assert climb_stairs(5) == 8 # Example 2 assert climb_stairs(3) == 3 # Example 3 assert climb_stairs(1) == 1 ``` # Performance Requirements: * Your solution should be efficient in both time and space, given the upper limit constraint of (10^5). # Notes: - Consider leveraging dynamic programming to store intermediate results and avoid redundant calculations. - Think about edge cases such as the smallest value of (n) where the number of ways can be trivially determined. Implement the function with these guidelines, considering edge cases, performance, and correctness.","solution":"def climb_stairs(n: int) -> int: Calculates the number of unique ways to climb a staircase with `n` steps where you can take either 1 or 2 steps at a time. :param n: The total number of steps in the staircase :return: Number of distinct ways to climb to the top Example: >>> climb_stairs(5) 8 if n == 1: return 1 # Initialize the base cases a, b = 1, 1 # Iterate from 2 to n to build up the solution for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement: You are tasked with creating a utility function to generate all possible unique permutations of a given string, ensuring that the permutations are generated using different approaches and analyzed for performance. Your implementation should handle various constraints and edge cases effectively, guaranteeing accurate and efficient results. # Requirements: 1. **Permutation Generation Function**: Implement a function `generate_permutations` that generates all unique permutations of a given string using three different methods. 2. **Performance Benchmark**: Implement benchmarking for different implementations to measure their performance with different input sizes. # Input & Output: 1. **generate_permutations(s: str) -> List[str]**: - **Input**: A string `s` (1 ≤ len(s) ≤ 10), containing alphanumeric characters. - **Output**: A list of strings representing all unique permutations of `s`. # Constraints: * The function should handle strings with duplicate characters to ensure all permutations are unique. * Only string inputs should be accepted; other types should raise a `TypeError`. # Function Specifications: Implement three versions of `generate_permutations`: 1. **Recursive backtracking method** using explicit swapping. 2. **Iterative method** leveraging itertools permutations and filtering for uniqueness. 3. **Lexicographic order method** generating permutations in a lexicographic sequence. # Performance Benchmarking: Compare the execution times of the three implementations using different sizes of input values, such as small, average, and edge-case strings. # Example Usage: ```python def generate_permutations_recursive(s: str) -> List[str]: Recursive backtracking method to generate all unique permutations of a string. pass def generate_permutations_iterative(s: str) -> List[str]: Iterative method to generate all unique permutations of a string. pass def generate_permutations_lexicographic(s: str) -> List[str]: Lexicographic order method to generate all unique permutations of a string. pass def benchmark() -> None: Benchmark multiple functions with different string values. pass # Example calls: print(generate_permutations_recursive(\\"abc\\")) # Output: [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] print(generate_permutations_iterative(\\"abc\\")) # Output: [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] print(generate_permutations_lexicographic(\\"abc\\")) # Output: [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] benchmark() # Execute and print benchmarking results. ``` # Notes: * Ensure your code is efficient and can handle edge cases and duplicate characters appropriately. * Document any assumptions or decisions made during implementation. * For benchmarking, use `timeit` to measure execution time and provide a summary of results.","solution":"from itertools import permutations as iter_permutations from typing import List import timeit def generate_permutations_recursive(s: str) -> List[str]: def backtrack(s, path, used, res): if len(path) == len(s): res.add(\\"\\".join(path)) return for i in range(len(s)): if used[i] or (i > 0 and s[i] == s[i - 1] and not used[i - 1]): continue used[i] = True path.append(s[i]) backtrack(s, path, used, res) used[i] = False path.pop() s = sorted(s) res = set() used = [False] * len(s) backtrack(s, [], used, res) return list(res) def generate_permutations_iterative(s: str) -> List[str]: return list(set(\\"\\".join(p) for p in iter_permutations(s))) def generate_permutations_lexicographic(s: str) -> List[str]: s = \'\'.join(sorted(s)) def next_permutation(s): i = len(s) - 2 while i >= 0 and s[i] >= s[i + 1]: i -= 1 if i == -1: return False, s j = len(s) - 1 while s[j] <= s[i]: j -= 1 s[i], s[j] = s[j], s[i] s = s[:i + 1] + s[i + 1:][::-1] return True, s s = list(s) res = [\'\'.join(s)] while True: has_next, s = next_permutation(s) if not has_next: break res.append(\'\'.join(s)) return res def benchmark(): test_strings = [\'abc\', \'aabb\', \'abcd\', \'aabc\'] funcs = [ generate_permutations_recursive, generate_permutations_iterative, generate_permutations_lexicographic ] for test_string in test_strings: for func in funcs: time_taken = timeit.timeit(lambda: func(test_string), number=1000) print(f\\"Function {func.__name__} with input \'{test_string}\' took {time_taken:.5f} seconds\\") # Example calls (for demonstration, not part of the solution to copy): print(generate_permutations_recursive(\\"abc\\")) print(generate_permutations_iterative(\\"abc\\")) print(generate_permutations_lexicographic(\\"abc\\")) benchmark() # Execute and print benchmarking results."},{"question":"# Problem Statement The Fibonacci sequence is a series of numbers where each number (after the first two) is the sum of the two preceding ones. The sequence starts with 0 and 1. That is, Fibonacci(0) = 0, Fibonacci(1) = 1, and for n ≥ 2, Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2). This sequence appears in various problems in computer science and mathematics. Task Your task is to write a function `nth_fibonacci` that calculates the nth Fibonacci number in the sequence. Function Signature ```python def nth_fibonacci(n: int) -> int: ``` Input * `n` (int): A non-negative integer representing the position in the Fibonacci sequence (0-indexed). Output * Returns an integer representing the nth Fibonacci number. Constraints * if `n` is negative, raise a `ValueError` with the message \\"Input must be a non-negative integer\\". Performance Requirements * The function should run efficiently with a time complexity of O(n) using an iterative approach. Example Usage ```python >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(5) 5 >>> nth_fibonacci(10) 55 >>> nth_fibonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer ``` Notes - Ensure your function handles all edge cases effectively. - You can assume the integer n will be within reasonable limits to prevent overflow issues.","solution":"def nth_fibonacci(n: int) -> int: if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Description In this task, you are required to implement an LRU (Least Recently Used) Cache with a predetermined capacity. The LRU Cache needs to support the following operations: `get` and `put`. # Objectives 1. Implement an LRU Cache that supports the following methods: - `get(key)` that returns the value of the key if it exists in the cache; otherwise, returns `-1`. - `put(key, value)` that inserts or updates the value in the cache. When the cache reaches its capacity, it should invalidate the least recently used key before inserting a new key-value pair. # Requirements Part 1: `get` Method * **Function Signature**: `def get(self, key: int) -> int` * **Inputs**: An integer `key`. * **Outputs**: The value of the key if it is in the cache; otherwise, `-1`. Part 2: `put` Method * **Function Signature**: `def put(self, key: int, value: int) -> None` * **Inputs**: An integer `key` and an integer `value`. * **Outputs**: None. * **Constraints**: - Both keys and values are integers. - The cache will have a fixed capacity; when capacity is reached, the least recently used key should be invalidated. - All operations must run in O(1) time complexity. # Scenario Consider that you are implementing a caching mechanism in a web server that stores frequent HTTP responses. It needs to be highly efficient both in terms of space and time. Your LRU Cache will ensure that the server can handle quick retrievals and insertions. # Example ```python # Example cache = LRUCache(2) # Initialize an LRU Cache with capacity 2 cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Output: 1, since key 1 is in the cache cache.put(3, 3) # This operation will invalidate key 2 as it is the LRU, and add key 3 print(cache.get(2)) # Output: -1, since key 2 has been invalidated cache.put(4, 4) # This operation will invalidate key 1 # Now the cache contains keys {3:3, 4:4} print(cache.get(1)) # Output: -1, since key 1 has been invalidated print(cache.get(3)) # Output: 3, as key 3 is in the cache print(cache.get(4)) # Output: 4, as key 4 is in the cache ``` # Implementation Details LRUCache Class ```python class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with the given capacity. :param capacity: maximum number of items to be stored in the cache self.capacity = capacity # Data structure to hold key-value pairs self.cache = {} # Double-ended queue to keep track of the order of keys for LRU eviction self.order = collections.deque() def get(self, key: int) -> int: Retrieve the value for the given key from the cache. :param key: key whose value is to be retrieved :return: value if key is present in the cache, otherwise -1 # Check if the key is in the cache if key in self.cache: # Move the key to the end to signify recent access self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: Insert or update the value in the cache for the given key. If the cache is at capacity, evict the least recently used item. :param key: key to be inserted/updated :param value: value to be linked with the key # If the key is in the cache, update the value and move key to the end if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: # Evict the least recently used key lru = self.order.popleft() del self.cache[lru] # Insert the key-value pair and mark this key as most recently used self.cache[key] = value self.order.append(key) ``` # Performance and Constraints - Ensure all operations (`get` and `put`) have O(1) time complexity. - Handle edge cases such as initializing the cache with capacity zero and attempting to `put` or `get` operations.","solution":"# Implementing the LRU Cache according to the instructions from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with the given capacity. :param capacity: maximum number of items to be stored in the cache self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: Retrieve the value for the given key from the cache. :param key: key whose value is to be retrieved :return: value if key is present in the cache, otherwise -1 if key in self.cache: self.cache.move_to_end(key) # Mark as most recently used return self.cache[key] return -1 def put(self, key: int, value: int) -> None: Insert or update the value in the cache for the given key. If the cache is at capacity, evict the least recently used item. :param key: key to be inserted/updated :param value: value to be linked with the key if key in self.cache: self.cache.move_to_end(key) # Update the order to mark it as most recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # pop the first item (least recently used)"},{"question":"# Scenario You have been hired by a company that develops data processing tools. As part of your role, you are tasked with implementing several fundamental string manipulation functions. These functions will be integrated into a larger text processing framework, which will be extensively tested. # Task Implement the following string operations as specified: 1. `reverse_string(s)`: Reverses the given string. 2. `is_palindrome(s)`: Checks if the given string is a palindrome (ignoring case and non-alphanumeric characters). 3. `find_substring(s, sub)`: Finds the starting index of the first occurrence of the substring `sub` in the string `s`. Returns -1 if the substring is not found. 4. `count_words(s)`: Counts the number of words in the string `s`. Words are separated by spaces and punctuation is ignored. 5. `remove_duplicates(s)`: Removes duplicate characters from the string while maintaining order. # Specifications - **Input**: - `reverse_string`, `is_palindrome`, `find_substring`, `count_words`, `remove_duplicates`: One string `s`. - `find_substring`: Additionally takes another string `sub` which is the substring to search for. - **Output**: - The result should be: - A string for `reverse_string` and `remove_duplicates`. - A boolean value for `is_palindrome`. - An integer for `find_substring`. - An integer for `count_words`. # Example Implementations ```python def reverse_string(s): # Implement string reversal logic pass def is_palindrome(s): # Implement palindrome check logic pass def find_substring(s, sub): # Implement substring search logic pass def count_words(s): # Implement word count logic pass def remove_duplicates(s): # Implement duplicate removal logic pass ``` # Constraints - You should handle invalid input cases gracefully by raising appropriate exceptions, such as `TypeError` for invalid data types. - Use built-in string handling functions where appropriate to ensure efficiency. # Performance Requirements - The time complexity should be kept as low as practical within the constraints of typical use cases. - Your code will be tested for efficiency and should handle reasonably large strings (e.g., with 100,000 characters) within acceptable time limits.","solution":"import re def reverse_string(s): Reverses the given string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") return s[::-1] def is_palindrome(s): Checks if the given string is a palindrome (ignoring case and non-alphanumeric characters). if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") filtered_s = re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() return filtered_s == filtered_s[::-1] def find_substring(s, sub): Finds the starting index of the first occurrence of the substring `sub` in the string `s`. Returns -1 if the substring is not found. if not isinstance(s, str) or not isinstance(sub, str): raise TypeError(\\"Both inputs must be strings\\") return s.find(sub) def count_words(s): Counts the number of words in the string `s`. Words are separated by spaces and punctuation is ignored. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") words = re.findall(r\'bw+b\', s) return len(words) def remove_duplicates(s): Removes duplicate characters from the string while maintaining order. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Task You are given an implementation of a Segment Tree. Your task is to implement a function to perform range minimum queries (RMQ). Additionally, you need to implement a function to update a specific element in the array. RMQ should return the minimum value in a given range [left, right). # Function Signature ```python class SegmentTree: # ... (existing methods) def __init__(self, data: list): Initialize the segment tree with a given list of integers. Parameters: data (list): List of integers to build the segment tree from Example Usage: >>> st = SegmentTree([1, 3, 5, 7, 9, 11]) >>> st.range_min_query(1, 4) 3 >>> st.update(2, 0) >>> st.range_min_query(1, 4) 0 pass def range_min_query(self, left: int, right: int) -> int: Returns the minimum value in the range [left, right). Parameters: left (int): left bound of the range (inclusive) right (int): right bound of the range (exclusive) Returns: int: Minimum value in the specified range Example Usage: >>> st = SegmentTree([1, 3, 5, 7, 9, 11]) >>> st.range_min_query(1, 4) 3 pass def update(self, index: int, value: int) -> None: Update the value at a specific index in the array. Parameters: index (int): Index of the element to update value (int): New value to set at the specified index Returns: None Example Usage: >>> st = SegmentTree([1, 3, 5, 7, 9, 11]) >>> st.update(2, 0) >>> st.range_min_query(1, 4) 0 pass ``` # Specifications 1. Implement the `range_min_query` method that returns the minimum value in the range [left, right). 2. Implement the `update` method to update a given index with a new value. 3. Ensure Segment Tree operations adhere to their efficiency constraints: - Range queries and updates should ideally have a complexity of O(log N). # Input - **left**: An integer representing the starting index of the range (inclusive). - **right**: An integer representing the ending index of the range (exclusive). - **index**: An integer representing the index to update. - **value**: An integer representing the new value to set at the specified index. # Output - The `range_min_query` method should return an integer, the minimum value in the specified range. - The `update` method should not return anything but should modify the internal state of the Segment Tree. # Example 1. Create a Segment Tree with specified elements: ```python st = SegmentTree([1, 3, 5, 7, 9, 11]) ``` 2. Perform a range minimum query: ```python assert st.range_min_query(1, 4) == 3 ``` 3. Update an element: ```python st.update(2, 0) ``` 4. Perform another range minimum query to verify the update: ```python assert st.range_min_query(1, 4) == 0 ``` # Constraints - You can assume that the indexes provided in the range and for the update are within the bounds of the array. - Values can be positive, negative, or zero.","solution":"class SegmentTree: def __init__(self, data: list): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def range_min_query(self, left: int, right: int) -> int: left += self.n right += self.n min_value = float(\'inf\') while left < right: if left % 2: min_value = min(min_value, self.tree[left]) left += 1 if right % 2: right -= 1 min_value = min(min_value, self.tree[right]) left //= 2 right //= 2 return min_value def update(self, index: int, value: int) -> None: pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1])"},{"question":"# Problem Statement: A \\"Hamming number\\" is a positive integer whose prime factors are limited to 2, 3, and 5. The sequence of Hamming numbers (1-based indexed) is: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, and so on. By definition, 1 is the smallest Hamming number. Given an integer `k`, your task is to implement a function that returns the kth smallest Hamming number. # Function Signature: ```python def find_kth_hamming_number(k: int) -> int: pass ``` # Input: - An integer `k` where 1 <= k <= 10^4. # Output: - Return the kth smallest Hamming number. # Constraints: - Your algorithm should efficiently handle the computation for large values of `k`. - Ensure a time complexity of O(k). # Example: ```python assert find_kth_hamming_number(1) == 1 assert find_kth_hamming_number(7) == 8 assert find_kth_hamming_number(11) == 15 assert find_kth_hamming_number(100) == 1536 ``` # Detailed Steps: 1. Initialize an array or list to store the Hamming numbers. 2. Setup three pointers to keep track of the current position for multiples of 2, 3, and 5. 3. Iteratively calculate the next candidate Hamming number by taking the minimum of the next values that can be generated using the pointers. 4. Add the derived minimum value to your list of Hamming numbers and advance the relevant pointer(s). 5. Repeat this process until you have generated the kth Hamming number. Make sure your implementation remains optimal and correctly handles edge cases such as small values of k.","solution":"def find_kth_hamming_number(k: int) -> int: hamming_numbers = [1] i2 = i3 = i5 = 0 while len(hamming_numbers) < k: next_hamming = min(2 * hamming_numbers[i2], 3 * hamming_numbers[i3], 5 * hamming_numbers[i5]) hamming_numbers.append(next_hamming) if next_hamming == 2 * hamming_numbers[i2]: i2 += 1 if next_hamming == 3 * hamming_numbers[i3]: i3 += 1 if next_hamming == 5 * hamming_numbers[i5]: i5 += 1 return hamming_numbers[k - 1]"},{"question":"# Coding Assessment Question: **Problem Description**: Your task is to implement a custom matrix multiplication function. The primary goal of this exercise is to test your understanding of matrix operations, as well as your ability to optimize performance when dealing with numerical computations in Python. Implement the `matrix_multiplication` function, which takes two matrices (2-dimensional lists) as input and returns their product. **Requirements**: Implement the following function: 1. **Function `matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]`** - Multiply matrix `A` (of size m x n) with matrix `B` (of size n x p) and return the result matrix (of size m x p). **Input/Output**: 1. **Function Parameters**: - `A` (List[List[int]]): The first input matrix of size m x n. - `B` (List[List[int]]): The second input matrix of size n x p. 2. **Function Output**: - Return (List[List[int]]): The resulting matrix of size m x p after multiplication. 3. **Constraints**: - The input matrices will always have dimensions such that matrix multiplication is defined. - Elements of the matrices will be integers in the range of [-1000, 1000]. - The size of matrices should be reasonable for typical computation limits (e.g., m, n, p <= 100). **Example**: ```python def matrix_multiplication(A, B): # Implement the function according to the specifications above pass if __name__ == \\"__main__\\": # Example 1 A = [[1, 2], [3, 4]] B = [[5, 6], [7, 8]] result = matrix_multiplication(A, B) # Expected Output: [[19, 22], # [43, 50]] print(result) # Example 2 A = [[2, 4], [1, 3], [0, -1]] B = [[1, 2, 0], [3, 4, 1]] result = matrix_multiplication(A, B) # Expected Output: [[14, 20, 4], # [10, 14, 3], # [-3, -4, -1]] print(result) ``` **Objective**: Ensure that you have a solid understanding of matrix multiplication and can implement an efficient solution to solve such problems. The function should handle typical edge cases and provide correct and optimized computation. --- This problem assesses your ability to handle basic linear algebra operations, understand nested loops, and be conscious of computational efficiency. The task is typical of those encountered in numerical methods and scientific computing.","solution":"from typing import List def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B. :param A: The first matrix of size m x n. :param B: The second matrix of size n x p. :return: The resulting matrix of size m x p. m, n = len(A), len(A[0]) p = len(B[0]) # Initialize the resulting matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Coding Assessment Question **Scenario**: As a part of a software system you\'re developing, you need to implement a utility that parses a list of strings into a meaningful representation. Specifically, you want to extract domain names from a list of email addresses to perform statistical analysis on the distribution of email domains. **Task**: Write a function `extract_domains` that: - Takes a single argument, `emails`, which is a list of email addresses as strings. - Returns a list of domain names extracted from the provided email addresses, where each domain appears only once (i.e., the list should not contain duplicates). The domain name is the part of the email address after the `@` symbol. **Input**: - A list of email addresses in string format. **Output**: - A list of unique domain names in string format. **Constraints**: - An email address is valid if it contains exactly one `@` symbol. - Ignore invalid email addresses (e.g., those without an `@` symbol or with multiple `@` symbols) - Domains in the output should be in the order they first appear in the input list. **Function Signature**: ```python def extract_domains(emails: List[str]) -> List[str]: ``` **Examples**: ```python extract_domains([\'alice@example.com\', \'bob@domain.org\', \'charlie@example.com\']) # Expected output: [\'example.com\', \'domain.org\'] extract_domains([\'invalidemail.com\', \'john@doe.com\', \'jane.doe@random.net\', \'invalid@address@com\']) # Expected output: [\'doe.com\', \'random.net\'] extract_domains([]) # Expected output: [] extract_domains([\'noatsign.net\', \'double@@example.com\', \'correct@fine.email\']) # Expected output: [\'fine.email\'] ``` Write comprehensive test cases to verify the correctness of your implementation. The function should pass all provided example cases, ensuring correct extraction of domain names, handling of duplicates, and appropriate ignoring of invalid email addresses.","solution":"from typing import List def extract_domains(emails: List[str]) -> List[str]: Extracts unique domain names from a list of email addresses. domains = [] seen = set() for email in emails: parts = email.split(\'@\') if len(parts) == 2: domain = parts[1] if domain not in seen: seen.add(domain) domains.append(domain) return domains"},{"question":"# Scenario: You are working on a simulation module for a network protocol analyzer. As part of the simulation, you need to implement a function that determines if a given IP address is part of a specified subnet. Given a function definition below, write logic to determine if the IP address belongs to the subnet. # Function Specification **Function name**: `is_ip_in_subnet` **Input**: - `ip` (str): The IP address in the format \\"x.x.x.x\\". - `subnet` (str): The subnet in the format \\"x.x.x.x/y\\" where y is the number of bits in the subnet mask. **Output**: - (bool): Return `True` if the IP address belongs to the subnet, otherwise return `False`. **Constraints**: - The IP address and subnet mask are both valid IPv4 addresses. - You cannot use built-in functions or libraries specific to IP address manipulation. **Examples**: ```python >>> is_ip_in_subnet(\\"192.168.1.10\\", \\"192.168.1.0/24\\") True >>> is_ip_in_subnet(\\"192.168.1.10\\", \\"192.168.2.0/24\\") False >>> is_ip_in_subnet(\\"10.0.0.5\\", \\"10.0.0.0/16\\") True >>> is_ip_in_subnet(\\"172.16.5.4\\", \\"172.16.0.0/12\\") True ``` # Task: Complete the implementation of the `is_ip_in_subnet` function to correctly determine whether the given IP address belongs to the specified subnet.","solution":"def is_ip_in_subnet(ip, subnet): Determine if an IP address is within a given subnet. Args: ip (str): The IP address in the format \\"x.x.x.x\\". subnet (str): The subnet in the format \\"x.x.x.x/y\\" where y is the number of bits in the subnet mask. Returns: bool: True if the IP address belongs to the subnet, otherwise False. # Convert IP and Subnet to binary form def ip_to_binary(ip_str): return \'\'.join(format(int(octet), \'08b\') for octet in ip_str.split(\'.\')) ip_binary = ip_to_binary(ip) subnet_ip, prefix_length = subnet.split(\'/\') subnet_binary = ip_to_binary(subnet_ip) # Check if the first prefix_length bits are the same return ip_binary[:int(prefix_length)] == subnet_binary[:int(prefix_length)]"},{"question":"# Question You are tasked with implementing a command-line utility that tracks and logs user activities in a file. The utility should read commands from the user, log these commands along with a timestamp, and provide a summary of all logged activities upon request. Function Signature ```python def activity_logger(log_filename: str) -> None: ``` Input * `log_filename` (str): The name of the file where activities should be logged. Output * This function does not return anything. Instead, it logs activities to the specified file and can print a summary of the logged activities. Instructions 1. The function should continuously prompt the user for a command input until the user inputs the command \\"SUMMARY\\". 2. For each command entered by the user: * Log the command to the specified file, prefixed with a timestamp in the format `\\"YYYY-MM-DD HH:MM:SS\\"`. * Example log entry: `\\"2023-03-15 14:45:23: command_entered\\"` 3. If the user enters the command \\"SUMMARY\\": * Print out all logged activities from the file in the order they were logged. * Exit the program after printing the summary. Constraints * Ensure the log file is opened in append mode to avoid overwriting previous logs. * Handle any file I/O exceptions gracefully. * Use the standard library `datetime` for handling timestamps. Example ```python def activity_logger(log_filename: str) -> None: # Your implementation here pass if __name__ == \\"__main__\\": log_filename = \\"activity_log.txt\\" activity_logger(log_filename) ``` Execution 1. Start the script. 2. Continuously prompt the user for input commands. 3. Log each command with a timestamp in the specified file. 4. On entering \\"SUMMARY\\", read and print all log entries, then terminate the program. Notes * Ensure your function is robust and handles unexpected inputs gracefully. * Write clean, maintainable, and well-documented code.","solution":"import datetime def activity_logger(log_filename: str) -> None: Logs user activities with a timestamp into a specified file and provides a summary of the logged activities when requested. # Opening the file in append mode with open(log_filename, \'a+\') as log_file: while True: command = input(\\"Enter command: \\") if command == \\"SUMMARY\\": break timestamp = datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\') log_file.write(f\\"{timestamp}: {command}n\\") # Reopen the file to read log entries for the summary with open(log_filename, \'r\') as log_file: logs = log_file.readlines() for log in logs: print(log.strip())"},{"question":"# Coding Assessment Question Scenario: Imagine you\'re managing a warehouse that stocks various items. Each item is identified by a unique SKU (Stock Keeping Unit) number. You need to design an inventory management system that can keep track of items and their quantities and should be able to perform a sequence of operations including adding, removing, and querying the quantity of items. Task: Write a class `Inventory` that provides the following methods: 1. `add_item(sku: str, quantity: int) -> None`: Adds the given quantity of the item with the provided SKU to the inventory. If the item already exists, increase its quantity by the given amount. 2. `remove_item(sku: str, quantity: int) -> bool`: Removes the given quantity of the item with the provided SKU from the inventory. If the item does not exist or there is not enough quantity to remove, the method should return `False`. Otherwise, it should return `True`. 3. `get_quantity(sku: str) -> int`: Returns the current quantity of the item with the provided SKU. If the item does not exist, return 0. Example: ```python inventory = Inventory() inventory.add_item(\\"A123\\", 10) inventory.add_item(\\"B456\\", 5) inventory.add_item(\\"A123\\", 5) print(inventory.get_quantity(\\"A123\\")) # Output: 15 print(inventory.get_quantity(\\"B456\\")) # Output: 5 print(inventory.get_quantity(\\"C789\\")) # Output: 0 print(inventory.remove_item(\\"A123\\", 3)) # Output: True print(inventory.get_quantity(\\"A123\\")) # Output: 12 print(inventory.remove_item(\\"B456\\", 10)) # Output: False print(inventory.get_quantity(\\"B456\\")) # Output: 5 ``` Requirements: 1. Your solution should handle up to 100,000 different items efficiently. 2. Ensure that the class methods are optimized for performance. Constraints: - The quantity of any item cannot be negative. - SKU (Stock Keeping Unit) numbers are unique strings. Note: - Make sure to handle edge cases, such as adding items not previously existing in the inventory and removing items in quantities greater than currently available.","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, sku: str, quantity: int) -> None: if sku in self.items: self.items[sku] += quantity else: self.items[sku] = quantity def remove_item(self, sku: str, quantity: int) -> bool: if sku in self.items and self.items[sku] >= quantity: self.items[sku] -= quantity if self.items[sku] == 0: del self.items[sku] return True return False def get_quantity(self, sku: str) -> int: return self.items.get(sku, 0)"},{"question":"# Coding Assessment Question **Context**: In this problem, you are asked to design an algorithm to balance a binary search tree (BST) which has a tendency to become skewed after a sequence of insertions and deletions. Perfectly balancing a BST ensures the optimal search time complexity of (O(log n)). Your task is to write a function `balance_bst` that accepts the root node of a BST and returns the root node of a balanced BST. You are required to utilize in-order traversal to collect the elements of the tree, and then use these elements to construct a balanced BST. # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def balance_bst(root: TreeNode) -> TreeNode: Balances an unbalanced binary search tree (BST). Args: root (TreeNode): The root node of the unbalanced BST. Returns: TreeNode: The root node of the balanced BST. ``` # Inputs * `root (TreeNode)`: The root node of the unbalanced BST. # Outputs * `TreeNode`: The root node of the balanced BST. # Constraints 1. The number of nodes in the tree is in the range [1, (10^4)]. 2. The value of each node is unique. 3. You cannot modify the original structure of the nodes, only rearrange their positions. # Examples 1. **Example 1**: * Input: ```python root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.right.right = TreeNode(20) ``` * `balance_bst(root)` * Returns: A balanced BST, for example: ``` 10 / 5 15 20 ``` 2. **Example 2**: * Input: ```python root = TreeNode(30) root.left = TreeNode(20) root.left.left = TreeNode(10) root.left.right = TreeNode(25) ``` * `balance_bst(root)` * Returns: A balanced BST, for example: ``` 25 / 20 30 / 10 ``` # Implementation Notes * You may need an auxiliary function to perform an in-order traversal and collect the elements into a list. * Another auxiliary function can be used to construct the balanced BST from this list. * Utilize a recursive approach to effectively build the balanced tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def balance_bst(root: TreeNode) -> TreeNode: Balances an unbalanced binary search tree (BST). Args: root (TreeNode): The root node of the unbalanced BST. Returns: TreeNode: The root node of the balanced BST. # Helper function to perform in-order traversal and collect nodes def inorder_traversal(node: TreeNode, result: list): if not node: return inorder_traversal(node.left, result) result.append(node.val) inorder_traversal(node.right, result) # Helper function to build a balanced BST from sorted list of nodes def build_balanced_bst(nodes: list, start: int, end: int) -> TreeNode: if start > end: return None mid = (start + end) // 2 node = TreeNode(nodes[mid]) node.left = build_balanced_bst(nodes, start, mid - 1) node.right = build_balanced_bst(nodes, mid + 1, end) return node # Perform in-order traversal to get sorted elements nodes = [] inorder_traversal(root, nodes) # Build the balanced BST from the sorted elements return build_balanced_bst(nodes, 0, len(nodes) - 1)"},{"question":"# Image Filter Application You are working as a software engineer in a company that focuses on image processing. Your task is to design and implement a function to apply a specific image filter to a grayscale image represented as a 2D list. The specific filter to be applied is a simple edge detection filter with the following kernel: ``` [[ -1, -1, -1 ], [ -1, 8, -1 ], [ -1, -1, -1 ]] ``` Your task involves the following steps: 1. **Implement Edge Detection Filter**: Write a function `apply_filter(image)` that: * Takes as input: * `image`, a 2D list of integers representing the pixel intensities of the grayscale image. Each integer is between 0 and 255, inclusive. * Returns: * A 2D list of integers representing the filtered image. The output image should also have pixel intensities in the range 0 to 255. 2. **Edge Handling**: For the sake of simplicity, you can assume that the input image has a padding of zeroes around it, so you do not need to handle the edges of the image specifically. 3. **Performance Requirements**: Your function should efficiently handle images of reasonable sizes (e.g., 512x512 pixels). **Input and Output Format:** Input: ```python image = [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ] ``` Output: ```python [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] ``` Your implementation must account for the following constraints and ensure it performs these operations correctly and efficiently. ```python def apply_filter(image): Apply an edge detection filter to a grayscale image. Args: image (list of list of int): 2D list representing the grayscale image. Returns: list of list of int: 2D list representing the filtered image. # Kernel Definition kernel = [ [-1, -1, -1], [-1, 8, -1], [-1, -1, -1] ] # Dimensions height = len(image) width = len(image[0]) # Initialize the output image with zeros filtered_image = [[0 for _ in range(width)] for _ in range(height)] # Apply the filter for i in range(1, height-1): for j in range(1, width-1): new_value = 0 for ki in range(3): for kj in range(3): new_value += image[i+ki-1][j+kj-1] * kernel[ki][kj] # Clip the value to be between 0 and 255 filtered_image[i][j] = max(0, min(255, new_value)) return filtered_image # Example usage (you can use this for testing your function): image = [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ] filtered_image = apply_filter(image) for row in filtered_image: print(row) # Expected output: # [0, 0, 0] # [0, 0, 0] # [0, 0, 0] ```","solution":"def apply_filter(image): Apply an edge detection filter to a grayscale image. Args: image (list of list of int): 2D list representing the grayscale image. Returns: list of list of int: 2D list representing the filtered image. # Kernel Definition kernel = [ [-1, -1, -1], [-1, 8, -1], [-1, -1, -1] ] # Dimensions height = len(image) width = len(image[0]) # Initialize the output image with zeros filtered_image = [[0 for _ in range(width)] for _ in range(height)] # Apply the filter for i in range(1, height-1): for j in range(1, width-1): new_value = 0 for ki in range(3): for kj in range(3): new_value += image[i+ki-1][j+kj-1] * kernel[ki][kj] # Clip the value to be between 0 and 255 filtered_image[i][j] = max(0, min(255, new_value)) return filtered_image # Example usage (you can use this for testing your function): image = [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ] filtered_image = apply_filter(image) for row in filtered_image: print(row) # Expected output: # [0, 0, 0] # [0, 0, 0] # [0, 0, 0]"},{"question":"# Coding Assessment Question You are a senior software developer responsible for enhancing a text processing library aimed at providing versatile string manipulation functionalities. Your task is to implement a function that performs various string operations efficiently. This will test your knowledge in string handling, regular expressions, and basic data structures. Write a function `string_operations(operation: str, data: list[str] | str, params: dict = {}) -> list[str] | str | int | bool` that performs one of the following operations based on the input parameters: 1. **Concatenation**: Concatenates a list of strings into one single string. 2. **Split**: Splits a string into a list of substrings based on a given delimiter. 3. **Find**: Finds the first occurrence of a substring in a string and returns its index. 4. **Count**: Counts the number of occurrences of a substring in a string. 5. **Replace**: Replaces all occurrences of a substring with another substring in a string. 6. **Length**: Returns the length of the string. 7. **Palindrome**: Checks if a string is a palindrome and returns a boolean value. Your function should handle the following inputs: * **operation**: A string specifying the operation, which can be \\"concat\\", \\"split\\", \\"find\\", \\"count\\", \\"replace\\", \\"length\\", or \\"palindrome\\". * **data**: A list of strings (for concatenation) or a single string for other operations. * **params**: An optional dictionary containing additional parameters required for the specific operation. Function Signature ```python def string_operations(operation: str, data: list[str] | str, params: dict = {}) -> list[str] | str | int | bool: pass ``` Input Conditions and Prechecks * For concatenation, data should be a list of non-empty strings. * For split operation, params should contain a \'delimiter\' key with a valid delimiter string. * For find, count, and replace operations, params should contain the key \'substring\' (and \'new_string\' for replace). * The length operation requires no additional parameters. * The palindrome operation should disregard case and whitespace when determining if the string is a palindrome. Expected Output Depending on the operation, the function should return: * A single string for concatenation and replace operations. * A list of strings for the split operation. * An integer for the find, count, and length operations. * A boolean for the palindrome operation. Example Usage ```python # Concatenation of strings print(string_operations(\\"concat\\", [\\"hello\\", \\" \\", \\"world\\"])) # Output: \\"hello world\\" # Split the string by a delimiter print(string_operations(\\"split\\", \\"hello world today\\", {\\"delimiter\\": \\" \\"})) # Output: [\\"hello\\", \\"world\\", \\"today\\"] # Find the position of a substring print(string_operations(\\"find\\", \\"hello world\\", {\\"substring\\": \\"world\\"})) # Output: 6 # Count occurrences of a substring print(string_operations(\\"count\\", \\"hello world\\", {\\"substring\\": \\"lo\\"})) # Output: 1 # Replace substring in a string print(string_operations(\\"replace\\", \\"hello world\\", {\\"substring\\": \\"world\\", \\"new_string\\": \\"there\\"})) # Output: \\"hello there\\" # Get length of the string print(string_operations(\\"length\\", \\"hello world\\")) # Output: 11 # Check if a string is a palindrome print(string_operations(\\"palindrome\\", \\"A Santa at NASA\\")) # Output: True ``` Ensure your implementation is well-optimized and thoroughly tested for correctness and performance.","solution":"def string_operations(operation: str, data: list[str] | str, params: dict = {}) -> list[str] | str | int | bool: Perform various string operations based on the specified operation. Args: - operation: a string specifying the operation (\\"concat\\", \\"split\\", \\"find\\", \\"count\\", \\"replace\\", \\"length\\", \\"palindrome\\"). - data: a list of strings for concatenation or a single string for other operations. - params: optional dictionary containing additional parameters required for the operation. Returns: - Depending on the operation: a single string, list of strings, integer, or boolean. if operation == \\"concat\\" and isinstance(data, list): return \'\'.join(data) elif operation == \\"split\\" and isinstance(data, str): delimiter = params.get(\'delimiter\', \' \') return data.split(delimiter) elif operation == \\"find\\" and isinstance(data, str): substring = params.get(\'substring\', \'\') return data.find(substring) elif operation == \\"count\\" and isinstance(data, str): substring = params.get(\'substring\', \'\') return data.count(substring) elif operation == \\"replace\\" and isinstance(data, str): substring = params.get(\'substring\', \'\') new_string = params.get(\'new_string\', \'\') return data.replace(substring, new_string) elif operation == \\"length\\" and isinstance(data, str): return len(data) elif operation == \\"palindrome\\" and isinstance(data, str): filtered_data = \'\'.join(filter(str.isalnum, data)).lower() return filtered_data == filtered_data[::-1] else: raise ValueError(\\"Invalid operation or data type\\")"},{"question":"**Context**: You have been given the task of building a system to manage bank accounts. The system should be capable of creating accounts, depositing and withdrawing money, and transferring money between accounts. Each account will have a unique identifier, and the balance for each account should be maintained. The system should ensure that no account goes into a negative balance. **Task**: 1. Implement a class `BankAccountSystem` that provides the necessary functions to manage the bank accounts. 2. Implement functions `create_account`, `deposit`, `withdraw`, and `transfer`. # Class Definition ```python class BankAccountSystem: def __init__(self): Initializes the bank account system with an empty dictionary to store accounts and their balances. self.accounts = {} def create_account(self, account_id: str) -> None: Creates a new account with the given account_id and initializes its balance to 0. :param account_id: The unique identifier for the account. if account_id in self.accounts: raise ValueError(\\"Account ID already exists.\\") self.accounts[account_id] = 0 def deposit(self, account_id: str, amount: float) -> None: Deposits the given amount into the specified account. :param account_id: The unique identifier for the account. :param amount: The amount to deposit. if account_id not in self.accounts: raise ValueError(\\"Account ID does not exist.\\") if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.accounts[account_id] += amount def withdraw(self, account_id: str, amount: float) -> None: Withdraws the given amount from the specified account. :param account_id: The unique identifier for the account. :param amount: The amount to withdraw. if account_id not in self.accounts: raise ValueError(\\"Account ID does not exist.\\") if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if self.accounts[account_id] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[account_id] -= amount def transfer(self, from_account_id: str, to_account_id: str, amount: float) -> None: Transfers the given amount from one account to another. :param from_account_id: The unique identifier for the account to transfer from. :param to_account_id: The unique identifier for the account to transfer to. :param amount: The amount to transfer. if from_account_id not in self.accounts: raise ValueError(\\"From account ID does not exist.\\") if to_account_id not in self.accounts: raise ValueError(\\"To account ID does not exist.\\") if amount <= 0: raise ValueError(\\"Transfer amount must be positive.\\") if self.accounts[from_account_id] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[from_account_id] -= amount self.accounts[to_account_id] += amount ``` # Example Usage: ```python # Creating an instance of the BankAccountSystem bank = BankAccountSystem() # Creating accounts bank.create_account(\'acc1\') bank.create_account(\'acc2\') # Making deposits bank.deposit(\'acc1\', 1000) bank.deposit(\'acc2\', 500) # Performing withdrawals bank.withdraw(\'acc1\', 200) # Transferring money bank.transfer(\'acc1\', \'acc2\', 300) # Checking balances print(bank.accounts) # Output should be: {\'acc1\': 500, \'acc2\': 800} ``` # Constraints: 1. Account identifiers will be non-empty strings and unique. 2. Amounts for deposit, withdraw, and transfer will be non-negative floats. 3. All balances and transactions will be conducted in the same currency. # Notes: - Ensure to handle the edge cases where an account might not have sufficient balance for a withdrawal or transfer. - Raise appropriate errors for invalid operations (e.g., creating an account with an existing ID, depositing a non-positive amount).","solution":"class BankAccountSystem: def __init__(self): Initializes the bank account system with an empty dictionary to store accounts and their balances. self.accounts = {} def create_account(self, account_id: str) -> None: Creates a new account with the given account_id and initializes its balance to 0. :param account_id: The unique identifier for the account. if account_id in self.accounts: raise ValueError(\\"Account ID already exists.\\") self.accounts[account_id] = 0 def deposit(self, account_id: str, amount: float) -> None: Deposits the given amount into the specified account. :param account_id: The unique identifier for the account. :param amount: The amount to deposit. if account_id not in self.accounts: raise ValueError(\\"Account ID does not exist.\\") if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.accounts[account_id] += amount def withdraw(self, account_id: str, amount: float) -> None: Withdraws the given amount from the specified account. :param account_id: The unique identifier for the account. :param amount: The amount to withdraw. if account_id not in self.accounts: raise ValueError(\\"Account ID does not exist.\\") if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if self.accounts[account_id] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[account_id] -= amount def transfer(self, from_account_id: str, to_account_id: str, amount: float) -> None: Transfers the given amount from one account to another. :param from_account_id: The unique identifier for the account to transfer from. :param to_account_id: The unique identifier for the account to transfer to. :param amount: The amount to transfer. if from_account_id not in self.accounts: raise ValueError(\\"From account ID does not exist.\\") if to_account_id not in self.accounts: raise ValueError(\\"To account ID does not exist.\\") if amount <= 0: raise ValueError(\\"Transfer amount must be positive.\\") if self.accounts[from_account_id] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[from_account_id] -= amount self.accounts[to_account_id] += amount"},{"question":"# Coding Assessment Question Scenario: You are building a system that needs to process text data and determine various properties about the words it contains. One such property is identifying whether a word is a palindrome or not. A palindrome is a word that reads the same forward and backward, ignoring case. Task: Write a Python function `is_palindrome(word: str) -> bool` that: * Takes a single string `word` which represents a word. * Determines if the word is a palindrome, ignoring case. * Returns `True` if the word is a palindrome, otherwise returns `False`. # Specifications: * **Input**: A single string `word`, with a maximum length of 1000 characters. * **Output**: A boolean value, `True` if the word is a palindrome and `False` otherwise. # Constraints: * The input string will only contain alphabetic characters. * The function should be case insensitive, i.e., \\"Madam\\" is considered a palindrome. Example Inputs and Outputs: 1. `is_palindrome(\\"racecar\\")` should return `True` 2. `is_palindrome(\\"Madam\\")` should return `True` 3. `is_palindrome(\\"hello\\")` should return `False` 4. `is_palindrome(\\"noon\\")` should return `True` # Edge Cases: 1. If the input is an empty string `\\"\\"`, it should return `True` because an empty string is considered a valid palindrome. 2. A single character string should also return `True` since it reads the same forward and backward. # Example Error Handling: 1. `is_palindrome(\\"\\")` should return `True`. 2. `is_palindrome(\\"a\\")` should return `True`. # Note: Ensure your function handles case insensitivity and optimally checks for palindrome properties given the constraints.","solution":"def is_palindrome(word: str) -> bool: Determines if the given word is a palindrome, ignoring case. Parameters: word (str): Input word to check Returns: bool: True if the word is a palindrome, False otherwise # Convert the word to lowercase to make the comparison case insensitive word = word.lower() # Reverse the word and compare it to the original return word == word[::-1]"},{"question":"# Data Processing and Visualization with Real-Time Updates Develop a data processing and visualization application that continuously reads data from a sensor, processes the data to compute real-time statistics, and updates a graphical plot displaying the processed data. Requirements: 1. **Data Acquisition**: Create a function, `read_sensor_data`, which reads data from a given sensor at regular intervals. 2. **Data Processing**: Implement a function, `compute_statistics`, to process the sensor data and compute real-time averages every minute. 3. **Data Visualization**: Develop a function, `update_plot`, to visualize the processed data on a real-time updating plot/graph. 4. **Efficiency and Performance**: Ensure that data reading, processing, and visualization are handled efficiently without significant delays. 5. **Error Handling**: Implement robust error handling strategies to manage scenarios like sensor disconnection, data corruption, and visualization errors gracefully. Technical Specifications: * **Input (Data Acquisition)**: `sensor_port` (int), `interval` (int) - interval in seconds between successive data reads. * **Output (Data Acquisition)**: Returns a list of data points read from the sensor. * **Input (Data Processing)**: `data` (list), `duration` (int) - duration in seconds for which statistics are computed. * **Output (Data Processing)**: Returns real-time statistics (e.g., average, variance) computed over the specified duration. * **Input (Data Visualization)**: `statistics` (dict), `plot_refresh_interval` (int) - interval in seconds for updating the plot. * **Output (Data Visualization)**: Updates the graphical plot in real-time. # Example **Data Acquisition (read_sensor_data example usage):** ```python def read_sensor_data(sensor_port: int, interval: int) -> list: # Implementation here if __name__ == \\"__main__\\": sensor_data = read_sensor_data(sensor_port=4, interval=5) # Reads data every 5 seconds ``` **Data Processing (compute_statistics example usage):** ```python def compute_statistics(data: list, duration: int) -> dict: # Implementation here if __name__ == \\"__main__\\": sensor_data_statistics = compute_statistics(data=sensor_data, duration=60) # Computes stats every minute ``` **Data Visualization (update_plot example usage):** ```python def update_plot(statistics: dict, plot_refresh_interval: int) -> None: # Implementation here if __name__ == \\"__main__\\": update_plot(statistics=sensor_data_statistics, plot_refresh_interval=10) # Updates plot every 10 seconds ``` **Constraints:** * The sensor data must be read at specified regular intervals. * Real-time statistics should be computed over the defined duration to reflect ongoing trends. * The graphical plot must automatically update at the designated refresh interval. * Implement comprehensive error handling to ensure the application can manage failures effectively without crashing.","solution":"import time import random import matplotlib.pyplot as plt from threading import Thread, Lock # Multi-threading lock for synchronization data_lock = Lock() # Global variable to store sensor data sensor_data = [] # Function to read sensor data def read_sensor_data(sensor_port: int, interval: int) -> None: Reads data from the sensor at regular intervals and stores it in a global list. Args: sensor_port (int): Port number of the sensor. interval (int): Interval in seconds between successive data reads. global sensor_data while True: try: # Simulate sensor data reading data_point = random.uniform(20.0, 25.0) with data_lock: sensor_data.append(data_point) time.sleep(interval) except Exception as e: print(f\\"Error reading sensor data: {e}\\") break # Function to compute statistics def compute_statistics(data: list, duration: int) -> dict: Computes real-time statistics of the data provided over the given duration. Args: data (list): List of data points. duration (int): Duration in seconds for which statistics are computed. Returns: dict: A dictionary containing the computed statistics. with data_lock: if len(data) == 0: return {\\"average\\": None, \\"variance\\": None} recent_data = data[-duration:] if len(recent_data) == 0: return {\\"average\\": None, \\"variance\\": None} average = sum(recent_data) / len(recent_data) variance = sum((x - average) ** 2 for x in recent_data) / len(recent_data) return {\\"average\\": average, \\"variance\\": variance} # Function to update plot def update_plot(statistics: dict, plot_refresh_interval: int) -> None: Updates the graphical plot with the provided statistics at regular intervals. Args: statistics (dict): Dictionary containing the statistics to plot. plot_refresh_interval (int): Interval in seconds for refreshing the plot. plt.ion() fig, ax = plt.subplots() averages = [] variances = [] while True: try: averages.append(statistics[\\"average\\"]) variances.append(statistics[\\"variance\\"]) ax.clear() ax.plot(averages, label=\'Average\') ax.plot(variances, label=\'Variance\') ax.legend() plt.pause(plot_refresh_interval) except Exception as e: print(f\\"Error updating plot: {e}\\") break if __name__ == \\"__main__\\": sensor_port = 4 read_interval = 1 compute_duration = 60 plot_refresh_interval = 10 # Start sensor data reading thread sensor_thread = Thread(target=read_sensor_data, args=(sensor_port, read_interval)) sensor_thread.start() # Continuously compute statistics and update plot while True: statistics = compute_statistics(sensor_data, compute_duration) update_plot(statistics, plot_refresh_interval)"},{"question":"# Coding Assessment Question Context In this task, you need to generate combinations from a given list of integers. Combinations are useful in various fields including statistics, algorithms, data analysis, and more. Understanding how to generate all combinations of a given length is essential for solving problems that involve subsets and permutations. Problem Write a Python function `generate_combinations(lst, k)` that generates all possible combinations of length `k` from the given list `lst`. The function should return a list of tuples, where each tuple is a combination of `k` elements from `lst`. Expected Input and Output * **Input**: - `lst` (list of int): A list of integers. - `k` (int): The length of each combination to generate. `0 <= k <= len(lst)` * **Output**: - Returns a list of tuples, each tuple containing a combination of `k` elements from `lst`. Constraints * The order of combinations in the list does not matter. * If `k` is 0, return a list containing an empty tuple. * If `k` is greater than the length of `lst`, return an empty list. Performance Requirements * Your solution should efficiently handle lists with up to 15 elements (`len(lst) <= 15`). Example ```python def generate_combinations(lst: list[int], k: int) -> list[tuple[int]]: Generates all possible combinations of length k from the list lst. :param lst: List of integers. :param k: Length of combinations to generate. :return: List of tuples, each tuple representing a combination of k elements from lst. >>> generate_combinations([1, 2, 3], 2) [(1, 2), (1, 3), (2, 3)] >>> generate_combinations([1, 2, 3], 0) [()] >>> generate_combinations([1, 2, 3], 4) [] # TODO: Implement this function pass # Test the function with various values of lst and k print(generate_combinations([1, 2, 3], 2)) # Output should be [(1, 2), (1, 3), (2, 3)] print(generate_combinations([4, 5, 6, 7], 3)) # Output should be [(4, 5, 6), (4, 5, 7), (4, 6, 7), (5, 6, 7)] print(generate_combinations([1, 2, 3], 0)) # Output should be [()] ``` Your solution should demonstrate: * Effective algorithm for generating combinations. * Handling of edge cases such as k=0 and k > len(lst). * Proper usage of Python data structures and functions.","solution":"from itertools import combinations def generate_combinations(lst, k): Generates all possible combinations of length k from the list lst. :param lst: List of integers. :param k: Length of combinations to generate. :return: List of tuples, each tuple representing a combination of k elements from lst. if k < 0 or k > len(lst): return [] return list(combinations(lst, k))"},{"question":"# String Compression Background You are working on a system that handles large amounts of text data. To optimize storage and transmission, you want to implement a basic string compression algorithm that simplifies repeated characters in a string. Task Implement the `compress` method in the provided `StringCompressor` class. This method should compress a string by replacing consecutive repeated characters with the character followed by the number of occurrences. If the compressed version of the string is not shorter than the original, the method should return the original string. Requirements - Implement the `compress` method in a class, `StringCompressor`. - The `compress` method should take a single string as input and return the compressed version of the string. Compression Description The compression algorithm can be described as follows: 1. Traverse the string and count consecutive repeated characters. 2. Replace each sequence of repeated characters with the character followed by the count. 3. If the compressed string is not shorter than the original string, return the original string. Input - A single input string: `str` Output - The compressed string or the original string if the compressed version is not shorter: `str` Example Usage ```python class StringCompressor: def compress(self, s: str) -> str: if not s: return s compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s # Example: Compressing the string compressor = StringCompressor() print(compressor.compress(\\"aabcccccaaa\\")) # Output: \\"a2b1c5a3\\" print(compressor.compress(\\"abcd\\")) # Output: \\"abcd\\" ``` Constraints - Ensure that the method is efficient and handles edge cases where the string might be empty or consist of a single character. - The input string will only contain uppercase and lowercase English letters (a-z, A-Z). Good luck!","solution":"class StringCompressor: def compress(self, s: str) -> str: if not s: return s compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"# Problem Statement Implement a `SparseMatrix` class that can handle basic operations for sparse matrices efficiently. Sparse matrices are matrices in which most of the elements are zero. This class should specially store only the non-zero elements to save space. Enhance this class by adding functionalities to perform matrix addition, subtraction, and multiplication. # Requirements 1. **Class to Implement**: `SparseMatrix` 2. **Functions to Add**: - `add(self, other: \'SparseMatrix\') -> \'SparseMatrix\'`: Adds two sparse matrices. - `subtract(self, other: \'SparseMatrix\') -> \'SparseMatrix\'`: Subtracts `other` matrix from this matrix. - `multiply(self, other: \'SparseMatrix\') -> \'SparseMatrix\'`: Multiplies two sparse matrices. 3. **Input**: Two `SparseMatrix` objects of size ( m times n ) and ( n times p ) respectively for multiplication, and the same size for addition and subtraction where ( m, n, p geq 1 ). 4. **Output**: A `SparseMatrix` object representing the result of the operation. 5. **Performance**: Aim for efficient operations, leveraging the sparsity of the matrices. 6. **Constraints**: Ensure proper size alignment for matrix multiplication. Raise appropriate exceptions for dimension mismatches. # Example ```python a = SparseMatrix(3, 3) a.set(0, 0, 1) a.set(1, 1, 2) a.set(2, 2, 3) b = SparseMatrix(3, 3) b.set(0, 0, 4) b.set(1, 1, 5) b.set(2, 2, 6) # Addition c = a.add(b) print(c.to_dense()) # Output: # [[ 5 0 0] # [ 0 7 0] # [ 0 0 9]] # Subtraction d = a.subtract(b) print(d.to_dense()) # Output: # [[ -3 0 0] # [ 0 -3 0] # [ 0 0 -3]] # Multiplication e = a.multiply(b) print(e.to_dense()) # Output: # [[ 4 0 0] # [ 0 10 0] # [ 0 0 18]] ``` # Notes - The `set(row, col, value)` method is used to set the value of a specific element in the matrix. - Implement a method `to_dense()` for easier display, which converts the sparse matrix to a dense matrix format (2D list of lists). - Store only non-zero elements internally, possibly using a dictionary with keys as (row, col) tuples. - Handle edge cases such as adding two matrices with mismatched dimensions or performing operations with one or both matrices being entirely zero (empty).","solution":"class SparseMatrix: def __init__(self, rows, cols): self.rows = rows self.cols = cols self.elements = {} # Dictionary to store non-zero elements def set(self, row, col, value): if value != 0: self.elements[(row, col)] = value elif (row, col) in self.elements: del self.elements[(row, col)] def get(self, row, col): return self.elements.get((row, col), 0) def to_dense(self): dense_matrix = [[0] * self.cols for _ in range(self.rows)] for (row, col), value in self.elements.items(): dense_matrix[row][col] = value return dense_matrix def add(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrix dimensions must match for addition.\\") result = SparseMatrix(self.rows, self.cols) all_keys = set(self.elements.keys()).union(other.elements.keys()) for key in all_keys: sum_value = self.get(*key) + other.get(*key) result.set(key[0], key[1], sum_value) return result def subtract(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrix dimensions must match for subtraction.\\") result = SparseMatrix(self.rows, self.cols) all_keys = set(self.elements.keys()).union(other.elements.keys()) for key in all_keys: diff_value = self.get(*key) - other.get(*key) result.set(key[0], key[1], diff_value) return result def multiply(self, other): if self.cols != other.rows: raise ValueError(\\"Matrix dimensions must match for multiplication.\\") result = SparseMatrix(self.rows, other.cols) for (i, k), v in self.elements.items(): for j in range(other.cols): result.set(i, j, result.get(i, j) + v * other.get(k, j)) return result"},{"question":"# Coding Assessment: Genetic Algorithm for TSP Problem Statement You are provided with an implementation of a Genetic Algorithm (GA) for the Traveling Salesman Problem (TSP). Your task is to implement a similar optimization algorithm but for a multi-objective optimization problem. Objectives 1. Implement a `genetic_algorithm_multi_objective` function that optimizes a given set of objectives. 2. Your implementation should return a Pareto front of solutions. 3. Implement a `MultiObjectiveProblem` class with appropriate methods to support the optimization process. Input - **Objectives**: A list of functions `f1, f2, ..., fn` that each take a solution representation and return a floating-point value. - **Initial Population**: A list of initial candidate solutions. - **Mutation and Crossover Rates**: The probabilities of mutation and crossover in the population. - **Algorithm Parameters**: Number of generations, population size, and selection method. Output - A Pareto front of non-dominated solutions. # Constraints 1. **Class Implementation**: Your `MultiObjectiveProblem` class must have the following methods: - `__init__(self, objectives: List[Callable], population: List[Any], mutation_rate: float, crossover_rate: float)` - `mutate(self, solution: Any) -> Any` - `crossover(self, solution1: Any, solution2: Any) -> Tuple[Any, Any]` - `evaluate(self, solution: Any) -> List[float]` 2. **Genetic Algorithm**: Your `genetic_algorithm_multi_objective` function must have the following signature: ```python def genetic_algorithm_multi_objective( problem: MultiObjectiveProblem, generations: int, population_size: int, selection_method: str = \\"tournament\\" ) -> List[Any]: ``` 3. **Performance Requirement**: Your implementation should efficiently converge to a diverse Pareto front of optimal or near-optimal solutions. # Example Usage ```python # Define sample objective functions def objective1(solution): # some function to minimize return sum(x**2 for x in solution) def objective2(solution): # some function to minimize return sum((x-2)**2 for x in solution) # Create initial population initial_population = [[random.uniform(-10, 10) for _ in range(3)] for _ in range(50)] # Define the multi-objective problem multi_obj_prob = MultiObjectiveProblem( objectives=[objective1, objective2], population=initial_population, mutation_rate=0.01, crossover_rate=0.8 ) # Perform multi-objective genetic algorithm pareto_front = genetic_algorithm_multi_objective( multi_obj_prob, generations=100, population_size=50, selection_method=\\"tournament\\" ) for solution in pareto_front: print(f\\"Solution: {solution}, Objectives: {multi_obj_prob.evaluate(solution)}\\") ``` Ensure your function is well-tested with various multi-objective functions to validate its correctness and performance.","solution":"import random from typing import List, Callable, Any, Tuple class MultiObjectiveProblem: def __init__(self, objectives: List[Callable], population: List[Any], mutation_rate: float, crossover_rate: float): self.objectives = objectives self.population = population self.mutation_rate = mutation_rate self.crossover_rate = crossover_rate def mutate(self, solution: Any) -> Any: Mutate the solution based on mutation rate. if random.random() < self.mutation_rate: index = random.randint(0, len(solution) - 1) solution[index] = random.uniform(-10, 10) return solution def crossover(self, solution1: Any, solution2: Any) -> Tuple[Any, Any]: Perform crossover between two solutions. if random.random() < self.crossover_rate: point = random.randint(1, len(solution1) - 1) new_solution1 = solution1[:point] + solution2[point:] new_solution2 = solution2[:point] + solution1[point:] return new_solution1, new_solution2 else: return solution1, solution2 def evaluate(self, solution: Any) -> List[float]: Evaluate the solution based on the objectives. return [objective(solution) for objective in self.objectives] def dominates(solution1: List[float], solution2: List[float]) -> bool: Check if solution1 dominates solution2. return all(x <= y for x, y in zip(solution1, solution2)) and any(x < y for x, y in zip(solution1, solution2)) def genetic_algorithm_multi_objective( problem: MultiObjectiveProblem, generations: int, population_size: int, selection_method: str = \\"tournament\\" ) -> List[Any]: def tournament_selection(population: List[Any], k: int = 3) -> Any: tournament = random.sample(population, k) tournament.sort(key=lambda sol: problem.evaluate(sol)) return tournament[0] def pareto_front(population: List[Any]) -> List[Any]: front = [] for solution in population: if not any(dominates(problem.evaluate(other), problem.evaluate(solution)) for other in population): front.append(solution) return front population = problem.population for generation in range(generations): new_population = [] while len(new_population) < population_size: parent1 = tournament_selection(population) parent2 = tournament_selection(population) child1, child2 = problem.crossover(parent1, parent2) child1 = problem.mutate(child1) child2 = problem.mutate(child2) new_population.append(child1) new_population.append(child2) population = new_population population = sorted(population, key=lambda sol: problem.evaluate(sol))[:population_size] return pareto_front(population)"},{"question":"# Coding Problem: A certain software system maintains logs of user login activities in a sequential list. Each entry in the list represents the login of a user with their unique User ID. Unfortunately, the logs contain multiple duplicates. To help the system administrators, you need to identify the most frequent User ID that appears in the logs and the number of times it appeared. Problem Statement: Given a list of integers representing user login activities, implement a function `most_frequent_user(logs: List[int]) -> Tuple[int, int]` to identify the User ID that appears the most in the logs and return a tuple containing this User ID and its count. # Function Signature: ```python def most_frequent_user(logs: List[int]) -> Tuple[int, int]: ``` # Input: - A list of integers `logs` (1 ≤ len(logs) ≤ 10000), each representing a User ID in the log entries. # Output: - A tuple of two integers, where the first integer is the User ID that appears the most frequently in the logs, and the second integer is the count of how many times this User ID appears. # Constraints: - Assume that the User IDs are positive integers. - If multiple User IDs are tied for the most appearances, return any one of them. - Use built-in data structures and methods if necessary to efficiently count appearances. # Example: ```python assert most_frequent_user([1, 2, 2, 3, 3, 3]) == (3, 3) assert most_frequent_user([4, 4, 4, 4, 3, 3, 2, 2, 1, 1]) == (4, 4) assert most_frequent_user([7, 8, 7, 9, 7, 9, 7]) == (7, 4) ``` # Detailed Requirements: * Create an efficient solution that processes the list in a single traversal or linear time complexity where possible. * Use appropriate data structures to store and find the frequency counts of User IDs. # Performance Requirements: * Your solution should handle the list lengths up to 10,000 efficiently. # Example Scenario: Given the logs list `[10, 20, 20, 30, 30, 30]`, it processes as: 1. `10` appears once. 2. `20` appears twice. 3. `30` appears three times. Thus, the output would be `(30, 3)` indicating that User ID `30` appears most frequently, 3 times. Good luck!","solution":"from typing import List, Tuple from collections import Counter def most_frequent_user(logs: List[int]) -> Tuple[int, int]: Identifies the User ID that appears the most frequently in the logs and returns it along with the count of its appearances. if not logs: return (None, 0) # Utilize Counter to count the frequency of each UserId in the logs counter = Counter(logs) # Find the most common UserId and its count most_common_user = counter.most_common(1)[0] return most_common_user"},{"question":"# Coding Assessment Task: Data Analysis on Weather Data Context You work for a meteorological department that analyzes weather data to predict patterns and inform the public. Your task is to process a dataset and extract meaningful insights such as the average temperature for each month. Task Write a Python function `average_monthly_temperature(data: List[Dict[str, str]]) -> Dict[str, float]` that: 1. Takes a list of dictionaries where each dictionary represents daily weather data with keys \\"date\\" (in \\"YYYY-MM-DD\\" format) and \\"temperature\\" (as a string representing a float value). 2. Calculates the average temperature for each month present in the dataset. 3. Returns a dictionary where keys are months in \\"YYYY-MM\\" format and values are the average temperatures for those months. Input Format - `data` (List[Dict[str, str]]): A list of dictionaries representing daily weather data. Output Format - A dictionary with months as keys (in \\"YYYY-MM\\" format) and their corresponding average temperatures as float values. Constraints - The input list will have at least one element. - Ensure the temperature values in the output are rounded to two decimal places. - Assume the input data is not empty and contains valid date and temperature entries. Example ```python >>> data = [ {\\"date\\": \\"2023-01-01\\", \\"temperature\\": \\"5.1\\"}, {\\"date\\": \\"2023-01-02\\", \\"temperature\\": \\"6.3\\"}, {\\"date\\": \\"2023-02-01\\", \\"temperature\\": \\"7.8\\"}, {\\"date\\": \\"2023-02-02\\", \\"temperature\\": \\"8.1\\"} ] >>> average_monthly_temperature(data) {\'2023-01\': 5.7, \'2023-02\': 7.95} ``` Performance Requirements - The function should process the data efficiently, even for larger datasets. Notes - You can use the datetime module to parse and handle dates. - Ensure the function gracefully handles any edge cases, such as missing data or format errors.","solution":"from collections import defaultdict from typing import List, Dict import datetime def average_monthly_temperature(data: List[Dict[str, str]]) -> Dict[str, float]: monthly_temps = defaultdict(list) for record in data: date = record[\'date\'] temperature = float(record[\'temperature\']) month = date[:7] # Extract YYYY-MM part of the date monthly_temps[month].append(temperature) average_temps = {} for month, temps in monthly_temps.items(): average_temps[month] = round(sum(temps) / len(temps), 2) return average_temps"},{"question":"# Question: KMP String Matching Algorithm Context: You are developing a text editor and need to implement a search feature that allows users to quickly find occurrences of a keyword within a large document. To achieve efficient search, you will use the Knuth-Morris-Pratt (KMP) algorithm, which provides a linear-time solution for the string matching problem. Task: Implement the function `kmp_search(pattern, text)` that returns a list of starting indices where the `pattern` is found in the `text`. The function should utilize the KMP algorithm to achieve efficient searching by preprocessing the `pattern` to create a partial match table (also known as the \\"lps\\" array). Function Signature: ```python def kmp_search(pattern: str, text: str) -> List[int]: pass ``` Input: - `pattern`: A string `pattern` representing the keyword to search for. - `text`: A string `text` representing the document in which to search for the `pattern`. Output: - A list of integers representing the starting indices of each occurrence of the `pattern` in the `text`. Constraints: - `1 <= len(pattern) <= 100` - `1 <= len(text) <= 10^4` - The `pattern` and `text` only contain lowercase English letters. Example: ```python pattern = \\"ababc\\" text = \\"ababcabcababc\\" assert kmp_search(pattern, text) == [0, 8] ``` Notes: - Ensure that the implementation is optimized for time complexity by preprocessing the `pattern` to create the \\"lps\\" (longest prefix suffix) array. - Handle edge cases such as an empty `pattern` or `text`, and when the `pattern` is not found in the `text`. - The function should be robust against overlapping occurrences.","solution":"from typing import List def kmp_search(pattern: str, text: str) -> List[int]: def compute_lps_array(pattern: str) -> List[int]: m = len(pattern) lps = [0] * m length = 0 # Length of the previous longest prefix suffix i = 1 while i < m: if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps n = len(text) m = len(pattern) lps = compute_lps_array(pattern) result = [] i = 0 # Index for text j = 0 # Index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Array Manipulation: In-Place Reversal Background In computer science, an array is a fundamental data structure consisting of a collection of elements, each identified by at least one array index. Reversing an array is a common operation, where the elements of the array are reversed such that the first element becomes the last, and so on. Task Write a function `reverse_array(arr: List[int]) -> List[int]` that takes an array of integers and reverses the array in-place, meaning you should not use additional storage for another array. Input - `arr`: A list of integers. Output - Returns the same list of integers with the elements in reversed order. Constraints - The function should modify the list in-place. - The elements of the array will be integers. - The input list can be of any length (including 0, an empty list). Example ```python >>> reverse_array([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> reverse_array([7, 6, 5]) [5, 6, 7] >>> reverse_array([]) [] ``` Additional Notes - You are not allowed to use any built-in functions that automatically reverse the list (e.g., `reverse()`, slicing). - Ensure that your implementation handles any edge cases (such as an empty list) gracefully. Your task is to implement this `reverse_array` function correctly and efficiently.","solution":"from typing import List def reverse_array(arr: List[int]) -> List[int]: Reverses the array in-place. Parameters: arr (List[int]): A list of integers. Returns: List[int]: The same list with elements in reversed order. start, end = 0, len(arr) - 1 while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 return arr"},{"question":"Question: Binary Tree Depth Calculation and Node Counting # Background You are working on a task that involves processing binary trees, which are a crucial data structure in computer science. Your goal is to enhance your library by adding functionalities for calculating the depth of the binary tree and counting the number of nodes. # Task Modify the provided `BinaryTree` class to: 1. **Add Depth Calculation**: - Implement a method to calculate the depth of the binary tree. The depth (or height) of a binary tree is the number of edges on the longest path from the root node to a leaf node. 2. **Implement Node Counting**: - Implement a method to count the number of nodes in the binary tree. # Specifications 1. **Depth Calculation**: - Implement `get_depth()` method in the `BinaryTree` class to compute the depth of the binary tree. 2. **Node Counting**: - Implement `count_nodes()` method in the `BinaryTree` class to count the total number of nodes in the binary tree. # Requirements - **Input**: - The `BinaryTree` class should be initialized and have the binary tree properly constructed using the existing methods. - The `get_depth` method takes no arguments. - The `count_nodes` method takes no arguments. - **Output**: - `get_depth` method should return an integer representing the depth of the binary tree. - `count_nodes` method should return an integer representing the total number of nodes in the binary tree. - **Constraints**: - Consider binary trees with up to 10,000 nodes. - Ensure accuracy and efficiency of the implemented methods for large datasets. # Example ```python # Example usage: class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add_node(self, value): if self.root is None: self.root = TreeNode(value) else: self._add_node_recursive(self.root, value) def _add_node_recursive(self, current, value): if value < current.value: if current.left is None: current.left = TreeNode(value) else: self._add_node_recursive(current.left, value) else: if current.right is None: current.right = TreeNode(value) else: self._add_node_recursive(current.right, value) def get_depth(self): def depth(node): if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(self.root) def count_nodes(self): def count(node): if not node: return 0 left_count = count(node.left) right_count = count(node.right) return left_count + right_count + 1 return count(self.root) # Example usage: bt = BinaryTree() bt.add_node(3) bt.add_node(1) bt.add_node(4) bt.add_node(2) print(bt.get_depth()) # Output: 3 print(bt.count_nodes()) # Output: 4 ``` # Evaluation - Ensure your code efficiently handles large binary trees. - Correctly calculate the depth of the binary tree. - Accurately count the number of nodes in the binary tree.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add_node(self, value): if self.root is None: self.root = TreeNode(value) else: self._add_node_recursive(self.root, value) def _add_node_recursive(self, current, value): if value < current.value: if current.left is None: current.left = TreeNode(value) else: self._add_node_recursive(current.left, value) else: if current.right is None: current.right = TreeNode(value) else: self._add_node_recursive(current.right, value) def get_depth(self): def depth(node): if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(self.root) def count_nodes(self): def count(node): if not node: return 0 left_count = count(node.left) right_count = count(node.right) return left_count + right_count + 1 return count(self.root)"},{"question":"# Conway\'s Game of Life with Custom Initial State You are given a skeleton code to simulate Conway\'s Game of Life, which is a cellular automaton where cells evolve based on their neighbors\' states. The board is represented as a 2D grid of cells that are either alive (1) or dead (0). Cells evolve according to the following rules: - Any live cell with fewer than two or more than three live neighbors dies. - Any live cell with two or three live neighbors lives on. - Any dead cell with exactly three live neighbors becomes a live cell. Task Complete the provided code by implementing a function named `next_generation` which calculates the next state of the board from the current state. Additionally, allow users to input a custom initial state for the grid. Create a function named `initialize_board` which accepts a 2D list representing the given custom initial state and a board size parameter. Extend the simulation to handle edge wrapping, where cells at the edge of the grid should wrap around to the opposite edge when counting neighbors. Function Signatures ```python def next_generation(board: list[list[int]]) -> list[list[int]]: pass def initialize_board(custom_state: list[list[int]], board_size: tuple[int, int]) -> list[list[int]]: pass ``` Constraints 1. `board_size` tuple will provide the dimensions (rows, columns) of the board. 2. Rows and columns for the initial board size will be between 5 and 100 inclusive. 3. The `custom_state` 2D list will have dimensions that fit within the specified `board_size`. Example ```python # Custom initial state initial_state = [ [0, 1, 0], [0, 1, 0], [0, 1, 0] ] board_size = (5, 5) # Initialize the board with the custom initial state board = initialize_board(initial_state, board_size) for _ in range(5): board = next_generation(board) for row in board: print(row) print(\\"n\\") ``` Evaluation Criteria 1. Correct implementation of the Game of Life rules. 2. Correct handling of edge wrapping. 3. Accurate initialization of the board with custom state. 4. Code quality and readability. # Additional Notes You may use the following utility function to count live neighbors: ```python def count_live_neighbors(board: list[list[int]], row: int, col: int) -> int: directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dr, dc in directions: rr = (row + dr) % len(board) cc = (col + dc) % len(board[0]) live_neighbors += board[rr][cc] return live_neighbors ``` Make sure to use this helper function in your `next_generation` implementation to count the number of live neighbors for each cell accurately, including the edge wrapping feature.","solution":"def count_live_neighbors(board: list[list[int]], row: int, col: int) -> int: directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dr, dc in directions: rr = (row + dr) % len(board) cc = (col + dc) % len(board[0]) live_neighbors += board[rr][cc] return live_neighbors def next_generation(board: list[list[int]]) -> list[list[int]]: rows = len(board) cols = len(board[0]) new_board = [[0] * cols for _ in range(rows)] for row in range(rows): for col in range(cols): live_neighbors = count_live_neighbors(board, row, col) if board[row][col] == 1 and live_neighbors in (2, 3): new_board[row][col] = 1 elif board[row][col] == 0 and live_neighbors == 3: new_board[row][col] = 1 else: new_board[row][col] = 0 return new_board def initialize_board(custom_state: list[list[int]], board_size: tuple[int, int]) -> list[list[int]]: rows, cols = board_size # Center the custom_state in the middle of the new board new_board = [[0] * cols for _ in range(rows)] start_row = (rows - len(custom_state)) // 2 start_col = (cols - len(custom_state[0])) // 2 for i in range(len(custom_state)): for j in range(len(custom_state[0])): new_board[start_row + i][start_col + j] = custom_state[i][j] return new_board"},{"question":"# Set Operations and Relations Context: You are working with sets and need to perform operations and determine relations between them. Specifically, you want to implement a function to find the union, intersection, and difference between two given sets, and also check if one set is a subset of another. Task: Write a function `set_operations(A: set, B: set) -> dict` that performs the following operations between two sets A and B: 1. Computes the union of `A` and `B`. 2. Computes the intersection of `A` and `B`. 3. Computes the difference of `A` from `B` (A - B). 4. Checks if `A` is a subset of `B`. The function should return a dictionary containing the results of these operations. Input: * A set of integers `A`. * A set of integers `B`. Output: * A dictionary with keys `\'union\'`, `\'intersection\'`, `\'difference\'`, and `\'is_subset\'` with the respective values being the result of the set operations. Example: ```python def set_operations(A: set, B: set) -> dict: Example usage: >>> set_operations({1, 2, 3}, {2, 3, 4}) {\'union\': {1, 2, 3, 4}, \'intersection\': {2, 3}, \'difference\': {1}, \'is_subset\': False} >>> set_operations({1, 2}, {1, 2, 3, 4}) {\'union\': {1, 2, 3, 4}, \'intersection\': {1, 2}, \'difference\': set(), \'is_subset\': True} ``` Constraints: * The sets `A` and `B` will contain only integers. * The sets `A` and `B` can be empty. **Edge Cases to consider**: * One or both sets being empty. * One set being a subset of another. Requirements: * Ensure that the function correctly handles all valid inputs including edge cases. * Return the results in a dictionary with the specified keys and operations.","solution":"def set_operations(A: set, B: set) -> dict: Perform set operations between sets A and B and return the results as a dictionary. Args: A (set): The first set of integers. B (set): The second set of integers. Returns: dict: A dictionary with keys \'union\', \'intersection\', \'difference\', and \'is_subset\' and their corresponding set operations. return { \'union\': A.union(B), \'intersection\': A.intersection(B), \'difference\': A.difference(B), \'is_subset\': A.issubset(B) }"},{"question":"# Programming Assessment Question Context List manipulations are fundamental operations in many programming scenarios. Understanding how to efficiently handle list-modifying operations is crucial. This problem requires combining multiple operations into one function to modify a list based on specific conditions. Task **Objective:** Write a function that modifies a list by replacing elements according to specified conditions. The function will replace each element with the sum of its neighbors (previous and next elements). Void elements (before the first element or after the last element) are considered zero. # Requirements * **Function Signature**: ```python def neighbor_sum_replacement(sequence: list) -> list: ``` * **Inputs**: - `sequence`: A list of integers that needs modification. * **Output**: - Returns a new list of the same length where each element is replaced by the sum of its immediate neighbors. # Constraints * The list can be of any length, including 0. * You should handle edge cases such as empty lists and lists with a single element gracefully. # Example Scenarios 1. **Example 1**: ```python neighbor_sum_replacement([3, 5, 1, 7]) # Returns: [5, 4, 12, 1] ``` (Explanation: Each element is replaced by the sum of its immediate neighbors, with the first and last elements considering void neighbors as 0.) 2. **Example 2**: ```python neighbor_sum_replacement([0, 1, 2, 3, 4, 5]) # Returns: [1, 2, 4, 6, 8, 4] ``` (Explanation: Element-wise neighbor sums result in [0+1, 0+2, 1+3, 2+4, 3+5, 4+0] which translates to [1, 2, 4, 6, 8, 4].) 3. **Example 3**: ```python neighbor_sum_replacement([1]) # Returns: [0] ``` (Explanation: The only element is replaced by the sum of void neighbors, both being 0.) # Additional Requirements * Ensure that your function works efficiently even with larger lists. * Avoid modifying the original input list inside the function. Return a new list with the required replacements.","solution":"def neighbor_sum_replacement(sequence): Replaces each element in the list with the sum of its immediate neighbors. if not sequence: return [] n = len(sequence) result = [0] * n for i in range(n): left = sequence[i - 1] if i - 1 >= 0 else 0 right = sequence[i + 1] if i + 1 < n else 0 result[i] = left + right return result"},{"question":"# Coding Challenge - Find Smallest Missing Positive Integer You are to solve the following problem by implementing a function `find_smallest_missing_positive`: Problem Description Given an unsorted integer array `nums`, find the smallest missing positive integer in the array. Function Signature ```python def find_smallest_missing_positive(nums: List[int]) -> int: ``` Input - `nums`: A list of integers, which may include positive, negative numbers, and zero. The length of the list is `n (1 <= n <= 100)`. Output - Return the smallest missing positive integer. Example ```python def find_smallest_missing_positive(nums: List[int]) -> int: # Implement your solution here pass if __name__ == \\"__main__\\": print(find_smallest_missing_positive([3, 4, -1, 1])) # Expected Output: 2 print(find_smallest_missing_positive([1, 2, 0])) # Expected Output: 3 print(find_smallest_missing_positive([7, 8, 9, 11, 12])) # Expected Output: 1 print(find_smallest_missing_positive([-1, -2, -3])) # Expected Output: 1 ``` **Note**: The example cases show multiple arrays and their corresponding smallest missing positive integers that aren\'t present in the arrays. **Considerations**: - Aim for an efficient solution that runs in linear time, i.e., O(n). - Avoid using extra space if possible. - Consider edge cases such as arrays with no positive integers or arrays already containing a sequence of consecutive positive integers.","solution":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: n = len(nums) # Mark numbers which are out of range and place each number in its correct position for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first number missing in the sequence for i in range(n): if nums[i] != i + 1: return i + 1 # If all numbers are in the correct sequence return n + 1"},{"question":"# Problem Statement You are tasked with designing a function that evaluates two arithmetic expressions and determines which one has the larger value. Each expression is represented as a string and can contain any of the basic arithmetic operations: addition (+), subtraction (-), multiplication (*), and division (/). # Function Signature ```python def compare_expressions(expr1: str, expr2: str) -> str: Compare two arithmetic expressions and return which one evaluates to a larger value or if they are equal. Parameters: - expr1 (str): A string representing the first arithmetic expression. - expr2 (str): A string representing the second arithmetic expression. Returns: - str: A string indicating which expression has the larger value or if they are equal, in the format \\"Expression 1 is larger\\", \\"Expression 2 is larger\\" or \\"Both are equal\\" pass ``` # Input - `expr1` and `expr2` are strings consisting of valid arithmetic expressions. - `expr1 = \\"3 + 5 * 2\\"` - `expr2 = \\"4 * 5 - 3\\"` # Output - A string that indicates which of the expressions `expr1` or `expr2` has the larger value or if they are equal. # Constraints - Each expression contains at least one operator and at least one number. - Numbers should be integers and can be positive, negative, or zero. - The expressions follow standard operator precedence rules. - Valid operators are + (addition), - (subtraction), * (multiplication), and / (division). - The division operator `/` should perform floating-point division. # Example ```python compare_expressions(\\"3 + 5 * 2\\", \\"4 * 5 - 3\\") # Output: \\"Expression 2 is larger\\" compare_expressions(\\"10 / 2\\", \\"5\\") # Output: \\"Both are equal\\" compare_expressions(\\"2 + 2\\", \\"1 + 1 * 3 + 1\\")# Output: \\"Expression 1 is larger\\" ``` # Notes - The comparison should evaluate the expressions following the standard operator precedence rules. - Ensure that division by zero is handled properly, returning suitable messages or values. - Use the `eval` function with caution to safely evaluate the expressions.","solution":"def compare_expressions(expr1: str, expr2: str) -> str: Compare two arithmetic expressions and return which one evaluates to a larger value or if they are equal. Parameters: - expr1 (str): A string representing the first arithmetic expression. - expr2 (str): A string representing the second arithmetic expression. Returns: - str: A string indicating which expression has the larger value or if they are equal, in the format \\"Expression 1 is larger\\", \\"Expression 2 is larger\\" or \\"Both are equal\\" try: val1 = eval(expr1) val2 = eval(expr2) except ZeroDivisionError: return \\"Error: Division by zero in one of the expressions\\" if val1 > val2: return \\"Expression 1 is larger\\" elif val1 < val2: return \\"Expression 2 is larger\\" else: return \\"Both are equal\\""},{"question":"# Question Scenario: You are tasked with developing a feature for a social media application that tracks the usage patterns of its users. The application needs to identify the most active users in terms of the number of posts they make each day. To achieve this, you decide to use a min-heap data structure to keep track of the top k users with the highest number of posts on any given day. Given a data structure representing user activity logs, develop a solution to identify the top k users based on the number of posts. Task: Implement the following functions: 1. **add_post(username: str) -> None**: - Records a new post by the user with the given `username`. Updates the count of posts made by the specified user. 2. **top_k_users(k: int) -> List[Tuple[str, int]]**: - Returns a list of tuples representing the usernames and their corresponding post counts of the top k users with the highest number of posts. The list should be sorted in descending order of post counts. If two users have the same number of posts, they should be sorted alphabetically by username. 3. **reset_counts() -> None**: - Resets the post counts for all users to zero. Function Definitions: ```python class MinHeap: Defining the structure and operations for MinHeap def __init__(self): self.heap = [] def insert(self, pair: Tuple[int, str]) -> None: pass def extract_min(self) -> Tuple[int, str]: pass def peek(self) -> Tuple[int, str]: pass def add_post(username: str) -> None: pass def top_k_users(k: int) -> List[Tuple[str, int]]: pass def reset_counts() -> None: pass ``` Constraints: - Assume usernames are unique and consist of lowercase letters. - The system can have a maximum of 10^5 unique users. - The value of `k` will be between 1 and 1000. - Posts can be recorded at any time, and the `top_k_users` function will be called at any point to list the most active users. Example: ```python add_post(\\"alice\\") add_post(\\"bob\\") add_post(\\"alice\\") add_post(\\"charlie\\") add_post(\\"bob\\") add_post(\\"bob\\") assert top_k_users(2) == [(\\"bob\\", 3), (\\"alice\\", 2)] reset_counts() assert top_k_users(2) == [] ``` Performance Requirements: - The `add_post` operation should run in O(log k) time where k is the number of top users to track. - The `top_k_users` operation should run in O(k log k) time. - The `reset_counts` operation should run in O(n) time where n is the number of unique users.","solution":"from heapq import heappush, heappop from typing import List, Tuple from collections import defaultdict class MinHeap: Defining the structure and operations for MinHeap def __init__(self): self.heap = [] def insert(self, pair: Tuple[int, str]) -> None: heappush(self.heap, pair) def extract_min(self) -> Tuple[int, str]: return heappop(self.heap) def peek(self) -> Tuple[int, str]: return self.heap[0] if self.heap else None def __len__(self): return len(self.heap) # Dictionary to keep track of the number of posts per user user_post_counts = defaultdict(int) def add_post(username: str) -> None: user_post_counts[username] += 1 def top_k_users(k: int) -> List[Tuple[str, int]]: min_heap = MinHeap() for username, post_count in user_post_counts.items(): min_heap.insert((post_count, username)) # If the heap exceeds size k, remove the smallest element if len(min_heap) > k: min_heap.extract_min() result = [] while len(min_heap) > 0: post_count, username = min_heap.extract_min() result.append((username, post_count)) # Return result in descending order by post count and then by username return sorted(result, key=lambda x: (-x[1], x[0])) def reset_counts() -> None: user_post_counts.clear()"},{"question":"# Scenario You are building an application that processes a large text file containing multiple records formatted as JSON. Each record represents a person\'s data, including their name, age, and a list of their favorite numbers. Your task is to write a function that extracts and processes this data by calculating the sum of favorite numbers for each person and identifying the person with the highest sum. # Requirements 1. **Extraction and Processing of JSON Records** - Write a function `process_records` that reads a text file of JSON records. - Each line in the file is a separate JSON object with `name` (string), `age` (int), and `favorites` (list of integers) fields. - Compute the sum of `favorites` for each person. - Identify the person with the highest sum of favorite numbers and return their `name` and the calculated sum. # Input - `file_path` (str): Path to the input text file containing JSON records. # Output - Tuple (str, int): Name of the person with the highest sum of favorite numbers and the sum itself. # Constraints - Names are non-empty strings with a maximum length of 100 characters. - Ages are integers between 0 and 120. - Favorites list contains up to 100 integers, each between -1000 and 1000. - The input file is not empty and contains at least one valid JSON record per line. # Function Signature ```python def process_records(file_path: str) -> tuple: pass ``` # Sample Input and Output Assume the input file `input.txt` contains the following lines: ```json {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"favorites\\": [1, 2, 3]} {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"favorites\\": [10, 20, 30]} {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"favorites\\": [5, 7, 11]} ``` ```python >>> process_records(\'input.txt\') (\'Bob\', 60) ``` # Instructions 1. **File Handling**: Ensure the function correctly reads and processes each line of the input file. 2. **JSON Parsing**: Handle parsing the JSON records and extracting relevant fields. 3. **Summation**: Compute the sum of the `favorites` list for each person. 4. **Identification**: Determine the person with the highest sum and return their name and the sum. 5. **Error Handling**: Assume that the input file is well-formatted and contains valid JSON records.","solution":"import json def process_records(file_path: str) -> tuple: highest_person = None highest_sum = -float(\'inf\') with open(file_path, \'r\') as file: for line in file: person = json.loads(line) favorites_sum = sum(person[\'favorites\']) if favorites_sum > highest_sum: highest_sum = favorites_sum highest_person = person[\'name\'] return (highest_person, highest_sum)"},{"question":"# Coding Assessment Question Problem Description: You are tasked with implementing a function `rotate_string(s: str, k: int) -> str`. This function should rotate the string `s` by `k` positions to the right, achieving the rotation in an efficient manner. Detailed Requirements: 1. **Function Signature**: `def rotate_string(s: str, k: int) -> str:` 2. **Inputs**: - `s`: a string (1 ≤ len(s) ≤ 10^6) consisting of alphanumeric characters. - `k`: an integer representing the number of positions to rotate the string (0 ≤ k ≤ 10^9). 3. **Output**: - A string representing the rotated result. 4. **Constraints**: - Ensure the function works within reasonable time and space limits. - Handle cases where `k` may be larger than the length of the string `s`. # Example: ```python >>> rotate_string(\\"abcdef\\", 2) \\"efabcd\\" >>> rotate_string(\\"abcdef\\", 0) \\"abcdef\\" >>> rotate_string(\\"abcdef\\", 6) \\"abcdef\\" >>> rotate_string(\\"abcdef\\", 8) \\"efabcd\\" ``` # Notes: 1. The function should handle large values of `s` and `k` efficiently. 2. Consider edge cases such as: - `k` being zero. - `k` being exactly the length of the string. - `k` being larger than the length of the string. 3. Use modular arithmetic to avoid unnecessary computational overhead. --- Good luck! Ensure your solution meets the optimal time and space complexity as discussed, and handles edge cases appropriately.","solution":"def rotate_string(s: str, k: int) -> str: Rotates the string s by k positions to the right. if not s: return s n = len(s) k = k % n # Avoid unnecessary full rotations return s[-k:] + s[:-k]"},{"question":"# Question: Extract and Display Weather Information You are tasked with creating a program that fetches and displays current weather information using the OpenWeatherMap API. Your program should include the following functionalities: 1. **Get current weather by city name**: Access the appropriate endpoint to get the weather details for a given city. 2. **Get weather information for multiple cities**: Fetch the weather details for a list of cities, showing the main weather description and temperature in Celsius. Functional Requirements: - **Function 1**: `get_weather_by_city(city_name: str) -> dict` - `city_name`: String specifying the name of the city. - Returns a dictionary containing: ```python { \\"description\\": \\"Weather description\\", \\"temperature_celsius\\": \\"Temperature in Celsius\\" } ``` - **Function 2**: `get_weather_for_cities(cities: list) -> list` - `cities`: List of strings specifying the names of the cities. - Returns a list of dictionaries where each dictionary follows the format from Function 1. Input and Output - **Input**: The functions take the city name or list of city names as input. - **Output**: The functions should return the expected data structures as outlined above. Constraints: - Your implementation should handle network errors gracefully, returning `None` or an empty list in case of failures. - You must use the `requests` library. - Consider network timeout by setting a timeout value of 10 seconds for your API calls. - You need to register to get an API key from OpenWeatherMap and include it in your API requests. Example ```python weather = get_weather_by_city(\'London\') # Expected output: {\'description\': \'clear sky\', \'temperature_celsius\': 15.0} weather_list = get_weather_for_cities([\'Paris\', \'Berlin\', \'Tokyo\']) # Expected output: [ # {\'description\': \'few clouds\', \'temperature_celsius\': 18.5}, # {\'description\': \'rain\', \'temperature_celsius\': 13.2}, # {\'description\': \'clear sky\', \'temperature_celsius\': 25.0} # ] ``` Write the function implementations for `get_weather_by_city(city_name: str)` and `get_weather_for_cities(cities: list)`.","solution":"import requests # Remember to replace \'your_api_key\' with your actual OpenWeatherMap API key. API_KEY = \'your_api_key\' BASE_URL = \'http://api.openweathermap.org/data/2.5/weather\' def get_weather_by_city(city_name: str) -> dict: try: response = requests.get( BASE_URL, params={\'q\': city_name, \'appid\': API_KEY, \'units\': \'metric\'}, timeout=10 ) response.raise_for_status() data = response.json() return { \'description\': data[\'weather\'][0][\'description\'], \'temperature_celsius\': data[\'main\'][\'temp\'] } except (requests.RequestException, KeyError): return None def get_weather_for_cities(cities: list) -> list: weather_list = [] for city in cities: weather = get_weather_by_city(city) if weather: weather_list.append(weather) return weather_list"},{"question":"# Problem Statement You are required to write a function that takes a list of integers and determines if any three integers in the list sum up to a target value. If such a combination exists, the function should return `True`, otherwise, it should return `False`. # Function Signature ```python def three_sum(nums: list, target: int) -> bool: ``` # Input - A list of integers `nums`. - An integer `target` representing the target sum. # Output - A boolean value `True` if there exist three integers in the list that add up to `target`. - `False` otherwise. # Constraints - `3 <= len(nums) <= 3000` - `-10^5 <= nums[i] <= 10^5` - `-10^5 <= target <= 10^5` # Example ```python assert three_sum([1, 2, 3, 4, 5], 9) == True assert three_sum([1, 2, 4, 6, 8], 20) == False assert three_sum([0, -1, 2, -3, 1], 0) == True assert three_sum([-1, 0, 1, 2, -1, -4], -1) == True ``` # Explanation For the first example: - The numbers 2, 3, and 4 sum up to 9, so the function returns `True`. For the second example: - There are no three numbers in the list that sum up to 20, so the function returns `False`. For the third example: - The numbers 0, -1, and 1 sum up to 0, so the function returns `True`. For the fourth example: - The numbers -1, 0, and 1 sum up to 0, so the function returns `True`. # Edge Cases to Consider - The list may contain both positive and negative integers. - The list is guaranteed to have at least three integers. Implement the function ensuring efficiency and correctness. Use an appropriate algorithm to handle the constraints effectively.","solution":"def three_sum(nums: list, target: int) -> bool: nums.sort() n = len(nums) for i in range(n-2): # Skip duplicate elements to avoid redundant work if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, n-1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"# Matrix Diagonal Sum Implement a function **matrix_diagonal_sum(matrix: List[List[int]]) -> int** that computes the sum of the diagonal elements of a square matrix. If the matrix is non-square, the function should return -1. Parameters: - **matrix** (List[List[int]]): A 2D list of integers representing the matrix. Returns: - The sum of the diagonal elements of the matrix if it is square. - -1 if the matrix is not square. Constraints: - The matrix will only contain integers. - `1 <= len(matrix) <= 1000` - `1 <= len(matrix[i]) <= 1000` Example: ```python matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(matrix_diagonal_sum(matrix_1)) # Output: 15 matrix_2 = [ [1, 2], [3, 4, 5], [6, 7, 8] ] print(matrix_diagonal_sum(matrix_2)) # Output: -1 ``` # Notes: - The primary diagonal of a square matrix runs from the top-left to the bottom-right. - The sum is simply the sum of elements where the row index equals the column index. - The function must check if the input matrix is square (i.e., it has the same number of rows and columns). - If the matrix dimensions are invalid (non-square), the function returns -1 immediately. # Guidelines: 1. Validate the matrix dimensions to ensure it is square. 2. Sum the elements from the top-left to bottom-right diagonal if the matrix is valid. 3. Efficiently handle edge cases such as non-square matrices.","solution":"from typing import List def matrix_diagonal_sum(matrix: List[List[int]]) -> int: Computes the sum of the diagonal elements of a square matrix. Parameters: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: int: The sum of the diagonal elements if the matrix is square, otherwise -1. n = len(matrix) for row in matrix: if len(row) != n: return -1 # The matrix is not square diagonal_sum = sum(matrix[i][i] for i in range(n)) return diagonal_sum"},{"question":"# Question: Implement and Test a URL Shortener Context: You are required to develop a URL shortening service similar to bit.ly or TinyURL. This service should accept a long URL and return a short, unique URL that can be used to redirect to the original long URL. Requirements: 1. **Shortening URL**: Implement a function to shorten a long URL into a unique short URL. 2. **Redirecting URL**: Implement a function to retrieve the original long URL given a short URL. 3. **Data Storage**: Maintain an in-memory data structure for storing mappings between long and short URLs. 4. **Uniqueness**: Ensure that each long URL maps to a unique short URL. Main Function Specification: ```python class URLShortener: def __init__(self): self.url_map = {} self.short_url_prefix = \\"http://short.url/\\" self.id_counter = 0 def shorten_url(self, long_url: str) -> str: Shortens a given long URL and returns the corresponding short URL. Parameters: long_url (str): The original long URL to be shortened. Returns: str: The unique short URL for the given long URL. pass def retrieve_url(self, short_url: str) -> str: Retrieves the original long URL given a short URL. Parameters: short_url (str): The short URL for which to retrieve the original long URL. Returns: str: The original long URL if found, otherwise an appropriate error message. pass ``` * **Input**: A long URL for shortening and a short URL for retrieving the original long URL. * **Output**: A short URL for the given long URL and the original long URL for the given short URL. Constraints: - The function should guarantee a unique short URL for each long URL. - Handle any special characters in the URLs properly. - Ensure that the mapping between long and short URLs is maintained accurately. * **Example**: ```python url_shortener = URLShortener() # Shorten a URL long_url = \\"https://www.example.com/some/very/long/path\\" short_url = url_shortener.shorten_url(long_url) print(short_url) # Output: http://short.url/1 # Retrieve the original URL retrieved_url = url_shortener.retrieve_url(short_url) print(retrieved_url) # Output: https://www.example.com/some/very/long/path # Validate assert short_url == \\"http://short.url/1\\" assert retrieved_url == long_url ``` Note: - Use a simple incremental counter to generate unique identifiers for short URLs. - Implement error handling for cases where the short URL does not exist in the mapping. - Ensure code is well-documented and includes test cases to demonstrate handling of edge cases.","solution":"class URLShortener: def __init__(self): self.url_map = {} self.short_to_long_map = {} self.short_url_prefix = \\"http://short.url/\\" self.id_counter = 1 def shorten_url(self, long_url: str) -> str: Shortens a given long URL and returns the corresponding short URL. Parameters: long_url (str): The original long URL to be shortened. Returns: str: The unique short URL for the given long URL. if long_url in self.url_map: return self.url_map[long_url] short_url = self.short_url_prefix + str(self.id_counter) self.url_map[long_url] = short_url self.short_to_long_map[short_url] = long_url self.id_counter += 1 return short_url def retrieve_url(self, short_url: str) -> str: Retrieves the original long URL given a short URL. Parameters: short_url (str): The short URL for which to retrieve the original long URL. Returns: str: The original long URL if found, otherwise an appropriate error message. if short_url in self.short_to_long_map: return self.short_to_long_map[short_url] return \\"Error: Short URL not found.\\""},{"question":"# Problem Statement: You are asked to create a function that identifies all anagrams between two provided lists of words. An anagram is a word formed by rearranging the letters of another, such as \\"cinema\\" and \\"iceman\\". Your task includes ensuring that your solution is optimized for performance and can handle the varying lengths of input lists. # Requirements: 1. **Anagram Finder Function**: Implement a function `find_anagrams` that takes two lists of words and returns a list of tuples. Each tuple should contain two words that are anagrams of each other, one from each input list. 2. **Efficiency**: Optimize the solution to handle large input lists efficiently. # Input & Output: 1. **find_anagrams(list1: List[str], list2: List[str]) -> List[Tuple[str, str]]**: - **Input**: Two lists of words `list1` and `list2`, each containing up to 10^5 words. - **Output**: A list of tuples where each tuple contains one word from `list1` and one word from `list2` that are anagrams. # Constraints: * Words in the lists consist of lowercase alphabets only. * Length of each word does not exceed 100 characters. * The function should efficiently handle lists with up to 10^5 words each. # Function Specifications: Implement the `find_anagrams` function using a helpful technique for checking anagrams, such as sorting or using character counts: 1. **Naive comparison method**: - Compare each word from `list1` to each word in `list2` to find anagrams. This method is straightforward but not optimized for large lists. 2. **Optimized method**: - Utilize sorting or character counting to improve efficiency and speed up the comparison process. # Example Usage: ```python from typing import List, Tuple def find_anagrams(list1: List[str], list2: List[str]) -> List[Tuple[str, str]]: Identifies anagrams between two lists of words. pass # Example calls: words1 = [\\"listen\\", \\"evil\\", \\"binary\\", \\"adobe\\", \\"star\\"] words2 = [\\"silent\\", \\"vile\\", \\"brainy\\", \\"abode\\", \\"tsar\\"] print(find_anagrams(words1, words2)) # Output: [(\'listen\', \'silent\'), (\'evil\', \'vile\'), (\'binary\', \'brainy\'), (\'adobe\', \'abode\'), (\'star\', \'tsar\')] ``` # Notes: * Ensure your code follows best practices for efficiency. * Document any assumptions or optimizations you make. * The naive approach is acceptable but strive for a more efficient solution to handle large input lists effectively. # Additional Context: Consider edge cases such as one or both lists being empty, and words that have no anagrams in the opposite list. Make sure to handle scenarios where multiple words in one list can have the same anagram in the other list.","solution":"from typing import List, Tuple def find_anagrams(list1: List[str], list2: List[str]) -> List[Tuple[str, str]]: Identifies anagrams between two lists of words. Args: list1 : List[str] - First list of words. list2 : List[str] - Second list of words. Returns: List[Tuple[str, str]] - List of tuples where each tuple contains one word from list1 and one word from list2 that are anagrams. # Function to create a sorted tuple of letters as a signature of the word def signature(word): return \'\'.join(sorted(word)) # Create dictionaries to store the signatures dict1 = {} dict2 = {} for word in list1: sig = signature(word) if sig in dict1: dict1[sig].append(word) else: dict1[sig] = [word] for word in list2: sig = signature(word) if sig in dict2: dict2[sig].append(word) else: dict2[sig] = [word] # Find the anagram pairs anagram_pairs = [] for sig in dict1: if sig in dict2: for w1 in dict1[sig]: for w2 in dict2[sig]: anagram_pairs.append((w1, w2)) return anagram_pairs"},{"question":"# Question: You are tasked with implementing a function `find_largest_rectangle(matrix: List[List[int]]) -> int` that finds the area of the largest rectangle containing all 1\'s in a given binary matrix. To solve this, follow these instructions: 1. Define a helper function `largest_histogram_area(heights: List[int]) -> int` that computes the largest rectangle area in a histogram given the heights of the bars. 2. Use this helper function within the `find_largest_rectangle` function to compute the area of the largest rectangle in the binary matrix containing only 1\'s. **Function Signature**: ```python from typing import List def find_largest_rectangle(matrix: List[List[int]]) -> int: pass ``` **Input**: - matrix (List[List[int]]): A binary matrix (0\'s and 1\'s) with dimensions (m times n). **Output**: - int: The area of the largest rectangle containing all 1\'s. **Constraints**: - The dimensions of the matrix (m) and (n) are such that (1 leq m, n leq 200). - The function should handle edge cases where the matrix is empty or contains only 0\'s. **Examples**: ```python matrix1 = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] find_largest_rectangle(matrix1) # Output: 6 (rectangle of 1\'s of area 3x2). matrix2 = [ [0, 0, 0], [0, 0, 0] ] find_largest_rectangle(matrix2) # Output: 0 matrix3 = [ [1] ] find_largest_rectangle(matrix3) # Output: 1 matrix4 = [ [] ] find_largest_rectangle(matrix4) # Output: 0 ``` Implement the `find_largest_rectangle` function in Python. Ensure to handle cases where the matrix is empty or does not contain any 1\'s correctly by returning 0 in those scenarios.","solution":"from typing import List def largest_histogram_area(heights: List[int]) -> int: Helper function to compute the largest rectangle area in a histogram given the heights of the bars. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def find_largest_rectangle(matrix: List[List[int]]) -> int: Function to find the area of the largest rectangle containing all 1\'s in a given binary matrix. if not matrix or not matrix[0]: return 0 max_area = 0 heights = [0] * len(matrix[0]) for row in matrix: for i in range(len(row)): if row[i] == 0: heights[i] = 0 else: heights[i] += row[i] max_area = max(max_area, largest_histogram_area(heights)) return max_area"},{"question":"# Array Rotation Problem Statement Write a function that rotates elements of a list by a given number of places to the right. The rotation should be performed in-place, meaning you should modify the original list and not return a new one. Requirements * Input: A list of integers and a non-negative integer representing the number of places to rotate. * Output: The modified list with elements rotated to the right by the specified number of places. Constraints 1. The list may contain zero or more elements. 2. The number of places to rotate can be zero or a positive integer. 3. If the number of places to rotate is larger than the list\'s length, rotate by the modulus of the list\'s length. Example ```python def rotate_list(nums: list, k: int) -> None: pass # Example test cases nums1 = [1, 2, 3, 4, 5] rotate_list(nums1, 2) print(nums1) # Output: [4, 5, 1, 2, 3] nums2 = [10, 20, 30, 40, 50] rotate_list(nums2, 3) print(nums2) # Output: [30, 40, 50, 10, 20] nums3 = [7, 8, 9] rotate_list(nums3, 1) print(nums3) # Output: [9, 7, 8] nums4 = [] rotate_list(nums4, 5) print(nums4) # Output: [] nums5 = [1, 2, 3] rotate_list(nums5, 3) print(nums5) # Output: [1, 2, 3] ``` # Additional Notes - You should modify the list in-place without using extra space for another list. - Consider edge cases such as empty list and rotations equal to or greater than the list\'s length. - Strive for an efficient implementation that minimizes time complexity. # Hints - You can use slicing to rearrange parts of the list. - Rotate by the modulus of the list\'s length to handle cases when `k` is larger than the list\'s length.","solution":"def rotate_list(nums: list, k: int) -> None: Rotates the elements of the list nums in-place by k places to the right. # Handle the case when the list is empty if not nums: return # Handle the case when k is greater than the length of the list n = len(nums) k = k % n # Rotate the list in-place # Reverse the entire list nums.reverse() # Reverse the first k elements nums[:k] = reversed(nums[:k]) # Reverse the rest of the list (from k to the end) nums[k:] = reversed(nums[k:])"},{"question":"# Implement A* Pathfinding Algorithm You are given an unweighted grid where `0` denotes a free path, and `1` denotes an obstacle. Your task is to find the shortest path between a start position and a goal position using the A* Pathfinding Algorithm. **Implement the function `astar_pathfinding(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]`:** Input: * `grid` (List[List[int]]): A 2D list representing the grid. * `start` (Tuple[int, int]): A tuple representing the starting position in the format (row, column). * `goal` (Tuple[int, int]): A tuple representing the goal position in the format (row, column). Output: * A list of tuples representing the shortest path from start to goal inclusively. If no path exists, return an empty list. Constraints: * `0 <= start[0], goal[0] < len(grid)` * `0 <= start[1], goal[1] < len(grid[0])` * The start and goal points will always be on valid points (i.e., `grid[start[0]][start[1]] == 0` and `grid[goal[0]][goal[1]] == 0`). Performance Requirements: * Solutions should efficiently utilize the heuristic function to guide the search towards the goal, avoiding unnecessary explorations. **Example Usage:** ```python grid = [ [0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0], ] start = (0, 0) goal = (6, 6) assert astar_pathfinding(grid, start, goal) == [ (0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3), (2, 4), (3, 4), (3, 5), (3, 6), (4, 6), (5, 6), (6, 6) ] ``` Note: Ensure that your solution properly implements the A* algorithm with an appropriate heuristic function such as Manhattan distance for grid-based paths. Additionally, handle edge cases where the path may not exist or where start and goal positions are the same.","solution":"from typing import List, Tuple import heapq def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: Calculate the Manhattan distance between points a and b. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def astar_pathfinding(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Find the shortest path in an unweighted grid using the A* algorithm. rows, cols = len(grid), len(grid[0]) open_set = [] heapq.heappush(open_set, (0 + heuristic(start, goal), 0, start)) came_from = {} g_score = {start: 0} while open_set: _, current_cost, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path neighbors = [ (current[0] + 1, current[1]), (current[0] - 1, current[1]), (current[0], current[1] + 1), (current[0], current[1] - 1) ] for neighbor in neighbors: row, col = neighbor if 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0: tentative_g_score = current_cost + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score, tentative_g_score, neighbor)) return []"},{"question":"# String Compression Algorithm You are required to implement a string compression algorithm. The function will compress a string such that consecutive identical characters are replaced by the character followed by the number of occurrences. If the compressed string is longer than the original, return the original string. Requirements 1. **`compress_string` function**: * **Input**: A string `s` which consists of lowercase letters. * **Output**: The compressed version of the string if it results in a shorter or equal length compared to the original string. Otherwise, return the original string. * **Function Signature**: ```python def compress_string(s: str) -> str: ``` Constraints * The length of the string `s` will be at most `10^5`. * The characters in the string `s` will be lowercase English letters. Example ```python compress_string(\\"aabcccccaaa\\") # Output: \\"a2b1c5a3\\" compress_string(\\"abc\\") # Output: \\"abc\\" ``` Notes * Ensure your implementation is efficient and can handle the upper limit of input size. * You can assume the input string only contains lowercase English letters. Good luck, and happy coding!","solution":"def compress_string(s: str) -> str: Compresses the input string \'s\' such that consecutive identical characters are replaced by the character followed by the number of occurrences. If the compressed string is longer than the original, the original string is returned. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Problem Statement You are tasked with implementing a function that takes a list of integers and an integer `target`, and returns all unique combinations of the integers in the list that add up to the `target`. Each number in the list may be used an unlimited number of times in the combination. The solution set must not contain duplicate combinations, and the order of numbers within the combination does not matter. # Function Signature ```python def combination_sum(candidates: list[int], target: int) -> list[list[int]]: pass ``` # Input * `candidates` (list of integers): The list of integers from which combinations can be made. Each element `candidates[i]` is a positive integer. * `target` (integer): The sum that each combination must add up to, where `target` is a non-negative integer. # Output * Returns a list of lists, where each inner list is a unique combination of numbers from `candidates` that sum up to `target`. # Constraints * You must validate that all elements in `candidates` are positive integers. * If `target` is 0, return a list containing an empty list `[[]]` since the combination of no numbers is valid for sum of 0. * If `target` is less than the minimum element in `candidates` and there are no elements combining to form the target, return an empty list. * If a negative integer is detected in `candidates`, raise a `ValueError` containing the message \\"Candidates must be positive integers.\\" # Requirements * Your solution should have a time complexity of (O(2^n)) in the worst-case scenario due to the potential number of combinations being explored. * The function should utilize backtracking to find the combinations. * Focus on writing clean, modular, and efficient code. # Example ```python combination_sum([2, 3, 6, 7], 7) # Expected output: # [[2, 2, 3], [7]] combination_sum([2, 3, 5], 8) # Expected output: # [[2, 2, 2, 2], [2, 3, 3], [3, 5]] combination_sum([2], 1) # Expected output: # [] combination_sum([1], 1) # Expected output: # [[1]] combination_sum([2, -3, 5], 7) # Expected output: # Raises ValueError: Candidates must be positive integers ``` # Notes * Ensure your solution handles the above cases effectively. * Avoid duplicates in the solution set. * Focus on writing clean, modular, and efficient code with proper validations and error handling.","solution":"def combination_sum(candidates: list[int], target: int) -> list[list[int]]: def backtrack(remain, comb, start): if remain == 0: result.append(list(comb)) return elif remain < 0: return for i in range(start, len(candidates)): comb.append(candidates[i]) backtrack(remain - candidates[i], comb, i) comb.pop() if any(c < 0 for c in candidates): raise ValueError(\\"Candidates must be positive integers\\") result = [] backtrack(target, [], 0) return result"},{"question":"# Efficient String Reversal Using Recursion You are given a string, and your task is to implement a function that reverses the string using a recursive approach. The reversed string should be returned as the output. Implement the following function: ```python def reverse_string_recursive(s: str) -> str: Reverses a string using recursion. @input: s (input string) @output: reversed string @example: >>> reverse_string_recursive(\\"hello\\") \'olleh\' >>> reverse_string_recursive(\\"Recursion\\") \'noisruceR\' pass ``` # Input * `s`: A string that needs to be reversed. `s` will contain at most 10^4 characters. # Output * Return a string that is the reversed version of the input string `s`. # Constraints * `s` will only contain printable ASCII characters. # Function Signature ```python def reverse_string_recursive(s: str) -> str: ``` Ensure your implementation is efficient enough to handle the maximum constraints. # Example ```python assert reverse_string_recursive(\\"example\\") == \\"elpmaxe\\" assert reverse_string_recursive(\\"abcd\\") == \\"dcba\\" assert reverse_string_recursive(\\"\\") == \\"\\" ``` # Hints 1. Think about the base case for the recursion (e.g., an empty string or a single character). 2. How can the problem be broken down into smaller subproblems that can be solved recursively? 3. Consider how to reassemble the string after solving the smaller subproblem.","solution":"def reverse_string_recursive(s: str) -> str: Reverses a string using recursion. @input: s (input string) @output: reversed string @example: >>> reverse_string_recursive(\\"hello\\") \'olleh\' >>> reverse_string_recursive(\\"Recursion\\") \'noisruceR\' # Base case: if the string is empty or a single character, return itself if len(s) == 0 or len(s) == 1: return s # Recursive case: reverse the rest of the string, then add the first character at the end return reverse_string_recursive(s[1:]) + s[0]"},{"question":"Rotate Matrix Scenario You have been tasked with building a feature for an image editing software that can rotate an image 90 degrees clockwise. Given that the image is represented as an NxN matrix, your job is to implement the rotation algorithm that modifies the given matrix in place. Task Write a function `rotate_matrix(matrix: List[List[int]]) -> None` that takes an NxN 2D list of integers representing an image and rotates the image by 90 degrees clockwise. Input The function will receive a single argument: - `matrix`: a 2D list of integers where `matrix[i][j]` represents the pixel value at the ith row and jth column of the image. Output The function should modify the input matrix in place and should not return any value: - The input matrix will be rotated by 90 degrees clockwise. Constraints - The matrix is guaranteed to have non-zero dimensions. - You are expected to perform the rotation in place, meaning you cannot use extra space for another matrix. Example ```python # Example of a 3x3 matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # Output: The matrix should be modified in place to: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example of a 4x4 matrix matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) # Output: The matrix should be modified in place to: # [ # [13, 9, 5, 1], # [14, 10, 6, 2], # [15, 11, 7, 3], # [16, 12, 8, 4] # ] ``` # Additional Notes - The function should handle edge cases such as an empty matrix or N being 1. - Consider the most efficient way to rotate the matrix in terms of both time and space complexity.","solution":"def rotate_matrix(matrix): Rotate the NxN matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): NxN matrix of integers representing an image. Returns: None: The function modifies the input matrix in place. N = len(matrix) # Transpose the matrix for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(N): matrix[i].reverse()"},{"question":"# **Coding Assessment Question** Context: You are developing a feature for a sophisticated finance tracking application. Users frequently need to identify potential fraudulent transactions based on transaction histories. For this task, the system must quickly find duplicates within a short transaction history to flag suspicious activities. Task: Implement an algorithm to identify any duplicate transaction amounts within a given list of transactions. The function should return a list of duplicate transaction amounts sorted in ascending order. If there are no duplicates, return an empty list. Function Signature: - `def find_duplicate_transactions(transactions: list[int]) -> list[int]:` # Input: - `transactions`: a list of integers representing transaction amounts. # Output: - A list of integers representing the duplicate transaction amounts sorted in ascending order. # Constraints: - The input list will have at most `10^5` elements. - Transaction amounts are positive integers. # Examples: ```python assert find_duplicate_transactions([10, 20, 30, 10, 40, 30, 50]) == [10, 30] assert find_duplicate_transactions([100, 200, 300, 400, 500]) == [] assert find_duplicate_transactions([7, 7, 7, 7, 7]) == [7] assert find_duplicate_transactions([]) == [] ``` **Note**: Handle edge cases such as an empty list, no duplicates, and all elements being the same. Additional Requirements: - Ensure the code is optimized and handles large inputs efficiently. - Write unit tests to verify the correctness of your implementation.","solution":"def find_duplicate_transactions(transactions): Returns a sorted list of duplicate transaction amounts. If there are no duplicates, return an empty list. transaction_count = {} for amount in transactions: if amount in transaction_count: transaction_count[amount] += 1 else: transaction_count[amount] = 1 duplicates = [amount for amount, count in transaction_count.items() if count > 1] duplicates.sort() return duplicates"},{"question":"# Problem Statement You have been tasked with creating a function that counts the number of unique paths from the top-left corner to the bottom-right corner of an `m x n` grid. You can only move either down or right at any point in time. Additionally, implement a similar function that calculates the number of unique paths considering some cells are blocked (represented as obstacles). # Function 1: `unique_paths(m: int, n: int) -> int` * **Input Parameters**: - `m` (int): Number of rows. - `n` (int): Number of columns. * **Output**: - Returns an integer representing the number of unique paths from the top-left corner to the bottom-right corner. * **Constraints**: - 1 <= `m`, `n` <= 100. # Function 2: `unique_paths_with_obstacles(grid: List[List[int]]) -> int` * **Input Parameters**: - `grid` (List[List[int]]): A 2D list where 0 represents a free cell and 1 represents a blocked cell. * **Output**: - Returns an integer representing the number of unique paths from the top-left corner to the bottom-right corner considering obstacles. * **Constraints**: - 1 <= `m`, `n` <= 100. - `grid[i][j]` is either 0 or 1. # Requirements: 1. Implement `unique_paths(m: int, n: int) -> int`. 2. Implement `unique_paths_with_obstacles(grid: List[List[int]]) -> int`. 3. Ensure efficient computation with the time complexity O(m * n). # Examples: Example 1 ```python >>> unique_paths(3, 7) 28 ``` Example 2 ```python >>> unique_paths_with_obstacles([ ... [0,0,0], ... [0,1,0], ... [0,0,0] ... ]) 2 ``` # Explanation: 1. `unique_paths(3, 7)` returns 28 because there are 28 distinct paths from the top-left to the bottom-right corner of a 3x7 grid, moving only down or right. 2. `unique_paths_with_obstacles([[0,0,0],[0,1,0],[0,0,0]])` returns 2 because there are only two distinct paths avoiding the obstacle in the middle.","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. # Create a 2D list to store the number of paths dp = [[1] * n for _ in range(m)] # Fill the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid with obstacles. m = len(grid) n = len(grid[0]) # Initialize the dp array where dp[i][j] will store the number of unique paths to cell (i, j) dp = [[0] * n for _ in range(m)] # If the starting cell has an obstacle, return 0 if grid[0][0] == 1: return 0 dp[0][0] = 1 # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Compare Binary Search Trees You are tasked with writing a function to compare two binary search trees (BSTs) to determine if they are identical or not. Two BSTs are considered identical if they contain the same values and structure. **Objective**: Write a function `are_identical_bsts` that checks if two given BSTs are identical. Implement the required class for the BST nodes and ensure the function accurately compares the structures and values of two BSTs. **Requirements**: 1. Define a `TreeNode` class to represent the nodes in the binary search tree. 2. Implement a helper function that recursively compares two subtrees. 3. The main function, `are_identical_bsts` should return `True` if the two trees are identical, otherwise `False`. **Expected Input/Output**: - The `are_identical_bsts` function will take two inputs, representing the root nodes of the two BSTs. - The function returns a boolean indicating whether the two BSTs are identical. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def are_identical_bsts(root1: TreeNode, root2: TreeNode) -> bool: if not root1 and not root2: return True if not root1 or not root2: return False return (root1.val == root2.val and are_identical_bsts(root1.left, root2.left) and are_identical_bsts(root1.right, root2.right)) # Example Usage if __name__ == \\"__main__\\": # Tree 1 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) # Tree 2 (identical to Tree 1) root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(3) # Tree 3 (different structure) root3 = TreeNode(1) root3.left = TreeNode(2) root3.right = TreeNode(4) print(are_identical_bsts(root1, root2)) # Output: True print(are_identical_bsts(root1, root3)) # Output: False ``` # Example ```python # Creating tree nodes tree_a = TreeNode(5) tree_a.left = TreeNode(3) tree_a.right = TreeNode(8) tree_b = TreeNode(5) tree_b.left = TreeNode(3) tree_b.right = TreeNode(8) tree_c = TreeNode(5) tree_c.left = TreeNode(3) # Comparing two identical trees print(are_identical_bsts(tree_a, tree_b)) # Output: True # Comparing two different trees print(are_identical_bsts(tree_a, tree_c)) # Output: False ``` Note: This question tests the understanding of binary search trees, recursion, and tree traversal techniques. The implementation ensures that the candidate can handle tree structures and the recursive approach effectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def are_identical_bsts(root1: TreeNode, root2: TreeNode) -> bool: Determines if two BSTs are identical. if not root1 and not root2: return True if not root1 or not root2: return False return (root1.val == root2.val and are_identical_bsts(root1.left, root2.left) and are_identical_bsts(root1.right, root2.right))"},{"question":"# Coding Assessment Question Context: You are tasked with improving the backend performance of a social media application by optimizing the way it handles user notifications. The current system delivers notifications sequentially, causing delays. To offer a better user experience, the notification delivery system should be refactored to send notifications in parallel using asynchronous programming techniques. Task: Refactor the provided `send_notifications` function to perform asynchronous notification delivery, handle potential failures gracefully, and implement retries for transient issues. Requirements: 1. **Function Signature**: ```python async def send_notifications(users: list, message: str) -> dict: ``` 2. **Input**: * `users` (list): A list of user identifiers to send the notification to. * `message` (str): The message to be delivered as a notification. 3. **Output**: * `dict`: A dictionary where each user identifier maps to the status of the notification delivery (\'success\' or \'failed\'). 4. **Constraints**: * Handle up to 50 concurrent notifications. * Implement retry logic with up to 2 attempts for network errors or failures. * Ensure proper error handling and fallback for failed delivery attempts. 5. **Performance Requirements**: * The function should efficiently handle concurrency to minimize overall delivery time. * Use asynchronous programming to avoid blocking during network operations. Example Usage: ```python import asyncio users = [1, 2, 3, 4, 5] message = \\"You have a new follower!\\" result = await send_notifications(users, message) # Expected Output Format # { # 1: \\"success\\", # 2: \\"success\\", # 3: \\"failed\\", # 4: \\"failed\\", # 5: \\"success\\" # } ``` Hints: * Utilize the `aiohttp` library for making asynchronous HTTP requests to the notification delivery service. * Use Python\'s `asyncio` for managing concurrent tasks. * Implement proper error handling logic to manage network errors and retries. Good luck!","solution":"import aiohttp import asyncio async def notify_user(user_id, message): url = f\\"http://notification.service/send?user={user_id}&message={message}\\" async with aiohttp.ClientSession() as session: for attempt in range(3): # up to 2 retries try: async with session.get(url) as response: if response.status == 200: return \\"success\\" except aiohttp.ClientError: await asyncio.sleep(2 ** attempt) # exponential backoff return \\"failed\\" async def send_notifications(users: list, message: str) -> dict: tasks = [ notify_user(user, message) for user in users ] results = await asyncio.gather(*tasks) return {user: result for user, result in zip(users, results)} # Example usage: # asyncio.run(send_notifications([1, 2, 3, 4, 5], \\"You have a new follower!\\"))"},{"question":"# Subsequence Identification A subsequence is a sequence derived from another sequence by deleting zero or more elements without changing the order of the remaining elements. Your task is to write a function `is_subsequence` that determines if a given string `s1` is a subsequence of another string `s2`. # Function Signature ```python def is_subsequence(s1: str, s2: str) -> bool: pass ``` # Input * `s1`: A string representing the potential subsequence. * `s2`: A string representing the sequence to check against. # Output * Returns a boolean indicating whether `s1` is a subsequence of `s2`. # Constraints * The input strings will be at most 10^5 characters long. # Example ```python >>> is_subsequence(\\"abc\\", \\"aebdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False >>> is_subsequence(\\"\\", \\"ahbgdc\\") True >>> is_subsequence(\\"abc\\", \\"\\") False >>> is_subsequence(\\"ace\\", \\"abcde\\") True ``` Ensure that your solution efficiently handles large input sizes, considering time complexity in your approach. This question requires an understanding of string manipulation and algorithm optimization to determine subsequence relationships efficiently.","solution":"def is_subsequence(s1: str, s2: str) -> bool: Determines if s1 is a subsequence of s2. Args: s1: A string representing the potential subsequence. s2: A string representing the sequence to check against. Returns: A boolean indicating whether s1 is a subsequence of s2. m, n = len(s1), len(s2) i, j = 0, 0 while i < m and j < n: if s1[i] == s2[j]: i += 1 j += 1 return i == m"},{"question":"# Problem Statement A common operation in image processing is to rotate an image by a certain angle. To simplify the complexities of handling actual image data, we will consider an array of coordinates representing the pixels of an image. Your task is to implement a function that rotates these coordinates by a given angle around the origin (0,0). # Implement the Function ```python from typing import List, Tuple def rotate_coordinates(coordinates: List[Tuple[float, float]], angle_in_degrees: float) -> List[Tuple[float, float]]: Rotate a list of coordinates by a specified angle around the origin. Parameters: - coordinates (List[Tuple[float, float]]): A list of (x, y) tuples representing the coordinates to rotate. - angle_in_degrees (float): The angle by which to rotate the coordinates, in degrees. Returns: - List[Tuple[float, float]]: A list of (x\', y\') tuples representing the rotated coordinates. Example: >>> rotate_coordinates([(1, 0)], 90) [(0.0, 1.0)] >>> rotate_coordinates([(0, 1)], 180) [(0.0, -1.0)] >>> rotate_coordinates([(1, 1)], -45) [(1.4142135624, 0.0)] Constraints: - The result coordinates should be rounded to 10 decimal places. - \'coordinates\' is a list of tuples containing two floats. - \'angle_in_degrees\' is a float and can be any real number. pass ``` # Requirements: 1. **Conversion**: * Convert the angle from degrees to radians for computation. 2. **Rotation Transformation**: * Use the rotation matrix for counterclockwise rotation: [ begin{bmatrix} cos(theta) & -sin(theta) sin(theta) & cos(theta) end{bmatrix} ] * Apply this matrix to each coordinate ((x, y)) to get the new coordinate ((x\', y\')): [ begin{bmatrix} x\' y\' end{bmatrix} = begin{bmatrix} cos(theta) & -sin(theta) sin(theta) & cos(theta) end{bmatrix} begin{bmatrix} x y end{bmatrix} ] 3. **Precision**: * The rotated coordinates should be rounded to 10 decimal places. 4. **Edge Cases**: * Handle various angles and coordinates including both positive and negative values correctly. Implement the `rotate_coordinates` function as described. Use the provided test cases to ensure your function works correctly.","solution":"from typing import List, Tuple import math def rotate_coordinates(coordinates: List[Tuple[float, float]], angle_in_degrees: float) -> List[Tuple[float, float]]: Rotate a list of coordinates by a specified angle around the origin. Parameters: - coordinates (List[Tuple[float, float]]): A list of (x, y) tuples representing the coordinates to rotate. - angle_in_degrees (float): The angle by which to rotate the coordinates, in degrees. Returns: - List[Tuple[float, float]]: A list of (x\', y\') tuples representing the rotated coordinates. Example: >>> rotate_coordinates([(1, 0)], 90) [(0.0, 1.0)] # Convert degrees to radians angle_in_radians = math.radians(angle_in_degrees) # Calculate the rotation matrix components cos_theta = math.cos(angle_in_radians) sin_theta = math.sin(angle_in_radians) rotated_coordinates = [] for x, y in coordinates: x_prime = x * cos_theta - y * sin_theta y_prime = x * sin_theta + y * cos_theta rotated_coordinates.append((round(x_prime, 10), round(y_prime, 10))) return rotated_coordinates"},{"question":"# Binary Search Tree Median You are tasked with writing a function to find the median value in a Binary Search Tree (BST). A BST is a tree structure where each node has at most two children, and for every node, the left subtree\'s values are less than the node\'s value, and the right subtree\'s values are greater than the node\'s value. The median is the middle element in the sorted order of all the nodes\' values. For an even number of nodes, the median is the average of the two middle values. # Function Signatures ```python class TreeNode: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None def find_bst_median(root: TreeNode) -> float: Find the median value in a Binary Search Tree (BST). :param root: TreeNode, the root node of the BST. :return: float, the median value of the BST. pass ``` # Constraints - The tree will have at least one node. - Each node\'s value will be a distinct integer within the range `[-10^6, 10^6]`. - The tree can have a maximum of `10^5` nodes. # Performance Requirements Your solution should aim to minimize the execution time and space, leveraging the properties of the BST. # Example ```python # Example Tree # 4 # / # 2 6 # / / # 1 3 5 7 if __name__ == \\"__main__\\": # Constructing the example tree root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(6) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(5) root.right.right = TreeNode(7) print(find_bst_median(root)) # Output: 4.0 ``` Write your code to implement the `find_bst_median` function.","solution":"class TreeNode: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None def inorder_traversal(root: TreeNode) -> list: Perform an in-order traversal of the BST and return the elements in sorted order. if not root: return [] return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) def find_bst_median(root: TreeNode) -> float: Find the median value in a Binary Search Tree (BST). :param root: TreeNode, the root node of the BST. :return: float, the median value of the BST. # Perform in-order traversal to get elements in sorted order sorted_elements = inorder_traversal(root) n = len(sorted_elements) # Calculate median if n % 2 == 1: median = sorted_elements[n // 2] else: median = (sorted_elements[n // 2 - 1] + sorted_elements[n // 2]) / 2.0 return median"},{"question":"# Task: You are required to implement a class `PriorityQueue` that allows for efficient extraction of both the minimum and maximum elements. This class will provide operations to insert new elements, delete elements, and retrieve the minimum or maximum value, maintaining these operations within efficient time complexity. # Requirements: - Implement necessary methods to manage a priority queue that supports efficient retrieval and deletion of both the minimum and maximum elements. - Ensure that the data structure is optimized for time and space complexity. # Detailed Function Requirements: 1. **`insert(value: int) -> None`**: Inserts `value` into the priority queue. * **Input**: `value` - an integer to be inserted. * **Output**: None. 2. **`delete_min() -> int`**: Deletes the minimum element from the priority queue and returns its value. * **Output**: The value of the deleted minimum element. * **Constraints**: Raises `ValueError` if the priority queue is empty. 3. **`delete_max() -> int`**: Deletes the maximum element from the priority queue and returns its value. * **Output**: The value of the deleted maximum element. * **Constraints**: Raises `ValueError` if the priority queue is empty. 4. **`get_min() -> int`**: Retrieves, but does not delete, the minimum element from the priority queue. * **Output**: The value of the minimum element. * **Constraints**: Raises `ValueError` if the priority queue is empty. 5. **`get_max() -> int`**: Retrieves, but does not delete, the maximum element from the priority queue. * **Output**: The value of the maximum element. * **Constraints**: Raises `ValueError` if the priority queue is empty. # Constraints: - The methods `insert`, `delete_min`, and `delete_max` must operate in O(log n) time complexity. - The methods `get_min` and `get_max` must operate in O(1) time complexity. # Example Usage: ```python pq = PriorityQueue() pq.insert(10) pq.insert(20) pq.insert(5) print(pq.get_min()) # Output: 5 print(pq.get_max()) # Output: 20 print(pq.delete_min()) # Output: 5 print(pq.delete_max()) # Output: 20 print(pq.get_min()) # Output: 10 print(pq.get_max()) # Output: 10 pq.insert(15) pq.insert(25) print(pq.get_min()) # Output: 10 print(pq.get_max()) # Output: 25 ``` # Note: Your implementation should ensure efficient handling of the operations to maintain the priority queue properties. Consider using suitable data structures such as balanced binary search trees or paired heaps to meet the required time complexities.","solution":"import heapq class PriorityQueue: def __init__(self): self.min_heap = [] # This will store all elements as a min-heap self.max_heap = [] # This will store all elements as a max-heap with negative values def insert(self, value: int) -> None: heapq.heappush(self.min_heap, value) heapq.heappush(self.max_heap, -value) def delete_min(self) -> int: if not self.min_heap: raise ValueError(\\"Priority queue is empty\\") min_val = heapq.heappop(self.min_heap) self.max_heap.remove(-min_val) # Remove the corresponding value in max_heap heapq.heapify(self.max_heap) # Re-heapify the max_heap to maintain heap property return min_val def delete_max(self) -> int: if not self.max_heap: raise ValueError(\\"Priority queue is empty\\") max_val = -heapq.heappop(self.max_heap) self.min_heap.remove(max_val) # Remove the corresponding value in min_heap heapq.heapify(self.min_heap) # Re-heapify the min_heap to maintain heap property return max_val def get_min(self) -> int: if not self.min_heap: raise ValueError(\\"Priority queue is empty\\") return self.min_heap[0] def get_max(self) -> int: if not self.max_heap: raise ValueError(\\"Priority queue is empty\\") return -self.max_heap[0]"},{"question":"# Introduction You are designing a system to analyze the connectivity of a network. The goal is to determine how well connected the nodes are by computing a metric known as the clustering coefficient. This coefficient measures the extent to which nodes tend to cluster together. # Problem Description Write a function `clustering_coefficient` that will compute the local clustering coefficient for a given node in an undirected graph. The clustering coefficient is a measure of how interconnected a node\'s neighbors are. Function: `clustering_coefficient` Write a function `clustering_coefficient` that computes the clustering coefficient for a specified node in an undirected graph. **Function Signature**: ```python def clustering_coefficient(graph: Dict[int, List[int]], node: int) -> float: ``` **Input**: - `graph` (Dict[int, List[int]]): An undirected graph represented as a dictionary where keys are node identifiers and values are lists of identifiers of the neighboring nodes. - `node` (int): The identifier of the node for which to compute the clustering coefficient. **Output**: - (float): The clustering coefficient of the specified node. If the node has fewer than two neighbors, return 0. **Constraints**: - The graph must be undirected (if node A is connected to node B, then node B must also be connected to node A). - Node identifiers will be non-negative integers. - The graph will contain at least one node. # Example ```python graph1 = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } assert round(clustering_coefficient(graph1, 0), 2) == 1.0 assert round(clustering_coefficient(graph1, 2), 2) == 0.33 graph2 = { 0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2] } assert round(clustering_coefficient(graph2, 0), 2) == 0.67 ``` # Note - The clustering coefficient C for a node v is given by: ( C(v) = frac{2 cdot text{{number of edges among the neighbors}}}{text{{number of neighbors}} cdot (text{{number of neighbors}} - 1)} ) - Ensure to include appropriate error handling for invalid inputs as specified in the constraints. - The solution should include necessary imports and follow proper coding standards. # Additional Information - A good resource to understand clustering coefficients in graphs is: https://en.wikipedia.org/wiki/Clustering_coefficient","solution":"def clustering_coefficient(graph, node): Calculate the clustering coefficient for a given node in an undirected graph. Parameters: graph (Dict[int, List[int]]): An undirected graph represented as a dictionary. Keys are node identifiers, and values are lists of neighboring nodes. node (int): The identifier of the node for which to compute the clustering coefficient. Returns: float: The clustering coefficient of the specified node. Returns 0 if the node has fewer than 2 neighbors. if node not in graph: return 0 neighbors = graph[node] num_neighbors = len(neighbors) if num_neighbors < 2: return 0 # Count the number of edges among the neighbors neighbor_edges = 0 for i in range(num_neighbors): for j in range(i + 1, num_neighbors): if neighbors[j] in graph[neighbors[i]]: neighbor_edges += 1 # Clustering coefficient calculation possible_edges = num_neighbors * (num_neighbors - 1) / 2 return neighbor_edges / possible_edges"},{"question":"# Question: Implement a Basic Linear Regression Model Context: You are tasked with creating a function that fits a simple linear regression model to a given dataset. The function will calculate the slope and intercept of the line of best fit using the least squares method. This is a fundamental task in statistics and machine learning. Requirements: Implement a function `linear_regression` that: - Takes a list of x-coordinates and a list of y-coordinates of data points. - Returns a tuple with the slope and intercept of the line of best fit. Function Signature: ```python def linear_regression(x_values: list[float], y_values: list[float]) -> tuple[float, float]: ``` Input: - `x_values` (list of float): The x-coordinates of the data points. - `y_values` (list of float): The y-coordinates of the data points. Output: - Returns a tuple with the slope and intercept of the line of best fit (both floats). Constraints: - The length of `x_values` and `y_values` must be the same. - If the lengths of the lists do not match, raise a `ValueError` with the message \\"x_values and y_values must be of the same length\\". - If less than 2 points are provided, raise a `ValueError` with the message \\"At least two data points are required\\" Example: ```python x_values = [1, 2, 3, 4, 5] y_values = [2, 4, 5, 4, 5] result = linear_regression(x_values, y_values) print(result) # Output: (0.6, 2.2) x_values = [0, 1, 2] y_values = [0, 2, 4] result = linear_regression(x_values, y_values) print(result) # Output: (2.0, 0.0) ``` Implement the function according to the above specifications and handle all errors appropriately.","solution":"def linear_regression(x_values: list[float], y_values: list[float]) -> tuple[float, float]: Calculates the slope and intercept of the line of best fit using the least squares method. Args: - x_values (list of float): The x-coordinates of the data points. - y_values (list of float): The y-coordinates of the data points. Returns: - (float, float): A tuple containing the slope and intercept of the line of best fit. Raises: - ValueError: If x_values and y_values have different lengths or if less than 2 points are provided. if len(x_values) != len(y_values): raise ValueError(\\"x_values and y_values must be of the same length\\") if len(x_values) < 2: raise ValueError(\\"At least two data points are required\\") n = len(x_values) sum_x = sum(x_values) sum_y = sum(y_values) sum_xy = sum(x * y for x, y in zip(x_values, y_values)) sum_x_squared = sum(x * x for x in x_values) denominator = n * sum_x_squared - sum_x * sum_x if denominator == 0: raise ValueError(\\"Cannot compute a unique line of best fit\\") slope = (n * sum_xy - sum_x * sum_y) / denominator intercept = (sum_y - slope * sum_x) / n return slope, intercept"},{"question":"# Problem Statement Create a class `MatrixOperations` to perform various operations on a matrix. This class should be capable of handling matrices represented as lists of lists of integers, where each inner list represents a row of the matrix. Implement the `MatrixOperations` class with the following methods: 1. **`__init__`**: - Initialize the matrix with a given 2D list. 2. **`transpose`**: - Return the transpose of the matrix. The transpose of a matrix is obtained by swapping rows with columns. 3. **`rotate_clockwise`**: - Rotate the matrix by 90 degrees in the clockwise direction and return the rotated matrix. 4. **`rotate_counterclockwise`**: - Rotate the matrix by 90 degrees in the counterclockwise direction and return the rotated matrix. 5. **`scalar_multiply`**: - Multiply every element in the matrix by a given scalar value and return the resulting matrix. 6. **`matrix_multiply`**: - Perform matrix multiplication with another matrix and return the resulting matrix. Ensure that matrix multiplication rules (i.e., the number of columns in the first matrix must equal the number of rows in the second matrix) are followed. # Requirements - Each method should handle edge cases appropriately, such as empty matrices or invalid inputs. - Pay attention to the performance of your solutions. Where possible, strive for efficient operations. - Ensure that the mathematical operations follow proper rules and constraints. # Example Usage ```python matrix_ops = MatrixOperations([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Transposing the matrix: assert matrix_ops.transpose() == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] # Rotating the matrix 90 degrees clockwise: assert matrix_ops.rotate_clockwise() == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] # Rotating the matrix 90 degrees counterclockwise: assert matrix_ops.rotate_counterclockwise() == [[3, 6, 9], [2, 5, 8], [1, 4, 7]] # Scaling the matrix elements by 2: assert matrix_ops.scalar_multiply(2) == [[2, 4, 6], [8, 10, 12], [14, 16, 18]] # Multiplying the matrix by another compatible matrix: other_matrix_ops = MatrixOperations([[1, 2], [3, 4], [5, 6]]) assert matrix_ops.matrix_multiply(other_matrix_ops.matrix) == [[22, 28], [49, 64], [76, 100]] ``` # Notes - Ensure that all the edge cases are covered in your implementation and unit tests. - Focus on performance where applicable, especially for larger matrices. - Raise appropriate errors for invalid operations (e.g., dimension mismatch in matrix multiplication). This question should align well with the existing set in terms of style, complexity, and scope, and will test candidates\' understanding of matrix operations and algorithm implementation.","solution":"class MatrixOperations: def __init__(self, matrix): self.matrix = matrix def transpose(self): return [list(row) for row in zip(*self.matrix)] def rotate_clockwise(self): transposed = self.transpose() return [row[::-1] for row in transposed] def rotate_counterclockwise(self): transposed = self.transpose() return transposed[::-1] def scalar_multiply(self, scalar): return [[element * scalar for element in row] for row in self.matrix] def matrix_multiply(self, other_matrix): if len(self.matrix[0]) != len(other_matrix): raise ValueError(\\"Number of columns of the first matrix must be equal to the number of rows of the second matrix.\\") result = [] other_transposed = list(zip(*other_matrix)) for row in self.matrix: new_row = [] for col in other_transposed: new_row.append(sum(x * y for x, y in zip(row, col))) result.append(new_row) return result"},{"question":"# Coding Assessment Question Scenario You have recently joined a team that is developing a simple inventory tracking system for a small store. One of the tasks assigned to you involves tracking the availability of various items in the store. You need to analyze the inventory list to determine which items have become out of stock. Task Write a function `out_of_stock_items(inventory)` that takes a list of dictionaries as input (representing the inventory) and returns a list of item names that are out of stock. Each dictionary will contain two keys: `\'item\'`, which is the name of the item, and `\'quantity\'`, which is the stock count of that item. Input * `inventory`: A list of dictionaries where each dictionary contains the following keys: * `\'item\'`: A string representing the name of the item. * `\'quantity\'`: An integer representing the quantity of the item in stock. Output * A list of strings representing the names of the items that have a quantity of 0. Constraints * The `inventory` list will contain at least one dictionary. * Each dictionary will always contain both `\'item\'` and `\'quantity\'` keys. * The `quantity` will be a non-negative integer. Example Input ```python inventory = [ {\'item\': \'apples\', \'quantity\': 10}, {\'item\': \'bananas\', \'quantity\': 0}, {\'item\': \'oranges\', \'quantity\': 5}, {\'item\': \'grapes\', \'quantity\': 0} ] ``` Example Output ```python [\'bananas\', \'grapes\'] ``` This output corresponds to the items \\"bananas\\" and \\"grapes\\" which have a stock quantity of 0. Additional Instructions Make sure your code is efficient and handles the case where all items or none of the items are out of stock correctly. The returned list should be sorted in alphabetical order. Hint To verify the correctness of your solution, you may need to iterate through the inventory list and check the `\'quantity\'` value of each dictionary. If it is 0, collect the `\'item\'` value. Finally, sort and return the collected item names.","solution":"def out_of_stock_items(inventory): Returns a list of item names that are out of stock. Parameters: inventory (list): A list of dictionaries with \'item\' and \'quantity\' keys. Returns: list: A list of strings representing the names of items that are out of stock, sorted alphabetically. out_of_stock = [item[\'item\'] for item in inventory if item[\'quantity\'] == 0] return sorted(out_of_stock)"},{"question":"# Coding Assessment Question You are tasked with implementing a basic version of the A* search algorithm to find the shortest path between two nodes in a given weighted grid. The goal is to navigate through a `m x n` grid where some cells can have varying weights, representing different terrains or obstacles. # Requirements 1. Implement a function `a_star_search(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]` such that: - `grid`: A 2D list where each cell contains a positive integer representing the weight of that cell. - `start`: A tuple (x, y) representing the starting coordinates in the grid. - `end`: A tuple (x, y) representing the target coordinates. - The function returns a list of tuples representing the path from start to end. - If no path is found, return an empty list. 2. Ensure your function correctly implements the A* search algorithm, including: - A heuristic function (such as the Manhattan distance) to estimate the cost from the current cell to the end. - Priority queue (min-heap) to select the next cell to process. - Handling of edge cases where start or end coordinates are out of bounds or coincide with each other. # Example Input and Output ```python >>> grid = [ ... [1, 1, 1, 1], ... [1, 9, 9, 1], ... [1, 1, 1, 1] ... ] >>> start = (0, 0) >>> end = (2, 3) >>> a_star_search(grid, start, end) [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3)] >>> start = (0, 0) >>> end = (3, 3) >>> a_star_search(grid, start, end) [] ``` # Constraints - The dimensions of `grid` will be within the range of 1 to 100 for both `m` and `n`. - The weights will be integers between 1 and 10. - The `start` and `end` coordinates will be valid indices within the grid. # Notes - Consider edge cases where the grid contains obstacles or cells with significantly higher weights, making some paths more challenging to traverse. - Implement efficient handling of the grid traversal to ensure performance remains acceptable for larger grid sizes. Good luck and ensure your solution rigorously follows the principles of the A* search algorithm!","solution":"import heapq from typing import List, Tuple, Dict def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: Calculate the Manhattan distance heuristic for A* search. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def a_star_search(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: Implements the A* search algorithm to find the shortest path in a weighted grid. # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] m, n = len(grid), len(grid[0]) open_set = [] heapq.heappush(open_set, (0 + heuristic(start, end), 0, start)) came_from: Dict[Tuple[int, int], Tuple[int, int]] = {} g_score = {start: 0} while open_set: _, current_cost, current = heapq.heappop(open_set) if current == end: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if 0 <= neighbor[0] < m and 0 <= neighbor[1] < n: tentative_g_score = current_cost + grid[neighbor[0]][neighbor[1]] if tentative_g_score < g_score.get(neighbor, float(\'inf\')): came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score = tentative_g_score + heuristic(neighbor, end) heapq.heappush(open_set, (f_score, tentative_g_score, neighbor)) return []"},{"question":"# Question: Social Media Post Scheduler You are tasked with creating a function that schedules posts to be automatically published on multiple social media platforms at specified times. You must design a function that correctly handles scheduling conflicts and ensures that posts are published on time. **Task** 1. Design a `PostScheduler` class that can schedule posts for multiple platforms. 2. Implement a method to add a post to the schedule with a specified time and platform. 3. Implement a method that checks for any scheduling conflicts (two posts scheduled for the same platform at the same time). 4. Provide functionality to start the scheduler, which will handle the publishing of posts at their scheduled times. 5. Ensure robust error handling and logging for troubleshooting. # Requirements **Class Definition** ```python from datetime import datetime, timedelta import time import logging import threading logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(message)s\') class PostScheduler: def __init__(self): self.schedule = [] self.lock = threading.Lock() def add_post(self, platform: str, post_content: str, publish_time: datetime) -> None: pass # Your implementation here def check_conflicts(self, platform: str, publish_time: datetime) -> bool: pass # Your implementation here def start(self) -> None: pass # Your implementation here ``` **Input** - Platform (str): The social media platform (e.g., \\"Twitter\\", \\"Facebook\\"). - Post Content (str): The content of the post to be published. - Publish Time (datetime): The time at which the post should be published. **Output** - Returns `None`. The `add_post` method should append posts to the schedule and the `start` method should handle automatic publishing. **Constraints** - Implement thread safety using locks when modifying the schedule. - Handle potential conflicts by checking if a post is already scheduled at the same time for the same platform. - Use robust error handling and proper logging for monitoring and debugging. **Example Usage** ```python from datetime import datetime, timedelta import time # Example usage scheduler = PostScheduler() # Add some posts to the schedule scheduler.add_post(\\"Twitter\\", \\"Hello World!\\", datetime.now() + timedelta(seconds=10)) scheduler.add_post(\\"Facebook\\", \\"Hello again, World!\\", datetime.now() + timedelta(seconds=15)) # Start the scheduler scheduler.start() ``` # Note - Log all actions and errors to provide a clear trace of operations. - Ensure the scheduler can handle multiple posts for different platforms without conflicts.","solution":"from datetime import datetime, timedelta import time import logging import threading logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(message)s\') class PostScheduler: def __init__(self): self.schedule = [] self.lock = threading.Lock() def add_post(self, platform: str, post_content: str, publish_time: datetime) -> None: # Check for conflicts before adding the post if self.check_conflicts(platform, publish_time): logging.error(f\\"Conflict detected for {platform} at {publish_time}. Post not scheduled.\\") return with self.lock: self.schedule.append((platform, post_content, publish_time)) self.schedule.sort(key=lambda x: x[2]) logging.info(f\\"Post scheduled on {platform} at {publish_time}.\\") def check_conflicts(self, platform: str, publish_time: datetime) -> bool: with self.lock: for post in self.schedule: if post[0] == platform and post[2] == publish_time: return True return False def start(self) -> None: def run_scheduler(): while True: with self.lock: now = datetime.now() for post in self.schedule[:]: if post[2] <= now: platform, content, publish_time = post self.schedule.remove(post) logging.info(f\\"Publishing post on {platform}: {content}\\") time.sleep(1) scheduler_thread = threading.Thread(target=run_scheduler, daemon=True) scheduler_thread.start()"},{"question":"# Problem Statement: You are tasked with developing a system that filters and sorts a list of user data based on dynamic criteria provided at runtime. Implement the `filter_and_sort_users` function that processes the data to return a filtered and sorted list. # Function Signature: ```python def filter_and_sort_users(users: List[Dict[str, Union[str, int]]], filters: Dict[str, Union[str, int]], sort_key: str) -> List[Dict[str, Union[str, int]]]: pass ``` # Requirements: 1. **Inputs**: - `users`: A list of dictionaries, where each dictionary represents a user with keys as \\"name\\" (str), \\"age\\" (int), and \\"city\\" (str). (1 ≤ len(users) ≤ 1000) - `filters`: A dictionary containing the criteria to filter users. Keys can be \\"age\\" or \\"city\\", and the values are the respective values to filter by. - `sort_key`: A string indicating the key by which the filtered data should be sorted, either \\"name\\" or \\"age\\". 2. **Outputs**: - A list of dictionaries representing the filtered and sorted users. 3. **Constraints**: - The function should filter users based on the criteria provided in the `filters` dictionary. - The filtered list should be sorted by the `sort_key` provided. - Sorting by \\"name\\" should be in ascending alphabetical order. - Sorting by \\"age\\" should be in ascending numerical order. - If the `filters` dictionary is empty, no filtering should be applied. - If the `sort_key` doesn\'t match the valid keys (\\"name\\" or \\"age\\"), raise a `ValueError`. 4. **Performance Consideration**: - Ensure the function handles up to 1000 users efficiently. # Example: ```python users = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"San Francisco\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"David\\", \\"age\\": 30, \\"city\\": \\"New York\\"} ] filters = {\\"age\\": 30} sort_key = \\"name\\" result = filter_and_sort_users(users, filters, sort_key) ``` Expected Output: ```python [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"David\\", \\"age\\": 30, \\"city\\": \\"New York\\"} ] ``` **Note**: - The returned list should match the filtered criteria and be correctly sorted based on the `sort_key`.","solution":"from typing import List, Dict, Union def filter_and_sort_users(users: List[Dict[str, Union[str, int]]], filters: Dict[str, Union[str, int]], sort_key: str) -> List[Dict[str, Union[str, int]]]: # Validate the sort_key if sort_key not in {\\"name\\", \\"age\\"}: raise ValueError(f\\"Invalid sort_key: {sort_key}. Must be \'name\' or \'age\'\\") # Filter the users based on filters filtered_users = users for key, value in filters.items(): filtered_users = [user for user in filtered_users if user.get(key) == value] # Sort filtered users based on sort_key filtered_users.sort(key=lambda x: x[sort_key]) return filtered_users"},{"question":"# Scenario You have been hired by a transportation planning committee to implement a feature for a city transit system. The city\'s subway network is represented as a weighted, undirected graph where stations are nodes and railroads between them have weights indicating the time (in minutes) it takes to travel between those stations. # Task Design a class called `CityTransitSystem` that builds the subway network and provides functionalities to find the shortest travel time between any two given stations. Function Implementations 1. **add_station(station: str) -> None** - Adds a new station to the subway network. 2. **add_railroad(from_station: str, to_station: str, travel_time: int) -> None** - Adds a bi-directional railroad between `from_station` and `to_station` with the given travel time. 3. **shortest_travel_time(start_station: str, end_station: str) -> int** - Returns the shortest travel time between `start_station` and `end_station` using Dijkstra\'s algorithm or any efficient shortest path algorithm. If no path exists, return -1. Constraints - Station names are non-empty strings. - Travel times are positive integers. - The network can contain up to `10^4` stations and `10^5` railroads. Performance Requirements - The `add_station` and `add_railroad` operations should be optimal for insertion. - The `shortest_travel_time` operation should compute efficiently even for large graphs. Example ```python cts = CityTransitSystem() # Adding stations cts.add_station(\\"Central\\") cts.add_station(\\"North\\") cts.add_station(\\"South\\") cts.add_station(\\"East\\") # Adding railroads with travel times cts.add_railroad(\\"Central\\", \\"North\\", 5) cts.add_railroad(\\"Central\\", \\"South\\", 10) cts.add_railroad(\\"North\\", \\"East\\", 15) cts.add_railroad(\\"South\\", \\"East\\", 20) # Finding shortest travel times print(cts.shortest_travel_time(\\"Central\\", \\"East\\")) # Output: 20 print(cts.shortest_travel_time(\\"North\\", \\"South\\")) # Output: 25 print(cts.shortest_travel_time(\\"East\\", \\"North\\")) # Output: 15 print(cts.shortest_travel_time(\\"Central\\", \\"West\\")) # Output: -1 (West is not a station) ``` Implement the `CityTransitSystem` class with the required methods, ensuring optimal performance and handling possible edge cases efficiently.","solution":"import heapq import sys class CityTransitSystem: def __init__(self): self.graph = {} def add_station(self, station): if station not in self.graph: self.graph[station] = {} def add_railroad(self, from_station, to_station, travel_time): self.add_station(from_station) self.add_station(to_station) self.graph[from_station][to_station] = travel_time self.graph[to_station][from_station] = travel_time def shortest_travel_time(self, start_station, end_station): if start_station not in self.graph or end_station not in self.graph: return -1 # Use a min-heap priority queue pq = [(0, start_station)] distances = {station: sys.maxsize for station in self.graph} distances[start_station] = 0 while pq: current_distance, current_station = heapq.heappop(pq) # Early exit if we reached the destination if current_station == end_station: return current_distance if current_distance > distances[current_station]: continue for neighbor, weight in self.graph[current_station].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If the destination is still unreachable return -1 if distances[end_station] == sys.maxsize else distances[end_station]"},{"question":"**Context**: You are developing a task scheduling application that helps users manage their tasks with dependencies. The tasks are represented as a directed acyclic graph (DAG), where vertices represent tasks and edges represent dependencies. **Task**: Implement the `topological_sort` function, which performs a topological sort on the given task dependency graph and returns an ordering of tasks such that each task appears before all tasks it depends on. **Function Signature**: ```python def topological_sort(tasks: dict) -> list: Perform a topological sort on the given task dependency graph. :param tasks: dict, a dictionary representing the task dependency graph :return: list, a topologically sorted order of tasks ``` # Input: - `tasks` (dict): A dictionary representing the task dependency graph. Each key is a task, and its value is a list of tasks that depend on the key task. # Output: - A list representing a topologically sorted order of tasks. If it\'s not possible to complete all tasks due to cyclic dependencies, return an empty list. # Constraints: - The graph contains no cycles (i.e., it\'s a DAG). # Example: ```python tasks = { \\"Task1\\": [\\"Task2\\", \\"Task3\\"], \\"Task2\\": [\\"Task4\\"], \\"Task3\\": [\\"Task4\\"], \\"Task4\\": [] } assert topological_sort(tasks) == [\\"Task1\\", \\"Task2\\", \\"Task3\\", \\"Task4\\"] or [\\"Task1\\", \\"Task3\\", \\"Task2\\", \\"Task4\\"] assert topological_sort({\\"A\\": [\\"B\\"], \\"B\\": [\\"A\\"]}) == [] ``` # Note: - Consider edge cases such as tasks with no dependencies and completely independent tasks. - Optimize for both runtime and memory usage. **Your implementation will be evaluated on correctness, efficiency, and handling of edge cases.**","solution":"def topological_sort(tasks: dict) -> list: from collections import deque, defaultdict # Calculate in-degrees for each node in_degree = defaultdict(int) for task, dependencies in tasks.items(): if task not in in_degree: in_degree[task] = 0 for dependent_task in dependencies: in_degree[dependent_task] += 1 # Initialize queue with nodes having no incoming edges (in_degree 0) zero_in_degree_queue = deque([task for task in tasks if in_degree[task] == 0]) sorted_order = [] while zero_in_degree_queue: current = zero_in_degree_queue.popleft() sorted_order.append(current) for dependent_task in tasks[current]: in_degree[dependent_task] -= 1 if in_degree[dependent_task] == 0: zero_in_degree_queue.append(dependent_task) # If the sorted order does not contain all tasks, then there is a cycle if len(sorted_order) != len(tasks): return [] return sorted_order"},{"question":"# Question: Implement a Library Management System You are required to implement a `Library` class that manages a collection of books and processes member transactions. Each book and member should be represented as a separate class. The system should support adding books, registering members, and issuing books to members. **Class Definitions**: 1. `Book`: - `__init__(self, title: str, author: str, isbn: str, copies: int)`: Initializes a new book instance with its title, author, ISBN number, and the number of available copies. - `title`, `author`, `isbn`, and `copies` should be instance attributes. 2. `Member`: - `__init__(self, member_id: int, name: str)`: Initializes a new library member with a unique ID and name. - `member_id` and `name` should be instance attributes. 3. `Library`: - `__init__(self)`: Initializes an empty library. - `add_book(self, book: Book) -> None`: Adds a new book or updates the number of copies for an existing book in the library. - `register_member(self, member: Member) -> None`: Registers a new member to the library. - `issue_book(self, isbn: str, member_id: int) -> str`: Issues a book to a member. Returns a message indicating the result of the transaction (e.g., success, book not found, no copies available, or member not registered). **Input & Output Requirements**: - `add_book` and `register_member` methods do not return any value. - `issue_book` should return a string message indicating the outcome. **Constraints**: - A member can have one copy of a particular book at a time. - ISBN numbers are unique across all books. - Member IDs are unique across all members. - The library is not required to manage returning books for this task. # Example ```python # Book instances book1 = Book(\\"1984\\", \\"George Orwell\\", \\"1234567890\\", 5) book2 = Book(\\"Brave New World\\", \\"Aldous Huxley\\", \\"0987654321\\", 3) # Member instances member1 = Member(1, \\"Alice\\") member2 = Member(2, \\"Bob\\") # Library instance library = Library() # Adding books to the library library.add_book(book1) library.add_book(book2) # Registering members library.register_member(member1) library.register_member(member2) # Issuing books print(library.issue_book(\\"1234567890\\", 1)) # Output: \\"Book issued successfully.\\" print(library.issue_book(\\"1234567890\\", 2)) # Output: \\"Book issued successfully.\\" print(library.issue_book(\\"1111111111\\", 1)) # Output: \\"Book not found.\\" print(library.issue_book(\\"1234567890\\", 3)) # Output: \\"Member not registered.\\" print(library.issue_book(\\"0987654321\\", 1)) # Output: \\"Book issued successfully.\\" ``` **Performance Requirements**: - Efficient handling of book search and member lookup for a library collection with up to `10^4` books and members.","solution":"class Book: def __init__(self, title: str, author: str, isbn: str, copies: int): self.title = title self.author = author self.isbn = isbn self.copies = copies class Member: def __init__(self, member_id: int, name: str): self.member_id = member_id self.name = name self.borrowed_books = set() class Library: def __init__(self): self.books = {} self.members = {} def add_book(self, book: Book) -> None: if book.isbn in self.books: self.books[book.isbn].copies += book.copies else: self.books[book.isbn] = book def register_member(self, member: Member) -> None: self.members[member.member_id] = member def issue_book(self, isbn: str, member_id: int) -> str: if isbn not in self.books: return \\"Book not found.\\" if member_id not in self.members: return \\"Member not registered.\\" member = self.members[member_id] book = self.books[isbn] if isbn in member.borrowed_books: return \\"Member already has a copy of this book.\\" if book.copies <= 0: return \\"No copies available.\\" book.copies -= 1 member.borrowed_books.add(isbn) return \\"Book issued successfully.\\""},{"question":"# Problem Statement You are assigned to develop a function that verifies whether a given string can be rearranged into a palindrome. A palindrome is a word or phrase that reads the same forward and backward, ignoring spaces, punctuation, and capitalization. Additionally, implement a function to determine the longest palindromic substring within a given string. # Input 1. **For the first function**: A string `s` which needs to be checked for a potential palindromic rearrangement. 2. **For the second function**: A string `s` from which the longest palindromic substring needs to be found. # Output 1. **For the first function**: A boolean value (`True` or `False`) indicating if the string can be rearranged to form a palindrome. 2. **For the second function**: The longest palindromic substring found within the input string. # Function Signature ```python def can_rearrange_to_palindrome(s: str) -> bool: # Your code here def longest_palindromic_substring(s: str) -> str: # Your code here ``` # Example ```python # Example 1 assert can_rearrange_to_palindrome(\\"civic\\") == True assert can_rearrange_to_palindrome(\\"ivicc\\") == True assert can_rearrange_to_palindrome(\\"hello\\") == False # Example 2 assert longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" ``` # Constraints 1. ( 1 leq text{len}(s) leq 10^5 ) 2. The input string `s` will consist of lowercase and uppercase English letters only. # Notes - Efficiency is key, consider time complexity when implementing the algorithms. - Ensure the solution gracefully handles strings of varying lengths and compositions.","solution":"def can_rearrange_to_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character char_count = Counter(s) # Count the number of characters with an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # We can form a palindrome if there is at most one character with an odd frequency return odd_count <= 1 def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string. if not s: return \\"\\" n = len(s) start = 0 max_length = 1 # Dynamic Programming table dp = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): dp[i][i] = True # Check for palindrome of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for palindrome of length greater than 2 for length in range(3, n + 1): # length of the palindrome for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True start = i max_length = length return s[start:start + max_length]"},{"question":"# Problem Statement A company has hired you to help them analyze the effectiveness of their project management. They want to track the duration of various tasks and determine which project has the longest average task duration. Each project is represented by a list of tasks, and each task is represented by its duration in days. You need to write a function that receives a list of projects, where each project is a list of task durations, and returns the index of the project with the longest average task duration. # Function Signature ```python def longest_avg_task(projects: list) -> int: Determine the index of the project with the longest average task duration. Args: projects (list of list of int): A list of projects, each containing a list of task durations. Returns: int: The index of the project with the longest average task duration. If multiple projects have the same longest average duration, return the smallest index. ``` # Input * `projects`: A list of n lists where each inner list contains m integers representing the task durations for a project. - 1 ≤ n ≤ 100 (number of projects) - 1 ≤ m ≤ 100 (number of tasks per project) - 1 ≤ task duration ≤ 1000 # Output * An integer representing the index of the project with the longest average task duration. If multiple projects have the same longest average duration, return the smallest index. # Examples ```python assert longest_avg_task([[5, 3, 2], [10, 2], [8, 8, 8], [1]]) == 2 assert longest_avg_task([[10, 10, 10], [1, 1, 1], [5, 5, 5]]) == 0 assert longest_avg_task([[3], [7, 2, 4], [1, 2, 3, 4]]) == 1 ``` # Explanation * In the first example, the average durations are: - Project 0: (5 + 3 + 2) / 3 = 3.33 - Project 1: (10 + 2) / 2 = 6.0 - Project 2: (8 + 8 + 8) / 3 = 8.0 - Project 3: 1 Project 2 has the highest average of 8.0, so the function returns index 2. * In the second example, the average durations are: - Project 0: (10 + 10 + 10) / 3 = 10.0 - Project 1: (1 + 1 + 1) / 3 = 1.0 - Project 2: (5 + 5 + 5) / 3 = 5.0 Project 0 has the highest average of 10.0, so the function returns index 0. * In the third example, the average durations are: - Project 0: 3 - Project 1: (7 + 2 + 4) / 3 = 4.33 - Project 2: (1 + 2 + 3 + 4) / 4 = 2.5 Project 1 has the highest average of 4.33, so the function returns index 1. # Additional Context Ensure your function runs efficiently even with the maximum constraints. Consider edge cases where task durations within a project are identical or all projects have only one task each.","solution":"def longest_avg_task(projects): Determine the index of the project with the longest average task duration. Args: projects (list of list of int): A list of projects, each containing a list of task durations. Returns: int: The index of the project with the longest average task duration. If multiple projects have the same longest average duration, return the smallest index. max_avg = -1 max_index = -1 for i, tasks in enumerate(projects): avg = sum(tasks) / len(tasks) if avg > max_avg: max_avg = avg max_index = i return max_index"},{"question":"# Problem Statement You need to implement a function that finds the longest substring of consecutive repeated characters in a given string. The function should return the substring itself and its length. # Function Signature ```python def longest_repeated_substring(s: str) -> tuple: ``` # Input * A single string `s`. # Output * A tuple containing the longest repeated substring and its length. # Constraints * The input string can be of any length and may contain any characters, including spaces and special characters. * If there are multiple substrings of the same maximum length, return the first one found. * The input will always be a valid string. # Examples ```python longest_repeated_substring(\\"aabbccdd\\") => (\'aa\', 2) longest_repeated_substring(\\"ababa\\") => (\'a\', 1) longest_repeated_substring(\\"aaaabbcc\\") => (\'aaaa\', 4) longest_repeated_substring(\\"abcdee\\") => (\'ee\', 2) longest_repeated_substring(\\"a\\") => (\'a\', 1) longest_repeated_substring(\\"abbaaaacccccccccdd\\") => (\'ccccccccc\', 9) ``` # Additional Information * Your implementation should find the longest substring of consecutive repeated characters efficiently. * Handle edge cases such as an empty string or a string with no repeated characters gracefully. # Implementation Challenge While implementing the function, ensure to optimize for time complexity. You might want to use a single pass or linear scan approach to determine the longest repeated substring for efficiency. Document your code to clarify how your approach ensures correctness and efficiency.","solution":"def longest_repeated_substring(s: str) -> tuple: if not s: return (\\"\\", 0) max_len = 1 max_substr = s[0] current_len = 1 current_char = s[0] for i in range(1, len(s)): if s[i] == current_char: current_len += 1 else: if current_len > max_len: max_len = current_len max_substr = current_char * current_len current_char = s[i] current_len = 1 # check last sequence if current_len > max_len: max_len = current_len max_substr = current_char * current_len return (max_substr, max_len)"},{"question":"# Question: Sum of Paths in a Binary Tree You are given a binary tree where each node contains a single digit (0-9). Your task is to write a function that returns the sum of all the numbers formed by the root-to-leaf paths. For example, in the following tree: ``` 1 / 2 3 / / 4 5 6 7 ``` The root-to-leaf paths are: - 124 - 125 - 136 - 137 The sum is `124 + 125 + 136 + 137 = 522`. # Function Signature ```python def sum_root_to_leaf_numbers(root: TreeNode) -> int: ``` # Input - `root` (TreeNode): The root of the binary tree, where `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - Returns an integer representing the sum of all the numbers formed by the root-to-leaf paths. # Constraints 1. The number of nodes in the tree is in the range `[1, 1000]`. 2. The value of each node is an integer between `[0, 9]`. # Example ```python # Example 1: # 1 # / # 2 3 # Output: 25 # Explanation: 12 + 13 = 25 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) print(sum_root_to_leaf_numbers(root)) # Output: 25 # Example 2: # 4 # / # 9 0 # / # 5 1 # Output: 1026 # Explanation: 495 + 491 + 40 = 1026 root = TreeNode(4) root.left = TreeNode(9) root.right = TreeNode(0) root.left.left = TreeNode(5) root.left.right = TreeNode(1) print(sum_root_to_leaf_numbers(root)) # Output: 1026 ``` # Hints 1. Use DFS (Depth-First Search) to traverse the tree. 2. Maintain the current number formed along the path as you traverse the tree. 3. When you reach a leaf node, add the current number to the result.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf_numbers(root: TreeNode) -> int: def dfs(node, current_sum): if not node: return 0 current_sum = current_sum * 10 + node.val if not node.left and not node.right: return current_sum return dfs(node.left, current_sum) + dfs(node.right, current_sum) return dfs(root, 0)"},{"question":"# Coding Assessment Question Context As part of a software package for processing and analyzing textual data, you need to implement a function that counts the number of unique words in a given list of strings (sentences). Words are considered equal if they match exactly, including case sensitivity. Task Implement a function `unique_word_count(sentences: List[str]) -> int` that counts and returns the number of unique words from the provided list of sentences. The function takes one parameter: 1. `sentences`: A list of strings, where each string represents a sentence. Words should be extracted by splitting sentences using spaces. Consider punctuation marks as part of the words. Input and Output Format **Input**: * `sentences`: List of strings - a list of sentences. **Output**: * int - the number of unique words. Constraints * The list `sentences` will contain between 1 and 100 sentences. * Each sentence will contain between 1 and 100 characters. Examples ```python # Example 1 sentences = [\\"Hello world\\", \\"Hello there\\", \\"world of Python\\"] unique_word_count(sentences) # Expected Output: 5 # Example 2 sentences = [\\"Test the function\\", \\"function testing\\"] unique_word_count(sentences) # Expected Output: 4 # Example 3 sentences = [\\"One two three\\", \\"three two one\\", \\"ONE Two THREE\\"] unique_word_count(sentences) # Expected Output: 7 ``` Ensure the implementation correctly identifies unique words, taking into account case sensitivity and punctuation, and accurately counts them across all provided sentences.","solution":"from typing import List def unique_word_count(sentences: List[str]) -> int: Counts and returns the number of unique words from the provided list of sentences. Parameters: sentences (List[str]): A list of sentences Returns: int: The number of unique words unique_words = set() for sentence in sentences: words = sentence.split() # Split the sentence into words using spaces as delimiters unique_words.update(words) # Add the words to the set of unique words return len(unique_words)"},{"question":"**Context**: As part of a new data analytics feature, you are developing a tool that can identify the most frequent element in a data stream. The challenge is that the memory needed to store the entire data stream is very high. Therefore, you\'ve decided to implement an efficient algorithm to find the most frequent element using the Boyer-Moore Voting Algorithm. **Problem**: Write a function `most_frequent_element` that finds the most frequent element in a list using the Boyer-Moore Voting Algorithm. **Function Signature**: ```python def most_frequent_element(data: list) -> int: ``` **Input**: * A list `data` containing integers. The length of the list can be up to 10^6 elements. **Output**: * Return the integer that appears most frequently in the list. If there are multiple elements with the same highest frequency, return any one of them. **Constraints**: * The input list is non-empty. * The list may contain up to 10^6 elements. * Elements in the list are guaranteed to be integers. **Performance requirements**: * The solution should run in O(n) time complexity where n is the length of the list. **Example**: ```python data = [2, 2, 1, 1, 1, 2, 2] output = most_frequent_element(data) print(output) # Expected: 2 data = [4, 4, 4, 2, 2, 2, 4] output = most_frequent_element(data) print(output) # Expected: 4 (as it appears more frequently than 2) ```","solution":"def most_frequent_element(data): Finds the most frequent element in a list using the Boyer-Moore Voting Algorithm. candidate = None count = 0 for num in data: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"# Context: You are designing a text processing tool that requires the ability to generate readable strings without consecutive repeated words. This is particularly useful for cleaning up user input, documents, and automatic report generation. # Problem Statement: Write a function `remove_consecutive_repeats(s: str) -> str` that removes consecutive repeated words in a given string while preserving the original order of the remaining words. Your implementation should: 1. Remove any leading and trailing whitespace from the input string. 2. Split the string into individual words. 3. Remove consecutive repeated words while maintaining the original order. 4. Join the words back into a single string, with a single space between words. # Input: * A string `s` (length <= 2000), which may contain leading and trailing whitespace, and words separated by one or more spaces. Words are any continuous sequence of non-space characters. # Output: * A string with consecutive repeated words removed, preserving the original order of remaining words. # Constraints: * The input string will only contain printable ASCII characters and spaces. * Words are case-sensitive, meaning \\"Hello\\" and \\"hello\\" are considered different words. # Examples: ```python >>> remove_consecutive_repeats(\\"This is is a test test string\\") \\"This is a test string\\" >>> remove_consecutive_repeats(\\" This is is another test \\") \\"This is another test\\" >>> remove_consecutive_repeats(\\"NoRepeatsHere\\") \\"NoRepeatsHere\\" >>> remove_consecutive_repeats(\\"\\") \\"\\" ``` # Detailed Requirements: 1. Trim any leading/trailing whitespace from the input string. 2. Split the input string into words, using one or more spaces as the delimiter. 3. Iterate over the words and build a result list by excluding consecutive repeated words. 4. Join the list back into a string with a single space between words and return it as the output. By following these guidelines, we can ensure the new question integrates seamlessly with the original set in terms of style, complexity, and scope.","solution":"def remove_consecutive_repeats(s: str) -> str: Removes consecutive repeated words in the given input string while preserving the original order of the remaining words. words = s.strip().split() if not words: return \\"\\" result = [words[0]] for word in words[1:]: if word != result[-1]: result.append(word) return \' \'.join(result)"},{"question":"# Coding Assessment Question Context You have to write a function to determine if an array of integers can be split into two subsets such that the sum of elements in both subsets is equal. This problem has applications in load balancing and partitioning tasks equally in parallel computing. Task Write a Python function `can_partition(nums: List[int]) -> bool` that takes as input a list of integers `nums` and returns `True` if the list can be partitioned into two subsets with equal sums, otherwise `False`. Function Specification - **Input**: - `nums` (List[int]): A list of integers where 1 <= len(nums) <= 200 and 1 <= nums[i] <= 100 for each element nums[i]. - **Output**: - A boolean value `True` if the list can be partitioned into two subsets with equal sums, otherwise `False`. Constraints - The length of the list `nums` will be between 1 and 200. - Each element in the list `nums` will be a positive integer with a maximum value of 100. Example ```python def can_partition(nums: List[int]) -> bool: # Implement the function based on the given algorithm pass # Sample Test Cases print(can_partition([1, 5, 11, 5])) # Expected output: True (two subsets [1, 5, 5] and [11]) print(can_partition([1, 2, 3, 5])) # Expected output: False (no such partition exists) print(can_partition([3, 3, 3, 4, 5])) # Expected output: True (two subsets [3,3,3] and [4,5]) ``` Explanation In the first example, the array can be partitioned into two subsets `[1, 5, 5]` and `[11]` with equal sums of 11. In the second example, there is no way to partition the array into two subsets with equal sums. In the third example, the array can be partitioned into `[3, 3, 3]` and `[4, 5]` with equal sums of 9. Implementation Requirements - Implement an efficient solution considering both time and space complexities. - Make use of dynamic programming techniques to solve the problem optimally.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: Determine if an array of integers can be split into two subsets with equal sums. total_sum = sum(nums) # If total sum is odd, it\'s not possible to partition into equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # dp array to store whether a sum is possible dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): if dp[j - num]: dp[j] = True return dp[target]"},{"question":"# Coding Exercise: Bitwise Operations and Substring Evaluation You are given a function `max_equal_subarray(arr: List[int], subarray_size: int) -> List[int]` which finds the largest subarray of given `subarray_size` where all elements in the subarray are equal. If multiple subarrays of the same size are found, return the subarray which occurs first. If no such subarray exists, return an empty list. # Objective Your task is to implement this function which finds and returns the required subarray while adhering to the input-output constraints and efficiently handling large arrays. # Input and Output - **Input**: A list of integers `arr` and an integer `subarray_size` where 1 ≤ `subarray_size` ≤ len(arr) ≤ 100,000. - **Output**: A list of integers representing the largest equal subarray of size `subarray_size`. # Constraints - You must handle edge cases where `subarray_size` may be greater than the count of any single repeating number in the array. - Consider optimization techniques to avoid excessive computations. - Ensure the solution is well-tested for performance with maximum constraints. # Example ```python >>> max_equal_subarray([1, 2, 2, 2, 3, 3, 3, 3, 1, 2, 2], 3) [3, 3, 3] >>> max_equal_subarray([1, 1, 1, 2, 2, 2, 2, 1, 1], 4) [2, 2, 2, 2] >>> max_equal_subarray([1, 1, 2, 3, 4, 4, 4, 5, 6], 2) [1, 1] >>> max_equal_subarray([1, 2, 3], 4) [] ``` # Notes - For large arrays, focus on sliding window techniques or efficient iteration to determine the subarrays. - Your implementation should prioritize space and time complexity improvements, making it feasible to run within acceptable limits for large inputs. - Pay attention to edge cases such as arrays with no repeating numbers or subarray sizes larger than the repeating sequences. Good luck, and aim for robust and efficient code!","solution":"from typing import List def max_equal_subarray(arr: List[int], subarray_size: int) -> List[int]: n = len(arr) if subarray_size == 1: return [arr[0]] if n > 0 else [] # Initial state max_count = 0 max_value = None current_count = 1 # Iterate through the array for i in range(1, n): if arr[i] == arr[i - 1]: current_count += 1 else: current_count = 1 # Check if we have found a sequence with the required subarray_size if current_count == subarray_size: return arr[i - subarray_size + 1 : i + 1] return []"},{"question":"**[Question 2]: Unique Character String Length** Given a string `s`, implement a function `max_unique_char_length(s: str) -> int` that returns the length of the longest substring that consists of unique characters. # Function Signature ```python def max_unique_char_length(s: str) -> int: ``` # Input * `s` (str): A string of characters (0 ≤ length of `s` ≤ 1000), where each character is a printable ASCII character. # Output * Returns an integer representing the length of the longest substring with all unique characters. # Constraints * Ensure the function can handle all edge cases including an empty string and strings with only one type of character. # Examples ```python >>> max_unique_char_length(\\"abcabcbb\\") 3 # \\"abc\\" >>> max_unique_char_length(\\"bbbb\\") 1 # \\"b\\" >>> max_unique_char_length(\\"pwwkew\\") 3 # \\"wke\\" or \\"kew\\" >>> max_unique_char_length(\\"\\") 0 ``` # Scenario Imagine you are developing a text processing application that performs various string operations. One feature of this application is to identify and work with substrings that contain all unique characters. To optimize performance and enhance functionality, you need to determine the length of the longest substring with unique characters for a given string input. Your task is to implement a function that efficiently provides this information. # Assessment Criteria * Correctness: The solution should return the correct length for given inputs. * Efficiency: The solution should handle large strings quickly. * Code Quality: The solution should be clear, well-documented, and maintainable.","solution":"def max_unique_char_length(s: str) -> int: Returns the length of the longest substring with all unique characters. if not s: return 0 max_length = 0 start = 0 seen = {} for end, char in enumerate(s): if char in seen and seen[char] >= start: start = seen[char] + 1 seen[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Scenario You are building a feature for an application that processes large strings of text data. One of the key requirements is to efficiently identify and eliminate duplicated characters from a string while preserving the order of their first occurrences. # Function Signature ```python def remove_duplicates(input_string: str) -> str: pass ``` # Input * `input_string`: A string that may contain any printable ASCII characters, including spaces and punctuation marks. # Output * A string where all duplicated characters have been removed, and only their first occurrence is retained. # Constraints * The input string can be of any length, including an empty string. * Make sure the final function runs in O(n) time complexity. * Be mindful of edge cases such as empty strings or strings with all unique characters. # Examples ```python remove_duplicates(\\"programming\\") # Output: \\"progamin\\" remove_duplicates(\\"aabbcc\\") # Output: \\"abc\\" remove_duplicates(\\"\\") # Output: \\"\\" remove_duplicates(\\"abcabcabc\\") # Output: \\"abc\\" ``` # Notes * Consider using auxiliary data structures to track the characters that have already been seen. * Ensure no additional memory is wasted unnecessarily. * Think about different character encodings but you can assume the input is standard ASCII for simplicity.","solution":"def remove_duplicates(input_string: str) -> str: Removes duplicated characters from the string while preserving the order of their first occurrence. Args: input_string (str): The input string from which duplicates are to be removed. Returns: str: A new string with duplicates removed. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Scenario A delivery robot moves in a 2D grid where each cell can either be passable or blocked. The robot needs to navigate from the top-left corner to the bottom-right corner of the grid, and it can only move right or down at each step. Write a function to determine the number of distinct paths the robot can take to reach its destination, given that some cells are blocked and cannot be passed through. # Problem Statement Write a Python function `count_paths(grid: List[List[int]]) -> int` that takes a 2D list `grid` as input and returns the number of unique paths from the top-left corner to the bottom-right corner. The cell grid[i][j] will contain `0` for a passable cell and `1` for a blocked cell. The robot can only move right or down and cannot pass through blocked cells. # Constraints - The dimensions of the grid are at least 1x1 and at most 100x100 - The starting cell (0,0) and the destination cell (n-1,m-1) will always be passable (i.e., contain `0`). # Input - A 2D list `grid` of size n x m where `n` and `m` are between 1 and 100, inclusive. # Output - An integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid. # Example ```python assert count_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 assert count_paths([[0, 0], [0, 0]]) == 2 assert count_paths([[0, 1], [0, 0]]) == 1 ``` # Performance Requirements - The algorithm should efficiently calculate the number of distinct paths, taking into account the blocked cells and large grid sizes within reasonable compute time.","solution":"from typing import List def count_paths(grid: List[List[int]]) -> int: Calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid with blocked cells. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 continue if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"# Task You are tasked with creating a program to analyze user data and compute statistical summaries for a set of user attributes in an efficient manner. # Problem Statement **Function Signature**: ```python def compute_stats(user_data: np.ndarray) -> dict: \'\'\' Parameters: user_data (np.ndarray): A 2D array where each row represents a user and each column represents an attribute of that user (e.g., age, height, weight). Returns: dict: A dictionary with keys as attribute indices and values as another dictionary containing \'mean\', \'median\', and \'std_dev\' (standard deviation). \'\'\' ``` Your task is to implement the `compute_stats` function that computes the mean, median, and standard deviation for each attribute column in the `user_data` array. Given the size of the dataset can be very large, your solution needs to be efficient and capable of handling potential large-scale data. # Constraints * `user_data` is a 2D numpy array with real values. * Each attribute (column) can have a number of different data points, but the minimum number of users (rows) is `1` and the maximum is `10^6`. * Each attribute column will have values in the range of [0, 1,000]. # Examples Example 1: * Input: ```python user_data = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) ``` * Output: ```python { 0: {\'mean\': 4.0, \'median\': 4.0, \'std_dev\': 2.449489742783178}, 1: {\'mean\': 5.0, \'median\': 5.0, \'std_dev\': 2.449489742783178}, 2: {\'mean\': 6.0, \'median\': 6.0, \'std_dev\': 2.449489742783178} } ``` Example 2: * Input: ```python user_data = np.array([[10, 20], [30, 40], [50, 60], [70, 80], [90, 100]]) ``` * Output: ```python { 0: {\'mean\': 50.0, \'median\': 50.0, \'std_dev\': 28.722813232690143}, 1: {\'mean\': 60.0, \'median\': 60.0, \'std_dev\': 28.722813232690143} } ``` # Notes * Implement the function efficiently using numpy\'s vectorized operations to leverage performance benefits. * Ensure the function correctly computes the statistics for each attribute even if there are missing values (e.g., NaN).","solution":"import numpy as np def compute_stats(user_data: np.ndarray) -> dict: stats = {} for col in range(user_data.shape[1]): column_data = user_data[:, col] mean = np.nanmean(column_data) median = np.nanmedian(column_data) std_dev = np.nanstd(column_data) stats[col] = { \'mean\': mean, \'median\': median, \'std_dev\': std_dev } return stats"},{"question":"# Task You are given an array of integers representing the order of students in a line. Each student has a distinct height, and you need to sort the students in non-decreasing order of their height. After sorting, you need to find the minimum number of swaps required to arrange them in this order. # Function Signature ```python def minimum_swaps_to_sort(arr: List[int]) -> int: pass ``` # Input * `arr` (List[int]): A list of integers where each integer represents the height of a student. # Output * Returns an integer representing the minimum number of swaps required to sort the array in non-decreasing order. # Constraints * (1 leq len(arr) leq 10^5) * Each height in the array is a distinct integer. # Example ```python arr = [3, 1, 2, 4] assert minimum_swaps_to_sort(arr) == 2 arr = [4, 3, 1, 2] assert minimum_swaps_to_sort(arr) == 3 ``` # Notes 1. The function must handle edge cases such as already sorted arrays or arrays sorted in reverse. 2. Consider using strategies that minimize the time complexity, ensuring the function runs efficiently for large input sizes.","solution":"from typing import List def minimum_swaps_to_sort(arr: List[int]) -> int: n = len(arr) # Create a list of tuples where each tuple is (value, index) of the array arr_index = list(enumerate(arr)) # Sort this list based on the values of the array arr_index.sort(key=lambda x: x[1]) visited = [False] * n swaps = 0 for i in range(n): # If the element is already in the correct place or visited, skip it if visited[i] or arr_index[i][0] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_index[j][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"# Scenario You have been hired as a junior software developer at a manufacturing company. Your task is to help design a software system for monitoring and calculating the efficiency of industrial machines based on their power input and output. Your system should ensure that given values are within reasonable bounds and perform the efficiency calculation efficiently. # Task Write a Python function `calculate_efficiency` to compute the efficiency of an industrial machine using the provided formula. Ensure that the function validates the input power values and raises appropriate errors if the inputs are not valid. # Input - `input_power` (float): Power input to the machine in watts. Must be positive and greater than zero. - `output_power` (float): Power output from the machine in watts. Must be non-negative and less than or equal to the input power. # Output - Return a float representing the efficiency (in percentage) of the machine. # Constraints 1. All inputs must be float numbers. 2. Raise `ValueError` with a descriptive message if any of the following conditions are not met: * Input power must be positive. * Output power must be non-negative. * Output power must be less than or equal to input power. # Examples ```python >>> calculate_efficiency(input_power=500.0, output_power=450.0) 90.0 >>> calculate_efficiency(input_power=0, output_power=300) Traceback (most recent call last): ... ValueError: Input power must be positive >>> calculate_efficiency(input_power=1000.0, output_power=-300.0) Traceback (most recent call last): ... ValueError: Output power must be non-negative >>> calculate_efficiency(input_power=1000.0, output_power=1200.0) Traceback (most recent call last): ... ValueError: Output power must be less than or equal to input power ```","solution":"def calculate_efficiency(input_power, output_power): Calculate the efficiency of an industrial machine. Parameters: input_power (float): Power input to the machine in watts. Must be positive and greater than zero. output_power (float): Power output from the machine in watts. Must be non-negative and less than or equal to input_power. Returns: float: The efficiency of the machine in percentage. if not isinstance(input_power, (int, float)): raise ValueError(\\"Input power must be a float number.\\") if not isinstance(output_power, (int, float)): raise ValueError(\\"Output power must be a float number.\\") if input_power <= 0: raise ValueError(\\"Input power must be positive\\") if output_power < 0: raise ValueError(\\"Output power must be non-negative\\") if output_power > input_power: raise ValueError(\\"Output power must be less than or equal to input power\\") efficiency = (output_power / input_power) * 100 return efficiency"},{"question":"Problem Statement You are tasked with implementing a function that identifies the optimal embedding dimension for a given dataset by evaluating the performance of a machine learning model. The optimal embedding dimension is the one that provides the best prediction accuracy when used as input to the model. # Function to Implement ```python def optimal_embedding_dimension(data, labels, max_dimension, model): Identify the optimal embedding dimension for the given dataset. @param data: A 2D numpy array where each row represents a data sample and each column represents a feature. @param labels: A 1D numpy array containing the labels corresponding to each data sample in \'data\'. @param max_dimension: An integer representing the maximum dimension to consider for embedding. @param model: A machine learning model with fit and score methods. @return: An integer representing the optimal embedding dimension that provides the highest prediction accuracy. # Your code here pass ``` # Input and Output Formats Input - `data`: A 2D numpy array of shape (n_samples, n_features) where each row represents a data sample and each column represents a feature. - `labels`: A 1D numpy array of shape (n_samples,) containing the labels corresponding to each data sample in `data`. - `max_dimension`: An integer indicating the maximum dimension to consider for embedding. - `model`: A machine learning model (such as a classifier or regressor) with `fit` and `score` methods. Output - This function returns an integer representing the optimal embedding dimension that results in the highest prediction accuracy. # Constraints - The `data` array should have at least 2 samples and `max_dimension` should be a positive integer less than or equal to the number of features in `data`. - The `model` should be already instantiated and have `fit` and `score` methods. # Example ```python # Example Input: import numpy as np from sklearn.neighbors import KNeighborsClassifier data = np.array([[0.1, 0.2, 0.5], [0.4, 0.3, 0.9], [0.8, 0.7, 0.5], [0.9, 0.4, 0.5]]) labels = np.array([0, 1, 1, 0]) max_dimension = 2 model = KNeighborsClassifier() # Example Output: # optimal_embedding_dimension(data, labels, max_dimension, model) # Expected return: an integer value representing the optimal embedding dimension, e.g., 1 ``` # Notes - To evaluate the performance for each dimension, you could use dimensionality reduction techniques (e.g., Principal Component Analysis) to project the data into a lower-dimensional space. - The function should attempt different dimensions from 1 up to `max_dimension` and determine the one with the highest prediction accuracy using the `model`\'s `score` method. - You can assume that the dataset is sufficient for training and evaluation purposes.","solution":"import numpy as np from sklearn.decomposition import PCA from sklearn.model_selection import train_test_split def optimal_embedding_dimension(data, labels, max_dimension, model): Identify the optimal embedding dimension for the given dataset. @param data: A 2D numpy array where each row represents a data sample and each column represents a feature. @param labels: A 1D numpy array containing the labels corresponding to each data sample in \'data\'. @param max_dimension: An integer representing the maximum dimension to consider for embedding. @param model: A machine learning model with fit and score methods. @return: An integer representing the optimal embedding dimension that provides the highest prediction accuracy. best_score = -1 best_dimension = 1 X_train, X_test, y_train, y_test = train_test_split(data, labels, test_size=0.2, random_state=42) for dimension in range(1, max_dimension + 1): # Apply PCA transformation pca = PCA(n_components=dimension) X_train_pca = pca.fit_transform(X_train) X_test_pca = pca.transform(X_test) # Fit and score the model model.fit(X_train_pca, y_train) score = model.score(X_test_pca, y_test) # Update the best score and best dimension if needed if score > best_score: best_score = score best_dimension = dimension return best_dimension"},{"question":"# Problem Statement You are given a list of integers representing the scores of different players in a game. Your task is to determine the rank of each player when the scores are sorted in descending order. Ties (equal scores) should receive the same rank, and the next available rank should skip accordingly. For example, if two players are tied for the 2nd position, the next player should be ranked 4th. # Function Signature ```python def calculate_ranks(scores: List[int]) -> List[int]: pass ``` # Input - A list of integers `scores` (1 ≤ len(scores) ≤ 1000, -10^6 ≤ scores[i] ≤ 10^6) representing the scores of players. # Output - A list of integers representing the rank of each player corresponding to their score in the input list. # Constraints - Each score will appear in the input list only once for a specific player. # Example ```python assert calculate_ranks([100, 50, 50, 25]) == [1, 2, 2, 4] assert calculate_ranks([60, 70, 70, 30, 100]) == [3, 1, 1, 5, 0] assert calculate_ranks([85, 85, 85, 70, 100, 23]) == [2, 2, 2, 5, 1, 6] ``` # Explanation - For the scores `[100, 50, 50, 25]`: - 100 is ranked 1st. - The two players with scores 50 are tied for 2nd rank. - The player with a score of 25 is ranked 4th. - For the scores `[60, 70, 70, 30, 100]`: - 100 is ranked 1st. - The two players with scores 70 are tied for 2nd rank. - The player with a score of 60 is ranked 3rd. - The player with a score of 30 is ranked 4th.","solution":"from typing import List def calculate_ranks(scores: List[int]) -> List[int]: This function returns the ranks of each player in the given list of scores in descending order. sorted_scores = sorted(scores, reverse=True) rank_map = {} rank = 1 for idx, score in enumerate(sorted_scores): if score not in rank_map: rank_map[score] = rank rank += 1 ranks = [rank_map[score] for score in scores] return ranks"},{"question":"# Problem Statement You have been provided with a class `Graph` that represents a directed graph. The class contains methods to add edges and determine certain properties of the graph. Your task is to implement a function `find_all_paths` that finds all possible paths between two given nodes in the graph. The `Graph` class includes the following methods: - `add_edge(u, v)`: Adds a directed edge from node `u` to node `v`. Implement the function `find_all_paths` that returns all possible paths from a start node to an end node in the form of a list of lists. # Function Specifications Function Signature ```python def find_all_paths(graph: Graph, start: int, end: int) -> List[List[int]]: ``` Input - `graph (Graph)`: An instance of the `Graph` class representing the graph. - `start (int)`: The starting node for the paths. - `end (int)`: The ending node for the paths. Output - `List[List[int]]`: A list of lists, where each inner list represents a path from the start node to the end node. # Constraints - The graph will not have more than 20 nodes. - The graph may contain cycles. - The start node and end node are guaranteed to exist in the graph. - There can be multiple paths between the start and end nodes, or there can be none. # Example ```python class Graph: def __init__(self): self.edges = {} def add_edge(self, u, v): if u in self.edges: self.edges[u].append(v) else: self.edges[u] = [v] # Example usage graph = Graph() graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 3) # Find all paths from node 0 to node 3 paths = find_all_paths(graph, 0, 3) print(paths) # Output: [[0, 1, 3], [0, 1, 2, 3], [0, 2, 3]] ``` # Notes - Ensure that your function handles cycles in the graph by not revisiting nodes within the same path. - The order of the paths in the result does not matter. - If no paths exist between the start and end nodes, return an empty list. - Consider recursion or a depth-first search approach to find paths efficiently.","solution":"from typing import List class Graph: def __init__(self): self.edges = {} def add_edge(self, u, v): if u in self.edges: self.edges[u].append(v) else: self.edges[u] = [v] def find_all_paths(graph: Graph, start: int, end: int) -> List[List[int]]: def dfs(current_node, end, path, visited): if current_node == end: paths.append(list(path)) return for neighbor in graph.edges.get(current_node, []): if not visited[neighbor]: visited[neighbor] = True path.append(neighbor) dfs(neighbor, end, path, visited) path.pop() visited[neighbor] = False paths = [] visited = [False] * 20 # Assuming max nodes are 20 as per the constraint visited[start] = True dfs(start, end, [start], visited) return paths"},{"question":"# Problem Statement You are given an array of integers representing altitude changes of a hiker walking on a trail. Each element in the array indicates the change in altitude between two consecutive points on the trail. The hiker starts at sea level (altitude 0). Your task is to compute the number of valleys the hiker has walked through. A valley is a sequence of consecutive steps below sea level, starting with a step down from sea level and ending with a step up to sea level. # Function Specification Your task is to implement the following function: ```python def count_valleys(steps: int, path: str) -> int: Count the number of valleys in the hiker\'s path. Parameters: steps (int): The number of steps the hiker takes. path (str): A string describing the path where each character represents a step: \'U\' for up and \'D\' for down. Returns: int: The number of valleys traversed in the path. Example: >>> count_valleys(8, \\"UDDDUDUU\\") 1 >>> count_valleys(12, \\"DDUUDDUDUUUD\\") 2 ``` # Input Format 1. **steps** (int): An integer representing the number of steps taken by the hiker. 2. **path** (str): A string of characters where each character is either \'U\' (up step) or \'D\' (down step). # Output Format An integer representing the number of valleys the hiker walked through. # Constraints 1. ( 2 leq steps leq 10^6 ) 2. The path will only contain \'U\' and \'D\' characters. # Examples ```python >>> count_valleys(8, \\"UDDDUDUU\\") 1 >>> count_valleys(12, \\"DDUUDDUDUUUD\\") 2 ``` # Notes 1. Ensure the function logic correctly handles edge cases, such as no valleys or continuous steps above sea level. 2. Optimize the function to handle the upper limit of steps efficiently without unnecessary computations.","solution":"def count_valleys(steps: int, path: str) -> int: Count the number of valleys in the hiker\'s path. Parameters: steps (int): The number of steps the hiker takes. path (str): A string describing the path where each character represents a step: \'U\' for up and \'D\' for down. Returns: int: The number of valleys traversed in the path. sea_level = 0 current_level = 0 valleys = 0 for step in path: if step == \'U\': current_level += 1 if current_level == sea_level: valleys += 1 elif step == \'D\': current_level -= 1 return valleys"},{"question":"# Problem Statement You are given a list of strings where each string represents a binary number (consisting of 0s and 1s). Write a function `max_consecutive_ones` which finds the maximum number of consecutive 1s in any binary number in the list. # Specifications * **Function Signature**: `def max_consecutive_ones(binary_list: List[str]) -> int:` * **Input**: A list of binary numbers represented as strings. Each string is: * Non-empty * Contains only \'0\' and \'1\' characters * **Output**: An integer representing the maximum number of consecutive 1s found in any string in the list. # Constraints * The length of `binary_list` will be at most 10^5. * Each binary string in `binary_list` will have a length of at most 10^5. # Example ```python binary_list = [\\"1101\\", \\"1110\\", \\"1001\\", \\"111111\\"] print(max_consecutive_ones(binary_list)) # Output should be: 6 (from \\"111111\\") print(max_consecutive_ones([\\"0\\", \\"01\\", \\"011\\"])) # Output should be: 2 (from \\"011\\") print(max_consecutive_ones([\\"101\\", \\"111\\", \\"1001\\"])) # Output should be: 3 (from \\"111\\") print(max_consecutive_ones([\\"0\\", \\"0\\", \\"0\\"])) # Output should be: 1 (from any \\"0\\") ``` # Notes * Your solution should have an optimal time complexity to handle the upper limit of constraints efficiently. * Consider edge cases, such as: * Strings with no \'1\'s * Single character strings * Strings with all \'1\'s * Performance is key given the large potential inputs.","solution":"from typing import List def max_consecutive_ones(binary_list: List[str]) -> int: Finds the maximum number of consecutive 1s in any binary number in the list. Parameters: binary_list (List[str]): A list of strings representing binary numbers. Returns: int: The maximum number of consecutive 1s found in any string in the list. max_count = 0 for binary_string in binary_list: current_count = max(len(seq) for seq in binary_string.split(\'0\')) max_count = max(max_count, current_count) return max_count"},{"question":"Data Structures and Algorithms: Most Frequent Substring Finder You are tasked with implementing an algorithm to find the most frequent substring of a given length in a string. This problem is common in text processing, where identifying repetitive patterns in large texts is crucial. # Problem Statement Write a function `most_frequent_substring` that finds the most frequently occurring substring of a specific length within a given text. If there are multiple substrings with the same highest frequency, return the lexicographically smallest one. # Function Signature ```python def most_frequent_substring(text: str, length: int) -> str: ``` # Input - `text`: A string representing the input text, consisting of lowercase English letters. - `length`: An integer representing the length of the substrings to be considered. # Output - A string representing the most frequently occurring substring of the specified length. If there is a tie, return the lexicographically smallest substring. # Constraints 1. The length of the text will be between 1 and 10^6. 2. The length of the substring (length) will be between 1 and the length of the text. # Requirements 1. **Frequency Calculation**: Calculate the frequency of each substring of the specified length. 2. **Lexicographical Order**: Handle ties by returning the lexicographically smallest substring. 3. **Efficiency**: Ensure the function performs efficiently, especially for large texts. # Example ```python # Sample input text text = \\"banana\\" # Substring length length = 2 # Find the most frequent substring of length 2 result = most_frequent_substring(text, length) print(result) ``` # Expected Output ```python \\"an\\" ``` # Explanation - Substrings of length 2: \\"ba\\", \\"an\\", \\"na\\", \\"an\\", \\"na\\" - Frequencies: {\\"ba\\": 1, \\"an\\": 2, \\"na\\": 2} - The substrings \\"an\\" and \\"na\\" both occur twice. The lexicographically smallest is \\"an\\". # Notes 1. Efficient processing of large texts is required. Consider using data structures that optimize search and frequency calculation. 2. You must handle ties by returning the lexicographically smallest substring properly. By providing a solution to this problem, you will demonstrate your understanding of string manipulation, frequency analysis, and efficient algorithm design.","solution":"from collections import Counter def most_frequent_substring(text, length): Finds the most frequently occurring substring of a specified length within a given text. In case of ties, returns the lexicographically smallest substring. if length > len(text): return \\"\\" # Create a Counter to store the frequency of substrings substring_counter = Counter() # Loop through the text to get all substrings of the specified length for i in range(len(text) - length + 1): substring = text[i:i + length] substring_counter[substring] += 1 # Find the maximum frequency max_frequency = max(substring_counter.values()) # Filter substrings that have the maximum frequency most_frequent_substrings = [substring for substring, count in substring_counter.items() if count == max_frequency] # Return the lexicographically smallest substring among the most frequent ones return min(most_frequent_substrings)"},{"question":"# Coding Assessment Question Question: You are given an integer array `arr` where each element represents the height of a building. You are required to calculate the maximum amount of water that can be trapped after a heavy rain. Water can only be trapped between the buildings where there is a dip in height. Write a function `max_water_trapped(arr: list) -> int` that returns the maximum amount of water that can be trapped between the buildings after the rain. Your function should efficiently handle the input and return the correct maximum volume of trapped water. Function Signature: ```python def max_water_trapped(arr: list) -> int: pass ``` Input: - `arr` (list): A list of non-negative integers representing the heights of the buildings. The length of `arr` will be between 1 and 10^5 and the heights will be between 0 and 10^4. Output: - `int`: An integer representing the maximum amount of water trapped between the buildings. Constraints: - Your implementation should efficiently handle large input sizes with a time complexity of O(n) and space complexity of O(1). Example: ```python >>> max_water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> max_water_trapped([4, 2, 0, 3, 2, 5]) 9 >>> max_water_trapped([1, 1, 1, 1]) 0 >>> max_water_trapped([3, 0, 2]) 2 >>> max_water_trapped([0]) 0 ``` # Additional Information: 1. Use of two-pointer technique or dynamic programming approach is recommended for achieving the required time and space complexities. 2. Ensure to perform input validation and handle edge cases where no water can be trapped.","solution":"def max_water_trapped(arr: list) -> int: if not arr or len(arr) < 3: return 0 left, right = 0, len(arr) - 1 left_max, right_max = arr[left], arr[right] trapped_water = 0 while left < right: if arr[left] < arr[right]: left += 1 left_max = max(left_max, arr[left]) trapped_water += max(0, left_max - arr[left]) else: right -= 1 right_max = max(right_max, arr[right]) trapped_water += max(0, right_max - arr[right]) return trapped_water"},{"question":"# Prime Number Generator with Sieve of Eratosthenes Objective Given an integer `N`, implement the Sieve of Eratosthenes algorithm to find all prime numbers less than or equal to `N`. This algorithm should efficiently identify prime numbers using a boolean array. Function Signature ```python def sieve_of_eratosthenes(n: int) -> List[int]: pass ``` Input 1. `n` (int): The maximum number to check for primality. Output A list of integers representing all prime numbers less than or equal to `n`. Constraints - `2 <= n <= 10^6` Performance Requirements - The implementation should aim for a time complexity of O(n log log n) and space complexity of O(n). Scenario Consider a scenario where a mathematician wants to study prime numbers and needs a list of all prime numbers up to a certain limit `N`. This implementation will facilitate generating this list efficiently, making it easier for the mathematician to further analyze prime numbers. Example ```python n = 30 result = sieve_of_eratosthenes(n) # Expected output: # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ```","solution":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: Use the Sieve of Eratosthenes algorithm to find all prime numbers up to n. :param n: The maximum number to check for primes. :return: A list of all prime numbers less than or equal to n. if n < 2: return [] is_prime = [True] * (n + 1) # Create a boolean array \\"is_prime[0..n]\\" and initialize all entries as true. is_prime[0] = is_prime[1] = False # 0 and 1 are not primes p = 2 while (p * p <= n): # If is_prime[p] is not changed, then it is a prime if is_prime[p]: # Updating all multiples of p to not be primes for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 # Collect all prime numbers prime_numbers = [p for p in range(n + 1) if is_prime[p]] return prime_numbers"},{"question":"# Coding Question: Efficient Network Packet Routing **Context**: Bob is working on optimizing the network packet routing algorithm for his company\'s data center. The data center\'s network is represented as a directed graph where nodes are the routers and edges represent possible data paths between routers. Each edge has a non-negative weight representing the latency of that path. **Objective**: Your task is to implement the `NetworkRouter` class with methods to find the shortest path from a source router to a destination router using Dijkstra\'s algorithm. **Function to Implement**: You need to implement the `NetworkRouter` class with the following methods: ```python class NetworkRouter: def __init__(self, graph: dict[int, list[tuple[int, int]]]): # Initialize method with the network graph. pass def shortest_path(self, start: int, goal: int) -> list[int] | None: # Method to find the shortest path using Dijkstra\'s algorithm. pass ``` **Input Format**: - The constructor `__init__` receives a dictionary `graph` where keys are integers representing the routers, and values are lists of tuples. Each tuple contains two integers `(neighbor, weight)` representing a neighboring router and the latency to that neighbor. - Example: `graph = {0: [(1, 2), (2, 4)], 1: [(3, 1)], 2: [(3, 2)], 3: []}` - The `shortest_path` method receives two integers `start` and `goal` representing the source and destination routers. **Output Format**: - The `shortest_path` method should return the shortest path as a list of integers representing the sequence of routers. If no path exists, return `None`. - Example: `[0, 1, 3]` **Constraints**: - The number of routers can be up to 10,000. - The edge weights (latencies) are non-negative integers. - Assume there is at least one router in the network graph. **Performance Requirements**: - The solution must efficiently handle large graphs, leveraging priority queues for optimal time complexity. **Example**: Given the following graph: ```python graph = { 0: [(1, 2), (2, 4)], 1: [(3, 1)], 2: [(3, 2)], 3: [] } start = 0 goal = 3 ``` Output: - The shortest path should be: `[0, 1, 3]` Write your implementation in the class provided to correctly determine the shortest path using Dijkstra\'s algorithm.","solution":"import heapq from typing import Dict, List, Tuple, Optional class NetworkRouter: def __init__(self, graph: Dict[int, List[Tuple[int, int]]]): self.graph = graph def shortest_path(self, start: int, goal: int) -> Optional[List[int]]: distances = {node: float(\'infinity\') for node in self.graph} previous_nodes = {node: None for node in self.graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we found the goal, construct and return the path if current_node == goal: path = [] while previous_nodes[current_node] is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] path.insert(0, start) # add the start node manually return path if current_distance > distances[current_node]: continue for neighbor, weight in self.graph.get(current_node, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) return None"},{"question":"# Coding Assessment Question: File Metadata Management System You are tasked to design a simple file metadata management system that allows users to store and retrieve metadata attributes of files. The system should support operations to add files, delete files, update metadata, and query metadata. # Requirements - Implement the `add_file(file_name)` function to add a new file to the system. - Implement the `delete_file(file_name)` function to remove a file from the system. - Implement the `update_metadata(file_name, metadata_key, metadata_value)` function to update the metadata attributes of a file. - Implement the `get_metadata(file_name, metadata_key)` function to retrieve the metadata value of a specific attribute for a file. # Input - The file name as a string. - Metadata key and value as a string pair for the update operation. - Note: Metadata should be stored as key-value pairs for each file. # Output - Functions should return appropriate values for their operations: - `add_file`: None - `delete_file`: None - `update_metadata`: None - `get_metadata`: Metadata value as a string if the key exists, else `None`. # Function Signatures ```python def add_file(file_name: str) -> None: pass def delete_file(file_name: str) -> None: pass def update_metadata(file_name: str, metadata_key: str, metadata_value: str) -> None: pass def get_metadata(file_name: str, metadata_key: str) -> str: pass ``` # Constraints - Ensure file names and metadata keys are unique within the system. - If a file does not exist when attempting to update or get metadata, raise a `FileNotFoundError`. - Metadata values are stored as strings. - Assume no more than 1000 files will be handled at a time. # Example ```python if __name__ == \\"__main__\\": add_file(\\"file1.txt\\") update_metadata(\\"file1.txt\\", \\"author\\", \\"Alice\\") print(get_metadata(\\"file1.txt\\", \\"author\\")) # Output: Alice update_metadata(\\"file1.txt\\", \\"author\\", \\"Bob\\") print(get_metadata(\\"file1.txt\\", \\"author\\")) # Output: Bob delete_file(\\"file1.txt\\") try: print(get_metadata(\\"file1.txt\\", \\"author\\")) # Should raise FileNotFoundError except FileNotFoundError: print(\\"File not found.\\") ```","solution":"file_system = {} def add_file(file_name: str) -> None: if file_name not in file_system: file_system[file_name] = {} def delete_file(file_name: str) -> None: if file_name in file_system: del file_system[file_name] def update_metadata(file_name: str, metadata_key: str, metadata_value: str) -> None: if file_name not in file_system: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") file_system[file_name][metadata_key] = metadata_value def get_metadata(file_name: str, metadata_key: str) -> str: if file_name not in file_system: raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") return file_system[file_name].get(metadata_key, None)"},{"question":"# Problem Summary You are given two sorted arrays. Your task is to write a function that finds the median of the combined sorted array. # Function Definition Write a function `find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float` that accepts the following parameters: * `nums1` (List[int]): The first sorted array. * `nums2` (List[int]): The second sorted array. # Output * The function should return a single float, which is the median of the combined sorted array. # Constraints * The length of either array can vary from 0 to 2000. * The arrays may contain negative numbers. * The combined size of the two arrays will not exceed 4000. * The arrays will not necessarily have the same length. # Example Suppose you have the following input arrays: ``` nums1 = [1, 3] nums2 = [2] ``` Calling `find_median_sorted_arrays(nums1, nums2)` should return `2.0` because the combined array is `[1, 2, 3]`, and the median is `2`. Another example: ``` nums1 = [1, 2] nums2 = [3, 4] ``` Calling `find_median_sorted_arrays(nums1, nums2)` should return `2.5` because the combined array is `[1, 2, 3, 4]`, and the median is `(2 + 3) / 2 = 2.5`. # Implementation Guidelines * Consider merging both arrays and then finding the median. * Alternatively, use a more optimized approach to find the median without merging the entire arrays. * The median is the middle element of the combined array or the average of the two middle elements if the number of elements is even. * Ensure your function handles edge cases, such as empty arrays or arrays with negative numbers. # Additional Notes Consider edge cases such as: * Both arrays being empty. * One of the arrays being empty. * Arrays with all duplicate elements.","solution":"from typing import List def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: Finds the median of the combined sorted array formed by the two sorted input arrays. nums = sorted(nums1 + nums2) length = len(nums) if length % 2 == 1: return float(nums[length // 2]) else: mid1 = (length // 2) - 1 mid2 = length // 2 return (nums[mid1] + nums[mid2]) / 2"},{"question":"# Problem Statement: Least Common Multiple (LCM) of Multiple Numbers Context: Calculating the Least Common Multiple (LCM) of two numbers is a common task in programming. This problem extends that concept to finding the LCM of multiple numbers. The LCM of a set of integers is the smallest positive integer that is evenly divisible by each of the integers in the set. Task: Implement a function `find_lcm` that calculates the LCM of a list of integers. Your function should handle both small and large sets of numbers efficiently. Requirements: 1. **Function Signature:** ```python def find_lcm(numbers: List[int]) -> int: Calculates the LCM of a list of integers ``numbers``. ``` 2. The function should handle lists containing any number of integers (including just two integers). 3. Utilize efficient algorithms and mathematical properties to handle large values and long lists of numbers. Input: * **numbers** (List[int]): A list of integers for which the LCM is to be found. Each integer is guaranteed to be greater than or equal to 1. Output: * Returns the Least Common Multiple of all integers in the list. Constraints: * 1 <= len(numbers) <= 10^5 * 1 <= numbers[i] <= 10^9 for all 0 <= i < len(numbers) Example: ```python >>> find_lcm([4, 6, 8]) 24 >>> find_lcm([2, 5, 7, 11]) 770 >>> find_lcm([10, 20, 30, 40]) 120 >>> find_lcm([1, 2, 3, 4, 5]) 60 ``` Notes: * Consider using the relationship between the Greatest Common Divisor (GCD) and LCM for pairs of numbers: LCM(a, b) = abs(a*b) // GCD(a, b). * The example demonstrates the usage of the `find_lcm` function to calculate the LCM of different sets of integers. * Handle edge cases where the list might contain large numbers or a large number of elements, both of which may impact the computational efficiency.","solution":"from typing import List import math from functools import reduce def lcm(a, b): return abs(a * b) // math.gcd(a, b) def find_lcm(numbers: List[int]) -> int: return reduce(lcm, numbers)"},{"question":"# Question: Calculate Loan Repayment Details You are asked to write three functions to calculate different aspects of loan repayment: monthly payment, total payment over the loan term, and the breakdown of interest paid vs. principal repaid in each payment. Each function should handle various input validations and return appropriate amounts, following loan amortization principles. Function 1: `monthly_payment(principal: float, annual_interest_rate: float, loan_term_years: float) -> float` **Calculate the monthly payment to be made over the term of the loan.** - **Input**: - `principal` (float): The initial amount of the loan. - `annual_interest_rate` (float): The annual interest rate. - `loan_term_years` (float): The duration of the loan in years. - **Output**: - `float`: The amount to be paid monthly. - **Constraints**: - `principal` must be greater than 0. - `annual_interest_rate` must be non-negative. - `loan_term_years` must be greater than 0. Function 2: `total_payment(principal: float, annual_interest_rate: float, loan_term_years: float) -> float` **Calculate the total payment made over the loan term.** - **Input**: - `principal` (float): The initial amount of the loan. - `annual_interest_rate` (float): The annual interest rate. - `loan_term_years` (float): The duration of the loan in years. - **Output**: - `float`: The total amount paid after all payments are made. - **Constraints**: - `principal` must be greater than 0. - `annual_interest_rate` must be non-negative. - `loan_term_years` must be greater than 0. Function 3: `repayment_schedule(principal: float, annual_interest_rate: float, loan_term_years: float) -> List[Tuple[float, float, float]]` **Calculate the repayment schedule showing monthly breakdown of interest paid vs. principal repaid.** - **Input**: - `principal` (float): The initial amount of the loan. - `annual_interest_rate` (float): The annual interest rate. - `loan_term_years` (float): The duration of the loan in years. - **Output**: - `List[Tuple[float, float, float]]`: A list, where each tuple contains: - `month` (int): The month number. - `interest_payment` (float): The amount of the payment that goes towards interest. - `principal_payment` (float): The amount of the payment that goes towards the principal. - **Constraints**: - `principal` must be greater than 0. - `annual_interest_rate` must be non-negative. - `loan_term_years` must be greater than 0. # Testing & Validation - Include checks for invalid inputs like negative values for principal, annual interest rate, and term years. - Use various test cases to validate the correctness of your implementation.","solution":"def monthly_payment(principal: float, annual_interest_rate: float, loan_term_years: float) -> float: Calculate the monthly loan payment. :param principal: The initial amount of the loan. :param annual_interest_rate: The annual interest rate as a percentage. :param loan_term_years: The duration of the loan in years. :return: The monthly payment amount. if principal <= 0: raise ValueError(\\"Principal must be greater than 0\\") if annual_interest_rate < 0: raise ValueError(\\"Annual interest rate must be non-negative\\") if loan_term_years <= 0: raise ValueError(\\"Loan term years must be greater than 0\\") monthly_interest_rate = annual_interest_rate / 12 / 100 number_of_payments = loan_term_years * 12 if monthly_interest_rate == 0: return principal / number_of_payments return principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1) def total_payment(principal: float, annual_interest_rate: float, loan_term_years: float) -> float: Calculate the total payment over the loan term. :param principal: The initial amount of the loan. :param annual_interest_rate: The annual interest rate as a percentage. :param loan_term_years: The duration of the loan in years. :return: The total payment amount. return monthly_payment(principal, annual_interest_rate, loan_term_years) * loan_term_years * 12 def repayment_schedule(principal: float, annual_interest_rate: float, loan_term_years: float): Calculate the repayment schedule showing monthly breakdown of interest and principal. :param principal: The initial amount of the loan. :param annual_interest_rate: The annual interest rate as a percentage. :param loan_term_years: The duration of the loan in years. :return: A list of tuples containing month number, interest payment, and principal payment. schedule = [] monthly_interest_rate = annual_interest_rate / 12 / 100 number_of_payments = loan_term_years * 12 fixed_monthly_payment = monthly_payment(principal, annual_interest_rate, loan_term_years) current_principal = principal for month in range(1, number_of_payments + 1): interest_payment = current_principal * monthly_interest_rate principal_payment = fixed_monthly_payment - interest_payment current_principal -= principal_payment schedule.append((month, interest_payment, principal_payment)) return schedule"},{"question":"# Question: Palindrome Permutation Checker Scenario: In text processing tasks, checking for possible palindromes is a common requirement. A permutation of a string is considered a palindrome if it can be rearranged to form a palindrome. For example, the string \\"civic\\" is a palindrome, and the string \\"ivicc\\" can be rearranged to form \\"civic,\\" making it a palindrome permutation. On the other hand, \\"hello\\" is not a palindrome and there is no rearrangement that can make it one. Task: Write a function `can_form_palindrome(s: str) -> bool` that checks if any permutation of the input string `s` can form a palindrome. Implement the function to consider only the alphabetic characters and ignore the case. Function Specifications: 1. `can_form_palindrome(s: str) -> bool` - **Input**: A string `s` of length 1 <= |s| <= 10^5. - **Output**: A boolean value `True` if any permutation of `s` can form a palindrome; otherwise, `False`. Examples: ```python >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"Aibohphobia\\") True >>> can_form_palindrome(\\"No \'x\' in Nixon\\") True >>> can_form_palindrome(\\"Was it a car or a cat I saw?\\") True >>> can_form_palindrome(\\"Random String\\") False ``` Constraints: - Ignore non-alphabetic characters in the input string. - The check should be case-insensitive. Performance Requirements: - The solution must run in linear time O(n) and use linear space O(n). # Explanation: To determine if a string can be rearranged to form a palindrome, observe that for even-length strings, all characters must appear an even number of times. For odd-length strings, at most one character can appear an odd number of times (this character would be the middle one). ```python def can_form_palindrome(s: str) -> bool: from collections import Counter # Convert string to lower case and filter only alphabetic characters cleaned_s = [char.lower() for char in s if char.isalpha()] char_counter = Counter(cleaned_s) # Count characters with an odd frequency odd_counts = sum(count % 2 for count in char_counter.values()) # Return True if at most one character has an odd frequency return odd_counts <= 1 ``` This new question provides a challenge that tests the candidates\' understanding of string manipulation, frequency counting, and palindromes while aligning with the difficulty, length, and scope of the original questions.","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter # Convert string to lower case and filter only alphabetic characters cleaned_s = [char.lower() for char in s if char.isalpha()] char_counter = Counter(cleaned_s) # Count characters with an odd frequency odd_counts = sum(count % 2 for count in char_counter.values()) # Return True if at most one character has an odd frequency return odd_counts <= 1"},{"question":"# Binary Search Tree Path Sum Question Scenario: You are working on a financial analysis tool that needs to track paths of specific transactions within a structured tree model. Each node in this tree contains a transaction amount, and you are required to determine if there exists a path from the root to any leaf such that the sum of transaction amounts equals a given target. Question: Implement a function `has_path_sum(root: TreeNode | None, target_sum: int) -> bool` that checks whether there exists a root-to-leaf path in a binary search tree (BST) such that adding up all the transaction amounts (node values) along the path equals the target sum. The binary search tree node is represented by the `TreeNode` class which has the properties `val` (an integer transaction amount), and `left` and `right` (references to child nodes). # Function Specification: Input: 1. `root` (`TreeNode | None`): The root node of the binary search tree. 2. `target_sum` (`int`): The target sum for the root-to-leaf path. Output: - Returns `True` (`bool`) if such a path exists, otherwise returns `False` (`bool`). # Constraints: - All node values (transaction amounts) in the BST are integers. - The tree can contain up to (10^4) nodes. - The target sum is an integer. - The tree can be empty. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example BST construction # 5 # / # 4 8 # / / # 11 13 4 # / # 7 2 1 root = TreeNode(5, TreeNode(4, TreeNode(11, TreeNode(7), TreeNode(2))), TreeNode(8, TreeNode(13), TreeNode(4, right=TreeNode(1)))) target_sum = 22 result = has_path_sum(root, target_sum) print(f\\"Path Exists: {result}\\") # Output: Path Exists: True ``` **Note:** Focus on ensuring that the function operates within an optimal time complexity, efficiently checking paths only when necessary, and correctly handles cases such as when the tree is empty or paths do not sum to the target value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode | None, target_sum: int) -> bool: if not root: return False if not root.left and not root.right: return root.val == target_sum target_sum -= root.val return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum)"},{"question":"# Matrix Rotation Context In many graphical applications, it is often required to rotate a 2D matrix by 90 degrees, either clockwise or counterclockwise. Understanding matrix manipulations and transformations is crucial in such applications. Problem Statement Implement a function in Python that takes a square 2D NumPy array and returns the array rotated 90 degrees clockwise. This function should handle any square matrix of size ( n times n ). Function Signature ```python def rotate_matrix(matrix: np.ndarray) -> np.ndarray: Rotates a given square matrix 90 degrees clockwise. Parameters: matrix: np.ndarray - Input 2D square NumPy array. Returns: np.ndarray - Rotated 2D square NumPy array. ``` Input/Output Formats - **Input**: A NumPy 2D square array `matrix` of dimension ( n times n ). - **Output**: A NumPy 2D square array `matrix` rotated 90 degrees clockwise. Constraints - The input array will always be a square matrix of dimension ( n times n ). - The function should be efficient and utilize NumPy for matrix operations. - Expected to handle matrices of varying sizes, from very small (e.g., ( 1 times 1 )) to reasonably large (e.g., ( 100 times 100 )). Examples ```python >>> rotate_matrix(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) array([[7, 4, 1], [8, 5, 2], [9, 6, 3]]) >>> rotate_matrix(np.array([[1, 2], [3, 4]])) array([[3, 1], [4, 2]]) >>> rotate_matrix(np.array([[1]])) array([[1]]) ``` Scenarios to Consider - Very small matrices (e.g., ( 1 times 1 ) or ( 2 times 2 )). - Larger matrices to test efficiency. - Edge cases including matrices with uniform values and those with sequential or random values. Implement the `rotate_matrix` function efficiently, ensuring it correctly rotates any given square matrix by 90 degrees clockwise. Test for various edge cases to ensure the function\'s robustness.","solution":"import numpy as np def rotate_matrix(matrix: np.ndarray) -> np.ndarray: Rotates a given square matrix 90 degrees clockwise. Parameters: matrix: np.ndarray - Input 2D square NumPy array. Returns: np.ndarray - Rotated 2D square NumPy array. # First, transpose the matrix transposed_matrix = np.transpose(matrix) # Then, reverse each row to get the rotated matrix rotated_matrix = np.flip(transposed_matrix, axis=1) return rotated_matrix"},{"question":"# Problem Statement You are given an undirected graph represented as an adjacency list. Write a function `find_all_bridges(graph: dict) -> list` that identifies all the bridges in the graph. A bridge (or cut-edge) is an edge that, if removed, will make the graph disconnected. # Input 1. `graph`: A dictionary where keys are nodes and values are lists of nodes to which they are connected. # Output * A list of tuples, where each tuple represents an edge that is a bridge in the graph. Each tuple should be in the format `(a, b)` with `a < b`. # Constraints 1. The graph is undirected and connected. 2. The graph has no parallel edges or self-loops. 3. The number of nodes in the graph will be up to 10^4. 4. The number of edges in the graph will be up to 10^5. # Performance Requirements * The solution must be efficient, ideally with a time complexity of O(V + E), where V is the number of vertices and E is the number of edges. # Example ```python graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4, 5], 4: [3, 5], 5: [3, 4] } print(find_all_bridges(graph)) # Output: [(2, 3)] graph = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } print(find_all_bridges(graph)) # Output: [(0, 1), (1, 2), (2, 3)] ``` # Function Signature ```python def find_all_bridges(graph: dict) -> list: # Your implementation here ```","solution":"def find_all_bridges(graph: dict) -> list: Finds all bridges in the given undirected graph. Parameters: graph (dict): The undirected graph represented as an adjacency list. Returns: list: A list of tuples where each tuple represents an edge that is a bridge. def dfs(node, parent, time): nonlocal time_counter time_counter += 1 discovery_time[node] = low[node] = time_counter for neighbor in graph[node]: if discovery_time[neighbor] == -1: # If the neighbor is not visited parent_map[neighbor] = node dfs(neighbor, node, time + 1) # Check if the subtree rooted at v has a connection back to one of the ancestors of u low[node] = min(low[node], low[neighbor]) # If the lowest vertex reachable from subtree under neighbor is below node in DFS tree if low[neighbor] > discovery_time[node]: bridges.append((min(node, neighbor), max(node, neighbor))) elif neighbor != parent: # Update low value of node for parent function calls low[node] = min(low[node], discovery_time[neighbor]) time_counter = 0 discovery_time = {node: -1 for node in graph} low = {node: -1 for node in graph} parent_map = {node: -1 for node in graph} bridges = [] for node in graph: if discovery_time[node] == -1: dfs(node, -1, 0) return sorted(bridges) # Sample usage: graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4, 5], 4: [3, 5], 5: [3, 4] } print(find_all_bridges(graph)) # Output: [(2, 3)] graph = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } print(find_all_bridges(graph)) # Output: [(0, 1), (1, 2), (2, 3)]"},{"question":"# Coding Assessment Question Scenario You are the lead developer at a software company and tasked with implementing a feature that manages user access permissions based on roles. Each user can have multiple roles, and each role can grant access to multiple resources. The roles also have a hierarchy, meaning that a role can inherit access permissions from another role. Problem Statement Implement a function `get_user_permissions(user_roles: list[str], role_hierarchy: dict[str, list[str]], role_permissions: dict[str, list[str]]) -> list[str]` that computes all the accessible resources for a user based on their roles and the role hierarchy. # Input: * A list of strings `user_roles` representing the roles directly assigned to the user. * A dictionary `role_hierarchy` representing the role inheritance, where keys are role names, and values are lists of role names that are inherited by the key. * A dictionary `role_permissions` representing the permissions granted by each role, where keys are role names, and values are lists of resource names accessible by the key. # Output: * A list of strings representing the names of all accessible resources for the user, without duplicates. # Constraints: * (1 leq text{number of roles} leq 10^4) * Each role and resource is represented using strings with a maximum length of 100 characters. * Assume there are no cyclic dependencies in the role hierarchy. # Example: ```python user_roles_1 = [\\"admin\\", \\"user\\"] role_hierarchy_1 = {\\"admin\\": [\\"manager\\"], \\"manager\\": [\\"user\\"], \\"user\\": []} role_permissions_1 = {\\"admin\\": [\\"res1\\", \\"res2\\"], \\"manager\\": [\\"res3\\"], \\"user\\": [\\"res4\\"]} assert sorted(get_user_permissions(user_roles_1, role_hierarchy_1, role_permissions_1)) == [\\"res1\\", \\"res2\\", \\"res3\\", \\"res4\\"] user_roles_2 = [\\"guest\\"] role_hierarchy_2 = {\\"guest\\": [\\"anonymous\\"], \\"anonymous\\": []} role_permissions_2 = {\\"guest\\": [\\"res5\\"], \\"anonymous\\": [\\"res6\\"]} assert sorted(get_user_permissions(user_roles_2, role_hierarchy_2, role_permissions_2)) == [\\"res5\\", \\"res6\\"] ``` Function Signature ```python def get_user_permissions(user_roles: list[str], role_hierarchy: dict[str, list[str]], role_permissions: dict[str, list[str]]) -> list[str]: pass ``` # Notes: * The solution should efficiently handle the traversal of the role hierarchy and ensure correct aggregation of permissions. * Ensure that permissions are aggregated without duplicates. * Use a depth-first or breadth-first search to aggregate the permissions from all inherited roles.","solution":"def get_user_permissions(user_roles, role_hierarchy, role_permissions): Computes all the accessible resources for a user based on their roles and the role hierarchy Args: user_roles (list of str): roles directly assigned to the user. role_hierarchy (dict of str: list of str): role inheritance where keys are role names and values are lists of role names inherited by the key. role_permissions (dict of str: list of str): permissions granted by each role. Returns: list of str: names of all accessible resources for the user, without duplicates. def dfs(role): if role in visited: return visited.add(role) # accumulate permissions of the current role permissions.update(role_permissions.get(role, [])) # traverse inherited roles for inherited_role in role_hierarchy.get(role, []): dfs(inherited_role) permissions = set() visited = set() # Traverse each role assigned to the user for role in user_roles: dfs(role) return list(permissions)"},{"question":"# Context: You are creating an inventory management system for a warehouse. Each item in the warehouse is identified by a unique code. Some of these codes need to be parsed and converted to provide meaningful information for categorization and logging. # Problem Statement: Write a function `parse_item_code(item_code: str) -> dict` that extracts information from the item code and returns it in a dictionary. The item code follows a strict format: 1. The first three characters represent the item category and are always uppercase letters. 2. The next five characters represent the item\'s serial number and are always digits. 3. The next four characters represent the batch number and consist of uppercase letters and digits. 4. The last character is a checksum letter and is an uppercase letter. Your implementation should: 1. Remove any leading or trailing whitespace from the input string. 2. Validate the format of the item code and raise `ValueError` with a descriptive message if it does not match the required format. 3. Parse the item code and return a dictionary with the extracted components: `category`, `serial_number`, `batch_number`, and `checksum`. # Input: * A string `item_code` (length exactly 13, including possible leading and trailing whitespace). # Output: * A dictionary with keys `category`, `serial_number`, `batch_number`, and `checksum`. # Constraints: * The input string will be exactly 13 characters long after trimming whitespace. # Examples: ```python >>> parse_item_code(\\"ABC12345XY12Z\\") {\'category\': \'ABC\', \'serial_number\': \'12345\', \'batch_number\': \'XY12\', \'checksum\': \'Z\'} >>> parse_item_code(\\" DEF67890AB34Y \\") {\'category\': \'DEF\', \'serial_number\': \'67890\', \'batch_number\': \'AB34\', \'checksum\': \'Y\'} >>> parse_item_code(\\"GHI12 345JKL6M\\") Traceback (most recent call last): ... ValueError: Item code has incorrect format or invalid characters ``` # Detailed Requirements: 1. Remove leading/trailing whitespace. 2. Validate the format: * Item code must be exactly 13 characters long. * The first three characters must be uppercase letters ([A-Z]). * The next five characters must be digits ([0-9]). * The next four characters must be uppercase letters or digits ([A-Z0-9]). * The last character must be an uppercase letter ([A-Z]). 3. Extract and return the components in a dictionary.","solution":"import re def parse_item_code(item_code: str) -> dict: Extracts components from an item code string. Args: item_code (str): The item code string to be parsed. Returns: dict: A dictionary with keys \'category\', \'serial_number\', \'batch_number\', and \'checksum\'. Raises: ValueError: If the item code does not match the required format. item_code = item_code.strip() # Validate the format of the item code if not re.fullmatch(r\\"[A-Z]{3}[0-9]{5}[A-Z0-9]{4}[A-Z]\\", item_code): raise ValueError(\\"Item code has incorrect format or invalid characters\\") # Extract components category = item_code[:3] serial_number = item_code[3:8] batch_number = item_code[8:12] checksum = item_code[12] return { \'category\': category, \'serial_number\': serial_number, \'batch_number\': batch_number, \'checksum\': checksum }"},{"question":"# String Manipulation - Challenge You are required to implement a series of string manipulation functions. These functions perform various operations on strings and aim to test your knowledge of string handling in a programming language. Functions to Implement: 1. `reverse_string(s: str) -> str` - **Input**: - `s` (str): The string to be reversed. - **Output**: A new string that is the reverse of the input string. 2. `is_palindrome(s: str) -> bool` - **Input**: - `s` (str): The string to check for palindromic properties. - **Output**: A boolean indicating whether the input string is a palindrome. A palindrome is a string that reads the same forward and backward, ignoring non-alphanumeric characters and case sensitivity. 3. `to_title_case(s: str) -> str` - **Input**: - `s` (str): The string to convert to title case. - **Output**: A string where the first letter of each word is capitalized and all other letters are lowercase. 4. `anagram_check(s1: str, s2: str) -> bool` - **Input**: - `s1` (str): The first string for anagram comparison. - `s2` (str): The second string for anagram comparison. - **Output**: A boolean indicating whether the two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 5. `compress_string(s: str) -> str` - **Input**: - `s` (str): The string to be compressed. - **Output**: A compressed version of the input string where consecutive, repeated characters are replaced with a single occurrence of the character followed by the count of repetitions. If the compressed string is not shorter than the original string, return the original string. Additional Constraints: * The input strings may contain spaces and special characters except for `compress_string` which deals only with alphabets (a-z and A-Z). * All functions should consider case sensitivity unless stated otherwise. Performance Requirements: * Functions should run efficiently within the constraints of typical input string lengths. Examples: ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"A man a plan a canal Panama\\") == \\"amanaP lanac a nalp a nam A\\" assert is_palindrome(\\"A man, a plan, a canal, Panama\\") == True assert is_palindrome(\\"hello\\") == False assert to_title_case(\\"hello world\\") == \\"Hello World\\" assert to_title_case(\\"a quick brown fox\\") == \\"A Quick Brown Fox\\" assert anagram_check(\\"listen\\", \\"silent\\") == True assert anagram_check(\\"hello\\", \\"world\\") == False assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert compress_string(\\"abcdef\\") == \\"abcdef\\" ``` Implement these functions correctly to handle the given constraints and requirements.","solution":"def reverse_string(s: str) -> str: Returns the reverse of the input string. return s[::-1] def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome; otherwise, returns False. Ignores non-alphanumeric characters and case sensitivity. import re s = re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() return s == s[::-1] def to_title_case(s: str) -> str: Returns the input string with the first letter of each word capitalized and all other letters in lowercase. return s.title() def anagram_check(s1: str, s2: str) -> bool: Returns True if the input strings are anagrams of each other; otherwise, returns False. return sorted(s1.replace(\\" \\", \\"\\").lower()) == sorted(s2.replace(\\" \\", \\"\\").lower()) def compress_string(s: str) -> str: Returns the compressed version of the input string. If the compressed string is not shorter, returns the original string. Compressed version is formed by replacing consecutive repeated characters with a single occurrence of the character followed by the count of repetitions. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(f\\"{s[i - 1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Calculate Students\' Average Grades You are required to write a Python function that calculates and displays the average grade for students from a given list of their grades. Function Signature ```python def calculate_average_grades(students_grades: dict) -> None: ``` Expected Input and Output - The function `calculate_average_grades()` receives one parameter: - `students_grades` (dictionary): A dictionary where keys are student names (strings) and values are lists of grades (floats or integers). - The function will calculate the average grade for each student and print the results in the following format: ``` Student Name: Average Grade e.g., Alice: 85.0 Bob: 90.6 ``` Constraints - All grades should be positive numbers between 0 and 100, inclusive. - Ensure proper handling of empty lists of grades for any student, printing \\"No grades available\\" if the list is empty. Performance Requirements - The function should handle a large number of students and grades efficiently. - Avoid any unnecessary computations to ensure optimal performance. Example Usage ```python students_grades = { \\"Alice\\": [85, 90, 78], \\"Bob\\": [92, 88, 91, 92], \\"Charlie\\": [] } calculate_average_grades(students_grades) ``` Expected Output: ``` Alice: 84.33 Bob: 90.75 Charlie: No grades available ``` Additional Considerations - Ensure the displayed average grades are rounded to two decimal places. - Handle edge cases such as students with no grades and maintain code readability with proper comments and structure.","solution":"def calculate_average_grades(students_grades: dict) -> None: This function receives a dictionary with student names as keys and lists of their grades as values. It calculates the average grade for each student and prints the result. for student, grades in students_grades.items(): if grades: average = sum(grades) / len(grades) print(f\\"{student}: {average:.2f}\\") else: print(f\\"{student}: No grades available\\")"},{"question":"# Matrix Path Finder You have been tasked to help a robot navigate a rectangular grid. The robot can move either right or down from a given cell. Starting from the top-left cell (0,0), the robot needs to find the total number of unique paths to reach the bottom-right cell (m-1, n-1), where m is the number of rows and n is the number of columns in the grid. Task Implement a function: ```python def unique_paths(m: int, n: int) -> int: ``` # Input - `m`: Number of rows in the grid (integer). - `n`: Number of columns in the grid (integer). # Output - Returns the total number of unique paths from the top-left cell to the bottom-right cell (integer). # Constraints - Values for `m` and `n` are positive integers and `1 <= m, n <= 100`. # Examples ```python assert unique_paths(3, 7) == 28 assert unique_paths(3, 2) == 3 assert unique_paths(7, 3) == 28 assert unique_paths(1, 1) == 1 ``` # Notes - Your implementation should efficiently compute the number of unique paths utilizing dynamic programming or combinatorial mathematics. - Ensure that your solution can handle the maximum constraints without significant performance degradation.","solution":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. if m == 1 or n == 1: return 1 # Create a 2D array \'dp\' with m rows and n columns dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from cell (1,1) for i in range(1, m): for j in range(1, n): # The number of ways to reach cell (i, j) is equal to the sum of the number of ways to reach # cell (i-1, j) and the number of ways to reach cell (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Problem Statement You are given an array of integers and a series of range queries. Your task is to implement a function that efficiently calculates the sum of all elements within each specified subarray range. Function Signature ```python def range_sum(arr: list[int], queries: list[tuple[int, int]]) -> list[int]: ``` Parameters * **arr**: A list of integers representing the array. * **queries**: A list of tuples, where each tuple contains two integers (start and end), representing the inclusive range for which to calculate the sum. Returns * A list of integers, where each integer is the sum of the elements in the array for the corresponding query range. Input Constraints * The length of the array `n` can be up to 10^4. * The number of queries `q` can be up to 10^4. * The values in the array are all integers within the range of -10^4 to 10^4. Performance Requirements * The overall time complexity of your solution should be O(n + q). Example ```python # Sample Initialization arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] queries = [(1, 3), (0, 5), (2, 7), (3, 9)] # Explanation: # (1, 3) -> 2 + 3 + 4 = 9 # (0, 5) -> 1 + 2 + 3 + 4 + 5 + 6 = 21 # (2, 7) -> 3 + 4 + 5 + 6 + 7 + 8 = 33 # (3, 9) -> 4 + 5 + 6 + 7 + 8 + 9 + 10 = 49 assert range_sum(arr, queries) == [9, 21, 33, 49] ``` Approach To efficiently solve the problem, you can preprocess the array and calculate prefix sums. The prefix sum array will be used to quickly calculate the sum of elements for any given range. ```python def range_sum(arr: list[int], queries: list[tuple[int, int]]) -> list[int]: # Calculate prefix sums prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] # Answer the queries result = [] for (start, end) in queries: result.append(prefix_sums[end + 1] - prefix_sums[start]) return result ```","solution":"def range_sum(arr: list[int], queries: list[tuple[int, int]]) -> list[int]: Given an array and a list of tuples representing range queries, return a list of sums for each range using prefix sums for efficiency. # Calculate prefix sums prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] # Answer the queries result = [] for (start, end) in queries: result.append(prefix_sums[end + 1] - prefix_sums[start]) return result"},{"question":"# Coding Assessment Question You are a software engineer working on implementing a numerical optimization algorithm for a machine learning model. One of the optimization techniques you need to implement is the RMSprop optimizer. This optimizer is often used to adjust the learning rate for each parameter dynamically. RMSprop works by maintaining a moving average of the squared gradients and using this to adjust the parameters. The formula for updating a parameter ( theta ) at each step ( t ) is as follows: [ E[g^2]_t = beta E[g^2]_{t-1} + (1 - beta)g_t^2 ] [ theta_t = theta_{t-1} - frac{eta}{sqrt{E[g^2]_t + epsilon}}g_t ] where: - ( g_t ) is the gradient of the loss with respect to the parameter ( theta ) at time step ( t ). - ( eta ) is the learning rate. - ( beta ) is the decay rate for the moving average (usually between 0.9 and 0.99). - ( epsilon ) is a small constant to avoid division by zero (typically ( 1e-8 )). Task Write a Python function `rmsprop_update` that applies one step of RMSprop optimization to an array of parameters and their corresponding gradients. The function should update the parameters in place. Example ```python import numpy as np def rmsprop_update(theta, gradients, learning_rate, beta, epsilon): # Implement RMSprop update here pass # Example usage: theta = np.array([1.0, 2.0, 3.0]) gradients = np.array([0.1, -0.2, 0.3]) learning_rate = 0.01 beta = 0.9 epsilon = 1e-8 rmsprop_update(theta, gradients, learning_rate, beta, epsilon) print(theta) # Updated parameters ``` Constraints - Use `numpy` for vectorized operations. - The input arrays for `theta` and `gradients` have the same length. - Avoid using loops. - Input array size can be up to 10^6 elements. Performance Requirement - The function should execute in linear time relative to the size of the input arrays.","solution":"import numpy as np def rmsprop_update(theta, gradients, learning_rate, beta, epsilon, Eg2): Applies one step of RMSprop optimization to update the parameters. Parameters: - theta: numpy array of parameters. - gradients: numpy array of gradients with respect to each parameter. - learning_rate: the learning rate (eta). - beta: the decay rate for the moving average. - epsilon: a small constant to avoid division by zero. - Eg2: the running average of the squared gradients. Returns: - Updated Eg2 and theta in place. Eg2 = beta * Eg2 + (1 - beta) * (gradients ** 2) theta -= learning_rate * gradients / (np.sqrt(Eg2) + epsilon) return Eg2"},{"question":"Efficient Pathfinding in a 2D Maze Context You are developing a software solution for navigating through a 2D maze represented by a grid. Each cell in the grid can either be an open space or blocked, and you need to determine the shortest path from the start point to the endpoint. Your solution will help in pathfinding algorithms for autonomous robots or AI agents in games. Problem Statement Implement a function `find_shortest_path` which takes a single input - a 2D list `maze` - and returns the length of the shortest path from the top-left corner to the bottom-right corner of the maze. The maze consists of only 0s and 1s, where 0 represents an open path and 1 represents a blocked cell. The shortest path can only move horizontally or vertically between adjacent cells. If no such path exists, the function should return -1. Requirements 1. **Input and Output Formats**: - Input for `find_shortest_path`: A 2D list of integers `maze` where each integer is either 0 or 1. - Output for `find_shortest_path`: An integer representing the length of the shortest path, or -1 if no path is possible. 2. **Constraints**: - `maze` dimensions: 1 ≤ len(maze), len(maze[0]) ≤ 1000. - The start point (top-left corner) and end point (bottom-right corner) are always 0 (open space). - The `maze` can contain varying proportions of open spaces and blocked cells. 3. **Performance**: - Ensure the implementation handles large grids efficiently within the given constraints. Example ```python def find_shortest_path(maze: list[list[int]]) -> int: # Implement this function pass # Example usage: maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] shortest_path_length = find_shortest_path(maze) # Expected output: 9 (The length of the shortest path) ``` Notes - Pay attention to edge cases such as a maze with no available path, all cells being open, or all cells being blocked except the start and end points. - Use efficient algorithms like Breadth-First Search (BFS) for finding the shortest path to ensure the solution works within the constraints. - Optimize both time and space complexity for handling the given input size.","solution":"from collections import deque def find_shortest_path(maze): if not maze or not maze[0]: return -1 rows, cols = len(maze), len(maze[0]) if maze[0][0] == 1 or maze[rows-1][cols-1] == 1: return -1 # Directions for right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # BFS initialization queue = deque([(0, 0, 1)]) # (row, col, distance_from_start) visited = {(0, 0)} while queue: row, col, dist = queue.popleft() # Reached the end if row == rows - 1 and col == cols - 1: return dist # Explore neighbors for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and maze[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"**Title**: Customizable String Formatter **Context**: You are to write a set of functions for customizable string formatting tasks. These functions are commonly used in text processing, data cleaning, and user interface development. **Task**: Implement three functions: `capitalize_words`, `replace_substring`, and `strip_whitespace`. # 1. Capitalize Words **Function**: `capitalize_words(s: str) -> str` **Description**: Create a function that capitalizes the first letter of each word in the given string `s`. A word is defined as a sequence of alphabetic characters separated by non-alphabetic characters. **Input**: - `s`: A string. **Output**: - A new string where the first letter of each word is capitalized. # 2. Replace Substring **Function**: `replace_substring(s: str, old: str, new: str, max_replacements: int) -> str` **Description**: Create a function that replaces occurrences of the substring `old` with the substring `new` in the given string `s`, up to `max_replacements` times. If `max_replacements` is -1, replace all occurrences. **Input**: - `s`: A string. - `old`: Substring to be replaced. - `new`: Substring to replace with. - `max_replacements`: Maximum number of replacements to perform. **Output**: - A new string with the specified replacements made. # 3. Strip Whitespace **Function**: `strip_whitespace(s: str, mode: str) -> str` **Description**: Create a function that removes whitespace from the string `s` based on the specified `mode`. The `mode` can be: - `\'left\'`: Strip whitespace from the beginning of the string. - `\'right\'`: Strip whitespace from the end of the string. - `\'both\'`: Strip whitespace from both the beginning and the end of the string. **Input**: - `s`: A string. - `mode`: One of `\'left\'`, `\'right\'`, or `\'both\'`. **Output**: - A new string with whitespace removed as specified by the mode. # Requirements and Constraints: 1. Ensure the functions are robust and handle edge cases, such as empty strings or no occurrences found for replacements. 2. For `capitalize_words`, non-alphabetic characters should delimit words, but be left unchanged. 3. For `replace_substring`, handle the `max_replacements` parameter efficiently. 4. For `strip_whitespace`, ensure only whitespace characters are stripped according to the given mode. **Example Cases**: **Case 1**: ```python assert capitalize_words(\\"hello world! welcome to the universe.\\") == \\"Hello World! Welcome To The Universe.\\" assert capitalize_words(\\"123 coding is fun!\\") == \\"123 Coding Is Fun!\\" ``` **Case 2**: ```python assert replace_substring(\\"foo bar foo\\", \\"foo\\", \\"baz\\", 1) == \\"baz bar foo\\" assert replace_substring(\\"foo bar foo\\", \\"foo\\", \\"baz\\", -1) == \\"baz bar baz\\" ``` **Case 3**: ```python assert strip_whitespace(\\" Hello World! \\", \\"left\\") == \\"Hello World! \\" assert strip_whitespace(\\" Hello World! \\", \\"right\\") == \\" Hello World!\\" assert strip_whitespace(\\" Hello World! \\", \\"both\\") == \\"Hello World!\\" ```","solution":"def capitalize_words(s: str) -> str: Capitalize the first letter of each word in the given string `s`. words = s.split() capitalized_words = [word.capitalize() for word in words] return \' \'.join(capitalized_words) def replace_substring(s: str, old: str, new: str, max_replacements: int) -> str: Replace occurrences of the substring `old` with `new` up to `max_replacements` times in the given string `s`. If `max_replacements` is -1, replace all occurrences. if max_replacements == -1: return s.replace(old, new) return s.replace(old, new, max_replacements) def strip_whitespace(s: str, mode: str) -> str: Remove whitespace from the string `s` based on the specified `mode`. Modes: - \'left\': Strip whitespace from the beginning of the string. - \'right\': Strip whitespace from the end of the string. - \'both\': Strip whitespace from both the beginning and the end of the string. if mode == \'left\': return s.lstrip() elif mode == \'right\': return s.rstrip() elif mode == \'both\': return s.strip() else: raise ValueError(\\"Mode must be \'left\', \'right\', or \'both\'.\\")"},{"question":"# Coding Question In this problem, you will implement a method to find the shortest path from a starting node to a target node in an unweighted graph. Use the Breadth-First Search (BFS) algorithm to find the shortest path and output the path itself. Function Signature ```python def bfs_shortest_path(graph: dict, start: str, target: str) -> List[str]: pass ``` Task 1. **Breadth-First Search (BFS) Implementation**: - Implement the `bfs_shortest_path` function to find the shortest path from the `start` node to the `target` node in the graph using the BFS algorithm. - The function should return the path as a list of node identifiers from the `start` to the `target`. Input - `graph`: A dictionary where keys are node identifiers (strings) and values are lists of adjacent nodes. - `start`: A string representing the starting node identifier. - `target`: A string representing the target node identifier. Output - A list of strings representing the nodes in the shortest path from `start` to `target` (inclusive). - If there is no path, return an empty list. Constraints - All node identifiers are strings of lowercase English letters. - All nodes in the graph are connected, and there are no isolated nodes. - The graph will have at most `10^4` nodes. - Each node will have at most `10^2` edges. - Both `start` and `target` nodes are guaranteed to exist in the graph. Example Usage ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } assert bfs_shortest_path(graph, \'A\', \'F\') == [\'A\', \'C\', \'F\'] assert bfs_shortest_path(graph, \'A\', \'E\') == [\'A\', \'B\', \'E\'] assert bfs_shortest_path(graph, \'D\', \'F\') == [\'D\', \'B\', \'E\', \'F\'] assert bfs_shortest_path(graph, \'G\', \'F\') == [] # Node \'G\' is not in the graph ``` Notes - Make sure the path returned is the shortest possible from `start` to `target`. - The BFS algorithm ensures that we find the shortest path in an unweighted graph. - If multiple shortest paths exist, any one of them can be returned.","solution":"from collections import deque from typing import List, Dict def bfs_shortest_path(graph: Dict[str, List[str]], start: str, target: str) -> List[str]: if start == target: return [start] queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node in visited: continue for neighbor in graph.get(node, []): new_path = list(path) new_path.append(neighbor) queue.append(new_path) if neighbor == target: return new_path visited.add(node) return []"},{"question":"# Question You are required to implement a K-Means Clustering algorithm from scratch to segment customers based on their annual income and spending score, using a customer dataset for a marketing analysis. Dataset Preparation 1. Download the dataset from the link: [Mall Customer Segmentation Data](https://www.kaggle.com/vjchoudhary7/customer-segmentation-tutorial-in-python). 2. Extract the relevant features (Annual Income and Spending Score) for clustering. 3. Normalize the data if necessary to improve clustering performance. K-Means Clustering Implementation 1. Initialize `k` cluster centroids randomly. 2. Assign each customer to the nearest centroid based on Euclidean distance. 3. Recompute centroids as the mean of all assigned customer points. 4. Repeat steps 2 and 3 until centroids no longer change significantly or a set number of iterations are reached. Visualization and Analysis 1. Plot the clustered customers in a 2D plot with different colors indicating different clusters. 2. Annotate the plot with centroids. 3. Measure and display the Sum of Squared Distances (SSD) to evaluate the quality of clustering. Requirements - **Input:** Number of clusters `k`, the dataset of annual income and spending score. - **Output:** A 2D plot of clustered data points, centroids, and the SSD value. - Implement a method to determine a reasonable value of `k` using the Elbow method. # Constraints - Use only basic libraries such as NumPy and Matplotlib. - Do not use built-in clustering functions from libraries like Scikit-learn for the core K-Means algorithm. # Performance - Ensure convergence within a reasonable number of iterations. - Aim for a visually meaningful cluster separation when plotted. # Example: ```python import numpy as np import matplotlib.pyplot as plt # K-Means Algorithm def k_means_clustering(X, k, max_iters=100, tol=1e-4): n_samples, n_features = X.shape centroids = X[np.random.choice(n_samples, k, replace=False)] prev_centroids = np.zeros_like(centroids) for _ in range(max_iters): # Assign clusters distances = np.linalg.norm(X[:, np.newaxis] - centroids, axis=2) cluster_assignment = np.argmin(distances, axis=1) # Update centroids for i in range(k): if np.sum(cluster_assignment == i) == 0: continue centroids[i] = X[cluster_assignment == i].mean(axis=0) # Check for convergence if np.all(np.abs(centroids - prev_centroids) < tol): break prev_centroids = centroids.copy() return cluster_assignment, centroids # Determining the optimal number of clusters with the Elbow Method def plot_elbow_method(X, max_k=10): ssd = [] for k in range(1, max_k + 1): _, centroids = k_means_clustering(X, k) distances = np.min(np.linalg.norm(X[:, np.newaxis] - centroids, axis=2), axis=1) ssd.append(np.sum(distances**2)) plt.plot(range(1, max_k + 1), ssd, marker=\'o\') plt.xlabel(\'Number of clusters\') plt.ylabel(\'Sum of Squared Distances\') plt.title(\'Elbow Method For Optimal k\') plt.show() # Plotting the clusters def plot_clusters(X, cluster_assignment, centroids): plt.scatter(X[:, 0], X[:, 1], c=cluster_assignment, cmap=\'viridis\') plt.scatter(centroids[:, 0], centroids[:, 1], s=300, c=\'red\', marker=\'X\') plt.xlabel(\'Annual Income\') plt.ylabel(\'Spending Score\') plt.title(\'Customer Segmentation\') plt.show() # Usage # Assume X is a 2D NumPy array of annual income and spending score plot_elbow_method(X) k = 5 # from elbow method plot clusters, centroids = k_means_clustering(X, k) plot_clusters(X, clusters, centroids) ```","solution":"import numpy as np import matplotlib.pyplot as plt # K-Means Algorithm def k_means_clustering(X, k, max_iters=100, tol=1e-4): n_samples, n_features = X.shape centroids = X[np.random.choice(n_samples, k, replace=False)] prev_centroids = np.zeros_like(centroids) for _ in range(max_iters): # Assign clusters distances = np.linalg.norm(X[:, np.newaxis] - centroids, axis=2) cluster_assignment = np.argmin(distances, axis=1) # Update centroids for i in range(k): if np.sum(cluster_assignment == i) == 0: continue centroids[i] = X[cluster_assignment == i].mean(axis=0) # Check for convergence if np.all(np.abs(centroids - prev_centroids) < tol): break prev_centroids = centroids.copy() return cluster_assignment, centroids # Determining the optimal number of clusters with the Elbow Method def plot_elbow_method(X, max_k=10): ssd = [] for k in range(1, max_k + 1): cluster_assignment, centroids = k_means_clustering(X, k) distances = np.min(np.linalg.norm(X[:, np.newaxis] - centroids, axis=2), axis=1) ssd.append(np.sum(distances**2)) plt.plot(range(1, max_k + 1), ssd, marker=\'o\') plt.xlabel(\'Number of clusters\') plt.ylabel(\'Sum of Squared Distances\') plt.title(\'Elbow Method For Optimal k\') plt.show() # Plotting the clusters def plot_clusters(X, cluster_assignment, centroids): plt.scatter(X[:, 0], X[:, 1], c=cluster_assignment, cmap=\'viridis\') plt.scatter(centroids[:, 0], centroids[:, 1], s=300, c=\'red\', marker=\'X\') plt.xlabel(\'Annual Income\') plt.ylabel(\'Spending Score\') plt.title(\'Customer Segmentation\') plt.show()"},{"question":"# Coding Question Problem Statement You are given an integer `n` representing the number of stairs, and you need to determine the number of distinct ways to climb to the top. Each time you can either climb 1 step, 2 steps, or 3 steps. Your task is to implement the function `count_ways_to_climb(n: int) -> int` that returns the number of distinct ways to reach the top of a staircase with `n` steps. Function Signature ```python def count_ways_to_climb(n: int) -> int: pass ``` Input - `n` (int): The number of stairs (0 ≤ n ≤ 10^5). Output - Returns an integer representing the number of distinct ways to reach the top of the stairs. Constraints - If the input is not an integer or if it is negative, raise a `ValueError` with the message: - \\"the number of stairs must be a non-negative integer\\" Example ```python assert count_ways_to_climb(4) == 7 assert count_ways_to_climb(5) == 13 assert count_ways_to_climb(6) == 24 try: count_ways_to_climb(-1) except ValueError as e: assert str(e) == \\"the number of stairs must be a non-negative integer\\" try: count_ways_to_climb(5.5) except ValueError as e: assert str(e) == \\"the number of stairs must be a non-negative integer\\" assert count_ways_to_climb(0) == 1 ``` Explanation - To climb 4 steps, the possible ways are: - (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2), (1,3), (3,1) -> 7 ways - To climb 5 steps, the possible ways are: - (1,1,1,1,1), (1,1,1,2), (1,1,2,1), (1,2,1,1), (2,1,1,1), (2,2,1), (2,1,2), (1,2,2), (1,1,3), (1,3,1), (3,1,1), (2,3), (3,2) -> 13 ways","solution":"def count_ways_to_climb(n: int) -> int: if not isinstance(n, int) or n < 0: raise ValueError(\\"the number of stairs must be a non-negative integer\\") # Base cases if n == 0: return 1 if n == 1: return 1 if n == 2: return 2 if n == 3: return 4 # Create a list to store the number of ways to climb to each step dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 dp[3] = 4 # Fill the dp list by using the relationship for i in range(4, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"```markdown # Task: Implement a function that generates all possible substrings of a given string. Substrings are defined as continuous sequences of characters within the string. # Function Specification: ```python def generate_substrings(s: str) -> List[str]: Generates all possible substrings from the given string. Parameters: s (str): The input string. Returns: List[str]: A list of all possible substrings. Examples: >>> generate_substrings(\'abc\') [\'a\', \'ab\', \'abc\', \'b\', \'bc\', \'c\'] >>> generate_substrings(\'\') [] >>> generate_substrings(\'a\') [\'a\'] >>> generate_substrings(\'good\') [\'g\', \'go\', \'goo\', \'good\', \'o\', \'oo\', \'ood\', \'o\', \'od\', \'d\'] # Your code here ``` # Requirements: 1. **Input**: - A non-empty string `s` for which substrings need to be generated. 2. **Output**: - A list of all possible continuous substrings of the given string `s`. 3. **Constraints**: - Ensure the function handles both lowercase and uppercase string characters. - The substrings should be returned in the order they appear in the original string. - The original string may include special characters and numbers. 4. **Error Handling**: - The function should handle an empty string by returning an empty list. # Scenario: Substrings are frequently used in various applications such as searching, pattern matching, and data manipulation. By generating all possible substrings, you can easily apply further operations like counting occurrences, finding palindromes within a string, or preparing for more complex algorithms. # Hint: Iterate through the string using nested loops to extract and collect all possible continuous subsequences. ```","solution":"from typing import List def generate_substrings(s: str) -> List[str]: Generates all possible substrings from the given string. Parameters: s (str): The input string. Returns: List[str]: A list of all possible substrings. substrings = [] for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.append(s[i:j]) return substrings"},{"question":"# Sudoku Solver Algorithm As a developer for an educational software company, you are tasked with creating a feature that allows students to solve Sudoku puzzles. A Sudoku puzzle is a 9x9 grid partially filled with digits from 1 to 9. The goal is to complete the grid such that each row, column, and 3x3 sub-grid contains all digits from 1 to 9 without repeating. Write a Python function `solve_sudoku` that accepts a partially filled Sudoku grid (a list of lists representing a 9x9 grid) and returns a completed grid that solves the puzzle. The input grid is a 9x9 list of lists where each inner list contains 9 integers, where 0 represents an empty cell. # Example Input and Usage ```python grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solve_sudoku(grid) # Output: A completed grid, for example: [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] ``` # Constraints - The input grid is guaranteed to be a 9x9 list of lists with integers from 0 to 9. - The puzzle will have a unique solution. - You must validate that inserting a number in a cell does not break the Sudoku rules. # Implementation ```python def solve_sudoku(grid: list[list[int]]) -> list[list[int]]: # Helper function to check if a number can be placed in a given cell def is_valid(board, row, col, num): # Check row for x in range(9): if board[row][x] == num: return False # Check column for x in range(9): if board[x][col] == num: return False # Check 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True # Helper function to solve the Sudoku puzzle def solve(board): for i in range(9): for j in range(9): if board[i][j] == 0: for num in range(1, 10): if is_valid(board, i, j, num): board[i][j] = num if solve(board): return True board[i][j] = 0 return False return True # Call the solver function solve(grid) return grid ``` Your task is to complete the `solve_sudoku` function ensuring the puzzle is solved correctly and efficiently while adhering to the standard Sudoku rules.","solution":"def solve_sudoku(grid): Solves the Sudoku puzzle and returns the completed grid. def is_valid(board, row, col, num): # Check row for x in range(9): if board[row][x] == num: return False # Check column for x in range(9): if board[x][col] == num: return False # Check 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True def solve(board): for i in range(9): for j in range(9): if board[i][j] == 0: for num in range(1, 10): if is_valid(board, i, j, num): board[i][j] = num if solve(board): return True board[i][j] = 0 return False return True solve(grid) return grid"},{"question":"# Coding Assessment Question Scenario You are tasked with designing a system that can efficiently manage a dynamic list of stock prices and rapidly compute the average price for a given range. To ensure efficient updates and queries, you decide to utilize a Fenwick Tree (Binary Indexed Tree). Task Implement the `update` and `query_range` functions to manage the stock prices and compute the average price over specified ranges. Additionally, implement the `build_fenwick_tree` function to initialize the tree from an existing list of stock prices. Function Definitions 1. **build_fenwick_tree**: * **Input**: A list of integers representing stock prices. * **Output**: A Fenwick Tree (Binary Indexed Tree) initialized with the given stock prices. * **Constraints**: - The input list may be empty. - The values may be negative, zero, or positive. 2. **update**: * **Input**: - A Fenwick Tree. - An integer `index` representing the position of the stock price to update. - An integer `value` representing the new stock price. * **Output**: None. * **Constraints**: - Ensure the index is within the valid range. - Handle updates efficiently. 3. **query_range**: * **Input**: - A Fenwick Tree generated from `build_fenwick_tree`. - Two integers (`left_bound`, `right_bound`) representing the range for the query. * **Output**: A float representing the average stock price in the range `[left_bound, right_bound]`. * **Constraints**: - Ensure the bounds are within the valid range. - Handle cases where the bounds are invalid. Sample Usage ```python fenwick_tree = build_fenwick_tree([10, 20, 30, 40, 50]) assert query_range(fenwick_tree, 1, 3) == 30.0 # Average of [20, 30, 40] update(fenwick_tree, 2, 35) assert query_range(fenwick_tree, 1, 3) == 31.667 # Average of [20, 35, 40] fenwick_tree = build_fenwick_tree([5, 15, 25]) assert query_range(fenwick_tree, 0, 2) == 15.0 # Average of [5, 15, 25] update(fenwick_tree, 1, 10) assert query_range(fenwick_tree, 0, 2) == 13.333 # Average of [5, 10, 25] ``` # Requirements * Implement the core algorithm as described. * Validate inputs to ensure error handling for edge cases such as empty lists and invalid query bounds. * Use efficient and optimal methods to achieve the desired performance. Constraints * Maximum length of the list ( n leq 10^5 ). * Ensure your implementation handles both small and large inputs effectively.","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) self.data = [0] * size def update(self, index, value): delta = value - self.data[index] self.data[index] = value index += 1 while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum_ = 0 index += 1 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def build_fenwick_tree(prices): size = len(prices) fenwick_tree = FenwickTree(size) for i in range(size): fenwick_tree.update(i, prices[i]) return fenwick_tree def query_range(fenwick_tree, left_bound, right_bound): if left_bound > right_bound or left_bound < 0 or right_bound >= fenwick_tree.size: return None # Invalid bounds sum_left = fenwick_tree.query(left_bound - 1) if left_bound > 0 else 0 sum_right = fenwick_tree.query(right_bound) total = sum_right - sum_left return total / (right_bound - left_bound + 1)"},{"question":"# Context You have been tasked to write a function that validates dates and calculates the number of days between two valid dates. Dates are provided in the format `YYYY-MM-DD`. # Task Implement a function `calculate_days_between_dates` to determine the number of days between two dates. Your function should: * Validate the input date strings. * Calculate the number of days between the two dates. * Handle leap years correctly. # Requirements * **Input**: * `date1` (string): The first date string in `YYYY-MM-DD` format. * `date2` (string): The second date string in `YYYY-MM-DD` format. * **Output**: * An integer representing the number of days between the two dates. * **Constraints**: * Both date strings must be valid dates in the `YYYY-MM-DD` format. * If any date string is invalid, raise a `ValueError` with a message indicating the issue. # Example ```python def calculate_days_between_dates(date1: str, date2: str) -> int: Compute the number of days between two dates. Parameters: date1 : str: The first date in \'YYYY-MM-DD\' format. date2 : str: The second date in \'YYYY-MM-DD\' format. Returns: int: Number of days between the two dates. Raises: ValueError: If any of the date strings are invalid. Example: >>> calculate_days_between_dates(\\"2020-01-01\\", \\"2020-01-10\\") 9 >>> calculate_days_between_dates(\\"2019-12-01\\", \\"2019-12-01\\") 0 >>> calculate_days_between_dates(\\"2020-02-29\\", \\"2021-02-28\\") 365 >>> calculate_days_between_dates(\\"2020-xy-z\\", \\"2021-02-28\\") ValueError: Invalid date format: \'2020-xy-z\'. # Your implementation here pass # Test cases print(calculate_days_between_dates(\\"2020-01-01\\", \\"2020-01-10\\")) # Output: 9 print(calculate_days_between_dates(\\"2019-12-01\\", \\"2019-12-01\\")) # Output: 0 print(calculate_days_between_dates(\\"2020-02-29\\", \\"2021-02-28\\")) # Output: 365 print(calculate_days_between_dates(\\"2021-05-15\\", \\"2020-12-01\\")) # Output: 165 ```","solution":"from datetime import datetime def calculate_days_between_dates(date1: str, date2: str) -> int: Compute the number of days between two dates. Parameters: date1 : str: The first date in \'YYYY-MM-DD\' format. date2 : str: The second date in \'YYYY-MM-DD\' format. Returns: int: Number of days between the two dates. Raises: ValueError: If any of the date strings are invalid. date_format = \\"%Y-%m-%d\\" try: d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) except ValueError: raise ValueError(\\"Invalid date format: \'{}\', both dates should be in \'YYYY-MM-DD\' format.\\".format(date1 if \'date1\' in locals() else date2)) return abs((d2 - d1).days)"},{"question":"# Question: Implement a Red-Black Tree You are required to implement a red-black tree, a type of self-balancing binary search tree. The red-black tree should support insertion, deletion, and search operations. # Requirements 1. Implement the `RedBlackTree` class and the `Node` class to represent the nodes within the tree. 2. Ensure that the class supports the following methods: - `insert(key, value)` - `delete(key)` - `search(key)` - `inorder_traversal()` (to print the nodes in an inorder sequence) # Guidelines 1. Each node must store the key, value, color (red or black), and pointers to its left and right children. 2. The tree should maintain red-black properties after every insertion and deletion: - Every node is either red or black. - The root is always black. - Red nodes cannot have red children (no two red nodes in a row). - Every path from a node to its descendants contains the same number of black nodes. 3. Implement necessary rotations and color changes to maintain these properties. 4. Handle edge cases appropriately, such as when the tree is empty or contains a single node. 5. Implement error handling for invalid operations, such as deleting a non-existent key. # Example ```python class Node: def __init__(self, key, value, color): self.key = key self.value = value self.color = color self.left = None self.right = None class RedBlackTree: def __init__(self): self.TNULL = Node(0, \\"\\", \\"black\\") # Sentinel node (null node) self.root = self.TNULL def insert(self, key, value): ... def delete(self, key): ... def search(self, key): ... def _inorder_traversal_helper(self, node): ... def inorder_traversal(self): self._inorder_traversal_helper(self.root) print() # Example usage: rbt = RedBlackTree() print(\\"Tree after insertion:\\") rbt.insert(20, \'A\') rbt.insert(15, \'B\') rbt.insert(25, \'C\') rbt.inorder_traversal() # Output: (15, \'B\'), (20, \'A\'), (25, \'C\') print(\\"Search result:\\") print(rbt.search(15)) # Output: \'B\' rbt.delete(15) print(\\"Tree after deletion:\\") rbt.inorder_traversal() # Output: (20, \'A\'), (25, \'C\') ``` # Constraints 1. Keys are integers. 2. Each key is unique in the tree. # Submission Submit the `Node` and `RedBlackTree` class definitions along with test cases demonstrating the functionality of insertion, deletion, search, and inorder traversal operations.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.color = \\"red\\" self.left = None self.right = None self.parent = None class RedBlackTree: def __init__(self): self.TNULL = Node(0, \\"\\") self.TNULL.color = \\"black\\" self.root = self.TNULL def insert(self, key, value): new_node = Node(key, value) new_node.left = self.TNULL new_node.right = self.TNULL new_node.parent = None parent = None current = self.root while current != self.TNULL: parent = current if new_node.key < current.key: current = current.left else: current = current.right new_node.parent = parent if parent is None: self.root = new_node elif new_node.key < parent.key: parent.left = new_node else: parent.right = new_node if new_node.parent is None: new_node.color = \\"black\\" return if new_node.parent.parent is None: return self.fix_insert(new_node) def fix_insert(self, k): while k.parent.color == \\"red\\": if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == \\"red\\": u.color = \\"black\\" k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == \\"red\\": u.color = \\"black\\" k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = \\"black\\" def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def search(self, key): return self._search_helper(self.root, key) def _search_helper(self, node, key): if node == self.TNULL or key == node.key: return node.value if node != self.TNULL else None if key < node.key: return self._search_helper(node.left, key) return self._search_helper(node.right, key) def delete(self, key): self._delete_node_helper(self.root, key) def _delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.key == key: z = node if node.key <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Couldn\'t find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self._rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self._rb_transplant(z, z.left) else: y = self._minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self._rb_transplant(y, y.right) y.right = z.right y.right.parent = y self._rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == \\"black\\": self._fix_delete(x) def _minimum(self, node): while node.left != self.TNULL: node = node.left return node def _rb_transplant(self, u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _fix_delete(self, x): while x != self.root and x.color == \\"black\\": if x == x.parent.left: s = x.parent.right if s.color == \\"red\\": s.color = \\"black\\" x.parent.color = \\"red\\" self.left_rotate(x.parent) s = x.parent.right if s.left.color == \\"black\\" and s.right.color == \\"black\\": s.color = \\"red\\" x = x.parent else: if s.right.color == \\"black\\": s.left.color = \\"black\\" s.color = \\"red\\" self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = \\"black\\" s.right.color = \\"black\\" self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == \\"red\\": s.color = \\"black\\" x.parent.color = \\"red\\" self.right_rotate(x.parent) s = x.parent.left if s.right.color == \\"black\\" and s.right.color == \\"black\\": s.color = \\"red\\" x = x.parent else: if s.left.color == \\"black\\": s.right.color = \\"black\\" s.color = \\"red\\" self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = \\"black\\" s.left.color = \\"black\\" self.right_rotate(x.parent) x = self.root x.color = \\"black\\" def inorder_traversal(self): self._inorder_traversal_helper(self.root) print() def _inorder_traversal_helper(self, node): if node != self.TNULL: self._inorder_traversal_helper(node.left) print(f\'({node.key}, {node.value})\', end=\' \') self._inorder_traversal_helper(node.right)"},{"question":"# Scenario You are developing a file synchronization system that ensures the data in the source directory is always in sync with the destination directory. To achieve this, you need to implement a function that compares the files in both directories and identifies files that are missing, modified, or deleted. # Task Write a Python function `sync_directories` that takes two inputs: 1. `source_files` (list of tuples) representing the files in the source directory. Each tuple contains a file name (string) and a last modified timestamp (string in the format YYYY-MM-DD HH:MM:SS). 2. `dest_files` (list of tuples) representing the files in the destination directory. Each tuple has the same structure as in the source directory. The function should return a dictionary with three keys: `\\"missing\\"`, `\\"modified\\"`, and `\\"deleted\\"`. Each key should map to a list of file names that are either missing in the destination, modified in comparison to the source, or deleted from the source but present in the destination. # Requirements - Compare the files based on their names and last modified timestamps. - A file is considered \\"modified\\" if the names are the same but the timestamps differ. - A file is considered \\"missing\\" if it exists in the source directory but not in the destination directory. - A file is considered \\"deleted\\" if it exists in the destination directory but not in the source directory. # Constraints - File names are unique within each directory. - All timestamps are in the format YYYY-MM-DD HH:MM:SS and are valid. - Both lists (`source_files` and `dest_files`) must be sorted in ascending order by file name. # Example ```python def sync_directories(source_files, dest_files): pass # Example input source_files = [ (\\"file1.txt\\", \\"2023-01-01 10:00:00\\"), (\\"file2.txt\\", \\"2023-01-02 11:00:00\\"), (\\"file3.txt\\", \\"2023-01-03 12:00:00\\") ] dest_files = [ (\\"file1.txt\\", \\"2023-01-01 10:00:00\\"), (\\"file2.txt\\", \\"2023-01-02 12:00:00\\"), (\\"file4.txt\\", \\"2023-01-04 13:00:00\\") ] result = sync_directories(source_files, dest_files) # Expected Output # { # \\"missing\\": [\\"file3.txt\\"], # \\"modified\\": [\\"file2.txt\\"], # \\"deleted\\": [\\"file4.txt\\"] # } ``` # Notes - Ensure your function works efficiently for large lists of files. - Use appropriate error handling for any invalid input conditions. This new question aligns with the existing set in terms of style, complexity, and scope, exploring file synchronization and comparison.","solution":"def sync_directories(source_files, dest_files): Compares the source and destination directories and identifies files that are missing, modified, or deleted. Args: source_files (list of tuples): List of (filename, timestamp) tuples for the source directory. dest_files (list of tuples): List of (filename, timestamp) tuples for the destination directory. Returns: dict: A dictionary with keys \'missing\', \'modified\', and \'deleted\'. \'missing\' maps to a list of files in source but not in destination. \'modified\' maps to a list of files with different timestamps in source and destination. \'deleted\' maps to a list of files in destination but not in source. source_dict = dict(source_files) dest_dict = dict(dest_files) missing = [] modified = [] deleted = [] # Identify missing and modified files for file, src_time in source_dict.items(): if file not in dest_dict: missing.append(file) elif dest_dict[file] != src_time: modified.append(file) # Identify deleted files for file in dest_dict: if file not in source_dict: deleted.append(file) return { \\"missing\\": missing, \\"modified\\": modified, \\"deleted\\": deleted }"},{"question":"# Reverse Words in a String Write a function `reverse_words` that takes a string containing several words and returns a string with the words in reverse order. Punctuation marks and spaces should be treated as part of their respective words, and the output should closely mirror the input format in terms of spacing. Input * A string `sentence` consisting of words and punctuations separated by spaces. Output * A string with the words in reverse order. Constraints - The sentence will contain only ASCII characters. - 1 (leq) length of `sentence` (leq) 1000 # Example ```python >>> reverse_words(\\"Hello, World!\\") \\"World! Hello,\\" >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\" Jump over the lazy dog \\") \\" dog lazy the over Jump \\" >>> reverse_words(\\"It\'s amazing, isn\'t it?\\") \\"it? isn\'t amazing, It\'s\\" ``` # Notes - Do not alter the punctuation marks, spaces, or capitalization of the words within the input sentence. - Ensure that multiple and leading/trailing spaces are preserved exactly as they appear in the input string.","solution":"def reverse_words(sentence): Reverses the order of words in the given sentence while preserving the original spacing. Args: sentence (str): The sentence consisting of words and punctuations. Returns: str: The sentence with words in reverse order. words = sentence.split(\' \') reversed_words = \' \'.join(reversed(words)) return reversed_words"},{"question":"# Problem Statement You are tasked to enhance a weather forecasting application by integrating a real-time weather API. The application should fetch the 7-day weather forecast for a given city and ensure the data is accurate and readily available. # Objective Implement a function `get_weekly_forecast` that: 1. Fetches the 7-day weather forecast asynchronously for a specified city. 2. Provides detailed error handling for network issues, invalid city names, and API rate limiting. 3. Returns the forecast data in a structured and usable format. # Requirements - **Input**: - `city_name`: A string representing the name of the city for which to fetch the weather forecast. - **Output**: A list of dictionaries, where each dictionary contains the `date`, `temperature`, `weather_description`, and `humidity` for one day of the week. Return an empty list if no data is available. # Constraints - Use asynchronous HTTP requests to fetch the weather data. - Ensure robust error handling for various potential issues like network errors, invalid responses, and invalid city names. - The function should be efficient and handle up to 1000 requests per hour. # Example Case ```python import asyncio async def get_weekly_forecast(city_name: str) -> list[dict]: # Your implementation here # Example usage forecast = asyncio.run(get_weekly_forecast(\\"New York\\")) print(forecast) ``` **Expected Output**: A list of dictionaries containing the forecast data for the upcoming week. # Note - You may use any Python libraries for HTTP requests and asynchronous operations. - Ensure that the function documents any assumptions made and gracefully handles various error scenarios. - Consider using popular weather APIs like OpenWeatherMap, WeatherAPI, etc. # Example Output Structure ```json [ { \\"date\\": \\"2023-10-01\\", \\"temperature\\": \\"18°C\\", \\"weather_description\\": \\"Partly Cloudy\\", \\"humidity\\": \\"65%\\" }, { \\"date\\": \\"2023-10-02\\", \\"temperature\\": \\"20°C\\", \\"weather_description\\": \\"Sunny\\", \\"humidity\\": \\"55%\\" }, // ... additional days ] ```","solution":"import aiohttp import asyncio API_KEY = \'your_api_key_here\' # Replace with your API key BASE_URL = \'https://api.openweathermap.org/data/2.5/onecall\' async def fetch_forecast(session, lat, lon): params = { \'lat\': lat, \'lon\': lon, \'exclude\': \'current,minutely,hourly,alerts\', \'units\': \'metric\', \'appid\': API_KEY } async with session.get(BASE_URL, params=params) as response: if response.status == 200: return await response.json() else: response.raise_for_status() async def get_coordinates(session, city_name): geocoding_url = \'http://api.openweathermap.org/geo/1.0/direct\' params = { \'q\': city_name, \'limit\': 1, \'appid\': API_KEY } async with session.get(geocoding_url, params=params) as response: if response.status == 200: data = await response.json() if data: return data[0][\'lat\'], data[0][\'lon\'] else: raise ValueError(f\\"City {city_name} not found\\") else: response.raise_for_status() async def get_weekly_forecast(city_name: str) -> list[dict]: async with aiohttp.ClientSession() as session: try: lat, lon = await get_coordinates(session, city_name) forecast_data = await fetch_forecast(session, lat, lon) forecast_list = [] for day in forecast_data[\'daily\']: forecast_list.append({ \'date\': day[\'dt\'], \'temperature\': day[\'temp\'][\'day\'], \'weather_description\': day[\'weather\'][0][\'description\'], \'humidity\': day[\'humidity\'] }) return forecast_list except aiohttp.ClientError as e: print(f\\"Network error: {e}\\") return [] except ValueError as e: print(e) return [] except Exception as e: print(f\\"An error occurred: {e}\\") return [] # Example usage # forecast = asyncio.run(get_weekly_forecast(\\"New York\\")) # print(forecast)"},{"question":"**Context**: You are part of a team developing a software application that can understand and process data from a log file. As part of this functionality, you need to analyze a sequence of IP addresses to determine the maximum number of unique IP addresses that appear within any interval of `k` consecutive log entries. **Coding Task**: Write a function called `max_unique_ips` that takes two parameters: * `log` (a list of strings, each representing an IP address), * `k` (an integer, the length of the interval). Your function should return the maximum number of unique IP addresses found in any interval of `k` consecutive log entries. # Input * The function will be called as: `max_unique_ips(log: List[str], k: int) -> int` * `log` (a list of strings): each string is a valid IP address (each string length is 7 ≤ len(ip) ≤ 15) * `k` (an integer): the interval length (1 ≤ k ≤ len(log)) # Output * Return an integer, representing the maximum number of unique IP addresses within any interval of `k` consecutive log entries. # Constraints * Optimize for both time and space complexity to handle large input sizes. * IP addresses are standard IPv4 addresses. # Example ```python def max_unique_ips(log: List[str], k: int) -> int: # Your implementation here # Example usage logs = [\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.1.1\\", \\"10.0.0.1\\", \\"10.0.0.2\\", \\"192.168.1.1\\"] k = 3 print(max_unique_ips(logs, k)) # Output: 2 logs = [\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.1.3\\", \\"10.0.0.1\\", \\"10.0.0.2\\", \\"10.0.0.3\\"] k = 3 print(max_unique_ips(logs, k)) # Output: 3 ``` # Explanation * In the first example, the sequence of log entries checked in each interval of `k=3` are: - [\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.1.1\\"] => 2 unique IPs - [\\"192.168.1.2\\", \\"192.168.1.1\\", \\"10.0.0.1\\"] => 3 unique IPs - [\\"192.168.1.1\\", \\"10.0.0.1\\", \\"10.0.0.2\\"] => 3 unique IPs - [\\"10.0.0.1\\", \\"10.0.0.2\\", \\"192.168.1.1\\"] => 3 unique IPs * Hence, the maximum number of unique IP addresses in any interval of length 3 is 3.","solution":"from typing import List def max_unique_ips(log: List[str], k: int) -> int: Returns the maximum number of unique IP addresses in any interval of `k` consecutive log entries. # Dictionary to keep count of IP addresses ip_count = {} max_unique = 0 # Initialize the first window for i in range(k): if log[i] in ip_count: ip_count[log[i]] += 1 else: ip_count[log[i]] = 1 max_unique = len(ip_count) # Slide the window for i in range(k, len(log)): # Remove the first element of the previous window start_ip = log[i - k] if ip_count[start_ip] == 1: del ip_count[start_ip] else: ip_count[start_ip] -= 1 # Add the new element of the current window new_ip = log[i] if new_ip in ip_count: ip_count[new_ip] += 1 else: ip_count[new_ip] = 1 # Update max_unique max_unique = max(max_unique, len(ip_count)) return max_unique"},{"question":"# Next Permutation Algorithm Context In a competitive programming challenge, you\'re required to generate the lexicographically next permutation of a given list of integers. The problem addresses the transition to the next possible ordering of a sequence using permutations. This task is crucial for scenarios that involve combinatorial generation, sequence modeling, or tests related to ordering. Task Write a function `next_permutation` that rearranges numbers into the lexicographically next greater permutation of numbers. If such rearrangement is not possible, it must arrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be in-place and use only constant extra memory. **Function Signature**: ```python def next_permutation(nums: List[int]) -> None: pass ``` Input - `nums` (List[int]): A list of integers where 1 ≤ len(nums) ≤ 10^4. Output - None: The function modifies the list in place. Constraints - The algorithm must run in O(n) time complexity. - The modification must be in-place with O(1) additional memory. Examples 1. **Input**: `nums = [1, 2, 3]` **Output**: `nums = [1, 3, 2]` (the next permutation) 2. **Input**: `nums = [3, 2, 1]` **Output**: `nums = [1, 2, 3]` (no higher permutation, return sorted list) 3. **Input**: `nums = [1, 1, 5]` **Output**: `nums = [1, 5, 1]` (next permutation in order) 4. **Input**: `nums = [5, 4, 7, 5, 3, 2]` **Output**: `nums = [5, 5, 2, 3, 4, 7]` (next permutation in order) Implement the `next_permutation` function considering the constraints and ensure it passes all provided scenarios and additional edge cases effectively.","solution":"from typing import List def next_permutation(nums: List[int]) -> None: Modifies the list \'nums\' to its next permutation in lexicographic order. If no such permutation exists, the list is sorted in ascending order. n = len(nums) if n <= 1: return # Step 1: Find the first decreasing element from the end i = n - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # If there is a decreasing element # Step 2: Find the element just larger than nums[i] from the end j = n - 1 while j >= 0 and nums[j] <= nums[i]: j -= 1 # Step 3: Swap the found elements nums[i], nums[j] = nums[j], nums[i] # Step 4: Reverse the elements after the found index nums[i + 1:] = reversed(nums[i + 1:])"},{"question":"# Merge Two Sorted Arrays Without Extra Space You are given two sorted arrays, `arr1` and `arr2`. You need to merge them into a single sorted array without using any extra space and modify `arr1` to hold the first part of the merged array and `arr2` to hold the remaining part. Implement the function `merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> None` that merges the two sorted arrays in-place. Input: - Two sorted arrays `arr1` and `arr2` of lengths `m` and `n` respectively, where 0 ≤ m, n ≤ 10^4, and each element is an integer between -10^9 and 10^9. Output: - No return value. Modify `arr1` and `arr2` in-place to contain the merged sorted elements. Constraints: - The total number of elements in `arr1` and `arr2` is guaranteed to fit in memory. - The solution must not use any extra space for merging. # Examples: ```python def test_merge_sorted_arrays(): arr1 = [1, 3, 5, 7] arr2 = [0, 2, 6, 8, 9] merge_sorted_arrays(arr1, arr2) assert arr1 == [0, 1, 2, 3] assert arr2 == [5, 6, 7, 8, 9] arr1 = [10, 12] arr2 = [5, 18, 20] merge_sorted_arrays(arr1, arr2) assert arr1 == [5, 10] assert arr2 == [12, 18, 20] arr1 = [2, 3] arr2 = [1, 4] merge_sorted_arrays(arr1, arr2) assert arr1 == [1, 2] assert arr2 == [3, 4] print(\\"All tests passed.\\") if __name__ == \\"__main__\\": test_merge_sorted_arrays() ``` # Explanation of the function\'s logic: 1. **Initialization**: Start with the last element of `arr1` and the first element of `arr2`. 2. **Swapping**: Compare elements of `arr1` and `arr2`, and swap them if necessary to maintain the sorting order. 3. **Sorting**: After swapping, sort both arrays individually since they might have out-of-place elements. 4. **In-place Merge**: Repeat the above steps until `arr1` is in complete sorted form as expected, followed by `arr2` continuing the sorted order. This algorithm ensures that `arr1` and `arr2` end up containing the merged sorted elements without requiring extra space beyond input arrays themselves.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays (arr1 and arr2) into one sorted sequence without using extra space. m, n = len(arr1), len(arr2) # Move all elements to the end of their respective lists, if needed i = m - 1 j = 0 while i >= 0 and j < n: if arr1[i] > arr2[j]: arr1[i], arr2[j] = arr2[j], arr1[i] i -= 1 j += 1 # Sort both arrays to maintain the final sorted order arr1.sort() arr2.sort()"},{"question":"# Question: Implementation of Topological Sort Using Kahn\'s Algorithm for a Directed Weighted Graph. Context: You are given a directed weighted graph represented as an adjacency list where each directed edge contains a weight. Your task is to implement the Topological Sort using Kahn\'s algorithm, which provides a linear ordering of vertices in a Directed Acyclic Graph (DAG) based on dependencies. Task: Implement Kahn\'s algorithm for topological sorting to handle **weighted** directed graphs. The algorithm should: 1. Parse and process weighted edges in the adjacency list. 2. Compute the in-degrees of all vertices. 3. Use a queue to repeatedly add vertices with zero in-degrees to the topological order. 4. Adjust in-degrees based on the weights of the outgoing edges and continue until all vertices are processed or a cycle is detected. Specifications: 1. **Input**: - `adj_list`: A dictionary representing the adjacency list of the graph. Keys are node identifiers, and values are lists of tuples in the format `(destination_node, weight)`. 2. **Output**: - `topological_order`: A list of vertices in topological order or an empty list if the graph contains a cycle. 3. **Constraints**: - Edge weights are positive integers. - The graph is guaranteed to be a DAG. Example Input: ```python adj_list = { \'A\': [(\'B\', 3), (\'C\', 2)], \'B\': [(\'D\', 4)], \'C\': [(\'D\', 1), (\'E\', 3)], \'D\': [(\'F\', 2)], \'E\': [(\'D\', 2)], \'F\': [] } ``` Example Output: ```python [\'A\', \'B\', \'C\', \'E\', \'D\', \'F\'] ``` This output indicates that a possible topological ordering of the given graph is `[\'A\', \'B\', \'C\', \'E\', \'D\', \'F\']`. Instructions: 1. **Parse and Process Weights**: Ensure the adjacency list accounts for weights while calculating in-degrees. 2. **Compute In-Degrees**: Create a function to initialize node in-degrees considering weights. 3. **Kahn\'s Algorithm**: Implement the main loop of Kahn\'s algorithm, adjusting queue operations based on in-degrees. 4. **Testing**: Write at least 3 test cases to verify your implementation. # Solution Template: ```python def topological_sort_kahns_algorithm(adj_list): # Initialize in-degrees of all vertices in_degrees = {node: 0 for node in adj_list} # Calculate in-degrees based on weights for node in adj_list: for (neighbor, weight) in adj_list[node]: in_degrees[neighbor] += weight # Initialize the queue with vertices that have zero in-degrees queue = [node for node in in_degrees if in_degrees[node] == 0] topological_order = [] while queue: current = queue.pop(0) topological_order.append(current) # Reduce in-degrees for all neighboring nodes for (neighbor, weight) in adj_list[current]: in_degrees[neighbor] -= weight if in_degrees[neighbor] == 0: queue.append(neighbor) # Check for cycles if len(topological_order) != len(adj_list): return [] # Cycle detected, return empty list return topological_order # Example Usage: adj_list = { \'A\': [(\'B\', 3), (\'C\', 2)], \'B\': [(\'D\', 4)], \'C\': [(\'D\', 1), (\'E\', 3)], \'D\': [(\'F\', 2)], \'E\': [(\'D\', 2)], \'F\': [] } print(topological_sort_kahns_algorithm(adj_list)) ``` Additional Test Cases: ```python # Test Case 1 adj_list_1 = { \'P\': [(\'Q\', 1)], \'Q\': [(\'R\', 2)], \'R\': [(\'S\', 3)], \'S\': [] } assert topological_sort_kahns_algorithm(adj_list_1) == [\'P\', \'Q\', \'R\', \'S\'] # Test Case 2 adj_list_2 = { \'M\': [(\'N\', 1)], \'N\': [(\'O\', 2)], \'O\': [(\'P\', 3)], \'P\': [(\'Q\', 1)], \'Q\': [(\'M\', 1)] # This creates a cycle } assert topological_sort_kahns_algorithm(adj_list_2) == [] # Test Case 3 adj_list_3 = { \'X\': [(\'Y\', 2)], \'Y\': [(\'Z\', 2)], \'Z\': [(\'W\', 2)], \'W\': [] } assert topological_sort_kahns_algorithm(adj_list_3) == [\'X\', \'Y\', \'Z\', \'W\'] ```","solution":"def topological_sort_kahns_algorithm(adj_list): # 1. Initialize in-degrees of all vertices to 0 in_degrees = {node: 0 for node in adj_list} # 2. Calculate in-degrees using the provided adjacency list for node in adj_list: for (neighbor, weight) in adj_list[node]: in_degrees[neighbor] += weight # 3. Initialize the queue with vertices that have zero in-degrees queue = [node for node in in_degrees if in_degrees[node] == 0] topological_order = [] # 4. Process the vertices in the queue while queue: current = queue.pop(0) topological_order.append(current) # Reduce in-degrees for all neighboring nodes for (neighbor, weight) in adj_list[current]: in_degrees[neighbor] -= weight if in_degrees[neighbor] == 0: queue.append(neighbor) # 5. If all vertices are processed, return the topological order # If there are unprocessed vertices, this means there\'s a cycle if len(topological_order) == len(adj_list): return topological_order else: return [] # Cycle detected, return empty list # Example Usage: adj_list = { \'A\': [(\'B\', 3), (\'C\', 2)], \'B\': [(\'D\', 4)], \'C\': [(\'D\', 1), (\'E\', 3)], \'D\': [(\'F\', 2)], \'E\': [(\'D\', 2)], \'F\': [] } print(topological_sort_kahns_algorithm(adj_list)) # Expected output: [\'A\', \'B\', \'C\', \'E\', \'D\', \'F\']"},{"question":"# Problem Statement: You are tasked with developing a new version of a `MatrixMultiplier` for matrix multiplication operations. This class should efficiently handle matrix multiplication with dense matrices. # Requirements: 1. Implement a class `MatrixMultiplier` with the following methods: - `def multiply(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]`: Multiplies two matrices A and B and returns the resultant matrix. - `def identity_matrix(self, size: int) -> List[List[int]]`: Generates and returns an identity matrix of the given size. 2. The `multiply` method should follow the standard rules for matrix multiplication: - If A is of dimensions `m x n` and B is of dimensions `n x p`, then the resultant matrix will be of dimensions `m x p`. - Ensure that each element of the resulting matrix is the dot product of the corresponding row of A and column of B. 3. Handle cases where matrix multiplication is not possible (e.g., mismatched dimensions) by raising a `ValueError`. # Input and Output Formats: - The `multiply` method accepts two matrices A and B, represented as lists of lists of integers. - The `identity_matrix` method accepts a single integer `size`. - Both methods return a matrix, represented as a list of lists of integers. # Constraints: - The matrices A and B contain integers of value between 1 and 100. - The dimensions of the matrices will be between 1 and 50 (inclusive). - The input matrices will be valid as specified. # Example: ```python from typing import List class MatrixMultiplier: def multiply(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass # Include your implementation here def identity_matrix(self, size: int) -> List[List[int]]: pass # Include your implementation here # Example usage: multiplier = MatrixMultiplier() A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] print(multiplier.multiply(A, B)) # Expected: # [ # [19, 22], # [43, 50] # ] print(multiplier.identity_matrix(3)) # Expected: # [ # [1, 0, 0], # [0, 1, 0], # [0, 0, 1] # ] ``` Complete the class `MatrixMultiplier` based on the provided requirements and examples.","solution":"from typing import List class MatrixMultiplier: def multiply(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Dimensions of matrix A m = len(A) n_A = len(A[0]) # Dimensions of matrix B n_B = len(B) p = len(B[0]) # Verify if matrix multiplication is possible if n_A != n_B: raise ValueError(\\"Matrices A and B cannot be multiplied due to incompatible dimensions.\\") # Initialize the resultant matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n_A): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(self, size: int) -> List[List[int]]: # Initialize the identity matrix identity = [[0] * size for _ in range(size)] # Set the diagonal elements to 1 for i in range(size): identity[i][i] = 1 return identity"},{"question":"# Coding Assessment Question: Scenario: You are required to implement a function to determine if all characters in a given string are unique. This function will be useful in validating constraints in password policies or processing text data where uniqueness is a requirement. Function Specification: Write a function `are_all_chars_unique(input_string: str) -> bool` that checks if all characters in the provided string are unique. Input: * `input_string`: A string of characters (1 <= len(input_string) <= 10^6). Output: * Returns `True` if all characters in `input_string` are unique. * Returns `False` if any character is repeated in `input_string`. Constraints: * The function should be case-sensitive, meaning \'A\' and \'a\' are considered different characters. * The function should handle all ASCII characters. Performance Requirements: * The implementation should aim for a time complexity of O(n), where n is the length of `input_string`. Examples: ```python >>> are_all_chars_unique(\'abcdef\') True >>> are_all_chars_unique(\'aAbBcC\') True >>> are_all_chars_unique(\'aa\') False >>> are_all_chars_unique(\'1234567890\') True >>> are_all_chars_unique(\'12345678901\') False >>> are_all_chars_unique(\'\') True >>> are_all_chars_unique(\' \') True >>> are_all_chars_unique(\' \') False ``` Ensure your function is optimized and handles edge cases appropriately. Validate the input and strive for an efficient implementation.","solution":"def are_all_chars_unique(input_string: str) -> bool: Returns True if all characters in the input_string are unique, False otherwise. The function checks each character in the string and uses a set to track which characters have been seen so far. If a character is found in the set, it means the character is repeated. Args: input_string (str): The string to check for unique characters. Returns: bool: True if all characters are unique, False otherwise. seen_chars = set() for char in input_string: if char in seen_chars: return False seen_chars.add(char) return True"},{"question":"Reverse a Linked List in K-Groups # Context You are given a linked list and an integer `k`. Your task is to reverse the nodes of the linked list `k` nodes at a time and return the modified list. If the number of nodes is not a multiple of `k`, the remaining nodes at the end should remain as is. # Input 1. An instance of `LinkedList`. 2. An integer `k` where `1 <= k <= length of LinkedList`. # Output 1. A new instance of `LinkedList` with nodes reversed in groups of `k`. # Constraints 1. The elements of the linked list are integers. 2. Assume no cycles exist in the linked list. # Performance Requirements 1. The time complexity of the reversing process should be linear, i.e., O(n) where n is the length of the linked list. 2. For space complexity, use O(1) additional space (besides the input and output). # Function Definition ```python def reverse_k_group(linked_list: LinkedList, k: int) -> LinkedList: pass ``` # Example ```python # Example Case # Input: linked_list = LinkedList([1, 2, 3, 4, 5, 6, 7, 8]) k = 3 # Output: reversed_list = reverse_k_group(linked_list, k) # reversed_list should represent the nodes: # 3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8 ``` # Notes 1. You may assume that the function `LinkedList` and class `Node` are defined with methods `__init__`, `__iter__`, and `__str__`, as well as the described properties from the code snippet. 2. Your solution should correctly handle the reversal process while maintaining the node order in non-reversal segments.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self, values=None): self.head = None if values is not None: self.head = Node(values[0]) current = self.head for value in values[1:]: current.next = Node(value) current = current.next def __iter__(self): current = self.head while current: yield current.value current = current.next def __str__(self): return \' -> \'.join(map(str, self)) def to_list(self): return list(iter(self)) def reverse_k_group(linked_list: LinkedList, k: int) -> LinkedList: def reverse_linked_list(head, k): prev, curr = None, head while k > 0 and curr: next_node = curr.next curr.next = prev prev = curr curr = next_node k -= 1 return prev, head def get_kth_node(head, k): curr = head while curr and k > 1: curr = curr.next k -= 1 return curr dummy = Node(0) dummy.next = linked_list.head group_prev = dummy while True: kth = get_kth_node(group_prev.next, k) if not kth: break group_next = kth.next prev, tail = reverse_linked_list(group_prev.next, k) group_prev.next = prev tail.next = group_next group_prev = tail new_linked_list = LinkedList() new_linked_list.head = dummy.next return new_linked_list"},{"question":"# Rotate the Matrix by 90 Degrees Anticlockwise You are tasked to design a function `rotate_matrix` that rotates a given 2D array (which represents an image matrix) by 90 degrees in the anticlockwise direction. # Function Specification Function: Rotate Matrix ```python def rotate_matrix(matrix: np.ndarray) -> np.ndarray: This function rotates a given 2D numpy array by 90 degrees in the anticlockwise direction. Args: matrix : np.ndarray : input 2D numpy array which is a square matrix. Returns: np.ndarray : the resulting 2D numpy array after rotating by 90 degrees anticlockwise. ``` # Input/Output Format * **Input**: - `matrix`: A 2D numpy array representing a square matrix (image). * **Output**: - Returns a 2D numpy array of the resultant matrix after rotating by 90 degrees anticlockwise. # Constraints - The input matrix must be a square matrix (i.e., the numbers of rows and columns are equal). - Handle exceptions and edge cases where inputs do not meet the specified constraints. # Example Example 1: Input: ```python matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) ``` Output: ```python array([[3, 6, 9], [2, 5, 8], [1, 4, 7]]) ``` # Implementation Write the implementation of the function as specified. Ensure you handle edge cases and provide meaningful error messages in exceptional scenarios.","solution":"import numpy as np def rotate_matrix(matrix: np.ndarray) -> np.ndarray: This function rotates a given 2D numpy array by 90 degrees anticlockwise. Args: matrix : np.ndarray : input 2D numpy array which is a square matrix. Returns: np.ndarray : the resulting 2D numpy array after rotating by 90 degrees anticlockwise. if not isinstance(matrix, np.ndarray): raise ValueError(\\"The input matrix must be a numpy array.\\") if len(matrix.shape) != 2 or matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"The input matrix must be a square 2D numpy array.\\") return np.rot90(matrix)"},{"question":"# Question: Rearrange Array Alternately Given the problem of finding sums of multiples and seeking a more challenging problem, here\'s an alternate scenario. Problem Statement Write a function `rearrange_alternately` that rearranges an array such that every alternate element is the maximum remaining element from the opposite end of the list. Function Signature ```python def rearrange_alternately(arr: List[int]) -> List[int]: ``` Input - `arr` (List[int]): The input array of integers. Output - `List[int]`: The array arranged alternately with the max remaining elements from the ends. Constraints - `1 <= len(arr) <= 10^5` - `-10^9 <= arr[i] <= 10^9` - The given array may contain repeated elements. Performance Requirements - The implemented solution should run efficiently for large input sizes. Example ```python >>> rearrange_alternately([1, 2, 3, 4, 5, 6]) [6, 1, 5, 2, 4, 3] >>> rearrange_alternately([10, 1, 9, 2, 8, 3]) [10, 1, 9, 2, 8, 3] >>> rearrange_alternately([4, 3, 2, 1]) [4, 1, 3, 2] ``` Notes - Make sure to handle both even and odd length arrays. - The function should alternate between the maximum element from the end and the next minimum element from the start and so on.","solution":"from typing import List def rearrange_alternately(arr: List[int]) -> List[int]: n = len(arr) if n == 1: return arr arr.sort() result = [] # Pointers to the beginning and the end of the sorted array i, j = 0, n - 1 while i <= j: if j > i: result.append(arr[j]) j -= 1 if i <= j: result.append(arr[i]) i += 1 return result"},{"question":"# Question: Find the Largest Common Subsequence in Multiple Lists You are given multiple lists of integers, and your task is to find the largest common subsequence (LCS) that appears in all lists. The subsequence does not need to be continuous, but the order must be maintained across all lists. **Input**: 1. A list of lists of integers, `lists`. **Output**: - A list of integers representing the largest common subsequence shared among all the input lists. **Function Signature**: ```python def largest_common_subsequence(lists: list[list[int]]) -> list[int]: pass ``` # Constraints: 1. The input `lists` can contain at most 100 lists. 2. Each sublist within `lists` can contain at most 100 integers. 3. All integers in the sublists are between (-10^9) and (10^9). # Example: ```python >>> largest_common_subsequence([[1, 3, 4, 9, 10], [1, 4, 9, 10, 15], [4, 9, 8, 10], [0, 4, 9, 10, 11]]) [4, 9, 10] >>> largest_common_subsequence([[5, 2, 8, 6], [8, 5, 2, 6], [5, 2, 6, 8]]) [5, 2, 6] >>> largest_common_subsequence([[1, 3, 5], [1, 3, 5], [1, 3, 5]]) [1, 3, 5] >>> largest_common_subsequence([[3, 7], [1, 4]]) [] ``` # Explanation: - The first example returns `[4, 9, 10]` because these elements appear in all lists in the same order. - The second example returns `[5, 2, 6]` as the largest common subsequence. - The third example returns `[1, 3, 5]` since all lists are identical. - The last example returns `[]` because there are no common subsequences in those lists. Make sure your implementation is efficient and handles the input constraints properly. Consider edge cases such as varying list lengths and empty lists.","solution":"def largest_common_subsequence(lists): from collections import defaultdict if not lists: return [] # Get the intersection elements which will be the candidates for the LCS element_positions = defaultdict(list) for lst in lists: unique_elements_in_list = set() for idx, elem in enumerate(lst): if elem not in unique_elements_in_list: element_positions[elem].append(idx) unique_elements_in_list.add(elem) # Filter out elements that are not in all lists common_elements = {key: positions for key, positions in element_positions.items() if len(positions) == len(lists)} if not common_elements: return [] # Extract common elements in the correct order common_elements_sorted = sorted(common_elements.items(), key=lambda x: min(x[1])) lcs = [] current_pos = [-1] * len(lists) for elem, positions in common_elements_sorted: if all(pos > current_pos[i] for i, pos in enumerate(positions)): lcs.append(elem) current_pos = positions return lcs"},{"question":"# Anagram Substring Search Given a text and a pattern, your task is to implement a function that searches for all the start indices of the pattern\'s anagrams in the given text. The function should return a list of starting indices of the anagrams of the pattern found in the text. Function Signature ```python def find_anagram_indices(text: str, pattern: str) -> List[int]: ``` # Input * `text` (str): The input text where we will search for anagrams. * `pattern` (str): The pattern whose anagrams we need to find in the text. # Output * `List[int]`: A list of starting indices where anagrams of the pattern are located in the text. # Implementation Steps 1. **Sliding Window**: Use a sliding window approach to check for anagrams within the `text`. 2. **Frequency Count**: Count the frequency of each character in the `pattern` and the current window in the `text`. 3. **Check for Anagrams**: Compare the frequency maps of the window and the `pattern`. If they match, it\'s an anagram. # Constraints * The length of the input string `text` will be in the range [1, 10^5]. * The length of the input string `pattern` will be in the range [1, 10^3]. # Example ```python # Test Case 1 text = \\"cbaebabacd\\" pattern = \\"abc\\" print(find_anagram_indices(text, pattern)) # Expected Output: [0, 6] as \\"cba\\" and \\"bac\\" are anagrams of \\"abc\\" # Test Case 2 text = \\"abab\\" pattern = \\"ab\\" print(find_anagram_indices(text, pattern)) # Expected Output: [0, 1, 2] as \\"ab\\", \\"ba\\", and \\"ab\\" are all anagrams of \\"ab\\" ``` # Hints * Use dictionaries or a fixed-size list (of length 26 for English lowercase letters) to store frequency counts. * Slide the window over the text, updating the frequency count of the outgoing and incoming characters efficiently. * Initially, calculate the frequency count for the first window and the pattern, then slide the window one character at a time and update the counts accordingly.","solution":"from typing import List from collections import Counter def find_anagram_indices(text: str, pattern: str) -> List[int]: Returns a list of starting indices where the anagrams of the pattern are found in the text. len_text, len_pattern = len(text), len(pattern) if len_pattern > len_text: return [] result = [] pattern_count = Counter(pattern) window_count = Counter(text[:len_pattern - 1]) for i in range(len_pattern - 1, len_text): window_count[text[i]] += 1 if window_count == pattern_count: result.append(i - len_pattern + 1) window_count[text[i - len_pattern + 1]] -= 1 if window_count[text[i - len_pattern + 1]] == 0: del window_count[text[i - len_pattern + 1]] return result"},{"question":"# Coding Assessment Question: **Problem Description**: You are to design and implement a simple Neural Network from scratch using only NumPy. The objective of this exercise is to test your understanding of the underlying mechanisms of neural networks, particularly focusing on forward and backward propagations and parameter updates through gradient descent. **Requirements**: Implement the `SimpleNeuralNetwork` class and its methods to perform binary classification tasks. You should utilize one hidden layer in the network. Your implementation should include the following methods: 1. **Constructor `__init__(self, input_size: int, hidden_size: int, output_size: int, learning_rate: float = 0.01)`** - Initialize the neural network with weights and biases, and set the learning rate. 2. **Method `sigmoid(self, z: np.ndarray) -> np.ndarray`** - Calculate the sigmoid activation for the input `z`. 3. **Method `sigmoid_derivative(self, z: np.ndarray) -> np.ndarray`** - Calculate the derivative of the sigmoid function. 4. **Method `forward(self, X: np.ndarray) -> np.ndarray`** - Perform the forward propagation to compute the activations. 5. **Method `backward(self, X: np.ndarray, y: np.ndarray, y_hat: np.ndarray) -> None`** - Perform backward propagation to compute gradients and update weights and biases. 6. **Method `fit(self, X: np.ndarray, y: np.ndarray, epochs: int = 1000) -> None`** - Train the neural network using the training dataset for the specified number of epochs. 7. **Method `predict(self, X: np.ndarray) -> np.ndarray`** - Predict the labels for the input features. **Input/Output**: 1. **Constructor Parameters**: - `input_size` (int): Number of input features. - `hidden_size` (int): Number of neurons in the hidden layer. - `output_size` (int): Number of output neurons (should be 1 for binary classification). - `learning_rate` (float): Learning rate for updating the network parameters. 2. **Method Parameters for `fit`**: - `X` (np.ndarray): Training features of shape (N, M), where N is the number of samples and M is the number of features. - `y` (np.ndarray): Training target labels of shape (N, 1). - `epochs` (int): Number of training epochs. 3. **Method Parameters for `predict`**: - `X` (np.ndarray): Test features of shape (N, M). 4. **Method Output for `predict`**: - Return (np.ndarray): Array of predicted labels of shape (N, 1). 5. **Constraints**: - Use a sigmoid activation function. - Binary classification with labels 0 and 1. **Performance Requirements**: - Ensure the implementation is efficient in both time and space and handles typical edge cases such as large input sizes or imbalanced datasets. **Example**: ```python import numpy as np from sklearn.datasets import make_moons from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score class SimpleNeuralNetwork: def __init__(self, input_size, hidden_size, output_size, learning_rate=0.01): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.learning_rate = learning_rate # Initialize weights and biases self.weights_input_hidden = np.random.randn(input_size, hidden_size) self.bias_hidden = np.zeros((1, hidden_size)) self.weights_hidden_output = np.random.randn(hidden_size, output_size) self.bias_output = np.zeros((1, output_size)) def sigmoid(self, z): return 1 / (1 + np.exp(-z)) def sigmoid_derivative(self, z): return z * (1 - z) def forward(self, X): self.z1 = np.dot(X, self.weights_input_hidden) + self.bias_hidden self.a1 = self.sigmoid(self.z1) self.z2 = np.dot(self.a1, self.weights_hidden_output) + self.bias_output self.a2 = self.sigmoid(self.z2) return self.a2 def backward(self, X, y, y_hat): # Output layer error output_error = y_hat - y output_delta = output_error * self.sigmoid_derivative(y_hat) # Hidden layer error hidden_error = np.dot(output_delta, self.weights_hidden_output.T) hidden_delta = hidden_error * self.sigmoid_derivative(self.a1) # Update weights and biases self.weights_hidden_output -= self.learning_rate * np.dot(self.a1.T, output_delta) self.bias_output -= self.learning_rate * np.sum(output_delta, axis=0, keepdims=True) self.weights_input_hidden -= self.learning_rate * np.dot(X.T, hidden_delta) self.bias_hidden -= self.learning_rate * np.sum(hidden_delta, axis=0, keepdims=True) def fit(self, X, y, epochs=1000): for epoch in range(epochs): y_hat = self.forward(X) self.backward(X, y, y_hat) def predict(self, X): y_hat = self.forward(X) return np.round(y_hat) if __name__ == \\"__main__\\": # Generate synthetic dataset X, y = make_moons(n_samples=1000, noise=0.2) y = y.reshape(-1, 1) # Split dataset X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Initialize and train the neural network nn = SimpleNeuralNetwork(input_size=2, hidden_size=5, output_size=1, learning_rate=0.01) nn.fit(X_train, y_train, epochs=10000) # Predict and evaluate accuracy y_pred = nn.predict(X_test) accuracy = accuracy_score(y_test, y_pred) print(f\\"Accuracy: {accuracy:.2f}\\") ``` **Objective**: Demonstrate an understanding of neural network fundamentals by implementing a simple binary classification neural network from scratch, focusing on forward and backward propagation, and gradient descent parameter updates.","solution":"import numpy as np class SimpleNeuralNetwork: def __init__(self, input_size, hidden_size, output_size, learning_rate=0.01): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.learning_rate = learning_rate # Initialize weights and biases self.weights_input_hidden = np.random.randn(input_size, hidden_size) self.bias_hidden = np.zeros((1, hidden_size)) self.weights_hidden_output = np.random.randn(hidden_size, output_size) self.bias_output = np.zeros((1, output_size)) def sigmoid(self, z): return 1 / (1 + np.exp(-z)) def sigmoid_derivative(self, z): return z * (1 - z) def forward(self, X): self.z1 = np.dot(X, self.weights_input_hidden) + self.bias_hidden self.a1 = self.sigmoid(self.z1) self.z2 = np.dot(self.a1, self.weights_hidden_output) + self.bias_output self.a2 = self.sigmoid(self.z2) return self.a2 def backward(self, X, y, y_hat): # Output layer error output_error = y_hat - y output_delta = output_error * self.sigmoid_derivative(y_hat) # Hidden layer error hidden_error = np.dot(output_delta, self.weights_hidden_output.T) hidden_delta = hidden_error * self.sigmoid_derivative(self.a1) # Update weights and biases self.weights_hidden_output -= self.learning_rate * np.dot(self.a1.T, output_delta) self.bias_output -= self.learning_rate * np.sum(output_delta, axis=0, keepdims=True) self.weights_input_hidden -= self.learning_rate * np.dot(X.T, hidden_delta) self.bias_hidden -= self.learning_rate * np.sum(hidden_delta, axis=0, keepdims=True) def fit(self, X, y, epochs=1000): for epoch in range(epochs): y_hat = self.forward(X) self.backward(X, y, y_hat) def predict(self, X): y_hat = self.forward(X) return np.round(y_hat)"},{"question":"# Sales Tax Calculator **Scenario**: You have been hired by a small business to develop a system for calculating the total price of items after applying sales tax. Sales tax rates vary depending on the type of item. The business needs a program that can handle different tax categories and compute the final price accordingly. **Requirements**: 1. Write a function `calculate_price(price: float, category: str) -> float` that takes a float representing the base price of an item and a string representing the category of the item. The function should return the total price after applying the appropriate sales tax. 2. Write a function `apply_bulk_discount(price: float, quantity: int) -> float` that takes a float representing the total price of items and an integer representing the quantity of items. If the quantity is 10 or more, apply a 5% discount, otherwise, return the original price. **Function Signatures**: ```python def calculate_price(price: float, category: str) -> float: pass def apply_bulk_discount(price: float, quantity: int) -> float: pass ``` **Input/Output**: * `calculate_price`: * **Input**: * A float `price` representing the base price of an item. * A string `category` representing the category of the item. * **Output**: * A float representing the total price of the item after applying the sales tax. * `apply_bulk_discount`: * **Input**: * A float `price` representing the total price of items. * An integer `quantity` representing the quantity of items. * **Output**: * A float representing the total price after applying the bulk discount (if applicable). **Constraints**: * The `category` should be one of the following: `\\"essential\\"`, `\\"luxury\\"`, `\\"other\\"`. * Sales tax rates: * `\\"essential\\"`: 5% * `\\"luxury\\"`: 15% * `\\"other\\"`: 10% * For `apply_bulk_discount`, the input `quantity` will always be a non-negative integer. * Do not use any external libraries other than built-in ones. * Ensure the functions handle edge cases and raise appropriate errors if the input format is invalid. **Example**: ```python >>> calculate_price(100.0, \\"essential\\") 105.0 >>> calculate_price(200.0, \\"luxury\\") 230.0 >>> apply_bulk_discount(105.0, 10) 99.75 >>> apply_bulk_discount(105.0, 5) 105.0 ``` # Additional Notes: Your solution will be evaluated on correctness, efficiency, and adherence to best coding practices. Ensure to write clean and readable code with appropriate comments.","solution":"def calculate_price(price: float, category: str) -> float: Calculates the total price of an item after applying the sales tax based on the category. :param price: Base price of the item. :param category: The category of the item, which can be \\"essential\\", \\"luxury\\", or \\"other\\". :return: Total price after applying the sales tax. if not isinstance(price, (float, int)) or price < 0: raise ValueError(\\"Price must be a non-negative float or int.\\") if category not in [\\"essential\\", \\"luxury\\", \\"other\\"]: raise ValueError(\\"Category must be one of \'essential\', \'luxury\', or \'other\'.\\") tax_rates = { \\"essential\\": 0.05, \\"luxury\\": 0.15, \\"other\\": 0.10 } tax_rate = tax_rates.get(category) total_price = price + (price * tax_rate) return round(total_price, 2) def apply_bulk_discount(price: float, quantity: int) -> float: Applies a bulk discount if the quantity is 10 or more. :param price: Total price of the items. :param quantity: Quantity of the items. :return: Total price after applying the bulk discount. if not isinstance(price, (float, int)) or price < 0: raise ValueError(\\"Price must be a non-negative float or int.\\") if not isinstance(quantity, int) or quantity < 0: raise ValueError(\\"Quantity must be a non-negative integer.\\") discount_rate = 0.05 if quantity >= 10: price = price - (price * discount_rate) return round(price, 2)"},{"question":"# Question: You are required to write a function that converts a given hexadecimal string to its equivalent decimal representation. The function should handle both upper and lower case hexadecimal characters. Additionally, it should validate the input to ensure it only contains valid hexadecimal characters (0-9, A-F, a-f). If the input is invalid, your function should return `None`. # Input: - A single string `hex_string` representing a number in hexadecimal format. # Output: - An integer representing the decimal equivalent of the given hexadecimal string, or `None` if the input is invalid. # Constraints: - Input string length can be up to 12 characters. - Input string can include any of the valid hexadecimal characters (0-9, A-F, a-f). # Function Signature: ```python def hex_to_decimal(hex_string: str) -> int: pass ``` # Example: ```python >>> hex_to_decimal(\'1A3F\') 6719 >>> hex_to_decimal(\'abc\') 2748 >>> hex_to_decimal(\'GHI\') None ``` # Note: Make sure your function is efficient and properly handles both valid and invalid inputs as specified.","solution":"def hex_to_decimal(hex_string: str) -> int: Converts a hexadecimal string to its equivalent decimal representation. Returns None if the input is not a valid hexadecimal string. try: # Check if the input string is a valid hexadecimal int_value = int(hex_string, 16) except ValueError: # If it raises a ValueError, it means the input is not a valid hexadecimal string return None return int_value"},{"question":"# Depth-First Search Variant: Course Scheduling In this task, you are required to solve a course scheduling problem using Depth-First Search (DFS). The problem involves determining if all courses can be completed given some prerequisites. Your Task Write a function `can_finish_courses` to determine if all courses can be finished given the prerequisite pairs. * **Input**: - `num_courses`: Integer denoting the total number of courses (labeled from 0 to num_courses-1). - `prerequisites`: List of pairs `[a, b]` where `b` is a prerequisite for `a`. * **Output**: - Return `True` if it\'s possible to complete all courses, otherwise return `False`. Constraints * (1 leq text{num_courses} leq 1000) * (0 leq text{prerequisites.length} leq 5000) * Prerequisites are represented as directed edges in a graph. Example ```python num_courses = 4 prerequisites = [ [1, 0], [2, 1], [3, 2], [1, 3] ] result = can_finish_courses(num_courses, prerequisites) print(\\"Can all courses be finished?:\\", result) # Output: False ``` Explanation - If there is a cycle in the course prerequisite graph, it means that it’s not possible to complete all courses because each course in the cycle would be waiting on the completion of another course in the cycle. - In the given example, there is a cycle involving courses `[1, 2, 3]`, making it impossible to complete all courses. Expectations: 1. **Correctness**: Correctly identify if all courses can be completed or not. 2. **Efficiency**: Implement the algorithm within the constraints of time and space. 3. **Robust Handling**: Cover edge cases such as no prerequisites, disjoint graphs, and self-loops. ```python def can_finish_courses(num_courses, prerequisites): from collections import defaultdict, deque # Create adjacency list for the graph graph = defaultdict(list) for dest, src in prerequisites: graph[src].append(dest) # Track visit states: 0 = not visited, 1 = visiting, 2 = visited visit = [0] * num_courses def dfs(course): if visit[course] == 1: # currently visiting return False if visit[course] == 2: # already visited return True visit[course] = 1 # mark as currently visiting for neighbor in graph[course]: if not dfs(neighbor): return False visit[course] = 2 # mark as visited return True # Check each course for course in range(num_courses): if not dfs(course): return False return True ``` This question aligns with the provided sample in terms of style, complexity, and scope. It involves understanding and applying graph algorithms, specifically depth-first search (DFS), along with handling cycles in directed graphs to determine course scheduling feasibility.","solution":"def can_finish_courses(num_courses, prerequisites): from collections import defaultdict # Create an adjacency list for the graph graph = defaultdict(list) for dest, src in prerequisites: graph[src].append(dest) # Track visit states: 0 = not visited, 1 = visiting, 2 = visited visit = [0] * num_courses def dfs(course): if visit[course] == 1: # currently visiting (cycle detected) return False if visit[course] == 2: # fully visited return True visit[course] = 1 # mark as currently visiting for neighbor in graph[course]: if not dfs(neighbor): return False visit[course] = 2 # mark as fully visited return True # Check each course for course in range(num_courses): if not dfs(course): return False return True"},{"question":"# Problem Statement A Fibonacci prime is a Fibonacci number that is also a prime number. The Fibonacci sequence is defined as follows: [ F_0 = 0, quad F_1 = 1, quad F_n = F_{n-1} + F_{n-2} quad text{for} quad n geq 2 ] Write a function to find the (N)-th Fibonacci prime number. # Requirements 1. Implement a function to generate Fibonacci numbers. 2. Implement a function to check if a number is prime. 3. Develop the main function that uses the above functionalities to find the (N)-th Fibonacci prime number. # Input - An integer (N), the position of the Fibonacci prime number to find. # Output - An integer representing the (N)-th Fibonacci prime number. # Example ```python def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. def nth_fibonacci_prime(N: int) -> int: Returns the N-th Fibonacci prime number. # Example usage: print(nth_fibonacci_prime(5)) # Expected output: 233 ``` # Constraints - ( 1 leq N leq 50 ) You are required to handle edge cases, optimize where possible, and ensure the functions are correct and efficient for large (N) values. # Hints - Use a helper function to check if a number is prime. - Use a generator or a loop to generate Fibonacci numbers until you find the (N)-th Fibonacci prime.","solution":"def generate_fibonacci(): A generator to yield Fibonacci numbers. a, b = 0, 1 while True: yield a a, b = b, a + b def is_prime(n: int) -> bool: Check if a number is prime. if n < 2: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def nth_fibonacci_prime(N: int) -> int: Find the N-th Fibonacci prime number. count = 0 fib_gen = generate_fibonacci() while True: fib_num = next(fib_gen) if is_prime(fib_num): count += 1 if count == N: return fib_num"},{"question":"New Question: **Problem Statement:** You are given a string and your goal is to determine the shortest distance from any character in the string to a target character specified. The function should take a string and a target character as input and return a list with each element representing the shortest distance from the character at that position to the target character. **Function Signature:** ```python def shortest_to_target(s: str, target: str) -> List[int]: pass ``` # Input: - `s`: A string of length `1` to `10^4` containing only lowercase alphabetic characters. - `target`: A single lowercase alphabetic character guaranteed to exist in the string `s`. # Output: - A list of integers where the `i-th` element is the shortest distance from the character at the `i-th` position to the target character in the string. # Constraints: - The length of the string `s` will be between `1` and `10^4`. - The string `s` will contain only lowercase alphabetic characters. - The target character `target` will be a lowercase alphabetic and will always be present in the string `s`. # Example: ```python # Given the string: # s = \\"loveleetcode\\", target = \'e\' # # The output should be: # shortest_to_target(s, target) -> [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] ``` # Implementation Details: - Traverse the string `s` to find the shortest distance to the target character for each position. - Consider efficient algorithms that can process the string in linear time. - Ensure the implementation handles edge cases like multiple consecutive occurrences of the target character. # Testing: Ensure your implementation passes the given example and apply additional test cases to validate your code.","solution":"from typing import List def shortest_to_target(s: str, target: str) -> List[int]: n = len(s) result = [float(\'inf\')] * n # Traverse from left to right prev_position = float(\'-inf\') for i in range(n): if s[i] == target: prev_position = i result[i] = i - prev_position # Traverse from right to left prev_position = float(\'inf\') for i in range(n - 1, -1, -1): if s[i] == target: prev_position = i result[i] = min(result[i], prev_position - i) return result"},{"question":"# Coding Assessment: Matrix Diagonal Sum Calculation Given an `N x N` matrix (a square matrix), write a program to calculate the sum of both its primary and secondary diagonals and return the results as a tuple. 1. **primary_diagonal_sum** 2. **secondary_diagonal_sum** Requirements 1. **primary_diagonal_sum(matrix):** - **Input**: - `matrix`: List of lists of integers, where each element represents a row in an `N x N` matrix. - **Output**: - Returns an integer representing the sum of the primary diagonal elements. - **Constraints**: - The matrix will always be a valid `N x N` matrix. - `1 <= N <= 100` 2. **secondary_diagonal_sum(matrix):** - **Input**: - `matrix`: List of lists of integers, where each element represents a row in an `N x N` matrix. - **Output**: - Returns an integer representing the sum of the secondary diagonal elements. - **Constraints**: - The matrix will always be a valid `N x N` matrix. - `1 <= N <= 100` Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Calculate the sum of the primary diagonal primary_sum = primary_diagonal_sum(matrix) # Expected: 15 (1 + 5 + 9) # Calculate the sum of the secondary diagonal secondary_sum = secondary_diagonal_sum(matrix) # Expected: 15 (3 + 5 + 7) ``` Use the above-mentioned function definitions to implement the required functionality. Inputs will always be in the specified format and constraints.","solution":"def primary_diagonal_sum(matrix): Returns the sum of the primary diagonal elements of the matrix. return sum(matrix[i][i] for i in range(len(matrix))) def secondary_diagonal_sum(matrix): Returns the sum of the secondary diagonal elements of the matrix. n = len(matrix) return sum(matrix[i][n - 1 - i] for i in range(n))"},{"question":"Question # [Question 2]: # Quicksort Algorithm Implementation and Validation **Scenario/Context:** Imagine you are developing a feature for a database management system where you need to sort entries efficiently. Your task is to implement the Quicksort algorithm to sort a list of elements provided as input. Additionally, ensure that the input is validated to be a list of comparable elements (e.g., integers, floats, or strings). **Task:** Implement the Quicksort algorithm with validation of the input parameters. The function should sort the list of elements in ascending order. **Function Signature:** ```python def quicksort( arr: list, ) -> list: pass ``` # Input - **arr** (list): A list of comparable elements (integers, floats, or strings). # Output - A list with elements sorted in ascending order. # Constraints - The input list `arr` should be a non-empty list of comparable elements (either all integers, all floats, or all strings). - Proper validation for edge cases and incorrect data types. # Performance Requirements - Expected average-case time complexity is O(n log n). - Expected worst-case time complexity is O(n^2). # Example ```python # Example 1 arr1 = [3, 6, 8, 10, 1, 2, 1] # Expected Output: [1, 1, 2, 3, 6, 8, 10] print(quicksort(arr1)) # Example 2 arr2 = [\\"apple\\", \\"orange\\", \\"banana\\", \\"grape\\"] # Expected Output: [\\"apple\\", \\"banana\\", \\"grape\\", \\"orange\\"] print(quicksort(arr2)) # Example 3 arr3 = [12.2, 3.2, 5.1, 7.4] # Expected Output: [3.2, 5.1, 7.4, 12.2] print(quicksort(arr3)) ``` # Validation Implement proper validation checks for the inputs to ensure they meet the following criteria: - `arr` must be a non-empty list. - All elements in `arr` must be of the same type (either all integers, all floats, or all strings). - Raise appropriate error messages for invalid inputs. # Implementation (Example) Here is an example implementation of the quicksort function. Ensure that you include validation logic in your solution. ```python def quicksort(arr): if not isinstance(arr, list) or len(arr) == 0: raise ValueError(\\"Input must be a non-empty list.\\") if not all(isinstance(x, (int, float)) for x in arr) and not all(isinstance(x, str) for x in arr): raise ValueError(\\"All elements must be of the same type (all integers, all floats, or all strings).\\") if len(set(type(x) for x in arr)) > 1: raise ValueError(\\"All elements in arr should be of the same type.\\") def partition(arr, low, high): pivot = arr[(low + high) // 2] left = low right = high while left <= right: while arr[left] < pivot: left += 1 while arr[right] > pivot: right -= 1 if left <= right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 return left def _quicksort(arr, low, high): if low < high: pi = partition(arr, low, high) _quicksort(arr, low, pi - 1) _quicksort(arr, pi, high) return arr return _quicksort(arr, 0, len(arr) - 1) ```","solution":"def quicksort(arr): Sorts a list of comparable elements using the Quicksort algorithm with added validation for input parameters. if not isinstance(arr, list) or len(arr) == 0: raise ValueError(\\"Input must be a non-empty list.\\") if not all(isinstance(x, (int, float)) for x in arr) and not all(isinstance(x, str) for x in arr): raise ValueError(\\"All elements must be of the same type (all integers, all floats, or all strings).\\") if len(set(type(x) for x in arr)) > 1: raise ValueError(\\"All elements in arr should be of the same type.\\") def partition(arr, low, high): pivot = arr[(low + high) // 2] left = low right = high while left <= right: while arr[left] < pivot: left += 1 while arr[right] > pivot: right -= 1 if left <= right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 return left def _quicksort(arr, low, high): if low < high: pi = partition(arr, low, high) _quicksort(arr, low, pi - 1) _quicksort(arr, pi, high) return arr return _quicksort(arr, 0, len(arr) - 1)"},{"question":"# Problem Statement You are assigned to implement a library catalog search system that can handle queries on book titles with wildcard characters. The wildcard character \'?\' matches exactly one arbitrary character, and the wildcard character \'*\' matches zero or more arbitrary characters. The catalog should support adding new books and searching for books with these wildcard patterns. Function Descriptions 1. **add_book(title: str) -> None** - Input: A book title string to be added to the catalog. - Output: None. It simply adds the book title to the catalog. - Example: ```python add_book(\\"The Great Gatsby\\") # Adds \\"The Great Gatsby\\" to the catalog. ``` 2. **search_books(query: str) -> List[str]** - Input: A query string containing alphabetical characters, spaces, and wildcard characters (\'?\' and \'*\'). - Output: A list of all book titles in the catalog that match the query pattern. - Example: ```python search_books(\\"The * Gatsby\\") # returns [\'The Great Gatsby\'] if it has been added to the catalog before. ``` # Constraints: - The input titles will be non-empty strings containing alphabetic characters and spaces. - The input queries will contain alphabetic characters, spaces, and wildcard characters (\'?\' and \'*\'). - The catalog can initially contain no books or an unspecified number of books. # Implementation Implement the following functions: ```python class Catalog: def __init__(self): self.books = [] def add_book(self, title: str) -> None: # Your implementation here pass def search_books(self, query: str) -> List[str]: # Your implementation here pass ``` # Example Usage ```python catalog = Catalog() catalog.add_book(\\"Harry Potter and the Philosopher\'s Stone\\") catalog.add_book(\\"The Great Gatsby\\") catalog.add_book(\\"To Kill a Mockingbird\\") print(catalog.search_books(\\"Harry *\\")) # Output: [\'Harry Potter and the Philosopher\'s Stone\'] print(catalog.search_books(\\"The ?reat Gatsby\\")) # Output: [\'The Great Gatsby\'] print(catalog.search_books(\\"To Kill a *\\")) # Output: [\'To Kill a Mockingbird\'] ```","solution":"import fnmatch class Catalog: def __init__(self): self.books = [] def add_book(self, title: str) -> None: Adds a new book title to the catalog. self.books.append(title) def search_books(self, query: str) -> list: Searches for books in the catalog that match the given query pattern. # Use fnmatch to support the necessary wildcard matching. # \'?\' matches exactly one character, \'*\' matches zero or more characters. matching_books = fnmatch.filter(self.books, query) return matching_books"},{"question":"# Coding Assessment Question Context You are working on a software project that requires analyzing and summarizing sales data for a large online retail store. As part of the project, you need to process sales records and generate a summary based on specific criteria. Task Write a Python function `sales_summary` that performs the following operations: 1. Parse the input list of strings where each string represents a sales record in the format \\"item_name,quantity_sold,price_per_item\\". 2. Calculate the total revenue for each unique item. 3. Return a dictionary where the keys are the item names and the values are the corresponding total revenues. Function Signature ```python def sales_summary(sales: List[str]) -> Dict[str, float]: ``` Input * `sales` (a list of strings): Each string contains an item name, the quantity sold, and the price per item separated by commas. Output * A dictionary where each key is an item name and the corresponding value is the total revenue generated from the item. Constraints 1. Each sales record will follow the format \\"item_name,quantity_sold,price_per_item\\". 2. `item_name` will be a string of printable ASCII characters without commas. 3. `quantity_sold` will be an integer in the range `[0, 1000]`. 4. `price_per_item` will be a float in the range `[0.0, 10000.0]`. 5. Each string in the input list will have a maximum length of `100` characters. 6. The input list will contain at most `10000` records. Example ```python # Example sales = [ \\"apple,10,0.5\\", \\"banana,5,0.2\\", \\"apple,20,0.55\\", \\"orange,3,0.75\\", ] print(sales_summary(sales)) # Output: {\'apple\': 16.0, \'banana\': 1.0, \'orange\': 2.25} ``` Notes * Make sure to handle any edge cases where the input list might be empty. * Ensure that your function correctly parses the input strings and performs calculations accurately.","solution":"from typing import List, Dict def sales_summary(sales: List[str]) -> Dict[str, float]: Parses the input list of sales records and calculates the total revenue for each unique item. Returns a dictionary with item names as keys and total revenues as values. summary = {} for record in sales: item_name, quantity_sold, price_per_item = record.split(\',\') quantity_sold = int(quantity_sold) price_per_item = float(price_per_item) revenue = quantity_sold * price_per_item if item_name in summary: summary[item_name] += revenue else: summary[item_name] = revenue return summary"},{"question":"# Question: Optimize a Road Network using Dijkstra\'s Algorithm **Context**: You are tasked with optimizing a road network for a city by implementing a modified Dijkstra\'s shortest path algorithm. The road network consists of various intersections (nodes) connected by roads (edges), with each road having a travel cost associated with it. Additionally, some intersections are marked as high traffic areas, and the travel cost from or to these intersections should be increased by a fixed penalty. **Function to Implement**: Implement the following function: ```python def optimize_road_network(graph, start, goal, high_traffic, traffic_penalty): Implementation of the modified Dijkstra\'s algorithm. Parameters: graph : Dictionary where the keys are node identifiers and the values are lists of tuples (neighbor, cost). start : The identifier of the starting node. goal : The identifier of the goal node. high_traffic : Set of node identifiers that are high traffic areas. traffic_penalty : An integer representing additional cost for traveling from or to a high traffic area. Returns: path : List of nodes representing the path from start to goal, inclusive. If no path is found, return an empty list. ``` **Input/Output**: - **Input**: - `graph`: A dictionary where the keys are node identifiers (strings or integers) and the values are lists of tuples. Each tuple represents a neighboring node and the cost to travel there. - `start`: A string or integer representing the identifier of the starting node. - `goal`: A string or integer representing the identifier of the goal node. - `high_traffic`: A set of node identifiers that are considered high traffic areas. - `traffic_penalty`: An integer indicating the additional cost incurred when traveling to or from a high traffic node. - **Output**: - `path`: A list of node identifiers representing the path from start to goal. If no path exists, return an empty list. **Constraints**: - The number of nodes does not exceed 500. - The number of edges does not exceed 5000. - `traffic_penalty` is a positive integer less than 100. - All costs in `graph` are positive integers. **Requirements**: 1. Ensure the algorithm handles increased costs for high traffic nodes appropriately. 2. Modify the node cost calculations to include the traffic penalty when applicable. 3. Optimize the usage of data structures to ensure the algorithm runs efficiently within the given constraints. **Performance Considerations**: - The algorithm should handle the maximum provided input size efficiently. - Utilize appropriate data structures, such as priority queues, for managing the node exploration process in Dijkstra\'s algorithm.","solution":"import heapq def optimize_road_network(graph, start, goal, high_traffic, traffic_penalty): Implementation of the modified Dijkstra\'s algorithm with traffic penalty. Parameters: graph : Dictionary where the keys are node identifiers and the values are lists of tuples (neighbor, cost). start : The identifier of the starting node. goal : The identifier of the goal node. high_traffic : Set of node identifiers that are high traffic areas. traffic_penalty : An integer representing additional cost for traveling from or to a high traffic area. Returns: path : List of nodes representing the path from start to goal, inclusive. If no path is found, return an empty list. # Create a priority queue for the min-heap. pq = [(0, start, [])] # (cost, current_node, path) # Dictionary to store the shortest path cost to each node. shortest_path_costs = {start: 0} while pq: current_cost, current_node, path = heapq.heappop(pq) if current_node in high_traffic: current_cost += traffic_penalty path = path + [current_node] # If we reached the goal node, we\'re done. if current_node == goal: return path # Traverse all neighbors. for neighbor, travel_cost in graph.get(current_node, []): new_cost = current_cost + travel_cost if neighbor in high_traffic: new_cost += traffic_penalty # If the newly calculated cost is less than the known cost, # update the path cost and push the new state to the priority queue. if neighbor not in shortest_path_costs or new_cost < shortest_path_costs[neighbor]: shortest_path_costs[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor, path)) # If the goal node wasn\'t reached, return an empty path. return []"},{"question":"# Question: Implement a Memory-Efficient Sudoku Solver Scenario Sudoku is a popular number-placement puzzle where the objective is to fill a 9x9 grid with digits so that each column, each row, and each of the nine 3x3 subgrids contain all of the digits from 1 to 9. You are provided with an incomplete Sudoku board and need to complete it by filling in the missing values. However, memory usage is a major concern due to a concurrent processing environment, which restricts your solution to be as memory-efficient as possible. Your task is to implement a Sudoku solver function that adheres to these memory constraints while solving the puzzle efficiently. Function Implementation You need to implement the `solve_sudoku` function, which once provided with an initial Sudoku configuration, solves the puzzle by filling in the missing digits complying with the Sudoku rules. Function Signature ```python def solve_sudoku(board: list[list[int]]) -> list[list[int]]: ``` Input - `board` : a 2D list of integers, representing the Sudoku board where empty cells are denoted by 0. The board is always a 9x9 grid. Output - Returns the completed Sudoku board as a 2D list of integers. Constraints - The initial board configuration will always be a valid but incomplete Sudoku puzzle. - The function needs to be optimized for minimal memory usage while ensuring correctness and completion of the puzzle. Example ```python initial_board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9], ] solved_board = solve_sudoku(initial_board) # Expected output would be a fully solved Sudoku board: # [ # [5, 3, 4, 6, 7, 8, 9, 1, 2], # [6, 7, 2, 1, 9, 5, 3, 4, 8], # [1, 9, 8, 3, 4, 2, 5, 6, 7], # [8, 5, 9, 7, 6, 1, 4, 2, 3], # [4, 2, 6, 8, 5, 3, 7, 9, 1], # [7, 1, 3, 9, 2, 4, 8, 5, 6], # [9, 6, 1, 5, 3, 7, 2, 8, 4], # [2, 8, 7, 4, 1, 9, 6, 3, 5], # [3, 4, 5, 2, 8, 6, 1, 7, 9], # ] ``` # Considerations - Implement a recursive backtracking algorithm with additional memory-efficient techniques. - Ensure the algorithm terminates in a reasonable timeframe even for the most challenging Sudoku puzzles. - Minimize extra memory usage by avoiding unnecessary data structures and excessive state duplication.","solution":"def solve_sudoku(board): Function to solve Sudoku in a memory-efficient manner using backtracking. def is_valid(board, row, col, num): Check if it\'s valid to place num at board[row][col] block_row, block_col = row // 3 * 3, col // 3 * 3 if any(num == board[row][x] for x in range(9)): return False if any(num == board[x][col] for x in range(9)): return False if any(num == board[block_row + i][block_col + j] for i in range(3) for j in range(3)): return False return True def solve(board): Solves the Sudoku board using backtracking algorithm. for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = 0 return False return True solve(board) return board"},{"question":"Word Pattern Matching You are to implement a function that determines if a given string follows a specified pattern. Each character in the pattern corresponds to a distinct word in the string. # Function Signature ```python def word_pattern(pattern: str, s: str) -> bool: ``` # Input: * A string `pattern` where `1 <= len(pattern) <= 100`. * A string `s` consisting of lowercase English letters separated by spaces where `1 <= len(s) <= 1000`. # Output: * A boolean value `True` if `s` follows the `pattern`, `False` otherwise. # Constraints: * Each character in `pattern` maps to a distinct non-empty word. * The input strings `pattern` and `s` will have at least one character/word respectively. # Examples: ```python >>> word_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> word_pattern(\\"abba\\", \\"dog cat cat fish\\") False >>> word_pattern(\\"aaaa\\", \\"dog dog dog dog\\") True >>> word_pattern(\\"abba\\", \\"dog dog dog dog\\") False ``` # Requirements: * Create a dictionary to map characters to words and another to ensure that words map back to their respective characters (bidirectional mapping). * Ensure that each character in the pattern maps to exactly one unique word and vice versa. * Efficiently handle the mapping to validate if the string follows the given pattern. # Explanation: 1. Split the string `s` into a list of words. 2. Traverse each character in `pattern` and each word in the split list simultaneously. 3. Use dictionaries to check if the mappings between characters and words are consistent. 4. Return `True` if the entire string follows the pattern, otherwise `False`.","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"# Linked List Reversal and Circular Detection Context Working with data structures efficiently is a critical skill in programming. Linked lists are a fundamental structure where each element (node) contains a reference to the next node in the sequence. Some advanced applications involve reversing linked lists or detecting circular references within them. Task Implement two functions: one to reverse a singly linked list and another to detect if a linked list has a loop (circular reference). Specific Objectives 1. **Reverse Linked List**: Write a function to reverse the order of nodes in a singly linked list. 2. **Detect Loop**: Write a function to detect if a singly linked list contains a cycle. Function Signatures ```python class ListNode: def __init__(self, x): self.val = x self.next = None def reverse_linked_list(head: ListNode) -> ListNode: pass def has_cycle(head: ListNode) -> bool: pass ``` Input * For `reverse_linked_list`: - `head`: The head node of a singly linked list. * For `has_cycle`: - `head`: The head node of a singly linked list. Output * For `reverse_linked_list`: - Returns the new head node of the reversed list. * For `has_cycle`: - Returns `True` if the list has a cycle, and `False` otherwise. Constraints - The number of nodes in the linked list is no more than (10^4). - Node values are integers in the range ([-10^5, 10^5]). Requirements - *Reverse Linked List*: Use an iterative approach to efficiently reverse the nodes of the list. - *Detect Cycle*: Implement Floyd’s Cycle-Finding Algorithm (or Tortoise and Hare algorithm) to detect cycles. Example ```python # Example for reverse_linked_list # Input: 1 -> 2 -> 3 -> 4 -> 5 -> None # Output: 5 -> 4 -> 3 -> 2 -> 1 -> None # Example for has_cycle # Input: 3 -> 2 -> 0 -> -4 -> (points back to 2) # Output: True ``` Note * Ensure that your solutions are optimized for both time and space. * Test your functions extensively to cover various edge cases, such as empty lists and single-node lists. Sample Code Implementation ```python class ListNode: def __init__(self, x): self.val = x self.next = None def reverse_linked_list(head: ListNode) -> ListNode: prev = None curr = head while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev def has_cycle(head: ListNode) -> bool: if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True ``` Good luck!","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list and returns the new head node. prev = None curr = head while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev def has_cycle(head: ListNode) -> bool: Detects if a linked list contains a cycle (loop). Uses Floyd’s Cycle-Finding Algorithm (Tortoise and Hare algorithm). if not head or not head.next: return False slow, fast = head, head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"# Problem Statement You are given a list of integers where each integer appears exactly twice, except for one integer that appears exactly once. Implement a function to find and return the integer that appears exactly once using linear time complexity and constant space complexity. # Function Signature ```python def find_single_number(nums: List[int]) -> int: Find the integer that appears exactly once in the list where every other integer appears exactly twice. Parameters: nums (List[int]): A list of integers where each integer, except one, appears twice. Returns: int: The integer that appears exactly once. Example: >>> find_single_number([2, 2, 1]) 1 >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([1]) 1 ``` # Constraints * The list will contain at least one integer and all integers are between (-10^5) and (10^5). * The solution should use linear time complexity (O(n)) and constant space complexity (O(1)). # Example Input ```python nums = [4, 1, 2, 1, 2] ``` # Example Output ```python 4 ``` # Performance Requirements * Handle lists with up to (10^6) integers efficiently.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Find the integer that appears exactly once in the list where every other integer appears exactly twice. Parameters: nums (List[int]): A list of integers where each integer, except one, appears twice. Returns: int: The integer that appears exactly once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Coding Challenge: Dynamic Non-overlapping Intervals Finder Context Managing schedules or reservations often involves working with time intervals. Efficiently finding the maximum set of non-overlapping intervals is a common optimization problem in various fields such as machine scheduling or event planning. Task Write a function `max_non_overlapping_intervals(intervals: list[tuple[int, int]]) -> int` that finds the maximum number of non-overlapping intervals from a given list of intervals. Input * A list of tuples `intervals`, where each tuple represents a time interval with a start and end time `(start, end)`. The start and end times are both integers. Output * An integer representing the maximum number of non-overlapping intervals. Constraints * The intervals may be overlapping or non-overlapping. * The list of intervals can be empty. Performance Requirement Your solution should efficiently handle a list of intervals up to the order of 10^5 elements. Example ```python >>> max_non_overlapping_intervals([(1, 2), (2, 3), (3, 4), (1, 3)]) 3 >>> max_non_overlapping_intervals([(1, 2), (1, 2), (1, 2)]) 1 >>> max_non_overlapping_intervals([(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_intervals([(1, 3), (4, 6), (7, 9)]) 3 >>> max_non_overlapping_intervals([(1, 8), (2, 4), (3, 5), (6, 7)]) 2 ``` Problem Solving Strategy 1. Sort the intervals by the end time. 2. Iterate through the sorted intervals, using a greedy approach to select the maximum number of non-overlapping intervals. Good luck and optimize efficiently to handle large inputs!","solution":"def max_non_overlapping_intervals(intervals): Finds the maximum number of non-overlapping intervals. Args: intervals (list[tuple[int, int]]): A list of tuples where each tuple represents a time interval. Returns: int: Maximum number of non-overlapping intervals. if not intervals: return 0 # Sort intervals by the end time intervals.sort(key=lambda x: x[1]) # Greedily select the maximum number of non-overlapping intervals count = 0 end_time = float(\'-inf\') for interval in intervals: if interval[0] >= end_time: count += 1 end_time = interval[1] return count"},{"question":"# Scenario You are developing a software module that handles basic text processing and manipulation. A key feature is to find and replace specific words in a given text. This feature should be case-insensitive and should replace only whole words, not substrings within other words. # Task Write a function `replace_word` that takes a string `text`, a string `target`, and a string `replacement`, and returns a new string where all occurrences of the `target` word are replaced with the `replacement` word. The replacement should be case-insensitive and should only replace whole words. # Function Signature ```python def replace_word(text: str, target: str, replacement: str) -> str: ``` # Input - `text`: A string representing the input text. - `target`: A string representing the word to be replaced. - `replacement`: A string representing the word to replace the target. # Output - Returns a new string with the target word replaced by the replacement word. # Constraints - The text can contain punctuations and spaces. - The text is non-empty and contains only printable ASCII characters. - The replacement must handle cases where the target appears at the start, middle, or end of the text. # Examples ```python print(replace_word(\\"The quick brown fox jumps over the lazy dog\\", \\"fox\\", \\"cat\\")) # Output: \\"The quick brown cat jumps over the lazy dog\\" print(replace_word(\\"Hello, hello, HELLO!\\", \\"hello\\", \\"hey\\")) # Output: \\"Hey, hey, HEY!\\" print(replace_word(\\"Testing! 1, 2, 3.\\", \\"2\\", \\"two\\")) # Output: \\"Testing! 1, two, 3.\\" print(replace_word(\\"Word boundary test: substring.\\", \\"sub\\", \\"new\\")) # Output: \\"Word boundary test: substring.\\" ``` # Notes - Ensure the solution maintains the case of words that are not part of the target. - Only replace whole words, not parts of words. For instance, replacing \\"he\\" in \\"the\\" should not occur. - Handle punctuation and spaces appropriately to ensure replacements happen only for whole words.","solution":"import re def replace_word(text: str, target: str, replacement: str) -> str: Replaces all occurrences of the target word with the replacement word in the given text. The replacement is case-insensitive and replaces only whole words. :param text: str - The input text. :param target: str - The word to be replaced. :param replacement: str - The word to replace the target with. :return: str - The text with all occurrences of the target word replaced by the replacement word. # Use regex to match whole words in a case-insensitive manner target_re = re.compile(r\'b\' + re.escape(target) + r\'b\', re.IGNORECASE) return target_re.sub(replacement, text)"},{"question":"Implementing the Longest Increasing Subsequence Problem Statement You are given an array of integers and your task is to find the length of the longest increasing subsequence (LIS). A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Input * An integer array `arr` of size `n` representing the elements of the sequence. Output * An integer representing the length of the longest increasing subsequence. Constraints * `0 <= n <= 10^4` * `-10^4 <= arr[i] <= 10^4` Example ```python arr = [10, 22, 9, 33, 21, 50, 41, 60, 80] length = longest_increasing_subsequence(arr) print(\\"Length of LIS: \\", length) # Output: 6 ``` Additional Requirements 1. Handle edge cases such as an empty array. 2. Ensure your implementation is efficient with time complexity O(n log n). 3. Implement and test using the provided signature: ```python def longest_increasing_subsequence(arr: list[int]) -> int: ``` 4. Include at least 3 unique tests covering different edge cases and normal scenarios to validate your implementation.","solution":"def longest_increasing_subsequence(arr: list[int]) -> int: Returns the length of the longest increasing subsequence in the array. if not arr: return 0 from bisect import bisect_left n = len(arr) lis = [] for num in arr: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# Coding Question Context In data analysis and manipulation, it is often necessary to perform operations on strings and lists to validate certain conditions, replace elements, or compute specific values. A typical example involves parsing a string of numbers and calculating the average after processing the string under certain rules. Task Implement a function `average_after_removals(input_string: str, k: int) -> float` that processes a string of numbers, removes the `k` largest and `k` smallest numbers, and then calculates the average of the remaining numbers. The function should handle numbers separated by commas. Requirements 1. **Function Signature**: `average_after_removals(input_string: str, k: int) -> float` 2. **Inputs**: - `input_string` (str): A string containing a list of integers separated by commas. - `k` (int): The number of largest and smallest elements to remove. 3. **Output**: - Returns the average of the remaining numbers after removals. 4. **Constraints**: - The string may contain between 2 and 1000 numbers. - Each number in the string is a valid integer within the range of -10000 to 10000. - 0 <= k <= len(numbers) // 2 Example ```python average_after_removals(\\"3,1,2,8,5\\", 1) # Removing the 1 smallest (1) and 1 largest (8) numbers # The remaining numbers are [3, 2, 5] # The average of [3, 2, 5] is 3.333... average_after_removals(\\"10, 20, 30, 40, 50, 60, 70, 80, 90, 100\\", 2) # Removing the 2 smallest (10, 20) and 2 largest (90, 100) numbers # The remaining numbers are [30, 40, 50, 60, 70, 80] # The average of [30, 40, 50, 60, 70, 80] is 55.0 ``` Edge Cases - Handling input strings with minimal elements (e.g., less than 2 elements remaining after removal). - Handling cases where `k` is 0, meaning no elements are removed. - Ensuring floating point precision in the output. Focus on writing correct and efficient code to handle various edge cases and large inputs effectively.","solution":"def average_after_removals(input_string: str, k: int) -> float: Process a string of numbers, removes the k largest and k smallest numbers, and calculates the average of the remaining numbers. # Split the input string by commas and convert to a list of integers numbers = list(map(int, input_string.split(\',\'))) # Sort the numbers sorted_numbers = sorted(numbers) # Remove the k smallest and k largest elements remaining_numbers = sorted_numbers[k:len(sorted_numbers) - k] # Calculate the average of the remaining numbers if remaining_numbers: average = sum(remaining_numbers) / len(remaining_numbers) else: average = 0.0 # In the event there are no remaining numbers return average"},{"question":"# Question: You are to implement a function that encodes a given string using a modified run-length encoding (RLE) algorithm with specific constraints and an inverse function to decode the encoded string back to its original form. **Objective:** Write two functions, `encode_rle` and `decode_rle`. 1. `encode_rle(s: str) -> str`: - Encodes a given string `s` using a modified run-length encoding algorithm. - Each sequence of repeated characters in the input string should be represented as the character followed by the count of its repetitions only if the length of the sequence is greater than 1. - If a character appears only once consecutively, it should be represented without a following count. 2. `decode_rle(s: str) -> str`: - Decodes a given encoded string `s` back to its original form based on the modified run-length encoding rules described above. **Constraints:** - The encoded string will only consist of lowercase alphabetic characters and digits (which represent the counts of repeated characters). - The original string will only consist of lowercase alphabetic characters. **Input and Output:** - For encode_rle: - **Input**: A lowercase string with alphabetic characters. - **Output**: A string representing the run-length encoded version. - For decode_rle: - **Input**: A string representing the run-length encoded version. - **Output**: The original string before encoding. **Examples:** 1. **Encoding Example:** ```python >>> encode_rle(\\"aaabccddd\\") \'a3bc2d3\' ``` This means \\"3 a\'s\\", \\"1 b\\", \\"2 c\'s\\", \\"3 d\'s\\". 2. **Decoding Example:** ```python >>> decode_rle(\'a3bc2d3\') \'aaabccddd\' ``` This means \\"3 a\'s\\", \\"1 b\\", \\"2 c\'s\\", \\"3 d\'s\\". **Function Signatures:** ```python def encode_rle(s: str) -> str: pass def decode_rle(s: str) -> str: pass ``` **Performance Requirements:** - The solution should handle strings up to 10^6 characters efficiently.","solution":"def encode_rle(s: str) -> str: Encodes a given string using a modified run-length encoding algorithm. if not s: return \\"\\" encoded_string = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 if count == 1: encoded_string.append(f\\"{s[i]}\\") else: encoded_string.append(f\\"{s[i]}{count}\\") i += 1 return \'\'.join(encoded_string) def decode_rle(s: str) -> str: Decodes a given encoded string back to its original form based on the modified run-length encoding rules. if not s: return \\"\\" decoded_string = [] i = 0 while i < len(s): if i + 1 < len(s) and s[i + 1].isdigit(): j = i + 1 count = 0 while j < len(s) and s[j].isdigit(): count = count * 10 + int(s[j]) j += 1 decoded_string.append(s[i] * count) i = j else: decoded_string.append(s[i]) i += 1 return \'\'.join(decoded_string)"},{"question":"# Complex Number Operations Context Working with complex numbers is a fundamental part of many fields such as signal processing, control systems, and fluid dynamics. Implementing arithmetic operations on complex numbers can strengthen your understanding of mathematical concepts and Python\'s object-oriented programming features. Task Implement a class `ComplexNumber` that supports basic arithmetic operations and some additional functionalities for complex numbers. Specific Objectives 1. **Support Arithmetic Operations**: Implement methods to add, subtract, multiply, and divide two complex numbers. 2. **Additional Functionalities**: Implement methods to find the conjugate, absolute value (magnitude), and angle (phase) of a complex number. Class Signature ```python class ComplexNumber: def __init__(self, real: float, imag: float): pass def add(self, other: \'ComplexNumber\') -> \'ComplexNumber\': pass def subtract(self, other: \'ComplexNumber\') -> \'ComplexNumber\': pass def multiply(self, other: \'ComplexNumber\') -> \'ComplexNumber\': pass def divide(self, other: \'ComplexNumber\') -> \'ComplexNumber\': pass def conjugate(self) -> \'ComplexNumber\': pass def magnitude(self) -> float: pass def angle(self) -> float: pass def __str__(self) -> str: pass ``` Input - `real`: A float representing the real part of the complex number. - `imag`: A float representing the imaginary part of the complex number. Output - Each method should return a new `ComplexNumber` instance (for arithmetic operations and conjugate) or a float (for magnitude and angle). Constraints - Ensure the division operation properly handles the case where the denominator is zero. Requirements - Your solution should handle arithmetic operations correctly following the rules of complex number operations. - Implement methods that are efficient and easy to understand. - Include a string representation of the complex number in the format \\"a + bi\\" or \\"a - bi\\". Example ```python class ComplexNumber: def __init__(self, real: float, imag: float): self.real = real self.imag = imag def add(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real + other.real, self.imag + other.imag) def subtract(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real - other.real, self.imag - other.imag) def multiply(self, other: \'ComplexNumber\') -> \'ComplexNumber\': real = self.real * other.real - self.imag * other.imag imag = self.real * other.imag + self.imag * other.real return ComplexNumber(real, imag) def divide(self, other: \'ComplexNumber\') -> \'ComplexNumber\': denom = other.real ** 2 + other.imag ** 2 if denom == 0: raise ValueError(\\"Division by zero\\") real = (self.real * other.real + self.imag * other.imag) / denom imag = (self.imag * other.real - self.real * other.imag) / denom return ComplexNumber(real, imag) def conjugate(self) -> \'ComplexNumber\': return ComplexNumber(self.real, -self.imag) def magnitude(self) -> float: return (self.real ** 2 + self.imag ** 2) ** 0.5 def angle(self) -> float: import math return math.atan2(self.imag, self.real) def __str__(self) -> str: if self.imag >= 0: return f\\"{self.real} + {self.imag}i\\" else: return f\\"{self.real} - {abs(self.imag)}i\\" if __name__ == \\"__main__\\": c1 = ComplexNumber(3, 4) c2 = ComplexNumber(1, -2) print(f\\"c1: {c1}\\") print(f\\"c2: {c2}\\") print(f\\"c1 + c2: {c1.add(c2)}\\") print(f\\"c1 - c2: {c1.subtract(c2)}\\") print(f\\"c1 * c2: {c1.multiply(c2)}\\") print(f\\"c1 / c2: {c1.divide(c2)}\\") print(f\\"Conjugate of c1: {c1.conjugate()}\\") print(f\\"Magnitude of c1: {c1.magnitude()}\\") print(f\\"Angle of c1: {c1.angle()} radians\\") ``` Good luck!","solution":"class ComplexNumber: def __init__(self, real: float, imag: float): self.real = real self.imag = imag def add(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real + other.real, self.imag + other.imag) def subtract(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real - other.real, self.imag - other.imag) def multiply(self, other: \'ComplexNumber\') -> \'ComplexNumber\': real = self.real * other.real - self.imag * other.imag imag = self.real * other.imag + self.imag * other.real return ComplexNumber(real, imag) def divide(self, other: \'ComplexNumber\') -> \'ComplexNumber\': denom = other.real ** 2 + other.imag ** 2 if denom == 0: raise ValueError(\\"Division by zero\\") real = (self.real * other.real + self.imag * other.imag) / denom imag = (self.imag * other.real - self.real * other.imag) / denom return ComplexNumber(real, imag) def conjugate(self) -> \'ComplexNumber\': return ComplexNumber(self.real, -self.imag) def magnitude(self) -> float: return (self.real ** 2 + self.imag ** 2) ** 0.5 def angle(self) -> float: import math return math.atan2(self.imag, self.real) def __str__(self) -> str: if self.imag >= 0: return f\\"{self.real} + {self.imag}i\\" else: return f\\"{self.real} - {abs(self.imag)}i\\""},{"question":"Graph Coloring: Implement and Validate the Greedy Algorithm # Objective: Demonstrate your understanding of graph algorithms by implementing and validating the Greedy Algorithm for graph coloring. This algorithm assigns colors to vertices such that no two adjacent vertices share the same color and minimizes the number of colors used. # Requirements: 1. **Function Implementation**: Implement a function `greedy_graph_coloring(graph)` that takes a graph represented as an adjacency list and returns a dictionary mapping each vertex to a color. 2. **Coloring Validity**: Ensure that the resultant coloring is valid - i.e., no two adjacent vertices have the same color. 3. **Minimum Colors**: Aim to minimize the number of colors used, although it may not always be optimal. # Input & Output Format: - **Input**: - `graph`: A dictionary where the keys are vertex labels and the values are lists of adjacent vertices. - **Output**: - A dictionary where the keys are vertex labels and the values are colors (integers starting from 1). # Examples: ```python # Example graph represented as an adjacency list graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'C\', \'D\'], \'C\': [\'A\', \'B\', \'D\'], \'D\': [\'B\', \'C\'] } # Expected output is a valid coloring, one possibility is: result = greedy_graph_coloring(graph) print(result) # {\'A\': 1, \'B\': 2, \'C\': 3, \'D\': 1} ``` # Constraints: - The graph is undirected and represented using an adjacency list. - The total number of vertices and edges should be reasonable for performance, typically up to 1000 vertices and 5000 edges. - Your algorithm does not need to find the optimal solution but should produce a valid coloring using the Greedy approach. # Performance: - The time complexity should be within acceptable limits considering the typical constraints of the problem, ideally O(V + E) where V is the number of vertices and E is the number of edges. # Function Signature: ```python def greedy_graph_coloring(graph: Dict[str, List[str]]) -> Dict[str, int]: pass ``` Implement the above function and validate its correctness and efficiency using the provided example and various test cases.","solution":"def greedy_graph_coloring(graph): Colors the vertices of the graph using the Greedy algorithm. Parameters: graph (dict): Adjacency list representation of the graph. Returns: dict: A dictionary mapping each vertex to a color. color_assignment = {} for vertex in sorted(graph): # Sorting for consistent output available_colors = set(range(1, len(graph) + 1)) # Possible color list for neighbor in graph[vertex]: if neighbor in color_assignment: available_colors.discard(color_assignment[neighbor]) color_assignment[vertex] = min(available_colors) return color_assignment"},{"question":"# Coding Question - Convert Infix to Postfix Expression In the context of symbolic manipulation and expression evaluation, it\'s often necessary to convert infix expressions to their postfix form (also known as Reverse Polish Notation). This conversion simplifies the process because postfix expressions do not require precedence rules or parentheses to indicate order of operations. # Scenario You are developing a small compiler that needs to convert mathematical expressions from infix notation (standard mathematical notation) to postfix notation. The expressions include variables, integers, and operators and may use parentheses to dictate operation order. # Task 1. Implement a function that converts a given infix expression string to its equivalent postfix expression string. 2. Ensure proper handling of operators\' precedence and associativity, as well as parentheses. # Function Signature ```python def infix_to_postfix(expression: str) -> str: pass ``` # Input * `expression`: A string representing a valid infix expression consisting of variables (single-letter), integers, and the operators `+`, `-`, `*`, `/`, and parentheses `(`, `)`. # Output * Return the equivalent postfix expression as a string. # Constraints * The input string only consists of valid infix expressions. * Handle spaces within the input string gracefully. * Operators `+` and `-` have the lowest precedence, `*` and `/` have higher precedence, and parentheses should always dictate evaluation order. # Performance Requirements * The function should run in O(n) time complexity, where n is the length of the expression. * Use O(n) space complexity to handle the operator stack and the output. # Example ```python assert infix_to_postfix(\\"a + b * c\\") == \\"a b c * +\\" assert infix_to_postfix(\\"( a + b ) * c\\") == \\"a b + c *\\" assert infix_to_postfix(\\"a + b * ( c - d )\\") == \\"a b c d - * +\\" assert infix_to_postfix(\\"a * b + c / d\\") == \\"a b * c d / +\\" assert infix_to_postfix(\\"3 + 4 * 2 / ( 1 - 5 )\\") == \\"3 4 2 * 1 5 - / +\\" ``` # Additional Notes * Consider the typical precedence rules: multiplication and division are performed before addition and subtraction, and operations inside parentheses are performed first. * Handle both single-letter variables and multi-digit integers in the expressions. * Your implementation should not rely on any external libraries for the conversion process.","solution":"def infix_to_postfix(expression: str) -> str: Convert infix expression string to postfix expression string. precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} output = [] stack = [] def is_operator(c): return c in precedence def precedence_of(c): return precedence[c] if c in precedence else 0 def handle_operator(op): while stack and precedence_of(op) <= precedence_of(stack[-1]): output.append(stack.pop()) stack.append(op) tokens = expression.split() for token in tokens: if token.isalnum(): # Operand output.append(token) elif token == \'(\': stack.append(token) elif token == \')\': while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() # pop \'(\' elif is_operator(token): handle_operator(token) while stack: output.append(stack.pop()) return \' \'.join(output)"},{"question":"# Question: Implementing a Custom List Intersection Function You are tasked with creating a custom function to find the intersection of two given lists. The intersection of two lists includes all the elements that are present in both lists without any duplicates. Ensure that the order of the elements in the output list matches the order of their first appearance in the first input list. # Function Signature ```python def list_intersection(list1: List[int], list2: List[int]) -> List[int]: Compute the intersection of two lists. :param list1: List[int] - The first list of integers. :param list2: List[int] - The second list of integers. :return: List[int] - A list containing the intersection of the two input lists, preserving the order of first occurrence in list1. >>> list_intersection([1, 2, 2, 3, 4], [3, 4, 4, 5, 6]) [3, 4] >>> list_intersection([7, 8, 9, 10], [0, 1, 2, 8]) [8] ``` # Input - `list1`: A list of integers. - `list2`: A list of integers. # Output - A list containing the intersection of the two input lists, without duplicates, while maintaining the order of first appearance in `list1`. # Constraints - The input lists can have at most 10,000 elements each. - Elements in the input lists are integers that can range from -100,000 to 100,000. # Example ```python list1 = [1, 2, 2, 3, 4] list2 = [3, 4, 4, 5, 6] output = list_intersection(list1, list2) # Expected output: [3, 4] list1 = [7, 8, 9, 10] list2 = [0, 1, 2, 8] output = list_intersection(list1, list2) # Expected output: [8] ``` # Notes: - Ensure no repeated elements in the output list. - The order of elements in the output should match their first occurrence in `list1`. ```python from typing import List def list_intersection(list1: List[int], list2: List[int]) -> List[int]: intersection_set = set(list2) result = [] seen = set() for number in list1: if number in intersection_set and number not in seen: result.append(number) seen.add(number) return result ```","solution":"from typing import List def list_intersection(list1: List[int], list2: List[int]) -> List[int]: Compute the intersection of two lists. :param list1: List[int] - The first list of integers. :param list2: List[int] - The second list of integers. :return: List[int] - A list containing the intersection of the two input lists, preserving the order of first occurrence in list1. intersection_set = set(list2) result = [] seen = set() for number in list1: if number in intersection_set and number not in seen: result.append(number) seen.add(number) return result"},{"question":"# Coding Assessment Question Problem Description Write a function that takes a list of dictionaries representing books and returns the dictionary of the book that has the highest average rating. Each dictionary contains the keys `title` (a string), `author` (a string), and `ratings` (a list of integers). If there are multiple books with the same highest average rating, return the one which appears first in the list. Function Signature ```python def highest_rated_book(books: list) -> dict: ``` Input - A list of dictionaries where each dictionary contains: - `title`: a string representing the title of the book. - `author`: a string representing the author of the book. - `ratings`: a list of integers where each integer is a rating between 1 and 5. Output - A dictionary representing the book with the highest average rating. Example ```python >>> books = [ ... {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"ratings\\": [4, 5, 3]}, ... {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"ratings\\": [5, 5, 5]}, ... {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"ratings\\": [4, 4, 4]} ... ] >>> highest_rated_book(books) {\'title\': \'Book B\', \'author\': \'Author B\', \'ratings\': [5, 5, 5]} >>> books = [ ... {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"ratings\\": [3, 3, 3]}, ... {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"ratings\\": [4, 4, 4]}, ... {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"ratings\\": [4, 4, 4]} ... ] >>> highest_rated_book(books) {\'title\': \'Book B\', \'author\': \'Author B\', \'ratings\': [4, 4, 4]} ``` Constraints - Assume all books have at least one rating. - The length of the ratings list for any book will not exceed 100. Additional Notes 1. Consider edge cases such as books with only one rating. 2. Ensure your function handles larger lists of books efficiently. 3. Return the book as given in the input list if it has the highest average rating.","solution":"def highest_rated_book(books: list) -> dict: Returns the book with the highest average rating. If there are multiple books with the same highest average rating, return the one which appears first in the list. if not books: return {} highest_avg = -1 highest_rated_book = None for book in books: avg_rating = sum(book[\'ratings\']) / len(book[\'ratings\']) if avg_rating > highest_avg: highest_avg = avg_rating highest_rated_book = book return highest_rated_book"},{"question":"# Problem Statement You have been tasked with enhancing the current algorithm used to analyze and summarize movie reviews. The existing implementation reads reviews from a text file, processes the content, and generates a summary. Your goal is to optimize this process by leveraging concurrency to handle multiple reviews simultaneously. # Objective Implement a function `summarize_movie_reviews` that: 1. Reads movie review data from a file asynchronously. 2. Processes each review concurrently to generate a summary. 3. Provides error handling for file access and data processing issues. # Requirements - **Input**: - `file_path`: A string representing the path to the file containing the movie reviews, where each review is separated by a blank line. - **Output**: A dictionary where each key is a unique review identifier and the value is the corresponding summary of the review. # Constraints - Use asynchronous file I/O operations. - Utilize concurrent processing to handle each individual review. - Implement robust error handling for issues such as file not found, permissions errors, and data parsing errors. - The function should handle large files efficiently. # Example Case ```python import asyncio async def summarize_movie_reviews(file_path: str) -> dict: # Your implementation here # Example usage file_path = \\"path/to/reviews.txt\\" summaries = asyncio.run(summarize_movie_reviews(file_path)) print(summaries) ``` **Expected Output**: A dictionary with review IDs as keys and their summaries as values. # Note - You may use any Python libraries for file I/O and concurrent processing. - Provide clear documentation for any assumptions and error handling strategies you implement. - Ensure the function manages memory efficiently and scales well with large data sets.","solution":"import asyncio from concurrent.futures import ProcessPoolExecutor import os def process_review(review): A mock function to process individual reviews. In a real scenario, this function would have a more complex implementation to create a summary. return review.strip().split()[0] # just a simple example to return the first word as the \'summary\' async def read_reviews(file_path): loop = asyncio.get_event_loop() with open(file_path, \'r\') as review_file: content = await loop.run_in_executor(None, review_file.read) reviews = content.strip().split(\'nn\') return reviews async def summarize_movie_reviews(file_path: str) -> dict: if not os.path.exists(file_path): raise FileNotFoundError(f\\"The file {file_path} does not exist.\\") reviews = await read_reviews(file_path) summaries = {} async with ProcessPoolExecutor() as executor: tasks = [] for i, review in enumerate(reviews): tasks.append(loop.run_in_executor(executor, process_review, review)) completed, pending = await asyncio.wait(tasks) for i, task in enumerate(completed): summaries[f\\"review_{i}\\"] = task.result() return summaries"},{"question":"# Context You are developing a system that processes large datasets of numbers and needs to efficiently find the two numbers that add up to a specific target. Your task is to implement a function that identifies these two numbers from a given list. # Problem Statement Implement a function `two_sum(nums: list[int], target: int) -> list[int]` that takes in a list of integers and a target sum. The function should return the indices of the two numbers such that they add up to the target sum. You may assume that each input has exactly one solution, and you may not use the same element twice. # Input - `nums`: A list of integers. - `target`: An integer representing the target sum. # Output - A list of two integers representing the indices of the two numbers that add up to the target. # Constraints 1. There is exactly one solution. 2. Each element in the input array may only be used once. 3. The order of the output does not matter. 4. The length of the list will be in the range [2, 10^4]. 5. The values of the integers will be in the range [-10^9, 10^9]. # Examples ```python >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1, 5, 1], 2) [0, 2] ``` # Notes - For the list [2, 7, 11, 15] with target 9, the numbers at indices 0 and 1 are 2 and 7, respectively, which add up to 9. - The solution must have a time complexity of O(n) and space complexity of O(n).","solution":"def two_sum(nums: list[int], target: int) -> list[int]: Finds the indices of the two numbers in the given list that add up to the target sum. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: list of int: A list containing the indices of the two numbers that add up to the target sum. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"# Problem Statement You are given two sparse matrices `mat1` and `mat2`, where each matrix is represented by a list of tuples. Each tuple contains three integers representing the row index, column index, and the value at that location in the matrix. Assume the matrices can have different dimensions and the row and column indices are 0-based. Write a function `add_sparse_matrices(mat1: list[tuple[int, int, int]], mat2: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]` to add these two matrices and return the result as a list of tuples. The result should be in the same format and should not contain any zero values. # Function Signature ```python def add_sparse_matrices(mat1: list[tuple[int, int, int]], mat2: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]: ``` # Input - `mat1`: A list of tuples where each tuple `(i, j, v)` represents the row index, column index, and value at that index in the sparse matrix. - `mat2`: A list of tuples with the same representation as `mat1`. # Output - Return a list of tuples where each tuple `(i, j, v)` represents the row index, column index, and value at that index in the resulting sparse matrix after addition. # Constraints - Sparse matrix dimension limits: 1 <= number of rows, number of columns <= 10^4. - There won\'t be any duplicate entries in the input matrices. - Row and column indices of both matrices are 0-based. - The value in the tuples can be negative, zero, or positive integers. # Example ```python >>> add_sparse_matrices( ... [(0, 1, 2), (1, 2, 1), (2, 0, 3)], ... [(0, 1, 3), (1, 0, 4), (2, 0, -3), (2, 1, 2)]) [(0, 1, 5), (1, 0, 4), (1, 2, 1), (2, 1, 2)] >>> add_sparse_matrices( ... [(0, 0, 1)], ... [(0, 0, -1)]) [] >>> add_sparse_matrices( ... [(0, 0, 1), (1, 2, 2)], ... [(0, 1, 3), (1, 2, -2)]) [(0, 0, 1), (0, 1, 3)] ``` # Note - Ensure to return a list of tuples sorted by row indices first and then by column indices for clarity. - Handle edge cases where the resulting matrix might be entirely zero or a mix of values including zero. - This problem assesses understanding of sparse matrix representations, efficient data structures usage, and clear implementation of matrix operations.","solution":"def add_sparse_matrices(mat1, mat2): Adds two sparse matrices represented as lists of tuples. Args: mat1: list[tuple[int, int, int]] - The first sparse matrix as a list of tuples (i, j, v). mat2: list[tuple[int, int, int]] - The second sparse matrix as a list of tuples (i, j, v). Returns: list[tuple[int, int, int]] - The resulting sparse matrix after addition. from collections import defaultdict # Use a dictionary to store the sum of values with the same (i, j) indices result_dict = defaultdict(int) # Add elements from the first matrix to the dictionary for i, j, v in mat1: result_dict[(i, j)] += v # Add elements from the second matrix to the dictionary for i, j, v in mat2: result_dict[(i, j)] += v # Generate the resulting list from the dictionary, filtering out zero values result = [(i, j, v) for (i, j), v in result_dict.items() if v != 0] # Sort the result by row and then by column result.sort(key=lambda x: (x[0], x[1])) return result"},{"question":"# Concurrent Prime Number Generator You are required to create a program that generates prime numbers up to `n` using concurrent processing. The goal is to refactor a basic prime number generator to utilize multiple processes, thereby improving computational efficiency for large values of `n`. Function Specification: Implement the function `generate_primes(n: int) -> List[int]`. This function should: 1. Divide the range from 2 to `n` into equal parts, where each part is processed by a separate worker process. 2. Each worker process should identify prime numbers in its assigned range. 3. Collect and combine the results from all worker processes to form a complete list of prime numbers up to `n`. 4. Ensure efficient inter-process communication and handle possible issues like process termination and data integrity. 5. Add logging to provide insights into the function\'s execution (process start/stop, range distribution, partial results, etc.). Input: - `n` (int): The upper limit (inclusive) for prime number generation. Output: - List[int]: A list of prime numbers up to `n`. Constraints: - 1 <= `n` <= 10^6 - The program should handle large values of `n` efficiently using multiple processes. - Handle potential issues with process management and data integrity. - Memory and CPU usage should be optimized for concurrent execution. Example Usage: ```python if __name__ == \\"__main__\\": primes = generate_primes(100) print(primes) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] ``` Notes: - Consider Python\'s `multiprocessing` module for handling multiple processes. - Ensure proper synchronization and data collection from each process. - The function should gracefully handle any process failures and ensure the main program\'s stability. - Use appropriate logging levels to monitor execution without overwhelming the log output.","solution":"import multiprocessing import logging from math import isqrt from typing import List logging.basicConfig(level=logging.INFO) def is_prime(num): if num < 2: return False for i in range(2, isqrt(num) + 1): if num % i == 0: return False return True def worker(start, end, queue): logging.info(f\\"Process started for range {start} to {end}\\") primes = [num for num in range(start, end) if is_prime(num)] queue.put(primes) logging.info(f\\"Process finished for range {start} to {end}\\") def generate_primes(n: int) -> List[int]: if n < 2: return [] num_procs = multiprocessing.cpu_count() chunk_size = (n - 1) // num_procs + 1 processes = [] queue = multiprocessing.Queue() for i in range(num_procs): start = 2 + i * chunk_size end = min(2 + (i + 1) * chunk_size, n + 1) p = multiprocessing.Process(target=worker, args=(start, end, queue)) processes.append(p) p.start() all_primes = [] for _ in range(num_procs): all_primes.extend(queue.get()) for p in processes: p.join() return sorted(all_primes)"},{"question":"# Context: A digital store inventory manager wants to design a system to help track their store\'s items\' prices and automatically identify the most expensive items in their inventory. This system should be able to handle updates to item prices efficiently and quickly return the top K most expensive items whenever requested. --- # Problem: You need to implement a class `StoreInventory` that will manage the inventory items along with their prices and provide methods to update item prices and fetch the top K highest-priced items in the inventory efficiently. # Class Definition: ```python class StoreInventory: def __init__(self): # Initializes an empty inventory pass def update_item(self, name: str, price: int) -> None: # Updates the price of the item with the given name in the inventory. # If the item does not exist, it adds the item with the given name and price. pass def top_k_expensive_items(self, k: int) -> List[Tuple[str, int]]: # Returns a list of tuples representing the top K most expensive items in sorted # order (highest price first). Each tuple contains the item name and its price. pass ``` # Constraints: - An item name contains only alphabetic characters and is unique, with a length between 1 and 50 characters. - Price of the item is a positive integer between 1 and 10^6. - There will be at most 100,000 unique items in the inventory. - The value of `k` will always be a positive integer not greater than the number of items in the inventory. # Example Usage: ```python # Initializing the inventory inventory = StoreInventory() # Update items in the inventory inventory.update_item(\\"Laptop\\", 1500) inventory.update_item(\\"Smartphone\\", 1000) inventory.update_item(\\"Headphones\\", 150) inventory.update_item(\\"Smartwatch\\", 300) inventory.update_item(\\"Tablet\\", 900) # Fetch top 3 most expensive items top_3 = inventory.top_k_expensive_items(3) # Expected Output # top_3 -> [(\\"Laptop\\", 1500), (\\"Smartphone\\", 1000), (\\"Tablet\\", 900)] ``` --- # Guidelines: 1. Implement efficient algorithms to handle updates and queries, considering potential constraints. 2. Ensure the `update_item` method performs updates or additions correctly. 3. The `top_k_expensive_items` method should be optimized for fetching the top K items quickly, especially in large inventories. --- # Note: - Utilize appropriate data structures to maintain efficiency. - Handle edge cases such as frequent price updates, items with the same name but different prices, and large inventories.","solution":"from typing import List, Tuple import heapq class StoreInventory: def __init__(self): self.items = {} def update_item(self, name: str, price: int) -> None: self.items[name] = price def top_k_expensive_items(self, k: int) -> List[Tuple[str, int]]: return heapq.nlargest(k, self.items.items(), key=lambda x: x[1])"},{"question":"# Context: You need to implement a feature in a file synchronization program to ensure that a directory\'s content is up-to-date with a source directory. The program should compare files based on their last modified timestamps and update the target directory with the newest files from the source directory. Additional functionality should include logging the synchronization process. # Task: 1. **Directory Comparison**: - Compare files in the source and target directories based on their last modified timestamps. - Copy files from the source to the target directory if they are newer or do not exist in the target directory. 2. **Logging**: - Log each synchronization event, including details about the file copied, the timestamp, and the operation performed (copy/update). # Implementation: 1. **Function Definitions**: - `compare_and_sync(source: str, target: str) -> None`: Compare and synchronize `target` directory to match `source` directory. - `log_sync_event(filename: str, operation: str, timestamp: str) -> None`: Log the synchronization event with the filename, operation type, and timestamp. 2. **Details**: - Use `os` and `shutil` libraries for file operations and comparisons. - Ensure the program handles nested directories (recursively synchronize sub-directories). - Use the `logging` library to log events. # Input & Output: - **Input**: - Source directory path. - Target directory path. - **Output**: - Logs detailing the synchronization process stored in a log file. # Constraints: - Ensure that the program handles large directories efficiently. - Only Python Standard Library modules are allowed (e.g., `os`, `shutil`, `logging`). # Example: Given the following directory structure: ``` Source Directory: - file1.txt (last modified: 2023-10-10) - file2.txt (last modified: 2023-10-12) - subdir/ - file3.txt (last modified: 2023-10-11) Target Directory: - file1.txt (last modified: 2023-10-09) - subdir/ - file3.txt (last modified: 2023-10-09) - file4.txt (last modified: 2023-10-10) ``` After synchronization, the target directory should be: ``` Target Directory: - file1.txt (copied, last modified: 2023-10-10) - file2.txt (new, last modified: 2023-10-12) - subdir/ - file3.txt (updated, last modified: 2023-10-11) - file4.txt (unchanged, last modified: 2023-10-10) ``` # Initial Code Skeleton: ```python import os import shutil import logging from datetime import datetime # Setting up logging configuration logging.basicConfig(filename=\'sync_log.log\', level=logging.INFO, format=\'%(asctime)s - %(message)s\', datefmt=\'%Y-%m-%d %H:%M:%S\') def compare_and_sync(source, target): Compare and synchronize target directory to match source directory. for root, dirs, files in os.walk(source): relative_path = os.path.relpath(root, source) target_root = os.path.join(target, relative_path) # Ensure the corresponding target directory exists if not os.path.exists(target_root): os.makedirs(target_root) for file in files: source_file = os.path.join(root, file) target_file = os.path.join(target_root, file) # Compare files if not os.path.exists(target_file) or os.path.getmtime(source_file) > os.path.getmtime(target_file): shutil.copy2(source_file, target_file) log_sync_event(file, \'copied\' if not os.path.exists(target_file) else \'updated\', datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')) def log_sync_event(filename, operation, timestamp): Log the synchronization event. logging.info(f\\"{operation}: {filename} at {timestamp}\\") def example(): source_dir = \'./source_directory\' target_dir = \'./target_directory\' compare_and_sync(source_dir, target_dir) if __name__ == \'__main__\': example() ``` **Notes**: - Ensure recursive synchronization of subdirectories. - The logging format should properly convey the synchronization actions taken and their timestamps. - Optimize to handle large numbers of files and directories efficiently.","solution":"import os import shutil import logging from datetime import datetime # Setting up logging configuration logging.basicConfig(filename=\'sync_log.log\', level=logging.INFO, format=\'%(asctime)s - %(message)s\', datefmt=\'%Y-%m-%d %H:%M:%S\') def compare_and_sync(source, target): Compare and synchronize target directory to match source directory. for root, dirs, files in os.walk(source): relative_path = os.path.relpath(root, source) target_root = os.path.join(target, relative_path) # Ensure the corresponding target directory exists if not os.path.exists(target_root): os.makedirs(target_root) for file in files: source_file = os.path.join(root, file) target_file = os.path.join(target_root, file) # Compare files if not os.path.exists(target_file) or os.path.getmtime(source_file) > os.path.getmtime(target_file): shutil.copy2(source_file, target_file) log_sync_event(file, \'copied\' if not os.path.exists(target_file) else \'updated\', datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')) def log_sync_event(filename, operation, timestamp): Log the synchronization event. logging.info(f\\"{operation}: {filename} at {timestamp}\\") def example(): source_dir = \'./source_directory\' target_dir = \'./target_directory\' compare_and_sync(source_dir, target_dir) if __name__ == \'__main__\': example()"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with developing a system that helps organize a library\'s loan records. The records include information on loan dates, return dates, and overdue computations. You are required to develop a function to help manage and automate this system. **Task**: Implement a function `calculate_overdue` that takes a list of loan records and a specific date. The function should return a list of overdue loans as of the specified date. Each record includes the following details: `loan_id`, `borrower`, `loan_date`, and `return_date`. **Function Signature**: ```python def calculate_overdue(records: list, date: str) -> list: Calculate overdue loan records as of the specified date. Args: records (list): A list of dictionaries, each containing \'loan_id\' (int), \'borrower\' (str), \'loan_date\' (str in \'YYYY-MM-DD\' format), and \'return_date\' (str in \'YYYY-MM-DD\' format, or None if not yet returned). date (str): The date in \'YYYY-MM-DD\' format to check overdue status against. Returns: list: List of overdue loan records (loan_id, borrower) as of the specified date. ``` **Example**: ```python records = [ {\'loan_id\': 1, \'borrower\': \'Alice\', \'loan_date\': \'2023-06-01\', \'return_date\': \'2023-06-10\'}, {\'loan_id\': 2, \'borrower\': \'Bob\', \'loan_date\': \'2023-05-15\', \'return_date\': \'2023-05-20\'}, {\'loan_id\': 3, \'borrower\': \'Charlie\', \'loan_date\': \'2023-07-01\', \'return_date\': None}, {\'loan_id\': 4, \'borrower\': \'Diana\', \'loan_date\': \'2023-04-20\', \'return_date\': None} ] overdue_loans = calculate_overdue(records, \'2023-06-15\') print(overdue_loans) # Output: [(3, \'Charlie\'), (4, \'Diana\')] ``` **Constraints**: 1. Assume all dates are valid and formatted correctly. 2. The function should interpret records with `return_date` of `None` as still on loan. 3. Loans are considered overdue if the `return_date` is later than the specified date or if the book has not been returned by the specified date. 4. Implement the function efficiently, ensuring it can handle a list of up to 10,000 loan records without significant performance issues. **Performance Boundaries**: - Ensure that the function can process the list within a reasonable time (e.g., within a few seconds for the maximum limit). **Additional Notes**: - Consider using Python’s standard library for date manipulation. - Properly structure and comment your code for readability and maintainability.","solution":"from datetime import datetime def calculate_overdue(records: list, date: str) -> list: Calculate overdue loan records as of the specified date. Args: records (list): A list of dictionaries, each containing \'loan_id\' (int), \'borrower\' (str), \'loan_date\' (str in \'YYYY-MM-DD\' format), and \'return_date\' (str in \'YYYY-MM-DD\' format, or None if not yet returned). date (str): The date in \'YYYY-MM-DD\' format to check overdue status against. Returns: list: List of overdue loan records (loan_id, borrower) as of the specified date. overdue = [] check_date = datetime.strptime(date, \'%Y-%m-%d\') for record in records: return_date = record[\'return_date\'] if return_date is None or datetime.strptime(return_date, \'%Y-%m-%d\') > check_date: overdue.append((record[\'loan_id\'], record[\'borrower\'])) return overdue"},{"question":"# Coding Challenge: Unique Pathways in Grid Objective: Create a function to determine the number of unique paths from the top-left corner to the bottom-right corner of a `m x n` grid, considering the constraints provided. Function Signature: ```python def unique_paths(m: int, n: int) -> int: pass ``` Input: * `m`: An integer `1 <= m <= 100` representing the number of rows in the grid. * `n`: An integer `1 <= n <= 100` representing the number of columns in the grid. Output: * An integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid. Constraints: * Movements to neighboring cells are restricted to either rightwards or downwards. * Optimized solutions are required to handle larger grids efficiently. Example: ```python assert unique_paths(3, 2) == 3 # Paths: (1,1) -> (2,1) -> (3,1) -> (3,2), (1,1) -> (1,2) -> (2,2) -> (3,2), (1,1) -> (2,1) -> (2,2) -> (3,2) assert unique_paths(7, 3) == 28 # Various paths considering only right or down moves ``` # Task Description: 1. **Factorial Calculation:** Utilize combinatoric calculations leveraging factorials, particularly combinations to determine the number of paths efficiently. 2. **Dynamic Programming:** Alternatively, implement a dynamic programming approach to iteratively calculate the number of unique paths, storing intermediate results to optimize computations. 3. **Edge Cases:** Consider minimum constraints with grids of `1x1`, `1xN`, and `Mx1`.","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. if m == 1 or n == 1: return 1 dp = [[0]*n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Image Rotation **Context:** You are developing a function for an image processing software that requires the ability to rotate images by 90 degrees clockwise. The input to this function is a 2D numpy array representing a grayscale image, and the output should be the same image rotated by 90 degrees. **Task:** Write a Python function `rotate_image` that takes a 2D numpy array representing a grayscale image and returns a new 2D numpy array of the same image rotated 90 degrees clockwise. **Function Signature:** ```python def rotate_image(image: np.ndarray) -> np.ndarray: ``` **Input:** * `image` (numpy.ndarray): A 2D array representing the grayscale image where each element is an integer from 0 to 255 (inclusive). **Output:** * A 2D numpy array with the same elements as `image`, rotated 90 degrees clockwise. **Constraints:** * The input array will always be non-empty. * The input array dimensions will not exceed 2000x2000. **Performance Requirements:** * The implementation should efficiently handle large arrays up to the maximum constraints. **Example:** ```python import numpy as np # Given grayscale image (3x3 image for example) image = np.array([ [52, 55, 61], [59, 79, 85], [51, 52, 58] ]) # Calling the function rotated_image = rotate_image(image) # Print the result print(rotated_image) ``` **Expected Output:** The output should be: ``` [[51 59 52] [52 79 55] [58 85 61]] ``` The elements of the input image have been rotated by 90 degrees clockwise in the output array.","solution":"import numpy as np def rotate_image(image: np.ndarray) -> np.ndarray: Rotates the given 2D numpy array (grayscale image) by 90 degrees clockwise. Parameters: image (numpy.ndarray): A 2D array representing the grayscale image. Returns: numpy.ndarray: The image rotated 90 degrees clockwise. return np.rot90(image, -1)"},{"question":"# Word Frequency Count Update You have been provided with a text processing function that counts the frequency of each word in a given string. However, the function currently treats \\"word\\" and \\"Word\\" as different entities and does not handle punctuation properly. Objective Enhance the existing function to accommodate the following additional requirements: 1. **Case Insensitivity**: Ensure the function counts words in a case-insensitive manner. 2. **Punctuation Handling**: Strip punctuation from words so that \\"word,\\" and \\"word\\" are counted as the same word. 3. **Empty Input Handling**: Return a meaningful error message when the input string is empty or non-string. Requirements 1. **Function Modification**: Update the function to: - Normalize case to ensure case insensitivity. - Remove punctuation from words to avoid discrepancies. - Handle empty and non-string inputs gracefully by returning an appropriate error message. 2. **Input and Output**: - **Input**: A string containing words separated by spaces. - **Output**: A dictionary with words as keys and their frequency counts as values, or a string error message if the input is invalid. 3. **Constraints**: - Ignore common punctuations such as `.,!?;:` while counting words. - Function name and parameters must remain unchanged. - Ensure efficient processing with linear time complexity relative to the length of the input string. 4. **Performance Requirements**: Maintain a controlled space complexity with respect to dictionary creation. Example Here is the sample function you need to update: ```python import string def word_frequency(text: str) -> dict: Count the frequency of each word in a given string, treating words case-insensitively and ignoring punctuation. If the input is invalid, return a meaningful error message. >>> word_frequency(\\"Hello, world! Hello...\\") {\'hello\': 2, \'world\': 1} >>> word_frequency(\\"Test, test, Test.\\") {\'test\': 3} >>> word_frequency(\\"\\") \'Invalid input: text must be a non-empty string\' >>> word_frequency(12345) \'Invalid input: text must be a non-empty string\' if not isinstance(text, str) or not text.strip(): return \'Invalid input: text must be a non-empty string\' # Remove punctuation translator = str.maketrans(\'\', \'\', string.punctuation) text = text.translate(translator) # Convert to lower case and split into words words = text.lower().split() word_count = {} for word in words: word_count[word] = word_count.get(word, 0) + 1 return word_count ``` Task Update the function to meet the enhanced specifications. Ensure all examples and edge cases are handled correctly, and the function passes the provided doctests.","solution":"import string def word_frequency(text: str) -> dict: Count the frequency of each word in a given string, treating words case-insensitively and ignoring punctuation. If the input is invalid, return a meaningful error message. >>> word_frequency(\\"Hello, world! Hello...\\") {\'hello\': 2, \'world\': 1} >>> word_frequency(\\"Test, test, Test.\\") {\'test\': 3} >>> word_frequency(\\"\\") \'Invalid input: text must be a non-empty string\' >>> word_frequency(12345) \'Invalid input: text must be a non-empty string\' if not isinstance(text, str) or not text.strip(): return \'Invalid input: text must be a non-empty string\' # Remove punctuation translator = str.maketrans(\'\', \'\', string.punctuation) text = text.translate(translator) # Convert to lower case and split into words words = text.lower().split() word_count = {} for word in words: word_count[word] = word_count.get(word, 0) + 1 return word_count"},{"question":"# Problem Statement You are given a list of non-negative integers representing the heights of buildings where the width of each building is 1 unit. Your task is to calculate the maximum amount of water that can be trapped after raining. # Function Signature ```python def trap_rain_water(heights: List[int]) -> int: pass ``` # Input - `heights` (0 <= len(heights) <= 10^5, 0 <= heights[i] <= 10^4): a list of non-negative integers representing the heights of buildings. # Output - An integer representing the maximum amount of water that can be trapped. # Example ```python trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) # Output: 6 trap_rain_water([4,2,0,3,2,5]) # Output: 9 trap_rain_water([0,0,0,0]) # Output: 0 ``` # Constraints - Consider edge cases where the list `heights` is empty or contains all zero heights. - The solution should maintain a balance of readability and efficiency in handling potentially large input sizes. # Explanation - In the first example, 6 units of water are trapped between the heights. - In the second example, water is trapped in the valleys between the buildings. - In the last example, since all heights are zero, no water can be trapped.","solution":"def trap_rain_water(heights): Calculate the maximum amount of water that can be trapped after raining. Args: heights (List[int]): A list of non-negative integers representing the heights of buildings. Returns: int: The maximum amount of water that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the water trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"# Coding Question: Task Scheduling With Dependencies **Scenario**: You are tasked with creating a system for ordering tasks that have dependencies on one another. The tasks are represented as a directed acyclic graph (DAG), where each node is a task, and each directed edge from node A to node B means task A must be completed before task B. **Requirements**: 1. Implement a function `find_task_order(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]` that returns a valid order in which the tasks can be completed. 2. If there is no valid task order due to a cyclic dependency, raise a `RuntimeError` with the message \\"Cyclic dependency detected\\". **Input**: * `tasks` - A list of task IDs (non-negative integers). * `dependencies` - A list of tuples representing dependencies, where each tuple (a, b) signifies that task `a` must be completed before task `b`. **Output**: * A list of task IDs representing a valid order of task completion. * Raises a `RuntimeError` if a cyclic dependency is detected. **Constraints**: * The number of tasks will not exceed 1000. * The number of dependencies will not exceed 5000. * Each task ID and dependency is valid and within the given task list. **Example**: ```python def find_task_order(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: # Your implementation here pass # Example use case try: order = find_task_order([1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) print(\\"Task order:\\", order) except RuntimeError as e: print(e) ``` **Hints**: * Use topological sorting algorithms such as Kahn\'s algorithm or Depth-First Search (DFS). * Employ Python\'s collections library to manage graph data structures effectively.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_task_order(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: # Build graph and in-degree count graph = defaultdict(list) in_degree = {task: 0 for task in tasks} for start, end in dependencies: graph[start].append(end) in_degree[end] += 1 # Find all starting tasks with zero in-degree queue = deque([task for task in tasks if in_degree[task] == 0]) task_order = [] while queue: current = queue.popleft() task_order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if task order size equals the number of tasks (i.e., no cycle detected) if len(task_order) != len(tasks): raise RuntimeError(\\"Cyclic dependency detected\\") return task_order"},{"question":"# Coding Question Context Sorting arrays is a fundamental task in computer science. One of the commonly used algorithms for sorting is the Merge Sort algorithm, which follows a divide-and-conquer approach to sort elements efficiently. Merge Sort works by: 1. Dividing the unsorted list into `n` sublists, each containing one element. 2. Repeatedly merging the sublists to produce new sorted sublists until there is only one sublist remaining, which will be the sorted list. In this question, you are required to implement the Merge Sort algorithm to sort a given list of integers. Tasks 1. Implement a function `merge_sort` to sort a list of integers using the Merge Sort algorithm. # Function Signature ```python def merge_sort(arr: list[int]) -> list[int]: # your code here ``` # Requirements - The function should handle edge cases such as an empty list or a list with one element gracefully. - The function should not use Python\'s built-in sort functions but must implement the Merge Sort algorithm from scratch. # Constraints - The input list can have a length between 0 and (10^4). - The elements in the list can be any integers, both positive and negative. # Example Usage ```python # Test cases for merge_sort function merge_sort([12, 11, 13, 5, 6, 7]) # should return [5, 6, 7, 11, 12, 13] merge_sort([]) # should return [] merge_sort([1]) # should return [1] merge_sort([3, 2, 1]) # should return [1, 2, 3] merge_sort([10, -1, 2, 5, 0]) # should return [-1, 0, 2, 5, 10] ``` Ensure your function handles various edge cases and provides the correct output for unsorted input lists.","solution":"def merge_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the Merge Sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: Merges two sorted lists into one sorted list. sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"Problem Statement **Context**: Imagine you are a data scientist working with time series data for weather predictions. One fundamental task is to smooth out the data to better identify trends and patterns. A commonly used technique for this is the Moving Median. Task Write a Python function `calculate_moving_median` that computes the Moving Median of a given list of observed temperatures. The function should accept a list of float values representing temperatures and an integer representing the window size. Requirements: * The function should handle empty input gracefully. * The function should raise a `ValueError` if the `window_size` is less than or equal to 0. * The result should be a list of floating-point values representing the Moving Median at each timestamp. Function Signature ```python def calculate_moving_median(temperatures: List[float], window_size: int) -> List[float]: pass ``` # Input * `temperatures`: A list of float values `[t1, t2, ..., tn]` representing temperatures. * `window_size`: An integer representing the number of periods used for calculating the Moving Median. # Output * A list of floats, where each element is the Moving Median of the temperatures calculated up to that point. # Constraints * The length of `temperatures` will be between `0` and `10^5`. * Each temperature in `temperatures` will be a float between `-100.0` and `100.0`. * The `window_size` will be a positive integer less than or equal to the length of `temperatures`. # Example ```python >>> calculate_moving_median([30.0, 25.5, 27.3, 20.1, 23.4, 26.8, 29.0], 3) [30.0, 27.75, 27.3, 25.5, 23.4, 23.4, 26.8] ``` # Note * The first few values can be computed using the available elements until the number of elements is sufficient to fill the window size. For example, the first window_size - 1 values can take median of available numbers incrementally.","solution":"from typing import List import heapq def calculate_moving_median(temperatures: List[float], window_size: int) -> List[float]: Computes the Moving Median of a given list of observed temperatures with a given window size. Parameters: temperatures (List[float]): List of temperatures. window_size (int): Window size. Returns: List[float]: List of moving median values. if window_size <= 0: raise ValueError(\\"window_size must be greater than 0\\") if len(temperatures) == 0: return [] medians = [] for i in range(len(temperatures)): # Determine the window range window = temperatures[max(0, i - window_size + 1):i + 1] # Find the median window_sorted = sorted(window) mid = len(window_sorted) // 2 if len(window_sorted) % 2 == 0: median = (window_sorted[mid - 1] + window_sorted[mid]) / 2.0 else: median = window_sorted[mid] medians.append(median) return medians"},{"question":"# Problem Statement You need to implement a function that can transform a matrix by rotating it 90 degrees clockwise or counterclockwise. Your implementation must be able to handle matrices of any size and contain any integer values. The target should be to understand matrix manipulations and two-dimensional array indexing. # Implementation Details **Function**: `rotate_matrix(matrix: list, direction: str) -> list` - **Input**: * `matrix`: A list of lists of integers representing a 2D matrix. * `direction`: A string that can be either \\"clockwise\\" or \\"counterclockwise\\", indicating the direction of rotation. - **Output**: * Returns a list of lists representing the 2D matrix rotated 90 degrees in the specified direction. - **Constraints**: * The number of rows and columns in the matrix will not exceed 100. * Each sub-list (representing a row in the matrix) will have the same number of elements. * The matrix will contain at least 1 element. * The elements of the matrix are integers. # Examples 1. **Example 1**: * Input: `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`, `direction = \\"clockwise\\"` * Output: `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]` 2. **Example 2**: * Input: `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`, `direction = \\"counterclockwise\\"` * Output: `[[3, 6, 9], [2, 5, 8], [1, 4, 7]]` 3. **Example 3**: * Input: `matrix = [[1, 2], [3, 4]]`, `direction = \\"clockwise\\"` * Output: `[[3, 1], [4, 2]]` # Function Signature You should implement the following function in Python: ```python def rotate_matrix(matrix: list, direction: str) -> list: # Your implementation here pass ``` # Hints 1. For rotating a matrix 90 degrees clockwise: * The rows of the original matrix become the columns of the new matrix, starting from the last row to the first. 2. For rotating a matrix 90 degrees counterclockwise: * The columns of the original matrix become the rows of the new matrix, from first column to the last.","solution":"def rotate_matrix(matrix: list, direction: str) -> list: n = len(matrix) m = len(matrix[0]) if direction == \'clockwise\': # For clockwise rotation return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(m)] elif direction == \'counterclockwise\': # For counterclockwise rotation return [[matrix[j][m - 1 - i] for j in range(n)] for i in range(m)] else: raise ValueError(\\"Invalid direction. Use \'clockwise\' or \'counterclockwise\'.\\")"},{"question":"# Problem Statement You have been given a list of sentences. Your task is to identify and return the longest sentence in the list. If there are multiple sentences of the same maximum length, return the one which appears first. 1. **Function to Implement** Write a function `longest_sentence(sentences: List[str]) -> str` that takes a parameter: * `sentences` (list of strings): A list containing multiple sentences. 2. **Expected Output** This function should return a single string that is the longest sentence in the list. # Constraints * 1 <= len(sentences) <= 100 * Each sentence will contain at least one word and at most 1000 characters. # Example ```python >>> longest_sentence([\\"Hello world\\", \\"A quick brown fox jumps over the lazy dog\\", \\"Goodbye\\"]) \'A quick brown fox jumps over the lazy dog\' ``` # Notes * Sentence lengths should be compared based on the number of characters. * If two sentences have the same length, return the first sentence that appears in the list with that length. * Ensure your solution is efficient and handles the maximum constraints comfortably.","solution":"from typing import List def longest_sentence(sentences: List[str]) -> str: Returns the longest sentence from the list of sentences. If there are multiple sentences with the same length, it returns the first one. if not sentences: return \\"\\" longest = sentences[0] for sentence in sentences[1:]: if len(sentence) > len(longest): longest = sentence return longest"},{"question":"```markdown # Binary Search Tree Traversal Task **Objective**: Implement a Binary Search Tree (BST) with functionalities for insertion, deletion, and various tree traversals. **Requirements**: 1. Implement the `BinarySearchTree` class that supports the following operations: - **Initialization (`__init__(self)`)**: Construct an empty Binary Search Tree. - **`insert(self, value: int)`**: Insert a value into the BST. - **`delete(self, value: int)`**: Delete a value from the BST, maintaining BST properties. - **`inorder(self) -> list`**: Return a list of elements in inorder traversal. - **`preorder(self) -> list`**: Return a list of elements in preorder traversal. - **`postorder(self) -> list`**: Return a list of elements in postorder traversal. **Inputs**: - `value`: An integer to be inserted or deleted from the tree. **Outputs**: - Traversal methods return lists of integers representing the tree elements in the specified traversal order. **Constraints**: - All operations should be implemented considering the properties of a BST. - The tree should handle duplicate values in a defined manner (e.g., ignore duplicates or handle appropriately as per your design). **Testing**: You should write test cases to verify the correctness of your implementation. Focus on cases like inserting a sequence of increasing or decreasing numbers, deleting nodes (leaf nodes, nodes with one child, and nodes with two children), and ensuring the tree structure remains valid after deletion. **Example Usage**: ```python # Initializing an empty BST bst = BinarySearchTree() # Insert elements bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(18) # Traverse the tree print(bst.inorder()) # Output: [3, 5, 7, 10, 12, 15, 18] print(bst.preorder()) # Output: [10, 5, 3, 7, 15, 12, 18] print(bst.postorder()) # Output: [3, 7, 5, 12, 18, 15, 10] # Delete elements bst.delete(10) bst.delete(5) # Traverse the tree again after deletions print(bst.inorder()) # Output: [3, 7, 12, 15, 18] print(bst.preorder()) # Output: [12, 7, 3, 15, 18] print(bst.postorder()) # Output: [3, 7, 18, 15, 12] # Continue testing as required ``` ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) elif key > node.val: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def delete(self, key): self.root = self._delete_node(self.root, key) def _delete_node(self, root, key): if root is None: return root if key < root.val: root.left = self._delete_node(root.left, key) elif key > root.val: root.right = self._delete_node(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._min_value_node(root.right) root.val = temp.val root.right = self._delete_node(root.right, temp.val) return root def _min_value_node(self, node): current = node while(current.left is not None): current = current.left return current def inorder(self): return self._inorder_traversal(self.root) def _inorder_traversal(self, root): res = [] if root: res = self._inorder_traversal(root.left) res.append(root.val) res = res + self._inorder_traversal(root.right) return res def preorder(self): return self._preorder_traversal(self.root) def _preorder_traversal(self, root): res = [] if root: res.append(root.val) res = res + self._preorder_traversal(root.left) res = res + self._preorder_traversal(root.right) return res def postorder(self): return self._postorder_traversal(self.root) def _postorder_traversal(self, root): res = [] if root: res = self._postorder_traversal(root.left) res = res + self._postorder_traversal(root.right) res.append(root.val) return res"},{"question":"# Coding Assessment Question Scenario You are participating in a game development project that involves generating various types of game levels procedurally. One of the game level generation requirements is to create a sequence representing a zigzag pattern. The sequence should follow a specific pattern moving up and then down incrementally by 1. Task Implement a function `generate_zigzag(n: int) -> List[int]` that produces a list representing the first `n` elements of the zigzag sequence. Requirements * **Input**: An integer `n` (1 ≤ n ≤ 100) * **Output**: A list of integers representing the zigzag pattern up to the nth element. Pattern * The zigzag sequence starts at 1 and alternates between ascending and descending by 1. * For example, for `n = 7`, the sequence would look like this: `[1, 2, 1, 2, 3, 2, 1]`. Constraints * Ensure the input value `n` is a positive integer within the specified range. * Validate the input to handle cases where `n` is not within the specified range or is not a positive integer. Example ```python generate_zigzag(1) # Output: [1] generate_zigzag(5) # Output: [1, 2, 1, 2, 3] generate_zigzag(7) # Output: [1, 2, 1, 2, 3, 2, 1] ``` Notes * Consider using a loop to generate the sequence. * Make sure the function handles edge cases gracefully. ```python def generate_zigzag(n: int) -> List[int]: if not isinstance(n, int) or n < 1 or n > 100: raise ValueError(\\"Input must be an integer between 1 and 100\\") zigzag = [] up = True current = 1 for _ in range(n): zigzag.append(current) if up: current += 1 else: current -= 1 if current == 1: up = True elif up and (len(zigzag) == 1 or zigzag[-2] == current - 2): up = False return zigzag ```","solution":"def generate_zigzag(n: int) -> list: if not isinstance(n, int) or n < 1 or n > 100: raise ValueError(\\"Input must be an integer between 1 and 100\\") zigzag = [] current = 1 up = True for i in range(n): zigzag.append(current) if up: current += 1 else: current -= 1 if current == 1: up = True elif current == max(zigzag) + 1: up = False return zigzag"},{"question":"# Problem: Median of Two Sorted Arrays You are designing a function for combining the sorted data from two sensors. Each sensor provides a sorted list of integers representing temperature readings. Your goal is to find the median temperature from the combined data of these two sensors. Problem Statement Given two lists of integers `nums1` and `nums2`, both of which are sorted in non-decreasing order, write a function that finds the median of the two sorted arrays. The overall run-time complexity should be (mathcal{O}(log(min(n, m)))), where (n) and (m) are the lengths of the two arrays. Ensure that your implementation properly handles the following: - Merging the arrays efficiently without combining them directly. - The median is defined as the middle element of the combined array if it is odd-length, and the average of the two middle elements if it is even-length. Implement the function `find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float`: * **Input**: Two sorted lists of integers, `nums1` and `nums2`. * **Output**: A float representing the median of the combined sorted array from `nums1` and `nums2`. Constraints * Each list has length between `0` and `10^6`. * Each entry in the lists is an integer such that (-10^6 leq text{entry} leq 10^6). * No built-in functions for finding the median or merging directly are allowed. Example ```python >>> find_median_sorted_arrays([1, 3], [2]) 2.0 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 >>> find_median_sorted_arrays([], [1]) 1.0 ``` Guidelines * **Edge Cases**: Consider cases where one or both lists are empty. * **Performance**: Focus on achieving the desired time complexity. * **Algorithm**: Utilize binary search to partition the lists and find the median efficiently.","solution":"def find_median_sorted_arrays(nums1, nums2): Finds the median of two sorted arrays `nums1` and `nums2`. The overall time complexity should be O(log(min(n, m))). if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 x, y = len(nums1), len(nums2) low, high = 0, x while low <= high: partitionX = (low + high) // 2 partitionY = (x + y + 1) // 2 - partitionX maxX = float(\'-inf\') if partitionX == 0 else nums1[partitionX - 1] minX = float(\'inf\') if partitionX == x else nums1[partitionX] maxY = float(\'-inf\') if partitionY == 0 else nums2[partitionY - 1] minY = float(\'inf\') if partitionY == y else nums2[partitionY] if maxX <= minY and maxY <= minX: if (x + y) % 2 == 0: return (max(maxX, maxY) + min(minX, minY)) / 2.0 else: return max(maxX, maxY) elif maxX > minY: high = partitionX - 1 else: low = partitionX + 1 raise ValueError(\\"Input arrays are not sorted.\\")"},{"question":"# Coding Assessment Question Scenario Your task is to work on a module for analyzing image color histograms. Given a grayscale image represented as a 2D list of integers, you need to implement a function that calculates and returns the histogram of pixel intensities. Objectives Your task is to implement a function that generates a histogram by counting the occurrences of each pixel intensity value in the image. Function Signature ```python def calculate_histogram(image: list[list[int]]) -> list[int]: pass ``` Input * A 2D list `image` where each element is an integer between 0 and 255 inclusive, representing pixel intensities in a grayscale image. Output * A list of 256 integers, where the i-th element corresponds to the number of pixels in the image with intensity i. Constraints * The input 2D list will have dimensions 1 ≤ len(image) ≤ 1000 and 1 ≤ len(image[i]) ≤ 1000 for all 0 ≤ i < len(image). * Each integer in the list will be between 0 and 255 inclusive. Performance Requirements * The function should run in O(n*m) time complexity, where n is the number of rows and m is the number of columns in the image. Example ```python >>> image = [ ... [0, 255, 127, 127], ... [0, 127, 127, 0], ... [255, 0, 0, 255], ... [127, 127, 0, 0] ... ] >>> calculate_histogram(image) [7, 0, 0, ..., 0, 0, 4] # length of the list is 256 ``` Instructions 1. Iterate through each pixel in the image to compute the histogram. 2. Ensure the function adheres to the specified input/output formats. 3. Do not import any additional libraries. Use only standard libraries available in Python. 4. Consider edge cases, such as when the image is uniform (all pixels have the same intensity). Notes * The output list should contain 256 integers, representing the counts of pixel intensity values from 0 to 255. * Maintain consistent and efficient coding practices for optimal performance.","solution":"def calculate_histogram(image: list[list[int]]) -> list[int]: Calculate the histogram of pixel intensities for a given grayscale image. :param image: 2D list of integers where each integer is between 0 and 255 inclusive :return: List of 256 integers representing the histogram of pixel intensities histogram = [0] * 256 for row in image: for pixel in row: histogram[pixel] += 1 return histogram"},{"question":"# Palindromic Substring Analysis Given a string, we want to find the longest palindromic substring within it. Your task is to implement the following functions: 1. **`longest_palindromic_substring(s: str) -> str`**: This function should return the longest palindromic substring within the input string `s`. 2. **`all_palindromic_substrings(s: str) -> list[str]`**: This function should return a list of all distinct palindromic substrings in the input string `s`. 3. **`palindromic_substring_counts(s: str) -> dict[str, int]`**: This function should return a dictionary where the keys are palindromic substrings found in `s`, and the values are the number of times each substring appears in `s`. # Requirements - **Input Format**: - `s`: A string containing the text to be analyzed. - **Output Format**: - For `longest_palindromic_substring`: A string that is the longest palindromic substring in `s`. - For `all_palindromic_substrings`: A list of distinct palindromic substrings in `s` sorted by length from longest to shortest. If multiple substrings have the same length, they should be sorted lexicographically. - For `palindromic_substring_counts`: A dictionary mapping each palindromic substring to the number of occurrences in `s`. - **Constraints**: - The input string `s` will have a length of up to 1,000 characters and will contain only ASCII characters. - **Performance**: - Optimize for efficiency in finding and counting palindromic substrings. # Example ```python # Given the string \\"babad\\" s = \\"babad\\" # Expected output for longest_palindromic_substring \\"bab\\" # or \\"aba\\" # Expected output for all_palindromic_substrings [\'bab\', \'aba\', \'b\', \'a\', \'d\'] # Expected output for palindromic_substring_counts { \'bab\': 1, \'aba\': 1, \'b\': 2, \'a\': 2, \'d\': 1 } ``` Implement the specified functions ensuring correctness and optimal performance.","solution":"def longest_palindromic_substring(s: str) -> str: n = len(s) if n == 0: return \\"\\" start, max_length = 0, 1 for i in range(n): if i - max_length >= 1 and s[i - max_length - 1:i + 1] == s[i - max_length - 1:i + 1][::-1]: start = i - max_length - 1 max_length += 2 elif i - max_length >= 0 and s[i - max_length:i + 1] == s[i - max_length:i + 1][::-1]: start = i - max_length max_length += 1 return s[start:start + max_length] def all_palindromic_substrings(s: str) -> list: n = len(s) palindromes = set() for i in range(n): for j in range(i, n): substring = s[i:j + 1] if substring == substring[::-1]: palindromes.add(substring) return sorted(palindromes, key=lambda x: (-len(x), x)) def palindromic_substring_counts(s: str) -> dict: n = len(s) palindrome_counts = {} for i in range(n): for j in range(i, n): substring = s[i:j + 1] if substring == substring[::-1]: if substring in palindrome_counts: palindrome_counts[substring] += 1 else: palindrome_counts[substring] = 1 return palindrome_counts"},{"question":"# Coding Assessment Question As a software engineer at a company that maintains historical weather data, you are required to improve the current system to provide enhanced weather insights. Your task involves fetching data from an archival weather API and performing various operations to ensure data accuracy and increased functionality. Your tasks are: 1. **Develop a function to fetch and display weather details from an archival API.** - Use the endpoint \\"https://archive-weather-api.com/data\\" to retrieve JSON data. - Format and display the weather details including temperature, humidity, and precipitation. 2. **Implement comprehensive error handling:** - Add mechanisms to manage network issues, API errors, and discrepancies in the data structure. - Ensure that retries are performed for failed requests up to a specified limit and appropriate logs are saved for error instances. 3. **Extend data features:** - Modify the `display_weather` function to include historical trends: average temperature changes over the past ten years. - Account for missing data for certain years, ensuring the display remains coherent. 4. **Optimize date processing functions:** - Improve the function that calculates days between dates, considering edge cases such as leap years, month-end boundaries, and different date formats. **Input:** - An integer representing the retry limit for failed network requests. **Output:** - A formatted report showing the weather details along with the average temperature trends over the past ten years. **Constraints:** - The archival API endpoint returns data in JSON format with weather details. - Ensure to handle up to 3 retries for failed network requests to ensure robust data fetching. - The date data will be provided in various commonly used formats and should be parsed correctly. **Scenario Context:** Consider a weather forecasting firm that intends to switch from using its current data provider to a new archival data API while maintaining uninterrupted and reliable weather insight services to its customers. The company needs to ensure the new system is as robust and informative as the previous one, especially in displaying historical temperature trends accurately.","solution":"import requests import json import logging from datetime import datetime from dateutil.parser import parse as parse_date from statistics import mean from time import sleep # Setup logging logging.basicConfig(level=logging.INFO) def fetch_weather_data(retry_limit=3, url=\\"https://archive-weather-api.com/data\\"): retries = 0 while retries < retry_limit: try: response = requests.get(url) response.raise_for_status() # This will raise an HTTPError for bad responses return response.json() except requests.exceptions.RequestException as e: logging.error(f\\"Error fetching data: {e}\\") retries += 1 sleep(1) raise Exception(\\"Failed to fetch data after multiple retries.\\") def display_weather(retry_limit=3): weather_data = fetch_weather_data(retry_limit) # Extract and display weather details weather_details = { \\"temperature\\": weather_data.get(\\"temperature\\"), \\"humidity\\": weather_data.get(\\"humidity\\"), \\"precipitation\\": weather_data.get(\\"precipitation\\") } print(\\"Weather Details:\\") print(f\\"Temperature: {weather_details[\'temperature\']}°C\\") print(f\\"Humidity: {weather_details[\'humidity\']}%\\") print(f\\"Precipitation: {weather_details[\'precipitation\']}mm\\") # Historical Temperature Trends temperature_data = weather_data.get(\\"historical_temperatures\\", []) if temperature_data: calculate_and_display_trends(temperature_data) def calculate_and_display_trends(temp_data): current_year = datetime.now().year temps_by_year = {} for entry in temp_data: year = parse_date(entry[\\"date\\"]).year if year <= current_year and year >= current_year - 10: if year not in temps_by_year: temps_by_year[year] = [] temps_by_year[year].append(entry[\\"temperature\\"]) trends = [] for year in range(current_year - 10, current_year + 1): if year in temps_by_year: trends.append((year, mean(temps_by_year[year]))) else: trends.append((year, None)) print(\\"nHistorical Temperature Trends (last 10 years):\\") for year, avg_temp in trends: if avg_temp is not None: print(f\\"Year {year}: {avg_temp:.2f}°C\\") else: print(f\\"Year {year}: No data available\\") def days_between_dates(date1, date2): d1 = parse_date(date1) d2 = parse_date(date2) return abs((d2 - d1).days)"},{"question":"# Challenging Coding Assessment Question Context Sorting algorithms are fundamental in computer science, with various methods optimized for different scenarios and constraints. One interesting variant is the \\"zigzag sort\\" where the array elements are arranged in a wave-like pattern such that `array[0] <= array[1] >= array[2] <= array[3] >= ...`. Task Implement a function `zigzag_sort(arr: List[int]) -> List[int]` that reorders the input list into a zigzag manner. Use the following guidelines and constraints to optimize the solution: Input and Output Formats: ```python def zigzag_sort(arr: List[int]) -> List[int]: pass # Example usage: print(zigzag_sort([4, 3, 7, 8, 6, 2, 1])) # Output: [3, 7, 4, 8, 2, 6, 1] print(zigzag_sort([1, 4, 3, 2])) # Output: [1, 4, 2, 3] ``` Constraints: * The input list, `arr`, contains between 2 and 10^4 integers. * Each integer in the list is within the range `[-10^6, 10^6]`. Requirements: 1. **In-place Sorting:** Optimize for an in-place sorting algorithm to achieve O(1) additional space complexity. 2. **Performance Efficiency:** Ensure the implementation runs with a time complexity of O(n) where n is the number of elements in the input list. 3. **Ensure Correctness:** The function should handle minimal, maximal, and typical cases maintaining the zigzag property. Implementation Goals: * A simple, yet effective approach to swap adjacent elements without needing additional memory. * Consider edge cases, such as already sorted or inversely sorted arrays, and handle them appropriately. * Aim for readability and efficiency in the code. Implement the `zigzag_sort` function, ensuring it adheres to the above specifications and performs optimally for all given constraints.","solution":"from typing import List def zigzag_sort(arr: List[int]) -> List[int]: Reorders the input list into a zigzag manner such that arr[0] <= arr[1] >= arr[2] <= arr[3] >= ... n = len(arr) for i in range(n-1): if (i % 2 == 0 and arr[i] > arr[i+1]) or (i % 2 == 1 and arr[i] < arr[i+1]): arr[i], arr[i+1] = arr[i+1], arr[i] return arr"},{"question":"# Coding Assessment Question # Objective Your task is to implement a function that finds the first non-repeating character in a string. This problem tests your ability to effectively use data structures to solve search problems in strings. # Problem Statement Implement the function `first_non_repeating_character(s: str) -> str`. Your function should find the first character in the string that does not repeat and return it. If all characters repeat or the string is empty, return an empty string. # Function Signature ```python def first_non_repeating_character(s: str) -> str: ``` # Input - `s`: A string with a length between (0 leq text{len}(s) leq 10^5). The string can include any printable characters. # Output - Return the first non-repeating character in the given string. If there is no non-repeating character, return an empty string. # Examples ```python assert first_non_repeating_character(\\"stress\\") == \\"t\\" assert first_non_repeating_character(\\"loveleetcode\\") == \\"v\\" assert first_non_repeating_character(\\"aabbcc\\") == \\"\\" assert first_non_repeating_character(\\"a\\") == \\"a\\" assert first_non_repeating_character(\\"\\") == \\"\\" ``` # Constraints - Your solution should handle the string efficiently in terms of both time and space complexity. - Consider edge cases such as strings with no non-repeating characters, single-character strings, and empty strings. # Note - Optimize for the best possible performance given the input constraints. Intermediate data structures like dictionaries can be utilized to track character counts and positions effectively.","solution":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the given string. If no such character exists, returns an empty string. # Dictionary to store counts of each character char_count = {} # Populate the dictionary with character counts for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return an empty string return \\"\\""},{"question":"# Scenario A networking company is developing a new protocol to optimize data packet delivery in a distributed system. They have presented a unique challenge regarding the calculation of optimal time for packet distribution given the current network configuration. Your task is to write a function that computes the minimum time required to deliver data packets from a source node to all other nodes in the network. # Objective Write a function `min_delivery_time` that determines the minimum time required to deliver data from a source node to all other nodes in a weighted, undirected graph representing the network. # Specification **Function Signature**: ```python def min_delivery_time(n: int, edges: List[Tuple[int, int, int]], src: int) -> int: pass ``` **Inputs**: * `n` (int): The number of nodes in the network, indexed from 0 to `n-1`. * `edges` (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers `u`, `v`, and `w` representing an edge between nodes `u` and `v` with weight `w`. * `src` (int): The starting node (source) for the packet delivery. **Output**: * Returns an integer representing the minimum time required to deliver data from the source node to all other nodes. If it\'s not possible to reach all nodes, return -1. # Constraints: * `1 <= n <= 100` * `1 <= len(edges) <= 1000` * `0 <= u, v < n` * `1 <= w <= 100` * The network may contain cycles, but no negative weight cycles. # Example Usage: ```python print(min_delivery_time(5, [(0, 1, 2), (0, 2, 4), (1, 3, 1), (2, 3, 3), (3, 4, 5)], 0)) # Expected Output: 8 print(min_delivery_time(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1)], 0)) # Expected Output: 3 print(min_delivery_time(4, [(0, 1, 1), (1, 2, 2)], 0)) # Expected Output: -1 (node 3 is not reachable) print(min_delivery_time(1, [], 0)) # Expected Output: 0 ``` # Notes: - Use efficient algorithms for shortest path calculation, such as Dijkstra\'s algorithm. - Carefully handle graphs where some nodes might not be reachable from the source. - Consider edge cases, such as networks with only one node or disconnected components.","solution":"import heapq from typing import List, Tuple def min_delivery_time(n: int, edges: List[Tuple[int, int, int]], src: int) -> int: Determines the minimum time required to deliver data from a source node to all other nodes in a weighted, undirected graph. Parameters: n (int): Number of nodes in the network edges (List[Tuple[int, int, int]]): List of edges in the network src (int): Source node Returns: int: Minimum time required to reach all nodes from the source node, or -1 if not all nodes can be reached # Create adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra\'s algorithm to find shortest paths from src min_heap = [(0, src)] distances = {i: float(\'inf\') for i in range(n)} distances[src] = 0 while min_heap: current_distance, node = heapq.heappop(min_heap) if current_distance > distances[node]: continue for neighbor, weight in graph[node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) # Check if there is any node that is unreachable max_distance = max(distances.values()) return max_distance if max_distance != float(\'inf\') else -1"},{"question":"# Problem Statement You are tasked with developing a function that extracts the most frequent numbers from a given list of integers. If multiple numbers have the same highest frequency, return all of them in ascending order. # Task Implement the function `most_frequent_numbers(numbers: List[int]) -> List[int]` where: * `numbers`: A list of integers for which you need to find the most frequent elements. Input * `numbers` (1 ≤ len(numbers) ≤ 10^5, -10^5 ≤ numbers[i] ≤ 10^5): the list of integers. Output * Return a list of integers with the most frequent numbers in ascending order. # Example ```python most_frequent_numbers([4, 1, 2, 2, 3, 4, 4, 1]) # Output: [4] most_frequent_numbers([1, 1, 2, 2, 3, 3]) # Output: [1, 2, 3] ``` Explanation For the first example: 1. The list `[4, 1, 2, 2, 3, 4, 4, 1]` has frequencies: {4: 3, 1: 2, 2: 2, 3: 1}. 2. The most frequent number is `4`. For the second example: 1. The list `[1, 1, 2, 2, 3, 3]` has equal frequencies for `1`, `2`, and `3`. 2. All numbers `1`, `2`, and `3` are the most frequent, so they are returned in ascending order. # Constraints * Ensure your solution handles large input sizes efficiently within time limits. * Validate to handle edge cases where the list may contain negative values. * The solution should operate within a reasonable time complexity for large input sizes.","solution":"from typing import List from collections import Counter def most_frequent_numbers(numbers: List[int]) -> List[int]: Returns the most frequent numbers from the given list in ascending order. if not numbers: return [] # Count the frequency of each number frequency = Counter(numbers) # Find the highest frequency max_frequency = max(frequency.values()) # Collect all numbers with the highest frequency most_frequent = [num for num, freq in frequency.items() if freq == max_frequency] # Sort the result in ascending order return sorted(most_frequent)"},{"question":"# Navigation Path Finder You have been hired to create a navigation system for a futuristic city where people use hovercrafts to move around on a grid. In this city, the hovercrafts can only move right or down. Additionally, certain grid cells may be blocked, and hovercrafts cannot pass through them. Given these constraints, your task is to determine the number of distinct paths from the top-left corner of the grid to the bottom-right corner. Write a function `count_paths(grid: List[List[int]]) -> int` that takes a 2D grid of integers as input and returns the number of distinct paths from the top-left to the bottom-right corner. # Input - `grid` (List[List[int]]) - a 2D list representing the grid, where `0` indicates an open cell and `1` indicates a blocked cell. - The grid will be of size `m x n` (1 ≤ m, n ≤ 100). # Output - The function should return an integer representing the number of distinct paths from the top-left to the bottom-right corner. # Examples ```python >>> count_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> count_paths([[0, 1], [0, 0]]) 1 >>> count_paths([[0, 0], [1, 0]]) 1 >>> count_paths([[1, 0], [0, 0]]) 0 ``` # Guidelines - Avoid paths that go through blocked cells. - Use dynamic programming to build the solution from the base cases and handle overlapping subproblems. - Consider edge cases where the starting or ending cells might be blocked, resulting in zero paths. # Constraints - The grid can have up to 10,000 cells in total. - Large grids may contain many blocked cells (1).","solution":"def count_paths(grid): Calculates the number of distinct paths from the top-left to the bottom-right corner of the grid. A cell with 0 indicates an open cell, and a cell with 1 indicates a blocked cell. Hovercrafts can only move right or down. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Coding Assessment Question **Scenario:** A robotics company is developing an algorithm to navigate its robots through a grid-based environment. The robot can move in four directions (up, down, left, right) and needs to find the shortest path from a starting point to a target point while avoiding obstacles. You are tasked with implementing a pathfinding algorithm using Breadth-First Search (BFS) to find the shortest path in the grid. **Task:** Implement the BFS algorithm for finding the shortest path on a grid following the given steps: 1. **Initialize the grid** with given dimensions and obstacles. 2. **Perform BFS** to find the shortest path from the start to the target. # Requirements: 1. **Function 1:** `initialize_grid(rows: int, cols: int, obstacles: list[tuple[int, int]]) -> list[list[int]]` - Takes the grid dimensions (`rows` and `cols`) and a list of obstacle coordinates. - Returns the initialized grid with `0` for empty spaces and `1` for obstacles. 2. **Function 2:** `bfs_pathfinding(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> list[tuple[int, int]]` - Takes the grid, a start coordinate, and a target coordinate. - Returns the list of coordinates representing the shortest path from start to target. # Input: - **`rows`**: An integer representing the number of rows in the grid (e.g., 5). - **`cols`**: An integer representing the number of columns in the grid (e.g., 5). - **`obstacles`**: A list of tuples representing the coordinates of obstacles (e.g., [(1, 1), (3, 2)]). - **`start`**: A tuple representing the starting coordinate (e.g., (0, 0)). - **`target`**: A tuple representing the target coordinate (e.g., (4, 4)). # Output: - **From `initialize_grid`**: A 2D list representing the initialized grid. - **From `bfs_pathfinding`**: A list of tuples for the coordinates of the shortest path. # Constraints: - Grid dimensions and coordinates are non-negative integers. - Coordinates for the start and target points are valid grid positions. - Obstacles do not overlap with the start or target points. # Example: ```python rows = 5 cols = 5 obstacles = [(1, 1), (3, 2), (3, 3)] start = (0, 0) target = (4, 4) grid = initialize_grid(rows, cols, obstacles) path = bfs_pathfinding(grid, start, target) print(path) ``` **Output:** ``` [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)] ``` **Edge Cases to Consider:** 1. The start and target points are the same. 2. No available path due to obstacles. --- This new question maintains consistency with the provided sample by focusing on a commonly used algorithm (BFS), requiring both understanding and implementation of the algorithm concept. It ensures similar complexity by having the candidate initialize a grid and navigate it, comparable to building and traversing a matrix in the original question.","solution":"from collections import deque def initialize_grid(rows: int, cols: int, obstacles: list[tuple[int, int]]) -> list[list[int]]: Initializes a grid with given dimensions and obstacles. grid = [[0 for _ in range(cols)] for _ in range(rows)] for (r, c) in obstacles: grid[r][c] = 1 return grid def bfs_pathfinding(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> list[tuple[int, int]]: Finds the shortest path from start to target avoiding obstacles using BFS. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: (current, path) = queue.popleft() if current == target: return path for dr, dc in directions: nr, nc = current[0] + dr, current[1] + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append(((nr, nc), path + [(nr, nc)])) visited.add((nr, nc)) return [] # No path found"},{"question":"# Coding Assessment Question Scenario & Context You are given a grid representing a city map where some cells are land and others are water. A valid city block is formed on contiguous lands (vertically and horizontally connected). For city planning, you are required to count the number of such distinct city blocks. Problem Statement Write a function `count_city_blocks` to count the number of distinct city blocks (connected groups of land cells). Function Signature ```python def count_city_blocks(grid: List[List[int]]) -> int: pass ``` Input * `grid` (List of Lists of Integers): A 2D grid where `1` represents land and `0` represents water. Output * Return an integer representing the number of distinct city blocks. Constraints * `1 ≤ len(grid) ≤ 1000` * `1 ≤ len(grid[0]) ≤ 1000` Examples ```python >>> grid = [ ... [1, 0, 0, 1], ... [1, 1, 0, 0], ... [0, 0, 1, 1], ... [0, 1, 1, 1] ... ] >>> count_city_blocks(grid) 3 >>> grid = [ ... [1, 1, 0, 0], ... [1, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1] ... ] >>> count_city_blocks(grid) 3 >>> grid = [ ... [0, 0, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 1, 0], ... [1, 0, 0, 0] ... ] >>> count_city_blocks(grid) 4 ``` Notes * You can use Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse and mark visited lands. * Make sure your solution scales well to the highest constraints. **Performance Requirement**: Your solution should have a complexity near O(m * n), where m is the number of rows and n is the number of columns in the grid.","solution":"def count_city_blocks(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # mark as visited dfs(i+1, j) # check down dfs(i-1, j) # check up dfs(i, j+1) # check right dfs(i, j-1) # check left city_blocks = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) city_blocks += 1 return city_blocks"},{"question":"# Scenario You are organizing a coding bootcamp where participants must complete several exercises throughout the week. Each exercise has a specific difficulty level, and participants can only complete exercises if their ability level is greater than or equal to that of the exercise. Participants can improve their abilities by attending special training sessions, each of which increases their ability by a certain amount. # Task Write a function `max_exercises_completed(abilities: list[int], exercises: list[int], trainings: list[int]) -> int` that determines the maximum number of exercises that the participants can collectively complete given their current abilities and the training sessions available. 1. `abilities`: A list of integers representing the current ability levels of the participants. 2. `exercises`: A list of integers representing the difficulty levels of the exercises. 3. `trainings`: A list of integers, where each integer represents the increase in ability a participant gains after attending that training session. # Input * `abilities` (list of integers): Current ability levels of the participants. * `exercises` (list of integers): Difficulty levels of the exercises. * `trainings` (list of integers): Increases in ability levels from attending training sessions. # Output * An integer representing the maximum number of exercises that can be completed by all participants combined. # Constraints 1. `abilities`, `exercises`, and `trainings` will all be non-empty lists. 2. Each participant can attend at most one training session. 3. The lists `abilities`, `exercises`, and `trainings` will contain positive integers. # Performance Requirements Your solution should aim for a time complexity of O(n log n) and a space complexity of O(n), where n is the maximum length of the input lists. # Examples ```python >>> max_exercises_completed([3, 1, 4], [2, 4, 3], [1, 2]) 3 >>> max_exercises_completed([2, 5], [4, 3, 1], [1, 1, 3]) 2 ``` # Note Ensure to handle erroneous inputs such as non-integer values or negative integers appropriately by raising a `ValueError`.","solution":"def max_exercises_completed(abilities: list[int], exercises: list[int], trainings: list[int]) -> int: Determines the maximum number of exercises that participants can complete given their current abilities, the difficulty of exercises, and available trainings to improve their abilities. if not all(isinstance(x, int) and x > 0 for x in abilities + exercises + trainings): raise ValueError(\\"All inputs must be non-negative integers\\") abilities.sort() exercises.sort() trainings.sort() num_exercises_completed = 0 for exercise in exercises: # Find the participant with the minimum ability needed to complete the exercise participant_index = next( (i for i, ability in enumerate(abilities) if ability + (trainings[0] if trainings else 0) >= exercise), len(abilities)) if participant_index < len(abilities): if abilities[participant_index] >= exercise: num_exercises_completed += 1 abilities.pop(participant_index) # Remove participant as they can only do one exercise elif trainings: abilities[participant_index] += trainings.pop(0) # Apply the best training if abilities[participant_index] >= exercise: num_exercises_completed += 1 abilities.pop(participant_index) # Remove participant return num_exercises_completed"},{"question":"# Factorial Function with Memoization **Objective**: Implement a function to compute the factorial of a non-negative integer using memoization to optimize for repeated calls. Function Signature ```python def factorial(n: int, memo: dict = None) -> int: ``` Input * `n` (int): The non-negative integer for which the factorial needs to be computed. * `memo` (dict): A dictionary to store previously computed factorial values for memoization (optional). Output * An integer representing the factorial of the input value. Constraints * The function should raise a `ValueError` for negative inputs. * Ensure proper handling and initialization of the memoization dictionary to retain values across function calls. * Handle edge cases appropriately (e.g., (0! = 1)). Example Usage: ```python >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(5, {0: 1, 1: 1}) # Using an existing memo dictionary 120 ``` # Additional Requirements * Include documentation with example cases. * Validate input types ensuring `n` is a non-negative integer. * Utilize memoization to provide faster results for repeated or recursive calls. # Context Factorials are fundamental in combinatorial mathematics, permutations, and statistical calculations. Using memoization improves efficiency, especially when repeatedly calculating factorials in recursive algorithms or dynamic programming solutions. This task assesses understanding of recursion, memoization, and the handling of function parameters.","solution":"def factorial(n: int, memo: dict = None) -> int: Computes the factorial of a non-negative integer using memoization. Args: n (int): The non-negative integer for which the factorial needs to be computed. memo (dict, optional): A dictionary to store previously computed factorial values for memoization. Returns: int: The factorial of the input value. Raises: ValueError: If the input integer is negative. Examples: >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(5, {0: 1, 1: 1}) 120 if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if memo is None: memo = {} if n in memo: return memo[n] if n == 0: memo[n] = 1 else: memo[n] = n * factorial(n - 1, memo) return memo[n]"},{"question":"# Coding Assessment Question **Context:** You are required to manipulate strings to create palindrome structures. A palindrome is a word, phrase, number, or other sequence of characters that reads the same backward as forward. **Problem Statement:** Write a function `longest_palindromic_subsequence(s: str) -> int` that takes a string `s` and returns the length of the longest palindromic subsequence in `s`. **Input:** - A string `s` where `1 ≤ len(s) ≤ 1000`. **Output:** - The length of the longest palindromic subsequence in the input string. **Constraints:** - The input string will consist of lowercase and uppercase English letters only. - The function should run efficiently within reasonable time limits for the given input bounds. # Function Signature ```python def longest_palindromic_subsequence(s: str) -> int: pass ``` # Examples ```python # Example 1: print(longest_palindromic_subsequence(\\"bbbab\\")) # Output: 4 # Explanation: One possible longest palindromic subsequence is \\"bbbb\\". # Example 2: print(longest_palindromic_subsequence(\\"cbbd\\")) # Output: 2 # Explanation: One possible longest palindromic subsequence is \\"bb\\". ``` --- This new question mirrors the style, complexity, and scope of combined combinatorics and sequence-related questions, ensuring it integrates seamlessly with the preceding set.","solution":"def longest_palindromic_subsequence(s: str) -> int: Computes the length of the longest palindromic subsequence in the given string. Args: s (str): The input string. Returns: int: The length of the longest palindromic subsequence. n = len(s) # dp[i][j] will be storing the length of the longest palindromic subsequence # of s[i:j+1] dp = [[0 for _ in range(n)] for _ in range(n)] # Strings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Build the table. The bottom-up approach is adopted here. for cl in range(2, n+1): # cl is the length of substring for i in range(n-cl+1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1]"},{"question":"# Generate All Permutations of a String You are working on a feature for a text editing application that generates all permutations of a given string. Your task is to implement a function that returns all possible permutations of a provided string in lexicographically sorted order. Function Signature ```python def generate_permutations(s: str) -> List[str]: This function computes all the permutations of the input string sorted in lexicographically order. :param s: A string for which permutations are to be generated. :return: A list of strings containing all permutations of the input string, sorted in lexicographical order. ``` Input 1. **s**: A string consisting of alphanumeric characters. Output * A list of strings where each string is a unique permutation of the input string, sorted in lexicographic order. Constraints * The input string can have a maximum length of 8 characters. * The input string may contain duplicate characters. Example ```python # Example usage assert generate_permutations(\\"ABC\\") == [\\"ABC\\", \\"ACB\\", \\"BAC\\", \\"BCA\\", \\"CAB\\", \\"CBA\\"] assert generate_permutations(\\"AAB\\") == [\\"AAB\\", \\"ABA\\", \\"BAA\\"] assert generate_permutations(\\"AB\\") == [\\"AB\\", \\"BA\\"] ``` Notes * You may use Python\'s built-in functions to generate permutations but ensure the result is sorted lexicographically. * Handle strings with duplicate characters appropriately to avoid redundant permutations. * Optimize for both time and space efficiency. * Ensure that special cases, such as an empty string or a single character string, are correctly managed.","solution":"from typing import List import itertools def generate_permutations(s: str) -> List[str]: This function computes all the permutations of the input string sorted in lexicographical order. :param s: A string for which permutations are to be generated. :return: A list of strings containing all permutations of the input string, sorted in lexicographical order. if not s: return [] permutations = set(itertools.permutations(s)) sorted_permutations = sorted([\'\'.join(p) for p in permutations]) return sorted_permutations"},{"question":"# Array Pair Sum Check In this challenge, you will implement a function that checks whether there exists a pair of distinct elements in an array whose sum is equal to a given target value. If such a pair exists, return True; otherwise, return False. # Requirements 1. Implement a function `has_pair_with_sum(arr: list[int], target: int) -> bool` that returns a boolean indicating the existence of the pair. 2. The function must perform efficiently with a complexity of (O(n)). # Function Signature ```python def has_pair_with_sum(arr: list[int], target: int) -> bool: pass ``` # Input * `arr`: A list of integers. * `target`: An integer representing the target sum. # Output * Returns a boolean value (`True` or `False`). # Constraints * The list `arr` will have at least two elements ((2 leq text{len}(arr) leq 10^5)). * The individual elements of `arr` will be in the range of (-10^9 leq text{element} leq 10^9). * The target sum ((target)) will be in the range of (-10^9 leq target leq 10^9). # Example ```python arr = [10, 15, 3, 7] target = 17 print(has_pair_with_sum(arr, target)) # Output: True arr = [1, 2, 3, 9] target = 8 print(has_pair_with_sum(arr, target)) # Output: False ``` # Explanation In the first example, the function returns `True` because 10 + 7 equals 17, which is the target sum. In the second example, the function returns `False` because there are no two distinct elements in the array that sum up to 8. # Notes - Consider using a set to keep track of the elements seen so far during the iteration through the list to achieve the desired time complexity. - Remember to handle edge cases, such as the scenario where no pair sums up to the target value. This problem tests your ability to work with arrays and utilize efficient data structures to achieve optimal runtime performance.","solution":"def has_pair_with_sum(arr: list[int], target: int) -> bool: Returns True if there exists a pair of distinct elements in the array whose sum equals the target value. Otherwise, returns False. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"# Scenario You are tasked with simulating a basic banking system. Each account in the bank has an account number, a balance, and a list of transactions. Transactions can either be deposits or withdrawals. Your goal is to implement a system capable of adding new accounts, performing transactions, and generating a statement for each account summarizing all transactions and the final balance. # Task Implement the following classes and functions: 1. **Account** class: - **Attributes**: - `account_number` (int): A unique identifier for the account. - `balance` (float): The balance in the account. - `transactions` (list): A list to store transactions. - **Methods**: - `deposit(amount: float) -> None`: Adds the amount to the balance and records the transaction. - `withdraw(amount: float) -> bool`: Deducts the amount from the balance if sufficient funds are available, records the transaction, and returns `True`; if insufficient funds, returns `False`. - `get_statement() -> str`: Returns a formatted statement showing the account number, all transactions, and the final balance. 2. **Bank** class: - **Attributes**: - `accounts` (dict): A dictionary to store accounts with the account number as the key. - **Methods**: - `add_account(account_number: int) -> None`: Adds a new account with the given account number. - `get_account(account_number: int) -> Account | None`: Retrieves the account with the given account number. # Input and Output Formats 1. **Input**: N/A for classes and methods implementation. 2. **Output**: Implement appropriate return types for methods as specified. # Constraints 1. Account numbers are unique integers. 2. Initial balance for a new account is 0.0. 3. Transaction amounts are positive floats. 4. Balance and transaction values should be accurate to two decimal places. 5. Ensure thread safety for concurrent transactions. # Examples ```python class Account: def __init__(self, account_number: int): self.account_number = account_number self.balance = 0.0 self.transactions = [] def deposit(self, amount: float) -> None: self.balance += round(amount, 2) self.transactions.append(f\'Deposit: +{amount:.2f}\') def withdraw(self, amount: float) -> bool: if amount > self.balance: return False self.balance -= round(amount, 2) self.transactions.append(f\'Withdrawal: -{amount:.2f}\') return True def get_statement(self) -> str: statement = f\\"Account Number: {self.account_number}n\\" statement += \\"n\\".join(self.transactions) statement += f\\"nFinal Balance: {self.balance:.2f}\\" return statement class Bank: def __init__(self): self.accounts = {} def add_account(self, account_number: int) -> None: if account_number not in self.accounts: self.accounts[account_number] = Account(account_number) def get_account(self, account_number: int) -> Account | None: return self.accounts.get(account_number) # Example usage bank = Bank() bank.add_account(12345) account = bank.get_account(12345) if account: account.deposit(200.0) account.withdraw(50.0) account.deposit(100.0) print(account.get_statement()) # Output should be: # Account Number: 12345 # Deposit: +200.00 # Withdrawal: -50.00 # Deposit: +100.00 # Final Balance: 250.00 ```","solution":"class Account: def __init__(self, account_number: int): self.account_number = account_number self.balance = 0.0 self.transactions = [] def deposit(self, amount: float) -> None: self.balance += round(amount, 2) self.transactions.append(f\'Deposit: +{amount:.2f}\') def withdraw(self, amount: float) -> bool: if amount > self.balance: return False self.balance -= round(amount, 2) self.transactions.append(f\'Withdrawal: -{amount:.2f}\') return True def get_statement(self) -> str: statement = f\\"Account Number: {self.account_number}n\\" statement += \\"n\\".join(self.transactions) statement += f\\"nFinal Balance: {self.balance:.2f}\\" return statement class Bank: def __init__(self): self.accounts = {} def add_account(self, account_number: int) -> None: if account_number not in self.accounts: self.accounts[account_number] = Account(account_number) def get_account(self, account_number: int) -> Account: return self.accounts.get(account_number)"},{"question":"# Question: Removing Duplicates from a Sorted Linked List Objective You are tasked to implement a function to remove duplicates from a sorted singly linked list. The linked list should only contain unique elements after the function execution. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: Removes duplicates from a sorted linked list. Parameters: head (ListNode): The head node of the sorted linked list. Returns: ListNode: The head node of the linked list after removing duplicates. ``` Input - **head**: The head node of a sorted linked list, which may contain duplicates. Output - Returns the head node of the modified linked list without duplicates. Constraints - The function should handle cases where the list is empty. - The list nodes are sorted in non-decreasing order. - Ensure that the function can handle lists with up to 10^4 nodes. Example Usage ```python # Helper function to create linked list from a list of values def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list of values def linked_list_to_list(head): values = [] current = head while current: values.append(current.val) current = current.next return values # Example head = create_linked_list([1, 1, 2, 3, 3]) new_head = remove_duplicates(head) print(linked_list_to_list(new_head)) # Output: [1, 2, 3] head = create_linked_list([1, 1, 1, 1, 1]) new_head = remove_duplicates(head) print(linked_list_to_list(new_head)) # Output: [1] ``` Explanation For the list `1 -> 1 -> 2 -> 3 -> 3`: - Start with the first element (1), compare it with the next element (1). - Since both are equal, skip the next element and move to the third element (2). - Compare the second element (2) with the next element (3). - Repeat the process to remove all duplicates resulting in `1 -> 2 -> 3`. For the list `1 -> 1 -> 1 -> 1 -> 1`: - Start with the first element (1), remove all subsequent duplicate elements. - Resulting in a single element list `1`. Tips 1. Traverse the linked list iteratively. 2. Check each node\'s value against the next node\'s value. 3. Use pointers to link nodes directly, skipping duplicates. 4. Handle edge cases such as an empty list or a list with all repeated elements.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: Removes duplicates from a sorted linked list. Parameters: head (ListNode): The head node of the sorted linked list. Returns: ListNode: The head node of the linked list after removing duplicates. if not head: return None current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head # Helper function to create linked list from a list of values def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list of values def linked_list_to_list(head): values = [] current = head while current: values.append(current.val) current = current.next return values"},{"question":"# Question You are tasked with developing a system that processes user data from multiple JSON files, consolidates the information, and replaces specific placeholders within template strings for report generation. The functionality should include reading multiple JSON files from a directory, merging the data based on user ID, and substituting placeholders in the predefined templates. Your task is to implement a function `generate_reports` that reads JSON files, consolidates user data, and applies the data to the given template string, replacing placeholders with respective user information. **Function Signature:** ```python def generate_reports(data_directory: pathlib.Path, template_file: pathlib.Path) -> dict[int, str]: pass ``` # Input: - `data_directory`: A `pathlib.Path` object pointing to the directory containing JSON files with user data. - `template_file`: A `pathlib.Path` object pointing to a file containing a template string with placeholders. # Output: - Returns a dictionary with user IDs as keys and their respective generated report strings as values. # Constraints: - Assume JSON files contain user data in the following format: ```json { \\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\" } ``` - Template placeholders are in the format `{placeholder}`, where `placeholder` corresponds to keys in the JSON objects. - Assume all JSON files in the `data_directory` follow the correct schema. - Raise appropriate errors if necessary, such as file not found or invalid JSON structure. # Example: Given a directory structure and template file: **Directory Structure**: ``` user_data/ ├── user_1.json ├── user_2.json └── user_3.json ``` **Template File Content (template.txt)**: ``` Welcome {name}! We have your information as follows: Age: {age} Email: {email} Thank you. ``` **JSON File Content (user_1.json)**: ```json { \\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\" } ``` ```python # Example Usage: from pathlib import Path result = generate_reports(Path(\\"user_data\\"), Path(\\"template.txt\\")) for user_id, report in result.items(): print(f\\"Report for User ID {user_id}:n{report}\\") ``` This example would output: ``` Report for User ID 1: Welcome Alice! We have your information as follows: Age: 30 Email: alice@example.com Thank you. ```","solution":"import json from pathlib import Path def generate_reports(data_directory: Path, template_file: Path) -> dict[int, str]: user_data = {} # Load template with open(template_file, \'r\') as file: template = file.read() # Read and merge JSON files for json_file in data_directory.glob(\\"*.json\\"): with open(json_file, \'r\') as file: data = json.load(file) user_data[data[\'id\']] = data # Generate reports reports = {} for user_id, data in user_data.items(): report = template for key, value in data.items(): report = report.replace(f\'{{{key}}}\', str(value)) reports[user_id] = report return reports"},{"question":"# Problem Statement: Image Compression Analysis You have been contracted to develop a tool for analyzing image compression techniques. Your goal is to implement a function that determines the compression ratio of an image file before and after compression. # Function Signature ```python def compression_ratio(original_size: int, compressed_size: int) -> float: pass ``` # Input - Two integer values: - `original_size` (size of the original image file in bytes) - `compressed_size` (size of the compressed image file in bytes) # Output - A floating-point number representing the compression ratio. The compression ratio is calculated as `original_size / compressed_size`. # Constraints - Both `original_size` and `compressed_size` are positive integers. - `compressed_size` should be less than or equal to `original_size`. # Example ```python # Given sizes in bytes compression_ratio(5000000, 1250000) # Expected output: 4.0 compression_ratio(2500000, 1250000) # Expected output: 2.0 compression_ratio(3000000, 750000) # Expected output: 4.0 ``` # Instructions 1. You must implement the `compression_ratio` function that takes the size of the original file and the size of the compressed file and returns the compression ratio. 2. Ensure to handle edge cases such as compressed_size being very small or just slightly less than original_size. 3. The function should be able to process the inputs efficiently and return the correct compression ratio as a floating-point number. 4. Validate the input constraints within the function. By implementing this function, you will provide crucial analysis for evaluating the effectiveness of various image compression algorithms.","solution":"def compression_ratio(original_size: int, compressed_size: int) -> float: Returns the compression ratio of an image file before and after compression. Parameters: original_size (int): Size of the original image file in bytes. compressed_size (int): Size of the compressed image file in bytes. Returns: float: Compression ratio calculated as original_size / compressed_size. if compressed_size <= 0 or original_size <= 0: raise ValueError(\\"Size values must be positive integers.\\") if compressed_size > original_size: raise ValueError(\\"Compressed size must be less than or equal to the original size.\\") return original_size / compressed_size"},{"question":"# Problem Statement: Suppose you are working with a graphical modeling software that allows users to define various shapes and their properties. Your task is to create a class that represents a generic shape and extends it to specific shapes like Circle and Rectangle. Implement methods to compute the area and perimeter of these shapes and override string representation methods for better readability. # Requirements: 1. Implement a base class `Shape` with the following properties and methods: - `name`: Name of the shape. - `area()`: Method to compute the area of the shape, to be overridden by subclasses. - `perimeter()`: Method to compute the perimeter of the shape, to be overridden by subclasses. - `__str__()`: Method to return a string representation of the shape including its name, area, and perimeter. 2. Implement subclasses `Circle` and `Rectangle` extending the `Shape` class. The `Circle` class should store the radius as an attribute and the `Rectangle` class should store the width and height. Implement the respective `area()` and `perimeter()` methods for these shapes. 3. Ensure proper validation and error handling in the constructors of the `Circle` and `Rectangle` classes (e.g., non-negative dimensions). # Constraints: - **Input validation**: Handle invalid inputs by raising exceptions (e.g., negative dimensions). - **Efficiency**: Implement the methods efficiently considering standard geometric formulas. # Function Signature: ```python class Shape: def __init__(self, name: str): self.name = name def area(self) -> float: raise NotImplementedError(\\"Subclasses should implement this!\\") def perimeter(self) -> float: raise NotImplementedError(\\"Subclasses should implement this!\\") def __str__(self) -> str: return f\\"{self.name} with area: {self.area()} and perimeter: {self.perimeter()}\\" class Circle(Shape): def __init__(self, radius: float): if radius < 0: raise ValueError(\\"Radius cannot be negative\\") super().__init__(\\"Circle\\") self.radius = radius def area(self) -> float: return 3.1416 * self.radius ** 2 def perimeter(self) -> float: return 2 * 3.1416 * self.radius class Rectangle(Shape): def __init__(self, width: float, height: float): if width < 0 or height < 0: raise ValueError(\\"Width and height cannot be negative\\") super().__init__(\\"Rectangle\\") self.width = width self.height = height def area(self) -> float: return self.width * self.height def perimeter(self) -> float: return 2 * (self.width + self.height) ``` # Example: ```python circle = Circle(5) print(circle) # Output: \\"Circle with area: 78.54 and perimeter: 31.416\\" rectangle = Rectangle(3, 4) print(rectangle) # Output: \\"Rectangle with area: 12 and perimeter: 14\\" ``` # Note: - Use appropriate geometric formulas: - Area of a circle: ( pi times text{radius}^2 ) - Perimeter (circumference) of a circle: ( 2 times pi times text{radius} ) - Area of a rectangle: ( text{width} times text{height} ) - Perimeter of a rectangle: ( 2 times (text{width} + text{height}) ) - Ensure to validate the dimensions passed to the constructors of `Circle` and `Rectangle` classes.","solution":"import math class Shape: def __init__(self, name: str): self.name = name def area(self) -> float: raise NotImplementedError(\\"Subclasses should implement this!\\") def perimeter(self) -> float: raise NotImplementedError(\\"Subclasses should implement this!\\") def __str__(self) -> str: return f\\"{self.name} with area: {self.area()} and perimeter: {self.perimeter()}\\" class Circle(Shape): def __init__(self, radius: float): if radius < 0: raise ValueError(\\"Radius cannot be negative\\") super().__init__(\\"Circle\\") self.radius = radius def area(self) -> float: return math.pi * self.radius ** 2 def perimeter(self) -> float: return 2 * math.pi * self.radius class Rectangle(Shape): def __init__(self, width: float, height: float): if width < 0 or height < 0: raise ValueError(\\"Width and height cannot be negative\\") super().__init__(\\"Rectangle\\") self.width = width self.height = height def area(self) -> float: return self.width * self.height def perimeter(self) -> float: return 2 * (self.width + self.height)"},{"question":"# Coding Assessment Question: Scenario: You are developing a financial software system that needs to handle real-time transactional data processing. Your task is to implement a function to calculate the moving average of a list of integers over a specified window size. The moving average is commonly used in time series analysis to smooth out short-term fluctuations and highlight longer-term trends. Task: Write a function `moving_average(data: list, window_size: int) -> list` that: 1. Takes a list of integers `data` and an integer `window_size`. 2. Calculates the moving average over the specified window size. 3. Returns a list of the moving averages. Input: - A list of integers `data` where `0 <= len(data) <= 10^6` and each element is in the range `-10^9 <= data[i] <= 10^9`. - An integer `window_size` where `1 <= window_size <= len(data)`. Output: - A list of floats where each float represents the moving average of the subarray of `window_size`. Constraints: - If `window_size` is larger than the length of `data`, or is less than 1, raise a `ValueError` with the message: \\"invalid window size\\". - If `data` is not a list or contains non-integer elements, raise a `TypeError`. Example: ```python moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) # Returns [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] moving_average([10, 20, 30, 40, 50], 4) # Returns [25.0, 35.0] moving_average([5, 5, 5, 5, 5], 2) # Returns [5.0, 5.0, 5.0, 5.0] ``` Requirements: - Implement robust error handling for invalid inputs. - Ensure optimal performance, particularly when handling large input sizes.","solution":"def moving_average(data, window_size): Calculate the moving average of a list of integers over a specified window size. :param data: List of integers. :param window_size: The size of the moving window. :return: List of floats representing the moving averages. :raises ValueError: If window_size is invalid. :raises TypeError: If data is not a list or contains non-integer elements. if not isinstance(data, list) or not all(isinstance(x, int) for x in data): raise TypeError(\\"data must be a list of integers\\") if not isinstance(window_size, int) or window_size <= 0 or window_size > len(data): raise ValueError(\\"invalid window size\\") moving_averages = [] window_sum = sum(data[:window_size]) moving_averages.append(window_sum / window_size) for i in range(window_size, len(data)): window_sum += data[i] - data[i - window_size] moving_averages.append(window_sum / window_size) return moving_averages"},{"question":"# DNA Sequence Counter: Counting Nucleotide Occurrence You are working on a bioinformatics application, and you need to analyze DNA sequences. A DNA sequence is a string consisting of the characters \'A\', \'C\', \'G\', and \'T\' which represent the nucleotide bases adenine, cytosine, guanine, and thymine respectively. Objective Write a function `count_nucleotides` that takes a DNA sequence string and returns a dictionary with the count of each nucleotide (\'A\', \'C\', \'G\', and \'T\') in the sequence. Function Signature ```python def count_nucleotides(dna: str) -> Dict[str, int]: ``` # Input - A single string `dna` that represents the DNA sequence. # Output - A dictionary with the keys \'A\', \'C\', \'G\', and \'T\', where the values are the counts of each nucleotide in the input DNA sequence. # Constraints - `1 <= len(dna) <= 10^6` - `dna` will only contain the characters \'A\', \'C\', \'G\', and \'T\' # Examples ```python assert count_nucleotides(\\"ACGT\\") == {\'A\': 1, \'C\': 1, \'G\': 1, \'T\': 1} assert count_nucleotides(\\"AAAACCCGTTT\\") == {\'A\': 4, \'C\': 3, \'G\': 1, \'T\': 3} assert count_nucleotides(\\"GGGGG\\") == {\'A\': 0, \'C\': 0, \'G\': 5, \'T\': 0} assert count_nucleotides(\\"TACG\\") == {\'A\': 1, \'C\': 1, \'G\': 1, \'T\': 1} ``` **Explanation**: 1. For the first example, the DNA sequence \\"ACGT\\" has one of each nucleotide, so the count dictionary is {\'A\': 1, \'C\': 1, \'G\': 1, \'T\': 1}. 2. For the second example, \\"AAAACCCGTTT\\" contains 4 \'A\'s, 3 \'C\'s, 1 \'G\', and 3 \'T\'s, resulting in the count dictionary {\'A\': 4, \'C\': 3, \'G\': 1, \'T\': 3}. # Requirements - Ensure your implementation handles large inputs efficiently. - Consider and handle edge cases such as the function receiving a string with only one type of nucleotide.","solution":"def count_nucleotides(dna): Returns the count of each nucleotide \'A\', \'C\', \'G\', and \'T\' in the DNA sequence. Parameters: dna (str): A string representing the DNA sequence. Returns: dict: A dictionary with the nucleotide counts. counts = {\'A\': 0, \'C\': 0, \'G\': 0, \'T\': 0} for nucleotide in dna: if nucleotide in counts: counts[nucleotide] += 1 return counts"},{"question":"# Question Write a Python function `rotate_string(s: str, k: int) -> str` that takes a string `s` and an integer `k`, and returns a new string which is a rotation of `s` by `k` characters to the right. If `k` is negative, rotate the string to the left by `|k|` characters instead. Specific Requirements: 1. **Function Name**: rotate_string 2. **Parameters**: * `s`: A string to be rotated. * `k`: An integer determining the number of characters to rotate the string. 3. **Return**: A new rotated string. Constraints: * The string `s` will contain only printable ASCII characters. * 0 <= len(s) <= 10^5 * -10^5 <= k <= 10^5 Examples: ```python assert rotate_string(\\"abcdef\\", 2) == \\"efabcd\\" assert rotate_string(\\"abcdef\\", -2) == \\"cdefab\\" assert rotate_string(\\"abcdef\\", 0) == \\"abcdef\\" assert rotate_string(\\"abcdef\\", 6) == \\"abcdef\\" assert rotate_string(\\"abcdef\\", -6) == \\"abcdef\\" assert rotate_string(\\"\\", 5) == \\"\\" ``` Explanation: In the first example, rotating \\"abcdef\\" by 2 characters to the right gives \\"efabcd\\". In the second example, rotating \\"abcdef\\" by 2 characters to the left gives \\"cdefab\\". In the third example, rotating \\"abcdef\\" by 0 characters gives \\"abcdef\\" (no change). In the fourth and fifth examples, rotating by the length of the string or a multiple of the length results in the same string. In the last example, rotating an empty string by any number of characters gives an empty string. Use efficient string operations to ensure the function compiles within the given constraints.","solution":"def rotate_string(s: str, k: int) -> str: Rotates the string s by k characters to the right if k is positive, or to the left if k is negative. Parameters: s (str): The string to be rotated. k (int): The number of characters to rotate the string. Returns: str: The rotated string. if len(s) == 0: # Edge case for empty string return s n = len(s) k = k % n # Normalize k to avoid unnecessary large rotations # Right rotation by k is equivalent to left rotation by n - k return s[-k:] + s[:-k] if k >= 0 else s[-k:] + s[:-k]"},{"question":"# Majority Element in an Array Problem Statement Given an array of integers, your task is to find the majority element. A majority element is an element that appears more than ⌊n / 2⌋ times in the array, where n is the length of the array. Assume that the array is non-empty and a majority element always exists in the given array. Your implementation should optimize for both time and space complexity. Functional Specification 1. **Function Name**: `find_majority_element` 2. **Input**: A list of integers `nums`. 3. **Output**: An integer, representing the majority element. Constraints 1. The input list `nums` contains at least one element. 2. The length of the list `n` (1 ≤ n ≤ 10^5). 3. The majority element always exists in the given list. Examples ```python >>> find_majority_element([3, 2, 3]) 3 >>> find_majority_element([2, 2, 1, 1, 1, 2, 2]) 2 >>> find_majority_element([1, 2, 1, 1, 3, 1, 1]) 1 ``` Implementation Implement the function to find the majority element by following the specifications provided. ```python def find_majority_element(nums): Returns the majority element in a non-empty list of integers. The majority element is the element that appears more than ⌊n / 2⌋ times. Args: nums: A list of integers where a majority element always exists. Returns: The majority element. # Implementing Moore\'s Voting Algorithm count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` This new question matches the original set in terms of style, complexity, and scope by focusing on algorithmic thinking and efficiency. It incorporates a single clear problem statement, constraints, examples, and a reference implementation, keeping consistent with the provided samples.","solution":"def find_majority_element(nums): Returns the majority element in a non-empty list of integers. The majority element is the element that appears more than ⌊n / 2⌋ times. Args: nums: A list of integers where a majority element always exists. Returns: The majority element. # Implementing Moore\'s Voting Algorithm count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"# Coding Assessment Question Scenario You are part of a development team working on an e-commerce application. One critical requirement is to validate and format user-provided email addresses properly. # Objective Implement the `validate_and_format_email` function that checks if a given email address is valid. The function should: 1. Validate the email address based on the following rules: - It must contain exactly one \\"@\\" symbol. - The domain name (part after the \\"@\\") should have at least one dot and should not start or end with a dot. - The local part (part before the \\"@\\") should not start or end with non-alphanumeric characters. Allowed special characters in the local part are dot (.), underscore (_), and plus (+). 2. If the email is valid, return the formatted email address in all lowercase. 3. If the email is invalid, raise a `ValueError` with a meaningful message. # Function Signature ```python def validate_and_format_email(email: str) -> str: pass ``` # Constraints - The function should handle both lowercase and uppercase letters in the email address. - Ensure the function operates within a reasonable time complexity for validations. # Input - `email` (str): A string representing the email address to be validated and formatted. # Output - (str): The formatted email address in lowercase if valid. # Examples ```python assert validate_and_format_email(\\"User.Name+tag@Example.com\\") == \\"user.name+tag@example.com\\" assert validate_and_format_email(\\"Us_er.Name@example.co.uk\\") == \\"us_er.name@example.co.uk\\" assert validate_and_format_email(\\"user.name@example\\") == \\"user.name@example\\" assert validate_and_format_email(\\"user@domain.com\\") == \\"user@domain.com\\" try: validate_and_format_email(\\"invalid-email.com\\") except ValueError as e: assert str(e) == \\"Invalid email address: must contain exactly one \'@\'.\\" try: validate_and_format_email(\\"user@domain..com\\") except ValueError as e: assert str(e) == \\"Invalid email address: domain part should not start or end with a dot and must contain at least one dot.\\" try: validate_and_format_email(\\"!user@domain.com\\") except ValueError as e: assert str(e) == \\"Invalid email address: local part should not start or end with non-alphanumeric characters.\\" ``` # Implementation Details 1. Implement `validate_and_format_email` that adheres to the specified behavior and constraints. 2. Write appropriate test cases to validate the correctness of the function, including edge cases and error handling.","solution":"import re def validate_and_format_email(email: str) -> str: Validates and formats an email address. Args: email (str): The email address to be validated and formatted. Returns: str: The formatted email address in lowercase if valid. Raises: ValueError: If the email address is invalid. if \\"@\\" not in email or email.count(\\"@\\") != 1: raise ValueError(\\"Invalid email address: must contain exactly one \'@\'.\\") local_part, domain_part = email.split(\\"@\\") # Validate domain part if domain_part.startswith(\\".\\") or domain_part.endswith(\\".\\") or domain_part.count(\\".\\") < 1: raise ValueError(\\"Invalid email address: domain part should not start or end with a dot and must contain at least one dot.\\") # Validate local part if not re.match(r\\"^[a-zA-Z0-9]+[a-zA-Z0-9._+]*\\", local_part) or local_part.startswith((\'.\', \'_\', \'+\')) or local_part.endswith((\'.\', \'_\', \'+\')): raise ValueError(\\"Invalid email address: local part should not start or end with non-alphanumeric characters.\\") return email.lower()"},{"question":"# Merge Sorted Lists: Iterative vs Recursive You are provided two algorithms to merge two already sorted lists into a single sorted list: an iterative approach and a recursive approach. Your task is to implement functions that employ these algorithms. Requirements: 1. **Iterative Approach**: Implement the iterative method using two-pointer technique. 2. **Recursive Approach**: Implement the method using recursion. # Function Signatures: ```python def merge_sorted_lists_iterative(list1: list[int | float], list2: list[int | float]) -> list[int | float]: pass def merge_sorted_lists_recursive(list1: list[int | float], list2: list[int | float], merged: list[int | float] = []) -> list[int | float]: pass ``` # Input: - Two sorted lists `list1` and `list2` of integers or floating-point numbers. # Output: - A single sorted list that contains all the elements of `list1` and `list2`. # Constraints: - Both input lists must be non-decreasing order. - Be attentive to edge cases, such as lists being empty, having large numbers, and including negative values and zeroes. # Sample Usage: ```python # Test cases for the iterative approach assert merge_sorted_lists_iterative([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists_iterative([-1, 0, 1], [-2, 2, 3]) == [-2, -1, 0, 1, 2, 3] assert merge_sorted_lists_iterative([3], [-1]) == [-1, 3] assert merge_sorted_lists_iterative([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_lists_iterative([3, 5, 7], []) == [3, 5, 7] # Test cases for the recursive approach assert merge_sorted_lists_recursive([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists_recursive([-1, 0, 1], [-2, 2, 3]) == [-2, -1, 0, 1, 2, 3] assert merge_sorted_lists_recursive([3], [-1]) == [-1, 3] assert merge_sorted_lists_recursive([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_lists_recursive([3, 5, 7], []) == [3, 5, 7] ``` Implement these functions ensuring efficiency, correctness, and handle edge cases appropriately.","solution":"def merge_sorted_lists_iterative(list1: list[int | float], list2: list[int | float]) -> list[int | float]: Merge two sorted lists into a single sorted list using an iterative approach. merged = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged.append(list1[i]) i += 1 else: merged.append(list2[j]) j += 1 while i < len(list1): merged.append(list1[i]) i += 1 while j < len(list2): merged.append(list2[j]) j += 1 return merged def merge_sorted_lists_recursive(list1: list[int | float], list2: list[int | float], merged: list[int | float] = []) -> list[int | float]: Merge two sorted lists into a single sorted list using a recursive approach. if not list1: return merged + list2 if not list2: return merged + list1 if list1[0] <= list2[0]: return merge_sorted_lists_recursive(list1[1:], list2, merged + [list1[0]]) else: return merge_sorted_lists_recursive(list1, list2[1:], merged + [list2[0]])"},{"question":"# Problem Statement Your task is to implement a function that checks whether a given string is a palindrome using recursion. A palindrome is a string that reads the same backward as forward. **Function Signature:** ```python def is_palindrome(s: str) -> bool: ``` **Input:** * `s` (str): A string that may contain uppercase and lowercase letters, digits, and punctuation. **Output:** * `bool`: Return `True` if the string is a palindrome, otherwise return `False`. # Requirements: * Implement the check recursively. * Ignore case, punctuation, and spaces in your palindrome check. # Constraints: * The length of the input string `s` will not exceed 1000 characters. # Performance: The algorithm should have a time complexity of O(n) and a space complexity O(n) due to the recursive stack. # Example: ```python print(is_palindrome(\\"A man, a plan, a canal, Panama\\")) # Expected: True print(is_palindrome(\\"racecar\\")) # Expected: True print(is_palindrome(\\"hello\\")) # Expected: False print(is_palindrome(\\"No lemon, no melon\\")) # Expected: True ``` # Additional Information * You may use helper functions if necessary. * Ensure your solution correctly handles edge cases like an empty string or strings with no alphanumeric characters.","solution":"import re def is_palindrome(s: str) -> bool: Checks if the given string s is a palindrome, ignoring case, punctuation, and spaces. This is done using recursion. # Helper function to clean the string def clean_string(s): return re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() cleaned_string = clean_string(s) # Function to check palindrome recursively def check_palindrome(s, left, right): if left >= right: return True if s[left] != s[right]: return False return check_palindrome(s, left + 1, right - 1) return check_palindrome(cleaned_string, 0, len(cleaned_string) - 1)"},{"question":"Problem Description You are tasked with creating a function to convert a matrix of integers into its corresponding zigzag pattern. The zigzag pattern should start from the top-left corner, move horizontally to the right, and then continue in a snake-like pattern for subsequent rows. Task 1. **Matrix Zigzag Conversion**: * You will implement a function to convert a 2D matrix (list of lists) of integers into a 1D list of integers that follows the zigzag pattern. * The function should handle matrices of any size (including edge cases like empty matrices and single-element matrices). 2. **Optimization Consideration**: * Ensure that the function handles large matrices efficiently with minimal computational overhead. # Input and Output Formats Function: `convert_to_zigzag` * **Input**: * A `matrix` (list of lists) where each element is an integer. * Constraints: The matrix can be of any size, including empty or single-element matrices. * **Output**: * A list of integers representing the matrix in zigzag order. * Example: For a 2x3 matrix `[[1, 2, 3], [4, 5, 6]]`, the output should be `[1, 2, 3, 6, 5, 4]`. * **Example**: ```python convert_to_zigzag([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 6, 5, 4] ``` * **Edge Cases**: * An empty matrix should return an empty list. * A single-element matrix should return a list with that single element. Implementation Details 1. Implement the function `convert_to_zigzag` to take a matrix (list of lists) and return the zigzag pattern as a list. 2. Ensure the function handles matrices of varying sizes and shapes efficiently. 3. Consider edge cases, such as empty matrices and matrices with only one row or one column. # Example ```python def convert_to_zigzag(matrix): if not matrix or not matrix[0]: return [] rows = len(matrix) cols = len(matrix[0]) result = [] for r in range(rows): if r % 2 == 0: result.extend(matrix[r]) else: result.extend(reversed(matrix[r])) return result # Test with a sample matrix print(convert_to_zigzag([[1, 2, 3], [4, 5, 6]])) # Output: [1, 2, 3, 6, 5, 4] ``` In this example, the function `convert_to_zigzag` first checks if the matrix is empty or not. It then iterates over each row, appending the row to the result list in its original or reversed order based on the row index. The zigzag pattern is achieved by alternating the direction of row traversal for each subsequent row.","solution":"def convert_to_zigzag(matrix): Converts a 2D matrix into a 1D list in a zigzag pattern. if not matrix or not matrix[0]: return [] rows = len(matrix) cols = len(matrix[0]) result = [] for r in range(rows): if r % 2 == 0: result.extend(matrix[r]) else: result.extend(reversed(matrix[r])) return result"},{"question":"Maze Solver You are given an implementation of a maze solver algorithm. Your task is to write a function that checks whether there is a path from the start point to the end point in a given maze represented by a grid. The grid will be a 2D list of integers where `0` represents an open cell and `1` represents a wall. The start point is always the top-left corner (0, 0) and the end point is always the bottom-right corner (n-1, m-1). You can only move up, down, left, or right. # Function Signature ```python def can_solve_maze(maze: List[List[int]]) -> bool: pass ``` # Input and Output * **Input**: - `maze` (type: `List[List[int]]`): A 2D grid representing the maze. * **Output**: - (type: `bool`): Returns `True` if there is a path from the start to the end, otherwise `False`. # Constraints * `maze` will be a non-empty 2D list. * The dimensions of the maze (n, m) will be at most 100 x 100. * `maze[0][0]` and `maze[n-1][m-1]` will always be `0`. # Example ```python # Test case 1: maze = [ [0, 1, 1, 0], [0, 0, 1, 0], [1, 0, 1, 1], [1, 0, 0, 0] ] # Expected output: True print(can_solve_maze(maze)) # Test case 2: maze = [ [0, 1, 1, 1], [1, 1, 1, 0], [1, 1, 1, 1], [0, 0, 0, 0] ] # Expected output: False print(can_solve_maze(maze)) # Test case 3: maze = [ [0, 0, 1], [1, 0, 1], [0, 0, 0] ] # Expected output: True print(can_solve_maze(maze)) ``` # Note - Ensure that the algorithm handles mazes of different sizes and configurations correctly. - Implement an efficient search algorithm, such as Depth-First Search (DFS) or Breadth-First Search (BFS), to determine if a path exists. - Consider edge cases where the maze is either completely open or completely blocked.","solution":"from typing import List def can_solve_maze(maze: List[List[int]]) -> bool: n = len(maze) m = len(maze[0]) # directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == 0 def dfs(x, y): if x == n - 1 and y == m - 1: return True maze[x][y] = 1 # Mark visited for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"Coding Challenge: Maximum Points on a Line # Objective: You are required to write a function that, given a set of points in a 2D plane, computes the maximum number of points that lie on a single straight line. # Problem Description: Given `n` points on a 2D plane, find the maximum number of points that lie on the same straight line. # Function Specification: Implement the following function: ```python def max_points_on_line(points: List[List[int]]) -> int: Calculate the maximum number of points that lie on a single straight line. Parameters: points (List[List[int]]): A list of points, where each point is represented as [x, y]. Returns: int: Maximum number of points on a single line. pass ``` # Input: * `points`: A list of points in a 2D plane, where each point is represented as a list with two integers [x, y]. The number of points provided will be in the range (1 ≤ points.length ≤ 1000). # Output: * Returns an integer representing the maximum number of points that lie on a single straight line. # Example: ```python print(max_points_on_line([[1,1],[2,2],[3,3]])) # Expected output: 3 print(max_points_on_line([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]])) # Expected output: 4 ``` # Constraints: * The points are not necessarily unique. * The coordinates of the points are all integers and can be represented within the range of a signed 32-bit integer. # Additional Notes: * Use a hashmap (dictionary) to keep track of lines defined by any two points. Specifically, calculate slopes and use them as keys to store the number of points on each line. * Handle edge cases such as vertical lines, overlapping points, and different precision errors with floating-point calculations. * Ensure your solution is optimal and efficiently handles the given constraints. # Guideline: - Calculate the slope between every pair of points. - Use a gcd (Greatest Common Divisor) function to handle division and avoid floating-point precision errors. - Count the maximum number of points for each unique slope, considering overlapping points. - Iterate over all points as potential starting points, and compute the maximum number of collinear points for each starting point. Good luck!","solution":"from typing import List from collections import defaultdict from math import gcd def max_points_on_line(points: List[List[int]]) -> int: if len(points) <= 1: return len(points) def calculate_slope(p1, p2): dy = p2[1] - p1[1] dx = p2[0] - p1[0] if dx == 0: return float(\'inf\') else: divisor = gcd(dx, dy) return (dy // divisor, dx // divisor) max_points = 0 for i in range(len(points)): slopes = defaultdict(int) duplicate = 1 for j in range(i + 1, len(points)): if points[i] == points[j]: duplicate += 1 else: slope = calculate_slope(points[i], points[j]) slopes[slope] += 1 current_max = duplicate for count in slopes.values(): current_max = max(current_max, count + duplicate) max_points = max(max_points, current_max) return max_points"},{"question":"# Word Ladder: Transforming Words with Minimal Steps Context You are working on a word transformation tool that provides users with the shortest possible sequence of steps to change one word into another. Each step in the transformation sequence must result in a valid dictionary word, differing by exactly one character from the previous word. Problem Statement Write a function `word_ladder_length` that takes in a start word `begin_word`, an end word `end_word`, and a set of words `word_list`. The function returns the minimum number of transformation steps needed to convert `begin_word` to `end_word`, or returns 0 if no such sequence exists. Input Format - A string `begin_word` representing the starting word. - A string `end_word` representing the target word. - A set of strings `word_list` containing dictionary words. It is guaranteed that: - Both `begin_word` and `end_word` are strings of the same length, with length `L`, where `1 <= L <= 20`. - All strings in `word_list` are also of length `L`. - The total number of words in `word_list` does not exceed `10^5`. Output Format - An integer representing the minimal number of steps required to transform `begin_word` to `end_word`. If no valid transformation sequence exists, return 0. Constraints - Transformations must result in intermediary words present in `word_list`. - Each transformation changes exactly one character of the word. - The function should aim for the shortest path, optimizing the transformation sequence. Performance Requirements - The implementation should handle the given input constraints efficiently, ideally aiming for O(L * N) complexity, where N is the size of the word list and L is the length of each word. Function Signature ```python def word_ladder_length(begin_word: str, end_word: str, word_list: set[str]) -> int: pass ``` Example ```python def word_ladder_length(begin_word: str, end_word: str, word_list: set[str]) -> int: from collections import deque if end_word not in word_list: return 0 word_list.add(end_word) queue = deque([(begin_word, 1)]) word_len = len(begin_word) while queue: current_word, level = queue.popleft() if current_word == end_word: return level for i in range(word_len): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i + 1:] if next_word in word_list: word_list.remove(next_word) queue.append((next_word, level + 1)) return 0 # Test case: begin_word = \\"hit\\" end_word = \\"cog\\" word_list = {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"} print(word_ladder_length(begin_word, end_word, word_list)) # Output: 5 ``` This problem assesses the ability to implement efficient algorithms using breadth-first search (BFS) for shortest path finding in word transformation scenarios.","solution":"def word_ladder_length(begin_word: str, end_word: str, word_list: set[str]) -> int: from collections import deque if end_word not in word_list: return 0 word_list.add(end_word) queue = deque([(begin_word, 1)]) word_len = len(begin_word) while queue: current_word, level = queue.popleft() if current_word == end_word: return level for i in range(word_len): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i + 1:] if next_word in word_list: word_list.remove(next_word) queue.append((next_word, level + 1)) return 0"},{"question":"# Coding Challenge: Design a Cache System **Context**: Caching is a mechanism to store frequently accessed data in a temporary storage to reduce access time and improve performance. A common type of cache is the Least Recently Used (LRU) cache, which discards the least recently used items first when the cache reaches its limit. # Task Implement a class `LRUCache` that simulates a Least Recently Used cache with a fixed size. Your class should support the following operations: 1. **Get**: Retrieve an item from the cache. 2. **Put**: Insert or update an item in the cache. 3. **Remove**: Remove an item from the cache if it exists. # Input and Output - **Get Operation**: - Method: `get(key: int) -> int | None` - Input: Integer key. - Output: Integer value corresponding to the key or None if key is not present. - **Put Operation**: - Method: `put(key: int, value: int) -> None` - Input: Integer key and value. - Output: None. - **Remove Operation**: - Method: `remove(key: int) -> bool` - Input: Integer key. - Output: Boolean indicating if the key was successfully removed (True) or not (False). # Constraints 1. The cache will have a maximum fixed size `n` specified when it is created. Ensure it maintains the order of usage to properly implement the LRU policy. 2. Keys and values are positive integers. 3. Implement all required functions. # Scenario Create an `LRUCache` instance with a size limit of 3. Perform a series of insertions, retrievals, and deletions while ensuring the correct implementation of the cache’s functionality. The cache should evict the least recently used item when it is full. ```python class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, size: int): self.size = size self.cache = {} self.head = None self.tail = None self.current_size = 0 def get(self, key: int) -> int | None: pass # Implement the get method def put(self, key: int, value: int) -> None: pass # Implement the put method def remove(self, key: int) -> bool: pass # Implement the remove method def _move_to_front(self, node: Node) -> None: pass # Utility to move accessed/inserted node to the front def _evict_least_recently_used(self) -> None: pass # Utility to evict the least recently used node if __name__ == \\"__main__\\": cache_size = 3 lru_cache = LRUCache(cache_size) lru_cache.put(1, 10) lru_cache.put(2, 20) lru_cache.put(3, 30) print(lru_cache.get(1)) # Expected Output: 10 lru_cache.put(4, 40) # This will evict key 2 print(lru_cache.get(2)) # Expected Output: None (key 2 was evicted) print(lru_cache.get(3)) # Expected Output: 30 lru_cache.remove(1) print(lru_cache.get(1)) # Expected Output: None (key 1 was removed) ``` Ensure to include edge cases such as cache overflow, access to non-existent keys, and successful/unsuccessful removals.","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, size: int): self.size = size self.cache = {} self.head = None self.tail = None self.current_size = 0 def get(self, key: int) -> int | None: if key in self.cache: node = self.cache[key] self._move_to_front(node) return node.value return None def put(self, key: int, value: int) -> None: if key in self.cache: node = self.cache[key] node.value = value self._move_to_front(node) else: new_node = Node(key, value) if self.current_size == self.size: self._evict_least_recently_used() self._add_to_front(new_node) self.cache[key] = new_node self.current_size += 1 def remove(self, key: int) -> bool: if key in self.cache: node = self.cache[key] self._remove_node(node) del self.cache[key] self.current_size -= 1 return True return False def _move_to_front(self, node: Node) -> None: if node == self.head: return self._remove_node(node) self._add_to_front(node) def _evict_least_recently_used(self) -> None: if self.tail: del self.cache[self.tail.key] self._remove_node(self.tail) self.current_size -= 1 def _add_to_front(self, node: Node) -> None: node.next = self.head node.prev = None if self.head: self.head.prev = node self.head = node if not self.tail: self.tail = node def _remove_node(self, node: Node) -> None: if node.prev: node.prev.next = node.next if node.next: node.next.prev = node.prev if node == self.head: self.head = node.next if node == self.tail: self.tail = node.prev node.prev = None node.next = None"},{"question":"# Problem Statement You are developing a simple content management system (CMS) that organizes text articles into categories. Each article can belong to one or more categories. Your task is to extend the functionality of the `CMS` class provided by adding methods that allow for: 1. Retrieving articles by a specific category. 2. Identifying the most popular category (i.e., the category with the most articles). 3. Counting the total number of articles in the system. # Task Requirements 1. Implement three new methods in the `CMS` class: * `get_articles_by_category(self, category: str) -> list[str]`: Returns a list of article titles that belong to the given `category`. If no articles belong to the category, return an empty list. * `most_popular_category(self) -> str`: Returns the name of the category that contains the most articles. If there are multiple categories with the same highest number of articles, return any one of them. * `total_article_count(self) -> int`: Returns the total number of articles present in the system. # Input - Articles and categories are represented as strings. - Each article title is unique. # Output - For `get_articles_by_category`, return a list of strings (article titles). - For `most_popular_category`, return a string (category name). - For `total_article_count`, return an integer. # Constraints 1. There can be up to `10^4` articles. 2. Each article can belong to up to `10` categories. 3. There can be up to `10^3` different categories. # Example ```python cms = CMS() cms.add_article(\'Article1\', [\'Tech\', \'Science\']) cms.add_article(\'Article2\', [\'Health\', \'Science\']) cms.add_article(\'Article3\', [\'Tech\']) # Example usage: print(cms.get_articles_by_category(\'Tech\')) # Output: [\'Article1\', \'Article3\'] print(cms.most_popular_category()) # Output: \'Science\' print(cms.total_article_count()) # Output: 3 ``` Implement the methods in such a way that they are efficient and handle the constraints mentioned.","solution":"class CMS: def __init__(self): self.articles = {} self.categories = {} def add_article(self, title, categories): self.articles[title] = categories for category in categories: if category not in self.categories: self.categories[category] = [] self.categories[category].append(title) def get_articles_by_category(self, category: str) -> list[str]: return self.categories.get(category, []) def most_popular_category(self) -> str: max_category = None max_count = 0 for category, articles in self.categories.items(): if len(articles) > max_count: max_category = category max_count = len(articles) return max_category def total_article_count(self) -> int: return len(self.articles)"},{"question":"# Problem Statement You are tasked with implementing the `merge_sorted_arrays` function. This function will merge two sorted arrays into a single sorted array with minimal additional space usage. # Function Signature ```python def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: pass ``` # Input * **arr1**: A list of integers in ascending order. * You can assume the list contains non-negative integers. * **arr2**: A list of integers in ascending order. * You can assume the list contains non-negative integers. # Output * Return a list of integers which is the sorted merge of `arr1` and `arr2`. # Constraints * 0 <= len(arr1), len(arr2) <= 10^6 * 0 <= arr1[i], arr2[i] <= 10^9 # Requirements * Implement the `merge_sorted_arrays` function using an approach that minimizes additional space usage. * Ensure the merged list is in ascending order. # Example Usage ```python arr1 = [0, 3, 4, 31] arr2 = [4, 6, 30] print(merge_sorted_arrays(arr1, arr2)) # Expected output: [0, 3, 4, 4, 6, 30, 31] arr1 = [] arr2 = [1, 2, 3] print(merge_sorted_arrays(arr1, arr2)) # Expected output: [1, 2, 3] arr1 = [1, 5, 8] arr2 = [] print(merge_sorted_arrays(arr1, arr2)) # Expected output: [1, 5, 8] ``` # Additional Information Testing for edge cases like: * Both lists being empty * One list being empty * Both lists having the same elements * Very large lists Your solution should ensure all the above cases are handled efficiently.","solution":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merges two sorted arrays into a single sorted array with minimal additional space. i, j = 0, 0 merged_array = [] # Iterate through both arrays until we reach the end of either while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append any remaining elements from arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Append any remaining elements from arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"# Coding Question **Objective**: Write a function to determine the mode of a list of integers. # Problem Statement You are given a list of integers, and you need to write a function `find_mode(numbers: List[int]) -> int` that takes this list as input and returns the mode of the list. The mode is the number that appears most frequently in the list. If there are multiple numbers with the same highest frequency, return the smallest one. # Input Format - A list of integers, which can include negative numbers and duplicates. - Example: `[4, 2, 2, 4, 3, 3, 1, 2]` # Output Format - A single integer, which is the mode of the list. - Example: `2` # Constraints - The list will contain at least one integer and at most 10^5 integers. - All integers in the list will be within the range of -10^6 to 10^6. # Example ```python assert find_mode([4, 2, 2, 4, 3, 3, 1, 2]) == 2 assert find_mode([1, 1, 2, 2, 3]) == 1 assert find_mode([5]) == 5 assert find_mode([1, 1, 2, 2, 3, 3]) == 1 assert find_mode([7, 3, 7, 3, 7, 4, 4]) == 7 ``` # Requirements - You must ensure that your implementation is efficient and can handle large inputs within the constraints. - Your solution should correctly handle edge cases, such as lists with only one element or where all elements are equally frequent. Note Your code should not utilize any built-in functions that directly compute the mode. Instead, develop the logic for determining the frequency of elements and finding the mode.","solution":"from typing import List from collections import defaultdict def find_mode(numbers: List[int]) -> int: Returns the mode of the list of numbers. In case of a tie, returns the smallest number among the modes. frequency = defaultdict(int) # Calculating frequencies of each number for number in numbers: frequency[number] += 1 # Finding the highest frequency and the corresponding mode max_freq = 0 mode = float(\'inf\') for number, freq in frequency.items(): if freq > max_freq or (freq == max_freq and number < mode): max_freq = freq mode = number return mode"},{"question":"# Coding Question: Matrix Element Product Your task is to create a function that calculates the product of all elements in a given `n x m` matrix of integers. The matrix will be provided as a list of lists, where each inner list represents a row of the matrix. You must implement the function `matrix_element_product(matrix: List[List[int]]) -> int` to achieve this. Input: * The function will take a single parameter `matrix` which is a list of lists containing integers. Output: * The function should return an integer which is the product of all the elements in the matrix. Constraints: * The matrix will have at least 1 row and 1 column, but no more than 1000 rows and 1000 columns (1 ≤ n, m ≤ 1000). * The elements in the matrix can be positive or negative integers, including zero. # Example: ```python from typing import List def matrix_element_product(matrix: List[List[int]]) -> int: >>> matrix_element_product([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 362880 >>> matrix_element_product([[1, -1], [-1, 1]]) 1 >>> matrix_element_product([[0, 2], [3, 4]]) 0 ``` # Notes: * Ensure that your function handles matrices with various dimensions correctly. * Consider edge cases such as matrices containing zeros or negative numbers. * Optimize the code to handle large matrices within the provided size constraints efficiently.","solution":"from typing import List def matrix_element_product(matrix: List[List[int]]) -> int: Returns the product of all elements in the given matrix. Args: matrix (List[List[int]]): A list of lists representing the matrix. Returns: int: The product of all elements in the matrix. product = 1 for row in matrix: for element in row: product *= element return product"},{"question":"Number Spiral Diagonal Sum Background In mathematics, a number spiral starts with the number 1 at the center and then wraps around to form a square spiral. The diagonal sums of these spirals often present interesting patterns. Given the size of the spiral, calculate the sum of the numbers on the diagonals. Problem Statement Write a function `spiral_diagonal_sum(size: int) -> int` that takes an odd integer `size` and returns the sum of the numbers on the diagonals in a number spiral of the given size. Input - An odd integer `size` (1 ≤ size ≤ 1001). Output - An integer representing the sum of the numbers on the diagonals in the spiral. Example 1. `spiral_diagonal_sum(5)` should return `101`. 2. `spiral_diagonal_sum(3)` should return `25`. 3. `spiral_diagonal_sum(1)` should return `1`. Constraints - Ensure your solution handles small values such as `size = 1`. - Optimize for larger odd sizes up to 1001. - Consider mathematical properties of the spiral for an efficient solution. Scenario Imagine a scenario in computer graphics where rendering intricate designs based on mathematical patterns is important. Knowing the sums of diagonals in such spirals can aid in generating visually aesthetic and symmetrical patterns. Likewise, in data encryption, such properties could also help in creating complex, hard-to-decipher codes. Code Template ```python def spiral_diagonal_sum(size: int) -> int: if size == 1: return 1 sum_diagonals = 1 current_number = 1 for layer in range(1, (size // 2) + 1): increment = layer * 2 for corner in range(4): current_number += increment sum_diagonals += current_number return sum_diagonals # Example usage: print(spiral_diagonal_sum(5)) # Output: 101 print(spiral_diagonal_sum(3)) # Output: 25 print(spiral_diagonal_sum(1)) # Output: 1 ```","solution":"def spiral_diagonal_sum(size: int) -> int: if size == 1: return 1 sum_diagonals = 1 current_number = 1 for layer in range(1, (size // 2) + 1): increment = layer * 2 for corner in range(4): current_number += increment sum_diagonals += current_number return sum_diagonals"},{"question":"# Problem Statement You are asked to implement a cache that allows storing key-value pairs and supports Least Recently Used (LRU) eviction policy when the cache exceeds its capacity. Use the provided `LRUCache` class template to implement the following operations: 1. **Put**: This method should add a key-value pair to the cache. If the cache exceeds its capacity, it should evict the least recently accessed item. 2. **Get**: This method should retrieve the value associated with the given key if it exists; otherwise, return -1. Each access to a key makes it the most recently used one. 3. **Delete**: This method should remove the key-value pair associated with the given key if it exists. 4. **Display Cache**: This method should return a list of keys in the cache from the most recently used to the least recently used. Input Format - The `LRUCache` is initialized with a positive integer representing its capacity. - Each subsequent command will be in one of the following formats: - `put(key, value)` - `get(key)` - `delete(key)` - `display_cache()` Output Format - For `get` operations, output the value associated with the key or -1 if the key doesn\'t exist. - For `display_cache` operations, output the list of keys in the cache from most recently used to least recently used. Constraints - The number of operations will not exceed 10^5. - The keys and values are integers in the range of -10^9 to 10^9. - The cache capacity will be between 1 and 10^4. Functions to Implement ```python class LRUCache: def __init__(self, capacity: int): pass def put(self, key: int, value: int) -> None: pass def get(self, key: int) -> int: pass def delete(self, key: int) -> None: pass def display_cache(self) -> List[int]: pass ``` Example ```python # Initialize the LRU cache with capacity 2 cache = LRUCache(2) # Perform put operations cache.put(1, 1) cache.put(2, 2) print(cache.display_cache()) # Output: [2, 1] # Perform get operation print(cache.get(1)) # Output: 1 print(cache.display_cache()) # Output: [1, 2] # Another put operation, causes eviction of key 2 cache.put(3, 3) print(cache.get(2)) # Output: -1 print(cache.display_cache()) # Output: [3, 1] # Delete operation cache.delete(1) print(cache.display_cache()) # Output: [3] # Add another key, again capacity is 2 cache.put(4, 4) print(cache.display_cache()) # Output: [4, 3] ``` Note: Ensure that any internal data structures you use support the required operations efficiently to handle the constraints.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def delete(self, key: int) -> None: if key in self.cache: del self.cache[key] def display_cache(self) -> list: return list(self.cache.keys())[::-1]"},{"question":"# Problem Statement: You are given an array of integers where each integer appears exactly twice, except for one integer which appears exactly once. Write a function to find the integer that appears only once using linear runtime complexity and without using extra memory. # Input: * `List[int] arr`: A list of integers where each integer appears exactly twice except for one. # Output: * Return the integer that appears only once. # Constraints: * The list will have a length of at least 1 and at most (10^5). * The integers in the list will be in the range ([-10^9, 10^9]). # Example: ```python # Example 1: # Input: [2, 2, 1] # Output: 1 # Example 2: # Input: [4, 1, 2, 1, 2] # Output: 4 ``` # Notes: * You can use bitwise XOR to find the unique element in linear time. * XOR of two identical numbers is zero and XOR of a number with zero is the number itself. This property can help in finding the unique number. # Function Signature: ```python def find_unique_number(arr: List[int]) -> int: # Implementation here ```","solution":"from typing import List def find_unique_number(arr: List[int]) -> int: Returns the integer that appears only once in an array where every other integer appears exactly twice. unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"# Problem Statement Write a function to determine if a given string is re-arrangeable into a palindrome. A palindrome is a word, phrase, or sequence that reads the same backward as forward. Your function should return `True` if the string can be rearranged into a palindrome, and `False` otherwise. Ignore spacing, punctuation, and case sensitivity while determining if the re-arrangement is possible. Detailed Requirements: 1. Implement the function `can_form_palindrome`. 2. The function should take a single string as input. 3. Palindrome re-arrangement is possible if at most one character has an odd frequency when counting character occurrences. Input: - A single string `s`, where (1 leq text{len}(s) leq 10^5). Output: - The function should return a boolean value `True` or `False`. Constraints: - The function should be case-insensitive, meaning \'A\' and \'a\' are considered the same. - Ignore all non-alphabet characters (spaces, punctuation). Performance Expectations: - Time Complexity: O(n), where n is the length of the string. - Space Complexity: O(1), considering the constant number of characters (26 letters in the English alphabet). Example: ```python def can_form_palindrome(s: str) -> bool: # Implement the function to solve the problem. pass if __name__ == \\"__main__\\": test_string1 = \\"A man, a plan, a canal, Panama!\\" test_string2 = \\"abc\\" print(can_form_palindrome(test_string1)) # Expected output: True print(can_form_palindrome(test_string2)) # Expected output: False ``` Example explanations: 1. For the input `\\"A man, a plan, a canal, Panama!\\"`, the function should return `True` since it can be rearranged into the palindrome \\"A man, a plan, a canal, Panama!\\" by ignoring spaces and punctuation. 2. For the input `\\"abc\\"`, the function should return `False` as no permutation of \\"abc\\" forms a palindrome.","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter import re # Remove non-alphabet characters and convert to lowercase cleaned_s = re.sub(r\'[^a-zA-Z]\', \'\', s).lower() # Count the frequency of each character char_count = Counter(cleaned_s) # Check the number of characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"# Coding Problem: Merge Two Sorted Lists You are given two sorted lists of integers. Your task is to write a function that merges these two lists into a single sorted list. Do not use the built-in sorting functions. # Function Signature ```python def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: ... ``` # Input * `list1` - A list of integers sorted in non-decreasing order. * `list2` - A list of integers sorted in non-decreasing order. # Output * Returns a single list of integers sorted in non-decreasing order containing all elements from `list1` and `list2`. # Constraints * Each list can have up to `10^5` elements. * The integers in the lists can range from `-10^9` to `10^9`. # Function Behavior * The function should efficiently merge the two input lists into a single sorted list. # Example ```python >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] ``` # Hints * Consider using a two-pointer technique to efficiently merge the lists. * One pointer should traverse `list1` and the other should traverse `list2`. * Append the smaller value pointed to by the pointers to the resulting list and increment the corresponding pointer. * Handle remaining elements from either list after one list is exhausted.","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 len1, len2 = len(list1), len(list2) while i < len1 and j < len2: if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements of list1, if any while i < len1: merged_list.append(list1[i]) i += 1 # Append remaining elements of list2, if any while j < len2: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Binary Tree Traversal You are tasked with implementing functions to perform different types of tree traversals on a binary tree. You need to complete the functions that will return the nodes of the binary tree in pre-order, in-order, and post-order traversals. **Function Signatures**: ```python def pre_order_traversal(root: TreeNode) -> List[int]: def in_order_traversal(root: TreeNode) -> List[int]: def post_order_traversal(root: TreeNode) -> List[int]: ``` **Classes and Structures**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Input**: * `root`: The root node of a binary tree. **Output**: * Returns a list of integers representing the nodes of the binary tree. **Constraints**: * The number of nodes in the tree is in the range [0, 1000]. * -1000 <= Node value <= 1000 **Example**: ```python # Example tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) pre_order_traversal(root) # Output: [1, 2, 4, 5, 3] in_order_traversal(root) # Output: [4, 2, 5, 1, 3] post_order_traversal(root) # Output: [4, 5, 2, 3, 1] ``` **Note**: 1. Ensure the functions handle edge cases appropriately, such as empty trees. 2. Pre-order traversal visits nodes in the order: root, left subtree, right subtree. 3. In-order traversal visits nodes in the order: left subtree, root, right subtree. 4. Post-order traversal visits nodes in the order: left subtree, right subtree, root.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pre_order_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def traverse(node): if node: result.append(node.val) # Visit root traverse(node.left) # Traverse left subtree traverse(node.right) # Traverse right subtree traverse(root) return result def in_order_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def traverse(node): if node: traverse(node.left) # Traverse left subtree result.append(node.val) # Visit root traverse(node.right) # Traverse right subtree traverse(root) return result def post_order_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def traverse(node): if node: traverse(node.left) # Traverse left subtree traverse(node.right) # Traverse right subtree result.append(node.val) # Visit root traverse(root) return result"},{"question":"Optimizing Flight Paths using Bellman-Ford Algorithm # Problem Statement You are tasked with implementing the Bellman-Ford algorithm to find the shortest paths from a given source node to all other nodes in a weighted, directed graph. This algorithm is particularly useful because it can handle graphs with negative weight edges, provided that there are no negative weight cycles. You must implement the `bellman_ford(graph, source, num_vertices)` function. The `graph` is represented as a list of edges, where each edge is a tuple `(u, v, w)` indicating an edge from node `u` to node `v` with weight `w`. The `bellman_ford` function should return a dictionary where the keys are the node names and the values are the shortest distances from the `source` node. If there is a negative weight cycle reachable from the source, return the string `\\"Negative weight cycle detected\\"` instead. # Input - `graph`: A list of tuples representing the edges in the graph `(u, v, w)`. Example: ```python [ (\'A\', \'B\', 1), (\'B\', \'C\', 2), (\'A\', \'C\', -3), (\'C\', \'D\', 1) ] ``` - `source`: The starting node for Bellman-Ford algorithm (a string). - `num_vertices`: The total number of vertices in the graph (an integer). # Output - A dictionary where each key is a node and the value is the shortest distance from the source node, or a string indicating a negative weight cycle. # Constraints - The graph may contain negative weight edges. - The graph must not contain negative weight cycles that are reachable from the source node. - The number of vertices in the graph will be between 1 and 100. # Example ```python graph = [ (\'A\', \'B\', 1), (\'B\', \'C\', 2), (\'A\', \'C\', -3), (\'C\', \'D\', 1) ] source = \'A\' num_vertices = 4 print(bellman_ford(graph, source, num_vertices)) # Output: {\'A\': 0, \'B\': 1, \'C\': -3, \'D\': -2} ``` # Implementation Details 1. Initialize the distances from the source to all other vertices as infinity, except for the source itself which should be 0. 2. Relax all the edges `num_vertices - 1` times to ensure the shortest paths are found. 3. Check for negative weight cycles by trying to relax the edges one more time. If any distance is updated, a negative weight cycle exists. 4. If no negative weight cycle is detected, return the calculated shortest distances for each node.","solution":"def bellman_ford(graph, source, num_vertices): Implements the Bellman-Ford algorithm. Parameters: graph (list): A list of edges where each edge is a tuple (u, v, w). source (str): The source node from which distances are calculated. num_vertices (int): The total number of vertices in the graph. Returns: dict: A dictionary containing shortest distances from the source to each node, or a string indicating a negative weight cycle. distances = {source: 0} for vertex in set([edge[0] for edge in graph] + [edge[1] for edge in graph]): if vertex != source: distances[vertex] = float(\'inf\') for _ in range(num_vertices - 1): for u, v, w in graph: if distances[u] != float(\'inf\') and distances[u] + w < distances[v]: distances[v] = distances[u] + w for u, v, w in graph: if distances[u] != float(\'inf\') and distances[u] + w < distances[v]: return \\"Negative weight cycle detected\\" return distances"},{"question":"# Question Context File compression is a common task in computer science, with numerous algorithms dedicated to reducing file size. One such algorithm is Run-Length Encoding (RLE), which compresses sequences of repeated characters into a single character followed by the count of its repetitions. Imagine that you are building a data processing application that needs to compress and decompress data using RLE. Your task is to implement two functions for this purpose: one to compress a given string, and another to decompress it. Problem Statement Implement two functions, `compress_rle` and `decompress_rle`, to compress and decompress strings using the Run-Length Encoding method. 1. **compress_rle(data: str) -> str** - **Input**: - `data`: A string representing the data to be compressed. - **Output**: - A string representing the compressed data using RLE. - **Example**: ```python >>> compress_rle(\\"aaabbbcccaaa\\") \\"a3b3c3a3\\" ``` 2. **decompress_rle(data: str) -> str** - **Input**: - `data`: A string representing the compressed data using RLE. - **Output**: - A string representing the decompressed original data. - **Example**: ```python >>> decompress_rle(\\"a3b3c3a3\\") \\"aaabbbcccaaa\\" ``` 3. **Constraints**: - The input string for `compress_rle` will only contain lowercase alphabetical characters (a-z). - The input string for `decompress_rle` will always be a valid RLE-encoded string, with characters followed by digits. - `1 <= len(data) <= 10^5` Additional Requirements - Your implementation should handle edge cases such as: - Single characters and strings with no repetitions. - Long sequences of a single character. - Strings with varying character frequencies. - Aim for an efficient solution to handle the upper input limits, especially for very long strings.","solution":"def compress_rle(data: str) -> str: Compresses a given string using Run-Length Encoding (RLE). :param data: A string to be compressed. :return: A compressed string using RLE. if not data: return \\"\\" compressed = [] count = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: count += 1 else: compressed.append(data[i - 1] + str(count)) count = 1 compressed.append(data[-1] + str(count)) # Append the last character and its count return \'\'.join(compressed) def decompress_rle(data: str) -> str: Decompresses a given string from its Run-Length Encoding (RLE) representation. :param data: A string compressed using RLE. :return: The original decompressed string. decompressed = [] i = 0 while i < len(data): char = data[i] count = \\"\\" i += 1 while i < len(data) and data[i].isdigit(): count += data[i] i += 1 decompressed.append(char * int(count)) return \'\'.join(decompressed)"},{"question":"# Problem Statement You are given a string `s` and a dictionary of words `words_dict`. The string `s` can be formed by concatenating some or all of the words in `words_dict`. Your task is to determine if the string can be segmented into a space-separated sequence of one or more dictionary words. # Input - A string `s` where `1 ≤ len(s) ≤ 10^5`, containing only lowercase alphabets. - A list of words `words_dict` where each word is composed of lowercase alphabets and the length of the list is `n` with `0 ≤ n ≤ 10^5`. # Output - Return `True` if `s` can be segmented into a space-separated sequence of one or more dictionary words, otherwise return `False`. # Constraints - The same word in the dictionary can be reused multiple times. - The list `words_dict` may contain duplicates. - Handle all edge cases such as empty dictionary or empty string. # Example ```python assert can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True assert can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True assert can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False assert can_segment_string(\\"abcd\\", [\\"a\\", \\"abc\\", \\"b\\", \\"cd\\"]) == True assert can_segment_string(\\"bb\\", [\\"a\\", \\"b\\", \\"bbb\\", \\"bbbb\\"]) == True assert can_segment_string(\\"catsand\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\"]) == True assert can_segment_string(\\"applepie\\", [\\"apple\\", \\"pie\\", \\"applepie\\"]) == True assert can_segment_string(\\"\\", [\\"apple\\", \\"banana\\"]) == False assert can_segment_string(\\"abcdef\\", []) == False assert can_segment_string(\\"abcdef\\", [\\"abcdef\\"]) == True assert can_segment_string(\\"ab\\", [\\"a\\", \\"b\\", \\"ab\\"]) == True ``` # Function Signature ```python def can_segment_string(s: str, words_dict: list[str]) -> bool: # implement here ``` # Notes - Ensure to raise ValueError if `words_dict` is not a list of strings.","solution":"def can_segment_string(s: str, words_dict: list[str]) -> bool: Determines if the string s can be segmented into a space-separated sequence of one or more dictionary words. Parameters: s (str): The string to be segmented. words_dict (list[str]): The list of words that can be used for segmentation. Returns: bool: True if the string can be segmented, otherwise False. if not s: return False if not isinstance(words_dict, list) or not all(isinstance(word, str) for word in words_dict): raise ValueError(\\"words_dict must be a list of strings\\") word_set = set(words_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"# Task Write a function `optimized_fibonacci` that uses an iterative approach and memoization to efficiently calculate the nth Fibonacci number with high precision. # Function Signature ```python def optimized_fibonacci(n: int) -> int: pass ``` # Input * `n` (int): The position in the Fibonacci sequence. Must be a non-negative integer. # Output * Returns `int`: The nth Fibonacci number. # Constraints * You must utilize an iterative approach combined with memoization to optimize the calculation. * Ensure that `n` is a non-negative integer and raise a `ValueError` if not. # Examples ```python >>> optimized_fibonacci(10) 55 >>> optimized_fibonacci(50) 12586269025 >>> optimized_fibonacci(0) 0 >>> optimized_fibonacci(-5) Traceback (most recent call last): ... ValueError: n must be a non-negative integer ``` # Notes * Utilize Python\'s built-in data structures to store previously calculated Fibonacci values, reducing the number of repeated calculations. * High precision should be prioritized to appropriately handle very large Fibonacci numbers.","solution":"def optimized_fibonacci(n: int) -> int: Calculate the nth Fibonacci number using an iterative approach combined with memoization. Parameters: n (int): The position in the Fibonacci sequence. Must be a non-negative integer. Returns: int: The nth Fibonacci number. Raises: ValueError: If n is a negative integer. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 fib_cache = [0] * (n + 1) fib_cache[1] = 1 for i in range(2, n + 1): fib_cache[i] = fib_cache[i - 1] + fib_cache[i - 2] return fib_cache[n]"},{"question":"# Coding Assessment Question: Simple Interest Calculator Context: Simple interest is calculated using the formula: [ SI = frac{P times R times T}{100} ] where: * ( P ) is the principal amount * ( R ) is the rate of interest per year as a percentage * ( T ) is the time period in years Task: Write a Python function `simple_interest` that takes three floating-point numbers: `principal`, `rate`, and `time`, and returns the calculated simple interest. Input: * Three positive floating-point numbers `principal`, `rate`, and `time` representing the principal amount, the annual interest rate, and the time period in years respectively. Output: * A floating-point number representing the calculated simple interest. Constraints: * All input values (`principal`, `rate`, `time`) must be positive. Raise a `ValueError` if any value is zero or negative. Example: ```python >>> simple_interest(1000.0, 5.0, 2.0) 100.0 >>> simple_interest(1500.0, 4.5, 3.0) 202.5 >>> simple_interest(2000.0, -2.0, 1.5) Traceback (most recent call last): ... ValueError: All input values must be positive >>> simple_interest(0.0, 5.0, 1.0) Traceback (most recent call last): ... ValueError: All input values must be positive ``` Requirements: 1. Ensure your function validates that all input values are positive. 2. Include error handling to raise a `ValueError` on invalid input. 3. Optimize your code for readability and efficiency. Performance: * The function should run in constant time ( O(1) ). * Memory usage must be constant as well ( O(1) ).","solution":"def simple_interest(principal, rate, time): Returns the calculated simple interest using the formula: SI = (P * R * T) / 100. Parameters: principal (float): The principal amount, must be positive. rate (float): The annual rate of interest, must be positive. time (float): The time period in years, must be positive. Returns: float: The calculated simple interest. Raises: ValueError: If any of the input values are zero or negative. if principal <= 0 or rate <= 0 or time <= 0: raise ValueError(\\"All input values must be positive\\") return (principal * rate * time) / 100"},{"question":"# Even and Odd Element Separator Your task is to implement a function that separates the even and odd numbers from a given list while preserving their original relative order. Core Functionality - Implement a function `separate_even_odd(numbers: List[int]) -> Tuple[List[int], List[int]]` that separates the even and odd numbers into two different lists. Input - A list `numbers` of integers with length `n` (0 ≤ n ≤ 1000). - Example input: `[3, 2, 4, 1, 5]` Output - A tuple containing two lists, the first list with all the even numbers, and the second list with all the odd numbers. - Example output: `([2, 4], [3, 1, 5])` Constraints - The input list can be empty, and in such cases, the function should return two empty lists. - Maintain the original order of elements in both the even and odd lists. Edge Cases - Consider handling lists with no even elements, no odd elements, or all elements being identical. Example ```python >>> separate_even_odd([3, 2, 4, 1, 5]) ([2, 4], [3, 1, 5]) >>> separate_even_odd([]) ([], []) >>> separate_even_odd([2, 4, 6]) ([2, 4, 6], []) >>> separate_even_odd([1, 3, 5]) ([], [1, 3, 5]) >>> separate_even_odd([7, 7, 7]) ([], [7, 7, 7]) ```","solution":"from typing import List, Tuple def separate_even_odd(numbers: List[int]) -> Tuple[List[int], List[int]]: Separates the even and odd numbers from the input list while preserving their order. Args: numbers (List[int]): The input list of integers. Returns: Tuple[List[int], List[int]]: A tuple with two lists, first containing even numbers and the second containing odd numbers. evens = [num for num in numbers if num % 2 == 0] odds = [num for num in numbers if num % 2 != 0] return (evens, odds)"},{"question":"# Coding Question **Context**: Dominic is developing a reading tracker application that maintains a list of books and their completion status. He wants to implement a feature that allows users to filter books based on their reading status and view summaries of completed books. **Task**: Write a Python class `ReadingTracker` with the following requirements: 1. A method to add a new book with its title and author. 2. A method to mark a book as completed based on its title. 3. A method to generate a summary of all completed books. 4. A method to filter and return book titles based on their completion status (completed or not completed). **Class and Method Signatures**: ```python class ReadingTracker: def __init__(self): Initializes an empty reading tracker. pass def add_book(self, title: str, author: str) -> None: Adds a new book with the specified title and author to the tracker. :param title: str - the title of the book :param author: str - the author of the book pass def mark_completed(self, title: str) -> None: Marks the book with the given title as completed. :param title: str - the title of the book to mark as completed pass def completed_books_summary(self) -> str: Generates a summary of all completed books in a specific format. :return: str - the summary of completed books pass def filter_books(self, completed: bool) -> list: Filters and returns book titles based on their completion status. :param completed: bool - the completion status to filter by :return: list - the list of book titles matching the completion status pass ``` **Constraints**: * Each book title in the tracker should be unique. * If adding a book with a title that already exists, it should raise a `ValueError`. * Marking a non-existent book as completed should raise a `ValueError`. * The summary format for completed books should be: `\\"Title by Author\\"`, each book on a new line. **Example**: ```python tracker = ReadingTracker() tracker.add_book(\\"Python Programming\\", \\"John Doe\\") tracker.add_book(\\"Learn Data Science\\", \\"Jane Smith\\") # Marks \\"Python Programming\\" as completed tracker.mark_completed(\\"Python Programming\\") # Returns a summary of completed books assert tracker.completed_books_summary() == \\"Python Programming by John Doen\\" # Filters books by completion status assert tracker.filter_books(completed=True) == [\\"Python Programming\\"] assert tracker.filter_books(completed=False) == [\\"Learn Data Science\\"] ``` Additionally, ensure your class handles performance efficiently, especially with a larger number of books, and appropriately raises exceptions for edge cases.","solution":"class ReadingTracker: def __init__(self): Initializes an empty reading tracker. self.books = {} self.completed_books = set() def add_book(self, title: str, author: str) -> None: Adds a new book with the specified title and author to the tracker. :param title: str - the title of the book :param author: str - the author of the book :raises ValueError: if the book with the given title already exists if title in self.books: raise ValueError(\\"Book with the given title already exists\\") self.books[title] = author def mark_completed(self, title: str) -> None: Marks the book with the given title as completed. :param title: str - the title of the book to mark as completed :raises ValueError: if the book with the given title does not exist if title not in self.books: raise ValueError(\\"Book with the given title does not exist\\") self.completed_books.add(title) def completed_books_summary(self) -> str: Generates a summary of all completed books in a specific format. :return: str - the summary of completed books summary = \\"n\\".join(f\\"{title} by {self.books[title]}\\" for title in sorted(self.completed_books)) return summary def filter_books(self, completed: bool) -> list: Filters and returns book titles based on their completion status. :param completed: bool - the completion status to filter by :return: list - the list of book titles matching the completion status if completed: return sorted(self.completed_books) else: return sorted(title for title in self.books if title not in self.completed_books)"},{"question":"# Problem Statement Write a function `reverse_sublist(arr: List[int], start: int, end: int) -> List[int]` that reverses a portion of a list of integers from index `start` to index `end` inclusive. Ensure that the function performs in-place reversal when possible and handles edge cases gracefully. # Requirements 1. Implement the function `reverse_sublist(arr: List[int], start: int, end: int) -> List[int]`. 2. The function should raise an exception if: - `start` or `end` are out of the bounds of the array. - `start` > `end`. 3. The function should return the modified list after the sublist has been reversed. 4. The reversal should not use any additional lists or slicing for the sublist. # Input - A list of integers `arr` where (1 leq text{len(arr)} leq 10^5). - Two integers `start` and `end` representing the starting and ending indices of the sublist to be reversed. # Output - The modified list after the sublist has been reversed. # Example ```python >>> reverse_sublist([1, 2, 3, 4, 5], 1, 3) [1, 4, 3, 2, 5] >>> reverse_sublist([10, 20, 30, 40, 50], 0, 4) [50, 40, 30, 20, 10] >>> reverse_sublist([7, 14, 21, 28], 2, 3) [7, 14, 28, 21] ``` # Constraints - Ensure the solution respects the in-place modification constraint for optimal space usage. - Handle potential errors where indices may be out of bounds or improperly ordered.","solution":"from typing import List def reverse_sublist(arr: List[int], start: int, end: int) -> List[int]: Reverses a portion of a list of integers from index start to index end inclusive. Args: arr (List[int]): The list of integers to be modified. start (int): The starting index of the sublist to reverse. end (int): The ending index of the sublist to reverse. Returns: List[int]: The modified list after the sublist has been reversed. Raises: ValueError: If start or end are out of the bounds of the array or if start > end. # Check if start and end are within the bounds of the array if start < 0 or end >= len(arr) or start > end: raise ValueError(\\"start or end are out of bounds or start is greater than end\\") # Perform in-place reversal of the sublist while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 return arr"},{"question":"# Maze Exit Pathfinding **Context:** In a rectangular maze represented by a 2D array, each cell can be either empty (`0`) or blocked (`1`). You start at the top-left corner (0, 0) and want to reach the bottom-right corner (m-1, n-1). You can move up, down, left, or right but cannot pass through blocked cells. Your task is to determine if there exists a path from the start to the exit. **Task:** Write a function `exists_path(maze: List[List[int]]) -> bool` that returns `True` if there is a path from the top-left to the bottom-right corner, and `False` otherwise. **Function Signature:** ```python from typing import List def exists_path(maze: List[List[int]]) -> bool: pass ``` **Input:** - `maze` (1 ≤ len(maze), len(maze[0]) ≤ 100): A 2D list of integers representing the maze. **Output:** - A boolean value indicating whether a path exists. **Constraints:** - If the starting or ending cell is blocked, return `False` immediately. - Ensure the solution handles large mazes efficiently. **Performance Requirements:** - Optimize for efficient traversal of the maze using an appropriate algorithm like BFS or DFS. - Utilize data structures that minimize overhead and speed up the pathfinding process. **Example:** ```python maze1 = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert exists_path(maze1) == True maze2 = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert exists_path(maze2) == False ``` **Additional context:** Make sure to test the function with mazes of varying sizes and configurations to ensure robustness and efficiency. Consider edge cases such as very small mazes or mazes where almost all cells are blocked.","solution":"from typing import List from collections import deque def exists_path(maze: List[List[int]]) -> bool: if not maze or maze[0][0] == 1 or maze[-1][-1] == 1: return False m, n = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (m-1, n-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and maze[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"# Sorting Linked List using Merge Sort Problem Statement You are given a singly linked list and your task is to sort it using the Merge Sort algorithm. Implement a function that takes the head of the linked list as input and returns the sorted linked list. Requirements Implement the following method: ```python def sort_linked_list(head: \'ListNode\') -> \'ListNode\': Sorts a linked list using the Merge Sort algorithm. Parameters: head (ListNode): The head of the linked list. Returns: ListNode: The head of the sorted linked list. Example: >>> # Creating a linked list 4 -> 2 -> 1 -> 3 >>> node1 = ListNode(4) >>> node2 = ListNode(2) >>> node3 = ListNode(1) >>> node4 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> sorted_head = sort_linked_list(node1) >>> # Printing sorted linked list >>> while sorted_head: ... print(sorted_head.val, end=\\" -> \\") ... sorted_head = sorted_head.next 1 -> 2 -> 3 -> 4 -> ``` Your implementation must: - Use the Merge Sort algorithm for sorting, which involves dividing the list into halves and merging them after sorting. - Ensure the division and merging steps maintain the properties of linked lists optimally. Input and Output - **Input**: The head of the singly linked list (of type `ListNode`). - **Output**: The head of the sorted singly linked list (of type `ListNode`). Constraints - The linked list will contain at most 10^4 nodes. - The values in the linked list nodes will be in the range [-10^5, 10^5]. Performance Requirements - Ensure the Merge Sort implementation works in O(n log n) time complexity for sorting the linked list. Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Creating a linked list 4 -> 2 -> 1 -> 3 node1 = ListNode(4) node2 = ListNode(2) node3 = ListNode(1) node4 = ListNode(3) node1.next = node2 node2.next = node3 node3.next = node4 sorted_head = sort_linked_list(node1) # Printing sorted linked list while sorted_head: print(sorted_head.val, end=\\" -> \\") sorted_head = sorted_head.next # Output: 1 -> 2 -> 3 -> 4 -> ``` # Note - You may define any additional helper functions needed to implement the division and merging steps effectively.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def sort_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head # Helper function to find the middle of the linked list def get_middle(head): slow, fast = head, head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None # Split the list into two halves return slow # Helper function to merge two sorted linked lists def merge(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 if l2: tail.next = l2 return dummy.next # Get the middle of the list middle = get_middle(head) left = sort_linked_list(head) right = sort_linked_list(middle) # Merge the sorted halves sorted_list = merge(left, right) return sorted_list"},{"question":"# Coding Assessment Question: **Scenario**: You are developing a software module that processes encrypted messages for a secure communication system. Part of your task involves converting a given string into its hexadecimal representation and vice versa. **Problem Statement**: Write two functions to handle the conversions between a string and its hexadecimal representation. 1. **Function 1: `string_to_hex`** Input: - `input_string` (str): The input string to be converted to hexadecimal. Output: - `str`: The hexadecimal representation of the input string. Constraints: - The input string must not be empty, otherwise raise a `ValueError`. 2. **Function 2: `hex_to_string`** Input: - `hex_string` (str): The hexadecimal representation to be converted back to a string. Output: - `str`: The original string represented by the hexadecimal input. Constraints: - The length of the hexadecimal string must be even and it should only contain valid hexadecimal characters (\'0\' to \'9\' and \'A\' to \'F\'/\'a\' to \'f\'), otherwise raise a `ValueError`. **Example:** ```python # Example of string_to_hex print(string_to_hex(\\"Hello\\")) # Output: \'48656c6c6f\' print(string_to_hex(\\"World\\")) # Output: \'576f726c64\' # Example of hex_to_string print(hex_to_string(\\"48656c6c6f\\")) # Output: \'Hello\' print(hex_to_string(\\"576f726c64\\")) # Output: \'World\' ``` **Performance Requirements**: - Ensure that your functions are efficient, with time complexity O(n) and space complexity O(n), where n is the length of the input string or hex string. **Note**: Ensure that input values are validated properly, and appropriate exceptions are raised for any invalid inputs.","solution":"def string_to_hex(input_string): Converts a string to its hexadecimal representation. :param input_string: str : Input string to be converted to hexadecimal. :return: str : Hexadecimal representation of the input string. :raises: ValueError : If the input string is empty. if not input_string: raise ValueError(\\"Input string must not be empty.\\") hex_string = \'\'.join(format(ord(char), \'02x\') for char in input_string) return hex_string def hex_to_string(hex_string): Converts a hexadecimal string back to its original string form. :param hex_string: str : The hexadecimal string to be converted back to string. :return: str : Original string represented by the hexadecimal input. :raises: ValueError : If the hex string length is not even, or if it contains invalid characters. if len(hex_string) % 2 != 0: raise ValueError(\\"Hexadecimal string length must be even.\\") try: bytes_object = bytes.fromhex(hex_string) except ValueError: raise ValueError(\\"Hexadecimal string contains invalid characters.\\") original_string = bytes_object.decode(\'utf-8\') return original_string"},{"question":"# Bloom Filter Implementation You are asked to implement a Bloom filter, which is a probabilistic data structure used to determine whether an element is present in a set. It can guarantee that false positives are possible, but false negatives are not. Implement a class `BloomFilter` that: 1. Initializes a bit array of a given size. 2. Uses a specified number of hash functions. 3. Provides methods to add elements to the filter and check if an element is possibly in the set. Method Signature ```python class BloomFilter: def __init__(self, size: int, hash_count: int): # Initializes the bit array with zeros and sets the number of hash functions. def add(self, item: str): # Adds an item to the Bloom filter using the hash functions. def check(self, item: str) -> bool: # Checks if an item is possibly in the set, and returns a boolean value. ``` Example ```python bloom = BloomFilter(1000, 3) bloom.add(\\"hello\\") bloom.add(\\"world\\") print(bloom.check(\\"hello\\")) # Output: True print(bloom.check(\\"world\\")) # Output: True print(bloom.check(\\"test\\")) # Output: False (or True, due to false positive condition) ``` Constraints - The bit array size will be a positive integer. - The number of hash functions will be a positive integer. - The input to the `add` and `check` methods will be a non-empty string. Implementation Requirements - Use multiple hash functions to set and check bits in the bit array. - Consider the use of Python\'s built-in `hash` function along with some basic arithmetic to simulate multiple hash functions. Note Your implementation should efficiently use the bit array and avoid any unnecessary memory usage. Consider edge cases such as adding the same element multiple times and checking for elements that were never added.","solution":"class BloomFilter: def __init__(self, size: int, hash_count: int): Initializes the Bloom Filter with a bit array of given size and the specified number of hash functions. self.size = size self.hash_count = hash_count self.bit_array = [0] * size def _hash(self, item: str, seed: int) -> int: Simple hash function using built-in hash and a seed for variation. return hash(item + str(seed)) % self.size def add(self, item: str): Adds an item to the Bloom filter. for i in range(self.hash_count): index = self._hash(item, i) self.bit_array[index] = 1 def check(self, item: str) -> bool: Checks if an item is possibly in the set. for i in range(self.hash_count): index = self._hash(item, i) if self.bit_array[index] == 0: return False return True"},{"question":"# Task: Create a function in Python that finds the deepest left leaf node in a binary tree and returns its value. # Function Signature: ```python def deepest_left_leaf(root: None | BinaryTreeNode) -> None | int: ``` # Input Parameters: - `root`: The root node of the binary tree (`BinaryTreeNode` or `None`). # Output: - Return the value of the deepest left leaf node if it exists, otherwise return `None`. # Constraints: - The values of the nodes are integers. - The number of nodes in the binary tree can be up to 10,000. - The binary tree may be empty. # Performance Requirements: - The solution should operate in O(n) time complexity where n is the number of nodes in the tree. - The space complexity can be up to O(h) where h is the height of the tree due to the recursion stack. # Examples: ```python # Example 1: # 1 # / # 2 3 # # 4 # # 5 # deepest_left_leaf(root) should return 2 # Example 2: # 1 # / # 2 # / # 3 # / # 4 # deepest_left_leaf(root) should return 4 # Example 3: # None (An empty tree) # deepest_left_leaf(None) should return None def deepest_left_leaf_example(): # Example 1 root1 = BinaryTreeNode(1) root1.left_child = BinaryTreeNode(2) root1.right_child = BinaryTreeNode(3) root1.right_child.right_child = BinaryTreeNode(4) root1.right_child.right_child.right_child = BinaryTreeNode(5) assert deepest_left_leaf(root1) == 2 # Example 2 root2 = BinaryTreeNode(1) root2.left_child = BinaryTreeNode(2) root2.left_child.left_child = BinaryTreeNode(3) root2.left_child.left_child.left_child = BinaryTreeNode(4) assert deepest_left_leaf(root2) == 4 # Example 3 assert deepest_left_leaf(None) == None deepest_left_leaf_example() ```","solution":"class BinaryTreeNode: def __init__(self, value, left_child=None, right_child=None): self.value = value self.left_child = left_child self.right_child = right_child def deepest_left_leaf(root: None | BinaryTreeNode) -> None | int: if not root: return None def dfs(node, is_left, depth): nonlocal max_depth, deepest_left_leaf_value if not node: return # Check if it\'s a left leaf node if is_left and not node.left_child and not node.right_child: if depth > max_depth: max_depth = depth deepest_left_leaf_value = node.value # Traverse left and right children dfs(node.left_child, True, depth + 1) dfs(node.right_child, False, depth + 1) max_depth = -1 deepest_left_leaf_value = None dfs(root, False, 0) return deepest_left_leaf_value"},{"question":"# Matrix Determinant and Inverse Calculation You are required to implement functions to calculate the determinant and the inverse of a given square matrix. Ensure that your functions handle edge cases appropriately, such as non-invertible matrices. # Matrix Determinant Implement a function `determinant(mat: list[list[int]]) -> int` that calculates the determinant of a square matrix `mat`. - **Input**: A square matrix `mat` as a list of lists. - **Output**: An integer representing the determinant of the matrix. - **Constraint**: If the matrix is not square, raise a `ValueError`. # Matrix Inverse Implement a function `inverse(mat: list[list[int]]) -> list[list[float]]` that calculates the inverse of a square matrix `mat`. - **Input**: A square matrix `mat` as a list of lists. - **Output**: The inverse of the matrix, represented as a list of lists of floats. - **Constraint**: If the matrix is not invertible, raise a `ValueError`. # Examples ```python # Example for determinant mat1 = [[1, 2], [3, 4]] assert determinant(mat1) == -2 # Example for inverse inverse_mat1 = [[-2.0, 1.0], [1.5, -0.5]] assert inverse(mat1) == inverse_mat1 mat2 = [[4, 7], [2, 6]] assert determinant(mat2) == 10 inverse_mat2 = [[0.6, -0.7], [-0.2, 0.4]] assert inverse(mat2) == inverse_mat2 ``` Note: Use appropriate algorithms for calculating the determinant and the inverse (e.g., Gaussian elimination for finding the inverse) and ensure that your implementation is efficient for the given problem constraints.","solution":"def determinant(mat): Calculates the determinant of a square matrix. n = len(mat) if not all(len(row) == n for row in mat): raise ValueError(\\"Matrix is not square\\") if n == 1: return mat[0][0] elif n == 2: return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0] det = 0 for c in range(n): minor = [[mat[i][j] for j in range(n) if j != c] for i in range(1, n)] det += ((-1) ** c) * mat[0][c] * determinant(minor) return det def inverse(mat): Calculates the inverse of a square matrix. n = len(mat) if not all(len(row) == n for row in mat): raise ValueError(\\"Matrix is not square\\") det = determinant(mat) if det == 0: raise ValueError(\\"Matrix is not invertible\\") def get_matrix_of_minors(mat): minors = [] for i in range(n): row_minors = [] for j in range(n): minor = [[mat[x][y] for y in range(n) if y != j] for x in range(n) if x != i] row_minors.append(determinant(minor)) minors.append(row_minors) return minors minors = get_matrix_of_minors(mat) cofactors = [[minors[i][j] * ((-1) ** (i + j)) for j in range(n)] for i in range(n)] adjugate = [list(row) for row in zip(*cofactors)] inverse_matrix = [[adjugate[i][j] / det for j in range(n)] for i in range(n)] return inverse_matrix"},{"question":"# Question Write a function `convert_to_balanced_bst` that takes a sorted singly linked list representing the in-order traversal of a binary search tree (BST) and returns the root of a new BST that is height-balanced. **Function Signature**: ```python def convert_to_balanced_bst(head: ListNode) -> TreeNode: ``` **Input**: - `head` (ListNode): The head node of a singly linked list where each node contains an integer. **Output**: - The root node of a height-balanced binary search tree. **Constraints**: - The number of nodes in the linked list is in the range `[0, 10^4]`. - The singly linked list is sorted in non-decreasing order. - Duplicate values are allowed. # Examples ```python # Example 1 # Linked list: -10 -> -3 -> 0 -> 5 -> 9 head = ListNode(-10) head.next = ListNode(-3) head.next.next = ListNode(0) head.next.next.next = ListNode(5) head.next.next.next.next = ListNode(9) root = convert_to_balanced_bst(head) print(inorder_traversal(root)) # Output: [-10, -3, 0, 5, 9] # Example 2 # Linked list: 1 -> 2 -> 3 -> 4 -> 5 head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) root = convert_to_balanced_bst(head) print(inorder_traversal(root)) # Output: [1, 2, 3, 4, 5] # Example 3 # Linked list: 0 head = ListNode(0) root = convert_to_balanced_bst(head) print(inorder_traversal(root)) # Output: [0] ``` **Notes**: - A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than 1. - Ensure efficiency to handle linked lists of up to 10,000 nodes. - You may assume the linked list is not empty. # Classes Definition ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> list: if not root: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_list_to_array(head: ListNode) -> list: array = [] while head: array.append(head.val) head = head.next return array def sorted_array_to_bst(arr: list) -> TreeNode: if not arr: return None mid = len(arr) // 2 root = TreeNode(arr[mid]) root.left = sorted_array_to_bst(arr[:mid]) root.right = sorted_array_to_bst(arr[mid+1:]) return root def convert_to_balanced_bst(head: ListNode) -> TreeNode: array = sorted_list_to_array(head) return sorted_array_to_bst(array) def inorder_traversal(root: TreeNode) -> list: if not root: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)"},{"question":"# Graph Traversal: Detecting Cycles Objective Implement cycle detection algorithms in both directed and undirected graphs using Depth-First Search (DFS). You need to identify if any cycle exists in the graph and return a boolean value indicating the presence of a cycle. Problem Statement You are required to enhance the given Graph structure to support the following additional operations: 1. **Detect Cycle in Directed Graph**: Implement function to detect if there is any cycle in a directed graph. 2. **Detect Cycle in Undirected Graph**: Implement function to detect if there is any cycle in an undirected graph. Function Specifications 1. **has_cycle_directed() -> bool**: This function will determine if the directed graph contains any cycle. Returns `True` if there is a cycle, otherwise `False`. 2. **has_cycle_undirected() -> bool**: This function will determine if the undirected graph contains any cycle. Returns `True` if there is a cycle, otherwise `False`. Graph Specifications - The Graph class should support the following methods: ```python class Graph: def __init__(self): self.graph = {} def add_edge(self, from_vertex: int, to_vertex: int, directed: bool = False) -> None: Adds an edge to the graph. If the graph is directed, the edge only goes from \'from_vertex\' to \'to_vertex\'. If undirected, an edge from \'to_vertex\' to \'from_vertex\' is also added. def has_cycle_directed() -> bool: Checks if the directed graph has any cycle. def has_cycle_undirected() -> bool: Checks if the undirected graph has any cycle. ``` Example ```python # Create a new Graph instance graph = Graph() # Add edges to the graph edges_directed = [(0, 1), (1, 2), (2, 0)] edges_undirected = [(0, 1), (1, 2), (2, 0)] # For directed graph for edge in edges_directed: graph.add_edge(edge[0], edge[1], directed=True) # Check for cycle in directed graph print(graph.has_cycle_directed()) # Output: True # Create another Graph instance for undirected graph undirected_graph = Graph() # Add edges to the undirected graph for edge in edges_undirected: undirected_graph.add_edge(edge[0], edge[1], directed=False) # Check for cycle in undirected graph print(undirected_graph.has_cycle_undirected()) # Output: True ``` Constraints - The graph vertices are represented with integers. - The functions should efficiently handle large graphs with respect to time and space complexity.","solution":"class Graph: def __init__(self): self.graph = {} def add_edge(self, from_vertex: int, to_vertex: int, directed: bool = False) -> None: if from_vertex in self.graph: self.graph[from_vertex].append(to_vertex) else: self.graph[from_vertex] = [to_vertex] if not directed: if to_vertex in self.graph: self.graph[to_vertex].append(from_vertex) else: self.graph[to_vertex] = [from_vertex] def has_cycle_directed(self) -> bool: visited = set() rec_stack = set() def dfs(vertex): visited.add(vertex) rec_stack.add(vertex) for neighbor in self.graph.get(vertex, []): if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(vertex) return False for vertex in self.graph: if vertex not in visited: if dfs(vertex): return True return False def has_cycle_undirected(self) -> bool: visited = set() def dfs(vertex, parent): visited.add(vertex) for neighbor in self.graph.get(vertex, []): if neighbor not in visited: if dfs(neighbor, vertex): return True elif neighbor != parent: return True return False for vertex in self.graph: if vertex not in visited: if dfs(vertex, -1): return True return False"},{"question":"Develop a library management system with basic functionalities to handle books and members. The system should support operations such as adding and removing books, registering and deregistering members, issuing and returning books, and checking the availability of books. Each book has a unique identifier (ISBN), title, and author. Each member has a unique member ID and name. # Implementation Details Implement the class `LibraryManagementSystem` that supports the following methods: 1. `__init__(self) -> None`: - Initializes an empty library system with no books or members. 2. `add_book(self, isbn: str, title: str, author: str) -> None`: - Adds a book to the library. Raises `ValueError` if the book with the same ISBN already exists. 3. `remove_book(self, isbn: str) -> None`: - Removes a book from the library. Raises `ValueError` if the book does not exist. 4. `register_member(self, member_id: str, name: str) -> None`: - Registers a new member in the library. Raises `ValueError` if a member with the same ID already exists. 5. `deregister_member(self, member_id: str) -> None`: - Deregisters a member from the library. Raises `ValueError` if the member does not exist. 6. `issue_book(self, book_isbn: str, member_id: str) -> None`: - Issues a book to a member. Raises `ValueError` if the book is not available or the member does not exist. 7. `return_book(self, book_isbn: str, member_id: str) -> None`: - Returns a book to the library. Raises `ValueError` if the book was not issued to the member. 8. `is_book_available(self, book_isbn: str) -> bool`: - Returns `True` if the book is available in the library, `False` otherwise. 9. `list_available_books(self) -> list[dict]`: - Returns a list of dictionaries with information of all available books (ISBN, title, author). # Constraints - Each book\'s ISBN is unique. - Each member ID is unique. - A book can only be issued to one member at a time. - Duplicate books or members should raise appropriate exceptions. # Example ```python library = LibraryManagementSystem() library.add_book(\'123456\', \'Book Title 1\', \'Author 1\') library.add_book(\'789101\', \'Book Title 2\', \'Author 2\') library.register_member(\'member1\', \'Alice\') library.register_member(\'member2\', \'Bob\') library.issue_book(\'123456\', \'member1\') assert library.is_book_available(\'123456\') == False assert library.is_book_available(\'789101\') == True library.return_book(\'123456\', \'member1\') assert library.is_book_available(\'123456\') == True library.deregister_member(\'member2\') library.remove_book(\'789101\') assert library.is_book_available(\'789101\') == False assert library.list_available_books() == [{\'isbn\': \'123456\', \'title\': \'Book Title 1\', \'author\': \'Author 1\'}] ``` # Notes - Properly handle edge cases such as trying to issue a non-existent book or deregister a non-existent member. - The system should ensure the consistency of book availability status during issue and return operations. - The implementation should be efficient and handle multiple operations seamlessly.","solution":"class LibraryManagementSystem: def __init__(self) -> None: self.books = {} self.members = {} self.issued_books = {} def add_book(self, isbn: str, title: str, author: str) -> None: if isbn in self.books: raise ValueError(\'Book with the same ISBN already exists.\') self.books[isbn] = {\'title\': title, \'author\': author} def remove_book(self, isbn: str) -> None: if isbn not in self.books: raise ValueError(\'Book does not exist.\') if isbn in self.issued_books: raise ValueError(\'Book is currently issued and cannot be removed.\') del self.books[isbn] def register_member(self, member_id: str, name: str) -> None: if member_id in self.members: raise ValueError(\'Member with the same ID already exists.\') self.members[member_id] = name def deregister_member(self, member_id: str) -> None: if member_id not in self.members: raise ValueError(\'Member does not exist.\') if any(member_id == value for value in self.issued_books.values()): raise ValueError(\'Member currently has a book issued and cannot be deregistered.\') del self.members[member_id] def issue_book(self, book_isbn: str, member_id: str) -> None: if book_isbn not in self.books: raise ValueError(\'Book does not exist.\') if book_isbn in self.issued_books: raise ValueError(\'Book is not available.\') if member_id not in self.members: raise ValueError(\'Member does not exist.\') self.issued_books[book_isbn] = member_id def return_book(self, book_isbn: str, member_id: str) -> None: if book_isbn not in self.issued_books: raise ValueError(\'Book was not issued.\') if self.issued_books[book_isbn] != member_id: raise ValueError(\'Book was not issued to this member.\') del self.issued_books[book_isbn] def is_book_available(self, book_isbn: str) -> bool: if book_isbn not in self.books: return False if book_isbn in self.issued_books: return False return True def list_available_books(self) -> list: available_books = [] for isbn, info in self.books.items(): if isbn not in self.issued_books: available_books.append({\'isbn\': isbn, \'title\': info[\'title\'], \'author\': info[\'author\']}) return available_books"},{"question":"# Log File Analyzer You are tasked to develop a simple log file analyzer that processes server log entries to extract information regarding the number of requests made by each IP address. # Requirements: 1. **Input**: A string representing the path to the log file. 2. **Output**: A dictionary where keys are IP addresses and values are the count of requests made by each IP address. 3. **Function Implementation**: Write a function `analyze_log_file(log_file_path: str) -> dict[str, int]`. # Constraints: 1. The log file format follows the pattern `[IP Address] - - [Date/Time] \\"Request Method URL Protocol\\" [Status Code] [Size]`. 2. The log file may contain several lines, each representing a separate request. 3. Handle errors gracefully and ignore malformed lines while processing the log file. # Example: ```python def analyze_log_file(log_file_path: str) -> dict[str, int]: # Your implementation # Test case logs = analyze_log_file(\\"/path/to/access.log\\") for ip, count in sorted(logs.items()): print(f\\"{ip}: {count} requests\\") ``` # Scenario: Imagine you are maintaining a web server and need to analyze access logs to monitor traffic patterns, detect unusual IP activity, and ensure a balanced load on your server. Your function should parse the log file efficiently, counting the number of requests from each IP address. # Notes: - Assume that each log line is well-formatted but gracefully handle lines that do not conform to the expected format. - Consider using regular expressions to extract the necessary information from each log line. - Optimize the function to handle potentially large log files without excessive memory usage or degradation in performance.","solution":"import re from collections import defaultdict def analyze_log_file(log_file_path: str) -> dict[str, int]: Analyzes the log file and returns a dictionary with the count of requests made by each IP address. Parameters: log_file_path (str): The path to the log file. Returns: dict[str, int]: A dictionary with IP addresses as keys and their request counts as values. ip_pattern = re.compile(r\'(d+.d+.d+.d+)\') ip_count = defaultdict(int) try: with open(log_file_path, \'r\') as file: for line in file: match = ip_pattern.match(line) if match: ip_address = match.group(1) ip_count[ip_address] += 1 except FileNotFoundError: print(f\\"File not found: {log_file_path}\\") except IOError: print(f\\"Error reading file: {log_file_path}\\") return dict(ip_count)"},{"question":"# Coding Assessment Question You are given a string consisting of lower case English letters and an integer `k`. Your task is to modify the string such that no two adjacent characters are the same, and the distance between the same character is at least `k`. If it is not possible to rearrange the string to meet these requirements, return an empty string. Use a greedy algorithm to solve the problem. Input - A string `s` consisting of lower case English letters. - An integer `k` which represents the minimum distance between the same characters. Output - A modified string that meets the requirements, or an empty string if it is not possible. Constraints - `1 <= len(s) <= 10^5` - `1 <= k <= len(s)` Performance Requirements - The implemented algorithm should run in linear time complexity relative to the length of the string. Example Input: ```python s = \\"aabbcc\\" k = 3 ``` Output: ```python \\"abcabc\\" ``` Input: ```python s = \\"aaabc\\" k = 2 ``` Output: ```python \\"abaca\\" ``` Input: ```python s = \\"aaabc\\" k = 3 ``` Output: ```python \\"\\" ``` Requirements Implement the following function: ```python def rearrange_string(s: str, k: int) -> str: This function rearranges the input string such that no two adjacent characters are the same, and the distance between the same character is at least k. Parameters: s (str): The input string. k (int): The minimum distance between the same characters. Returns: str: The rearranged string or an empty string if it is not possible. # Your implementation here ``` Make sure to handle edge cases regarding input validity and ensure your implementation adheres to the expected time complexity.","solution":"def rearrange_string(s: str, k: int) -> str: This function rearranges the input string such that no two adjacent characters are the same, and the distance between the same character is at least k. Parameters: s (str): The input string. k (int): The minimum distance between the same characters. Returns: str: The rearranged string or an empty string if it is not possible. if k == 0: return s # No constraints if k is 0 from collections import Counter import heapq char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((count + 1, char)) if len(wait_queue) >= k: front = wait_queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) return \'\'.join(result) if len(result) == len(s) else \'\'"},{"question":"# Social Network Influencer Recommendation You are tasked with designing an influencer recommendation system for a social network platform. The social network is represented as a directed graph where each node represents a user and each directed edge from user A to user B indicates that user A follows user B. Your objective is to recommend top K influencers for a user based on their follower count. Input and Output: - **Input**: * A dictionary \'graph\' where keys are user IDs and values are lists of user IDs representing the users followed by the key user. * An integer \'user_id\' representing the ID of the user for whom influencers are being recommended. * An integer \'K\' representing the number of top influencers to recommend. - **Output**: * A list of tuples where each tuple contains two elements: * An integer representing the user ID of the recommended influencer. * An integer representing the number of followers the influencer has. * The list should be sorted by the number of followers in descending order. If two influencers have the same number of followers, then sort by user ID in ascending order. * If less than K influencers exist, return the list with all available influencers. * If no influencers exist for the given user, return an empty list. Constraints: - The graph contains up to 10,000 users. - Each user may follow up to 1,000 other users. - The graph may not necessarily be connected. - User IDs are unique positive integers. Example: ```python graph = { 1: [2, 3, 4], 2: [3, 4], 3: [4], 4: [] } user_id = 1 K = 2 # Expected Output: [(4, 3), (3, 2)] print(recommend_influencers(graph, user_id, K)) ``` Function Signature: ```python def recommend_influencers(graph: Dict[int, List[int]], user_id: int, K: int) -> List[Tuple[int, int]]: pass ``` Provide the implementation for the `recommend_influencers` function, ensuring it handles all constraints and edge cases listed above.","solution":"def recommend_influencers(graph, user_id, K): Recommends the top K influencers for a given user based on the follower count. from collections import defaultdict import heapq if user_id not in graph: return [] # Calculate followers count for each user followers_count = defaultdict(int) for followers in graph.values(): for user in followers: followers_count[user] += 1 # Get the list of users followed by the given user followed_users = graph[user_id] # If followed_users is empty, return an empty list if not followed_users: return [] # List to store followers count for each followed user influencers = [(followers_count[u], u) for u in followed_users] # Sort in descending order by number of followers, and by user id in ascending order if equal influencers.sort(key=lambda x: (-x[0], x[1])) # Return the top K influencers return [(u, count) for count, u in influencers[:K]]"},{"question":"# Coding Assessment Question Problem Description: You are given a list of integers, where each integer represents the height of a container\'s wall at different positions. Your task is to calculate the maximum amount of water that can be trapped between the walls after raining. Implement the following function: ```python def trap_water(heights: list[int]) -> int: ``` Expected Input and Output: * **Input**: A list of integers (heights) where each integer represents the height of the wall at that position. * Constraints: 1 <= len(heights) <= 10^5, 0 <= heights[i] <= 10^4 * **Output**: An integer representing the maximum amount of water that can be trapped between the walls. Context: This problem can be solved using a two-pointer technique or dynamic programming to efficiently calculate the amount of trapped water, and has applications in computational geometry, fluid dynamics, and land-use planning. Example ```python assert trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trap_water([4, 2, 0, 3, 2, 5]) == 9 assert trap_water([1, 1, 1, 1, 1, 1]) == 0 assert trap_water([5, 4, 1, 2]) == 1 ``` **Note**: 1. The water trapped at a particular position is determined by the minimum of the maximum heights to the left and right of that position minus the height at that position. 2. Focus on both time and space optimization for large inputs. Constraints: - The solution must be efficient with a time complexity of O(n) and space complexity of O(1) if using a two-pointer technique, or O(n) if using additional arrays for dynamic programming.","solution":"def trap_water(heights: list[int]) -> int: if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) trapped += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped += right_max - heights[right] return trapped"},{"question":"# Question: Implement a Moving Average Filter for a List of Data Points Context A moving average filter is used to smooth out short-term fluctuations and highlight longer-term trends in a dataset. You are tasked with implementing this filter for a custom data type representing data points over time. Objective Write a Python function `moving_average_filter` that takes a list of `DataPoint` objects and computes the moving average of their values over a specified window size. # Requirements 1. **Class Definition**: Define a `DataPoint` class to represent a single data point with attributes `timestamp` and `value`. 2. **Function Definition**: Implement a `moving_average_filter` function: ```python def moving_average_filter(data_points: List[DataPoint], window_size: int) -> List[float]: ``` Input Format - `data_points`: A list of `DataPoint` objects. - Each `DataPoint` contains `timestamp` (int) representing the time at which the data point was recorded, and `value` (float) representing the measurement at that time. - `window_size`: An integer representing the size of the moving window. Output Format - A list of floats, where each entry represents the moving average of the values of the corresponding `DataPoint` over the specified window. Constraints - The `window_size` must be a positive integer. - The input list `data_points` can have any length, including length 0. - The `timestamp` attributes of `DataPoint` objects are always in non-decreasing order. - If the number of data points is less than the `window_size`, the function should return an empty list. - Ensure robustness against edge cases such as an empty input list. Example Usage ```python class DataPoint: def __init__(self, timestamp: int, value: float): self.timestamp = timestamp self.value = value def moving_average_filter(data_points: List[DataPoint], window_size: int) -> List[float]: pass # Example DataPoints data = [ DataPoint(1, 10.0), DataPoint(2, 20.0), DataPoint(3, 30.0), DataPoint(4, 40.0), DataPoint(5, 50.0) ] # Function Call result = moving_average_filter(data, 3) print(result) # Expected output might look similar to: [20.0, 30.0, 40.0] ``` # Guidelines: - Ensure the class attributes can be accessed and modified appropriately. - Utilize efficient algorithms to compute the moving average to handle large datasets. - Validate and document the solution adequately.","solution":"from typing import List class DataPoint: def __init__(self, timestamp: int, value: float): self.timestamp = timestamp self.value = value def moving_average_filter(data_points: List[DataPoint], window_size: int) -> List[float]: if not data_points or window_size <= 0 or window_size > len(data_points): return [] moving_averages = [] window_sum = sum(data_points[i].value for i in range(window_size)) # Calculate the first moving average moving_averages.append(window_sum / window_size) # Calculate the rest of the moving averages for i in range(window_size, len(data_points)): window_sum += data_points[i].value - data_points[i - window_size].value moving_averages.append(window_sum / window_size) return moving_averages"},{"question":"# Question: Depth-First Search in a Graph Consider the implementation of a basic Graph provided below in Python. Your task is to extend the functionality of this Graph by implementing the following functions: 1. `def depth_first_search(self, start: int) -> List[int]`: - **Description**: This function should perform a depth-first search (DFS) starting from the given node and return a list of nodes in the order they were visited. - **Input**: An integer `start` representing the starting node for the DFS. - **Output**: A list of integers representing the nodes in the order they were visited during the DFS. If the start node does not exist, return an empty list. 2. `def is_cyclic(self) -> bool`: - **Description**: This function should determine whether the graph contains a cycle. - **Input**: No input. - **Output**: A boolean value `True` if the graph contains a cycle, otherwise `False`. # Graph Class ```python class Graph: def __init__(self): self.graph = {} def add_edge(self, u: int, v: int): if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append(v) def insert_many(self, edges: List[Tuple[int, int]]): for u, v in edges: self.add_edge(u, v) ``` # Example ```python edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] graph = Graph() graph.insert_many(edges) # Example for depth_first_search function assert graph.depth_first_search(2) == [2, 0, 1, 3] # Example for is_cyclic function assert graph.is_cyclic() == True # Additional Test Case edges = [(0, 1), (1, 2), (2, 3)] graph = Graph() graph.insert_many(edges) assert graph.depth_first_search(0) == [0, 1, 2, 3] assert graph.is_cyclic() == False ``` # Constraints - Assume nodes are labeled with non-negative integers. - Handle edge cases such as an empty graph or non-existent start node for DFS functions. - Do not modify the given Graph class except for adding the new methods. # Performance Requirements - The DFS function should aim for O(V + E) time complexity, where V is the number of vertices and E is the number of edges. - The cycle detection function should also aim for O(V + E) time complexity.","solution":"from typing import List, Tuple class Graph: def __init__(self): self.graph = {} def add_edge(self, u: int, v: int): if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append(v) def insert_many(self, edges: List[Tuple[int, int]]): for u, v in edges: self.add_edge(u, v) def depth_first_search(self, start: int) -> List[int]: if start not in self.graph: return [] visited = set() result = [] def dfs(node): visited.add(node) result.append(node) for neighbor in self.graph[node]: if neighbor not in visited: dfs(neighbor) dfs(start) return result def is_cyclic(self) -> bool: visited = set() rec_stack = set() def is_cyclic_util(v): visited.add(v) rec_stack.add(v) for neighbor in self.graph[v]: if neighbor not in visited: if is_cyclic_util(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for node in self.graph: if node not in visited: if is_cyclic_util(node): return True return False"},{"question":"# Prime Numbers Between Two Intervals Write a function `find_primes_interval` that determines all prime numbers between two given positive integers `start` and `end` (inclusive). The function should return a list of prime numbers found within the given interval. # Function Signature ```python def find_primes_interval(start: int, end: int) -> list[int]: pass ``` # Input * **start** (int) - The starting value of the interval. * **end** (int) - The ending value of the interval. # Output * **primes** (list of int) - A list containing all prime numbers between `start` and `end` inclusive. If no primes are found, return an empty list. # Constraints * 0 <= start <= end <= 10^6 # Example ```python result = find_primes_interval(10, 50) print(result) # Output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] ``` # Notes * A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. * Ensure to handle cases when `start` and `end` are very close to each other or when the interval contains no prime numbers. * Optimize your solution to handle large intervals efficiently, potentially using the Sieve of Eratosthenes.","solution":"def find_primes_interval(start: int, end: int) -> list[int]: Returns a list of prime numbers between start and end (inclusive). if end < 2: return [] sieve_end = end + 1 sieve = [True] * sieve_end sieve[0] = sieve[1] = False # Implementing Sieve of Eratosthenes p = 2 while p * p <= end: if sieve[p]: for multiple in range(p * p, sieve_end, p): sieve[multiple] = False p += 1 primes = [num for num in range(max(2, start), end + 1) if sieve[num]] return primes"},{"question":"# Question: Implement a Priority Queue using a min-heap You are to build a priority queue using a min-heap data structure. Write a class `PriorityQueue` with the following methods: 1. **Constructor `__init__(self)`**: - Initializes the priority queue. 2. **Method `insert(self, key: int) -> None`**: - Inserts a new key into the priority queue. 3. **Method `get_min(self) -> int`**: - Returns the smallest key in the priority queue without removing it. If the queue is empty, it raises an `IndexError` with a message \\"Priority queue is empty.\\" 4. **Method `extract_min(self) -> int`**: - Removes and returns the smallest key in the priority queue. If the queue is empty, it raises an `IndexError` with a message \\"Priority queue is empty.\\" # Example ```python pq = PriorityQueue() pq.insert(10) pq.insert(4) pq.insert(15) pq.insert(20) print(pq.get_min()) # Output: 4 print(pq.extract_min()) # Output: 4 print(pq.get_min()) # Output: 10 pq.insert(2) print(pq.get_min()) # Output: 2 print(pq.extract_min()) # Output: 2 print(pq.extract_min()) # Output: 10 print(pq.extract_min()) # Output: 15 try: print(pq.get_min()) # This should raise IndexError except IndexError as e: print(e) # Output: Priority queue is empty ``` # Constraints - You must implement the priority queue using a min-heap data structure. - No additional libraries or modules should be used to handle the heap (e.g., no using `heapq`). - The queue must support operations in a time complexity of O(log n) for insert and extract-min operations. - Keys to be inserted are all integers and can be positive or negative. Use these constraints and aspects to guide your implementation process.","solution":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, key: int) -> None: self.heap.append(key) self._heapify_up(len(self.heap) - 1) def get_min(self) -> int: if not self.heap: raise IndexError(\\"Priority queue is empty\\") return self.heap[0] def extract_min(self) -> int: if not self.heap: raise IndexError(\\"Priority queue is empty\\") if len(self.heap) == 1: return self.heap.pop() min_element = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_element def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Coding Assessment Question **Problem Statement**: A hexagonal number is a figurate number of a hexagon. The nth hexagonal number (H(n)) is given by the formula `H(n) = n(2n - 1)`. The first few hexagonal numbers are: 1, 6, 15, 28, 45, 66, 91, 120, 153, 190, ... Interestingly, some hexagonal numbers are also triangular numbers. Triangular numbers are generated by the formula (T(n) = frac{n(n+1)}{2}). Write a function that finds the first `n` hexagonal numbers that are also triangular numbers. Return these numbers in a list. **Function Signature**: ```python def find_triangular_hexagonal_numbers(n: int) -> list: pass ``` **Input**: - `n` (int): The number of triangular hexagonal numbers to find. **Output**: - (list): A list of the first `n` hexagonal numbers that are also triangular. **Constraints**: - 1 <= n <= 10 **Examples**: ```python >>> find_triangular_hexagonal_numbers(3) [1, 6, 15] ``` **Guidelines**: * Implement the helper function `is_triangular(number: int) -> bool` to check if a given number is triangular. * Ensure your implementation is efficient and handles edge cases correctly. * Thoroughly test your function with various values of `n` to ensure correctness. **Hints**: - Utilize the properties of triangular and hexagonal number formulas to optimize the search. - Consider precomputing triangular numbers up to a certain limit to speed up the checking process.","solution":"def is_triangular(number: int) -> bool: # A number is triangular if and only if 8*number + 1 is a perfect square import math x = 8 * number + 1 sqrt_x = int(math.isqrt(x)) return sqrt_x * sqrt_x == x def find_triangular_hexagonal_numbers(n: int) -> list: result = [] index = 1 while len(result) < n: hexagonal_number = index * (2 * index - 1) if is_triangular(hexagonal_number): result.append(hexagonal_number) index += 1 return result"},{"question":"Implement a Python function `find_majority_element` that takes a list of integers and determines if there is a majority element. A majority element is an element that appears more than half the time in the list. If such an element exists, return it; otherwise, return `None`. # Requirements: 1. The function must handle edge cases such as an empty list or a list with only one element. 2. The algorithm should be efficient in terms of time complexity, ideally O(n). # Input: - `nums`: A list of integers which can include positive and negative values, and zero. # Output: - The majority element if it exists, otherwise `None`. # Function Signature ```python def find_majority_element(nums: list[int]) -> Optional[int]: pass ``` # Example ```python # Example usage: # List has a majority element: print(find_majority_element([3, 3, 4, 2, 3, 3, 3])) # Output: 3 # List does not have a majority element: print(find_majority_element([1, 2, 3, 4, 5])) # Output: None # List with a single element: print(find_majority_element([10])) # Output: 10 # Empty list: print(find_majority_element([])) # Output: None ``` # Constraints: - The input list can be of any length, including zero. - The function should handle various integer values, both positive and negative. # Notes: - You may use the Boyer-Moore Voting Algorithm to solve this problem efficiently. - Ensure appropriate error handling for edge cases. - The function should return `None` if no majority element is found.","solution":"from typing import Optional, List def find_majority_element(nums: List[int]) -> Optional[int]: Finds the majority element in the list of integers. A majority element is an element that appears more than half the time in the list. Returns the majority element if found, otherwise returns None. if not nums: return None # Boyer-Moore Voting Algorithm majority_candidate = None count = 0 for num in nums: if count == 0: majority_candidate = num count += (1 if num == majority_candidate else -1) # Verify that the candidate is actually the majority element if nums.count(majority_candidate) > len(nums) // 2: return majority_candidate else: return None"},{"question":"# Problem Statement Implement a function to find the maximum sum of non-adjacent numbers in a list. # Description You are given a list of integers. You need to find the maximum sum of non-adjacent numbers, which means that no two elements that are picked are next to each other in the list. # Objective Write a function `max_non_adjacent_sum` that calculates the maximum possible sum of non-adjacent numbers in the given list. # Function Signature ```python def max_non_adjacent_sum(nums: List[int]) -> int: pass ``` # Input - **nums** (List[int]): a list of integers, nums, where ( 0 leq |nums| leq 10^4 ). # Output - Return the maximum sum of non-adjacent numbers as an integer. # Constraints - The input list can be empty, in which case the function should return 0. - Elements in the list can be negative, zero, or positive. # Examples **Example 1:** ```python nums = [4, 1, 1, 4, 2, 1] print(max_non_adjacent_sum(nums)) # Expected output: 9 ``` **Example 2:** ```python nums = [3, 2, 5, 10, 7] print(max_non_adjacent_sum(nums)) # Expected output: 15 ``` **Example 3:** ```python nums = [] print(max_non_adjacent_sum(nums)) # Expected output: 0 ``` **Example 4:** ```python nums = [3, 2, 7, 10] print(max_non_adjacent_sum(nums)) # Expected output: 13 ``` **Example 5:** ```python nums = [-2, 1, 3, -4, 5] print(max_non_adjacent_sum(nums)) # Expected output: 8 ``` # Hints 1. Consider the optimal substructure nature of the problem and use dynamic programming to break it down into smaller subproblems. 2. Use two variables to keep track of maximum sums ending at the previous element and the one before that. 3. Use a bottom-up approach to build up the solution.","solution":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: Calculate the maximum sum of non-adjacent numbers in the list. if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) prev1 = 0 prev2 = 0 for num in nums: current = max(prev1, prev2 + num) prev2 = prev1 prev1 = current return prev1"},{"question":"**Problem Statement:** You are given a singly linked list where each node contains an integer value. Your task is to implement a function that sorts the list using merge sort. The linked list should be sorted in non-decreasing order. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def sort_linked_list(head: ListNode) -> ListNode: pass ``` # Input * A singly linked list `head` where each node contains an integer value. The linked list can contain between 0 and 10^5 nodes. * Each node\'s integer value can range from -10^9 to 10^9. # Output * The function should return the head of the sorted linked list. # Constraints * Your solution should have an average case time complexity of O(n log n), where n is the number of nodes in the linked list. * The linked list should be sorted in-place with only O(1) extra memory used for pointers (excluding the stack space for recursion if implemented). # Example ```python # Helper function to create a linked list from a list and to print a linked list def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head def print_linked_list(head): result = [] while head: result.append(head.val) head = head.next print(result) arr = [4, 2, 1, 3] head = create_linked_list(arr) sorted_head = sort_linked_list(head) print_linked_list(sorted_head) # Output should be [1, 2, 3, 4] ``` # Requirements * Your function should sort the linked list by leveraging the merge sort algorithm. * Consider edge cases such as a linked list with a single element, already sorted lists, lists with duplicate values, and empty lists. * Ensure your code handles large inputs efficiently. # Notes * You may use helper functions if necessary. * Avoid using Python’s built-in sort functions and libraries directly. * Ensure the linked list is re-arranged properly and efficiently with minimal space overhead.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort(head: ListNode) -> ListNode: if not head or not head.next: return head def split_list(node): slow = node fast = node.next while fast and fast.next: slow = slow.next fast = fast.next.next mid = slow.next slow.next = None return node, mid def merge_lists(l1, l2): dummy = ListNode() pointer = dummy while l1 and l2: if l1.val < l2.val: pointer.next = l1 l1 = l1.next else: pointer.next = l2 l2 = l2.next pointer = pointer.next if l1: pointer.next = l1 else: pointer.next = l2 return dummy.next left, right = split_list(head) left = merge_sort(left) right = merge_sort(right) return merge_lists(left, right) def sort_linked_list(head: ListNode) -> ListNode: return merge_sort(head)"},{"question":"# Problem Statement As a software developer, you are required to prepare a function that performs data analysis on a large collection of sensors in a weather monitoring system. Given a list of dictionaries where each dictionary represents a sensor\'s data for a specific day, you need to extract and process specific details to generate meaningful insights. Each sensor data has readings for the maximum and minimum temperatures of the day. # Requirements 1. Implement a function `calculate_avg_min_max_temperatures` to compute the average minimum and maximum temperatures based on all the sensors\' data for a given number of days. 2. Implement a function `count_extreme_temperature_days` to identify how many days experienced extreme temperatures compared to the provided thresholds. # Function Signatures ```python def calculate_avg_min_max_temperatures(sensor_data: List[Dict[str, int]]) -> Tuple[float, float]: # Your code here def count_extreme_temperature_days(sensor_data: List[Dict[str, int]], min_threshold: int, max_threshold: int) -> int: # Your code here ``` # Input - `sensor_data` (List[Dict[str, int]]): A list of dictionaries. Each dictionary contains: - `max_temp` (int): Maximum temperature recorded by the sensor on a particular day in degrees Celsius. - `min_temp` (int): Minimum temperature recorded by the sensor on a particular day in degrees Celsius. - `min_threshold` (int): Threshold for the minimum temperature regarded as extreme in degrees Celsius. - `max_threshold` (int): Threshold for the maximum temperature regarded as extreme in degrees Celsius. # Output - `avg_min_temp` (float): The average minimum temperature derived from the sensor data. - `avg_max_temp` (float): The average maximum temperature derived from the sensor data. - `extreme_days_count` (int): The count of days with temperatures exceeding specified thresholds. # Constraints - The sensor_data list will have at least one dictionary. - Temperature values are within the range of -100 to 100 degrees Celsius. - Threshold values will be reasonable temperature values within the usual atmospheric range. # Example ```python # Example 1: data = [ {\'max_temp\': 30, \'min_temp\': 15}, {\'max_temp\': 25, \'min_temp\': 10}, {\'max_temp\': 35, \'min_temp\': 20}, ] avg_min_temp, avg_max_temp = calculate_avg_min_max_temperatures(data) assert avg_min_temp == 15.0 assert avg_max_temp == 30.0 extreme_days = count_extreme_temperature_days(data, 12, 33) assert extreme_days == 2 # Example 2: data = [ {\'max_temp\': -5, \'min_temp\': -20}, {\'max_temp\': 0, \'min_temp\': -15}, {\'max_temp\': 5, \'min_temp\': -10}, ] avg_min_temp, avg_max_temp = calculate_avg_min_max_temperatures(data) assert avg_min_temp == -15.0 assert avg_max_temp == 0.0 extreme_days = count_extreme_temperature_days(data, -18, 4) assert extreme_days == 2 ``` # Explanation 1. `calculate_avg_min_max_temperatures` computes the average minimum and maximum temperatures by aggregating sensor data over a list of entries. 2. `count_extreme_temperature_days` identifies the number of days where the recorded temperatures exceed specified minimum and maximum thresholds. 3. These functions assist in analyzing temperature data for identifying trends and anomalous weather patterns. 4. Ensure correct and efficient implementation, considering potential edge cases.","solution":"from typing import List, Dict, Tuple def calculate_avg_min_max_temperatures(sensor_data: List[Dict[str, int]]) -> Tuple[float, float]: total_min_temp = 0 total_max_temp = 0 num_days = len(sensor_data) for data in sensor_data: total_min_temp += data[\'min_temp\'] total_max_temp += data[\'max_temp\'] avg_min_temp = total_min_temp / num_days avg_max_temp = total_max_temp / num_days return avg_min_temp, avg_max_temp def count_extreme_temperature_days(sensor_data: List[Dict[str, int]], min_threshold: int, max_threshold: int) -> int: extreme_days_count = 0 for data in sensor_data: if data[\'min_temp\'] < min_threshold or data[\'max_temp\'] > max_threshold: extreme_days_count += 1 return extreme_days_count"},{"question":"# Vehicle Fleet Traffic Analysis Background: In a traffic management system, analyzing vehicle positions and speeds at various times is crucial for optimizing traffic flow and avoiding congestion. Each vehicle can be represented by its current position and speed. Vehicles might form \\"fleets\\" where a fleet is a sequence of vehicles traveling at the same speed and starting at the same time. Whenever a slow vehicle in front causes faster vehicles behind it to slow down, it also becomes part of the same fleet. Task: You are required to implement the function `num_fleets` to determine how many separate fleets will arrive at the target destination. Assume all vehicles begin driving simultaneously and move towards the target along the same path. Function Signature: ```python def num_fleets(target: int, position: list, speed: list) -> int: Calculate the number of separate fleets of vehicles. Parameters: target (int): The destination point for the vehicles. position (list): List of initial positions of the vehicles. speed (list): List of speeds of the vehicles. Returns: int: Number of distinct fleets that will arrive at the target. ``` Example Tests: ```python >>> num_fleets(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]) 3 >>> num_fleets(10, [3], [3]) 1 >>> num_fleets(100, [10, 30, 50, 70, 90], [1, 1, 1, 1, 1]) 5 >>> num_fleets(100, [40, 60, 20], [4, 2, 3]) 2 >>> num_fleets(50, [], []) 0 ``` Constraints: * Vehicles are defined by their positional arrays and speed arrays, where `position[i]` and `speed[i]` represent the initial position and speed of the i-th vehicle. * The target destination and positions will be non-negative integers, and speeds will be positive integers. * The lengths of position and speed lists are equal. * Ensure the function handles edge cases, such as no vehicles or all vehicles starting from the same position. # Explanation: To determine the number of fleets: 1. Determine the time each vehicle takes to reach the target. 2. Sort the vehicles based on their initial positions. 3. Traverse from the vehicle closest to the target to the farthest. 4. Track the number of fleets by monitoring changes in arrival times due to vehicles catching up with each other.","solution":"def num_fleets(target: int, position: list, speed: list) -> int: Calculate the number of separate fleets of vehicles. Parameters: target (int): The destination point for the vehicles. position (list): List of initial positions of the vehicles. speed (list): List of speeds of the vehicles. Returns: int: Number of distinct fleets that will arrive at the target. if not position or not speed: return 0 vehicles = sorted(zip(position, speed), reverse=True) times = [(target - pos) / spd for pos, spd in vehicles] fleets = 0 curr_time = 0 for time in times: if time > curr_time: fleets += 1 curr_time = time return fleets"},{"question":"# Problem Statement You are approached by a team of data analysts working for a customer relationship management (CRM) company. They need a utility function that can process customer data and segment their customers by age groups. The company\'s customer data is provided as a list of integers, each representing a customer\'s age. Your task is to write a function that segments these ages into predefined age groups and returns the frequency count for each group. The predefined age groups are: - `0-18` - `19-35` - `36-50` - `51-100` - `100+` Implement a function `segment_ages(ages: List[int]) -> Dict[str, int]` that takes a list of ages and returns a dictionary where the keys are the group labels (`\\"0-18\\"`, `\\"19-35\\"`, `\\"36-50\\"`, `\\"51-100\\"`, `\\"100+\\"`) and the values are the counts of how many ages fall into each group. Input: * `ages`: A list of integers where 0 <= age <= 200. Output: * Returns a dictionary with the age groups as keys and their corresponding counts as values. Example: * `segment_ages([10, 20, 34, 50, 85, 102, 17, 33, 41])` should return * `{\'0-18\': 2, \'19-35\': 3, \'36-50\': 2, \'51-100\': 1, \'100+\': 1}`. * `segment_ages([1, 5, 75, 120, 35, 19, 45, 50])` should return * `{\'0-18\': 2, \'19-35\': 2, \'36-50\': 2, \'51-100\': 1, \'100+\': 1}`. Constraints: * Ensure the function handles a large list of ages efficiently. * Consider edge cases such as an empty list or ages exactly on the boundaries of the groups. Notes: * Do not assume that the input list is pre-sorted. * Make sure to handle cases where the age might fall outside the generally expected human lifespan.","solution":"from typing import List, Dict def segment_ages(ages: List[int]) -> Dict[str, int]: # Initialize the dictionary with the age group labels and set counts to 0 age_groups = {\\"0-18\\": 0, \\"19-35\\": 0, \\"36-50\\": 0, \\"51-100\\": 0, \\"100+\\": 0} # Iterate through the list of ages and increment the appropriate age group count for age in ages: if 0 <= age <= 18: age_groups[\\"0-18\\"] += 1 elif 19 <= age <= 35: age_groups[\\"19-35\\"] += 1 elif 36 <= age <= 50: age_groups[\\"36-50\\"] += 1 elif 51 <= age <= 100: age_groups[\\"51-100\\"] += 1 elif age > 100: age_groups[\\"100+\\"] += 1 return age_groups"},{"question":"**Dynamic Programming: Longest Increasing Subsequence** You are working as a software engineer tasked with optimizing a recommendation system. One of the challenges involves analyzing user behavior sequences to identify the longest increasing subsequence of actions. Understanding these subsequences aids in predicting future actions more accurately. # Problem Statement You are given a list of integers representing a sequence of steps taken by a user. Your task is to determine the length of the longest increasing subsequence (LIS) within this sequence. # Task Implement the function `longest_increasing_subsequence(sequence)` that returns the length of the longest increasing subsequence in the given sequence. # Expected Input and Output Formats ```python def longest_increasing_subsequence(sequence: List[int]) -> int: pass ``` - `sequence`: A list of integers where each integer represents a step taken by a user. **Output**: An integer representing the length of the longest increasing subsequence. # Constraints 1. `1 <= len(sequence) <= 10^3` 2. `-10^6 <= sequence[i] <= 10^6` # Performance Requirements Your solution should efficiently handle sequences up to the upper constraint limit. # Scenario Consider scenarios where analyzing user behavior sequences involves steps such as purchases, clicks, or other interactions. Identifying the longest increasing subsequence can help predict sequences like promotional interests or trends in user engagement. # Example ```python sequence = [10, 22, 9, 33, 21, 50, 41, 60, 80] print(longest_increasing_subsequence(sequence)) # Output: 6 ``` In this example, the longest increasing subsequence is [10, 22, 33, 50, 60, 80], and its length is 6. **Solution Approach** A dynamic programming approach should be employed, where for each element in the sequence, you determine the length of the longest increasing subsequence ending at that element. By maintaining an array that records these longest lengths, you can derive the overall longest increasing subsequence for the sequence. --- This problem tests the candidate\'s ability to implement dynamic programming solutions and understand subsequence concepts, aligning with the complexity and style of the fractional knapsack problem.","solution":"from typing import List def longest_increasing_subsequence(sequence: List[int]) -> int: if not sequence: return 0 n = len(sequence) lis = [1] * n # Initialize LIS values for all indexes as 1 # Compute optimized LIS values in a bottom-up manner for i in range(1, n): for j in range(0, i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in LIS array return max(lis)"},{"question":"# Problem Statement: You are given a string containing a sentence. Your task is to implement the following functions: 1. **`word_count`**: Compute the number of words in the sentence. 2. **`frequency_distribution`**: Calculate the frequency of each word in the sentence. 3. **`most_frequent_word`**: Identify the word(s) with the highest frequency. If there is a tie, return a list of words sorted alphabetically. 4. **`reverse_sentence`**: Return the sentence with the words\' order reversed. 5. **`capitalize_alternate_words`**: Capitalize every alternate word in the sentence, starting with the first word. # Function Signatures: 1. **`def word_count(sentence: str) -> int:`** 2. **`def frequency_distribution(sentence: str) -> dict:`** 3. **`def most_frequent_word(sentence: str) -> list:`** 4. **`def reverse_sentence(sentence: str) -> str:`** 5. **`def capitalize_alternate_words(sentence: str) -> str:`** # Input: - `sentence`: A string representing the input sentence. Words are separated by spaces and the sentence contains only lowercase alphabetic characters and spaces. # Output: - The functions should return the required linguistic values or transformations as described in the function signatures. # Constraints: - The input sentence has at least one word and each word is composed of alphabetic characters only. - Words are separated by single spaces and there are no leading or trailing spaces. - The length of the sentence does not exceed 1000 characters. # Example: ```python # Example usage of the functions: sentence = \\"the quick brown fox jumps over the lazy dog\\" # Word Count wc = word_count(sentence) print(wc) # Output: 9 # Frequency Distribution fd = frequency_distribution(sentence) print(fd) # Output: {\'the\': 2, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 1} # Most Frequent Word mfw = most_frequent_word(sentence) print(mfw) # Output: [\'the\'] # Reverse Sentence rs = reverse_sentence(sentence) print(rs) # Output: \\"dog lazy the over jumps fox brown quick the\\" # Capitalize Alternate Words caw = capitalize_alternate_words(sentence) print(caw) # Output: \\"The quick Brown fox Jumps over The lazy Dog\\" ```","solution":"def word_count(sentence: str) -> int: Compute the number of words in the sentence. return len(sentence.split()) def frequency_distribution(sentence: str) -> dict: Calculate the frequency of each word in the sentence. words = sentence.split() freq = {} for word in words: if word in freq: freq[word] += 1 else: freq[word] = 1 return freq def most_frequent_word(sentence: str) -> list: Identify the word(s) with the highest frequency. If there is a tie, return a list of words sorted alphabetically. freq = frequency_distribution(sentence) max_freq = max(freq.values()) most_freq_words = [word for word, count in freq.items() if count == max_freq] return sorted(most_freq_words) def reverse_sentence(sentence: str) -> str: Return the sentence with the words\' order reversed. words = sentence.split() return \' \'.join(reversed(words)) def capitalize_alternate_words(sentence: str) -> str: Capitalize every alternate word in the sentence, starting with the first word. words = sentence.split() for i in range(0, len(words), 2): words[i] = words[i].capitalize() return \' \'.join(words)"},{"question":"# Coding Assessment Question **Context**: You are implementing a logging service for a multi-user application. Whenever a user performs an action, an event log is created with a unique ID, timestamp, user ID, and action description. The service should aggregate and summarize logs to monitor user activity efficiently. # Task Write a function `summarize_logs` that takes a list of event logs and returns a summary of the logs, categorized by user ID. Each user’s summary should include the total number of actions performed and a list of distinct action descriptions. # Function Signature ```python def summarize_logs(event_logs: List[Dict[str, Union[int, str]]]) -> Dict[int, Dict[str, Union[int, List[str]]]]: ``` # Input - `event_logs` (List[Dict[str, Union[int, str]]]): A list of dictionaries, where each dictionary represents an event log with the following keys: - `log_id` (int): A unique integer identifier for the log. - `timestamp` (str): The timestamp when the action occurred (ISO 8601 format). - `user_id` (int): An integer representing the user\'s ID. - `action` (str): A string describing the user\'s action. # Output - Returns a dictionary where each key is a user ID (int), and the value is another dictionary containing: - `total_actions` (int): The total number of actions performed by this user. - `distinct_actions` (List[str]): A list of distinct action descriptions performed by this user. # Constraints - Each log entry is guaranteed to have the keys `log_id`, `timestamp`, `user_id`, and `action`. - The list `event_logs` can have up to 10,000 log entries. - The function should handle logs for up to 1,000 distinct users. # Performance Requirements - The function should efficiently handle the aggregation and summarization to ensure it performs well within the given constraints. - Consider both time and space complexity when implementing the solution. # Example ```python logs = [ {\\"log_id\\": 1, \\"timestamp\\": \\"2023-10-26T14:48:00Z\\", \\"user_id\\": 101, \\"action\\": \\"login\\"}, {\\"log_id\\": 2, \\"timestamp\\": \\"2023-10-26T15:00:00Z\\", \\"user_id\\": 102, \\"action\\": \\"upload_document\\"}, {\\"log_id\\": 3, \\"timestamp\\": \\"2023-10-26T15:30:00Z\\", \\"user_id\\": 101, \\"action\\": \\"view_page\\"}, {\\"log_id\\": 4, \\"timestamp\\": \\"2023-10-26T15:45:00Z\\", \\"user_id\\": 102, \\"action\\": \\"logout\\"}, {\\"log_id\\": 5, \\"timestamp\\": \\"2023-10-26T16:00:00Z\\", \\"user_id\\": 101, \\"action\\": \\"login\\"} ] print(summarize_logs(logs)) ``` Expected Output: ```python { 101: { \\"total_actions\\": 3, \\"distinct_actions\\": [\\"login\\", \\"view_page\\"] }, 102: { \\"total_actions\\": 2, \\"distinct_actions\\": [\\"upload_document\\", \\"logout\\"] } } ``` **Note**: The order of distinct actions in the output list does not matter.","solution":"from typing import List, Dict, Union def summarize_logs(event_logs: List[Dict[str, Union[int, str]]]) -> Dict[int, Dict[str, Union[int, List[str]]]]: user_summary = {} for log in event_logs: user_id = log[\\"user_id\\"] action = log[\\"action\\"] if user_id not in user_summary: user_summary[user_id] = { \\"total_actions\\": 0, \\"distinct_actions\\": set() } user_summary[user_id][\\"total_actions\\"] += 1 user_summary[user_id][\\"distinct_actions\\"].add(action) for user_id in user_summary: user_summary[user_id][\\"distinct_actions\\"] = list(user_summary[user_id][\\"distinct_actions\\"]) return user_summary"},{"question":"# Finding the Closest Pair of Points Given a list of points in a 2D plane, write a Python function to find the closest pair of points and return the distance between them. Implement the solution using an efficient divide-and-conquer algorithm. Function Signature ```python def closest_pair_of_points(points: List[Tuple[int, int]]) -> float: ``` # Input * `points` (List[Tuple[int, int]]): A list of tuples representing the coordinates of the points in a 2D plane. For example, [(1, 2), (3, 4), (5, 6)]. # Output * (float): The distance between the closest pair of points. # Constraints * `2 <= len(points) <= 10^5` * `-10^9 <= points[i][0], points[i][1] <= 10^9` # Requirements * Implement an efficient algorithm to find the closest pair of points, ideally with a complexity of O(n log n). * Consider edge cases such as points with identical coordinates. * Use appropriate data structures to optimize the searching and sorting steps of the algorithm. * Ensure the result is accurate up to 6 decimal places. # Example Usage ```python points = [(1, 2), (3, 4), (5, 6), (7, 8)] assert closest_pair_of_points(points) == 2.828427 points = [(1, 1), (4, 4), (7, 7), (1, 2)] assert closest_pair_of_points(points) == 1.000000 points = [(1, 1), (1, 1)] assert closest_pair_of_points(points) == 0.0 points = [(-1, -1), (-4, -4), (4, 4), (4, 2)] assert closest_pair_of_points(points) == 2.0 ``` # Notes * Use `math.sqrt` for computing the Euclidean distance between two points. * Implement a helper function to compute the distance between two points. * Given the constraints, consider an approach that reduces the number of distance calculations such as the “Closest Pair of Points Algorithm” which uses divide-and-conquer. * Ensure that the solution is optimized for both performance and accuracy.","solution":"from typing import List, Tuple import math def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def closest_pair_of_points(points: List[Tuple[int, int]]) -> float: def closest_pair_recursive(px, py): if len(px) <= 3: return brute_force_closest_pair(px) mid = len(px) // 2 Qx = px[:mid] Rx = px[mid:] midpoint = px[mid][0] Qy = list(filter(lambda p: p[0] < midpoint, py)) Ry = list(filter(lambda p: p[0] >= midpoint, py)) (d1, p1) = closest_pair_recursive(Qx, Qy) (d2, p2) = closest_pair_recursive(Rx, Ry) if d1 < d2: d = d1 closest_pair = p1 else: d = d2 closest_pair = p2 (d3, p3) = closest_split_pair(px, py, d, closest_pair) if d <= d3: return (d, closest_pair) else: return (d3, p3) def brute_force_closest_pair(points): min_dist = float(\'inf\') closest_pair = (None, None) for i in range(len(points)): for j in range(i + 1, len(points)): dist = euclidean_distance(points[i], points[j]) if dist < min_dist: min_dist = dist closest_pair = (points[i], points[j]) return min_dist, closest_pair def closest_split_pair(px, py, delta, best_pair): len_px = len(px) mx = px[len_px // 2][0] sy = [point for point in py if mx - delta <= point[0] <= mx + delta] best = delta for i in range(len(sy) - 1): for j in range(i + 1, min(i + 7, len(sy))): p, q = sy[i], sy[j] dist = euclidean_distance(p, q) if dist < best: best = dist best_pair = (p, q) return best, best_pair px = sorted(points, key=lambda x: x[0]) py = sorted(points, key=lambda x: x[1]) (min_dist, closest_pair) = closest_pair_recursive(px, py) return round(min_dist, 6)"},{"question":"# Task You are provided with a function that counts digits in a string and returns their sum. However, the current implementation is tailored for ASCII characters, and you need to extend this functionality to handle a wider range of numerical Unicode digits, such as those in other numeral systems. # Requirements 1. **Function**: Implement a function `unicode_digit_sum(word: str) -> int` that computes the sum of all numerical digits in a string, supporting both ASCII and Unicode digit characters. 2. **Input**: A string `word` which may contain ASCII, Unicode digit characters, letters, and special characters. 3. **Output**: An integer which is the sum of all digits in the input string. 4. **Constraints**: * The input string will have a maximum length of 10^5 characters. # Example ```python def unicode_digit_sum(word: str) -> int: # Your implementation here # Test case print(unicode_digit_sum(\\"123abc\\")) # Output: 6 print(unicode_digit_sum(\\"a1b2c3\\")) # Output: 6 print(unicode_digit_sum(\\"अनु456\\")) # Output: 15 (since \'4\', \'5\', \'6\' are ASCII digits) print(unicode_digit_sum(\\"١٢٣٤\\")) # Output: 10 (since these are Arabic-Indic digits equivalent to \'1\', \'2\', \'3\', \'4\') print(unicode_digit_sum(\\"内3外2\\")) # Output: 5 (since \'3\' and \'2\' are ASCII digits) print(unicode_digit_sum(\\"你好\\")) # Output: 0 (no digits in the string) ``` # Explanation - The function should iterate over each character in the string `word`. - For each character, it should determine if the character is a numerical digit. - Use Unicode properties to identify digits, not just ASCII. - If it is a digit, convert it to its integer value. - Sum all the integer values of the digits found in the string. Implement the algorithm without relying solely on ASCII digit checks to properly handle various numeral systems and ensure accurate results for a broader range of inputs.","solution":"def unicode_digit_sum(word: str) -> int: Computes the sum of all numerical digits in a string, supporting both ASCII and Unicode digit characters. Parameters: word (str): The input string that may contain ASCII, Unicode digits, letters, and special characters. Returns: int: The sum of all digits in the input string. total = 0 for char in word: if char.isdigit(): total += int(char) return total"},{"question":"# Context A tech startup is developing a smart application for monitoring the health metrics of its users. One of the key features involves analyzing the variations in the users\' heart rates over a certain period. Part of this task requires calculating the maximum difference between two heart rates readings where the later reading in time is greater than the preceding one. # Problem Statement Write a function `max_difference(arr: List[int]) -> int` that takes a list of integers as input and returns the maximum difference between any two elements such that the later element is larger than the previous one. If no such pair exists, return `-1`. # Function Signature ```python def max_difference(arr: List[int]) -> int: pass ``` # Input 1. `arr` - a list of integers representing heart rate readings over time. # Output * An integer, the maximum difference between any two elements with the condition that the later element is greater than the previous one, or `-1` if no such pair exists. # Examples 1. `max_difference([2, 3, 10, 2, 4, 8, 1])` should return `8`. 2. `max_difference([7, 9, 5, 6, 3, 2])` should return `2`. 3. `max_difference([5, 4, 3, 2])` should return `-1`. 4. `max_difference([10, 1, 4, 1, 10, 8])` should return `9`. # Constraints * The length of `arr` will be between 1 and 10^5. * Each element in `arr` will be a non-negative integer (0 ≤ arr[i] ≤ 10^4). # Notes * Your solution should be efficient to handle large input sizes. * Consider edge cases like all elements being the same or the array length being very small.","solution":"from typing import List def max_difference(arr: List[int]) -> int: if not arr or len(arr) < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"# Context You are part of a team developing a new fitness tracking app that helps users monitor their daily physical activity. One of the features of this app is calculating the Body Mass Index (BMI) and providing health recommendations based on the BMI value. # Task Implement a function `calculate_bmi_and_recommendation(height: float, weight: float) -> dict` that calculates the BMI and provides a health recommendation. The function should accept the height (in meters) and weight (in kilograms) of an individual and then return a dictionary containing the BMI value and the corresponding health recommendation. # Input Requirements 1. `height`: A positive float representing the height in meters. 2. `weight`: A positive float representing the weight in kilograms. # Output Format A dictionary with the following key-value pairs: - `\\"bmi\\"`: The calculated BMI value (rounded to 2 decimal places). - `\\"recommendation\\"`: A health recommendation string based on the BMI value. # Calculation & Recommendations - **BMI Calculation**: The formula to calculate BMI is `weight / (height * height)`. - **Recommendations**: - BMI < 18.5: \\"Underweight\\" - 18.5 <= BMI < 24.9: \\"Normal weight\\" - 25.0 <= BMI < 29.9: \\"Overweight\\" - BMI >= 30.0: \\"Obesity\\" # Constraints & Considerations - **Constraints**: - Raise appropriate errors for invalid input values. A **ValueError** should be raised if the height or weight is non-positive. - Raise a **TypeError** if the inputs are not numbers. - **Performance requirements**: The solution should efficiently handle basic arithmetic operations and conditional checks, ensuring quick response times. # Function Signature In the implementation, ensure to define the function signature as follows: ```python def calculate_bmi_and_recommendation(height: float, weight: float) -> dict: pass ``` # Example ```python >>> calculate_bmi_and_recommendation(1.75, 70) { \\"bmi\\": 22.86, \\"recommendation\\": \\"Normal weight\\" } >>> calculate_bmi_and_recommendation(1.6, 90) { \\"bmi\\": 35.16, \\"recommendation\\": \\"Obesity\\" } >>> calculate_bmi_and_recommendation(1.8, 50) { \\"bmi\\": 15.43, \\"recommendation\\": \\"Underweight\\" } >>> calculate_bmi_and_recommendation(-1.75, 70) Traceback (most recent call last): ... ValueError: Invalid height. Should be a positive number. >>> calculate_bmi_and_recommendation(1.75, -70) Traceback (most recent call last): ... ValueError: Invalid weight. Should be a positive number. ```","solution":"def calculate_bmi_and_recommendation(height: float, weight: float) -> dict: Calculate BMI (Body Mass Index) and provide health recommendation. :param height: A positive float representing the height in meters. :param weight: A positive float representing the weight in kilograms. :return: A dictionary containing the BMI value and the health recommendation. :raises ValueError: If height or weight is non-positive. :raises TypeError: If height or weight is not a number. if not isinstance(height, (int, float)) or not isinstance(weight, (int, float)): raise TypeError(\\"Both height and weight must be numbers.\\") if height <= 0: raise ValueError(\\"Invalid height. Should be a positive number.\\") if weight <= 0: raise ValueError(\\"Invalid weight. Should be a positive number.\\") bmi = weight / (height ** 2) bmi = round(bmi, 2) if bmi < 18.5: recommendation = \\"Underweight\\" elif 18.5 <= bmi < 24.9: recommendation = \\"Normal weight\\" elif 25.0 <= bmi < 29.9: recommendation = \\"Overweight\\" else: recommendation = \\"Obesity\\" return {\\"bmi\\": bmi, \\"recommendation\\": recommendation}"},{"question":"# Task: Array Missing Integer Scenario: You are given an unsorted array of unique integers ranging from 1 to n where one integer is missing. Your goal is to find the missing integer in the array. Problem Statement: Write a function `find_missing_integer(arr: list) -> int` that takes a list of integers `arr` representing the array and returns the missing integer. Input Format: - A list of integers `arr` where the size of the list is `n-1` and integers range from 1 to `n`. Output Format: - An integer representing the missing integer from the array. Constraints: - The length of the array will be at least 1 and at most 10^6. Example: ```python find_missing_integer([1, 2, 4, 6, 3, 7, 8]) # returns 5 find_missing_integer([1, 2]) # returns 3 find_missing_integer([3, 5, 1, 4]) # returns 2 find_missing_integer([2, 3, 1, 5]) # returns 4 ``` # Implementation Details: - Calculate the expected sum of the first `n` natural numbers using the formula `n * (n + 1) / 2`. - Calculate the actual sum of the given array. - The difference between the expected sum and the actual sum will give the missing integer.","solution":"def find_missing_integer(arr): Finds the missing integer in the array of unique integers ranging from 1 to n. Args: arr (list): List of integers with one integer missing. Returns: int: The missing integer. n = len(arr) + 1 # since one integer is missing, n should be length of array + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"# Question Problem Statement: You are tasked with implementing a function to calculate the GCD (Greatest Common Divisor) of two integers. Given two integers, write a Python function `calculate_gcd(a: int, b: int) -> int` that computes their GCD using Euclid\'s algorithm. Euclid\'s algorithm is based on the principle that the GCD of two numbers does not change if the larger number is replaced by its remainder when divided by the smaller number. Specifically: - ( text{gcd}(a, b) = text{gcd}(b, a % b) ) - If ( b = 0 ), then ( text{gcd}(a, b) = a ) Requirements: * **Input Format**: - Two integers, `a` and `b`. * **Output Format**: - A single integer, representing the GCD of `a` and `b`. Example: ``` Input: 48, 18 Output: 6 Input: 101, 103 Output: 1 Input: 56, 98 Output: 14 ``` Constraints: * 0 ≤ `a`, `b` ≤ 10^6 Additional Notes: 1. You can assume both `a` and `b` will be non-negative. 2. The function should handle edge cases where one or both integers are zero. 3. The GCD of two numbers is always non-negative. Testing: 1. Test your implementation with pairs of numbers that have obvious GCDs: - ( a = 48, b = 18 Rightarrow text{GCD} = 6 ) - ( a = 101, b = 103 Rightarrow text{GCD} = 1 ) 2. Ensure your solution can handle edge cases: - When one of the numbers is zero. - When both numbers are zero.","solution":"def calculate_gcd(a: int, b: int) -> int: Calculate the Greatest Common Divisor (GCD) of two integers using Euclid\'s algorithm. while b != 0: a, b = b, a % b return a"},{"question":"# Problem Statement You need to implement a function that sorts an array of integers in non-decreasing order using Merge Sort. Merge Sort is a divide-and-conquer algorithm that splits the array into two halves, recursively sorts each half, and then merges the sorted halves to produce the final sorted array. Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers, where -10^9 ≤ arr[i] ≤ 10^9 for all elements in the list. # Output - Returns a new list of integers sorted in non-decreasing order. # Constraints - The maximum length of `arr` is 10^6. # Example ```python assert merge_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert merge_sort([1, 4, 3, 2]) == [1, 2, 3, 4] assert merge_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert merge_sort([-3, -7, 0, 7, 5, 2]) == [-7, -3, 0, 2, 5, 7] assert merge_sort([2]) == [2] # Edge case with one element assert merge_sort([]) == [] # Edge case with no elements ``` # Explanation 1. The function recursively divides the array into two halves until each subarray contains a single element. 2. Then it merges the subarrays in such a way that the resulting merged subarray is sorted. 3. This process is repeated until the entire array is sorted. Implement the `merge_sort` function, focusing on correctness and efficiency, particularly for large inputs.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] <= right[right_idx]: merged.append(left[left_idx]) left_idx += 1 else: merged.append(right[right_idx]) right_idx += 1 # Add remaining elements (if any) if left_idx < len(left): merged.extend(left[left_idx:]) if right_idx < len(right): merged.extend(right[right_idx:]) return merged mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Fibonacci Sequence and Golden Ratio Calculation Context You have been tasked with developing a function for numerical analysis. This function will generate the Fibonacci sequence and calculate the approximate value of the golden ratio using the generated sequence. Objective Write two functions: 1. `generate_fibonacci(n: int) -> list`: This function generates the Fibonacci sequence up to the `n`-th term. 2. `calculate_golden_ratio(fib_sequence: list) -> float`: This function calculates the approximation of the golden ratio using the last two elements of the provided Fibonacci sequence. Detailed Requirements 1. **Function 1: generate_fibonacci** * **Input**: An integer `n` representing the number of terms. * **Output**: A list of integers representing the Fibonacci sequence up to the `n`-th term. * **Constraints**: - `n` should be a positive integer greater than or equal to 2. - Raise a `ValueError` for invalid input (non-integer or integer less than 2). * **Description**: - The function should generate a list of the first `n` terms of the Fibonacci sequence. - The Fibonacci sequence starts with 0 and 1, and each subsequent term is the sum of the previous two terms. 2. **Function 2: calculate_golden_ratio** * **Input**: A list of integers representing the Fibonacci sequence. * **Output**: A float representing the approximate value of the golden ratio. * **Constraints**: - The sequence should be a non-empty list of integers. - Raise a `ValueError` for invalid input (non-list or empty list). * **Description**: - The function calculates the golden ratio as the ratio of the last two elements of the Fibonacci sequence (second to last element divided by the last element). - Ensure proper handling of edge cases such as sequences too short to calculate the ratio. Example Usage ```python # Generating Fibonacci sequence print(generate_fibonacci(5)) # [0, 1, 1, 2, 3] print(generate_fibonacci(10)) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # Calculating golden ratio fib_seq = generate_fibonacci(10) print(calculate_golden_ratio(fib_seq)) # ~1.618033988749895 fib_seq_small = generate_fibonacci(5) print(calculate_golden_ratio(fib_seq_small)) # ~1.5 ``` Constraints * You must handle edge cases such as invalid types or sequences too short to calculate the ratio. * Ensure the performance and accuracy of the implementation. * The solution should be self-contained without any additional libraries. Good luck!","solution":"def generate_fibonacci(n: int) -> list: Generates the Fibonacci sequence up to the n-th term. Parameters: n (int): The number of terms in the Fibonacci sequence. Returns: list: A list containing the Fibonacci sequence up to the n-th term. Raises: ValueError: If n is not an integer or n is less than 2. if not isinstance(n, int) or n < 2: raise ValueError(\\"Input must be an integer greater than or equal to 2\\") fib_sequence = [0, 1] for _ in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence def calculate_golden_ratio(fib_sequence: list) -> float: Calculates the golden ratio using the last two elements of the Fibonacci sequence. Parameters: fib_sequence (list): A list containing the Fibonacci sequence. Returns: float: The approximate value of the golden ratio. Raises: ValueError: If fib_sequence is not a list or contains less than 2 elements. if not isinstance(fib_sequence, list) or len(fib_sequence) < 2: raise ValueError(\\"Input must be a list with at least 2 elements\\") return fib_sequence[-1] / fib_sequence[-2]"},{"question":"# Problem Statement You are developing a text processing utility and need to implement a function that identifies the maximum frequency character in a given string. The function will help in analyzing the frequency of character occurrences, which could be instrumental in compression algorithms and data analysis. Write a function `max_frequency_char` that takes a string as input and returns the character with the highest frequency. If multiple characters have the same maximum frequency, return the one that appears first in the string. # Function Signature ```python def max_frequency_char(text: str) -> str: ``` # Input * `text` (str): A non-empty string containing a mix of upper and lower case letters, digits, and special characters. # Output * Returns a single character string which is the character with the highest frequency in the input string. # Constraints * The input string is non-empty. * The function should be case-sensitive, meaning \'a\' and \'A\' are considered different characters. # Examples ```python >>> max_frequency_char(\\"hello world\\") \'l\' >>> max_frequency_char(\\"aabbbcc\\") \'b\' >>> max_frequency_char(\\"a1b1c1\\") \'1\' >>> max_frequency_char(\\"abAB\\") \'a\' >>> max_frequency_char(\\"mississippi\\") \'i\' >>> max_frequency_char(\\"1223334444\\") \'4\' ``` # Hints * Consider using dictionaries or collections to keep track of character frequencies. * Carefully handle ties by maintaining the order of first appearance. By providing a clear and detailed problem statement along with examples and function signatures, the problem is designed to be on par with the existing questions in scope and difficulty, focusing on text processing and frequency analysis, which complements the bit manipulation and network packet analysis topics from the original problem set.","solution":"def max_frequency_char(text: str) -> str: Returns the character with the highest frequency in the given string. If multiple characters have the same frequency, returns the first one. from collections import defaultdict frequency = defaultdict(int) for char in text: frequency[char] += 1 max_freq = 0 max_char = \'\' for char in text: if frequency[char] > max_freq: max_freq = frequency[char] max_char = char return max_char"},{"question":"# Problem Statement Write a function `calculate_gpa` to calculate the Grade Point Average (GPA) of a student based on their grades in multiple subjects. Each grade should be converted to a numeric value, then averaged to produce the GPA. # Function Signature ```python def calculate_gpa(grades: List[str]) -> float: ``` # Input - `grades`: A list of strings where each string represents a grade (A, B, C, D, F). # Output - A floating-point number representing the GPA of the student, with two decimal places. # Grade to Numeric Conversion - A: 4.0 - B: 3.0 - C: 2.0 - D: 1.0 - F: 0.0 # Constraints - The list of grades can contain any number of grades (including an empty list). - All grades in the input list will be valid grade strings (A, B, C, D, F). # Example Input ```python [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"F\\"] [\\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"C\\"] [] [\\"F\\", \\"F\\", \\"F\\"] ``` Output ```python 2.00 3.20 0.00 0.00 ``` # Additional Requirements - Ensure that the function handles an empty list gracefully and returns a GPA of 0.00. - The function should round the GPA to two decimal places.","solution":"from typing import List def calculate_gpa(grades: List[str]) -> float: Calculate the GPA from a list of grades. Args: grades (List[str]): A list of grades (A, B, C, D, F). Returns: float: The GPA rounded to two decimal places. if not grades: return 0.0 grade_to_points = { \'A\': 4.0, \'B\': 3.0, \'C\': 2.0, \'D\': 1.0, \'F\': 0.0 } total_points = sum(grade_to_points[grade] for grade in grades) gpa = total_points / len(grades) return round(gpa, 2)"},{"question":"# Coding Question: Finding Strongly Connected Components in Directed Graph Problem Statement Given a directed graph represented as an adjacency list, write a function `find_scc` that identifies all strongly connected components (SCCs) in the graph. A strongly connected component is a maximal subgraph where any two vertices are reachable from each other. Function Signature ```python def find_scc(graph: Dict[int, List[int]]) -> List[List[int]]: ``` Input - `graph`: A dictionary representing the directed graph. The keys are node identifiers (integers) and the values are lists of adjacent node identifiers. Output - A list of lists, where each sublist represents a strongly connected component consisting of the node identifiers. Constraints - The graph may contain up to `10^4` nodes. Example ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5], 5: [3], 6: [7], 7: [6], 8: [9], 9: [8, 10], 10: [11], 11: [8], } find_scc(graph) # Output: [[0, 1, 2], [3, 4, 5], [6, 7], [8, 9, 10, 11]] ``` Ensure your solution is optimized for graphs with up to `10^4` nodes and adheres to the time complexity of O(V + E). Consider edge cases such as single-node graphs, graphs with no strongly connected components (disconnected nodes), and graphs with multiple strongly connected components.","solution":"from typing import Dict, List def find_scc(graph: Dict[int, List[int]]) -> List[List[int]]: Finds all strongly connected components (SCCs) in a directed graph using Kosaraju\'s algorithm. def dfs(vertex, visited, stack): visited[vertex] = True for neighbor in graph.get(vertex, []): if not visited[neighbor]: dfs(neighbor, visited, stack) stack.append(vertex) def reverse_graph(graph): reversed_graph = {v: [] for v in graph} for v in graph: for neighbor in graph[v]: reversed_graph[neighbor].append(v) return reversed_graph def fill_order(graph): visited = {v: False for v in graph} stack = [] for v in graph: if not visited[v]: dfs(v, visited, stack) return stack def find_sccs_in_reversed_graph(reversed_graph, stack): visited = {v: False for v in reversed_graph} sccs = [] while stack: v = stack.pop() if not visited[v]: component = [] dfs_collect(v, visited, reversed_graph, component) sccs.append(component) return sccs def dfs_collect(vertex, visited, graph, component): visited[vertex] = True component.append(vertex) for neighbor in graph[vertex]: if not visited[neighbor]: dfs_collect(neighbor, visited, graph, component) stack = fill_order(graph) reversed_graph = reverse_graph(graph) sccs = find_sccs_in_reversed_graph(reversed_graph, stack) return sccs # Example usage: # graph = { # 0: [1], # 1: [2], # 2: [0, 3], # 3: [4], # 4: [5], # 5: [3], # 6: [7], # 7: [6], # 8: [9], # 9: [8, 10], # 10: [11], # 11: [8], # } # print(find_scc(graph)) # # Output: [[0, 1, 2], [3, 4, 5], [6, 7], [8, 9, 10, 11]]"},{"question":"# Coding Assessment Question Scenario & Context You are managing a warehouse that requires efficient tracking of inventory movements. Each item has a unique identifier and a set of attributes indicating its category, storage location, and quantity. Your task is to develop an inventory tracking system that can handle multiple operations: adding an item, removing an item, and querying the inventory based on certain criteria. Problem Statement Write a class `InventoryTracker` that supports the following operations: * `add_item`: Adds an item with the specified identifier, category, location, and quantity to the inventory. * `remove_item`: Removes a specified quantity of the item with the given identifier from the inventory. If the quantity to remove exceeds the available quantity, it removes the item completely. * `query_inventory`: Returns a list of item identifiers matching a given category and location. Class Structure ```python class InventoryTracker: def __init__(self): pass def add_item(self, identifier: str, category: str, location: str, quantity: int) -> None: pass def remove_item(self, identifier: str, quantity: int) -> None: pass def query_inventory(self, category: str, location: str) -> List[str]: pass ``` Input and Output * `add_item` (Method): - `identifier` (String): A unique identifier for the item. - `category` (String): The category of the item. - `location` (String): The storage location of the item. - `quantity` (Integer): The quantity of the item to be added. - Returns: None * `remove_item` (Method): - `identifier` (String): The unique identifier of the item. - `quantity` (Integer): The quantity of the item to be removed. - Returns: None * `query_inventory` (Method): - `category` (String): The category to filter items by. - `location` (String): The location to filter items by. - Returns: List of strings representing item identifiers. Constraints * `identifier` is a unique alphanumeric string. * `category` and `location` are non-empty strings. * `quantity` is a non-negative integer. Examples ```python tracker = InventoryTracker() tracker.add_item(\\"item1\\", \\"electronics\\", \\"A1\\", 10) tracker.add_item(\\"item2\\", \\"electronics\\", \\"A2\\", 5) tracker.add_item(\\"item3\\", \\"furniture\\", \\"B1\\", 7) tracker.remove_item(\\"item1\\", 3) print(tracker.query_inventory(\\"electronics\\", \\"A1\\")) # Output: [\\"item1\\"] tracker.remove_item(\\"item1\\", 7) print(tracker.query_inventory(\\"electronics\\", \\"A1\\")) # Output: [] ``` Notes * Ensure efficient handling of operations, especially querying which might be called frequently. * Use appropriate data structures to maintain and query the inventory efficiently.","solution":"from typing import List class InventoryTracker: def __init__(self): self.inventory = {} # Stores items with their details. def add_item(self, identifier: str, category: str, location: str, quantity: int) -> None: if identifier in self.inventory: self.inventory[identifier][\'quantity\'] += quantity else: self.inventory[identifier] = {\'category\': category, \'location\': location, \'quantity\': quantity} def remove_item(self, identifier: str, quantity: int) -> None: if identifier in self.inventory: if self.inventory[identifier][\'quantity\'] <= quantity: del self.inventory[identifier] else: self.inventory[identifier][\'quantity\'] -= quantity def query_inventory(self, category: str, location: str) -> List[str]: return [identifier for identifier, details in self.inventory.items() if details[\'category\'] == category and details[\'location\'] == location]"},{"question":"Summing elements in JSON Array Context: You are asked to implement a function that parses a JSON-encoded string representing an array of integers and returns the sum of those integers. # Function: Sum JSON Array Write a function `sum_json_array(json_string: str) -> int` that takes a JSON string representing an array of integers and returns the sum of the integers. If the input string is not a valid JSON format or does not represent an array of integers, the function should raise a `ValueError`. Example: ```python >>> sum_json_array(\'[1, 2, 3, 4]\') 10 >>> sum_json_array(\'[-1, -2, -3, -4]\') -10 >>> sum_json_array(\'[]\') 0 >>> sum_json_array(\'[\\"1\\", 2, 3]\') Traceback (most recent call last): ... ValueError: Invalid JSON array of integers. >>> sum_json_array(\'[1, 2, 3, 4, \\"five\\"]\') Traceback (most recent call last): ... ValueError: Invalid JSON array of integers. >>> sum_json_array(\'[1, 2, 3, 4.5]\') Traceback (most recent call last): ... ValueError: Invalid JSON array of integers. >>> sum_json_array(\'{\\"key\\": \\"value\\"}\') Traceback (most recent call last): ... ValueError: Invalid JSON array of integers. >>> sum_json_array(\'1, 2, 3, 4\') Traceback (most recent call last): ... ValueError: Invalid input, expects a JSON encoded string. ``` # Constraints: 1. The input string must represent a valid JSON-encoded array. 2. The elements of the array must be integers; otherwise, a `ValueError` should be raised. 3. The function should ignore empty arrays and return 0 in such cases. 4. The function should not modify the input string. Note: Ensure to handle any unexpected data formats rigorously by raising appropriate exceptions.","solution":"import json def sum_json_array(json_string: str) -> int: Returns the sum of integers in the JSON encoded string array. :param json_string: A JSON string representing an array of integers. :return: Sum of the integers in the JSON array. :raises ValueError: If the JSON string is not properly formatted or does not contain integers. try: data = json.loads(json_string) except json.JSONDecodeError: raise ValueError(\\"Invalid input, expects a JSON encoded string.\\") if not isinstance(data, list): raise ValueError(\\"Invalid JSON array of integers.\\") total = 0 for item in data: if not isinstance(item, int): raise ValueError(\\"Invalid JSON array of integers.\\") total += item return total"},{"question":"# Problem Statement: You are required to implement a function that determines if a given string `s` can be transformed into another string `t` using only one specific operation: swapping any two adjacent characters in the string `s` any number of times. The function should determine if it\'s possible to sort `s` to match `t`. # Function Signature: ```python def can_transform_via_swaps(s: str, t: str) -> bool: pass ``` # Input: * `s` - A string composed of lowercase English letters (1 ≤ len(s) ≤ 10^5) * `t` - A string of the same length and character set as `s` # Output: * Returns `True` if it\'s possible to transform `s` into `t` using the mentioned operation, otherwise returns `False`. # Constraints: * Both strings `s` and `t` are guaranteed to be of the same length. * The function should operate efficiently to handle large input sizes within the given constraints. # Examples: ```python assert can_transform_via_swaps(\\"abc\\", \\"bca\\") == True # s can be transformed to t assert can_transform_via_swaps(\\"aa\\", \\"bb\\") == False # s cannot be transformed to t assert can_transform_via_swaps(\\"aab\\", \\"bba\\") == False # s cannot be transformed to t assert can_transform_via_swaps(\\"ab\\", \\"ba\\") == True # s can be transformed to t assert can_transform_via_swaps(\\"xyz\\", \\"zyx\\") == True # s can be transformed to t ``` **Note**: Ensure that your implementation considers the constraints and can handle the maximum possible input size efficiently. # Task: Write an efficient implementation of the function `can_transform_via_swaps` that determines if string `s` can be transformed into string `t` using only adjacent swaps.","solution":"def can_transform_via_swaps(s: str, t: str) -> bool: Determines if string `s` can be transformed into string `t` using only adjacent swaps. # To transform s to t using adjacent swaps, # both strings must have the same characters with the same frequencies. return sorted(s) == sorted(t)"},{"question":"Binary Tree Right Side View Challenge You are tasked with implementing a function to return the right side view of a binary tree. The right side view of a binary tree contains the values of the nodes that are visible when the tree is viewed from the right side. Description: Implement a function `right_side_view(root)` that returns a list of the values of the nodes visible from the right side of the binary tree. Input: - `root`: The root node of the binary tree. Each node is an instance of the `TreeNode` class. Output: - Returns a list of integers representing the values of the nodes visible from the right side. Constraints: - You can assume the tree consists of nodes with unique integer values. - The number of nodes in the tree will be in the range [0, 100]. Requirements: - The implementation should correctly handle trees with varying structures, including skewed and balanced trees. - Efficiency should be considered to handle the upper constraint of the input size. Additional Details: 1. You may use depth-first search (DFS) or breadth-first search (BFS) to achieve the implementation. 2. Ensure that your algorithm handles edge cases such as empty trees and trees with only one node. Sample Input: Consider the binary tree represented as follows: ``` 1 / 2 3 5 4 ``` Sample Output: ```python [1, 3, 4] ``` Implement the `right_side_view` function accordingly. Starter Code: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): # Your code here pass # Example Usage # Construct the tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) root.right.right = TreeNode(4) print(right_side_view(root)) # Output: [1, 3, 4] ``` Note: - Feel free to add any additional helper functions as needed to complete your solution. - Ensure you thoroughly test your implementation with various cases to cover all edge scenarios.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): if not root: return [] right_view = [] queue = [(root, 0)] while queue: node, level = queue.pop(0) if level == len(right_view): right_view.append(node.val) if node.right: queue.append((node.right, level + 1)) if node.left: queue.append((node.left, level + 1)) return right_view"},{"question":"# Linked List Cycle Detection and Removal **Background**: You are given a singly linked list that may or may not contain a cycle. A cycle occurs when a node\'s next pointer points to an earlier node in the list. Detecting and removing cycles in a linked list is a common problem that may arise in various applications, such as dealing with corrupt data structures or performing clean-up in systems where cyclical reference may persist. **Objective**: Implement a function to detect if a cycle exists in a linked list and remove it if present. You will complete the function using Floyd’s Tortoise and Hare algorithm for cycle detection and make necessary modifications to break the cycle. **Task**: 1. Implement the method `detect_and_remove_cycle` to: - Detect if a cycle is present in the linked list. - If a cycle is detected, remove the cycle by setting the next pointer of the node that leads to the cycle to None. 2. Write a helper function `print_list(head: ListNode) -> None` to: - Print the list elements from head to end. **Function Signature**: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_and_remove_cycle(head: ListNode) -> None: pass def print_list(head: ListNode) -> None: pass ``` **Input**: - The `head` node of a singly linked list. **Output**: - The linked list will be modified in place to remove the cycle if it exists. **Constraints**: - The number of nodes `n` in the linked list is such that `1 <= n <= 10^4`. - Each node’s value can be any integer. **Example**: ```python # Creating a linked list with a cycle for demonstration: # List: 1 -> 2 -> 3 -> 4 -> 5 -> 3 (cycle starting at node with value 3) head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) head.next.next.next.next.next = head.next.next # Creating a cycle detect_and_remove_cycle(head) print_list(head) # Expected Output: 1 2 3 4 5 ``` Make sure to implement the function `detect_and_remove_cycle` efficiently using O(n) time complexity and O(1) space complexity for cycle detection and removal.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_and_remove_cycle(head: ListNode) -> None: Detects and removes a cycle in the linked list using Floyd’s Tortoise and Hare algorithm. if head is None or head.next is None: return # No cycle possible in empty or single node list # Step 1: Detect cycle using Floyd’s Tortoise and Hare algorithm slow = head fast = head cycle_detected = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break if not cycle_detected: return # No cycle detected # Step 2: Remove the cycle # Reset slow to head slow = head if slow == fast: while fast.next != slow: fast = fast.next fast.next = None else: while slow.next != fast.next: slow = slow.next fast = fast.next fast.next = None def print_list(head: ListNode) -> None: Prints the value of each node in the list starting from head to end. current = head while current: print(current.value, end=\\" \\") current = current.next print()"},{"question":"# Problem Statement: You are tasked with implementing a data structure to efficiently manage and query the maximum value in a dynamically changing list of integers. Specifically, you need to develop a `MaxList` class that supports the following operations: 1. **Insert a Value**: Add a new integer to the list. 2. **Remove a Value**: Remove the first occurrence of a specified integer from the list. 3. **Get Maximum**: Retrieve the maximum integer currently in the list. # Class Definition: ```python class MaxList: def __init__(self): pass def insert(self, value: int) -> None: pass def remove(self, value: int) -> bool: pass def get_max(self) -> int: pass ``` # Implementations Required: - **`insert(value: int) -> None`**: Adds `value` to the list. - **`remove(value: int) -> bool`**: Finds and removes the first occurrence of `value` from the list. Returns `True` if the value was found and removed, `False` otherwise. - **`get_max() -> int`**: Returns the maximum value in the list. If the list is empty, it should raise a `ValueError` with the message \\"List is empty\\". # Constraints: - Each operation (`insert`, `remove`, `get_max`) should be optimized for efficiency. Aim for operations that take approximately O(log n) time on average. - The class should handle the dynamic nature of the list, including cases where multiple instances of the same value exist and ensuring they are handled correctly during insertions and removals. # Example: ```python max_list = MaxList() # Test insertions max_list.insert(5) max_list.insert(1) max_list.insert(5) max_list.insert(3) assert max_list.get_max() == 5 # Test removal assert max_list.remove(5) == True assert max_list.get_max() == 5 # Since there is another 5 assert max_list.remove(5) == True assert max_list.get_max() == 3 # Test edge cases assert max_list.remove(10) == False # Removing non-existent element assert max_list.remove(3) == True assert max_list.remove(1) == True try: max_list.get_max() # Should raise an exception since list is empty except ValueError as e: assert str(e) == \\"List is empty\\" ``` # Note: - Implement the internal handling of the list and the efficient retrieval of the maximum value as efficiently as possible. Consider using additional data structures like heaps or balanced binary search trees to optimize the operations. - Be mindful of edge cases such as trying to get the maximum from an empty list or removing an element that does not exist in the list.","solution":"import bisect class MaxList: def __init__(self): self.lst = [] def insert(self, value: int) -> None: bisect.insort(self.lst, value) def remove(self, value: int) -> bool: index = bisect.bisect_left(self.lst, value) if index != len(self.lst) and self.lst[index] == value: self.lst.pop(index) return True return False def get_max(self) -> int: if not self.lst: raise ValueError(\\"List is empty\\") return self.lst[-1]"},{"question":"# List Manipulation and Analysis You are working on developing a small utility that manipulates and analyzes integer lists for a data processing application. Your task is to complete the implementation of functions `remove_duplicates_and_sort` and `find_top_n_odd_integers`, ensuring that your solution handles edge cases and adheres to the specified requirements. Task 1. Implement the `remove_duplicates_and_sort` function that: * Takes a list of integers and returns a new list with duplicates removed and the remaining integers sorted in ascending order. 2. Implement the `find_top_n_odd_integers` function that: * Takes a list of integers and an integer `n`, and returns a list containing the highest `n` odd integers from the input list, sorted in descending order. * If there are fewer than `n` odd integers, return all odd integers sorted in descending order. Specifications: * **Function Signatures**: * `remove_duplicates_and_sort(nums: List[int]) -> List[int]` * `find_top_n_odd_integers(nums: List[int], n: int) -> List[int]` * **Input and Output**: * `nums` is a list containing between 0 and 10^6 integers, each in the range of -10^6 to 10^6. * `n` is an integer between 1 and 10^3. * Both functions should return a list of integers. * **Performance Requirement**: Ensure that both functions handle the upper bounds of input sizes efficiently. * **Constraints**: * The implementation should not use any advanced data structures beyond standard lists and sets. * Aim for a time complexity not exceeding O(n log n) where n is the length of the input list. Below is the initial implementation template: ```python from typing import List def remove_duplicates_and_sort(nums: List[int]) -> List[int]: Remove duplicates from the list and return it sorted in ascending order. pass # Your code here def find_top_n_odd_integers(nums: List[int], n: int) -> List[int]: Find the top n odd integers from the list, sorted in descending order. pass # Your code here if __name__ == \\"__main__\\": import doctest doctest.testmod() # Example input nums = [int(x) for x in input(\\"Enter list of integers: \\").split()] n = int(input(\\"Enter the value of n: \\")) # Function calls print(\\"Unique and sorted: \\", remove_duplicates_and_sort(nums)) print(\\"Top N odd integers: \\", find_top_n_odd_integers(nums, n)) ```","solution":"from typing import List def remove_duplicates_and_sort(nums: List[int]) -> List[int]: Remove duplicates from the list and return it sorted in ascending order. return sorted(set(nums)) def find_top_n_odd_integers(nums: List[int], n: int) -> List[int]: Find the top n odd integers from the list, sorted in descending order. odd_integers = [num for num in nums if num % 2 != 0] odd_integers_sorted = sorted(odd_integers, reverse=True) return odd_integers_sorted[:n]"},{"question":"# Palindrome Check using String Manipulation As a software developer, you are required to implement a function that checks whether a given string is a palindrome. A palindrome is a word, phrase, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Input - A single string `s`. Output - Return `True` if the string `s` is a palindrome, otherwise return `False`. Constraints - The input string `s` contains only ASCII characters and has a maximum length of 1000. Example ```python >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"Was it a car or a cat I saw\\") True ``` Implementation Details 1. Normalize the string by removing all non-alphanumeric characters and converting to lowercase. 2. Check if the normalized string reads the same backward as forward. Compose the implementation considering the efficiency and handling of potential edge cases.","solution":"def is_palindrome(s): Checks if the given string s is a palindrome, ignoring spaces, punctuation, and capitalization. :param s: Input string :return: True if s is a palindrome, False otherwise import re # Normalize: remove non-alphanumeric characters and convert to lowercase normalized_str = re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() # Check if the normalized string is equal to its reverse return normalized_str == normalized_str[::-1]"},{"question":"# Introduction You will implement a class that manages an interval tree for efficient range querying and insertion of intervals. # Objective Write a class `IntervalTree` that supports: 1. The method `insert_interval` to add an interval to the tree. 2. The method `find_overlapping_intervals` to retrieve intervals that overlap with a given interval. 3. The method `delete_interval` to remove an interval from the tree. # Specifications Insert Interval Method ```python def insert_interval(self, start: int, end: int) -> None: Inserts an interval [start, end] into the interval tree. :param start: The start of the interval. :param end: The end of the interval. ``` Find Overlapping Intervals Method ```python def find_overlapping_intervals(self, start: int, end: int) -> List[Tuple[int, int]]: Finds all intervals in the tree that overlap with the given interval. :param start: The start of the query interval. :param end: The end of the query interval. :return: A list of tuples, each containing the start and end of an overlapping interval. ``` Delete Interval Method ```python def delete_interval(self, start: int, end: int) -> None: Deletes the interval [start, end] from the interval tree. :param start: The start of the interval to be deleted. :param end: The end of the interval to be deleted. ``` # Constraints * The intervals are inclusive of their endpoints [start, end]. * Start and end are non-negative integers. * Overlapping of intervals is defined as intervals having at least one common point. * Avoid duplicating intervals in the tree. * Provide reasonable performance for both insertion and query operations. # Example ```python it = IntervalTree() it.insert_interval(5, 10) it.insert_interval(15, 20) print(it.find_overlapping_intervals(7, 9)) # [(5, 10)] print(it.find_overlapping_intervals(10, 15)) # [(5, 10), (15, 20)] it.delete_interval(5, 10) print(it.find_overlapping_intervals(7, 9)) # [] ``` # Note Ensure the implementation efficiently manages overlapping intervals and maintains the properties required for fast querying and insertion.","solution":"class IntervalTree: def __init__(self): self.intervals = [] def insert_interval(self, start: int, end: int) -> None: interval = (start, end) if interval not in self.intervals: self.intervals.append(interval) self.intervals.sort() def find_overlapping_intervals(self, start: int, end: int): result = [] for current_start, current_end in self.intervals: if not (end < current_start or start > current_end): result.append((current_start, current_end)) return result def delete_interval(self, start: int, end: int) -> None: interval = (start, end) if interval in self.intervals: self.intervals.remove(interval)"},{"question":"# Dijkstra\'s Algorithm Implementation Dijkstra\'s algorithm is widely used for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. You are to implement a simplified version of Dijkstra\'s algorithm to test your understanding of graphs and priority queues. Objective: Your task is to write a function `dijkstra` that finds the shortest path from a starting node to all other nodes in an undirected graph with non-negative weights. Function Definition: ```python def dijkstra(graph: dict, start: int) -> dict: Finds the shortest path from a starting node to all other nodes in the graph. :param graph: A dictionary representing an undirected graph where keys are nodes and values are lists of tuples [(neighbor, weight)]. :param start: The starting node for Dijkstra\'s algorithm. :return: A dictionary where keys are nodes and values are the shortest path distances from the start node. pass ``` Input: - `graph` (dict): An undirected graph represented as an adjacency list where each key is a node and each value is a list of tuples representing the neighboring nodes and the weights of the edges connecting them. - `start` (int): The starting node. Output: - A dictionary where each key is a node and each value is the shortest path distance from the starting node to that node. Constraints: - All graph node identifiers are unique positive integers. - The graph contains no negative weight edges. - The graph has at most 500 nodes. - Total number of edges across all test cases doesn\'t exceed 10^4. Example: ```python # Example graph representation: graph = { 0: [(1, 4), (2, 1)], 1: [(0, 4), (2, 2), (3, 5)], 2: [(0, 1), (1, 2), (3, 1)], 3: [(1, 5), (2, 1)] } # Example usage: assert dijkstra(graph, 0) == {0: 0, 1: 3, 2: 1, 3: 2} ``` Explanation: - The distance from node 0 to itself is 0. - The shortest path from node 0 to node 1 is via node 2 with a total weight of 3. - The shortest path from node 0 to node 2 is direct with a weight of 1. - The shortest path from node 0 to node 3 is via node 2 with a total weight of 2.","solution":"import heapq def dijkstra(graph, start): Finds the shortest path from a starting node to all other nodes in the graph. :param graph: A dictionary representing an undirected graph where keys are nodes and values are lists of tuples [(neighbor, weight)]. :param start: The starting node for Dijkstra\'s algorithm. :return: A dictionary where keys are nodes and values are the shortest path distances from the start node. # Priority queue to hold vertex distances pq = [(0, start)] # Dictionary to hold the shortest distance to each vertex distances = {node: float(\'inf\') for node in graph} distances[start] = 0 while pq: current_distance, current_vertex = heapq.heappop(pq) # If the popped vertex distance is greater than the recorded shortest distance, continue if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this path if it\'s shorter if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"# Question: Array Manipulation Based on Index Conditions **Context:** You are working on optimizing a sequence of operations on an array of integers. The operations involve modifying the array elements based on their indices and the given set of rules. These operations should be efficient to handle large arrays and their respective operations. **Objective:** Implement the following functions to perform specific operations on arrays: 1. **Sum Of Even Positioned Elements**: Compute the sum of elements present at even indices (0-based) in the array. 2. **Product Of Odd Positioned Elements**: Compute the product of elements present at odd indices (0-based) in the array. 3. **Reverse Subsection**: Reverse a subsection of the array defined by two indices, inclusive. **Function Signatures:** ```python def sum_even_positioned_elements(arr: list) -> int: pass def product_odd_positioned_elements(arr: list) -> int: pass def reverse_subsection(arr: list, start: int, end: int) -> list: pass ``` **Expected Input and Output**: ```python assert sum_even_positioned_elements([1, 2, 3, 4, 5, 6]) == 9 # 1 + 3 + 5 assert product_odd_positioned_elements([1, 2, 3, 4, 5, 6]) == 48 # 2 * 4 * 6 assert reverse_subsection([1, 2, 3, 4, 5, 6], 1, 4) == [1, 5, 4, 3, 2, 6] ``` **Constraints:** - The input array for all functions will contain integers. - The array lengths for all functions will be between 1 and 10^6. - For `reverse_subsection`, both start and end indices are inclusive and within the array bounds. - Performance should be optimized for both time and space complexities. **Detailed Requirements:** 1. **Sum Of Even Positioned Elements**: - **Input:** An array of integers. - **Output:** An integer representing the sum of elements at even indices. - Sum elements at index positions 0, 2, 4, etc. 2. **Product Of Odd Positioned Elements**: - **Input:** An array of integers. - **Output:** An integer representing the product of elements at odd indices. - Compute the product of elements at index positions 1, 3, 5, etc. 3. **Reverse Subsection**: - **Input:** An array of integers, and two integers representing the start and end indices of the subsection to reverse. - **Output:** The array after reversing the subsection from start to end, inclusive. - Perform an in-place reversal of elements between the start and end indices. **Edge Cases to Consider**: - Minimal Input: Test with an array of length 1. - Large Arrays: Ensure performance is efficient with arrays nearing the upper size limit. - Boundary Conditions: Ensure correct handling of start and end indices for the `reverse_subsection` function.","solution":"def sum_even_positioned_elements(arr: list) -> int: Compute the sum of elements present at even indices (0-based) in the array. return sum(arr[i] for i in range(0, len(arr), 2)) def product_odd_positioned_elements(arr: list) -> int: Compute the product of elements present at odd indices (0-based) in the array. product = 1 for i in range(1, len(arr), 2): product *= arr[i] return product def reverse_subsection(arr: list, start: int, end: int) -> list: Reverse a subsection of the array defined by two indices, inclusive. while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 return arr"},{"question":"# Matrix Rotation Objective Your task is to implement a function that rotates an NxN matrix by 90 degrees clockwise. The function should perform the rotation in place, modifying the input matrix directly without using additional matrices. Input The function will take: 1. **matrix**: A two-dimensional list of integers representing an NxN matrix. Output The function should return nothing as the matrix should be rotated in place. Constraints - The matrix is guaranteed to be square (NxN) and non-empty. - The function should modify the input matrix directly. Example Usage ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix_90_clockwise(matrix) print(matrix) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Implementation Details 1. Rotate the matrix layer by layer, starting from the outermost layer and moving towards the innermost layer. 2. For each layer, perform a four-way swap to move elements into their correct positions. Function Signature ```python def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> None: # Your implementation here pass ```","solution":"def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> None: Rotate the NxN matrix by 90 degrees clockwise in place. :param matrix: List of lists representing the NxN matrix. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first top = matrix[first][i] # Save top # Left -> Top matrix[first][i] = matrix[last - offset][first] # Bottom -> Left matrix[last - offset][first] = matrix[last][last - offset] # Right -> Bottom matrix[last][last - offset] = matrix[i][last] # Top -> Right matrix[i][last] = top # Right <- saved top"},{"question":"# Task Description Write a function that simulates the operation of a basic calculator supporting addition, subtraction, multiplication, and division. # Function Specifications Implement the following function: ```python def basic_calculator(operations: List[Tuple[str, float, float]]) -> List[float]: Simulates a basic calculator that performs a series of arithmetic operations. Args: operations (List[Tuple[str, float, float]]): A list of tuples, where each tuple consists of a string representing the operation (\'add\', \'subtract\', \'multiply\', \'divide\') and two floats as operands. Returns: List[float]: A list of results for each arithmetic operation in the input. Example: >>> basic_calculator([(\'add\', 1, 2), (\'subtract\', 5, 3)]) [3.0, 2.0] >>> basic_calculator([(\'multiply\', 2, 3), (\'divide\', 8, 2)]) [6.0, 4.0] # Your implementation here ``` # Constraints 1. The `operations` list is non-empty. 2. Allowed operations: \'add\', \'subtract\', \'multiply\', \'divide\'. 3. For \'divide\' operations, the second operand will never be zero. 4. All operands will be valid floating-point numbers. # Detailed Example Given the `operations` list `[(\'multiply\', 2, 3), (\'divide\', 8, 2)]`: 1. For the first operation: `2 * 3 = 6.0` 2. For the second operation: `8 / 2 = 4.0` 3. The result list would be: `[6.0, 4.0]`","solution":"from typing import List, Tuple def basic_calculator(operations: List[Tuple[str, float, float]]) -> List[float]: Simulates a basic calculator that performs a series of arithmetic operations. Args: operations (List[Tuple[str, float, float]]): A list of tuples, where each tuple consists of a string representing the operation (\'add\', \'subtract\', \'multiply\', \'divide\') and two floats as operands. Returns: List[float]: A list of results for each arithmetic operation in the input. results = [] for operation, x, y in operations: if operation == \'add\': results.append(x + y) elif operation == \'subtract\': results.append(x - y) elif operation == \'multiply\': results.append(x * y) elif operation == \'divide\': results.append(x / y) return results"},{"question":"# List Intersection You are part of a team working on a system that processes large datasets. One of your tasks is to find the common elements (intersection) between two lists of integers. The lists might not be sorted, and the approach should efficiently handle large inputs. Implement a function that accepts two lists of integers and returns a new list containing only the integers that are present in both input lists. The result list should be sorted in ascending order and should not have any duplicates. # Function Signature ```python def list_intersection(list1: list[int], list2: list[int]) -> list[int]: ``` # Input - `list1` (list of int): The first list of integers. - `list2` (list of int): The second list of integers. # Output - `list of int`: A sorted list with the unique integers found in both `list1` and `list2`. # Examples 1. `list_intersection([1, 2, 3, 4], [3, 4, 5, 6])` should return `[3, 4]`. 2. `list_intersection([10, 20, 30, 40], [15, 20, 25, 30])` should return `[20, 30]`. 3. `list_intersection([1, 1, 2, 2], [2, 2, 3, 3])` should return `[2]`. 4. `list_intersection([1, 2, 3], [])` should return `[]`. 5. `list_intersection([], [4, 5, 6])` should return `[]`. # Constraints - Both `list1` and `list2` can have up to 10^6 elements. - Each element in `list1` and `list2` is an integer in the range [1, 10^9]. - If there are no common elements, return an empty list. Implement the function in Python, ensuring optimal performance for large inputs.","solution":"def list_intersection(list1: list[int], list2: list[int]) -> list[int]: Returns the sorted list of unique integers found in both list1 and list2. # Convert lists to sets to remove duplicates and to enable O(1) average time complexity for membership checks set1 = set(list1) set2 = set(list2) # Find the intersection of sets intersection = set1.intersection(set2) # Convert the result to a sorted list before returning return sorted(intersection)"},{"question":"# Coding Assessment Question You are tasked with writing a function that emulates a simplified version of a text editor\'s find-and-replace feature. The function should find all instances of a target substring within a given text and replace them with a replacement substring. Additionally, it should handle edge cases such as empty strings or no occurrences of the target substring. 1. **Input**: * The original text (`str`) where the search and replace operations need to be performed. * The target substring (`str`) that needs to be found and replaced. * The replacement substring (`str`) that will replace each occurrence of the target substring. 2. **Behavior**: * Traverse the original text to find all instances of the target substring. * Replace each occurrence of the target substring with the replacement substring. * Return the new text with all replacements made. * Handle cases where the target substring is not found, ensuring the original text remains unchanged. * Ensure the function performs efficiently even for larger text inputs. 3. **Output**: Return the modified text after performing all the replacements. 4. **Constraints**: * The function should not use built-in string replacement functions. * The function should be case-sensitive. * Handle empty strings for any of the inputs gracefully, ensuring no errors are raised. Here is an example function signature to get you started: ```python def find_and_replace(original: str, target: str, replacement: str) -> str: pass ``` **Performance Requirements**: - The function should complete in O(n) time complexity where n is the length of the original text. - The space complexity should be O(n) to account for the space needed to construct the new text. Write the `find_and_replace` function according to the stated requirements. Example Usage: ```python original_text = \\"the quick brown fox jumps over the lazy dog\\" target_substring = \\"the\\" replacement_substring = \\"a\\" # Calling the function should return \\"a quick brown fox jumps over a lazy dog\\" find_and_replace(original_text, target_substring, replacement_substring) ``` **Edge Cases**: - If `target` is an empty string, return the `original` text unchanged. - If any of the input strings are empty, handle them appropriately without raising errors.","solution":"def find_and_replace(original: str, target: str, replacement: str) -> str: Replaces all occurrences of the target substring in the original string with the replacement substring. if not target: return original result = [] i = 0 target_len = len(target) while i <= len(original) - target_len: if original[i:i + target_len] == target: result.append(replacement) i += target_len else: result.append(original[i]) i += 1 result.append(original[i:]) return \\"\\".join(result)"},{"question":"# Classification Using Natural Language Processing (NLP) You are given a dataset containing customer reviews about a product along with their corresponding sentiment labels (positive or negative). Implement a function using Natural Language Processing (NLP) techniques to classify the sentiment of the reviews. Your task is to build a text classifier that trains on these reviews to predict their sentiment. **Function Implementation:** 1. **Function Signature**: `def nlp_sentiment_analysis(data: dict) -> np.ndarray:` 2. **Input**: The input will be a dictionary with two keys: - `reviews`: A list of strings, where each string represents a customer review. - `sentiments`: A list of integers, where each integer is 1 for a positive review and 0 for a negative review, corresponding to the reviews in `reviews`. 3. **Process**: * Preprocess the text data, including tokenization, lowercasing, removal of stop words, and lemmatization. * Split the dataset into training and testing sets using an 80-20 ratio for training and testing, respectively. * Train a text classification model (e.g., Logistic Regression, Naive Bayes, etc.) using the training dataset. * Predict the sentiments for the test dataset. 4. **Output**: A numpy array containing the predicted sentiments for the test dataset. **Constraints**: * Ensure all necessary preprocessing of the text data is performed within the function. * Use appropriate hyperparameters to optimize the model performance. * Evaluate the model performance using accuracy, precision, recall, and F1 score. **Example**: ```python >>> data = { ... \\"reviews\\": [ ... \\"This product is excellent! It exceeded my expectations.\\", ... \\"Awful experience. The product broke after two days.\\", ... # Add more reviews ... ], ... \\"sentiments\\": [1, 0, # Add more sentiments ... ] ... } >>> nlp_sentiment_analysis(data) array([1, 0]) # Example output representing predicted sentiments (not actual) ``` **Note**: The example provided is based on a simplified representation of customer reviews. Refer to this example for guidance on preprocessing and text feature extraction. Good luck, and ensure your solution is well-tested across multiple scenarios to validate its robustness!","solution":"import numpy as np from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.model_selection import train_test_split from sklearn.naive_bayes import MultinomialNB from sklearn.pipeline import make_pipeline from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def preprocess_reviews(reviews): # Preprocess text data here if necessary # For simplicity, we will rely on TfidfVectorizer\'s internal preprocessing return reviews def nlp_sentiment_analysis(data: dict) -> np.ndarray: reviews = data[\'reviews\'] sentiments = data[\'sentiments\'] # Preprocess reviews reviews = preprocess_reviews(reviews) # Split the data X_train, X_test, y_train, y_test = train_test_split(reviews, sentiments, test_size=0.2, random_state=42) # Create a pipeline with TfidfVectorizer and a classifier (Naive Bayes in this case) model = make_pipeline(TfidfVectorizer(), MultinomialNB()) # Train the model model.fit(X_train, y_train) # Predict the sentiments for the test dataset y_pred = model.predict(X_test) # Print evaluation metrics print(f\\"Accuracy: {accuracy_score(y_test, y_pred)}\\") print(f\\"Precision: {precision_score(y_test, y_pred)}\\") print(f\\"Recall: {recall_score(y_test, y_pred)}\\") print(f\\"F1 Score: {f1_score(y_test, y_pred)}\\") return y_pred"},{"question":"# Scenario: You have been tasked with implementing a custom data structure called `UniqueMinHeap` that behaves like a min-heap but only contains unique elements. This heap should support standard operations such as insertion, extraction of the minimum element, and maintaining the heap property. # Task: Write a class `UniqueMinHeap` that efficiently supports the insertion of unique elements and extraction of the minimum element. The heap should maintain the min-heap property at all times. # Class Signature: ```python class UniqueMinHeap: def __init__(self): pass def insert(self, value: int): pass def extract_min(self) -> int: pass def get_min(self) -> int: pass ``` # Method Descriptions: - `__init__`: Initializes an empty UniqueMinHeap. - `insert(value: int)`: Inserts a unique integer into the heap. If the integer already exists in the heap, it should not be added again. - `extract_min() -> int`: Removes and returns the smallest integer from the heap. If the heap is empty, raise an appropriate exception. - `get_min() -> int`: Returns the smallest integer in the heap without removing it. If the heap is empty, raise an appropriate exception. # Constraints: - The heap must efficiently handle up to 10^5 insertions. - Values inserted into the heap are integers within the range of -10^9 to 10^9. # Example: ```python heap = UniqueMinHeap() heap.insert(5) heap.insert(3) heap.insert(10) heap.insert(3) # Should not be inserted, as 3 is already in the heap print(heap.get_min()) # Output: 3 print(heap.extract_min()) # Output: 3 print(heap.get_min()) # Output: 5 heap.insert(1) print(heap.get_min()) # Output: 1 ``` # Notes: - Utilize appropriate data structures to ensure that all operations are efficient. - Ensure that duplicate elements are not added to the heap. - Properly handle edge cases such as extracting or getting the minimum from an empty heap.","solution":"import heapq class UniqueMinHeap: def __init__(self): self.heap = [] self.set = set() def insert(self, value: int): if value not in self.set: heapq.heappush(self.heap, value) self.set.add(value) def extract_min(self) -> int: if not self.heap: raise IndexError(\\"extract_min(): empty heap\\") min_val = heapq.heappop(self.heap) self.set.remove(min_val) return min_val def get_min(self) -> int: if not self.heap: raise IndexError(\\"get_min(): empty heap\\") return self.heap[0]"},{"question":"# Coding Assessment Question You are required to design a function that extracts temperature data from a given weather website and stores the details in a CSV file. Objective Write a function called `fetch_and_write_temperature` that will: 1. Fetch the current weather data for a specified city from a given URL (default URL is \\"https://www.weatherapi.com/current?city={}\\"). 2. Parse the JSON response to extract the city\'s name, current temperature, and weather condition. 3. Store these details in a CSV file named \\"Current_Weather.csv\\" with three columns: \\"City\\", \\"Temperature\\", and \\"Weather Condition\\". Function Signature ```python def fetch_and_write_temperature(city: str, url: str = \\"https://www.weatherapi.com/current?city={}\\", filename: str = \\"Current_Weather.csv\\") -> None: pass ``` Input and Output Formats * **Input**: * `city`: A string representing the city for which to fetch weather data. * `url` (optional): A string URL template pointing to the weather API endpoint with a placeholder for the city name. * `filename` (optional): A string specifying the output CSV file name. * **Output**: The function writes a CSV file with the city name, temperature, and weather condition. Constraints * The weather API should be reliable and handle potential changes in JSON structure gracefully. * Handle potential network and API errors with retries. * Ensure the CSV is written without data corruption or formatting issues. Performance Requirements * Solution should efficiently handle network requests and JSON parsing. * Implement reasonable error handling for robustness without compromising performance. Additional Requirements * Write a `main` function that calls `fetch_and_write_temperature(city)` to demonstrate its usage. * Your solution should comply with best practices, including appropriate use of libraries, clean code, and detailed comments. Good luck and happy coding!","solution":"import requests import csv import time def fetch_and_write_temperature(city: str, url: str = \\"https://www.weatherapi.com/current?city={}\\", filename: str = \\"Current_Weather.csv\\") -> None: Fetches current weather data for the specified city and writes it to a CSV file. :param city: A string representing the city for which to fetch weather data. :param url: A string URL template pointing to the weather API endpoint with a placeholder for city name. :param filename: A string specifying the output CSV file name. full_url = url.format(city) retries = 3 for attempt in range(retries): try: response = requests.get(full_url) response.raise_for_status() weather_data = response.json() city_name = weather_data[\'location\'][\'name\'] temperature = weather_data[\'current\'][\'temp_c\'] condition = weather_data[\'current\'][\'condition\'][\'text\'] with open(filename, mode=\'w\', newline=\'\') as file: writer = csv.writer(file) writer.writerow([\\"City\\", \\"Temperature\\", \\"Weather Condition\\"]) writer.writerow([city_name, temperature, condition]) print(f\\"Weather data for {city_name} written to {filename}\\") break except requests.exceptions.RequestException as e: print(f\\"Error: {e}. Attempt {attempt + 1} of {retries}\\") time.sleep(1) if attempt == retries - 1: raise except KeyError as e: print(f\\"KeyError: {e}. Check the assumption about JSON response structure.\\") raise def main(): city = \\"London\\" fetch_and_write_temperature(city) if __name__ == \\"__main__\\": main()"},{"question":"# Context: You\'re working on a project that involves handling large datasets containing various numerical values. A frequent operation is to compute the sum of the elements within a given range of indices. To optimize this, you need a function that precomputes some values to allow for efficient range sum queries. # Problem Statement: Write a function `RangeSumCalculator` that takes a list of integers and implements two methods: 1. `__init__(self, nums: List[int])`: Constructs the object and precomputes the necessary data to allow for efficient range sum queries. 2. `range_sum(self, left: int, right: int) -> int`: Returns the sum of the elements within the inclusive range `[left, right]`. Input and Output Formats: * **Input**: - A list of integers `nums`. - Two integers `left` and `right` representing the inclusive range of indices. * **Output**: - An integer representing the sum of the elements within the specified range. Constraints and Limitations: * All elements in the input list `nums` are integers. * 0 <= left <= right < len(nums) * The solution should be optimized for fast range sum queries. * You should appropriately handle edge cases. Example: ```python # Creating an instance of the RangeSumCalculator calculator = RangeSumCalculator([1, 2, 3, 4, 5]) # Example range sum queries >>> calculator.range_sum(0, 2) 6 # 1 + 2 + 3 >>> calculator.range_sum(1, 3) 9 # 2 + 3 + 4 >>> calculator.range_sum(2, 4) 12 # 3 + 4 + 5 ``` # Performance Requirements: * The initialization should preprocess the data in O(n) time complexity. * Each range sum query should run in O(1) time complexity.","solution":"class RangeSumCalculator: def __init__(self, nums): Initialize the RangeSumCalculator with the given list of integers. Precompute the prefix sums to enable efficient range sum queries. self.prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): self.prefix_sums[i + 1] = self.prefix_sums[i] + nums[i] def range_sum(self, left, right): Returns the sum of the elements within the inclusive range [left, right]. return self.prefix_sums[right + 1] - self.prefix_sums[left]"},{"question":"# Question: You are provided with an implementation of a Segment Tree that supports range minimum queries. Your objective is to extend this data structure by adding a new method that counts the number of prime numbers within a specified subarray range. **Function Signature**: ```python def count_primes(node: Node | None, start: int, end: int) -> int: Returns the count of prime numbers in the range [start, end] of the array represented by the Segment Tree. Parameters: - node: The root node of the Segment Tree. - start: Starting index of the range (inclusive). - end: Ending index of the range (inclusive). Returns: - The count of prime numbers in the specified range. If the range is invalid or empty, return 0. ``` # Input: * `node:` The Segment Tree root node built from the given array. * `start (int):` The starting index of the range (0-indexed). * `end (int):` The ending index of the range (0-indexed). # Output: * Return the number of prime numbers in the range `[start, end]` of the array. If the range is invalid or empty, return `0`. # Constraints: * The array contains positive integers, and the size will not exceed 100,000 elements. * You may assume that the numbers in the array are within a reasonable range for prime checking. * Ensure that the function correctly handles edge cases. # Example: ```python >>> root = build_segment_tree([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) >>> count_primes(root, 0, 4) 3 >>> count_primes(root, 5, 10) 2 >>> count_primes(root, 10, 18) 2 ``` **Notes**: * A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. * The function should implement efficient prime-checking to accommodate large ranges within the size constraints.","solution":"class Node: def __init__(self, start, end): self.start = start self.end = end self.minimum = float(\'inf\') self.left = None self.right = None self.prime_count = 0 def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def build_segment_tree(arr, start, end): if start == end: node = Node(start, end) node.minimum = arr[start] if is_prime(arr[start]): node.prime_count = 1 return node mid = (start + end) // 2 node = Node(start, end) node.left = build_segment_tree(arr, start, mid) node.right = build_segment_tree(arr, mid + 1, end) node.minimum = min(node.left.minimum, node.right.minimum) node.prime_count = node.left.prime_count + node.right.prime_count return node def count_primes(node, start, end): if not node or start > end or start > node.end or end < node.start: return 0 if start <= node.start and node.end <= end: return node.prime_count return count_primes(node.left, start, end) + count_primes(node.right, start, end)"},{"question":"**Context**: You are working on a backend system that processes data about cities and distances between them. The cities form a network represented by a weighted, undirected graph. Your task is to implement functionality to find the minimum spanning tree (MST) of the graph using Prim\'s algorithm. The MST is a subset of edges that connects all vertices in the graph with the minimum possible total edge weight. **Task**: Write a Python function to find the MST of a given weighted, undirected graph using Prim\'s algorithm. **Requirements**: - Write a class `CityNetwork` that: - Initializes with an adjacency list with edge weights. - Implements a `find_mst` method that returns the edges and the total weight of the MST. **Function Signatures**: ```python class CityNetwork: def __init__(self, graph: dict[str, list[tuple[str, int]]]) -> None: ... def find_mst(self) -> tuple[list[tuple[str, str, int]], int]: ... ``` **Input Format**: - `graph`: A dictionary where keys are city names (strings) and values are lists of tuples. Each tuple contains another city name and the weight of the edge connecting them. **Output Format**: - A list of triples, each representing an edge in the MST. Each triple contains two cities and the weight of the edge between them. - The total weight of the MST as an integer. **Example**: ```python graph = { \\"A\\": [(\\"B\\", 3), (\\"C\\", 1), (\\"D\\", 4)], \\"B\\": [(\\"A\\", 3), (\\"C\\", 2), (\\"D\\", 5)], \\"C\\": [(\\"A\\", 1), (\\"B\\", 2), (\\"D\\", 6)], \\"D\\": [(\\"A\\", 4), (\\"B\\", 5), (\\"C\\", 6)], } network = CityNetwork(graph) mst_edges, total_weight = network.find_mst() print(mst_edges) # Output: [(\'A\', \'C\', 1), (\'C\', \'B\', 2), (\'A\', \'D\', 4)] print(total_weight) # Output: 7 ``` **Constraints**: - All city names are unique. - The graph is connected and contains at least one edge. - Edge weights are positive integers. **Performance Notes**: - Your solution should be efficient in both time and space complexity for graphs with many cities and edges.","solution":"import heapq class CityNetwork: def __init__(self, graph: dict[str, list[tuple[str, int]]]) -> None: Initializes the CityNetwork with an adjacency list with edge weights. self.graph = graph def find_mst(self) -> tuple[list[tuple[str, str, int]], int]: Uses Prim\'s Algorithm to find the Minimum Spanning Tree (MST) of the graph. Returns the edges in the MST and the total weight of the MST. # Pick an arbitrary start node (we assume the graph is connected) start_node = next(iter(self.graph)) mst_edges = [] total_weight = 0 # Min-heap to store (cost, from_node, to_node) min_heap = [(0, start_node, start_node)] visited = set() while min_heap: cost, from_node, to_node = heapq.heappop(min_heap) if to_node in visited: continue visited.add(to_node) if from_node != to_node: mst_edges.append((from_node, to_node, cost)) total_weight += cost for neighbor, weight in self.graph[to_node]: if neighbor not in visited: heapq.heappush(min_heap, (weight, to_node, neighbor)) return mst_edges, total_weight # Example usage graph_example = { \\"A\\": [(\\"B\\", 3), (\\"C\\", 1), (\\"D\\", 4)], \\"B\\": [(\\"A\\", 3), (\\"C\\", 2), (\\"D\\", 5)], \\"C\\": [(\\"A\\", 1), (\\"B\\", 2), (\\"D\\", 6)], \\"D\\": [(\\"A\\", 4), (\\"B\\", 5), (\\"C\\", 6)], } network = CityNetwork(graph_example) mst_edges, total_weight = network.find_mst() print(mst_edges) # Expected output: [(\'A\', \'C\', 1), (\'C\', \'B\', 2), (\'A\', \'D\', 4)] print(total_weight) # Expected output: 7"},{"question":"# Coding Challenge: Implement a Binary Search Tree with In-Order Traversal Context A Binary Search Tree (BST) is a node-based data structure in which each node has at most two children referred to as the left child and the right child. For each node, the left subtree contains only nodes with values less than the node\'s value, and the right subtree contains only nodes with values greater than the node’s value. An in-order traversal of a BST visits all the nodes in ascending order of their values. Task Write a Python class to implement a BST with methods to insert, delete, and perform in-order traversal of the tree. Additionally, implement a method to check if the tree is a valid BST. Class Signature ```python class BinarySearchTree: class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key def __init__(self): Initializes an empty BST. self.root = None def insert(self, key: int) -> None: Inserts a key into the BST. Args: - key: The integer value to insert into the BST. pass def delete(self, key: int) -> None: Deletes a key from the BST. If the key does not exist, do nothing. Args: - key: The integer value to delete from the BST. pass def inorder_traversal(self) -> list[int]: Performs in-order traversal of the BST and returns a list of values. Returns: - A list of integers representing the BST values in ascending order. pass def is_valid_BST(self) -> bool: Checks if the current tree is a valid BST. Returns: - True if the tree is a valid BST, False otherwise. pass ``` Guidelines 1. **Input Format**: The insert and delete methods will take an integer value. The inorder_traversal method will return a list of integers. The is_valid_BST method will return a boolean. 2. **Output Format**: - insert and delete methods should not return anything. - inorder_traversal should return a list of integers in ascending order. - is_valid_BST should return a boolean indicating whether the tree is a valid BST. 3. **Constraints**: - The tree does not contain duplicate values. - Methods are called in a typical sequence of inserts and deletes. Example Example of expected functionality: ```python bst = BinarySearchTree() bst.insert(4) bst.insert(2) bst.insert(5) bst.insert(1) bst.insert(3) assert bst.inorder_traversal() == [1, 2, 3, 4, 5] bst.delete(3) assert bst.inorder_traversal() == [1, 2, 4, 5] assert bst.is_valid_BST() == True ``` The class should properly handle various cases of insertion, deletion (including nodes with zero, one, and two children), and validation of the BST property.","solution":"class BinarySearchTree: class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key def __init__(self): Initializes an empty BST. self.root = None def insert(self, key: int) -> None: Inserts a key into the BST. Args: - key: The integer value to insert into the BST. if self.root is None: self.root = self.Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node: \'BinarySearchTree.Node\', key: int) -> None: if key < node.val: if node.left is None: node.left = self.Node(key) else: self._insert_recursive(node.left, key) elif key > node.val: if node.right is None: node.right = self.Node(key) else: self._insert_recursive(node.right, key) def delete(self, key: int) -> None: Deletes a key from the BST. If the key does not exist, do nothing. Args: - key: The integer value to delete from the BST. self.root = self._delete_recursive(self.root, key) def _delete_recursive(self, node: \'BinarySearchTree.Node\', key: int) -> \'BinarySearchTree.Node\': if node is None: return None if key < node.val: node.left = self._delete_recursive(node.left, key) elif key > node.val: node.right = self._delete_recursive(node.right, key) else: # Node to be deleted found if node.left is None: return node.right elif node.right is None: return node.left else: # Node with two children # Get the inorder successor (smallest in the right subtree) min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right = self._delete_recursive(node.right, min_larger_node.val) return node def _get_min(self, node: \'BinarySearchTree.Node\') -> \'BinarySearchTree.Node\': while node.left is not None: node = node.left return node def inorder_traversal(self) -> list[int]: Performs in-order traversal of the BST and returns a list of values. Returns: - A list of integers representing the BST values in ascending order. result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node: \'BinarySearchTree.Node\', result: list) -> None: if node is not None: self._inorder_recursive(node.left, result) result.append(node.val) self._inorder_recursive(node.right, result) def is_valid_BST(self) -> bool: Checks if the current tree is a valid BST. Returns: - True if the tree is a valid BST, False otherwise. def is_valid(node: \'BinarySearchTree.Node\', low: float, high: float) -> bool: if node is None: return True if not (low < node.val < high): return False return is_valid(node.left, low, node.val) and is_valid(node.right, node.val, high) return is_valid(self.root, float(\'-inf\'), float(\'inf\'))"},{"question":"# Coding Assessment Question **Objective**: Implement a function to reverse a linked list in blocks of size `k`. **Scenario**: You are given a singly linked list and an integer `k`. Your task is to reverse the linked list in blocks of size `k` using the function `reverse_in_blocks_of_k`. If the number of nodes is not a multiple of `k`, then the remaining nodes should remain as they are. **Function Description**: The function `reverse_in_blocks_of_k` should take the head of the linked list and an integer `k` as inputs and return the head of the modified list. **Task**: - Implement the `reverse_in_blocks_of_k` method. - Preserve the order of the nodes within each block of size `k`. **Constraints**: - The function should handle an empty linked list and `k` values greater than 0. **Expected Behavior**: - If the linked list is empty, return `None`. - Only reverse the linked list in blocks of size `k`. **Function Signature**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_in_blocks_of_k(head: ListNode, k: int) -> ListNode: pass ``` **Examples**: ```python # Definition of ListNode for testing class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Helper function to convert a list to a linked list def list_to_linkedlist(items): if not items: return None head = ListNode(items[0]) current_node = head for item in items[1:]: current_node.next = ListNode(item) current_node = current_node.next return head # Helper function to convert a linked list to a list def linkedlist_to_list(node): result = [] while node: result.append(node.val) node = node.next return result # Creating test cases lst = list_to_linkedlist([1, 2, 3, 4, 5]) k = 2 reversed_lst = reverse_in_blocks_of_k(lst, k) print(linkedlist_to_list(reversed_lst)) # Expected output: [2, 1, 4, 3, 5] lst = list_to_linkedlist([1, 2, 3, 4, 5, 6]) k = 3 reversed_lst = reverse_in_blocks_of_k(lst, k) print(linkedlist_to_list(reversed_lst)) # Expected output: [3, 2, 1, 6, 5, 4] lst = list_to_linkedlist([1, 2]) k = 3 reversed_lst = reverse_in_blocks_of_k(lst, k) print(linkedlist_to_list(reversed_lst)) # Expected output: [1, 2] lst = list_to_linkedlist([]) k = 2 reversed_lst = reverse_in_blocks_of_k(lst, k) print(linkedlist_to_list(reversed_lst)) # Expected output: [] ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode, k: int) -> ListNode: prev, current = None, head while current and k > 0: nxt = current.next current.next = prev prev = current current = nxt k -= 1 return prev def reverse_in_blocks_of_k(head: ListNode, k: int) -> ListNode: if head is None or k == 1: return head count = 0 current = head while current and count < k: current = current.next count += 1 if count < k: return head reversed_head = reverse_linked_list(head, k) if head: head.next = reverse_in_blocks_of_k(current, k) return reversed_head"},{"question":"# Sorting Employees by Age Background Sorting algorithms are a staple in computer science, used to arrange data in a particular order. Implementing a custom sort function can deepen the understanding of these algorithms. In this task, you\'ll work with employee records and sort them by age using a specified sorting algorithm. Task Implement a function that sorts employees by age using the QuickSort algorithm. Each employee record is represented as a dictionary with keys `name` (string) and `age` (integer). Your function should correctly sort the list of dictionaries in ascending order of age. Your function should have the following signature: ```python def quicksort_employees_by_age(employees: list[dict]) -> list[dict]: ``` Constraints * The function must use the QuickSort algorithm. * Assume that the `employees` list contains at least one employee. * Each employee dictionary will have the keys \'name\' and \'age\', where: * `name` is a non-empty string. * `age` is a non-negative integer. * Implement two helper functions to partition the list and perform the recursive quicksort. Example Usage ```python employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 28}, {\\"name\\": \\"Bob\\", \\"age\\": 35}, {\\"name\\": \\"Eve\\", \\"age\\": 22}, {\\"name\\": \\"Charlie\\", \\"age\\": 30} ] sorted_employees = quicksort_employees_by_age(employees) expected_output = [ {\\"name\\": \\"Eve\\", \\"age\\": 22}, {\\"name\\": \\"Alice\\", \\"age\\": 28}, {\\"name\\": \\"Charlie\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 35} ] assert sorted_employees == expected_output, \\"Test Case Failed\\" print(f\\"Sorted Employees: {sorted_employees}\\") ``` Notes * Ensure your solution correctly sorts the employees by age using QuickSort. * Handle edge cases gracefully, such as when there are employees with the same age. * Write unit tests to verify the correctness of your implementation.","solution":"def quicksort_employees_by_age(employees): Sorts a list of employee dictionaries by age using the QuickSort algorithm. Args: employees: list of dicts, each dict has keys \'name\' (string) and \'age\' (integer) Returns: list of dicts sorted in ascending order by \'age\' if len(employees) <= 1: return employees pivot = employees[len(employees) // 2][\'age\'] less = [emp for emp in employees if emp[\'age\'] < pivot] equal = [emp for emp in employees if emp[\'age\'] == pivot] greater = [emp for emp in employees if emp[\'age\'] > pivot] return quicksort_employees_by_age(less) + equal + quicksort_employees_by_age(greater)"},{"question":"**Scenario**: A company is managing an event where attendees sign up with their email addresses. However, some users may submit their email addresses in various letter cases (e.g., \\"example@domain.com\\" and \\"Example@Domain.COM\\"), which creates duplicate entries in the system. To ensure accurate count and manage the list cleanly, convert all email addresses to a uniform case and remove any duplicates. **Problem**: Write a function `unique_emails` that normalizes email addresses to lowercase and removes any duplicates from the list. **Function Signature**: ```python def unique_emails(emails: List[str]) -> List[str]: Returns a list of unique email addresses, all in lowercase. Parameters: emails (List[str]): The list of email addresses. Returns: List[str]: A list of unique email addresses in lowercase. ``` # Input - A list of email addresses (`emails`) where each email address is a string. # Output - A list of unique email addresses, all in lowercase. # Constraints - Email addresses may contain uppercase and lowercase letters. - The list of emails (`emails`) is non-empty. - Each email address in the list is in a valid email address format. # Example ```python emails = [\\"Example@domain.COM\\", \\"example@domain.com\\", \\"user@site.org\\"] unique_emails_list = unique_emails(emails) print(unique_emails_list) # Output should be: [\'example@domain.com\', \'user@site.org\'] ``` # Additional Notes - The implementation should ensure the output list contains each unique email address exactly once. - Consider the efficiency of your solution, especially for large lists. - Handle edge cases like lists where all emails are already unique or no duplicates exist. This question aligns with sorting and data management concepts, requiring candidates to manipulate and clean data efficiently, similar to handling and sorting integers in the original question set.","solution":"from typing import List def unique_emails(emails: List[str]) -> List[str]: Returns a list of unique email addresses, all in lowercase. Parameters: emails (List[str]): The list of email addresses. Returns: List[str]: A list of unique email addresses in lowercase. # Convert all emails to lowercase and use a set to filter out duplicates unique_emails_set = set(email.lower() for email in emails) # Convert the set back to a list return list(unique_emails_set)"},{"question":"**Problem Statement: Meeting Room Allocation** You are given the start and end times of multiple meetings. Implement a function `allocate_meeting_rooms(meetings: list[tuple[int, int]]) -> int` to determine the minimum number of meeting rooms required to accommodate all the meetings without overlapping. # Input - `meetings`: A list of tuples, where each tuple contains two integers: (start, end). Each integer represents the start and end times of a meeting. # Output - An integer representing the minimum number of meeting rooms required. # Constraints - Meeting times are given as non-negative integers. - Start times are strictly less than end times for all meetings. # Examples ```python allocate_meeting_rooms([(0, 30), (5, 10), (15, 20)]) # Output: 2 allocate_meeting_rooms([(1, 5), (2, 6), (3, 8), (4, 9)]) # Output: 4 allocate_meeting_rooms([(10, 15), (12, 20), (20, 30)]) # Output: 2 allocate_meeting_rooms([(1, 10)]) # Output: 1 allocate_meeting_rooms([]) # Output: 0 ``` # Approach 1. **Separate and Sort**: Create separate lists for start times and end times. Sort them both. 2. **Two Pointers Method**: Use two pointers to iterate through the start and end times. Maintain a count of simultaneous ongoing meetings and update the maximum as necessary. 3. **Count Rooms**: Increment the meeting room count when a meeting starts and decrement it when a meeting ends. **Implement the `allocate_meeting_rooms` function**","solution":"def allocate_meeting_rooms(meetings): if not meetings: return 0 # Separate and sort start and end times start_times = sorted([meeting[0] for meeting in meetings]) end_times = sorted([meeting[1] for meeting in meetings]) # Initialize pointers and variables to track maximum rooms required start_pointer, end_pointer = 0, 0 used_rooms = 0 max_rooms = 0 # Process until all the meetings are checked while start_pointer < len(meetings): if start_times[start_pointer] < end_times[end_pointer]: # A new meeting starts before the last one ends used_rooms += 1 start_pointer += 1 else: # A meeting ends before the next one starts used_rooms -= 1 end_pointer += 1 # Update the maximum number of rooms required max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"# Problem Statement You are provided with a string and a set of delimiters. Your task is to implement the `split_string` function which splits the input string into a list of substrings based on the given set of delimiters. # Requirements 1. Implement a function called `split_string` in Python. 2. The function should take two arguments: - A string `s` which is the input string to be split. - A string `delimiters` which is a set of characters used as delimiters. 3. The function should return a list of substrings found in `s` split by any of the characters in `delimiters`. 4. Do not use Python\'s built-in `split()` method for this task. # Function Signature ```python def split_string(s: str, delimiters: str) -> list[str]: pass ``` # Input * A string `s` which can include any characters (e.g., `\'hello,world!goodbye\'`). * A string `delimiters` which includes delimiter characters (e.g., `\',!\'`). # Output * A list of strings split by the delimiters, maintaining the order they appear in `s`. # Constraints * The length of the input string `s` can be up to 1000 characters. * The length of the delimiters string can be up to 10 characters. # Example ```python assert split_string(\'hello,world!goodbye\', \',!\') == [\'hello\', \'world\', \'goodbye\'] assert split_string(\'one|two;three,four\', \'|;,\') == [\'one\', \'two\', \'three\', \'four\'] assert split_string(\'no delimiters\', \'\') == [\'no delimiters\'] ``` # Notes - Handling edge cases like an empty string or no delimiters in the input is essential. - Ensure that the implementation works efficiently with respect to both time and space complexity.","solution":"def split_string(s: str, delimiters: str) -> list[str]: Splits the input string s into a list of substrings based on given delimiters. if not delimiters: # If there are no delimiters, return the entire string as one element in the list return [s] result = [] current_word = [] delimiters_set = set(delimiters) for char in s: if char in delimiters_set: if current_word: result.append(\'\'.join(current_word)) current_word = [] else: current_word.append(char) if current_word: result.append(\'\'.join(current_word)) return result"},{"question":"# Programming Assessment Question **Context**: You are developing an e-commerce platform, and as part of your user analytics, you need to identify patterns in user browsing behavior. One of the tasks is to find which user sessions contain all the items from a given shopping list. **Task**: Implement a function `find_sessions_with_items()` that finds all user sessions that contain all the items from a given shopping list of product identifiers. Function Signature: ```python def find_sessions_with_items(sessions: list[set[str]], shopping_list: set[str]) -> list[int]: pass ``` Input: * `sessions`: List of sets of strings, where each set represents the product identifiers visited by a user during a session. * `shopping_list`: Set of strings, representing the product identifiers in a given shopping list. Output: * List of integers, representing the indices of the sessions that contain all the items from the shopping list. Constraints: * The input list `sessions` will contain at most 100,000 sessions. * Each session will include at most 1,000 product identifiers. * Each product identifier can have a length of up to 50 characters. * The `shopping_list` set will contain at most 100 product identifiers. * Indices in the output should be sorted in ascending order. Requirements: * Ensure your solution is efficient given the constraints mentioned above. * Handle edge cases such as empty sessions list and empty shopping list. Example: ```python find_sessions_with_items( [{\'item1\', \'item2\'}, {\'item3\', \'item4\', \'item2\'}, {\'item1\', \'item2\', \'item3\'}], {\'item1\', \'item2\'} ) # Output: [0, 2] find_sessions_with_items( [{\'apple\', \'banana\'}, {\'banana\', \'cherry\', \'apple\'}, {\'apple\', \'banana\', \'cherry\', \'date\'}, {\'pear\'}], {\'apple\', \'banana\'} ) # Output: [0, 1, 2] find_sessions_with_items( [{\'item5\', \'item6\'}, {\'item7\', \'item8\'}, {\'item9\', \'item10\'}], {\'item1\', \'item2\'} ) # Output: [] find_sessions_with_items([], {\'item1\'}) # Output: [] find_sessions_with_items([{\'item1\', \'item2\'}, {\'item3\', \'item4\'}], set()) # Output: [0, 1] ``` Additional Notes: * Make sure to validate the input and handle any edge cases appropriately. * Focus on the efficiency of your solution to handle large datasets within the constraints. * Ensure the function is consistent with the examples and processes the inputs correctly.","solution":"def find_sessions_with_items(sessions: list[set[str]], shopping_list: set[str]) -> list[int]: Function to find all user sessions that contain all the items from a given shopping list. :param sessions: List of sets of strings, where each set represents the product identifiers visited by a user during a session. :param shopping_list: Set of strings, representing the product identifiers in a given shopping list. :return: List of integers, representing the indices of the sessions that contain all the items from the shopping list. if not shopping_list: return list(range(len(sessions))) result = [] for i, session in enumerate(sessions): if shopping_list.issubset(session): result.append(i) return result"},{"question":"**Scenario**: You are part of a team developing a scheduling application that organizes and optimizes event timelines. One of the key components you are working on is a data structure that manages intervals of time. The intervals can overlap, and you need to implement methods to handle overlapping intervals and merge them efficiently. **Task**: Using a list of tuples where each tuple represents an interval with a start and end time, implement the following methods for managing the time intervals: 1. `merge_intervals(self, intervals: list[tuple[int, int]]) -> list[tuple[int, int]]`: This method should merge all overlapping intervals and return a list of the merged intervals. 2. `find_free_time(self, intervals: list[tuple[int, int]], start: int, end: int) -> list[tuple[int, int]]`: This method should find all free time intervals within a specified range (`start` to `end`) that are not covered by any of the given intervals. # Requirements: - **`merge_intervals` Method:** - **Input**: A list of tuples `intervals`, where each tuple represents an interval `[start_time, end_time]`. - **Output**: A list of merged intervals. - **`find_free_time` Method:** - **Input**: A list of tuples `intervals` (similar to the `merge_intervals` method) and two integers `start` and `end` that define the range to find free time. - **Output**: A list of non-overlapping intervals `[start_time, end_time]` that are free within the specified range. # Constraints: - Intervals are positive integers. - Intervals in the input list might be unsorted. - The start time of an interval is always less than the end time. - The `start` and `end` for `find_free_time` will be within the range of the intervals specified. Implement these methods considering efficiency and edge cases. **Function Signatures**: ```python def merge_intervals(self, intervals: list[tuple[int, int]]) -> list[tuple[int, int]]: pass def find_free_time(self, intervals: list[tuple[int, int]], start: int, end: int) -> list[tuple[int, int]]: pass ``` **Example**: ```python intervals = [(1, 3), (2, 6), (8, 10), (15, 18)] scheduler = Scheduler() merged_intervals = scheduler.merge_intervals(intervals) assert merged_intervals == [(1, 6), (8, 10), (15, 18)] free_time = scheduler.find_free_time(intervals, 0, 20) assert free_time == [(0, 1), (6, 8), (10, 15), (18, 20)] free_time_no_gaps = scheduler.find_free_time(merged_intervals, 0, 20) assert free_time_no_gaps == [(0, 1), (6, 8), (10, 15), (18, 20)] free_time_within_range = scheduler.find_free_time([(1, 4), (7, 10)], 1, 8) assert free_time_within_range == [(4, 7)] ``` # Notes: Ensure the solution handles: - Intervals that touch or overlap by even a small portion should be merged. - Cases where no intervals exist should be correctly managed by `find_free_time`. - Make sure to account for cases where the given range in `find_free_time` partially overlaps with actual intervals.","solution":"class Scheduler: def merge_intervals(self, intervals): Merges overlapping intervals. Args: intervals (list[tuple[int, int]]): A list of intervals to merge. Returns: list[tuple[int, int]]: A list of merged intervals. if not intervals: return [] sorted_intervals = sorted(intervals, key=lambda x: x[0]) merged = [sorted_intervals[0]] for current in sorted_intervals[1:]: last_merged = merged[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged.append(current) return merged def find_free_time(self, intervals, start, end): Finds free time intervals within a specified range. Args: intervals (list[tuple[int, int]]): A list of intervals. start (int): The start time of the range. end (int): The end time of the range. Returns: list[tuple[int, int]]: A list of free time intervals within the range. merged_intervals = self.merge_intervals(intervals) free_time = [] current_start = start for interval in merged_intervals: if current_start < interval[0]: free_time.append((current_start, interval[0])) current_start = max(current_start, interval[1]) if current_start < end: free_time.append((current_start, end)) return free_time"},{"question":"# Question: You are given a 2D grid that represents a map where \'1\' is land and \'0\' is water. An island is formed by connecting adjacent lands horizontally or vertically. You need to count the number of islands on this map. Write a function `num_islands` to solve this problem using Depth-First Search (DFS). Requirements: 1. Implement the function `num_islands` to count the number of islands in the grid. 2. The function should consider the map\'s boundaries and avoid counting the same island more than once. Input: - `grid`: list of list of str (each string element is either \'1\' for land or \'0\' for water) Output: - int (number of distinct islands) # Constraints: - 1 <= `len(grid)`, `len(grid[0])` <= 300 # Example: ```python grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] assert num_islands(grid) == 3 grid = [ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ] assert num_islands(grid) == 1 ``` # Notes: - The function should use DFS to explore an island completely before moving to another. - Each \'1\' cell connected horizontally or vertically forms part of the same island. - The function should handle empty grid inputs by returning 0. - Ensure edge cases where grid dimensions are minimal, such as a single cell or very large size, are correctly processed. # Implementation: Implement the `num_islands` function in Python. ```python def num_islands(grid): if not grid or not grid[0]: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' # Mark the cell as visited dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) island_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': island_count += 1 dfs(grid, i, j) return island_count ```","solution":"def num_islands(grid): if not grid or not grid[0]: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' # Mark the cell as visited dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) island_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': island_count += 1 dfs(grid, i, j) return island_count"},{"question":"# Question: Implement Kosaraju\'s Algorithm for Strongly Connected Components **Background:** Kosaraju\'s Algorithm is an efficient method for finding all the Strongly Connected Components (SCCs) in a given directed graph. A strongly connected component is a subgraph where every vertex is reachable from every other vertex in that subgraph. **Task:** Implement Kosaraju\'s Algorithm in Python to find and return all the SCCs in a given directed graph. The algorithm proceeds in two main steps: 1. Perform a Depth-First Search (DFS) to compute the finishing times of each vertex. 2. Perform a second DFS in the reverse graph, using the vertices in the order of their finishing times. **Function Signature:** ```python class Graph: def __init__(self, num_of_nodes: int) -> None: # Initialization function def add_edge(self, u_node: int, v_node: int) -> None: # Adds a directed edge to the graph def _dfs(self, node: int, visited: list[bool], stack: list[int]) -> None: # Depth-First Search that fills the stack with finishing times def _reverse_dfs(self, node: int, visited: list[bool], component: list[int]) -> None: # Depth-First Search used on the reversed graph to find SCCs def get_sccs(self) -> list[list[int]]: # Executes Kosaraju’s Algorithm and returns all SCCs in the graph ``` **Expected Input and Output Formats:** - `__init__: Graph(n)`: initializes a graph with `n` nodes. - `add_edge(u_node: int, v_node: int)`: adds a directed edge from `u_node` to `v_node`. - `_dfs(node: int, visited: list[bool], stack: list[int])`: performs DFS to determine the finishing order. - `_reverse_dfs(node: int, visited: list[bool], component: list[int])`: performs DFS on the reversed graph to collect SCCs. - `get_sccs() -> list[list[int]]`: executes Kosaraju\'s Algorithm and returns a list of SCCs, where each SCC is represented as a list of nodes. **Constraints:** 1. The number of nodes `n` will be between 2 and 1000. 2. The number of edges `m` will be between 1 and 10000. **Example:** ```python g = Graph(5) g.add_edge(1, 0) g.add_edge(0, 2) g.add_edge(2, 1) g.add_edge(0, 3) g.add_edge(3, 4) sccs = g.get_sccs() print(sccs) # Expected output: [[0, 2, 1], [3], [4]] ``` Implement the missing methods in the `Graph` class to complete Kosaraju\'s Algorithm, ensuring the identification of all SCCs in the directed graph.","solution":"class Graph: def __init__(self, num_of_nodes: int) -> None: self.graph = [[] for _ in range(num_of_nodes)] self.num_of_nodes = num_of_nodes def add_edge(self, u_node: int, v_node: int) -> None: self.graph[u_node].append(v_node) def _dfs(self, node: int, visited: list[bool], stack: list[int]) -> None: visited[node] = True for neighbor in self.graph[node]: if not visited[neighbor]: self._dfs(neighbor, visited, stack) stack.append(node) def _reverse_dfs(self, node: int, visited: list[bool], component: list[int], reverse_graph: list[list[int]]) -> None: visited[node] = True component.append(node) for neighbor in reverse_graph[node]: if not visited[neighbor]: self._reverse_dfs(neighbor, visited, component, reverse_graph) def _get_reverse_graph(self) -> list[list[int]]: reverse_graph = [[] for _ in range(self.num_of_nodes)] for u_node in range(self.num_of_nodes): for v_node in self.graph[u_node]: reverse_graph[v_node].append(u_node) return reverse_graph def get_sccs(self) -> list[list[int]]: visited = [False] * self.num_of_nodes stack = [] for node in range(self.num_of_nodes): if not visited[node]: self._dfs(node, visited, stack) reverse_graph = self._get_reverse_graph() visited = [False] * self.num_of_nodes sccs = [] while stack: node = stack.pop() if not visited[node]: component = [] self._reverse_dfs(node, visited, component, reverse_graph) sccs.append(component) return sccs"},{"question":"# Problem Description You are given a list of integers representing the weights of items and a target weight `W`. Your task is to implement both iterative and recursive versions of a function to determine if there is a subset of the given list that sums up to the target weight. This problem is a variation of the Subset Sum Problem. # Function Signature - **Iterative Version**: `def subset_sum(weights: list[int], target: int) -> bool` - **Recursive Version**: `def subset_sum_by_recursion(weights: list[int], target: int, n: int | None = None) -> bool` # Input - `weights`: A list of integers representing the weights of the items. - `target`: An integer representing the target weight to check for a subset. # Output Return `True` if there is a subset of the list that sums up to the target weight, otherwise return `False`. # Constraints 1. The list will have at most (10^5) elements. 2. The elements in the list are between (-1000) and (1000). 3. The target weight `W` will be between (-1000) and (1000). # Examples ```python assert subset_sum([3, 34, 4, 12, 5, 2], 9) == True assert subset_sum([3, 34, 4, 12, 5, 2], 30) == False assert subset_sum([1, 2, 3, 4, 5], 15) == True assert subset_sum_by_recursion([3, 34, 4, 12, 5, 2], 9) == True assert subset_sum_by_recursion([3, 34, 4, 12, 5, 2], 30) == False ``` # Explanation - In the first example, there are subsets like `[4, 5]` or `[3, 2, 4]` which sum up to `9`, so the function returns `True`. - In the second example, there is no subset that sums up to `30`, so the function returns `False`. - In the third example, the whole list sums up to `15`, so the function returns `True`. - The first recursive example finds a subset `[4, 5]` that sums to `9`, returning `True`. - The second recursive example confirms there is no subset that sums to `30`, returning `False`. # Notes - Pay special attention to cases such as when the list is empty, when the target is `0`, and when weights are negative. - Ensure your solution is efficient for large input sizes, especially the iterative implementation.","solution":"def subset_sum(weights: list[int], target: int) -> bool: Determines if there is a subset of weights that sums up to the target using an iterative approach. # Create a list to store subset sums n = len(weights) subset = [[False] * (target + 1) for _ in range(n + 1)] # When the sum is 0, we can always have an empty subset to make the sum 0 for i in range(n + 1): subset[i][0] = True # Fill the subset array in bottom up manner for i in range(1, n + 1): for t in range(1, target + 1): if t < weights[i - 1]: subset[i][t] = subset[i - 1][t] else: subset[i][t] = subset[i - 1][t] or subset[i - 1][t - weights[i - 1]] return subset[n][target] def subset_sum_by_recursion(weights: list[int], target: int, n: int = None) -> bool: Determines if there is a subset of weights that sums up to the target using a recursive approach. if n is None: n = len(weights) # Base Cases if target == 0: return True if n == 0: return False # If last element is greater than target, ignore it if weights[n - 1] > target: return subset_sum_by_recursion(weights, target, n - 1) # Check if sum can be obtained by any of the following # (a) including the last element # (b) excluding the last element return subset_sum_by_recursion(weights, target - weights[n - 1], n - 1) or subset_sum_by_recursion(weights, target, n - 1)"},{"question":"# Problem Statement You have been provided with an outline of a Python function that performs run-length encoding (RLE) on a string. RLE is a simple compression algorithm that replaces consecutive repeated characters with a single character followed by the number of repetitions. Your task is to implement the function `rle_encode(s: str) -> str` which takes in a string and returns its run-length encoded version. # Requirements and Constraints 1. **Input**: - `s`: A string composed of lowercase letters only (a-z). 2. **Output**: - Returns the run-length encoded version of the input string. 3. **Constraints**: - The length of the input string `s` will be in the range [1, 1000]. # Example **Input**: ```python s = \\"aabcccccaaa\\" ``` **Output**: ```python \\"a2b1c5a3\\" ``` **Explanation**: - The character \'a\' is repeated 2 times. - The character \'b\' is repeated 1 time. - The character \'c\' is repeated 5 times. - The character \'a\' is repeated 3 times. # Instructions 1. Implement the function `rle_encode(s: str) -> str`. 2. Ensure that the function processes the string correctly and efficiently. 3. Test your function thoroughly with different strings. ```python def rle_encode(s: str) -> str: # Your code goes here pass # Example usage: # s = \\"aabcccccaaa\\" # result = rle_encode(s) ``` --- This question aligns with the given structured problem statement, follows the presentation, difficulty level, and length guidelines, and introduces a fresh problem related to string manipulation and compression.","solution":"def rle_encode(s: str) -> str: Encodes the input string using run-length encoding (RLE). Parameters: - s (str): The input string composed of lowercase letters only. Returns: - str: The run-length encoded version of the input string. if not s: return \\"\\" encoded_str = [] i = 0 length = len(s) while i < length: count = 1 while i + 1 < length and s[i] == s[i + 1]: i += 1 count += 1 encoded_str.append(f\\"{s[i]}{count}\\") i += 1 return \'\'.join(encoded_str)"},{"question":"# Array Rotation Challenge Array rotation is a common operation that involves shifting the elements of an array to the left or right. In this challenge, you will implement a function to rotate an array a specified number of times in the desired direction. # Problem Statement Implement a function `rotate_array(arr: List[int], rotations: int, direction: str) -> List[int]` that rotates the elements of the given array either left or right by the given number of rotations. The function should: 1. Accept a list of integers `arr`, the number of rotations `rotations`, and a direction `direction` which can be either \'left\' or \'right\'. 2. Rotate the elements of the array based on the `direction` and the number of `rotations`. If `direction` is \'left\', shift elements to the left. If `direction` is \'right\', shift elements to the right. # Constraints - `arr` will have a length between 1 and 1,000, inclusive. - Each element in `arr` is an integer between -10^6 and 10^6. - `rotations` is a non-negative integer within the range of 0 to 10,000. - `direction` is a string that will be either \'left\' or \'right\'. # Example ```python def rotate_array(arr: List[int], rotations: int, direction: str) -> List[int]: pass # Example runs: print(rotate_array([1, 2, 3, 4, 5], 2, \'left\')) # Output: [3, 4, 5, 1, 2] print(rotate_array([1, 2, 3, 4, 5], 3, \'right\')) # Output: [3, 4, 5, 1, 2] ``` # Edge Cases to Consider 1. **No rotations (rotations = 0)**: The original array should be returned. 2. **Rotations larger than the array length**: Apply modular arithmetic to optimize the number of effective rotations. 3. **Array with one element**: Should return the same single element regardless of the number of rotations or direction. 4. **Negative elements in the array**: Ensure correctness of rotation despite the presence of negative values. # Guidelines - Optimize the solution to handle large values of `rotations` efficiently. - Consider edge cases and validate inputs before processing. - Aim for a clean and modular approach, keeping the code readable and maintainable. Hint: Effective rotations can be reduced using the length of the array to simplify operations (e.g., `rotations % len(arr)`).","solution":"from typing import List def rotate_array(arr: List[int], rotations: int, direction: str) -> List[int]: n = len(arr) # Return the array as is if no rotations are needed if rotations == 0 or n == 0: return arr # Effective rotations rotations %= n if direction == \'left\': return arr[rotations:] + arr[:rotations] elif direction == \'right\': return arr[-rotations:] + arr[:-rotations] else: raise ValueError(\\"Direction can only be \'left\' or \'right\'\\")"},{"question":"# Coding Question: Optimizing Network Latency Scenario: You are managing a network where each node represents a server, and each link represents a direct communication channel between two servers. The efficiency of the network depends greatly on the time it takes for data to travel from one server to another. Given a network of `n` servers and `m` direct links, each with an associated latency (time taken for data to travel that link), you need to determine the optimal way to rearrange the links to minimize the maximum latency between any two servers. Task: Implement a function `minimize_max_latency` that rearranges the direct links to achieve the minimal possible maximum latency. Function Signature: ```python def minimize_max_latency(n: int, links: List[Tuple[int, int, int]]) -> int: pass ``` Input: - `n` (int): The number of servers. - `links` (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers `u`, `v`, and `w` representing a direct link between servers `u` and `v` with latency `w`. Output: - Return the smallest possible maximum latency after optimizing the network links. Constraints: - `1 <= n <= 100` - `0 <= m <= 1000` - `1 <= u, v <= n` - `1 <= w <= 100` Example: ```python >>> minimize_max_latency(4, [(1, 2, 4), (1, 3, 7), (2, 3, 1), (3, 4, 2)]) 3 # The maximum latency is minimized to 3 after rearranging links between the servers. >>> minimize_max_latency(5, [(1, 2, 5), (2, 3, 3), (3, 4, 8), (4, 5, 2), (5, 1, 4)]) 5 # The optimal arrangement gives a maximum latency of 5. ``` Additional Information: Consider both direct and indirect paths when calculating potential latencies. The goal is to find a network configuration that minimizes the worst-case communication time between any two servers. Remember to consider edge cases where `m = 0` or `n = 1`. Efficient algorithms such as modified Dijkstra or Kruskal may be necessary to ensure performance within the given constraints.","solution":"def minimize_max_latency(n, links): # Kruskal\'s algorithm to find Minimum Spanning Tree (MST) using Union-Find def find(parent, i): if parent[i] == i: return i parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Sort the links based on their latency (weight) links.sort(key=lambda x: x[2]) # Initialize result mst_max_latency = 0 # Create n subsets with single elements parent = [i for i in range(n)] rank = [0] * n # Number of edges in MST is n-1 edge_count = 0 i = 0 # An index variable, used for sorted edges # Loop to consider the smallest weight edge until MST has n-1 edges while edge_count < n - 1 and i < len(links): u, v, w = links[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) # If including this edge doesn\'t cause cycle, include it in result # and increment the index of the result for next edge if x != y: edge_count += 1 mst_max_latency = max(mst_max_latency, w) union(parent, rank, x, y) return mst_max_latency"},{"question":"# Event Scheduler **Scenario**: You are tasked with implementing a function to manage events in an event scheduler. The events are identified by their start and end times, and no two events can overlap. Your objective is to write functions that add events to the scheduler and verify the addition adheres to the non-overlapping rule. **Requirements**: 1. **Class to Manage Events**: Create a class `EventScheduler` with the following methods: - **Method `__init__(self)`**: Initializes an empty scheduler. - **Method `add_event(self, start: int, end: int) -> bool`**: - **Input**: Two integers, `start` and `end`, indicating the start and end times of an event. - **Output**: Returns `True` if the event is added successfully without overlapping any existing event. Otherwise, returns `False`. 2. **Check for Overlapping**: Ensure the `add_event` method checks for overlapping events and prevents adding such events. The method should be efficient to handle a large number of events. 3. **Sorting Events**: Maintain the events in a sorted order based on their start times for efficient overlap checking. 4. **Performance Constraints**: Ensure the solution works efficiently for adding up to 100,000 events. **Constraints**: - Events in the scheduler are represented by non-negative integer start and end times. - The `start` time of an event is strictly less than its `end` time. - The solution should handle a large number of events and perform overlap checks efficiently. **Example**: ```python scheduler = EventScheduler() print(scheduler.add_event(1, 5)) # Output: True print(scheduler.add_event(5, 10)) # Output: True print(scheduler.add_event(2, 7)) # Output: False (overlaps with 1-5 and 5-10) print(scheduler.add_event(10, 15)) # Output: True # Events in scheduler: [(1, 5), (5, 10), (10, 15)] ``` This new question covers event scheduling, a common scenario in coding assessments. It requires knowledge of sorting, interval overlap checking, and efficient data structure usage, matching the complexity and scope of the provided questions.","solution":"class EventScheduler: def __init__(self): self.events = [] def add_event(self, start: int, end: int) -> bool: for event_start, event_end in self.events: if max(event_start, start) < min(event_end, end): return False self.events.append((start, end)) self.events.sort() return True"},{"question":"# Find Missing Number in Array Given an array of integers from 1 to n with one number missing, your task is to implement a function `find_missing_number` that finds and returns the missing number. The array will contain all the numbers from 1 to n except for the missing number, with no duplicates. Function Signature ```python def find_missing_number(nums: list[int]) -> int: pass ``` # Input: - A list of integers `nums` representing numbers from 1 to n with one number missing. The length of the list will be `n-1`. # Output: - An integer representing the missing number from the array. # Constraints: - The array can have a length between 1 and 10^6 integers. - Each number in the array is a unique integer ranging from 1 to n, inclusive. - No duplicates exist in the array. # Example: ```python assert find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6 assert find_missing_number([1, 2, 4, 5, 6]) == 3 assert find_missing_number([2, 4, 1, 3, 6, 7, 8, 9, 10]) == 5 assert find_missing_number([1]) == 2 ``` Notes: - Ensure your function can handle large input sizes efficiently. - Your solution should have a time complexity of O(n). The space complexity should be kept minimal, ideally O(1) additional space.","solution":"def find_missing_number(nums: list[int]) -> int: Finds and returns the missing number in the array containing numbers from 1 to n. Args: nums (list): List of integers from 1 to n with one number missing. Returns: int: The missing number. n = len(nums) + 1 total_sum = n * (n + 1) // 2 array_sum = sum(nums) return total_sum - array_sum"},{"question":"**Title**: Implement a Function for Detecting a Cycle in an Undirected Graph **Objective**: Write a function to determine if a given undirected graph contains a cycle. **Function Signature**: ```python def has_cycle(graph: Graph) -> bool: pass ``` **Input**: * graph (Graph): An instance of the `Graph` class, with vertices and edges already added. **Output**: * bool: A boolean value indicating whether the graph contains a cycle. **Constraints**: * The graph may contain between 1 and 10^3 vertices. * Vertices are labeled with non-negative integers. * The graph can have self-loops and be disconnected. **Performance Requirements**: * Time Complexity: `O(V + E)` * Space Complexity: `O(V)` **Context**: You are given a `Graph` class that allows you to add vertices and edges. The class also provides methods to check the adjacency of vertices and iterate over the neighbors of a vertex. Your task is to implement the function `has_cycle` that detects if there is any cycle in the undirected graph. **Example**: ```python # Example graph usage g = Graph() g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(2, 3) result = has_cycle(g) print(result) # Output: True ``` **Note**: * Solve the problem using Depth-First Search (DFS) or Union-Find algorithm. * Pay special attention to edge cases, such as self-loops and disconnected components. * Consider handling each vertex and edge carefully to ensure an efficient implementation while avoiding unnecessary checks. The question should match the complexity, style, and scope of the existing question and explore a core concept in graph theory, maintaining diversity in problem scenarios yet consistency in the challenge level presented.","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, u, v): if u not in self.adjacency_list: self.adjacency_list[u] = [] if v not in self.adjacency_list: self.adjacency_list[v] = [] self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def get_vertices(self): return list(self.adjacency_list.keys()) def get_neighbors(self, v): return self.adjacency_list.get(v, []) def has_cycle(graph: Graph) -> bool: def dfs(vertex, parent): visited.add(vertex) for neighbor in graph.get_neighbors(vertex): if neighbor not in visited: if dfs(neighbor, vertex): return True elif neighbor != parent: return True return False visited = set() for vertex in graph.get_vertices(): if vertex not in visited: if dfs(vertex, -1): return True return False"},{"question":"# Problem Statement You are given a list of strings where each string is a word consisting of lowercase alphabetic characters. You need to sort the words in the list based on the sum of the alphabetic positions of their characters (A=1, B=2, ..., Z=26). In case of a tie, maintain the original order of the words with the same alphabetic position sum. # Function Implementation **Function**: `sort_by_alphabetic_weight(words: list[str]) -> list[str]` - **Input**: A list of strings where each string consists of lowercase alphabetic characters. - **Output**: A list of strings sorted based on the alphabetic weight (sum of positions of the characters in the alphabet). - **Constraints**: The input list will always contain at least one string, and all strings will consist of lowercase alphabetic characters only. # Requirements * Your function should handle edge cases such as strings with the same alphabetic weight. * The implementation should maintain the original order for words with the same alphabetic weight. * The time complexity of your implementation should be efficient and within acceptable limits for a typical coding assessment. # Example ```python def sort_by_alphabetic_weight(words: list[str]) -> list[str]: Sort the list of words based on their alphabetic weight (sum of the positions of the characters in the alphabet). :param words: list of strings to be sorted :return: list of sorted strings >>> sort_by_alphabetic_weight([\\"apple\\", \\"banana\\", \\"cherry\\"]) [\'banana\', \'apple\', \'cherry\'] >>> sort_by_alphabetic_weight([\\"dog\\", \\"cat\\", \\"bat\\"]) [\'bat\', \'cat\', \'dog\'] >>> sort_by_alphabetic_weight([\\"a\\", \\"aa\\", \\"aaa\\"]) [\'a\', \'aa\', \'aaa\'] pass ``` # Task Implement the `sort_by_alphabetic_weight` function in Python to meet the above specifications. Ensure to handle edge cases and write efficient, clean code.","solution":"def sort_by_alphabetic_weight(words: list[str]) -> list[str]: Sort the list of words based on their alphabetic weight (sum of the positions of the characters in the alphabet). :param words: list of strings to be sorted :return: list of sorted strings def alphabetic_weight(word): # Calculate the sum of positions of the characters in the word (a=1, b=2, ..., z=26) return sum(ord(char) - ord(\'a\') + 1 for char in word) # Sort words by their alphabetic weight sorted_words = sorted(words, key=alphabetic_weight) return sorted_words"},{"question":"# Sentence Reversal with Capitalization Preservation You are provided with a transformation task where you need to write a function that can reverse the order of words in a given sentence while preserving the capitalization pattern of the original input. This involves maintaining the original starting capital letters and any mix of uppercase/lowercase letters within the words after reordering. # Requirements 1. **Function Implementation**: Implement a function `reverse_words(sentence: str) -> str` that takes a single string argument `sentence`. This function should reverse the order of the words in the sentence while maintaining the original capitalization patterns within each word. 2. **Preservation**: Ensure that the capitalization of each character within a word is preserved after the word order is reversed. # Input/Output Format - **Input**: - `reverse_words(sentence: str) -> str`: Reverses the order of words in the input string while maintaining the original capitalization pattern. - **Output**: - The function should return a string representing the sentence with the words’ order reversed and original capitalization preserved. # Performance Requirements - Ensure that the solution maintains a time complexity of `O(n)` where `n` is the length of the string. - Space complexity should remain `O(1)` aside from the space used to store the output string. # Constraints - The sentence will contain only alphabetic characters and spaces. - Words will be separated by exactly one space. - The input sentence will not have leading or trailing spaces. # Example Workflow ```python reversed_sentence = reverse_words(\\"Python is GREAT and the Community is STRONG\\") print(reversed_sentence) # OUTPUT: \\"STRONG is Community the and GREAT is Python\\" reversed_sentence = reverse_words(\\"hello WORLD\\") print(reversed_sentence) # OUTPUT: \\"WORLD hello\\" ``` # Hints for Consideration - Think about how you can split the sentence into individual words while preserving their individual capitalization. - Consider using built-in Python string methods to help with splitting and joining the words back together. - Ensure that you properly handle strings with irregular capitalization patterns within the words.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in the input string while maintaining the original capitalization pattern within each word. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Question: Implement a Matrix Rotation Checker You are given two NxN 2D matrices (lists of lists) of integers, `matrix1` and `matrix2`. Write a function to determine if `matrix2` is a rotation of `matrix1`. The matrix can be rotated by 90 degrees clockwise any number of times (0 to 3). # Input * Two matrices `matrix1` and `matrix2`, both NxN where 1 ≤ N ≤ 10, and each element is an integer. # Output * Return a boolean `True` if `matrix2` is a rotation of `matrix1`, otherwise return `False`. # Example Input ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix2 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Output ```python True ``` Input ```python matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [4, 3], [2, 1] ] ``` Output ```python False ``` # Function Signature ```python def is_matrix_rotation(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: pass ``` # Constraints - Ensure your function handles all valid rotations efficiently. - No external libraries should be used except for standard Python libraries.","solution":"def rotate_matrix_90(matrix): Rotates the given NxN matrix by 90 degrees clockwise. N = len(matrix) return [[matrix[N - 1 - j][i] for j in range(N)] for i in range(N)] def is_matrix_rotation(matrix1, matrix2): Checks if matrix2 is a rotation of matrix1 by 0, 90, 180, or 270 degrees. if matrix1 == matrix2: return True rotated_matrix = matrix1 for _ in range(3): rotated_matrix = rotate_matrix_90(rotated_matrix) if rotated_matrix == matrix2: return True return False"},{"question":"# Stock Trading Transaction Cost Minimization You are provided with daily stock prices for a company over a period of days. Your task is to implement a function that calculates the minimum cost incurred for a specified number of buying and selling transactions. Each transaction consists of buying the stock one day and selling it on a subsequent day. Due to market constraints, you can only hold one stock at a time, meaning you must sell the stock before buying a new one. # Input - An array `prices` where `prices[i]` is the stock price on day `i`. - An integer `k` which represents the maximum number of buy-sell transactions allowed. # Output - A single integer representing the minimum cost incurred for using the transaction strategy. # Constraints - 1 ≤ `prices.length` ≤ 100 - 1 ≤ `prices[i]` ≤ 10^4 - 1 ≤ `k` ≤ min(10, `prices.length`//2) # Example ```python def min_cost(prices, k): # Implementing a dynamic programming approach to minimize cost with k transactions if not prices or k == 0: return 0 n = len(prices) if 2 * k >= n: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) # Initialize DP tables dp = [[0] * (k + 1) for _ in range(n)] for j in range(1, k + 1): max_diff = -prices[0] for i in range(1, n): dp[i][j] = max(dp[i - 1][j], prices[i] + max_diff) max_diff = max(max_diff, dp[i][j - 1] - prices[i]) return dp[-1][-1] # Example main invocation if __name__ == \\"__main__\\": prices = [3, 2, 6, 5, 0, 3] k = 2 print(min_cost(prices, k)) # Output should be 7 ``` **Note**: The presented solution uses a dynamic programming approach to efficiently calculate the minimum transaction cost while adhering to the constraints. Feel free to enhance the solution and include additional helper functions if needed.","solution":"def min_cost(prices, k): This function calculates the minimum cost incurred for a specified number of buying and selling transactions. :param prices: List of integers where prices[i] is the stock price on day i. :param k: Integer indicating the number of allowed buy-sell transactions. :return: Integer representing the minimum cost incurred for using the transaction strategy. if not prices or k == 0: return 0 n = len(prices) if 2 * k >= n: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) dp = [[0] * (k + 1) for _ in range(n)] for j in range(1, k + 1): max_diff = -prices[0] for i in range(1, n): dp[i][j] = max(dp[i - 1][j], prices[i] + max_diff) max_diff = max(max_diff, dp[i][j - 1] - prices[i]) return dp[-1][-1]"},{"question":"# Coding Assessment Question Task You are required to implement a function that takes a string representing a bracket sequence and determines the number of moves needed to make the sequence valid. A valid bracket sequence is one where every opening bracket has a matching closing bracket and they are correctly nested. For this task, you will only consider the round brackets `(` and `)`. Function Signature ```python def min_bracket_move(s: str) -> int: ``` # Input - `s` (string): A string consisting of characters `(` and `)` only, representing the bracket sequence. # Output - (int): Minimum number of moves required to make the bracket sequence valid. # Constraints - The length of string `s` is between 1 and 1000 inclusive. - A move is defined as either adding or removing one bracket. # Requirements * Determine the minimum number of moves needed to balance the given bracket sequence. * Treat the input string as case-sensitive and only containing the characters `(` and `)`. # Example Here is an example of how your function might be called and what the expected output would be: ```python assert min_bracket_move(\\"(()\\") == 1 # Need one \')\' to balance assert min_bracket_move(\\")(\\") == 2 # Need one \'(\' at the start and one \')\' at the end assert min_bracket_move(\\"\\") == 0 # Already balanced ``` # Notes * Ensure memory and time efficiency suitable for the input constraints. * Utilize a stack or counter-based approach to efficiently calculate the balance required for the sequence.","solution":"def min_bracket_move(s: str) -> int: Returns the minimum number of moves required to make the bracket sequence valid. A move is defined as either adding or removing one bracket. balance = 0 moves = 0 for char in s: if char == \'(\': balance += 1 else: # char == \')\' if balance > 0: balance -= 1 else: moves += 1 # Balance holds the number of unmatched \'(\' brackets return moves + balance"},{"question":"# Calculate the Number of Unique Subarrays Context In the analysis of numerical arrays, it\'s often useful to determine the diversity of subarrays. A subarray is a contiguous portion of an array. Specifically, we need to find out how many unique subarrays can be formed from a given array where each element of the subarray has distinct elements. Task Write a function `countUniqueSubarrays(arr: List[int]) -> int` that returns the total number of unique subarrays in which all elements are distinct. Example ``` Input: [1, 2, 1] Output: 5 Explanation: The unique subarrays with all distinct elements are: [1], [2], [1, 2], [2, 1], and [1] again in the third position So, the total count is 5. Input: [4, 4, 4] Output: 3 Explanation: The unique subarrays with all distinct elements are: [4], [4], and [4] So, the total count is 3. ``` # Constraints - The input array `arr` contains `n` integers such that 1 ≤ n ≤ 2000. - Each element of `arr` is an integer between 1 and 10000. Hint Consider using a sliding window approach to efficiently count the number of valid subarrays.","solution":"def countUniqueSubarrays(arr): Returns the count of unique subarrays with all distinct elements. Parameters: arr (list[int]): The input array of integers. Returns: int: The count of unique subarrays with all distinct elements. n = len(arr) seen = set() left = 0 count = 0 for right in range(n): while arr[right] in seen: seen.remove(arr[left]) left += 1 seen.add(arr[right]) count += right - left + 1 return count"},{"question":"# Fibonacci Number Finder You are tasked with implementing a function that generates the nth Fibonacci number. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. Function Signature ```python def fibonacci(n: int) -> int: pass ``` Input and Output * **Input** * `n` (int): The position in the Fibonacci sequence for which the number is to be found. (0 <= n <= 10^6) * **Output** * (int): Returns the nth Fibonacci number. Constraints * The function should raise a `ValueError` if `n` is a negative number. * The function should raise a `TypeError` if `n` is not an integer. Example ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040 ``` Notes * Consider using an efficient algorithm to handle large values of `n`, such as matrix exponentiation or iterative methods with memoization. * Avoid recursive solutions that can lead to long-running executions and stack overflow issues for large `n`. This new question integrates well with the existing set, maintaining a similar structure, complexity, and domain focus on algorithmic problem-solving with an emphasis on efficiency for large inputs.","solution":"def fibonacci(n: int) -> int: if not isinstance(n, int): raise TypeError(\\"Input must be an integer.\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Calculate the Area of Overlapping Rectangles You need to write a function that calculates the area of the overlapping region between two rectangles. Each rectangle is defined by its bottom-left and top-right corners. Function Requirements: `overlap_area` Your function needs to: - Accept two rectangles as inputs. - Each rectangle is represented by a tuple of four integers: `(x1, y1, x2, y2)`, where `(x1, y1)` is the bottom-left corner and `(x2, y2)` is the top-right corner. - Calculate and return the area of the overlapping region. If there is no overlap, return `0`. # Input: - `rect1` (tuple): A tuple of four integers representing the first rectangle. - `rect2` (tuple): A tuple of four integers representing the second rectangle. # Output: - (int): The area of the overlapping region. # Example: ```python assert overlap_area((0, 0, 2, 2), (1, 1, 3, 3)) == 1 assert overlap_area((0, 0, 1, 1), (1, 1, 2, 2)) == 0 assert overlap_area((0, 0, 3, 3), (1, 1, 2, 2)) == 1 ``` # Solution Skeleton Here is a skeleton code for you to complete: ```python def overlap_area(rect1: tuple, rect2: tuple) -> int: x1 = max(rect1[0], rect2[0]) y1 = max(rect1[1], rect2[1]) x2 = min(rect1[2], rect2[2]) y2 = min(rect1[3], rect2[3]) # Add your solution here pass # Test your implementation if __name__ == \\"__main__\\": assert overlap_area((0, 0, 2, 2), (1, 1, 3, 3)) == 1 assert overlap_area((0, 0, 1, 1), (1, 1, 2, 2)) == 0 assert overlap_area((0, 0, 3, 3), (1, 1, 2, 2)) == 1 ``` # Description 1. Analyze the bottom-left and top-right corners of both rectangles. 2. Calculate the overlapping region by determining the maximum of the lower coordinates and the minimum of the upper coordinates. 3. If the overlapping region is valid, calculate the overlapping area; otherwise, return `0` if there is no overlap.","solution":"def overlap_area(rect1: tuple, rect2: tuple) -> int: # Unpack the rectangle coordinates x1, y1, x2, y2 = rect1 x3, y3, x4, y4 = rect2 # Calculate the maximum of the left boundaries and the minimum of the right boundaries overlap_x1 = max(x1, x3) overlap_y1 = max(y1, y3) overlap_x2 = min(x2, x4) overlap_y2 = min(y2, y4) # Calculate the overlap dimensions if valid overlap_width = overlap_x2 - overlap_x1 overlap_height = overlap_y2 - overlap_y1 if overlap_width > 0 and overlap_height > 0: return overlap_width * overlap_height else: return 0"},{"question":"# Problem Statement In a grid of characters, words can be formed by connecting letters sequentially in any direction: vertically, horizontally, or diagonally. Write a function that finds the longest word that exists in a given dictionary (`word_list`) and can be traced in the grid. # Detailed Requirements * Define a function `longest_word_in_grid(grid: List[List[str]], word_list: List[str]) -> str` that finds and returns the longest word from the `word_list` that can be traced in the grid. * A word can be traced in any direction (up, down, left, right, or diagonals). * The same cell in the grid cannot be used more than once for the same word. # Input and Output - **Input**: - `grid`: A 2D list of characters representing the grid (1 ≤ len(grid) ≤ 10, 1 ≤ len(grid[0]) ≤ 10). - `word_list`: A list of valid words (1 ≤ len(word_list) ≤ 100, 1 ≤ len(word_list[i]) ≤ 10). - **Output**: A string, the longest word found that can be traced in the grid. If multiple words have the same length, return any one of them. If no word can be found, return an empty string. **Constraints**: 1. The function should efficiently handle grids of sizes up to 10x10. 2. The grid contains only lowercase English letters. 3. The `word_list` contains only lowercase English words. # Example Case ```python grid = [ [\'o\', \'a\', \'a\', \'n\'], [\'e\', \'t\', \'a\', \'e\'], [\'i\', \'h\', \'k\', \'r\'], [\'i\', \'f\', \'l\', \'v\'] ] word_list = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] longest_word_in_grid(grid, word_list) -> \\"oath\\" ``` # Explanation: Function should explore all possible directions to trace each word in the `word_list` and determine the longest one that can be formed. \\"oath\\" is the longest word that can be traced in this example.","solution":"from typing import List def longest_word_in_grid(grid: List[List[str]], word_list: List[str]) -> str: def dfs(x, y, word, index): if index == len(word): return True if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != word[index]: return False temp = grid[x][y] grid[x][y] = \\"#\\" found = dfs(x+1, y, word, index+1) or dfs(x-1, y, word, index+1) or dfs(x, y+1, word, index+1) or dfs(x, y-1, word, index+1) or dfs(x+1, y+1, word, index+1) or dfs(x+1, y-1, word, index+1) or dfs(x-1, y+1, word, index+1) or dfs(x-1, y-1, word, index+1) grid[x][y] = temp return found longest_word = \\"\\" for word in word_list: word_found = False for i in range(len(grid)): for j in range(len(grid[0])): if dfs(i, j, word, 0): word_found = True break if word_found: break if word_found and len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"# Coding Assessment Question Scenario: You are developing a scheduling system for a conference that automatically generates time slots for talks based on their estimated durations. Different talks have different durations, and they must fit within a specified time period. Your task is to implement an algorithm that schedules these talks optimally, minimizing the number of unused slots and ensuring no overlap. Task: Implement a function `schedule_talks` that receives a list of talk durations and the total duration of the conference day. The function should arrange the talks within the conference day such that the time slots are used efficiently. Function: ```python def schedule_talks(talk_durations: List[int], total_duration: int) -> List[List[int]]: Schedules talks within a specified total duration, ensuring no overlaps and optimal usage of time slots. Args: talk_durations (List[int]): A list of durations for each talk. total_duration (int): The total available duration for the conference day. Returns: List[List[int]]: A list where each inner list contains talk durations scheduled in the same time slot. ``` Input: * `talk_durations` (List[int]): A list of integers where each integer represents the duration of a talk in minutes. * `total_duration` (int): An integer representing the total available duration of the conference day in minutes. Output: * A list of lists where each inner list represents a set of talks scheduled in the same non-overlapping time slot. Constraints: * Each talk must be scheduled in its entirety within the available time. * The sum of durations in each slot should not exceed `total_duration`. * All talks must be scheduled. Example: ```python # Given talk durations [30, 60, 90, 45] and total duration of 120 minutes schedule = schedule_talks([30, 60, 90, 45], 120) print(schedule) # Output might be: [[90, 30], [60, 45]] or any other valid arrangement # Given talk durations [20, 30, 50, 60, 90] and total duration of 100 minutes schedule = schedule_talks([20, 30, 50, 60, 90], 100) print(schedule) # Output might be: [[50, 30, 20], [90, 10]] or any other valid arrangement ``` The output list should ensure that all talks are scheduled optimally within the given total duration and time slots do not exceed the total available duration.","solution":"from typing import List def schedule_talks(talk_durations: List[int], total_duration: int) -> List[List[int]]: Schedules talks within a specified total duration, ensuring no overlaps and optimal usage of time slots. Args: talk_durations (List[int]): A list of durations for each talk. total_duration (int): The total available duration for the conference day. Returns: List[List[int]]: A list where each inner list contains talk durations scheduled in the same time slot. talk_durations.sort(reverse=True) slots = [] for talk in talk_durations: placed = False for slot in slots: if sum(slot) + talk <= total_duration: slot.append(talk) placed = True break if not placed: slots.append([talk]) return slots"},{"question":"# Coding Assessment Question Background A financial software application deals with a scenario where a company\'s expenses need to be categorized and reported based on certain criteria. The application should automatically allocate any transaction to one of several predefined expense categories based on the transaction\'s description and amount. Objective Your task is to implement a function that will categorize a list of transactions based on predefined rules. Each category has its own set of rules defined by keywords in the transaction description and amount ranges. Function Signature ```python def categorize_transactions(transactions: list, categories: dict) -> dict: ``` Input * `transactions` (list): A list of transactions where each transaction is represented by a tuple containing `(description: str, amount: float)`. * `categories` (dict): A dictionary where keys are category names and values are dictionaries with two keys: \\"keywords\\" (a list of strings) and \\"amount_range\\" (a tuple of two floats representing the minimum and maximum amounts inclusive). Output * Return a dictionary where the keys are category names and the values are lists of transactions that belong to that category. Constraints 1. Each transaction must belong to exactly one category. 2. Keywords in the categories are case insensitive. 3. A transaction description must contain at least one keyword from the corresponding category. 4. A transaction\'s amount must fall within the specified range for the corresponding category. Example 1 ```python transactions = [ (\\"Office Supplies\\", 150.00), (\\"Team Lunch\\", 70.00), (\\"Conference Travel\\", 500.00), ] categories = { \\"Office Expenses\\": {\\"keywords\\": [\\"Office\\", \\"Supplies\\"], \\"amount_range\\": (100, 200)}, \\"Travel Expenses\\": {\\"keywords\\": [\\"Travel\\", \\"Flight\\"], \\"amount_range\\": (300, 1000)}, \\"Meals\\": {\\"keywords\\": [\\"Lunch\\", \\"Dinner\\", \\"Meal\\"], \\"amount_range\\": (50, 100)}, } expected_output = { \\"Office Expenses\\": [(\\"Office Supplies\\", 150.00)], \\"Travel Expenses\\": [(\\"Conference Travel\\", 500.00)], \\"Meals\\": [(\\"Team Lunch\\", 70.00)], } assert categorize_transactions(transactions, categories) == expected_output ``` Notes * Ensure that all matching criteria (description keywords and amount range) are satisfied for a transaction to be categorized. * Transactions should not fall under multiple categories. * Handle edge cases where no transactions match any category by returning an empty list for those categories. * Validate inputs rigorously, including type checks and value ranges. Your implementation should accurately allocate transactions to the predefined categories, ensuring all constraints and rules are followed.","solution":"def categorize_transactions(transactions, categories): results = {category: [] for category in categories} for description, amount in transactions: for category, rules in categories.items(): keywords = rules[\\"keywords\\"] min_amount, max_amount = rules[\\"amount_range\\"] if any(keyword.lower() in description.lower() for keyword in keywords) and min_amount <= amount <= max_amount: results[category].append((description, amount)) break return results"},{"question":"You need to implement a function that counts the number of distinct words in a given sentence and returns this count. The words in the sentence are case-insensitive, and punctuation marks should not be considered part of the words. **Function Definition**: You must implement a function called `count_distinct_words(sentence: str) -> int`. # Detailed Function Description * **Input**: - `sentence` (str): A string containing the sentence. The sentence may include punctuation and is guaranteed to have at least one word. * **Output**: - Returns an integer which is the count of distinct case-insensitive words. # Constraints - Words are case-insensitive, meaning \\"Hello\\" and \\"hello\\" should be considered the same word. - Punctuation marks (e.g., \'.\', \',\', \'!\', \'?\') should be ignored when determining distinct words. - The function should raise a `ValueError` if the provided `sentence` is an empty string. # Example ```python >>> count_distinct_words(\\"Hello, World! Hello World.\\") 2 >>> count_distinct_words(\\"Coding is fun, and coding is great!\\") 5 ``` # Additional Requirements: * Write tests specific to: 1. Edge case handling (e.g., empty string or sentence with only one word multiple times). 2. Realistic handling of typical sentences with varied words and punctuation. Hints - Use regular expressions or the `string` module to handle punctuation. - Consider converting the sentence to lower case to handle case insensitivity. - Use a set to store words for counting distinct entries efficiently.","solution":"import re def count_distinct_words(sentence: str) -> int: Returns the number of distinct case-insensitive words in the provided sentence, ignoring punctuation marks. Args: sentence (str): The input sentence. Returns: int: The count of distinct words. Raises: ValueError: If the input sentence is empty. if not sentence.strip(): raise ValueError(\\"The input sentence should not be empty.\\") # Remove punctuation using regular expression and convert to lowercase processed_sentence = re.sub(r\'[^ws]\', \'\', sentence).lower() # Split the sentence into words words = processed_sentence.split() # Use a set to find distinct words distinct_words = set(words) return len(distinct_words)"},{"question":"# Problem Statement: You are asked to write a Python function to process a given log file and summarize the error occurrences. Each line in the log file represents an entry, starting with a timestamp followed by the log level and message. Your task is to identify entries with the \\"ERROR\\" log level, count the occurrences of each unique error message, and save this summary in JSON format to a specified file. Handle edge cases such as missing files or invalid log entries gracefully. # Function Signature: ```python def summarize_errors(log_filename: str, output_filename: str) -> None: Processes a log file to identify and count unique error occurrences and saves the summary to a JSON file. Parameters: log_filename (str): Name of the input log file containing log entries. output_filename (str): Name of the output file to save the error summary in JSON format. Raises: FileNotFoundError: If the log file does not exist. ValueError: If the log entries are not in the expected format. IOError: If there is an error while writing to the output file. ``` # Input: - `log_filename`: A string representing the name of the log file to be processed. - `output_filename`: A string representing the name of the JSON file where to save the error summary. # Output: - None (Details should be written to the given file). # Example Invocation: ```python # Summarize errors from \'server.log\' and save to \'error_summary.json\' summarize_errors(\'server.log\', \'error_summary.json\') ``` # Constraints: 1. **File Handling**: The function should raise a `FileNotFoundError` if `log_filename` does not exist. 2. **Error Handling**: Gracefully handle cases where log entries do not have the expected format. Raise a `ValueError` if the log entry format is invalid. 3. **Log Processing**: Only consider entries with the log level \\"ERROR\\". Ignore other log levels. 4. **Output Format**: Ensure the output summary is written in correct JSON format. 5. **Performance**: Optimize file reading and processing to handle large log files efficiently. # Notes: * A log entry is typically formatted as: `2023-10-10 14:23:45 ERROR This is an error message` * Use Python\'s built-in JSON library for writing the summary to a file. * Include comments and document the code thoroughly to explain the logic and error handling involved.","solution":"import json import os import re from collections import defaultdict def summarize_errors(log_filename: str, output_filename: str) -> None: Processes a log file to identify and count unique error occurrences and saves the summary to a JSON file. Parameters: log_filename (str): Name of the input log file containing log entries. output_filename (str): Name of the output file to save the error summary in JSON format. Raises: FileNotFoundError: If the log file does not exist. ValueError: If the log entries are not in the expected format. IOError: If there is an error while writing to the output file. if not os.path.exists(log_filename): raise FileNotFoundError(f\\"The log file \'{log_filename}\' does not exist.\\") error_counts = defaultdict(int) pattern = re.compile(r\'^d{4}-d{2}-d{2} d{2}:d{2}:d{2} ERROR (.+)\') try: with open(log_filename, \'r\') as file: for line in file: match = pattern.match(line.strip()) if match: error_message = match.group(1) error_counts[error_message] += 1 elif not re.match(r\'^d{4}-d{2}-d{2} d{2}:d{2}:d{2}\', line.strip()): raise ValueError(f\\"Invalid log entry found: {line.strip()}\\") except OSError as e: raise IOError(f\\"An error occurred while reading the log file: {str(e)}\\") try: with open(output_filename, \'w\') as outfile: json.dump(error_counts, outfile, indent=4) except OSError as e: raise IOError(f\\"An error occurred while writing to the output file: {str(e)}\\")"},{"question":"# Detect Island Perimeter **Context**: You are a developer working on a geographic information system. One of the key features is the ability to analyze island shapes within mapped regions. An essential part of this analysis involves determining the perimeter of these islands. **Objective**: Write a function that calculates the perimeter of an island represented in a 2D grid. The grid is composed of \'1\'s (land) and \'0\'s (water). Each cell is a square with a side length of 1. The island is connected horizontally and vertically (but not diagonally). **Function Signature**: ```python def island_perimeter(grid: List[List[int]]) -> int: pass ``` **Input and Output Format**: * **Input**: A 2D list of integers where `grid[i][j]` is `1` for land and `0` for water. * **Output**: An integer representing the perimeter of the island. **Constraints**: * The grid lengths will not exceed `100 x 100`. * There is exactly one island (one or more connected land cells). **Example Input and Output**: ```python # Example Input 1 grid = [ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0] ] # Example Output 1 print(island_perimeter(grid)) # Output: 16 # Example Input 2 grid = [ [1] ] # Example Output 2 print(island_perimeter(grid)) # Output: 4 # Example Input 3 grid = [ [1, 0] ] # Example Output 3 print(island_perimeter(grid)) # Output: 4 ``` **Task Requirements**: 1. Implement the function to return the correct perimeter for any given grid respecting constraints. 2. Include edge cases in your solution like single-cell islands or maximum grid sizes. 3. Optimize for clarity and performance without sacrificing the accuracy of results. **Notes**: 1. Make sure to properly handle edge cells and avoid index errors. 2. Utilize helper functions where necessary for clarity. 3. Visualizing the grid might help understand the problem more intuitively.","solution":"def island_perimeter(grid): rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 if r > 0 and grid[r-1][c] == 1: # check the cell above perimeter -= 2 if c > 0 and grid[r][c-1] == 1: # check the cell to the left perimeter -= 2 return perimeter"},{"question":"# Context You are tasked with implementing a basic Integer Set class in Python that supports fundamental operations such as insertion, deletion, membership testing, and retrieving the size of the set. This set should mimic the behavior of Python\'s built-in set, but only allow integer elements. # Problem Statement Implement an `IntegerSet` class that supports the following methods: - `add(self, element)`: Inserts the integer element into the set. - `remove(self, element)`: Removes the integer element from the set. Raises a `KeyError` if the element is not in the set. - `__contains__(self, element)`: Returns `True` if the integer element is in the set, `False` otherwise. - `__len__(self)`: Returns the number of elements in the set. - `clear(self)`: Removes all elements from the set. - `elements(self)`: Returns a list of all elements in the set. Order is not guaranteed. # Requirements 1. Ensure that the `IntegerSet` class only allows integer elements. Raise a `TypeError` if a non-integer element is added. 2. Your implementation should handle duplicate elements gracefully, ensuring no duplicate entries exist. 3. Aim for an average time complexity of O(1) for add, remove, and membership testing operations. # Constraints - Assume the input elements are within the range of valid Python integers. - The operations should behave as close as possible to the operations of Python\'s built-in set, but restricted to integers. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python class IntegerSet: def __init__(self): # Initialize your data structure pass def add(self, element): # Insert the integer element into the set pass def remove(self, element): # Remove the integer element from the set pass def __contains__(self, element): # Check if the element exists in the set pass def __len__(self): # Return the number of elements in the set pass def clear(self): # Remove all elements from the set pass def elements(self): # Return a list of all elements in the set pass ``` # Example Usage ```python iset = IntegerSet() iset.add(1) iset.add(2) iset.add(3) print(1 in iset) # Output: True print(len(iset)) # Output: 3 iset.remove(2) print(2 in iset) # Output: False print(len(iset)) # Output: 2 iset.clear() print(len(iset)) # Output: 0 print(iset.elements()) # Output: [] ```","solution":"class IntegerSet: def __init__(self): self._set = set() def add(self, element): if not isinstance(element, int): raise TypeError(\\"Only integers are allowed\\") self._set.add(element) def remove(self, element): self._set.remove(element) def __contains__(self, element): return element in self._set def __len__(self): return len(self._set) def clear(self): self._set.clear() def elements(self): return list(self._set)"},{"question":"# Coding Assessment Question: Fibonacci Sequence Generator **Context**: You are tasked with developing a robust number sequence generator for a mathematical software tool. One of the essential number sequences to be included is the Fibonacci sequence which is widely used in various computational algorithms. # Task: Implement a Python function named `generate_fibonacci_sequence` that generates the first `n` numbers of the Fibonacci sequence. The sequence starts with 0 and 1, and each subsequent number is the sum of the previous two. # Requirements: 1. **Function Signature**: ```python def generate_fibonacci_sequence(n: int) -> list: ``` 2. **Inputs**: - `n` (int): The number of terms to generate from the Fibonacci sequence. 3. **Output**: - Returns a list containing the first `n` numbers of the Fibonacci sequence. 4. **Constraints**: - `1 <= n <= 50` - The function should handle the case where `n` is 1 explicitly. 5. **Performance**: - The function should have O(n) time complexity and O(n) space complexity. # Example: ```python >>> generate_fibonacci_sequence(1) [0] >>> generate_fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> generate_fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Hints: - The Fibonacci sequence can be defined recursively as F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1. - Iteratively build the sequence up to the `n`th term using a list to store intermediate results.","solution":"def generate_fibonacci_sequence(n: int) -> list: Generates the first n numbers of the Fibonacci sequence. Args: n (int): The number of terms to generate. Returns: list: A list containing the first n numbers of the Fibonacci sequence. if n == 1: return [0] fibonacci_sequence = [0, 1] for i in range(2, n): next_value = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_value) return fibonacci_sequence"},{"question":"# Shortest Path in Binary Matrix You are given a two-dimensional binary matrix `grid` where `0` represents an empty cell and `1` represents an obstacle cell. You are allowed to move to an adjacent cell in the 8 directions (horizontal, vertical, and diagonal). Write a function `shortest_path_binary_matrix(grid: List[List[int]]) -> int` that returns the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner ((n-1, m-1)). If it is not possible to reach the bottom-right corner, return -1. Input * A two-dimensional list `grid` where each element is either `0` or `1`. * It is guaranteed that `grid` will have at least one element and each row in `grid` will also have at least one element. The dimensions of `grid` are at most (100 times 100). Output * A single integer representing the length of the shortest path from (0, 0) to (n-1, m-1). If no such path exists, return -1. # Constraints * The function should handle different grid dimensions efficiently. * Avoid using excessive memory or deep recursion to prevent stack overflow. # Example ```python grid = [ [0, 0, 0], [1, 1, 0], [1, 1, 0] ] assert shortest_path_binary_matrix(grid) == 4 grid = [ [0, 1], [1, 0] ] assert shortest_path_binary_matrix(grid) == 2 ``` # Approach * Implement a breadth-first search (BFS) to find the shortest path. * Handle edge cases such as an empty grid, or when the start or end positions are blocked. * Ensure the code is optimized to handle the constraints. # Additional Guidelines * Clearly comment on your code explaining the BFS approach, handling of the 8 possible directions, and edge cases. * Avoid using excessive memory or deep recursion to prevent stack overflow.","solution":"from collections import deque from typing import List def shortest_path_binary_matrix(grid: List[List[int]]) -> int: n = len(grid) if n == 0 or grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] queue = deque([(0, 0)]) grid[0][0] = 1 # Mark the cell as visited by storing the path length while queue: x, y = queue.popleft() distance = grid[x][y] if x == n - 1 and y == n - 1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0: queue.append((nx, ny)) grid[nx][ny] = distance + 1 return -1"},{"question":"# Problem Statement You are given two sorted integer arrays `nums1` and `nums2` of size `m` and `n` respectively. The arrays are sorted in non-decreasing order, and it is guaranteed that there are no duplicate elements within each array. Your task is to merge these two arrays into a single sorted array. # Function Signature ```python def merge_arrays(nums1: List[int], nums2: List[int]) -> List[int]: ``` # Input - `nums1` (List[int]): A sorted list of integers of size `m`. - `nums2` (List[int]): A sorted list of integers of size `n`. # Output - Return a sorted list of integers containing all elements from `nums1` and `nums2`. # Constraints - The lengths of the input arrays (0 leq m, n leq 10^4). - The integers in the arrays are within the range (-10^9 leq nums1[i], nums2[i] leq 10^9). - There are no duplicate values within each individual array, but nums1 and nums2 may share common values. # Example ```python nums1 = [1, 3, 5, 7] nums2 = [2, 4, 6, 8] print(merge_arrays(nums1, nums2)) # Expected output: [1, 2, 3, 4, 5, 6, 7, 8] nums1 = [0, 10, 20, 30] nums2 = [5, 15, 25, 35] print(merge_arrays(nums1, nums2)) # Expected output: [0, 5, 10, 15, 20, 25, 30, 35] ``` # Requirements 1. Implement the function `merge_arrays(nums1: List[int], nums2: List[int]) -> List[int]` that takes two sorted arrays and returns a single merged and sorted array. 2. Ensure that your implementation is efficient and can handle the largest inputs within the provided constraints. Consider using a two-pointer technique for merging. # Tips - Use a two-pointer methodology to efficiently merge the two lists. - Maintain a result list to store the merged output as you traverse both input arrays.","solution":"from typing import List def merge_arrays(nums1: List[int], nums2: List[int]) -> List[int]: Merge two sorted arrays into a single sorted array. Args: nums1 (List[int]): First sorted array. nums2 (List[int]): Second sorted array. Returns: List[int]: Merged sorted array. i, j = 0, 0 merged = [] while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: merged.append(nums1[i]) i += 1 else: merged.append(nums2[j]) j += 1 # Append remaining elements of nums1 or nums2 while i < len(nums1): merged.append(nums1[i]) i += 1 while j < len(nums2): merged.append(nums2[j]) j += 1 return merged"},{"question":"# Least Prime Factor for Each Number Given an integer `n`, you need to find the least prime factor for each number from 1 to `n` inclusively. The least prime factor of an integer `x` is the smallest prime number that divides `x`. Function Signature ```python def least_prime_factors(n: int) -> List[int]: ``` # Input * `n` (int): An integer representing the upper limit. # Output * Returns a list of integers where the ith element is the least prime factor of the number `i` (1-based indexing). # Constraints * (1 leq n leq 10^5) # Example ```python assert least_prime_factors(10) == [0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2] ``` # Explanation * For `n = 10`, the list is: * Index 0: Not used (0-based indexing) * Index 1: 1 (Least prime factor of 1 is 1) * Index 2: 2 (Least prime factor of 2 is 2) * Index 3: 3 (Least prime factor of 3 is 3) * Index 4: 2 (Least prime factor of 4 is 2) * Index 5: 5 (Least prime factor of 5 is 5) * Index 6: 2 (Least prime factor of 6 is 2) * Index 7: 7 (Least prime factor of 7 is 7) * Index 8: 2 (Least prime factor of 8 is 2) * Index 9: 3 (Least prime factor of 9 is 3) * Index 10: 2 (Least prime factor of 10 is 2) # Requirements * Implement the function `least_prime_factors` using a sieve-like algorithm to efficiently determine the least prime factor for each number up to `n`. * Ensure that the function handles edge cases, optimizes memory usage, and is efficient enough to run within the given constraints. # Notes * You can assume the input is always valid. * Consider optimizing the sieve step to avoid redundant calculations for better performance in large ranges.","solution":"from typing import List def least_prime_factors(n: int) -> List[int]: # Initialize a list to store the least prime factor for each number lpf = [0] * (n + 1) # 1 does not have any prime factors, so we set it to 1 itself for convention if n >= 1: lpf[1] = 1 # Iterate from 2 to n for i in range(2, n + 1): # If the current number is still marked as 0, it\'s a prime number if lpf[i] == 0: # Mark the current number itself as its least prime factor lpf[i] = i # Mark the least prime factor for all multiples of i for j in range(i * i, n + 1, i): if lpf[j] == 0: lpf[j] = i return lpf"},{"question":"# Context You are developing a scheduling feature for an event management application. The feature needs to determine the earliest possible start time for an event given multiple constraints. Each constraint specifies a meeting that must end before the event can start. All meetings have fixed start and end times. This task helps in finding the optimal slot for the event among the given constraints. # Task Implement the function `find_earliest_start_time` to determine the earliest possible start time for an event, based on a list of meeting intervals. Each interval is represented as a tuple `(start, end)`, where `start` and `end` are timestamps in minutes past midnight. Function Signature ```python def find_earliest_start_time(meetings: List[Tuple[int, int]]) -> int: pass ``` Input - `meetings` (List[Tuple[int, int]]): a list of tuples, where each tuple contains two integers representing the start and end time of a meeting, respectively. - 0 ≤ start < end ≤ (24 times 60) (number of minutes in a day) - 1 ≤ len(meetings) ≤ 10^5 Output - Returns the earliest possible start time in minutes past midnight after all meetings have ended. # Performance Requirements - The solution must handle up to 100,000 meetings efficiently. # Example ```python # Example 1 print(find_earliest_start_time([(540, 600), (610, 660), (570, 590)])) # Output: 660 # Example 2 print(find_earliest_start_time([(720, 750), (780, 810), (765, 795)])) # Output: 810 ``` # Hints - Consider sorting the meetings based on their end times. - Iterate through the sorted meetings to find the maximum end time, as this will determine the earliest start time for the event.","solution":"from typing import List, Tuple def find_earliest_start_time(meetings: List[Tuple[int, int]]) -> int: Determines the earliest possible start time for an event given meeting constraints. Parameters: - meetings (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers representing the start and end time of a meeting in minutes past midnight. Returns: - int: The earliest possible start time in minutes past midnight after all meetings have ended. # Sort the meetings by their end times sorted_meetings = sorted(meetings, key=lambda x: x[1]) # The earliest start time will be just after the last meeting\'s end time return sorted_meetings[-1][1]"},{"question":"# Sorting an Array of Strings by Decreasing Length You are required to implement a function that takes an array of strings and sorts it in decreasing order of string length. If two strings have the same length, they should retain their original relative order (i.e., maintain stability). # Objective Implement a function `sort_by_length(strings: List[str]) -> List[str]` that sorts the input list in decreasing order of string length. # Input * A list `strings` of `n` strings (0 ≤ n ≤ 100,000). # Output * Return a list of strings sorted by decreasing length. # Constraints * The length of each string is at most 1,000 characters. * The solution should maintain the relative order of strings with the same lengths (i.e., it should be a stable sort). # Example ```python from typing import List def sort_by_length(strings: List[str]) -> List[str]: pass # Test cases print(sort_by_length([\\"apple\\", \\"banana\\", \\"pear\\", \\"grape\\"])) # Output: [\\"banana\\", \\"apple\\", \\"grape\\", \\"pear\\"] print(sort_by_length([\\"a\\", \\"abc\\", \\"abcd\\", \\"ab\\", \\"abcdef\\"])) # Output: [\\"abcdef\\", \\"abcd\\", \\"abc\\", \\"ab\\", \\"a\\"] print(sort_by_length([])) # Output: [] print(sort_by_length([\\"same\\", \\"length\\", \\"test\\"])) # Output: [\\"length\\", \\"same\\", \\"test\\"] ``` # Guidelines 1. Use a stable sorting algorithm that respects the original relative order of strings with equal lengths. 2. Carefully handle edge cases such as an empty list or all strings having the same length. 3. Test your function with various inputs to ensure correctness and performance within the provided constraints.","solution":"from typing import List def sort_by_length(strings: List[str]) -> List[str]: Sorts a list of strings in decreasing order of their lengths. Parameters: strings (List[str]): The list of strings to sort. Returns: List[str]: The sorted list of strings by decreasing length. return sorted(strings, key=len, reverse=True)"},{"question":"You\'ve implemented the radix sort algorithm for sorting a list of non-negative integers. However, there is a twist. Instead of using base 10 (decimal system), the algorithm needs to adapt to an arbitrary base `b` (where 2 ≤ `b` ≤ 512). Write a Python function to perform radix sort on a given list of non-negative integers using the specified base `b`. # Function signature ```python def radix_sort(arr: List[int], b: int) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of non-negative integers. The length of the list will be at most 10^5. - `b` (int): An integer representing the base. `2 <= b <= 512`. # Output - A list of non-negative integers sorted in non-decreasing order. # Example ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66], 10) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66], 2) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66], 512) == [2, 24, 45, 66, 75, 90, 170, 802] ``` # Constraints - The algorithm should be efficient in terms of time complexity, ideally O(kn), where `k` is the number of digits in the largest number, and `n` is the number of elements in the list. - You must handle bases greater than 10 by adapting the digit extraction process for general bases. # Additional Notes - Consider the implications of different bases on the implementation and ensure the algorithm can handle any valid base within the given range efficiently. - Test with various bases and list configurations to validate your solution fully.","solution":"from typing import List def get_digit(number, base, digit_index): return (number // base ** digit_index) % base def radix_sort(arr: List[int], b: int) -> List[int]: if not arr: return [] max_num = max(arr) max_digits = 0 while max_num > 0: max_digits += 1 max_num //= b for d in range(max_digits): buckets = [[] for _ in range(b)] # Place each number in the appropriate bucket for num in arr: digit = get_digit(num, b, d) buckets[digit].append(num) # Gather numbers from buckets arr = [num for bucket in buckets for num in bucket] return arr"},{"question":"# Implement a Min-Heap Data Structure In this task, you are required to implement a min-heap data structure in Python. A min-heap is a binary tree where the key at each node is smaller than or equal to the keys of its children, making the smallest element the root of the tree. Detailed Specifications 1. Implement the `MinHeap` class with the following methods: ```python class MinHeap: def __init__(self): # Initialize an empty heap self.heap = [] def push(self, key: int) -> None: # Insert an element into the heap ... def pop(self) -> int: # Remove and return the smallest element from the heap ... def peek(self) -> int: # Return the smallest element without removing it ... def size(self) -> int: # Return the number of elements in the heap ... ``` 2. You are provided with a basic implementation structure. Use this to define the functionality required: ```python class MinHeap: def __init__(self): self.heap = [] def push(self, key: int) -> None: self.heap.append(key) self._sift_up(len(self.heap) - 1) def pop(self) -> int: if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._sift_down(0) return root def peek(self) -> int: return self.heap[0] if self.heap else -1 def size(self) -> int: return len(self.heap) def _sift_up(self, idx: int) -> None: # Move the element at index idx up to maintain the heap property ... def _sift_down(self, idx: int) -> None: # Move the element at index idx down to maintain the heap property ... ``` Constraints * The elements inserted into the heap are non-negative integers. Input and Output Formats * **Input**: - `push(key)` (integer): Insert the element `key` into the heap. - `pop()` (no argument): Remove and return the smallest element in the heap. - `peek()` (no argument): Return the smallest element without removing it. - `size()` (no argument): Return the number of elements in the heap. * **Output**: - The `pop` method should return the smallest element in the heap. - The `peek` method should return the smallest element without removing it. Example Usage ```python heap = MinHeap() heap.push(3) heap.push(1) heap.push(2) print(heap.peek()) # returns 1 (the smallest element) print(heap.pop()) # returns 1 and removes it from the heap print(heap.pop()) # returns 2 print(heap.size()) # returns 1 (one element left) print(heap.pop()) # returns 3 print(heap.pop()) # returns -1 as the heap is empty ``` Implement the `MinHeap` class to meet the specifications mentioned above.","solution":"class MinHeap: def __init__(self): self.heap = [] def push(self, key: int) -> None: self.heap.append(key) self._sift_up(len(self.heap) - 1) def pop(self) -> int: if len(self.heap) == 0: return -1 if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._sift_down(0) return root def peek(self) -> int: return self.heap[0] if self.heap else -1 def size(self) -> int: return len(self.heap) def _sift_up(self, idx: int) -> None: parent = (idx - 1) // 2 while idx > 0 and self.heap[idx] < self.heap[parent]: self.heap[idx], self.heap[parent] = self.heap[parent], self.heap[idx] idx = parent parent = (idx - 1) // 2 def _sift_down(self, idx: int) -> None: child = (idx * 2) + 1 while child < len(self.heap): if child + 1 < len(self.heap) and self.heap[child + 1] < self.heap[child]: child += 1 if self.heap[idx] <= self.heap[child]: break self.heap[idx], self.heap[child] = self.heap[child], self.heap[idx] idx = child child = (idx * 2) + 1"},{"question":"# Coding Assessment Question Scenario You are part of a development team working on a new feature for a ride-sharing application. This feature involves calculating the total distance traveled by a driver during a series of rides, as well as identifying the longest continuous ride in terms of distance. Function Specification Write a function `calculate_distances` that performs the following: - **Parameters**: - A list of tuples, where each tuple contains two integers representing the start and end distance markers of a ride (e.g., `[(2, 5), (5, 10), (10, 12)]`). - **Returns**: - A tuple containing two elements: 1. The total distance traveled for all rides combined. 2. The distance of the longest continuous ride. Examples ```python def calculate_distances(rides: list) -> tuple: pass # Example test cases print(calculate_distances([(2, 5), (5, 10), (10, 12)])) # Expected output: (10, 5) print(calculate_distances([(0, 3), (3, 7), (7, 10)])) # Expected output: (10, 4) print(calculate_distances([(1, 3), (4, 7), (8, 12)])) # Expected output: (9, 4) ``` Constraints - Each tuple in the input list represents a non-negative integer range where the start distance is always less than the end distance. - The function should be able to handle an empty list by returning `(0, 0)`. - No rides will have overlapping distances. Requirements Focus on implementing an efficient algorithm. Ensure minimal memory usage and optimal performance, particularly for large datasets with up to 10,000 rides.","solution":"def calculate_distances(rides): Calculate the total distance traveled and the longest continuous ride distance. Parameters: rides (list): List of tuples where each tuple contains two integers representing the start and end distance markers of a ride. Returns: (tuple): A tuple containing: - Total distance traveled (int) - Longest continuous ride distance (int) if not rides: return (0, 0) total_distance = 0 longest_ride = 0 for start, end in rides: ride_distance = end - start total_distance += ride_distance if ride_distance > longest_ride: longest_ride = ride_distance return (total_distance, longest_ride)"},{"question":"# Coding Assessment Question You are provided with three functions that perform arithmetic operations (addition, subtraction, and multiplication) on two given matrices. However, the current implementations of these functions lack robust error handling and validation for the input matrices. Your Task Write enhanced versions of the provided functions (`matrix_add`, `matrix_subtract`, `matrix_multiply`) that incorporate additional validation checks and raise appropriate exceptions for the following cases: 1. If the input matrices are not of appropriate dimensions for the requested operation. 2. If the input matrices contain non-numeric elements. 3. If the input matrices are empty. # Function Specifications `matrix_add` - **Input**: `matrix_a` (list of lists of numeric elements), `matrix_b` (list of lists of numeric elements) - **Output**: `list of lists of numeric elements` (resultant matrix after addition) - **Exceptions**: - Raise `ValueError` if the input matrices are not of the same dimensions. - Raise `TypeError` if the input matrices contain non-numeric elements. - Raise `ValueError` if any of the input matrices are empty. `matrix_subtract` - **Input**: `matrix_a` (list of lists of numeric elements), `matrix_b` (list of lists of numeric elements) - **Output**: `list of lists of numeric elements` (resultant matrix after subtraction) - **Exceptions**: - Raise `ValueError` if the input matrices are not of the same dimensions. - Raise `TypeError` if the input matrices contain non-numeric elements. - Raise `ValueError` if any of the input matrices are empty. `matrix_multiply` - **Input**: `matrix_a` (list of lists of numeric elements), `matrix_b` (list of lists of numeric elements) - **Output**: `list of lists of numeric elements` (resultant matrix after multiplication) - **Exceptions**: - Raise `ValueError` if the input matrices are not compatible for multiplication (i.e., the number of columns in `matrix_a` is not equal to the number of rows in `matrix_b`). - Raise `TypeError` if the input matrices contain non-numeric elements. - Raise `ValueError` if any of the input matrices are empty. # Example Usage ```python try: matrix1 = [ [1, 2, 3], [4, 5, 6], ] matrix2 = [ [7, 8, 9], [10, 11, 12], ] added_matrix = matrix_add(matrix1, matrix2) print(added_matrix) # Expected Output: [[8, 10, 12], [14, 16, 18]] subtracted_matrix = matrix_subtract(matrix1, matrix2) print(subtracted_matrix) # Expected Output: [[-6, -6, -6], [-6, -6, -6]] matrix3 = [ [1, 2], [3, 4], [5, 6], ] matrix4 = [ [7, 8, 9], [10, 11, 12], ] multiplied_matrix = matrix_multiply(matrix3, matrix4) print(multiplied_matrix) # Expected Output: [[27, 30, 33], [61, 68, 75], [95, 106, 117]] except ValueError as e: print(e) except TypeError as e: print(e) ``` # Constraints - The input matrices are lists of lists containing numeric elements. - Ensure to handle dimension mismatches and presence of non-numeric elements appropriately. Good luck, and ensure your functions are thoroughly tested with both correct and incorrect inputs!","solution":"def matrix_add(matrix_a, matrix_b): Returns the result of adding matrix_a and matrix_b. if not matrix_a or not matrix_b: raise ValueError(\\"Input matrices must not be empty.\\") if len(matrix_a) != len(matrix_b) or any(len(row_a) != len(row_b) for row_a, row_b in zip(matrix_a, matrix_b)): raise ValueError(\\"Input matrices must have the same dimensions.\\") for row in matrix_a + matrix_b: for element in row: if not isinstance(element, (int, float)): raise TypeError(\\"All elements of input matrices must be numeric.\\") result = [] for row_a, row_b in zip(matrix_a, matrix_b): result.append([a + b for a, b in zip(row_a, row_b)]) return result def matrix_subtract(matrix_a, matrix_b): Returns the result of subtracting matrix_b from matrix_a. if not matrix_a or not matrix_b: raise ValueError(\\"Input matrices must not be empty.\\") if len(matrix_a) != len(matrix_b) or any(len(row_a) != len(row_b) for row_a, row_b in zip(matrix_a, matrix_b)): raise ValueError(\\"Input matrices must have the same dimensions.\\") for row in matrix_a + matrix_b: for element in row: if not isinstance(element, (int, float)): raise TypeError(\\"All elements of input matrices must be numeric.\\") result = [] for row_a, row_b in zip(matrix_a, matrix_b): result.append([a - b for a, b in zip(row_a, row_b)]) return result def matrix_multiply(matrix_a, matrix_b): Returns the result of multiplying matrix_a with matrix_b. if not matrix_a or not matrix_b: raise ValueError(\\"Input matrices must not be empty.\\") if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Number of columns in matrix_a must match the number of rows in matrix_b.\\") for row in matrix_a + matrix_b: for element in row: if not isinstance(element, (int, float)): raise TypeError(\\"All elements of input matrices must be numeric.\\") result = [] for row_a in matrix_a: new_row = [] for col in range(len(matrix_b[0])): new_element = sum(row_a[i] * matrix_b[i][col] for i in range(len(matrix_b))) new_row.append(new_element) result.append(new_row) return result"},{"question":"# Problem Description You need to design a function that finds the intersection of two singly linked lists. The intersection is defined as the node at which the two lists merge into a single list. If the two linked lists have no intersection, return `None`. # Function Signature You need to implement the following function: ```python class ListNode: def __init__(self, x): self.val = x self.next = None def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: Finds the intersection node of two singly linked lists. Parameters: headA (ListNode): The head of the first linked list. headB (ListNode): The head of the second linked list. Returns: ListNode: The node at which the intersection begins, or None if there is no intersection. ``` # Input and Output * `headA`: The head node of the first singly linked list. * `headB`: The head node of the second singly linked list. * Returns the node where the intersection starts, or `None` if there is no intersection. # Example ```python # Example 1: # List A: 1 -> 3 -> 5 -> 7 -> 9 # List B: 4 -> 6 -> 7 -> 9 # Intersection at node with value 7 # Example 2: # List A: 2 -> 4 -> 6 # List B: 1 -> 3 # No intersection # For Example 1: headA = ListNode(1) headA.next = ListNode(3) headA.next.next = ListNode(5) intersect_node = ListNode(7) headA.next.next.next = intersect_node intersect_node.next = ListNode(9) headB = ListNode(4) headB.next = ListNode(6) headB.next.next = intersect_node print(get_intersection_node(headA, headB).val) # Output: 7 ``` # Constraints * The linked lists must retain their original structure after the function returns. * The intersection, if present, will always be by reference, not by value. * Your solution should have O(n) time complexity, where n is the number of nodes in the longer list. * Your solution should avoid using additional space, thus achieving O(1) space complexity. # Notes * You may assume there are no cycles anywhere in the entire linked structure. * Remember to handle the edge case where either or both lists are empty.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: Finds the intersection node of two singly linked lists. Parameters: headA (ListNode): The head of the first linked list. headB (ListNode): The head of the second linked list. Returns: ListNode: The node at which the intersection begins, or None if there is no intersection. if not headA or not headB: return None # Initialize two pointers for both lists p1, p2 = headA, headB # Traverse both lists, and when reaching the end of one list, continue from the head of the other list # This way, they\'ll both travel the same total distance, and we\'ll find the intersection if it exists while p1 != p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1"},{"question":"# Coding Assessment Question: Reverse and Append Strings Scenario: You are tasked with performing a transformation on a list of strings. For each string in the list, you need to reverse the string and then append it back to the original string. This operation should be performed for each string in the list. Problem Statement: Write a Python function that takes a list of strings as input and returns a new list where each string has been transformed by reversing it and appending the reversed string to the original. Input: - A list of strings, where each string consists of lowercase English characters and has a length of at least 1 and at most 1000 characters. Output: - A new list of strings, where each string is the original followed by its reverse. Example: ```python # Sample Input [\\"abc\\", \\"hello\\", \\"python\\"] # Sample Output [\\"abccba\\", \\"helloolleh\\", \\"pythonnohtyp\\"] ``` Constraints: * The length of the input list will be between 1 and 1000 inclusive. * Each string in the list will be between 1 and 1000 characters inclusive. * The strings will only contain lowercase English letters. Tips: 1. Think about how to reverse a string in Python. 2. Consider using list comprehensions to simplify your solution. 3. Test your function with different edge cases, such as a single-character string or very large strings. Good Luck!","solution":"def reverse_and_append(strings): Takes a list of strings and returns a new list where each string is the original string followed by its reverse. return [s + s[::-1] for s in strings]"},{"question":"# Introduction You are tasked with managing and scheduling server requests to optimize the load balancing in a data center. The goal is to determine the minimum number of servers required to handle a set of requests without any overlap in their processing times. # Problem Description Write a function `min_servers` that determines the minimum number of servers required to handle all incoming requests. Each request is represented by its start and end processing times. Function: `min_servers` Write a function `min_servers` that computes the minimum number of servers needed. **Function Signature**: ```python def min_servers(requests: List[Tuple[int, int]]) -> int: ``` **Input**: - `requests` (List[Tuple[int, int]]): A list of tuples where each tuple represents a request with a start and an end time `(start, end)`. **Output**: - (int): The minimum number of servers required. **Constraints**: - The number of requests will be between 1 and 10^4. - Each start and end time will be an integer within the range [0, 10^9]. - The end time will always be greater than the start time for each request. # Example ```python requests = [(1, 4), (2, 6), (4, 8), (9, 10)] assert min_servers(requests) == 2 requests = [(1, 2), (2, 3), (3, 4), (4, 5)] assert min_servers(requests) == 1 ``` # Note - Ensure to include appropriate error handling for edge cases such as overlapping and consecutive requests. - The solution should include necessary imports and follow proper coding standards.","solution":"from typing import List, Tuple def min_servers(requests: List[Tuple[int, int]]) -> int: Returns the minimum number of servers required to handle all requests without overlap. if not requests: return 0 # Split the requests into start and end events events = [] for start, end in requests: events.append((start, \'start\')) events.append((end, \'end\')) # Sort events first by time, then by type of event (end should come before start if same time) events.sort(key=lambda x: (x[0], x[1] == \'start\')) max_servers_needed = 0 current_servers = 0 # Process events to find maximum overlap at any point for time, event in events: if event == \'start\': current_servers += 1 max_servers_needed = max(max_servers_needed, current_servers) else: current_servers -= 1 return max_servers_needed"},{"question":"# Problem Statement You are required to implement a function, `compress_string`, and another function, `decompress_string`, to compress and decompress strings respectively using a simple run-length encoding scheme. Function Signature ```python def compress_string(data: str) -> str: pass def decompress_string(encoded_data: str) -> str: pass ``` Requirements 1. **Run-Length Encoding Compression**: - Convert the input string into a compressed format by replacing consecutive characters with the character followed by the count of repeated occurrences. - For example, the string \\"aaabbc\\" would be compressed to \\"a3b2c1\\". 2. **Run-Length Encoding Decompression**: - Convert the compressed string back to its original format. - For example, the compressed string \\"a3b2c1\\" would be decompressed to \\"aaabbc\\". Inputs - `compress_string`: - `data: str` - The raw input string to compress. - `decompress_string`: - `encoded_data: str` - The run-length encoded string to decompress. Outputs - Return type for both functions is `str`. Constraints - Only alphabets (both uppercase and lowercase) and digits will be present in the input string. - The output string for both functions should be concise and represent the correct compression or decompression as specified. Example ```python # Compress String input_data = \\"aaabbc\\" compressed = compress_string(input_data) assert compressed == \\"a3b2c1\\" # Decompress String encoded_string = \\"a3b2c1\\" decompressed = decompress_string(encoded_string) assert decompressed == \\"aaabbc\\" ``` Notes 1. Do not use any predefined libraries (e.g., `zlib`) for compression and decompression. 2. Ensure that your implementation of the compression and decompression is efficient. 3. Validate the input strings to ensure they match the expected format and raise appropriate errors if they do not.","solution":"def compress_string(data: str) -> str: Compress the string using run-length encoding. if not data: return \\"\\" compressed = [] count = 1 previous_char = data[0] for char in data[1:]: if char == previous_char: count += 1 else: compressed.append(f\\"{previous_char}{count}\\") previous_char = char count = 1 compressed.append(f\\"{previous_char}{count}\\") return \'\'.join(compressed) def decompress_string(encoded_data: str) -> str: Decompress the string using run-length encoding. if not encoded_data: return \\"\\" decompressed = [] i = 0 while i < len(encoded_data): char = encoded_data[i] count = \\"\\" # Read the number that follows the character while i + 1 < len(encoded_data) and encoded_data[i + 1].isdigit(): i += 1 count += encoded_data[i] decompressed.append(char * int(count)) # Repeat the character i += 1 # Move to the next character return \'\'.join(decompressed)"},{"question":"# Context In a social media app, you have to create an efficient data structure to manage the IDs of users who have engaged with a post, such as liking or commenting on it. The data structure should allow for quick adding, removing, and querying of user IDs within a certain range using their numerical IDs. # Task Implement a `UserActivityTracker` class to efficiently manage and query user activity IDs in a given range using a binary search tree (BST). # Specifications: `__init__(self) -> None` Initializes an empty BST to store user IDs. `insert(self, user_id: int) -> None` Inserts `user_id` into the BST. `delete(self, user_id: int) -> None` Deletes `user_id` from the BST if it exists. `search(self, user_id: int) -> bool` Returns `True` if `user_id` is present in the BST, `False` otherwise. `range_query(self, left: int, right: int) -> list[int]` Returns a sorted list of user IDs within the inclusive range `[left, right]`. # Example ```python # Example usage: tracker = UserActivityTracker() tracker.insert(10) tracker.insert(5) tracker.insert(15) tracker.insert(3) tracker.insert(7) tracker.insert(18) assert tracker.search(7) == True assert tracker.search(6) == False tracker.delete(7) assert tracker.search(7) == False assert tracker.range_query(4, 16) == [5, 10, 15] assert tracker.range_query(10, 20) == [10, 15, 18] assert tracker.range_query(1, 3) == [3] ``` Ensure your implementation is correct, efficient, and follows best practices for managing and manipulating BSTs.","solution":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None class UserActivityTracker: def __init__(self): self.root = None def insert(self, user_id: int) -> None: self.root = self._insert(self.root, user_id) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) return node def delete(self, user_id: int) -> None: self.root = self._delete(self.root, user_id) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._minValueNode(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) return node def _minValueNode(self, node): current = node while current.left is not None: current = current.left return current def search(self, user_id: int) -> bool: return self._search(self.root, user_id) is not None def _search(self, node, key): if not node or node.key == key: return node if key < node.key: return self._search(node.left, key) return self._search(node.right, key) def range_query(self, left: int, right: int) -> list[int]: result = [] self._range_query(self.root, left, right, result) return result def _range_query(self, node, left, right, result): if node is None: return if left < node.key: self._range_query(node.left, left, right, result) if left <= node.key <= right: result.append(node.key) if right > node.key: self._range_query(node.right, left, right, result)"},{"question":"# Question Problem Statement You have been tasked with developing a tool to manage and schedule tasks using a blocking dependency resolution system. Your goal is to determine if a set of tasks can be completed given their dependencies, and if so, produce one possible order of execution. This is known as the Topological Sort problem for a Directed Acyclic Graph (DAG). Function Signature ```python def find_task_order(tasks: int, dependencies: list) -> list: Determines a possible order of task execution given their dependencies using topological sort. Parameters: tasks (int): The total number of tasks, labeled from 0 to tasks-1. dependencies (list): A list of tuples where each tuple (a, b) indicates that task `a` must be completed before task `b`. Returns: list: A list of integers representing a valid task execution order, or an empty list if no valid order exists. pass ``` Input * `tasks`: The total number of tasks (vertices in the graph), an integer (1 leq tasks leq 1000). * `dependencies`: A list of tuples representing directed edges in the graph. Each tuple (a, b) indicates that task `a` precedes task `b` in the execution sequence, where (0 leq a, b < tasks). Output * A list of integers representing one possible valid task order, or an empty list if no such order exists (cycle in the graph). Constraints * The number of tasks (1 leq tasks leq 1000). * The number of dependencies (0 leq |dependencies| leq 5000). * Tasks are labeled from 0 to (tasks - 1). Example ```python tasks = 4 dependencies = [(1, 0), (2, 0), (3, 1), (3, 2)] assert find_task_order(tasks, dependencies) in [[3, 2, 1, 0], [3, 1, 2, 0]] # Possible valid orders tasks = 2 dependencies = [(0, 1), (1, 0)] assert find_task_order(tasks, dependencies) == [] # No valid order, as there is a cycle ``` Additional Information * Ensure your solution efficiently handles the graph structure and can detect cycles. * Consider edge cases such as no dependencies, fully independent tasks, and cyclic dependencies. * Aim to implement a topological sort algorithm (e.g., Kahn\'s algorithm or Depth First Search based approach).","solution":"from collections import defaultdict, deque def find_task_order(tasks, dependencies): Determines a possible order of task execution given their dependencies using topological sort. Parameters: tasks (int): The total number of tasks, labeled from 0 to tasks-1. dependencies (list): A list of tuples where each tuple (a, b) indicates that task `a` must be completed before task `b`. Returns: list: A list of integers representing a valid task execution order, or an empty list if no valid order exists. # Create adjacency list and in-degree array adj_list = defaultdict(list) in_degree = [0] * tasks # Populate adjacency list and in-degree array for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Initialize the queue with all nodes having in-degree of 0 queue = deque([i for i in range(tasks) if in_degree[i] == 0]) result = [] while queue: node = queue.popleft() result.append(node) # Process all neighbors for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we were able to process all nodes if len(result) == tasks: return result else: return []"},{"question":"# Question: Detect and Convert Roman Numerals You are provided with two individual tasks. Write two functions to achieve the following: Task 1: Validate Roman Numeral Write a function `validate_roman_numeral(numeral: str) -> bool` that checks if the given string is a valid Roman numeral. Valid Roman numerals include the characters `I`, `V`, `X`, `L`, `C`, `D`, and `M` and must follow the rules of Roman numeral construction. **Input** - A string `numeral`. **Output** - Return `True` if the numeral is valid, otherwise `False`. **Examples** ```python >>> validate_roman_numeral(\'XIV\') True >>> validate_roman_numeral(\'IIII\') False >>> validate_roman_numeral(\'MMXXIII\') True ``` Task 2: Convert Roman Numeral to Integer Write a function `roman_to_integer(numeral: str) -> int` that converts a valid Roman numeral string to its equivalent integer value. **Input** - A string `numeral` that is a valid Roman numeral. **Output** - Return the equivalent integer value as an integer. **Examples** ```python >>> roman_to_integer(\'XIV\') 14 >>> roman_to_integer(\'CDXLIV\') 444 >>> roman_to_integer(\'MMXXIII\') 2023 ``` **Constraints**: - Both functions should raise a `ValueError` if the input is empty or not a string. - The `roman_to_integer` function should assume the input is always a valid Roman numeral. ```python def validate_roman_numeral(numeral: str) -> bool: # your code here pass def roman_to_integer(numeral: str) -> int: # your code here pass ``` Use the following assertions to verify the correctness of your code: ```python assert validate_roman_numeral(\'XIV\') == True assert validate_roman_numeral(\'IIII\') == False assert validate_roman_numeral(\'MMXXIII\') == True assert roman_to_integer(\'XIV\') == 14 assert roman_to_integer(\'CDXLIV\') == 444 assert roman_to_integer(\'MMXXIII\') == 2023 ```","solution":"import re def validate_roman_numeral(numeral: str) -> bool: Validates if the given string is a valid Roman numeral. if not isinstance(numeral, str) or not numeral: raise ValueError(\\"Input must be a non-empty string\\") valid_roman_pattern = \\"^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})\\" return bool(re.match(valid_roman_pattern, numeral)) def roman_to_integer(numeral: str) -> int: Converts a Roman numeral to an integer. if not isinstance(numeral, str) or not numeral: raise ValueError(\\"Input must be a non-empty string\\") roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(numeral): value = roman_to_int[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"# Question You are given an array of integers where each element appears twice except for one element that appears only once. Your goal is to find the element that appears only once. The solution should have a linear runtime complexity and use only constant extra space. Write a function `single_number(nums: List[int]) -> int` that returns the element that appears only once in the array. # Input and Output Formats Inputs: - `nums`: A list of integers where all but one integer appear twice; the rest appear exactly once. Output: - An integer that appears only once in the array. # Constraints - The list will have at least 1 element and at most 10^4 elements. - Each element in the array is between -3 * 10^4 and 3 * 10^4. # Example ```python # Example Input nums = [4, 1, 2, 1, 2] # Example Function Call print(single_number(nums)) # Expected Output 4 ``` In the provided array, every element except for `4` appears twice, so the function should return `4`.","solution":"from typing import List def single_number(nums: List[int]) -> int: Returns the element that appears only once in the array. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"# Palindrome Permutation Check Context A palindrome is a word that reads the same forward and backward, e.g., \\"level\\" or \\"racecar\\". A permutation is a rearrangement of letters. Given a string, the task is to check if any permutation of the string is a palindrome. Task Description 1. **Palindrome Permutation Function**: Write a function that determines if any permutation of the given string can form a palindrome. 2. **Case Insensitivity**: Make sure the function treats uppercase and lowercase letters as equivalent. Function Signature: ```python def can_form_palindrome(input_string: str) -> bool: Determines if any permutation of the input string can form a palindrome. :param input_string: The string to check :return: True if any permutation of the input string can form a palindrome, otherwise False Examples: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"Aba\\") True ``` Constraints: * The input string may contain up to (10^3) characters. * The input string will only consist of letters (both uppercase and lowercase) and no whitespace or punctuation. Additional Requirements: * Optimize the function for time complexity to handle up to (10^3) characters efficiently. * Ensure case insensitivity in character comparison.","solution":"def can_form_palindrome(input_string: str) -> bool: Determines if any permutation of the input string can form a palindrome. :param input_string: The string to check :return: True if any permutation of the input string can form a palindrome, otherwise False # Normalize the string to lowercase for case insensitivity input_string = input_string.lower() # Dictionary to count occurrences of each character char_count = {} for char in input_string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # We can form a palindrome if at most one character has an odd count odd_count_chars = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count_chars <= 1"},{"question":"# Problem Statement You are tasked with creating a function that generates a summary of word frequencies from a given list of sentences. Your function should be able to: 1. Consolidate words from multiple sentences into a single frequency count. 2. Ignore case differences (e.g., \\"Word\\" and \\"word\\" should be counted together). 3. Exclude certain common words, which will be provided as a list, from the frequency count. # Function Signature ```python def word_frequency(sentences: list[str], exclude_words: list[str]) -> dict[str, int]: ``` # Input * `sentences`: A list of strings, each representing a sentence. * `exclude_words`: A list of common words (all lowercase) to be ignored in the frequency count. # Output A dictionary where the keys are the words (in lowercase) and the values are their respective frequencies. # Constraints * `sentences` will contain between 1 and 1000 strings. * Each sentence will have a maximum length of 1000 characters. * `exclude_words` will contain between 1 and 100 words. * Each word in `exclude_words` will have a maximum length of 20 characters. # Example Input ```python sentences = [\\"This is a test sentence.\\", \\"This is another test sentence with some more words.\\"] exclude_words = [\\"is\\", \\"a\\", \\"with\\", \\"some\\"] ``` Output ```python { \\"this\\": 2, \\"test\\": 2, \\"sentence\\": 2, \\"another\\": 1, \\"more\\": 1, \\"words\\": 1 } ``` # Notes * Handle punctuation and special characters by removing them from the word count. * Consider using regular expressions to aid in word extraction and filtering. * Ensure that the function performs efficiently given the constraints.","solution":"import re from collections import Counter def word_frequency(sentences: list[str], exclude_words: list[str]) -> dict[str, int]: exclude_set = set(exclude_words) word_count = Counter() for sentence in sentences: words = re.findall(r\'bw+b\', sentence.lower()) filtered_words = [word for word in words if word not in exclude_set] word_count.update(filtered_words) return dict(word_count)"},{"question":"# Coding Assessment Question Context: One of the common tasks in data processing is to find the intersection and union between datasets. These operations are essential in various domains such as database management, data analysis, and information retrieval. In this task, you will write programs to find the intersection and union of two lists of integers. Task: 1. Implement the `intersection` function that returns a list of integers appearing in both input lists. 2. Implement the `union` function that returns a list of all unique integers appearing in either input list. 3. Include a main function to accept two lists of integers from users, calculate their intersection and union, and print the results. Requirements: 1. **Function `intersection(list1: List[int], list2: List[int]) -> List[int]`** - Receive two lists of integers as input and return a sorted list of integers that appear in both lists. 2. **Function `union(list1: List[int], list2: List[int]) -> List[int]`** - Receive two lists of integers as input and return a sorted list of all unique integers that appear in either list. 3. **Function `main()`** - Accept two lists of integers from the user. - Calculate and print the intersection of the two lists. - Calculate and print the union of the two lists. Constraints: - Input lists can be of any length, but both lists will contain integers only. - The program should handle edge cases such as empty lists or lists with duplicate elements. Example: For input lists `[1, 2, 3, 4]` and `[3, 4, 5, 6]`: - `intersection([1, 2, 3, 4], [3, 4, 5, 6])` should return `[3, 4]`. - `union([1, 2, 3, 4], [3, 4, 5, 6])` should return `[1, 2, 3, 4, 5, 6]`.","solution":"from typing import List def intersection(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of integers that appear in both input lists. intersect = list(set(list1) & set(list2)) return sorted(intersect) def union(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of all unique integers that appear in either input list. union_set = list(set(list1) | set(list2)) return sorted(union_set) def main(): list1 = list(map(int, input(\\"Enter the first list of integers separated by spaces: \\").split())) list2 = list(map(int, input(\\"Enter the second list of integers separated by spaces: \\").split())) print(\\"Intersection:\\", intersection(list1, list2)) print(\\"Union:\\", union(list1, list2))"},{"question":"# Coding Assessment Question **Title**: Combination Sum Path Finder **Context**: Combination Sum problems are widely used in scenarios where choices need to be made to hit a target value. These can be found in financial calculations, resource distribution, and game theory. Understanding how to determine possible combinations that reach a given sum is a valuable skill in algorithm design. **Objective**: Write a function `combination_sum(nums: list[int], target: int) -> list[list[int]]` that returns a list of all unique combinations in `nums` where the candidate numbers sum to the target. Each number in `nums` may be used multiple times in the combination. The combinations should be returned in ascending order. **Input**: - `nums`: A list of non-negative integers. - `target`: A non-negative integer representing the sum to be achieved. **Output**: - A list of lists, where each inner list contains a unique combination from `nums` that adds up to `target`. **Constraints**: - `1 ≤ len(nums) ≤ 20` - `0 ≤ nums[i] ≤ 50` - `0 ≤ target ≤ 500` - Each number in `nums` is unique and the result list should not contain duplicate combinations. **Requirements**: - Do not use global variables; instead, focus on utilizing appropriate local variables and helper functions. **Example**: ```python def combination_sum(nums: list[int], target: int) -> list[list[int]]: # Your solution here # Example Usage: print(combination_sum([2, 3, 6, 7], 7)) # Expected output: [[2, 2, 3], [7]] print(combination_sum([2, 3, 5], 8)) # Expected output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] ``` **Hints**: - Consider using a depth-first search (DFS) approach to explore all possible combinations. - Implement backtracking to avoid unnecessary computations and duplicates.","solution":"def combination_sum(nums, target): nums.sort() res = [] def dfs(start, path, remaining): if remaining == 0: res.append(path) return for i in range(start, len(nums)): if nums[i] > remaining: break dfs(i, path + [nums[i]], remaining - nums[i]) dfs(0, [], target) return res"},{"question":"Question: Minimum Number of Operations to Make Two Lists Equal Your task is to implement a function that calculates the minimum number of operations required to make two lists equal. The only allowed operation is to select an element from either list and replace it with any integer. # Function Signature ```python def min_operations_to_equalize(arr1: List[int], arr2: List[int]) -> int: Given two lists of integers, returns the minimum number of operations required to make the two lists identical. Args: arr1: List[int] - A list of integers. arr2: List[int] - Another list of integers of the same length as arr1. Returns: int - The minimum number of operations required to make arr1 and arr2 identical. ``` # Input * Two lists arr1 and arr2 containing integers. * Both lists will have the same length. # Output * An integer representing the minimum number of operations required to make the two lists identical. # Constraints * 0 <= len(arr1), len(arr2) <= 10^6 * -10^9 <= arr1[i], arr2[i] <= 10^9 # Example ```python >>> min_operations_to_equalize([1, 2, 3], [3, 2, 1]) 2 >>> min_operations_to_equalize([1, 2, 3], [1, 2, 3]) 0 >>> min_operations_to_equalize([], []) 0 ``` # Performance Requirements * The solution should have a time complexity of O(n). # Notes * Ensure to handle edge cases, such as empty lists. * Each operation consists of selecting a single element and replacing it with any integer. # Additional Context Imagine you are developing a data synchronization software that needs to make two data arrays identical with the minimum number of edit operations. For this task, you need an efficient algorithm to calculate the minimum number of replacements required. Implement a function that can handle this efficiently even for very large input sizes.","solution":"def min_operations_to_equalize(arr1: list, arr2: list) -> int: Given two lists of integers, returns the minimum number of operations required to make the two lists identical. Args: arr1: list[int] - A list of integers. arr2: list[int] - Another list of integers of the same length as arr1. Returns: int - The minimum number of operations required to make arr1 and arr2 identical. # Since the lists are of equal length, we can iterate over both simultaneously return sum(1 for a, b in zip(arr1, arr2) if a != b)"},{"question":"# Problem Description Write a function `frequent_words` that, given a list of words, determines which words appear most frequently and returns them in alphabetical order. # Function Signature ```python def frequent_words(words: List[str]) -> List[str]: ``` # Input * `words` (List[str]): A list of words containing only lowercase English letters. (1 leq text{len(words)} leq 10^6). # Output * List[str]: A list of the most frequent words, sorted alphabetically. # Constraints * If multiple words have the same highest frequency, return all such words in alphabetical order. # Examples ```python >>> frequent_words([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) [\'apple\'] >>> frequent_words([\\"dog\\", \\"cat\\", \\"dog\\", \\"bird\\", \\"cat\\", \\"dog\\", \\"cat\\"]) [\'cat\', \'dog\'] >>> frequent_words([\\"x\\", \\"y\\", \\"z\\"]) [\'x\', \'y\', \'z\'] ``` # Notes * Consider using a dictionary to count word occurrences efficiently.","solution":"from typing import List def frequent_words(words: List[str]) -> List[str]: Returns the list of words that appear most frequently, sorted alphabetically. word_count = {} # Count each word\'s frequency for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 # Find the maximum frequency max_freq = max(word_count.values()) # Collect words with the maximum frequency most_frequent_words = [word for word, count in word_count.items() if count == max_freq] # Return the words sorted alphabetically return sorted(most_frequent_words)"},{"question":"# Question You are to design a simple movie recommendation system. A library contains many movies and their respective genres. Your task is to recommend movies to users based on their list of preferred genres. Implement the function `recommend_movies` where the provided input is: - a dictionary of movies where each key is the movie title (string) and the value is a list of genres (list of strings). - a list of preferred genres from the user (list of strings). The function should return a list of movie titles sorted first by the number of preferred genres they match (in descending order), and then alphabetically by movie title (in ascending order). # Constraints 1. A movie can belong to multiple genres, and there can be several movies per genre. 2. The user\'s preferred genres list can contain multiple genres, and the order does not matter. 3. If two movies match the same number of preferred genres, they should be sorted alphabetically. # Function Signature ```python def recommend_movies(movies: dict[str, list[str]], preferred_genres: list[str]) -> list[str]: ... ``` # Input Format - `movies`: A dictionary where the key is a string representing a movie title and the value is a list of strings, each representing a genre. - `preferred_genres`: A list of strings, each representing a genre. # Output Format - A list of movie titles, sorted by the number of matched preferred genres and then alphabetically. # Example ```python movies = { \\"The Matrix\\": [\\"Action\\", \\"Sci-Fi\\"], \\"Inception\\": [\\"Action\\", \\"Sci-Fi\\", \\"Thriller\\"], \\"Toy Story\\": [\\"Animation\\", \\"Family\\"], \\"Finding Nemo\\": [\\"Animation\\", \\"Family\\"], \\"The Godfather\\": [\\"Crime\\", \\"Drama\\"], } preferred_genres = [\\"Action\\", \\"Sci-Fi\\", \\"Drama\\"] output = recommend_movies(movies, preferred_genres) print(output) # Expected: [\\"Inception\\", \\"The Matrix\\", \\"The Godfather\\"] ``` # Additional Requirements: 1. Raise a `ValueError` if either the `movies` dictionary or the `preferred_genres` list is empty. 2. Handle cases where no movies match any of the preferred genres. Return an empty list in such scenarios.","solution":"def recommend_movies(movies: dict[str, list[str]], preferred_genres: list[str]) -> list[str]: Recommend movies based on user\'s preferred genres. :param movies: A dictionary where keys are movie titles and values are lists of genres. :param preferred_genres: A list of genres preferred by the user. :return: A list of movie titles sorted by the number of matching preferred genres and then alphabetically. if not movies or not preferred_genres: raise ValueError(\\"Movies dictionary or preferred genres list cannot be empty.\\") movie_matches = [] for movie, genres in movies.items(): match_count = len(set(genres) & set(preferred_genres)) if match_count > 0: movie_matches.append((movie, match_count)) movie_matches.sort(key=lambda x: (-x[1], x[0])) return [movie for movie, _ in movie_matches]"},{"question":"# Reverse Each Word in a Sentence When processing text, it could be useful to manipulate individual words within a sentence while maintaining their position. For instance, reversing each word in a sentence can reveal interesting patterns or be used for decoding messages. Your task is to write a function that reverses each word in a given string, but keeps the words in their original positions within the sentence. Function Signature ```python def reverse_words_in_sentence(sentence: str) -> str: pass ``` Input - `sentence` (str): A string containing words separated by spaces. The sentence will consist of only alphabetic characters and spaces. Output - Returns a string where each word in the original sentence is reversed, but the words retain their original positions. Constraints - All words in the input string are separated by a single space. - There will be no leading or trailing spaces in the input. # Examples ```python reverse_words_in_sentence(\\"hello world\\") # Returns \\"olleh dlrow\\" reverse_words_in_sentence(\\"openai is amazing\\") # Returns \\"ianepo si gnizama\\" ``` # Requirements - Implement the `reverse_words_in_sentence` function to reverse each word in the input sentence while preserving word positions. - Ensure that all words in the original sentence are isolated and reversed correctly, resulting in transformed words but maintaining their original sequence. # Scenario In certain applications, such as encoding or text manipulation tasks, it is useful to transform words individually while preserving their overall structure. This function could serve as a building block for more complex text processing tools or for creative writing software that plays with word modifications while maintaining readability. Ensure your solution handles various lengths of words gracefully and efficiently processes the input to produce the correct output.","solution":"def reverse_words_in_sentence(sentence: str) -> str: Reverses each word in a given sentence while keeping the words in their original positions. Args: sentence (str): The input sentence with words separated by spaces. Returns: str: A string where each word from the original sentence is reversed. words = sentence.split() reversed_words = [word[::-1] for word in words] return \\" \\".join(reversed_words)"},{"question":"# Problem Statement Create a function named `generate_sublists` that generates all possible non-empty sublists of a given list of integers. The generated sublists should retain the order of elements as they appear in the original list. The function should return the sublists sorted by length; if multiple sublists have the same length, they should appear in the order they first appear in the list. # Function Signature ```python def generate_sublists(arr: List[int]) -> List[List[int]]: pass ``` # Input * `arr`: A list of integers. # Output * A list containing all non-empty sublists of `arr`, sorted by sublist length and maintaining the order of appearance for sublists of equal length. # Constraints * `0 <= len(arr) <= 15` * `-10^3 <= arr[i] <= 10^3` # Examples ```python assert generate_sublists([1, 2, 3]) == [[1], [2], [3], [1, 2], [2, 3], [1, 2, 3]] assert generate_sublists([4, 5]) == [[4], [5], [4, 5]] assert generate_sublists([7]) == [[7]] assert generate_sublists([]) == [] ``` # Additional Notes 1. Consider using a nested loop or any other method to generate the possible sublists. 2. Be mindful of the efficiency, especially since the list can contain up to 15 elements. 3. Ensure the sublists are returned in the correct order as specified. 4. Pay attention to handling edge cases such as an empty list or a single-element list.","solution":"from typing import List def generate_sublists(arr: List[int]) -> List[List[int]]: sublists = [] n = len(arr) # Generate all possible sublists for i in range(n): for j in range(i+1, n+1): sublists.append(arr[i:j]) # Sort sublists by length primarily, and by order of appearance secondarily sublists.sort(key=lambda x: len(x)) return sublists"},{"question":"# Maximum Length of Pair Chain You are given a list of pairs of integers. Each pair is an instance of a class Pair and contains two integers (a, b) such that a < b. Your task is to write a function that returns the length of the longest chain which can be formed where each pair (a, b) is followed by a pair (c, d) if and only if b < c. The function signature is as follows: ```python def find_longest_chain(pairs: List[Pair]) -> int: ``` # Input * `pairs` (1 ≤ len(pairs) ≤ 1000): A list of `Pair` objects where each `Pair` has two properties `a` and `b` such that `a < b`. # Output * An integer representing the length of the longest chain that can be formed. # Constraints * Your solution should have a time complexity of O(nlogn) and a space complexity of O(n). # Example Example 1: Input: pairs = [Pair(1, 2), Pair(2, 3), Pair(3, 4)] Output: 2 Explanation: The longest chain that can be formed is (1, 2) -> (3, 4) with length 2. Example 2: Input: pairs = [Pair(1, 2), Pair(7, 8), Pair(4, 5)] Output: 3 Explanation: The longest chain that can be formed is (1, 2) -> (4, 5) -> (7, 8) with length 3. # Notes * You can assume that the list of pairs is not sorted. * The pairs satisfy the condition `a < b` for all pairs.","solution":"from typing import List class Pair: def __init__(self, a: int, b: int): self.a = a self.b = b def find_longest_chain(pairs: List[Pair]) -> int: # Sort pairs based on their second element pairs.sort(key=lambda x: x.b) # Initialize the longest chain length max_len = 1 # The end of the first pair in the sorted order current_end = pairs[0].b # Iterate through the sorted pairs and count the chains for i in range(1, len(pairs)): if pairs[i].a > current_end: max_len += 1 current_end = pairs[i].b return max_len"},{"question":"# Sorting Books by Height You are required to write a function `arrange_books_by_height(books: list[tuple[str, int, int]]) -> list[tuple[str, int, int]]` that takes a list of books where each book is represented as a tuple containing the book\'s title, width, and height. The function should return a list of books sorted by their height in ascending order. If two books have the same height, they should be arranged in alphabetical order based on their titles. Function Signature ```python def arrange_books_by_height(books: list[tuple[str, int, int]]) -> list[tuple[str, int, int]]: ``` # Input: 1. `books`: A list of tuples, where each tuple contains a string (title of the book), an integer (width of the book), and an integer (height of the book). # Output: - A list of tuples representing the books sorted first by height in ascending order and then by title alphabetically if heights are the same. # Constraints: - 1 <= |books| <= 1000 - Each title is a non-empty string and can have a maximum length of 100 characters. - 1 <= width, height <= 1000 # Performance Requirements: - The sorting should be efficient with a time complexity of O(NlogN), where N is the number of books. # Examples: **Example 1:** ```python arrange_books_by_height([(\\"Book1\\", 5, 300), (\\"Book2\\", 4, 200), (\\"BookA\\", 6, 200)]) ``` Output: ```python [(\\"Book2\\", 4, 200), (\\"BookA\\", 6, 200), (\\"Book1\\", 5, 300)] ``` **Example 2:** ```python arrange_books_by_height([(\\"Title1\\", 3, 150), (\\"Title2\\", 2, 150), (\\"Title3\\", 4, 100)]) ``` Output: ```python [(\\"Title3\\", 4, 100), (\\"Title2\\", 2, 150), (\\"Title1\\", 3, 150)] ``` **Example 3:** ```python arrange_books_by_height([(\\"A\\", 1, 500), (\\"B\\", 2, 300), (\\"C\\", 3, 500), (\\"D\\", 4, 200)]) ``` Output: ```python [(\\"D\\", 4, 200), (\\"B\\", 2, 300), (\\"A\\", 1, 500), (\\"C\\", 3, 500)] ``` **Example 4:** ```python arrange_books_by_height([]) ``` Output: ```python [] ``` **Example 5:** ```python arrange_books_by_height([(\\"Book1\\", 3, 1000), (\\"Book2\\", 6, 900), (\\"Book3\\", 2, 1000), (\\"Book4\\", 5, 1100)]) ``` Output: ```python [(\\"Book2\\", 6, 900), (\\"Book1\\", 3, 1000), (\\"Book3\\", 2, 1000), (\\"Book4\\", 5, 1100)] ``` # Additional Notes: - You may use Python\'s built-in sorting functionality but make sure to implement the appropriate key to sort by height and then by title if necessary. - Ensure that your function handles edge cases such as an empty list correctly.","solution":"def arrange_books_by_height(books): Arrange a list of books by height in ascending order. If two books have the same height, they are arranged by title alphabetically. Args: - books: A list of tuples. Each tuple contains a title (str), width (int), and height (int). Returns: - A list of tuples sorted by height, then by title. return sorted(books, key=lambda book: (book[2], book[0]))"},{"question":"# Problem Description You are given two strings `s` and `t`. You need to determine if `t` is a subsequence of `s`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. # Function Signature ```python def is_subsequence(s: str, t: str) -> bool: pass ``` # Input * `s: str` - A string consisting of lowercase and uppercase letters. (`1 <= len(s) <= 10^3`) * `t: str` - A string consisting of lowercase and uppercase letters. (`1 <= len(t) <= 10^3`) # Output * Return a boolean value `True` if `t` is a subsequence of `s`, otherwise `False`. # Constraints * All characters in `s` and `t` only include alphabetic characters (`a-z`, `A-Z`). # Example 1. `s = \\"abcdefg\\", t = \\"ace\\"` returns `True`: * `ace` is a subsequence of `abcdefg`. 2. `s = \\"abcdefg\\", t = \\"aec\\"` returns `False`: * While the characters `a`, `e`, and `c` appear in `abcdefg`, they do not appear in the same order. # Note You can implement the function using a two-pointer technique to ensure time efficiency.","solution":"def is_subsequence(s: str, t: str) -> bool: Determine if t is a subsequence of s. Args: s (str): The string to be checked against. t (str): The proposed subsequence. Returns: bool: True if t is a subsequence of s, False otherwise. t_index = 0 t_len = len(t) if t_len == 0: return True for char in s: if char == t[t_index]: t_index += 1 if t_index == t_len: return True return False"},{"question":"# Question: Find Minimum Platforms **Problem Description:** Given the arrival and departure times of trains on a single day at a railway station, your task is to write a function `find_minimum_platforms(arrivals: List[str], departures: List[str]) -> int` that determines the minimum number of platforms required to accommodate all trains without delay. **Function Signature:** ```python def find_minimum_platforms(arrivals: List[str], departures: List[str]) -> int: ``` **Input:** - `arrivals` (1 ≤ len(arrivals) ≤ 1000): A list of strings where each string represents the arrival time of a train in the \\"HH:MM\\" format. - `departures` (1 ≤ len(departures) ≤ 1000): A list of strings where each string represents the departure time of a train in the \\"HH:MM\\" format. Note that the ith train arrives at the time specified by `arrivals[i]` and departs at the time specified by `departures[i]`. **Output:** - Returns an integer representing the minimum number of platforms required. **Example:** ```python arrivals = [\\"09:00\\", \\"09:40\\", \\"09:50\\", \\"11:00\\", \\"15:00\\", \\"18:00\\"] departures = [\\"09:10\\", \\"12:00\\", \\"11:20\\", \\"11:30\\", \\"19:00\\", \\"20:00\\"] print(find_minimum_platforms(arrivals, departures)) # Expected output: 3 arrivals = [\\"09:00\\", \\"09:10\\", \\"09:20\\", \\"09:30\\", \\"09:40\\"] departures = [\\"09:50\\", \\"09:30\\", \\"09:40\\", \\"09:50\\", \\"10:00\\"] print(find_minimum_platforms(arrivals, departures)) # Expected output: 4 ``` **Constraints:** - Trains are not delayed, so the departure time of a train will always be after its arrival time. - Use an efficient algorithm to handle the maximum input size. **Notes:** - Ensure your function accurately handles edge cases such as multiple trains arriving or departing at the same time. - Converting the time format to minutes since midnight may simplify the comparison of times.","solution":"from typing import List def convert_time_to_minutes(time: str) -> int: Convert HH:MM time format to minutes since midnight. hours, minutes = map(int, time.split(\':\')) return hours * 60 + minutes def find_minimum_platforms(arrivals: List[str], departures: List[str]) -> int: n = len(arrivals) # Convert all time strings to minutes since midnight arrival_times = sorted(convert_time_to_minutes(time) for time in arrivals) departure_times = sorted(convert_time_to_minutes(time) for time in departures) platform_needed = 0 max_platforms = 0 i = 0 # index for arrivals j = 0 # index for departures # Traverse through all arrival and departure times while i < n and j < n: if arrival_times[i] <= departure_times[j]: platform_needed += 1 max_platforms = max(max_platforms, platform_needed) i += 1 else: platform_needed -= 1 j += 1 return max_platforms"},{"question":"# Question: Implementing Bubble Sort Context: You are required to implement the Bubble Sort algorithm to sort a given list of integers in ascending order. The function should utilize the basic principles of Bubble Sort, which involves repeatedly stepping through the list, comparing adjacent elements, and swapping them if they are in the wrong order. Function Signature: ```python def bubble_sort(lst: list) -> list: ``` Parameters: - `lst`: a list of integers that needs to be sorted. Returns: - The function returns the sorted list in ascending order. Constraints: - Ensure that the function handles edge cases like an empty list, a list with one element, and a list where all elements are identical. - Optimize the function to stop early if the list becomes sorted before making all potential passes. Examples: ```python # Example 1 print(bubble_sort([64, 34, 25, 12, 22, 11, 90])) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2 print(bubble_sort([5, 1, 4, 2, 8])) # Output: [1, 2, 4, 5, 8] # Example 3 print(bubble_sort([3, 0, 2, 5, -1, 4, 1])) # Output: [-1, 0, 1, 2, 3, 4, 5] # Example 4 print(bubble_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] # Example 5 print(bubble_sort([])) # Output: [] ``` Note: Implement the function in a way that makes use of the Bubble Sort algorithm without using any built-in sorting functions or libraries. Make sure to handle different input scenarios effectively and ensure the function performs the sorting correctly.","solution":"def bubble_sort(lst: list) -> list: Sorts a list of integers in ascending order using the Bubble Sort algorithm. n = len(lst) for i in range(n): # Track if any elements were swapped in the inner loop swapped = False for j in range(0, n-i-1): if lst[j] > lst[j+1]: # Swap adjacent elements if they are in the wrong order lst[j], lst[j+1] = lst[j+1], lst[j] swapped = True # If no elements were swapped, the list is already sorted if not swapped: break return lst"},{"question":"# Question: Minimum Insertion Steps to Make a String Palindrome **Context**: Constructing palindromes from strings is a common problem in computer science and can be achieved through various methods. The minimum insertion steps to make a string palindrome is a measure of how far a given string is from being a palindrome. **Task**: Write a function `minInsertionsToPalindrome` that calculates the minimum number of insertions needed to make a given string a palindrome. An insertion means you can insert any character at any position in the string. **Function Signature**: ```python def minInsertionsToPalindrome(s: str) -> int: Calculate the minimum number of insertions needed to make the string a palindrome. Args: - s (str): The input string. Returns: - int: The minimum number of insertions needed. # Example: # >>> minInsertionsToPalindrome(\\"leetcode\\") # 5 # Explanation: Inserting \'e\', \'e\', \'t\', \'l\', \'l\' at the appropriate positions makes the string \\"leetcodel\\". ``` **Requirements**: 1. Efficient algorithm: Ensure the solution handles the input string length up to 1000 characters efficiently. 2. Dynamic programming: Use a dynamic programming approach to solve the problem optimally. 3. Input constraints: Consider all lowercase English letters. **Hint**: * Compare the given string with its reverse and find the longest common subsequence (LCS). The number of insertions needed would be the difference between the length of the string and the LCS. **Input/Output**: * **Input**: A single string `s`. * **Output**: An integer representing the minimum number of insertions required to make the string a palindrome.","solution":"def minInsertionsToPalindrome(s: str) -> int: Calculate the minimum number of insertions needed to make the string a palindrome. Args: - s (str): The input string. Returns: - int: The minimum number of insertions needed. def longest_common_subsequence(a: str, b: str) -> int: Find the length of the longest common subsequence between two strings. Args: - a (str): The first input string. - b (str): The second input string. Returns: - int: The length of the longest common subsequence. m, n = len(a), len(b) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] rev_s = s[::-1] lcs_length = longest_common_subsequence(s, rev_s) return len(s) - lcs_length"},{"question":"# Question: Subsets Generator You are tasked with implementing a function that generates all possible subsets (the power set) of a given list of distinct integers using a backtracking technique. Your function should take a list of integers and return a list of lists, where each inner list is a unique subset of the input list. Requirements: - Implement a function `generate_subsets(nums: list[int]) -> list[list[int]]` that performs the task. - Do not use Python\'s built-in library functions for subsets or combinations. - Aim for time complexity of `O(2^n)` and space complexity of `O(2^n)`, where `n` is the length of the input list. Constraints: - The input list `nums` will have distinct integers. - The length of `nums` will not exceed 15. # Input Example: ```python nums = [1, 2, 3] ``` # Output Example: ```python [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` # Implementation Challenge: - Consider all edge cases, including the input list containing one or zero elements. - Ensure that the subsets are returned in ascending order based on their length and lexographical order of elements within subsets of same length. # Performance Considerations: - Ensure that your solution efficiently handles the required subsets generation within the given constraints.","solution":"def generate_subsets(nums): Generate all possible subsets of a given list of distinct integers. :param nums: List[int] - a list of distinct integers :return: List[List[int]] - a list of all possible subsets def backtrack(start, path): result.append(path[:]) # Add a copy of the current path to the result for i in range(start, len(nums)): # Include nums[i] in the current subset path.append(nums[i]) # Recurse with remaining items starting from the next position backtrack(i + 1, path) # Exclude the last added item to backtrack path.pop() result = [] backtrack(0, []) return result"},{"question":"# Question **Problem Statement**: You are given a string of lowercase alphabets. Your task is to implement a function that checks if the string is a palindrome by comparing characters case-insensitively while ignoring any non-alphabetic characters. Function Signature: ```python def is_palindrome(s: str) -> bool: pass ``` Input: - `s`: A string. `str`. Output: - Return `True` if the string is a palindrome, otherwise return `False`. Constraints: - Assume the length of the string does not exceed (10^5). Examples: - `is_palindrome(\\"A man, a plan, a canal, Panama\\")` should return `True`. - `is_palindrome(\\"race a car\\")` should return `False`. - `is_palindrome(\\"No \'x\' in Nixon\\")` should return `True`. - `is_palindrome(\\"abc\\")` should return `False`. Notes: - The function should ignore case and any characters that are not alphabets. - Consider both time and space efficiency in your implementation. **Hint**: - Utilize two pointers technique: one starting from the beginning (`left`) and the other from the end (`right`). Move the pointers towards each other while skipping non-alphabetic characters. Good luck!","solution":"def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome, ignoring non-alphabetic characters and case-insensitively. left, right = 0, len(s) - 1 while left < right: # Move left pointer to the next alphabetic character while left < right and not s[left].isalpha(): left += 1 # Move right pointer to the previous alphabetic character while left < right and not s[right].isalpha(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"# Problem Statement You are tasked to implement a function that generates all possible permutations of a given string. Each permutation should be unique and the order of permutations does not matter. Implement the function: 1. `string_permutations(s: str) -> List[str]` Function Definition * **Input**: * `s` (str): The input string. * **Output**: * `List[str]`: A list of all unique permutations of the input string. Constraints * The input string `s` will contain only lowercase letters (\'a\' to \'z\') and will have a length between 1 and 8 inclusive. Error Handling * If `s` is not a string, raise a `ValueError` with the message: `\\"string_permutations() requires a string for input\\"`. Examples * `string_permutations(\\"abc\\")` should return a list containing [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] (order may vary). * `string_permutations(\\"a\\")` should return `[\\"a\\"]`. * `string_permutations(\\"\\")` should raise a `ValueError`.","solution":"from typing import List from itertools import permutations def string_permutations(s: str) -> List[str]: if not isinstance(s, str): raise ValueError(\\"string_permutations() requires a string for input\\") if len(s) == 0: raise ValueError(\\"string_permutations() requires a non-empty string\\") perm_set = set(permutations(s)) return [\\"\\".join(p) for p in perm_set]"},{"question":"# Scenario You are working on developing a streaming service\'s recommendation system and you need to implement a function to suggest new movies based on user ratings. The system should leverage collaborative filtering to find the closest users and suggest movies that they like but the current user has not yet watched. # Requirements 1. **Implementation of Movie Recommendation** - Write a function `recommend_movies` that suggests movies for a user based on movie ratings from other users. - Your function should use a simple collaborative filtering approach based on user similarity using cosine similarity. - Assume that the input movie ratings are given in the form of a 2D array where each row corresponds to a user and each column corresponds to a movie. A value of -1 indicates that the user has not rated the movie. # Input - `ratings` (list of lists of int): User-movie ratings matrix where each row represents a user and each column represents a movie. A rating of -1 indicates the user has not rated the movie. - `user_id` (int): Index of the current user for whom we want to recommend movies. - `num_recommendations` (int): Number of movie recommendations to return. # Output - list of int: List of movie indices recommended for the user. # Constraints - All rating values ∈ [-1, 0, 1, 2, 3, 4, 5] where -1 means the user hasn\'t rated the movie. - 1 ≤ len(ratings) ≤ 1000 (number of users). - 1 ≤ len(ratings[0]) ≤ 1000 (number of movies). - 0 ≤ user_id < len(ratings) (user indices are valid). - 1 ≤ num_recommendations ≤ len(ratings[0]) - number of already rated movies for the user. # Function Signature ```python def recommend_movies(ratings: List[List[int]], user_id: int, num_recommendations: int) -> List[int]: pass ``` # Sample Input and Output ```python >>> ratings_matrix = [ ... [5, 3, -1, 1], ... [4, -1, 4, 1], ... [1, 1, -1, 5], ... [1, -1, -1, 4], ... [5, -1, 4, -1], ... ] >>> user_id = 0 >>> num_recommendations = 2 >>> recommend_movies(ratings_matrix, user_id, num_recommendations) [2, 3] >>> user_id = 2 >>> num_recommendations = 1 >>> recommend_movies(ratings_matrix, user_id, num_recommendations) [2] ``` # Instructions 1. **Similarity Calculation**: Use cosine similarity to find users most similar to the target user. 2. **Movie Selection**: Recommend movies that the most similar users have rated highly but the target user has not rated yet. 3. **Output**: Return the indices of the recommended movies, sorted by the predicted relevance in descending order.","solution":"from typing import List from sklearn.metrics.pairwise import cosine_similarity import numpy as np def recommend_movies(ratings: List[List[int]], user_id: int, num_recommendations: int) -> List[int]: Recommends movies for a user based on movie ratings from other users using collaborative filtering. :param ratings: User-movie ratings matrix where each row represents a user and each column represents a movie. A rating of -1 indicates the user has not rated the movie. :param user_id: Index of the current user for whom we want to recommend movies. :param num_recommendations: Number of movie recommendations to return. :return: List of movie indices recommended for the user. # Convert -1 ratings to 0 for similarity computation ratings_matrix = np.array(ratings) ratings_matrix_for_sim = np.where(ratings_matrix == -1, 0, ratings_matrix) # Compute cosine similarity between users user_similarity = cosine_similarity(ratings_matrix_for_sim) # Similar users for the target user similar_users = np.argsort(-user_similarity[user_id]) # Descending order to get most similar users first similar_users = similar_users[similar_users != user_id] # Exclude the current user # Movies already rated by target user user_ratings = ratings_matrix[user_id] unrated_movies = np.where(user_ratings == -1)[0] movie_scores = {} # Aggregate scores for unrated movies from similar users for similar_user in similar_users: similar_user_ratings = ratings_matrix[similar_user] # Only consider movies rated by the similar user that the target user hasn\'t rated for movie in unrated_movies: if similar_user_ratings[movie] != -1: if movie not in movie_scores: movie_scores[movie] = 0 # Add score weighted by the similarity movie_scores[movie] += similar_user_ratings[movie] * user_similarity[user_id][similar_user] # Sort movies by aggregate scores in descending order and take top N recommended_movies = sorted(movie_scores, key=movie_scores.get, reverse=True)[:num_recommendations] return recommended_movies"},{"question":"Scenario You are tasked with developing a system to manage and track tasks for a project. The system needs to identify which tasks are critical to the project\'s completion based on dependencies. Each task has a unique identifier, and some tasks depend on the completion of others. Your goal is to find out if there\'s a circular dependency among the tasks, which would prevent the project from being completed. # Question Write a function `detect_circular_dependency` that accepts a dictionary where keys are task identifiers and values are lists of task identifiers that the given task depends on. The function should determine if there is a circular dependency among the tasks. # Input * A dictionary where keys are task identifiers and values are lists of task identifiers that the given task depends on (e.g., `{1: [2, 3], 2: [4], 4: [1], 3: []}`). # Output * A boolean value `True` if there is a circular dependency, otherwise `False`. # Constraints 1. The dictionary will contain up to (10^5) tasks. 2. Each task identifier will be a positive integer less than (10^6). 3. No task will depend on itself directly (i.e., no self-loops in input). # Example ```python detect_circular_dependency({1: [2, 3], 2: [4], 4: [1], 3: []}) # Output: True detect_circular_dependency({1: [2, 3], 2: [4], 4: [5], 3: [] , 5: []}) # Output: False detect_circular_dependency({1: []}) # Output: False ``` # Notes * Ensure to handle situations where tasks have no dependencies. * The function must handle cases where task dependency information is missing. * Consider using graph traversal algorithms like DFS to detect cycles effectively. # Function Signature ```python def detect_circular_dependency(tasks: dict) -> bool: pass ```","solution":"def detect_circular_dependency(tasks): Determines if there is a circular dependency in the given tasks. :param tasks: Dictionary where keys are task identifiers and values are lists of task identifiers that the given task depends on. :return: True if there is a circular dependency, otherwise False. def dfs(task, visited, stack): visited.add(task) stack.add(task) for dependency in tasks.get(task, []): if dependency not in visited: if dfs(dependency, visited, stack): return True elif dependency in stack: return True stack.remove(task) return False visited = set() for task in tasks: if task not in visited: if dfs(task, visited, set()): return True return False"},{"question":"# Tree Balance Indicator Scenario You are working on software that evaluates the balance of binary trees. A balanced binary tree is defined as one in which the height of two subtrees of any node never differ by more than one. Your task is to create a function to determine whether a given binary tree is balanced. Problem Statement Implement a function, `is_balanced(root: TreeNode) -> bool`, that: 1. Checks if a binary tree is balanced. 2. Returns `True` if the tree is balanced, and `False` otherwise. Input - `root`: The root node of the binary tree, represented by the `TreeNode` class. Output - Returns a boolean value indicating whether the tree is balanced or not. Constraints - The `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - You may assume the tree is composed of nodes instantiated using the `TreeNode` class. - The solution should effectively handle large trees, ensuring the function runs efficiently without exceeding maximum recursion depth or experiencing significant performance degradation. Example ```python # Example 1: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.left.right = TreeNode(3) root.left.left.left = TreeNode(4) root.left.left.right = TreeNode(4) # The tree looks like this: # 1 # / # 2 2 # / # 3 3 # / # 4 4 print(is_balanced(root)) # Output: False # Example 2: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) # The tree looks like this: # 1 # / # 2 3 # / / # 4 5 6 7 print(is_balanced(root)) # Output: True ``` This function should accurately determine whether a given binary tree is balanced, taking into account the constraint that the height difference between the left and right subtrees of any node is no more than one.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def height_and_balance(node): if not node: return 0, True left_height, left_balance = height_and_balance(node.left) right_height, right_balance = height_and_balance(node.right) current_height = max(left_height, right_height) + 1 current_balance = left_balance and right_balance and abs(left_height - right_height) <= 1 return current_height, current_balance _, balance = height_and_balance(root) return balance"},{"question":"# String Pattern Matching Assessment String pattern matching is a common problem in computer science, which involves finding occurrences of a pattern string within another string. Your task is to implement a function that performs the KMP (Knuth-Morris-Pratt) pattern matching algorithm to locate substrings. Part 1: Compute KMP Table Implement the function `build_kmp_table(pattern: str) -> list` that takes a string `pattern` and returns a list representing the KMP table (also known as the \\"partial match\\" table) used to perform the search efficiently. # Input * `pattern` (str): A string pattern to search for. # Output * List of integers representing the KMP table for the given pattern. # Example ```python >>> build_kmp_table(\\"ABABCABAA\\") [0, 0, 1, 2, 0, 1, 2, 3, 1] ``` Part 2: KMP Search Implement the function `kmp_search(text: str, pattern: str) -> list` that takes two strings, `text` and `pattern`, and returns a list of starting indices where the pattern is found in the text. # Input * `text` (str): The string to search within. * `pattern` (str): The string pattern to search for. # Output * List of integers representing starting indices where the pattern is found in the text. # Example ```python >>> kmp_search(\\"ABABDABACDABABCABAA\\", \\"ABABCABAA\\") [10] ``` Constraints * Characters in the input strings could be any printable ASCII characters. * The pattern will always be non-empty, and the length of the text will be greater than or equal to the length of the pattern. Performance Requirements * Aim for optimal performance with respect to both time and space complexity, leveraging the properties of the KMP algorithm. ```python def build_kmp_table(pattern: str) -> list: # Your code here def kmp_search(text: str, pattern: str) -> list: # Your code here ``` # Solution Outline `build_kmp_table` - Initialize a list `table` with zeros of the same length as `pattern`. - Use two pointers to maintain positions within the pattern: `pointer` to iterate and `length` to mark the length of the current longest prefix which is also a suffix. - Iterate through the pattern to fill the table based on comparisons. `kmp_search` - Use the pre-built KMP table to skip unnecessary comparisons. - Iterate through the text and use the pattern table to move the search index in case of mismatches, efficiently locating all starting indices of pattern matches in the text.","solution":"def build_kmp_table(pattern: str) -> list: Builds the KMP table for a given pattern. length = len(pattern) kmp_table = [0] * length j = 0 for i in range(1, length): while (j > 0 and pattern[i] != pattern[j]): j = kmp_table[j - 1] if pattern[i] == pattern[j]: j += 1 kmp_table[i] = j return kmp_table def kmp_search(text: str, pattern: str) -> list: Implements the KMP search algorithm to find all occurrences of the pattern in the text. if not pattern: return [] kmp_table = build_kmp_table(pattern) text_length = len(text) pattern_length = len(pattern) i = 0 j = 0 result = [] while i < text_length: if text[i] == pattern[j]: i += 1 j += 1 if j == pattern_length: result.append(i - j) j = kmp_table[j - 1] elif i < text_length and text[i] != pattern[j]: if j != 0: j = kmp_table[j - 1] else: i += 1 return result"},{"question":"# Problem Statement Design a class `Cache` to simulate a simple in-memory cache that supports adding, removing, and retrieving key-value pairs. The class should also handle expiration of cached items based on a configurable time-to-live (TTL) value for each item. # Class Signature ```python class Cache: def __init__(self, default_ttl: int): # Your code here def set(self, key: str, value: any, ttl: int = None) -> None: # Your code here def get(self, key: str) -> any: # Your code here def delete(self, key: str) -> None: # Your code here def size(self) -> int: # Your code here ``` # Input * `default_ttl` (int): Default time to live for the cache items in seconds, passed during the cache initialization. * `key` (str): The key for the cache entry. * `value` (any): The value to be cached. * `ttl` (int, optional): Time to live for the cache entry in seconds. If not provided, the cache should use the default TTL passed during initialization. # Output * `None`: For `set` and `delete` methods. * `any`: The cached value or `None` if the key is not found or expired, for the `get` method. * `int`: The current number of non-expired items in the cache, for the `size` method. # Constraints * The cache should handle entries expiring automatically after their TTL has passed. * The `get` method should return `None` for both missing and expired items. * Ensure the implementation is thread-safe to handle concurrent access. # Example ```python >>> cache = Cache(default_ttl=5) >>> cache.set(\\"key1\\", \\"value1\\") >>> cache.get(\\"key1\\") \\"value1\\" >>> time.sleep(6) >>> cache.get(\\"key1\\") None >>> cache.set(\\"key2\\", \\"value2\\", ttl=10) >>> cache.get(\\"key2\\") \\"value2\\" >>> cache.delete(\\"key2\\") >>> cache.get(\\"key2\\") None >>> cache.set(\\"key3\\", \\"value3\\") >>> cache.size() 1 ``` # Additional Notes * Consider using Python\'s built-in `time` module for handling TTL. * Implement appropriate mechanisms to clean up expired items to avoid memory leaks. * Enhance the class with thread-safety measures to manage concurrent read/write operations efficiently.","solution":"import time import threading class Cache: def __init__(self, default_ttl: int): self.default_ttl = default_ttl self.cache = {} self.lock = threading.Lock() def set(self, key: str, value: any, ttl: int = None) -> None: if ttl is None: ttl = self.default_ttl expire_time = time.time() + ttl with self.lock: self.cache[key] = (value, expire_time) def get(self, key: str) -> any: current_time = time.time() with self.lock: if key in self.cache: value, expire_time = self.cache[key] if current_time < expire_time: return value else: del self.cache[key] return None def delete(self, key: str) -> None: with self.lock: if key in self.cache: del self.cache[key] def size(self) -> int: current_time = time.time() with self.lock: self.cache = {k: v for k, v in self.cache.items() if v[1] > current_time} return len(self.cache)"},{"question":"# Code Challenge: Implement LRU Cache **Context**: A Least Recently Used (LRU) Cache is a cache data structure that evicts the least recently used entry when it reaches its max size limit. This keeps the most frequently accessed elements in the cache. # Task Implement a class `LRUCache` using a combination of a dictionary and a doubly linked list. Your class should support the following operations: 1. **Get**: Retrieve an element from the cache. 2. **Put**: Add or update an element in the cache. # Input and Output - **Get Operation**: - Method: `get(key: int) -> int` - Input: Integer key. - Output: Integer value associated with the key, or -1 if the key does not exist in the cache. - **Put Operation**: - Method: `put(key: int, value: int) -> None` - Input: Integer key and value pair. - Output: None. # Constraints 1. Cache capacity will be a positive integer. 2. Make sure all operations have an average time complexity of O(1). 3. Implement all required functions. # Scenario Create an `LRUCache` instance with a size limit of 3. Add and retrieve elements, observing the correct property of the cache evicting the least recently used elements. ```python class DLinkedNode: def __init__(self, key: int = 0, value: int = 0): self.key = key # Key associated with the node self.value = value # Value associated with the node self.prev = None # Pointer to the previous node in the list self.next = None # Pointer to the next node in the list class LRUCache: def __init__(self, capacity: int): self.cache = {} # Dictionary to map keys to their corresponding node self.capacity = capacity # Maximum number of items that can be held in the cache self.size = 0 # Number of items currently stored in the cache self.head = DLinkedNode() # Dummy head of the doubly linked list self.tail = DLinkedNode() # Dummy tail of the doubly linked list self.head.next = self.tail self.tail.prev = self.head def get(self, key: int) -> int: pass # Implement the get operation def put(self, key: int, value: int) -> None: pass # Implement the put operation def _add_node(self, node: DLinkedNode) -> None: pass # Add a new node right after the head def _remove_node(self, node: DLinkedNode) -> None: pass # Remove an existing node from the list def _move_to_head(self, node: DLinkedNode) -> None: pass # Move certain node in between to the head def _pop_tail(self) -> DLinkedNode: pass # Pop the current tail if __name__ == \\"__main__\\": cache = LRUCache(3) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) print(cache.get(1)) # Expected Output: 1 cache.put(4, 4) # The cache\'s size is only 3, so the least recently used key (2) should be removed. print(cache.get(2)) # Expected Output: -1 # The remaining keys should be (1, 3, 4) cache.put(5, 5) # The key (3) should now be removed from the cache print(cache.get(3)) # Expected Output: -1 print(cache.get(4)) # Expected Output: 4 ``` Ensure proper handling of edge cases such as capacity limits, non-existent keys, and maintaining the order of least recently used elements.","solution":"class DLinkedNode: def __init__(self, key: int = 0, value: int = 0): self.key = key # Key associated with the node self.value = value # Value associated with the node self.prev = None # Pointer to the previous node in the list self.next = None # Pointer to the next node in the list class LRUCache: def __init__(self, capacity: int): self.cache = {} # Dictionary to map keys to their corresponding node self.capacity = capacity # Maximum number of items that can be held in the cache self.size = 0 # Number of items currently stored in the cache self.head = DLinkedNode() # Dummy head of the doubly linked list self.tail = DLinkedNode() # Dummy tail of the doubly linked list self.head.next = self.tail self.tail.prev = self.head def get(self, key: int) -> int: node = self.cache.get(key, None) if not node: return -1 self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if not node: newNode = DLinkedNode(key, value) self.cache[key] = newNode self._add_node(newNode) self.size += 1 if self.size > self.capacity: tail = self._pop_tail() del self.cache[tail.key] self.size -= 1 else: node.value = value self._move_to_head(node) def _add_node(self, node: DLinkedNode) -> None: node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _remove_node(self, node: DLinkedNode) -> None: prev = node.prev new = node.next prev.next = new new.prev = prev def _move_to_head(self, node: DLinkedNode) -> None: self._remove_node(node) self._add_node(node) def _pop_tail(self) -> DLinkedNode: res = self.tail.prev self._remove_node(res) return res"},{"question":"# Coding Assessment Question Context: You are working on a financial application that processes transaction logs to identify fraudulent activities based on sudden spikes in transaction amounts. Each transaction log includes a timestamp, an account id, and the transaction amount. Given a series of transactions, you need to detect if any transaction amount significantly exceeds the average transaction amount for that account. Task: Write a function `detect_fraud(transactions: list[tuple[int, int, float]]) -> list[int]` that accepts a list of transactions and returns a list of account ids where suspicious transactions are detected. A transaction is considered suspicious if it is more than 3 times the average amount of all previous transactions for that account. The list of suspicious accounts should be sorted in ascending order and must not contain duplicates. Function Signature: ```python def detect_fraud(transactions: list[tuple[int, int, float]]) -> list[int]: ``` Input: * `transactions`: A list of tuples where each tuple contains: - `timestamp` (int): The time of the transaction in Unix epoch format. - `account_id` (int): The identifier for the account. - `amount` (float): The amount of the transaction in dollars. * Example: `[(1622547800, 1, 100.0), (1622547801, 2, 50.0), (1622547802, 1, 500.0)]` Output: * A list of integers representing account ids with suspicious transactions. * Example: `[1]` for the example above. Constraints: * The input list will contain between 1 and 10^5 transactions. * Amounts will be positive floating point numbers. * The transaction list is sorted by timestamp in ascending order. Example: ```python transactions = [(1622547800, 1, 100.0), (1622547801, 2, 50.0), (1622547802, 1, 500.0)] assert detect_fraud(transactions) == [1] ``` Performance Requirements: * The solution should operate efficiently with respect to both time and space, ideally within O(n log n) time complexity for processing and sorting. Summary: Implement the `detect_fraud` function to identify suspicious transactions from a list of transaction logs. Ensure that the detection aligns with the criteria for significant deviation from the average transaction amount and handles potential edge cases efficiently.","solution":"def detect_fraud(transactions): account_data = {} suspicious_accounts = set() for timestamp, account_id, amount in transactions: if account_id not in account_data: account_data[account_id] = { \\"total_amount\\": 0, \\"transaction_count\\": 0, \\"suspicious\\": False } account = account_data[account_id] total_amount = account[\\"total_amount\\"] transaction_count = account[\\"transaction_count\\"] if transaction_count > 0: avg_amount = total_amount / transaction_count if amount > 3 * avg_amount and not account[\\"suspicious\\"]: suspicious_accounts.add(account_id) account_data[account_id][\\"suspicious\\"] = True account_data[account_id][\\"total_amount\\"] += amount account_data[account_id][\\"transaction_count\\"] += 1 return sorted(suspicious_accounts)"},{"question":"**Scenario** You are developing a mathematical library to aid in statistical and numerical operations. As part of this project, you are required to enhance the existing library by adding functionalities for matrix operations, including addition, multiplication, and transposition. # Task 1. **Class Implementation**: - Implement a `Matrix` class that supports the following functionalities: - A constructor that initializes the matrix with a 2D list (list of lists). - An `add` method that takes another `Matrix` object and returns a new `Matrix` representing the element-wise sum of the two matrices. - A `multiply` method that takes another `Matrix` object and returns a new `Matrix` representing the matrix product. - A `transpose` method that returns a new `Matrix` which is the transpose of the original matrix. - An `__str__` method for a user-friendly string representation of the matrix. 2. **Dimension Validation**: - Ensure that for matrix addition and multiplication, the dimensions of the matrices are validated. If the dimensions do not allow the operation, raise a `ValueError` with an appropriate message. 3. **Utility Method**: - Implement a static `identity` method that generates and returns an identity matrix of a given size. # Input and Output Format - **Input**: * For `Matrix` class constructor: a 2D list of floats. * For `add` and `multiply` methods: another `Matrix` object. * For `transpose` method: No additional input. * For `identity` method: size of the identity matrix (integer). - **Output**: * For `add` and `multiply` methods: returns a new `Matrix` object. * For `transpose` method: returns a new `Matrix` object. * For `identity` method: returns a new `Matrix` object. * For `__str__` method: returns a string representation of the matrix. # Constraints - All elements in the matrices will be floating-point numbers. - Matrices involved in addition must be of the same dimension. - Matrices involved in multiplication must have compatible dimensions (the number of columns in the first matrix must match the number of rows in the second matrix). # Example ```python # Class Implementation matrix1 = Matrix([[1.0, 2.0], [3.0, 4.0]]) matrix2 = Matrix([[5.0, 6.0], [7.0, 8.0]]) # Matrix Addition try: result_add = matrix1.add(matrix2) print(result_add) # Matrix([[6.0, 8.0], [10.0, 12.0]]) except ValueError as e: print(e) # Outputs: \\"Matrices must have the same dimensions for addition.\\" # Matrix Multiplication try: result_multiply = matrix1.multiply(matrix2) print(result_multiply) # Matrix([[19.0, 22.0], [43.0, 50.0]]) except ValueError as e: print(e) # Outputs: \\"Matrix dimensions are not compatible for multiplication.\\" # Matrix Transpose result_transpose = matrix1.transpose() print(result_transpose) # Matrix([[1.0, 3.0], [2.0, 4.0]]) # Identity Matrix identity_matrix = Matrix.identity(2) print(identity_matrix) # Matrix([[1.0, 0.0], [0.0, 1.0]]) ```","solution":"class Matrix: def __init__(self, data): self.data = data self.rows = len(data) self.cols = len(data[0]) if data else 0 def __check_dimensions_for_addition(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices must have the same dimensions for addition.\\") def __check_dimensions_for_multiplication(self, other): if self.cols != other.rows: raise ValueError(\\"Matrix dimensions are not compatible for multiplication.\\") def add(self, other): self.__check_dimensions_for_addition(other) result_data = [[self.data[i][j] + other.data[i][j] for j in range(self.cols)] for i in range(self.rows)] return Matrix(result_data) def multiply(self, other): self.__check_dimensions_for_multiplication(other) result_data = [[sum(self.data[i][k] * other.data[k][j] for k in range(self.cols)) for j in range(other.cols)] for i in range(self.rows)] return Matrix(result_data) def transpose(self): result_data = [[self.data[j][i] for j in range(self.rows)] for i in range(self.cols)] return Matrix(result_data) def __str__(self): return \'n\'.join([\'t\'.join(map(str, row)) for row in self.data]) @staticmethod def identity(size): return Matrix([[1.0 if i == j else 0.0 for j in range(size)] for i in range(size)])"},{"question":"# Question You are responsible for writing a function `anagram_groups` that processes a list of strings and groups the anagrams together. The function should leverage efficient data structures to ensure optimal performance given the constraints. Specifications - Function: `anagram_groups(words: list[str]) -> list[list[str]]` - **Input**: - `words`: List of strings to be analyzed, where each string consists of lowercase English letters. - **Output**: - A list of lists, where each inner list contains words that are anagrams of each other. Constraints - Assume the length of each word is between 1 and 100 characters. - The maximum number of words is 10,000. - Words are case-sensitive. Example ```python >>> words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] >>> anagram_groups(words) [[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']] ```","solution":"from collections import defaultdict def anagram_groups(words): Groups the anagrams together from the given list of words. :param words: List of strings where each string consists of lowercase English letters :return: List of lists of anagrams anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"# Binary Tree Level Order Traversal You are asked to implement a binary tree level order traversal algorithm. This is a common programming task in various computing applications, including parsing hierarchical data structures. # Requirements 1. **Class Definition**: Define a class `TreeNode` that represents a node in the binary tree. This class should have an integer value, and pointers to its left and right children. 2. **Function Implementation**: Implement a function `level_order_traversal(root: TreeNode) -> List[List[int]]` that accepts the root node of a binary tree and returns a list of lists containing the values of the nodes for each level of the tree. 3. **Edge Case Handling**: Ensure that the function correctly handles an empty tree (i.e., when the root node is `None`). # Input/Output Format - **Input**: - `level_order_traversal(root: TreeNode) -> List[List[int]]`: Takes the root of a binary tree and returns a list of lists where each sublist contains the values of the nodes at a particular level in the tree. - **Output**: - The function should return a list of lists, where each sublist represents one level of the binary tree. # Performance Requirements - Ensure that the solution maintains a time complexity of `O(n)` where `n` is the number of nodes in the tree. - Space complexity should also remain `O(n)`. # Constraints - Each `TreeNode` value must be an integer. - The binary tree can have an arbitrary structure with both positive and negative integer values. # Example Workflow ```python # Define TreeNode class class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example of creating a binary tree. root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) # Example usage of level_order_traversal output = level_order_traversal(root) print(output) # OUTPUT: [[3], [9, 20], [15, 7]] ``` # Hints for Consideration - Consider using a queue data structure to facilitate the level order traversal. - Think about how to handle nodes at each level to populate the corresponding sublist in the result. - Ensure that the algorithm correctly processes all nodes from the root to the leaves.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Binary Tree Height You are required to implement a function to calculate the height of a binary tree. The height of a binary tree is the number of edges on the longest path from the root node to any leaf node. **Input Format:** A binary tree represented by a root node `root`. **Output Format:** Return an integer representing the height of the binary tree. **Constraints:** 1. The number of nodes in the tree will be in the range [0, 10^4]. 2. The value of each node in the tree will be a unique integer. **Performance Requirements:** The implementation should be efficient, operating in O(n) time complexity, where n is the number of nodes in the tree. **Examples:** ```python # Example 1: # Input: # 1 # / # 2 3 # / # 4 5 # Output: 2 # Example 2: # Input: # 10 # / # 20 30 # # 40 # / # 50 # Output: 3 # Example 3: # Input: # 10 # Output: 0 ``` **Function Signature:** ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_height(root: TreeNode) -> int: # Your code goes here pass ``` **Note:** - Ensure to handle cases where the tree is empty. For an empty tree, the height is considered to be -1. - Use a recursive approach to calculate the height for a clear and concise implementation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_height(root: TreeNode) -> int: if root is None: return -1 else: left_height = binary_tree_height(root.left) right_height = binary_tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Question: Temperature Conversion and Comparison Context You are developing a module for temperature conversion between Fahrenheit and Celsius, and comparing these temperatures. You aim to determine which of the two temperatures is higher after conversion. Function Definition Complete the function `compare_temperatures` that accepts two parameters: - `temp1` (str): the first temperature specified as a string in the format \\"XXF\\" or \\"XXC\\" where `XX` represents the numerical temperature and `F` or `C` indicates Fahrenheit or Celsius, respectively. - `temp2` (str): the second temperature specified as a string in the same format as `temp1`. The function should return: - `\\"Temp1\\"` if the first temperature is higher, - `\\"Temp2\\"` if the second temperature is higher, - `\\"Equal\\"` if both temperatures are the same. Example: ```python def compare_temperatures(temp1: str, temp2: str) -> str: Compares two temperatures given in Fahrenheit or Celsius and determines which one is higher. >>> compare_temperatures(\\"30C\\", \\"86F\\") \'Equal\' >>> compare_temperatures(\\"25C\\", \\"77F\\") \'Equal\' >>> compare_temperatures(\\"50F\\", \\"10C\\") \'Temp1\' >>> compare_temperatures(\\"100C\\", \\"212F\\") \'Equal\' >>> compare_temperatures(\\"5C\\", \\"41F\\") \'Equal\' # Your implementation here # Example usage compare_temperatures(\\"30C\\", \\"86F\\") ``` Constraints: - Both temperatures will always include a numerical part followed by either \'F\' or \'C\'. - The numerical part (temperature value) will be within a reasonable range typically encountered in weather data.","solution":"def compare_temperatures(temp1: str, temp2: str) -> str: Compares two temperatures given in Fahrenheit or Celsius and determines which one is higher. Args: - temp1 (str): First temperature specified as a string in the format \\"XXF\\" or \\"XXC\\" - temp2 (str): Second temperature specified as a string in the format \\"XXF\\" or \\"XXC\\" Returns: - str: \\"Temp1\\" if the first temperature is higher, \\"Temp2\\" if the second temperature is higher, or \\"Equal\\" if both temperatures are the same. def to_celsius(temp: str) -> float: Convert temperature to Celsius. value = float(temp[:-1]) if temp[-1] == \'F\': return (value - 32) * 5/9 return value temp1_c = to_celsius(temp1) temp2_c = to_celsius(temp2) if temp1_c > temp2_c: return \\"Temp1\\" elif temp1_c < temp2_c: return \\"Temp2\\" else: return \\"Equal\\""},{"question":"# Coding Assessment Question **Context**: You are designing a data structure that manages a collection of books in a library. Each book has a unique identifier, a title, an author, and a year of publication. You are required to provide functionality to add new books, update existing ones, delete books, and query the collection based on certain criteria. **Objective**: Write a class `LibraryCollection` to manage the book information. This class should support the following operations: 1. **Initialize**: `__init__(self)` - Initializes an empty collection. 2. **Add Book**: `add_book(self, book_id: int, title: str, author: str, year: int)` - Adds a new book to the collection. 3. **Update Book**: `update_book(self, book_id: int, title: Optional[str] = None, author: Optional[str] = None, year: Optional[int] = None)` - Updates information for an existing book. Any parameter not provided should remain unchanged. 4. **Delete Book**: `delete_book(self, book_id: int)` - Removes a book from the collection. 5. **Query Books by Author**: `query_by_author(self, author: str) -> List[int]` - Returns a list of book IDs written by the specified author. 6. **Query Books by Year Range**: `query_by_year_range(self, start_year: int, end_year: int) -> List[int]` - Returns a list of book IDs published within the specified year range (inclusive). **Input/Output Formats**: * **Input**: * Add Book: `add_book(self, book_id: int, title: str, author: str, year: int)` * Update Book: `update_book(self, book_id: int, title: Optional[str] = None, author: Optional[str] = None, year: Optional[int] = None)` * Delete Book: `delete_book(self, book_id: int)` * Query by Author: `query_by_author(self, author: str)` * Query by Year Range: `query_by_year_range(self, start_year: int, end_year: int)` * **Output**: * Query by Author: Returns a list of book IDs of books written by the specified author. * Query by Year Range: Returns a list of book IDs of books published in the specified year range. **Constraints**: * Each book ID will be a unique integer. * The title and author will be non-empty strings. * The year will be a 4-digit integer, representing a valid year. * The number of books in the collection will not exceed 10^5. * The number of operations (add, update, delete, query) will not exceed 10^5. **Example**: ```python # Initialize the library collection library = LibraryCollection() # Add books to the collection library.add_book(1, \\"Book One\\", \\"Author A\\", 2001) library.add_book(2, \\"Book Two\\", \\"Author B\\", 2005) library.add_book(3, \\"Book Three\\", \\"Author A\\", 2010) # Update a book in the collection library.update_book(1, title=\\"Updated Book One\\") # Query books by author assert library.query_by_author(\\"Author A\\") == [1, 3] # Query books by year range assert library.query_by_year_range(2000, 2005) == [1, 2] # Delete a book from the collection library.delete_book(2) # Re-query books by year range assert library.query_by_year_range(2000, 2005) == [1] ```","solution":"from typing import List, Optional, Dict class LibraryCollection: def __init__(self): self.books = {} def add_book(self, book_id: int, title: str, author: str, year: int): self.books[book_id] = { \\"title\\": title, \\"author\\": author, \\"year\\": year } def update_book(self, book_id: int, title: Optional[str] = None, author: Optional[str] = None, year: Optional[int] = None): if book_id in self.books: if title is not None: self.books[book_id][\\"title\\"] = title if author is not None: self.books[book_id][\\"author\\"] = author if year is not None: self.books[book_id][\\"year\\"] = year def delete_book(self, book_id: int): if book_id in self.books: del self.books[book_id] def query_by_author(self, author: str) -> List[int]: return [book_id for book_id, book in self.books.items() if book[\\"author\\"] == author] def query_by_year_range(self, start_year: int, end_year: int) -> List[int]: return [book_id for book_id, book in self.books.items() if start_year <= book[\\"year\\"] <= end_year]"},{"question":"**Introduction**: You are given a binary search tree (BST) and a target value. Your task is to find the node in the BST that is closest to the target value. This problem will test your understanding of tree traversal and your ability to handle BST properties to find the optimal solution efficiently. **Problem**: Implement the method `closest_value(self, target: float) -> int` within the `BinarySearchTree` class. The method should return the value of the node that is closest to the target value. If there are two values with equal distance to the target, return the smaller one. **Input**: - An instance of the `BinarySearchTree` class, which has been initialized with an iterable to create the BST. - A float `target`, which specifies the target value you need to find the closest node to. **Output**: - An integer, the value of the node that is closest to the target. **Constraints**: - The number of nodes in the BST is at most 1000. - Node values are distinct integers. - `target` is a float number. **Example**: ```python >>> bst = BinarySearchTree([10, 5, 3, 7, 15, 13, 18]) >>> bst.closest_value(8.4) 7 >>> bst = BinarySearchTree([4, 2, 5, 1, 3]) >>> bst.closest_value(3.714286) 4 ``` **Requirements**: - Ensure the solution is efficient, with an average time complexity of O(log n). - Handle edge cases, such as an empty tree (return `None`). **Additional**: - You may utilize helper methods or additional classes if needed. - Assume the provided `BinarySearchTree` and `Node` classes allow for standard BST operations but adhere to the input and output format constraints. Example Solution: ```python class BinarySearchTreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self, values: list): self.root = None for value in values: self.insert(value) def insert(self, value: int) -> None: if not self.root: self.root = BinarySearchTreeNode(value) else: self._insert(self.root, value) def _insert(self, node: BinarySearchTreeNode, value: int) -> None: if value < node.value: if node.left: self._insert(node.left, value) else: node.left = BinarySearchTreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = BinarySearchTreeNode(value) def closest_value(self, target: float) -> int: return self._closest_value(self.root, target, float(\'inf\')) def _closest_value(self, node: BinarySearchTreeNode, target: float, closest: int) -> int: if not node: return closest if abs(target - node.value) < abs(target - closest): closest = node.value if target < node.value and node.left: return self._closest_value(node.left, target, closest) elif target > node.value and node.right: return self._closest_value(node.right, target, closest) else: return closest ```","solution":"class BinarySearchTreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self, values: list): self.root = None for value in values: self.insert(value) def insert(self, value: int) -> None: if not self.root: self.root = BinarySearchTreeNode(value) else: self._insert(self.root, value) def _insert(self, node: BinarySearchTreeNode, value: int) -> None: if value < node.value: if node.left: self._insert(node.left, value) else: node.left = BinarySearchTreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = BinarySearchTreeNode(value) def closest_value(self, target: float) -> int: return self._closest_value(self.root, target, float(\'inf\')) def _closest_value(self, node: BinarySearchTreeNode, target: float, closest: int) -> int: if not node: return closest if abs(target - node.value) < abs(target - closest): closest = node.value if target < node.value and node.left: return self._closest_value(node.left, target, closest) elif target > node.value and node.right: return self._closest_value(node.right, target, closest) else: return closest"},{"question":"# Problem Statement You are tasked with creating a function `windowed_sum` that computes the sum of elements within a sliding window of a specified size across a given list of integers. The function should return a new list where each element is the sum of the elements within the sliding window at that position. # Input * A list of integers, `arr`, where (1 leq text{len(arr)} leq 10^5). * An integer, `window_size`, where (1 leq text{window_size} leq text{len(arr)}). # Output * Return a list of integers representing the sum of elements within each sliding window. # Function Signature ```python def windowed_sum(arr: list, window_size: int) -> list: pass ``` # Constraints * You may not use any external libraries. * The function should aim to minimize time complexity and make efficient use of sliding window techniques. # Example ```python >>> windowed_sum([1, 2, 3, 4, 5], 3) [6, 9, 12] >>> windowed_sum([10, 20, 30, 40, 50], 2) [30, 50, 70, 90] >>> windowed_sum([0, -1, 2, -3, 4, -5], 4) [-2, 2, -2] ``` # Detailed Explanation * The function `windowed_sum` should compute the sum of elements for each possible position of the sliding window across the list `arr`. * For example, if `arr = [1, 2, 3, 4, 5]` and `window_size = 3`, the windows are `[1, 2, 3]`, `[2, 3, 4]`, and `[3, 4, 5]`, and their sums are `6`, `9`, and `12` respectively. * Use an efficient approach to avoid re-computing the sum from scratch for each window position. * A sliding window technique involves adding the new element of the window and subtracting the old element exiting the window. * Handle edge cases, such as minimal and maximal values of `arr` and `window_size`, ensuring proper windowing and summation even when `window_size` is 1 or equal to the length of `arr`.","solution":"def windowed_sum(arr: list, window_size: int) -> list: Computes the sum of elements within a sliding window of specified size across the given list of integers. Parameters: arr (list): List of integers. window_size (int): Size of the sliding window. Returns: list: List of sums of elements within each sliding window. if not arr or window_size <= 0 or window_size > len(arr): return [] # Initialize the result list and the initial window sum result = [] window_sum = sum(arr[:window_size]) result.append(window_sum) for i in range(window_size, len(arr)): window_sum += arr[i] - arr[i - window_size] result.append(window_sum) return result"},{"question":"# Palindromic Primes Context: A palindromic prime is a prime number that remains the same when its digits are reversed. In other words, it is both a palindrome and a prime number. To determine whether a number is a palindromic prime, you need to check that it is a prime number and that it reads the same forward and backward. Objective: Write a function that identifies all palindromic prime numbers within a given range `[a, b]` (inclusive). Function Signature: ```python def palindromic_primes(a: int, b: int) -> List[int]: ``` Input: * `a` (int): the start of the range, where 1 ≤ a ≤ 10^6. * `b` (int): the end of the range, where 1 ≤ b ≤ 10^6, and `a <= b`. Output: * A list of all palindromic prime numbers in the range `[a, b]`. The list should be sorted in ascending order. Constraints: * The function should handle ranges efficiently, even up to 10^6. * Prime checking and palindrome checking should both be optimized to avoid redundant calculations. Example: ```python assert palindromic_primes(1, 100) == [2, 3, 5, 7, 11, 101] assert palindromic_primes(101, 200) == [101, 131, 151, 181, 191] ``` Notes: * Utilize efficient algorithms for prime checking, such as the Sieve of Eratosthenes. * Consider a helper function to check if a number is a palindrome. * Aim to minimize the time complexity to handle large ranges effectively.","solution":"from typing import List def is_prime(num: int) -> bool: Check if a given number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def is_palindrome(num: int) -> bool: Check if a given number is a palindrome. return str(num) == str(num)[::-1] def palindromic_primes(a: int, b: int) -> List[int]: Find all palindromic prime numbers within a given range [a, b]. palindromic_primes_list = [] for num in range(a, b + 1): if is_palindrome(num) and is_prime(num): palindromic_primes_list.append(num) return palindromic_primes_list"},{"question":"# Objective Implement and validate the provided temperature and unit conversion functions with a focus on ensuring both correctness in conversions and handling edge cases effectively. # Question You are tasked to implement three functions: `celsius_to_fahrenheit`, `fahrenheit_to_celsius`, and `temperature_converter`. These functions will compute temperature conversions between Celsius and Fahrenheit. `celsius_to_fahrenheit` This function converts a given temperature from Celsius to Fahrenheit. **Function Signature:** ```python def celsius_to_fahrenheit(celsius: float) -> float: ``` **Input:** * `celsius` (float): the temperature in Celsius. **Output:** * Returns the temperature in Fahrenheit. `fahrenheit_to_celsius` This function converts a given temperature from Fahrenheit to Celsius. **Function Signature:** ```python def fahrenheit_to_celsius(fahrenheit: float) -> float: ``` **Input:** * `fahrenheit` (float): the temperature in Fahrenheit. **Output:** * Returns the temperature in Celsius. `temperature_converter` This function converts the temperature given a unit type to the other format and vice versa. **Function Signature:** ```python def temperature_converter(temperature: float, from_unit: str, to_unit: str) -> float: ``` **Input:** * `temperature` (float): the temperature value to be converted. * `from_unit` (str): a string indicating the unit type of the input temperature (`\\"C\\"` for Celsius or `\\"F\\"` for Fahrenheit). * `to_unit` (str): a string indicating the unit type of the desired output temperature (`\\"C\\"` for Celsius or `\\"F\\"` for Fahrenheit). **Output:** * Returns the converted temperature. * Raises `ValueError` if the `from_unit` or `to_unit` is not `\\"C\\"` or `\\"F\\"`. * Raises `ValueError` if `from_unit` and `to_unit` are the same. # Example ```python # Example function calls and expected results: print(celsius_to_fahrenheit(100.0)) # Expected output: 212.0 print(fahrenheit_to_celsius(32.0)) # Expected output: 0.0 print(temperature_converter(100.0, \\"C\\", \\"F\\")) # Expected output: 212.0 print(temperature_converter(32.0, \\"F\\", \\"C\\")) # Expected output: 0.0 ``` # Constraints 1. You must validate the input parameters as described. 2. Ensure precision and accuracy in your arithmetic calculations. 3. Aim to make your implementations efficient with O(1) time complexity. 4. Use proper exception handling where specified, especially for parameters outside the typical range of temperatures and incorrect unit inputs. This new question focuses on implementing and validating temperature conversion functions, adding variety while maintaining consistency with the existing questions on financial calculations and floating-point precision.","solution":"def celsius_to_fahrenheit(celsius: float) -> float: Converts a temperature from Celsius to Fahrenheit. return (celsius * 9/5) + 32 def fahrenheit_to_celsius(fahrenheit: float) -> float: Converts a temperature from Fahrenheit to Celsius. return (fahrenheit - 32) * 5/9 def temperature_converter(temperature: float, from_unit: str, to_unit: str) -> float: Converts the temperature from one unit to another. Parameters: temperature (float): The temperature value to be converted. from_unit (str): The unit of the input temperature, \\"C\\" for Celsius or \\"F\\" for Fahrenheit. to_unit (str): The unit of the desired output temperature, \\"C\\" for Celsius or \\"F\\" for Fahrenheit. Returns: float: The converted temperature. Raises: ValueError: If from_unit or to_unit is not \\"C\\" or \\"F\\", or if from_unit and to_unit are the same. if from_unit == to_unit: raise ValueError(\\"from_unit and to_unit must be different.\\") if from_unit == \'C\' and to_unit == \'F\': return celsius_to_fahrenheit(temperature) elif from_unit == \'F\' and to_unit == \'C\': return fahrenheit_to_celsius(temperature) else: raise ValueError(\\"Invalid unit. Use \'C\' for Celsius and \'F\' for Fahrenheit.\\")"},{"question":"# Question: Inventory Management System You are working on an inventory management system for a warehouse. The system needs to keep track of the quantities of various items and process orders for item retrieval effectively. Your task is to implement a function that processes an order list, updates the inventory quantities, and returns a list of items that could not be fulfilled due to insufficient stock. The inventory is represented as a dictionary where keys are item names and values are the quantities in stock. An order list is provided as a list of dictionaries, each containing an item name and a quantity requested. Function Signature ```python def process_orders(inventory: dict, orders: list[dict]) -> list[str]: Args: inventory (dict): A dictionary representing the current stock levels. Keys are item names (strings) and values are quantities (integers). orders (list[dict]): A list of dictionaries, each representing an order with the keys \\"item\\" (string) and \\"quantity\\" (integer). Returns: list[str]: A list of item names that could not be fulfilled due to insufficient stock. ``` Example ```python inventory = { \\"apple\\": 10, \\"banana\\": 5, \\"cherry\\": 0, } orders = [ {\\"item\\": \\"apple\\", \\"quantity\\": 5}, {\\"item\\": \\"banana\\", \\"quantity\\": 6}, {\\"item\\": \\"cherry\\", \\"quantity\\": 1}, {\\"item\\": \\"apple\\", \\"quantity\\": 7}, ] print(process_orders(inventory, orders)) # Output: [\'banana\', \'cherry\', \'apple\'] ``` Constraints - Item names are non-empty strings. - Quantities in the inventory and orders are non-negative integers. - If an item is requested that is not present in the inventory, it should be considered unavailable and added to the unfulfilled list. - The inventory and order list will contain up to 1000 items each. Notes - The inventory should be updated in place, reflecting the quantities after processing all orders. - Ensure your implementation handles edge cases correctly, such as when orders request nonexistent items or when quantities requested exceed quantities in stock. - Optimize your solution for efficient processing of the orders, given the size constraints.","solution":"def process_orders(inventory: dict, orders: list[dict]) -> list[str]: Args: inventory (dict): A dictionary representing the current stock levels. Keys are item names (strings) and values are quantities (integers). orders (list[dict]): A list of dictionaries, each representing an order with the keys \\"item\\" (string) and \\"quantity\\" (integer). Returns: list[str]: A list of item names that could not be fulfilled due to insufficient stock. unfulfilled_items = [] for order in orders: item = order[\\"item\\"] quantity = order[\\"quantity\\"] if item not in inventory: unfulfilled_items.append(item) elif inventory[item] < quantity: unfulfilled_items.append(item) else: inventory[item] -= quantity return unfulfilled_items"},{"question":"# Scenario You are building a system to manage a library\'s book inventory. Each book in the inventory is identified by an ISBN, along with its title, author, and the number of copies available. To efficiently manage the inventory, you need to write functions to add new books, update the number of copies for existing books, and look up books by their ISBN. # Task Write three functions: 1. **add_book**: - **Input**: * `inventory` (dict): the current inventory, where keys are ISBNs (strings) and values are dictionaries containing `title` (string), `author` (string), and `copies` (int). * `isbn` (string): the ISBN of the new book. * `title` (string): the title of the new book. * `author` (string): the author of the new book. * `copies` (int): the number of copies of the new book. - **Output**: * Updates the inventory with the new book if the ISBN does not already exist. * Returns `True` if the book was successfully added, or `False` if the ISBN already exists. - **Constraints**: * `copies` must be a non-negative integer. - **Example**: ```python inventory = {} result = add_book(inventory, \\"978-3-16-148410-0\\", \\"Python Programming\\", \\"John Doe\\", 5) # Result: True # Inventory: {\\"978-3-16-148410-0\\": {\\"title\\": \\"Python Programming\\", \\"author\\": \\"John Doe\\", \\"copies\\": 5}} ``` 2. **update_copies**: - **Input**: * `inventory` (dict): the current inventory. * `isbn` (string): the ISBN of the book to update. * `copies` (int): the new number of copies. This value will replace the existing number of copies. - **Output**: * Updates the number of copies for the specified book. * Returns `True` if the update was successful, or `False` if the ISBN does not exist. - **Constraints**: * `copies` must be a non-negative integer. - **Example**: ```python inventory = {\\"978-3-16-148410-0\\": {\\"title\\": \\"Python Programming\\", \\"author\\": \\"John Doe\\", \\"copies\\": 5}} result = update_copies(inventory, \\"978-3-16-148410-0\\", 10) # Result: True # Inventory: {\\"978-3-16-148410-0\\": {\\"title\\": \\"Python Programming\\", \\"author\\": \\"John Doe\\", \\"copies\\": 10}} ``` 3. **lookup_book**: - **Input**: * `inventory` (dict): the current inventory. * `isbn` (string): the ISBN of the book to look up. - **Output**: * Returns a dictionary containing `title`, `author`, and `copies` if the ISBN exists. * Returns `None` if the ISBN does not exist. - **Constraints**: * `isbn` must be a string. - **Example**: ```python inventory = {\\"978-3-16-148410-0\\": {\\"title\\": \\"Python Programming\\", \\"author\\": \\"John Doe\\", \\"copies\\": 5}} result = lookup_book(inventory, \\"978-3-16-148410-0\\") # Result: {\\"title\\": \\"Python Programming\\", \\"author\\": \\"John Doe\\", \\"copies\\": 5} ``` # Performance Requirements - Your implementations should work efficiently with a large number of books in the inventory. # Additional Notes - Ensure to handle invalid inputs by raising a `ValueError` with an appropriate error message. - Validate your solutions using unit tests to check for edge cases and typical scenarios.","solution":"def add_book(inventory, isbn, title, author, copies): Adds a new book to the inventory. Parameters: - inventory (dict): The current inventory. - isbn (string): The ISBN of the new book. - title (string): The title of the new book. - author (string): The author of the new book. - copies (int): The number of copies of the new book. Returns: - True if the book was successfully added. - False if the ISBN already exists in the inventory or copies is a negative integer if copies < 0: raise ValueError(\'Number of copies must be a non-negative integer.\') if isbn in inventory: return False inventory[isbn] = { \'title\': title, \'author\': author, \'copies\': copies } return True def update_copies(inventory, isbn, copies): Updates the number of copies for a book in the inventory. Parameters: - inventory (dict): The current inventory. - isbn (string): The ISBN of the book to update. - copies (int): The new number of copies. Returns: - True if the update was successful. - False if the ISBN does not exist or copies is a negative integer if copies < 0: raise ValueError(\'Number of copies must be a non-negative integer.\') if isbn not in inventory: return False inventory[isbn][\'copies\'] = copies return True def lookup_book(inventory, isbn): Looks up a book by its ISBN. Parameters: - inventory (dict): The current inventory. - isbn (string): The ISBN of the book to look up. Returns: - A dictionary containing title, author, and copies if the ISBN exists. - None if the ISBN does not exist. if isbn not in inventory: return None return inventory[isbn]"},{"question":"# Coding Assessment Question Background In many programming tasks, managing data structures and understanding their functions are key. One such data structure is the min-heap, which allows for efficient retrieval of the smallest element. This exercise involves simulating the behavior of a dynamic min-heap. Problem Statement You are required to implement a function that processes a series of commands to manipulate a min-heap and returns the results of specific queries. The commands are issued in a list of strings, where each string is one of the following forms: 1. `\'insert X\'` - Insert the integer `X` into the heap. 2. `\'removeMin\'` - Remove the smallest integer from the heap. If the heap is empty, do nothing. 3. `\'getMin\'` - Query the smallest integer in the heap. If the heap is empty, return `-1`. Implement the function `process_commands(commands: List[str]) -> List[int]` to perform these operations and collect the results of `\'getMin\'` queries in the order they are received. Input * A list of strings `commands` where each string represents a command to be executed on the min-heap. The length of the list will not exceed `10^4`. Output * A list of integers representing the results of the `\'getMin\'` commands. If the heap is empty during a `\'getMin\'` command, `-1` should be included in the results list for that command. Example ```python >>> process_commands([\\"insert 5\\", \\"insert 3\\", \\"getMin\\", \\"removeMin\\", \\"getMin\\", \\"removeMin\\", \\"getMin\\"]) [3, 5, -1] ``` Constraints * Your solution should handle up to `10^4` commands efficiently. * Usage of built-in heap library is encouraged for managing the min-heap. Notes - Use a min-heap data structure to maintain the elements in the heap. - Be mindful of the edge cases where the heap could be empty when attempting to remove or get the minimum element.","solution":"import heapq from typing import List def process_commands(commands: List[str]) -> List[int]: min_heap = [] result = [] for command in commands: if command.startswith(\'insert\'): _, num = command.split() heapq.heappush(min_heap, int(num)) elif command == \'removeMin\': if min_heap: heapq.heappop(min_heap) elif command == \'getMin\': if min_heap: result.append(min_heap[0]) else: result.append(-1) return result"},{"question":"# Context You are developing an application that manages employees within a company. Each employee has an identifier and may have multiple direct reports (subordinates). Your task is to implement functionality that helps determine the depth of the hierarchy in different parts of the company. # Task Implement a function `find_hierarchy_depth(employee_tree: dict, employee_id) -> int` that computes the maximum depth of the hierarchy starting from a given employee. The depth of a hierarchy is defined as the longest path from the starting employee to a leaf in the tree. # Input and Output * **Input**: * `employee_tree` (dict): A dictionary representing the company\'s hierarchy where keys are employee identifiers, and their values are lists of direct report IDs. * `employee_id`: The identifier of the starting employee. * **Output**: * An integer representing the maximum depth of the hierarchy starting from the given employee. # Constraints * All employee identifiers in the hierarchy will be unique. * The hierarchy tree will contain at least one employee. * There are no cycles in the hierarchy. # Example ```python example_tree = { 1: [2, 3], 2: [4], 3: [5, 6], 4: [], 5: [], 6: [7], 7: [] } print(find_hierarchy_depth(example_tree, 1)) # Expected Output: 4 # Explanation: The longest path from employee 1 is 1 -> 3 -> 6 -> 7, which has a depth of 4. print(find_hierarchy_depth(example_tree, 3)) # Expected Output: 3 # Explanation: The longest path from employee 3 is 3 -> 6 -> 7, which has a depth of 3. ``` # Performance Requirements The function should have a time complexity of O(N), where N is the number of employees in the hierarchy. It should be capable of efficiently handling up to 10,000 employees. # Note You do not need to handle input validation. Assume all input provided will be valid according to the constraints.","solution":"def find_hierarchy_depth(employee_tree: dict, employee_id) -> int: Computes the maximum depth of the hierarchy starting from the given employee. Args: employee_tree (dict): A dictionary representing the company\'s hierarchy. employee_id: The identifier of the starting employee. Returns: int: The maximum depth of the hierarchy. def dfs(employee): if not employee_tree[employee]: # Base case: no direct reports return 1 max_depth = 0 for report in employee_tree[employee]: max_depth = max(max_depth, dfs(report)) return max_depth + 1 return dfs(employee_id)"},{"question":"# Substring Generation and Sorting Objective Write a function that generates all possible non-empty substrings of a given string, sorts them in lexicographical order, and then returns them as a list. Your solution should be efficient in terms of both time and space complexity. Input * A string `s` consisting of lowercase English letters where `1 <= len(s) <= 10^3`. Output * A list of strings containing all possible non-empty substrings of `s`, sorted in lexicographical order. Constraints * The input string length will not exceed 1000 characters. * The function should handle strings efficiently even if the number of substrings is large. Example ```python assert generate_sorted_substrings(\\"abc\\") == [\'a\', \'ab\', \'abc\', \'b\', \'bc\', \'c\'] assert generate_sorted_substrings(\\"aaa\\") == [\'a\', \'a\', \'a\', \'aa\', \'aa\', \'aaa\'] assert generate_sorted_substrings(\\"xyz\\") == [\'x\', \'xy\', \'xyz\', \'y\', \'yz\', \'z\'] ``` Implementation details 1. Generate all possible non-empty substrings of the given string. 2. Sort the substrings in lexicographical order. 3. Return the sorted list of substrings.","solution":"def generate_sorted_substrings(s): Generates all possible non-empty substrings of the string \'s\' and returns them sorted in lexicographical order. Parameters: s (str): The input string consisting of lowercase English letters. Returns: List[str]: A list of non-empty substrings of \'s\' sorted in lexicographical order. substrings = [s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)] return sorted(substrings)"},{"question":"# Fibonacci Sequence Generator with Caching You are tasked with creating a function that efficiently generates a list of the first `n` Fibonacci numbers using caching to improve performance. The function must utilize a caching mechanism (such as `functools.lru_cache` or a dictionary) to store previously computed values and avoid redundant calculations. Function Signature ```python def cached_fibonacci(n: int) -> list[int]: Parameters: - n (int): The number of Fibonacci numbers to generate. Returns: - list[int]: A list containing the first `n` Fibonacci numbers. Constraints: - The implementation must use caching to minimize redundant computations. - Ensure the function handles large input values efficiently. ``` Input - A single integer `n` representing the number of Fibonacci numbers to generate. Output - A list of the first `n` Fibonacci numbers. Example ```python >>> cached_fibonacci(5) [0, 1, 1, 2, 3] >>> cached_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> cached_fibonacci(1) [0] >>> cached_fibonacci(0) [] ``` Constraints - `0 <= n <= 10^5` - You need to handle invalid inputs, such as non-integer types and negative integers.","solution":"from functools import lru_cache @lru_cache(maxsize=None) def fibonacci(n): if n < 2: return n return fibonacci(n-1) + fibonacci(n-2) def cached_fibonacci(n: int) -> list[int]: if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = [] for i in range(n): result.append(fibonacci(i)) return result"},{"question":"# Problem Statement **Balanced Brackets Alien Language** An alien language uses the following six types of brackets: `@`, `#`, ``, `%`, `&`, `*`. A string of these brackets is considered balanced if: 1. Every opening bracket has a corresponding closing bracket. 2. Brackets of the same type are properly nested. The bracket pairs are defined as: - `@` and `@` - `#` and `#` - `` and `` - `%` and `%` - `&` and `&` - `*` and `*` Write a function `is_balanced(brackets: str) -> bool` that checks whether a given string of brackets is balanced or not. **Constraints**: - The length of the string `brackets` does not exceed 10^5. Input - `brackets` (str): A string consisting of the characters `@`, `#`, ``, `%`, `&`, and `*`. Output - `bool`: Returns `True` if the string is balanced, `False` otherwise. Example ```python def is_balanced(brackets: str) -> bool: # Implementation here… print(is_balanced(\\"@@\\")) # output should be True print(is_balanced(\\"@%@\\")) # output should be False print(is_balanced(\\"@@%%&&**\\")) # output should be True ``` Notes - You may use a stack to keep track of the opening brackets and ensure they are properly closed. - The function should handle large input efficiently, and performance will be considered during evaluation. Performance Requirements - The function should run efficiently for strings up to 10^5 characters within reasonable time limits.","solution":"def is_balanced(brackets: str) -> bool: Check if the given string of brackets is balanced. stack = [] for bracket in brackets: if stack and stack[-1] == bracket: stack.pop() else: stack.append(bracket) return len(stack) == 0"},{"question":"# Problem Statement Write a function that takes a list of integers and returns the list sorted in ascending order using the merge sort algorithm. Your implementation should be purely functional, meaning you should not modify the input list. # Function Signature ```python def merge_sort(array: list[int]) -> list[int]: ``` # Input * **array** (*List[int]*): The list of integers ( -10^5 <= element <= 10^5 ). # Output * **list[int]**: A new list with elements sorted in ascending order. # Constraints * The length of the array will not exceed 10^5. * Your implementation should use the merge sort algorithm. * The input list can contain duplicate elements. * Handle edge cases such as an empty list or a list with one element. # Example ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([5, 3, 8, 6, 2, 7, 4, 1]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sort([-5, -1, -8, -7, 0, 0, 5]) [-8, -7, -5, -1, 0, 0, 5] ``` # Requirements * **Performance**: Your solution should run in O(n log n) time. * **Immutable input**: The input list should not be modified during sorting. * **Recursive function**: Your implementation should use recursion to divide and conquer. * Account for all possible edge cases, such as an already sorted list, reverse sorted list, and list containing all identical elements. --- This problem tests the understanding of the merge sort algorithm, recursion, and immutability in terms of not modifying the original input, ensuring that it matches the complexity and style of the provided question. The question not only requires a correct implementation but also emphasizes performance constraints with time complexity and proper handling of edge cases.","solution":"def merge_sort(array): Returns a new list which is the sorted version of the input list using merge sort algorithm. if len(array) <= 1: return array def merge(left, right): sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list mid = len(array) // 2 left_half = merge_sort(array[:mid]) right_half = merge_sort(array[mid:]) return merge(left_half, right_half)"},{"question":"# Coding Assessment Question: Most Frequent Element in a Stream Scenario: You are tasked with creating a system that processes a continuous stream of integers and keeps track of the most frequently occurring element in the stream efficiently. Problem: Write a class called `StreamProcessor` that implements the following methods: 1. `add(item: int)`: Adds an item to the stream. 2. `most_frequent() -> int | None`: Returns the most frequently occurring element in the stream. If there is a tie, return any one of the most frequent elements. Returns `None` if the stream is empty. Input and Output Formats: * **add(item: int)**: Adds `item` to the stream. Does not return anything. * **most_frequent() -> int | None**: Returns the most frequently occurring element in the stream. If the stream is empty, it should return `None`. Constraints: * The method `add` should have an average time complexity of O(1). * The method `most_frequent` should have an average time complexity of O(1). Example Usage: ```python processor = StreamProcessor() processor.add(1) processor.add(2) processor.add(1) assert processor.most_frequent() == 1 # 1 appears twice processor.add(2) processor.add(2) assert processor.most_frequent() == 2 # 2 appears three times, which is the most frequent processor.add(3) assert processor.most_frequent() == 2 # 2 is still the most frequent processor.add(3) processor.add(3) assert processor.most_frequent() in [2, 3] # both 2 and 3 appear three times ``` Implementation: Implement the class with appropriate methods to satisfy the above requirements.","solution":"from collections import defaultdict class StreamProcessor: def __init__(self): self.counts = defaultdict(int) self.max_freq = 0 self.most_freq_element = None def add(self, item: int): self.counts[item] += 1 if self.counts[item] > self.max_freq: self.max_freq = self.counts[item] self.most_freq_element = item def most_frequent(self) -> int | None: return self.most_freq_element if self.max_freq > 0 else None"},{"question":"# Problem Statement You have been enlisted to create a feature for a text editor that suggests word completions based on the current prefix typed by a user. Your task is to write a function that, given an input prefix and a list of possible completions, returns all completions that start with the given prefix. # Requirements Write a function `suggest_completions(prefix: str, completions: List[str]) -> List[str]` that takes a prefix and a list of possible completions and returns a list of all completions that start with the given prefix. The completions should be returned in lexicographical order. # Input Format - `prefix`: A single string of length ( p ) (1 ≤ ( p ) ≤ 100). - `completions`: A list of strings, each of length ( c_i ) (1 ≤ ( c_i ) ≤ 1000), with total length of all strings combined ( m ) (1 ≤ ( m ) ≤ 100,000). # Output Format - A list of strings that begin with the given prefix. # Constraints - The alphabet is assumed to be UTF-8 encoded. - The function should be optimized to handle large inputs efficiently. # Example ```python assert suggest_completions(\\"he\\", [\\"hello\\", \\"hero\\", \\"hey\\", \\"hi\\", \\"help\\"]) == [\\"hello\\", \\"help\\", \\"hero\\", \\"hey\\"] assert suggest_completions(\\"cat\\", [\\"caterpillar\\", \\"cat\\", \\"catalogue\\", \\"dog\\", \\"catch\\"]) == [\\"cat\\", \\"catch\\", \\"caterpillar\\", \\"catalogue\\"] ``` # Notes - Ensure to account for cases where no completions match the prefix. - Consider edge cases such as an empty list of completions or an empty prefix. - Aim to balance efficiency and readability in your solution.","solution":"from typing import List def suggest_completions(prefix: str, completions: List[str]) -> List[str]: Returns a list of all completions that start with the given prefix, sorted in lexicographical order. # Filter the completions that start with the given prefix matched_completions = [word for word in completions if word.startswith(prefix)] # Sort the matched completions in lexicographical order matched_completions.sort() return matched_completions"},{"question":"# Multi-threaded Matrix Multiplication Scenario: You are developing a high-performance application that requires efficient matrix multiplication. To achieve this, you will implement a multi-threaded matrix multiplication algorithm. The system should handle matrices of any given size and leverage concurrency to improve performance on large matrices. Requirements: 1. **Matrix Class**: Implement a `Matrix` class that supports basic matrix operations including initialization, element access, and string representation. 2. **Multi-threaded Multiplication Function**: Implement a function to multiply two matrices using multiple threads for parallel computation. 3. **Error Handling**: Ensure proper handling and messages for incompatible matrix dimensions. Input & Output: * **Function Signatures**: ```python class Matrix: def __init__(self, rows: int, cols: int, data: List[List[int]]): # Initialize the Matrix with the given dimensions and data pass def __getitem__(self, idx: int) -> List[int]: # Get the row at the specified index pass def __str__(self) -> str: # Return a string representation of the matrix pass def threaded_matrix_multiplication(mat1: Matrix, mat2: Matrix) -> Matrix: # Perform multi-threaded matrix multiplication and return the resulting matrix pass ``` * **Constraints**: * The number of columns in the first matrix must be equal to the number of rows in the second matrix. * Matrices can have arbitrary dimensions as long as they are compatible for multiplication. * **Error Messages**: * Raise `ValueError` with message \\"Incompatible matrix dimensions\\" for matrices that cannot be multiplied. Example: ```python # Example usage: mat1_data = [ [1, 2, 3], [4, 5, 6] ] mat2_data = [ [7, 8], [9, 10], [11, 12] ] mat1 = Matrix(rows=2, cols=3, data=mat1_data) mat2 = Matrix(rows=3, cols=2, data=mat2_data) result = threaded_matrix_multiplication(mat1, mat2) print(result) ``` The printed result should be: ``` 58 64 139 154 ``` Implementation Details: Provide your implementation for the `Matrix` class and `threaded_matrix_multiplication` function following the specifications and requirements provided. Ensure to use threading constructs to achieve concurrency in the multiplication process.","solution":"from threading import Thread from typing import List class Matrix: def __init__(self, rows: int, cols: int, data: List[List[int]]): if len(data) != rows or any(len(row) != cols for row in data): raise ValueError(\\"Data dimensions do not match specified row and column counts\\") self.rows = rows self.cols = cols self.data = data def __getitem__(self, idx: int) -> List[int]: return self.data[idx] def __str__(self) -> str: return \'n\'.join(\' \'.join(map(str, row)) for row in self.data) def threaded_matrix_multiplication(mat1: Matrix, mat2: Matrix) -> Matrix: if mat1.cols != mat2.rows: raise ValueError(\\"Incompatible matrix dimensions\\") result_data = [[0 for _ in range(mat2.cols)] for _ in range(mat1.rows)] def compute_element(i, j): result_data[i][j] = sum(mat1[i][k] * mat2[k][j] for k in range(mat1.cols)) threads = [] for i in range(mat1.rows): for j in range(mat2.cols): thread = Thread(target=compute_element, args=(i, j)) threads.append(thread) thread.start() for thread in threads: thread.join() return Matrix(rows=mat1.rows, cols=mat2.cols, data=result_data)"},{"question":"QuickSort Algorithm Implementation with Median-of-Three Pivot Selection Implement the QuickSort algorithm using the median-of-three pivot selection method. This variation of QuickSort chooses the pivot as the median of the first, middle, and last elements of the array to improve performance on certain types of datasets. Your task is to write a function that sorts an array of integers using this version of QuickSort and returns the sorted array. Input Format: - A list of integers (the array to be sorted). Output Format: - A list of integers representing the sorted array. Constraints: - The input array can contain up to (10^5) elements. - The values within the array are integers and can be positive, negative, or zero. - Implement the algorithm in place to reduce memory usage. - Aim for an average-case time complexity of (O(n log n)). Example: ```python # Input arr = [34, 7, 23, 32, 5, 62] # Calling the function sorted_arr = quicksort_median_of_three(arr) # Output # sorted_arr should now be [5, 7, 23, 32, 34, 62] ``` **Function Signature:** ```python def quicksort_median_of_three(arr: list) -> list: pass ``` # Median-of-Three Pivot Selection Explanation 1. To find the median of three: - Compare the first, middle, and last elements of the array. - Select the median of these three elements. 2. Use this median as the pivot to partition the array. # QuickSort Function Explanation 1. Partition the array around the median-of-three pivot such that elements less than the pivot go to the left, and elements greater than the pivot go to the right. 2. Recursively apply the same process to the left and right subarrays until the base case (subarray with one or zero elements) is reached. Implementing this should make the QuickSort function more robust to worst-case scenarios, such as already sorted arrays.","solution":"def quicksort_median_of_three(arr): def median_of_three(low, high): mid = (low + high) // 2 a = arr[low] b = arr[mid] c = arr[high] if a > b: if a < c: return low elif b > c: return mid else: return high else: if a > c: return low elif b < c: return mid else: return high def partition(low, high): pivot_index = median_of_three(low, high) arr[high], arr[pivot_index] = arr[pivot_index], arr[high] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort_helper(low, high): if low < high: pi = partition(low, high) quicksort_helper(low, pi - 1) quicksort_helper(pi + 1, high) quicksort_helper(0, len(arr) - 1) return arr"},{"question":"**Context**: You are developing a program to manage customer transactions in a retail system. Each transaction has an identifier, a timestamp, and a monetary value. Your task is to compute the average daily transaction amount for the given dataset. # Task: Implement a function `average_daily_transactions(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]` that processes the transactions and returns a dictionary with the average transaction amount per day. # Detailed Steps: 1. Parse the transactions list. 2. Group transactions by date. 3. For each date, calculate the average transaction amount. 4. Return a dictionary where the keys are the dates (in \\"YYYY-MM-DD\\" format) and the values are the average transaction amounts for those dates. # Input: * `transactions`: A list of tuples, each containing a transaction identifier (string), a timestamp (string in ISO 8601 format: \\"YYYY-MM-DDTHH:MM:SS\\"), and a transaction amount (float). # Output: * Returns a dictionary mapping each unique date to the average transaction amount for that date. # Constraints: * Ensure the transactions are valid and properly formatted. * The list can contain transactions spanning multiple years. * There can be multiple transactions on the same date. # Example: ```python from typing import List, Tuple, Dict def average_daily_transactions(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]: # Your implementation here # Usage sample_transactions = [ (\\"txn1\\", \\"2023-10-01T14:32:00\\", 100.0), (\\"txn2\\", \\"2023-10-01T16:25:00\\", 50.0), (\\"txn3\\", \\"2023-10-02T10:00:00\\", 200.0), (\\"txn4\\", \\"2023-10-02T11:30:00\\", 80.0) ] result = average_daily_transactions(sample_transactions) print(result) # Expected output: {\'2023-10-01\': 75.0, \'2023-10-02\': 140.0} ``` # Performance Requirements: * Your solution should handle input lists with up to 1 million transactions efficiently, within acceptable runtime limits.","solution":"from typing import List, Tuple, Dict from collections import defaultdict from datetime import datetime def average_daily_transactions(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]: daily_totals = defaultdict(list) for txn_id, timestamp, amount in transactions: date = timestamp.split(\\"T\\")[0] daily_totals[date].append(amount) daily_averages = {} for date, amounts in daily_totals.items(): daily_averages[date] = sum(amounts) / len(amounts) return daily_averages"},{"question":"# LED Controller Optimization You are provided with a basic implementation of a simple LED controller which can switch an LED on or off based on an input condition. The current implementation takes a boolean input to turn the LED on (`True`) or off (`False`). **Problem Statement:** Extend this concept to create an 8-LED controller. This extended controller will have eight boolean input values that determine the state (on or off) of each individual LED. Additionally, implement a function to return the total number of LEDs that are currently on. **Function Signature:** ```python def led_controller(led0: bool, led1: bool, led2: bool, led3: bool, led4: bool, led5: bool, led6: bool, led7: bool) -> int: Implement an 8-LED controller. :param led0: State of LED 0 (True for on, False for off). :param led1: State of LED 1 (True for on, False for off). :param led2: State of LED 2 (True for on, False for off). :param led3: State of LED 3 (True for on, False for off). :param led4: State of LED 4 (True for on, False for off). :param led5: State of LED 5 (True for on, False for off). :param led6: State of LED 6 (True for on, False for off). :param led7: State of LED 7 (True for on, False for off). :return: An integer representing the number of LEDs that are currently on. ``` **Requirements:** 1. The inputs (`led0`, `led1`, `led2`, `led3`, `led4`, `led5`, `led6`, and `led7`) must be boolean values (`True` or `False`). Otherwise, raise a `ValueError`. 2. Count and return the number of LEDs that are in the `on` state (`True`). **Examples:** ```python >>> led_controller(True, False, True, False, True, False, True, False) 4 >>> led_controller(True, True, True, True, True, True, True, True) 8 >>> led_controller(False, False, False, False, False, False, False, False) 0 >>> led_controller(True, False, \\"on\\", False, True, False, True, False) Traceback (most recent call last): ... ValueError: All inputs must be boolean values (True or False) >>> led_controller(True, 0, True, False, True, False, True, 1) Traceback (most recent call last): ... ValueError: All inputs must be boolean values (True or False) ``` Ensure that your implementation handles invalid inputs gracefully and raises an appropriate error if the inputs are not boolean values (`True` or `False`).","solution":"def led_controller(led0: bool, led1: bool, led2: bool, led3: bool, led4: bool, led5: bool, led6: bool, led7: bool) -> int: Implement an 8-LED controller. :param led0: State of LED 0 (True for on, False for off). :param led1: State of LED 1 (True for on, False for off). :param led2: State of LED 2 (True for on, False for off). :param led3: State of LED 3 (True for on, False for off). :param led4: State of LED 4 (True for on, False for off). :param led5: State of LED 5 (True for on, False for off). :param led6: State of LED 6 (True for on, False for off). :param led7: State of LED 7 (True for on, False for off). :return: An integer representing the number of LEDs that are currently on. leds = [led0, led1, led2, led3, led4, led5, led6, led7] if not all(isinstance(led, bool) for led in leds): raise ValueError(\\"All inputs must be boolean values (True or False)\\") return leds.count(True)"},{"question":"# Rotated Prime Identification and Sum Calculation Context A rotated number is formed by rotating the digits of a number in any order. A number is considered a rotated prime if all of its rotations are prime numbers. Task 1. Implement a function, `is_rotated_prime(num: int) -> bool` that checks if the input number is a rotated prime. 2. Implement a function, `sum_of_rotated_primes(up_to: int) -> int` that calculates the sum of all rotated primes up to a given limit. Specifications 1. You have two functions to implement: ```python def is_rotated_prime(num: int) -> bool: Determine if the provided number is a rotated prime. Args: num: A positive integer Returns: bool: True if the number is a rotated prime, False otherwise Raises: ValueError: If input number is invalid def sum_of_rotated_primes(up_to: int) -> int: Return the sum of all rotated primes up to the given limit. Args: up_to: A positive integer Returns: int: The sum of all rotated primes up to the given limit Raises: ValueError: If input limit is invalid ``` Input and Output Formats * **Input**: * `num` - A positive integer for `is_rotated_prime`. * `up_to` - A positive integer representing the upper limit for `sum_of_rotated_primes`. * Both parameters must be positive integers. * **Output**: * For `is_rotated_prime`: Return `True` if the number is a rotated prime, otherwise `False`. * For `sum_of_rotated_primes`: Return the sum of all rotated primes up to the specified limit as an integer. Constraints * Numbers and limits should be positive integers. * Consider rotations obtained by rotating all digits of the number. Examples ```python assert is_rotated_prime(197) == True # Rotations: 197, 971, 719 assert is_rotated_prime(23) == False # Rotations: 23, 32 (32 is not prime) assert sum_of_rotated_primes(100) == 446 # Includes: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, 97 ```","solution":"def is_prime(n: int) -> bool: if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def is_rotated_prime(num: int) -> bool: if num <= 0: raise ValueError(\\"Input number must be a positive integer.\\") if not is_prime(num): return False str_num = str(num) rotations = [str_num[i:] + str_num[:i] for i in range(len(str_num))] return all(is_prime(int(rotation)) for rotation in rotations) def sum_of_rotated_primes(up_to: int) -> int: if up_to <= 0: raise ValueError(\\"Input limit must be a positive integer.\\") total_sum = 0 for num in range(2, up_to + 1): if is_rotated_prime(num): total_sum += num return total_sum"},{"question":"**Question**: Matrix Multiplication You are required to implement a function that multiplies two 2D matrices and returns the resultant matrix. Matrix multiplication here follows the standard definition where if `A` and `B` are two matrices of sizes respectively, then the number of columns in `A` must be equal to the number of rows in `B`. # Problem Statement Given two matrices `A` and `B`, you need to implement a function that returns their product `C`. # Input Format - Two 2D matrices `A` (with dimensions `m x n`) and `B` (with dimensions `n x p`) represented as lists of lists. Each inner list represents a row in the matrix. # Output Format - A 2D matrix `C` (with dimensions `m x p`) resulting from the multiplication of `A` and `B`, represented as a list of lists. # Constraints - 1 ≤ `m`, `n`, `p` ≤ 100 - Each element in matrices `A` and `B` will be in the range of -1000 to 1000. # Example ```python def matrix_multiply(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: # Get the sizes of matrices m, n = len(A), len(A[0]) n_b, p = len(B), len(B[0]) # Ensure multiplication is possible if n != n_b: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Initialize the result matrix with zeros C = [[0 for _ in range(p)] for _ in range(m)] # Perform the matrix multiplication for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C # Example Usage: A = [ [1, 2], [3, 4] ] B = [ [2, 0], [1, 2] ] print(matrix_multiply(A, B)) # Output: [[4, 4], [10, 8]] A = [ [1, 0, 2], [-1, 3, 1] ] B = [ [3, 1], [2, 1], [1, 0] ] print(matrix_multiply(A, B)) # Output: [[5, 1], [4, 2]] ``` # Notes - Validate the inputs properly to ensure the inner lists (rows) contain the correct number of elements. - Implement meaningful error handling to catch cases where the dimensions are incompatible for multiplication. - Consider optimizing to avoid unnecessary computational overhead, especially for large matrices.","solution":"def matrix_multiply(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: Multiplies two 2D matrices A and B and returns the resultant matrix. Parameters: A (list of list of int): Matrix A with dimensions m x n B (list of list of int): Matrix B with dimensions n x p Returns: list of list of int: Resultant matrix C with dimensions m x p m, n = len(A), len(A[0]) n_b, p = len(B), len(B[0]) if n != n_b: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Initialize the result matrix with zeros C = [[0 for _ in range(p)] for _ in range(m)] # Perform the matrix multiplication for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"**Context:** You are tasked with developing a contact book application where users can store, search, and manage their contacts efficiently. One of the key functionalities involves searching for contacts using various criteria. This can include searching by name, phone number, or email address. **Objective:** Write a program that allows users to search for contacts based on specific query terms. Your solution should return matching contacts that contain the query term in either the name, phone number, or email fields. **Task:** Create a function `search_contacts(contacts: list[dict], query: str) -> list[dict]` that takes a list of contacts and a query string, returning a list of contacts that match the query in any of the three fields: name, phone, or email. # Expected Input and Output: * **Input**: - `contacts`: A list of dictionaries where each dictionary represents a contact with `name`, `phone`, and `email` fields. - Each field in the dictionary is a string. - `query`: A string representing the search term. * **Output**: - A list of dictionaries representing the contacts that match the query string in any of the three fields. # Constraints: - The matching should be case-insensitive. - If a contact does not match the query in any field, it should be excluded from the output. - The length of the `contacts` list can be up to 1,000 contacts. **Example:** ```python contacts = [ {\\"name\\": \\"Alice Johnson\\", \\"phone\\": \\"555-1234\\", \\"email\\": \\"alice@example.com\\"}, {\\"name\\": \\"Bob Smith\\", \\"phone\\": \\"555-5678\\", \\"email\\": \\"bob@example.com\\"}, {\\"name\\": \\"Carol White\\", \\"phone\\": \\"555-8765\\", \\"email\\": \\"carol.w@example.com\\"}, {\\"name\\": \\"Dave Brown\\", \\"phone\\": \\"555-4321\\", \\"email\\": \\"dave_b@example.com\\"} ] query = \\"Alice\\" assert search_contacts(contacts, query) == [ {\\"name\\": \\"Alice Johnson\\", \\"phone\\": \\"555-1234\\", \\"email\\": \\"alice@example.com\\"} ] query = \\"555\\" assert search_contacts(contacts, query) == [ {\\"name\\": \\"Alice Johnson\\", \\"phone\\": \\"555-1234\\", \\"email\\": \\"alice@example.com\\"}, {\\"name\\": \\"Bob Smith\\", \\"phone\\": \\"555-5678\\", \\"email\\": \\"bob@example.com\\"}, {\\"name\\": \\"Carol White\\", \\"phone\\": \\"555-8765\\", \\"email\\": \\"carol.w@example.com\\"}, {\\"name\\": \\"Dave Brown\\", \\"phone\\": \\"555-4321\\", \\"email\\": \\"dave_b@example.com\\"} ] ``` Note: Ensure your implementation is efficient and performs well with the given constraints. Use appropriate data structures and algorithms to achieve this.","solution":"def search_contacts(contacts, query): Search for contacts that match the query in any of the `name`, `phone`, or `email` fields. Args: contacts: List[Dict[str, str]] - List of contacts, where each contact is a dictionary with `name`, `phone`, and `email` fields. query: str - The search term to match against the contacts. Returns: List[Dict[str, str]] - List of contacts that match the query in any of the fields. query_lower = query.lower() matching_contacts = [] for contact in contacts: if (query_lower in contact[\'name\'].lower() or query_lower in contact[\'phone\'].lower() or query_lower in contact[\'email\'].lower()): matching_contacts.append(contact) return matching_contacts"},{"question":"# Array Slicing and Appending You are required to implement a function that takes an array and splits it into two separate arrays based on a given index. After splitting, the function appends all elements of the second array to the end of the first array. # Requirements 1. Provide a method `split_and_append(original_array: list[int], index: int) -> list[int]` that splits the input array at the given index and returns the modified array after appending the elements as described. 2. `original_array`: A list of integers to be split and combined. 3. `index`: An integer that specifies where to split the array. Elements at and after this index will be appended to the elements before this index. # Constraints 1. The length of `original_array` will be at least 1. 2. The `index` will be within the valid range [0, len(original_array) - 1]. # Example ```python original_array = [1, 2, 3, 4, 5] index = 2 modified_array = split_and_append(original_array, index) print(modified_array) # Example Output: [1, 2, 4, 5, 3] ```","solution":"def split_and_append(original_array: list[int], index: int) -> list[int]: Splits the input array at the given index and appends the elements at and after the index to the elements before this index. :param original_array: List of integers to be split and combined. :param index: Index at which to split the array. :return: Modified list after appending the elements. if index < 0 or index >= len(original_array): raise ValueError(\\"Index out of the valid range\\") first_part = original_array[:index] second_part = original_array[index:] return first_part + second_part[1:] + [second_part[0]]"},{"question":"# Question: Unique Element Finder **Objective**: Write a program to identify the first unique (non-repeating) element in a list of integers. **Scenario**: You are developing software for a customer support system that processes a queue of support requests. Each request has a unique identifier represented as an integer. For organizational purposes, you often need to identify the first unique request that has not been handled by the support team yet. Function Details: Implement the function `first_unique_element(arr: List[int]) -> Union[int, None]`: 1. **Input**: - `arr` (List[int]): A list of integers representing the support request identifiers. The list may include duplicate elements. - Constraints: `0 <= len(arr) <= 10**5`, `-10^6 <= arr[i] <= 10^6` for any element `arr[i]`. 2. **Output**: - Returns the first unique integer element from the list. If there is no unique element, return `None`. 3. **Error Handling**: - The function is not required to handle input validation errors, assume input format is always valid as described. 4. **Performance Requirements**: - The solution should efficiently handle the input range and avoid long execution times. Example Usage: ```python >>> first_unique_element([1, 2, 2, 3, 1, 4]) 3 >>> first_unique_element([7, 8, 8, 7, 9]) 9 >>> first_unique_element([5, 5, 5, 5]) None >>> first_unique_element([]) None ``` # Requirements - Write clean and well-documented code. - Optimize the solution to run efficiently for large input sizes. **Hints**: - Consider using a dictionary or hash map to track the frequencies of elements in the list. - Be mindful of the order in which elements appear to ensure that the first unique element is correctly identified.","solution":"from typing import List, Union def first_unique_element(arr: List[int]) -> Union[int, None]: Returns the first unique (non-repeating) element in a list of integers. Parameters: arr (List[int]): A list of integers representing support request identifiers. Returns: Union[int, None]: The first unique integer element from the list, or None if there are no unique elements. frequency = {} # First pass: count the frequency of each element for element in arr: if element in frequency: frequency[element] += 1 else: frequency[element] = 1 # Second pass: find the first unique element for element in arr: if frequency[element] == 1: return element return None"},{"question":"# Question: Integrate Function Using Simpson\'s Rule You are tasked with implementing Simpson\'s Rule to numerically integrate a given function over a specified interval with a specified number of subdivisions. The function should align with the properties and characteristics described in the analysis. Function Signature ```python def integrate_simpson(func: Callable[[float], float], lower_bound: float, upper_bound: float, subdivisions: int) -> float: pass ``` # Input 1. `func`: A callable function `func(x: float) -> float` representing the function to be integrated. 2. `lower_bound`: A float representing the lower bound of the integration interval. 3. `upper_bound`: A float representing the upper bound of the integration interval. 4. `subdivisions`: An integer representing the number of subdivisions (must be even). # Output * Returns a float representing the estimated integral of the function over the interval. # Constraints - The number of subdivisions must be even. - Ensure that the subdivision number is not zero or negative. - Handle edge cases where the interval length is very small. - Do not assume the function is always well-behaved; implement necessary checks to handle discontinuities gracefully. # Example ```python def example_func(x: float) -> float: return x**3 integral_value = integrate_simpson(example_func, 0.0, 1.0, 10) print(integral_value) # Expected output: 0.25 (or very close) ``` # Explanation In this example: - `example_func` represents the equation (x^3). - Simpson\'s Rule is used to integrate the function over the interval [0.0, 1.0]. - 10 even subdivisions are used to approximate the integral, ideally converging to ( frac{1}{4} ) or 0.25.","solution":"from typing import Callable def integrate_simpson(func: Callable[[float], float], lower_bound: float, upper_bound: float, subdivisions: int) -> float: if subdivisions <= 0 or subdivisions % 2 != 0: raise ValueError(\\"Number of subdivisions must be a positive even integer.\\") h = (upper_bound - lower_bound) / subdivisions sum_odd = 0 sum_even = 0 for i in range(1, subdivisions, 2): sum_odd += func(lower_bound + i * h) for i in range(2, subdivisions, 2): sum_even += func(lower_bound + i * h) result = (h/3) * (func(lower_bound) + 4 * sum_odd + 2 * sum_even + func(upper_bound)) return result"},{"question":"Problem Statement: Find the Smallest Window Given a string ( s ) and a set of characters ( t ), implement a function that finds the smallest substring of ( s ) that contains all the characters in ( t ). If there are multiple substrings of the smallest length, return the first one found. # Function Signature ```python def smallest_window(s: str, t: str) -> str: pass ``` # Input * ( text{s} ) (1 ≤ ( text{len}(s) ) ≤ ( 10^5 )): A non-empty string consisting of lowercase English characters. * ( text{t} ) (1 ≤ ( text{len}(t) ) ≤ ( 10^5 )): A non-empty string consisting of lowercase English characters. # Output * Returns the smallest substring of ( s ) that contains all the characters in ( t ). If no such substring exists, return an empty string. # Example ```python >>> smallest_window(\\"this is a test string\\", \\"tist\\") \\"t stri\\" >>> smallest_window(\\"geeksforgeeks\\", \\"ork\\") \\"ksfor\\" >>> smallest_window(\\"a\\", \\"a\\") \\"a\\" ``` # Constraints * Assume there are no repeated characters in ( t ). * If ( t ) contains a character not present in ( s ), return an empty string. # Notes 1. **Sliding Window Technique**: - Use a sliding window approach to maintain a window of substrings in ( s ) that contain all characters in ( t ). - Keep expanding the window to include required characters and contracting it to discard unnecessary ones. 2. **Hash Map Usage**: - Utilize hash maps to keep track of character counts and determine if all characters in ( t ) are present. # Solution Outline 1. Start with initializing two pointers for the sliding window. 2. Move one pointer to extend the window until all characters in ( t ) are included. 3. Move the other pointer to minimize the window while keeping all characters in ( t ) inside. 4. Keep track of the minimum length window that satisfies the condition. 5. Return the smallest window found, or an empty string if no such window exists.","solution":"def smallest_window(s: str, t: str) -> str: from collections import defaultdict if not s or not t: return \\"\\" required_chars = set(t) char_count_t = defaultdict(int) for char in t: char_count_t[char] += 1 start = 0 min_len = float(\'inf\') min_start = 0 found_chars = defaultdict(int) found_count = 0 for end in range(len(s)): end_char = s[end] if end_char in required_chars: found_chars[end_char] += 1 if found_chars[end_char] <= char_count_t[end_char]: found_count += 1 while found_count == len(t): window_len = end - start + 1 if window_len < min_len: min_len = window_len min_start = start start_char = s[start] if start_char in required_chars: found_chars[start_char] -= 1 if found_chars[start_char] < char_count_t[start_char]: found_count -= 1 start += 1 return \\"\\" if min_len == float(\'inf\') else s[min_start:min_start + min_len]"},{"question":"# Coding Assessment Question Scenario You are working on a text editing application that automatically corrects common typographical errors by identifying and fixing mismatched brackets in mathematical expressions. The system should be able to process expressions containing different types of brackets: round `()`, square `[]`, and curly `{}`. Objective Write a function `fix_brackets` that takes a mathematical expression as input and outputs the corrected expression with properly matched brackets. Your task is to implement logic that identifies and fixes mismatched brackets to produce a valid mathematical expression. Function Signature ```python def fix_brackets(expression: str) -> str: Given a mathematical expression, identify and fix mismatched brackets to ensure all brackets are properly paired and nested. Parameters: expression (str): The mathematical expression possibly containing mismatched brackets. Returns: str: The corrected expression with properly matched brackets. ``` Input 1. `expression` (str): The mathematical expression which may contain mismatched brackets along with digits and basic mathematical operators `+`, `-`, `*`, `/`. Output * A string representing the corrected mathematical expression with matched brackets. Constraints * The length of the expression is not more than 10^3 characters. * The expression consists of digits, mathematical operators, and any of the three types of brackets. * The mathematical operators and digits in the expression may or may not be properly connected. Example ```python fix_brackets(\\"(5 + [3 - {2 * (4 + 1)}]\\") # Output: \\"(5 + [3 - {2 * (4 + 1)}])\\" fix_brackets(\\"{[(3 / 1) + 2]\\") # Output: \\"{[(3 / 1) + 2]}\\" fix_brackets(\\"3 + (2 - [1 * 4))\\") # Output: \\"3 + (2 - [1 * 4])\\" ``` Requirements * You must handle edge cases such as expressions with deeply nested mismatched brackets. * Ensure the function maintains the logical structure of the mathematical expression. * Correct only the mismatched brackets and do not alter the mathematical components of the expression.","solution":"def fix_brackets(expression: str) -> str: Given a mathematical expression, identify and fix mismatched brackets to ensure all brackets are properly paired and nested. Parameters: expression (str): The mathematical expression possibly containing mismatched brackets. Returns: str: The corrected expression with properly matched brackets. stack = [] open_to_close = {\'(\': \')\', \'[\': \']\', \'{\': \'}\'} close_to_open = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} result = [] # First pass, identify and auto-close any currently open brackets for char in expression: if char in open_to_close: stack.append(char) elif char in close_to_open: if stack and stack[-1] == close_to_open[char]: stack.pop() else: # We have a mismatch or an early closing, ignore this closing bracket continue result.append(char) # Close any remaining open brackets at the end of the expression while stack: result.append(open_to_close[stack.pop()]) return \'\'.join(result)"},{"question":"# Question: Implement a Multi-Stage Dependency Resolver **Context**: You are working on a project management tool where tasks are dependent on the completion of other tasks. Your objective is to create a function that categorizes these tasks into different stages such that all the dependencies of a task are resolved in the earlier stages. You are to write a function `schedule_tasks` that takes in a list of dependent tasks and returns the list of stages, each stage containing a set of tasks that can be executed concurrently. **Function Signature**: ```python def schedule_tasks(tasks: list[set[int]]) -> list[set[int]]: pass ``` **Input**: - `tasks`: A list of sets where each set contains the indices of tasks that must be completed before the respective task (the index of the list). **Output**: - Returns a list of sets, where each set contains tasks that can be executed concurrently (i.e., all tasks in the previous sets are their prerequisites). **Constraints**: - The dependency graph is acyclic and valid. - Each task can uniquely refer to other tasks that must come before it. - There are no cyclic dependencies. **Example**: ```python tasks = [ {1, 2}, # Task 0 depends on tasks 1 and 2 {}, # Task 1 has no dependencies {}, # Task 2 has no dependencies {0, 1} # Task 3 depends on tasks 0 and 1 ] schedule_tasks(tasks) # Expected output: [{1, 2}, {0}, {3}] ``` # Guidelines: 1. Ensure that each task is placed in the earliest possible stage where all its dependencies are already completed. 2. Handle the case where tasks with no dependencies can be executed in the initial stage. 3. Consider using topological sorting techniques or level-order traversal methods appropriate for Directed Acyclic Graphs (DAGs). 4. Ensure that the returned stages preserve the correct execution order according to the dependencies provided.","solution":"from collections import defaultdict, deque def schedule_tasks(tasks): This function takes in a list of sets where each set contains the indices of tasks that must be completed before the respective task (the index of the list). It returns a list of sets, where each set contains tasks that can be executed concurrently. # num_tasks is the total number of tasks num_tasks = len(tasks) # Calculate in-degrees of each task in_degree = [0] * num_tasks adjacency_list = defaultdict(list) # Build the graph and update in-degrees for task_index, dependencies in enumerate(tasks): for dep in dependencies: adjacency_list[dep].append(task_index) in_degree[task_index] += 1 # Initialize a queue for tasks with no incoming edges (in-degree 0) zero_in_degree_queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) stages = [] while zero_in_degree_queue: current_stage = set() next_zero_in_degree_queue = deque() while zero_in_degree_queue: current_task = zero_in_degree_queue.popleft() current_stage.add(current_task) # Reduce the in-degree of the neighbors for neighbor in adjacency_list[current_task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: next_zero_in_degree_queue.append(neighbor) stages.append(current_stage) zero_in_degree_queue = next_zero_in_degree_queue return stages"},{"question":"# Question: You are tasked with creating a function that calculates the nth Fibonacci number using Dynamic Programming (DP). The Fibonacci sequence is defined as follows: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n geq 2 ) Your implementation should optimize space complexity by only storing the last two computed values instead of using an entire array to store all Fibonacci numbers up to ( n ). Implement the following function: ```python def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using a space-optimized Dynamic Programming approach. :param n: The index (n) of the Fibonacci sequence to compute. :return: The nth Fibonacci number. :raises ValueError: If the input number is negative. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: n must be a non-negative integer pass ``` # Requirements: 1. **Function Signature**: - The function should take a single integer `n` as input. - The function should return the nth Fibonacci number as an integer. 2. **Input Constraints**: - ( n ) will be a non-negative integer. 3. **Output**: - The function should return the value of the nth Fibonacci number. 4. **Performance**: - Optimize the function to use ( O(1) ) space complexity by storing only the last two Fibonacci numbers. # Important Notes: - Ensure the function raises a `ValueError` if the input number is negative. - The function should be efficient and avoid using excessive memory.","solution":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using a space-optimized Dynamic Programming approach. :param n: The index (n) of the Fibonacci sequence to compute. :return: The nth Fibonacci number. :raises ValueError: If the input number is negative. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: n must be a non-negative integer if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Problem Statement You are required to implement a function that calculates the frequency of elements in a list and returns the element with the highest frequency. If multiple elements have the same highest frequency, return the one that appeared first in the list. # Function Signature ```python def highest_frequency_element(arr: List[int]) -> int: pass ``` # Input and Output The function should take: * `arr`: a list of integers. The function should return an integer which is the element with the highest frequency. # Constraints * The list will contain at least one element and at most 10^6 elements. * The elements in the list will be within the range of -10^6 to 10^6. # Explanation and Example To find the element with the highest frequency: 1. Traverse the array and build a frequency dictionary. 2. Identify the element that has the maximum frequency. 3. In case of a tie (multiple elements having the same frequency), return the one that appeared first. Example ```python highest_frequency_element([1, 2, 2, 3, 1, 1]) ``` The function should return `1` since it appears more frequently than any other element. ```python highest_frequency_element([4, 4, 7, 7, 7, 6, 4, 4]) ``` The function should return `4` as it appears first among the elements with the highest frequency (both 4 and 7 appear 4 times, but 4 is first). # Note Ensure to consider edge cases like: * Single-element arrays * Arrays where each element is unique * Arrays where multiple elements have the same highest frequency but one appears earlier than the others.","solution":"from typing import List def highest_frequency_element(arr: List[int]) -> int: Returns the element with the highest frequency in the list. If there are multiple elements with the same frequency, return the one that appeared first. if not arr: return None freq_dict = {} max_frequency = 0 result = None for num in arr: if num in freq_dict: freq_dict[num] += 1 else: freq_dict[num] = 1 if freq_dict[num] > max_frequency: max_frequency = freq_dict[num] result = num elif freq_dict[num] == max_frequency and result is not None and arr.index(result) > arr.index(num): result = num return result"},{"question":"# Sorting a List of Dictionaries by Multiple Keys You are given a list of dictionaries where each dictionary represents an object with multiple attributes. Your task is to sort this list based on specified keys and their respective sort orders. Objective: Implement a function named `multi_key_sort` that takes in a list of dictionaries and sorts it based on multiple keys and their corresponding sort orders. # Specifications: - **Function Name**: multi_key_sort - **Inputs**: - `data`: a list of dictionaries. - `keys`: a list of strings where each string is a key present in the dictionaries. - `orders`: a list of booleans which indicates the sort order for each key in the `keys` list. True means ascending and False means descending. - **Output**: A list of dictionaries sorted according to the specified keys and orders. # Constraints: - `data` is a list of dictionaries where all dictionaries contain the same set of keys. - `keys` and `orders` lists have the same length. - Each key in `keys` is a valid key in the dictionaries. - The length of `keys` and `orders` does not exceed 5. - Sorting must be stable and maintain the relative order of elements with equal keys. # Example: ```python data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"height\\": 65.0}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"height\\": 70.0}, {\\"name\\": \\"Charlie\\", \\"age\\": 30, \\"height\\": 72.0} ] keys = [\\"age\\", \\"height\\"] orders = [True, False] print(multi_key_sort(data, keys, orders)) # Expected: [ # {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"height\\": 70.0}, # {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"height\\": 65.0}, # {\\"name\\": \\"Charlie\\", \\"age\\": 30, \\"height\\": 72.0} # ] ``` # Steps: 1. Verify that `data` is a list of dictionaries and ensure all dictionaries have the keys provided. 2. Validate that `keys` and `orders` are lists of same length. 3. Sort `data` based on the keys and their respective sort orders specified in `keys` and `orders`. 4. Utilize Python\'s built-in sorting capabilities, leveraging `lambda` expressions or the `itemgetter` in the context of stable sorting. 5. Handle cases where keys have equal values by maintaining their relative order. # Edge Cases to Consider: - Empty `data` list. - Different types of values associated with the keys. - Nonexistent key scenarios. - Incorrect lengths of `keys` and `orders`.","solution":"def multi_key_sort(data, keys, orders): Sorts a list of dictionaries based on multiple keys and respective sort orders. Parameters: - data (list of dicts): The list of dictionaries to be sorted. - keys (list of str): The keys on which the dictionaries should be sorted. - orders (list of bool): The sort orders for each key, True for ascending and False for descending. Returns: - list of dicts: The sorted list of dictionaries. assert len(keys) == len(orders), \\"The number of keys and orders must match.\\" return sorted(data, key=lambda x: tuple( (x[key],) if order else (-x[key] if isinstance(x[key], (int, float)) else x[key][::-1] if isinstance(x[key], str) else x[key]) for key, order in zip(keys, orders) )) # Example usage: data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"height\\": 65.0}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"height\\": 70.0}, {\\"name\\": \\"Charlie\\", \\"age\\": 30, \\"height\\": 72.0} ] keys = [\\"age\\", \\"height\\"] orders = [True, False] print(multi_key_sort(data, keys, orders))"},{"question":"# Problem Statement **Title**: Implementing a Basic Calculator You are tasked with creating a function `basic_calculator` that can evaluate simple mathematical expressions given as strings involving addition, subtraction, multiplication, and division. The function should return the result of the evaluation as a float. Function Signature ```python def basic_calculator(expression: str) -> float: ``` Input - `expression` (str): A string representing a mathematical expression. The input expression will consist of numbers and operators (+, -, *, /) separated by spaces. It is guaranteed that the expression will be valid and contain no parentheses. Output - Returns a float that is the result of evaluating the input mathematical expression. Constraints - The input string expression will be at most 100 characters long. - Numbers in the expression can be positive or negative and can be expressed as integers or decimal numbers. - Division operations will not result in division by zero. Examples ```python assert basic_calculator(\\"3 + 5\\") == 8.0 assert basic_calculator(\\"10 - 2 * 3\\") == 4.0 assert basic_calculator(\\"4.5 / 1.5 + 2\\") == 5.0 assert basic_calculator(\\"-7 + 3 * 4 - 2 / 2\\") == 4.0 ``` Notes - You should handle invalid inputs by raising a `ValueError` with the message \\"Invalid expression\\". - For the sake of simplicity, assume that the input expression is always valid and there will be no spaces within the numbers themselves. - Handle the operations according to the standard operator precedence, i.e., multiplication and division should be performed before addition and subtraction. - The function should parse the expression and compute the result incrementally. # Additional Guidelines 1. **Input Validation**: If the input string contains invalid characters or malformed expressions, your function should raise a `ValueError` with the message \\"Invalid expression\\". 2. **Operator Precedence**: Implement proper handling of operator precedence so that multiplication and division are performed before addition and subtraction. 3. **Edge Handling**: Consider edge cases such as multiple consecutive operators, negative numbers, and decimal point numbers while ensuring accurate evaluation.","solution":"def basic_calculator(expression: str) -> float: Evaluates a simple mathematical expression involving +, -, *, /. Returns the result as a float. try: result = eval(expression) return float(result) except (SyntaxError, NameError, ZeroDivisionError): raise ValueError(\\"Invalid expression\\")"},{"question":"Implementing and Optimizing a Function to Generate Pascal\'s Triangle Context: Pascal\'s Triangle is a triangular array of the binomial coefficients. Each row represents the coefficients of the expanded form of the binomial expression `(x + y)^n`. The triangle starts with a 1 at the top, and each subsequent row is constructed by adding adjacent elements from the row above, starting and ending each row with 1. Task: Write a Python function named `optimized_pascals_triangle` that generates the first `n` rows of Pascal\'s Triangle. Focus on optimizing both time and space complexities where possible, compared to the typical iterative approach. * **Input**: An integer `n` representing the number of rows of Pascal\'s Triangle to generate. * **Output**: A list of lists, where each inner list contains the elements of a row in Pascal\'s Triangle. Constraints: 1. (1 leq n leq 100) 2. Your implementation should not use more memory than necessary to store the result. Performance Requirement: - The function must be optimized to handle the maximum input size efficiently, both in terms of time and space. Example: ```python def optimized_pascals_triangle(n: int) -> list: # Your optimized implementation goes here # Example usage: print(optimized_pascals_triangle(5)) # Expected output: # [ # [1], # [1, 1], # [1, 2, 1], # [1, 3, 3, 1], # [1, 4, 6, 4, 1] # ] ``` Ensure your implementation can handle the maximum constraint and verify its correctness with edge cases. Additionally, provide a brief explanation of how your optimization improves over the naive implementation.","solution":"def optimized_pascals_triangle(n: int) -> list: Generate the first n rows of Pascal\'s Triangle in an optimized manner. Parameters: n (int): Number of rows of Pascal\'s Triangle to generate. Returns: list: List of lists, where each inner list is a row of Pascal\'s Triangle. if n == 0: return [] result = [[1]] for current_row in range(1, n): row = [1] # Start each row with a 1 for j in range(1, current_row): row.append(result[current_row - 1][j - 1] + result[current_row - 1][j]) row.append(1) # End each row with a 1 result.append(row) return result"},{"question":"# Problem Statement You are given an m x n grid where each cell is either \'0\' (representing water) or \'1\' (representing land). Your task is to find the number of islands in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. # Input: 1. An integer `m` representing the number of rows in the grid (1 ≤ m ≤ 300). 2. An integer `n` representing the number of columns in the grid (1 ≤ n ≤ 300). 3. A `m x n` list `grid` where `grid[i][j]` is either \'0\' or \'1\'. # Output: An integer representing the number of islands in the grid. # Constraints: - The grid may contain many islands. - The grid may be completely water or completely land. # Example: ```python # Sample input m = 4 n = 5 grid = [ [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'1\'], [\'0\', \'0\', \'0\', \'1\', \'1\'], [\'0\', \'1\', \'0\', \'0\', \'0\'] ] # Expected output 3 ``` # Function Signature ```python def num_islands(m: int, n: int, grid: list[list[str]]) -> int: pass ``` # Instructions: 1. Implement a function that uses Depth-First Search (DFS) or Breadth-First Search (BFS) to find all islands in the given `m x n` grid. 2. Your function should return the total number of islands found in the grid. 3. Take care to mark visited cells appropriately to avoid counting the same island multiple times.","solution":"def num_islands(m: int, n: int, grid: list[list[str]]) -> int: def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \'0\': return grid[i][j] = \'0\' # Mark as visited directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for di, dj in directions: dfs(i + di, j + dj) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\': island_count += 1 dfs(i, j) return island_count"},{"question":"# Tower of Hanoi Moves Counter You are given the classic problem of the Tower of Hanoi, which involves moving n disks from one peg to another using a third peg. The goal is to count the minimal number of moves required to solve the puzzle. Requirements 1. Implement `count_hanoi_moves(n: int) -> int`, which returns the minimal number of moves needed to solve the Tower of Hanoi puzzle with `n` disks. # Input - An integer `n` representing the number of disks (1 ≤ n ≤ 20). # Output - An integer representing the minimal number of moves required. # Constraints - The mathematical formula to calculate the number of moves is `2^n - 1`. - Ensure your implementation can handle the maximum input size efficiently. Example ```python assert count_hanoi_moves(1) == 1 assert count_hanoi_moves(2) == 3 assert count_hanoi_moves(3) == 7 assert count_hanoi_moves(4) == 15 ``` Write code to: - Calculate the minimal number of moves required for any given `n` disks. - Use the formula for minimal moves to ensure efficiency.","solution":"def count_hanoi_moves(n: int) -> int: Returns the minimal number of moves required to solve the Tower of Hanoi puzzle with n disks. return 2**n - 1"},{"question":"# Problem Statement: Matrix Transposition Context You are given a matrix represented as a list of lists in Python. Implement a function to transpose the given matrix. Transposing a matrix involves swapping its rows with its columns. Objective Implement a function named `transpose_matrix` that transposes a given matrix. Function Specifications * **Function Name**: `transpose_matrix` * **Input**: - `matrix`: A list of lists where each inner list represents a row of the matrix. * **Output**: - Returns a new list of lists representing the transposed matrix. Constraints * Each row in the matrix must have the same length. * The matrix can be of any size, including 0x0 (an empty matrix). * The elements of the matrix should be integers or floats. Requirements * Implement the function with optimal time complexity for matrix transposition. * Ensure validation to handle non-uniform row lengths. Example ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] ``` Implementation Guidelines 1. Initialize a new matrix with swapped dimensions (columns become rows and vice versa). 2. Iterate through the original matrix to fill the new matrix with transposed elements. 3. Validate input to ensure all rows are of equal length and that the matrix can be transposed. ```python def transpose_matrix(matrix: list) -> list: # Your implementation here pass ``` Testing - Ensure test cases cover basic, edge, and complex scenarios, including irregularly shaped matrices and empty matrices.","solution":"def transpose_matrix(matrix): Returns the transposed matrix. :param matrix: List of lists where each inner list represents a row of the matrix. :return: List of lists representing the transposed matrix. # Edge case: If the matrix is empty, return an empty matrix if not matrix or not matrix[0]: return [] # Transpose the matrix using list comprehension transposed_matrix = [[matrix[row][col] for row in range(len(matrix))] for col in range(len(matrix[0]))] return transposed_matrix"},{"question":"# Coding Assessment Question: Context: You are developing a utility for traversing and mapping file systems to help users manage their files more efficiently. This utility will list all files in a given directory tree, categorize them based on file extensions, and generate a summary of the findings. Part of the application should include handling large directories and providing results in an easy-to-read format. Task: Implement a function called `directory_file_mapper` that traverses a given directory and generates a summary report of all files found. This function should: 1. Accept the path of the directory to be scanned. 2. Recursively traverse all subdirectories. 3. Categorize files based on their extensions. 4. Provide a summary that includes the count of each file type and total size. 5. Handle permission issues gracefully and skip inaccessible directories/files. 6. Ensure performance efficiency especially for directories with a large number of files. 7. Include appropriate docstrings and comments for clarity. Requirements: 1. Use provided libraries (`os`, `os.path`, `collections`) for file handling and traversal. 2. Handle file permission errors without stopping the traversal process. 3. Optimize the function for performance to handle large directories efficiently. 4. Provide console output summary including the count and total size of each file type. Expected Input and Output: **Input**: - `directory_path` (String): Path to the directory to be scanned. **Output**: - Console output listing the file types, their count, and total size. Example: ```python # This is a simplified representation of expected outputs. >>> directory_file_mapper(\\"/path/to/directory\\") Scanning directory: /path/to/directory Summary: .txt files: 15 files, 200 KB .jpg files: 10 files, 3500 KB .pdf files: 5 files, 1000 KB Total: 30 files, 4700 KB ``` Implementation Notes: - Utilize `os.walk` for efficient directory traversal. - Use `collections.defaultdict` for categorizing files by extension. - Handle potential `PermissionError` exceptions gracefully to ensure the scan continues. - Provide a readable summary after the scan completes. - Ensure the code is self-contained and free of external dependencies.","solution":"import os import collections def directory_file_mapper(directory_path): Traverses the directory and generates a summary report of all files found. Args: directory_path (str): Path to the directory to be scanned. file_summary = collections.defaultdict(lambda: {\\"count\\": 0, \\"size\\": 0}) for root, _, files in os.walk(directory_path): for file in files: try: file_path = os.path.join(root, file) file_size = os.path.getsize(file_path) file_extension = os.path.splitext(file)[1].lower() file_summary[file_extension][\'count\'] += 1 file_summary[file_extension][\'size\'] += file_size except PermissionError: # Skipping files/directories for which permission errors occur continue # Printing the summary report print(f\\"Scanning directory: {directory_path}n\\") print(\\"Summary:\\") total_files = 0 total_size = 0 for extension, info in file_summary.items(): total_files += info[\'count\'] total_size += info[\'size\'] size_kb = info[\'size\'] // 1024 print(f\\"{extension} files: {info[\'count\']} files, {size_kb} KB\\") total_size_kb = total_size // 1024 print(f\\"Total: {total_files} files, {total_size_kb} KB\\")"},{"question":"# Analyzing Weather Data from JSON API You are tasked with creating a function to fetch and analyze weather data from a given API URL using the `requests` library in Python. The function should retrieve the current temperature, humidity, and a short description of the weather from the provided JSON response. Function Signature: ```python def fetch_weather_data(url: str) -> WeatherData: pass ``` Requirements: 1. **Fetch Data**: Use the provided API URL parameter to make an HTTP GET request to fetch the JSON content of the weather data. 2. **Parse JSON**: Extract the current temperature (in Celsius), humidity (percentage), and a short description (e.g., \\"clear sky\\") of the weather from the JSON response. 3. **Return Data**: Return the extracted data as an instance of the `WeatherData` named tuple. Constraints: - The function should handle potential errors such as: - HTTP request failures. - JSON parsing errors. - Missing expected fields in the JSON response. Input and Output Format: - **Input**: A string representing the URL of the JSON API to fetch the weather data from. - **Output**: A `WeatherData` named tuple containing the current temperature (float), humidity (int), and a short description (string). Example ```python url = \\"https://api.open-meteo.com/v1/forecast?latitude=35.6895&longitude=139.6917&current_weather=true\\" result = fetch_weather_data(url) print(result) # Possible output format given the JSON structure # WeatherData(temperature=22.5, humidity=65, description=\\"clear sky\\") ``` Additional Notes: - Ensure robust error handling and consider edge cases such as incomplete JSON responses or unexpected data types. - Optimize for minimal latency and efficient parsing.","solution":"from typing import NamedTuple import requests class WeatherData(NamedTuple): temperature: float humidity: int description: str def fetch_weather_data(url: str) -> WeatherData: Fetches weather data from the provided API URL and returns it as a WeatherData named tuple. Parameters: - url (str): The URL to fetch the weather data from. Returns: - WeatherData: A named tuple containing the temperature, humidity, and a short description of the weather. try: response = requests.get(url) response.raise_for_status() # Check for HTTP request errors data = response.json() # Extract required fields current_weather = data[\'current_weather\'] temperature = current_weather[\'temperature\'] # assumed to be in Celsius humidity = current_weather[\'humidity\'] # assumed to be in percentage description = current_weather[\'weather_description\'] # short description of the weather return WeatherData(temperature=temperature, humidity=humidity, description=description) except requests.RequestException as e: # Handle any request-related errors raise RuntimeError(f\\"HTTP Request failed: {e}\\") except (ValueError, KeyError) as e: # Handle JSON decoding errors or missing fields raise RuntimeError(f\\"Error parsing response data: {e}\\")"},{"question":"Problem Statement You are given a string s and a list of words dictionary. Your task is to implement a function `find_embedded_words(s: str, dictionary: List[str]) -> List[str]` that finds all words from the dictionary that are embedded in the string s. A word is considered embedded if all the characters of the word appear in the string s in the exact same order but not necessarily contiguously. # Input: * A single string `s` consisting of lowercase alphabets. * A list of strings `dictionary` where each string is a word consisting of lowercase alphabets. # Output: * Return a list of strings representing the words from the dictionary that are embedded in the string s, maintaining their original order from the dictionary. # Constraints: * The length of the string s will be between 1 and 100,000. * The size of the dictionary will be between 1 and 1000. * Each word in the dictionary will have a length between 1 and 100. # Example: ```python def test_find_embedded_words(): assert find_embedded_words(\\"abppplee\\", [\\"able\\", \\"ale\\", \\"apple\\", \\"bale\\", \\"kangaroo\\"]) == [\\"able\\", \\"ale\\", \\"apple\\"] assert find_embedded_words(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\", \\"acb\\"]) == [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\"] assert find_embedded_words(\\"abcdefgh\\", [\\"bc\\", \\"de\\", \\"fg\\", \\"ace\\"]) == [\\"bc\\", \\"de\\", \\"fg\\", \\"ace\\"] assert find_embedded_words(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == [] assert find_embedded_words(\\"abcdefg\\", [\\"hij\\", \\"klm\\", \\"nop\\"]) == [] test_find_embedded_words() ``` # Performance Considerations: * Optimize the string and list traversal to handle large input sizes effectively. * Ensure that the algorithm runs efficiently for both the length of the string and the number of words in the dictionary.","solution":"from typing import List def find_embedded_words(s: str, dictionary: List[str]) -> List[str]: def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) result = [word for word in dictionary if is_subsequence(word, s)] return result"},{"question":"# Median Finder **Objective**: Implement an algorithm to find the median of a list of integers. # Problem Statement Given a list of integers, implement an algorithm to find the median of the elements. **Function Signature** ```python def find_median(array: list[int]) -> float: Finds the median of a list of integers. :param array: A list of integers :return: The median value as a float Example Usage: >>> find_median([1, 3, 3, 6, 7, 8, 9]) 6.0 >>> find_median([1, 2, 3, 4, 5, 6, 8, 9]) 4.5 ``` # Input - A list of integers `array` that can contain negative numbers, positive numbers, or be empty. # Output - The median as a float. # Constraints * The list can have up to `10^6` integer elements. # Performance Requirements * Your implementation should efficiently handle lists with up to a million elements. # Example ```python >>> find_median([1, 3, 3, 6, 7, 8, 9]) 6.0 >>> find_median([1, 2, 3, 4, 5, 6, 8, 9]) 4.5 >>> find_median([]) 0.0 >>> find_median([-5, -3, -1, 0, 2, 4, 6]) 0.0 >>> find_median([4]) 4.0 ``` **Scenario**: You are analyzing a large dataset of financial transactions and need to find the median transaction amount. This requires an efficient solution to handle potentially large volumes of data. **Edge cases to consider**: - An empty list of values should return 0.0 as the median. - Lists with negative and positive numbers. - Lists with an even and odd number of elements. # Instructions 1. Define the `find_median` function according to the function signature provided. 2. Ensure the function passes the example usages provided in the problem statement. 3. Write your own test cases to cover edge cases and additional scenarios.","solution":"def find_median(array): Finds the median of a list of integers. :param array: A list of integers :return: The median value as a float if not array: return 0.0 array.sort() n = len(array) mid = n // 2 if n % 2 == 0: median = (array[mid - 1] + array[mid]) / 2.0 else: median = float(array[mid]) return median"},{"question":"# Find the First Non-Repeating Character in a String **Context**: Identifying unique elements in a sequence is a common problem in many applications, including text processing, data analysis, and database management. In this task, you need to find the first non-repeating character in a given string, which is a typical requirement in various competitive programming challenges and coding interviews. **Your Task**: Implement a function that returns the first non-repeating character in a string. If there is no unique character, return an empty string. Function Signature ```python def first_non_repeating_char(s: str) -> str: ``` Input - `s`: A string that consists of lower-case English letters. Output - Returns the first non-repeating character. If all characters repeat, return an empty string. Constraints - The string will have at least 1 character and at most (10^5) characters. - The string will only contain lowercase English letters (\'a\'-\'z\'). Example ```python >>> first_non_repeating_char(\\"swiss\\") \\"w\\" >>> first_non_repeating_char(\\"hello\\") \\"h\\" >>> first_non_repeating_char(\\"aabb\\") \\"\\" ``` Requirements - Your solution should be optimized to handle the upper limit of characters efficiently. - Consider the most efficient way to count characters and determine the first unique one. Hints - Think about how you can use hash maps (dictionaries) for efficient counting. - A two-pass solution (one pass to count, another to find the first non-repeating character) could be effective.","solution":"def first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the string s. If there is no unique character, return an empty string. # Dictionary to keep count of each character\'s occurrences char_count = {} # First pass to count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return an empty string return \\"\\""},{"question":"# Find Common Elements in Multiple Lists Context: Given multiple lists of integers, the task is to identify the common elements that appear in all of these lists. Objective: Implement a function that takes a list of lists and returns a sorted list of integers that are common to all input lists. Function Signature: ```python def common_elements(lists: List[List[int]]) -> List[int]: pass ``` Input: 1. **lists** (List[List[int]]): A list containing multiple lists of integers. Output: - **List[int]**: A sorted list of integers that are common to all input lists. Constraints: - Each individual list within the `lists` will contain between 0 and 10^4 integers. - The total number of lists in `lists` will be between 1 and 10^2. - Each integer in the lists will be between -10^6 and 10^6. Example: ```python assert common_elements([[1, 2, 3], [2, 3, 4], [2, 5, 3]]) == [2, 3] assert common_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [] assert common_elements([[10, 20, 30], [10, 20], [20, 10]]) == [10, 20] assert common_elements([[5], [5, 5], [5, 5, 5]]) == [5] assert common_elements([[], [1, 2, 3], [2, 3, 4]]) == [] ``` Note: - Ensure that your implementation efficiently handles edge cases such as empty lists and lists with very large or very small integers. - You can assume that input to this function will always be valid and adhere to the constraints.","solution":"from typing import List def common_elements(lists: List[List[int]]) -> List[int]: Identify and return a sorted list of integers that are common to all input lists. if not lists: return [] common_set = set(lists[0]) for lst in lists[1:]: common_set &= set(lst) return sorted(common_set)"},{"question":"# Mode Finder Assessment You are tasked with implementing a utility to find the mode(s) of a list of integers. The mode is the number that appears most frequently in a dataset. This is an important operation in statistics and data analysis. # Problem Description **Function 1: calculate_mode** Implement a function `calculate_mode(numbers: list[int]) -> list[int]` that calculates the mode(s) from a list of integers. Your implementation should handle cases where multiple numbers have the same highest frequency by returning all of them. # Expected Input and Output 1. **calculate_mode Function** * Input: `numbers` - A list of integers. * Output: A list containing the mode(s) of the provided list of integers. If the input list is empty, return an empty list. # Constraints * The list `numbers` will have at most 1000 integers. * The integers in the list will be in the range of -1000 to 1000. # Performance Requirements Ensure your solution performs efficiently within the given constraints. # Example Use Case ```python assert calculate_mode([1, 2, 3, 3, 4]) == [3] assert calculate_mode([1, 1, 2, 2, 3, 3]) == [1, 2, 3] assert calculate_mode([]) == [] ``` Write and test your implementation to demonstrate its correctness and efficiency.","solution":"def calculate_mode(numbers): Returns the mode(s) of the list of numbers. If there are multiple modes, returns all of them in a list. If the list is empty, returns an empty list. if not numbers: return [] frequency = {} for num in numbers: frequency[num] = frequency.get(num, 0) + 1 max_frequency = max(frequency.values()) modes = [num for num, freq in frequency.items() if freq == max_frequency] return modes"},{"question":"# Coding Assessment Question Graphs are fundamental data structures in computer science that represent relationships between entities. They are widely used in network analysis, pathfinding algorithms, and various optimization problems. **Objective**: Implement a function to detect cycles in a directed graph using Depth-First Search (DFS). Requirements: 1. **Cycle Detection**: * Implement a class `Graph` with a method `add_edge` to add a directed edge between two vertices. * Implement a method `has_cycle` within the `Graph` class to detect if there are any cycles in the graph using DFS. 2. **Handling Input**: * Ensure that your implementation handles potential edge cases (e.g., graphs with no vertices, no edges, and self-loops). Function Signature ```python class Graph: def __init__(self): # Initialize the graph structure self.graph = {} def add_edge(self, from_vertex: int, to_vertex: int) -> None: # Add a directed edge to the graph pass def has_cycle(self) -> bool: # Implement DFS to detect cycles in the graph pass ``` Example Usage: ```python g = Graph() g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) print(g.has_cycle()) # Output: True h = Graph() h.add_edge(0, 1) h.add_edge(1, 2) print(h.has_cycle()) # Output: False ``` Constraints: 1. Vertices are represented as non-negative integers. 2. The graph may have multiple edges and self-loops. 3. The graph should be able to handle up to 10^5 vertices and edges efficiently. 4. Implement a solution with a time complexity of O(V + E), where V is the number of vertices and E is the number of edges. Context: Cycle detection in directed graphs is crucial in many applications such as scheduling, deadlock detection in operating systems, and verifying the correctness of engineering workflows. Being able to detect cycles using DFS showcases your understanding of graph traversal algorithms and their practical applications in computer science.","solution":"class Graph: def __init__(self): # Initialize the graph structure as an adjacency list self.graph = {} def add_edge(self, from_vertex: int, to_vertex: int) -> None: Adds a directed edge from `from_vertex` to `to_vertex` in the graph. if from_vertex not in self.graph: self.graph[from_vertex] = [] self.graph[from_vertex].append(to_vertex) def has_cycle(self) -> bool: Returns True if there is a cycle in the graph, otherwise False. Uses Depth-First Search (DFS) to detect cycles. visited = set() rec_stack = set() def dfs(v): if v not in visited: visited.add(v) rec_stack.add(v) for neighbour in self.graph.get(v, []): if neighbour not in visited: if dfs(neighbour): return True elif neighbour in rec_stack: return True rec_stack.remove(v) return False for node in self.graph: if node not in visited: if dfs(node): return True return False"},{"question":"# Question: Unique Elements from Merged Lists Background: In data science and data engineering workflows, it\'s common to operate on multiple datasets simultaneously. One routine task is merging data collections and then filtering out duplicates to obtain a set of unique elements. Problem Statement: Write a function `unique_elements` which takes two lists of integers as input and returns a list containing unique elements that appear in either of the input lists. Function Signature: ```python def unique_elements(list1: list[int], list2: list[int]) -> list[int]: pass ``` Input: * Two lists `list1` and `list2`, each containing integers. Output: * A list of integers representing the unique elements that appear in `list1`, `list2`, or both. Constraints: * The integers in the input lists can range from `-10^9` to `10^9`. * The lengths of the input lists will be between `0` and `10^5`. Performance Requirements: * The function should be efficient, ideally operating within O(M + N) time complexity, where M and N are the lengths of `list1` and `list2` respectively. Example: ```python assert unique_elements([1, 2, 3], [2, 3, 4]) == [1, 2, 3, 4] assert unique_elements([], [5, 6, 7]) == [5, 6, 7] assert unique_elements([7, 8, 9], []) == [7, 8, 9] assert unique_elements([2, 2, 2], [2, 2]) == [2] ``` Edge Cases: 1. **One Empty List**: `unique_elements([], [1, 2, 3])` should return `[1, 2, 3]`. 2. **Both Lists Empty**: `unique_elements([], [])` should return `[]`. Additional Notes: 1. The output list should not contain any duplicate elements. 2. The order of elements in the output list does not matter. 3. Handle cases where non-integers are present in the list by raising a `TypeError` with the message \\"All elements in the list must be \'int\' type\\". Write comprehensive test cases to validate your implementation.","solution":"def unique_elements(list1: list[int], list2: list[int]) -> list[int]: Returns a list containing unique elements that appear in either of the input lists. # Check if all elements are integers if not all(isinstance(x, int) for x in list1 + list2): raise TypeError(\\"All elements in the list must be \'int\' type\\") # Use a set to find unique elements unique_set = set(list1).union(set(list2)) return list(unique_set)"},{"question":"# Scenario Designing an efficient algorithm often involves optimizing how we access and store data. One such problem arises when dealing with nested data structures, where the objective is to flatten or expand these structures to simplify operations such as searching and filtering. # Task Write a Python function `flatten_dict(nested_dict: dict, separator: str = \'.\') -> dict` that flattens a nested dictionary. The function should recursively traverse the dictionary and convert any nested sub-dictionaries into flat dictionaries by concatenating keys using the specified separator. If no separator is provided, use \'.\' by default. # Input Specifications * `nested_dict`: A dictionary that may contain other dictionaries as values. * `separator`: A string to use as a separator between concatenated keys. # Output Specifications * Returns a flat dictionary with concatenated keys. # Constraints * The nested dictionary can have multiple levels of nesting. * Values in the dictionary can be of any type. * Each key in the dictionary is a string. # Example ```python >>> nested_dict = { ... \'a\': 1, ... \'b\': { ... \'c\': 2, ... \'d\': { ... \'e\': 3 ... } ... }, ... \'f\': 4 ... } >>> flatten_dict(nested_dict) {\'a\': 1, \'b.c\': 2, \'b.d.e\': 3, \'f\': 4} >>> nested_dict = { ... \'x\': { ... \'y\': { ... \'z\': 5 ... } ... }, ... \'p\': { ... \'q\': 6, ... \'r\': { ... \'s\': 7, ... \'t\': { ... \'u\': 8 ... } ... } ... } ... } >>> flatten_dict(nested_dict, \'_\') {\'x_y_z\': 5, \'p_q\': 6, \'p_r_s\': 7, \'p_r_t_u\': 8} ``` # Requirements * Use recursion to traverse and flatten the dictionary. * Ensure that the function can handle deeply nested dictionaries. * Performance should be efficient for typical input sizes found in real-world applications.","solution":"def flatten_dict(nested_dict, separator=\'.\'): Flatten a nested dictionary. :param nested_dict: dict, the nested dictionary to flatten :param separator: str, the separator to use between concatenated keys, default is \'.\' :return: dict, the flattened dictionary def recurse(d, parent_key=\'\'): items = [] for k, v in d.items(): new_key = f\'{parent_key}{separator}{k}\' if parent_key else k if isinstance(v, dict): items.extend(recurse(v, new_key).items()) else: items.append((new_key, v)) return dict(items) return recurse(nested_dict)"},{"question":"# Unique Automorphic Number Detection You are required to implement a function that checks whether a given integer is an automorphic number. An automorphic number is a number whose square ends with the number itself. Function Signature ```python def is_automorphic_number(n: int) -> bool: pass ``` Input: - `n` (int): The integer to be checked. Output: - Returns a boolean, `True` if the number is automorphic, `False` otherwise. Constraints: - ( 0 leq n leq 10^9 ) - The function should handle large integers efficiently. Requirements: - The function should have a time complexity of ( O(k) ), where ( k ) is the number of digits in the square of ( n ). - Verify edge cases such as `n = 0` or `n = 1`. Example: ```python print(is_automorphic_number(5)) # Expected output: True (5^2 = 25) print(is_automorphic_number(76)) # Expected output: True (76^2 = 5776) print(is_automorphic_number(10)) # Expected output: False (10^2 = 100) print(is_automorphic_number(25)) # Expected output: True (25^2 = 625) ``` Scenario: Imagine you are tasked with creating a number checker in a system that processes various mathematical properties. One of the requirements is to check if a number is automorphic. For example, knowing that 76 is an automorphic number because ( 76^2 = 5776 ), where the number ends in 76. Implement this functionality to provide quick verification of such numbers.","solution":"def is_automorphic_number(n: int) -> bool: Check if an integer is an automorphic number. An automorphic number is a number whose square ends with the number itself. Args: n (int): The integer to be checked. Returns: bool: True if the number is automorphic, False otherwise. square = n ** 2 str_n = str(n) str_square = str(square) return str_square.endswith(str_n)"},{"question":"Problem Statement You are provided with an encoded string, which is a series of numbers separated by commas. Each number represents the position of a letter in the alphabet (1 for \'A\', 2 for \'B\', ..., 26 for \'Z\'). Your task is to decode this string into its corresponding alphabetic representation. # Function Signature ```python def decode_string(encoded_str: str) -> str: ``` # Input - `encoded_str` (1 ≤ len(encoded_str) ≤ 1000): A string consisting of integers separated by commas, where each integer is in the range 1 to 26. # Output - A string representing the decoded message by converting each number to its corresponding letter in the alphabet. The output should maintain the case sensitivity according to the examples. # Constraints - The encoded string will only contain valid integers separated by commas without any spaces. # Performance Requirements - The decoding process should handle the conversion efficiently even for the upper limit of the input length. # Example ```python decode_string(\\"8,5,12,12,15\\") # Expected output: \\"HELLO\\" (8 -> H, 5 -> E, 12 -> L, 12 -> L, 15 -> O) decode_string(\\"20,8,5,17,21,9,3,11,2,18,15,23,14,6,15,24,10,21,13,16,19,15,22,5,18\\") # Expected output: \\"THEQUICKBROWNFOXJUMPSOVER\\" (as each number translates to a corresponding letter) ``` Write the implementation for the function `decode_string` according to the above specifications.","solution":"def decode_string(encoded_str: str) -> str: Decodes a string of numbers separated by commas into its corresponding alphabetic representation, where each number represents the position of a letter in the alphabet (1 for \'A\', 2 for \'B\', ..., 26 for \'Z\'). :param encoded_str: A string of numbers separated by commas. :return: A decoded string represented by the numbers. # Split the input string into a list of numbers numbers = encoded_str.split(\',\') # Convert each number to its corresponding letter in the alphabet decoded_message = \'\'.join(chr(int(num) + 64) for num in numbers) return decoded_message"},{"question":"# Coding Assessment Question Scenario You are building a simple neural network library, and one of the fundamental components required is a function that computes the sigmoid activation. The sigmoid function is widely used in neural networks to introduce non-linearity into the model. Task Write a function `sigmoid_activation` that computes the sigmoid of a given float value. The sigmoid function is mathematically defined as: [ sigma(x) = frac{1}{1 + e^{-x}} ] where ( x ) is the input value. Requirements 1. If the input is not a number (`NaN`), raise a `ValueError` with the message \\"Input must be a number\\". 2. Ensure the function handles positive, negative, and zero input values correctly. 3. Use the `math` library to compute the exponential function. Function Signature ```python def sigmoid_activation(x: float) -> float: pass ``` Inputs - `x` (float): The input value to the sigmoid function. Output - (float): The computed sigmoid value. Constraints - The input will be a floating-point number in the range of (-1e9) to (1e9). Example ```python >>> sigmoid_activation(0) 0.5 >>> sigmoid_activation(2) 0.8807970779778823 >>> sigmoid_activation(-3) 0.04742587317756678 >>> sigmoid_activation(float(\'nan\')) Traceback (most recent call last): ... ValueError: Input must be a number ``` Implement this function to correctly handle the computation of the sigmoid activation for various input values.","solution":"import math def sigmoid_activation(x: float) -> float: Computes the sigmoid of the given float value. :param x: Input value. :return: Sigmoid value. :raises ValueError: If the input is not a number. if not isinstance(x, (int, float)) or math.isnan(x): raise ValueError(\\"Input must be a number\\") return 1 / (1 + math.exp(-x))"},{"question":"# Question: Efficient Trimming of a String You are required to write an efficient algorithm that trims a given string by removing all leading and trailing whitespace characters without using inbuilt trimming functions (like `strip`, `lstrip`, or `rstrip`). Your function should achieve this by scanning through the string and identifying the indexes where the first and last non-whitespace characters occur. Function to Implement ```python def custom_trim(input_str: str) -> str: Trim leading and trailing whitespaces from the input string. Arguments: input_str: str -- The string to be trimmed. Returns: str -- The trimmed string with no leading and trailing whitespaces. Example: >>> custom_trim(\\" Hello World! \\") \'Hello World!\' >>> custom_trim(\\"NoSpace\\") \'NoSpace\' >>> custom_trim(\\" \\") \'\' >>> custom_trim(\\" a b \\") \'a b\' # Your implementation here ``` Input * `input_str`: string (0 ≤ len(input_str) ≤ 10^6) Output * A string that has all leading and trailing whitespace characters removed. Performance * Your function should efficiently handle the maximum input size, relying solely on linear scans without the use of Python’s inbuilt trimming functions. Special Instructions * Focus on handling edge cases, such as strings entirely composed of whitespaces or empty strings. * Ensure that the function operates within acceptable time and space complexity constraints for large inputs.","solution":"def custom_trim(input_str: str) -> str: Trim leading and trailing whitespaces from the input string without using inbuilt trim functions. Arguments: input_str: str -- The string to be trimmed. Returns: str -- The trimmed string with no leading and trailing whitespaces. if input_str == \\"\\": return input_str start = 0 end = len(input_str) - 1 # Find the first non-whitespace character from the left while start <= end and input_str[start].isspace(): start += 1 # Find the first non-whitespace character from the right while start <= end and input_str[end].isspace(): end -= 1 # Slice from start to end (inclusive) return input_str[start:end+1]"},{"question":"# Coding Exercise: Railway Reservation System **Objective**: Implement a basic railway reservation system using object-oriented programming concepts. Your task is to create a system that handles bookings, cancellations, and queries related to a train\'s seating arrangement. # Specification: 1. Create a `Train` class that contains the attributes `name`, `number`, `seats`, and `bookings`. The `seats` attribute is a dictionary that tracks seat availability (e.g., `\\"A1\\": True` for available, `\\"A1\\": False` for booked). 2. Write a `book_seat(seat: str) -> str` method in the `Train` class that books the specified seat if it is available and returns a confirmation message. If the seat is already booked, return a message indicating the seat is unavailable. 3. Implement a `cancel_seat(seat: str) -> str` method in the `Train` class that cancels the booking for the specified seat if it is booked and returns a cancellation confirmation message. If the seat is not booked or doesn\'t exist, return an appropriate message. 4. Write a `query_seat(seat: str) -> str` method in the `Train` class that returns the current status of the specified seat (available or booked). # Class Definition: ```python class Train: def __init__(self, name: str, number: int): Initialize a new Train object. Parameters: name (str): The name of the train. number (int): The number of the train. pass def book_seat(self, seat: str) -> str: Book a seat on the train. Parameters: seat (str): The seat number to book. Returns: str: Confirmation message. pass def cancel_seat(self, seat: str) -> str: Cancel the booking of a seat on the train. Parameters: seat (str): The seat number to cancel. Returns: str: Cancellation confirmation message. pass def query_seat(self, seat: str) -> str: Query the status of a seat on the train. Parameters: seat (str): The seat number to query. Returns: str: Status message (either \\"available\\" or \\"booked\\"). pass ``` # Constraints: * The train has a specific number of seats organized in a particular pattern (e.g., Rows \\"A\\" to \\"E\\" and numbers \\"1\\" to \\"10\\"). * The seat numbers are strings in the format `row + number` (e.g., \\"A1\\", \\"B5\\"). * Assume valid seat numbers are provided for booking, cancellation, and query operations. # Examples: ```python train = Train(\\"Express\\", 12345) # Initial bookings print(train.book_seat(\'A1\')) # Output: \'Seat A1 successfully booked.\' print(train.book_seat(\'A1\')) # Output: \'Seat A1 is unavailable.\' print(train.query_seat(\'A1\')) # Output: \'Seat A1 is booked.\' # Cancellations print(train.cancel_seat(\'A1\')) # Output: \'Seat A1 successfully canceled.\' print(train.query_seat(\'A1\')) # Output: \'Seat A1 is available.\' print(train.cancel_seat(\'A1\')) # Output: \'Seat A1 is not booked.\' # Querying seats print(train.query_seat(\'A5\')) # Output: \'Seat A5 is available.\' ``` # Context: In a world where railway travel is common, maintaining a smooth and efficient booking system is crucial. This exercise tests your ability to implement a scalable reservation system using object-oriented principles while managing seat availability and ensuring a smooth user experience.","solution":"class Train: def __init__(self, name: str, number: int): Initialize a new Train object. Parameters: name (str): The name of the train. number (int): The number of the train. self.name = name self.number = number self.seats = {f\\"{row}{num}\\": True for row in \\"ABCDE\\" for num in range(1, 11)} self.bookings = {} def book_seat(self, seat: str) -> str: Book a seat on the train. Parameters: seat (str): The seat number to book. Returns: str: Confirmation message. if seat in self.seats and self.seats[seat]: self.seats[seat] = False self.bookings[seat] = \\"booked\\" return f\\"Seat {seat} successfully booked.\\" return f\\"Seat {seat} is unavailable.\\" def cancel_seat(self, seat: str) -> str: Cancel the booking of a seat on the train. Parameters: seat (str): The seat number to cancel. Returns: str: Cancellation confirmation message. if seat in self.seats and not self.seats[seat]: self.seats[seat] = True self.bookings.pop(seat, None) return f\\"Seat {seat} successfully canceled.\\" return f\\"Seat {seat} is not booked.\\" def query_seat(self, seat: str) -> str: Query the status of a seat on the train. Parameters: seat (str): The seat number to query. Returns: str: Status message (either \\"available\\" or \\"booked\\"). if seat in self.seats: return f\\"Seat {seat} is {\'available\' if self.seats[seat] else \'booked\'}.\\" return \\"Invalid seat number.\\""},{"question":"# Scenario As part of a data analysis suite, you need to develop a function that identifies the longest substring of digits within a given text. This function will help quickly extract and analyze numeric data embedded within larger strings. # Task Write a Python function `longest_digit_sequence(s: str) -> int` to determine and return the length of the longest contiguous substring of digits in the provided input string. Your solution should correctly handle strings that may include uppercase and lowercase letters, as well as non-alphabetic characters. # Input/Output Formats * **Input**: A string `s` with up to 10^6 characters. * **Output**: An integer representing the length of the longest contiguous substring composed exclusively of digits. # Constraints * `s` can contain both uppercase and lowercase letters, numbers, and special characters. * Digits include: \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\'. # Performance Requirements Your function should handle large strings efficiently within linear time complexity. # Examples ```python >>> longest_digit_sequence(\\"123abc456def789\\") 3 >>> longest_digit_sequence(\\"lucky number 7777\\") 4 >>> longest_digit_sequence(\\"there are no digits here!\\") 0 >>> longest_digit_sequence(\\"2021 was a year to remember\\") 4 >>> longest_digit_sequence(\\"34 and 56 are magic numbers\\") 2 >>> longest_digit_sequence(\\"errors: 404, 503\\") 3 ``` # Edge Cases * If the input string contains no digits, the function should return 0. * The function should consider all characters and correctly identify contiguous sequences of digits.","solution":"def longest_digit_sequence(s: str) -> int: Determines and returns the length of the longest contiguous substring composed exclusively of digits in the provided input string s. max_length = 0 current_length = 0 for char in s: if char.isdigit(): current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"# Question: Longest Consecutive Sequence in a Binary Tree Given a binary tree, write a Python function to find the length of the longest consecutive sequence path. The path refers to any sequence of nodes in the tree that is connected by edges. The consecutive sequence path must be increasing by 1 for each step along the path. Function Signature: ```python def longest_consecutive(root: Node) -> int: pass ``` Input: - `root`: The root node of the binary tree, which can be `None` for an empty tree. Output: - An integer representing the length of the longest consecutive sequence path in the tree. Constraints: - Tree can be empty, in which case the length is 0. - You must achieve (O(n)) time complexity where (n) is the number of nodes in the tree. # Example: ```python # Example 1: # Construct the following binary tree # 1 # # 3 # / # 2 4 # # 5 root = Node(1) root.right = Node(3) root.right.left = Node(2) root.right.right = Node(4) root.right.right.right = Node(5) assert longest_consecutive(root) == 3 # The consecutive sequence is 3 -> 4 -> 5 # Example 2: # Construct the following binary tree # 2 # # 3 # / # 2 # / # 1 root = Node(2) root.right = Node(3) root.right.left = Node(2) root.right.left.left = Node(1) assert longest_consecutive(root) == 2 # The consecutive sequence is 2 -> 3 ``` # Notes: - You may define additional helper functions if necessary. - Make sure to handle edge cases like an empty tree or trees with only one node.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive(root: Node) -> int: if not root: return 0 def dfs(node, parent_val, length): if not node: return length if node.value == parent_val + 1: length += 1 else: length = 1 left_length = dfs(node.left, node.value, length) right_length = dfs(node.right, node.value, length) return max(length, left_length, right_length) return dfs(root, root.value - 1, 0)"},{"question":"# Task Overview: You are given a string of alphanumeric characters and spaces. Your task is to identify the most frequent alphanumeric character in the string. If there is a tie, return the character that appears first alphabetically. Spaces should be ignored in the counting process. # Function Signature: ```python def most_frequent_char(s: str) -> str: Find the most frequent alphanumeric character in the string. Parameters: s (str): Input string containing alphanumeric characters and spaces. Returns: str: The most frequent alphanumeric character, with ties broken by alphabetical order. ``` # Input: - `s`: A string of length `1 <= len(s) <= 10^5`, containing alphanumeric characters and spaces. # Output: - A string containing a single character, which is the most frequent alphanumeric character in the input string. # Constraints: - The input contains at least one alphanumeric character. - Space characters should be ignored. # Examples: ```python >>> most_frequent_char(\\"hello world\\") \\"l\\" >>> most_frequent_char(\\"123 456 789 123\\") \\"1\\" >>> most_frequent_char(\\"aabbcc\\") \\"a\\" ``` # Explanation: 1. **First Example:** The input string is `\\"hello world\\"`. The most frequent alphanumeric character is \'l\', which appears 3 times. 2. **Second Example:** The input string is `\\"123 456 789 123\\"`. The most frequent alphanumeric character is \'1\', which appears more frequently than any other digit or letter. 3. **Third Example:** The input string is `\\"aabbcc\\"`. All characters appear twice, but \'a\' appears first alphabetically. # Additional Notes: You must handle both uppercase and lowercase characters case-insensitively, meaning \'A\' and \'a\' should be considered the same. The function should return the character in lowercase. Proper handling of spaces and efficient counting using appropriate data structures should be considered.","solution":"def most_frequent_char(s: str) -> str: Find the most frequent alphanumeric character in the string. Parameters: s (str): Input string containing alphanumeric characters and spaces. Returns: str: The most frequent alphanumeric character, with ties broken by alphabetical order. from collections import Counter import string # Filter out spaces and convert to lowercase filtered_string = \'\'.join(c.lower() for c in s if c in string.ascii_letters + string.digits) # Count frequencies of each character counts = Counter(filtered_string) # Find the most frequent character with alphabetical tie-breakers most_frequent = min(counts, key=lambda x: (-counts[x], x)) return most_frequent"},{"question":"# Scenario You are given a set of students, each with a name and a list of scores they have achieved on various assignments. Implement a system that allows efficient management of student scores and makes it easy to calculate average scores and ranks. # Task Description Implement a `StudentScoresManager` class to manage and analyze student scores. The `StudentScoresManager` class should provide the following functionalities: 1. Add a new student. 2. Add a score for a student. 3. Retrieve the average score of a student. 4. Retrieve the student with the highest average score. # Input and Output Formats `StudentScoresManager` class should have the following methods: - `add_student(name: str)`: Adds a new student with the given name. - `add_score(name: str, score: float)`: Adds a new score for the specified student. - `get_average_score(name: str) -> float`: Returns the average score of the specified student. - `get_highest_average_score() -> str`: Returns the name of the student with the highest average score. # Constraints - Student names are unique. - Scores are floating-point numbers. - There will not be more than (10^5) students. - Each student will not have more than (10^3) scores. # Example ```python score_manager = StudentScoresManager() score_manager.add_student(\\"Alice\\") score_manager.add_student(\\"Bob\\") score_manager.add_score(\\"Alice\\", 95.0) score_manager.add_score(\\"Alice\\", 85.0) score_manager.add_score(\\"Bob\\", 90.0) score_manager.add_score(\\"Bob\\", 88.0) assert score_manager.get_average_score(\\"Alice\\") == 90.0 assert score_manager.get_average_score(\\"Bob\\") == 89.0 assert score_manager.get_highest_average_score() == \\"Alice\\" ``` # Requirements Ensure that your implementation is efficient and handles all edge cases appropriately.","solution":"class StudentScoresManager: def __init__(self): self.students = {} def add_student(self, name: str): if name not in self.students: self.students[name] = [] def add_score(self, name: str, score: float): if name in self.students: self.students[name].append(score) def get_average_score(self, name: str) -> float: if name in self.students: scores = self.students[name] if scores: return sum(scores) / len(scores) return 0.0 def get_highest_average_score(self) -> str: highest_avg = float(\'-inf\') top_student = None for name, scores in self.students.items(): if scores: avg_score = sum(scores) / len(scores) if avg_score > highest_avg: highest_avg = avg_score top_student = name return top_student"},{"question":"# Problem Statement You are given a dictionary where the keys are string names, and the values are lists of integers representing scores obtained by people in different activities. Your task is to implement a function `top_performers(scores, N)` that returns a list of top `N` performers based on their average score. If multiple performers have the same average score, they should be ranked by their name in alphabetical order. # Function Signature ```python def top_performers(scores: Dict[str, List[int]], N: int) -> List[str]: ... ``` # Input * `scores`: A dictionary where each key is a string representing a person\'s name and the corresponding value is a list of integers representing their scores. * `N`: An integer representing the number of top performers to return. # Output * A list of strings representing the names of the top `N` performers sorted based on their average score and then alphabetically by name. # Constraints * The `scores` dictionary contains between 0 and 1000 entries. * Each list of scores contains between 1 and 100 integers. * Each score is between 0 and 100. * `N` is a positive integer not greater than the number of entries in `scores`. # Example ```python input_scores = { \\"Alice\\": [90, 80, 70], \\"Bob\\": [100, 85, 90], \\"Charlie\\": [60, 100, 90], \\"David\\": [80, 90, 95], \\"Eve\\": [100, 100, 100] } print(top_performers(input_scores, 3)) # Output: [\\"Eve\\", \\"Bob\\", \\"David\\"] input_scores = { \\"Zara\\": [50, 60, 70], \\"Yan\\": [70, 80, 90] } print(top_performers(input_scores, 1)) # Output: [\\"Yan\\"] ``` # Guidelines * Your function should include error handling if `N` is greater than the number of entries in `scores`. * Consider edge cases such as an empty `scores` dictionary or lists with identical average scores. * Optimize the function to handle up to 1000 entries efficiently.","solution":"from typing import Dict, List def top_performers(scores: Dict[str, List[int]], N: int) -> List[str]: if N > len(scores): raise ValueError(\\"N cannot be greater than the number of entries in scores\\") average_scores = {name: sum(values) / len(values) for name, values in scores.items()} sorted_performers = sorted(average_scores.items(), key=lambda item: (-item[1], item[0])) return [name for name, _ in sorted_performers[:N]]"},{"question":"# Problem Statement: You are tasked with designing a rate limiter for an API. The rate limiter should allow a maximum number of requests within a given time frame. Implement the rate limiter using the Token Bucket Algorithm in Python. Your solution should encapsulate the algorithm in a class with the following specifications: # Class Specification: ```python class RateLimiter: def __init__(self, max_requests: int, refill_time: int): Initializes the RateLimiter with a maximum number of requests allowed and the refill time in seconds. :param max_requests: The maximum number of requests allowed within the given time frame (refill_time). :param refill_time: The time frame in seconds within which the requests are counted. self.max_requests = max_requests self.refill_time = refill_time def allow_request(self) -> bool: Determines if a new request can be allowed under the current rate limiting conditions. :return: True if the request is allowed, False otherwise. ``` 1. `__init__(self, max_requests: int, refill_time: int)` - Initializes the rate limiter to allow up to `max_requests` within `refill_time` seconds. 2. `allow_request(self) -> bool` - Returns `True` if a request is allowed under the current rate limiting conditions, otherwise returns `False`. # Example: ```python import time rate_limiter = RateLimiter(5, 10) print(rate_limiter.allow_request()) # Expected: True print(rate_limiter.allow_request()) # Expected: True # simulate 5 quick requests for _ in range(3): print(rate_limiter.allow_request()) # Expected: True, True, True print(rate_limiter.allow_request()) # Expected: False (since 5 requests already made) # wait for the refill time to pass time.sleep(10) print(rate_limiter.allow_request()) # Expected: True (refilled) ``` # Constraints: * The `allow_request` method should be thread-safe to ensure correctness in a multithreaded environment. * The maximum number of requests (max_requests) will always be a positive integer. * The refill time (refill_time) is always provided in seconds as a positive integer.","solution":"import time import threading class RateLimiter: def __init__(self, max_requests: int, refill_time: int): Initializes the RateLimiter with a maximum number of requests allowed and the refill time in seconds. :param max_requests: The maximum number of requests allowed within the given time frame (refill_time). :param refill_time: The time frame in seconds within which the requests are counted. self.max_requests = max_requests self.refill_time = refill_time self.tokens = max_requests self.last_refill_timestamp = time.monotonic() self.lock = threading.Lock() def allow_request(self) -> bool: Determines if a new request can be allowed under the current rate limiting conditions. :return: True if the request is allowed, False otherwise. with self.lock: current_timestamp = time.monotonic() time_passed = current_timestamp - self.last_refill_timestamp # Calculate how many tokens to refill tokens_to_add = (time_passed / self.refill_time) * self.max_requests if tokens_to_add > 0: self.tokens = min(self.max_requests, self.tokens + tokens_to_add) self.last_refill_timestamp = current_timestamp if self.tokens >= 1: self.tokens -= 1 return True else: return False"},{"question":"# Scenario You are developing a caching system that frequently requires item retrieval based on the least recently used (LRU) policy. To ensure high performance, the cache must efficiently manage item accesses and evictions. # Task You are required to write a class called `LRUCache` that implements an LRU caching mechanism. Your implementation should support the following operations: 1. `get(key)`: Retrieve the value associated with the `key` if it exists in the cache, otherwise return `-1`. 2. `put(key, value)`: Insert a new item into the cache or update the value of an existing item. If the cache exceeds its capacity, evict the least recently used item before inserting the new item. # Requirements * **Input**: - An integer `capacity` representing the maximum number of items the cache can hold, e.g., `2`. - For `get` and `put` operations, integer keys and values, e.g., `get(1)` or `put(1, 100)`. * **Output**: - For `get` operations, return the value associated with the key or `-1` if the key is not found. - For `put` operations, manage the cache state accordingly with no return value. * **Constraints**: - Max capacity of the cache is between 1 and 10^3. - The key and value are integers. - Avoid using Python built-in ordered dictionary directly. Here\'s the class definition: ```python class LRUCache: def __init__(self, capacity: int): # Initialize the cache with the given capacity pass def get(self, key: int) -> int: # Retrieve the value associated with the key pass def put(self, key: int, value: int) -> None: # Update the cache with the key-value pair pass ``` # Example ```python >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) -1 >>> cache.put(4, 4) # evicts key 1 >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 ``` # Notes 1. Consider using data structures that optimize for average O(1) time complexity for get and put operations. 2. Ensure your implementation is efficient in terms of both time and memory. 3. Provide inline documentation explaining your logic and approach. 4. Make sure your class adheres to standard object-oriented practices, and thoroughly test your solution against various edge cases.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) # mark as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) # mark as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # pop the least recently used item"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},O={class:"card-container"},L={key:0,class:"empty-state"},R=["disabled"],z={key:0},P={key:1};function D(r,e,l,m,s,a){const p=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const j=h(N,[["render",D],["__scopeId","data-v-c5cda067"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/10.md","filePath":"drive/10.md"}'),Y={name:"drive/10.md"},U=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{B as __pageData,U as default};
