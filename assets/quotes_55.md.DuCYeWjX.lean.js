import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-012354a0"]]),S=JSON.parse('[{"question":"# Sum of Unique Squares Write a function that takes a list of integers as input and returns the sum of squares of the unique (non-duplicate) integers in the list. **Function Signature**: ```python def sum_of_unique_squares(numbers: list[int]) -> int: ``` **Input**: * `numbers`: A list of integers. **Output**: * Return the sum of squares of the unique integers in the list. **Constraints**: * The input list `numbers` will have at most 10^5 elements. * Each element in `numbers` will be between -10^3 to 10^3, inclusive. * The function should raise a `TypeError` if `numbers` is not a list of integers. **Examples**: * `sum_of_unique_squares([1, 2, 2, 3])` should return `1^2 + 3^2 = 1 + 9 = 10` * `sum_of_unique_squares([0, 0, -1, 1])` should return `(-1)^2 + 1^2 = 1 + 1 = 2` * `sum_of_unique_squares([1, 1, 1, 1, 1])` should return `0` (no unique elements) * `sum_of_unique_squares([-2, -1, 1, 2, -2])` should return `(-1)^2 + 1^2 + 2^2 = 1 + 1 + 4 = 6` * `sum_of_unique_squares([])` should return `0` (empty list) **Requirements**: * Ensure that the implementation efficiently handles large lists. * Handle non-integer inputs within the list by raising a `TypeError`.","solution":"def sum_of_unique_squares(numbers: list[int]) -> int: Returns the sum of squares of the unique integers in the list. :param numbers: A list of integers. :return: Sum of squares of unique integers in the list. :raises TypeError: If the input is not a list of integers. if not isinstance(numbers, list): raise TypeError(\\"Input must be a list.\\") for num in numbers: if not isinstance(num, int): raise TypeError(\\"All elements in the list must be integers.\\") from collections import Counter counter = Counter(numbers) unique_integers = [num for num, count in counter.items() if count == 1] return sum(num ** 2 for num in unique_integers)"},{"question":"# Problem Statement # Course Schedule You are given an integer `numCourses` representing the number of courses you need to take, labeled from 0 to `numCourses - 1`. You are also given a list of `prerequisites` where prerequisites[i] = [ai, bi] indicates that you must take course `bi` before course `ai`. Determine if it is possible to finish all courses. Return `true` if you can finish all courses, or `false` otherwise. **Input:** * an integer `numCourses`: the number of courses (1 <= numCourses <= 1000). * a list of integers `prerequisites`: a list of pairs of integers where each pair represents a dependency. **Output:** * a boolean value indicating whether it is possible to complete all courses. **Example:** ```practical Input: numCourses = 4 prerequisites = [[1,0], [2,0], [3,1], [3,2]] Output: True ``` In this example, it is possible to complete all courses. One way to complete the courses is: - Take course 0. - Take course 1. - Take course 2. - Take course 3. **Example:** ```practical Input: numCourses = 2 prerequisites = [[1,0], [0,1]] Output: False ``` In this example, it is impossible to complete all courses due to the cycle in the prerequisites. # Constraints: * The list of prerequisites can be empty, meaning there are no prerequisites for any course. * There are no duplicate pairs in the list of prerequisites. # Task: 1. Implement a function `can_finish` that determines if you can finish all courses. 2. Ensure your solution follows the provided input and output formats. 3. Your function should efficiently handle the constraints provided. # Function Signature: ```python def can_finish(numCourses: int, prerequisites: List[List[int]]) -> bool: # your code here ``` **Note:** Consider edge cases, such as an empty list of prerequisites, and ensure your code handles them gracefully. Optimize your solution to manage the given input constraints effectively.","solution":"from typing import List def can_finish(numCourses: int, prerequisites: List[List[int]]) -> bool: from collections import defaultdict, deque # Create adjacency list and in-degree count adj_list = defaultdict(list) indegree = [0] * numCourses # Build the graph for dest, src in prerequisites: adj_list[src].append(dest) indegree[dest] += 1 # Find all the courses with no prerequisites zero_indegree_queue = deque([i for i in range(numCourses) if indegree[i] == 0]) # Count of courses for which prerequisites are satisfied satisfied_courses = 0 # Process nodes with no prerequisites while zero_indegree_queue: course = zero_indegree_queue.popleft() satisfied_courses += 1 # Decrease the in-degree of adjacent courses by 1 for neighbor in adj_list[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If the number of satisfied courses matches the total courses, it\'s possible to finish all courses return satisfied_courses == numCourses"},{"question":"Problem Statement You are given a string containing only lowercase letters and a dictionary specifying point values for each letter. Your task is to implement a function `max_points_sentence` that returns the maximum possible points for any word formed from the string. Words are defined by sequences of contiguous letters. # Function Signature ```python def max_points_sentence(s: str, points_dict: dict[str, int]) -> int: pass ``` # Input - `s`: A string consisting of only lowercase letters, with length `len(s) <= 10^5`. - `points_dict`: A dictionary where the keys are individual lowercase letters and the values are their corresponding point values. # Output - Returns an integer representing the maximum points for any word that can be formed from the string. # Constraints - Each letter in the string can appear multiple times. - Each letter in the string will always have a defined point value in `points_dict`. - Dictionary length will be exactly 26 elements (covering all lowercase letters). # Example Example 1: ```python s = \\"abcabc\\" points_dict = {\'a\': 1, \'b\': 3, \'c\': 2} max_points_sentence(s, points_dict) ``` **Output**: `6` *Explanation: The word \\"abcabc\\" gives the highest points, i.e., `1 + 3 + 2 + 1 + 3 + 2 = 12`. Example 2: ```python s = \\"xyz\\" points_dict = {\'x\': 5, \'y\': 1, \'z\': 7} max_points_sentence(s, points_dict) ``` **Output**: `13` *Explanation: The word \\"xyz\\" forms the word with the maximum points, i.e., `5 + 1 + 7 = 13`. Example 3: ```python s = \\"zzz\\" points_dict = {\'z\': 2, \'y\': 8, \'x\': 10} max_points_sentence(s, points_dict) ``` **Output**: `6` *Explanation: The word \\"zzz\\" gives the total points of `2 + 2 + 2 = 6`. # Additional Requirements - Your implementation should efficiently handle long strings. # Hints - Think about how you can traverse through the string and keep track of the maximum points using given values. - Consider using a sliding window approach or dynamic programming to calculate the maximum possible points.","solution":"def max_points_sentence(s: str, points_dict: dict[str, int]) -> int: Returns the maximum possible points for any word formed from the string. max_points = 0 current_points = 0 for char in s: current_points += points_dict[char] if current_points > max_points: max_points = current_points return max_points"},{"question":"[New Question]: # Subarray with Given Sum **Context:** You are required to find a contiguous subarray in an integer list that adds up to a given sum `S`. This is a common problem in array manipulation and has many applications in data analysis. **Problem:** Write a function `find_subarray_with_sum(array: List[int], sum: int) -> Optional[Tuple[int, int]]` to identify the starting and ending indices of a contiguous subarray that sums to a given value. **Requirements:** * **Input:** - `array` (List[int]): A list of integers. - `sum` (int): The target sum to be achieved by the subarray. * **Output:** - A tuple `(start_index, end_index)` if such a subarray is found. - `None` if no such subarray exists. **Constraints:** * `array` will have a length between 1 and 1000. * Each element in `array` will be an integer between -10^6 and 10^6. * The sum will be an integer within the same range. **Example:** ```python from typing import List, Optional, Tuple def find_subarray_with_sum(array: List[int], sum: int) -> Optional[Tuple[int, int]]: # Your implementation here pass # Example test cases array = [1, 2, 3, 7, 5] sum = 12 result = find_subarray_with_sum(array, sum) print(result) # Output: (1, 3) array = [1, 2, 3, 4, 5] sum = 9 result = find_subarray_with_sum(array, sum) print(result) # Output: (1, 3) array = [1, 2, 3, 4, 5] sum = 20 result = find_subarray_with_sum(array, sum) print(result) # Output: None ``` # Notes: * Your solution should efficiently handle arrays with up to 1000 elements. * The function should return indices such that the subarray from `array[start_index]` to `array[end_index]` (inclusive) sums to the given `sum`. * If there are multiple possible answers, any correct subarray can be returned. * Utilize techniques such as the sliding window approach to achieve optimal performance. Good Luck!","solution":"from typing import List, Optional, Tuple def find_subarray_with_sum(array: List[int], target_sum: int) -> Optional[Tuple[int, int]]: Finds a contiguous subarray which sums to the given target_sum. Parameters: - array: List[int], A list of integers. - target_sum: int, The target sum to be achieved by the subarray. Returns: - Tuple[int, int]: The starting and ending indices of the subarray that sums to target_sum. - None: If no such subarray is found. current_sum = 0 start_index = 0 sum_map = {} for end_index, value in enumerate(array): current_sum += value if current_sum == target_sum: return (start_index, end_index) if current_sum - target_sum in sum_map: return (sum_map[current_sum - target_sum] + 1, end_index) sum_map[current_sum] = end_index return None"},{"question":"# Coding Task: Implement a Max-Pooling Operation # Background: Max-pooling is a downsampling operation commonly used in convolutional neural networks to reduce spatial dimensions and extract dominant features. It works by dividing the input into non-overlapping rectangular regions and outputting the maximum value from each region. # Task: Implement the **Max-Pooling** function. For a given input 2D matrix (list of lists) and a pool size, the function should perform the max-pooling operation with a stride equal to the pool size. The pooling operation should extract non-overlapping patches, find the maximum value in each patch, and generate a downsampled matrix as the output. # Function Signature: ```python def max_pooling(matrix: list[list[float]], pool_size: int) -> np.array: pass ``` # Input: - A 2D matrix represented as a list of lists of real numbers. - An integer `pool_size` which determines the size of the pooling window. # Output: - A NumPy array representing the downsampled matrix after applying the max-pooling operation. # Examples: ```python >>> max_pooling([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 2) array([[ 6, 8], [14, 16]]) >>> max_pooling([[1, 3, 2, 4], [5, 6, 7, 8], [9, 11, 12, 14], [13, 15, 10, 16]], 2) array([[ 6, 8], [15, 16]]) ``` # Constraints: - The input matrix has dimensions `m x n`, where `1 <= m, n <= 100`. - Each element in the matrix is a real number in the range of -10^6 to 10^6. - The `pool_size` is a positive integer and a divisor of both `m` and `n`. # Notes: - Ensure your implementation converts the input matrix to a NumPy array if it is not already one. - Consider edge cases such as small matrix sizes and pool sizes that match the matrix dimensions. - If `m` or `n` are not divisible by `pool_size`, the function should raise a ValueError.","solution":"import numpy as np def max_pooling(matrix: list[list[float]], pool_size: int) -> np.array: Perform max-pooling operation on a 2D matrix with the given pool size. matrix = np.array(matrix) m, n = matrix.shape if m % pool_size != 0 or n % pool_size != 0: raise ValueError(\\"The pool_size must be a divisor of both dimensions of the matrix\\") pooled_matrix = [] for i in range(0, m, pool_size): row = [] for j in range(0, n, pool_size): patch = matrix[i:i+pool_size, j:j+pool_size] max_value = patch.max() row.append(max_value) pooled_matrix.append(row) return np.array(pooled_matrix)"},{"question":"# Task: Implement a Modified Quick Sort for Nearly Sorted Arrays Scenario You are presented with an algorithm challenge to implement a modified version of the Quick Sort algorithm. This variant should take advantage of the input array\'s almost sorted nature. The task requires you to create an algorithm that optimizes typical Quick Sort by employing a mechanism to detect and capitalize on the nearly sorted order of the array. Core Requirements Enhance the standard Quick Sort algorithm to achieve the following: 1. **Adaptative Partitioning**: Modify the partitioning step to identify if the subarray is already in order and skip unnecessary recursive sorting. 2. **Optimized Pivot Selection**: Include an enhancement for pivot selection that leverages the array\'s near-sorted state. 3. **Threshold for Insertion Sort**: Incorporate a threshold where if the size of the subarray is smaller than a pre-defined limit, an Insertion Sort is used instead of Quick Sort for better performance. Function Specifications You need to implement one function: 1. `modified_quick_sort(array: list, threshold: int = 10) -> None` Input - `array` (list): The list of elements to be sorted. - `threshold` (int): The size below which Insertion Sort is used instead of Quick Sort. The default value is 10, and it must be positive. Output - The function sorts the provided list in place. Constraints - The algorithm should be efficient for a broad range of input sizes, especially for nearly sorted arrays. - Handle edge cases like already sorted arrays, reverse sorted arrays, and arrays with all identical elements. - The threshold parameter must be positive. Performance Requirements - The code should run with an average time complexity of (O(n log n)), and the worst-case scenario should be better than standard Quick Sort due to the detection of nearly sorted subarrays. - Space complexity should remain within (O(log n)) for the recursion stack. Example ```python # example usage arr = [1, 2, 3, 5, 4, 6, 7, 8] modified_quick_sort(arr) print(arr) # Output should be: [1, 2, 3, 4, 5, 6, 7, 8] arr2 = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] modified_quick_sort(arr2) print(arr2) # Output should be: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ```","solution":"def insertion_sort(arr, left, right): Helper function to perform insertion sort on a subarray from left to right. for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def modified_partition(arr, low, high): Partition the array for quicksort using median-of-three method. mid = (low + high) // 2 if arr[mid] < arr[low]: arr[low], arr[mid] = arr[mid], arr[low] if arr[high] < arr[low]: arr[low], arr[high] = arr[high], arr[low] if arr[high] < arr[mid]: arr[mid], arr[high] = arr[high], arr[mid] arr[mid], arr[high - 1] = arr[high - 1], arr[mid] pivot = arr[high - 1] i = low for j in range(low, high - 1): if arr[j] <= pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high - 1] = arr[high - 1], arr[i] return i def modified_quick_sort_rec(arr, low, high, threshold): The recursive quicksort function with a threshold for insertion sort. if high - low <= threshold: insertion_sort(arr, low, high) else: if low < high: pivot_index = modified_partition(arr, low, high) modified_quick_sort_rec(arr, low, pivot_index - 1, threshold) modified_quick_sort_rec(arr, pivot_index + 1, high, threshold) def modified_quick_sort(arr, threshold=10): Function to perform the modified quick sort with threshold for insertion sort. if threshold <= 0: raise ValueError(\\"Threshold must be positive\\") modified_quick_sort_rec(arr, 0, len(arr) - 1, threshold)"},{"question":"# Coding Assessment Question Context: You are developing a library of functions related to matrices. An important feature of this library involves implementing the Strassen algorithm to multiply two matrices efficiently. Task: Implement the function `strassen_multiplication`, which multiplies two square matrices (of dimension 2^n x 2^n) using Strassen\'s algorithm. This algorithm should be more efficient than the conventional matrix multiplication for large matrices, achieving a time complexity of approximately (O(n^{2.81})). Specifically, you need to: 1. Divide the input matrices into submatrices. 2. Recursively apply Strassen\'s algorithm to these submatrices. 3. Combine the submatrices to get the final product. Function Signature ```python def strassen_multiplication(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: Multiplies two 2^n x 2^n matrices using Strassen\'s algorithm. Args: matrix_a (list of list of int): The first matrix to be multiplied. matrix_b (list of list of int): The second matrix to be multiplied. Returns: list of list of int: The product of the two matrices. ``` Expected Inputs and Outputs - Input: Two matrices, `matrix_a` and `matrix_b`, each being a list of lists of integers. - Output: A single matrix (list of lists) representing the product. Constraints - Both input matrices will be of dimensions 2^n x 2^n where n >= 1. - Ensure to handle the base case of the recursion properly. - You may assume all elements in the matrices are well-formed integers. Example ```python matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [5, 6], [7, 8] ] product = strassen_multiplication(matrix_a, matrix_b) # Expected output: # product should be: # [ # [19, 22], # [43, 50] # ] ``` Notes - You are allowed to use any helper functions if necessary. - Pay attention to the efficiency and ensure that the recursion terminates correctly. - Test your implementation with various matrix sizes to guarantee correctness and performance. - Use modular programming practices to keep your code organized and readable.","solution":"def add_matrices(matrix_a, matrix_b): size = len(matrix_a) return [[matrix_a[i][j] + matrix_b[i][j] for j in range(size)] for i in range(size)] def subtract_matrices(matrix_a, matrix_b): size = len(matrix_a) return [[matrix_a[i][j] - matrix_b[i][j] for j in range(size)] for i in range(size)] def split_matrix(matrix): mid = len(matrix) // 2 a11 = [row[:mid] for row in matrix[:mid]] a12 = [row[mid:] for row in matrix[:mid]] a21 = [row[:mid] for row in matrix[mid:]] a22 = [row[mid:] for row in matrix[mid:]] return a11, a12, a21, a22 def merge_matrices(a11, a12, a21, a22): top = [a11_row + a12_row for a11_row, a12_row in zip(a11, a12)] bottom = [a21_row + a22_row for a21_row, a22_row in zip(a21, a22)] return top + bottom def strassen_multiplication(matrix_a, matrix_b): size = len(matrix_a) if size == 1: return [[matrix_a[0][0] * matrix_b[0][0]]] a11, a12, a21, a22 = split_matrix(matrix_a) b11, b12, b21, b22 = split_matrix(matrix_b) m1 = strassen_multiplication(add_matrices(a11, a22), add_matrices(b11, b22)) m2 = strassen_multiplication(add_matrices(a21, a22), b11) m3 = strassen_multiplication(a11, subtract_matrices(b12, b22)) m4 = strassen_multiplication(a22, subtract_matrices(b21, b11)) m5 = strassen_multiplication(add_matrices(a11, a12), b22) m6 = strassen_multiplication(subtract_matrices(a21, a11), add_matrices(b11, b12)) m7 = strassen_multiplication(subtract_matrices(a12, a22), add_matrices(b21, b22)) c11 = add_matrices(subtract_matrices(add_matrices(m1, m4), m5), m7) c12 = add_matrices(m3, m5) c21 = add_matrices(m2, m4) c22 = add_matrices(subtract_matrices(add_matrices(m1, m3), m2), m6) return merge_matrices(c11, c12, c21, c22)"},{"question":"# **Question: Incremental Array Partitioning** You are provided with a sequence of numbers (a 1D array) and an integer `k`. Your task is to partition the array into the smallest number of contiguous subarrays, such that the sum of each subarray is at most `k`. Requirements 1. Implement the function `partition_array(arr, k)`. 2. Optimally and correctly partition the array to achieve the objective. Constraints 1. All elements in the input array `arr` are non-negative integers. 2. The integer `k` is a positive integer. 3. It is guaranteed that all elements in the input array are less than or equal to `k`. Input - `arr`: A list of non-negative integers. - `k`: A positive integer. Output - Returns a list of lists, where each inner list is a subarray of contiguous elements from the original array. - Each subarray\'s sum must be less than or equal to `k`. # Example ```python arr = [1, 2, 3, 4, 5] k = 5 print(partition_array(arr, k)) # Output: [[1, 2], [3], [4], [5]] arr = [7, 2, 1, 3, 8] k = 10 print(partition_array(arr, k)) # Output: [[7, 2, 1], [3], [8]] arr = [5, 5, 5, 6] k = 10 print(partition_array(arr, k)) # Output: [[5, 5], [5], [6]] ``` # Requirements * Implement the `partition_array` function. * Ensure proper handling of edge cases. * Maintain efficient time and space complexity.","solution":"def partition_array(arr, k): Partitions the array into the smallest number of contiguous subarrays, such that the sum of each subarray is at most k. :param arr: List[int] - The input array of non-negative integers. :param k: int - The maximum allowed subarray sum. :return: List[List[int]] - A list of lists where each inner list is a contiguous subarray with sum <= k. result = [] current_subarray = [] current_sum = 0 for num in arr: if current_sum + num > k: result.append(current_subarray) current_subarray = [num] current_sum = num else: current_subarray.append(num) current_sum += num if current_subarray: result.append(current_subarray) return result"},{"question":"# Problem: Enhanced Stack with Max API **Scenario**: You have been employed by a software company that deals with large datasets and requires a stack that supports not only the usual operations of push and pop, but also a constant time max operation. Your task is to implement this enhanced stack with the added functionality. # Function to Implement: Implement the `EnhancedStack` class with the following methods: 1. **push(value: int)**: * **Input**: An integer `value` to be added to the stack. * **Output**: This method does not return any value but should correctly add the `value` to the stack. 2. **pop()**: * **Output**: Returns the top element of the stack if it is not empty, otherwise return `None`. 3. **max()**: * **Output**: Returns the maximum value in the stack if it is not empty, otherwise return `None`. # Constraints: * The stack operations `push`, `pop`, and `max` should have a time complexity of O(1). ```python class EnhancedStack: def __init__(self): Initialize your data structure here. pass def push(self, value: int) -> None: Push element value onto stack. pass def pop(self) -> int: Removes the element on the top of the stack and returns that element. pass def max(self) -> int: Get the maximum element in the stack. pass ``` # Example: ```python # Initialize an empty stack stack = EnhancedStack() # Push elements to the stack stack.push(5) stack.push(1) stack.push(5) # Get the maximum value in the stack print(stack.max()) # Output: 5 # Remove the top element from the stack print(stack.pop()) # Output: 5 # Get the maximum value in the stack print(stack.max()) # Output: 5 # Remove the top element from the stack print(stack.pop()) # Output: 1 # Get the maximum value in the stack print(stack.max()) # Output: 5 # Remove the top element from the stack print(stack.pop()) # Output: 5 # Get the maximum value in the stack print(stack.max()) # Output: None ``` # Note: * Use additional data structures if needed to maintain the maximum element efficiently.","solution":"class EnhancedStack: def __init__(self): Initialize your data structure here. self.stack = [] self.max_stack = [] def push(self, value: int) -> None: Push element value onto stack. self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self) -> int: Removes the element on the top of the stack and returns that element. if not self.stack: return None popped_value = self.stack.pop() if popped_value == self.max_stack[-1]: self.max_stack.pop() return popped_value def max(self) -> int: Get the maximum element in the stack. if not self.max_stack: return None return self.max_stack[-1]"},{"question":"# Scenario You are part of a development team for a popular social media platform. The platform needs an efficient way to determine the most frequent words used in user posts over a given period. Your task is to write a function that lists the top `k` most frequent words in descending order of their frequency, breaking ties by lexicographical order. # Problem Statement Given a list of strings representing user posts and an integer `k`, you are to write a function `top_k_frequent_words(posts: List[str], k: int) -> List[str]` that returns the `k` most frequent words. The function should handle the following operations efficiently: 1. Tokenize the user posts into individual words. 2. Count the frequency of each word. 3. Return the top `k` most frequent words sorted by their frequency in descending order. In case of ties, the words should be sorted in lexicographical order. # Input * `posts` (List of Strings): A list of strings where each string represents a user post. * `k` (Integer): The number of top frequent words to return. # Output * Return a list of the top `k` most frequent words as strings. # Example ```python >>> top_k_frequent_words([\\"hello world\\", \\"hello\\", \\"hello hi\\"], 2) [\'hello\', \'hi\'] >>> top_k_frequent_words([\\"this is a test\\", \\"test this out\\", \\"this is good\\"], 3) [\'this\', \'is\', \'test\'] >>> top_k_frequent_words([\\"a\\", \\"b\\", \\"a\\", \\"b\\", \\"c\\"], 2) [\'a\', \'b\'] ``` # Constraints * The words are case-sensitive; \\"Hello\\" and \\"hello\\" are considered different words. * 1 ≤ len(posts) ≤ 10^4 * 1 ≤ len(each post) ≤ 10^5 * The function should be optimized for large inputs, both in terms of time and space complexity. # Note Consider using data structures like heaps or PriorityQueue to maintain the top k elements efficiently during the counting process.","solution":"from collections import Counter import heapq def top_k_frequent_words(posts, k): Returns the top k most frequent words in descending order of their frequency. In case of ties, words are sorted in lexicographical order. # Tokenize the posts into words words = [] for post in posts: words.extend(post.split()) # Count frequencies of each word count = Counter(words) # Use a heap to get the top k elements heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) # Extract the elements from the heap result = [] for _ in range(k): freq, word = heapq.heappop(heap) result.append(word) return result"},{"question":"# Problem Statement A fictional cryptocurrency engine needs optimization for transaction validation. One critical functionality is to ensure that an array of transaction amounts follows a strictly increasing pattern, to prevent duplicate or erroneous entries. Write a function `is_strictly_increasing` that checks if a given list of integers (representing transaction amounts) is strictly increasing. A list is said to be strictly increasing if every element is greater than the preceding one. # Function Signature ```python def is_strictly_increasing(transactions: list[int]) -> bool: ``` # Input - `transactions` (list[int]): A list of integers representing the series of transaction amounts. The list can be empty or contain up to 10^5 elements. # Output - Returns a boolean value: `True` if the list of transaction amounts is strictly increasing, `False` otherwise. # Constraints - The list elements can be anywhere in the range of -10^9 to 10^9. - The function must handle the edge cases, such as: * An empty list (which should return `True` as there\'s no violation of strict increase). # Examples ```python >>> is_strictly_increasing([1, 2, 3, 4, 5]) True >>> is_strictly_increasing([5, 3, 6]) False >>> is_strictly_increasing([-1, 0, 1, 2]) True >>> is_strictly_increasing([100]) True >>> is_strictly_increasing([]) True >>> is_strictly_increasing([10, 20, 20]) False >>> is_strictly_increasing([1, 100, 50]) False ``` # Hints - Consider edge cases where the list might be empty or have only one element. - Think about the simplest and most efficient way to check the strictly increasing property. - The solution should be optimal for the upper constraint of 10^5 elements.","solution":"def is_strictly_increasing(transactions: list[int]) -> bool: Checks if the given list of transaction amounts is strictly increasing. Parameters: transactions (list[int]): A list of integers representing the series of transaction amounts. Returns: bool: True if the list is strictly increasing, False otherwise. for i in range(1, len(transactions)): if transactions[i] <= transactions[i - 1]: return False return True"},{"question":"# Scenario As a software developer for a logistics company, you are tasked with optimizing the cargo loading process of delivery trucks. Each truck has a maximum weight capacity, and the company has a set of packages each with a specific weight. You need to determine the maximum total weight of packages that can be loaded onto a truck without exceeding the weight limit. # Problem Statement Implement the function `max_weight_packages(weights: list, capacity: int) -> int` to compute the maximum weight that can be loaded onto the truck without exceeding its weight capacity. Input: * `weights`: A list of integers where each integer represents the weight of a package. * `capacity`: An integer representing the maximum weight capacity of the truck. Output: * An integer representing the maximum total weight of packages that can be loaded without exceeding the truck\'s weight capacity. Constraints: * The number of packages (length of the weights list) can be very large (up to 10,000). * Each package has a weight between 1 and 10,000. * The truck\'s capacity is a positive integer up to 100,000. Example: ```python weights = [2, 3, 4, 5, 9] capacity = 10 print(max_weight_packages(weights, capacity)) # Output: 10 ``` # Notes: - Your solution should be efficient and handle large input sizes gracefully. - It is acceptable to use a dynamic programming approach or a greedy algorithm if it fits the problem constraints.","solution":"def max_weight_packages(weights, capacity): Returns the maximum weight that can be loaded onto the truck without exceeding its weight capacity. n = len(weights) dp = [0] * (capacity + 1) for weight in weights: for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + weight) return dp[capacity]"},{"question":"# Question: Implement a Class for Two Sum You are required to implement a Python class that provides a method to find two numbers in a list that add up to a target sum. The class should be designed to handle multiple queries efficiently by storing the list and allowing search operations based on different target sums. Requirements: 1. Implement a class named `TwoSum`. 2. Add an `__init__` method to initialize the list storage. 3. Implement a method `add(number: int) -> None` that adds a number to the internal list. 4. Implement a method `find(target: int) -> bool` that returns `True` if there are any two distinct numbers in the internal list that add up to the specified target sum, and `False` otherwise. 5. Ensure that your solution handles multiple add and find operations efficiently. 6. Handle edge cases gracefully (e.g., no two numbers can sum to the target). Input: * The `add` method takes a single integer `number`. * The `find` method takes a single integer `target` which represents the desired sum. Output: * The `add` method does not return a value. * The `find` method returns a boolean indicating whether two distinct numbers sum to the target. Constraints: * The input `number` for `add` will be an integer. * The input `target` for `find` will be an integer. * Optimize for efficient addition and search operations. Example: ```python >>> two_sum = TwoSum() >>> two_sum.add(1) >>> two_sum.add(3) >>> two_sum.add(5) >>> two_sum.find(4) True >>> two_sum.find(7) False >>> two_sum.add(2) >>> two_sum.find(7) True >>> two_sum.find(10) False ``` Your implementation should ensure efficient searching and addition operations, maintaining the capability to handle multiple addition and query requests optimally.","solution":"class TwoSum: def __init__(self): Initialize the internal data structure. self.numbers = {} def add(self, number: int) -> None: Add a number to the internal data structure. if number in self.numbers: self.numbers[number] += 1 else: self.numbers[number] = 1 def find(self, target: int) -> bool: Find if there exists any pair of numbers which sum is equal to the target. for num in self.numbers: complement = target - num if complement in self.numbers: if complement != num or (complement == num and self.numbers[num] > 1): return True return False"},{"question":"# Coding Assessment Question Scenario: You are writing a file management utility to help users with various file operations. One of the features is merging multiple sorted text files into a single sorted file without loading the entire contents of any file into memory at once. The files may contain a very large number of integers, each separated by a newline character. You need to merge these files such that the integers in the resulting file are in non-decreasing order. Task Write a function that merges multiple sorted text files into a single sorted file. You should read and write to the files line by line to handle potentially large file sizes efficiently. Function Signature ```python def merge_sorted_files(file_paths: List[str], output_path: str): Merge multiple sorted text files into a single sorted file. :param file_paths: List of file paths to be merged. :param output_path: The path of the output file. ``` Inputs and Outputs * **Input Format**: * `file_paths`: A list of strings representing the paths to the sorted input files. * `output_path`: A string representing the path to the output file. * **Output Format**: * The function should not return a value but should create a new file at `output_path` with the merged and sorted contents from the input files. Constraints * The files are large, so the merge operation should be memory-efficient. * Each input file is sorted in non-decreasing order. * All integers in the file are separated by newline characters. * The list `file_paths` will have at least two files. Performance Requirements * Efficiently handle large file sizes without reading all files into memory. Example Consider the following files: * `file1.txt` ``` 1 4 7 10 ``` * `file2.txt` ``` 2 3 6 8 ``` * `file3.txt` ``` 0 5 9 11 ``` ```python merge_sorted_files([\'file1.txt\', \'file2.txt\', \'file3.txt\'], \'output.txt\') ``` The resulting `output.txt` should contain: ``` 0 1 2 3 4 5 6 7 8 9 10 11 ``` Evaluation Criteria: 1. Correctness: The output file should contain all integers from the input files, sorted in non-decreasing order. 2. Efficiency: Ensure the solution handles large files without consuming excessive memory. 3. Code Quality: Code should be clean, well-commented, and adhere to good practices. --- Example Implementation: ```python from typing import List import heapq def merge_sorted_files(file_paths: List[str], output_path: str): Merge multiple sorted text files into a single sorted file. :param file_paths: List of file paths to be merged. :param output_path: The path of the output file. open_files = [open(file_path, \'r\') for file_path in file_paths] min_heap = [] # Initialize the heap with the first line from each file for i, file in enumerate(open_files): line = file.readline().strip() if line: heapq.heappush(min_heap, (int(line), i)) with open(output_path, \'w\') as output_file: while min_heap: smallest, file_index = heapq.heappop(min_heap) output_file.write(f\\"{smallest}n\\") next_line = open_files[file_index].readline().strip() if next_line: heapq.heappush(min_heap, (int(next_line), file_index)) # Close all input files for file in open_files: file.close() # Example usage: # merge_sorted_files([\'file1.txt\', \'file2.txt\', \'file3.txt\'], \'output.txt\') ``` This implementation utilizes a min-heap to keep track of the smallest current elements across all files, ensuring efficient merging while handling large files.","solution":"from typing import List import heapq def merge_sorted_files(file_paths: List[str], output_path: str): Merge multiple sorted text files into a single sorted file. :param file_paths: List of file paths to be merged. :param output_path: The path of the output file. # Open all files open_files = [open(file_path, \'r\') for file_path in file_paths] min_heap = [] # Initialize the heap with the first line from each file for i, f in enumerate(open_files): line = f.readline().strip() if line: heapq.heappush(min_heap, (int(line), i)) with open(output_path, \'w\') as output_file: # Process the heap while min_heap: smallest, file_index = heapq.heappop(min_heap) output_file.write(f\\"{smallest}n\\") next_line = open_files[file_index].readline().strip() if next_line: heapq.heappush(min_heap, (int(next_line), file_index)) # Close all input files for f in open_files: f.close()"},{"question":"# Coding Assessment Question Context You are tasked with developing components for a basic image processing library. One essential feature is converting a grayscale image, represented as a 2D list of pixel values, into a binary image by applying a specified threshold. Pixels equal to or above the threshold should be set to 1 (white), and those below should be set to 0 (black). Problem Statement **Task**: Implement a `binarize_image` function in Python that processes a grayscale image and converts it into a binary image based on a given threshold. Additionally, you need to create a `print_binary_image` function that outputs the binary image in a readable format. * **Function Specifications**: - **Function 1**: `binarize_image` - **Input**: - A 2D list of integers `grayscale_image` where each integer represents a pixel value (0-255). - An integer `threshold` ranging from 0 to 255. - **Output**: A 2D list of integers where each pixel value is either `0` or `1` based on the thresholding logic. - **Function 2**: `print_binary_image` - **Input**: A 2D list of integers representing a binary image. - **Output**: A string representing the binary image with each row printed on a new line. * **Constraints**: - The input image will always be a non-empty 2D list of integers between 0 and 255. - The threshold will always be an integer between 0 and 255. - Each row in the image will contain at least one pixel. * **Performance Requirements**: - Ensure the solution processes each pixel in the image, resulting in an O(n * m) time complexity, where `n` is the number of rows, and `m` is the number of columns in the input image. Example Usage ```python def binarize_image(grayscale_image: list[list[int]], threshold: int) -> list[list[int]]: >>> binarize_image([[100, 150], [200, 50]], 100) [[1, 1], [1, 0]] >>> binarize_image([[255, 0], [128, 128]], 128) [[1, 0], [1, 1]] def print_binary_image(binary_image: list[list[int]]) -> str: >>> print(print_binary_image([[1, 1], [1, 0]])) 1 1 1 0 >>> print(print_binary_image([[1, 0], [0, 1]])) 1 0 0 1 # Your program should be able to execute the following if __name__ == \\"__main__\\": import doctest doctest.testmod() binary_image = binarize_image([[100, 150], [200, 50]], 100) print(print_binary_image(binary_image)) ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"def binarize_image(grayscale_image, threshold): Converts a grayscale image to a binary image based on the given threshold. Parameters: grayscale_image (list of list of int): A 2D list of integers representing the grayscale image. threshold (int): The threshold value to apply to the grayscale image. Returns: list of list of int: A 2D list of integers representing the binary image. Example: >>> binarize_image([[100, 150], [200, 50]], 100) [[1, 1], [1, 0]] binary_image = [] for row in grayscale_image: binary_row = [] for pixel in row: binary_row.append(1 if pixel >= threshold else 0) binary_image.append(binary_row) return binary_image def print_binary_image(binary_image): Outputs the binary image in a readable format. Parameters: binary_image (list of list of int): A 2D list of integers representing the binary image. Returns: str: A formatted string representing the binary image. Example: >>> print(print_binary_image([[1, 1], [1, 0]])) 1 1 1 0 >>> print(print_binary_image([[1, 0], [0, 1]])) 1 0 0 1 output = [] for row in binary_image: output.append(\' \'.join(map(str, row))) return \'n\'.join(output)"},{"question":"# Dijkstra\'s Algorithm Implementation Context One of the most important graph algorithms is Dijkstra\'s algorithm, which is used to find the shortest path from a source node to all other nodes in a weighted graph. This algorithm is widely used in routing and as a subroutine in other graph algorithms. Task Implement the function `dijkstra` that computes the shortest path from a given source node to all other nodes in a weighted graph represented as an adjacency matrix. Function Signature ```python def dijkstra(graph, src): Function to apply Dijkstra\'s shortest path algorithm on a graph. :param graph: 2D list or 2D numpy array representing the adjacency matrix of the graph. :param src: Integer representing the source node. :return: List of distances where the value at index i represents the shortest distance from the source node to the node i. pass ``` Parameters - **graph** (`list[list[int]]` or `numpy.ndarray`): A 2D list or 2D numpy array where `graph[i][j]` represents the weight of the edge from node `i` to node `j`. If no edge exists, the weight would be represented by a very large number (e.g., `float(\'inf\')`). - **src** (`int`): An integer representing the index of the source node. Constraints - The `graph` matrix should be non-empty and square i.e., the number of rows must equal the number of columns. - The nodes are zero-indexed. - The weights of the edges are non-negative integers. Expected Output - Return a list of shortest path distances from the source node to each other node in the graph. Example ```python # Example adjacency matrix graph = [ [0, 1, 4, float(\'inf\'), float(\'inf\')], [1, 0, 4, 2, 7], [4, 4, 0, 3, 5], [float(\'inf\'), 2, 3, 0, 4], [float(\'inf\'), 7, 5, 4, 0] ] # Source node src = 0 # Calling the function distances = dijkstra(graph, src) # `distances` is expected to be [0, 1, 4, 3, 7] which are the shortest distances # from the source node to each other node. ``` Notes - Consider edge cases where the graph is empty or has only one node. - Optimize the algorithm to handle large graphs efficiently using appropriate data structures (e.g., priority queue). - Validate input parameters and handle edge cases appropriately. This question evaluates the understanding of graph algorithms, specifically Dijkstra’s algorithm, and the ability to handle weighted graphs and priority queues for optimization.","solution":"import heapq def dijkstra(graph, src): Function to apply Dijkstra\'s shortest path algorithm on a graph. :param graph: 2D list or 2D numpy array representing the adjacency matrix of the graph. :param src: Integer representing the source node. :return: List of distances where the value at index i represents the shortest distance from the source node to the node i. n = len(graph) distances = [float(\'inf\')] * n distances[src] = 0 priority_queue = [(0, src)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor in range(n): distance = graph[current_node][neighbor] if distance != float(\'inf\'): new_distance = current_distance + distance if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return distances"},{"question":"# Scenario As a software developer, you are tasked with optimizing the performance of a social media platform\'s backend services. One key feature is the ability to quickly and accurately summarize user activities, such as posts and likes, over various periods. Your objective is to design an efficient data structure to store user activities and implement functionalities to query the summary data. # Problem Statement Create a class `UserActivityTracker` that supports storing user activities and querying summarized data over a specified range of timestamps. # Class Signature ```python class UserActivityTracker: def __init__(self): pass def record_activity(self, user_id: int, timestamp: int, activity_type: str) -> None: pass def query_summary(self, user_id: int, start_time: int, end_time: int) -> dict: pass ``` # Input * `record_activity` method: - `user_id` (int): The ID of the user performing the activity. - `timestamp` (int): The timestamp of the activity in seconds since epoch. - `activity_type` (str): The type of activity. This can be either `\\"post\\"` or `\\"like\\"`. * `query_summary` method: - `user_id` (int): The ID of the user whose activity summary is queried. - `start_time` (int): The start of the time range (inclusive). - `end_time` (int): The end of the time range (inclusive). # Output * `record_activity` method: None * `query_summary` method: A dictionary with keys `\\"posts\\"` and `\\"likes\\"` and corresponding counts of each activity type for the given user within the specified time range. # Constraints 1. `0 <= user_id <= 10^5` 2. `0 <= timestamp <= 2^31 - 1` 3. `activity_type` can only be `\\"post\\"` or `\\"like\\"` 4. `0 <= start_time <= end_time <= 2^31 - 1` # Examples ```python tracker = UserActivityTracker() tracker.record_activity(1, 1000, \\"post\\") tracker.record_activity(1, 2000, \\"like\\") tracker.record_activity(1, 3000, \\"post\\") assert tracker.query_summary(1, 1000, 2500) == {\\"posts\\": 1, \\"likes\\": 1} assert tracker.query_summary(1, 0, 4000) == {\\"posts\\": 2, \\"likes\\": 1} ``` # Note * The system should be designed to handle a large number of users and activities efficiently. * Assume that all activities for a specific user will come in non-decreasing order of timestamps. * Consider using appropriate data structures to achieve efficient time complexity for recording and querying activities. # Performance Requirements * Your solution should optimize both memory usage and execution time, particularly for high-frequency queries and activities. # Additional Context The main challenge is to design a data structure that can efficiently store and retrieve activity counts in response to range queries. Potential data structures or techniques that might be useful include dictionaries, lists, and segment trees for optimized performance.","solution":"from collections import defaultdict class UserActivityTracker: def __init__(self): self.activities = defaultdict(list) def record_activity(self, user_id: int, timestamp: int, activity_type: str) -> None: self.activities[user_id].append((timestamp, activity_type)) def query_summary(self, user_id: int, start_time: int, end_time: int) -> dict: posts = 0 likes = 0 for timestamp, activity_type in self.activities[user_id]: if start_time <= timestamp <= end_time: if activity_type == \\"post\\": posts += 1 elif activity_type == \\"like\\": likes += 1 return {\\"posts\\": posts, \\"likes\\": likes}"},{"question":"# Problem Statement You are tasked to implement a directory structure traversal tool. Your function should print the hierarchical structure of directories and files, given a root directory. The structure should be printed with a tree-like format using indentation to signify levels of nested directories. Make sure to handle edge cases such as empty directories and various file types. # Function Signature ```python def print_directory_structure(root_directory: str) -> None: pass ``` # Input 1. `root_directory` (str): A string representing the path to the root directory. # Output 1. Your function should print the directory and file structure to the console in a formatted tree-like structure. # Requirements - Each directory level should be indented by two spaces. - Print files in alphabetical order. - Print directories first, then files within each directory. # Example Suppose the directory structure is as follows: ``` /root_dir |-- dir_a | |-- file_1.txt | |-- file_2.txt |-- dir_b | |-- dir_c | |-- file_3.txt | |-- file_4.txt |-- file_5.txt |-- file_6.txt ``` Output: ``` root_dir/ dir_a/ file_1.txt file_2.txt dir_b/ dir_c/ file_3.txt file_4.txt file_5.txt file_6.txt ``` # Hints 1. You might find the `os` module in Python helpful for traversing the directory structure. 2. Utilize recursion to handle nested directories effectively. 3. Sorting can be achieved using the `sorted()` function in Python. # Constraints - Assume that the input directory path is a valid path. - The input path is always an absolute path. # Additional Notes - Pay attention to the formatting, particularly the spacing and ordering of files and directories. - Consider using helper functions to manage recursive directory traversal and printing.","solution":"import os def print_directory_structure(root_directory: str) -> None: def traverse_dir(current_path, indent): items = sorted(os.listdir(current_path)) dirs = [item for item in items if os.path.isdir(os.path.join(current_path, item))] files = [item for item in items if not os.path.isdir(os.path.join(current_path, item))] for d in dirs: print(f\\"{\' \' * indent}{d}/\\") traverse_dir(os.path.join(current_path, d), indent + 1) for f in files: print(f\\"{\' \' * indent}{f}\\") print(f\\"{os.path.basename(root_directory)}/\\") traverse_dir(root_directory, 1)"},{"question":"# Sorting by Frequency You are given a list of integers where each integer represents an item. Your task is to sort this list in a way that the items that appear the most frequently come first. If two items have the same frequency, the one with the smaller value should come first. Write a function `frequency_sort(items: List[int]) -> List[int]` that takes a list of integers and returns a list sorted by the frequency of occurrences in descending order. If two integers have the same frequency, they should be sorted in ascending order. # Input: - `items` (List[int]): A list of integers where each integer is an item. (-10^5 <= item <= 10^5, 1 <= len(items) <= 10^5) # Output: - (List[int]): A list of integers sorted by frequency and value. # Example: ```python # Example Case 1 # Input: items = [4, 5, 6, 5, 4, 3] # Output: [4, 4, 5, 5, 3, 6] # Example Case 2 # Input: items = [10, 10, 20, 20, 30, 30, 30] # Output: [30, 30, 30, 10, 10, 20, 20] # Example Case 3 # Input: items = [5, 5, 5, 3, 3, 1, 1, 1, 1] # Output: [1, 1, 1, 1, 5, 5, 5, 3, 3] ``` # Constraints: - Items with higher frequencies appear first. - If two items have the same frequency, the smaller item comes first. # Performance Requirement: Ensure your algorithm runs efficiently for the maximum input size. # Hints: 1. Use a dictionary to count the frequency of each element. 2. Sort based on the frequency count in descending order, and then by the element\'s value in ascending order. Write your function implementation below: ```python from collections import Counter from typing import List def frequency_sort(items: List[int]) -> List[int]: frequency = Counter(items) sorted_items = sorted(items, key=lambda x: (-frequency[x], x)) return sorted_items # Testing the function print(frequency_sort([4, 5, 6, 5, 4, 3])) # Output: [4, 4, 5, 5, 3, 6] print(frequency_sort([10, 10, 20, 20, 30, 30, 30])) # Output: [30, 30, 30, 10, 10, 20, 20] print(frequency_sort([5, 5, 5, 3, 3, 1, 1, 1, 1])) # Output: [1, 1, 1, 1, 5, 5, 5, 3, 3] ```","solution":"from collections import Counter from typing import List def frequency_sort(items: List[int]) -> List[int]: Sorts the list by frequency of occurrences in descending order. If two items have the same frequency, the smaller item appears first. frequency = Counter(items) sorted_items = sorted(items, key=lambda x: (-frequency[x], x)) return sorted_items"},{"question":"# Customer Order Processing You are developing a customer order management system for an online retail company. The system needs to efficiently manage customer orders by allowing creation, updating, and querying of orders. Orders have unique IDs, product names, quantities, and statuses. Task Implement the `OrderManager` class that manages customer orders with the following methods: 1. `create_order(order_id: int, product_name: str, quantity: int) -> None`: Adds a new order with the specified `order_id`, `product_name`, and `quantity`. The status of a new order should be \'NEW\'. If an order with the same `order_id` already exists, raise a `ValueError` with the message \\"Order ID already exists\\". 2. `update_order(order_id: int, product_name: str, quantity: int) -> None`: Updates an existing order\'s `product_name` and `quantity` for the given `order_id`. If no such order exists, raise a `ValueError` with the message \\"Order ID does not exist\\". 3. `get_order_status(order_id: int) -> str`: Returns the status of the order with the given `order_id`. If no such order exists, raise a `ValueError` with the message \\"Order ID does not exist\\". 4. `change_order_status(order_id: int, new_status: str) -> None`: Changes the status of the order with the given `order_id` to `new_status`. Valid statuses are \'NEW\', \'PROCESSING\', \'SHIPPED\', and \'DELIVERED\'. If the `new_status` is invalid, raise a `ValueError` with the message \\"Invalid status\\". If no such order exists, raise a `ValueError` with the message \\"Order ID does not exist\\". Class Signature ```python class OrderManager: def create_order(self, order_id: int, product_name: str, quantity: int) -> None: pass def update_order(self, order_id: int, product_name: str, quantity: int) -> None: pass def get_order_status(self, order_id: int) -> str: pass def change_order_status(self, order_id: int, new_status: str) -> None: pass ``` Example Usage ```python orders = OrderManager() orders.create_order(1, \\"Laptop\\", 2) print(orders.get_order_status(1)) # Output: \\"NEW\\" orders.update_order(1, \\"Gaming Laptop\\", 4) orders.change_order_status(1, \\"PROCESSING\\") print(orders.get_order_status(1)) # Output: \\"PROCESSING\\" ``` Constraints * Each `order_id` is a positive integer and unique across orders. * `product_name` is a non-empty string. * `quantity` is a positive integer. * Assume case-insensitive comparisons for statuses. Requirements * Use appropriate data structures for efficient order management. * Ensure the system handles concurrent order operations gracefully. * Consider edge cases such as attempting to change the status of a non-existent order or creating an order with an already existing ID.","solution":"class OrderManager: def __init__(self): self.orders = {} def create_order(self, order_id: int, product_name: str, quantity: int) -> None: if order_id in self.orders: raise ValueError(\\"Order ID already exists\\") self.orders[order_id] = { \\"product_name\\": product_name, \\"quantity\\": quantity, \\"status\\": \\"NEW\\" } def update_order(self, order_id: int, product_name: str, quantity: int) -> None: if order_id not in self.orders: raise ValueError(\\"Order ID does not exist\\") self.orders[order_id][\\"product_name\\"] = product_name self.orders[order_id][\\"quantity\\"] = quantity def get_order_status(self, order_id: int) -> str: if order_id not in self.orders: raise ValueError(\\"Order ID does not exist\\") return self.orders[order_id][\\"status\\"] def change_order_status(self, order_id: int, new_status: str) -> None: if order_id not in self.orders: raise ValueError(\\"Order ID does not exist\\") valid_statuses = {\\"NEW\\", \\"PROCESSING\\", \\"SHIPPED\\", \\"DELIVERED\\"} if new_status.upper() not in valid_statuses: raise ValueError(\\"Invalid status\\") self.orders[order_id][\\"status\\"] = new_status.upper()"},{"question":"***Appointment Scheduling Problem*** # Context You are responsible for managing appointment schedules in a busy clinic. Each appointment has a specific duration, and you aim to maximize the number of appointments that can be scheduled without any overlaps, given the available time slots in a day. # Problem Statement You are given: 1. An integer `D` representing the total number of available time slots in a day. 2. A list of tuples `appointments` where each tuple (a, b) represents an appointment with a start time `a` and an end time `b`. Write a Python function: ```python def max_appointments(D, appointments): pass ``` The function should return the maximum number of non-overlapping appointments that can be scheduled within the available time slots. # Input Format - An integer `D` - the total number of available time slots in a day. - A list of tuples `appointments`: - Each tuple (a, b) represents an appointment with start time `a` and end time `b` where `0 ≤ a < b ≤ D`. # Output Format - A single integer representing the maximum number of non-overlapping appointments that can be scheduled. # Constraints - (1 leq D leq 10^9) - (1 leq text{len(appointments)} leq 10^4) - (0 leq a < b leq D) for each tuple (a, b) # Example ```python def max_appointments(D, appointments): # implementation goes here pass # Example D = 10 appointments = [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)] output = max_appointments(D, appointments) print(output) # Should print 3 ``` # Explanation For the example provided: - Time slots available: 10 - Appointment times: - Appointment 0: 1 to 4 - Appointment 1: 3 to 5 - Appointment 2: 0 to 6 - Appointment 3: 5 to 7 - Appointment 4: 8 to 9 The function should calculate the maximum set of appointments that can be scheduled without overlapping: - Appointments [1, 5], [5, 7], and [8, 9] can be scheduled making the output 3. # Edge Cases - All appointments overlap entirely (output will be 1). - No overlapping appointments (schedule all). # Notes Optimize the solution by sorting the appointments by their end times and then using a greedy algorithm to select the non-overlapping appointments that fit within the available slots. Handle potential large input sizes efficiently.","solution":"def max_appointments(D, appointments): Given the total number of available time slots in a day and a list of appointments, return the maximum number of non-overlapping appointments that can be scheduled. Parameters: D (int): Total number of available time slots in a day. appointments (list): List of tuples where each tuple (a, b) represents an appointment. Each appointment has start time `a` and end time `b`. Returns: int: Maximum number of non-overlapping appointments. # Sort appointments by their end times appointments.sort(key=lambda x: x[1]) count = 0 last_end_time = -1 for start, end in appointments: if start >= last_end_time: # If the current appointment does not overlap, count it count += 1 last_end_time = end return count"},{"question":"# Problem Statement You are tasked with implementing a system that processes a list of transactions made in an online store. Each transaction is recorded as a string in the format `\\"product_id:quantity:price_per_unit\\"`. You need to create a function `calculate_total_sales` that calculates the total sales value for each product and returns a dictionary with product IDs as keys and their corresponding total sales values as values. # Function Signature ```python def calculate_total_sales(transactions: list[str]) -> dict[str, float]: pass ``` # Input - `transactions`: a list of strings, where each string represents a transaction in the format `\\"product_id:quantity:price_per_unit\\"`. # Output - Returns a dictionary with product IDs (strings) as keys and their corresponding total sales values (floats) as values. # Constraints - `transactions` list will contain between 1 and (10^5) entries. - Each `product_id` will be a non-empty string of alphanumeric characters. - Each `quantity` and `price_per_unit` will be valid numbers represented as strings, where `quantity` is an integer between 1 and (10^4) and `price_per_unit` is a floating-point number between 0.01 and (10^4). # Example ```python >>> calculate_total_sales([\\"A123:2:10.50\\", \\"B456:1:5.30\\", \\"A123:3:10.50\\", \\"C789:4:8.75\\"]) { \\"A123\\": 52.5, \\"B456\\": 5.3, \\"C789\\": 35.0 } >>> calculate_total_sales([\\"X001:5:3.99\\", \\"X001:3:3.99\\"]) { \\"X001\\": 31.92 } ``` # Notes - Assume that `transactions` will not contain malformed strings. - Focus on maximizing the performance considering the constraints.","solution":"def calculate_total_sales(transactions: list[str]) -> dict[str, float]: Calculate the total sales value for each product. Parameters: transactions (list of str): List of transaction strings in the format \\"product_id:quantity:price_per_unit\\". Returns: dict: Dictionary with product IDs as keys and total sales values as values. sales = {} for txn in transactions: product_id, quantity, price_per_unit = txn.split(\':\') quantity = int(quantity) price_per_unit = float(price_per_unit) total_sales_value = quantity * price_per_unit if product_id in sales: sales[product_id] += total_sales_value else: sales[product_id] = total_sales_value return sales"},{"question":"# Scheduling Emails: Delivery Time Calculation **Context**: You are building an email scheduling system where users can specify time delays for their emails to be sent. The application needs to calculate the exact delivery time based on the current time and the specified delay. **Task**: Implement a function `calculate_delivery_time(current_time: str, delay_minutes: int) -> str` that calculates the delivery time of an email based on the current time and a given delay in minutes. **Input Format**: - A string `current_time` representing the current time in the format \\"HH:MM\\". - An integer `delay_minutes` representing the delay time in minutes. **Output Format**: - A string representing the delivery time in the format \\"HH:MM\\". **Constraints**: - The `current_time` string will be a valid time in 24-hour format (00:00 to 23:59). - The `delay_minutes` will be a non-negative integer less than 1440. **Examples**: ```python assert calculate_delivery_time(\\"09:30\\", 30) == \\"10:00\\" assert calculate_delivery_time(\\"23:45\\", 20) == \\"00:05\\" assert calculate_delivery_time(\\"12:15\\", 45) == \\"13:00\\" assert calculate_delivery_time(\\"00:00\\", 60) == \\"01:00\\" assert calculate_delivery_time(\\"11:59\\", 2) == \\"12:01\\" ``` **Performance Requirements**: - The function must handle any given `current_time` and `delay_minutes` efficiently, with constant time complexity O(1).","solution":"def calculate_delivery_time(current_time: str, delay_minutes: int) -> str: Calculates the delivery time based on the current time and delay in minutes. Args: - current_time: str: The current time in \\"HH:MM\\" 24-hour format. - delay_minutes: int: The delay in minutes. Returns: - str: The delivery time in \\"HH:MM\\" 24-hour format. # Split the current_time to get hours and minutes hours, minutes = map(int, current_time.split(\':\')) # Calculate total minutes from current time total_minutes = hours * 60 + minutes # Add the delay minutes to the total minutes total_minutes += delay_minutes # Calculate new hours and minutes new_hours = (total_minutes // 60) % 24 new_minutes = total_minutes % 60 # Format the result in \\"HH:MM\\" return f\\"{new_hours:02d}:{new_minutes:02d}\\""},{"question":"# Coding Assessment Question Context You have been tasked with writing a function that calculates the intersection of two lists without using any built-in set operations. The function should return a list containing the unique elements that appear in both input lists. Task Write a Python function `list_intersection(lst1: list[int], lst2: list[int]) -> list[int]` that takes two lists of integers, and returns a list of unique integers that are present in both input lists. The output list should be sorted in ascending order. Function Signature ```python def list_intersection(lst1: list[int], lst2: list[int]) -> list[int]: pass ``` Inputs - `lst1` (list of int): The first list of integers. - `lst2` (list of int): The second list of integers. Output - Returns a list of unique integers that are present in both `lst1` and `lst2`, sorted in ascending order. Constraints - Elements in `lst1` and `lst2` are not necessarily unique. - You are required to not use any built-in set operations (`set()`, set comprehension, `intersection`, etc.). Examples ```python >>> list_intersection([1, 2, 3, 4], [3, 4, 5, 6]) [3, 4] >>> list_intersection([7, 8, 9], [10, 11, 8, 7]) [7, 8] >>> list_intersection([1, 1, 2, 2, 3, 3], [2, 2, 3, 3, 4, 4]) [2, 3] >>> list_intersection([5, 6, 7], [8, 9, 10]) [] >>> list_intersection([], [1, 2, 3]) [] >>> list_intersection([1, 2, 3], []) [] ``` Notes - The elements in the input lists may have duplicates, but the output list should contain unique elements only. - Ensure the output list is sorted in ascending order. - Consider edge cases like empty lists and lists with no intersections. - Ensure the solution does not use any set-based operations.","solution":"def list_intersection(lst1, lst2): Returns a list of unique integers that are present in both lst1 and lst2, sorted in ascending order. intersection = [] seen_lst1 = {} seen_lst2 = {} # Count occurrences in lst1 for num in lst1: if num not in seen_lst1: seen_lst1[num] = 0 seen_lst1[num] += 1 # Count occurrences in lst2 for num in lst2: if num not in seen_lst2: seen_lst2[num] = 0 seen_lst2[num] += 1 # Find the intersection for num in seen_lst1: if num in seen_lst2: intersection.append(num) # Sort the result intersection.sort() return intersection"},{"question":"# Warehouse Inventory Manager You are working on a software for managing the inventory of a warehouse. Each item in the warehouse has a unique identifier and can be stored in multiple locations. Your task is to implement a system that can update the quantity of items when a shipment arrives or departs and also retrieve the current quantities for auditing purposes. # Implementation Details Implement the class `Warehouse` with methods to handle stock updates and audits. Class Signature ```python class Warehouse: def __init__(self): ... def add_shipment(self, items: list[tuple[int, int]]) -> None: ... def remove_shipment(self, items: list[tuple[int, int]]) -> None: ... def audit(self) -> dict: ... ``` Methods 1. `__init__()`: Initializes an empty inventory. 2. `add_shipment(items: list[tuple[int, int]]) -> None`: Adds the given quantities to the inventory. Each item in the list is represented by a tuple (item_id, quantity). 3. `remove_shipment(items: list[tuple[int, int]]) -> None`: Removes the given quantities from the inventory. If a shipment tries to remove more than what\'s available for any item, raise a `ValueError` with the message `\\"Insufficient stock for item {item_id}\\"`. 4. `audit() -> dict`: Returns the current inventory as a dictionary where keys are item IDs and values are the quantities. Constraints - Item IDs will be positive integers. - Quantities will be non-negative integers. Example ```python warehouse = Warehouse() warehouse.add_shipment([(1, 100), (2, 200), (3, 50)]) warehouse.remove_shipment([(1, 30), (3, 10)]) warehouse.add_shipment([(2, 100), (3, 40)]) print(warehouse.audit()) # Outputs: {1: 70, 2: 300, 3: 80} warehouse.remove_shipment([(1, 80)]) # Raises ValueError: Insufficient stock for item 1 ``` Note - Ensure that the class handles inventory updates efficiently even with repeated operations. - You may use a dictionary to maintain the current quantities of each item, indexed by their item IDs.","solution":"class Warehouse: def __init__(self): Initializes an empty inventory. self.inventory = {} def add_shipment(self, items): Adds the given quantities to the inventory. Each item in the list is represented by a tuple (item_id, quantity). for item_id, quantity in items: if item_id in self.inventory: self.inventory[item_id] += quantity else: self.inventory[item_id] = quantity def remove_shipment(self, items): Removes the given quantities from the inventory. Each item in the list is represented by a tuple (item_id, quantity). If a shipment tries to remove more than what\'s available for any item, raise a ValueError. for item_id, quantity in items: if item_id not in self.inventory or self.inventory[item_id] < quantity: raise ValueError(f\\"Insufficient stock for item {item_id}\\") self.inventory[item_id] -= quantity if self.inventory[item_id] == 0: del self.inventory[item_id] def audit(self): Returns the current inventory as a dictionary where keys are item IDs and values are the quantities. return dict(self.inventory)"},{"question":"# Question: Implement a Basic Banking Ledger You are asked to write three functions to manage a basic banking ledger: add a transaction, retrieve the balance, and generate a statement of transactions. The ledger should handle multiple transactions and compute the balance accurately. Function 1: `add_transaction(ledger: list, transaction_type: str, amount: float) -> list` **Add a transaction to the banking ledger.** - **Input**: - `ledger` (list): The current ledger of transactions. - `transaction_type` (str): The type of transaction (\'deposit\' or \'withdrawal\'). - `amount` (float): The amount of the transaction. - **Output**: - `list`: Updated ledger with the new transaction appended. - **Constraints**: - `transaction_type` must be either \'deposit\' or \'withdrawal\'. - `amount` must be greater than 0. - For a withdrawal, the `amount` must not exceed the current balance in the ledger. Function 2: `calculate_balance(ledger: list) -> float` **Calculate the balance from the ledger transactions.** - **Input**: - `ledger` (list): The ledger of transactions. - **Output**: - `float`: The current balance computed from the ledger. - **Constraints**: - Each element in the `ledger` is a dictionary with keys \'type\' and \'amount\'. - Initial balance is 0. Function 3: `generate_statement(ledger: list) -> str` **Generate a statement listing all transactions and the final balance.** - **Input**: - `ledger` (list): The ledger of transactions. - **Output**: - `str`: A formatted statement listing each transaction and the final balance. - **Constraints**: - Each element in the `ledger` is a dictionary with keys \'type\' and \'amount\'. - Initial balance is 0. # Testing & Validation - Include checks for invalid inputs like transaction types other than \'deposit\' or \'withdrawal\', and negative amounts. - Use various test cases to validate the correctness of your implementation. Example of Test Case: ```python ledger = [] ledger = add_transaction(ledger, \'deposit\', 100.0) ledger = add_transaction(ledger, \'withdrawal\', 40.0) ledger = add_transaction(ledger, \'deposit\', 60.0) balance = calculate_balance(ledger) # should return 120.0 statement = generate_statement(ledger) print(statement) ``` Expected Statement Output: ``` Transaction Summary: 1. deposit: +100.0 2. withdrawal: -40.0 3. deposit: +60.0 Final Balance: 120.0 ```","solution":"def add_transaction(ledger, transaction_type, amount): if transaction_type not in [\'deposit\', \'withdrawal\']: raise ValueError(\\"Transaction type must be \'deposit\' or \'withdrawal\'\\") if amount <= 0: raise ValueError(\\"Amount must be greater than 0\\") current_balance = calculate_balance(ledger) if transaction_type == \'withdrawal\' and amount > current_balance: raise ValueError(\\"Insufficient funds for withdrawal\\") ledger.append({\'type\': transaction_type, \'amount\': amount}) return ledger def calculate_balance(ledger): balance = 0.0 for transaction in ledger: if transaction[\'type\'] == \'deposit\': balance += transaction[\'amount\'] elif transaction[\'type\'] == \'withdrawal\': balance -= transaction[\'amount\'] return balance def generate_statement(ledger): statement_lines = [\\"Transaction Summary:\\"] for i, transaction in enumerate(ledger, start=1): sign = \'+\' if transaction[\'type\'] == \'deposit\' else \'-\' statement_lines.append(f\\"{i}. {transaction[\'type\']}: {sign}{transaction[\'amount\']}\\") final_balance = calculate_balance(ledger) statement_lines.append(f\\"Final Balance: {final_balance}\\") return \'n\'.join(statement_lines)"},{"question":"# Introduction In this task, you need to help develop a bookstore\'s inventory management system. The goal is to determine the available quantity of a specific book, as well as calculate the total value of the inventory for a particular genre of books. # Problem Description Write two functions `book_quantity` and `inventory_value` that take specific input parameters and return the quantity of a given book and the total value of the inventory for a specific genre, respectively. Function 1: `book_quantity` Write a function `book_quantity` that returns the available quantity of a specific book in the inventory. **Function Signature**: ```python def book_quantity(inventory: dict[str, dict[str, Any]], book_name: str) -> int: ``` **Input**: - `inventory` (dict): A dictionary representing the bookstore\'s inventory where keys are book titles and values are dictionaries with keys `quantity` (int) and `genre` (str). - `book_name` (str): The title of the book whose quantity needs to be fetched. **Output**: - (int): The available quantity of the specified book. **Constraints**: - Assume that the inventory dictionary and the book quantities are always valid and non-negative. Function 2: `inventory_value` Write a function `inventory_value` that computes the total value of all books in the inventory for a specific genre. **Function Signature**: ```python def inventory_value( inventory: dict[str, dict[str, Any]], book_prices: dict[str, float], genre: str ) -> float: ``` **Input**: - `inventory` (dict): A dictionary representing the bookstore\'s inventory where keys are book titles and values are dictionaries with keys `quantity` (int) and `genre` (str). - `book_prices` (dict): A dictionary where keys are book titles and values are the prices (float) of the books. - `genre` (str): The genre of books for which the total inventory value needs to be calculated. **Output**: - (float): The total value of the inventory for the specified genre. **Constraints**: - Assume that the inventory dictionary, book prices dictionary, and the prices themselves are always valid and non-negative. - If a book title exists in the inventory but not in `book_prices`, its value should be considered zero. # Example ```python inventory = { \\"Book A\\": {\\"quantity\\": 10, \\"genre\\": \\"Fiction\\"}, \\"Book B\\": {\\"quantity\\": 5, \\"genre\\": \\"Science\\"}, \\"Book C\\": {\\"quantity\\": 3, \\"genre\\": \\"Fiction\\"} } book_prices = { \\"Book A\\": 15.0, \\"Book B\\": 20.0, \\"Book C\\": 25.0 } assert book_quantity(inventory, \\"Book A\\") == 10 assert inventory_value(inventory, book_prices, \\"Fiction\\") == 325.0 ``` # Note - Ensure to include appropriate error handling for invalid inputs as specified in the constraints. - The solution should include necessary imports and follow proper coding standards.","solution":"from typing import Any, Dict def book_quantity(inventory: Dict[str, Dict[str, Any]], book_name: str) -> int: Returns the quantity of the specified book in the inventory. Args: inventory: A dictionary representing the bookstore\'s inventory. book_name: The title of the book whose quantity is to be fetched. Returns: The available quantity of the specified book. return inventory.get(book_name, {}).get(\'quantity\', 0) def inventory_value( inventory: Dict[str, Dict[str, Any]], book_prices: Dict[str, float], genre: str ) -> float: Computes the total value of all books in the inventory for a specific genre. Args: inventory: A dictionary representing the bookstore\'s inventory. book_prices: A dictionary where keys are book titles and values are their prices. genre: The genre of books for which the total inventory value needs to be calculated. Returns: The total value of the inventory for the specified genre. total_value = 0.0 for book, details in inventory.items(): if details[\'genre\'] == genre: total_value += details[\'quantity\'] * book_prices.get(book, 0.0) return total_value"},{"question":"File System Simulation Your task is to implement a simplified file system that supports basic operations such as creating files, writing data to files, reading data from files, and listing all files in a directory. The file system should maintain a structure where each directory can contain files and other directories. Function Signatures: 1. `def create_file(path: str) -> None:` - **Input**: - `path`: a string representing the file\'s path (e.g., `\\"/home/user/file.txt\\"`) - **Output**: None 2. `def write_file(path: str, data: str) -> None:` - **Input**: - `path`: a string representing the file\'s path - `data`: a string containing the data to write to the file - **Output**: None 3. `def read_file(path: str) -> str:` - **Input**: - `path`: a string representing the file\'s path - **Output**: - A string containing the file\'s data 4. `def list_files(path: str) -> list[str]:` - **Input**: - `path`: a string representing the directory\'s path - **Output**: - A list of strings, each representing a file or directory name in the specified directory 5. `def create_directory(path: str) -> None:` - **Input**: - `path`: a string representing the directory\'s path (e.g., `\\"/home/user/documents\\"`) - **Output**: None Constraints: - A file or directory must only be created if its parent directory exists. - File paths must be absolute (starting with `/`). - Directory paths must also be absolute and must not include file extensions. - Each operation should throw an appropriate error if the operation is invalid (e.g., writing to a non-existent file, listing a non-existent directory). - The file system must support nested directories. Example: ```python create_directory(\'/home\') create_directory(\'/home/user\') create_file(\'/home/user/file.txt\') write_file(\'/home/user/file.txt\', \'Hello, world!\') print(read_file(\'/home/user/file.txt\')) # Output: \'Hello, world!\' create_directory(\'/home/user/documents\') create_file(\'/home/user/documents/test.txt\') write_file(\'/home/user/documents/test.txt\', \'Test data\') print(list_files(\'/home/user/documents\')) # Output: [\'test.txt\'] ``` Notes: - Ensure that edge cases are handled, such as attempting to write to a non-existent file or creating a file in a non-existent directory. - The solution should be efficient in terms of both time and space complexity, making use of appropriate data structures as needed.","solution":"class FileSystemError(Exception): pass class FileSystem: def __init__(self): self.fs = {} def _split_path(self, path): parts = path.strip(\'/\').split(\'/\') if not parts or \'\' in parts: raise FileSystemError(\'Invalid path.\') return parts def create_directory(self, path: str) -> None: parts = self._split_path(path) node = self.fs for part in parts: if part not in node: node[part] = {} elif not isinstance(node[part], dict): raise FileSystemError(\'Cannot create directory, a file already exists at the path.\') node = node[part] def create_file(self, path: str) -> None: parts = self._split_path(path) *dirs, file_name = parts node = self.fs for dir in dirs: if dir not in node or not isinstance(node[dir], dict): raise FileSystemError(\'Cannot create file, parent directory does not exist.\') node = node[dir] if file_name in node: raise FileSystemError(\'File already exists.\') node[file_name] = \'\' def write_file(self, path: str, data: str) -> None: parts = self._split_path(path) *dirs, file_name = parts node = self.fs for dir in dirs: if dir not in node or not isinstance(node[dir], dict): raise FileSystemError(\'Cannot write to file, parent directory does not exist.\') node = node[dir] if file_name not in node or not isinstance(node[file_name], str): raise FileSystemError(\'Cannot write to file, file does not exist.\') node[file_name] = data def read_file(self, path: str) -> str: parts = self._split_path(path) *dirs, file_name = parts node = self.fs for dir in dirs: if dir not in node or not isinstance(node[dir], dict): raise FileSystemError(\'Cannot read from file, parent directory does not exist.\') node = node[dir] if file_name not in node or not isinstance(node[file_name], str): raise FileSystemError(\'Cannot read from file, file does not exist.\') return node[file_name] def list_files(self, path: str) -> list[str]: parts = self._split_path(path) node = self.fs for part in parts: if part not in node or not isinstance(node[part], dict): raise FileSystemError(\'Cannot list files, directory does not exist.\') node = node[part] return sorted(node.keys()) fs = FileSystem() create_directory = fs.create_directory create_file = fs.create_file write_file = fs.write_file read_file = fs.read_file list_files = fs.list_files"},{"question":"# String Permutation Checker You are required to develop a function to determine whether two given strings are permutations of each other. Two strings are considered permutations if one is a rearrangement of the characters in the other. Function Signature ```python def are_permutations(str1: str, str2: str) -> bool: ``` Input * `str1` (str): The first string. * `str2` (str): The second string. Output * Boolean: `True` if the strings are permutations of each other, `False` otherwise. Errors The function assumes both inputs are strings and does not need to handle input validation. Example Usage ```python >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"triangle\\", \\"integral\\") True >>> are_permutations(\\"apple\\", \\"pale\\") False >>> are_permutations(\\"abcd\\", \\"dcbae\\") False >>> are_permutations(\\"aabbcc\\", \\"abcabc\\") True >>> are_permutations(\\"xyz\\", \\"yxz\\") True ``` # Instructions - The function should consider case sensitivity, e.g., \\"Abc\\" is not a permutation of \\"abc\\". - Leading or trailing spaces should be considered as part of the string. - You are not allowed to use sorting to solve this problem. # Example Explanation - \\"listen\\" and \\"silent\\" contain the same characters with the same frequencies, so they are permutations. - \\"triangle\\" and \\"integral\\" also meet the condition. - \\"apple\\" and \\"pale\\" do not, as \\"pale\\" is missing an \\"p\\" and has an extra \\"e\\". - \\"abcd\\" and \\"dcbae\\" do not have the same length and thus cannot be permutations. # Constraints - The solution should efficiently handle strings up to 10^5 characters. - Avoid solutions with a time complexity higher than O(n).","solution":"def are_permutations(str1: str, str2: str) -> bool: Determines whether two strings are permutations of each other. # First, quick check: if lengths differ, they cannot be permutations. if len(str1) != len(str2): return False # Create a dictionary to count character occurrences in str1. count = {} # Count each character in str1. for char in str1: count[char] = count.get(char, 0) + 1 # Subtract counts using characters in str2. for char in str2: if char not in count: return False # If a char in str2 doesn\'t exist in str1, they are not permutations count[char] -= 1 if count[char] < 0: return False # More occurrences of a char in str2 than in str1 return True"},{"question":"# Problem Statement As a developer, you are required to implement a system that can manage the history of unique web page accesses. This system should be efficient, accommodating frequent accesses and lookups while ensuring that duplicate accesses are not stored multiple times. # Goal Create a class called `WebAccessTracker` that tracks the unique accesses of web pages. Your task is to: 1. Implement a method `record_access` that records the access of a web page. Ensure that each page URL is recorded only once. 2. Implement a method `get_access_history` that returns the list of unique web pages in the order they were first accessed. 3. Design the class to handle large amounts of data efficiently. # Implementation WebAccessTracker Class 1. **Recording Access** * The method `record_access(page_url: str)` should add the URL to the access history if it is unique. * If the URL has already been recorded, it should not be added again. 2. **Retrieving Access History** * The method `get_access_history()` should return a list of URLs in the order they were first accessed. # Input and Output Format ```python class WebAccessTracker: def __init__(self): self.access_history = [] def record_access(self, page_url): # Implementation for recording a unique access def get_access_history(self): # Implementation for retrieving access history # Expected Input tracker = WebAccessTracker() tracker.record_access(\\"https://example.com\\") tracker.record_access(\\"https://test.com\\") tracker.record_access(\\"https://example.com\\") print(tracker.get_access_history()) # Expected Output: [\'https://example.com\', \'https://test.com\'] # Constraint # The access history must maintain the order of first access and should not contain duplicates. ``` # Constraints and Performance Requirements 1. The system should efficiently handle recording and retrieving access history for at least 100,000 unique URL accesses. 2. The average time complexity for adding an access should be O(1). # Example Scenario ```python # Create an instance of WebAccessTracker tracker = WebAccessTracker() # Record web page accesses tracker.record_access(\\"https://example.com\\") tracker.record_access(\\"https://test.com\\") tracker.record_access(\\"https://example.com\\") tracker.record_access(\\"https://homepage.com\\") # Retrieve access history print(tracker.get_access_history()) # Expected Output: [\'https://example.com\', \'https://test.com\', \'https://homepage.com\'] ``` # Write your WebAccessTracker class below: ```python class WebAccessTracker: def __init__(self): self.access_history = [] self.seen_urls = set() def record_access(self, page_url): if page_url not in self.seen_urls: self.access_history.append(page_url) self.seen_urls.add(page_url) def get_access_history(self): return self.access_history ``` In this example, the `record_access` method ensures that each URL is recorded only once, and `get_access_history` retrieves the access history in the correct order. The implementation uses a set to track seen URLs for O(1) average time complexity per insertion.","solution":"class WebAccessTracker: def __init__(self): self.access_history = [] self.seen_urls = set() def record_access(self, page_url): if page_url not in self.seen_urls: self.access_history.append(page_url) self.seen_urls.add(page_url) def get_access_history(self): return self.access_history"},{"question":"Problem: Efficient Prime Number Generation Using the Sieve of Eratosthenes # Scenario You are required to develop an efficient tool for generating a list of prime numbers within a given range. The tool should utilize the Sieve of Eratosthenes algorithm to optimize performance, especially for large upper limits. # Task Write a function `generate_primes` that takes a single integer input `upper_limit` and returns a list of all prime numbers less than or equal to `upper_limit` using the Sieve of Eratosthenes algorithm. Emphasis should be on optimizing the function to handle large upper limits up to 1,000,000 efficiently. # Function Signature ```python def generate_primes(upper_limit: int) -> list[int]: pass ``` # Input * `upper_limit` (int): The upper limit (inclusive) up to which to generate prime numbers. # Output * A list of integers where each integer is a prime number less than or equal to `upper_limit`. # Constraints 1. `upper_limit` will be a non-negative integer between 0 and 1,000,000 inclusive. # Example ```python # Example 1 upper_limit = 10 print(generate_primes(upper_limit)) # Output: [2, 3, 5, 7] # Example 2 upper_limit = 30 print(generate_primes(upper_limit)) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Example 3 upper_limit = 0 print(generate_primes(upper_limit)) # Output: [] # Example 4 upper_limit = 1 print(generate_primes(upper_limit)) # Output: [] # Example 5 upper_limit = 999983 print(generate_primes(upper_limit)) # Output: [2, 3, 5, 7, 11, 13, 17, ..., 999961, 999979, 999983] ``` # Sieve of Eratosthenes Algorithm 1. Create a boolean array `is_prime` of size `upper_limit + 1` and initialize all entries as `True`. A value in `is_prime[i]` will finally be `False` if `i` is Not a prime; otherwise `True`. 2. Mark `is_prime[0]` and `is_prime[1]` as `False` since 0 and 1 are not primes. 3. Iterate from `p = 2` to `sqrt(upper_limit)`: - If `is_prime[p]` is `True`, mark all multiples of `p` as `False`. 4. Collect all indices `i` where `is_prime[i]` is `True`. # Notes * Your solution should be efficient and capable of handling the maximum constraint effectively. * Pay attention to the proper initialization and marking within the Sieve of Eratosthenes to avoid unnecessary computations and ensure optimal performance.","solution":"def generate_primes(upper_limit: int) -> list[int]: Returns a list of prime numbers less than or equal to upper_limit using the Sieve of Eratosthenes algorithm. if upper_limit < 2: return [] is_prime = [True] * (upper_limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes for i in range(2, int(upper_limit**0.5) + 1): if is_prime[i]: for multiple in range(i*i, upper_limit + 1, i): is_prime[multiple] = False return [i for i, prime in enumerate(is_prime) if prime]"},{"question":"Trie-based Autocomplete System Background Autocompletion is a common feature in text editors and search engines, where based on the prefix provided, the system suggests possible completions. One efficient way to implement autocompletion is using a Trie (prefix tree) data structure. The Trie stores a set of strings and, given a prefix, can quickly return all the strings in the set that start with that prefix. Task Write a class `AutocompleteSystem` to manage and perform autocomplete operations using a Trie. The class should support inserting words into the Trie and retrieving all words that start with a given prefix. Class Methods ```python class AutocompleteSystem: def __init__(self): pass def insert(self, word: str) -> None: pass def autocomplete(self, prefix: str) -> List[str]: pass ``` Method Descriptions - `__init__`: Initializes an empty Trie. - `insert`: Takes a single word and inserts it into the Trie. - `autocomplete`: Takes a prefix string and returns a list of all words in the Trie that start with that prefix. The returned list should be sorted lexicographically. Input - `insert`: A string `word` consisting of lowercase letters. - `autocomplete`: A string `prefix` consisting of lowercase letters. Output - `insert`: Does not return anything. - `autocomplete`: Returns a list of strings that were inserted into the Trie and start with the given prefix, sorted lexicographically. Constraints - The maximum number of words to be inserted is 10^4. - The length of each word and prefix will be between 1 and 100. - The total length of all inserted words will not exceed 10^5. Example ```python autocomplete_system = AutocompleteSystem() autocomplete_system.insert(\\"apple\\") autocomplete_system.insert(\\"app\\") autocomplete_system.insert(\\"application\\") autocomplete_system.insert(\\"banana\\") print(autocomplete_system.autocomplete(\\"app\\")) # Output: [\'app\', \'apple\', \'application\'] print(autocomplete_system.autocomplete(\\"ban\\")) # Output: [\'banana\'] print(autocomplete_system.autocomplete(\\"cat\\")) # Output: [] ``` # Instructions 1. Design and implement the Trie data structure within the `AutocompleteSystem` class. 2. Optimize the `autocomplete` method to handle large datasets efficiently. 3. Ensure the `autocomplete` method returns the results in a lexicographically sorted order.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class AutocompleteSystem: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def autocomplete(self, prefix: str) -> list: node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._find_words_from_node(node, prefix) def _find_words_from_node(self, node, prefix): words = [] if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): words.extend(self._find_words_from_node(next_node, prefix + char)) return sorted(words)"},{"question":"# Coding Question Context You are given an integer `n` and a list of prime numbers. Your task is to find the largest prime factor of the integer `n` using the provided list of prime numbers. You should return -1 if no prime factor from the list divides `n`. Function Signature ```python def largest_prime_factor(n: int, primes: List[int]) -> int: ``` Input The function receives two parameters: - `n`: An integer representing the number to factorize. - `primes`: A list of integers where each integer is a prime number. Output - The function should return an `int` representing the largest prime factor of `n` from the provided list. If no prime from the list divides `n`, return -1. Constraints - `n` will be a positive integer. - Each element in `primes` will be a distinct prime number. - The size of `primes` will be at most 1000. - All prime numbers in `primes` will be less than or equal to `10^5`. Example ```python n = 56 primes = [2, 3, 5, 7, 11, 13, 17] result = largest_prime_factor(n, primes) print(result) # Output should be 7 n = 30 primes = [2, 3, 5, 7, 11, 13, 17] result = largest_prime_factor(n, primes) print(result) # Output should be 5 n = 97 primes = [2, 3, 5, 7, 11, 13, 17] result = largest_prime_factor(n, primes) print(result) # Output should be -1 ``` Hint You may start by iterating over the list of primes in descending order and check if each prime divides `n` without a remainder. The first prime that satisfies this condition will be the largest prime factor from the list.","solution":"from typing import List def largest_prime_factor(n: int, primes: List[int]) -> int: Returns the largest prime factor of n from the provided list of primes. If no prime from the list divides n, returns -1. # Sorting primes in descending order to find the largest prime factor primes.sort(reverse=True) for prime in primes: if n % prime == 0: return prime return -1"},{"question":"# Largest Square of 1s in a Binary Matrix Objective: Implement a function that finds the size of the largest square submatrix that contains only 1s within a given binary matrix. Context: Determining the maximal square of 1s in a binary matrix is a common problem in image processing and computer vision, where recognizing patterns and structures within binary representations can be critical for applications such as object detection. Problem Statement: Given a binary matrix, the task is to identify the size (`side length`) of the largest square submatrix made entirely of 1s. You need to write a function `largest_square_of_1s` that takes a binary matrix and returns the size of the side of the largest square submatrix of 1s. Function Signature: ```python def largest_square_of_1s(matrix: list[list[int]]) -> int: ``` Input: - `matrix`: A list of lists where each inner list represents a row of the binary matrix. The matrix contains only 0s and 1s. Output: - An integer representing the size of the side of the largest square submatrix that contains only 1s. Constraints: - The number of rows and columns in the matrix is in the range [0, 300]. - The matrix contains only binary values (0s and 1s). Example: ```python # Example binary matrix matrix1 = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] print(largest_square_of_1s(matrix1)) # Output should be 2 matrix2 = [ [0, 1], [1, 0] ] print(largest_square_of_1s(matrix2)) # Output should be 1 matrix3 = [ [0] ] print(largest_square_of_1s(matrix3)) # Output should be 0 (No 1s in the matrix) matrix4 = [ [0, 0, 0], [0, 1, 1], [0, 1, 1] ] print(largest_square_of_1s(matrix4)) # Output should be 2 ``` Note: - Handle edge cases where the matrix may be empty or may not contain any 1s. - Aim for an efficient implementation to manage matrices at the upper limit of the size constraints. The solution should ideally use dynamic programming to efficiently find the size of the largest square submatrix of 1s.","solution":"def largest_square_of_1s(matrix): if not matrix or not matrix[0]: return 0 rows = len(matrix) columns = len(matrix[0]) dp = [[0] * columns for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(columns): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"# String Compression You are asked to implement a basic string compression function using the RLE (Run-Length Encoding) algorithm. The RLE algorithm replaces sequences of the same character with the character followed by the number of occurrences. For example: - The string \\"AAAABBBCCDAA\\" would be compressed to \\"A4B3C2D1A2\\". - The string \\"CCCCCCCCCCCCCCC\\" would be compressed to \\"C15\\". If the compressed string is not shorter than the original string, the function should return the original string. Function Signature ```python def compress_string(input_string: str) -> str: ... ``` Input - `input_string` (str): The string to compress. It only contains alphabetic characters and has a length of at least 1 and at most 10^4. Output - `str`: The compressed string or the original string if compression does not reduce the length. Constraints - The string consists solely of lowercase and uppercase alphabetic characters. - The length of the input string is between 1 and 10^4. Example ```python >>> compress_string(\\"AAAABBBCCDAA\\") \\"A4B3C2D1A2\\" >>> compress_string(\\"CCCCCCCCCCCCCCC\\") \\"C15\\" >>> compress_string(\\"AAB\\") \\"AAB\\" # Compression \\"A2B1\\" is not shorter, so return original string >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" ``` Error Handling - There is no need for additional error handling beyond the given constraints.","solution":"def compress_string(input_string: str) -> str: Compress the input string using RLE (Run-Length Encoding) algorithm. If the compressed string is not shorter than the original string, return the original string. if len(input_string) == 0: return input_string compressed_string = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i-1]: count += 1 else: compressed_string.append(input_string[i-1] + str(count)) count = 1 compressed_string.append(input_string[-1] + str(count)) compressed_result = \'\'.join(compressed_string) if len(compressed_result) >= len(input_string): return input_string return compressed_result"},{"question":"# Implement a File System with Directories and Files Objective You are required to build a simplified in-memory file system that allows basic directory and file operations. # Task Description 1. **Class Implementations**: - Implement a `FileSystem` class to represent the file system. - Implement a `Directory` class that extends `FileSystem` for directory specific functionalities. - Implement a `File` class that extends `FileSystem` to handle files with their contents. 2. **Methods**: - `FileSystem`: - `__init__(self, name: str)`: Initializes the file system object with a name. - `Directory`: - `__init__(self, name: str)`: Initializes a directory with the given name and an empty list for storing subdirectories and files. - `add(self, fs_obj: \'FileSystem\')`: Adds a file system object to the directory. - `ls(self) -> List[str]`: Lists all entries (directories and files) alphabetically. - `File`: - `__init__(self, name: str, content: str = \'\')`: Initializes a file with the given name and optional content. - `read(self) -> str`: Returns the content of the file. - `write(self, content: str)`: Overwrites the content of the file. - `append(self, content: str)`: Appends content to the file. 3. **Operations**: - Create a directory or file: ```python mkdir <dir_name> touch <file_name> ``` - Add content to a file: ```python write <file_name> <content> append <file_name> <content> ``` - List contents of a directory: ```python ls <dir_name> ``` # Constraints - Directories and files are identifiable by their names, which are strings containing only alphanumeric characters. - Directory depth and number of files/directories can be up to `10^4`. - File size limit is `10^6` characters. - Files may contain standard ASCII characters. - Operations must achieve constant time complexity for reading and writing files, and logarithmic time complexity for listing contents. # Input Format - The input will be provided as a list of commands: ```python commands = [ (\\"mkdir\\", \\"root\\", \\"docs\\"), (\\"mkdir\\", \\"root/docs\\", \\"projects\\"), (\\"touch\\", \\"root/docs/file1.txt\\"), (\\"write\\", \\"root/docs/file1.txt\\", \\"Hello, World!\\"), (\\"ls\\", \\"root/docs\\") ] ``` Each command is a tuple consisting of an operation followed by corresponding arguments: - `\\"mkdir\\"` command includes the parent directory path and new directory name. - `\\"touch\\"` command includes the directory path and new file name. - `\\"write\\"` and `\\"append\\"` commands include the file path and content. - `\\"ls\\"` command includes the directory path. # Output Format - Produce a list of results for `ls` operations, showing directory contents: # Example ```python commands = [ (\\"mkdir\\", \\"root\\", \\"docs\\"), (\\"mkdir\\", \\"root/docs\\", \\"projects\\"), (\\"touch\\", \\"root/docs/file1.txt\\"), (\\"write\\", \\"root/docs/file1.txt\\", \\"Hello, World!\\"), (\\"ls\\", \\"root/docs\\") ] # Expected Output: # [ # [\'file1.txt\', \'projects\'] # ] ``` Implement the directory and file classes along with the necessary methods to support the described file system operations and produce the expected results.","solution":"class FileSystem: def __init__(self, name: str): self.name = name class Directory(FileSystem): def __init__(self, name: str): super().__init__(name) self.contents = {} def add(self, fs_obj: \'FileSystem\'): self.contents[fs_obj.name] = fs_obj def ls(self) -> list: return sorted(self.contents.keys()) def get(self, name: str): return self.contents.get(name) class File(FileSystem): def __init__(self, name: str, content: str = \'\'): super().__init__(name) self.content = content def read(self) -> str: return self.content def write(self, content: str): self.content = content def append(self, content: str): self.content += content class FileSystemManager: def __init__(self): self.root = Directory(\'root\') def run_commands(self, commands: list): results = [] for command in commands: if command[0] == \'mkdir\': self.mkdir(command[1], command[2]) elif command[0] == \'touch\': self.touch(command[1], command[2]) elif command[0] == \'write\': self.write(command[1], command[2]) elif command[0] == \'append\': self.append(command[1], command[2]) elif command[0] == \'ls\': results.append(self.ls(command[1])) return results def mkdir(self, path: str, name: str): directory = self.traverse_path(path) new_directory = Directory(name) directory.add(new_directory) def touch(self, path: str, name: str): directory = self.traverse_path(path) new_file = File(name) directory.add(new_file) def write(self, path: str, content: str): directory_path, file_name = path.rsplit(\'/\', 1) directory = self.traverse_path(directory_path) file = directory.get(file_name) file.write(content) def append(self, path: str, content: str): directory_path, file_name = path.rsplit(\'/\', 1) directory = self.traverse_path(directory_path) file = directory.get(file_name) file.append(content) def ls(self, path: str): directory = self.traverse_path(path) return directory.ls() def traverse_path(self, path: str): parts = path.split(\'/\') current = self.root for part in parts[1:]: current = current.get(part) return current"},{"question":"# Coding Challenge: Enhancing Binary Search Tree Validation Given a binary search tree (BST) implementation, the task is to enhance the `is_valid_bst` method for improved performance and edge-case handling. Particularly, focus on streamlining the node validation process. # Task Enhance the `is_valid_bst` method to ensure its correctness for all valid and invalid BST configurations, optimizing it for efficiency. # Function Signature ```python def is_valid_bst(root: TreeNode) -> bool: ``` # Inputs - `root`: A `TreeNode` object representing the root of a binary tree. Each `TreeNode` has three attributes: * `val` (int): The value of the node. * `left` (TreeNode or None): The left child. * `right` (TreeNode or None): The right child. # Outputs - Returns a boolean indicating whether the binary tree is a valid binary search tree. # Constraints 1. The tree nodes contain unique integer values. 2. The tree can be empty (in which case it is a valid BST). 3. The tree can have up to 10,000 nodes. # Example ```python # Example tree # 5 # / # 3 7 # / #2 4 8 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(8) print(is_valid_bst(root)) # Expected Output: True # Invalid tree example # 5 # / # 3 7 # / #2 6 8 root_invalid = TreeNode(5) root_invalid.left = TreeNode(3) root_invalid.right = TreeNode(7) root_invalid.left.left = TreeNode(2) root_invalid.left.right = TreeNode(6) root_invalid.right.right = TreeNode(8) print(is_valid_bst(root_invalid)) # Expected Output: False ``` # Additional Information - Ensure that the implementation handles edge cases such as empty trees, single node trees, and subtrees with maximum or minimum node values effectively. - Avoid unnecessary recursive calls. - Utilize efficient traversal techniques and ensure no node is validated multiple times unnecessarily. # Hints - Use appropriate bounds or constraints within the recursive function to validate node values. - Think about in-order traversal as it naturally processes nodes in BST order. - Consider iterative solutions using stack data structures to avoid deep recursion for large trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"**Problem Statement**: You are tasked with creating a simplified version of a library management system. The system should allow users to add books, search for books by title or author, and check out books. Write a Python class `Library` that achieves the following: 1. Allows you to add books to the library with a title, author, and a unique identifier (ID). 2. Allows you to search for books by either title or author. The search should be case-insensitive and return a list of matching books. 3. Allows you to check out a book by its ID. Once a book is checked out, it should not be available for further checkout. The `Book` class should encapsulate the attributes of a book: title, author, and ID. **Class Definitions**: ```python class Book: def __init__(self, title: str, author: str, book_id: int): self.title = title self.author = author self.book_id = book_id class Library: def __init__(self): self.books = [] self.checked_out_books = set() def add_book(self, title: str, author: str, book_id: int): self.books.append(Book(title, author, book_id)) def search_books_by_title(self, title: str) -> list: return [book for book in self.books if title.lower() in book.title.lower()] def search_books_by_author(self, author: str) -> list: return [book for book in self.books if author.lower() in book.author.lower()] def check_out_book(self, book_id: int) -> bool: for book in self.books: if book.book_id == book_id and book_id not in self.checked_out_books: self.checked_out_books.add(book_id) return True return False ``` **Methods Descriptions**: - `add_book(title: str, author: str, book_id: int)`: Adds a book to the library. - `search_books_by_title(title: str) -> list`: Returns a list of books where the title contains the search string (case-insensitive). - `search_books_by_author(author: str) -> list`: Returns a list of books where the author contains the search string (case-insensitive). - `check_out_book(book_id: int) -> bool`: Checks out a book by its ID if it is not already checked out and returns `True`. If the book is already checked out or doesn\'t exist, it returns `False`. **Constraints/Limitations**: - Each book will have a unique ID. - The library will only manage books and does not need to handle different types of media. - Efficient search and book management is required. **Example**: ```python # Create a Library instance library = Library() # Add books to the library library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 2) library.add_book(\\"1984\\", \\"George Orwell\\", 3) # Search for books by title library.search_books_by_title(\\"great\\") # Output: [<Book object at ...>] # Search for books by author library.search_books_by_author(\\"harper\\") # Output: [<Book object at ...>] # Check out a book library.check_out_book(1) # Output: True # Attempt to check out the same book again library.check_out_book(1) # Output: False ```","solution":"class Book: def __init__(self, title: str, author: str, book_id: int): self.title = title self.author = author self.book_id = book_id class Library: def __init__(self): self.books = [] self.checked_out_books = set() def add_book(self, title: str, author: str, book_id: int): self.books.append(Book(title, author, book_id)) def search_books_by_title(self, title: str) -> list: return [book for book in self.books if title.lower() in book.title.lower()] def search_books_by_author(self, author: str) -> list: return [book for book in self.books if author.lower() in book.author.lower()] def check_out_book(self, book_id: int) -> bool: for book in self.books: if book.book_id == book_id and book_id not in self.checked_out_books: self.checked_out_books.add(book_id) return True return False"},{"question":"# Problem: Longest Common Subsequence Using Dynamic Programming Objective: Implement the class `LongestCommonSubsequence` to compute the longest common subsequence (LCS) between two given strings. The class should follow the provided interface and method structure adhering to the complexity constraints. Function Signature: ```python class LongestCommonSubsequence: def __init__(self, string_a=None, string_b=None): Initialize the LCS object with two strings. pass def __compute_lcs_matrix(self): Compute the LCS length and prepare the matrix used for backtracking. pass def get_lcs_length(self): Return the length of the LCS. pass def get_lcs_string(self): Return the actual LCS as a string. pass def __str__(self): Return the string representation of the LCS length and the LCS string. pass ``` # Input: 1. **string_a**: A string of length up to (10^3) characters. 2. **string_b**: A string of length up to (10^3) characters. # Output: - An integer representing the length of the longest common subsequence. - A string representing the longest common subsequence itself. # Constraints: - Both input strings will consist of lowercase English letters (\'a\'-\'z\') and/or digits (\'0\'-\'9\'). # Requirements: 1. Your implementation must correctly handle cases where the strings have no common subsequence. 2. The LCS length must be computed using dynamic programming with a time complexity of O(n*m), where n and m are the lengths of the input strings. 3. The LCS string must be reconstructed by backtracking through the dynamic programming matrix. # Examples: ```python # Example 1: string_a = \\"abcde\\" string_b = \\"ace\\" lcs = LongestCommonSubsequence(string_a, string_b) print(lcs.get_lcs_length()) # Expected: 3 print(lcs.get_lcs_string()) # Expected: \\"ace\\" # Example 2: string_a = \\"abc\\" string_b = \\"def\\" lcs = LongestCommonSubsequence(string_a, string_b) print(lcs.get_lcs_length()) # Expected: 0 print(lcs.get_lcs_string()) # Expected: \\"\\" ``` Implement the `LongestCommonSubsequence` class in Python as per the function signature provided above to solve the problem while maintaining the expected time and space complexity.","solution":"class LongestCommonSubsequence: def __init__(self, string_a=None, string_b=None): self.string_a = string_a self.string_b = string_b self.lcs_matrix = None self.lcs_length = 0 self.lcs_string = \\"\\" if string_a is not None and string_b is not None: self.__compute_lcs_matrix() def __compute_lcs_matrix(self): n = len(self.string_a) m = len(self.string_b) self.lcs_matrix = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if self.string_a[i - 1] == self.string_b[j - 1]: self.lcs_matrix[i][j] = self.lcs_matrix[i - 1][j - 1] + 1 else: self.lcs_matrix[i][j] = max(self.lcs_matrix[i - 1][j], self.lcs_matrix[i][j - 1]) self.lcs_length = self.lcs_matrix[n][m] self.__backtrack_lcs_string() def __backtrack_lcs_string(self): n = len(self.string_a) m = len(self.string_b) i, j = n, m lcs_chars = [] while i > 0 and j > 0: if self.string_a[i - 1] == self.string_b[j - 1]: lcs_chars.append(self.string_a[i - 1]) i -= 1 j -= 1 elif self.lcs_matrix[i - 1][j] > self.lcs_matrix[i][j - 1]: i -= 1 else: j -= 1 self.lcs_string = \'\'.join(reversed(lcs_chars)) def get_lcs_length(self): return self.lcs_length def get_lcs_string(self): return self.lcs_string def __str__(self): return f\\"LCS length: {self.lcs_length}, LCS string: \'{self.lcs_string}\'\\""},{"question":"# Problem Statement You are building a logistics system where you need to efficiently manage packages moving between various hubs. The hubs are represented as a grid and each cell in the grid represents a possible hub location. Some hubs have obstacles, and you need to avoid those while finding the shortest path from a start hub to a target hub using Dijkstra\'s algorithm. # Function Signature ```python def shortest_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> int: Returns the shortest path distance from start to end avoiding obstacles, or -1 if unreachable. ``` # Input * `grid` (1 <= len(grid) <= 500, 1 <= len(grid[0]) <= 500): A 2D list where each element is an integer. 0 represents a clear path, and 1 represents an obstacle. * `start` (2-tuple of integers): A tuple (x, y) representing the starting hub coordinates. * `end` (2-tuple of integers): A tuple (x, y) representing the target hub coordinates. # Output * An integer representing the shortest path distance from `start` to `end` avoiding obstacles. Return -1 if no such path exists. # Example ```python assert shortest_path( [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ], (0, 0), (4, 4) ) == 8 assert shortest_path( [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ], (0, 0), (2, 2) ) == 4 assert shortest_path( [ [0, 1], [1, 0] ], (0, 0), (1, 1) ) == -1 ``` # Constraints * Ensure your implementation efficiently handles large grids. * Consider all four possible moves (up, down, left, right) from any given cell. * Implement Dijkstra\'s algorithm using a priority queue (heap) for optimal performance. * Avoid processing cells multiple times by keeping track of the shortest distance to reach each cell.","solution":"from heapq import heappop, heappush from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def in_bounds(x, y): return 0 <= x < rows and 0 <= y < cols def dijkstra(): heap = [(0, start[0], start[1])] dist = [[float(\'inf\')] * cols for _ in range(rows)] dist[start[0]][start[1]] = 0 while heap: d, x, y = heappop(heap) if (x, y) == end: return d for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and grid[nx][ny] == 0: new_dist = d + 1 if new_dist < dist[nx][ny]: dist[nx][ny] = new_dist heappush(heap, (new_dist, nx, ny)) return -1 if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 return dijkstra()"},{"question":"Task Management System # Context You\'re developing a simple task management system where users can add tasks, mark tasks as completed, and view all tasks. This system needs to be efficient and user-friendly. You are tasked with implementing a class that handles these tasks. # Task Implement a class `TaskManager` that manages tasks. This class should: 1. Allow adding tasks with a unique ID and description. 2. Allow marking tasks as completed. 3. Provide a list of all tasks. 4. Provide a list of pending tasks. 5. Provide a list of completed tasks. 6. Provide a user-friendly message in case of invalid operations, such as marking a non-existent task as completed. # Class Signature ```python class TaskManager: def __init__(self): pass def add_task(self, task_id: int, description: str) -> None: pass def mark_completed(self, task_id: int) -> None: pass def get_all_tasks(self) -> list: pass def get_pending_tasks(self) -> list: pass def get_completed_tasks(self) -> list: pass ``` # Inputs and Outputs - **Input**: - `task_id`: An integer representing the unique ID of the task. - `description`: A string describing the task. - **Output**: - For `add_task` and `mark_completed`, there is no return value, but the method should modify the internal state of the class. - For `get_all_tasks`, `get_pending_tasks`, and `get_completed_tasks`, return a list of tuples, where each tuple contains a task ID and a description. Each method should return tasks corresponding to the method\'s purpose (`all`, `pending`, or `completed`). # Constraints - `task_id` will always be a non-negative integer. - `description` will always be a non-empty string. # Example Usage ```python manager = TaskManager() # Add tasks manager.add_task(1, \\"Complete coding assessment\\") manager.add_task(2, \\"Submit code review\\") # Mark task 1 as completed manager.mark_completed(1) # Get all tasks assert manager.get_all_tasks() == [(1, \\"Complete coding assessment\\"), (2, \\"Submit code review\\")] # Get pending tasks assert manager.get_pending_tasks() == [(2, \\"Submit code review\\")] # Get completed tasks assert manager.get_completed_tasks() == [(1, \\"Complete coding assessment\\")] # Test for invalid task_id try: manager.mark_completed(3) except ValueError as e: assert str(e) == \\"Task ID 3 does not exist.\\" ``` # Notes 1. Ensure `add_task` either adds a new task or raises an exception if the task ID already exists. 2. Ensure `mark_completed` raises an exception if the task ID does not exist. 3. Tasks should be maintained in an internally consistent state, with each ID being unique and each task being either pending or completed (but not both). 4. The lists returned by `get_all_tasks`, `get_pending_tasks`, and `get_completed_tasks` should be sorted by task ID.","solution":"class TaskManager: def __init__(self): self.tasks = {} self.completed = set() def add_task(self, task_id: int, description: str) -> None: if task_id in self.tasks: raise ValueError(f\\"Task ID {task_id} already exists.\\") self.tasks[task_id] = description def mark_completed(self, task_id: int) -> None: if task_id not in self.tasks: raise ValueError(f\\"Task ID {task_id} does not exist.\\") self.completed.add(task_id) def get_all_tasks(self) -> list: return sorted([(task_id, desc) for task_id, desc in self.tasks.items()]) def get_pending_tasks(self) -> list: return sorted([(task_id, self.tasks[task_id]) for task_id in self.tasks if task_id not in self.completed]) def get_completed_tasks(self) -> list: return sorted([(task_id, self.tasks[task_id]) for task_id in self.completed])"},{"question":"# Problem Statement You are given an integer `k` and a list of integers `arr`. Your task is to implement a function that finds whether there exist two distinct elements in the list whose sum is exactly `k`. If such a pair exists, return `True`; otherwise, return `False`. # Function Signature ```python def has_pair_with_sum(arr: list[int], k: int) -> bool: ... ``` # Input * A list of integers `arr` (0 <= len(arr) <= 10^5). * An integer `k`. # Output * A boolean value `True` if there are two distinct elements in `arr` whose sum is equal to `k`, otherwise `False`. # Constraints * Each element in `arr` falls within the range [-10^9, 10^9]. * The list may contain duplicate values. * The list can be empty. # Examples Example 1 Input: `arr = [1, 4, 45, 6, 10, -8]`, `k = 16` Output: `True` Explanation: The pair (10, 6) adds up to 16. Example 2 Input: `arr = [1, 2, 4, 4]`, `k = 8` Output: `True` Explanation: The pair (4, 4) adds up to 8. Example 3 Input: `arr = [1, 2, 3, 9]`, `k = 8` Output: `False` Explanation: No pair of elements adds up to 8. Example 4 Input: `arr = []`, `k = 5` Output: `False` Explanation: The list is empty. # Notes * Consider using a hash set to optimize for better time complexity. * Ensure the solution runs efficiently with large input sizes. * Pay attention to edge cases such as the list being empty or containing negative numbers. # Hint You might find it helpful to iterate through the list and keep track of the required complement for each element in a hash set. If the required complement appears later in the list, you have found your pair.","solution":"def has_pair_with_sum(arr: list[int], k: int) -> bool: Determines whether there are two distinct elements in the list whose sum is equal to k. :param arr: List of integers :param k: The target sum :return: Boolean indicating whether such a pair exists seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"You need to design a function `parse_transaction_log` that extracts and processes transaction data from a given `.txt` log file. Each line in the file contains a timestamp, transaction ID, customer ID, and the transaction amount separated by spaces. The function should return a summary that includes the total number of transactions, the total amount spent by all customers, and a dictionary mapping each customer ID to the total amount they spent. Objective Improve the function `parse_transaction_log` to: 1. Efficiently process and parse the input file line by line. 2. Accurately extract and aggregate transaction details. 3. Handle edge cases, including incorrectly formatted lines and missing data. Requirements - **Input**: - `logfile`: A string representing the name of the log file to be processed. - **Output**: - A tuple containing: 1. Total number of transactions (int). 2. Total amount spent by all customers (float). 3. A dictionary with customer ID as keys and total amount spent as values. - **Constraints**: - Ensure the function can handle large log files efficiently. - Assume reasonable file size and formats, where valid transaction amounts are convertible to floats. Performance Requirements - Ensure that the function reads and processes the file in a memory-efficient manner. - Aim for O(n) complexity where n is the number of lines in the log file. Edge Cases & Error Handling - Gracefully handle lines that do not conform to the expected format. - Ignore any lines with missing or malformed data and continue processing the rest of the file. # Scenario You are managing financial transactions for an online retail platform. The system logs transactions to a text file, and you need a robust and efficient way to summarize the transaction data for financial reporting. Function Signature ```python def parse_transaction_log(logfile: str) -> tuple: # Your improved implementation here ``` Example Consider a log file `transactions.txt` with the following content: ``` 2023-03-15T12:45:33 1234 1 50.0 2023-03-15T12:45:35 1235 2 75.5 2023-03-15T12:50:00 1236 1 30.0 ``` ```python parse_transaction_log(\\"transactions.txt\\") ``` Output: ```python (3, 155.5, {\'1\': 80.0, \'2\': 75.5}) ``` This function correctly calculates the total number of transactions, overall amount, and spending per customer, ensuring robust error handling and efficiency.","solution":"def parse_transaction_log(logfile: str) -> tuple: Parse the transaction log file and return: - Total number of transactions. - Total amount spent by all customers. - Dictionary mapping each customer ID to the total amount they spent. total_transactions = 0 total_amount = 0.0 customer_spending = {} with open(logfile, \'r\') as file: for line in file: parts = line.strip().split() if len(parts) != 4: continue # Skip lines that do not have exactly 4 parts try: timestamp, transaction_id, customer_id, amount = parts amount = float(amount) total_transactions += 1 total_amount += amount if customer_id in customer_spending: customer_spending[customer_id] += amount else: customer_spending[customer_id] = amount except ValueError: continue # Skip lines with malformed numerical values return total_transactions, total_amount, customer_spending"},{"question":"# Task You are given a list of strings, where each string contains a mix of lowercase letters and digits. Your task is to write a Python function `sort_strings_by_sum(strings: List[str]) -> List[str]` that sorts these strings based on the sum of their digits. If two strings have the same sum of digits, they should be sorted lexicographically. # Function Signature ```python def sort_strings_by_sum(strings: List[str]) -> List[str]: pass ``` # Input * **strings**: A list of strings, where each string contains lowercase letters and digits. The length of each string is between 1 and 100, and the number of strings is between 1 and 1000. # Output * Returns a list of strings sorted by the sum of their digits. If two strings have the same sum, they should be sorted lexicographically (alphabetically). # Constraints * Handle strings efficiently to ensure the function works within the given limits. # Example Consider `strings = [\\"a1b2\\", \\"c3d4\\", \\"abc5\\", \\"1ab\\", \\"x2y2\\"]`. - The sums of the digits are as follows: - \\"a1b2\\" -> 1+2 = 3 - \\"c3d4\\" -> 3+4 = 7 - \\"abc5\\" -> 5 = 5 - \\"1ab\\" -> 1 = 1 - \\"x2y2\\" -> 2+2 = 4 The sorted order of the strings is: - \\"1ab\\" (sum = 1) - \\"a1b2\\" (sum = 3) - \\"x2y2\\" (sum = 4) - \\"abc5\\" (sum = 5) - \\"c3d4\\" (sum = 7) Therefore, the function should return `[\\"1ab\\", \\"a1b2\\", \\"x2y2\\", \\"abc5\\", \\"c3d4\\"]`. ```python >>> sort_strings_by_sum([\\"a1b2\\", \\"c3d4\\", \\"abc5\\", \\"1ab\\", \\"x2y2\\"]) [\\"1ab\\", \\"a1b2\\", \\"x2y2\\", \\"abc5\\", \\"c3d4\\"] ```","solution":"from typing import List def sort_strings_by_sum(strings: List[str]) -> List[str]: def digit_sum(s: str) -> int: return sum(int(char) for char in s if char.isdigit()) return sorted(strings, key=lambda s: (digit_sum(s), s))"},{"question":"# Problem Statement: You need to design a simplified version of a calendar application. The application must allow adding and querying events with specific start and end times while ensuring no overlapping events can be added. # Requirements: 1. Implement a class `Calendar` with the following methods: - `bool add_event(int start, int end)`: Adds a new event if it does not overlap with any existing event. - `List[Tuple[int, int]] get_events()`: Returns a list of all events in the calendar as tuples of (start, end) times. 2. The `add_event` method should return `True` if the event is added successfully, and `False` if it conflicts with an existing event. 3. Handle edge cases where events have the same start time or end time as existing events. # Input and Output Formats: - The `add_event` method accepts two integers, `start` and `end`, representing the start and end times of the event. - The `get_events` method returns a list of tuples representing the start and end times of all events. # Constraints: - 0 <= `start` < `end` <= 10^6 - A maximum of 10,000 events can be added. - The events should be stored in the order they are added. # Example: ```python class Calendar: def __init__(self): pass # Include your initialization code here def add_event(self, start: int, end: int) -> bool: pass # Include your add_event implementation here def get_events(self) -> List[Tuple[int, int]]: pass # Include your get_events implementation here # Example usage: cal = Calendar() print(cal.add_event(10, 20)) # Expected: True print(cal.add_event(15, 25)) # Expected: False (overlap with the first event) print(cal.add_event(20, 30)) # Expected: True (no overlap) print(cal.get_events()) # Expected: [(10, 20), (20, 30)] ``` Complete the class `Calendar` based on the provided requirements and examples.","solution":"class Calendar: def __init__(self): self.events = [] def add_event(self, start: int, end: int) -> bool: for event in self.events: if max(event[0], start) < min(event[1], end): return False self.events.append((start, end)) return True def get_events(self): return self.events"},{"question":"# Coding Assessment: Implementing a Simple Recommender System using Cosine Similarity **Objective**: Create a function to recommend the top-`k` most similar items from a dataset based on cosine similarity with a given input item. # Problem Given a dataset of items and features, implement a function `recommend_items` that finds and returns the indices of the top-`k` most similar items to a given input item using cosine similarity. # Function Signature ```python def recommend_items(input_item: np.ndarray, items_dataset: np.ndarray, k: int) -> List[int]: Recommend the top-k most similar items to the input item based on cosine similarity. Args: input_item (np.ndarray): A 1D numpy array representing the features of the input item. items_dataset (np.ndarray): A 2D numpy array where each row is a feature vector of an item in the dataset. k (int): The number of top similar items to recommend. Returns: List[int]: A list of indices representing the top-k most similar items in the dataset. pass ``` # Input * `input_item`: A numpy array of shape (d,) where `d` is the number of features. * `items_dataset`: A numpy array of shape (n, d) where `n` is the number of items and `d` is the number of features. * `k`: An integer representing the number of top similar items to recommend. # Output * A list of `k` integers, each representing the index of a similar item in the `items_dataset`. # Constraints * 1 ≤ n ≤ 10^3 (number of items in the dataset) * 1 ≤ d ≤ 10 (number of features) * 1 ≤ k ≤ n # Example ```python import numpy as np input_item = np.array([1.0, 0.0, 0.0]) items_dataset = np.array([[1.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 1.0], [0.0, 0.0, 1.0]]) k = 2 result = recommend_items(input_item, items_dataset, k) print(result) # Example output might be [1, 0] due to the similarity values. ``` # Instructions 1. Implement the function `recommend_items` considering the cosine similarity between the input item and each item in the dataset. 2. Ensure that your function handles edge cases such as items with zero vectors. 3. Pay attention to the computational complexity and try to optimize where feasible. 4. Test your function with various datasets and `k` values to ensure accuracy. # Notes * Use the cosine similarity formula: `cosine similarity = (A dot B) / (|A| * |B|)`, where `A` and `B` are feature vectors. * Consider using numpy for efficient computation of vector operations. * Validate the input shapes and values to ensure robustness and handle potential numerical stability issues. --- This new question is intended to be consistent with the existing set in terms of coding complexity, topic, and expected analytical thinking related to machine learning and data manipulation tasks.","solution":"import numpy as np from typing import List def recommend_items(input_item: np.ndarray, items_dataset: np.ndarray, k: int) -> List[int]: Recommend the top-k most similar items to the input item based on cosine similarity. Args: input_item (np.ndarray): A 1D numpy array representing the features of the input item. items_dataset (np.ndarray): A 2D numpy array where each row is a feature vector of an item in the dataset. k (int): The number of top similar items to recommend. Returns: List[int]: A list of indices representing the top-k most similar items in the dataset. def cosine_similarity(A, B): dot_product = np.dot(A, B) norm_A = np.linalg.norm(A) norm_B = np.linalg.norm(B) if norm_A == 0 or norm_B == 0: return 0 return dot_product / (norm_A * norm_B) similarities = [] for idx, item in enumerate(items_dataset): similarity = cosine_similarity(input_item, item) similarities.append((similarity, idx)) # Sort by similarity in descending order similarities.sort(key=lambda x: -x[0]) # Extract the top-k most similar item indices top_k_indices = [idx for _, idx in similarities[:k]] return top_k_indices"},{"question":"# Question You have been asked to develop a monitoring tool that analyses log files generated by a web server. Your task is to implement a function `find_error_spikes` that scans a series of log files and identifies periods of unusually high error occurrences. This function should: 1. Read and parse each log file to extract error entries. 2. Count the number of error entries in each 10-minute interval. 3. Identify the intervals where error counts exceed a specified threshold. 4. Return a list of tuples, where each tuple contains the start time of an interval and the corresponding error count. **Function Signature:** ```python def find_error_spikes(log_directory: pathlib.Path, threshold: int) -> list[tuple[datetime, int]]: pass ``` # Input: - `log_directory`: A `pathlib.Path` object pointing to the directory containing log files. - `threshold`: An integer specifying the minimum number of errors needed to identify a spike. # Output: - Returns a list of tuples, where each tuple consists of a `datetime` object representing the start time of a 10-minute interval with an error spike and an `int` representing the number of errors in that interval. # Constraints: - Assume log files are plain text files with each log entry on a new line. - Each log entry follows the format: `\\"[YYYY-MM-DD HH:MM:SS] ERROR Message\\"`. - Only consider the entries that contain the keyword \\"ERROR\\". - If no spikes are found, return an empty list. # Example: Given a log directory structure and files: **Directory Structure**: ``` logs/ ├── log1.txt ├── log2.txt ``` **Log File Content (log1.txt)**: ``` [2023-01-01 10:00:03] ERROR Something went wrong [2023-01-01 10:02:34] ERROR Another error occurred [2023-01-01 10:12:45] ERROR Critical failure ``` **Log File Content (log2.txt)**: ``` [2023-01-01 10:05:12] ERROR Something went wrong again [2023-01-01 10:08:22] ERROR Unexpected condition [2023-01-01 10:15:30] ERROR Exception occurred ``` If the threshold is set to 3 errors per 10-minute interval: ```python from pathlib import Path, datetime result = find_error_spikes(Path(\\"logs\\"), 3) print(result) # Output: [(datetime(2023, 1, 1, 10, 0), 3)] ``` The function finds one spike interval starting at `2023-01-01 10:00:00` with exactly 3 errors.","solution":"import pathlib from datetime import datetime, timedelta from collections import defaultdict import re def find_error_spikes(log_directory: pathlib.Path, threshold: int) -> list[tuple[datetime, int]]: error_counts = defaultdict(int) interval_format = \\"%Y-%m-%d %H:%M\\" log_files = log_directory.glob(\\"*.txt\\") error_pattern = re.compile(r\\"[(?P<timestamp>.+?)] ERROR\\") for log_file in log_files: with log_file.open() as file: for line in file: match = error_pattern.search(line) if match: timestamp_str = match.group(\\"timestamp\\") log_time = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") interval = log_time - timedelta(minutes=log_time.minute % 10, seconds=log_time.second) interval_str = interval.strftime(interval_format) error_counts[interval_str] += 1 return [(datetime.strptime(interval, interval_format), count) for interval, count in error_counts.items() if count >= threshold]"},{"question":"# Stock Price Change Analysis Implement a class `StockPrices` that keeps track of stock prices and supports the following operations: 1. Adding a daily stock price. 2. Retrieving the maximum stock price within a specified date range. 3. Retrieving the minimum stock price within a specified date range. 4. Calculating the average stock price over a specified date range. Additionally, implement a function `analyze_stock_trend` that takes a starting date, an ending date, and a list of daily stock prices. This function should return a dictionary containing the maximum price, minimum price, and average price over the specified date range. # Requirements: Class: * **StockPrices** * `add_price(self, date: str, price: float) -> None`: Adds a daily stock price. * `max_price(self, start_date: str, end_date: str) -> float`: Retrieves the maximum stock price within the specified date range. * `min_price(self, start_date: str, end_date: str) -> float`: Retrieves the minimum stock price within the specified date range. * `average_price(self, start_date: str, end_date: str) -> float`: Calculates the average stock price over the specified date range. Function: * **analyze_stock_trend** * **Input**: * `start_date`: str - the start date in the format \'YYYY-MM-DD\'. * `end_date`: str - the end date in the format \'YYYY-MM-DD\'. * `prices`: List[Tuple[str, float]] - list of tuples containing dates and corresponding stock prices. * **Output**: * Dictionary containing the maximum price, minimum price, and average price over the specified date range. # Scenario: You are given the historical stock prices of a company, and you need to analyze the stock trend within a specified date range. The analysis should provide the maximum, minimum, and average stock prices during this period. # Example: ```python prices = [ (\'2023-01-01\', 150.0), (\'2023-01-02\', 155.0), (\'2023-01-03\', 148.0), (\'2023-01-04\', 154.0), (\'2023-01-05\', 153.0), ] result = analyze_stock_trend(\'2023-01-01\', \'2023-01-05\', prices) # Result should be: # { # \'max_price\': 155.0, # \'min_price\': 148.0, # \'average_price\': 152.0 # } ``` Ensure the function handles edge cases like dates outside the provided price range, and check for invalid date formats.","solution":"from datetime import datetime from typing import List, Tuple, Dict class StockPrices: def __init__(self): self.prices = {} def add_price(self, date: str, price: float) -> None: self.prices[date] = price def _filter_by_date_range(self, start_date: str, end_date: str) -> List[float]: start_dt = datetime.strptime(start_date, \'%Y-%m-%d\') end_dt = datetime.strptime(end_date, \'%Y-%m-%d\') return [price for date, price in self.prices.items() if start_dt <= datetime.strptime(date, \'%Y-%m-%d\') <= end_dt] def max_price(self, start_date: str, end_date: str) -> float: filtered_prices = self._filter_by_date_range(start_date, end_date) if not filtered_prices: return None return max(filtered_prices) def min_price(self, start_date: str, end_date: str) -> float: filtered_prices = self._filter_by_date_range(start_date, end_date) if not filtered_prices: return None return min(filtered_prices) def average_price(self, start_date: str, end_date: str) -> float: filtered_prices = self._filter_by_date_range(start_date, end_date) if not filtered_prices: return None return sum(filtered_prices) / len(filtered_prices) def analyze_stock_trend(start_date: str, end_date: str, prices: List[Tuple[str, float]]) -> Dict[str, float]: stock_prices = StockPrices() for date, price in prices: stock_prices.add_price(date, price) return { \'max_price\': stock_prices.max_price(start_date, end_date), \'min_price\': stock_prices.min_price(start_date, end_date), \'average_price\': stock_prices.average_price(start_date, end_date) }"},{"question":"# Question: Path Existence in Graph You are given an undirected graph represented by an adjacency list and two nodes `start` and `end`. Your task is to implement a function that determines if there is a path between `start` and `end` in the graph. Function Signature: ```python def does_path_exist(graph: Dict[str, List[str]], start: str, end: str) -> bool: ``` Input: - **graph**: A dictionary where keys are node identifiers (strings) and values are lists of adjacent nodes. - **start**: A string representing the starting node. - **end**: A string representing the ending node. Output: - **Result**: A boolean value indicating whether a path exists between `start` and `end`. Constraints & Notes: - The graph is undirected, meaning if there is an edge between `A` and `B`, then `B` is also in the adjacency list of `A`. - The graph does not contain self-loops or multiple edges between the same pair of nodes. - The nodes in the graph are represented by non-empty strings. - Both `start` and `end` will always be keys in the `graph` dictionary. Example: **Input**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' end = \'F\' ``` **Output**: ```python True ``` **Input**: ```python graph = { \'A\': [\'B\'], \'B\': [\'A\'], \'C\': [\'D\'], \'D\': [\'C\'] } start = \'A\' end = \'D\' ``` **Output**: ```python False ``` Implementation Details: - Use an appropriate graph traversal algorithm (such as BFS or DFS) to search for a path between `start` and `end`. - Ensure that you handle cases where the graph is disconnected. - Consider optimizing for both time and space complexity. By ensuring the generated question follows the original task\'s guidelines, it provides a seamless integration with the sample set, balancing style, complexity, and scope appropriately.","solution":"def does_path_exist(graph, start, end): Determines if there is a path between start and end in the given undirected graph. Uses a BFS approach to traverse the graph. from collections import deque # To keep track of visited nodes visited = set() # Initialize the queue with the starting node queue = deque([start]) while queue: current = queue.popleft() # If the end node is found, return True if current == end: return True # Mark the current node as visited visited.add(current) # Add all unvisited adjacent nodes to the queue for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) # If the queue is empty and the end node was not reached, return False return False"},{"question":"# Array Rotation Task You are required to implement a function that performs a left rotation on an array. Given an array of integers, rotate the elements in the array to the left by a given number of positions. Function Signature: ```python def rotate_left(arr: List[int], d: int) -> List[int]: ``` Expected Input and Output: * **Input**: * `arr` (List[int]): A list of integers. * `d` (int): The number of positions to rotate the array. * **Output**: * A list of integers representing the rotated array. Constraints: * The length of the array `n` should be between 1 and 10^5 (inclusive). * The number of positions `d` should be between 0 and 10^5 (inclusive). * The elements in the array should be integers between -10^9 and 10^9. Examples: ```python assert rotate_left([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] assert rotate_left([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] assert rotate_left([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_left([1, 2, 3, 4, 5], 3) == [4, 5, 1, 2, 3] assert rotate_left([-1, -2, -3, -4, -5], 4) == [-5, -1, -2, -3, -4] ``` Instructions: 1. **Implement the function**: Define `rotate_left` to rotate the array elements according to the given number of positions. 2. **Edge cases**: Ensure that your function correctly handles cases where the number of rotations `d` is equal to or greater than the length of the array. 3. **Optimization**: Aim for an efficient solution that minimizes time and space complexity. 4. **Validation**: Validate the input to ensure it conforms to the specified constraints. # Notes: - The rotation should be performed such that elements shifted off one end of the array appear at the other end. - Consider using modular arithmetic to optimize array rotations, especially for large values of `d`.","solution":"from typing import List def rotate_left(arr: List[int], d: int) -> List[int]: Perform left rotation on an array by d positions. Parameters: arr (List[int]): A list of integers. d (int): The number of positions to rotate the array. Returns: List[int]: The rotated array. n = len(arr) if n == 0: return arr # Edge case: empty array d = d % n # If d is greater than the length of the array return arr[d:] + arr[:d]"},{"question":"Problem: Evaluating Expression Trees Using Preorder and Postorder Traversal # Scenario You are developing an algorithm to evaluate mathematical expressions represented as binary trees. The operations supported are addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). You need to implement this in the most efficient way by leveraging the characteristics of tree traversal techniques. # Task Given the root of a binary tree that represents a mathematical expression, write a function `evaluate_expression_tree` that computes the value of the expression by traversing the tree using a pre-order or post-order traversal technique. You will need to handle invalid trees gracefully. # Function Signature ```python def evaluate_expression_tree(root: TreeNode, method: str = \'postorder\') -> float: pass ``` # Input * `root` (TreeNode): The root of the binary tree representing the expression. * `method` (str, optional): The traversal method to use for evaluation (\'preorder\' or \'postorder\'). Default is \'postorder\'. # Output * The result of the expression as a float. # Constraints 1. The tree will only contain integers as leaf values and the operators `+, -, *, /` as internal node values. 2. Division by zero should be handled by raising a `ZeroDivisionError`. 3. Only valid trees (with correct operator placement) will be provided. 4. The function should handle operations in the correct order dictated by traversal. 5. The number of nodes in the tree will be between 1 and 1000 inclusive. 6. The values of the leaf nodes will be between `-10^6` to `10^6`. # Example ```python # Tree example: # (*) # / # (+) (-) # / / # 3 2 5 1 class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(\'*\', TreeNode(\'+\', TreeNode(3), TreeNode(2)), TreeNode(\'-\', TreeNode(5), TreeNode(1))) print(evaluate_expression_tree(root, \'postorder\')) # Output: 9.0 print(evaluate_expression_tree(root, \'preorder\')) # Output: 9.0 ``` # Notes * Ensure your solution can handle both pre-order and post-order traversal methods effectively. * Appropriately handle potential exceptions, such as division by zero, by raising the correct errors. * Consider the efficiency of tree traversal and evaluation in your implementation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def evaluate_expression_tree(root: TreeNode, method: str = \'postorder\') -> float: if method not in {\'preorder\', \'postorder\'}: raise ValueError(\\"Invalid traversal method. Use \'preorder\' or \'postorder\'.\\") def evaluate_postorder(node): if node is None: return 0 if isinstance(node.val, int): return node.val left_val = evaluate_postorder(node.left) right_val = evaluate_postorder(node.right) if node.val == \'+\': result = left_val + right_val elif node.val == \'-\': result = left_val - right_val elif node.val == \'*\': result = left_val * right_val elif node.val == \'/\': if right_val == 0: raise ZeroDivisionError(\\"Division by zero.\\") result = left_val / right_val return result def evaluate_preorder(node): if node is None: return 0 if isinstance(node.val, int): return node.val operator = node.val left_val = evaluate_preorder(node.left) right_val = evaluate_preorder(node.right) if operator == \'+\': result = left_val + right_val elif operator == \'-\': result = left_val - right_val elif operator == \'*\': result = left_val * right_val elif operator == \'/\': if right_val == 0: raise ZeroDivisionError(\\"Division by zero.\\") result = left_val / right_val return result if method == \'postorder\': return evaluate_postorder(root) else: # preorder return evaluate_preorder(root)"},{"question":"# Scenario In this exercise, you are tasked with implementing an algorithm to merge k sorted linked lists into one sorted linked list. This is useful in various real-world applications inclusing merging data from various sorted data sources. # Task Implement the function `merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]` in Python, which takes a list of k sorted linked lists and returns one sorted linked list. # Requirements 1. **Input**: - `lists`: A list consisting of k linked lists, each already sorted in ascending order. The list has at least 1 but no more than 10^4 linked lists, and each linked list has between 0 and 10^4 nodes. 2. **Output**: - A single linked list that is the result of merging the input sorted linked lists. # Input/Output Format - **Input**: `lists = [[1, 4, 5], [1, 3, 4], [2, 6]]` - **Output**: `[1, 1, 2, 3, 4, 4, 5, 6]` # Constraints 1. Each of the linked lists is sorted in ascending order. 2. The result linked list should also be sorted in ascending order. 3. The number of linked lists k is at least 1 and at most 10^4, and the total number of nodes across all lists is at most 10^4. 4. Each node value is an integer within the range [-10^9, 10^9]. # Performance Requirements - Your solution should handle up to 10^4 linked lists and a total of 10^4 nodes efficiently. # Example ```python >>> class ListNode: ... def __init__(self, val=0, next=None): ... self.val = val ... self.next = next ... >>> def print_list(node): ... result = [] ... while node: ... result.append(node.val) ... node = node.next ... return result ... >>> l1 = ListNode(1, ListNode(4, ListNode(5))) >>> l2 = ListNode(1, ListNode(3, ListNode(4))) >>> l3 = ListNode(2, ListNode(6)) >>> merged = merge_k_lists([l1, l2, l3]) >>> print_list(merged) [1, 1, 2, 3, 4, 4, 5, 6] ``` # Notes - Make sure to handle edge cases such as empty linked lists or all linked lists containing a single node gracefully. - Use efficient algorithms like min-heaps to maintain the performance requirements. Implement your `merge_k_lists` function based on the analysis provided.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode() current = dummy while min_heap: value, index, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, index, node.next)) return dummy.next"},{"question":"# Optimizing Delivery Routes for Logistics Scenario You work for a logistics company that needs to optimize delivery routes for a fleet of trucks. The company wants to find the shortest path that a truck should take to deliver goods to multiple destinations from a central warehouse. The destinations are given as nodes in a weighted graph where the weights represent the travel distance between nodes. Objective Implement the `TruckRouteOptimizer` class to find the shortest delivery route starting from the central warehouse, visiting all destinations exactly once, and then returning to the warehouse. Your solution must demonstrate an understanding of algorithms for solving the Traveling Salesman Problem (TSP). Requirements 1. **Input**: - A list of tuples representing the weighted edges of the graph `(u, v, w)`, where `u` and `v` are node identifiers and `w` is the distance between them. - An integer `start` representing the warehouse node from which all deliveries begin and end. - An integer `n` representing the total number of nodes (including the warehouse). 2. **Output**: - A list of node identifiers representing the optimal delivery route, starting and ending at the warehouse. If no valid route exists, return `None`. 3. **Constraints**: - The number of nodes `n` will be between `2` and `20`. - The number of edges will be suitable for the given nodes, with no repeat edges and all distances positive. 4. **Performance**: - The solution should be efficient enough to handle the maximum of `20` nodes. - Consider using dynamic programming or a heuristic to solve TSP for reasonable performance. Function Signature ```python class TruckRouteOptimizer: def __init__(self, edges: list[tuple[int, int, int]], start: int, n: int): # initialization code def find_shortest_route(self) -> list[int] | None: # code to perform the route optimization and return the path ``` Hints - Use dynamic programming (e.g., Held-Karp algorithm) to handle the exponential number of possible routes efficiently. - Ensure that you create a complete graph from the input, as TSP requires every node to be at least indirectly connected. - Use memoization to store intermediate results and avoid redundant computations. Example ```python edges = [ (0, 1, 10), (0, 2, 15), (0, 3, 20), (1, 2, 35), (1, 3, 25), (2, 3, 30), (3, 0, 10), (2, 1, 35), (3, 1, 25), (3, 2, 30) ] tro = TruckRouteOptimizer(edges, 0, 4) route = tro.find_shortest_route() print(route) # Expected output: [0, 1, 3, 2, 0] or any other optimal path ``` This question requires efficient management of intermediate results, exploring all possible routes, and understanding the principles behind dynamic programming to optimize the search space for the Traveling Salesman Problem.","solution":"import itertools from functools import lru_cache class TruckRouteOptimizer: def __init__(self, edges, start, n): self.edges = edges self.start = start self.n = n self.graph = self._create_graph(n, edges) def _create_graph(self, n, edges): graph = [[float(\'inf\')] * n for _ in range(n)] for u, v, w in edges: graph[u][v] = w graph[v][u] = w return graph @lru_cache(None) def tsp(self, mask, pos): if mask == (1 << self.n) - 1: return self.graph[pos][self.start] ans = float(\'inf\') for city in range(self.n): if (mask & (1 << city)) == 0: new_ans = self.graph[pos][city] + self.tsp(mask | (1 << city), city) ans = min(ans, new_ans) return ans def find_shortest_route(self): min_distance = self.tsp(1 << self.start, self.start) if min_distance == float(\'inf\'): return None mask = 1 << self.start pos = self.start path = [pos] for _ in range(self.n - 1): next_city = None best_cost = float(\'inf\') for city in range(self.n): if (mask & (1 << city)) == 0: new_cost = self.graph[pos][city] + self.tsp(mask | (1 << city), city) if new_cost < best_cost: best_cost = new_cost next_city = city pos = next_city mask |= (1 << pos) path.append(pos) path.append(self.start) return path"},{"question":"# Question: Text Classification using Recurrent Neural Network Context You are required to implement a simplified Recurrent Neural Network (RNN) model designed to classify text into predefined categories. You will focus on constructing the RNN cell, handling sequential data, and a portion of the backpropagation training process for the network. These implementations will form the core of your text classification model. Task Implement the following functions within a Python class `SimpleRNN`: 1. `rnn_cell(self, input_vector, hidden_state)`: - Compute the output of a single RNN cell. - Input: - `input_vector`: 1D numpy array of shape (v,), where `v` is the vocabulary size. - `hidden_state`: 1D numpy array of shape (h,), where `h` is the hidden state size. - Output: 1D numpy array representing the new hidden state. 2. `forward_pass(self, sequence)`: - Perform the forward pass over a sequence of input vectors using the RNN cells. - Input: - `sequence`: List of 1D numpy arrays, where each array has shape (v,). - Output: 1D numpy array representing the final hidden state after processing the sequence. 3. `train(self, training_data, labels, epochs, learning_rate)`: - Implement a basic training routine that updates RNN parameters using backpropagation through time (BPTT) and gradient descent. - Input: - `training_data`: List of sequences, where each sequence is a list of 1D numpy arrays. - `labels`: List of integers representing the true labels for the training sequences. - `epochs`: Integer, number of training epochs. - `learning_rate`: Float, learning rate for gradient descent. - Output: None. It should update the model parameters. Constraints - You can use numpy for array operations but avoid pre-built neural network libraries like TensorFlow, Keras, pytorch, etc. - Assume each sequence is of fixed length (e.g., 10 words). - Ensure you handle boundary cases for sequences and gradient updates properly. # Solution Outline ```python import numpy as np class SimpleRNN: def __init__(self, vocabulary_size, hidden_state_size): self.vocabulary_size = vocabulary_size self.hidden_state_size = hidden_state_size self.Wxh = np.random.randn(hidden_state_size, vocabulary_size) * 0.01 self.Whh = np.random.randn(hidden_state_size, hidden_state_size) * 0.01 self.bh = np.zeros((hidden_state_size,)) def rnn_cell(self, input_vector, hidden_state): new_hidden_state = np.tanh(np.dot(self.Wxh, input_vector) + np.dot(self.Whh, hidden_state) + self.bh) return new_hidden_state def forward_pass(self, sequence): hidden_state = np.zeros((self.hidden_state_size,)) for input_vector in sequence: hidden_state = self.rnn_cell(input_vector, hidden_state) return hidden_state def train(self, training_data, labels, epochs, learning_rate): for epoch in range(epochs): for sequence, label in zip(training_data, labels): # Forward pass through the sequence hidden_state_final = self.forward_pass(sequence) # Compute loss and gradients, update weights # ... pass # Sample usage: rnn = SimpleRNN(vocabulary_size=5000, hidden_state_size=128) rnn.train(training_data, labels, epochs=10, learning_rate=0.01) ```","solution":"import numpy as np class SimpleRNN: def __init__(self, vocabulary_size, hidden_state_size): self.vocabulary_size = vocabulary_size self.hidden_state_size = hidden_state_size self.Wxh = np.random.randn(hidden_state_size, vocabulary_size) * 0.01 self.Whh = np.random.randn(hidden_state_size, hidden_state_size) * 0.01 self.bh = np.zeros((hidden_state_size,)) def rnn_cell(self, input_vector, hidden_state): new_hidden_state = np.tanh(np.dot(self.Wxh, input_vector) + np.dot(self.Whh, hidden_state) + self.bh) return new_hidden_state def forward_pass(self, sequence): hidden_state = np.zeros((self.hidden_state_size,)) for input_vector in sequence: hidden_state = self.rnn_cell(input_vector, hidden_state) return hidden_state def train(self, training_data, labels, epochs, learning_rate): for epoch in range(epochs): for sequence, label in zip(training_data, labels): hidden_state_final = self.forward_pass(sequence) # Compute loss and gradients, update weights # ... pass # Sample usage example rnn = SimpleRNN(vocabulary_size=5000, hidden_state_size=128) rnn.train(training_data=[[np.random.randn(5000) for _ in range(10)]], labels=[0], epochs=10, learning_rate=0.01)"},{"question":"You need to design and implement a function that simulates the reservations system for a small hotel. The function should handle room bookings and cancellations efficiently and provide an overview of room availability. Specifically, implement the following features: 1. **Booking**: - Allow booking a room for a specified number of nights starting from a given date. - Return an error if the room is already booked for any of these nights. - Support multiple rooms, identified by unique room numbers. 2. **Cancellation**: - Allow cancellations of a booking, specified by room number and booking dates. - Return an error if the booking does not exist. 3. **Availability Check**: - Provide a function to check the availability of all rooms for a given date range. 4. **Concurrent Access**: - Ensure that your solution can handle concurrent booking and cancellation operations without data inconsistencies. **Function Signatures**: ```python from datetime import datetime, timedelta from typing import List, Dict, Tuple class HotelReservationSystem: def __init__(self, room_numbers: List[int]): # Your initialization code here def book_room(self, room_number: int, start_date: datetime, nights: int) -> str: # Your implementation here def cancel_booking(self, room_number: int, start_date: datetime, nights: int) -> str: # Your implementation here def check_availability(self, start_date: datetime, end_date: datetime) -> Dict[int, List[datetime]]: # Your implementation here ``` # Input: - `room_numbers` (List[int]): List of room numbers available in the hotel. - `room_number` (int): The room number to be booked or cancelled. - `start_date` (datetime): The starting date of the booking or cancellation. - `nights` (int): The number of nights for the booking or cancellation. - `end_date` (datetime): The ending date for availability checking. # Output: - `book_room` returns a string confirming the booking or an error message. - `cancel_booking` returns a string confirming the cancellation or an error message. - `check_availability` returns a dictionary with room numbers as keys and lists of available dates as values. # Example: ```python hotel = HotelReservationSystem([101, 102, 103]) # Booking rooms print(hotel.book_room(101, datetime(2023, 10, 1), 3)) # Should print a confirmation message # Trying to book a room that is already booked print(hotel.book_room(101, datetime(2023, 10, 2), 2)) # Should print an error message # Cancelling a booking print(hotel.cancel_booking(101, datetime(2023, 10, 1), 3)) # Should print a cancellation confirmation # Checking availability availability = hotel.check_availability(datetime(2023, 10, 1), datetime(2023, 10, 10)) print(availability) # Should print available dates for each room ```","solution":"from datetime import datetime, timedelta from typing import List, Dict, Tuple from collections import defaultdict import threading class HotelReservationSystem: def __init__(self, room_numbers: List[int]): self.room_bookings = {room: [] for room in room_numbers} self.lock = threading.Lock() def book_room(self, room_number: int, start_date: datetime, nights: int) -> str: with self.lock: end_date = start_date + timedelta(days=nights) for booking in self.room_bookings[room_number]: if start_date < booking[1] and end_date > booking[0]: return \\"The room is already booked for the provided dates.\\" self.room_bookings[room_number].append((start_date, end_date)) return f\\"Room {room_number} successfully booked from {start_date} to {end_date}\\" def cancel_booking(self, room_number: int, start_date: datetime, nights: int) -> str: with self.lock: end_date = start_date + timedelta(days=nights) for booking in self.room_bookings[room_number]: if booking == (start_date, end_date): self.room_bookings[room_number].remove(booking) return f\\"Booking for Room {room_number} from {start_date} to {end_date} has been cancelled.\\" return \\"No such booking exists.\\" def check_availability(self, start_date: datetime, end_date: datetime) -> Dict[int, List[datetime]]: availability = defaultdict(list) with self.lock: for room, bookings in self.room_bookings.items(): date = start_date while date <= end_date: is_available = True for booking in bookings: if date >= booking[0] and date < booking[1]: is_available = False break if is_available: availability[room].append(date) date += timedelta(days=1) return availability"},{"question":"# Sudoku Solver Enhancement You are provided with a class `SudokuSolver` that solves a given 9x9 Sudoku puzzle using a backtracking algorithm. Your task is to extend the functionality of this class to add the following features: 1. **Sudoku Validator**: * Implement a method `is_valid_board` that verifies whether a given 9x9 Sudoku board is valid. * A valid board follows these rules: - Each row must contain the digits 1-9 without repetition. - Each column must contain the digits 1-9 without repetition. - Each of the nine 3x3 sub-grids must contain the digits 1-9 without repetition. 2. **Partial Solving**: * Implement a method `solve_partial` that attempts to solve the Sudoku puzzle up to a specific number of filled cells. * If the specified number of filled cells is reached before the puzzle is completely solved, the method should terminate and return the current state of the board. **Input**: - For validation: A 9x9 list of lists `board` representing the Sudoku puzzle. - For partial solving: A 9x9 list of lists `board` representing the Sudoku puzzle and an integer `target_filled_cells` specifying the target number of filled cells. **Output**: - For validation: A boolean indicating whether the board is valid. - For partial solving: A 9x9 list of lists representing the current state of the board after attempting to solve it up to the specified number of filled cells. **Performance Requirements**: - Ensure that the `is_valid_board` method runs in O(1) time, as it only performs a fixed amount of checks on a constant-sized board. - Maintain a time complexity of O(n^2) for the `solve_partial` method, where n is the number of empty cells in the worst-case scenario. **Constraints**: - The board is always a 9x9 grid. - Input boards and target filled cells for the partial solver are valid (target filled cells are in the range 0 to 81). - Board cells contain integers 1-9 or 0 for empty cells. **Example Usage**: ```python solver = SudokuSolver() # Validate board board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] is_valid = solver.is_valid_board(board) print(is_valid) # Partially solve board partial_solution = solver.solve_partial(board, 40) for row in partial_solution: print(row) ``` Write the enhanced class `SudokuSolver` with the specified improvements.","solution":"class SudokuSolver: def __init__(self): pass def is_valid_board(self, board): def is_valid_unit(unit): unit = [i for i in unit if i != 0] return len(unit) == len(set(unit)) for i in range(9): if not is_valid_unit(board[i]): return False if not is_valid_unit([board[x][i] for x in range(9)]): return False for i in range(0, 9, 3): for j in range(0, 9, 3): unit = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] if not is_valid_unit(unit): return False return True def solve_partial(self, board, target_filled_cells): def is_valid(board, row, col, num): for x in range(9): if board[row][x] == num: return False if board[x][col] == num: return False if board[3 * (row // 3) + x // 3][3 * (col // 3) + x % 3] == num: return False return True def solve(board, cells_count): if cells_count >= target_filled_cells: return True for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(board, cells_count + 1): return True board[row][col] = 0 return False # if no valid number found, return false return cells_count >= target_filled_cells cells_count = sum(cell != 0 for row in board for cell in row) solve(board, cells_count) return board"},{"question":"# Robust Route Planner with Traffic Conditions Objective You are tasked with developing a more sophisticated route planner for a city represented by a directed graph. Aside from standard weights (travel times between intersections), you must integrate dynamic traffic conditions which can alter these travel times during different times of the day. Task Modify the existing Dijkstra\'s algorithm implementation to account for dynamic traffic conditions. Adapt the algorithm to properly consider these updated weights dynamically while calculating the shortest path. Input 1. **City Graph**: A dictionary where keys are intersections names (strings), and the values are lists of tuples `(neighbor, base_weight)` representing adjacent intersections and the base weight (travel time) to get there. ```python city_graph = { \'A\': [(\'B\', 5), (\'C\', 10)], \'B\': [(\'C\', 3), (\'D\', 2)], \'C\': [(\'D\', 1)], \'D\': [] } ``` 2. **Traffic Conditions**: A dictionary where the keys are time slots (integers) and the values are dictionaries representing the modified travel times for each pair of intersections. Each nested dictionary has intersection pairs as keys and their new travel time as values. ```python traffic_updates = { 8: {(\'A\', \'B\'): 7, (\'B\', \'C\'): 5}, 17: {(\'A\', \'C\'): 15, (\'B\', \'D\'): 3}, ... } ``` 3. **Start Intersection**: A string representing the starting intersection. 4. **Goal Intersection**: A string representing the goal intersection. 5. **Current Time**: An integer representing the current time slot for travel. Output A list of strings where each string is an intersection name representing the optimal path from the start to the goal intersection, inclusive. Constraints 1. The graph is directed and may have edges with no return path. 2. You must account for varying traffic conditions dynamically based on the provided current time slot. 3. Ensure the algorithm remains efficient with manageable time and memory complexity. Performance Requirements * Your solution should maintain optimal performance close to O(E + V log V) where E is the number of edges and V is the number of vertices in practice. * Memory usage should be optimized to handle large city graphs efficiently. Scenario The city has varying traffic conditions that impact route planning significantly. For instance, during peak hours, certain routes may become significantly slower, affecting the shortest path calculation. Example ```python city_graph = { \'A\': [(\'B\', 5), (\'C\', 10)], \'B\': [(\'C\', 3), (\'D\', 2)], \'C\': [(\'D\', 1)], \'D\': [] } traffic_updates = { 8: {(\'A\', \'B\'): 7, (\'B\', \'C\'): 5}, 17: {(\'A\', \'C\'): 15, (\'B\', \'D\'): 3}, } start_intersection = \'A\' goal_intersection = \'D\' current_time_slot = 8 # Expected output: List of intersection names representing the optimal path, e.g., [\'A\', \'B\', \'D\'] ``` Implement the modified algorithm in class `DynamicTrafficDijkstra`.","solution":"import heapq class DynamicTrafficDijkstra: def __init__(self, city_graph, traffic_updates): self.city_graph = city_graph self.traffic_updates = traffic_updates def get_dynamic_weight(self, u, v, base_weight, current_time): if (u, v) in self.traffic_updates.get(current_time, {}): return self.traffic_updates[current_time][(u, v)] return base_weight def shortest_path(self, start, goal, current_time): pq = [(0, start, [])] # Priority queue for min-heap (distance, node, path) distances = {node: float(\'inf\') for node in self.city_graph} distances[start] = 0 visited = set() while pq: current_distance, current_node, path = heapq.heappop(pq) if current_node in visited: continue path = path + [current_node] if current_node == goal: return path visited.add(current_node) for neighbor, base_weight in self.city_graph.get(current_node, []): weight = self.get_dynamic_weight(current_node, neighbor, base_weight, current_time) distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor, path)) return [] # Example usage: city_graph = { \'A\': [(\'B\', 5), (\'C\', 10)], \'B\': [(\'C\', 3), (\'D\', 2)], \'C\': [(\'D\', 1)], \'D\': [] } traffic_updates = { 8: {(\'A\', \'B\'): 7, (\'B\', \'C\'): 5}, 17: {(\'A\', \'C\'): 15, (\'B\', \'D\'): 3}, } start_intersection = \'A\' goal_intersection = \'D\' current_time_slot = 8 planner = DynamicTrafficDijkstra(city_graph, traffic_updates) print(planner.shortest_path(start_intersection, goal_intersection, current_time_slot))"},{"question":"# Question: Palindrome Checker Enhancement You are tasked with enhancing a palindrome checker function to not only check if a string is a palindrome but also validate and handle various types of inputs dynamically. **Objective**: Enhance the given `is_palindrome` function by: 1. **Supporting** input strings with special characters and case differences. 2. **Including** input validation to handle different types of input. 3. **Ensuring** the solution remains efficient and easy to understand. **Function Signature**: ```python def enhanced_is_palindrome(s: str) -> bool: pass ``` # Input: - `s` (str): A string that can include letters, numbers, and special characters. # Output: - Returns a boolean indicating whether the input string is a palindrome after normalizing case and ignoring non-alphanumeric characters. # Constraints: - The input can be an empty string or contain only special characters. - The function should handle both uppercase and lowercase letters without considering spaces and special characters. - Assume the string will be valid UTF-8 encoded text. # Performance Requirements: - The function should run efficiently with a linear time complexity, O(n), where n is the length of the input string. - The function should use O(1) additional space, not counting the space needed for the output. # Detailed Requirements: 1. **Normalization**: - Convert all characters to lowercase. - Remove all non-alphanumeric characters from the string. 2. **Validation**: - If the input is not a string, raise a `TypeError` with a descriptive message. 3. **Checking Palindrome**: - Determine if the normalized string reads the same forwards and backwards. # Example Scenarios 1. Basic palindrome check: ```python assert enhanced_is_palindrome(\\"A man, a plan, a canal, Panama\\") == True ``` 2. Handling non-string input: ```python try: enhanced_is_palindrome(12345) except TypeError as e: print(e) # Expected output: \\"Input must be a string.\\" ``` 3. Palindrome with only special characters: ```python assert enhanced_is_palindrome(\\"@@!!@@\\") == True ``` 4. Non-palindrome string: ```python assert enhanced_is_palindrome(\\"Hello World\\") == False ``` # Specific Challenge: Implement the `enhanced_is_palindrome` function to ensure it handles input validation, normalization, and palindrome checking efficiently. ```python def enhanced_is_palindrome(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"Input must be a string.\\") # Normalize the string normalized = \'\'.join(c.lower() for c in s if c.isalnum()) # Check if the normalized string is a palindrome return normalized == normalized[::-1] # Example Usage print(enhanced_is_palindrome(\\"A man, a plan, a canal, Panama\\")) # True ```","solution":"def enhanced_is_palindrome(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"Input must be a string.\\") # Normalize the string by converting to lowercase and remove non-alphanumeric characters normalized = \'\'.join(c.lower() for c in s if c.isalnum()) # Check if the normalized string is a palindrome return normalized == normalized[::-1] # Example Usage print(enhanced_is_palindrome(\\"A man, a plan, a canal, Panama\\")) # True"},{"question":"# Data Transformation and Analysis You have been provided with a dataset containing information about various products listed on an e-commerce platform. Each product is represented by a dictionary with the following keys: \\"name\\", \\"category\\", \\"price\\", \\"rating\\", and \\"reviews\\". Your task is to implement functions that perform specific transformations and analysis on this dataset. Requirements 1. **Function Implementation**: - Implement a function `average_price_per_category(products: list) -> dict`, which takes a list of product dictionaries and returns a dictionary where the keys are product categories and the values are the average price of products in that category. - Implement a function `top_reviewed_product(products: list) -> dict`, which takes a list of product dictionaries and returns the product with the highest number of reviews. If there are multiple products with the same highest number of reviews, return the one with the highest rating among them. Input and Output Formats - **Input**: * A list of dictionaries, where each dictionary contains the following keys: - `name` (string): The name of the product. - `category` (string): The product category. - `price` (float): The price of the product. - `rating` (float): The rating of the product (between 0 and 5). - `reviews` (int): The number of reviews the product has received. - **Output**: * For `average_price_per_category`: * A dictionary where keys are categories and values are the average price of products in that category. * For `top_reviewed_product`: * A dictionary representing the product with the highest number of reviews (or the highest-rated one if there\'s a tie). Constraints: - Ensure the implementation handles: * Empty product lists. * Products with missing or malformed data. * Categories with only one product. Performance Requirements: - The solution should be efficient in terms of time complexity, ideally O(n) where n is the number of products. - Handle large datasets within reasonable time and space constraints. Example Dataset ```python products = [ {\\"name\\": \\"Product A\\", \\"category\\": \\"Electronics\\", \\"price\\": 99.99, \\"rating\\": 4.5, \\"reviews\\": 150}, {\\"name\\": \\"Product B\\", \\"category\\": \\"Electronics\\", \\"price\\": 299.99, \\"rating\\": 4.7, \\"reviews\\": 250}, {\\"name\\": \\"Product C\\", \\"category\\": \\"Home\\", \\"price\\": 49.99, \\"rating\\": 4.2, \\"reviews\\": 75}, {\\"name\\": \\"Product D\\", \\"category\\": \\"Home\\", \\"price\\": 89.99, \\"rating\\": 4.8, \\"reviews\\": 125}, {\\"name\\": \\"Product E\\", \\"category\\": \\"Books\\", \\"price\\": 15.99, \\"rating\\": 4.9, \\"reviews\\": 300}, ] ``` Implementation Notes - Use Python\'s built-in `statistics` library to calculate the average prices. - Carefully consider edge cases such as empty categories, missing fields, and products with the same number of reviews but different ratings. Sample Output - For function `average_price_per_category(products)`: ```python { \\"Electronics\\": 199.99, \\"Home\\": 69.99, \\"Books\\": 15.99 } ``` - For function `top_reviewed_product(products)`: ```python { \\"name\\": \\"Product E\\", \\"category\\": \\"Books\\", \\"price\\": 15.99, \\"rating\\": 4.9, \\"reviews\\": 300 } ``` Implement the necessary functions in Python and test them with the given sample dataset. Ensure your code is well-documented and handles the edge cases appropriately.","solution":"from typing import List, Dict from collections import defaultdict from statistics import mean def average_price_per_category(products: List[Dict]) -> Dict[str, float]: Returns a dictionary containing the average price of products per category. category_prices = defaultdict(list) for product in products: category = product.get(\\"category\\") price = product.get(\\"price\\") if category and isinstance(price, (int, float)): category_prices[category].append(price) return {category: mean(prices) for category, prices in category_prices.items()} def top_reviewed_product(products: List[Dict]) -> Dict: Returns the product with the highest number of reviews. If multiple products have the same highest number of reviews, return the one with the highest rating. top_product = None for product in products: reviews = product.get(\\"reviews\\") if reviews is not None and isinstance(reviews, int): if (top_product is None or reviews > top_product[\'reviews\'] or (reviews == top_product[\'reviews\'] and product.get(\'rating\', 0) > top_product.get(\'rating\', 0))): top_product = product return top_product"},{"question":"# Scenario You are building a system to manage a database of employees for a company. Each employee has a unique ID, name, department, and salary. You need to create a class that allows adding new employees, retrieving employee information by ID, and calculating the average salary of employees in a given department. # Task Write a Python class `EmployeeDatabase` that allows you to manage the employee data as described. # Class Structure ```python class EmployeeDatabase: def __init__(self) -> None: Initialize the EmployeeDatabase with an empty list to store employee records. pass def add_employee(self, emp_id: int, name: str, department: str, salary: float) -> None: Add a new employee to the database. pass def get_employee(self, emp_id: int) -> dict: Retrieve the employee information by their ID. pass def average_salary(self, department: str) -> float: Calculate the average salary for the employees in a specific department. pass ``` # Constraints and Requirements * The class should be capable of storing and handling a list of employee records. * Each employee record is a dictionary with the following keys: `emp_id`, `name`, `department`, `salary`. * Expected methods input and output: * `add_employee` method: * `emp_id` is an integer representing the unique ID for the employee. * `name` is a string representing the employee\'s name. * `department` is a string representing the employee\'s department. * `salary` is a float representing the employee\'s salary. * `get_employee` method: * `emp_id` is an integer. * Returns a dictionary with the employee\'s information or `None` if not found. * `average_salary` method: * `department` is a string. * Returns a float representing the average salary of the employees in that department. # Example ```python # Example usage db = EmployeeDatabase() db.add_employee(1, \'Alice\', \'Engineering\', 75000) db.add_employee(2, \'Bob\', \'Engineering\', 80000) db.add_employee(3, \'Carol\', \'HR\', 60000) print(db.get_employee(1)) # Expected Output: {\'emp_id\': 1, \'name\': \'Alice\', \'department\': \'Engineering\', \'salary\': 75000} print(db.get_employee(4)) # Expected Output: None print(db.average_salary(\'Engineering\')) # Expected Output: 77500.0 print(db.average_salary(\'HR\')) # Expected Output: 60000.0 ``` # Important Note Ensure that the class handles typical edge cases gracefully, such as: - Adding an employee with an existing `emp_id` should result in an update, not a duplicate entry. - Avoid division by zero in `average_salary` if there are no employees in the specified department. - Input validation should be performed where appropriate to maintain data integrity.","solution":"class EmployeeDatabase: def __init__(self) -> None: Initialize the EmployeeDatabase with an empty list to store employee records. self.employees = [] def add_employee(self, emp_id: int, name: str, department: str, salary: float) -> None: Add a new employee to the database. If the employee ID already exists, update the record. for employee in self.employees: if employee[\'emp_id\'] == emp_id: employee.update({\'name\': name, \'department\': department, \'salary\': salary}) return self.employees.append({\'emp_id\': emp_id, \'name\': name, \'department\': department, \'salary\': salary}) def get_employee(self, emp_id: int) -> dict: Retrieve the employee information by their ID. for employee in self.employees: if employee[\'emp_id\'] == emp_id: return employee return None def average_salary(self, department: str) -> float: Calculate the average salary for the employees in a specific department. total_salary = 0 count = 0 for employee in self.employees: if employee[\'department\'] == department: total_salary += employee[\'salary\'] count += 1 return total_salary / count if count > 0 else 0.0"},{"question":"# Student Grades Calculation System You have been asked to create a grading system for a class of students. The system needs to fetch student grade data from a mock API, process this data, and save the processed information to a file. The current system only reads data from an API and prints it. Your task is to extend this functionality to perform additional operations. Requirements: 1. **Function `fetch_student_grades`**: - Takes a class ID as input. - Asynchronously fetches the grade data from a mock API. - Includes robust error handling for API request failures and missing data fields. - Validates the JSON response to ensure it contains the expected structure. - Returns a list of dictionaries, each containing student\'s name and their grades. 2. **Function `calculate_average`**: - Takes a list of dictionaries (student\'s grades data). - Calculates the average grade for each student. - Returns a list of dictionaries, each containing the student\'s name and their average grade. 3. **Function `save_to_file`**: - Takes a list of dictionaries (student\'s average grades) and a filename. - Writes the student\'s average grades to the specified file, each student\'s name and their average grade on a new line. 4. **Constraints**: - You must use the `aiohttp` library for making asynchronous requests. - Timeout for the HTTP request should be 5 seconds. - Ensure efficient use of resources and handle potential exceptions gracefully. Input & Output Formats: * The `fetch_student_grades` function should return a list of dictionaries containing each student\'s name and grades. * The `calculate_average` function should return a list of dictionaries containing each student\'s name and their average grade. * The `save_to_file` function should not return anything but must write the data to a file. Example: Given a hypothetical class ID `\\"class_1001\\"`, the script should: 1. Fetch the student grades. 2. Calculate each student\'s average grade. 3. Write the student\'s name and their average grade to a file named `grades_report.txt`. ```python import aiohttp import asyncio import json _GRADES_API = \\"https://api.mockgrades.com/v1/classes/\\" async def fetch_student_grades(class_id: str) -> list: async with aiohttp.ClientSession() as session: try: async with session.get(_GRADES_API + class_id, timeout=5) as response: if response.status != 200: raise Exception(f\\"Error fetching data: {response.status}\\") json_response = await response.json() return [ {\'name\': student[\'name\'], \'grades\': student[\'grades\']} for student in json_response.get(\'students\', []) ] except Exception as e: print(f\\"An error occurred: {e}\\") return [] def calculate_average(grades_data: list) -> list: averages = [] for student in grades_data: avg_grade = sum(student[\'grades\']) / len(student[\'grades\']) averages.append({\'name\': student[\'name\'], \'average_grade\': avg_grade}) return averages def save_to_file(averages: list, filename: str) -> None: try: with open(filename, \'w\') as file: for student in averages: file.write(f\\"{student[\'name\']}: {student[\'average_grade\']:.2f}n\\") except IOError as e: print(f\\"File operation error: {e}\\") if __name__ == \\"__main__\\": class_id = \\"<Your Class ID goes here>\\" grades_data = asyncio.run(fetch_student_grades(class_id)) averages = calculate_average(grades_data) save_to_file(averages, \'grades_report.txt\') ```","solution":"import aiohttp import asyncio from typing import List, Dict _GRADES_API = \\"https://api.mockgrades.com/v1/classes/\\" async def fetch_student_grades(class_id: str) -> List[Dict[str, List[int]]]: async with aiohttp.ClientSession() as session: try: async with session.get(f\\"{_GRADES_API}{class_id}\\", timeout=5) as response: response.raise_for_status() json_response = await response.json() if \'students\' not in json_response: raise ValueError(\\"Invalid response structure: \'students\' key not found\\") return [ {\'name\': student[\'name\'], \'grades\': student[\'grades\']} for student in json_response[\'students\'] ] except (aiohttp.ClientError, asyncio.TimeoutError, ValueError, KeyError) as e: print(f\\"An error occurred: {e}\\") return [] def calculate_average(grades_data: List[Dict[str, List[int]]]) -> List[Dict[str, float]]: averages = [] for student in grades_data: if len(student[\'grades\']) == 0: avg_grade = 0.0 else: avg_grade = sum(student[\'grades\']) / len(student[\'grades\']) averages.append({\'name\': student[\'name\'], \'average_grade\': avg_grade}) return averages def save_to_file(averages: List[Dict[str, float]], filename: str) -> None: try: with open(filename, \'w\') as file: for student in averages: file.write(f\\"{student[\'name\']}: {student[\'average_grade\']:.2f}n\\") except IOError as e: print(f\\"File operation error: {e}\\")"},{"question":"# Scenario You are creating a software simulation for a parking lot management system. One of the critical features is to track the vehicle entry and exit times and calculate the total parking fee based on the duration of the stay. The parking fee is charged at a fixed rate per hour or part thereof. # Task Implement a function that calculates the parking fee for a vehicle given its entry and exit times. The parking fee should be calculated based on a fixed hourly rate. If the vehicle stays for a part of an hour, it should be rounded up to the next whole hour. # Function Signature ```python def calculate_parking_fee(entry_time: str, exit_time: str, hourly_rate: int) -> int: Calculate the parking fee based on entry and exit times and an hourly rate. :param entry_time: The entry time in \\"HH:MM\\" format (24-hour). :param exit_time: The exit time in \\"HH:MM\\" format (24-hour). :param hourly_rate: The hourly rate for parking (positive integer). :return: The total parking fee (integer). :raises ValueError: If any of the inputs are invalid or if exit_time is earlier than entry_time. ``` # Input * `entry_time`: a string in \\"HH:MM\\" format (24-hour clock, \\"00:00\\" to \\"23:59\\"). * `exit_time`: a string in \\"HH:MM\\" format (24-hour clock, \\"00:00\\" to \\"23:59\\"). * `hourly_rate`: an integer (positive value). # Output Returns the total parking fee as an integer. # Constraints * `entry_time` and `exit_time` should be valid times in \\"HH:MM\\" format. * `exit_time` should not be earlier than `entry_time` on the same day. * `hourly_rate` should be a positive integer. * The parking fee is charged for every hour or part thereof (round up). # Example ```python >>> calculate_parking_fee(\\"10:00\\", \\"13:15\\", 5) 20 >>> calculate_parking_fee(\\"09:30\\", \\"10:45\\", 8) 16 >>> calculate_parking_fee(\\"23:00\\", \\"01:00\\", 10) Traceback (most recent call last): ... ValueError: Exit time must be later than entry time on the same day >>> calculate_parking_fee(\\"08:00\\", \\"08:45\\", 7) 7 >>> calculate_parking_fee(\\"06:30\\", \\"11:15\\", 3) 18 ``` # Notes * Ensure your implementation properly handles the rounding logic for partial hours. * Validations should be in place to catch incorrect time formats and other constraints. * Assume entry and exit times refer to the same calendar day (no overnight parking scenarios).","solution":"from datetime import datetime def calculate_parking_fee(entry_time: str, exit_time: str, hourly_rate: int) -> int: Calculate the parking fee based on entry and exit times and an hourly rate. :param entry_time: The entry time in \\"HH:MM\\" format (24-hour). :param exit_time: The exit time in \\"HH:MM\\" format (24-hour). :param hourly_rate: The hourly rate for parking (positive integer). :return: The total parking fee (integer). :raises ValueError: If any of the inputs are invalid or if exit_time is earlier than entry_time. # Parse the entry and exit times try: entry_dt = datetime.strptime(entry_time, \\"%H:%M\\") exit_dt = datetime.strptime(exit_time, \\"%H:%M\\") except ValueError: raise ValueError(\\"Invalid time format. Use \'HH:MM\'.\\") # Validate the hourly rate if hourly_rate <= 0: raise ValueError(\\"Hourly rate must be a positive integer.\\") # Check if exit time is earlier than entry time if exit_dt < entry_dt: raise ValueError(\\"Exit time must be later than entry time on the same day\\") # Calculate the total duration in minutes duration_minutes = (exit_dt - entry_dt).seconds // 60 # Calculate the total fee (rounding up to the nearest hour) total_hours = (duration_minutes + 59) // 60 # Equivalent to math.ceil(duration_minutes / 60) total_fee = total_hours * hourly_rate return total_fee"},{"question":"# Coding Assessment Question You are developing a system for managing a library\'s collection of digital media. This includes books, journals, and videos, each with their unique metadata. Your task is to implement functionality to search for media items by keyword and filter them by type. Task: 1. Implement a function `search_media(keyword: str, media_type: str = None) -> list` that: - Searches through a given library\'s collection for items that match the `keyword` in their title or description. - Filters the results by `media_type` if provided (`media_type` can be \\"book\\", \\"journal\\", or \\"video\\"). - Returns a list of dictionaries, each containing metadata for a media item (title, type, description). 2. Implement a function `add_media_item(media_item: dict) -> None` that: - Adds a new media item to the collection. - Ensures each media item contains the necessary fields (\'title\', \'type\', \'description\', \'year\', \'author\'). Expected Input and Output: * `search_media`: - **Input**: `keyword`: str, `media_type`: str (optional, default is None). - **Output**: List of dictionaries (each dictionary should contain \'title\', \'type\', \'description\'). * `add_media_item`: - **Input**: `media_item`: dict. - **Output**: Adds the media item to the collection. Returns None. Constraints: - All input strings will be non-empty and properly formatted as per their descriptions. - The `media_item` dictionary will always contain valid fields if non-existent already. - Assume there\'s a global variable `library_collection` which is a list of dictionaries representing the media items. Performance Requirements: - Ensure searches are efficient, even with a large collection. - Input validation should be performed to maintain the integrity of the media collection. Hints: - Use list comprehensions for searching and filtering. - Ensure basic type checking and validation when adding new items to the collection. Here’s a starting template for your implementation: ```python library_collection = [] def search_media(keyword: str, media_type: str = None) -> list: Search for media items that match the keyword and filter by type if provided. result = [] for item in library_collection: if (keyword.lower() in item[\'title\'].lower() or keyword.lower() in item[\'description\'].lower()): if media_type: if item[\'type\'] == media_type: result.append({ \\"title\\": item[\\"title\\"], \\"type\\": item[\\"type\\"], \\"description\\": item[\\"description\\"], }) else: result.append({ \\"title\\": item[\\"title\\"], \\"type\\": item[\\"type\\"], \\"description\\": item[\\"description\\"], }) return result def add_media_item(media_item: dict) -> None: required_fields = {\'title\', \'type\', \'description\', \'year\', \'author\'} if not required_fields.issubset(media_item): raise ValueError(f\\"Missing required fields: {required_fields - set(media_item.keys())}\\") library_collection.append(media_item) # Example usage add_media_item({ \\"title\\": \\"Understanding AI\\", \\"type\\": \\"book\\", \\"description\\": \\"An introduction to artificial intelligence.\\", \\"year\\": 2021, \\"author\\": \\"Jane Doe\\" }) results = search_media(\\"AI\\") print(results) ``` # Testing the Functions Here are some test cases to verify the correct implementation: ```python def test_add_media_item(): global library_collection library_collection.clear() add_media_item({ \\"title\\": \\"Understanding AI\\", \\"type\\": \\"book\\", \\"description\\": \\"An introduction to artificial intelligence.\\", \\"year\\": 2021, \\"author\\": \\"Jane Doe\\" }) assert len(library_collection) == 1, \\"Test case failed! Expected 1 item in the collection.\\" def test_search_media(): global library_collection library_collection = [ { \\"title\\": \\"Understanding AI\\", \\"type\\": \\"book\\", \\"description\\": \\"An introduction to artificial intelligence.\\", \\"year\\": 2021, \\"author\\": \\"Jane Doe\\" }, { \\"title\\": \\"AI Revolution\\", \\"type\\": \\"journal\\", \\"description\\": \\"Latest trends in AI.\\", \\"year\\": 2022, \\"author\\": \\"John Smith\\" } ] results = search_media(\\"AI\\") assert len(results) == 2, \\"Test case failed! Expected 2 items in the result.\\" results = search_media(\\"AI\\", \\"journal\\") assert len(results) == 1, \\"Test case failed! Expected 1 item in the result.\\" assert results[0][\'title\'] == \\"AI Revolution\\", \\"Incorrect item returned in the result.\\" test_add_media_item() test_search_media() ```","solution":"library_collection = [] def search_media(keyword: str, media_type: str = None) -> list: Search for media items that match the keyword and filter by type if provided. keyword = keyword.lower() result = [ { \\"title\\": item[\\"title\\"], \\"type\\": item[\\"type\\"], \\"description\\": item[\\"description\\"], } for item in library_collection if (keyword in item[\'title\'].lower() or keyword in item[\'description\'].lower()) and (not media_type or item[\'type\'] == media_type) ] return result def add_media_item(media_item: dict) -> None: Adds a new media item to the collection after validating that required fields are present. required_fields = {\'title\', \'type\', \'description\', \'year\', \'author\'} if not required_fields.issubset(media_item): raise ValueError(f\\"Missing required fields: {required_fields - set(media_item.keys())}\\") library_collection.append(media_item)"},{"question":"# Question You are required to implement a function that simulates a simple version of the game \\"Battleship\\". The game board is represented by a 10x10 grid, and you need to track the state of the game and changes in response to player moves. Given the following requirements: - Implement a Python function `battleship_move()` that updates the game board based on an incoming move and determines the outcome of that move. - The board is represented by a list of strings where each string is a row, and each character in the string represents a cell. \'S\' indicates a part of a ship, \'H\' indicates a hit on a ship, and \'.\' indicates an empty cell. - A move is represented by a tuple of integers (row, col) specifying the cell targeted by the player. # Function Signature ```python def battleship_move(board: List[str], move: Tuple[int, int]) -> Tuple[List[str], str]: pass ``` # Parameters - `board`: A list of 10 strings, each representing a row of the game board. - `move`: A tuple containing two integers representing the row index and column index of the targeted cell. # Returns - A tuple containing the updated board (a list of strings) and the outcome (a string: either \\"Hit!\\", \\"Miss!\\", or \\"Already Hit!\\") of the move. # Constraints - The board will always be a 10x10 grid. - The move will always be within the bounds of the board. # Example ```python board = [ \\"..........\\", \\"..S.......\\", \\"..S.......\\", \\"..........\\", \\".....S....\\", \\"..........\\", \\"..........\\", \\"..........\\", \\".....S....\\", \\".....S....\\" ] move = (1, 2) print(battleship_move(board, move)) # Example Output: ([\\"..........\\", \\"..H.......\\", \\"..S.......\\", \\"..........\\", \\".....S....\\", \\"..........\\", \\"..........\\", \\"..........\\", \\".....S....\\", \\".....S....\\"], \\"Hit!\\") move = (0, 0) print(battleship_move(board, move)) # Example Output: ([\\"..........\\", \\"..S.......\\", \\"..S.......\\", \\"..........\\", \\".....S....\\", \\"..........\\", \\"..........\\", \\"..........\\", \\".....S....\\", \\".....S....\\"], \\"Miss!\\") move = (1, 2) print(battleship_move(board, move)) # Example Output: ([\\"..........\\", \\"..H.......\\", \\"..S.......\\", \\"..........\\", \\".....S....\\", \\"..........\\", \\"..........\\", \\"..........\\", \\".....S....\\", \\".....S....\\"], \\"Already Hit!\\") ``` # Additional Note Ensure that your implementation correctly identifies the different types of results from a move and updates the game board accurately. Consider edge cases such as moves to already hit cells and hitting ship parts.","solution":"from typing import List, Tuple def battleship_move(board: List[str], move: Tuple[int, int]) -> Tuple[List[str], str]: row, col = move cell = board[row][col] if cell == \'S\': new_row = board[row][:col] + \'H\' + board[row][col + 1:] board[row] = new_row outcome = \\"Hit!\\" elif cell == \'.\': outcome = \\"Miss!\\" elif cell == \'H\': outcome = \\"Already Hit!\\" return board, outcome"},{"question":"# Problem Description You are required to enhance a Hash Table to efficiently handle collisions using separate chaining with linked lists, and implement additional functionalities to support dynamic resizing and item retrieval by key. # Objectives 1. Implement separate chaining to handle collisions in the Hash Table. 2. Add functionality to dynamically resize the Hash Table when the load factor exceeds a certain threshold. 3. Provide robust methods to insert, delete, and retrieve values by key. # Requirements Part 1: Separate Chaining Collision Handling * **Function Signature**: `def insert(self, key: int, value: Any) -> None` * **Function Signature**: `def delete(self, key: int) -> None` * **Function Signature**: `def retrieve(self, key: int) -> Any` * **Inputs**: Keys are integers, and values can be any data type. * **Outputs**: `insert` and `delete` return `None`. `retrieve` returns the value associated with the given key, or `None` if the key is not present in the table. * **Constraints**: - The hash table will use a simple modular hash function for this exercise: `hash_code = key % current_capacity`. - Collisions should be handled using separate chaining with linked lists. Part 2: Dynamic Resizing * Automatically resize the Hash Table (double the size) when the load factor exceeds 0.7. - Load factor is defined as `number of elements / current_capacity`. - Rehash all keys and redistribute them across the new buckets when resizing occurs. Part 3: Comprehensive Linked List Implementation for Chaining * Design a simple linked list class for managing collisions within each bucket of the hash table. # Input and Output Format ```python # Example for Part 1 hash_table = HashTable(10) # Initial capacity is 10 hash_table.insert(15, \'value1\') print(hash_table.retrieve(15)) # Output should be \'value1\' hash_table.delete(15) print(hash_table.retrieve(15)) # Output should be None # Example for Part 2 hash_table = HashTable(2) # Capacity starts at 2 hash_table.insert(1, \'value1\') hash_table.insert(2, \'value2\') hash_table.insert(3, \'value3\') # This should trigger resizing print(hash_table.retrieve(1)) # Output should be \'value1\' print(hash_table.retrieve(2)) # Output should be \'value2\' print(hash_table.retrieve(3)) # Output should be \'value3\' # Example for Part 3 linked_list = LinkedList() linked_list.insert(1, \'value1\') linked_list.insert(2, \'value2\') print(linked_list.find(1)) # Output should be \'value1\' linked_list.delete(1) print(linked_list.find(1)) # Output should be None ``` Performance and Constraints - Ensure efficient average time complexity for insertion, deletion, and retrieval: O(1) on average due to hash table properties. - Properly handle edge cases such as inserting, deleting, and retrieving from an empty list within a bucket, and rehashing on resizing. # Function Details 1. `insert(self, key: int, value: Any) -> None` 2. `delete(self, key: int) -> None` 3. `retrieve(self, key: int) -> Any` 4. Additional helper functions for managing the linked list and resizing. # Scenario Imagine you are developing a data catalog service that frequently stores and retrieves metadata about various datasets by using unique dataset IDs. To ensure quick access and manage dynamically updating data, you need a robust Hash Table implementation that can handle collisions effectively and resize dynamically as the volume of data grows. By implementing separate chaining and supporting dynamic resizing, you can maintain efficient performance and correct data retrieval under varying loads.","solution":"class LinkedListNode: def __init__(self, key, value): self.key = key self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, key, value): current = self.head while current is not None: if current.key == key: current.value = value return current = current.next new_node = LinkedListNode(key, value) new_node.next = self.head self.head = new_node def delete(self, key): current = self.head prev = None while current is not None: if current.key == key: if prev: prev.next = current.next else: self.head = current.next return prev = current current = current.next def find(self, key): current = self.head while current is not None: if current.key == key: return current.value current = current.next return None class HashTable: def __init__(self, capacity=10): self.capacity = capacity self.size = 0 self.buckets = [LinkedList() for _ in range(capacity)] def _hash(self, key): return key % self.capacity def _resize(self): old_buckets = self.buckets self.capacity *= 2 self.buckets = [LinkedList() for _ in range(self.capacity)] self.size = 0 for bucket in old_buckets: current = bucket.head while current is not None: self.insert(current.key, current.value) current = current.next def insert(self, key, value): if self.size / self.capacity >= 0.7: self._resize() index = self._hash(key) self.buckets[index].insert(key, value) self.size += 1 def delete(self, key): index = self._hash(key) bucket = self.buckets[index] bucket.delete(key) self.size -= 1 def retrieve(self, key): index = self._hash(key) return self.buckets[index].find(key)"},{"question":"# Problem Statement Create a Python function to find the shortest path in a weighted directed graph using Dijkstra\'s algorithm. You need to implement a class that represents the graph and includes a method to perform Dijkstra\'s shortest path algorithm. # Requirements 1. **Class Definition**: Define a class called `WeightedDirectedGraph`. 2. **Methods**: - `__init__(self, vertices: list[T], edges: list[tuple[T, T, float]])`: Initializes the graph. - `add_vertex(self, vertex: T)`: Adds a vertex to the graph. - `add_edge(self, source_vertex: T, destination_vertex: T, weight: float)`: Adds a weighted edge to the graph. - `shortest_path(self, start_vertex: T, end_vertex: T) -> tuple[list[T], float]`: Computes the shortest path from `start_vertex` to `end_vertex` using Dijkstra\'s algorithm. 3. **Error Handling**: Properly handle cases where vertices do not exist or edges involve non-existent vertices. 4. **Constraints**: - All vertices are unique. - Edge weights are non-negative floating-point numbers. - The graph can contain up to 100 vertices and 10,000 edges. - The input will always be well-formed and valid. # Input/Output Structure - **Input**: N/A (The input parameters will be method parameters) - **Output**: - The `shortest_path` method returns a tuple: The first element is a list of vertices representing the shortest path, and the second element is the total cost (weight) of this path. - Returns an empty list and `float(\'inf\')` if no path exists. # Example ```python # Example Usage graph = WeightedDirectedGraph(vertices=[1, 2, 3, 4], edges=[(1, 2, 1.0), (2, 3, 2.5), (3, 4, 0.5)]) graph.add_vertex(5) graph.add_edge(4, 5, 2.0) path, cost = graph.shortest_path(1, 5) print(path) # Output: [1, 2, 3, 4, 5] print(cost) # Output: 6.0 path, cost = graph.shortest_path(1, 6) print(path) # Output: [] print(cost) # Output: inf ``` # Implementation ```python from typing import TypeVar, Generic, List, Tuple, Dict import heapq T = TypeVar(\'T\') class WeightedDirectedGraph(Generic[T]): def __init__(self, vertices: List[T], edges: List[Tuple[T, T, float]]): self.adjacency_list: Dict[T, Dict[T, float]] = {} for vertex in vertices: self.adjacency_list[vertex] = {} for (src, dest, weight) in edges: self.add_edge(src, dest, weight) def add_vertex(self, vertex: T): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = {} def add_edge(self, source_vertex: T, destination_vertex: T, weight: float): if source_vertex in self.adjacency_list and destination_vertex in self.adjacency_list: self.adjacency_list[source_vertex][destination_vertex] = weight def shortest_path(self, start_vertex: T, end_vertex: T) -> Tuple[List[T], float]: if start_vertex not in self.adjacency_list or end_vertex not in self.adjacency_list: return [], float(\'inf\') distances = {vertex: float(\'inf\') for vertex in self.adjacency_list} distances[start_vertex] = 0 previous_vertices = {vertex: None for vertex in self.adjacency_list} priority_queue = [(0, start_vertex)] heapq.heapify(priority_queue) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adjacency_list[current_vertex].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_vertices[neighbor] = current_vertex heapq.heappush(priority_queue, (distance, neighbor)) path = [] current_vertex = end_vertex while previous_vertices[current_vertex] is not None: path.insert(0, current_vertex) current_vertex = previous_vertices[current_vertex] if path: path.insert(0, current_vertex) return path, distances[end_vertex] if distances[end_vertex] != float(\'inf\') else float(\'inf\') ```","solution":"from typing import TypeVar, Generic, List, Tuple, Dict import heapq T = TypeVar(\'T\') class WeightedDirectedGraph(Generic[T]): def __init__(self, vertices: List[T], edges: List[Tuple[T, T, float]]): self.adjacency_list: Dict[T, Dict[T, float]] = {} for vertex in vertices: self.adjacency_list[vertex] = {} for (src, dest, weight) in edges: self.add_edge(src, dest, weight) def add_vertex(self, vertex: T): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = {} def add_edge(self, source_vertex: T, destination_vertex: T, weight: float): if source_vertex in self.adjacency_list and destination_vertex in self.adjacency_list: self.adjacency_list[source_vertex][destination_vertex] = weight def shortest_path(self, start_vertex: T, end_vertex: T) -> Tuple[List[T], float]: if start_vertex not in self.adjacency_list or end_vertex not in self.adjacency_list: return [], float(\'inf\') distances = {vertex: float(\'inf\') for vertex in self.adjacency_list} distances[start_vertex] = 0 previous_vertices = {vertex: None for vertex in self.adjacency_list} priority_queue = [(0, start_vertex)] heapq.heapify(priority_queue) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adjacency_list[current_vertex].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_vertices[neighbor] = current_vertex heapq.heappush(priority_queue, (distance, neighbor)) path = [] current_vertex = end_vertex while previous_vertices[current_vertex] is not None: path.insert(0, current_vertex) current_vertex = previous_vertices[current_vertex] if path: path.insert(0, current_vertex) return path, distances[end_vertex] if distances[end_vertex] != float(\'inf\') else float(\'inf\')"},{"question":"# Coding Challenge: Least Recently Used (LRU) Cache Implementation **Context**: An LRU Cache is a data structure that maintains a fixed number of elements, removing the least recently used (i.e., least accessed or least written) entry when the cache exceeds its size limit. # Task Implement a class `LRUCache` using a dictionary for fast access and a doubly linked list (DLL) for tracking the usage order. Your class should support the following operations: 1. **Get**: Retrieve the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. 2. **Put**: Insert or update the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting the new item. 3. **Print Cache**: Print the elements of the cache from most recently used to least recently used. # Input and Output - **Get Operation**: - Method: `get(key: int) -> int` - Input: Integer key. - Output: Integer value corresponding to key or -1 if the key does not exist. - **Put Operation**: - Method: `put(key: int, value: int) -> None` - Input: Integer key and value. - Output: None. - **Print Cache**: - Method: `print_cache() -> None` - Output: Print elements starting from most recently used to least recently used. # Constraints 1. The cache will have a maximum fixed size `n` specified when the cache is created. 2. Implement all required functions. 3. Maintain a dictionary to store key-value pairs and a doubly linked list to maintain the order of use. # Scenario Create an `LRUCache` instance with a size limit of 3. Perform get and put operations while ensuring the correct implementation of cache functionality. ```python class Node: def __init__(self, key: int, value: int) -> None: self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node) -> None: prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node: Node) -> None: node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) new_node = Node(key, value) self._add(new_node) self.cache[key] = new_node if len(self.cache) > self.capacity: lru = self.tail.prev self._remove(lru) del self.cache[lru.key] def print_cache(self) -> None: current = self.head.next while current != self.tail: print(f\\"{current.key}:{current.value}\\", end=\\" \\") current = current.next print() if __name__ == \\"__main__\\": cache = LRUCache(3) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) cache.print_cache() # Expected Output: 3:3 2:2 1:1 cache.get(2) cache.print_cache() # Expected Output: 2:2 3:3 1:1 cache.put(4, 4) cache.print_cache() # Expected Output: 4:4 2:2 3:3 (1:1 is removed) print(cache.get(1)) # Expected Output: -1 (as 1 was removed) print(cache.get(3)) # Expected Output: 3 cache.print_cache() # Expected Output: 3:3 4:4 2:2 (3 is moved to the front) ``` Ensure to include edge cases such as cache overflow and correct eviction of the least recently used element.","solution":"class Node: def __init__(self, key: int, value: int) -> None: self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node) -> None: prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node: Node) -> None: node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) new_node = Node(key, value) self._add(new_node) self.cache[key] = new_node if len(self.cache) > self.capacity: lru = self.tail.prev self._remove(lru) del self.cache[lru.key] def print_cache(self) -> None: current = self.head.next while current != self.tail: print(f\\"{current.key}:{current.value}\\", end=\\" \\") current = current.next print()"},{"question":"# Scenario You are tasked with building a recommendation system for an e-commerce platform. The platform sells a variety of products, and the recommendation system needs to suggest products based on user behavior patterns. # Task Implement a Trie data structure that can efficiently handle the following types of operations: 1. **Insert**: Add a new product name to the Trie structure. 2. **Search**: Check if a product name exists in the Trie. 3. **Starts With**: Return all product names that start with a given prefix. # Input and Output Format * **Input**: 1. `operations` - A list of dictionary objects, each with: - `type` - One of `\'insert\'`, `\'search\'`, or `\'starts_with\'`. - Additional parameters based on `type`: - For `\'insert\'`: `product` (product name). - For `\'search\'`: `product` (product name). - For `\'starts_with\'`: `prefix` (prefix string). * **Output**: - A list of results from the operations in the order they were performed. - For `\'insert\'` operation, return `None`. - For `\'search\'` operation, return `True` or `False`. - For `\'starts_with\'` operation, return a list of product names. # Constraints - Product names will be lowercase strings containing only alphabetical characters. - Each operation involving a product name or prefix will ensure the lengths do not exceed (100). - The number of operations will be up to (10^4). # Example ```python from typing import List, Dict, Union Operation = Dict[str, Union[str, None]] class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._search_prefix(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> List[str]: node = self._search_prefix(prefix) if not node: return [] return self._find_words_with_prefix(node, prefix) def _search_prefix(self, prefix: str) -> TrieNode: node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node def _find_words_with_prefix(self, node: TrieNode, prefix: str) -> List[str]: result = [] if node is None: return result if node.is_end_of_word: result.append(prefix) for char, child_node in node.children.items(): result.extend(self._find_words_with_prefix(child_node, prefix + char)) return result def trie_operations(operations: List[Operation]) -> List[Union[None, bool, List[str]]]: trie = Trie() results = [] for operation in operations: if operation[\'type\'] == \'insert\': trie.insert(operation[\'product\']) results.append(None) elif operation[\'type\'] == \'search\': result = trie.search(operation[\'product\']) results.append(result) elif operation[\'type\'] == \'starts_with\': result = trie.starts_with(operation[\'prefix\']) results.append(result) return results # Example usage: test_operations = [ {\\"type\\": \\"insert\\", \\"product\\": \\"apple\\"}, {\\"type\\": \\"insert\\", \\"product\\": \\"app\\"}, {\\"type\\": \\"search\\", \\"product\\": \\"apple\\"}, {\\"type\\": \\"search\\", \\"product\\": \\"app\\"}, {\\"type\\": \\"search\\", \\"product\\": \\"appl\\"}, {\\"type\\": \\"starts_with\\", \\"prefix\\": \\"app\\"}, {\\"type\\": \\"starts_with\\", \\"prefix\\": \\"appl\\"}, {\\"type\\": \\"starts_with\\", \\"prefix\\": \\"apx\\"} ] print(trie_operations(test_operations)) # Expected output: [None, None, True, True, False, [\'app\', \'apple\'], [\'apple\'], []] ```","solution":"from typing import List, Dict, Union Operation = Dict[str, Union[str, None]] class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._search_prefix(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> List[str]: node = self._search_prefix(prefix) if not node: return [] return self._find_words_with_prefix(node, prefix) def _search_prefix(self, prefix: str) -> TrieNode: node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node def _find_words_with_prefix(self, node: TrieNode, prefix: str) -> List[str]: result = [] if node.is_end_of_word: result.append(prefix) for char, child_node in node.children.items(): result.extend(self._find_words_with_prefix(child_node, prefix + char)) return result def trie_operations(operations: List[Operation]) -> List[Union[None, bool, List[str]]]: trie = Trie() results = [] for operation in operations: if operation[\'type\'] == \'insert\': trie.insert(operation[\'product\']) results.append(None) elif operation[\'type\'] == \'search\': result = trie.search(operation[\'product\']) results.append(result) elif operation[\'type\'] == \'starts_with\': result = trie.starts_with(operation[\'prefix\']) results.append(result) return results"},{"question":"# Quadratic Equation Solver **Objective**: Write a function to find the real roots of a quadratic equation, adhering to specific constraints and requirements. Function Signature ```python def solve_quadratic(a: float, b: float, c: float) -> Union[Tuple[float, float], Tuple[float], str]: Returns the real roots of the quadratic equation ax^2 + bx + c = 0. pass ``` # Input * Three float values `a`, `b`, and `c` which are the coefficients of the quadratic equation. * The input must include at least one non-zero value among the three coefficients. # Output * A tuple of two float values representing the real roots if there are two distinct real roots. * A tuple with one float value if there is only one real root (a repeated root). * A string `\\"No Real Roots\\"` if there are no real roots. # Constraints * The function should handle coefficients provided up to ±10^6. * Raise a `ValueError` if all of the coefficients `a`, `b`, and `c` are zero. # Example Cases Example 1: **Input**: ```python a = 1 b = -3 c = 2 ``` **Output**: ```python (2.0, 1.0) ``` **Explanation**: The quadratic equation x^2 - 3x + 2 = 0 has two real roots: 2 and 1. Example 2: **Input**: ```python a = 1 b = 2 c = 1 ``` **Output**: ```python (-1.0,) ``` **Explanation**: The quadratic equation x^2 + 2x + 1 = 0 has one real root: -1. Example 3: **Input**: ```python a = 1 b = 0 c = 1 ``` **Output**: ```python \\"No Real Roots\\" ``` **Explanation**: The quadratic equation x^2 + 1 = 0 has no real roots. # Implementation Hints 1. Calculate the discriminant ( b^2 - 4ac ). 2. Determine the nature of the roots based on the value of the discriminant: - If the discriminant is positive, there are two distinct roots. - If the discriminant is zero, there is one repeated root. - If the discriminant is negative, there are no real roots. 3. Handle edge cases as described.","solution":"from typing import Union, Tuple import math def solve_quadratic(a: float, b: float, c: float) -> Union[Tuple[float, float], Tuple[float], str]: if a == 0 and b == 0 and c == 0: raise ValueError(\'At least one coefficient must be non-zero.\') if a == 0: # Handle linear case bx + c = 0 if b == 0: return \\"No Real Roots\\" return (-c / b,) discriminant = b**2 - 4*a*c if discriminant > 0: root1 = (-b + math.sqrt(discriminant)) / (2 * a) root2 = (-b - math.sqrt(discriminant)) / (2 * a) return (root1, root2) elif discriminant == 0: root = -b / (2 * a) return (root,) else: return \\"No Real Roots\\""},{"question":"# Unique Elements Intersection Challenge You are tasked with writing a function that identifies the common unique elements shared among two given lists of integers. The function should merge the results from both lists and return a sorted list of these common elements. Function Signature ```python def unique_elements_intersection(list1: list[int], list2: list[int]) -> list[int]: # implementation here ``` Input - `list1` (list of int): The first list of integers. - `list2` (list of int): The second list of integers. Output - (list of int): A sorted list of unique elements that are present in both lists. Constraints - The length of `list1` and `list2` will not exceed 10^6. - The integers in both lists will be within the range of -10^6 to 10^6. Requirements - Ensure each returned element appears only once in the output list. - Handle cases where there are no common elements, or either list is empty. - Aim for an efficient approach with regards to both time and space complexity. Performance - The solution should ideally have a time complexity better than O(n*m), where n is the length of `list1` and m is the length of `list2`. Example ```python print(unique_elements_intersection([1, 2, 2, 3, 4], [3, 3, 4, 4, 5])) # Output: [3, 4] print(unique_elements_intersection([7, 8, 9], [9, 10, 11])) # Output: [9] print(unique_elements_intersection([], [1, 2, 3])) # Output: [] print(unique_elements_intersection([5, 6, 7], [8, 9, 10])) # Output: [] ``` Notes * Ensure the solution handles edge cases such as lists with duplicate values, negative numbers, and very large inputs. * Document the core logic and thought process in the comments for clarity.","solution":"def unique_elements_intersection(list1: list[int], list2: list[int]) -> list[int]: Returns a sorted list of unique elements that are present in both input lists. # Convert both lists to sets to filter unique elements and then perform intersection. set1 = set(list1) set2 = set(list2) # Find the common elements between both sets. common_elements = set1.intersection(set2) # Convert the resultant set to a list and sort it before returning. return sorted(common_elements)"},{"question":"# Problem Statement You are tasked with implementing a function that checks if a provided string is a valid rotated palindrome. A rotated palindrome is a string that can be rotated (shifted circularly to the left or right) to form a palindrome. Function Signature ```python def is_rotated_palindrome(s: str) -> bool: ``` Input - `s` (str): A string of length `1 <= len(s) <= 1000`, containing only lowercase alphabets. Output - `bool`: Returns `True` if the string is a valid rotated palindrome, otherwise `False`. Constraints - You must create helper functions `is_palindrome`, and `rotate_string` as needed, which will be used inside the main `is_rotated_palindrome` function. - The performance of the solution should be optimized to handle the upper limit of the input size. # Example ```python s1 = \\"aabb\\" print(is_rotated_palindrome(s1)) # Output should be: # True # Explanation: Rotating \\"aabb\\" results in \\"abba\\", which is a palindrome. s2 = \\"abcde\\" print(is_rotated_palindrome(s2)) # Output should be: # False # Explanation: No rotation of \\"abcde\\" results in a palindrome. s3 = \\"aba\\" print(is_rotated_palindrome(s3)) # Output should be: # True # Explanation: \\"aba\\" is already a palindrome, no rotation needed. s4 = \\"abcabc\\" print(is_rotated_palindrome(s4)) # Output should be: # False # Explanation: No rotation of \\"abcabc\\" results in a palindrome. ``` # Additional Notes - A palindrome is a string that reads the same forwards and backwards, e.g., \\"madam\\". - Rotations of a string should be made circularly, meaning after the last character, the string wraps around back to the beginning. For example, a left rotation of the string \\"abc\\" results in \\"bca\\", and a right rotation results in \\"cab\\". - Test your functions thoroughly to ensure all edge cases are covered.","solution":"def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. return s == s[::-1] def rotate_string(s: str, n: int) -> str: Rotate a string s to the left by n positions. return s[n:] + s[:n] def is_rotated_palindrome(s: str) -> bool: Check if any rotation of the given string is a palindrome. for i in range(len(s)): if is_palindrome(rotate_string(s, i)): return True return False"},{"question":"# Coding Assessment Question As a software engineer, you are tasked with enhancing the functionality of an e-commerce platform by implementing a solution that tracks customers\' shopping carts and calculates the total cost including applied discounts. The current system does not account for various edge cases and lacks performance optimization, particularly when calculating discounts. Your task is to: 1. Refactor the existing `calculate_total_cost` function to improve performance and incorporate error handling. 2. Implement a new function that applies percentage-based and fixed-amount discounts and recalculates the total cart value. 3. Provide documentation for the new function and update the existing one. Expected Input and Output **Function 1**: `def calculate_total_cost(cart: list[dict[str, int | float]]) -> float`: Calculate the total cost of the shopping cart. - **Input**: A cart (list) containing dictionaries of items with \'price\' (float) and \'quantity\' (int). - **Output**: The total cost (float) of items in the cart. **Function 2**: `def apply_discounts(cart: list[dict[str, int | float]], discounts: list[dict[str, float | int]]) -> float`: Apply discounts to the cart and recalculate the total cost. - **Input**: - `cart` (list): List of items with \'price\' and \'quantity\'. - `discounts` (list): List of discounts with each discount as a dictionary in the format {\'type\': \'percentage\' or \'fixed\', \'value\': float or int}. - **Output**: The new total cost (float) after applying discounts. # Constraints - Ensure all input data is properly validated, including negative values and incorrect formats. - Include edge cases such as empty carts and invalid discount values. - Optimize the calculations to handle large carts efficiently. Example - **Input**: `cart = [{\'price\': 10.0, \'quantity\': 2}, {\'price\': 15.0, \'quantity\': 1}]`, `discounts = [{\'type\': \'percentage\', \'value\': 10}, {\'type\': \'fixed\', \'value\': 5}]` - **Output**: `32.0` (total after applying discounts: first a 10% discount on 35 = 31.5, then subtracting fixed amount 5) # Provided Functions (before refactoring for performance and error handling) ```python def calculate_total_cost(cart: list[dict[str, int | float]]) -> float: total = 0.0 for item in cart: total += item[\'price\'] * item[\'quantity\'] return total def apply_discounts(cart: list[dict[str, int | float]], discounts: list[dict[str, float | int]]) -> float: total = calculate_total_cost(cart) for discount in discounts: if discount[\'type\'] == \'percentage\': total -= total * (discount[\'value\'] / 100) elif discount[\'type\'] == \'fixed\': total -= discount[\'value\'] return total ```","solution":"def calculate_total_cost(cart: list[dict[str, int | float]]) -> float: Calculate the total cost of the shopping cart. :param cart: A list of dictionaries containing items with \'price\' (float) and \'quantity\' (int). :return: The total cost (float) of items in the cart. total = 0.0 for item in cart: if isinstance(item[\'price\'], (int, float)) and item[\'price\'] >= 0 and isinstance(item[\'quantity\'], int) and item[\'quantity\'] >= 0: total += item[\'price\'] * item[\'quantity\'] else: raise ValueError(\'Invalid price or quantity in cart item\') return total def apply_discounts(cart: list[dict[str, int | float]], discounts: list[dict[str, float | int]]) -> float: Apply discounts to the cart and recalculate the total cost. :param cart: A list of items with \'price\' (float) and \'quantity\' (int). :param discounts: A list of discounts with each discount as a dictionary in the format {\'type\': \'percentage\' or \'fixed\', \'value\': float or int}. :return: The new total cost (float) after applying discounts. total = calculate_total_cost(cart) for discount in discounts: if discount[\'type\'] == \'percentage\' and 0 <= discount[\'value\'] <= 100: total -= total * (discount[\'value\'] / 100) elif discount[\'type\'] == \'fixed\' and discount[\'value\'] >= 0: total -= discount[\'value\'] else: raise ValueError(\'Invalid discount type or value\') return max(total, 0.0) # Ensure the total cost does not go below 0"},{"question":"# Coding Assessment Question You are given an array of integers representing the heights of a series of contiguous buildings, and you need to calculate the total amount of rainwater that can be trapped between these buildings after a downpour. # Function Specifications Function: `calculate_rainwater` **Input**: - A list of integers (`heights`) representing the height of each building. Each height must be a non-negative integer. **Output**: - An integer representing the total amount of rainwater that can be trapped between the buildings. **Constraints**: - Raise a `ValueError` with the message \\"Height at index X is negative!\\" where X is the index of the negative value if any value is negative. - The input list must contain at least 3 heights; if not, raise a `ValueError` with the message \\"Insufficient number of buildings\\". # Examples ```python # Example 1 print(calculate_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])) # Output: 6 # Example 2 try: calculate_rainwater([3, 0, -1, 2]) except ValueError as e: print(e) # Output: Height at index 2 is negative! # Example 3 try: calculate_rainwater([2]) except ValueError as e: print(e) # Output: Insufficient number of buildings ``` Note: Implement the function ensuring linear time complexity and linear space complexity. --- Ensure that the provided function handles edge cases, such as heights list being too short or containing negative values. The function should correctly calculate the trapped rainwater for valid input lists of heights.","solution":"def calculate_rainwater(heights): Given a list of integers representing the heights of buildings, calculates the total amount of rainwater trapped between the buildings after a downpour. :param heights: List[int] - A list of non-negative integers :return: int - Total amount of rainwater trapped :raises ValueError: If any height is negative or if there are less than 3 heights if len(heights) < 3: raise ValueError(\\"Insufficient number of buildings\\") for i, height in enumerate(heights): if height < 0: raise ValueError(f\\"Height at index {i} is negative!\\") n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"# Two\'s Complement Calculation You are tasked with writing a function that calculates the Two\'s Complement of a given binary string. Two\'s Complement is a way of representing signed integers in binary form and is commonly used in computer science and digital systems. The process involves inverting the bits of the number (i.e., changing 0s to 1s and 1s to 0s) and then adding 1 to the least significant bit (LSB). # Function Signature ```python def twos_complement(binary_str: str) -> str: pass ``` # Input - `binary_str` (str): A string representing a binary number. # Output - Returns the two\'s complement of the input binary string as a new binary string. # Constraints - The input string will contain only \'0\' and \'1\' characters. - The input string will have a length between 1 and 32, inclusive. - The binary string represents a positive integer in unsigned form. # Example ```python assert twos_complement(\\"0001\\") == \\"1111\\" assert twos_complement(\\"1010\\") == \\"0110\\" assert twos_complement(\\"1111\\") == \\"0001\\" assert twos_complement(\\"0000\\") == \\"0000\\" ``` # Context This question is intended to test your ability to manipulate binary representations and understand the concept of Two\'s Complement, which is commonly used for representing negative numbers in computer science. --- This question complements the existing set by focusing on the manipulation of binary strings and understanding numerical representation in digital systems, akin to the logic-based nature of the IMPLY gate problem.","solution":"def twos_complement(binary_str: str) -> str: Calculate the two\'s complement of a given binary string. Args: binary_str (str): A string representing a binary number. Returns: str: The two\'s complement of the input binary string. # Invert the bits inverted_str = \'\'.join(\'1\' if bit == \'0\' else \'0\' for bit in binary_str) # Add 1 to the inverted binary string n = len(inverted_str) result = list(inverted_str) carry = 1 for i in range(n-1, -1, -1): if carry == 0: break if result[i] == \'1\': result[i] = \'0\' else: result[i] = \'1\' carry = 0 # Join list into a string return \'\'.join(result)"},{"question":"# Question: Implement and Use a Custom Sorting Algorithm Context Sorting algorithms are fundamental to computer science, and custom sorting implementations can be crucial for specialized tasks. Your task is to implement a custom sorting algorithm that sorts an array of integers. This algorithm should be a variation of the bubble sort, known as \\"Odd-Even Sort\\" or \\"Brick Sort\\". It is a parallel version of the bubble sort algorithm. Task Implement a function `odd_even_sort(arr: list) -> list` that sorts an array of integers using the Odd-Even Sort algorithm. Requirements 1. **Function Signature**: ```python def odd_even_sort(arr: list) -> list: ``` 2. **Inputs**: - `arr`: A list of integers to be sorted. 3. **Output**: - A sorted list of integers in ascending order. 4. **Constraints**: - The input list `arr` may contain any integer values, including negatives and duplicates. - The length of the input list `arr` will be between 1 and 1000. 5. **Algorithm Specifications**: - The algorithm should repeatedly perform two types of passes: - Odd Pass: Compare and swap elements at odd indices. - Even Pass: Compare and swap elements at even indices. - Continue performing these passes until the array is sorted. Examples ```python >>> odd_even_sort([34, 2, 78, 1, 45, 99]) [1, 2, 34, 45, 78, 99] >>> odd_even_sort([10, -2, 0, 3, 20]) [-2, 0, 3, 10, 20] ``` ```python def odd_even_sort(arr): n = len(arr) is_sorted = False while not is_sorted: is_sorted = True for i in range(1, n-1, 2): # Perform the odd pass if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] is_sorted = False for i in range(0, n-1, 2): # Perform the even pass if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] is_sorted = False return arr ```","solution":"def odd_even_sort(arr): Sorts an array of integers using the Odd-Even Sort algorithm. n = len(arr) is_sorted = False while not is_sorted: is_sorted = True for i in range(1, n-1, 2): # Perform the odd pass if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] is_sorted = False for i in range(0, n-1, 2): # Perform the even pass if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] is_sorted = False return arr"},{"question":"# Coding Question: Roman Numeral Converter Scenario You are building a software tool that requires conversion of numbers between integer and Roman numeral representations. The Roman numeral system originated in ancient Rome and uses combinations of letters from the Latin alphabet (I, V, X, L, C, D, M) to represent values. Your task is to implement a function that converts a given integer to its corresponding Roman numeral, and vice versa. Requirements - Implement two functions: 1. `int_to_roman` which converts an integer to a Roman numeral. 2. `roman_to_int` which converts a Roman numeral to an integer. - Ensure that your implementation correctly handles the standard range of Roman numeral values (1 to 3999). Expected Format ```python def int_to_roman(number: int) -> str: # your implementation here pass def roman_to_int(roman: str) -> int: # your implementation here pass ``` Constraints 1. The integer input for `int_to_roman` will be in the range 1 to 3999. 2. The Roman numeral input for `roman_to_int` will be a valid string representing a number between 1 and 3999. 3. You are allowed to assume that the inputs are always valid within their respective constraints. Examples ```python print(int_to_roman(58)) # \'LVIII\' print(int_to_roman(1994)) # \'MCMXCIV\' print(roman_to_int(\'LVIII\')) # 58 print(roman_to_int(\'MCMXCIV\')) # 1994 ``` Use these examples to verify your implementation.","solution":"def int_to_roman(number: int) -> str: Convert an integer to a Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while number > 0: for _ in range(number // val[i]): roman_num += syms[i] number -= val[i] i += 1 return roman_num def roman_to_int(roman: str) -> int: Convert a Roman numeral to an integer. roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } prev_value = 0 total = 0 for char in reversed(roman): value = roman_to_value[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Prompt: You need to implement a system that can compress a string by converting consecutive repeated characters to a single character followed by the count of that character. If the compressed string is not smaller than the original string, the original string should be returned. Implement the following function: - `compress_string(s: str) -> str`: * Compresses the string `s` by converting consecutive repeated characters to a single character followed by the count of that character. * If the length of the compressed string is not smaller than the original string, return the original string. * You may assume the string contains only uppercase alphabetic characters. # Example: ```python print(compress_string(\\"AABBBCC\\")) # Returns \\"A2B3C2\\" print(compress_string(\\"ABCD\\")) # Returns \\"ABCD\\" print(compress_string(\\"AAABBBBCCCCC\\")) # Returns \\"A3B4C5\\" print(compress_string(\\"AABBCCDDEEFFGG\\")) # Returns \\"AABBCCDDEEFFGG\\" ``` # Constraints: * The input string `s` will have a length between 1 and 1000. * The string contains only uppercase alphabetic characters. # Detailed Explanation: 1. Iterate through the input string and keep a count of consecutive repeated characters. 2. Construct a compressed string using each character followed by its count of repetitions. 3. Compare the length of the compressed string with the original string. 4. Return the compressed string if its length is smaller than the original string; otherwise, return the original string.","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(f\\"{s[i-1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") compressed_str = \'\'.join(compressed) if len(compressed_str) < len(s): return compressed_str else: return s"},{"question":"# Coding Assessment Question: Invert a Binary Tree Problem Statement You are given the root of a binary tree. Write a function `invert_tree` that inverts the binary tree, meaning all left and right children of all nodes are swapped. Write a class `BinaryTreeInverter` that includes the following methods: 1. `__init__()`: Initialization method. 2. `invert_tree(self, root: Node) -> Node`: This method inverts the binary tree starting from the given root node and returns the new root node. Requirements: - **Input Format**: - `root`: The root node of the binary tree (`Node | None`). - **Output Format**: - The new root node of the inverted binary tree (`Node`). Constraints: - Each node in the binary tree has the following attributes: - `value` (int): The value of the node, which can be any integer. - `left` (Node | None): The left child of the node. - `right` (Node | None): The right child of the node. - The binary tree can have up to `10000` nodes. # Example Consider the following examples to ensure clarity of the problem: **Example 1:** Input: ``` 4 / 2 7 / / 1 3 6 9 ``` Output: ``` 4 / 7 2 / / 9 6 3 1 ``` **Example 2:** Input: ``` 1 / 2 ``` Output: ``` 1 2 ``` You can use the `Node` class provided below to create the binary tree nodes. ```python class Node: A Node has a value variable and pointers to nodes to its left and right. def __init__(self, value: int) -> None: self.value = value self.left: Node | None = None self.right: Node | None = None ``` Ensure your solution covers both optimal implementation and performance considerations. Feel free to use additional helper methods if necessary.","solution":"class Node: A Node has a value variable and pointers to nodes to its left and right. def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None class BinaryTreeInverter: def __init__(self): pass def invert_tree(self, root: Node) -> Node: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees self.invert_tree(root.left) self.invert_tree(root.right) return root"},{"question":"# Problem Statement You have been contracted by an app development company to build a module that handles user authentication processes. The company requires the implementation of a function to enforce password policies for account security. One such policy is that passwords must be strong according to specified criteria. # Task Implement a function `is_strong_password` that checks if a given password meets the following criteria: 1. At least 8 characters long. 2. Contains both upper and lower case characters. 3. Includes at least one numerical digit. 4. Contains at least one special character (e.g., !, @, #, ). Function Signature ```python def is_strong_password(password: str) -> bool: ``` Input * `password` (str): The password string to be evaluated. Output * (bool): Return `True` if the password is strong according to the criteria specified; otherwise, return `False`. Constraints * The password string is non-empty and consists of printable ASCII characters. # Example ```python print(is_strong_password(\\"Aa1!aaaa\\")) # False (less than 8 characters) print(is_strong_password(\\"Aa1!aaaaa\\")) # True (meets all criteria) print(is_strong_password(\\"Aa1Aaaaaa\\")) # False (no special character) print(is_strong_password(\\"aa1!aaaaa\\")) # False (no uppercase character) print(is_strong_password(\\"AA1!AAAAA\\")) # False (no lowercase character) print(is_strong_password(\\"Aa!aaaaaa\\")) # False (no digit) ``` # Notes 1. To implement your solution, consider iterating over the password string to check for the presence of characters meeting each criterion. 2. Ensure to document any assumptions or edge cases identified during your implementation.","solution":"def is_strong_password(password: str) -> bool: Checks if the password is strong. A strong password meets the following criteria: 1. At least 8 characters long. 2. Contains both upper and lower case characters. 3. Includes at least one numerical digit. 4. Contains at least one special character (e.g., !, @, #, ). Args: password (str): The password string to be evaluated. Returns: bool: True if the password is strong, otherwise False. if len(password) < 8: return False has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in \'!@#%^&*()-_+=<>?/|[]{}:;,\\"\'~`\' for c in password) return has_upper and has_lower and has_digit and has_special"},{"question":"# Coding Assessment Question **Scenario**: You\'re tasked with creating a small module for a financial application that processes transaction data. The module should summarize the transactions by categories and provide insights. **Objective**: Write a function `summarize_transactions` that: 1. Processes a list of transactions. 2. Aggregates the total amount spent in each category. 3. Returns the results as a dictionary where the keys are categories and the values are the total amounts spent in those categories. **Function Signature**: ```python def summarize_transactions(transactions: list[dict]) -> dict[str, float]: Summarize transaction amounts by category. Args: - transactions (list[dict]): A list of transactions, where each transaction is a dictionary with keys \'amount\' (float) and \'category\' (str). Returns: - dict[str, float]: A dictionary with categories as keys and the total amounts spent as values. ``` **Constraints**: - **Input**: - `transactions`: A non-empty list of dictionaries, each representing a transaction with the following structure: ```python { \\"amount\\": 50.0, \\"category\\": \\"Groceries\\" } ``` - **Output**: - A dictionary where each key is a unique category from the transactions, and the value is the sum of all amounts spent in that category. **Example**: ```python transactions = [ {\\"amount\\": 50.0, \\"category\\": \\"Groceries\\"}, {\\"amount\\": 20.0, \\"category\\": \\"Transport\\"}, {\\"amount\\": 15.0, \\"category\\": \\"Groceries\\"}, {\\"amount\\": 5.0, \\"category\\": \\"Entertainment\\"} ] result = summarize_transactions(transactions) Expected Output (example): { \\"Groceries\\": 65.0, \\"Transport\\": 20.0, \\"Entertainment\\": 5.0 } ``` **Guidelines for Implementation**: 1. **Transaction Processing**: Iterate through the list of transactions to aggregate amounts correctly. 2. **Sum Calculation**: Ensure accurate summation of amounts for each category. 3. **Dictionary Management**: Efficiently handle dictionary operations to store results. 4. **Edge Cases**: Consider cases with varying transaction structures or empty category names. 5. **Data Types**: The `amount` should be processed as a float to handle decimal values accurately.","solution":"def summarize_transactions(transactions): Summarize transaction amounts by category. Args: - transactions (list[dict]): A list of transactions, where each transaction is a dictionary with keys \'amount\' (float) and \'category\' (str). Returns: - dict[str, float]: A dictionary with categories as keys and the total amounts spent as values. summary = {} for transaction in transactions: category = transaction[\'category\'] amount = transaction[\'amount\'] if category in summary: summary[category] += amount else: summary[category] = amount return summary"},{"question":"Problem Description You are given a string containing digits from 2 to 9 inclusive, generated by pressing keys on a telephone keypad. Each digit maps to a set of letters, as shown below: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" Your task is to return all possible letter combinations that the number could represent. Implement this using a recursive backtracking approach. Function Signature ```python def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2 to 9, return all possible letter combinations that the number could represent. Parameters: ---------- digits: str - A string containing digits from 2 to 9. Returns: ------- List[str] - A list of all possible letter combinations. Constraints: ----------- - 0 <= len(digits) <= 4 - digits[i] is a digit between \'2\'-\'9\'. Notes: ------ - An empty input string should return an empty list. ``` Example ```python assert letter_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] assert letter_combinations(\\"\\") == [] assert letter_combinations(\\"2\\") == [\\"a\\", \\"b\\", \\"c\\"] assert letter_combinations(\\"9\\") == [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] ``` # Constraints * Returns all combinations in lexicographical order, if necessary. * Handle edge cases where the input string is empty or contains a single digit. # Performance Requirement * The solution should use a recursive backtracking approach and handle edge cases efficiently. # Edge Cases to Handle * If the input string contains no digits. * If the input string contains only one digit. * Ensuring no combinations are generated for invalid digits (e.g., 0 or 1).","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: if not digits: return [] phone_keypad = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return possible_letters = phone_keypad[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"# Task You are given a class that represents a collection of books in a library. Each book has a unique ISBN number, title, author, and publication year. Your task is to extend this class by adding functionality to search for books based on different criteria. # Extended Functionality: **Search Criteria**: Implement searches based on: - Title - Author - Publication Year # Implementation: * Add methods `search_by_title`, `search_by_author`, and `search_by_year` to the `Library` class. * Each method should accept a string or integer parameter and return a list of books that match the search criteria. * Ensure the methods handle cases where no matches are found gracefully. # Input and Output: Implement your solution through the following steps: * Instantiate the `Library` object and add some initial book data. * Use the search methods to find books based on the given criteria. * Verify your implementation using a few example test cases. # Constraints: - Assume valid, non-null string inputs for titles and authors. - Assume valid numerical inputs for publication years. # Example: ```python # Assuming `Library` is already defined as per provided code snippet. class Library: def __init__(self): self.books = [] def add_book(self, isbn, title, author, year): self.books.append({\\"ISBN\\": isbn, \\"Title\\": title, \\"Author\\": author, \\"Year\\": year}) def search_by_title(self, title): return [book for book in self.books if title.lower() in book[\\"Title\\"].lower()] def search_by_author(self, author): return [book for book in self.books if author.lower() in book[\\"Author\\"].lower()] def search_by_year(self, year): return [book for book in self.books if book[\\"Year\\"] == year] # Create an instance of the Library library = Library() # Add some books library.add_book(\\"978-3-16-148410-0\\", \\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) library.add_book(\\"978-0-14-028329-7\\", \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(\\"978-0-452-28423-4\\", \\"1984\\", \\"George Orwell\\", 1949) library.add_book(\\"978-0-452-28423-4\\", \\"Animal Farm\\", \\"George Orwell\\", 1945) # Search for books by title print(\\"Search by Title - \'1984\':\\") print(library.search_by_title(\\"1984\\")) # Search for books by author print(\\"Search by Author - \'George Orwell\':\\") print(library.search_by_author(\\"George Orwell\\")) # Search for books by publication year print(\\"Search by Year - 1945:\\") print(library.search_by_year(1945)) ``` Implement the required methods in the `Library` class and test thoroughly with different criteria.","solution":"class Library: def __init__(self): self.books = [] def add_book(self, isbn, title, author, year): self.books.append({\\"ISBN\\": isbn, \\"Title\\": title, \\"Author\\": author, \\"Year\\": year}) def search_by_title(self, title): return [book for book in self.books if title.lower() in book[\\"Title\\"].lower()] def search_by_author(self, author): return [book for book in self.books if author.lower() in book[\\"Author\\"].lower()] def search_by_year(self, year): return [book for book in self.books if book[\\"Year\\"] == year]"},{"question":"# Problem Statement: Your task is to implement a **Graph Search Algorithm with Weight Adjustments** to efficiently find the shortest path in a weighted undirected graph while dynamically adjusting edge weights based on certain conditions. # Requirements: 1. **Function to Adjust Edge Weights:** - Implement a function `adjust_edge_weights(graph: Dict[int, List[Tuple[int, int]]], conditions: List[Tuple[int, int, int]]) -> None` that adjusts the weights of the edges in the graph based on provided conditions. Each condition is a tuple `(u, v, new_weight)` specifying that the weight of the edge between node `u` and node `v` should be updated to `new_weight`. 2. **Dijkstra\'s Algorithm with Weight Adjustments:** - Implement a modified Dijkstra\'s algorithm, `modified_dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, adjust_weights: bool) -> Dict[int, int]`, which finds the shortest path from the `start` node to all other nodes. If `adjust_weights` is `True`, the algorithm should first call `adjust_edge_weights` to update the graph weights before finding the shortest paths. 3. **Performance Logging:** - Add functionality to log key metrics such as the total number of nodes visited and the execution time for the algorithm. # Input/Output Formats: * **Input:** - `graph`: A dictionary representing the weighted undirected graph where keys are node identifiers and values are lists of tuples `(neighbor, weight)` representing the connected nodes and edge weights. - `start`: An integer representing the starting node. - `conditions`: A list of tuples `(u, v, new_weight)` which is only used if `adjust_weights` is `True`. - `adjust_weights`: A boolean indicating whether or not to adjust edge weights before executing the search algorithm. * **Output:** - A dictionary where keys represent nodes and values represent the shortest distance from the `start` node. - Log of performance metrics. # Constraints: - The graph will have no more than 1000 nodes and 5000 edges. - Node identifiers will be integers. - Edge weights will be positive integers. # Sample Usage: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(0, 4), (3, 1), (4, 5)], 2: [(0, 1), (3, 2)], 3: [(1, 1), (2, 2), (4, 3)], 4: [(1, 5), (3, 3)] } start = 0 conditions = [(1, 3, 2), (0, 2, 2)] adjust_weights = True shortest_paths, metrics = modified_dijkstra(graph, start, conditions, adjust_weights) print(\\"Shortest Paths:\\", shortest_paths) print(\\"Metrics:\\", metrics) ``` **Note:** Ensure that the algorithm efficiently handles updates in edge weights and logs the necessary performance metrics accurately.","solution":"import heapq import time from typing import Dict, List, Tuple def adjust_edge_weights(graph: Dict[int, List[Tuple[int, int]]], conditions: List[Tuple[int, int, int]]) -> None: for u, v, new_weight in conditions: for index, (neighbor, weight) in enumerate(graph[u]): if neighbor == v: graph[u][index] = (neighbor, new_weight) for index, (neighbor, weight) in enumerate(graph[v]): if neighbor == u: graph[v][index] = (neighbor, new_weight) def modified_dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, conditions: List[Tuple[int, int, int]], adjust_weights: bool) -> Tuple[Dict[int, int], Dict[str, object]]: if adjust_weights: adjust_edge_weights(graph, conditions) distances = {node: float(\'inf\') for node in graph} distances[start] = 0 visited = set() priority_queue = [(0, start)] nodes_visited_count = 0 start_time = time.time() while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) nodes_visited_count += 1 if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) end_time = time.time() execution_time = end_time - start_time metrics = { \\"nodes_visited\\": nodes_visited_count, \\"execution_time\\": execution_time, } return distances, metrics"},{"question":"# Problem: Implement a Sudoku Solver Background Sudoku is a number puzzle famously known for its 9x9 grid constraints. Each of the grid\'s 3x3 sub-grids must contain all numbers from 1 to 9 without repetition. The challenge is to fill the empty cells, where zeros represent blanks, such that every row, column, and sub-grid (3x3) contains all numbers from 1 to 9 exactly once. This problem tests your understanding of recursion, backtracking, and constraint satisfaction problems. Task Implement a `SudokuSolver` class in Python that solves a given Sudoku puzzle using recursive backtracking. Input - `board`: A 2D list of integers representing the Sudoku grid (9x9), where zeros represent empty cells. Output - The solved Sudoku grid as a 2D list of integers. Constraints 1. The input board will always be a 9x9 grid with integers between 0 and 9. 2. There will always be a possible solution to the provided Sudoku puzzle. Performance Requirements - The algorithm should efficiently handle valid Sudoku puzzles without unnecessary recursion. Example ```python class SudokuSolver: def __init__(self, board): self.board = board def solve_sudoku(self): def is_valid(num, pos): # Check row for i in range(len(self.board[0])): if self.board[pos[0]][i] == num and pos[1] != i: return False # Check column for i in range(len(self.board)): if self.board[i][pos[1]] == num and pos[0] != i: return False # Check box box_x = pos[1] // 3 box_y = pos[0] // 3 for i in range(box_y * 3, box_y * 3 + 3): for j in range(box_x * 3, box_x * 3 + 3): if self.board[i][j] == num and (i, j) != pos: return False return True def solve(): for i in range(len(self.board)): for j in range(len(self.board[0])): if self.board[i][j] == 0: for num in range(1, 10): if is_valid(num, (i, j)): self.board[i][j] = num if solve(): return True self.board[i][j] = 0 return False return True solve() if __name__ == \\"__main__\\": board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solver = SudokuSolver(board) solver.solve_sudoku() for row in solver.board: print(row) ``` This question integrates well with the given sample question, keeping the complexity, style, length, and topic congruent with the original set.","solution":"class SudokuSolver: def __init__(self, board): self.board = board def solve_sudoku(self): def is_valid(num, pos): # Check row for i in range(len(self.board[0])): if self.board[pos[0]][i] == num and pos[1] != i: return False # Check column for i in range(len(self.board)): if self.board[i][pos[1]] == num and pos[0] != i: return False # Check box box_x = pos[1] // 3 box_y = pos[0] // 3 for i in range(box_y * 3, box_y * 3 + 3): for j in range(box_x * 3, box_x * 3 + 3): if self.board[i][j] == num and (i, j) != pos: return False return True def solve(): for i in range(len(self.board)): for j in range(len(self.board[0])): if self.board[i][j] == 0: for num in range(1, 10): if is_valid(num, (i, j)): self.board[i][j] = num if solve(): return True self.board[i][j] = 0 return False return True solve()"},{"question":"# Coding Assessment Question: Implement Library Inventory Management System **Context**: You are tasked with designing a Library Inventory Management System to help the librarian keep track of book checkouts, returns, and availability. You need to implement the core functionalities which include adding a new book, checking out a book, and returning a book. Assume each book is uniquely identified by its ISBN number. **Problem Statement**: Write a class named `LibraryInventory` that simulates a library inventory system with methods to manage book checkouts and returns. **Class Definition**: ```python class LibraryInventory: def __init__(self): Initializes an empty inventory for the library. def add_book(self, isbn: str, copies: int) -> None: Adds a new book with the given ISBN and number of copies to the inventory. :param isbn: A string representing the ISBN of the book. :param copies: An integer representing the number of copies of the book. def checkout_book(self, isbn: str) -> bool: Checks out a copy of the book with the given ISBN if available. :param isbn: A string representing the ISBN of the book. :returns: True if the checkout was successful, False if the book is not available or does not exist. def return_book(self, isbn: str) -> None: Returns a copy of the book with the given ISBN. :param isbn: A string representing the ISBN of the book. def get_available_copies(self, isbn: str) -> int: Gets the number of available copies of the book with the given ISBN. :param isbn: A string representing the ISBN of the book. :returns: An integer representing the number of available copies. Returns 0 if the book does not exist. ``` **Input**: - ISBNs: Strings representing the unique identifier of books. - Copies: Non-negative integers representing the number of copies of each book. **Output**: - Various actions are performed through the methods: adding books to the inventory, checking out books, returning books, and getting the number of available copies. - Returns appropriate results for each action (boolean for checkout success/failure and integer for available copies). **Constraints**: - ISBN strings will not exceed 20 characters. - 1 ≤ number of unique books ≤ 10000 - 0 ≤ copies ≤ 1000 for any given ISBN **Performance Requirements**: - The implementation should efficiently handle inventory management operations. - Operations should be optimized for constant time complexity where possible. **Example**: ```python library = LibraryInventory() library.add_book(\\"978-1234567890\\", 3) library.add_book(\\"978-1234567891\\", 2) print(library.checkout_book(\\"978-1234567890\\")) # Expected Output: True print(library.get_available_copies(\\"978-1234567890\\")) # Expected Output: 2 library.return_book(\\"978-1234567890\\") print(library.get_available_copies(\\"978-1234567890\\")) # Expected Output: 3 print(library.checkout_book(\\"978-1234567892\\")) # Expected Output: False ``` Your implementation will be tested against multiple cases, including edge cases and performance-critical situations. Make sure to account for all scenarios and confirm that your solution is both correct and efficient.","solution":"class LibraryInventory: def __init__(self): self.inventory = {} def add_book(self, isbn: str, copies: int) -> None: if isbn in self.inventory: self.inventory[isbn] += copies else: self.inventory[isbn] = copies def checkout_book(self, isbn: str) -> bool: if isbn in self.inventory and self.inventory[isbn] > 0: self.inventory[isbn] -= 1 return True return False def return_book(self, isbn: str) -> None: if isbn in self.inventory: self.inventory[isbn] += 1 def get_available_copies(self, isbn: str) -> int: return self.inventory.get(isbn, 0)"},{"question":"# Coding Assessment Question You are required to implement a function that performs a sentence segmentation operation on a given text without relying on external libraries like nltk. The function should split the text into individual sentences based on punctuation marks (period \'.\'), question marks (\'?\'), or exclamation marks (\'!\'), while maintaining proper capitalization of the first word in each sentence. Task Implement a function `segment_sentences(text: str) -> list[str]` that divides the input text into a list of sentences. Input - `text`: A string representing a paragraph containing multiple sentences. Output - Returns a list of strings, each representing a segmented sentence. Constraints - The input `text` will always be a non-empty string. - Sentences end with either a period (\'.\'), a question mark (\'?\'), or an exclamation mark (\'!\'). - Each sentence will be properly capitalized. - There will be no abbreviations that could be confused with sentence-end markers (e.g., \\"Dr.\\" or \\"Mr.\\"). Example ```python text = \\"Hello world. How are you? I\'m fine!\\" output = segment_sentences(text) # Output: [\\"Hello world.\\", \\"How are you?\\", \\"I\'m fine!\\"] text = \\"This is a test. Isn\'t it great? Yes, it is!\\" output = segment_sentences(text) # Output: [\\"This is a test.\\", \\"Isn\'t it great?\\", \\"Yes, it is!\\"] ``` Notes 1. Ensure that the function handles various punctuation marks for sentence boundaries. 2. The function should correctly handle cases where multiple sentences are joined by these punctuation marks. 3. The whitespace between sentences should be appropriately managed. ```python import re def segment_sentences(text: str) -> list[str]: Segments the input text into a list of sentences. # Regular expression to split sentences based on punctuation sentences = re.split(r\'(?<=[.?!])s*\', text) # Remove any empty strings that may result from the split return [sentence.strip() for sentence in sentences if sentence] # Example usage: text = \\"Hello world. How are you? I\'m fine!\\" print(segment_sentences(text)) # Output: [\\"Hello world.\\", \\"How are you?\\", \\"I\'m fine!\\"] ```","solution":"import re def segment_sentences(text: str) -> list[str]: Segments the input text into a list of sentences. # Regular expression to split sentences based on punctuation sentences = re.split(r\'(?<=[.?!])s*\', text) # Remove any empty strings that may result from the split return [sentence.strip() for sentence in sentences if sentence]"},{"question":"# Problem Statement You are invited to implement a function that finds all the unique permutations of a given string and returns them in sorted order. The string can contain both uppercase and lowercase letters, digits, spaces, and special characters. It\'s important to maintain case sensitivity. # Implementation Details **Function**: `find_unique_permutations(text: str) -> list` - **Input**: * `text`: A string with mixed characters (alphabets of different cases, numbers, spaces, and special characters). - **Output**: * Returns a list of unique permutations of the given string in lexicographical order. - **Constraints**: * The input string length will not exceed 10. * Permutations should be case-sensitive. * The function should handle and return permutations for strings that include spaces and special characters as well. # Example 1. **Example 1**: - Input: `\\"abc\\"` - Output: `[\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]` 2. **Example 2**: - Input: `\\"aA1!\\"` - Output: `[\\"!1Aa\\", \\"!1aA\\", \\"!A1a\\", \\"!Aa1\\", \\"!a1A\\", \\"!aA1\\", \\"1!Aa\\", \\"1!aA\\", \\"1A!a\\", \\"1Aa!\\", \\"1a!A\\", \\"1aA!\\", \\"A!1a\\", \\"A!a1\\", \\"A1!a\\", \\"A1a!\\", \\"Aa!1\\", \\"Aaa!\\", \\"a!1A\\", \\"a!A1\\", \\"a1!A\\", \\"a1A!\\", \\"aA!1\\", \\"aAa1\\"]` # Implementation You should implement the following function in Python: ```python def find_unique_permutations(text: str) -> list: from itertools import permutations # Generate all permutations and remove duplicates by using a set unique_permutations = sorted(set([\'\'.join(p) for p in permutations(text)])) return unique_permutations ``` Note: This function uses `itertools.permutations` which efficiently generates permutations. The results are then sorted to ensure lexicographical order. This ensures that the returned list of permutations is both unique and ordered as required.","solution":"def find_unique_permutations(text: str) -> list: from itertools import permutations # Generate all permutations and remove duplicates by using a set unique_permutations = sorted(set(\'\'.join(p) for p in permutations(text))) return unique_permutations"},{"question":"# Coding Assessment Question Problem Statement Write a function `reverse_words(sentence: str) -> str` that reverses the words in a given sentence. The words should be reversed, but their order in the sentences should remain the same. If an input is not a string of words, the function should return an empty string. Requirements 1. The function should split the sentence into words, reverse each word and then join them back together. 2. The function should handle invalid inputs gracefully and return an empty string for the following cases: * None. * Non-string values. Input * A string `sentence` consisting of words separated by spaces. Output * A string where each word in the original sentence is reversed, but their order remains the same. Constraints * A word is defined as a sequence of characters separated by spaces. * The input string may contain special characters or punctuation as part of the words. Example ```python >>> reverse_words(\\"Hello world\\") \\"olleH dlrow\\" >>> reverse_words(\\"The quick brown fox\\") \\"ehT kciuq nworb xof\\" >>> reverse_words(\\"racecar\\") \\"racecar\\" >>> reverse_words(42) \\"\\" >>> reverse_words(None) \\"\\" >>> reverse_words(\\"Python 3.8!\\") \\"nohtyP !8.3\\" ``` Additional Notes * The function should only account for the word boundaries created by spaces. * Special characters and punctuation are considered part of the word they are attached to.","solution":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence, but maintains their order in the sentence. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: The sentence with each word reversed, or an empty string for invalid input. if not isinstance(sentence, str): return \\"\\" words = sentence.split() reversed_words = [word[::-1] for word in words] return \\" \\".join(reversed_words)"},{"question":"# Problem Statement Create a function that compresses a string using the run-length encoding algorithm. The function should simplify sequences of repeating characters by replacing them with the character followed by the count of repetitions. # Requirements * The function should be named `run_length_encode` and take a single input `s` which is the string to be compressed. * Return the run-length encoded string, which should effectively shorten sequences of repeating characters. * Validate the input to ensure `s` is a string. If it is not, raise appropriate exceptions: * **TypeError**: If `s` is not a string. # Constraints * The length of `s` can be up to 10^5. * The function should handle both empty strings and strings with no repeating characters gracefully. # Example Usage ```python >>> run_length_encode(\\"aabccc\\") \'a2b1c3\' >>> run_length_encode(\\"abcd\\") \'a1b1c1d1\' >>> run_length_encode(\\"\\") \'\' >>> run_length_encode(12345) Traceback (most recent call last): ... TypeError: Input must be a string ``` # Notes * Carefully handle edge cases such as empty strings and strings with no repeating characters. * The function should efficiently process the input string without unnecessary computations. * Be mindful of string formatting, ensuring that the output is correctly concatenated with no extraneous characters. By offering a function dealing with run-length encoding, which complements high-precision calculation tasks by pivoting to fundamental string manipulation and compression techniques, this question stays within the same general programming domain but explores a different, yet related facet.","solution":"def run_length_encode(s): Compresses the string using run-length encoding. :param s: The input string to be compressed. :return: Run-length encoded string. :raises TypeError: If the input is not a string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded_string.append(f\\"{current_char}{count}\\") return \\"\\".join(encoded_string)"},{"question":"Problem Description You are given a paragraph of text which may contain a mix of alphabets, numbers, and punctuation marks. The task is to develop a Python function that extracts and returns the longest word in the given paragraph. In case there are multiple words of the same maximum length, return the word that appears first. # Function Specification **Function Name**: `longest_word` **Input**: - `paragraph`: A string containing a mix of words, numbers, spaces, and punctuation marks. The length of the paragraph will be between 1 and (10^5) characters. **Output**: - Returns a string that is the longest word found in the given paragraph. # Constraints - Special characters and numbers are considered delimiters and should not be part of the word. - Words are case-insensitive but the returned word should match the case used in the input. # Example ```python def longest_word(paragraph): >>> longest_word(\\"This is a simple test case.\\") \'simple\' >>> longest_word(\\"In a village of La Mancha, the name of which I have no desire to call to mind...\\") \'village\' >>> longest_word(\\"!@#% 12345 abcde\\") \'abcde\' ``` # Requirements - You must avoid using any built-in library functions that directly solve the problem (e.g., `re` for regular expressions). - Efficiency is important—the solution should process the paragraph in linear time relative to its length. # Performance Requirements - The solution should be efficient with a time complexity of O(n), where n is the number of characters in the paragraph. - The space complexity should be O(1) for additional storage, not considering the input and output size.","solution":"def longest_word(paragraph): Returns the longest word in the given paragraph. Words are case-insensitive, but the return word should match the case used in the input. max_length = 0 longest_word = \'\' current_word = \'\' for char in paragraph: if char.isalpha(): current_word += char else: if len(current_word) > max_length: max_length = len(current_word) longest_word = current_word current_word = \'\' # Check last word if len(current_word) > max_length: longest_word = current_word return longest_word"},{"question":"# Question: Grid Path Length Checker Background Consider a rectangular grid with dimensions `m x n`. You can move from a cell to the adjacent cell either to the right or downward. The objective is to determine whether you can reach the bottom-right corner cell starting from the top-left corner cell, if only given a limited number of total steps `s`. Problem Description You are to write a Python function `can_reach_target(m: int, n: int, s: int) -> bool` that returns a boolean indicating whether it is possible to reach the bottom-right corner cell of an `m x n` grid starting from the top-left corner by using exactly `s` steps. Each step can either move right or down. Input - Two integers `m` and `n` (1 ≤ m, n ≤ 100), representing the dimensions of the grid. - An integer `s` (1 ≤ s ≤ 200), representing the exact number of steps available. Output - A boolean value `True` if it is possible to reach the bottom-right corner with exactly `s` steps, and `False` otherwise. Constraints - Each move must be a single step to the right or downward. - You are guaranteed that `s` will be greater than or equal to `m + n - 2` (minimum steps required). Notes - Ensure to validate the input constraints properly. - Think about any special edge cases that might simplify or complicate reaching the target with exactly `s` steps. Examples ```python >>> can_reach_target(2, 2, 2) True >>> can_reach_target(2, 2, 3) False >>> can_reach_target(3, 3, 4) True >>> can_reach_target(3, 3, 5) False ``` Explanation - In the first example, it\'s possible to reach the target with exactly 2 steps: [right, down] or [down, right]. - In the second example, it is not possible to reach the target with exactly 3 steps, as only paths with 2 steps are valid. - In the third example, it is possible to reach the target with exactly 4 steps. - In the fourth example, 5 steps are not possible as there are only paths with 4 steps in a 3x3 grid.","solution":"def can_reach_target(m: int, n: int, s: int) -> bool: Returns True if it is possible to reach the bottom-right cell of an m x n grid starting from the top-left cell with exactly s steps, where each step is either moving right or down. # The minimum number of steps required to reach the bottom-right corner min_steps = (m - 1) + (n - 1) # Check if the exact number of steps s matches min_steps added with any number of extra moves return s >= min_steps and (s - min_steps) % 2 == 0"},{"question":"Binary Tree Level-Order Traversal You are provided with a partial implementation of a `BinaryTree` class. Your task is to complete the class by implementing the `level_order_traversal` method to perform a level-order traversal (breadth-first traversal) of the binary tree. Objective Complete the implementation of the `level_order_traversal` method in the `BinaryTree` class to traverse the binary tree and return the values of each node in level-order. # Tasks 1. **level_order_traversal(root)**: - Traverses the binary tree in level-order starting from the `root` node. - Uses a queue-based approach to visit each level of the tree from left to right. - Returns a list of node values in the order they are visited. # Input/Output - **level_order_traversal method**: - **Input**: - `root`: The root node of the binary tree (of type `TreeNode`). - **Output**: - A list of node values in level-order traversal. # Constraints - The input node and all nodes in the tree are of type `TreeNode`, which is defined as: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Sample Usage ```python # Example of tree construction # 1 # / # 2 3 # / / # 4 5 6 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) binary_tree = BinaryTree() result = binary_tree.level_order_traversal(root) print(result) # Expected output: [1, 2, 3, 4, 5, 6, 7] ``` # Considerations - Ensure you handle cases where the input `root` node is `None` (an empty tree). - Implement a queue-based approach using collections.dequeue for efficiency. - Your method should not modify the original tree structure. Write your implementation of the `level_order_traversal` method below. ```python from collections import deque class BinaryTree: def __init__(self): self.root = None def level_order_traversal(self, root): if not root: return [] queue = deque([root]) level_order_list = [] while queue: current_node = queue.popleft() level_order_list.append(current_node.value) if current_node.left: queue.append(current_node.left) if current_node.right: queue.append(current_node.right) return level_order_list ```","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def level_order_traversal(self, root): if not root: return [] queue = deque([root]) level_order_list = [] while queue: current_node = queue.popleft() level_order_list.append(current_node.value) if current_node.left: queue.append(current_node.left) if current_node.right: queue.append(current_node.right) return level_order_list"},{"question":"# Binary Search Implementation Objective Implement the binary search algorithm to determine if a target integer exists in a sorted array of integers. Your implementation should be efficient and handle all edge cases. Task Write a function `binary_search` that takes a sorted list of integers and a target integer as inputs. The function should return `True` if the target integer is found in the list and `False` otherwise. Function Signature ```python def binary_search(arr: List[int], target: int) -> bool: pass ``` Input - A sorted list of integers `arr` with `0 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. - An integer `target` where `-10^9 <= target <= 10^9`. Output - A boolean indicating whether the target integer is found in the list. Constraints - The solution should have a time complexity of O(log n). - Assume that the input list is always sorted in ascending order. Example ```python # Example 1 arr = [1, 2, 3, 4, 5] target = 3 output = binary_search(arr, target) # Output: True # Example 2 arr = [1, 2, 3, 4, 5] target = 6 output = binary_search(arr, target) # Output: False # Example 3 arr = [] target = 3 output = binary_search(arr, target) # Output: False # Example 4 arr = [2, 4, 6, 8, 10] target = 8 output = binary_search(arr, target) # Output: True ``` Notes - Consider edge cases such as an empty array or an array with one element. - Ensure that the function properly handles cases where the target is not present in the list. - The function should efficiently handle large arrays up to the maximum constraint size.","solution":"from typing import List def binary_search(arr: List[int], target: int) -> bool: Implements binary search algorithm to check if target is present in the sorted list arr. Parameters: arr (List[int]): A list of sorted integers. target (int): The integer to search for in the list. Returns: bool: True if target is found in arr, False otherwise. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return True elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"# Scenario You are tasked with developing a basic inventory management system for a small store. The system should keep track of items in stock and support operations to add, remove, and search for items. # Objective Create a class `Inventory` that manages the store\'s inventory by efficiently tracking items and their quantities. Implement the following functionalities: 1. **Add Item**: A method to add a specified quantity of an item to the inventory. 2. **Remove Item**: A method to remove a specified quantity of an item from the inventory. 3. **Search Item**: A method to search for an item by its name and return its quantity. 4. **List Items**: A method to list all items currently in the inventory with their respective quantities. 5. **Handle Non-existent Items and Quantities**: Gracefully handle operations that involve items not present in the inventory or invalid quantities. # Instructions 1. Implement the class `Inventory` with the following methods: - `add_item(self, item_name, quantity)` - `remove_item(self, item_name, quantity)` - `search_item(self, item_name)` - `list_items(self)` 2. The methods should follow these specifications: - **`add_item` method**: Increases the quantity of the specified item. If the item does not exist, add it to the inventory. - **`remove_item` method**: Decreases the quantity of the specified item. If the quantity to remove exceeds the available quantity, remove all of it and notify the user. If the item does not exist, inform the user. - **`search_item` method**: Returns the quantity of the specified item. If the item is not found, notify the user. - **`list_items` method**: Returns a list of tuples containing all items and their quantities. # Expected Input and Output - **Input**: Method calls made to an instance of the `Inventory` class. - **Output**: Appropriate responses from the methods, such as quantities or notifications. # Example Usage ```python inventory = Inventory() # Add items inventory.add_item(\\"Apple\\", 50) inventory.add_item(\\"Banana\\", 100) # Remove items inventory.remove_item(\\"Apple\\", 20) inventory.remove_item(\\"Orange\\", 10) # Item does not exist # Search for items print(inventory.search_item(\\"Banana\\")) # Output: 100 print(inventory.search_item(\\"Grapes\\")) # Item does not exist # List all items print(inventory.list_items()) # Output: [(\'Apple\', 30), (\'Banana\', 100)] ``` # Constraints - An item name is a string that contains only alphabetic characters. - Quantities are non-negative integers. - The system should handle up to 10,000 unique items. # Performance Requirements - Efficiently add, remove, and search for items in the inventory, considering both time and space complexity. # Additional Notes - Ensure the system is robust, handling all edge cases gracefully. - Provide clear and informative messages to the user for any operation that cannot be completed as requested. ```python class Inventory: def __init__(self): self.items = {} def add_item(self, item_name, quantity): pass def remove_item(self, item_name, quantity): pass def search_item(self, item_name): pass def list_items(self): pass ```","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_name, quantity): if quantity < 0: return \\"Quantity must be a non-negative integer\\" if item_name in self.items: self.items[item_name] += quantity else: self.items[item_name] = quantity def remove_item(self, item_name, quantity): if quantity < 0: return \\"Quantity must be a non-negative integer\\" if item_name in self.items: if self.items[item_name] > quantity: self.items[item_name] -= quantity elif self.items[item_name] <= quantity: self.items.pop(item_name) # Remove the item completely if quantity is zero or below return f\\"All {item_name}s have been removed\\" else: return f\\"Item {item_name} does not exist in the inventory\\" def search_item(self, item_name): if item_name in self.items: return self.items[item_name] else: return f\\"Item {item_name} not found\\" def list_items(self): return list(self.items.items())"},{"question":"# Reorder Linked List Given a singly linked list, reorder it such that the nodes are rearranged in a specific way: the first element should be followed by the last element, followed by the second element, followed by the second-last element, and so forth. This problem is particularly useful in scenarios where displaying a list in a visually appealing and \'centering\' manner is needed. # Function Signature Implement the function `reorder_list` using the following signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head: ListNode) -> None: ``` # Parameters 1. **head (ListNode)**: The head of the singly linked list. # Returns The function should reorder the list in place and does not need to return anything. # Requirements * The function should handle edge cases appropriately, such as empty list or list with a single node. * The implementation should have a time complexity of O(n) and a space complexity of O(1), where n is the number of nodes in the linked list. # Example ```python # Helper function to create list from python list def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head # Helper function to convert linked list to python list def linked_list_to_array(head): arr = [] while head: arr.append(head.val) head = head.next return arr # Example usage: arr = [1, 2, 3, 4] head = create_linked_list(arr) reorder_list(head) print(linked_list_to_array(head)) # Output: [1, 4, 2, 3] arr = [1, 2, 3, 4, 5] head = create_linked_list(arr) reorder_list(head) print(linked_list_to_array(head)) # Output: [1, 5, 2, 4, 3] arr = [1] head = create_linked_list(arr) reorder_list(head) print(linked_list_to_array(head)) # Output: [1] ``` # Constraints * The linked list can have between 0 and 10^5 nodes. * The value of each node in the linked list can be any integer. # Notes * You should rearrange the nodes in-place, altering the `next` pointers of the existing nodes. * Split the list into two halves, reverse the second half, and merge the halves to achieve the desired order. * Make sure to handle edge cases such as empty linked list or linked list with only one node gracefully.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head: ListNode) -> None: if not head or not head.next: return # Find the middle of the list slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev, curr = None, slow.next slow.next = None # Split the list into two halves while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Merge the two halves first, second = head, prev while second: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first, second = tmp1, tmp2"},{"question":"# Prime Number Generator with Concurrency You are recruited by a company that requires a high-performance system to generate prime numbers. This system needs to leverage concurrent processing to quickly find prime numbers within a specified range. Your task is to develop a prime numbers generator that handles multiple threads, ensuring efficient use of system resources. **Requirements**: 1. Implement a function to initialize the concurrent system. 2. Implement a function to generate prime numbers within a given range using multiple threads. 3. Ensure the generated primes are unique and sorted. 4. Implement a function to reset the generator system. # Objectives: - **Function**: `initialize_prime_system(n: int)` - **Input**: - `n`: Integer, maximum number to consider for prime generation. - **Output**: Initializes the system state for prime number generation. - **Function**: `generate_primes(start: int, end: int, num_threads: int) -> List[int]` - **Input**: - `start`: Integer, the starting point of the range. - `end`: Integer, the ending point of the range. - `num_threads`: Integer, number of threads to be used for generating primes. - **Output**: Returns a list of unique prime numbers in the specified range, sorted in ascending order. - **Function**: `reset_prime_system()` - **Input**: None - **Output**: Resets the generator system to its initial unpopulated state. Constraints: - Ensure the system efficiently divides the workload between threads. - Primes are to be calculated in a thread-safe manner, avoiding race conditions. - The range `start` to `end` should be validated, ensuring `start ≤ end`. - Handle cases where `end` is less than or equal to 1 appropriately, as there are no primes. # Example Scenario: 1. Initialize the system using: ```python initialize_prime_system(1000) ``` 2. Generate prime numbers between 1 and 100 using 4 threads: ```python generate_primes(1, 100, 4) ``` - Expected output: `[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]` 3. Reset the generator system to its initial state: ```python reset_prime_system() ``` # Guidelines: - Document edge cases and test the functions thoroughly. - Optimize prime-checking algorithms to ensure high performance even for large ranges and high numbers of threads. - Utilize appropriate synchronization techniques to manage the concurrent execution and ensure correctness. - Discuss the performance impacts observed with different thread counts and ranges. Are you ready to advance computational power with high-speed concurrent prime generation?","solution":"import threading from typing import List # Shared state for prime generation class PrimeSystem: def __init__(self): self.max_num = 0 self.initialize = False prime_system = PrimeSystem() def initialize_prime_system(n: int): Initializes the system state for prime number generation up to a max number n. prime_system.max_num = n prime_system.initialize = True def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_in_range(start: int, end: int) -> List[int]: Generates a list of primes in the given range [start, end). primes = [] for number in range(start, end): if is_prime(number): primes.append(number) return primes def generate_primes(start: int, end: int, num_threads: int) -> List[int]: Generates primes using multiple threads. if not prime_system.initialize: raise RuntimeError(\\"Prime system not initialized. Please call initialize_prime_system first.\\") if start > end: raise ValueError(\\"Start must be less than or equal to end.\\") if end <= 1: return [] step = (end - start) // num_threads threads = [] results = [[] for _ in range(num_threads)] def thread_task(thread_index: int, start: int, stop: int): Task run by each thread. results[thread_index] = primes_in_range(start, stop) for i in range(num_threads): thread_start = start + i * step thread_end = min(start + (i + 1) * step, end) if i == num_threads - 1: thread_end = end thread = threading.Thread(target=thread_task, args=(i, thread_start, thread_end)) threads.append(thread) thread.start() for thread in threads: thread.join() unique_primes = sorted(set(prime for sublist in results for prime in sublist)) return unique_primes def reset_prime_system(): Resets the generator system to its initial unpopulated state. prime_system.max_num = 0 prime_system.initialize = False"},{"question":"# Prime Factorization Visualization Art Objective You need to visualize the prime factorization of a natural number in a graphical representation. This visual representation will help to better understand the structure of the number in terms of its prime factors. Task Create a function that generates a graphical chart representing the prime factors of a number. Each prime factor should be displayed with a repeated pattern depending on its frequency in the factorization. Input 1. **Number**: An integer, n, where 2 <= n <= 10^6. Output A graphical visualization (string format) where each line represents a prime factor and its frequency using a specific symbol. Constraints 1. Use `*` to represent each instance of a prime factor. 2. The factors must be displayed in ascending order. 3. Each prime factor line should be a separate line. 4. If the number is a prime number itself, it should show itself on a single line. Example **Input**: ```python number = 60 ``` **Output**: ``` 2: ** 3: * 5: * ``` *Explanation:* 60 = 2^2 * 3^1 * 5^1. There are two 2\'s, one 3, and one 5. **Input**: ```python number = 17 ``` **Output**: ``` 17: * ``` *Explanation:* 17 is a prime number. **Function Signature**: ```python def prime_factor_visualization(number: int) -> str: # Your implementation here ``` Hints - You can use efficient algorithms like the Sieve of Eratosthenes for generating the list of prime numbers up to a certain limit. - Consider implementing a function to return the prime factors of a given number along with their frequencies. - Format the final graphical representation carefully to ensure clarity.","solution":"from collections import Counter import math def factorize(n): factors = [] # Check for the number of twos in n while n % 2 == 0: factors.append(2) n //= 2 # n must be odd at this point, so check for odd factors from 3 onwards for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: factors.append(i) n //= i if n > 2: factors.append(n) return factors def prime_factor_visualization(number: int) -> str: factors = factorize(number) count_factors = Counter(factors) result = [] for prime in sorted(count_factors): result.append(f\\"{prime}: {\'*\' * count_factors[prime]}\\") return \'n\'.join(result)"},{"question":"# Problem Statement You are required to implement a function that evaluates arithmetic expressions containing addition, subtraction, multiplication, and division, while respecting the standard order of operations (PEMDAS/BODMAS rules). # Requirements 1. **Function Implementation**: Implement the function `evaluate_expression(expression: str) -> float` that calculates the result of an arithmetic expression. - **Parameters**: - `expression`: A `str` representing the arithmetic expression to be evaluated. The expression contains integers, \'+\', \'-\', \'*\', \'/\', and parentheses for grouping. - **Return**: A `float` representing the computed result of the expression. 2. **Constraints**: - The `expression` string is non-empty and contains only valid characters (numbers, operators, and parentheses). - Division operations are floating-point divisions. - The given expression will always be a valid arithmetic expression. - You must handle nested and multiple levels of parentheses. 3. **Example**: ```python result = evaluate_expression(\\"3 + 5 * 2 / (8 - 3)\\") print(result) # Output: 5.0 result = evaluate_expression(\\"12 / 4 - (1 + 2 * 3)\\") print(result) # Output: -4.0 ``` 4. **Edge Cases**: - Handle division by zero gracefully without crashing. - Consider scenarios with multiple nested parentheses. - Empty parentheses should not appear in the string; you can assume the input always has valid structure. # Hints - Use a stack-based approach to handle parentheses and operator precedence. - Evaluate parts of the expression step-by-step, reducing it to simpler forms. - Implement helper functions to process operations and manage operator precedence.","solution":"def evaluate_expression(expression: str) -> float: def compute(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == \'+\': values.append(left + right) elif op == \'-\': values.append(left - right) elif op == \'*\': values.append(left * right) elif op == \'/\': values.append(left / right) def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': compute(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): compute(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: compute(operators, values) return float(values[-1])"},{"question":"# Dynamic Programming for Maximum Profit with Stock Trading Objective You are given a list representing the price of a stock on each day. You are allowed to buy and sell the stock only once. Your objective is to maximize your profit from this single transaction. You must implement a function to determine the maximum profit that can be achieved. Task Write a function that takes a list of integers representing stock prices and returns the maximum profit that can be obtained from buying and then selling the stock exactly once. Input 1. **Prices**: A list of integers where each integer represents the stock price on a given day. ```python prices = [7, 1, 5, 3, 6, 4] ``` Output An integer representing the maximum profit obtainable from a single buy-sell transaction. Constraints 1. The function should handle both positive and zero values within the list of prices. 2. If no profitable transaction is possible, the function should return 0. 3. The length of the list will be between 1 and 10^5, inclusively. 4. The stock prices are given in chronological order. Performance Requirements * The solution should have a time complexity of O(n). * The space complexity should be O(1). Scenario The function should efficiently manage the state of the minimum price seen so far and the maximum profit possible at each step. The dynamic programming approach will help in solving this problem optimally. Example ```python prices = [7, 1, 5, 3, 6, 4] # Expected output: 5 # Explanation: Buy at price 1 and sell at price 6 for a profit of 6 - 1 = 5. ``` Implement the function `max_profit(prices: List[int]) -> int`. ```python def max_profit(prices): if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit # Example usage: prices = [7, 1, 5, 3, 6, 4] print(max_profit(prices)) # Outputs: 5 ```","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"# Coding Assessment Question **Title**: Implement Matrix Rotation **Context**: As part of a 2D graphics rendering system, you need to develop functionality to manipulate and transform images. One common operation is rotating an image or matrix by 90 degrees clockwise. This task will help you implement such a feature. **Task**: Write a function `rotate_matrix_90` that takes a square matrix and rotates it 90 degrees clockwise in-place. **Input**: - `matrix`: a list of lists of integers representing an n x n matrix. **Output**: - The function does not return anything. It should modify the matrix in place. **Constraints**: - The input matrix is guaranteed to have equal number of rows and columns (i.e., it is a square matrix). - The elements of the matrix are integers. - The matrix dimensions are guaranteed to be at least 1x1 and can be up to 100x100. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix_90(matrix) print(matrix) ``` **Expected Output**: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` **Notes**: - You should rotate the matrix in place without using extra space for another matrix. - Consider edge cases such as the smallest possible matrix (1x1) which should remain unchanged after rotation.","solution":"def rotate_matrix_90(matrix): Rotates the given n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Simple Calculator Function Coding Challenge Overview You\'re tasked with developing a basic calculator that can perform simple arithmetic operations. The goal is to implement a function that evaluates a string containing a basic mathematical expression and returns the result. Problem Statement Implement a function `simple_calculator(expression: str) -> float` that parses and evaluates a simple mathematical expression given as a string. The expression may include the addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`) operations, as well as parentheses for altering precedence. Input - `expression`: A string `expression` representing a mathematical equation. The string will not contain any variables, only numbers and the operators mentioned above. Output - A float representing the result of the evaluated expression. Constraints - The input string `expression` will be a valid mathematical expression. - Division by zero should return `float(\'inf\')` or `-float(\'inf\')` if applicable. - The expression will not contain any spaces. - The numbers in the expression can be integers or decimal numbers. Example ```python expression = \\"3+2*2\\" output = 7.0 assert simple_calculator(\\"3+2*2\\") == 7.0 ``` ```python expression = \\"2-3/3\\" output = 1.0 assert simple_calculator(\\"2-3/3\\") == 1.0 ``` ```python expression = \\"(2+3)*4-3\\" output = 17.0 assert simple_calculator(\\"(2+3)*4-3\\") == 17.0 ``` ```python expression = \\"10/0\\" output = float(\'inf\') assert simple_calculator(\\"10/0\\") == float(\'inf\') ``` Notes - Ensure to handle edge cases such as division by zero. - Properly manage operator precedence and parentheses in the evaluation process. - Minimize excess memory usage and operations for efficient performance.","solution":"def simple_calculator(expression: str) -> float: Parses and evaluates a simple mathematical expression provided as a string. Supports operations: addition, subtraction, multiplication, division. Handles parentheses for precedence. try: result = eval(expression) if result == float(\'inf\') or result == -float(\'inf\'): return result return float(result) except ZeroDivisionError: return float(\'inf\') if \'/\' in expression and not \'-\' in expression else -float(\'inf\') except Exception: raise ValueError(\\"Invalid expression\\")"},{"question":"# Problem: Matrix Diagonal Traversal **Context**: You have been asked to develop a method to traverse a matrix diagonally. This means starting from the top-left to bottom-right of the matrix and traversing each diagonal line. The traversal should start from the top row and then continue to the first column until the entire matrix is covered. # Task: Implement the function `diagonal_traversal(matrix: List[List[int]]) -> List[int]` that returns the elements of the matrix in a diagonal order. 1. **diagonal_traversal(matrix: List[List[int]]) -> List[int]**: - Return the elements of the matrix in diagonal order. # Constraints: - The elements in the matrix can be any integers. - The matrix has `m` rows and `n` columns where `1 <= m, n <= 1000`. **Note**: The matrix may not be square (i.e., `m` may not be equal to `n`). # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert diagonal_traversal(matrix) == [1, 2, 4, 7, 5, 3, 6, 8, 9] matrix = [ [1, 2], [3, 4] ] assert diagonal_traversal(matrix) == [1, 2, 3, 4] ``` # Explanation: For the first example, the diagonals would be traversed as: - [1] - [2, 4] - [3, 5, 7] - [6, 8] - [9] For the second example: - [1] - [2, 3] - [4] # Implementation You may use the template below to write your solution: ```python def diagonal_traversal(matrix: List[List[int]]) -> List[int]: if not matrix: return [] m = len(matrix) n = len(matrix[0]) result = [] for d in range(m + n - 1): if d < n: i = 0 j = d else: i = d - n + 1 j = n - 1 temp = [] while i < m and j >= 0: temp.append(matrix[i][j]) i += 1 j -= 1 if d % 2 == 0: result.extend(temp[::-1]) else: result.extend(temp) return result # Example usage: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(diagonal_traversal(matrix)) # Output: [1, 2, 4, 7, 5, 3, 6, 8, 9] ``` Ensure your function is well-tested and optimized for the provided constraints.","solution":"from typing import List def diagonal_traversal(matrix: List[List[int]]) -> List[int]: if not matrix: return [] m = len(matrix) n = len(matrix[0]) result = [] for d in range(m + n - 1): if d < n: i = 0 j = d else: i = d - n + 1 j = n - 1 temp = [] while i < m and j >= 0: temp.append(matrix[i][j]) i += 1 j -= 1 if d % 2 == 0: result.extend(temp[::-1]) else: result.extend(temp) return result"},{"question":"# Context Many algorithms require the ability to find the shortest path in a graph. A common algorithm used for this purpose is Dijkstra\'s algorithm. # Problem Statement Implement Dijkstra\'s algorithm to find the shortest path from a given source vertex to all other vertices in a weighted, directed graph. Your program should return a dictionary representing the shortest distance from the source vertex to each vertex. # Requirements 1. **shortest_path(graph: dict, start_vertex: Any) -> dict**: Given a graph represented as a dictionary where each key is a vertex and each value is a list of tuples representing the connected vertices and their respective weights, compute the shortest path from the start vertex to all other vertices. # Input and Output Formats * **Input**: - `graph`: A dictionary representing the graph, where the keys are vertices and the values are lists of tuples. Each tuple represents a connection to another vertex (first element) and the weight of the edge (second element). - `start_vertex`: The vertex from which to calculate the shortest paths. * **Output**: - A dictionary where each key is a vertex and its value is the shortest distance from the start vertex to that vertex. # Constraints * The graph can have up to 1000 vertices. * Assume all edge weights are non-negative. * If there is no path to a vertex, the shortest distance should be represented as infinity (`float(\'inf\')`). # Performance Considerations * The algorithm should efficiently handle graphs with a large number of vertices and edges using appropriate data structures. # Example ```python # Example usage: graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } assert shortest_path(graph, \'A\') == { \'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4 } ``` # Edge Cases to Consider * Starting vertex with no connections to any other vertices. * Graph with only one vertex. * Graph with very high weights compared to others. Implement the function: ```python import heapq def shortest_path(graph: dict, start_vertex: Any) -> dict: distances = {vertex: float(\'inf\') for vertex in graph} distances[start_vertex] = 0 priority_queue = [(0, start_vertex)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances ```","solution":"import heapq from typing import Any, Dict, List, Tuple def shortest_path(graph: Dict[Any, List[Tuple[Any, float]]], start_vertex: Any) -> Dict[Any, float]: Computes the shortest paths from the start_vertex to all other vertices in a weighted directed graph. Args: graph: A dictionary where the keys are the vertices and the values are lists of tuples. Each tuple contains a connected vertex and the weight of the edge. start_vertex: The vertex from which to calculate the shortest paths. Returns: A dictionary where each key is a vertex and its value is the shortest distance from the start vertex to that vertex. distances = {vertex: float(\'inf\') for vertex in graph} distances[start_vertex] = 0 priority_queue = [(0, start_vertex)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Background In data parsing and transformation, managing and converting date-time strings is a common task across various applications, from logging systems to scheduling platforms. Incorrect date formats can lead to errors in processing and interpreting data. # Problem Statement You are required to implement a function `convert_date_format` that converts dates from one format to another. Specifically, the function should take a list of date strings in the format \'DD/MM/YYYY\' and convert each date in the list to the format \'YYYY-MM-DD\'. The function should return a list of the converted date strings. # Function Signature ```python def convert_date_format(dates: List[str]) -> List[str]: pass ``` # Input Format - `dates`: A list of strings, where each string is a date in the format \'DD/MM/YYYY\'. # Output Format - Returns a list of strings, where each string is a date in the format \'YYYY-MM-DD\'. # Constraints - The input list will contain valid date strings in the format \'DD/MM/YYYY\'. - The length of the input list will be between 1 and 10,000. - The input dates will be within the range of \'01/01/1900\' and \'31/12/2100\'. # Example ```python dates = [\\"25/12/2020\\", \\"01/01/2021\\", \\"31/10/1999\\"] print(convert_date_format(dates)) # Output: [\\"2020-12-25\\", \\"2021-01-01\\", \\"1999-10-31\\"] ``` # Notes - Focus on string manipulation functions to achieve the format conversion. - Ensure that your solution is efficient enough to handle the upper constraint limits.","solution":"from typing import List def convert_date_format(dates: List[str]) -> List[str]: Converts a list of date strings from \'DD/MM/YYYY\' format to \'YYYY-MM-DD\' format. Args: dates (List[str]): A list of date strings in \'DD/MM/YYYY\' format. Returns: List[str]: A list of date strings in \'YYYY-MM-DD\' format. converted_dates = [] for date in dates: day, month, year = date.split(\'/\') converted_dates.append(f\\"{year}-{month}-{day}\\") return converted_dates"},{"question":"Sales Commission Calculator # Scenario Retail companies often have sales employees who receive a commission based on their monthly sales figures. You are tasked with developing a commission calculator that will determine the commission amount for each employee based on their sales. # Function to Implement You need to write a function, `calculate_commission`, which will accept a list of dictionaries where each dictionary represents an employee\'s sales data and return a list of dictionaries where each dictionary includes the employee\'s name and their calculated commission. # Function Signature ```python def calculate_commission(employees: list) -> list: pass ``` # Input - A list of dictionaries where each dictionary contains: - `name` (string): The name of the employee. - `sales` (float): The total sales amount for the month. # Output - A list of dictionaries where each dictionary contains: - `name` (string): The name of the employee. - `commission` (float): The calculated commission amount. # Commission Calculation Rules - If monthly sales are less than 1000, the commission is 3% of sales. - If monthly sales are between 1000 and 5000 (inclusive), the commission is 5% of sales. - If monthly sales exceed 5000, the commission is 7% of sales. # Example ```python calculate_commission([ {\\"name\\": \\"Alice\\", \\"sales\\": 500}, {\\"name\\": \\"Bob\\", \\"sales\\": 1500}, {\\"name\\": \\"Charlie\\", \\"sales\\": 6000} ]) ``` Output: ```python [ {\\"name\\": \\"Alice\\", \\"commission\\": 15.0}, {\\"name\\": \\"Bob\\", \\"commission\\": 75.0}, {\\"name\\": \\"Charlie\\", \\"commission\\": 420.0} ] ``` # Notes - Ensure that all calculations are accurate and handle up to two decimal points, where necessary. - Assume all input data is valid and no additional input validation is required. - The order of output should follow the order of input. This question assesses your ability to implement a function to calculate commissions based on conditional logic. You will need to use basic programming constructs such as loops and conditional statements to solve this problem.","solution":"def calculate_commission(employees: list) -> list: Calculate the commission for each employee based on their sales. Parameters: employees (list): A list of dictionaries with \'name\' and \'sales\' keys. Returns: list: A list of dictionaries with \'name\' and \'commission\' keys. result = [] for employee in employees: name = employee[\'name\'] sales = employee[\'sales\'] if sales < 1000: commission = sales * 0.03 elif sales <= 5000: commission = sales * 0.05 else: commission = sales * 0.07 result.append({\\"name\\": name, \\"commission\\": round(commission, 2)}) return result"},{"question":"# Binary Image Compression You are given a binary image represented as a 2D list of integers, where each integer is either 0 (representing a white pixel) or 1 (representing a black pixel). The task is to compress this image using Run-Length Encoding (RLE). RLE is a simple form of data compression in which consecutive runs of the same value are stored as a single data value and count. **Task**: Implement a function `compress_binary_image(image: List[List[int]]) -> List[Tuple[int, int]]` that returns a list of tuples, each containing a value (0 or 1) and its run length. The image is traversed row by row. Function Signature ```python def compress_binary_image(image: List[List[int]]) -> List[Tuple[int, int]]: ``` Input * `image`: A 2D list of integers, where each sublist represents a row in the binary image. The integers are either 0 or 1. The dimensions of the image are positive integers, constrained by ( 1 leq text{rows}, text{cols} leq 1000 ). Output * Return a list of tuples. Each tuple contains two integers: the first is the element (either 0 or 1), and the second is the run length. Constraints * The image is guaranteed to contain only binary values, i.e., 0 or 1. * The dimensions of the image ensure feasible computations within standard runtime limits. Example ```python assert compress_binary_image([[1, 1, 0, 0], [0, 0, 0, 1], [1, 1, 1, 1]]) == [(1, 2), (0, 2), (0, 3), (1, 1), (1, 4)] assert compress_binary_image([[0], [0], [0], [1]]) == [(0, 1), (0, 1), (0, 1), (1, 1)] ``` Additional Notes * Consider edge cases such as an all-white or all-black image. * Ensure that consecutive rows are properly encoded as separate runs when applicable. * Efficiency in both space and time is important given the potential size of the image.","solution":"from typing import List, Tuple def compress_binary_image(image: List[List[int]]) -> List[Tuple[int, int]]: compressed = [] for row in image: if not row: # Edge case: if a row is empty continue current_value = row[0] count = 1 for pixel in row[1:]: if pixel == current_value: count += 1 else: compressed.append((current_value, count)) current_value = pixel count = 1 compressed.append((current_value, count)) return compressed"},{"question":"# Coding Assessment Question: Scenario: You are a software developer at a fintech company and are tasked with implementing an algorithm for detecting suspicious banking activities based on transaction flows. One metric used in this process is to check for the presence of specific repetitive patterns in transaction descriptions. Task: Write a function `has_repeated_substring(s: str) -> bool` that detects if a string can be constructed by repeating a substrings. The function should return `True` if it\'s possible and `False` otherwise. The implementation should avoid nested loops to optimize performance. Input: - A string `s`, which can contain lowercase English letters. Output: - A boolean `True` if the string can be constructed by repeating a substring, `False` otherwise. Constraints: - The length of input string `s` is at least 1 and at most 1000. - Focus on performance, particularly ensuring linear or near-linear time complexity. Examples: ```python has_repeated_substring(\\"abab\\") # Returns: True (repeated \\"ab\\") has_repeated_substring(\\"abcabcabc\\") # Returns: True (repeated \\"abc\\") has_repeated_substring(\\"abcd\\") # Returns: False (no repeating substring) has_repeated_substring(\\"aaaa\\") # Returns: True (repeated \\"a\\") has_repeated_substring(\\"abac\\") # Returns: False (no repeating substring) ``` Ensure your solution leverages efficient string manipulation techniques, aiming for optimal performance.","solution":"def has_repeated_substring(s: str) -> bool: Checks if the string can be constructed by repeating a substring. n = len(s) if n <= 1: return False # Double the string and remove the first and the last character doubled = (s + s)[1:-1] # Check if the original string exists in the modified double string return s in doubled"},{"question":"# Binary Image Inversion Problem Statement You are tasked with developing a function to invert a given binary image. A binary image is represented as a 2D list of integers, where each element is either 1 (representing a black pixel) or 0 (representing a white pixel). Inverting a binary image means replacing each 1 with a 0, and each 0 with a 1. Your function should take in a 2D list representing the binary image and return a new 2D list representing the inverted image. Function Signature ```python def invert_binary_image(image: list[list[int]]) -> list[list[int]]: pass ``` Input * `image` (list[list[int]]): A 2D list of integers where each element is either 0 or 1. The dimensions of the list will be between 1 and 1000 for both rows and columns. Output * Returns a new 2D list of integers where each 1 has been replaced by a 0, and each 0 has been replaced by a 1. Constraints * You must not use external libraries or modules (use only Python\'s standard library). * The input list will always have at least one row and one column. * The input list will only contain integers 0 or 1. Example ```python # Example 1 invert_binary_image( [ [1, 0, 0], [0, 1, 0], [1, 1, 1] ] ) # Output: # [ # [0, 1, 1], # [1, 0, 1], # [0, 0, 0] # ] # Example 2 invert_binary_image( [ [1, 1, 1], [1, 1, 0], [0, 0, 1] ] ) # Output: # [ # [0, 0, 0], # [0, 0, 1], # [1, 1, 0] # ] # Example 3 invert_binary_image( [ [1] ] ) # Output: # [ # [0] # ] # Example 4 invert_binary_image( [ [0, 0, 0, 0] ] ) # Output: # [ # [1, 1, 1, 1] # ] ```","solution":"def invert_binary_image(image): Inverts a given binary image represented as a 2D list. Parameters: image (list of list of int): 2D list representing the binary image to be inverted. Returns: list of list of int: New 2D list representing the inverted binary image. return [[1 - pixel for pixel in row] for row in image]"},{"question":"# Problem Statement: You need to design a function that reads a file containing a list of mathematical expressions, evaluates them, and returns the results. Each expression is given in a separate line in the file. Implement the `evaluate_expressions` function which reads the expressions from the provided file, evaluates them, and returns the results in the form of a list. # Functions to Implement: 1. `evaluate_expressions(file_path) -> list` **Parameters**: - `file_path` (str): The path to the input file containing the mathematical expressions. **Returns**: - `results` (list): A list of results for each expression evaluated in the file, in the same order as they appear. # Constraints: - The file is guaranteed to contain valid mathematical expressions. - Expressions may include addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`) operators. - Handle division by zero by returning `None` for that specific expression. # Example: Suppose the contents of the file at `\\"/path/to/expressions.txt\\"` are: ``` 3 + 5 10 / 2 8 * 7 12 - 4 5 / 0 ``` ```python print(evaluate_expressions(\\"/path/to/expressions.txt\\")) # Output should be [8, 5.0, 56, 8, None] ``` # Hints: - You may use Python\'s built-in `eval` function to evaluate the mathematical expressions safely. - Ensure to handle exceptions, such as division by zero, gracefully. - Consider using a `try-except` block to catch and handle any errors during the evaluation of expressions.","solution":"def evaluate_expressions(file_path): Reads mathematical expressions from a file and evaluates them. Parameters: - file_path (str): The path to the input file containing the mathematical expressions. Returns: - results (list): A list of results for each expression evaluated in the file, in the same order as they appear. results = [] try: with open(file_path, \'r\') as file: expressions = file.readlines() for expression in expressions: expression = expression.strip() try: result = eval(expression) results.append(result) except ZeroDivisionError: results.append(None) except FileNotFoundError: raise FileNotFoundError(f\\"The file at {file_path} was not found.\\") return results"},{"question":"# Problem Statement You are building a utility for processing large datasets stored in CSV files. One of the tasks is to compress a CSV file by converting consecutive identical rows into a count representation. # Task Write a function `compress_csv(file_path, output_path)` that reads data from a CSV file at `file_path`, compresses consecutive identical rows, and writes the result into a new CSV file at `output_path`. # Input * `file_path` (string): Path to the input CSV file. * `output_path` (string): Path to the output CSV file to save the compressed data. # Output * None. The function writes the compressed data into `output_path`. # Compression Rules * If one or more consecutive rows are identical, compress them into a single row followed by the number of occurrences. * The compressed CSV should maintain the column headers from the original file. * If a row appears only once, it should be written as is. # Example For an input CSV: ```csv Name,Amount,Date Alice,50,2021-05-01 Alice,50,2021-05-01 Bob,20,2021-05-01 Bob,20,2021-05-01 Bob,20,2021-05-01 Alice,50,2021-05-01 ``` The output CSV file should be: ```csv Name,Amount,Date,Count Alice,50,2021-05-01,2 Bob,20,2021-05-01,3 Alice,50,2021-05-01,1 ``` # Constraints * The input CSV file will not contain any empty rows. * The column headers in the input CSV file are guaranteed to be unique. * Assume the CSV file can fit into memory. # Notes * Use appropriate CSV handling libraries if available in your programming language. * Ensure the output CSV preserves the order of rows as in the input CSV but in a compressed format. # Example Usage ```python compress_csv(\\"input.csv\\", \\"output.csv\\") ``` * This will read data from `input.csv`, compress it, and write the result into `output.csv`.","solution":"import csv def compress_csv(file_path, output_path): Compress consecutive identical rows in a CSV file. Args: - file_path (str): Path to the input CSV file. - output_path (str): Path to the output CSV file. with open(file_path, mode=\'r\', newline=\'\') as infile: reader = csv.reader(infile) headers = next(reader) # Prepare the data structure to hold the compressed data compressed_data = [headers + [\'Count\']] previous_row = None count = 0 for row in reader: # Check if the row is identical to the previous one if row == previous_row: count += 1 else: # If we encounter a new row, we need to write the previous row with its count if previous_row is not None: compressed_data.append(previous_row + [count]) # Reset counters for the new row previous_row = row count = 1 # Don\'t forget to add the last row group after the loop completes if previous_row is not None: compressed_data.append(previous_row + [count]) # Write compressed data to the output file with open(output_path, mode=\'w\', newline=\'\') as outfile: writer = csv.writer(outfile) writer.writerows(compressed_data)"},{"question":"# Coding Assessment Question **Title**: Implement a Function to Calculate the Edit Distance Between Two Strings **Context**: You are building a text processing application that requires determining the similarity between two strings. To achieve this, you need to implement a function that calculates the Levenshtein distance (also known as the edit distance) which measures the minimum number of single-character edits required to change one word into the other. **Task**: Write a function `calculate_edit_distance` that takes two strings and returns the edit distance between them. **Input**: - `str1`: a string containing between 1 and 1000 characters. - `str2`: a string containing between 1 and 1000 characters. **Output**: - An integer representing the edit distance between `str1` and `str2`. **Constraints**: - All characters in both strings are lowercase English letters. - The length of the strings will not exceed 1000 characters. **Example**: ```python str1 = \\"kitten\\" str2 = \\"sitting\\" print(calculate_edit_distance(str1, str2)) ``` **Expected Output**: ``` 3 ``` **Notes**: - The allowed single-character edits are: - Insertion of a character. - Deletion of a character. - Substitution of a character. - To implement this, you can use dynamic programming to store partial results and build up the solution incrementally. This ensures an efficient computation even for relatively long strings. **Hints**: - Utilize a 2D array `dp` where `dp[i][j]` represents the edit distance between the first `i` characters of `str1` and the first `j` characters of `str2`. - Initialize `dp[i][0] = i` for all `i` from 0 to the length of `str1`, and `dp[0][j] = j` for all `j` from 0 to the length of `str2`. This represents the cost of converting an empty string to another string by insertions or deletions. - Iterate through the array to fill it up using the relation: [ text{dp}[i][j] = begin{cases} text{dp}[i-1][j-1] & text{if} ; text{str1}[i-1] = text{str2}[j-1] 1 + min(text{dp}[i-1][j], ; text{dp}[i][j-1], ; text{dp}[i-1][j-1]) & text{if} ; text{str1}[i-1] neq text{str2}[j-1] end{cases} ] - The value at `dp[len(str1)][len(str2)]` will be the edit distance between `str1` and `str2`.","solution":"def calculate_edit_distance(str1, str2): Computes the Levenshtein distance (edit distance) between two strings. Parameters: - str1 (str): First string - str2 (str): Second string Returns: - int: The edit distance between the two strings len1, len2 = len(str1), len(str2) # Initialize a 2D array to store the distances dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Base cases: dp[i][0] and dp[0][j] for i in range(len1 + 1): dp[i][0] = i for j in range(len2 + 1): dp[0][j] = j # Fill dp array for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Substitution ) return dp[len1][len2]"},{"question":"# Question: Implement Custom Queue with Maximum Function You are asked to implement a custom queue that supports not only the standard queues\' enqueue and dequeue operations but also has an additional function to retrieve the maximum element currently in the queue. The operations must be efficiently implemented to handle large volumes of data. Objective Create a custom queue class with methods to enqueue an element, dequeue an element, and retrieve the maximum element currently in the queue. Expected Input and Output * **Input**: Calls to various methods (enqueue, dequeue, get_max) on an instance of the custom queue class. ```python CustomQueue().method() ``` * **Output**: - For enqueue and dequeue, no output is expected. - For get_max, return the maximum element in the queue. Constraints * The queue may contain at most 100,000 elements at any time. * Each integer in the queue will fit within the 32-bit signed integer range: [−2³¹, 2³¹ − 1]. * It is guaranteed that get_max will not be called on an empty queue. Performance Requirements * Enqueue, dequeue, and get_max operations should each run in amortized O(1) time. Scenario You are developing a data processing system where maintaining and quickly retrieving the maximum value in a queue of incoming sensor data is critical. Your custom queue class will be used in several performance-sensitive calculations. # Your Task: Write a Python class `CustomQueue` that implements the described functionality. ```python class CustomQueue: def __init__(self): Initialize your data structure here. pass def enqueue(self, x: int) -> None: :param x: integer to add to the queue pass def dequeue(self) -> None: :return: remove the front element from the queue pass def get_max(self) -> int: :return: return the maximum element in the queue pass ``` **Example**: ```python # Initialize the custom queue queue = CustomQueue() # Enqueue elements queue.enqueue(1) queue.enqueue(3) queue.enqueue(2) # Get maximum element print(queue.get_max()) # Output: 3 # Dequeue elements queue.dequeue() # Get maximum element print(queue.get_max()) # Output: 3 ``` This question ensures you understand data structure implementation and can optimize for performance, simulating real-world problem-solving scenarios.","solution":"from collections import deque class CustomQueue: def __init__(self): Initialize two deques: one to store the elements of the queue and another to track the maximum values. self.queue = deque() self.max_queue = deque() def enqueue(self, x: int) -> None: :param x: integer to add to the queue self.queue.append(x) # Maintain the max queue such that max_queue[0] is always the maximum element while self.max_queue and self.max_queue[-1] < x: self.max_queue.pop() self.max_queue.append(x) def dequeue(self) -> None: :return: remove the front element from the queue if self.queue: elem = self.queue.popleft() if elem == self.max_queue[0]: self.max_queue.popleft() def get_max(self) -> int: :return: return the maximum element in the queue if self.max_queue: return self.max_queue[0] raise IndexError(\\"get_max called on an empty queue\\")"},{"question":"# Problem Statement You are given a list of tuples representing the edges of a directed graph. Each tuple `(u, v)` indicates an edge going from node `u` to node `v`. Your task is to implement a function that detects if there is a cycle in the graph. Implement the function `detect_cycle_in_directed_graph(edges: List[Tuple[int, int]]) -> bool` where: **Input**: * `edges` (List[Tuple[int, int]]): A list of tuples representing the edges of the directed graph. **Output**: * (bool): Returns `True` if there is a cycle in the graph, and `False` otherwise. **Constraints**: * The number of nodes and edges in the graph will not exceed 10^4. * The graph will not contain parallel edges (i.e., multiple edges with the same start and end nodes). * Self-loops (edges where `u == v`) are allowed and should be considered as a cycle. **Example**: ```python >>> detect_cycle_in_directed_graph([(1, 2), (2, 3), (3, 1)]) True >>> detect_cycle_in_directed_graph([(1, 2), (2, 3), (3, 4)]) False >>> detect_cycle_in_directed_graph([(1, 2), (2, 2)]) True ``` **Notes**: * If the list of edges is empty, it indicates an acyclic graph and the function should return `False`. * You may assume that the nodes are referenced by integers starting from 1.","solution":"from typing import List, Tuple from collections import defaultdict, deque def detect_cycle_in_directed_graph(edges: List[Tuple[int, int]]) -> bool: Detects if there is a cycle in the directed graph represented by edges. :param edges: List of tuples indicating directed edges of the graph. :return: True if there is a cycle, False otherwise. # Create adjacency list graph = defaultdict(list) in_degree = defaultdict(int) # Populate the graph and calculate in-degrees for u, v in edges: graph[u].append(v) in_degree[v] += 1 if u not in in_degree: in_degree[u] = 0 # Initialize queue with nodes having zero in-degree queue = deque([node for node in in_degree if in_degree[node] == 0]) visited_count = 0 # Perform topological sort while queue: current = queue.popleft() visited_count += 1 for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If the number of visited nodes is less than the total number of nodes, there is a cycle return visited_count != len(in_degree)"},{"question":"# Question: Enhanced To-Do List Management You have been provided with a To-Do List application that manages tasks. Your task is to improve the application by adding support for task priority and recurring tasks while considering performance and error handling enhancements. **Task** 1. Modify the `add_task` function to accept a priority level (low, medium, high). 2. Modify the `add_task` function to accept a recurrence interval (daily, weekly, monthly). 3. Enhance the `get_tasks` function to retrieve tasks sorted by priority. 4. Ensure proper handling and logging of all potential errors, including invalid inputs. # Requirements **Function Signatures** ```python import datetime # You may use this library for date and time handling import logging # You may use this library for logging tasks = [] # List to store tasks def add_task(task_name: str, priority: str, recurrence: str) -> None: pass # Your implementation here def get_tasks() -> list[dict]: pass # Your implementation here ``` **Task Structure** ```python task_example = { \\"name\\": \\"Task 1\\", \\"priority\\": \\"high\\", \\"recurrence\\": \\"daily\\", \\"created_at\\": datetime.datetime.now() } ``` **Input** - `task_name` (str): The name of the task to be added. - `priority` (str): The priority level of the task (\\"low\\", \\"medium\\", \\"high\\"). - `recurrence` (str): The recurrence interval of the task (\\"daily\\", \\"weekly\\", \\"monthly\\"). **Output** - `add_task()`: Adds a task to the list. - `get_tasks()`: Returns a list of tasks sorted by priority in descending order. **Constraints** - Handle invalid priority and recurrence inputs with appropriate error messages. - Ensure the `get_tasks` function operates efficiently for a large number of tasks. **Performance** - Efficiently handle the addition and retrieval of tasks, especially under high usage. # Example ```python add_task(\\"Complete project report\\", \\"high\\", \\"daily\\") add_task(\\"Grocery shopping\\", \\"medium\\", \\"weekly\\") add_task(\\"Call plumber\\", \\"low\\", \\"monthly\\") tasks = get_tasks() print(tasks) ``` ```python # Expected output [ {\\"name\\": \\"Complete project report\\", \\"priority\\": \\"high\\", \\"recurrence\\": \\"daily\\", \\"created_at\\": <timestamp>}, {\\"name\\": \\"Grocery shopping\\", \\"priority\\": \\"medium\\", \\"recurrence\\": \\"weekly\\", \\"created_at\\": <timestamp>}, {\\"name\\": \\"Call plumber\\", \\"priority\\": \\"low\\", \\"recurrence\\": \\"monthly\\", \\"created_at\\": <timestamp>} ] ``` # Note - Use proper logging to record all types of errors for troubleshooting. - Ensure task priority is respected in the output of `get_tasks`.","solution":"import datetime import logging logging.basicConfig(level=logging.ERROR) tasks = [] def add_task(task_name: str, priority: str, recurrence: str) -> None: valid_priorities = [\\"low\\", \\"medium\\", \\"high\\"] valid_recurrences = [\\"daily\\", \\"weekly\\", \\"monthly\\"] if priority not in valid_priorities: logging.error(f\\"Invalid priority: {priority}. Valid priorities are {valid_priorities}.\\") return if recurrence not in valid_recurrences: logging.error(f\\"Invalid recurrence: {recurrence}. Valid recurrences are {valid_recurrences}.\\") return task = { \\"name\\": task_name, \\"priority\\": priority, \\"recurrence\\": recurrence, \\"created_at\\": datetime.datetime.now() } tasks.append(task) def get_tasks() -> list[dict]: priority_order = {\\"high\\": 3, \\"medium\\": 2, \\"low\\": 1} return sorted(tasks, key=lambda x: priority_order[x[\\"priority\\"]], reverse=True)"},{"question":"# Question: Design a Parking Lot System Scenario You are asked to develop a parking lot system that manages the parking spaces for vehicles. The parking lot has multiple levels, and each level has a fixed number of parking spaces of various types (small, medium, and large). Each type of vehicle (motorcycle, car, and bus) can park in different types of spaces: - A motorcycle can park in any spot. - A car can park in either a medium or large spot. - A bus can park only in a large spot. Task Implement a class `ParkingLot` with the following methods: 1. **`__init__(self, levels: int, spaces_per_level: List[Dict[str, int]]):`** * Initializes the parking lot with a given number of levels, each level having a specified number of small, medium, and large parking spaces. The `spaces_per_level` argument is a list of dictionaries where each dictionary corresponds to one level with keys `\\"small\\"`, `\\"medium\\"`, and `\\"large\\"` indicating the number of each space type. 2. **`park(self, vehicle_type: str) -> bool:`** * Parks a vehicle of the given type (`\'motorcycle\'`, `\'car\'`, or `\'bus\'`) into an appropriate spot if available. Returns `True` if the vehicle was parked successfully, otherwise returns `False`. 3. **`leave(self, level: int, space_type: str) -> None:`** * Frees up a parking space of the specified type (`\'small\'`, `\'medium\'`, `\'large\'`) on the given level (`0`-indexed). Constraints * Levels and parking spaces are indexed starting from 0. * Assume the inputs to the methods will be valid as per the above descriptions. * The typical usage would be: * `parking_lot = ParkingLot(levels, spaces_per_level)` * `is_parked = parking_lot.park(vehicle_type)` * `parking_lot.leave(level, space_type)` Example ```python # Initialize a parking lot with 2 levels: # Level 0 has 1 small, 2 medium, and 1 large spot. # Level 1 has 2 small, 2 medium, and 2 large spots. parking_lot = ParkingLot(2, [{\'small\': 1, \'medium\': 2, \'large\': 1}, {\'small\': 2, \'medium\': 2, \'large\': 2}]) # Park vehicles print(parking_lot.park(\'motorcycle\')) # returns True (parked in a small space in level 0) print(parking_lot.park(\'car\')) # returns True (parked in a medium space in level 0) print(parking_lot.park(\'bus\')) # returns True (parked in a large space in level 0) print(parking_lot.park(\'bus\')) # returns True (parked in a large space in level 1) print(parking_lot.park(\'bus\')) # returns False (no large space available) # Leave spaces parking_lot.leave(0, \'small\') print(parking_lot.park(\'motorcycle\')) # returns True (parked in a small space in level 0) parking_lot.leave(1, \'large\') print(parking_lot.park(\'bus\')) # returns True (parked in a large space in level 1) ```","solution":"class ParkingLot: def __init__(self, levels: int, spaces_per_level: list[dict[str, int]]): self.levels = levels self.spaces_per_level = spaces_per_level self.parking_status = [ {\'small\': spaces.get(\'small\', 0), \'medium\': spaces.get(\'medium\', 0), \'large\': spaces.get(\'large\', 0)} for spaces in spaces_per_level ] def park(self, vehicle_type: str) -> bool: if vehicle_type == \'motorcycle\': for level in range(self.levels): for space_type in [\'small\', \'medium\', \'large\']: if self.parking_status[level][space_type] > 0: self.parking_status[level][space_type] -= 1 return True elif vehicle_type == \'car\': for level in range(self.levels): for space_type in [\'medium\', \'large\']: if self.parking_status[level][space_type] > 0: self.parking_status[level][space_type] -= 1 return True elif vehicle_type == \'bus\': for level in range(self.levels): if self.parking_status[level][\'large\'] > 0: self.parking_status[level][\'large\'] -= 1 return True return False def leave(self, level: int, space_type: str) -> None: self.parking_status[level][space_type] += 1"},{"question":"# Coding Assessment Question **Scenario**: You are developing a utility for word processing software that involves simplifying sentences by removing duplicate words. The goal is to create a function that processes a sentence and returns the sentence without any duplicated words, preserving the order of the first occurrence of each word. **Task**: Write a function `remove_duplicates` that: - Takes a single argument, `sentence`, which is a string. - Returns a string with all duplicated words removed, preserving the order of their first occurrence. Words are case-sensitive, meaning \\"Hello\\" and \\"hello\\" are considered different words. **Input**: - A single string `sentence` representing a sentence, which may contain multiple words separated by spaces. **Output**: - A string with all duplicated words removed, preserving the order of their first occurrence. **Constraints**: - Words are case-sensitive. - Punctuation is considered part of the word, so \\"word.\\" and \\"word\\" are treated as distinct. - The input will not contain any leading or trailing spaces. - The function should handle larger sentences efficiently. **Function Signature**: ```python def remove_duplicates(sentence: str) -> str: ``` **Examples**: ```python remove_duplicates(\\"This is a test test sentence\\") # Expected output: \\"This is a test sentence\\" remove_duplicates(\\"Hello hello Hello\\") # Expected output: \\"Hello hello\\" remove_duplicates(\\"Python Python python\\") # Expected output: \\"Python python\\" remove_duplicates(\\"No duplicates here\\") # Expected output: \\"No duplicates here\\" remove_duplicates(\\"\\") # Expected output: \\"\\" ``` Write comprehensive test cases to ensure the validity of your implementation. The function should handle edge cases, such as sentences with no duplicates or multiple occurrences of the same word.","solution":"def remove_duplicates(sentence: str) -> str: Removes duplicate words from the sentence, preserving the order of their first occurrence. Parameters: sentence (str): A string representing the sentence. Returns: str: A string with duplicates removed. words = sentence.split() seen = set() result = [] for word in words: if word not in seen: result.append(word) seen.add(word) return \' \'.join(result)"},{"question":"# Prime Number Checker **Context**: As part of a security feature for a new application, you need to implement a function to verify whether given numbers are prime. This feature helps ensure that selected encryption keys meet a prime-number criterion, which is essential for certain cryptographic algorithms. **Task**: Write a Python function named `is_prime(n: int) -> bool:` that performs the following tasks: 1. Determines whether the given integer `n` is a prime number. 2. Returns `True` if `n` is a prime number, otherwise returns `False`. **Constraints**: - You may assume the input will be a non-negative integer. - The function should handle edge cases such as 0 and 1, which are not prime numbers. - Aim for an efficient solution considering time complexity. **Input**: - `n` (int): A non-negative integer to be checked for primality. **Output**: - `bool`: A boolean value indicating whether the given number is prime. **Example**: ```python >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(1) False ``` # Instructions: 1. Create a function that accepts an integer `n`. 2. Implement the logic to check if `n` is prime. 3. Utilize efficient algorithms for prime checking, such as trial division up to the square root of `n`. 4. Consider edge cases and return appropriate results.","solution":"def is_prime(n: int) -> bool: Determines whether the given integer n is a prime number. Args: n (int): A non-negative integer to be checked for primality. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Coding Assessment Question **Title**: Implement a Matrix Rotation Function **Context**: You are working on a software that involves manipulating and transforming images stored as 2D matrices. For a particular operation, you need to rotate a given square matrix by 90 degrees clockwise. **Task**: Write a function `rotate_matrix` that takes a square matrix represented as a 2D list and returns the matrix rotated by 90 degrees clockwise. **Input**: - `matrix`: a 2D list of integers representing the matrix to be rotated. **Output**: - A 2D list of integers representing the rotated matrix. **Constraints**: - The input matrix will always be a non-empty square matrix (same number of rows and columns). - Elements in the matrix are integers and can be negative. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_matrix(matrix) print(rotated_matrix) ``` **Expected Output**: ``` [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` **Additional Example**: ```python matrix = [ [-1, -2, -3, -4], [-5, -6, -7, -8], [-9, -10, -11, -12], [-13, -14, -15, -16] ] rotated_matrix = rotate_matrix(matrix) print(rotated_matrix) ``` **Expected Output**: ``` [[-13, -9, -5, -1], [-14, -10, -6, -2], [-15, -11, -7, -3], [-16, -12, -8, -4]] ``` **Notes**: - Avoid using external libraries for this transformation. Use nested loops or Python list comprehensions. - Consider edge cases such as a 1x1 matrix where the rotation should return the same matrix. **Hints**: - Reflect the matrix about its main diagonal (transpose the matrix). - Reverse each row of the transposed matrix to get the rotated matrix. This question tests your ability to understand and implement matrix manipulations, a fundamental problem-solving skill in various computational fields.","solution":"def rotate_matrix(matrix): Rotates a given square matrix by 90 degrees clockwise. :param matrix: List[List[int]] - A 2D list of integers representing the matrix :return: List[List[int]] - A 2D list of integers representing the rotated matrix # First, transpose the matrix n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Sudoku Solver Coding Challenge Overview You are tasked with solving a classic Sudoku puzzle. The objective is to fill a 9x9 grid so that each row, each column, and each of the nine 3x3 subgrids (also known as blocks or regions) contains all the digits from 1 to 9. Problem Statement Implement a function `solve_sudoku(board: List[List[str]]) -> None` that takes a 9x9 matrix representing a Sudoku grid and modifies it in place to solve the puzzle. Empty cells are denoted by the character `\'.\'`. Input - `board`: A 9x9 matrix (list of lists) containing characters `\'1\'` to `\'9\'` and `\'.\'` for empty cells. Output - The function should modify the board in place to be a valid solved Sudoku board. Constraints - The input board will correspond to a valid Sudoku puzzle, and exactly one solution exists. - The function should modify the board in place, without returning anything. Example ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solve_sudoku(board) # Expected output: The board should be modified to: # [ # [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], # [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], # [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], # [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], # [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], # [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], # [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], # [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], # [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] # ] ``` Notes - You may assume that the board configuration is always valid and solvable. - Use a backtracking approach to fill in the missing numbers systematically. - Ensure the solution doesn\'t exceed reasonable time and space complexity.","solution":"def solve_sudoku(board): def is_valid(board, r, c, num): for i in range(9): if board[r][i] == num or board[i][c] == num: return False row_start, col_start = 3 * (r // 3), 3 * (c // 3) for i in range(row_start, row_start + 3): for j in range(col_start, col_start + 3): if board[i][j] == num: return False return True def solve(board): for r in range(9): for c in range(9): if board[r][c] == \'.\': for num in map(str, range(1, 10)): if is_valid(board, r, c, num): board[r][c] = num if solve(board): return True board[r][c] = \'.\' return False return True solve(board)"},{"question":"# Scenario A technology company is working on a new social network analysis tool. As part of this project, they need to identify the largest connected component of users in the network. Each user is represented as a node in a graph, and friendships between users are represented as undirected edges. You are tasked with implementing a function that finds the size of the largest connected component in the graph. # Problem Statement You are given a graph representing a social network, where each node corresponds to a user, and each undirected edge corresponds to a friendship. Complete the function **largest_connected_component** which takes the number of users and a list of edges. The function should return the size (number of nodes) of the largest connected component. # Function Signature ```python def largest_connected_component(num_users: int, edges: List[Tuple[int, int]]) -> int: ``` # Input - **num_users**: An integer representing the number of users (N) in the social network. - **edges**: A list of tuples, where each tuple ( (u, v) ) represents an undirected edge connecting user ( u ) and user ( v ). # Output - Returns an integer representing the size of the largest connected component in the graph (number of users in the largest group of connected users). # Constraints - (1 leq num_users leq 2000) - (0 leq u, v < num_users) - ( leq edges leq N * (N - 1) / 2) # Example ```python users = 6 edges = [ (0, 1), (1, 2), (3, 4), (4, 5) ] print(largest_connected_component(users, edges)) # Expected Output: 3 ``` # Constraints and Performance Notes - Ensure the solution is efficient and scales well with the maximum constraints. - You may assume that there are no duplicate edges in the input list.","solution":"from typing import List, Tuple def largest_connected_component(num_users: int, edges: List[Tuple[int, int]]) -> int: # Helper function for Depth-First Search (DFS) def dfs(node, visited, graph): stack = [node] size = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True size += 1 for neighbor in graph[current]: if not visited[neighbor]: stack.append(neighbor) return size # Create an adjacency list for the graph graph = [[] for _ in range(num_users)] for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * num_users largest_size = 0 for user in range(num_users): if not visited[user]: component_size = dfs(user, visited, graph) largest_size = max(largest_size, component_size) return largest_size"},{"question":"# Coding Question: You are tasked with implementing a function that finds the smallest integer which, when its digits are squared and added together repeatedly, ends in 1. The goal is to test your understanding of mathematical sequences and iterative processes. Function Signature: ```python def smallest_happy_number() -> int: Finds the smallest integer such that the sum of the squares of its digits, repeated iteratively, eventually equals 1. Returns: - int: The smallest happy number. Example: - Example Output: 1 or 7 pass ``` Explanation: A \\"happy number\\" is defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process. If the process results in 1, then the original number is a happy number. If the process cycles endlessly in a loop that does not include 1, then the number is not a happy number. Example: For example, starting with `19`: 1^2 + 9^2 = 1 + 81 = 82 8^2 + 2^2 = 64 + 4 = 68 6^2 + 8^2 = 36 + 64 = 100 1^2 + 0^2 + 0^2 = 1 Since this process results in `1`, `19` is a happy number. The smallest happy number is thus `1` (or could be `7`). Constraints: - You may use any positive integer in your calculations. - Optimize your solution to handle larger numbers efficiently. Implementation Details: - Write helper functions as necessary. - Focus on creating an efficient algorithm to detect cycles and terminate the process if a loop is detected. Good luck!","solution":"def is_happy_number(n: int) -> bool: Checks whether a given number is a happy number. Parameters: n (int): The number to check. Returns: bool: True if `n` is a happy number, False otherwise. def next_number(num): total_sum = 0 while num > 0: digit = num % 10 total_sum += digit * digit num //= 10 return total_sum seen = set() while n != 1 and n not in seen: seen.add(n) n = next_number(n) return n == 1 def smallest_happy_number() -> int: Finds the smallest integer such that the sum of the squares of its digits, repeated iteratively, eventually equals 1. Returns: - int: The smallest happy number. i = 1 while True: if is_happy_number(i): return i i += 1"},{"question":"# Graph Connectivity Task **Context**: You are tasked with verifying the connectivity of an undirected graph. This is crucial in applications related to network reliability, social network analysis, and physical infrastructure planning. You will determine if there is a path between any given pair of vertices in the graph. **Task**: Write a function `is_connected` that, given the number of vertices and the edges of an undirected graph, returns whether the graph is connected. * **Input**: - An integer `n` representing the number of vertices (numbered from 0 to n-1). - A list of edges where each edge is represented by a tuple of two integers `(u, v)` indicating an undirected edge between vertices `u` and `v`. * **Output**: - A boolean value `True` if the graph is connected and `False` otherwise. * **Constraints**: - `1 <= n <= 10^4` (Number of vertices) - `0 <= len(edges) <= 10^4` (Number of edges) - Vertices are 0-indexed. * **Performance Requirements**: Optimize for time and space complexity, considering the upper limits of the constraints. ```python def is_connected(n: int, edges: list[tuple[int, int]]) -> bool: # Implement your solution here pass # Example: n = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4)] # Expected Output: # True ``` **Note**: Provide edge cases handling, such as graphs with no edges, self-loops, or graphs that are inherently disconnected due to isolated vertices. Document your approach to using graph traversal algorithms to verify connectivity.","solution":"def is_connected(n: int, edges: list[tuple[int, int]]) -> bool: from collections import defaultdict, deque if n == 1: return True if not edges: return False # Create the adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS to check connectivity visited = set() queue = deque([0]) visited.add(0) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # If we visited all nodes, the graph is connected return len(visited) == n"},{"question":"# Segment Tree Range Queries Problem Statement: You have to implement a Segment Tree to efficiently handle range queries and updates on an array of integers. This tree will support the following operations: 1. **build_segment_tree(arr)** - **Input**: - `arr`: A list of integers. - **Output**: - Returns the root of the Segment Tree constructed from the given array. 2. **range_sum_query(segment_tree, start, end)** - **Input**: - `segment_tree`: The root of a Segment Tree. - `start`: An integer representing the starting index of the query range. - `end`: An integer representing the ending index of the query range. - **Output**: - Returns the sum of elements within the range `[start, end]`. 3. **update_value(segment_tree, index, value)** - **Input**: - `segment_tree`: The root of a Segment Tree. - `index`: An integer representing the index of the element to update. - `value`: An integer representing the new value to be updated at the specified index. - **Output**: - Updates the value at `arr[index]` to `value` and modifies the Segment Tree accordingly. Constraints: - The array will have at least one element. - The values in the array will be finite integer numbers. - Use a reasonable limit on the number of elements in the array (N <= 10^5). Example: ```python arr = [1, 3, 5, 7, 9, 11] # Function Calls segment_tree = build_segment_tree(arr) range_sum = range_sum_query(segment_tree, 1, 3) update_value(segment_tree, 2, 6) updated_range_sum = range_sum_query(segment_tree, 1, 3) # Expected Output # range_sum should be 15 (3 + 5 + 7) # After update, indices are: [1, 3, 6, 7, 9, 11] # updated_range_sum should be 16 (3 + 6 + 7) ``` Notes: - Your implementation should handle edge cases such as out of range queries and updates. - The Segment Tree should be built and queried as efficiently as possible. - Test your implementation thoroughly to ensure correctness and efficiency. # Example Execution: ```python arr = [1, 3, 5, 7, 9, 11] segment_tree = build_segment_tree(arr) print(range_sum_query(segment_tree, 1, 3)) # Output: 15 update_value(segment_tree, 2, 6) print(range_sum_query(segment_tree, 1, 3)) # Output: 16 ```","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos >>= 1 self.tree[pos] = self.tree[pos << 1] + self.tree[pos << 1 | 1] def query(self, left, right): res = 0 left += self.n right += self.n + 1 while left < right: if left & 1: res += self.tree[left] left += 1 if right & 1: right -= 1 res += self.tree[right] left >>= 1 right >>= 1 return res def build_segment_tree(arr): return SegmentTree(arr) def range_sum_query(segment_tree, start, end): return segment_tree.query(start, end) def update_value(segment_tree, index, value): segment_tree.update(index, value)"},{"question":"# Scenario: You are developing a utility for date manipulation that can calculate the number of days between two dates. The dates will be provided in the format \\"YYYY-MM-DD\\". Additionally, you need to correctly handle leap years and ensure that the calculation is accurate even for different month lengths. # Task: Write a function named `days_between_dates` that takes in two strings representing dates (`date1` and `date2`) and returns the number of days between them. The function should accept dates in the \\"YYYY-MM-DD\\" format and perform the following tasks: 1. Parse the inputs to ensure they are valid dates. 2. Calculate the absolute difference in days between the two dates. # Input: - Two strings representing dates in the \\"YYYY-MM-DD\\" format: `date1` and `date2`. # Output: - An integer representing the number of days between the two dates. # Constraints: - The dates provided will be valid and in the correct format. - The dates can be from the year 1900 onwards. # Example: ```python >>> days_between_dates(\\"2023-01-01\\", \\"2023-01-31\\") 30 >>> days_between_dates(\\"2020-02-01\\", \\"2020-03-01\\") 29 >>> days_between_dates(\\"2019-02-01\\", \\"2019-03-01\\") 28 >>> days_between_dates(\\"2023-12-25\\", \\"2024-01-01\\") 7 ``` Ensure your solution handles leap years and varying month lengths correctly.","solution":"from datetime import datetime def days_between_dates(date1, date2): Returns the number of days between two dates. Parameters: date1 (str): The first date in YYYY-MM-DD format. date2 (str): The second date in YYYY-MM-DD format. Returns: int: The number of days between the two dates. date_format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) return abs((d2 - d1).days)"},{"question":"# Problem Statement A common problem in computer vision algorithms is the detection of shapes within a grid. One of the fundamental shapes is the square. Given a binary matrix (composed of 0s and 1s) where 1s represent part of a shape and 0s represent empty space, your task is to detect the largest square (composed only of 1s) within this matrix and return its area. # Requirements 1. Implement the `find_largest_square_area(matrix: list[list[int]]) -> int` function. 2. Ensure that the function handles large matrices efficiently. 3. The function should return the area (number of cells) of the largest square composed entirely of 1s. # Input Format * A list of lists where each sub-list contains binary integers (0s and 1s). # Output Format * An integer representing the area (number of cells) of the largest square composed of 1s. # Constraints * The input `matrix` will have dimensions up to 1000 rows and 1000 columns. * Each sub-list will contain only integers 0 and 1. # Example ```python # Input matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] # Output output_area = 4 ``` Implement the function `find_largest_square_area` that meets the above requirements.","solution":"def find_largest_square_area(matrix): if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) max_side = 0 dp = [[0] * (cols + 1) for _ in range(rows + 1)] for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i-1][j-1] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"# Problem: Optimizing Data Storage with Run-Length Encoding (RLE) Context You are working in a data compression project where storing data efficiently is crucial. One of the widely used methods in data compression is Run-Length Encoding (RLE). RLE compresses data by replacing sequences of the same data value (runs) with a single value and count. You are required to implement this compression and decompression algorithm. Task 1. **Implement the RLE Compression Function** that takes a string and returns its Run-Length Encoded form. 2. **Implement the RLE Decompression Function** that takes a Run-Length Encoded string and returns the original string. Details 1. **Functionality**: - Write a function `rle_compress` that compresses the input string using RLE. - Write a function `rle_decompress` that decompresses the RLE string back to its original form. 2. **Input and Output Formats**: - `rle_compress(data: str) -> str`: Compresses the input `data` string. - `rle_decompress(encoded_data: str) -> str`: Decompresses the `encoded_data` string. 3. **Constraints and Requirements**: - Consider edge cases such as an empty string. - Ensure correctness and efficiency in both compression and decompression. - The RLE encoded format should be a series of characters followed by their counts (e.g., \\"a3b2\\" for \\"aaabb\\"). 4. **Example Usage**: - `rle_compress(\'aaabbccccd\')` should return \'a3b2c4d1\'. - `rle_decompress(\'a3b2c4d1\')` should return \'aaabbccccd\'. Implementation ```python def rle_compress(data: str) -> str: Compresses the input string using Run-Length Encoding (RLE). if not data: return \\"\\" compressed = [] count = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: count += 1 else: compressed.append(data[i - 1] + str(count)) count = 1 compressed.append(data[-1] + str(count)) return \'\'.join(compressed) def rle_decompress(encoded_data: str) -> str: Decompresses the Run-Length Encoded string back to its original form. if not encoded_data: return \\"\\" decompressed = [] i = 0 while i < len(encoded_data): char = encoded_data[i] count = \\"\\" i += 1 while i < len(encoded_data) and encoded_data[i].isdigit(): count += encoded_data[i] i += 1 decompressed.append(char * int(count)) return \'\'.join(decompressed) # Example to test print(rle_compress(\'aaabbccccd\')) # Expected: \\"a3b2c4d1\\" print(rle_decompress(\'a3b2c4d1\')) # Expected: \\"aaabbccccd\\" ``` Write your implementation and ensure it passes all test cases provided.","solution":"def rle_compress(data: str) -> str: Compresses the input string using Run-Length Encoding (RLE). if not data: return \\"\\" compressed = [] count = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: count += 1 else: compressed.append(data[i - 1] + str(count)) count = 1 compressed.append(data[-1] + str(count)) return \'\'.join(compressed) def rle_decompress(encoded_data: str) -> str: Decompresses the Run-Length Encoded string back to its original form. if not encoded_data: return \\"\\" decompressed = [] i = 0 while i < len(encoded_data): char = encoded_data[i] count = \\"\\" i += 1 while i < len(encoded_data) and encoded_data[i].isdigit(): count += encoded_data[i] i += 1 decompressed.append(char * int(count)) return \'\'.join(decompressed)"},{"question":"Scenario You are responsible for creating a dashboard that displays user activity in the form of hourly statistics. One of the requirements is to generate a compressed representation of user activities, where consecutive hourly activity counts are represented in the form of a run-length encoding. This will help reduce the amount of data that needs to be stored and processed. Problem Statement Write a function `compress_hourly_activity` that, given a list of integers representing hourly user activity counts, returns a list that represents the run-length encoding of these counts. # Function Signature ```python def compress_hourly_activity(activity_counts: List[int]) -> List[Tuple[int, int]]: ``` # Input * A list of integers `activity_counts` where each integer represents the number of user activities in a specific hour. # Output * The function should return a list of tuples: * Each tuple contains two integers: the first integer is the activity count, and the second integer is the number of consecutive hours that this activity count appears. # Constraints * 1 <= len(activity_counts) <= 1000 * 0 <= activity_count <= 10000 # Example ```python activity_counts = [5, 5, 5, 8, 8, 1, 1, 1, 1, 10] result = compress_hourly_activity(activity_counts) # This should return: [(5, 3), (8, 2), (1, 4), (10, 1)] ``` # Additional Information * The list should be compressed such that fewer data points are needed to represent the same hourly activity information. * Ensure that your function efficiently handles cases with large numbers of hours or activity counts. * Implement checks to ensure that the run-length encoding is correctly maintained without any data loss.","solution":"from typing import List, Tuple def compress_hourly_activity(activity_counts: List[int]) -> List[Tuple[int, int]]: if not activity_counts: return [] compressed_list = [] current_count = activity_counts[0] current_streak = 1 for count in activity_counts[1:]: if count == current_count: current_streak += 1 else: compressed_list.append((current_count, current_streak)) current_count = count current_streak = 1 compressed_list.append((current_count, current_streak)) return compressed_list"},{"question":"String Compression with Count # Description: Write a function to perform basic string compression using the counts of repeated characters. For example, the string \\"aabcccccaaa\\" would become \\"a2b1c5a3\\". If the \\"compressed\\" string would not become smaller than the original string, your method should return the original string. # Input: * A string `s` that represents the input string to be compressed. # Output: * A compressed version of the string, or the original string if the compressed version is not shorter. # Constraints: * `1 <= len(s) <= 10^5` * `s` consists of lowercase English letters only. # Example: ```python def string_compression(s: str) -> str: # Your implementation here # Example Usage: s = \\"aabcccccaaa\\" compressed_s = string_compression(s) print(compressed_s) # Output: \\"a2b1c5a3\\" s = \\"abcd\\" compressed_s = string_compression(s) print(compressed_s) # Output: \\"abcd\\" ``` **Example Execution:** Given: ```plaintext s = \\"aabcccccaaa\\" ``` Expected output: ```plaintext \\"a2b1c5a3\\" ``` Given: ```plaintext s = \\"abcd\\" ``` Expected output: ```plaintext \\"abcd\\" ```","solution":"def string_compression(s: str) -> str: Performs basic string compression using the counts of repeated characters. Returns the original string if the compressed string is not shorter. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 compressed.append(s[-1]) compressed.append(str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"# Fibonacci Number Finder **Scenario**: A biologist is studying rabbit population growth, which follows the Fibonacci sequence. To assist in their research, you need to write a Python function that computes the `n`-th Fibonacci number. The biologist often works with large values, so your solution should be efficient. **Function Signature**: ```python def fibonacci(n: int) -> int: Computes the n-th Fibonacci number. :param n: The position in the Fibonacci sequence :return: The n-th Fibonacci number ``` **Input**: - A single integer `n` (0 <= n <= 10^5) **Output**: - An integer representing the `n`-th Fibonacci number. **Constraints**: - Your solution should be efficient enough to handle `n` up to 100,000. **Performance Requirements**: - Aim for at least O(n) time complexity and O(1) space complexity for your solution. **Example**: ```python print(fibonacci(0)) # Output: 0 print(fibonacci(1)) # Output: 1 print(fibonacci(10)) # Output: 55 print(fibonacci(20)) # Output: 6765 print(fibonacci(50)) # Output: 12586269025 ``` **Special Notes**: - Avoid using recursive solutions due to potential stack overflow and inefficiency for large `n`. - Consider using an iterative approach or dynamic programming to meet performance requirements. - Ensure your function handles the lower edge cases (e.g., 0 and 1) correctly.","solution":"def fibonacci(n: int) -> int: Computes the n-th Fibonacci number. :param n: The position in the Fibonacci sequence (0 <= n <= 10^5) :return: The n-th Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Objective Write a program that determines the optimal trade route for a series of planets based on provided trade values and distances between the planets. # Function Implementation Function Name: `optimal_trade_route` * **Input**: * `trade_values` (List[float]): List of trade values (profits) for each planet. * `distances` (List[List[float]]): Matrix of distances between planets, where `distances[i][j]` represents the distance between planet `i` and planet `j`. * **Output**: (float) Maximum profit achievable with the optimal trade route. * **Constraints**: * `trade_values` will have a length of `n` (number of planets), where `2 <= n <= 20`. * `distances` will be an `n x n` matrix. * All trade values and distances will be non-negative numbers. * The trade route must start from the first planet (index 0). # Error Handling * Raise ValueError with an appropriate message if: * The length of `trade_values` does not match the size of the `distances` matrix. * Any negative value is found in `trade_values` or `distances`. # Example ```python def optimal_trade_route(trade_values: list, distances: list) -> float: # Implement the function as specified above ``` # Sample Usage ```python trade_values = [10, 20, 30] distances = [ [0, 5, 10], [5, 0, 15], [10, 15, 0] ] print(optimal_trade_route(trade_values, distances)) # Expected output: 50 (Trade route: planet 0 -> planet 1 -> planet 2) trade_values = [8, 15, 5] distances = [ [0, 4, 7], [4, 0, 1], [7, 1, 0] ] print(optimal_trade_route(trade_values, distances)) # Expected output: 28 (Trade route: planet 0 -> planet 2 -> planet 1) ``` # Notes - You can use graph traversal algorithms such as Depth-First Search (DFS) or Dynamic Programming (DP) to find the optimal trade route. - Ensure your solution handles edge cases such as zero distances and duplicate trade values effectively.","solution":"def optimal_trade_route(trade_values, distances): from itertools import permutations # Validate input n = len(trade_values) if not all(len(row) == n for row in distances): raise ValueError(\\"Size of distances matrix must be equal to the length of trade_values list.\\") if any(tv < 0 for tv in trade_values) or any(any(d < 0 for d in row) for row in distances): raise ValueError(\\"Trade values and distances must be non-negative.\\") max_profit = 0 # Compute all permutations of planet indices starting from 0 planets = list(range(n)) for route in permutations(planets[1:], n - 1): route = [0] + list(route) profit = trade_values[0] current_planet = 0 for next_planet in route[1:]: profit += trade_values[next_planet] current_planet = next_planet max_profit = max(max_profit, profit) return max_profit"},{"question":"# Programming Assessment Question 2 **Context**: You are developing a cash register application. A key feature of this application is to calculate the required change that needs to be returned to a customer after a purchase. The change must be returned using the smallest number of coins and bills. **Task**: Implement a function `calculate_change()` that computes the smallest number of coins and bills required to return the change. Function Signature: ```python def calculate_change(amount_paid: float, item_cost: float) -> dict: pass ``` Input: * `amount_paid`: A float representing the amount of money given by the customer. * `item_cost`: A float representing the total cost of the purchased items. Output: * A dictionary representing the number of each denomination of coins and bills (descending order of value) necessary to make the change. Denominations include 100, 50, 20, 10, 5, 1, 0.25, 0.10, 0.05, and 0.01. Constraints: * The input amounts will be non-negative. * Assume there is always sufficient funds to provide the change (i.e., `amount_paid` is always greater than or equal to `item_cost`). Requirements: * Ensure the change is computed using the smallest number of coins and bills. * Include all possible denominations in the computation. * Return exactly zero denominations where applicable in the dictionary to maintain consistency. Example: ```python calculate_change(200, 121.96) # Output: {\'100\': 0, \'50\': 1, \'20\': 1, \'10\': 0, \'5\': 1, \'1\': 3, \'0.25\': 0, \'0.10\': 0, \'0.05\': 0, \'0.01\': 4} calculate_change(150, 143.45) # Output: {\'100\': 0, \'50\': 1, \'20\': 0, \'10\': 0, \'5\': 1, \'1\': 1, \'0.25\': 2, \'0.10\': 0, \'0.05\': 1, \'0.01\': 0} calculate_change(10, 10) # Output: {\'100\': 0, \'50\': 0, \'20\': 0, \'10\': 0, \'5\': 0, \'1\': 0, \'0.25\': 0, \'0.10\': 0, \'0.05\': 0, \'0.01\': 0} ``` Additional Notes: * Focus on correctness and efficiency of your solution. * Carefully consider rounding issues that might arise with floating-point arithmetic and aim to mitigate them. * Consider edge cases such as exact payment amounts where no change is required.","solution":"def calculate_change(amount_paid: float, item_cost: float) -> dict: Calculate the smallest number of coins and bills required to make the change. denominations = [ (\'100\', 100.0), (\'50\', 50.0), (\'20\', 20.0), (\'10\', 10.0), (\'5\', 5.0), (\'1\', 1.0), (\'0.25\', 0.25), (\'0.10\', 0.10), (\'0.05\', 0.05), (\'0.01\', 0.01) ] change_dict = {den: 0 for den, _ in denominations} change = round(amount_paid - item_cost, 2) for den, value in denominations: count = int(change // value) change_dict[den] = count change -= count * value change = round(change, 2) # Avoid floating point precision issues return change_dict"},{"question":"# String Character Case Transformation Your task is to implement a function `character_case_transformation` which alters the case of each alphabetical character in a given string based on its position according to the following rules: 1. If the character is in an odd position (1, 3, 5, ...), convert it to uppercase. 2. If the character is in an even position (2, 4, 6, ...), convert it to lowercase. The function should return the transformed string. Input: - `input_string` (str): A string consisting of alphabetical characters and possibly whitespace or punctuation. Output: - `transformed_string` (str): The string with characters transformed according to the specified rules. Constraints: - The input string can be of any length (0 <= length of `input_string` <= 10^4). - Only alphabetical characters should be affected by the transformation. Example: ```python def character_case_transformation(input_string): transformed_string = \\"\\" for i, char in enumerate(input_string): if char.isalpha(): if (i + 1) % 2 == 0: transformed_string += char.lower() else: transformed_string += char.upper() else: transformed_string += char return transformed_string # Example usage: print(character_case_transformation(\\"Hello World!\\")) # Expected Output: \\"HeLlO WoRlD!\\" ``` **Hint**: Use Python\'s string methods `isalpha()`, `upper()`, and `lower()` to facilitate the case changes according to character positions.","solution":"def character_case_transformation(input_string): Transform the case of each alphabetical character in the input string based on its position (1-indexed). Odd positions are uppercase, even positions are lowercase. transformed_string = \\"\\" for i, char in enumerate(input_string): if char.isalpha(): if (i + 1) % 2 == 0: transformed_string += char.lower() else: transformed_string += char.upper() else: transformed_string += char return transformed_string"},{"question":"# Scenario: You have been tasked with building a utility tool for network administrators to help them analyze subnet masks. A subnet mask is used in networking to divide an IP address into a network and host portion. An essential feature of your tool is to validate if the given subnet mask is correct and determine the number of hosts that can be supported within that subnet mask. # Problem Description: Implement a function `validate_subnet_mask` that takes a string input representing a subnet mask in dot-decimal notation and returns a tuple indicating its validity and the number of possible hosts it supports if valid. If the subnet mask is invalid, indicate the error in your output. # Function Signature: `def validate_subnet_mask(mask: str) -> (bool, str or int):` # Input: - `mask`: A string representing the subnet mask in dot-decimal notation (e.g., \\"255.255.255.0\\"). # Output: - Returns a tuple where: - The first element is a boolean indicating if the subnet mask is valid. - If valid, the second element is an integer representing the number of possible hosts supported. - If invalid, the second element is a string with an error message explaining the issue. # Constraints: - A valid subnet mask in dot-decimal notation has a contiguous block of 1 bits followed by a contiguous block of 0 bits. - The subnet mask must have exactly four octets (Example: 255.255.255.0). - Each octet must be in the range 0-255. # Example: ```python print(validate_subnet_mask(\'255.255.255.0\')) # Output: (True, 254) print(validate_subnet_mask(\'255.255.0.255\')) # Output: (False, \'Subnet mask is invalid\') print(validate_subnet_mask(\'255.255.255.128\')) # Output: (True, 126) print(validate_subnet_mask(\'255.255.255.255.0\')) # Output: (False, \'Incorrect format for subnet mask\') ``` # Notes: - You may find it useful to convert the subnet mask from dot-decimal notation to its binary form for validation. - Recall that the number of possible hosts is calculated by taking 2 raised to the number of zero bits in the subnet mask, minus 2 (for the network and broadcast addresses).","solution":"def validate_subnet_mask(mask: str) -> (bool, str or int): Validates the given subnet mask and returns a tuple indicating its validity and the number of possible hosts it supports. :param mask: A string representing the subnet mask in dot-decimal notation. :return: A tuple (isValid, result) where isValid is a boolean indicating the validity of the subnet mask, and result is either an integer representing the number of possible hosts or an error message. # Split the mask by dots octets = mask.split(\'.\') if len(octets) != 4: return (False, \'Incorrect format for subnet mask\') # Convert each octet to binary string and check validity try: binary_mask = \\"\\".join([bin(int(octet))[2:].zfill(8) for octet in octets]) except ValueError: return (False, \'Invalid numeric value in subnet mask\') if any(int(octet) < 0 or int(octet) > 255 for octet in octets): return (False, \'Each octet must be in the range 0-255\') # Check for the contiguous block of 1s followed by a block of 0s if \'01\' in binary_mask: return (False, \'Subnet mask is invalid\') # Calculate the number of hosts zero_bits = binary_mask.count(\'0\') if zero_bits == 0: return (True, 0) num_hosts = (2 ** zero_bits) - 2 return (True, num_hosts)"},{"question":"# Problem Statement: Task Scheduler You are given a list of tasks, each represented by a single character. Una task necesita exactamente una unidad de tiempo para completarse, y dos tareas idénticas deben estar separadas por al menos `n` unidades de tiempo (`n` puede ser 0, lo que significa que no hay restricciones de separación). Tu tarea es determinar el tiempo mínimo (`min_time`) que se necesita para completar todas las tareas. # Function Signature ```python def task_scheduler(tasks: List[str], n: int) -> int: pass ``` # Parameters * `tasks` (List[str]): A list of tasks represented by characters (A-Z). * `n` (int): The required cooldown period between two identical tasks. # Output * `int` - The minimum time (`min_time`) required to complete all the tasks. # Constraints * `1 <= len(tasks) <= 10^4` * `0 <= n <= 100` # Examples ```python # Example 1 tasks = [\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"B\\"] n = 2 print(task_scheduler(tasks, n)) # Expected output: 8 # Example 2 tasks = [\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"B\\"] n = 0 print(task_scheduler(tasks, n)) # Expected output: 6 # Example 3 tasks = [\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"B\\"] n = 1 print(task_scheduler(tasks, n)) # Expected output: 6 ``` # Additional Information 1. Each distinct task can be completed in any order. 2. If there is no need to wait, the tasks can be completed one after another without idle time. 3. If there is a required cooldown period, you might need to insert idle intervals (represented by `#`) to satisfy the cooldown requirements. # Further Considerations 1. Be considerate of the task distribution and the impact of the cooldown period on the overall scheduling. 2. Implement the function with an efficient approach to handle the larger input sizes within the constraints. 3. Validate `tasks` and `n` to ensure they provide a meaningful and solvable problem.","solution":"from typing import List import collections def task_scheduler(tasks: List[str], n: int) -> int: Given a list of tasks represented by characters and a cooldown period `n`, determine the minimum time required to complete all tasks. task_counts = collections.Counter(tasks) max_freq = max(task_counts.values()) max_count = sum(1 for task, count in task_counts.items() if count == max_freq) intervals_required = (max_freq - 1) * (n + 1) + max_count return max(intervals_required, len(tasks))"},{"question":"# Fibonacci Series: Nth Term Finder and Memoization Background: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, and so forth. Efficient computation of Fibonacci numbers is a common problem in computer science, often solved using dynamic programming and memoization. Task: You need to create a class `Fibonacci` with two methods: 1. `nth_term(self, n: int) -> int`: Computes the nth term of the Fibonacci series using memoization to optimize performance. 2. `clear_cache(self) -> None`: Clears the cache used for memoization. Requirements: - Utilize a dictionary or list to store previously computed Fibonacci terms to avoid redundant calculations. - Ensure that the `nth_term` method can handle larger values of `n` efficiently by employing memoization. Function Signature: ```python class Fibonacci: def __init__(self): # Your code here def nth_term(self, n: int) -> int: # Your code here def clear_cache(self) -> None: # Your code here ``` Input: - The `nth_term` method takes a single integer `n` (the position in the Fibonacci sequence to compute). Output: - The `nth_term` method returns the nth term of the Fibonacci series. - The `clear_cache` method resets the cache (does not return any value). Constraints / Assumptions: - `n` will be a non-negative integer. - Assume the input values for `n` can be large. - The Fibonacci class should use memoization to handle large computations efficiently. # Function Examples: ```python # Example 1 fib = Fibonacci() print(fib.nth_term(10)) # Returns 55 # Example 2 print(fib.nth_term(50)) # Returns 12586269025 # Example 3 fib.clear_cache() print(fib.nth_term(20)) # Returns 6765 # Example 4 print(fib.nth_term(0)) # Returns 0 # Example 5 print(fib.nth_term(1)) # Returns 1 ``` # Implementation Notes: - Ensure that the memoization structure is initialized during the instantiation of the `Fibonacci` class. - `nth_term` should handle base cases (n = 0 and n = 1) directly. - When calling `clear_cache`, the memoization structure should be emptied or reinitialized.","solution":"class Fibonacci: def __init__(self): self.cache = {} def nth_term(self, n: int) -> int: if n in self.cache: return self.cache[n] if n == 0: result = 0 elif n == 1: result = 1 else: result = self.nth_term(n-1) + self.nth_term(n-2) self.cache[n] = result return result def clear_cache(self) -> None: self.cache = {}"},{"question":"# Coding Assessment Question You are required to develop a function to simulate a simple in-memory key-value storage system that supports basic CRUD (Create, Read, Update, Delete) operations while ensuring thread safety. Your task involves designing and implementing this storage with the following specifications: 1. **Input**: N/A (The function ensures the ability to store key-value pairs in memory). 2. **Function Behaviors**: - **set(key: str, value: str)**: Stores the `key-value` pair. If the key already exists, update its value. - **get(key: str)**: Retrieves the value associated with the given `key`. If the key does not exist, return `None`. - **delete(key: str)**: Deletes the given `key` and its associated value. If the key does not exist, do nothing. - **list_keys()**: Returns a list of all stored keys. 3. **Thread Safety**: Ensure the implemented storage is thread-safe to allow operations from multiple threads without data corruption. 4. **Constraints**: - The keys and values will be simple strings. - The storage should efficiently handle up to 10,000 keys. - Prevent any race conditions that might arise from concurrent access. Here is an example class and method signatures to get you started: ```python import threading class InMemoryStorage: def __init__(self): self.store = {} self.lock = threading.Lock() def set(self, key: str, value: str): with self.lock: self.store[key] = value def get(self, key: str) -> str: with self.lock: return self.store.get(key, None) def delete(self, key: str): with self.lock: if key in self.store: del self.store[key] def list_keys(self) -> [str]: with self.lock: return list(self.store.keys()) ``` **Performance Requirements**: - Each function should complete in O(1) time complexity for its respective operation due to direct dictionary access. - The space complexity is O(n) where n is the number of stored key-value pairs. Implement the `InMemoryStorage` class according to the outlined requirements.","solution":"import threading class InMemoryStorage: def __init__(self): self.store = {} self.lock = threading.Lock() def set(self, key: str, value: str): with self.lock: self.store[key] = value def get(self, key: str) -> str: with self.lock: return self.store.get(key, None) def delete(self, key: str): with self.lock: if key in self.store: del self.store[key] def list_keys(self) -> [str]: with self.lock: return list(self.store.keys())"},{"question":"# Problem Statement You are asked to write a function that counts the number of unique characters in a given string and returns the count. # Function Signature ```python def count_unique_characters(s: str) -> int: pass ``` # Input * `s` (str): A string composed of lowercase and uppercase letters, digits, and special characters. # Output * An integer representing the number of unique characters in the string. # Constraints * The length of the string `s` will be in the range `[0, 10^5]`. * If `s` is not a string, your function should raise a TypeError. # Example ```python >>> count_unique_characters(\\"hello\\") 4 >>> count_unique_characters(\\"abcABC123\\") 9 >>> count_unique_characters(\\"aabbcc\\") 3 >>> count_unique_characters(\\"\\") 0 >>> count_unique_characters(\\"aA1!\\") 4 ``` # Notes 1. You should ensure the input is validated to be a string as mentioned in the constraints. 2. Special characters should also be considered in counting the number of unique characters.","solution":"def count_unique_characters(s: str) -> int: Returns the number of unique characters in the given string s. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") return len(set(s))"},{"question":"# Coding Assessment Question Background & Context You are developing a performance monitoring tool that tracks the CPU and memory usage of various processes running on a system. One of the critical functionalities of this tool is to calculate and log the resource usage statistics over time. Task Write a function `calculate_average_usage` that takes a list of process logs and calculates the average CPU and memory usage over the given period. Each entry in the logs is a dictionary containing the process id, timestamp, CPU usage percentage, and memory usage in megabytes. Function Signature ```python def calculate_average_usage(process_logs: List[dict]) -> dict: Calculates the average CPU and memory usage from the given process logs. :param process_logs: List[dict], a list of process logs where each log is a dictionary with keys: \'process_id\' (int), \'timestamp\' (str), \'cpu_usage\' (float), \'memory_usage\' (float). :returns: dict, a dictionary with keys \'average_cpu_usage\' and \'average_memory_usage\' with their respective average values. ``` Input and Output Format * **Input**: - `process_logs` (List[dict]): A list of process logs. Each log is a dictionary with the following structure: ```python { \'process_id\': int, # Unique identifier of the process \'timestamp\': str, # Timestamp of the log entry in the format \\"YYYY-MM-DD HH:MM:SS\\" \'cpu_usage\': float, # CPU usage percentage of the process at the time of the log \'memory_usage\': float # Memory usage in megabytes of the process at the time of the log } ``` * **Output**: - Returns a dictionary with two keys: - `average_cpu_usage` (float): The average CPU usage percentage rounded to two decimal places. - `average_memory_usage` (float): The average memory usage in megabytes rounded to two decimal places. Constraints * The input list will have at least one log entry. * The `cpu_usage` values will be between 0 and 100 (inclusive). * The `memory_usage` values will be non-negative floats. Example ```python process_logs = [ {\'process_id\': 1, \'timestamp\': \'2023-01-01 00:00:00\', \'cpu_usage\': 25.0, \'memory_usage\': 100.0}, {\'process_id\': 1, \'timestamp\': \'2023-01-01 01:00:00\', \'cpu_usage\': 30.0, \'memory_usage\': 110.0}, {\'process_id\': 2, \'timestamp\': \'2023-01-01 00:30:00\', \'cpu_usage\': 20.0, \'memory_usage\': 90.0} ] average_usage = calculate_average_usage(process_logs) # average_usage should be: # { # \'average_cpu_usage\': 25.00, # \'average_memory_usage\': 100.00 # } ``` Notes * Ensure that the function handles different numbers of log entries and maintains precision in the average calculations. * Consider using helper functions for tasks such as calculating sums or counts if needed. * Efficiently handle the list processing to ensure performance remains acceptable with larger input sizes.","solution":"from typing import List def calculate_average_usage(process_logs: List[dict]) -> dict: Calculates the average CPU and memory usage from the given process logs. :param process_logs: List[dict], a list of process logs where each log is a dictionary with keys: \'process_id\' (int), \'timestamp\' (str), \'cpu_usage\' (float), \'memory_usage\' (float). :returns: dict, a dictionary with keys \'average_cpu_usage\' and \'average_memory_usage\' with their respective average values. total_cpu_usage = 0.0 total_memory_usage = 0.0 logs_count = len(process_logs) for log in process_logs: total_cpu_usage += log[\'cpu_usage\'] total_memory_usage += log[\'memory_usage\'] average_cpu_usage = round(total_cpu_usage / logs_count, 2) average_memory_usage = round(total_memory_usage / logs_count, 2) return { \'average_cpu_usage\': average_cpu_usage, \'average_memory_usage\': average_memory_usage }"},{"question":"# File Compression and Decompression You are tasked with implementing a simple file compression and decompression tool using the Run-Length Encoding (RLE) algorithm. This algorithm is effective for files with many repeated characters. # Task: Implement the functions `compress` and `decompress` as specified below: 1. **Function `compress(data: str) -> str`:** * **Input**: * `data`: A string representing the content to be compressed. * **Output**: * A compressed string where each sequence of identical characters is replaced by the character followed by the number of times it appears consecutively. For example, \\"aaa\\" would be compressed to \\"a3\\". * **Constraints**: * If the input string is empty, return an empty string. 2. **Function `decompress(encoded_data: str) -> str`:** * **Input**: * `encoded_data`: A string representing the RLE compressed content. * **Output**: * The decompressed string, obtained by expanding the RLE compressed string back to its original form. For example, \\"a3\\" would be decompressed to \\"aaa\\". * **Constraints**: * The `encoded_data` will always be in a valid format where a character is followed by a positive integer. # Examples: ```python # Example usages of compress: print(compress(\\"aaabbbccc\\")) # Output: \\"a3b3c3\\" print(compress(\\"abcd\\")) # Output: \\"a1b1c1d1\\" print(compress(\\"\\")) # Output: \\"\\" # Example usages of decompress: print(decompress(\\"a3b3c3\\")) # Output: \\"aaabbbccc\\" print(decompress(\\"a1b1c1d1\\")) # Output: \\"abcd\\" print(decompress(\\"\\")) # Output: \\"\\" ``` # Additional Information: Ensure your functions handle all edge cases appropriately. The `decompress` function should correctly expand the RLE encoded string, and the `compress` function should correctly compress sequences of identical characters.","solution":"def compress(data: str) -> str: if not data: return \\"\\" compressed = [] prev_char = data[0] count = 1 for char in data[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 compressed.append(f\\"{prev_char}{count}\\") return \'\'.join(compressed) def decompress(encoded_data: str) -> str: if not encoded_data: return \\"\\" decompressed = [] i = 0 n = len(encoded_data) while i < n: char = encoded_data[i] i += 1 count = 0 while i < n and encoded_data[i].isdigit(): count = count * 10 + int(encoded_data[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Problem Description You are tasked with implementing a function that can automatically group a space-separated string of integers into clusters. The goal is to group these integers based on their proximity to each other, so that numbers close to each other form a group. # Inputs and Outputs * **Input**: - A string of space-separated integers. - An integer `threshold` that defines the maximum distance between two integers in the same group. * **Output**: - A list of lists, where each list contains integers that form a group based on the given threshold. # Constraints - The input string will only contain valid integers separated by spaces. - The `threshold` will be a positive integer. - The integers in the resulting groups should appear in the same order as they appear in the input string. # Requirements You are required to: 1. Parse the input string to extract the integers. 2. Group the integers based on the specified `threshold`. 3. Return the groups in a list of lists, maintaining the order of appearance. # Example Given: - Input string: `\\"1 2 3 10 11 20 21 22 23\\"` - `threshold = 2` Your function should create groups based on proximity (`threshold`), and return: ```python [[1, 2, 3], [10, 11], [20, 21, 22, 23]] ``` # Function Signature ```python def group_numbers(input_string: str, threshold: int) -> list: # Implement the logic to group numbers pass # Example usage groups = group_numbers(\\"1 2 3 10 11 20 21 22 23\\", threshold=2) print(groups) ```","solution":"def group_numbers(input_string: str, threshold: int) -> list: Groups numbers based on the given threshold. :param input_string: A string of space-separated integers. :param threshold: An integer defining the maximum distance between integers in the same group. :return: A list of lists where each inner list contains grouped integers. numbers = list(map(int, input_string.split())) if not numbers: return [] groups = [[numbers[0]]] for num in numbers[1:]: if num - groups[-1][-1] <= threshold: groups[-1].append(num) else: groups.append([num]) return groups"},{"question":"# Coding Question: Implement a Function to Reverse Words in a Sentence Context You are working on a text-processing application where one of the tasks is to reverse the words in a given sentence. This is commonly required in scenarios like text manipulation, format conversions, and other string processing operations. Task Write a function `reverse_words(sentence: str) -> str` that takes a string `sentence` as input and returns a new string where the order of the words is reversed. Words are defined as sequences of non-space characters, and words in the input string are separated by one or more spaces. Your function should handle multiple spaces between words and remove leading or trailing spaces. Expected Input and Output * **Input**: A single string parameter `sentence`. * **Output**: A string with words in reversed order. Constraints 1. The function should return an empty string if the input is empty or contains only spaces. 2. The function should raise a `TypeError` if the input is not a string. 3. The function should remove any leading and trailing spaces and handle multiple spaces between words by collapsing them into a single space. Examples ```python >>> reverse_words(\\"Hello world\\") \'world Hello\' >>> reverse_words(\\" The quick brown fox \\") \'fox brown quick The\' >>> reverse_words(\\" \\") \'\' >>> reverse_words(\\"a b c d\\") \'d c b a\' >>> reverse_words(\\"Python is awesome\\") \'awesome is Python\' >>> reverse_words(12345) Traceback (most recent call last): ... TypeError: Input must be a string >>> reverse_words(\\"\\") \'\' ``` - **Empty String Example**: `reverse_words(\\"\\")` should return `\'\'`. - **Whitespace Only Example**: `reverse_words(\\" \\")` should return `\'\'`. - **Multiple Spaces Example**: `reverse_words(\\"The quick brown fox\\")` should return `\'fox brown quick The\'`. # Edge Cases and Performance Expectations Consider and handle edge cases such as: * Strings with leading, trailing, or multiple spaces between words. * Empty strings or strings containing only whitespace. * Non-string input values. Your solution should account for these scenarios and operate efficiently, with a time complexity of O(n), where n is the length of the input string.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. # Validate input if not isinstance(sentence, str): raise TypeError(\\"Input must be a string\\") # Trim leading and trailing spaces and split the sentence into words words = sentence.strip().split() # Reverse the list of words and join them with a single space reversed_words = \' \'.join(reversed(words)) return reversed_words"},{"question":"# Programming Question: Palindrome Integer Finder **Context**: Optimizing integer-based algorithms is a common task in software development, often related to data analysis, cryptography, or mathematical computations. **Problem Statement**: Write a function `next_palindrome(n: int) -> int` that finds the smallest palindrome greater than a given integer `n`. A palindrome is a number that reads the same forward and backward, such as `121` or `1331`. This function could be useful in cases where palindromic structures are of interest, such as in certain hashing functions or digital-based puzzles. **Function Signature**: ```python def next_palindrome(n: int) -> int: pass ``` **Input**: * A single integer `n` where `1 <= n <= 10^9`. **Output**: * An integer representing the smallest palindrome number that is strictly greater than `n`. **Constraints**: * The input integer `n` will always be a positive integer within the specified range. * Ensure the function efficiently handles the upper constraint. **Examples**: ```python next_palindrome(123) # Output: 131 next_palindrome(999) # Output: 1001 next_palindrome(12321) # Output: 12421 ``` **Notes**: * Consider edge cases such as when `n` itself is a palindrome. * An efficient algorithm is important for handling values close to the upper limit of the constraint.","solution":"def next_palindrome(n: int) -> int: def is_palindrome(x: int) -> bool: s = str(x) return s == s[::-1] candidate = n + 1 while not is_palindrome(candidate): candidate += 1 return candidate"},{"question":"# Directory Tree Traversal Problem Statement: Implement a Python function that traverses a directory tree and returns a nested dictionary representing the structure of the directories and files. Each key in the dictionary represents a directory name, where the value is another dictionary (sub-directory) or a list of file names within that directory. Function Specification: * **Function Name**: `directory_tree` * **Input**: A single string `root_dir` - the root directory path to start traversal. * **Output**: A dictionary representing the directory tree structure. Constraints: 1. The input `root_dir` can be an absolute or relative path. 2. Your implementation should handle potential exceptions such as permission errors or nonexistent directories gracefully. 3. The function should only include files and directories accessible with the current user\'s permissions. Example: Suppose the directory structure starting from \\"root_dir\\" is as follows: ``` root_dir/ folder1/ file1.txt file2.txt folder2/ subfolder1/ file3.txt file4.txt file5.txt ``` The function call `directory_tree(\\"root_dir\\")` should return: ```python { \\"root_dir\\": { \\"folder1\\": [\\"file1.txt\\", \\"file2.txt\\"], \\"folder2\\": { \\"subfolder1\\": [\\"file3.txt\\"], \\"file4.txt\\": [] }, \\"file5.txt\\": [] } } ``` (Note: Each file name is mapped to an empty list for consistency.) Ensure that your function passes the following assertions: ```python assert directory_tree(\\"sample_root\\") == { \\"sample_root\\": { \\"dir1\\": [\\"file_a.txt\\", \\"file_b.txt\\"], \\"dir2\\": { \\"subdir1\\": [\\"file_c.txt\\"], \\"file_d.txt\\": [] }, \\"file_e.txt\\": [] } } ``` Considerations: 1. Use appropriate libraries and functions like `os.walk`, `os.path`, `os.listdir` to navigate through directories. 2. Handle edge cases, such as empty directories, symbolic links, and deeply nested directories. 3. Pay attention to avoid infinite loops with cyclic links in the file system. # Notes: 1. You are allowed to use standard libraries such as `os` and `sys`. 2. Ensure the output structure is a dictionary with proper nested form, clearly representing the directory hierarchy.","solution":"import os def directory_tree(root_dir): Traverses a directory tree and returns a nested dictionary representing the structure of the directories and files. Parameters: root_dir (str): The root directory path to start traversal. Returns: dict: A dictionary representing the directory tree structure. tree = {} def traverse_dir(dir_path): dir_dict = {} try: with os.scandir(dir_path) as it: for entry in it: if entry.is_file(): dir_dict.setdefault(entry.name, []) elif entry.is_dir(): dir_dict[entry.name] = traverse_dir(entry.path) except PermissionError: pass # ignore directories that cannot be accessed return dir_dict base_name = os.path.basename(root_dir) if not base_name: base_name = root_dir # in case of root directory tree[base_name] = traverse_dir(root_dir) return tree"},{"question":"# Problem Statement You are given an array of n distinct integers. Your task is to determine if there exists a subset of these integers that sums to zero. Write a function, `find_zero_sum_subset(arr)`, that returns `True` if such a subset exists and `False` otherwise. # Requirements: 1. Implement a function named `find_zero_sum_subset` that takes a list of integers, `arr`, and returns a boolean value. 2. If the array includes zero, the function should return `True`. 3. The solution should efficiently handle the case of larger arrays. # Input Format: 1. A list of distinct integers `arr`, where the length of `arr` is `n` and `1 <= n <= 100`. # Output Format: 1. A boolean indicating whether there is a subset of `arr` with a sum of zero. # Constraints: 1. The elements in the array are distinct. 2. 1 <= n <= 100 3. Each element in the array is an integer such that -10^5 <= arr[i] <= 10^5 # Example: ```python >>> find_zero_sum_subset([4, -1, -2, 1]) True >>> find_zero_sum_subset([1, 2, 3, 4, 5]) False >>> find_zero_sum_subset([-1, 1, 2, -2, 3]) True >>> find_zero_sum_subset([1]) False ``` Note: * Pay attention to the efficiency of your solution. A brute-force solution might not be suitable for the upper constraint limits. * Your solution will be tested against various cases to ensure its correctness and performance.","solution":"def find_zero_sum_subset(arr): Returns True if there exists a subset of arr that sums to zero, otherwise False. n = len(arr) # Edge case for single element if n == 1: return arr[0] == 0 # Using Set to store all possible sums of subsets subset_sums = set() # Traverse each element in the array for num in arr: # If the current number is zero, we have a subset with zero sum if num == 0: return True # Create a new set to keep track of new sums generated by including the current number new_sums = set() for s in subset_sums: new_sum = s + num if new_sum == 0: return True new_sums.add(new_sum) # Add the current number itself to the subset sums subset_sums.add(num) # Add the new sums generated to the main subset sums set subset_sums.update(new_sums) return False"},{"question":"# Coding Assessment Question: Background Pascal\'s Triangle is a triangular array of the binomial coefficients. The entry in the nth row and kth column represents the number of ways to choose k elements from a set of n elements, and is denoted as C(n, k). Task Implement a function `pascal_triangle_row(n)` that generates the nth row of Pascal\'s Triangle. - **Input**: A single integer `n` (0 ≤ n ≤ 25). - **Output**: A list of integers representing the nth row of Pascal\'s Triangle. - **Constraints**: The input should be a non-negative integer. Raise an appropriate error if the input is negative or not an integer. - **Performance**: Ensure the implementation handles the upper limits of the input size efficiently. Function Signature ```python def pascal_triangle_row(n: int) -> list: pass ``` Examples ```python assert pascal_triangle_row(0) == [1] assert pascal_triangle_row(1) == [1, 1] assert pascal_triangle_row(4) == [1, 4, 6, 4, 1] assert pascal_triangle_row(6) == [1, 6, 15, 20, 15, 6, 1] ``` Additional Notes - You may assume the valid input will always be less than or equal to 25. - Raise a `ValueError` for negative integers and a `TypeError` for non-integer inputs. - Aim to leverage mathematical properties of binomial coefficients for an efficient solution, avoiding excessive computation wherever possible. **Helper Formula (for reference)**: The value of C(n, k) can be computed as `C(n, k) = n! / (k! * (n - k)!)`. But it\'s often more efficient to use the recursive property: `C(n, k) = C(n-1, k-1) + C(n-1, k)`, with initial conditions `C(n, 0) = C(n, n) = 1`.","solution":"from math import comb def pascal_triangle_row(n: int) -> list: Returns the nth row of Pascal\'s Triangle. Args: n (int): The row index (0 ≤ n ≤ 25). Returns: list: The nth row of Pascal\'s Triangle. Raises: ValueError: If n is not a non-negative integer. TypeError: If n is not an integer. if not isinstance(n, int): raise TypeError(\\"The input must be an integer.\\") if n < 0: raise ValueError(\\"The input must be a non-negative integer.\\") return [comb(n, k) for k in range(n + 1)]"},{"question":"# Coding Assessment Question Scenario You are tasked with developing an application that performs user authentication through a set of rules. A user\'s login attempt is evaluated based on their username and password. Your job is to write a function to validate a set of users\' login attempts based on predefined constraints and rules. Task Implement a function `validate_logins` that, given a list of users and their login attempts, validates each attempt against a set of rules and returns a list of results. Function Signature ```python def validate_logins(users: List[Tuple[str, str]], logins: List[Tuple[str, str]]) -> List[bool]: ``` Input * `users (List[Tuple[str, str]])`: A list of tuples where each tuple contains a username and its corresponding password. * `logins (List[Tuple[str, str]])`: A list of tuples where each tuple contains a username and a password attempt. Output * Returns a list of booleans where each entry corresponds to whether the login attempt is valid (`True`) or invalid (`False`). Constraints * Each username and password is a non-empty string consisting of alphanumeric characters. * No duplicate usernames are present in the users list. * The number of users and logins will not exceed 10^4. Example ```python You have the following users: [(\\"alice\\", \\"password123\\"), (\\"bob\\", \\"qwerty\\"), (\\"carol\\", \\"abcABC123\\")] And the following login attempts: [(\\"alice\\", \\"password123\\"), (\\"bob\\", \\"wrongpassword\\"), (\\"carol\\", \\"abcABC123\\"), (\\"dave\\", \\"noPassword\\")] The function should return the results as follows: [True, False, True, False] users = [(\\"alice\\", \\"password123\\"), (\\"bob\\", \\"qwerty\\"), (\\"carol\\", \\"abcABC123\\")] logins = [(\\"alice\\", \\"password123\\"), (\\"bob\\", \\"wrongpassword\\"), (\\"carol\\", \\"abcABC123\\"), (\\"dave\\", \\"noPassword\\")] results = validate_logins(users, logins) print(results) # Output should be [True, False, True, False] ``` Notes * Focus on efficiently querying user credentials. * Ensure that the solution handles different cases of valid and invalid login attempts gracefully. * Aim for a solution with optimal time complexity, considering the constraints provided.","solution":"from typing import List, Tuple def validate_logins(users: List[Tuple[str, str]], logins: List[Tuple[str, str]]) -> List[bool]: user_dict = {username: password for username, password in users} results = [] for username, password_attempt in logins: if username in user_dict and user_dict[username] == password_attempt: results.append(True) else: results.append(False) return results"},{"question":"# Quick Sort Challenge Context You are given a list of integers that must be sorted in ascending order. You need to implement the Quick Sort algorithm to complete this task. Quick Sort is another efficient and commonly used sorting algorithm that uses the divide-and-conquer strategy to sort elements. Task Write a Python function `quick_sort(collection: list) -> list` that takes a list of integers and returns a new list sorted in ascending order using the Quick Sort algorithm. Your implementation should recursively partition the list around a pivot element and sort the partitions. Function Signature ```python def quick_sort(collection: list) -> list: pass ``` Input and Output * **Input**: A list of integers, `collection`, where each integer can be negative, positive, or zero. The list may contain duplicate values and can be of any length, including zero. * **Output**: A new list sorted in ascending order. Constraints * Each integer in the list will be in the range -10^6 to 10^6. * The length of the list will not exceed 10^4. Examples ```python assert quick_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5] assert quick_sort([]) == [] assert quick_sort([-2, -5, -45]) == [-45, -5, -2] ``` Performance Requirements Your implementation should have an average time complexity of O(n log n) and worst-case time complexity of O(n^2). The space complexity should be O(log n) due to recursive stack space. Additional Notes * Consider using median-of-three partitioning or random pivot selection to improve average case performance and avoid worst-case scenarios. * Edge cases include empty lists and lists with negative numbers or duplicates.","solution":"def quick_sort(collection): Sorts a list using the Quick Sort algorithm. :param collection: list of integers :return: sorted list of integers if len(collection) < 2: return collection pivot = collection[len(collection) // 2] left = [x for x in collection if x < pivot] middle = [x for x in collection if x == pivot] right = [x for x in collection if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Question You are given a string containing digits from 2 to 9 inclusive. Your task is to return all possible letter combinations that the number could represent using the mapping on a traditional T9 mobile keypad (as shown below). Use recursive backtracking to generate the combinations. # Function Signature ```python def letter_combinations(digits: str) -> list[str]: ``` # Input - `digits`: a string of digits from 2 to 9 (inclusive). # Output - A list containing all possible letter combinations. The combinations can be returned in any order. # Constraints - The length of `digits` will be within the range 0 to 4. - Digits \'0\' and \'1\' will not be included. # Examples ```python >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] ``` # Explanation - In the first example, the digit \'2\' maps to [\\"a\\", \\"b\\", \\"c\\"] and \'3\' maps to [\\"d\\", \\"e\\", \\"f\\"], so the function returns all combinations of these letters. - If the input is an empty string, the function returns an empty list. - For a single digit, the function returns the corresponding letters. T9 Mobile Keypad Mapping: ``` 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" ``` Implement your function in Python: ```python def letter_combinations(digits: str) -> list[str]: # Your code here # ```","solution":"def letter_combinations(digits: str) -> list[str]: # T9 Mobile Keypad Mapping phone_map = { \'2\': \\"abc\\", \'3\': \\"def\\", \'4\': \\"ghi\\", \'5\': \\"jkl\\", \'6\': \\"mno\\", \'7\': \\"pqrs\\", \'8\': \\"tuv\\", \'9\': \\"wxyz\\" } # If the input digits string is empty, return an empty list if not digits: return [] # Helper function to generate combinations using backtracking def backtrack(index, path): # If the path length is equal to the digits length, we have found a valid combination if len(path) == len(digits): combinations.append(\\"\\".join(path)) return # Get the letters corresponding to the current digit possible_letters = phone_map[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() # List to hold the combinations combinations = [] # Start backtracking from index 0 and an empty path backtrack(0, []) return combinations"},{"question":"# Pascal\'s Triangle Row Calculation **Scenario**: You are developing a module that involves combinatorial mathematics, specifically to generate rows from Pascal\'s Triangle, which has applications in algebra and probability. Your task is to create a function that computes the `n\'th` row of Pascal\'s Triangle. **Task**: Implement the following function to generate the required row from Pascal\'s Triangle: ```python def pascals_triangle_row(n): Computes the nth row of Pascal\'s Triangle. Parameters: n : int The row index in Pascal\'s Triangle to compute. Returns: list : A list of integers representing the nth row of Pascal\'s Triangle. Raises: ValueError : If an invalid type for n is provided or if n is negative. pass ``` **Input and Output Formats**: - `n`: A non-negative integer representing the row index in Pascal’s Triangle. **Constraints**: 1. `n` must be a non-negative integer. **Performance Requirements**: Your solution should use an efficient approach to compute the `n\'th` row (time complexity O(n), space complexity O(n)). **Examples**: ```python assert pascals_triangle_row(0) == [1] assert pascals_triangle_row(1) == [1, 1] assert pascals_triangle_row(2) == [1, 2, 1] assert pascals_triangle_row(3) == [1, 3, 3, 1] assert pascals_triangle_row(4) == [1, 4, 6, 4, 1] assert pascals_triangle_row(5) == [1, 5, 10, 10, 5, 1] ``` **Note**: Ensure to handle invalid inputs by raising appropriate errors. The function should return a precise list of integers representing the desired row.","solution":"def pascals_triangle_row(n): Computes the nth row of Pascal\'s Triangle. Parameters: n : int The row index in Pascal\'s Triangle to compute. Returns: list : A list of integers representing the nth row of Pascal\'s Triangle. Raises: ValueError : If an invalid type for n is provided or if n is negative. if not isinstance(n, int) or n < 0: raise ValueError(\\"The input should be a non-negative integer.\\") row = [1] for k in range(1, n + 1): row.append(row[-1] * (n - k + 1) // k) return row"},{"question":"# Working with Custom Graphs You are provided with a directed graph data structure where each node has a list of adjacent nodes. There is no limit on the number of nodes or the number of edges. Your task is to enhance this graph data structure to include the following functionalities: 1. **Detect Cycles**: Add a method `has_cycle() -> bool` that checks if the graph contains any cycles. 2. **Find Shortest Path**: Add a method `shortest_path(start: int, end: int) -> List[int]` that returns the shortest path in terms of the number of edges between two nodes (start and end). If there are multiple paths with the same length, return any one of them. If no path exists, return an empty list. Input and Output Formats * **Input**: * For the `has_cycle` method: No input parameters. * For the `shortest_path` method: * `start` and `end`: integers representing the starting and ending nodes for which the shortest path is to be found. * **Output**: * For the `has_cycle` method: A boolean indicating the presence of a cycle. * For the `shortest_path` method: A list of integers representing the nodes in the shortest path from `start` to `end`. Constraints * The graph can have up to `10^5` nodes and `10^6` edges. * Node values are integers from `0` to `n-1`, where `n` is the number of nodes. * Assume the graph is represented using an adjacency list format. Performance Requirements * Ensure that cycle detection and path finding are efficient, ideally leveraging algorithms with linear or near-linear complexity with respect to the number of nodes and edges. # Example ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } custom_graph = CustomGraph(graph) print(custom_graph.has_cycle()) # Output: True print(custom_graph.shortest_path(1, 3)) # Output: [1, 2, 3] or any other shortest path ``` # Implementation Enhance the provided `CustomGraph` class by implementing the `has_cycle` and `shortest_path` methods as described.","solution":"from collections import deque class CustomGraph: def __init__(self, graph): self.graph = graph def has_cycle(self): def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in self.graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False visited = {node: False for node in self.graph} rec_stack = {node: False for node in self.graph} for node in self.graph: if not visited[node]: if dfs(node, visited, rec_stack): return True return False def shortest_path(self, start, end): if start == end: return [start] visited = {node: False for node in self.graph} prev = {node: None for node in self.graph} queue = deque([start]) visited[start] = True while queue: current = queue.popleft() for neighbor in self.graph.get(current, []): if not visited[neighbor]: queue.append(neighbor) visited[neighbor] = True prev[neighbor] = current if neighbor == end: break path = [] at = end while at is not None: path.insert(0, at) at = prev[at] if path and path[0] == start: return path else: return []"},{"question":"**Context**: Searching for elements in a collection is a common need in various applications, and efficient searching algorithms can drastically improve performance. The Binary Search algorithm is a powerful approach for finding elements in a sorted list with logarithmic time complexity. # Problem Statement Implement a modified version of the Binary Search algorithm to find the position of a target element in a sorted list of integers. Additionally, extend the algorithm to return the count of occurrences of the target element if it appears multiple times in the list. # Requirements * **Function Name**: `binary_search_count` * **Input**: - A sorted list of integers `collection` - An integer `target` * **Output**: A tuple containing the position (zero-based index) of the `target` element and the count of its occurrences. If the target is not found, return -1 for the position and 0 for the count. # Constraints - The list `collection` will be sorted in ascending order. - The function should have a logarithmic time complexity, O(log n), for the search part. # Example ```python def binary_search_count(collection: list, target: int) -> tuple: # Your code here # Examples: print(binary_search_count([1, 2, 2, 3, 3, 3, 4, 5], 3)) # Output: (3, 3) # 3 is found at index 3 and appears 3 times print(binary_search_count([1, 2, 2, 3, 3, 3, 4, 5], 2)) # Output: (1, 2) # 2 is found at index 1 and appears 2 times print(binary_search_count([1, 2, 2, 3, 3, 3, 4, 5], 6)) # Output: (-1, 0) # 6 is not found ``` # Special Considerations - Handle the case where the list is empty. - Ensure that the function correctly identifies the first occurrence of the target element and counts all of its occurrences in an efficient manner. - Avoid unnecessary iterations through the list. # Testing Create a series of unit tests to validate your function under different scenarios, including edge cases where the list is empty, the target element is at the beginning or end of the list, and when the target element has multiple occurrences.","solution":"def binary_search_count(collection: list, target: int) -> tuple: def find_first_position(collection, target): low, high = 0, len(collection) - 1 first_pos = -1 while low <= high: mid = (low + high) // 2 if collection[mid] == target: first_pos = mid high = mid - 1 # keep searching on the left side elif collection[mid] < target: low = mid + 1 else: high = mid - 1 return first_pos def find_last_position(collection, target): low, high = 0, len(collection) - 1 last_pos = -1 while low <= high: mid = (low + high) // 2 if collection[mid] == target: last_pos = mid low = mid + 1 # keep searching on the right side elif collection[mid] < target: low = mid + 1 else: high = mid - 1 return last_pos first_position = find_first_position(collection, target) if first_position == -1: return -1, 0 # target not found last_position = find_last_position(collection, target) count = last_position - first_position + 1 return first_position, count"},{"question":"# Problem Statement A critical operation in network security is to identify any potential breaches by scanning log files for certain patterns. Suppose we are given a structured log file in the form of a list of strings, where each string represents a log entry. We need to determine if any sequence of log entries contains sensitive information that matches a predefined set of patterns. # Function Signature ```python def detect_patterns(logs: list[str], patterns: list[str]) -> list[list[int]]: pass ``` # Input - `logs`: A list of strings where each string represents a log entry. - `patterns`: A list of strings where each string represents a sensitive pattern that we need to detect in the logs. # Output - Returns a list of lists, where each inner list contains the 0-based indices of log entries that match a specific pattern. The order of inner lists should correspond to the order of patterns provided as input. # Constraints 1. The number of log entries will be between 1 and 10^5. 2. Each log entry will have a length between 1 and 1000 characters. 3. The number of patterns will be between 1 and 1000. 4. Each pattern will have a length between 1 and 1000 characters. 5. A pattern needs to be completely matched within a log entry for it to be considered a match. # Examples ```python assert detect_patterns([\\"user login\\", \\"error 404\\", \\"access granted\\", \\"password reset\\"], [\\"login\\", \\"error\\", \\"password\\"]) == [[0], [1], [3]] assert detect_patterns([\\"file opened\\", \\"connection lost\\", \\"user logout\\", \\"access denied\\"], [\\"access\\", \\"lost\\"]) == [[3], [1]] ``` # Explanation 1. For the first example: - The pattern \\"login\\" matches the log entry at index 0 (\\"user login\\"). - The pattern \\"error\\" matches the log entry at index 1 (\\"error 404\\"). - The pattern \\"password\\" matches the log entry at index 3 (\\"password reset\\"). 2. For the second example: - The pattern \\"access\\" matches the log entry at index 3 (\\"access denied\\"). - The pattern \\"lost\\" matches the log entry at index 1 (\\"connection lost\\"). Implement the function to efficiently detect the given patterns within the log entries, bearing in mind the constraints provided.","solution":"def detect_patterns(logs, patterns): This function takes a list of log entries and a list of patterns, and returns a list of lists with indices where each pattern is found in the logs. result = [] # Iterate over each pattern for pattern in patterns: pattern_indices = [] # Iterate over each log entry for index, log in enumerate(logs): # If pattern is found in the log entry, save the index if pattern in log: pattern_indices.append(index) result.append(pattern_indices) return result"},{"question":"# Problem Statement Write a function that calculates the sum of each row in a given NxN matrix of integers, and returns a list of these sums sorted in descending order. # Input A single NxN list of lists (matrix) of integers. # Output A list of integers, representing the sums of each row in descending order. # Constraints 1. The matrix will always have NxN dimensions where 1 ≤ N ≤ 100. 2. Each element in the matrix is an integer between -1000 and 1000 (inclusive). # Requirements 1. The function should handle edge cases such as the smallest and largest possible matrix sizes. 2. The solution should be optimized for performance within the given constraints. 3. Provide complete and well-documented code. # Example Consider the following example NxN grid: ``` [ [3, 5, 1], [0, -2, 7], [-1, 4, 2] ] ``` The sums of each row are as follows: Row 1: 3 + 5 + 1 = 9 Row 2: 0 - 2 + 7 = 5 Row 3: -1 + 4 + 2 = 5 The function should return the list `[9, 5, 5]`. # Function Signature ```python def row_sums_descending(matrix: List[List[int]]) -> List[int]: # Add your implementation here ``` # Implementation Implement the `row_sums_descending` function and ensure that it correctly calculates and returns the sums of each row in descending order for the provided example and other test cases that meet the constraints.","solution":"from typing import List def row_sums_descending(matrix: List[List[int]]) -> List[int]: Given an NxN matrix of integers, return a list of the sums of each row sorted in descending order. Args: matrix (List[List[int]]): An NxN matrix of integers. Returns: List[int]: A list of integers representing the sums of each row in descending order. row_sums = [sum(row) for row in matrix] row_sums.sort(reverse=True) return row_sums"},{"question":"# Task Description You are given a singly linked list represented by the `ListNode` class. Implement a function `remove_duplicates(head: ListNode | None) -> ListNode | None` that removes all duplicate numbers from a sorted linked list such that each element appears only once. # Function Signature ```python def remove_duplicates(head: ListNode | None) -> ListNode | None: ``` # ListNode Class Definition ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Input - **head**: The head node of the singly linked list (ListNode | None). If the head is None, return None. # Output - The head node of the modified linked list with duplicates removed. # Constraints - The linked list is sorted in non-decreasing order. - You may assume the list has at most `10^4` nodes. # Example Given the sorted linked list constructed as follows: ``` 1 -> 1 -> 2 -> 3 -> 3 ``` The `remove_duplicates` function should return the modified linked list: ``` 1 -> 2 -> 3 ``` # Notes - You must solve the problem without using any extra space (in-place). - Maintain the sorted order of the linked list. - Ensure your solution handles edge cases, such as empty lists or lists with only one node. # Implementation Implement the function `remove_duplicates` in Python. The function should efficiently remove duplicates and maintain the sorted order of the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode | None) -> ListNode | None: if not head: return None current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head"},{"question":"# Array Rotation You are given an array and a number `d`. Your task is to rotate the array to the left by `d` positions. Function Signature ```python def left_rotate_array(arr: list, d: int) -> list: Args: - arr (list): A list of integers. - d (int): The number of positions to rotate the array to the left. Returns: - list: The array after being rotated to the left by `d` positions. ``` Input * `arr` : A list of integers, representing the array to be rotated. * 1 ≤ len(arr) ≤ 1000 * -10^5 ≤ arr[i] ≤ 10^5 * `d` (int): The number of positions to rotate the array to the left. * 0 ≤ d < len(arr) Output * A list of integers representing the array after being rotated to the left by `d` positions. Example ```python >>> left_rotate_array([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> left_rotate_array([10, 20, 30, 40, 50, 60], 4) [50, 60, 10, 20, 30, 40] >>> left_rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> left_rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] ``` # Expectations 1. **Correctness**: Your solution should correctly rotate the array as specified by the number of positions `d` for various input combinations. 2. **Efficiency**: The solution should handle the upper limits of the input size efficiently without significant performance degradation. 3. **Edge Cases**: Ensure to handle edge cases such as `d` being zero, or `d` equaling the length of the array, and arrays with only one element. Implement your function `left_rotate_array` based on the above specifications. You can test your solution with the provided examples.","solution":"def left_rotate_array(arr, d): Rotates the array arr to the left by d positions. Args: - arr (list): A list of integers. - d (int): The number of positions to rotate the array to the left. Returns: - list: The array after being rotated to the left by d positions. n = len(arr) d = d % n # In case d is greater than len(arr) return arr[d:] + arr[:d]"},{"question":"Context You are tasked with developing a feature for a ride-sharing application that optimizes the allocation of cars to passengers, minimizing the total waiting time for all passengers. This is a typical example of the Linear Assignment Problem, where the goal is to minimize the cost of assigning passengers to available cars. To solve this problem, you can use the Hungarian Algorithm, which guarantees finding the optimal assignment in polynomial time. Task Your goal is to implement a function called `optimal_assignment` using the principles of the Hungarian Algorithm. The function should return the optimal assignment of passengers to cars and the total minimized waiting time. Function Signature ```python def optimal_assignment(waiting_times: list[list[int]]) -> tuple[list[int], int]: ``` Input - `waiting_times`: A 2D list where each element represents the waiting time for a passenger (row index) if assigned to a specific car (column index). The matrix is square, i.e., the number of passengers is equal to the number of cars. Output - A tuple containing: - A list of integers representing the assignments where the ith index is the car assigned to the ith passenger. - An integer representing the total minimized waiting time. Constraints - The number of passengers and cars ( n ) with ( 1 leq n leq 50 ). - Waiting times will be integers ranging from 0 to 1000. Example ```python waiting_times = [ [4, 2, 5, 1], [2, 3, 4, 2], [3, 5, 1, 3], [6, 4, 2, 1] ] optimal_assignment(waiting_times) # Output ([3, 0, 1, 2], 6) # Example output, actual result may vary ``` Notes - Consider using helper functions for intermediate steps like row and column reduction, finding and covering zeros, and adjusting the matrix based on step results. - While implementing the Hungarian Algorithm, be sure to handle edge cases such as no assignments possible (e.g., empty matrix). Good luck with minimizing the waiting time and ensuring a pleasant experience for your users!","solution":"from scipy.optimize import linear_sum_assignment def optimal_assignment(waiting_times: list[list[int]]) -> tuple[list[int], int]: Given a 2D list of waiting times, returns the optimal assignment of passengers to cars minimizing the total waiting time. :param waiting_times: list of lists of waiting times :return: A tuple containing the optimal assignment list and the total minimized waiting time # Use linear_sum_assignment from scipy to solve the assignment problem row_ind, col_ind = linear_sum_assignment(waiting_times) # Calculate the total minimized waiting time total_waiting_time = sum(waiting_times[row][col] for row, col in zip(row_ind, col_ind)) return list(col_ind), total_waiting_time"},{"question":"# Graph Traversal Path Finder Scenario You are building a navigation system that can find all possible paths between two nodes in a directed graph. The system should return all unique paths from the start node to the end node. Problem Statement Implement a function, `find_all_paths(graph: dict, start: str, end: str) -> list[list[str]]`, that: 1. Takes a directed graph represented as an adjacency list. 2. Finds all unique paths from the `start` node to the `end` node. 3. Returns a list of paths, where each path is represented as a list of nodes (strings). Input - `graph`: A dictionary representing the directed graph, where keys are node names (strings) and values are lists of adjacent node names (strings). - `start`: The starting node (string). - `end`: The ending node (string). Output - A list of all unique paths from the `start` node to the `end` node. Each path is a list of nodes (strings) in the order they are visited. Constraints - All node names in the graph consist of lowercase English letters. - The graph contains no cycles. - The length of each path does not exceed 100 nodes. - The number of unique paths can be very large, so efficiency matters. - Consider using Depth-First Search (DFS) for finding paths. Example ```python graph = { \\"a\\": [\\"b\\", \\"c\\"], \\"b\\": [\\"c\\", \\"d\\"], \\"c\\": [\\"d\\"], \\"d\\": [] } start = \\"a\\" end = \\"d\\" # Expected output: [[\'a\', \'b\', \'d\'], [\'a\', \'c\', \'d\'], [\'a\', \'b\', \'c\', \'d\']] print(find_all_paths(graph, start, end)) ``` Additional Notes - Ensure your function correctly handles cases where no paths exist by returning an empty list in such scenarios. - Your solution should avoid revisiting nodes within a single path to ensure path uniqueness.","solution":"def find_all_paths(graph, start, end): Finds all unique paths from the start node to the end node in a directed graph. Parameters: graph (dict): The graph represented as an adjacency list. start (str): The starting node. end (str): The ending node. Returns: list[list[str]]: A list of all unique paths from start to end. def dfs(current_node, end, path, paths): path.append(current_node) if current_node == end: paths.append(path.copy()) else: for neighbor in graph.get(current_node, []): if neighbor not in path: dfs(neighbor, end, path, paths) path.pop() paths = [] dfs(start, end, [], paths) return paths"},{"question":"Scenario: As part of a project focusing on data normalization, you are required to write a function that normalizes a given sentence by removing duplicate words, preserving only their first occurrence, and maintaining the original word order. Task: Implement the function `normalize_sentence` that takes a single string input and returns a normalized version of the sentence. For this task, words are defined as sequences of characters separated by spaces. Implementation: 1. Define the function `normalize_sentence(sentence: str) -> str`. 2. Ensure the function handles the following: * Case insensitivity when identifying duplicate words. * Preserves the case of words in the final output. * The order of the first occurrence of each word should be maintained. 3. Input validation to ensure the input is a string. 4. Optimize for performance. Input: * A single string `sentence`. Output: * A string representing the normalized sentence without duplicate words, maintaining the original order. Constraints: * The input length does not exceed 10^6 characters. * Words are separated by spaces and do not contain punctuation or special characters. Examples: ```python >>> normalize_sentence(\\"This is a test This is only a test\\") \\"This is a test only\\" >>> normalize_sentence(\\"Repeat repeat words here repeat\\") \\"Repeat words here\\" >>> normalize_sentence(\\"\\") \\"\\" >>> normalize_sentence(\\"One two one TWO\\") \\"One two\\" >>> normalize_sentence(\\"unique words are unique\\") \\"unique words are\\" ``` Performance Requirements: The function should run efficiently with a linear time complexity with respect to the input sentence\'s length, ensuring it can handle large inputs up to 10^6 characters.","solution":"def normalize_sentence(sentence: str) -> str: Normalizes a given sentence by removing duplicate words, preserving only their first occurrence, and maintaining the original word order. if not isinstance(sentence, str): raise ValueError(\\"Input must be a string\\") seen = set() result = [] words = sentence.split() for word in words: lower_word = word.lower() if lower_word not in seen: seen.add(lower_word) result.append(word) return \' \'.join(result)"},{"question":"# Scenario You are developing a ridesharing application, and an important feature is to match drivers with the nearest rider requests. To facilitate this, you need to compute the minimum distance a driver has to travel to reach a rider. Given a series of rider and driver locations on a 2D grid, determine the best match for each driver based on the shortest Euclidean distance. # Task Implement a function `closest_rider` that assigns each driver to their closest rider. The function should return the indexes of the riders assigned to the drivers. # Function Signature ```python def closest_rider(drivers: List[Tuple[int, int]], riders: List[Tuple[int, int]]) -> List[int]: ``` # Input * `drivers`: A list of tuples where each tuple contains two integers representing the coordinates (x, y) of a driver. * `riders`: A list of tuples where each tuple contains two integers representing the coordinates (x, y) of a rider. # Output * A list of integers where the i-th integer is the index of the rider that is assigned to the i-th driver. Each rider can only be assigned to one driver and each driver can only be assigned to one rider. # Constraints * The number of drivers (`d`) and riders (`r`) are such that 1 ≤ d, r ≤ 100. * The coordinates for drivers and riders are within the range -10000 ≤ x, y ≤ 10000. # Example ```python drivers = [(0, 0), (1, 2), (2, 1)] riders = [(2, 3), (0, 1), (1, 1)] closest_rider(drivers, riders) # Output: [1, 2, 0] # Explanation: # Driver at (0, 0) is closest to rider at (0, 1) -> Index 1 # Driver at (1, 2) is closest to rider at (1, 1) -> Index 2 # Driver at (2, 1) is closest to rider at (2, 3) -> Index 0 ``` # Hints * Consider using a sorting-based approach or a priority queue to manage and compare distances efficiently. * Ensure that each driver and rider pairing is unique and optimal in terms of distance.","solution":"from typing import List, Tuple import math def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def closest_rider(drivers: List[Tuple[int, int]], riders: List[Tuple[int, int]]) -> List[int]: closest = [-1] * len(drivers) rider_taken = [False] * len(riders) for i, driver in enumerate(drivers): min_distance = float(\'inf\') min_index = -1 for j, rider in enumerate(riders): if not rider_taken[j]: distance = euclidean_distance(driver, rider) if distance < min_distance: min_distance = distance min_index = j closest[i] = min_index rider_taken[min_index] = True return closest"},{"question":"# Reverse Words in a Sentence Write a function `reverse_words(sentence: str) -> str` that takes a string as input, where the string contains multiple words separated by spaces. The function should reverse the order of the words in the string. Words are defined as contiguous sequences of non-space characters. Input * A string `sentence` consisting of words separated by single spaces (length ≤ 10^5). Output * A string with the words in reversed order, separated by a single space. Constraints * The input string will contain only printable ASCII characters and spaces. * There will be no leading or trailing spaces. * The words in the string are separated by exactly one space. Example ```python assert reverse_words(\\"hello world\\") == \\"world hello\\" assert reverse_words(\\"open the door\\") == \\"door the open\\" assert reverse_words(\\"good morning\\") == \\"morning good\\" assert reverse_words(\\"wow\\") == \\"wow\\" ``` # Context You are developing a text manipulation feature useful in applications such as chatbots, where reversing the order of words in a sentence can serve specific conversational or stylistic purposes. # Notes Consider edge cases such as: * A single-word string. * Empty strings. * Sentences with different numbers of words. Ensure your solution handles large inputs efficiently within the given constraints.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in the input string `sentence`. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Problem Statement You are a software developer tasked with improving the functionality of a financial application. The application currently processes transactions but lacks a feature to summarize account activities. Your task is to write a function that generates an account summary from a list of transactions. You need to implement a function `account_summary` that takes a list of transactions and returns a dictionary summarizing the account activities. Each transaction is defined by its type (either \\"deposit\\" or \\"withdrawal\\") and the amount. # Function Signature ```python from typing import List, Dict Transaction = namedtuple(\\"Transaction\\", \\"type amount\\") def account_summary(transactions: List[Transaction]) -> Dict[str, float]: ... ``` # Input * `transactions` - A list of `Transaction` namedtuples, where each `Transaction` has: * `type (str)`: The type of the transaction. It is either \\"deposit\\" or \\"withdrawal\\". * `amount (float)`: The amount of the transaction. It will always be a non-negative value. # Output * A dictionary with two entries: * `\\"total_deposits\\"`: The sum of all deposit amounts. * `\\"total_withdrawals\\"`: The sum of all withdrawal amounts. # Constraints 1. `transactions` can be empty, in which case the function should return `{\\"total_deposits\\": 0.0, \\"total_withdrawals\\": 0.0}`. 2. The `type` field in each transaction must be either \\"deposit\\" or \\"withdrawal\\". If a transaction contains an invalid type, raise a `ValueError` with the message `\\"Invalid transaction type\\"`. # Examples ```python >>> account_summary([ ... Transaction(\\"deposit\\", 100.0), ... Transaction(\\"withdrawal\\", 50.0), ... Transaction(\\"deposit\\", 200.0) ... ]) {\'total_deposits\': 300.0, \'total_withdrawals\': 50.0} >>> account_summary([ ... Transaction(\\"deposit\\", 150.0), ... Transaction(\\"deposit\\", 250.0) ... ]) {\'total_deposits\': 400.0, \'total_withdrawals\': 0.0} >>> account_summary([ ... Transaction(\\"deposit\\", 100.0), ... Transaction(\\"withdrawal\\", 150.0), ... Transaction(\\"deposit\\", 200.0), ... Transaction(\\"withdrawal\\", 50.0) ... ]) {\'total_deposits\': 300.0, \'total_withdrawals\': 200.0} >>> account_summary([ ... Transaction(\\"withdrawal\\", 50.0), ... Transaction(\\"withdrawal\\", 50.0) ... ]) {\'total_deposits\': 0.0, \'total_withdrawals\': 100.0} >>> account_summary([ ... Transaction(\\"withdrawal\\", 50.0), ... Transaction(\\"spend\\", 100.0), ... ]) Traceback (most recent call last): ... ValueError: Invalid transaction type ``` # Notes 1. Ensure your function handles both valid and invalid types of transactions, raising errors as needed. 2. Optimize the function to run efficiently in O(n) time complexity where n is the number of transactions.","solution":"from typing import List, Dict, NamedTuple class Transaction(NamedTuple): type: str amount: float def account_summary(transactions: List[Transaction]) -> Dict[str, float]: summary = {\\"total_deposits\\": 0.0, \\"total_withdrawals\\": 0.0} for transaction in transactions: if transaction.type == \\"deposit\\": summary[\\"total_deposits\\"] += transaction.amount elif transaction.type == \\"withdrawal\\": summary[\\"total_withdrawals\\"] += transaction.amount else: raise ValueError(\\"Invalid transaction type\\") return summary"},{"question":"# Question: String Compression Algorithm with Error Handling Implement a string compression algorithm where consecutive duplicate characters are reduced to the character followed by the number of times it appears consecutively. For example, \\"aaabbc\\" becomes \\"a3b2c1\\". Additionally, implement a corresponding decompression algorithm that reverses this process. Both functions should include error handling for invalid inputs. Implement two functions: 1. **`compress(text: str) -> str`** 2. **`decompress(text: str) -> str`** Details: 1. **`compress` Function**: - **Input**: - `text`: a string containing the data to be compressed. - **Output**: - A compressed version of the input string. - **Constraints**: - Handle cases where `text` might be an empty string. - Ensure that non-string inputs result in an appropriate error message. - **Example**: ```python >>> compress(\\"aaabbc\\") \'a3b2c1\' ``` 2. **`decompress` Function**: - **Input**: - `text`: a string representing the compressed data. - **Output**: - The original string before compression. - **Constraints**: - Ensure the input follows the correct format for decompression (character followed by number). - Handle strings that might be empty. - Ensure non-string inputs or incorrect formats result in an appropriate error message. - **Example**: ```python >>> decompress(\\"a3b2c1\\") \'aaabbc\' ``` **Additional Requirements**: - Include appropriate error handling for invalid inputs (e.g., non-integer counts in compressed format). - Ensure the functions are well-documented with clear and concise comments where necessary.","solution":"def compress(text): Compresses a string by reducing consecutive duplicate characters to the character followed by the count of its appearances. Parameters: text (str): The string to be compressed. Returns: str: The compressed string. if not isinstance(text, str): return \\"Error: Input must be a string.\\" if not text: return \\"\\" compressed = [] count = 1 prev_char = text[0] for char in text[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) return \'\'.join(compressed) def decompress(text): Decompresses a string by expanding characters followed by counts to their original repeated form. Parameters: text (str): The string to be decompressed. Returns: str: The decompressed string. if not isinstance(text, str): return \\"Error: Input must be a string.\\" if not text: return \\"\\" decompressed = [] i = 0 length = len(text) while i < length: if not text[i].isalpha(): return \\"Error: Invalid compressed format.\\" char = text[i] i += 1 count_str = \\"\\" while i < length and text[i].isdigit(): count_str += text[i] i += 1 if not count_str: return \\"Error: Invalid compressed format.\\" count = int(count_str) decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Coding Challenge: You have been tasked with developing a function that can identify and count all pairs of elements in an input list that add up to a specified target sum. The function should be optimized to handle large datasets efficiently and should return a list of tuples representing the pairs. # Objective: Write a function `find_pairs_with_sum` that: 1. Takes a list of integers and a target sum as input. 2. Returns a list of tuples, where each tuple contains a pair of elements from the input list that add up to the target sum. Expected Input and Output: * **Input**: * A list of integers. * An integer representing the target sum. * **Output**: * A list of tuples, with each tuple containing two integers from the input list whose sum equals the target sum. Performance Requirements: * The function should handle large inputs efficiently, ideally with a time complexity of O(n) and a space complexity of O(n). Constraints and Considerations: * Consider edge cases such as empty lists or lists containing a single element. * Ensure the function returns unique pairs only, where the order of elements in the tuple does not matter (i.e., (a, b) and (b, a) should be considered the same). * Ensure the function handles duplicates in the input list correctly by including all valid unique pairs. * Use robust checking mechanisms to handle invalid inputs such as non-integer elements in the list. # Example: ```python def find_pairs_with_sum(numbers: list, target_sum: int) -> list: pass print(find_pairs_with_sum([1, 2, 3, 4, 3, 5], 6)) # Expected output: [(1, 5), (2, 4), (3, 3)] print(find_pairs_with_sum([1, 1, 2, 45, 46, 46], 47)) # Expected output: [(1, 46), (2, 45)] print(find_pairs_with_sum([], 5)) # Expected output: [] print(find_pairs_with_sum([5, 5, 5], 10)) # Expected output: [(5, 5)] ``` # Note: * Provide a detailed explanation of your algorithm and implementation choices. * Describe any assumptions made in the process of developing the function.","solution":"def find_pairs_with_sum(numbers, target_sum): Returns a list of tuples where each tuple contains a pair of elements from the input list that add up to the target sum. seen_numbers = {} pairs = set() for number in numbers: complement = target_sum - number if complement in seen_numbers: pairs.add((min(number, complement), max(number, complement))) seen_numbers[number] = True return list(pairs)"},{"question":"**Array Shuffler** You are tasked with implementing a function `shuffle_array(arr: List[int]) -> List[int]` that takes a list of integers and returns a new list where the elements are shuffled randomly. # Input specifications: - `arr` (0 ≤ len(arr) ≤ 10^5): A list of integers which can be empty or contain up to 100,000 elements. # Output specifications: - Returns a new list of integers containing the same elements as `arr` but in a randomly shuffled order. # Requirements: - The use of built-in or external libraries for shuffling (such as `random.shuffle`) is prohibited. - Ensure that your implementation handles large lists efficiently. - The function should produce truly random shuffles, meaning repeated runs of the function should yield different orderings. # Example Usage: ```python # Example Input and Output arr = [1, 2, 3, 4, 5] shuffled_arr = shuffle_array(arr) print(shuffled_arr) # Output: Possible outcomes: [3, 5, 1, 4, 2], [1, 4, 5, 3, 2], etc. (Note that the exact output will vary each time.) arr = [] shuffled_arr = shuffle_array(arr) print(shuffled_arr) # Output: [] arr = [1] shuffled_arr = shuffle_array(arr) print(shuffled_arr) # Output: [1] ``` Write your implementation ensuring that you effectively randomize the elements of the array while maintaining the optimal time and space complexity.","solution":"import random def shuffle_array(arr): Randomly shuffles the elements of the given list and returns a new list. Args: arr (List[int]): The list of integers to shuffle. Returns: List[int]: A new list with the elements of arr shuffled. n = len(arr) shuffled_arr = arr[:] for i in range(n): j = random.randint(i, n-1) shuffled_arr[i], shuffled_arr[j] = shuffled_arr[j], shuffled_arr[i] return shuffled_arr"},{"question":"# Question: Balancing Parentheses in Mathematical Expressions **Context**: Parentheses are used to indicate the order of operations in mathematical expressions. Given an expression string consisting of numbers, operators (`+`, `-`, `*`, `/`), and parentheses, it may be necessary to determine if the parentheses are balanced correctly. **Task**: Write a function `are_parentheses_balanced` that checks whether the parentheses in a given mathematical expression are balanced. **Function Signature**: ```python def are_parentheses_balanced(expr: str) -> bool: ``` **Input**: - `expr` (string): the mathematical expression to check, containing numbers, operators (+, -, *, /), and parentheses. Constraints: `1 <= len(expr) <= 1000`. **Output**: - Returns a boolean value `True` if the parentheses are balanced, `False` otherwise. **Example**: ```python assert are_parentheses_balanced(\\"3 + (2 * (9 / 3))\\") == True assert are_parentheses_balanced(\\"((3 + 2)) * (4 / (7 - 2)\\") == False assert are_parentheses_balanced(\\"12 / (3 + 2)) - (5\\") == False assert are_parentheses_balanced(\\"((1 + 2) * 3)\\") == True ``` **Explanation**: For example, for `expr = \\"3 + (2 * (9 / 3))\\"`, all the opening parentheses `(` have corresponding closing parentheses `)`, hence the function returns `True`. For `expr = \\"((3 + 2)) * (4 / (7 - 2)\\"`, there is an unmatched opening parenthesis `(`, hence the function returns `False`. **Solution Approach**: - Use a stack data structure to keep track of opening parentheses. - Loop through the characters of the expression. - For every opening parenthesis `(` encountered, push it onto the stack. - For every closing parenthesis `)` encountered, check if there\'s a corresponding opening parenthesis on the stack. If not, the expression is unbalanced. - Finally, ensure the stack is empty. If not, there are unmatched opening parentheses.","solution":"def are_parentheses_balanced(expr: str) -> bool: Returns True if the parentheses in the given expression are balanced, False otherwise. stack = [] for char in expr: if char == \'(\': stack.append(char) elif char == \')\': if not stack: # If stack is empty, no matching opening parenthesis return False stack.pop() # Remove the matching opening parenthesis return not stack # If stack is empty, all parentheses were matched"},{"question":"Coding Assessment Question **Question: Optimized Pathfinding with A* Algorithm** You are tasked with implementing a pathfinding function using the A* algorithm, a popular and efficient algorithm for finding the shortest path between nodes in a weighted graph. Your function should be optimized to handle large graphs and provide accurate paths with minimal computational overhead. # Function Signature ```python def a_star_search(graph: Dict[str, Dict[str, int]], start: str, goal: str) -> List[str]: pass ``` # Input * A weighted directed graph represented as a dictionary, where keys are node identifiers (strings) and values are dictionaries with neighbor nodes as keys and edge weights as values. * Two strings `start` and `goal` representing the starting and ending nodes. * Constraints: * All edge weights are positive integers. * The graph can contain up to ( 10^5 ) nodes and ( 10^6 ) edges. * The starting and goal nodes are guaranteed to be present in the graph. # Output * A list of node identifiers representing the path from the start node to the goal node in the shortest manner. * If no path exists, return an empty list. # Requirements * Your implementation should: * Efficiently handle large graphs. * Use a heuristic to optimize the search. * Ensure the shortest path is found (if it exists). * Minimize the number of expanded nodes. # Example ```python graph = { \\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"D\\": 1}, \\"D\\": {} } assert a_star_search(graph, \\"A\\", \\"D\\") == [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] assert a_star_search(graph, \\"A\\", \\"C\\") == [\\"A\\", \\"B\\", \\"C\\"] assert a_star_search(graph, \\"A\\", \\"A\\") == [\\"A\\"] assert a_star_search(graph, \\"A\\", \\"E\\") == [] ``` # Explanation * Your task is to develop the function `a_star_search` to find the shortest path in the input graph from `start` to `goal` using the A* algorithm. * The A* algorithm should leverage both the actual cost to reach a node and a heuristic estimate of the remaining cost to optimize the search. * Ensure that your implementation deals with large graph sizes efficiently, considering both the computational time and memory overhead. * Handle edge cases, such as when no path exists between the given nodes.","solution":"import heapq def heuristic(node: str, goal: str) -> int: Heuristic function used by A* algorithm. Here, we assume a uniform edge cost. return 0 # As we do not have specific heuristic information, using 0 as a placeholder. def a_star_search(graph: dict, start: str, goal: str) -> list: A* pathfinding algorithm to find the shortest path in a weighted graph. open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {node: float(\'inf\') for node in graph} g_score[start] = 0 f_score = {node: float(\'inf\') for node in graph} f_score[start] = heuristic(start, goal) while open_set: _, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for neighbor, weight in graph[current].items(): tentative_g_score = g_score[current] + weight if tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return [] # No path found"},{"question":"# Context: You are developing a text-based application that requires an efficient way to track the frequency of words in a document. Writing a function to count the occurrences of each word will help you analyze and process text data effectively. Words are defined as contiguous sequences of letters and numbers. The function should handle different punctuation and case variations consistently. # Problem Statement: Write a function `word_count(text: str) -> dict` that takes a string as input and returns a dictionary where the keys are words (converted to lowercase) and the values are the counts of those words in the input text. Punctuation should be ignored, and words should be case-insensitive. Input and Output Formats: * **Input**: A single argument `text` which is a string containing the text to be analyzed. * **Output**: A dictionary with words as keys and their respective counts as values. Constraints and Limitations: * The input text can contain any standard ASCII characters, including punctuation and whitespace. * The input text can be of any length. * Words are case-insensitive and should be treated as the same irrespective of their case in the input text. Example: ```python >>> word_count(\'Hello, hello! How are you? Are you doing fine?\') {\'hello\': 2, \'how\': 1, \'are\': 2, \'you\': 2, \'doing\': 1, \'fine\': 1} >>> word_count(\'This is a test. This test is only a test.\') {\'this\': 2, \'is\': 2, \'a\': 2, \'test\': 3, \'only\': 1} >>> word_count(\'123 apples. 123 oranges. Apples and oranges.\') {\'123\': 2, \'apples\': 2, \'oranges\': 2, \'and\': 1} ``` # Performance Requirements: * The solution should ideally run in O(n) time complexity, where n is the length of the input text.","solution":"import re from collections import defaultdict def word_count(text: str) -> dict: Takes a string as input and returns a dictionary where the keys are words (converted to lowercase) and the values are the counts of those words in the input text. Punctuation is ignored, and words are case-insensitive. text = text.lower() # Convert text to lowercase words = re.findall(r\'bw+b\', text) # Extract words, ignoring punctuation count = defaultdict(int) # Dictionary to count words for word in words: count[word] += 1 return dict(count)"},{"question":"# Scenario You are developing a web application that allows users to manage their to-do lists. The application should support functionality to add, delete, and list to-dos. Your task is to implement a utility that processes a list of commands to manipulate a basic to-do list, and then write unit tests for this utility. # Task 1. Implement a class `ToDoList` with methods to add, delete, and list to-dos. 2. Write unit tests for your class to ensure it behaves correctly for a range of inputs. # Requirements **Class and Method Signatures**: ```python class ToDoList: def __init__(self): # Your implementation here def add(self, item: str) -> None: # Your implementation here def delete(self, index: int) -> None: # Your implementation here def list(self) -> list: # Your implementation here ``` # Example ```python # Example of usage todo_list = ToDoList() todo_list.add(\\"Buy milk\\") todo_list.add(\\"Walk the dog\\") print(todo_list.list()) # Expected output: [\\"Buy milk\\", \\"Walk the dog\\"] todo_list.delete(0) print(todo_list.list()) # Expected output: [\\"Walk the dog\\"] ``` # Constraints - The `add` method should append a new to-do item to the list. - The `delete` method should remove the to-do item at the specified index. - The `list` method should return the current list of to-do items. - Raise an appropriate exception if an invalid index is provided in the `delete` method. # Testing - Use a testing framework such as `unittest` or `pytest` to write unit tests for the `ToDoList` class. - Ensure the tests cover adding items, deleting items, listing items, and handling invalid deletions. # Additional Information - Consider edge cases, such as deleting from an empty list or deleting using an out-of-range index. - Use assertions to verify that the list state is maintained correctly across multiple operations.","solution":"class ToDoList: def __init__(self): self._todos = [] def add(self, item: str) -> None: self._todos.append(item) def delete(self, index: int) -> None: if index < 0 or index >= len(self._todos): raise IndexError(\\"Invalid index\\") self._todos.pop(index) def list(self) -> list: return self._todos"},{"question":"# Coding Assessment Question In data analysis and scientific computing, matrix operations play a vital role in performing fast computations. One such operation is the matrix multiplication which is ubiquitous in various algorithms, including machine learning and image processing. Write a function `batch_matrix_multiplication` that performs matrix multiplication on a batch of input matrices and a single matrix. The function should be optimized to handle large batches of matrices efficiently. **Function Signature**: ```python def batch_matrix_multiplication(batch_matrices, single_matrix): pass ``` # Input and Output - **Input**: - `batch_matrices` - A 3D NumPy array of shape (N, M, K) representing N matrices of size MxK. - `single_matrix` - A 2D NumPy array of shape (K, P) representing a single matrix for multiplication. - **Output**: - Returns a 3D NumPy array of shape (N, M, P) representing the result of each matrix in the batch multiplied by the single matrix. # Constraints - The dimensions of the matrices will conform to the rules of matrix multiplication (i.e., the number of columns in each matrix in `batch_matrices` will be equal to the number of rows in `single_matrix`). - The size of N, M, K, and P will be such that the operation should complete within a reasonable time for practical computation purposes. # Requirements & Performance - The function should make use of efficient matrix operations and should leverage NumPy\'s optimized functions for handling large-scale matrix multiplications. - Ensure the function scales well with the number of matrices in the batch. # Example ```python import numpy as np batch_matrices = np.array([ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ]) single_matrix = np.array([ [1, 0], [0, 1] ]) out = batch_matrix_multiplication(batch_matrices, single_matrix) print(out) # Expected Output: # [[[1, 2], # [3, 4]], # [[5, 6], # [7, 8]]] single_matrix2 = np.array([ [1, 2], [3, 4] ]) out2 = batch_matrix_multiplication(batch_matrices, single_matrix2) print(out2) # Expected Output: # [[[ 7, 10], # [15, 22]], # [[23, 34], # [31, 46]]] ``` Make sure to handle edge cases where the input dimensions might cause issues and optimize for performance using efficient matrix multiplication techniques.","solution":"import numpy as np def batch_matrix_multiplication(batch_matrices, single_matrix): Multiplies each matrix in a batch with a single matrix. Parameters: - batch_matrices: A 3D NumPy array of shape (N, M, K) - single_matrix: A 2D NumPy array of shape (K, P) Returns: - A 3D NumPy array of shape (N, M, P) return np.matmul(batch_matrices, single_matrix)"},{"question":"# Evaluate Nested List Depth You are given a potentially nested list of integers. Write a function that determines the depth of nesting within the list. The depth of a non-nested list is `1`. If a list contains another list as an element, the depth increases by `1` for each level of nesting. # Task 1. Define a function `find_list_depth` that calculates the depth of a nested list. # Function Specifications 1. **Function**: `find_list_depth` * Input: nested list of integers `lst` * Output: integer representing the maximum depth of nesting within the list # Input and Output Formats * **Input**: * `lst`: A list which can contain integers or other lists. * **Output**: * Returns an integer representing the maximum depth of nesting of the input list. # Constraints * The nested list may contain integers or other lists, which themselves may contain integers or more lists. * Empty lists should be considered as having depth `1`. # Example ```python print(find_list_depth([1, 2, [3, 4], 5])) # Expected output: 2 print(find_list_depth([1, [2, [3, [4, 5]]]])) # Expected output: 4 print(find_list_depth([1, 2, 3])) # Expected output: 1 print(find_list_depth([[[[]]]])) # Expected output: 4 ``` # Notes - Use recursion to traverse the nested lists. - Ensure to validate inputs and handle cases where lists are empty or contain no nesting. Implement the `find_list_depth` function to check the depth of various levels of nested lists.","solution":"def find_list_depth(lst): Determines the depth of nesting within the list. :param lst: Nested list of integers and other lists :return: Integer representing the maximum depth of the list if not isinstance(lst, list): return 0 if not lst: return 1 else: return 1 + max(find_list_depth(x) for x in lst)"},{"question":"# Problem Statement You are given a list of strings. Your task is to group the anagrams together. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. # Input Format * A list of strings ( S ) where ( S ) can range from ( 0 ) to ( 10^4 ) strings, and each string\'s length can be up to 100 characters. # Output Format * A list of lists, where each sublist contains anagrams grouped together. # Constraints * All strings consist of lowercase English letters. # Example ```python For an input list [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"], the output should be [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]]. ``` # Instructions 1. The order of the groups and the order of strings within each group does not need to match the example. 2. Optimize for both time and space complexity. # Solution Template Here is a starting template for your solution: ```python from collections import defaultdict def group_anagrams(strings): anagram_dict = defaultdict(list) for string in strings: sorted_string = \'\'.join(sorted(string)) anagram_dict[sorted_string].append(string) return list(anagram_dict.values()) if __name__ == \\"__main__\\": user_input = input(\\"Enter strings separated by spaces:n\\").strip() string_list = user_input.split() grouped_anagrams = group_anagrams(string_list) for group in grouped_anagrams: print(group) ``` In your implementation, ensure that you handle all edge cases effectively and test the function against a variety of input scenarios before finalizing your code.","solution":"from collections import defaultdict def group_anagrams(strings): Groups anagrams from the input list of strings. Parameters: - strings (list of str): List of input strings to be grouped as anagrams. Returns: - list of list of str: List of lists, each containing grouped anagrams. anagram_dict = defaultdict(list) for string in strings: sorted_string = \'\'.join(sorted(string)) anagram_dict[sorted_string].append(string) return list(anagram_dict.values())"},{"question":"# Problem Statement: Maximum Product of Two Elements in an Array In this problem, you are required to write a function that finds the maximum product of two distinct elements in an array of integers. The product should be calculated after subtracting 1 from each selected element. Function Signature ```python def max_product(nums: list) -> int: Given a list of integers `nums`, return the maximum product of two distinct elements in the array after subtracting 1 from each element. Parameters: nums (list): A list of integers. Returns: int: The maximum product of two distinct elements after subtracting 1 from each. pass ``` Examples ```python max_product([3, 4, 5, 2]) # Output: 12 (Max product is from 4*3 after subtracting 1 from 5 and 4) max_product([1, 5, 4, 5]) # Output: 16 (Max product is from 4*4 after subtracting 1 from both 5s) max_product([3, 7]) # Output: 12 (Max product is from 6*2 after subtracting 1 from 7 and 3) max_product([10, 2, 5, 2]) # Output: 36 (Max product is from 9*4 after subtracting 1 from 10 and 5) ``` Constraints * The input list `nums` will contain at least two elements. * All elements in the list `nums` are integers within the range [1, 1000]. Notes * Ensure that the same element is not used twice in the product calculation unless it appears more than once in the input list. * Optimize for efficient time and space complexity, ideally O(n) time and O(1) space.","solution":"def max_product(nums: list) -> int: Given a list of integers `nums`, return the maximum product of two distinct elements in the array after subtracting 1 from each element. Parameters: nums (list): A list of integers. Returns: int: The maximum product of two distinct elements after subtracting 1 from each. first, second = 0, 0 for num in nums: if num > first: second = first first = num elif num > second: second = num return (first - 1) * (second - 1)"},{"question":"# Problem Statement **Budget Travel Planner** You are given a list of cities and the cost of travel between each pair of cities. Your task is to devise a budget-friendly plan that suggests the minimum cost required to travel between a given pair of cities, ensuring that the total travel cost is as low as possible. # Task Write a function `find_min_cost_route(cities: List[str], travel_costs: List[Tuple[str, str, int]], start: str, end: str) -> int` that determines the minimum cost to travel from the city `start` to the city `end`. # Input Format - `cities`: A list of strings where each string represents a city. - `travel_costs`: A list of tuples where each tuple contains two strings representing a pair of cities and an integer representing the travel cost between these cities. - `start`: A string representing the starting city. - `end`: A string representing the destination city. # Output Format - An integer representing the minimum travel cost from the `start` city to the `end` city. If there is no possible route, return `-1`. # Constraints - (2 leq text{len(cities)} leq 1000) - The length of each city name will not exceed 100 characters. - Each cost in `travel_costs` will be a non-negative integer and will not exceed (10^6). # Performance Requirements - The solution must efficiently handle up to 1000 cities and a large number of travel costs. # Example *Example 1:* Input: ```python cities = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] travel_costs = [(\\"A\\", \\"B\\", 100), (\\"B\\", \\"C\\", 200), (\\"A\\", \\"D\\", 300), (\\"D\\", \\"C\\", 100)] start = \\"A\\" end = \\"C\\" ``` Output: ``` 300 ``` *Example 2:* Input: ```python cities = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] travel_costs = [(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 10), (\\"A\\", \\"D\\", 1), (\\"D\\", \\"C\\", 100)] start = \\"A\\" end = \\"C\\" ``` Output: ``` 15 ``` # Notes - Ensure the function accounts for all edges and potential isolated cities where no travel is possible. - Dijkstra\'s algorithm or any other efficient shortest path algorithm can be used. Implement the function `find_min_cost_route` as specified: ```python from typing import List, Tuple def find_min_cost_route(cities: List[str], travel_costs: List[Tuple[str, str, int]], start: str, end: str) -> int: # Your implementation here ```","solution":"from typing import List, Tuple import heapq def find_min_cost_route(cities: List[str], travel_costs: List[Tuple[str, str, int]], start: str, end: str) -> int: # Create a dictionary to store the graph graph = {city: [] for city in cities} # Fill the graph with travel costs for city1, city2, cost in travel_costs: graph[city1].append((city2, cost)) graph[city2].append((city1, cost)) # Min-heap to keep track of the minimum cost to reach each city heap = [(0, start)] # Distances dictionary to keep track of the minimum cost to reach each city distances = {city: float(\'inf\') for city in cities} distances[start] = 0 while heap: current_cost, current_city = heapq.heappop(heap) # If we reach the end city, return the cost if current_city == end: return current_cost for neighbor, cost in graph[current_city]: new_cost = current_cost + cost # If a cheaper cost is found, update the heap and distances if new_cost < distances[neighbor]: distances[neighbor] = new_cost heapq.heappush(heap, (new_cost, neighbor)) # If the end city is not reachable, return -1 return -1 if distances[end] == float(\'inf\') else distances[end]"},{"question":"# Question: Sort and Remove Duplicates Implement a function `sort_and_deduplicate` that takes a list of integers, removes any duplicates, and returns the remaining integers in ascending order. Function Signature ```python def sort_and_deduplicate(sequence: list) -> list: ``` Input - `sequence`: A list of integers that may contain duplicates. Output - A list of integers sorted in ascending order, with all duplicate elements removed. Constraints - The input list can have up to 10^4 elements. - Each element in the list can be any integer value (including negative integers). Examples ```python print(sort_and_deduplicate([4, 5, 1, 2, 1, 4])) # Output: [1, 2, 4, 5] print(sort_and_deduplicate([10, 10, 10, 5, 4])) # Output: [4, 5, 10] print(sort_and_deduplicate([])) # Output: [] ``` **Note**: Ensure your function handles edge cases, such as when the list is empty.","solution":"def sort_and_deduplicate(sequence): Takes a list of integers, removes duplicates, and returns the sorted list. return sorted(set(sequence))"},{"question":"# Shortest Path in Weighted Graph Using Dijkstra\'s Algorithm As a programmer, you are tasked with finding the shortest path from a given source node to all other nodes in a weighted graph using Dijkstra\'s algorithm. # Task Write a function `dijkstra_shortest_path` that takes two parameters: 1. `num_nodes` (an integer): The number of vertices in the graph. 2. `edges` (a list of tuples): Each tuple contains three integers (u, v, weight), representing an edge from vertex u to vertex v with the specified weight. The function should return a dictionary where the keys are the vertices and the values are the shortest distance from the source node (node 0) to that vertex. If a vertex is unreachable from the source node, its distance should be `-1`. Constraints * 1 ≤ num_nodes ≤ 1000 * 1 ≤ number of edges ≤ 10^5 * 1 ≤ weight of each edge ≤ 10^4 * The input graph can be disconnected. Function Signature ```python def dijkstra_shortest_path(num_nodes: int, edges: list[tuple[int, int, int]]) -> dict[int, int]: ``` # Example ```python edges = [ (0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 1), (2, 3, 5), (3, 4, 3) ] expected_output = {0: 0, 1: 3, 2: 1, 3: 4, 4: 7} assert dijkstra_shortest_path(5, edges) == expected_output edges = [ (0, 1, 2), (1, 2, 4), (2, 0, 7), (3, 4, 1) # disconnected component ] expected_output = {0: 0, 1: 2, 2: 6, 3: -1, 4: -1} assert dijkstra_shortest_path(5, edges) == expected_output ``` # Performance Requirements * Ensure the function executes within O(E log V) time complexity. # Notes * Handle multiple disconnected components by using `-1` for unreachable vertices. * Use a priority queue (min-heap) to efficiently implement Dijkstra\'s algorithm. * Consider edge cases where the number of nodes is very small or very large.","solution":"import heapq import sys from typing import List, Tuple, Dict def dijkstra_shortest_path(num_nodes: int, edges: List[Tuple[int, int, int]]) -> Dict[int, int]: # Create adjacency list graph = {i: [] for i in range(num_nodes)} for u, v, weight in edges: graph[u].append((v, weight)) graph[v].append((u, weight)) # For undirected graph; remove if directed # Distance dictionary to store the shortest distance from the source to each vertex distances = {i: sys.maxsize for i in range(num_nodes)} distances[0] = 0 # Starting node # Priority queue to store the vertices for exploring priority_queue = [(0, 0)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # Visiting each neighbor for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Replace maxsize distances with -1 to indicate node is unreachable for vertex in distances: if distances[vertex] == sys.maxsize: distances[vertex] = -1 return distances"},{"question":"Problem Statement You are given a text file containing several pairs of positive integers. Each line in the file represents one pair, with the integers separated by a space. Your task is to write a function that reads the file and, for each pair, determines if the two integers are coprime (i.e., their greatest common divisor is 1). The function should return the total count of coprime pairs. # Input - A single string `filepath` representing the path to the text file. # Output - An integer representing the number of coprime pairs found in the file. # Constraints - Each integer in a pair is between 1 and 1000 inclusive. - The text file contains at most 1000 pairs. # Example Consider the following pairs in the file: - Pair A: 14 25 - Pair B: 18 27 - Pair C: 35 64 The function `count_coprime_pairs(\'pairs.txt\')` should return `2`, since the pairs (14, 25) and (35, 64) are coprime, but (18, 27) is not. # Guidance To determine if two numbers are coprime, use the Euclidean algorithm to compute the greatest common divisor (GCD). Implement the following helper function: 1. `is_coprime(a: int, b: int) -> bool`: Returns `True` if `a` and `b` are coprime, `False` otherwise. # Sample Function Definition ```python def count_coprime_pairs(filepath: str) -> int: # Your code here ``` # Note Ensure your solution reads the input file correctly and handles any edge cases appropriately.","solution":"import math def is_coprime(a: int, b: int) -> bool: Determines if two numbers are coprime. return math.gcd(a, b) == 1 def count_coprime_pairs(filepath: str) -> int: Reads a file containing pairs of integers and counts how many pairs are coprime. coprime_count = 0 with open(filepath, \'r\') as file: for line in file: a, b = map(int, line.split()) if is_coprime(a, b): coprime_count += 1 return coprime_count"},{"question":"# Coding Task: Implement a Trie Data Structure Scenario You are asked to implement a Trie (pronounced as \\"try\\"), which is a data structure that is used to store a dynamic set of strings. You must support insertion of words and checking whether a given word or prefix exists in the Trie. This structure is especially useful in applications such as autocomplete or spellchecker. Task Implement a class `Trie` in Python with the following methods: 1. `insert(word: str) -> None`: Inserts a word into the Trie. 2. `search(word: str) -> bool`: Returns true if the word is in the Trie. 3. `starts_with(prefix: str) -> bool`: Returns true if there is any word in the Trie that starts with the given prefix. Class Signature ```python class Trie: def __init__(self): Initialize your data structure here. pass def insert(self, word: str) -> None: Inserts a word into the Trie. Args: - word (str): The word to be inserted into the Trie. pass def search(self, word: str) -> bool: Returns if the word is in the Trie. Args: - word (str): The word to search in the Trie. Returns: - bool: True if the word is found, False otherwise. pass def starts_with(self, prefix: str) -> bool: Returns if there is any word in the Trie that starts with the given prefix. Args: - prefix (str): The prefix to search in the Trie. Returns: - bool: True if there exists any word with the given prefix, False otherwise. pass ``` # Input * Words and prefixes consist of lowercase English letters (`a-z`). * The `insert` method will be called at most `3 * 10^4` times. * The `search` and `starts_with` methods will be called at most `3 * 10^4` times. # Output * The `search` method returns a boolean indicating if the word is in the Trie. * The `starts_with` method returns a boolean indicating if there is any word in the Trie that starts with the given prefix. # Example ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Expected output: True print(trie.search(\\"app\\")) # Expected output: False print(trie.starts_with(\\"app\\"))# Expected output: True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Expected output: True ``` # Notes 1. The implementation should be efficient in terms of both time and space complexity. 2. Consider optimizing the Trie operations to handle the upper limits of input sizes effectively. 3. Make sure to handle edge cases gracefully, such as inserting or searching for empty strings.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize your data structure here. self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the Trie. Args: - word (str): The word to be inserted into the Trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Returns if the word is in the Trie. Args: - word (str): The word to search in the Trie. Returns: - bool: True if the word is found, False otherwise. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: Returns if there is any word in the Trie that starts with the given prefix. Args: - prefix (str): The prefix to search in the Trie. Returns: - bool: True if there exists any word with the given prefix, False otherwise. node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Objective: Create a Python function to validate and calculate the ISBN-10 check digit, ensuring proper input and output handling. # Problem Statement: An ISBN-10 (International Standard Book Number) is a 10-digit code used to uniquely identify a book. The check digit is the last digit of the ISBN and is calculated based on the preceding 9 digits according to a specific formula. Your task is to implement a function that validates the input, calculates the ISBN-10 check digit, and returns the complete ISBN-10 including the check digit. # Function Signature: ```python def calculate_isbn10(isbn: str) -> str: ``` # Input: - `isbn`: a string of exactly 9 digits representing the first part of an ISBN-10 code. # Output: - A string of exactly 10 characters representing the complete ISBN-10 code, including the calculated check digit. # Constraints: - The input string must be exactly 9 digits long. - The input string must contain only numeric characters. # Examples: ```python >>> calculate_isbn10(\\"030640615\\") \'0306406152\' >>> calculate_isbn10(\\"123456789\\") \'123456789X\' >>> calculate_isbn10(\\"012345678\\") \'0123456789\' >>> calculate_isbn10(\\"abcdefgh9\\") Traceback (most recent call last): ... ValueError: ISBN should only contain numeric digits. >>> calculate_isbn10(\\"12345\\") Traceback (most recent call last): ... ValueError: ISBN length must be exactly 9 digits. ``` # Computation of the Check Digit: To calculate the ISBN-10 check digit: 1. Multiply each of the first 9 digits by its position (i.e., 1*digit1, 2*digit2, ..., 9*digit9). 2. Sum these products. 3. Compute the modulo 11 of the sum. 4. The check digit is this result. If the result is equal to 10, the check digit should be \'X\'. # Requirements: - Validate that the input is exactly 9 digits long. - Ensure the input contains only numeric characters. - Compute and append the correct check digit. - Handle invalid input by raising appropriate exceptions with informative messages.","solution":"def calculate_isbn10(isbn: str) -> str: Validates and calculates the ISBN-10 check digit, and returns the complete ISBN-10 code. :param isbn: A string of exactly 9 digits representing the first part of an ISBN-10 code. :return: A string of exactly 10 characters representing the complete ISBN-10 code. :raises ValueError: If the input is not exactly 9 digits or contains non-numeric characters. # Validate the length of the input if len(isbn) != 9: raise ValueError(\\"ISBN length must be exactly 9 digits.\\") # Validate if the input contains only numeric characters if not isbn.isdigit(): raise ValueError(\\"ISBN should only contain numeric digits.\\") # Calculate the check digit total = sum((i + 1) * int(digit) for i, digit in enumerate(isbn)) remainder = total % 11 # Determine the check digit if remainder == 10: check_digit = \'X\' else: check_digit = str(remainder) # Return the complete ISBN-10 return isbn + check_digit"},{"question":"# Scenario You are working on a weather forecasting application that involves calculating the average temperature from a large dataset. The temperatures are recorded at various timestamps, and the dataset is a list of tuples where each tuple contains a timestamp and the corresponding temperature. Your task is to implement a function that calculates the average daily temperature from this continuous data while ensuring efficiency and accuracy. # Requirements 1. **Efficient Average Temperature Calculation** - Write a function `average_daily_temperature` that calculates the average temperature for each day given a list of temperature records. - The function should return a dictionary where the keys are the dates and the values are the average temperatures for those dates. - Ensure the function efficiently handles large datasets. # Input - `temperature_records` (list of tuples): A list where each tuple contains a timestamp (string in \'YYYY-MM-DD HH:MM:SS\' format) and a temperature (float). # Output - A dictionary where: - Keys are dates in \'YYYY-MM-DD\' format. - Values are the average temperatures (float) for the corresponding dates. # Constraints - The timestamps are in the range from \'2000-01-01 00:00:00\' to \'2099-12-31 23:59:59\'. - Temperatures are within the range [-100, 100]. - The list can contain up to 10^5 records. # Function Signature ```python def average_daily_temperature(temperature_records: List[Tuple[str, float]]) -> Dict[str, float]: pass ``` # Sample Input and Output ```python >>> temperature_records = [ (\\"2023-10-01 06:00:00\\", 15.5), (\\"2023-10-01 12:00:00\\", 18.0), (\\"2023-10-01 18:00:00\\", 14.2), (\\"2023-10-02 06:00:00\\", 13.5), (\\"2023-10-02 12:00:00\\", 17.8), (\\"2023-10-03 06:00:00\\", 11.1), (\\"2023-10-03 12:00:00\\", 14.6) ] >>> average_daily_temperature(temperature_records) {\'2023-10-01\': 15.9, \'2023-10-02\': 15.65, \'2023-10-03\': 12.85} >>> temperature_records = [ (\\"2022-12-31 23:59:00\\", 0.0), (\\"2023-01-01 00:01:00\\", 1.0), (\\"2023-01-01 12:00:00\\", 5.0), (\\"2023-01-02 00:00:00\\", -2.0), (\\"2023-01-02 23:59:00\\", 3.0) ] >>> average_daily_temperature(temperature_records) {\'2022-12-31\': 0.0, \'2023-01-01\': 3.0, \'2023-01-02\': 0.5} ``` # Instructions 1. **Date Extraction**: Extract the date part from the timestamp to group temperatures by date. 2. **Handling Large Data**: Ensure the solution efficiently processes up to 10^5 records. 3. **Precision**: Use appropriate data structures to maintain precision in calculating averages.","solution":"from typing import List, Tuple, Dict from collections import defaultdict def average_daily_temperature(temperature_records: List[Tuple[str, float]]) -> Dict[str, float]: # Dictionary to store sum of temperatures and count of records for each date temp_data = defaultdict(lambda: [0.0, 0]) for timestamp, temp in temperature_records: date = timestamp.split(\' \')[0] temp_data[date][0] += temp temp_data[date][1] += 1 # Compute average temperature for each date average_temps = {date: sum_temp / count for date, (sum_temp, count) in temp_data.items()} return average_temps"},{"question":"# Coding Assessment Question Context: Dealing with strings and basic data structures, such as dictionaries, is a common task in programming. Often, these tasks involve transforming data and aggregating information in specific ways. Task: Write a function `character_frequencies(text: str) -> dict[str, int]` that calculates the frequency of each character in a given string. The function should return a dictionary where the keys are characters and the values are their respective counts in the input string. Input: * A string `text` consisting of any characters, including letters, digits, punctuation, and whitespace. Output: * A dictionary with characters as keys and their corresponding counts as values. Constraints: * The input string can be empty, in which case the function should return an empty dictionary. * All characters, including spaces and punctuation, should be counted. * The function should be case sensitive, meaning \'a\' and \'A\' should be counted separately. Performance Requirements: * Aim for an O(n) time complexity where n is the length of the string. * Space complexity should also be O(n) to store the character counts. Example: ```python def character_frequencies(text: str) -> dict[str, int]: # Your implementation here # Test cases print(character_frequencies(\\"hello world\\")) # Output: {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1} print(character_frequencies(\\"AaBbCc\\")) # Output: {\'A\': 1, \'a\': 1, \'B\': 1, \'b\': 1, \'C\': 1, \'c\': 1} print(character_frequencies(\\"\\")) # Output: {} ``` Note: * Consider edge cases such as empty strings or strings with all identical characters. * Ensure your function handles both common and edge cases efficiently and correctly.","solution":"def character_frequencies(text: str) -> dict[str, int]: Calculates the frequency of each character in the given string. Args: text (str): The input string for which character frequencies are to be calculated. Returns: dict: A dictionary where keys are characters and values are their respective counts in the input string. freq_dict = {} for char in text: if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return freq_dict"},{"question":"# Coding Assessment Question Problem Description Write a function called `merge_two_sorted_lists` that takes two sorted lists of integers and returns a single sorted list containing all the elements from both input lists. The function should merge the lists in a way that maximizes efficiency, leveraging the fact that the input lists are already sorted. Function Signature ```python def merge_two_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: pass ``` Input - `list1 (list[int])`: A list of integers sorted in ascending order. - `list2 (list[int])`: Another list of integers sorted in ascending order. Output - Returns a new list containing all the elements from `list1` and `list2`, sorted in ascending order. Constraints 1. Both input lists are already sorted in ascending order. 2. The function should maintain O(n + m) time complexity, where n and m are the lengths of `list1` and `list2`, respectively. 3. The function should not use additional sorting mechanisms like the built-in `sort` function. Example ```python >>> merge_two_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_two_sorted_lists([10, 20, 30], [5, 15, 25, 35]) [5, 10, 15, 20, 25, 30, 35] >>> merge_two_sorted_lists([-5, -3, -1], [-10, 0, 1]) [-10, -5, -3, -1, 0, 1] >>> merge_two_sorted_lists([], [1, 2, 3]) [1, 2, 3] ``` Performance Requirements - The function should handle edge cases where one or both lists are empty. - The function should merge the lists in linear time, ensuring it adheres to the O(n + m) time complexity. Edge Cases to Consider 1. Both lists are empty: `[]` and `[]` 2. One list is empty: `[]` and `[1, 2, 3]` 3. Both lists contain the same elements: `[1, 2, 3]` and `[1, 2, 3]` 4. Lists contain negative and positive integers: `[-5, -3, -1]` and `[-10, 0, 1]` 5. Lists of different lengths: `[1, 3]` and `[2, 4, 6, 8, 10]` Good luck!","solution":"def merge_two_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into a single sorted list. Parameters: list1 (list[int]): The first sorted list. list2 (list[int]): The second sorted list. Returns: list[int]: A merged and sorted list containing elements of both list1 and list2. merged_list = [] i, j = 0, 0 # Traverse both lists and append the smaller element to the merged list while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements of list1, if any while i < len(list1): merged_list.append(list1[i]) i += 1 # Append remaining elements of list2, if any while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Coding Assessment Question: Implementing the Factorial Function Iteratively Context The factorial function is a classic problem in computer science and mathematics, where it is frequently used in permutations, combinations, and many other areas. This exercise will test your understanding of iterative loops and handling of large integers. Problem Statement Write a function `factorial(n: int) -> int` that returns the factorial of a non-negative integer `n`. The factorial of a number `n` is the product of all positive integers less than or equal to `n`. Input and Output * The input will be a non-negative integer `n`. * The output should be an integer which is the factorial of `n`. Constraints * The input value `n` will be within the range of 0 to 20. * Implement the function iteratively. Edge Cases * Consider how to handle the factorial of `0`, which by definition is `1`. * Ensure the implementation handles the maximum constraints without error. Example ```python def factorial(n: int) -> int: Return the factorial of a non-negative integer n. :param n: the number :return: the factorial of n >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(10) 3628800 >>> factorial(20) 2432902008176640000 pass ``` Implement the function and ensure it passes all the provided tests.","solution":"def factorial(n: int) -> int: Return the factorial of a non-negative integer n. :param n: the number :return: the factorial of n if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Coding Assessment Question Background You are tasked with developing a system to manage inventory in a warehouse. Each item in the inventory has a unique identifier, a name, and a quantity. Operations that can be performed on the inventory include adding a new item, updating the quantity of an existing item, and removing an item from the inventory. Additionally, you should be able to retrieve information about the current state of the inventory. Objective Your task is to implement a class `Inventory` that provides the necessary methods to perform these operations. Class Signature ```python class Inventory: def __init__(self): # Initializes an empty inventory pass def add_item(self, item_id: int, item_name: str, quantity: int) -> None: # Adds a new item to the inventory pass def update_quantity(self, item_id: int, quantity: int) -> None: # Updates the quantity of an existing item pass def remove_item(self, item_id: int) -> None: # Removes an item from the inventory if it exists pass def get_inventory(self) -> dict: # Retrieves the current state of the inventory pass ``` Methods - `__init__(self)`: Initializes an empty inventory. - `add_item(self, item_id: int, item_name: str, quantity: int) -> None`: Adds a new item to the inventory. If the item already exists, its quantity should be updated. - `update_quantity(self, item_id: int, quantity: int) -> None`: Updates the quantity of an existing item. If the item does not exist, it raises a `ValueError` with the message \\"Item not found\\". - `remove_item(self, item_id: int) -> None`: Removes an item from the inventory if it exists. If the item does not exist, it raises a `ValueError` with the message \\"Item not found\\". - `get_inventory(self) -> dict`: Returns a dictionary representing the current inventory. The keys should be the item IDs, and the values should be another dictionary with `name` and `quantity` of the item. Example Usage ```python inventory = Inventory() # Add items inventory.add_item(1, \\"Laptop\\", 10) inventory.add_item(2, \\"Smartphone\\", 5) # Update quantity inventory.update_quantity(1, 15) # Remove item inventory.remove_item(2) # Get current inventory print(inventory.get_inventory()) ``` Expected output: ```python {1: {\\"name\\": \\"Laptop\\", \\"quantity\\": 15}} ``` Constraints 1. All item IDs must be unique integers. 2. The quantity must be a non-negative integer. 3. All item names must be non-empty strings. 4. The methods should handle all edge cases, including trying to update or remove items that do not exist.","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_id: int, item_name: str, quantity: int) -> None: if item_id in self.items: self.items[item_id][\'quantity\'] += quantity else: self.items[item_id] = {\\"name\\": item_name, \\"quantity\\": quantity} def update_quantity(self, item_id: int, quantity: int) -> None: if item_id not in self.items: raise ValueError(\\"Item not found\\") self.items[item_id][\'quantity\'] = quantity def remove_item(self, item_id: int) -> None: if item_id not in self.items: raise ValueError(\\"Item not found\\") del self.items[item_id] def get_inventory(self) -> dict: return self.items"},{"question":"# Binary Search Extension: Find First and Last Position of Element in Sorted Array You are given a sorted list of integers where some elements may be repeated. Your task is to implement a function `find_first_last_position` that returns the indices of the first and last occurrence of a given element in the list. If the element is not found, return `[-1, -1]`. Your implementation should use the principles of binary search to achieve an efficient solution in terms of time complexity. Input: * `numbers` (List of integers) - A sorted list of integers. * `target` (integer) - The element for which we need to find the first and last position. Output: * List of two integers representing the first and last position of the target element in the list, or `[-1, -1]` if the element is not found. Constraints: * Assume that the list is sorted in non-decreasing order. * Your solution should aim for O(log n) time complexity. Example: ```python >>> find_first_last_position([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> find_first_last_position([5, 7, 7, 8, 8, 10], 6) [-1, -1] >>> find_first_last_position([1, 2, 3, 4, 4, 4, 5], 4) [3, 5] >>> find_first_last_position([], 0) [-1, -1] ``` Guidelines: * Use binary search to find the first occurrence and then the last occurrence of the target element. * Ensure your function handles edge cases such as an empty list and lists where the target is not present. * Avoid using linear search techniques to keep within the required time complexity. Make sure your code is efficient and adheres to the outlined constraints.","solution":"def find_first_last_position(numbers, target): Returns the indices of the first and last occurrence of a given element in a sorted list of integers. If the element is not found, returns [-1, -1]. def find_first(numbers, target): left, right = 0, len(numbers) - 1 first_position = -1 while left <= right: mid = left + (right - left) // 2 if numbers[mid] == target: first_position = mid right = mid - 1 # Search in the left half elif numbers[mid] < target: left = mid + 1 else: right = mid - 1 return first_position def find_last(numbers, target): left, right = 0, len(numbers) - 1 last_position = -1 while left <= right: mid = left + (right - left) // 2 if numbers[mid] == target: last_position = mid left = mid + 1 # Search in the right half elif numbers[mid] < target: left = mid + 1 else: right = mid - 1 return last_position first_position = find_first(numbers, target) last_position = find_last(numbers, target) if first_position == -1: return [-1, -1] return [first_position, last_position]"},{"question":"# Graph Level Order Traversal You are given a `GraphNode` class, representing a node in a graph. Each node contains a value and a list of neighboring nodes. Your task is to implement a function `level_order_traversal` that performs level order traversal on the graph starting from a given node. The level order traversal should return a list of values where each sublist represents the nodes at that particular level of the graph. Function Signature ```python def level_order_traversal(start_node: GraphNode) -> list[list[int]]: Perform a level order traversal on the graph starting from `start_node`. Args: start_node (GraphNode): The starting node of the graph traversal. Returns: list[list[int]]: A list of lists, where each sublist contains the values of nodes at that level. ``` Input 1. `start_node`: An instance of `GraphNode` that represents the starting node of the graph traversal. Output - A list of lists, where each sublist contains the values of the nodes at that level. Constraints 1. The graph will have no more than 1000 nodes. 2. Each node\'s value is an integer. 3. There are no self-loops. 4. The graph may contain cycles and multiple components. # Example ```python # Graph construction node1 = GraphNode(1) node2 = GraphNode(2) node3 = GraphNode(3) node4 = GraphNode(4) node5 = GraphNode(5) node1.neighbors = [node2, node3] node2.neighbors = [node4, node5] node3.neighbors = [] node4.neighbors = [] node5.neighbors = [] # Expected output result = level_order_traversal(node1) # Output should be: [[1], [2, 3], [4, 5]] ``` # Hints 1. Use a queue to help with the level-order traversal. 2. Keep track of visited nodes to avoid processing the same node multiple times.","solution":"from collections import deque, defaultdict class GraphNode: def __init__(self, value): self.value = value self.neighbors = [] def level_order_traversal(start_node: GraphNode) -> list[list[int]]: if not start_node: return [] result = [] queue = deque([start_node]) visited = set([start_node]) while queue: level_length = len(queue) current_level = [] for _ in range(level_length): node = queue.popleft() current_level.append(node.value) for neighbor in node.neighbors: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) result.append(current_level) return result"},{"question":"# Problem Statement You have been assigned to create a function that analyzes a given list of integers and identifies the subsequence with the maximum sum. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The main goal is to handle the analysis efficiently, particularly for large lists. # Functionality Requirements - Implement the function `max_subsequence_sum(arr: list) -> int` that finds the sum of the subsequence with the highest possible sum from the given list. - The subsequence can be non-contiguous, but the relative order of elements must remain the same as in the original list. # Constraints - The function should handle input lists with up to 100,000 integers. - Each integer in the input list will be between -10^6 and 10^6. # Input - `arr` (list): A list of integers. # Output - An integer representing the maximum sum of a subsequence of the input list. # Examples ```python max_subsequence_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) ``` should return: ```python 10 # The subsequence [4, -1, 2, 1, 4] gives the sum 4 + (-1) + 2 + 1 + 4 = 10 ``` ```python max_subsequence_sum([3, -2, 5, -1]) ``` should return: ```python 8 # The subsequence [3, 5] gives the sum 3 + 5 = 8 ``` # Scenario You are developing a financial application that needs to detect the most profitable subsequence of transactions. By identifying the subsequence with the highest sum of transaction values, the application can provide insights on investment opportunities and fluctuations. # Performance Requirements - Ensure that the solution efficiently handles large input lists without excessive computational delay. - Optimize the function to run in linear time complexity, O(n), leveraging efficient algorithms if necessary. # Hints - Consider dynamic programming techniques to efficiently solve the problem. - Review the \\"Maximum Subarray Problem\\" for potential insights, but note that your solution needs to handle non-contiguous subsequences. # Output Compose one additional question that seamlessly integrates with the existing set, adhering to all the above guidelines. Your new question should appear as if it were part of the original examination and indistinguishable in quality. Output one new question only.","solution":"def max_subsequence_sum(arr): Returns the maximum sum of a subsequence of the input array. # The maximum sum of a subsequence is achieved by summing all positive numbers max_sum = sum(x for x in arr if x > 0) # If max_sum is 0, it means there were no positive numbers. So, we should return the max number in the list. return max_sum if max_sum > 0 else max(arr)"},{"question":"# Coding Question: Implement a Custom Random Forest Classifier with Feature Importance Analysis Objective You are tasked with building and analyzing a Random Forest classifier for a given dataset. Your solution should demonstrate your understanding of the algorithm, its application, and feature importance analysis to identify the most significant features. Requirements 1. Implement a function `build_and_analyze_rf_classifier(features: np.ndarray, target: np.ndarray, test_size: float = 0.2) -> tuple` that: * Splits the given features and target arrays into training and testing subsets based on the given `test_size`. * Trains a Random Forest classifier on the training data. * Computes the importance of each feature used in the model. * Returns a tuple containing the trained model, its accuracy score on the test set, and a list of feature importances. 2. The function should handle common edge cases such as missing values or imbalanced target classes appropriately. Constraints - Input features will be a two-dimensional numpy array of shape (N, M), where N is the number of samples and M is the number of features. - Target will be a one-dimensional numpy array of length N. - The `test_size` parameter will be a float between 0 and 1, representing the proportion of the dataset to be used for testing. - Your implementation should be efficient and work for datasets with up to 100,000 samples and 500 features without excessive memory usage. Performance Requirements - Submissions are expected to implement error handling for invalid inputs. - Model accuracy on the test set should be maximized while also identifying the most important features. - Execution time should be reasonable, considering the complexity of the algorithm and the dataset size. Expected API ```python from typing import Tuple, List import numpy as np from sklearn.ensemble import RandomForestClassifier def build_and_analyze_rf_classifier( features: np.ndarray, target: np.ndarray, test_size: float = 0.2 ) -> Tuple[RandomForestClassifier, float, List[float]]: # Your code here pass ``` # Example Usage ```python import numpy as np # Example dataset features = np.array([[5.1, 3.5, 1.4, 0.2], [4.9, 3.0, 1.4, 0.2], ...]) target = np.array([0, 0, ...]) # Build and analyze Random Forest classifier clf, test_score, feature_importances = build_and_analyze_rf_classifier(features, target, test_size=0.3) print(\\"Trained Model:\\", clf) print(\\"Test Set Accuracy:\\", test_score) print(\\"Feature Importances:\\", feature_importances) ``` # Notes - You can use libraries such as `scikit-learn` for splitting the dataset, training the model, and computing feature importances. - Document your code and provide comments explaining key steps and decisions.","solution":"from typing import Tuple, List import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score def build_and_analyze_rf_classifier( features: np.ndarray, target: np.ndarray, test_size: float = 0.2 ) -> Tuple[RandomForestClassifier, float, List[float]]: Builds a Random Forest Classifier, trains it, and analyzes feature importance. Parameters: features (np.ndarray): The input features (N, M) where N is the number of samples and M is the number of features. target (np.ndarray): The target values (N,). test_size (float): The proportion of the dataset to be used for testing. Default is 0.2. Returns: Tuple containing: - RandomForestClassifier: The trained Random Forest model. - float: The accuracy of the model on the test set. - List[float]: The importance of each feature. # Validate inputs if not (0 < test_size < 1): raise ValueError(\\"test_size should be between 0 and 1\\") if features.shape[0] != target.shape[0]: raise ValueError(\\"Number of samples in features and target must match\\") # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=test_size, random_state=42) # Train the Random Forest model rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42) rf_classifier.fit(X_train, y_train) # Predict on the test set y_pred = rf_classifier.predict(X_test) # Calculate accuracy accuracy = accuracy_score(y_test, y_pred) # Get feature importances feature_importances = rf_classifier.feature_importances_.tolist() return rf_classifier, accuracy, feature_importances"},{"question":"# Scenario You are tasked with developing an analytics feature for a marketing application. The objective is to analyze a sequence of daily user engagements over a given period and determine the longest continuous period where user engagement increased every day. Each day\'s engagement is represented as an integer in a list, and the goal is to find the length of the longest increasing subsequence of consecutive days in terms of user engagement. # Task Write a function `longest_increasing_engagement_period` that accepts a list `engagements`, where each element represents the engagement level on a given day, and returns an integer representing the length of the longest continuous period with increasing engagement. # Function Signature ```python def longest_increasing_engagement_period(engagements: list[int]) -> int: ``` # Input * `engagements` - a list of integers, where each element represents the user engagement on that day. * Constraints: * The length of the list will be between 1 and 10000. * Each engagement level will be a non-negative integer less than or equal to 10000. # Output * An integer value representing the length of the longest continuous period with increasing engagement levels. # Example ```python assert longest_increasing_engagement_period([1, 2, 2, 3, 4, 5, 3, 6]) == 4 assert longest_increasing_engagement_period([5, 6, 7, 8, 9]) == 5 assert longest_increasing_engagement_period([10, 9, 8, 7]) == 1 ```","solution":"def longest_increasing_engagement_period(engagements): if not engagements: return 0 max_length = 1 current_length = 1 for i in range(1, len(engagements)): if engagements[i] > engagements[i - 1]: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"# \\"K’th Largest Element\\" Context Finding the K\'th largest element in an array is a common problem in computer science. This task is pertinent in scenarios like determining the top performer in a competition, identifying the largest numbers in a dataset, or processing real-time sensor data where only the highest values are of interest. Task You need to implement a function `kth_largest` that returns the K\'th largest element in an array of integers. Requirements 1. **Function Name**: `kth_largest` 2. **Input**: * `arr`: List of integers. * `k`: Integer representing the position of the largest element that needs to be found (1 ≤ k ≤ len(arr)). 3. **Output**: * Returns an integer, the K\'th largest element. Constraints * The list `arr` will have at least one element and at most 10^4 elements. * The elements of the list can be positive or negative integers. Performance Requirements The implemented function should efficiently handle the given constraints. Aim for a time complexity better than O(n log n), ideally the average O(n) time complexity. Function Signature ```python def kth_largest(arr, k): pass ``` Example ```python # Example 1: arr = [3, 2, 1, 5, 6, 4] k = 2 # Output: 5 # Explanation: The 2nd largest element in the array is 5. # Example 2: arr = [7, 10, 4, 3, 20, 15] k = 4 # Output: 7 # Explanation: The 4th largest element in the array is 7. ``` # Notes * Implement the solution considering optimal use of time and space as per the constraints. * Assume the function will be tested with various inputs to ensure correctness and efficiency.","solution":"import heapq def kth_largest(arr, k): Returns the K\'th largest element in the array. Parameters: arr (List[int]): List of integers. k (int): The K\'th position (1-based) largest element to find. Returns: int: The K\'th largest element. # Use a min-heap to keep track of the k largest elements. min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappushpop(min_heap, num) return min_heap[0]"},{"question":"# Problem Statement You are tasked with developing a more efficient way to compute all permutations of a given string without generating duplicate permutations. Design a function that takes a string and returns all possible unique permutations of its characters. # Function Signature ```python def unique_permutations(s: str) -> list[str]: Generates all unique permutations of the input string. Args: - s (str): The input string to permute. Returns: - list[str]: A list of all unique permutations of the input string. ``` # Input - A string `s` consisting of alphanumeric characters. # Output - A list of strings, where each string is a unique permutation of the input string. # Constraints - The length of string `s` will be in the range `[1, 8]`. - The string can contain duplicate characters. # Example ```python s = \\"aab\\" assert set(unique_permutations(s)) == {\\"aab\\", \\"aba\\", \\"baa\\"} s = \\"abc\\" assert set(unique_permutations(s)) == {\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"} ``` # Requirements 1. You must implement the `unique_permutations` function. 2. The function should eliminate duplicate permutations efficiently. 3. Your solution should strive for optimal performance, avoiding generating non-unique permutations whenever possible.","solution":"from itertools import permutations def unique_permutations(s: str) -> list: Generates all unique permutations of the input string. Args: - s (str): The input string to permute. Returns: - list: A list of all unique permutations of the input string. return list(set([\'\'.join(p) for p in permutations(s)]))"},{"question":"Write a function `validate_isbn` that checks if a given ISBN-10 string is valid or not. The ISBN-10 is a 10-character code that contains 9 digits followed by an optional \'X\' which stands for the hexadecimal value 10. The formula for checking the validity of an ISBN-10 is as follows: - Take the first digit and multiply it by 10, the second digit by 9, and so on until the 9th digit which is multiplied by 2. - Add these values together. - Add the last digit (or \'X\' treated as 10) directly to the sum. - If the resulting sum is divisible by 11, the ISBN-10 is valid. # Requirements: 1. Validate the length of the input string to be exactly 10 characters. 2. Ensure the string contains only numeric characters except possibly the last character which can be \'X\' or a digit. 3. If any validation fails, return `False`. Otherwise, return `True` if the ISBN-10 is valid. # Function Signature: ```python def validate_isbn(isbn: str) -> bool: Input Parameters ---------------- isbn : str The ISBN-10 string to be validated. Returns ------- result : bool True if the ISBN-10 is valid, otherwise False. Examples -------- >>> validate_isbn(\\"0306406152\\") True >>> validate_isbn(\\"123456789X\\") True >>> validate_isbn(\\"1234567890\\") False >>> validate_isbn(\\"12345678X0\\") False >>> validate_isbn(\\"12345678\\") False pass ``` # Constraints: * The input string must be exactly 10 characters long. * The first 9 characters must be numeric, and the 10th character can either be numeric or \'X\'. * The function must return the correct validity status of the ISBN-10 based on the given algorithm. Implement the function and ensure it passes all the given test cases.","solution":"def validate_isbn(isbn: str) -> bool: Input Parameters ---------------- isbn : str The ISBN-10 string to be validated. Returns ------- result : bool True if the ISBN-10 is valid, otherwise False. if len(isbn) != 10: return False if not isbn[:-1].isdigit() or (isbn[-1] not in \'0123456789X\'): return False total = 0 for i in range(9): total += int(isbn[i]) * (10 - i) last_digit = 10 if isbn[-1] == \'X\' else int(isbn[-1]) total += last_digit return total % 11 == 0"},{"question":"# [Coding Assessment Question] You are given a grid of \'0\'s and \'1\'s with dimensions `m x n`. Implement a function `num_distinct_islands(grid: List[List[int]]) -> int` that counts the number of distinct islands in the grid. An island is composed of \'1\'s (land) and is surrounded by \'0\'s (water). Two islands are considered distinct if one island cannot be transformed into the other through rotation (0, 90, 180, or 270 degrees) or reflection. # Input: - A list of lists `grid` where each element is either a \'0\' or a \'1\', representing the grid (1 <= m, n <= 50). # Output: - An integer representing the number of distinct islands in the grid. # Constraints: 1. Your solution must handle the transformation and comparison of islands efficiently. 2. Consider any optimization to differentiate between islands accurately within the constraints. # Example: ```python assert num_distinct_islands([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1] ]) == 1 assert num_distinct_islands([ [1, 1, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 1, 1] ]) == 2 assert num_distinct_islands([ [1, 1, 0, 1, 1], [1, 0, 0, 0, 1], [0, 0, 0, 0, 1], [1, 0, 0, 1, 1] ]) == 3 ``` # Scenario: You are developing software for geographic visualization. The goal is to categorize landmasses extracted from satellite images. An efficient algorithm to count distinct islands, considering all possible transformations, is crucial for this task.","solution":"from typing import List def num_distinct_islands(grid: List[List[int]]) -> int: def dfs(grid, x, y, island_shape, pos): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 island_shape.append(pos) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up for i, (dx, dy) in enumerate(directions): dfs(grid, x + dx, y + dy, island_shape, (pos[0] + dx, pos[1] + dy)) def normalize_islandshape(shape): forms = [[] for _ in range(8)] for x, y in shape: forms[0].append((x, y)) forms[1].append((-x, y)) forms[2].append((x, -y)) forms[3].append((-x, -y)) forms[4].append((y, x)) forms[5].append((-y, x)) forms[6].append((y, -x)) forms[7].append((-y, -x)) for form in forms: form.sort() return min(form) unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: island_shape = [] dfs(grid, i, j, island_shape, (0, 0)) normalized_island = normalize_islandshape(island_shape) unique_islands.add(tuple(normalized_island)) return len(unique_islands)"},{"question":"# Unique Elements in Subarrays You are given an array of integers and a positive integer `k`. Write a function that calculates the number of unique elements in every subarray of length `k` in the given array. Return the result in the form of a list where the i-th element is the number of unique elements in the subarray starting at index i. Function Signature ```python def unique_elements_in_subarrays(arr: list[int], k: int) -> list[int]: ``` Input * A list of integers `arr` (1 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9). * An integer `k` (1 ≤ k ≤ len(arr)) which represents the length of the subarray. Output * A list of integers where each element represents the number of unique elements in each consecutive subarray of length `k`. Constraints * Your solution should be efficient and run in O(n) time complexity. Example ```python print(unique_elements_in_subarrays([1, 2, 2, 1, 3, 4, 2, 3, 3], 3)) # Output: [2, 2, 3, 3, 3, 3, 2] print(unique_elements_in_subarrays([4, 4, 4, 4, 4], 1)) # Output: [1, 1, 1, 1, 1] ``` Notes * Consider using a sliding window approach to achieve the desired time complexity. * Handle edge cases such as where all elements are the same or `k` equals the length of the array.","solution":"def unique_elements_in_subarrays(arr: list[int], k: int) -> list[int]: if not arr or k <= 0 or k > len(arr): return [] from collections import defaultdict unique_count = [] element_counts = defaultdict(int) unique_elements = 0 for i in range(len(arr)): if element_counts[arr[i]] == 0: unique_elements += 1 element_counts[arr[i]] += 1 if i >= k: if element_counts[arr[i - k]] == 1: unique_elements -= 1 element_counts[arr[i - k]] -= 1 if i >= k - 1: unique_count.append(unique_elements) return unique_count"},{"question":"# Coding Assessment Question Implement a function that generates all possible abbreviations of a given word. An abbreviation can replace any number of consecutive characters with a single number representing the count of those characters. Note that no two consecutive numbers are allowed in the abbreviations. # Requirements 1. **Input**: A single string consisting of lowercase English letters. 2. **Output**: A list of all possible abbreviations of the input string. # Constraints 1. The input string\'s length will be between 1 and 20. 2. The input string will only contain lowercase English letters. # Example ```python def generate_abbreviations(word: str) -> list: pass print(generate_abbreviations(\\"word\\")) # Expected output: # [\\"word\\", \\"w1rd\\", \\"wo2d\\", \\"wor1\\", \\"w2d\\", \\"w1r1\\", \\"wo1d\\", \\"3d\\", \\"1ord\\", \\"1o2d\\", \\"1or1\\", \\"1o1rd\\", \\"w3\\", \\"2rd\\", \\"w1r1\\", \\"1o1r1\\", \\"w2d\\", \\"0o2\\", \\"1o3\\", \\"0o1d1\\", \\"0o2d1\\", \\"0o1rd\\", ...] print(generate_abbreviations(\\"a\\")) # Expected output: # [\\"a\\", \\"1\\"] ``` # Notes 1. Consider using a recursive or backtracking approach to generate all possible combinations of abbreviations. 2. Ensure that abbreviations do not have consecutive numbers, which means you need to manage transitions between characters and numbers carefully. 3. The order of the generated abbreviations does not matter but ensure all unique abbreviations are present in the output list.","solution":"def generate_abbreviations(word): def backtrack(position, current, count, result): if position == len(word): if count > 0: current += str(count) result.append(current) else: # Option to abbreviate the current character backtrack(position + 1, current, count + 1, result) # Option to keep the current character if count > 0: current += str(count) backtrack(position + 1, current + word[position], 0, result) result = [] backtrack(0, \\"\\", 0, result) return result"},{"question":"# Problem Statement: You are required to create a script that processes a JSON file containing employee information and generates a summary report. The JSON file includes details like employee names, ages, departments, and salaries. # Requirements: 1. **Function Name**: `read_employees` - **Input**: A string representing the filename of the JSON file containing employee data (default value: `\\"employees.json\\"`). - **Output**: A list of dictionaries, where each dictionary represents an employee’s details (name, age, department, salary). - **Details**: This function should use the `json` library to read and parse the employee data from the JSON file. 2. **Function Name**: `generate_summary_report` - **Input**: - `employees` : A list of dictionaries containing the employee data. - `output_filename` : A string representing the filename for the summary report (default value: `\\"employee_summary_report.txt\\"`). - **Output**: None (writes the summary report to a text file). - **Details**: This function should generate a summary report containing: - Total number of employees. - Average age of employees. - Total salary expense. - A list of departments and the number of employees in each department. - The report should be written to the specified output file in a readable format. # Constraints: - The JSON file is guaranteed to be well-formed and correctly structured. - Employee ages are integers, names are strings, departments are strings, and salaries are floats. - Ensure the summary report is clearly formatted for easy readability. # Performance Requirements: - The functions should handle large JSON files efficiently. - JSON reading and parsing should be optimized for performance. # Example Usage: ```python if __name__ == \\"__main__\\": employee_data = read_employees(\\"employees.json\\") generate_summary_report(employee_data) ``` This script should read the employee data from `\\"employees.json\\"` and generate a summary report named `\\"employee_summary_report.txt\\"` in the current working directory, containing the specified details.","solution":"import json def read_employees(filename=\\"employees.json\\"): Reads the employee data from a JSON file and returns it as a list of dictionaries. :param filename: str, the filename of the JSON file containing employee data :return: list of dictionaries, where each dictionary represents an employee\'s details with open(filename, \'r\') as file: employees = json.load(file) return employees def generate_summary_report(employees, output_filename=\\"employee_summary_report.txt\\"): Generates a summary report of employee data and writes it to a text file. :param employees: list of dictionaries, containing the employee data :param output_filename: str, the filename for the summary report total_employees = len(employees) total_age = sum(employee[\'age\'] for employee in employees) total_salary = sum(employee[\'salary\'] for employee in employees) departments = {} for employee in employees: department = employee[\'department\'] if department in departments: departments[department] += 1 else: departments[department] = 1 avg_age = total_age / total_employees if total_employees > 0 else 0 with open(output_filename, \'w\') as file: file.write(f\\"Total number of employees: {total_employees}n\\") file.write(f\\"Average age of employees: {avg_age:.2f}n\\") file.write(f\\"Total salary expense: {total_salary:.2f}n\\") file.write(\\"Departments and number of employees:n\\") for department, count in departments.items(): file.write(f\\" - {department}: {count}n\\")"},{"question":"# Problem Description Develop a Python function to determine if a given string is a valid palindrome with the additional feature of allowing at most one character deletion to achieve the palindrome state. You should implement both recursive and iterative approaches to solve this problem. # Task Implement a function that checks if a given string can become a palindrome by removing at most one character. # Function Signature ```python def recursive_is_near_palindrome(s: str, left: int, right: int, delete_allowed: bool=True) -> bool: pass def iterative_is_near_palindrome(s: str) -> bool: pass ``` # Input - `s` (str): The input string. - `left` (int): The start index for the recursive function. - `right` (int): The end index for the recursive function. - `delete_allowed` (bool): A flag to allow one character deletion. # Output - Return True if the string can be made a palindrome by removing at most one character, otherwise return False. # Constraints - The input string can contain alphanumeric characters and have a length up to 5000. # Examples ```python # Main function signature of iterative palindrome check with one deletion assert iterative_is_near_palindrome(\\"abca\\") == True assert iterative_is_near_palindrome(\\"racecar\\") == True assert iterative_is_near_palindrome(\\"abcea\\") == False assert iterative_is_near_palindrome(\\"a\\") == True assert iterative_is_near_palindrome(\\"\\") == True # Main function signature of recursive palindrome check with one deletion assert recursive_is_near_palindrome(\\"abca\\", 0, 3) == True assert recursive_is_near_palindrome(\\"racecar\\", 0, 6) == True assert recursive_is_near_palindrome(\\"abcea\\", 0, 4) == False assert recursive_is_near_palindrome(\\"a\\", 0, 0) == True assert recursive_is_near_palindrome(\\"\\", 0, -1) == True ``` # Hints - Use two-pointer technique to compare characters from both ends of the string. - For recursive approach, ensure that base cases and edge cases such as empty strings and single character strings are handled properly. - In both approaches keep track of whether you have already deleted a character or not, as only one deletion is allowed.","solution":"def recursive_is_near_palindrome(s: str, left: int, right: int, delete_allowed: bool=True) -> bool: Helper function to check if the substring s[left:right+1] can be made a palindrome by removing at most one character. while left < right: if s[left] != s[right]: if not delete_allowed: return False # Try deleting either s[left] or s[right] and check recursively return (recursive_is_near_palindrome(s, left + 1, right, False) or recursive_is_near_palindrome(s, left, right - 1, False)) left += 1 right -= 1 return True def iterative_is_near_palindrome(s: str) -> bool: Function to check if the string can be made a palindrome by removing at most one character using an iterative approach. left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try to skip the mismatching characters from either ends skip_left = s[left+1:right+1] skip_right = s[left:right] return skip_left == skip_left[::-1] or skip_right == skip_right[::-1] left += 1 right -= 1 return True"},{"question":"# Question: Binary Search Tree (BST) Operations Context: You are required to implement a Binary Search Tree (BST) that offers fundamental operations like insertion, searching, and in-order traversal to produce a sorted sequence. Additionally, you need to implement functionality to find the height of the tree and check if the tree is balanced. # Task: Create a class `BinarySearchTree` that supports the following operations: 1. **Insertion**: Method `insert(data)` to add a value into the BST. 2. **Searching**: Method `search(data)` to determine if a value exists in the BST. 3. **In-order Traversal**: Method `in_order_traversal()` to return a list of values representing an in-order traversal of the BST. 4. **Height of the Tree**: Method `height()` to return the height of the tree. 5. **Check if Balanced**: Method `is_balanced()` to determine if the tree is balanced, where a balanced tree is defined as one where the height difference between any node\'s two subtrees is no more than 1. # Requirements: 1. **Input/Output**: - Each method should operate on instances of `BinarySearchTree` and modify the tree in place where applicable. - The `__repr__()` method should be implemented to provide a string representation of the in-order traversal of the BST for visual confirmation. 2. **Constraints**: - Each operation should handle edge cases such as empty trees or singleton trees. - Ensure the methods are implemented with efficient time and space complexity considerations. 3. **Performance**: - The operations `insert`, `search`, and `in_order_traversal` should have a time complexity of O(h), where h is the height of the tree. - The methods for height and balance checking should aim for O(n) complexity, where n is the number of nodes in the tree. # Example: ```python # Creating Binary Search Tree with initial data bst = BinarySearchTree() initial_data = [10, 5, 20, 3, 7, 15, 30] for value in initial_data: bst.insert(value) print(bst) # Expected: 3, 5, 7, 10, 15, 20, 30 (in-order traversal) # Inserting additional data bst.insert(25) print(bst) # Expected: 3, 5, 7, 10, 15, 20, 25, 30 (in-order traversal) # Searching for a value print(bst.search(15)) # Expected: True print(bst.search(100)) # Expected: False # Height of the tree print(bst.height()) # Expected height for this structure # Checking if the tree is balanced print(bst.is_balanced()) # Expected: True or False, depending on tree structure ``` # Note: - The `__repr__()` method should provide an in-order traversal string representation like: \\"3, 5, 7, 10, 15, 20, 30\\". - Ensure your code handles edge cases gracefully, like inserting into an empty tree or searching in an empty tree.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, data): if not self.root: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if not node.left: node.left = Node(data) else: self._insert(node.left, data) else: if not node.right: node.right = Node(data) else: self._insert(node.right, data) def search(self, data): return self._search(self.root, data) def _search(self, node, data): if not node: return False if node.data == data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.data) self._in_order_traversal(node.right, result) def height(self): return self._height(self.root) def _height(self, node): if not node: return 0 return 1 + max(self._height(node.left), self._height(node.right)) def is_balanced(self): return self._is_balanced(self.root) def _is_balanced(self, node): if not node: return True left_height = self._height(node.left) right_height = self._height(node.right) if abs(left_height - right_height) > 1: return False return self._is_balanced(node.left) and self._is_balanced(node.right) def __repr__(self): return \', \'.join(map(str, self.in_order_traversal()))"},{"question":"# Question Scenario You are tasked with implementing a sorting algorithm to determine the order of an exam results list. Each student has a name and a numerical score. Your function should sort the list according to the scores in descending order. In the case where two students have the same score, the tie should be broken by sorting their names in ascending lexicographic order. You must ensure your solution is efficient for large datasets. Task Write a Python function `sort_exam_results` that sorts a list of students based on their scores and, if necessary, their names. Function Specification ```python def sort_exam_results(results): Sorts a list of students based on their scores in descending order. In case of ties, sorts by names in ascending order. Args: results (list of tuple): A list where each tuple contains a student\'s name (str) and score (int). Returns: list of tuple: Sorted list of students. ``` Constraints - Each student\'s name is a non-empty string containing only alphabetic characters. - Each student\'s score is a non-negative integer. - The list `results` contains at least one student and no more than 10,000 students. Example ```python results = [(\\"John\\", 85), (\\"Alice\\", 92), (\\"Bob\\", 85), (\\"Eve\\", 92)] assert sort_exam_results(results) == [(\\"Alice\\", 92), (\\"Eve\\", 92), (\\"John\\", 85), (\\"Bob\\", 85)] ``` Performance Requirements - The function should be able to handle lists of size up to 10,000 efficiently. - Memory usage should be within acceptable limits for large input sizes.","solution":"def sort_exam_results(results): Sorts a list of students based on their scores in descending order. In case of ties, sorts by names in ascending order. Args: results (list of tuple): A list where each tuple contains a student\'s name (str) and score (int). Returns: list of tuple: Sorted list of students. return sorted(results, key=lambda x: (-x[1], x[0]))"},{"question":"# Question: Extended String Manipulation Functions **Context:** You are developing a string manipulation library. The library already supports basic string operations like reversing a string, converting to uppercase, and finding substrings. Your task is to extend this library with more advanced string operations that will be useful in different contexts like text processing and cryptographic applications. **Objective:** Implement the following functions, ensuring to handle edge cases, optimize for performance, and deal with different input types effectively: 1. **Longest Palindromic Substring**: Find the longest palindromic substring within a given string. 2. **String Compression**: Implement a basic string compression algorithm where consecutive duplicate characters are replaced with the character followed by the count of repetitions. 3. **Is Anagram**: Determine whether two given strings are anagrams of each other. **Function Signatures:** ```python def longest_palindromic_substring(s: str) -> str: pass def compress_string(s: str) -> str: pass def is_anagram(s1: str, s2: str) -> bool: pass ``` **Expected Input and Output**: ```python assert longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert is_anagram(\\"listen\\", \\"silent\\") == True assert is_anagram(\\"hello\\", \\"world\\") == False ``` **Constraints:** - The input for all functions will be non-empty strings. - The length of the strings will not exceed 10^5 characters. **Detailed Requirements:** 1. **Longest Palindromic Substring**: - **Input:** A single non-empty string, s. - **Output:** A string representing the longest palindromic substring within s. - Utilize efficient algorithms like expanding around center or dynamic programming to ensure optimal performance. 2. **String Compression**: - **Input:** A single non-empty string, s. - **Output:** A compressed version of the string using the described method. - Ensure that single characters or small groups do not unnecessarily inflate the string\'s length. 3. **Is Anagram**: - **Input:** Two non-empty strings, s1 and s2. - **Output:** A boolean indicating whether s1 and s2 are anagrams. - Consider character frequency and sorting, ensuring an optimal and efficient solution. **Edge Cases to Consider**: - Minimal Input: Test the smallest strings (e.g., one character). - Completely Non-Repetitive Strings: Ensure the correct behavior for strings without repeated characters. - Case Sensitivity: Consider whether the functions should be case-sensitive and document it. - Large Input: Test the performance with the upper limit of string length. ---- Attached are the function signatures and expected outputs to guide the implementation. Please test thoroughly to cover various edge cases and ensure robustness.","solution":"def longest_palindromic_substring(s: str) -> str: if len(s) == 0: return \\"\\" def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes pal1 = expand_around_center(i, i) if len(pal1) > len(longest): longest = pal1 # Even length palindromes pal2 = expand_around_center(i, i + 1) if len(pal2) > len(longest): longest = pal2 return longest def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 compressed.append(s[-1]) compressed.append(str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s def is_anagram(s1: str, s2: str) -> bool: return sorted(s1) == sorted(s2)"},{"question":"# Problem Description You need to implement a queue data structure using a singly linked list. The queue should support the following operations: 1. `enqueue(data)`: Adds an element \'data\' to the end of the queue. 2. `dequeue()`: Removes the front element from the queue and returns it. 3. `front()`: Returns the front element of the queue without removing it. 4. `is_empty()`: Checks whether the queue is empty. 5. `__len__()`: Returns the number of elements currently in the queue. # Function Signatures You need to implement the following methods in the `Queue` class: ```python class Queue: def __init__(self): Initializes an empty queue. def enqueue(self, data): Adds \'data\' to the end of the queue. def dequeue(self): Removes and returns the front element from the queue. If the queue is empty, return None. def front(self): Returns the front element without removing it. If the queue is empty, return None. def is_empty(self): Checks and returns if the queue is empty. def __len__(self): Returns the number of elements in the queue. ``` # Input and Output * `enqueue(data)`: No input. Returns None. * `dequeue()`: No input. Returns the front element or None if the queue is empty. * `front()`: No input. Returns the front element or None if the queue is empty. * `is_empty()`: No input. Returns True if the queue is empty, False otherwise. * `__len__()`: No input. Returns the count of elements in the queue. # Constraints * Data can be of any type. * Ensure efficient handling of edge cases, such as operations on an empty queue. # Notes * Do not use any built-in data structures for the queue operations. * Focus on maintaining the efficiency and correctness of your implementation.","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None class Queue: def __init__(self): self.head = None self.tail = None self._size = 0 def enqueue(self, data): new_node = Node(data) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node self._size += 1 def dequeue(self): if not self.head: return None dequeued_data = self.head.data self.head = self.head.next if not self.head: self.tail = None self._size -= 1 return dequeued_data def front(self): return self.head.data if self.head else None def is_empty(self): return self.head is None def __len__(self): return self._size"},{"question":"# Coding Assessment Question Problem Statement You are tasked with creating a function that generates the Collatz sequence starting from a given integer. The Collatz conjecture is a mathematical sequence that hypothesizes that no matter which positive integer you start with, you will always eventually reach 1. Detailed Description * **Function Name**: `collatz_sequence` * **Inputs**: * `start_number` (int): A positive integer to start the sequence. * **Output**: * Returns a list of integers representing the Collatz sequence starting from the `start_number` and ending at 1. * **Constraints**: * `start_number` must be a positive integer. * Raise appropriate exceptions with helpful error messages if the constraints are violated. Rules The sequence is generated by repeatedly applying the following rules: * If the current number is even, divide it by 2. * If the current number is odd, multiply it by 3 and add 1. Example ```python >>> collatz_sequence(6) [6, 3, 10, 5, 16, 8, 4, 2, 1] >>> collatz_sequence(19) [19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] >>> collatz_sequence(0) # invalid start number Traceback (most recent call last): ... Exception: Start number must be a positive integer >>> collatz_sequence(-5) # invalid start number Traceback (most recent call last): ... Exception: Start number must be a positive integer ``` Implementation Implement the function in Python, structured as follows: ```python def collatz_sequence(start_number: int) -> list: Takes a positive integer and returns a list representing the Collatz sequence starting from the given integer. Examples: >>> collatz_sequence(6) [6, 3, 10, 5, 16, 8, 4, 2, 1] >>> collatz_sequence(19) [19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] >>> collatz_sequence(0) # invalid start number Traceback (most recent call last): ... Exception: Start number must be a positive integer >>> collatz_sequence(-5) # invalid start number Traceback (most recent call last): ... Exception: Start number must be a positive integer if start_number <= 0: raise Exception(\\"Start number must be a positive integer\\") sequence = [] while start_number != 1: sequence.append(start_number) if start_number % 2 == 0: start_number //= 2 else: start_number = 3 * start_number + 1 sequence.append(1) return sequence ```","solution":"def collatz_sequence(start_number: int) -> list: Takes a positive integer and returns a list representing the Collatz sequence starting from the given integer. Examples: >>> collatz_sequence(6) [6, 3, 10, 5, 16, 8, 4, 2, 1] >>> collatz_sequence(19) [19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] >>> collatz_sequence(0) # invalid start number Traceback (most recent call last): ... Exception: Start number must be a positive integer >>> collatz_sequence(-5) # invalid start number Traceback (most recent call last): ... Exception: Start number must be a positive integer if start_number <= 0: raise Exception(\\"Start number must be a positive integer\\") sequence = [] while start_number != 1: sequence.append(start_number) if start_number % 2 == 0: start_number //= 2 else: start_number = 3 * start_number + 1 sequence.append(1) return sequence"},{"question":"# Question: Implement Simple Linked List Operations You are tasked with implementing a simple singly linked list in Python. Specifically, you need to create a `Node` class and a `SinglyLinkedList` class with methods for basic linked list operations. Class 1: `Node` The `Node` class should store: - An integer value (`val`). - A pointer to the next node (`next`). # Example: ```python node = Node(5) print(node.val) # Output: 5 print(node.next) # Output: None ``` Class 2: `SinglyLinkedList` The `SinglyLinkedList` class should support the following methods: 1. **Initialization**: Initialize an empty linked list. 2. **Insert at Head**: Insert a new node with a given value at the head of the list. 3. **Insert at Tail**: Insert a new node with a given value at the tail of the list. 4. **Delete by Value**: Delete the first node that contains a given value. 5. **Search**: Return `True` if a node with the given value exists in the list, otherwise `False`. 6. **Display**: Print all node values in the linked list. # Example: ```python linked_list = SinglyLinkedList() linked_list.insert_at_head(10) linked_list.insert_at_tail(20) print(linked_list.search(10)) # Output: True print(linked_list.search(15)) # Output: False linked_list.delete_by_value(10) linked_list.display() # Output: 20 ``` # Solution Skeleton Here is a skeleton code for you to complete: ```python class Node: def __init__(self, val: int): self.val = val self.next = None class SinglyLinkedList: def __init__(self): self.head = None def insert_at_head(self, val: int) -> None: # Add your solution here pass def insert_at_tail(self, val: int) -> None: # Add your solution here pass def delete_by_value(self, val: int) -> bool: # Add your solution here pass def search(self, val: int) -> bool: # Add your solution here pass def display(self) -> None: # Add your solution here pass # Test your implementation if __name__ == \\"__main__\\": linked_list = SinglyLinkedList() linked_list.insert_at_head(10) linked_list.insert_at_tail(20) assert linked_list.search(10) == True assert linked_list.search(15) == False linked_list.delete_by_value(10) linked_list.display() # Should output 20 ``` # Function Requirements: 1. **Node Initialization**: - `Node(val: int)` 2. **Insert at Head**: - `insert_at_head(val: int) -> None` 3. **Insert at Tail**: - `insert_at_tail(val: int) -> None` 4. **Delete by Value**: - `delete_by_value(val: int) -> bool` 5. **Search**: - `search(val: int) -> bool` 6. **Display**: - `display() -> None`","solution":"class Node: def __init__(self, val: int): self.val = val self.next = None class SinglyLinkedList: def __init__(self): self.head = None def insert_at_head(self, val: int) -> None: new_node = Node(val) new_node.next = self.head self.head = new_node def insert_at_tail(self, val: int) -> None: new_node = Node(val) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete_by_value(self, val: int) -> bool: current = self.head prev = None while current: if current.val == val: if prev: prev.next = current.next else: self.head = current.next return True prev = current current = current.next return False def search(self, val: int) -> bool: current = self.head while current: if current.val == val: return True current = current.next return False def display(self) -> None: current = self.head values = [] while current: values.append(current.val) current = current.next print(\\" -> \\".join(map(str, values)))"},{"question":"# Binary Search Algorithm Background One of the fundamental algorithms in computer science is the binary search algorithm. This algorithm is used to efficiently find an element in a sorted array by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. Task Create a function `binary_search` that takes a sorted list of integers and a target integer. The function should return the index of the target if it is present in the list. If the target is not found, the function should return -1. Function Signature ```python def binary_search(sorted_list: List[int], target: int) -> int: pass ``` Input * `sorted_list`: A list of integers sorted in ascending order. * `target`: An integer value to search for within the list. Output * An integer representing the index of the target in the list if found. Otherwise, return -1. Constraints * The length of the sorted list will be between 1 and 10^5, inclusive. * The integers in the sorted list will be within the range of -10^9 to 10^9. * The target integer will be within the range of -10^9 to 10^9. Performance Requirements * Your implementation should run in logarithmic time, i.e., O(log n) where n is the length of the sorted list. Example ```python >>> binary_search([1, 2, 3, 4, 5], 3) 2 >>> binary_search([1, 2, 3, 4, 5], 6) -1 ``` In the first example, the target 3 is found at index 2 in the sorted list. In the second example, the target 6 is not found in the list, so the function returns -1. **Note**: Ensure the binary search algorithm is implemented correctly to handle various edge cases and is efficient in terms of time complexity.","solution":"from typing import List def binary_search(sorted_list: List[int], target: int) -> int: left, right = 0, len(sorted_list) - 1 while left <= right: mid = (left + right) // 2 if sorted_list[mid] == target: return mid elif sorted_list[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Assessment Question Scenario You are working on a text processing tool and have been asked to implement a function that finds the longest substring of a given string which contains at most two distinct characters. The goal is to efficiently identify such substrings, ensuring optimal performance even for larger input strings. Function Specification **Function Name**: `longest_substring_with_two_distinct` **Parameters**: - `s`: A string consisting of lowercase English letters only. **Returns**: - A tuple where the first element is the longest substring with at most two distinct characters, and the second element is the length of this substring. **Constraints**: - The input string size will not exceed 10,000 characters. Example ```python assert longest_substring_with_two_distinct(\\"eceba\\") == (\\"ece\\", 3) assert longest_substring_with_two_distinct(\\"ccaabbb\\") == (\\"aabbb\\", 5) assert longest_substring_with_two_distinct(\\"\\") == (\\"\\", 0) assert longest_substring_with_two_distinct(\\"a\\") == (\\"a\\", 1) ``` Task 1. Write the function `longest_substring_with_two_distinct(s)` to find and return the longest substring that contains at most two distinct characters. 2. Ensure your implementation passes the provided example cases. 3. Consider edge cases and handle them appropriately within your function. 4. Focus on achieving optimal performance, especially for larger input strings. Provide any additional notes or comments in your code to explain key steps or decisions in your implementation.","solution":"def longest_substring_with_two_distinct(s): Finds the longest substring with at most two distinct characters. Parameters: s (str): The input string consisting of lowercase English letters. Returns: tuple: (longest substring, length of the substring) if not s: return \\"\\", 0 left = 0 right = 0 max_len = 0 max_substring = \\"\\" char_map = {} while right < len(s): char = s[right] char_map[char] = char_map.get(char, 0) + 1 right += 1 while len(char_map) > 2: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 if (right - left) > max_len: max_len = right - left max_substring = s[left:right] return max_substring, max_len"},{"question":"# Problem Statement Create a function to find the diameter of a binary tree. The diameter (or width) of a tree is defined as the number of nodes on the longest path between two end nodes. # Function Signature ```python def diameter_of_binary_tree(root: Optional[TreeNode]) -> int: ``` # Input - `root`: The root node of a binary tree. Each node is an instance of the `TreeNode` class. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - An integer representing the diameter of the tree. # Example ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(diameter_of_binary_tree(root)) # Output: 4 ``` # Constraints - The number of nodes in the tree is in the range [1, 10^4]. - The value of each node is within the range [-100, 100]. - Your solution should handle both balanced and unbalanced trees. # Notes 1. Consider using Depth First Search (DFS) to traverse the tree. 2. Maintain and update the maximum diameter found during the traversal. 3. Consider edge cases, such as trees with only one node or extremely unbalanced trees.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root: Optional[TreeNode]) -> int: max_diameter = 0 def depth(node): nonlocal max_diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) # Update the diameter if the path through the root is larger max_diameter = max(max_diameter, left_depth + right_depth) # Return the depth of the tree return max(left_depth, right_depth) + 1 depth(root) return max_diameter"},{"question":"# Data Analysis and Visualization Assessment You are required to implement a Python script to read sales data from a CSV file, analyze it, and generate a visualization. The objective is to assess your understanding of data handling, analytical skills, and proficiency in creating visualizations using Python. Context: You need to read a given CSV file containing sales data, process the data to compute total sales per product category, and generate a bar chart visualizing the results. Task: 1. Write a function `read_sales_data(filename: str) -> pd.DataFrame` which reads sales data from a specified CSV file and returns a pandas DataFrame. Assume the CSV file contains columns such as \'Date\', \'Product\', \'Category\', \'Quantity\', and \'Price\'. 2. Write a second function `compute_total_sales(data: pd.DataFrame) -> pd.Series` that takes the DataFrame returned by `read_sales_data` and computes the total sales per product category. The function should return a pandas Series where the index represents the product categories and the values represent the total sales. 3. Write a third function `plot_sales(data: pd.Series, filename: str = \\"sales_chart.png\\") -> None` that takes the Series returned by `compute_total_sales` and generates a bar chart. The function should save the bar chart as a PNG file with the specified filename. Input: - `filename`: (str) The name of the CSV file containing sales data. - `data`: (pd.DataFrame) DataFrame containing sales data. - `filename`: (str) The name of the PNG file to save the bar chart to. Default is \\"sales_chart.png\\". Output: - For `read_sales_data`: A pandas DataFrame containing the sales data. - For `compute_total_sales`: A pandas Series containing total sales per product category. - For `plot_sales`: No return value, but it should create a PNG file with a bar chart visualizing total sales per category. Notes: - Ensure the CSV file path is valid and handle potential file-related errors with appropriate exception handling. - The bar chart should have clear labels for the product categories and the corresponding total sales. - Use appropriate libraries like pandas for data manipulation and matplotlib for visualization. - The total sales for each category should be computed as the sum of (Quantity * Price) for that category. Constraints: - The CSV file should not be empty and must contain the expected columns. - Ensure the DataFrame is properly formatted before performing computations. - Code should be modular and follow best practices for readability and maintainability. Example: Here is an example of expected function usage: ```python filename = \\"sales_data.csv\\" data = read_sales_data(filename) total_sales = compute_total_sales(data) plot_sales(total_sales, \\"sales_chart.png\\") ``` This question assesses your capability to handle data analysis and visualization tasks using Python libraries, ensuring a thorough understanding of data pipelines and graphical representation of results.","solution":"import pandas as pd import matplotlib.pyplot as plt def read_sales_data(filename: str) -> pd.DataFrame: Reads sales data from a CSV file and returns a pandas DataFrame. Parameters: - filename (str): The name of the CSV file containing sales data. Returns: - pd.DataFrame: A DataFrame containing the sales data. try: df = pd.read_csv(filename) if \'Date\' not in df.columns or \'Product\' not in df.columns or \'Category\' not in df.columns or \'Quantity\' not in df.columns or \'Price\' not in df.columns: raise ValueError(\\"The CSV file does not contain the expected columns.\\") return df except FileNotFoundError: raise FileNotFoundError(f\\"The file {filename} does not exist.\\") except pd.errors.EmptyDataError: raise ValueError(\\"The CSV file is empty.\\") except Exception as e: raise ValueError(f\\"An error occurred while reading the CSV file: {e}\\") def compute_total_sales(data: pd.DataFrame) -> pd.Series: Computes total sales per product category. Parameters: - data (pd.DataFrame): DataFrame containing sales data. Returns: - pd.Series: Series with product categories as index and total sales as values. data[\'Total_Sales\'] = data[\'Quantity\'] * data[\'Price\'] return data.groupby(\'Category\')[\'Total_Sales\'].sum() def plot_sales(data: pd.Series, filename: str = \\"sales_chart.png\\") -> None: Generates a bar chart visualizing total sales per product category and saves it as a PNG file. Parameters: - data (pd.Series): Series with product categories as index and total sales as values. - filename (str): The name of the PNG file to save the bar chart to. Default is \\"sales_chart.png\\". Returns: - None plt.figure(figsize=(10, 6)) data.plot(kind=\'bar\', color=\'skyblue\') plt.title(\'Total Sales per Product Category\') plt.xlabel(\'Product Category\') plt.ylabel(\'Total Sales\') plt.tight_layout() plt.savefig(filename) plt.close()"},{"question":"# Question: Binary Tree Level Average Calculation Design and implement a function that calculates the average value of the nodes at each level of a binary tree. Your task is to write a function `level_averages` that takes one argument: 1. `root`: The root node of a binary tree. The function should return a list of floats representing the average values of the nodes on each level of the tree, from the root level to the lowest level. Implementation ```python from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_averages(root: TreeNode) -> list: Returns a list of the average values of the nodes at each level of the binary tree Parameters: root (TreeNode): The root node of the binary tree Returns: list: A list of floats representing the average values at each level Example: Given the binary tree: 3 / 9 20 / 15 7 The level averages would be: [3.0, 14.5, 11.0] >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> level_averages(root) [3.0, 14.5, 11.0] if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_length) return result ``` Input and Output Format: - **Input**: The root node of a binary tree. - **Output**: A list of floats representing the average values of nodes at each level. Constraints: - The binary tree nodes will have integer values. - The number of nodes in the tree is in the range [1, 10^4]. Example: **Input**: ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) print(level_averages(root)) ``` **Output**: ```python [3.0, 14.5, 11.0] ``` **Note**: This problem tests the ability to perform level-order traversal on a binary tree and calculate averages, commonly used for analyzing hierarchical data structures.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_averages(root: TreeNode) -> list: Returns a list of the average values of the nodes at each level of the binary tree Parameters: root (TreeNode): The root node of the binary tree Returns: list: A list of floats representing the average values at each level Example: Given the binary tree: 3 / 9 20 / 15 7 The level averages would be: [3.0, 14.5, 11.0] >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> level_averages(root) [3.0, 14.5, 11.0] if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_length) return result"},{"question":"# Coding Assessment Question You are required to develop a function that computes the determinant of a given square matrix. Determinants are a vital concept in linear algebra and have numerous applications in various fields including computer graphics, quantum mechanics, and systems of linear equations. Your Task Implement the function `calculate_determinant(matrix)` that computes and returns the determinant of a given square matrix. The function should handle input validation and raise appropriate exceptions based on the following cases: 1. The matrix is not square (i.e., the number of rows does not match the number of columns). 2. The matrix contains non-numeric elements (i.e., elements that cannot be interpreted as numbers). # Function Specifications `calculate_determinant` - **Input**: `matrix` (list of lists of integers or floats) - **Output**: `float` (determinant value) - **Exceptions**: - Raise `ValueError` if the matrix is not square. - Raise `TypeError` if any element in the matrix is non-numeric. # Example Usage ```python try: matrix1 = [[1, 2], [3, 4]] det1 = calculate_determinant(matrix1) print(det1) # Expected Output: -2.0 matrix2 = [[4, 5, 6], [7, 8, 9], [1, 2, 3]] det2 = calculate_determinant(matrix2) print(det2) # Expected Output: 0.0 matrix3 = [[1.5, 2.5], [3.5, 4.5]] det3 = calculate_determinant(matrix3) print(det3) # Expected Output: -2.0 except ValueError as ve: print(ve) except TypeError as te: print(te) ``` # Constraints - The matrix is represented as a list of lists where each sub-list is a row in the matrix. - The size of the matrix (number of rows and columns) ranges from 1 to 10. - Elements of the matrix are either integers or floats. # Notes - Utilize recursive methods to compute the determinant for larger matrices. - Ensure to handle the base case for the smallest square matrix (1x1) correctly. Good luck, and ensure your function is tested with both correct and incorrect inputs!","solution":"def calculate_determinant(matrix): Calculate the determinant of a square matrix. :param matrix: list of lists of integers or floats :return: determinant as a float :raises ValueError: if the matrix is not square :raises TypeError: if any element in the matrix is non-numeric # Validate matrix is a square n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix is not square.\\") # Validate all elements are numeric for row in matrix: for element in row: if not isinstance(element, (int, float)): raise TypeError(\\"Matrix can only contain numeric elements.\\") # Base case for 1x1 matrix if n == 1: return matrix[0][0] # Base case for 2x2 matrix if n == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] # Recursive case for nxn matrix determinant = 0 for c in range(n): sub_matrix = [row[:c] + row[c+1:] for row in matrix[1:]] cofactor = ((-1) ** c) * matrix[0][c] * calculate_determinant(sub_matrix) determinant += cofactor return determinant"},{"question":"# Problem Statement You are given a list of integers and an integer `k`, and you need to determine whether there is any pair of integers in the list whose sum equals `k`. The function should return `True` if such a pair exists, and `False` otherwise. # Objective Write a function `has_pair_with_sum(nums, k)` that takes a list of integers, `nums`, and an integer `k`, and returns a boolean value indicating whether there exists a pair of integers in the list that adds up to `k`. # Input - `nums`: A list of integers, which can be positive, negative, or zero. - `k`: An integer (positive, negative, or zero). # Output - Returns a boolean value `True` if there exists a pair of integers in the list whose sum equals `k`, otherwise `False`. # Constraints - The elements in the list can be repeated. - The list can contain at least 1 and at most 10^5 elements. - The elements in the list can be between -10^9 and 10^9 inclusive. - The solution should have an average time complexity of O(n). # Example ```python # Example 1 nums = [10, 15, 3, 7] k = 17 # Return Value: True # Explanation: 10 + 7 = 17 # Example 2 nums = [1, 2, 3, 4, 5] k = 10 # Return Value: False # Explanation: There is no pair that adds up to 10 ``` # Function Signature ```python def has_pair_with_sum(nums: list[int], k: int) -> bool: pass ``` # Function Implementation ```python def has_pair_with_sum(nums: list[int], k: int) -> bool: seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False # Test cases print(has_pair_with_sum([10, 15, 3, 7], 17)) # Output: True print(has_pair_with_sum([1, 2, 3, 4, 5], 10)) # Output: False ```","solution":"def has_pair_with_sum(nums, k): Determines if there is a pair of integers in the list nums that adds up to k. :param nums: List of integers :param k: Target sum :return: True if there exists a pair of integers whose sum is k, otherwise False seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"# Task Develop a function `format_duration` that converts a given duration in seconds into a human-readable string that represents the duration in weeks, days, hours, minutes, and seconds according to the following rules: 1. The output should be a string in the format: \\"X weeks Y days Z hours A minutes B seconds\\". 2. If any of the units (weeks, days, hours, minutes, seconds) are zero, they should be omitted from the output. 3. If the input duration is zero seconds, the function should return the string \\"0 seconds\\". # Function Signature ```python def format_duration(seconds: int) -> str: ``` # Input - A single input parameter `seconds`, which is an integer representing the total duration in seconds. # Output - The function should return a string that represents the duration in a human-readable format. # Constraints - The input integer `seconds` will be non-negative. # Examples ```python assert format_duration(0) == \\"0 seconds\\" assert format_duration(59) == \\"59 seconds\\" assert format_duration(60) == \\"1 minute\\" assert format_duration(3661) == \\"1 hour 1 minute 1 second\\" assert format_duration(86400) == \\"1 day\\" assert format_duration(90061) == \\"1 day 1 hour 1 minute 1 second\\" assert format_duration(604800) == \\"1 week\\" assert format_duration(1209600) == \\"2 weeks\\" ``` # Notes - The function needs to handle various units of time (weeks, days, hours, minutes, and seconds) and omit any unit that is zero from the final output string. - Ensure proper singular and plural forms (e.g., \\"1 day\\" vs. \\"2 days\\"). - Consider edge cases, such as when the duration is just below a week or a day, to ensure the function behaves as expected.","solution":"def format_duration(seconds: int) -> str: if seconds == 0: return \\"0 seconds\\" # Constants for time conversion SECONDS_IN_MINUTE = 60 SECONDS_IN_HOUR = 3600 SECONDS_IN_DAY = 86400 SECONDS_IN_WEEK = 604800 # Calculate number of weeks, days, hours, minutes, and seconds weeks = seconds // SECONDS_IN_WEEK seconds %= SECONDS_IN_WEEK days = seconds // SECONDS_IN_DAY seconds %= SECONDS_IN_DAY hours = seconds // SECONDS_IN_HOUR seconds %= SECONDS_IN_HOUR minutes = seconds // SECONDS_IN_MINUTE seconds %= SECONDS_IN_MINUTE # Build the result string parts = [] if weeks > 0: parts.append(f\\"{weeks} week{\'s\' if weeks != 1 else \'\'}\\") if days > 0: parts.append(f\\"{days} day{\'s\' if days != 1 else \'\'}\\") if hours > 0: parts.append(f\\"{hours} hour{\'s\' if hours != 1 else \'\'}\\") if minutes > 0: parts.append(f\\"{minutes} minute{\'s\' if minutes != 1 else \'\'}\\") if seconds > 0: parts.append(f\\"{seconds} second{\'s\' if seconds != 1 else \'\'}\\") return \' \'.join(parts)"},{"question":"# Coding Assessment Question You are contributing to a codebase that involves data processing for an e-commerce application. One of the requirements is to analyze the transaction records to identify any purchases that contain certain items of interest. Your task is to write a function that checks if any item from a given list of items is present in a transaction record. Problem Statement Write a function named `contains_interested_item` that determines if any item from a list of interested items is present in a given transaction record. The function should return `True` if at least one interested item is found in the transaction record, and `False` otherwise. Function Signature ```python def contains_interested_item(transaction: list[str], interested_items: list[str]) -> bool: pass ``` Input - `transaction`: A list of strings, where each string represents an item bought in a transaction. - `interested_items`: A list of strings, where each string represents an item of interest. Output - Returns a boolean: - `True` if the transaction contains at least one item from the interested items list. - `False` otherwise. Example ```python assert contains_interested_item([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"banana\\", \\"orange\\"]) == True assert contains_interested_item([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"orange\\", \\"grape\\"]) == False assert contains_interested_item([\\"milk\\", \\"bread\\"], [\\"bread\\", \\"milk\\", \\"cheese\\"]) == True assert contains_interested_item([\\"milk\\", \\"bread\\"], [\\"cheese\\", \\"butter\\"]) == False ``` Constraints - The function must run in O(n) time complexity, where n is the length of the longer list between `transaction` and `interested_items`. - Each item in the input lists is a non-empty string containing only lowercase letters. - Transaction lists and interested item lists can have up to 10,000 items. Requirements - Implement the function `contains_interested_item` as described. - Ensure the function passes basic tests to verify its correctness.","solution":"def contains_interested_item(transaction: list[str], interested_items: list[str]) -> bool: Check if any item from the list of interested items is present in the transaction record. :param transaction: List of strings where each string is an item in the transaction. :param interested_items: List of strings where each string is an item of interest. :return: True if any item from interested_items is found in transaction, False otherwise. # Convert the list of transaction items into a set for O(1) lookup time transaction_set = set(transaction) # Loop through the interested items and check if any is in the transaction set for item in interested_items: if item in transaction_set: return True return False"},{"question":"# Coding Assessment Question You are given a list of integers `nums` representing a series of elevations on a landscape, where each integer corresponds to the height of that point. The goal is to determine the maximum amount of water that can be trapped between the elevations after a rain. Write a function `trap_water` that calculates the total amount of trapped water. **Function Signature**: ```python def trap_water(nums: list[int]) -> int: ``` **Input**: * A list `nums` of non-negative integers representing the elevation map. * Example: ```python nums = [0,1,0,2,1,0,1,3,2,1,2,1] ``` **Output**: * An integer representing the total amount of trapped water. * Example: ```python 6 # Corresponding to the input \'nums\' ``` **Constraints**: * The length of `nums` will not exceed 10^4. * Each element in `nums` will be an integer between 0 and 10^5. # Performance Requirements * Your implementation should optimize for both time and space, considering the constraints provided. # Examples ```python assert trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 assert trap_water([4,2,0,3,2,5]) == 9 assert trap_water([0,0,0,0]) == 0 ``` In solving this problem, make sure to consider efficient strategies, such as two-pointer approaches or dynamic programming, to minimize computational overhead while handling various edge cases accurately.","solution":"def trap_water(nums): Calculate the total amount of trapped water in the elevation map represented by nums. :param nums: List[int] - list of non-negative integers representing elevation heights :return: int - total amount of trapped water if not nums or len(nums) < 3: return 0 left, right = 0, len(nums) - 1 left_max, right_max = nums[left], nums[right] trapped_water = 0 while left < right: if nums[left] < nums[right]: left += 1 left_max = max(left_max, nums[left]) trapped_water += left_max - nums[left] else: right -= 1 right_max = max(right_max, nums[right]) trapped_water += right_max - nums[right] return trapped_water"},{"question":"# Question: Reverse Words in a String Given a string `s`, implement a function `reverse_words(s: str) -> str` that reverses the order of words in the string while preserving whitespace and initial word order within each word. Function Signature: ```python def reverse_words(s: str) -> str: pass ``` # Input: * A string `s` where `1 <= len(s) <= 10^4`. The string consists only of spaces and alphanumeric characters. # Output: * A string with the words in reverse order but each word should maintain its original order within the word. # Constraints: * Leading and trailing whitespace should be removed before reversing the words. * Multiple spaces between words should be reduced to a single space after reversing. # Example: ```python assert reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" assert reverse_words(\\" hello world \\") == \\"world hello\\" assert reverse_words(\\"a good example\\") == \\"example good a\\" ``` # Performance Requirements: * The function should operate efficiently within the provided constraints, particularly considering the potential length of the string. **Hint**: Consider string methods and operations that can help with splitting, trimming, and joining words effectively to achieve the desired output. # Scenario: Imagine you are working on a text processing utility for a large-scale web application. The function you write will help in reformatting user input into a standardized form for storage and retrieval. Efficiency and handling different whitespace scenarios are crucial to maintaining performance in a high-traffic environment. Validate your solution against various edge cases, including strings with multiple spaces and leading/trailing spaces.","solution":"def reverse_words(s: str) -> str: Reverses the order of words in the string while preserving whitespace and initial word order within each word. # Split the string by spaces and filter out empty strings words = s.strip().split() # Reverse the list of words words.reverse() # Join the reversed list of words with a single space return \' \'.join(words)"},{"question":"Question # Graph Shortest Path with Dijkstra’s Algorithm You are designing a navigation system that helps users find the shortest path between locations in a city. Given a set of locations and roads connecting them, with each road having a certain distance, you need to help users determine the shortest path from their current location to a desired destination. Your objective is to implement Dijkstra’s algorithm which should: 1. Build a graph based on the given locations and roads. 2. Use Dijkstra’s algorithm to find the shortest path from the starting location to the target location. # Requirements * Implement the function `shortest_path(num_locations: int, roads: List[Tuple[int, int, int]], start: int, target: int) -> List[int]`. * **Input**: - `num_locations`: An integer representing the number of locations (nodes) in the graph, numbered from `0` to `num_locations - 1`. - `roads`: A list of tuples where each tuple `(u, v, d)` indicates there is a road from location `u` to location `v` with a distance `d`. - `start`: An integer representing the starting location. - `target`: An integer representing the target location. * **Output**: - A list of integers representing the sequence of locations in the shortest path from the starting location to the target location. # Constraints 1. The number of locations will not exceed 10^4. 2. The number of roads will not exceed 10^5. 3. Distances will be positive integers. # Example ```python shortest_path( 5, [(0, 1, 10), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 1, 4), (2, 3, 8), (2, 4, 2), (3, 4, 7), (4, 3, 9)], 0, 3 ) ``` Output: `[0, 2, 1, 3]` # Performance Requirement The solution should operate within (O((V + E) log V)), where (V) is the number of locations (nodes) and (E) is the number of roads (edges). # Implementation Guide 1. **Graph Representation**: Use an appropriate data structure to represent the graph, such as an adjacency list. 2. **Priority Queue**: Utilize a priority queue (e.g., heap) to manage the nodes to be explored, ensuring the node with the smallest tentative distance is processed next. 3. **Dijkstra\'s Algorithm**: Implement the algorithm to maintain the shortest path from the start location to the target location. Your implementation should adhere closely to the principles of Dijkstra\'s algorithm and be optimized for large-scale inputs. Enjoy coding!","solution":"import heapq from typing import List, Tuple def shortest_path(num_locations: int, roads: List[Tuple[int, int, int]], start: int, target: int) -> List[int]: # Step 1: Build the graph as an adjacency list graph = {i: [] for i in range(num_locations)} for u, v, d in roads: graph[u].append((v, d)) graph[v].append((u, d)) # Assuming undirected graph, omit if directed # Step 2: Initialize data structures for Dijkstra\'s algorithm distances = {node: float(\'inf\') for node in range(num_locations)} distances[start] = 0 priority_queue = [(0, start)] predecessors = {node: None for node in range(num_locations)} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reach the target, no need to continue if current_node == target: break # Check next nodes for neighbor, weight in graph[current_node]: distance = current_distance + weight # If a shorter path to `neighbor` is found if distance < distances[neighbor]: distances[neighbor] = distance predecessors[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # Step 3: Reconstruct the shortest path path = [] step = target while step is not None: path.insert(0, step) step = predecessors[step] if path[0] == start: return path else: return [] # No path found"},{"question":"# Coding Assessment Question Problem Statement You are working on a string processing project and need to manipulate and analyze text data in various ways. Implement two functions: one that finds and returns all palindromic substrings of a given string and another that counts the occurrences of each character in the string. **Function Signatures** ```python def find_palindromic_substrings(s: str) -> List[str]: pass def count_character_occurrences(s: str) -> Dict[str, int]: pass ``` **Input/Output Description** 1. `s` (str): A string consisting of lowercase and uppercase English letters. The length of `s` will be between 1 and 10^3. The function `find_palindromic_substrings` should return a list of all unique palindromic substrings present in the input string. A substring is considered palindromic if it reads the same forwards and backwards. The function `count_character_occurrences` should return a dictionary where the keys are the characters of the string and the values are the counts of each character. **Constraints** * The input string `s` will contain only alphabetic characters (both lowercase and uppercase). Example ```python # Example of find_palindromic_substrings s1 = \\"abccba\\" print(find_palindromic_substrings(s1)) # Output: [\'a\', \'b\', \'c\', \'cc\', \'bccb\', \'abccba\'] # Example of count_character_occurrences s2 = \\"banana\\" print(count_character_occurrences(s2)) # Output: {\'b\': 1, \'a\': 3, \'n\': 2} ``` Notes 1. Palindromic substrings should be unique in the output. 2. Consider performance and optimize where possible, particularly for the `find_palindromic_substrings` function. 3. Ensure the functions perform correctly by writing both common and edge case tests.","solution":"from typing import List, Dict def find_palindromic_substrings(s: str) -> List[str]: Finds and returns all unique palindromic substrings of the input string. def is_palindrome(sub: str) -> bool: return sub == sub[::-1] palindromes = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] if is_palindrome(substring): palindromes.add(substring) return list(palindromes) def count_character_occurrences(s: str) -> Dict[str, int]: Counts the occurrences of each character in the input string and returns a dictionary. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"# Coding Assessment Question **Context**: You are tasked with implementing a feature for a logistics application that helps in route optimization. For this purpose, you need to identify the longest subsequence in a list of delivery truck speeds that is strictly increasing. A subsequence is derived by deleting some or no elements of the list without changing the order of the remaining elements. Your goal is to find the length of this longest increasing subsequence. **Task**: Write a function `longest_increasing_subsequence` that takes a list of integers representing delivery truck speeds and returns the length of the longest subsequence that is strictly increasing. Your algorithm should operate in O(n log n) time complexity. **Function Signature**: ```python def longest_increasing_subsequence(speeds: list[int]) -> int: ``` **Input**: * `speeds` - a list of integers representing truck speeds, where `1 <= len(speeds) <= 10^5` and `-10^9 <= speeds[i] <= 10^9`. **Output**: * Return the length of the longest strictly increasing subsequence from the list. **Constraints**: * The list can have duplicate values, but they should not be counted in the increasing subsequence. **Example**: ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6 >>> longest_increasing_subsequence([-1, 0, 3, 5, 2, 3]) 4 ``` **Note**: * You may use external libraries for efficient sequence processing. * Your solution must be optimal in terms of both time and space complexity.","solution":"from bisect import bisect_left def longest_increasing_subsequence(speeds: list[int]) -> int: Returns the length of the longest strictly increasing subsequence. if not speeds: return 0 # This will store the smallest possible end element for all increasing subsequences # of length i+1 in subsequence_end. subsequence_end = [] for speed in speeds: # Use binary search to find the first element in subsequence_end that is >= speed pos = bisect_left(subsequence_end, speed) # If pos equals the length of subsequence_end, it means speed is larger than # any element in subsequence_end and can be added to it to extend the longest # subsequence found so far. if pos == len(subsequence_end): subsequence_end.append(speed) else: subsequence_end[pos] = speed return len(subsequence_end)"},{"question":"# Product of Matrix Diagonal Elements You are tasked with writing a function that computes the product of the diagonal elements of a square matrix. The function should validate inputs correctly and handle various edge cases. # Function Definition Implement the following function: ```python def diagonal_product(matrix: List[List[Union[int, float]]]) -> Union[int, float]: pass ``` # Input Parameters * **matrix** (List of Lists of int or float): A square matrix (2D list) containing integers or floating-point numbers. # Output * **Union[int, float]**: The product of the diagonal elements of the matrix. # Constraints * You must handle edge cases where the matrix is not square by returning 0. * If the matrix is empty or if its diagonal element(s) is(are) 0, return 0. * Ensure the function correctly processes matrices of different sizes and types (int or float). # Performance Requirements The function should efficiently handle matrices of sizes up to 1000x1000. # Example ```python # Example usage and output print(diagonal_product([[2, 3], [4, 5]])) # Output: 10 (2 * 5) print(diagonal_product([[1, 0, 0], [0, 2, 0], [0, 0, 3]])) # Output: 6 (1 * 2 * 3) print(diagonal_product([[1.5, 0], [0, 3.5]])) # Output: 5.25 (1.5 * 3.5) print(diagonal_product([[1, 2], [3, 4], [5, 6]])) # Output: 0 (Matrix is not square) print(diagonal_product([[1, 0], [0, 0]])) # Output: 0 (Diagonal element is zero) print(diagonal_product([])) # Output: 0 (Matrix is empty) ``` # Notes * The function should be robust and handle varying matrix sizes and types. * Consider edge cases for input validation to ensure the function\'s reliability. This question examines the candidate\'s understanding of matrix operations, input validation, and edge case handling in Python.","solution":"from typing import List, Union def diagonal_product(matrix: List[List[Union[int, float]]]) -> Union[int, float]: Calculate the product of the diagonal elements of a square matrix. :param matrix: A 2D list representation of the square matrix. :return: The product of the diagonal elements, or 0 for invalid input cases. # Check if matrix is empty if not matrix: return 0 # Check if matrix is square size = len(matrix) if any(len(row) != size for row in matrix): return 0 # Calculate the product of diagonal elements product = 1 for i in range(size): # Check for diagonal element being zero if matrix[i][i] == 0: return 0 product *= matrix[i][i] return product"},{"question":"**Scenario**: You are working on a web application that displays weather information for various cities. You need to fetch and process weather data efficiently while ensuring that the application remains responsive even if the data provider\'s API experiences issues. **Task**: Create a class `WeatherDataFetcher` with the following methods: 1. `fetch_current_temperature(city: str) -> float`: Fetch the current temperature for a given city. 2. `fetch_weekly_forecast(city: str) -> dict`: Fetch the daily weather forecast for the next seven days for a specified city. The forecast should be a dictionary with dates as keys and temperatures as values. 3. `fetch_extreme_temperatures(city: str) -> tuple`: Fetch the highest and lowest temperatures recorded in the past 24 hours for a given city. * Expected input and output formats: * `fetch_current_temperature(city)` -> float * `fetch_weekly_forecast(city)` -> `{ \\"YYYY-MM-DD\\": float, ... }` * `fetch_extreme_temperatures(city)` -> (float, float) * Constraints: * The API responses might occasionally be delayed or fail; handle these situations gracefully. * Assume the API base URL is \\"https://api.weatherapi.com/v1\\". * Ensure that the city inputs are valid and handled correctly. Below is the starting code for the class: ```python import requests class WeatherDataFetcher: BASE_URL = \\"https://api.weatherapi.com/v1\\" API_KEY = \\"your_api_key_here\\" # Replace with your actual API key def fetch_current_temperature(self, city: str) -> float: # Implement the logic to get the current temperature for the given city. pass def fetch_weekly_forecast(self, city: str) -> dict: # Implement the logic to get the weekly weather forecast for the given city. pass def fetch_extreme_temperatures(self, city: str) -> tuple: # Implement the logic to get the highest and lowest temperatures in the past 24 hours for the given city. pass ``` This question aligns with the first question in terms of style, complexity, and scope by requiring students to interact with an external API, handle potential errors, and ensure valid input handling. The problem is different but tests similar skills, such as making API calls, processing responses, and implementing robust, fail-safe code.","solution":"import requests from requests.exceptions import RequestException from datetime import datetime, timedelta class WeatherDataFetcher: BASE_URL = \\"https://api.weatherapi.com/v1\\" API_KEY = \\"your_api_key_here\\" # Replace with your actual API key def fetch_current_temperature(self, city: str) -> float: try: response = requests.get(f\\"{self.BASE_URL}/current.json\\", params={\\"key\\": self.API_KEY, \\"q\\": city}) response.raise_for_status() data = response.json() return data[\'current\'][\'temp_c\'] except RequestException: print(f\\"Failed to fetch current temperature for {city}\\") return None def fetch_weekly_forecast(self, city: str) -> dict: try: response = requests.get(f\\"{self.BASE_URL}/forecast.json\\", params={\\"key\\": self.API_KEY, \\"q\\": city, \\"days\\": 7}) response.raise_for_status() data = response.json() forecast = data[\'forecast\'][\'forecastday\'] result = {} for day in forecast: date = day[\'date\'] temp = day[\'day\'][\'avgtemp_c\'] result[date] = temp return result except RequestException: print(f\\"Failed to fetch weekly forecast for {city}\\") return None def fetch_extreme_temperatures(self, city: str) -> tuple: try: # Get current datetime and 24 hours ago datetime now = datetime.utcnow() last_24_hours = now - timedelta(hours=24) response = requests.get(f\\"{self.BASE_URL}/history.json\\", params={\\"key\\": self.API_KEY, \\"q\\": city, \\"dt\\": last_24_hours.strftime(\'%Y-%m-%d\')}) response.raise_for_status() data = response.json() temps = [hourly[\'temp_c\'] for hourly in data[\'forecast\'][\'forecastday\'][0][\'hour\']] return (max(temps), min(temps)) except RequestException: print(f\\"Failed to fetch extreme temperatures for {city}\\") return None"},{"question":"# Matrix Rotation Challenge Problem Description You are provided with a square matrix (2D list) of integers. Your task is to rotate the matrix 90 degrees clockwise. The function should modify the matrix in place and return nothing. Function Signature Write a Python function `rotate_matrix(matrix: List[List[int]]) -> None` that takes one parameter: - `matrix`: A list of lists representing the square matrix to be rotated. The length of each sublist is the same as the number of sublists, representing an NxN matrix. Return The function should not return anything and should modify the matrix in place. Constraints - The size of the matrix `N` will be between 1 and 50. Example ```python def rotate_matrix(matrix: List[List[int]]) -> None: # Your code here # Example Test Cases matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) print(matrix1) # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] matrix2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix2) print(matrix2) # Output: [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] ``` In these examples, the input matrices are rotated 90 degrees clockwise in place. Requirements - Implement the `rotate_matrix` function to solve the problem using the provided constraints. - Avoid using extra space for another matrix of the same size, ensuring optimal space complexity (O(1) additional space).","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Task: Non-Decreasing Array Check **Scenario**: In this task, you will determine if it\'s possible to make a given array non-decreasing by modifying at most one element. A non-decreasing array is one in which each element is less than or equal to the next element. **Function Details**: * **Function Name**: `check_non_decreasing` * **Input Parameters**: - `arr` (List[int]): A list of integers representing the array to be checked. * **Output**: - A boolean value, `True` if it is possible to modify at most one element to make the array non-decreasing, and `False` otherwise. * **Error Handling**: - If an empty list is provided, raise a `ValueError` with the message \\"No elements in the array\\". * **Example Usage**: ```python >>> check_non_decreasing([10, 5, 7]) True >>> check_non_decreasing([2, 3, 3, 2, 4]) True >>> check_non_decreasing([4, 2, 1]) False >>> check_non_decreasing([1, 2, 3, 4, 5]) True >>> check_non_decreasing([]) Traceback (most recent call last): ... ValueError: No elements in the array ``` # Constraints: - The number of elements in the array (n) will be in the range of 1 ≤ n ≤ 10^5. - Each element in the array will be in the range of -10^5 ≤ arr[i] ≤ 10^5. Consider the edge cases and ensure your solution handles them efficiently. --- **Notes**: - This problem requires efficient handling of array manipulations, specifically focusing on determining the feasibility of converting an array to a non-decreasing sequence with minimal modifications.","solution":"def check_non_decreasing(arr): Determines if it is possible to make the array non-decreasing by modifying at most one element. Parameters: arr (List[int]): A list of integers representing the array to be checked. Returns: bool: True if it is possible to modify at most one element to make the array non-decreasing, False otherwise. Raises: ValueError: If an empty list is provided. if not arr: raise ValueError(\\"No elements in the array\\") n = len(arr) cnt = 0 for i in range(n - 1): if arr[i] > arr[i + 1]: if cnt == 1: return False cnt += 1 if i == 0 or arr[i - 1] <= arr[i + 1]: arr[i] = arr[i + 1] else: arr[i + 1] = arr[i] return True"},{"question":"# Palindromic Paths in a Matrix Problem Statement You are given a 2D matrix of characters consisting of lowercase letters. Your task is to find the number of distinct paths from the top-left corner to the bottom-right corner in which the characters along the path form a palindrome when concatenated in order. You can only move right or down at each step. # Function Signature ```python def palindromic_paths(matrix: List[List[str]]) -> int: pass ``` # Input * `matrix` (List[List[str]]): A 2D list of characters, with (1 leq text{len(matrix)} leq 10) and (1 leq text{len(matrix[0])} leq 10). # Output * Return the number of distinct palindromic paths from the top-left to the bottom-right of the matrix. # Constraints * The matrix contains only lowercase English letters. * A path is valid if it always moves either right or down. * The characters in the path, when concatenated, should be a palindrome. # Example ```python matrix = [ [\'a\', \'a\', \'a\'], [\'b\', \'d\', \'a\'], [\'a\', \'d\', \'a\'] ] assert palindromic_paths(matrix) == 2 ``` # Notes * For the given example, the two palindromic paths are: \\"aaa\\" and \\"ada\\". * The function should efficiently handle the computation considering the constraints. * Consider dynamic programming or memoization techniques to optimize the solution. # Hints * A helper function to check if a string is a palindrome may be useful. * Recursively explore paths and prune paths that cannot possibly form a palindrome early.","solution":"def palindromic_paths(matrix): # Define a helper function to check if a string is a palindrome def is_palindrome(s): return s == s[::-1] # Get the dimensions of the matrix m, n = len(matrix), len(matrix[0]) # A memoization dictionary to store valid palindromic paths memo = {} def dfs(x, y, path): # If we reach the bottom-right corner, check if it\'s a palindrome if x == m - 1 and y == n - 1: return 1 if is_palindrome(path + matrix[x][y]) else 0 # Memoization check if (x, y, path) in memo: return memo[(x, y, path)] # Initialize count of palindromic paths to 0 count = 0 # Move right if possible if y + 1 < n: count += dfs(x, y + 1, path + matrix[x][y]) # Move down if possible if x + 1 < m: count += dfs(x + 1, y, path + matrix[x][y]) # Store the result in memoization dictionary memo[(x, y, path)] = count return count # Start the DFS from the top-left corner return dfs(0, 0, \\"\\")"},{"question":"# Coding Assessment Question Objective: Write a function to parse, evaluate, and compare two boolean algebra expressions given in infix notation. The function should return whether the two expressions are logically equivalent. Description: You are given two boolean algebra expressions in infix notation. Your task is to write a function `are_boolean_expressions_equivalent` that checks if the two expressions are logically equivalent. For simplification, assume the expressions contain only the following operators: AND (`&`), OR (`|`), and NOT (`!`). The variables in the expressions are single lowercase letters. Input: - Two strings `expr1` and `expr2` representing the boolean expressions. Output: - Return a boolean value `True` if the expressions are logically equivalent, and `False` otherwise. Constraints: - Each expression will contain between 1 to 100 characters. - Expressions will be valid and only include lowercase letters, `&`, `|`, `!`, and parentheses `()`. - Assume all variables are single lowercase letters and are consistent across both expressions. Example: ```python expr1 = \\"(a & b) | !c\\" expr2 = \\"(!c) | (b & a)\\" expected_output = True expr1 = \\"a & (b | c)\\" expr2 = \\"(a & b) | c\\" expected_output = False ``` Function Signature: ```python def are_boolean_expressions_equivalent(expr1: str, expr2: str) -> bool: pass ``` Implementation Instructions: 1. Parse the input expressions and convert them into boolean functions. 2. Use a truth table or other evaluation method to compare the logical equivalence of the expressions. 3. Ensure proper handling of string manipulation and logical operators. 4. Consider edge cases such as different variable occurrences and operator precedence. This question will assess your ability to handle expressions, understand boolean algebra, and implement parsing and evaluation logic accurately.","solution":"from itertools import product import re def parse_expression(expr): # Function to parse and convert infix expression to Postfix (RPN) precedence = {\'!\': 3, \'&\': 2, \'|\': 1, \'(\': 0, \')\': 0} output = [] operators = [] def greater_precedence(op1, op2): return precedence[op1] > precedence[op2] tokens = re.findall(r\'[a-z]+|[&|)(!]\', expr) for token in tokens: if token.isalpha(): output.append(token) elif token == \'(\': operators.append(token) elif token == \')\': top_token = operators.pop() while top_token != \'(\': output.append(top_token) top_token = operators.pop() else: while (operators and operators[-1] != \'(\' and greater_precedence(operators[-1], token)): output.append(operators.pop()) operators.append(token) while operators: output.append(operators.pop()) return output def evaluate_postfix(postfix, values): stack = [] for token in postfix: if token.isalpha(): stack.append(values[token]) elif token == \'!\': operand = stack.pop() stack.append(not operand) else: b = stack.pop() a = stack.pop() if token == \'&\': stack.append(a and b) elif token == \'|\': stack.append(a or b) return stack.pop() def are_boolean_expressions_equivalent(expr1: str, expr2: str) -> bool: # Extract all variables in the expressions variables = sorted(set(re.findall(r\'[a-z]\', expr1 + expr2))) postfix_expr1 = parse_expression(expr1) postfix_expr2 = parse_expression(expr2) # Generate all possible truth values for the variables for values in product([False, True], repeat=len(variables)): value_mapping = dict(zip(variables, values)) if evaluate_postfix(postfix_expr1, value_mapping) != evaluate_postfix(postfix_expr2, value_mapping): return False return True"},{"question":"# Question Title: Weather Data Aggregator with Caching and Rate Limiting # Scenario You are required to develop a script that retrieves current weather data for a list of cities from a weather API. To optimize performance and avoid exceeding API rate limits, implement caching to store previously fetched data, and make use of rate limiting to control the frequency of API requests. # Requirements 1. **Data Fetching and Parsing**: - Use the `requests` library to fetch the weather data for each city from a weather API like OpenWeatherMap. - Extract the temperature, humidity, and weather description from the JSON response. - Organize the extracted data into a named tuple `WeatherData` with fields `temperature`, `humidity`, and `description`. 2. **Caching**: - Implement an in-memory cache to store weather data for cities recently fetched. - The cache should expire entries that are older than 10 minutes. 3. **Rate Limiting**: - Ensure the script does not make more than 60 API requests per minute. - Implement a rate limiting mechanism to manage the frequency of API calls accordingly. 4. **Input and Output**: - The function should accept a list of city names. - It should return a dictionary where the keys are city names and the values are `WeatherData` named tuples containing the current weather information. # Function Signature Implement the following function: ```python from typing import List, Dict def get_weather_data(cities: List[str]) -> Dict[str, WeatherData]: pass ``` # Input The function `get_weather_data` takes a list of city names as input. # Output The function returns a dictionary where: - Keys are city names. - Values are `WeatherData` named tuples containing: - `temperature`: Current temperature in degrees Celsius. - `humidity`: Current humidity percentage. - `description`: Brief description of the current weather condition. # Constraints - Use the `requests` library to handle API requests. - Implement caching to store weather data for cities recently fetched, with a 10-minute expiration time. - Implement rate limiting to ensure no more than 60 API requests are made per minute. # Example Usage ```python cities = [\\"New York\\", \\"London\\", \\"Paris\\", \\"Tokyo\\"] weather_data = get_weather_data(cities) for city, data in weather_data.items(): print(f\\"{city}: {data.temperature}°C, {data.humidity}%, {data.description}\\") ``` Expected output (subject to current weather data): ``` New York: 22°C, 60%, Clear sky London: 18°C, 70%, Light rain Paris: 19°C, 65%, Partly cloudy Tokyo: 25°C, 55%, Sunny ``` Write your implementation of `get_weather_data` and ensure it meets the requirements specified above.","solution":"import requests import time from collections import namedtuple from typing import List, Dict from cachetools import TTLCache # Define the WeatherData named tuple WeatherData = namedtuple(\'WeatherData\', [\'temperature\', \'humidity\', \'description\']) # Initialize cache with a TTL of 10 minutes (600 seconds) cache = TTLCache(maxsize=100, ttl=600) # Function to get weather data from OpenWeatherMap API def fetch_weather_data(city: str) -> WeatherData: API_KEY = \'your_api_key\' # Substitute your actual OpenWeatherMap API key here url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric\\" response = requests.get(url) data = response.json() temperature = data[\'main\'][\'temp\'] humidity = data[\'main\'][\'humidity\'] description = data[\'weather\'][0][\'description\'] return WeatherData(temperature, humidity, description) # Implement rate limiting control last_call = time.time() # Fetch weather data for a list of cities with caching and rate limiting def get_weather_data(cities: List[str]) -> Dict[str, WeatherData]: global last_call weather_data = {} for city in cities: # Check cache first if city in cache: weather_data[city] = cache[city] continue # Rate limiting current_time = time.time() if current_time - last_call < 1: time.sleep(1 - (current_time - last_call)) # Fetch weather data result = fetch_weather_data(city) weather_data[city] = result # Update cache cache[city] = result # Update last call timestamp last_call = time.time() return weather_data"},{"question":"# Question Design a function to simulate a simplified file system that performs basic file and directory operations. The file system should support the following operations: 1. Create a new directory. 2. Create a new file with specified content. 3. Read the content of a file. 4. List the content of a directory. 5. Delete a file or a directory. Your task is to implement the core functionalities to manage these operations in a structured and efficient manner. # Function Requirements create_directory * **Input**: A string `path` representing the full directory path. * **Output**: None. This function should create an empty directory at the specified path. create_file * **Input**: A string `path` representing the full file path and a string `content` representing the file content. * **Output**: None. This function should create a file with the given content at the specified path. read_file * **Input**: A string `path` representing the full file path. * **Output**: A string representing the content of the file at the specified path. list_directory * **Input**: A string `path` representing the full directory path. * **Output**: A list of strings representing the names of files and directories within the specified directory. delete * **Input**: A string `path` representing the full path to the file or directory to be deleted. * **Output**: None. This function should delete the file or directory at the specified path. # Constraints - Assume that there are no permission issues with file and directory operations. - If attempting to read from, list, or delete a non-existent path, the function should raise an appropriate error. - Directory paths should end with a `/`. # Example ```python # Create a new directory create_directory(\'/home/user/docs/\') # Create a new file create_file(\'/home/user/docs/file1.txt\', \'Hello, world!\') # Read the file content content = read_file(\'/home/user/docs/file1.txt\') print(content) # Output: \'Hello, world!\' # List directory content dir_content = list_directory(\'/home/user/docs/\') print(dir_content) # Output: [\'file1.txt\'] # Delete a file delete(\'/home/user/docs/file1.txt\') # List directory content after deletion dir_content = list_directory(\'/home/user/docs/\') print(dir_content) # Output: [] # Delete a directory delete(\'/home/user/docs/\') ``` Notes: - The functions should maintain an internal representation of the file system since you should not interact with the real file system. - Ensure edge cases, such as attempting operations on non-existent paths, are handled gracefully.","solution":"class FileSystemError(Exception): pass class SimpleFileSystem: def __init__(self): self.file_system = {} def create_directory(self, path): if path in self.file_system: raise FileSystemError(\\"Directory already exists\\") self.file_system[path] = {} def create_file(self, path, content): directory_path = \'/\'.join(path.split(\'/\')[:-1]) + \'/\' if directory_path not in self.file_system: raise FileSystemError(\\"Directory does not exist\\") self.file_system[directory_path][path.split(\'/\')[-1]] = content def read_file(self, path): directory_path = \'/\'.join(path.split(\'/\')[:-1]) + \'/\' if directory_path not in self.file_system: raise FileSystemError(\\"Directory does not exist\\") if path.split(\'/\')[-1] not in self.file_system[directory_path]: raise FileSystemError(\\"File does not exist\\") return self.file_system[directory_path][path.split(\'/\')[-1]] def list_directory(self, path): if path not in self.file_system: raise FileSystemError(\\"Directory does not exist\\") return list(self.file_system[path].keys()) def delete(self, path): directory_path = \'/\'.join(path.split(\'/\')[:-1]) + \'/\' if path in self.file_system: # Deleting a directory del self.file_system[path] elif directory_path in self.file_system and path.split(\'/\')[-1] in self.file_system[directory_path]: # Deleting a file del self.file_system[directory_path][path.split(\'/\')[-1]] else: raise FileSystemError(\\"Path does not exist\\")"},{"question":"# **Text Search with Relevance Scoring** You are tasked with implementing a search engine\'s core functionality that searches through a list of documents and returns those most relevant to a given query. The relevance of each document to the query is measured by the frequency of the query\'s words in the document combined with word rarity across the document set. **Function Signature**: ```python def search_documents(documents: List[str], query: str) -> List[str]: pass ``` **Input**: * `documents`: A list of strings, with each string being a document. * `query`: A single string containing the search query. **Output**: * A list of strings representing the documents in descending order of relevance to the query. If two documents have the same relevance, they should be returned in the order they appeared in the input list. **Constraints**: * Assume there are at most `1000` documents, each with at most `1000` words. * Words in the documents and query are case-insensitive and contain only alphabetic characters. **Example**: ```python documents = [ \\"machine learning models are great\\", \\"learning models adapt based on data\\", \\"data science and machine learning models\\", \\"introduction to machine learning\\", \\"deep learning models are a subset of machine learning\\" ] query = \\"machine learning models\\" result = search_documents(documents, query) assert result == [ \\"machine learning models are great\\", \\"data science and machine learning models\\", \\"introduction to machine learning\\", \\"deep learning models are a subset of machine learning\\", \\"learning models adapt based on data\\" ] ``` **Note**: - The relevance score is calculated based on term frequency-inverse document frequency (TF-IDF). - Consider preprocessing steps such as lowercasing words and tokenizing both query and documents. - Ensure your implementation is efficient in terms of both time and space complexity, handling edge cases and variability within input sizes as specified in the constraints. **Hints**: 1. Compute the term frequency (TF) of each word in each document. 2. Compute the inverse document frequency (IDF) of each word across all documents. 3. Calculate the TF-IDF score for each document relative to the query. 4. Sort and return the documents based on these scores. **Additional Information**: - The TF-IDF score for a term `t` is calculated as: - `TF(t, d) = (Number of times term t appears in document d) / (Total number of terms in document d)` - `IDF(t) = log_e(Total number of documents / Number of documents containing term t)` - `TF-IDF(t, d) = TF(t, d) * IDF(t)`","solution":"from typing import List import math from collections import defaultdict, Counter def search_documents(documents: List[str], query: str) -> List[str]: def tokenize(text): return text.lower().split() def compute_tf(document_tokens): term_count = Counter(document_tokens) doc_length = len(document_tokens) return {term: count / doc_length for term, count in term_count.items()} def compute_idf(documents_tokens): num_documents = len(documents_tokens) document_frequency = defaultdict(int) for tokens in documents_tokens: unique_tokens = set(tokens) for token in unique_tokens: document_frequency[token] += 1 return {term: math.log(num_documents / df) for term, df in document_frequency.items()} def compute_tf_idf(document_tf, idf_scores): return {term: tf * idf_scores.get(term, 0) for term, tf in document_tf.items()} query_tokens = tokenize(query) documents_tokens = [tokenize(doc) for doc in documents] document_tfs = [compute_tf(tokens) for tokens in documents_tokens] idf_scores = compute_idf(documents_tokens) document_scores = [] for i, doc_tf in enumerate(document_tfs): tf_idf = compute_tf_idf(doc_tf, idf_scores) relevance_score = sum(tf_idf.get(term, 0) for term in query_tokens) document_scores.append((relevance_score, documents[i])) document_scores.sort(key=lambda x: x[0], reverse=True) return [doc for _, doc in document_scores]"},{"question":"# Coding Assessment Question You are tasked with creating a function that processes and filters a list of dictionaries containing employee information. The goal is to extract employee details based on specific criteria and write test cases to ensure the function\'s correctness. Scenario You need to write a function `filter_employees` that filters employees based on their department and salary threshold. Additionally, you should write test cases to validate the function\'s behavior under various conditions. Implementation Details **Function: filter_employees(employees: list, department: str, min_salary: int) -> list** * **Inputs**: - `employees` (list): A list of dictionaries, each containing employee information with keys `name`, `department`, and `salary`. - `department` (str): The department to filter employees by. - `min_salary` (int): The minimum salary threshold. * **Outputs**: - A list of dictionaries containing information of employees who belong to the specified department and have a salary greater than or equal to the minimum salary threshold. **Test Cases Function** * Write a function `test_filter_employees` to test `filter_employees`. * Ensure to cover edge cases such as an empty list of employees or no employees meeting the criteria. Example: ```python def filter_employees(employees, department, min_salary): filtered = [] for employee in employees: if employee[\'department\'] == department and employee[\'salary\'] >= min_salary: filtered.append(employee) return filtered def test_filter_employees(): employees = [ {\\"name\\": \\"John\\", \\"department\\": \\"HR\\", \\"salary\\": 50000}, {\\"name\\": \\"Jane\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70000}, {\\"name\\": \\"Doe\\", \\"department\\": \\"HR\\", \\"salary\\": 45000}, {\\"name\\": \\"Smith\\", \\"department\\": \\"Marketing\\", \\"salary\\": 60000}, ] result = filter_employees(employees, \\"HR\\", 48000) assert len(result) == 1 assert result[0][\'name\'] == \\"John\\" result = filter_employees(employees, \\"Engineering\\", 60000) assert len(result) == 1 assert result[0][\'name\'] == \\"Jane\\" result = filter_employees(employees, \\"Marketing\\", 60000) assert len(result) == 1 assert result[0][\'name\'] == \\"Smith\\" result = filter_employees(employees, \\"HR\\", 60000) assert len(result) == 0 result = filter_employees([], \\"HR\\", 50000) assert len(result) == 0 print(\\"All test cases pass\\") test_filter_employees() ``` In the above example, you need to ensure the correctness of `filter_employees` by developing appropriate test cases and assertions. **Constraints**: * The input list of employees could be of variable length (including empty). * Ensure the function handles edge cases such as no employees meeting the criteria or having different department names. * Use Python\'s standard data structures and control flow statements to solve the problem.","solution":"def filter_employees(employees, department, min_salary): Filters employees based on department and salary threshold. Parameters: employees (list of dict): List of employee dictionaries with keys \'name\', \'department\', \'salary\'. department (str): The department to filter by. min_salary (int): The minimum salary threshold. Returns: list of dict: Filtered list of employees meeting the criteria. filtered = [] for employee in employees: if employee[\'department\'] == department and employee[\'salary\'] >= min_salary: filtered.append(employee) return filtered"},{"question":"# Question You are given two classes, `Square` and `Rectangle`, which respectively represent squares and rectangles with their side lengths and dimensions. However, there is another important use case: calculating the area of shapes with multiple sides, such as polygons. Implement a class named `Polygon` that calculates the area of a regular polygon given the number of sides and the length of each side. The class should include methods to: - **Initialize** the polygon\'s properties. - **Compute the area** using the given formula for the area of a regular polygon. # Requirements * **Class Definition**: ```python class Polygon: def __init__(self, num_sides: int, side_length: float): def area(self) -> float: ``` * **Constructor Parameters**: - `num_sides`: An integer representing the number of sides of the polygon. - `side_length`: A float representing the length of each side. * **Method**: - `area`: Computes and returns the area of the polygon using the formula: text{Area} = frac{n times s^2}{4 times tan(frac{pi}{n})} where `n` is the number of sides, `s` is the side length, and `tan` is the tangent function from the math module. * **Returns**: The area of the polygon as a float. # Constraints 1. `num_sides` will be an integer greater than or equal to 3. 2. `side_length` will be a positive float. # Example ```python from math import tan, pi class Polygon: def __init__(self, num_sides: int, side_length: float): self.num_sides = num_sides self.side_length = side_length def area(self) -> float: n, s = self.num_sides, self.side_length return (n * s**2) / (4 * tan(pi / n)) # Example usage: polygon1 = Polygon(4, 5) print(polygon1.area()) # Output should be 25.0 polygon2 = Polygon(6, 3) print(polygon2.area()) # Output should be approximately 23.382685902179844 polygon3 = Polygon(3, 2) print(polygon3.area()) # Output should be approximately 1.73205080757 ``` # Implementation Guidelines * Use the `math` module to access the `tan` function and `pi` constant. * Ensure that invalid inputs are handled properly by raising appropriate errors. * Precisely follow the given formula to compute the area.","solution":"from math import tan, pi class Polygon: def __init__(self, num_sides: int, side_length: float): if num_sides < 3: raise ValueError(\\"A polygon must have at least 3 sides.\\") if side_length <= 0: raise ValueError(\\"The side length must be a positive number.\\") self.num_sides = num_sides self.side_length = side_length def area(self) -> float: n, s = self.num_sides, self.side_length return (n * s**2) / (4 * tan(pi / n))"},{"question":"# Scenario An online bookstore is managing its inventory and customer recommendation system. Each book has a limited number of copies, and each customer has a ranked preference list of books they are interested in buying. The bookstore needs an algorithm to allocate books to customers in a fair manner, ensuring that no customer misses out on their higher preferences if it is available. # Problem Given the details of customers\' preferences and available book copies, implement the function `allocate_books(preferences: list[list[int]], book_copies: list[int]) -> list[list[int]]` to allocate books to customers as fairly as possible based on their preferences. Input * `preferences`: A list of lists where each sublist represents a customer\'s ranked preferences over books. * `book_copies`: A list of integers where the value at each index represents the number of available copies of the corresponding book. Output * A list of lists where each sublist contains the allocated book IDs for the corresponding customer in the order they were allocated. Constraints * The length of `preferences` will be equal to the number of customers. * The length of `book_copies` will be equal to the number of unique books. * Each customer\'s preference list will contain unique integers within the valid range of book IDs. * The number of customers and books will not exceed 1000. # Example ```python def allocate_books(preferences: list[list[int]], book_copies: list[int]) -> list[list[int]]: # Function body here # Example data preferences = [[0, 1, 2], [2, 0, 1], [1, 2, 0]] book_copies = [1, 2, 1] result = allocate_books(preferences, book_copies) print(result) # Should print allocated books list such as [[0], [2], [1, 2]] ``` Performance Requirement * The solution must run in O(n*m) time complexity, where n is the number of customers and m is the number of different books. # Note You need to ensure that the implemented function allocates the books in a way that attempts to satisfy the highest preferences of each customer as much as possible within the available supply limits. If multiple allocations are possible, any valid allocation will be accepted.","solution":"def allocate_books(preferences, book_copies): num_customers = len(preferences) allocations = [[] for _ in range(num_customers)] fulfilled = [False] * num_customers for priority in range(len(book_copies)): for customer in range(num_customers): if not fulfilled[customer] and len(preferences[customer]) > priority: desired_book = preferences[customer][priority] if book_copies[desired_book] > 0: allocations[customer].append(desired_book) book_copies[desired_book] -= 1 if len(allocations[customer]) == 1 or len(preferences[customer]) <= len(allocations[customer]): fulfilled[customer] = True return allocations"},{"question":"# String Permutation Checker Your task is to implement a function that checks if two given strings are permutations of each other. Two strings are permutations of each other if they contain the same characters with the same frequencies, but possibly in different orders. Task: Implement a function `are_permutations` that takes two strings as input and returns `True` if the strings are permutations of each other, and `False` otherwise. Example Function Signature: ```python def are_permutations(str1: str, str2: str) -> bool: pass ``` Expected Input: * `str1`: A string consisting of alphanumeric characters and punctuation. * `str2`: A string consisting of alphanumeric characters and punctuation. Expected Output: * A boolean value indicating whether the two strings are permutations of each other. Constraints: * The length of each string will be between 1 and 1000 characters. * The strings can contain any printable ASCII characters, including spaces and punctuation. Example: ```python str1 = \\"listen\\" str2 = \\"silent\\" expected_output = True assert are_permutations(str1, str2) == expected_output str1 = \\"hello\\" str2 = \\"world\\" expected_output = False assert are_permutations(str1, str2) == expected_output ``` # Requirements: 1. Ensure the function is case-sensitive (e.g., \\"Hello\\" is not a permutation of \\"hello\\"). 2. The function should handle empty spaces and punctuation appropriately. 3. Optimize for clarity and performance, given the constraints. Create an algorithm that accurately checks for permutations, ensuring efficiency and correctness in handling various edge cases, such as different string lengths or character sets.","solution":"def are_permutations(str1: str, str2: str) -> bool: Check if two strings are permutations of each other. # If the lengths are not the same, they cannot be permutations if len(str1) != len(str2): return False # Count the characters in both strings char_count1 = {} char_count2 = {} for char in str1: if char in char_count1: char_count1[char] += 1 else: char_count1[char] = 1 for char in str2: if char in char_count2: char_count2[char] += 1 else: char_count2[char] = 1 # Compare the dictionaries return char_count1 == char_count2"},{"question":"# Question: Evaluate Expression with Nested Parentheses You are asked to write a function that evaluates arithmetic expressions containing integers and the operators `+` and `-` with nested parentheses. The function should parse the expression and compute the result, handling the correct order of operations and nested structures. 1. **Function Implementation**: - `evaluate_expression(expression: str) -> int`: Compute the result of the given arithmetic expression which includes `+` and `-` operators and may have nested parentheses. 2. **Input and Output Formats**: - Input: A single string `expression` containing non-negative integers, `+`, `-` operators, and parentheses `(`, `)`. - Output: A single integer which is the result of evaluating the expression. 3. **Constraints**: - The length of the `expression` will not exceed `1000` characters. - Every parenthesis will be properly matched. - There will be no invalid characters in the input. 4. **Example**: ```python print(evaluate_expression(\\"1 + 1\\")) # Output: 2 print(evaluate_expression(\\"2 - 1 + 2\\")) # Output: 3 print(evaluate_expression(\\"(1 + 2) - (3 - 4)\\")) # Output: 4 print(evaluate_expression(\\"((2 + 3) - (1 - 3))\\")) # Output: 7 ``` 5. **Edge Cases**: - Expressions with multiple nested parentheses. - Expressions with zero values and operations resulting in zero. - Single and multiple digit numbers. # Requirements Your implementation will be evaluated based on: - Correctness of the computed result. - Handling of nested parentheses and order of operations. - Efficiency and clarity of the parsing logic. # Submission Submit your implementation of the `evaluate_expression` function. Ensure edge cases are thoroughly handled and consider the performance given the constraint on expression length. ```python def evaluate_expression(expression: str) -> int: def parse(): num = 0 sign = 1 stack = [] result = 0 for char in expression: if char.isdigit(): num = num * 10 + int(char) elif char == \'+\': result += sign * num num = 0 sign = 1 elif char == \'-\': result += sign * num num = 0 sign = -1 elif char == \'(\': stack.append(result) stack.append(sign) sign = 1 result = 0 elif char == \')\': result += sign * num num = 0 result *= stack.pop() result += stack.pop() return result + sign * num return parse() # Example usage: print(evaluate_expression(\\"1 + 1\\")) # Output: 2 print(evaluate_expression(\\"2 - 1 + 2\\")) # Output: 3 print(evaluate_expression(\\"(1 + 2) - (3 - 4)\\")) # Output: 4 print(evaluate_expression(\\"((2 + 3) - (1 - 3))\\")) # Output: 7 ```","solution":"def evaluate_expression(expression: str) -> int: def parse(expression): num = 0 sign = 1 stack = [] result = 0 i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = num * 10 + int(char) elif char == \'+\': result += sign * num num = 0 sign = 1 elif char == \'-\': result += sign * num num = 0 sign = -1 elif char == \'(\': stack.append(result) stack.append(sign) result = 0 sign = 1 elif char == \')\': result += sign * num num = 0 result *= stack.pop() # sign result += stack.pop() # result i += 1 return result + sign * num return parse(expression) # Example usage: print(evaluate_expression(\\"1 + 1\\")) # Output: 2 print(evaluate_expression(\\"2 - 1 + 2\\")) # Output: 3 print(evaluate_expression(\\"(1 + 2) - (3 - 4)\\")) # Output: 4 print(evaluate_expression(\\"((2 + 3) - (1 - 3))\\")) # Output: 7"},{"question":"# Coding Assessment Question **Context**: You are developing an inventory management system for a chain of bookstores. Each book in the inventory has a unique ISBN (International Standard Book Number), title, author, and a quantity that indicates how many copies of the book are currently in stock at each store. The stores often receive new shipments of books or transfer books between themselves, and you need to update the inventory accordingly. # Task Write a class `Inventory` that manages the inventory of books in a bookstore chain. Your class should provide methods to add books, update stock quantities, and get the current stock of a book by its ISBN. Additionally, implement a method to transfer a certain quantity of books from one store to another. # Class Definition ```python class Inventory: def __init__(self): # Initializes an empty inventory pass def add_book(self, isbn: str, title: str, author: str, store: str, quantity: int): # Adds a new book to the inventory or updates the quantity if the book already exists pass def update_stock(self, isbn: str, store: str, quantity: int): # Updates the stock quantity of a given book in a specific store pass def get_stock(self, isbn: str, store: str) -> int: # Retrieves the current stock of a given book in a specific store pass def transfer_stock(self, isbn: str, from_store: str, to_store: str, quantity: int): # Transfers a certain quantity of books from one store to another pass ``` # Inputs - `isbn` (str): A string representing the ISBN of the book. - `title` (str): A string representing the title of the book. - `author` (str): A string representing the author of the book. - `store` (str): A string representing the name of the store. - `quantity` (int): An integer representing the number of copies of the book. # Outputs - `get_stock` should return the current stock quantity (int) of the specified book in the specified store. # Constraints - `quantity` is a non-negative integer. - `isbn`, `title`, `author`, and `store` are non-empty strings. - Transactions that result in negative stock should be prevented with an appropriate error message. - Ensure robust error handling for invalid inputs and store or book IDs that do not exist in the inventory. # Example ```python inventory = Inventory() inventory.add_book(\\"978-3-16-148410-0\\", \\"Book Title\\", \\"Author Name\\", \\"Store A\\", 10) inventory.add_book(\\"978-3-16-148410-0\\", \\"Book Title\\", \\"Author Name\\", \\"Store B\\", 5) inventory.update_stock(\\"978-3-16-148410-0\\", \\"Store A\\", 3) print(inventory.get_stock(\\"978-3-16-148410-0\\", \\"Store A\\")) inventory.transfer_stock(\\"978-3-16-148410-0\\", \\"Store A\\", \\"Store B\\", 2) print(inventory.get_stock(\\"978-3-16-148410-0\\", \\"Store B\\")) ``` Expected Output: ``` 13 7 ```","solution":"class Inventory: def __init__(self): self.inventory = {} def add_book(self, isbn: str, title: str, author: str, store: str, quantity: int): if isbn not in self.inventory: self.inventory[isbn] = { \'title\': title, \'author\': author, \'stores\': {} } if store not in self.inventory[isbn][\'stores\']: self.inventory[isbn][\'stores\'][store] = 0 self.inventory[isbn][\'stores\'][store] += quantity def update_stock(self, isbn: str, store: str, quantity: int): if isbn in self.inventory and store in self.inventory[isbn][\'stores\']: new_quantity = self.inventory[isbn][\'stores\'][store] + quantity if new_quantity < 0: raise ValueError(f\\"Stock for {isbn} in {store} cannot be negative\\") self.inventory[isbn][\'stores\'][store] = new_quantity else: raise ValueError(f\\"Book with ISBN {isbn} not in the inventory or store {store} does not exist\\") def get_stock(self, isbn: str, store: str) -> int: if isbn in self.inventory and store in self.inventory[isbn][\'stores\']: return self.inventory[isbn][\'stores\'][store] else: raise ValueError(f\\"Book with ISBN {isbn} not in the inventory or store {store} does not exist\\") def transfer_stock(self, isbn: str, from_store: str, to_store: str, quantity: int): if quantity < 0: raise ValueError(\\"Quantity must be a positive integer\\") self.update_stock(isbn, from_store, -quantity) self.update_stock(isbn, to_store, quantity)"},{"question":"# Problem Statement You are required to implement a basic multi-threaded producer-consumer problem using queues and threading. 1. **Producer**: This method, `producer`, should add items into the queue in sequence starting from 1 to a given value, `n`. Each item insertion should be followed by a short sleep to simulate production time. 2. **Consumer**: This method, `consumer`, should continuously monitor the queue and remove items from it, processing each item by simply printing it. 3. **Main**: In the `main` function, initiate and run one producer thread and one consumer thread. The producer will produce a given number of items, `n`, and the consumer will consume until there are no more items left to process. Input Format - An integer `n` representing the number of items to be produced. Output Format - The consumer\'s print output of processed items. Constraints - `1 <= n <= 10^5` - Each print output should be a sequential integer from 1 to `n`. Functions to Implement ```python def producer(queue: Queue, n: int) -> None: pass def consumer(queue: Queue) -> None: pass def main(n: int) -> None: pass ``` Example ```python if __name__ == \\"__main__\\": main(10) # Sample Output: 1 2 3 4 5 6 7 8 9 10 ``` The producer thread will produce items from 1 to `n` and place them into the queue. The consumer thread will consume these items and print them. The order of processing ensures the items are printed sequentially.","solution":"import threading import queue import time def producer(q: queue.Queue, n: int) -> None: for i in range(1, n + 1): q.put(i) time.sleep(0.01) # Simulate production time def consumer(q: queue.Queue) -> None: while True: item = q.get() if item is None: # Sentinel value to indicate end of production break print(item) q.task_done() def main(n: int) -> None: q = queue.Queue() producer_thread = threading.Thread(target=producer, args=(q, n)) consumer_thread = threading.Thread(target=consumer, args=(q,)) producer_thread.start() consumer_thread.start() producer_thread.join() q.put(None) # Send sentinel value to the consumer to indicate completion consumer_thread.join()"},{"question":"# Question: Analyzing and Implementing a Priority Queue using a Min-Heap You are required to implement a `PriorityQueue` class using a Min-Heap. In addition to the standard operations of a priority queue, you need to include methods to analyze the time complexity for each operation. # Task: 1. **Implement the Priority Queue using Min-Heap**: - Create a class `PriorityQueue` with the following methods: - Insert an element into the priority queue. - Extract the minimum element from the priority queue. - Peek at the minimum element without removing it. - Return the size of the priority queue. - Check if the priority queue is empty. 2. **Analyze and Test**: - Analyze the time complexity of each method in terms of Big-O notation. - Write appropriate unittests to ensure the correct functionality of all the operations, including edge cases. # Specifications: - **`PriorityQueue` Class**: - `__init__(self)`: Initialize an empty priority queue. - `insert(self, element: int)`: Insert an element into the priority queue. - `extract_min(self) -> int | None`: Remove and return the minimum element from the priority queue. If the queue is empty, return `None`. - `peek(self) -> int | None`: Return the minimum element without removing it. If the queue is empty, return `None`. - `size(self) -> int`: Return the number of elements in the priority queue. - `is_empty(self) -> bool`: Return `True` if the priority queue is empty, otherwise `False`. # Input and Output - **Input**: - For `insert`: An integer element to be inserted into the priority queue. - For `extract_min` and `peek`: None required. - **Output**: - For `insert`: None. - For `extract_min`: The minimum element in the priority queue, or `None` if the queue is empty. - For `peek`: The minimum element in the priority queue without removal, or `None` if the queue is empty. - For `size`: The number of elements in the priority queue. - For `is_empty`: `True` if the queue is empty, otherwise `False`. # Constraints: - The elements inserted into the priority queue are integers. - The priority queue should handle a large number of elements efficiently. # Example: ```python # Initialize an empty priority queue pq = PriorityQueue() # Insert elements into the priority queue pq.insert(10) pq.insert(4) pq.insert(15) pq.insert(7) # Get the size of the priority queue print(pq.size()) # Output: 4 # Peek at the minimum element print(pq.peek()) # Output: 4 # Extract the minimum element print(pq.extract_min()) # Output: 4 # Check if the priority queue is empty print(pq.is_empty()) # Output: False # Extract remaining elements print(pq.extract_min()) # Output: 7 print(pq.extract_min()) # Output: 10 print(pq.extract_min()) # Output: 15 # Check if the priority queue is empty print(pq.is_empty()) # Output: True ``` # Deliverables: - The complete implementation of `PriorityQueue` using Min-Heap. - Analysis of the implemented code regarding its time complexity for each method. - Unittests to validate the correct operation of the priority queue for edge cases and typical scenarios.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element: int): Insert an element into the priority queue. Time Complexity: O(log n) heapq.heappush(self.heap, element) def extract_min(self) -> int | None: Remove and return the minimum element from the priority queue. Time Complexity: O(log n) if not self.is_empty(): return heapq.heappop(self.heap) return None def peek(self) -> int | None: Return the minimum element without removing it. Time Complexity: O(1) if not self.is_empty(): return self.heap[0] return None def size(self) -> int: Return the number of elements in the priority queue. Time Complexity: O(1) return len(self.heap) def is_empty(self) -> bool: Return True if the priority queue is empty, otherwise False. Time Complexity: O(1) return len(self.heap) == 0"},{"question":"# Problem Description Write a function that receives a list of positive integers and, for each integer in the list, returns the smallest positive integer that cannot be represented as the sum of any subset of the list up to that integer. The function should be efficient and handle large inputs gracefully. # Function Signature ```python def smallest_non_representable(numbers: List[int]) -> List[int]: pass ``` # Input - `numbers`: A list of n positive integers where each integer > 0 and n (1 ≤ n ≤ 1000). # Output - A list of integers where each integer represents the smallest positive integer that cannot be formed as the sum of any subset of its respective list of numbers. # Constraints - The sum of integers in each sublist can be very large, so efficient computing is required. - Each integer in the sublists is positive and less than or equal to 1,000,000. # Example ```python >>> smallest_non_representable([[1, 2, 3], [1, 2, 5], [1, 1, 3, 4]]) [7, 4, 10] ``` Explanation: - For the list [1, 2, 3], every number up to 6 can be represented as the sum of some subset of the list. The smallest number that cannot be formed is 7. - For the list [1, 2, 5], the smallest number that cannot be represented is 4. - For the list [1, 1, 3, 4], the smallest number that cannot be represented is 10. # Notes - Sorting the list first can help in finding the smallest non-representable sum, as you can iteratively add the numbers and check the gaps. - Consider precomputing results for frequently occurring patterns or numbers to optimize performance.","solution":"from typing import List def smallest_non_representable(numbers: List[List[int]]) -> List[int]: def find_smallest_non_representable(nums: List[int]) -> int: nums.sort() smallest_sum = 1 for num in nums: if num > smallest_sum: break smallest_sum += num return smallest_sum return [find_smallest_non_representable(sublist) for sublist in numbers]"},{"question":"# Coding Assessment Question # Objective Your task is to implement a function that highlights your understanding of searching algorithms and handling edge cases efficiently. This problem tests your ability to apply the binary search algorithm to solve for specific conditions in a sorted list. # Problem Statement Implement the function `binary_search_for_position(arr: List[int], target: int) -> int`. Your function should return the index of the given `target` in the sorted list `arr` using the binary search algorithm. If the `target` is not present in the list, return the index where it would be if it were inserted in order. # Function Signature ```python def binary_search_for_position(arr: List[int], target: int) -> int: ``` # Input - `arr`: A list of integers with a length between (0 leq text{len(arr)} leq 10^4), sorted in non-decreasing order. - `target`: An integer, which can be positive, negative, or zero. # Output - Return the index of the `target` if it exists in the list. - If the `target` is not found, return the index where it would be if it were inserted in order. # Examples ```python assert binary_search_for_position([1, 3, 5, 6], 5) == 2 assert binary_search_for_position([1, 3, 5, 6], 2) == 1 assert binary_search_for_position([1, 3, 5, 6], 7) == 4 assert binary_search_for_position([1, 3, 5, 6], 0) == 0 assert binary_search_for_position([], 5) == 0 ``` # Constraints - Ensure your solution uses the binary search algorithm to handle the searching process efficiently. - Your solution should handle edge cases such as empty lists and single-element lists effectively. # Note Binary search is a common algorithm for searching within sorted datasets efficiently due to its logarithmic time complexity. The implementation should demonstrate its effectiveness in handling both presence and absence conditions of the `target` in the list.","solution":"from typing import List def binary_search_for_position(arr: List[int], target: int) -> int: Returns the index of the target in the sorted list arr. If target is not found, returns the index where it would be inserted in order. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Shuffling the Deck You have been given a deck of cards represented as a list of integers. Each integer uniquely identifies a card. Write a function `shuffle_deck(deck)` that takes the deck of cards and returns a new shuffled deck such that no card remains in its original position. If it is not possible to shuffle the deck so that no card remains in its original position, the function should return an empty list. # Input * `deck`: A list of integers representing the deck of cards. # Output * A list of integers representing the shuffled deck where no card remains in its initial position. If such a shuffle is not possible, return an empty list. # Constraints * The length of the deck `n` satisfies `2 <= n <= 10^5`. # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(n) # Examples ```python assert shuffle_deck([1, 2, 3, 4]) in [[2, 1, 4, 3], [3, 4, 1, 2], [4, 3, 2, 1]] # One of the possible shuffles assert shuffle_deck([1, 2, 3]) in [[2, 3, 1], [3, 1, 2], [2, 3, 1]] # One of the possible shuffles assert shuffle_deck([1, 1]) == [] # It is not possible to shuffle assert shuffle_deck([1]) == [] # It is not possible to shuffle assert shuffle_deck([]) == [] # Empty deck # Additional Considerations Ensure that your solution handles: * Edge cases such as deck with duplicate numbers which should return an empty list. * Minimum length deck with no possible shuffle arrangement. # Function Signature ```python def shuffle_deck(deck: list[int]) -> list[int]: # Your code here ```","solution":"import random def shuffle_deck(deck): Shuffles the deck such that no card remains in its original position. Returns an empty list if it\'s not possible. n = len(deck) # Handle edge case for empty deck or single card deck if n <= 1: return [] # Create a shuffled deck shuffled_deck = deck[:] random.shuffle(shuffled_deck) # Check if we have a valid shuffle such that no card remains in its original position for _ in range(100): # Try shuffling multiple times to find a valid derangement random.shuffle(shuffled_deck) if all(original != shuffled for original, shuffled in zip(deck, shuffled_deck)): return shuffled_deck return []"},{"question":"# Problem Statement: Integer Sequence Length You have to implement a function that calculates the longest increasing subsequence length in a given list of integers. An increasing subsequence is a sequence of numbers in which each number is less than or equal to the number following it. # Requirements: 1. **Efficiency**: The algorithm should be efficient and optimized for lists with large number of elements. 2. **Edge Cases**: Appropriately handle edge cases such as an empty list, a list with one element, or a list with all duplicate elements. 3. **Unique Solutions**: Ensure that the solution provides the longest length possible and handles multiple potential subsequences correctly. # Function Implementations: * `longest_increasing_subsequence_length`: This function should take a list of integers as input and return the length of the longest increasing subsequence. # Input Format: * A single list of integers `arr` (0 ≤ len(arr) ≤ 10,000) where each integer `n` (0 ≤ n ≤ 100,000). # Output Format: * Return an integer representing the length of the longest increasing subsequence. # Constraints: * The solution should efficiently handle both small and large datasets. * The algorithm should run in O(n log n) time complexity. # Example: ```python def longest_increasing_subsequence_length(arr): if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Test case 1: General case print(longest_increasing_subsequence_length([10, 9, 2, 5, 3, 7, 101, 18])) # Output: 4 # Test case 2: All elements in increasing order print(longest_increasing_subsequence_length([1, 2, 3, 4, 5])) # Output: 5 # Test case 3: All elements in decreasing order print(longest_increasing_subsequence_length([5, 4, 3, 2, 1])) # Output: 1 # Test case 4: Empty list print(longest_increasing_subsequence_length([])) # Output: 0 # Test case 5: List with all duplicate elements print(longest_increasing_subsequence_length([2, 2, 2, 2])) # Output: 1 ``` # Hint: Consider using dynamic programming to solve the problem efficiently. For an optimized approach, explore the possibility of using binary search techniques. # Additional Notes: While the detailed example function provided utilizes dynamic programming with a basic comparison method, it can be further optimized using data structures like binary indexed trees or segment trees for improving the lookup and update performance leading to the O(n log n) solution.","solution":"import bisect def longest_increasing_subsequence_length(arr): Function to calculate the length of the longest increasing subsequence in a list of integers. :param arr: List[int] - the input list of integers :return: int - the length of the longest increasing subsequence if not arr: return 0 lis = [] for num in arr: pos = bisect.bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) return len(lis)"},{"question":"# New Question # Coding Challenge: Subsequence Finder Objective: You are given two strings. Your task is to determine if the second string is a subsequence of the first string. Detailed Task Description: 1. **Function Implementation**: - Implement `is_subsequence(s: str, t: str) -> bool`: This function should determine whether the string `t` is a subsequence of the string `s`. 2. **Main Function**: - `is_subsequence(s: str, t: str) -> bool`: This function should return `True` if `t` is a subsequence of `s`, and `False` otherwise. Input: - Two strings, `s` and `t`, where `s` and `t` consist of lowercase English letters and have lengths of at most 1,000. Output: - A boolean value indicating if `t` is a subsequence of `s`. Example: ```python print(is_subsequence(\'abcde\', \'ace\')) # True print(is_subsequence(\'abcde\', \'aec\')) # False print(is_subsequence(\'axc\', \'ahbgdc\')) # False print(is_subsequence(\'ahbgdc\', \'abc\')) # True ``` Constraints: - The characters in the subsequence are from the original string, and they appear in the same order. - The length of both strings will be reasonably small to ensure efficiency with an O(n) time complexity solution. Function Signature: - def is_subsequence(s: str, t: str) -> bool In this task, the developer needs to understand string manipulation and be able to efficiently verify the subsequence condition, ensuring each character in `t` can be found sequentially in `s`. The problem enhances understanding of algorithmic complexity and string processing, suitable for intermediate level challenges.","solution":"def is_subsequence(s: str, t: str) -> bool: Determines if t is a subsequence of s. Args: s (str): The source string. t (str): The target subsequence string. Returns: bool: True if t is a subsequence of s, False otherwise. it = iter(s) return all(char in it for char in t)"},{"question":"# Question: Rotate a 2D Matrix 90 Degrees Clockwise In a graphics application, you frequently need to rotate images stored as 2D matrices. Implement a function that takes a square 2D matrix and rotates it 90 degrees clockwise in place. The rotation should be performed layer by layer from the outermost layer to the innermost layer. **Function Signature:** ```python def rotate_matrix_90_degrees(matrix: List[List[int]]) -> None: pass ``` **Input:** - A square 2D matrix `matrix` with dimensions `n x n` where `1 <= n <= 1000`. **Output:** - The matrix should be modified in place to reflect the 90 degrees clockwise rotation. **Constraints:** 1. You must rotate the matrix in place, do not use extra space for another matrix. **Examples:** ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix_90_degrees(matrix1) # Expected output: matrix1 becomes [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [5, 1], [3, 7] ] rotate_matrix_90_degrees(matrix2) # Expected output: matrix2 becomes [ # [3, 5], # [7, 1] # ] ``` **Scenario:** In your company’s graphics application, performance and efficiency are crucial as large images might be rotated frequently. Your task is to design and implement an efficient algorithm that handles these rotations without using additional memory for a second matrix.","solution":"from typing import List def rotate_matrix_90_degrees(matrix: List[List[int]]) -> None: Rotates the given square 2D matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# **Question: Subarrays with Maximum Sum** You are provided with an array of integers. You need to develop two functionalities: 1. **Find the subarray with the maximum sum**: Implement a function `max_subarray_sum(arr)` that returns the contiguous subarray which has the largest sum. 2. **Count all subarrays with a given sum**: Implement a function `count_subarrays_with_sum(arr, target_sum)` that returns the number of contiguous subarrays that sum up to a given target. Constraints 1. The input array will be non-empty. 2. The input array can include both positive and negative integers. 3. The target sum for subarrays to be counted can be any integer (positive, negative, or zero). Input 1. For the maximum subarray sum function: - `arr`: A list of integers. 2. For subarrays with given sum function: - `arr`: A list of integers. - `target_sum`: An integer representing the target sum for subarrays. Output 1. For the maximum subarray sum function: - Returns a list containing the elements of the subarray with the maximum sum. 2. For subarrays with given sum function: - Returns an integer representing the count of subarrays which sum up to the target. # Example 1. **Using max_subarray_sum function:** ```python arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] print(max_subarray_sum(arr)) # Output: [4, -1, 2, 1] arr = [1] print(max_subarray_sum(arr)) # Output: [1] ``` 2. **Using count_subarrays_with_sum function:** ```python arr = [1, 1, 1] target_sum = 2 print(count_subarrays_with_sum(arr, target_sum)) # Output: 2 arr = [10, 2, -2, -20, 10] target_sum = -10 print(count_subarrays_with_sum(arr, target_sum)) # Output: 3 ``` # Requirements * Implement the `max_subarray_sum` function. * Implement the `count_subarrays_with_sum` function. * Ensure proper handling of edge cases. * Maintain efficient time and space complexity.","solution":"def max_subarray_sum(arr): Returns the contiguous subarray which has the largest sum. max_ending_here = max_so_far = arr[0] start = end = s = 0 for i in range(1, len(arr)): if arr[i] > max_ending_here + arr[i]: max_ending_here = arr[i] s = i else: max_ending_here += arr[i] if max_ending_here > max_so_far: max_so_far = max_ending_here start = s end = i return arr[start:end+1] def count_subarrays_with_sum(arr, target_sum): Returns the number of contiguous subarrays that sum up to a given target. count = 0 current_sum = 0 sum_counts = {0: 1} for num in arr: current_sum += num if (current_sum - target_sum) in sum_counts: count += sum_counts[current_sum - target_sum] if current_sum in sum_counts: sum_counts[current_sum] += 1 else: sum_counts[current_sum] = 1 return count"},{"question":"# String Matching with Wildcards String matching is a fundamental concept in computer science, often used in search algorithms, text processing, and data validation. In this task, you are required to implement a function that determines whether a given pattern matches a specific text. The pattern may contain wildcard characters. Wildcard Characters - `\'*\'` Matches any sequence of characters (including an empty sequence). - `\'?\'` Matches any single character. Your task is to implement a function that checks if the pattern matches the provided text string. Function Signature ```python def is_match(text: str, pattern: str) -> bool: pass ``` Input - **text**: A string `text` representing the text to be matched. - **pattern**: A string `pattern` containing the wildcard pattern. Output - A boolean value `True` if the pattern matches the text, `False` otherwise. Constraints - The length of `text` and `pattern` will be between 1 and 2000 characters. - `text` and `pattern` will only contain lowercase letters and the wildcard characters `\'*\'` and `\'?\'`. # Sample Input ```python text = \\"adceb\\" pattern = \\"*a*b\\" ``` # Sample Output ```python True ``` # Explanation The pattern `*a*b` can match the text `adceb` because: - `\'*\'` can match `\'adc\'` - `\'a\'` matches `\'a\'` - `\'*\'` matches `\'\'` - `\'b\'` matches `\'b\'` # Additional Information * Ensure that the function handles various edge cases including but not limited to patterns that are only wildcards, empty text, and text that exceeds the pattern\'s structure. * Consider the efficiency of your implementation since the input size can be up to 2000 characters. Note You may use dynamic programming or any other efficient algorithm to solve this problem. Ensure your implementation handles backtracking scenarios promptly and avoids unnecessary re-computations.","solution":"def is_match(text: str, pattern: str) -> bool: Checks if the given pattern matches the text. Supports wildcard characters \'*\' and \'?\'. Args: text (str): The text to be matched. pattern (str): The pattern containing wildcards. Returns: bool: True if the pattern matches the text, False otherwise. m, n = len(text), len(pattern) # DP table where dp[i][j] means if text[:i] matches pattern[:j] dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty text and empty pattern match dp[0][0] = True # Handle patterns with \'*\' at the beginning for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Fill the rest of the table for i in range(1, m + 1): for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif pattern[j - 1] == \'?\' or pattern[j - 1] == text[i - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"Question Your task is to implement a function to determine if a given word can be constructed using a set of given tiles. Each tile has a letter, and each letter can be used only once to form the word. # Function Signature ```python def can_form_word(tiles: str, word: str) -> bool: Check if a given word can be formed using the given tiles. ``` # Input - `tiles` (str): A string representing the available tiles, each character in the string is a tile with a letter. - `word` (str): A string representing the word to be formed. # Output - Returns `True` if the word can be formed using the tiles, and `False` otherwise. # Example ```python can_form_word(\\"aabbcc\\", \\"abc\\") # Expected Output: True can_form_word(\\"aabbcc\\", \\"abccba\\") # Expected Output: True can_form_word(\\"aabbcc\\", \\"abcd\\") # Expected Output: False ``` # Constraints * The length of the `tiles` string and the `word` string will not exceed 1000 characters. * Only lowercase English letters are used in both `tiles` and `word`. # Scenario Imagine you are designing a word game where players must create words using a set of letter tiles. You need a function to verify if the word they want to create is possible with the given tiles, ensuring a fair and fun gaming experience.","solution":"from collections import Counter def can_form_word(tiles: str, word: str) -> bool: Check if a given word can be formed using the given tiles. tile_count = Counter(tiles) word_count = Counter(word) for char, count in word_count.items(): if tile_count[char] < count: return False return True"},{"question":"# Question: Implement a Simple File Compression Algorithm You need to implement a simple run-length encoding (RLE) algorithm to compress and decompress strings. RLE is a basic form of data compression where consecutive repetitions of the same character are replaced by one character followed by the count of repetitions. Function 1: `rle_compress` Implement the function `rle_compress(input_string: str) -> str`. **Input:** - `input_string`: A string to be compressed. **Output:** - A compressed string using RLE. **Constraints:** - The string will only contain uppercase English letters (A-Z). - The length of the string will be between 1 and 10,000 characters. **Example:** ```python assert rle_compress(\\"AABBBCC\\") == \\"A2B3C2\\" assert rle_compress(\\"AAAAAA\\") == \\"A6\\" ``` Function 2: `rle_decompress` Implement the function `rle_decompress(compressed_string: str) -> str`. **Input:** - `compressed_string`: A string compressed using the RLE algorithm. **Output:** - The original uncompressed string. **Constraints:** - The compressed string is guaranteed to be valid and will contain patterns as produced by the `rle_compress` function. **Example:** ```python assert rle_decompress(\\"A2B3C2\\") == \\"AABBBCC\\" assert rle_decompress(\\"A6\\") == \\"AAAAAA\\" ``` **Edge Cases to Consider:** - Single character strings (e.g., \\"A\\"). - Strings with no consecutive repeats (e.g., \\"ABC\\"). - Strings where all characters are the same.","solution":"def rle_compress(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 compressed.append(input_string[-1] + str(count)) return \'\'.join(compressed) def rle_decompress(compressed_string: str) -> str: if not compressed_string: return \\"\\" decompressed = [] i = 0 while i < len(compressed_string): char = compressed_string[i] count = 0 i += 1 while i < len(compressed_string) and compressed_string[i].isdigit(): count = count * 10 + int(compressed_string[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Problem Statement: Optimal Portfolio Allocation You are a financial analyst responsible for maximizing the returns of a portfolio consisting of various assets. Each asset has an historical average return and risk associated with it, represented as a standard deviation. Your objective is to balance the portfolio such that the overall return is maximized while keeping the risk under a specified threshold. # Requirements 1. **Function Implementation**: Implement the function `optimal_portfolio_allocation(returns: list[float], risks: list[float], threshold: float) -> list[float]` 2. **Input**: * `returns` - A list of floats representing the average returns of the assets. * `risks` - A list of floats representing the risks (standard deviations) of the returns of the assets. * `threshold` - A float representing the maximum acceptable risk for the portfolio. 3. **Output**: * Returns a list of floats representing the optimal weights for each asset in the portfolio. # Constraints 1. The length of `returns` and `risks` lists are the same and contain at least one element. 2. All values in `returns` and `risks` are non-negative floats. 3. The sum of the returned weights must be 1.0. 4. The total risk for the portfolio must be less than or equal to the `threshold`. # Example ```python returns = [0.10, 0.07, 0.12, 0.05] risks = [0.15, 0.10, 0.20, 0.08] threshold = 0.12 result = optimal_portfolio_allocation(returns, risks, threshold) print(result) # Expected Output: # [0.2, 0.1, 0.5, 0.2] ``` # Requirements 1. Deploy an efficient optimization technique that ensures the solution is feasible within reasonable computational limits. 2. Ensure the allocation respects the constraints of the problem. 3. The precision of the weights should be up to two decimal points.","solution":"def optimal_portfolio_allocation(returns, risks, threshold): Returns the optimal weights for asset allocation in a portfolio to maximize returns while ensuring the risk is under the specified threshold. Args: returns (list of floats): The average returns of the assets. risks (list of floats): The risks (standard deviations) of the returns of the assets. threshold (float): The maximum acceptable risk for the portfolio. Returns: list of floats: The optimal weights of the assets in the portfolio. from scipy.optimize import linprog import numpy as np n = len(returns) # Objective function: maximize returns --> minimize -returns c = [-r for r in returns] # Constraints: sum of some weights <= threshold A_ub = [risks] b_ub = [threshold] # Sum of weights should be 1 A_eq = [np.ones(n)] b_eq = [1] # Bounds for weights should be between 0 and 1 bounds = [(0, 1) for _ in range(n)] result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=\'highs\') if result.success: return np.round(result.x, 2).tolist() else: raise ValueError(\\"Optimization did not converge\\") # Example usage # returns = [0.10, 0.07, 0.12, 0.05] # risks = [0.15, 0.10, 0.20, 0.08] # threshold = 0.12 # result = optimal_portfolio_allocation(returns, risks, threshold) # print(result) # # Expected Output: # # [0.2, 0.1, 0.5, 0.2]"},{"question":"# Coding Assessment Question Context: You are part of a team working on a high-performance web server. One component of the server needs to efficiently process log files to generate real-time statistics on web traffic. Your task is to create a function that, given a log file, calculates the total number of requests to each unique URL and returns the results in a specific format. Function Specification: - **Function Name**: `count_requests_per_url` - **Input**: - `log_entries` (List[str]): A list of log entries where each entry is a string in the format `\\"[timestamp] URL\\"`. - **Output**: - A dictionary where the keys are URLs and the values are the count of how many times each URL was requested. Input Constraints: - Each log entry is a non-empty string. - Valid URL formats need to be handled (assuming URLs do not contain spaces). Performance Requirements: - The function should be efficient in terms of both time and space complexity. Edge Cases to Consider: - Handling of log entries with malformed URLs. - Empty list of log entries. Examples: ```python >>> count_requests_per_url([\\"[2023-01-01 00:00:00] /index.html\\", \\"[2023-01-01 00:01:00] /contact.html\\", \\"[2023-01-01 00:02:00] /index.html\\"]) {\'/index.html\': 2, \'/contact.html\': 1} >>> count_requests_per_url([\\"[2023-01-01 00:00:00] /index.html\\", \\"[2023-01-01 00:00:00] /index.html\\", \\"[2023-01-01 00:00:00] /about.html\\", \\"[2023-01-01 00:01:00] /about.html\\", \\"[2023-01-01 00:02:00] /index.html\\"]) {\'/index.html\': 3, \'/about.html\': 2} >>> count_requests_per_url([]) {} >>> count_requests_per_url([\\"[2023-01-01 00:00:00] /index.html\\"]) {\'/index.html\': 1} ``` Implementation Notes: - You may use Python\'s built-in collections module for data structures like dictionaries. - Ensure to handle edge cases gracefully, including but not limited to malformed URLs. - Assume all timestamps and other potential delimiters are correctly formatted and do not require validation.","solution":"def count_requests_per_url(log_entries): Given a list of log entries, calculates the number of requests to each unique URL. Parameters: log_entries (list of str): List of log entries in the format \\"[timestamp] URL\\" Returns: dict: Dictionary with URLs as keys and request counts as values. request_count = {} for entry in log_entries: # Split the log entry by spaces, and assume the URL is the last part parts = entry.split(\\" \\") url = parts[-1] if url in request_count: request_count[url] += 1 else: request_count[url] = 1 return request_count"},{"question":"# Maximize Subarray Sum Context and Objective You have been tasked with developing an efficient method to maximize the sum of a contiguous subarray within a one-dimensional numerical array. This type of problem is common in financial analysis, where you might need to calculate the maximum potential profit over a sequence of transactions constrained by time. Problem Statement Given an integer array `nums`, write a function `max_subarray_sum` that returns the maximum sum of any contiguous subarray within `nums`. The function should be optimized for performance, ideally achieving linear time complexity. Function Signature ```python def max_subarray_sum(nums: list[int]) -> int: pass ``` Input Constraints - `nums`: A list of integers which represents the array. - The length of `nums`: `1 <= len(nums) <= 10^5`. - Each element of `nums`: `-10^4 <= nums[i] <= 10^4`. Output - Return an integer representing the maximum sum of any contiguous subarray within the array `nums`. Example ```python # Example 1: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # Maximum subarray with the largest sum is [4, -1, 2, 1] with sum = 6 assert max_subarray_sum(nums) == 6 # Example 2: nums = [1] # Maximum subarray with the largest sum is [1] with sum = 1 assert max_subarray_sum(nums) == 1 # Example 3: nums = [5, 4, -1, 7, 8] # Maximum subarray with the largest sum is [5, 4, -1, 7, 8] with sum = 23 assert max_subarray_sum(nums) == 23 ``` Notes - You should aim to solve this problem using Kadane\'s Algorithm to achieve the optimal performance. - Ensure your implementation handles various types of input including arrays with all negative, all positive, and mixed values.","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray within nums. Utilizes Kadane\'s algorithm for an optimal O(n) time solution. current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Coding Assessment Question **Scenario**: You are working on a piece of software that requires encoding and decoding of strings. The software uses a custom encoding mechanism where each character in a string is replaced with its corresponding ASCII value, separated by a specific delimiter. **Task**: Implement two Python functions, `encode_string` and `decode_string`, that handle the encoding and decoding process. The `encode_string` function converts a given string into an encoded format where each character is represented by its ASCII value, concatenated with a given delimiter. The `decode_string` function reverses this process, taking the encoded string and converting it back to the original string. **Function Signatures**: ```python def encode_string(s: str, delimiter: str) -> str: Encode a given string by converting each character to its ASCII value and concatenating with the specified delimiter. Parameters: - s (str): The input string to be encoded. - delimiter (str): The delimiter used to separate ASCII values in the encoded string. Returns: - str: The encoded string with ASCII values separated by the delimiter. Exceptions: - Raise ValueError if delimiter is an empty string. pass def decode_string(encoded: str, delimiter: str) -> str: Decode an encoded string where ASCII values are separated by the specified delimiter, back to the original string. Parameters: - encoded (str): The encoded string with ASCII values separated by the delimiter. - delimiter (str): The delimiter used to separate ASCII values in the encoded string. Returns: - str: The decoded original string. Exceptions: - Raise ValueError if delimiter is an empty string. pass ``` **Constraints**: - The input string `s` can contain any printable ASCII characters. - The `delimiter` must be a non-empty string. **Performance Requirements**: - Encoding and decoding should run in linear time O(n). **Examples**: ```python >>> encode_string(\\"hello\\", \\"-\\") \'104-101-108-108-111\' >>> encode_string(\\"world!\\", \\",\\") \'119,111,114,108,100,33\' >>> decode_string(\\"104-101-108-108-111\\", \\"-\\") \'hello\' >>> decode_string(\\"119,111,114,108,100,33\\", \\",\\") \'world!\' >>> encode_string(\\"hello\\", \\"\\") Traceback (most recent call last): ... ValueError: Delimiter must be a non-empty string >>> decode_string(\\"119,111,114,108,100,33\\", \\"\\") Traceback (most recent call last): ... ValueError: Delimiter must be a non-empty string ```","solution":"def encode_string(s: str, delimiter: str) -> str: if not delimiter: raise ValueError(\\"Delimiter must be a non-empty string\\") ascii_values = [str(ord(char)) for char in s] return delimiter.join(ascii_values) def decode_string(encoded: str, delimiter: str) -> str: if not delimiter: raise ValueError(\\"Delimiter must be a non-empty string\\") ascii_values = encoded.split(delimiter) return \'\'.join(chr(int(value)) for value in ascii_values)"},{"question":"# Question: Implement a Simplified Online Bookstore Inventory System You are asked to create a simplified inventory management system for an online bookstore. The system should allow adding, removing, and searching for books by title or author, as well as checking the availability of a specific book. Requirements: 1. **Classes and Methods**: * `Book`: Represents a book with attributes `title` and `author`. * `Inventory`: Manages the collection of `Book` objects with the following methods: - `add_book(book: Book) -> None`: Adds a book to the inventory. - `remove_book(title: str) -> bool`: Removes a book by title from the inventory. Returns `True` if the book was successfully removed and `False` if the book was not found. - `search_by_title(title: str) -> List[Book]`: Returns a list of books that match the given title (case-insensitive). - `search_by_author(author: str) -> List[Book]`: Returns a list of books that match the given author (case-insensitive). - `is_available(title: str) -> bool`: Checks if a book with the given title is available in the inventory. Example: ```python class Book: def __init__(self, title: str, author: str): self.title = title self.author = author class Inventory: def __init__(self): self.books = [] def add_book(self, book: Book) -> None: self.books.append(book) def remove_book(self, title: str) -> bool: for book in self.books: if book.title.lower() == title.lower(): self.books.remove(book) return True return False def search_by_title(self, title: str) -> List[Book]: return [book for book in self.books if title.lower() in book.title.lower()] def search_by_author(self, author: str) -> List[Book]: return [book for book in self.books if author.lower() in book.author.lower()] def is_available(self, title: str) -> bool: return any(book.title.lower() == title.lower() for book in self.books) # Testing the implementation inventory = Inventory() book1 = Book(\'The Great Gatsby\', \'F. Scott Fitzgerald\') book2 = Book(\'To Kill a Mockingbird\', \'Harper Lee\') book3 = Book(\'1984\', \'George Orwell\') inventory.add_book(book1) inventory.add_book(book2) inventory.add_book(book3) assert inventory.remove_book(\'The Great Gatsby\') == True assert inventory.remove_book(\'The Catcher in the Rye\') == False assert inventory.search_by_title(\'1984\') == [book3] assert inventory.search_by_author(\'Harper Lee\') == [book2] assert inventory.is_available(\'To Kill a Mockingbird\') == True ``` Constraints: * Titles and authors are case-insensitive for search and removal operations. * Each book added to the inventory is unique by title. Steps to Implement: 1. **Class Definitions**: Define the `Book` and `Inventory` classes with the required methods and attributes. 2. **Book Addition/Removal**: Implement the `add_book` and `remove_book` methods in the `Inventory` class. 3. **Search Functions**: Implement the `search_by_title` and `search_by_author` methods to allow finding books by their titles or authors. 4. **Availability Check**: Implement the `is_available` method to check the existence of a book by its title. Tips: * Utilize list comprehensions for search methods to maintain code simplicity and efficiency. * Ensure `remove_book` and `is_available` methods handle case-insensitivity correctly.","solution":"from typing import List class Book: def __init__(self, title: str, author: str): self.title = title self.author = author def __eq__(self, other): return (self.title.lower() == other.title.lower() and self.author.lower() == other.author.lower()) class Inventory: def __init__(self): self.books = [] def add_book(self, book: Book) -> None: # Assuming each book added is unique by title, case-insensitive if not self.is_available(book.title): self.books.append(book) def remove_book(self, title: str) -> bool: for book in self.books: if book.title.lower() == title.lower(): self.books.remove(book) return True return False def search_by_title(self, title: str) -> List[Book]: return [book for book in self.books if title.lower() in book.title.lower()] def search_by_author(self, author: str) -> List[Book]: return [book for book in self.books if author.lower() in book.author.lower()] def is_available(self, title: str) -> bool: return any(book.title.lower() == title.lower() for book in self.books)"},{"question":"# Question Write a function that takes a string and returns a string where for every digit in the original string, the corresponding word (in English) representing the digit is substituted. The function should maintain the order of characters and replace digits only. # Function Signature ```python def digit_to_word(s: str) -> str: ``` # Input * A string `s` of length `1 <= len(s) <= 1000` that can contain letters, digits, and special characters. # Output * A string with all digits in the input string replaced by their respective English words. # Constraints * The function should maintain the original order of characters. # Example ```python # Example 1 input_string = \\"I have 2 apples.\\" print(digit_to_word(input_string)) # Output: \\"I have two apples.\\" # Example 2 input_string = \\"Meeting at 5pm\\" print(digit_to_word(input_string)) # Output: \\"Meeting at fivepm\\" # Example 3 input_string = \\"Room numbers 101 and 202 are reserved.\\" print(digit_to_word(input_string)) # Output: \\"Room numbers onezeroone and twozerotwo are reserved.\\" # Example 4 input_string = \\"Hello, World! 1234\\" print(digit_to_word(input_string)) # Output: \\"Hello, World! onetwothreefour\\" ``` # Explanation * In **Example 1**, the digit `2` in `input_string` is replaced with the word `two`, resulting in `\\"I have two apples.\\"`. * In **Example 2**, the digit `5` is replaced with `five`, producing the string `\\"Meeting at fivepm\\"`. * In **Example 3**, all digits are converted to their respective words, leading to `\\"onezeroone` and `twozerotwo` being substituted for `101` and `202` respectively. * In **Example 4**, each digit in the sequence `1234` is replaced with its English word, resulting in `\\"Hello, World! onetwothreefour\\"`. # Additional Information * Consider edge cases such as strings without any digits, strings containing only digits and special characters, and strings with digits interspersed among letters.","solution":"def digit_to_word(s: str) -> str: digit_map = { \'0\': \'zero\', \'1\': \'one\', \'2\': \'two\', \'3\': \'three\', \'4\': \'four\', \'5\': \'five\', \'6\': \'six\', \'7\': \'seven\', \'8\': \'eight\', \'9\': \'nine\' } result = [] for char in s: if char.isdigit(): result.append(digit_map[char]) else: result.append(char) return \'\'.join(result)"},{"question":"# Coding Question: Generate All Subsets Write a function to generate all possible subsets of a given set of distinct integers. The subset elements can appear in any order, and the function should return a list of lists, where each list represents a subset. Your tasks are: 1. Implement a recursive function to generate the power set (set of all subsets) of the provided list of integers. 2. Ensure that the generated subsets are unique and include the empty set as well. # Function Signature ```python def generate_all_subsets(nums: list) -> list: pass ``` # Inputs and Outputs - **Input**: A list of distinct integers, `nums`, which can contain zero or more integers. - **Output**: A list of lists, where each list represents a unique subset of `nums`. # Constraints: - Your implementation should handle lists of sizes up to 20 elements efficiently. - The elements in the input list will be distinct. # Example ```python >>> generate_all_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> generate_all_subsets([0]) [[], [0]] >>> generate_all_subsets([]) [[]] >>> generate_all_subsets([4, 5, 6, 7]) [[], [4], [5], [6], [7], [4, 5], [4, 6], [4, 7], [5, 6], [5, 7], [6, 7], [4, 5, 6], [4, 5, 7], [4, 6, 7], [5, 6, 7], [4, 5, 6, 7]] ``` Write a function `generate_all_subsets` that generates all possible subsets of a given list of distinct integers, ensuring each subset is unique and includes the empty set.","solution":"def generate_all_subsets(nums: list) -> list: result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"# Question Given an array of `n` integers, find an integer that appears more than `n/3` times in the array. If no such integer exists, return `None`. Implement a Python function `find_majority_element(nums)` which finds such a majority element. * **Input**: - `nums`: a list of integers where `n` is the length of the list. * **Output**: - Returns a single integer if there is an element that appears more than `n/3` times in the array, otherwise returns `None`. * **Constraints**: - The input list can be empty. - The integers in the list can be negative, zero, or positive. - The length `n` of the list will be at most 10^4. * **Additional Specifications**: - Solution must have a time complexity of O(n) and auxiliary space complexity of O(1). * **Example**: ```python nums = [3, 2, 3] print(find_majority_element(nums)) # Output: 3 nums = [1, 1, 1, 3, 3, 2, 2, 2] print(find_majority_element(nums)) # Output: None ```","solution":"def find_majority_element(nums): Finds an integer that appears more than n/3 times in the array. If no such integer exists, returns None. if not nums: return None # Boyer-Moore Voting Algorithm for finding elements that occur more than n/3 times candidate1, candidate2, count1, count2 = None, None, 0, 0 for num in nums: if candidate1 == num: count1 += 1 elif candidate2 == num: count2 += 1 elif count1 == 0: candidate1, count1 = num, 1 elif count2 == 0: candidate2, count2 = num, 1 else: count1 -= 1 count2 -= 1 count1, count2 = 0, 0 for num in nums: if num == candidate1: count1 += 1 elif num == candidate2: count2 += 1 if count1 > len(nums) // 3: return candidate1 if count2 > len(nums) // 3: return candidate2 return None"},{"question":"# **Rotating Elements in a List by a Given Count** Write a function `rotate_elements(input_list: list[int], count: int) -> list[int]` that rotates the elements in a list to the right by the specified count. For this task: 1. **Input:** - `input_list`: A list of integers. - `count`: An integer specifying the number of places to rotate the elements. 2. **Output:** - A list of integers with elements rotated to the right by the given count. 3. **Constraints:** - `input_list` should only contain integers. - `count` can be any integer (positive, negative, or zero). - If `input_list` is empty, return an empty list. - If `count` is zero, return the list unchanged. - The function should handle any integer value of `count`, including negative values, which indicate rotation to the left. 4. **Handling Errors:** - If `input_list` contains non-integer elements, raise a `ValueError` with the message `\\"All elements in input_list must be integers\\"`. # Example Usage ```python >>> rotate_elements([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_elements([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_elements([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_elements([1, 2, 3], 5) [2, 3, 1] >>> rotate_elements([], 3) [] >>> rotate_elements([1, 2, \'a\', 4], 2) Traceback (most recent call last): ... ValueError: All elements in input_list must be integers >>> rotate_elements([1], 2) [1] ``` # Requirements * Ensure the function handles invalid input gracefully by raising exceptions where necessary. * Implement the function efficiently to handle large input data. By examining the provided examples and constraints carefully, you will understand that rotating a list means moving elements circularly and handling any direction indicated by the count.","solution":"def rotate_elements(input_list: list[int], count: int) -> list[int]: Rotates elements in a list to the right by the specified count. Arguments: input_list -- a list of integers to be rotated. count -- an integer specifying the number of places to rotate. Returns: A list of integers with elements rotated to the right by the given count. if not all(isinstance(element, int) for element in input_list): raise ValueError(\\"All elements in input_list must be integers\\") if len(input_list) == 0: return [] count = count % len(input_list) # Ensure count is within list length return input_list[-count:] + input_list[:-count]"},{"question":"# Subset Sum Equal Partition In this problem, you need to determine if a given set of positive integers can be partitioned into two subsets whose sums are equal. Requirements * Implement the function `can_partition(nums: List[int]) -> bool` that returns `True` if the input list can be partitioned into two subsets with equal sum and `False` otherwise. * Use dynamic programming to achieve optimal efficiency in the solution. Function Signature ```python def can_partition(nums: List[int]) -> bool: pass ``` # Input * `nums`: A list of positive integers (1 ≤ len(nums) ≤ 200, 1 ≤ nums[i] ≤ 100). # Output * Returns a boolean value: `True` if the list can be partitioned into two subsets with equal sum, `False` otherwise. # Example ```python assert can_partition([1, 5, 11, 5]) == True assert can_partition([1, 2, 3, 5]) == False assert can_partition([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == True ``` # Constraints * Use a dynamic programming approach where the subset sum problem is tackled by building a 2D DP array. * Consider the sum of all elements and check if it is even; if it is odd, partitioning into two equal subsets is impossible. * Minimize space complexity by using a 1D DP array if possible. # Notes * Handle edge cases such as a single integer input where partition is not possible. * The solution must be efficient and minimize unnecessary computations to handle larger inputs within the constraints.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: Determine if the input list can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, it\'s not possible to partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"# Scenario You are developing software for a railway system that manages train schedules. A key functionality needed is to determine the total travel time between two stations, including stops at intermediate stations. Each station has its respective arrival and departure times stored in 24-hour format strings (e.g., \'13:45\'). Your task is to calculate the total travel time from a list of station stops. # Task Write a function `calculate_travel_time(schedule)` that: 1. Takes a list of dictionaries representing the train schedule. Each dictionary contains: - `station` (str): The name of the station. - `arrival` (str): Arrival time at the station in 24-hour format. It can be `None` for the first station. - `departure` (str): Departure time from the station in 24-hour format. It can be `None` for the last station. 2. Returns the total travel time in minutes. # Input and Output Formats Input * `schedule` (list of dicts): The train\'s travel schedule. Output * `total_travel_time` (int): The total travel time in minutes. # Function Signature ```python def calculate_travel_time(schedule: list[dict]) -> int: ``` # Example ```python # Example 1 schedule = [ {\\"station\\": \\"A\\", \\"arrival\\": None, \\"departure\\": \\"08:00\\"}, {\\"station\\": \\"B\\", \\"arrival\\": \\"09:30\\", \\"departure\\": \\"09:45\\"}, {\\"station\\": \\"C\\", \\"arrival\\": \\"11:00\\", \\"departure\\": \\"11:10\\"}, {\\"station\\": \\"D\\", \\"arrival\\": \\"12:30\\", \\"departure\\": None} ] print(calculate_travel_time(schedule)) # Output: 270 # Example 2 schedule = [ {\\"station\\": \\"Start\\", \\"arrival\\": None, \\"departure\\": \\"06:15\\"}, {\\"station\\": \\"Middle\\", \\"arrival\\": \\"08:50\\", \\"departure\\": \\"09:00\\"}, {\\"station\\": \\"End\\", \\"arrival\\": \\"11:45\\", \\"departure\\": None} ] print(calculate_travel_time(schedule)) # Output: 330 ``` # Constraints * The list `schedule` will contain at least two stops. * Times are given in the 24-hour format string (hh:mm). * The departure time of a station will always be later than or equal to its arrival time. * The total travel time is calculated based on the departure time of the first station and the arrival time of the last station. # Notes * You can use the `datetime` module in Python to help with time calculations. **Complete the implementation in Python.**","solution":"from datetime import datetime def calculate_travel_time(schedule): Calculates the total travel time from the first departure to the last arrival. Parameters: schedule (list of dict): The train schedule with each station\'s arrival and departure times Returns: int: The total travel time in minutes first_departure_time = None last_arrival_time = None for stop in schedule: if stop[\'departure\'] is not None and first_departure_time is None: first_departure_time = stop[\'departure\'] if stop[\'arrival\'] is not None: last_arrival_time = stop[\'arrival\'] time_format = \\"%H:%M\\" departure_time_obj = datetime.strptime(first_departure_time, time_format) arrival_time_obj = datetime.strptime(last_arrival_time, time_format) travel_time = arrival_time_obj - departure_time_obj total_minutes = travel_time.seconds // 60 return total_minutes"},{"question":"# Question: Implement a Genetic Algorithm for Function Optimization Develop a Python function to implement a simple genetic algorithm to find the maximum value of a given function `f(x)` over a specified interval `[a, b]`. The algorithm should utilize standard operations such as selection, crossover, and mutation. # Function Signature ```python def genetic_algorithm_optimization(f, a: float, b: float, pop_size: int, generations: int) -> float: pass ``` # Input 1. `f`: A callable function `f(x)` that returns a float value for a given float input `x`. 2. `a`: A float representing the start of the interval. 3. `b`: A float representing the end of the interval. 4. `pop_size`: An integer representing the size of the population. 5. `generations`: An integer representing the number of generations to evolve. # Output * Return a float value representing the estimated maximum value of the function `f` within the interval `[a, b]`. # Constraints * `a` < `b`, and both `a` and `b` must be finite real numbers. * `pop_size` should be a positive integer (e.g., 20 to 100). * `generations` should be a positive integer (e.g., 50 to 1000). # Performance Requirements * Efficiently handle the genetic operations (selection, crossover, mutation) within the specified population and generations. # Example ```python import math def f(x): return -((x-2)**2) + 5 # A simple parabolic function with a maximum at x = 2 result = genetic_algorithm_optimization(f, 0, 4, 50, 100) print(result) # Should print a value close to 2 ``` # Notes * Initialize a population of `pop_size` random individuals within the interval `[a, b]`. * Use a fitness function to evaluate how close an individual is to the maximum point. * Use a selection process such as tournament selection to choose parents. * Implement crossover (e.g., one-point crossover) to produce offspring. * Apply mutation with a small probability to introduce variations. * Evolve the population over the specified number of generations. # Hints * Ensure the population initialization covers the entire interval `[a, b]`. * Consider edge cases where the function may have multiple local maxima. * Adjust mutation rates to avoid premature convergence or excessive exploration.","solution":"import random def genetic_algorithm_optimization(f, a: float, b: float, pop_size: int, generations: int) -> float: # Generate initial population population = [random.uniform(a, b) for _ in range(pop_size)] def fitness(x): return f(x) def selection(population): # Tournament selection tournament_size = 3 selected = [] for _ in range(pop_size): contenders = random.sample(population, tournament_size) selected.append(max(contenders, key=fitness)) return selected def crossover(parent1, parent2): # One-point crossover if random.random() < 0.5: return (parent1, parent2) else: return (parent2, parent1) def mutate(individual): # Mutation with a small probability mutation_rate = 0.01 if random.random() < mutation_rate: return random.uniform(a, b) else: return individual for _ in range(generations): # Selection selected_population = selection(population) next_generation = [] # Crossover for i in range(0, pop_size, 2): parent1 = selected_population[i] parent2 = selected_population[i + 1] offspring1, offspring2 = crossover(parent1, parent2) next_generation.append(offspring1) next_generation.append(offspring2) # Mutation population = [mutate(individual) for individual in next_generation] # Return the best best_individual = max(population, key=fitness) return best_individual"},{"question":"# K-Closest Points to Origin In this task, you need to implement a function that finds the `k` closest points to the origin (0, 0) from a given list of points in a 2D plane. The distance between two points ((x1, y1)) and ((x2, y2)) is defined as (sqrt{(x2 - x1)^2 + (y2 - y1)^2}). For this problem, you can use the squared Euclidean distance to avoid the cost of computing square roots. # Function Signature ```python def k_closest_points(points: List[List[int]], k: int) -> List[List[int]]: ``` # Input - A list of points `points` ( ([[x1, y1], [x2, y2], ...]) ), where each point is defined by two integers ( x, y) ((|x|, |y| leq 10^4) ). - An integer `k` ( (1 leq k leq text{len}(points)) ): the number of closest points to find. # Output - A list of `k` points ( ([[x1, y1], [x2, y2], ...]) ) closest to the origin, sorted by increasing distance. If two points have the same distance, their order can be any. # Constraints - The list `points` will contain at least `k` points. - The time complexity should handle up to 10,000 points efficiently. # Example ```python print(k_closest_points([[1, 3], [-2, 2], [4, 6]], 2)) # Output: [[-2, 2], [1, 3]] print(k_closest_points([[3, 3], [5, -1], [-2, 4]], 1)) # Output: [[3, 3]] ``` # Notes 1. In `k_closest_points([[1, 3], [-2, 2], [4, 6]], 2)`, the points closest to the origin are [-2, 2] (distance 8) and [1, 3] (distance 10). 2. In `k_closest_points([[3, 3], [5, -1], [-2, 4]], 1)`, the closest point to the origin is [3, 3]. # Tips - Consider using a data structure that keeps track of the k smallest elements encountered so far. - You might find utilizing the `heapq` library in Python helpful for efficiently finding the smallest distances.","solution":"import heapq from typing import List def k_closest_points(points: List[List[int]], k: int) -> List[List[int]]: Returns the k closest points to the origin. Args: points (List[List[int]]): List of points where each point is represented as [x, y]. k (int): Number of closest points to return. Returns: List[List[int]]: List of the k closest points to the origin. # Utilize a max-heap to keep track of the k closest points heap = [] for (x, y) in points: # Calculate the squared distance to the origin dist = x * x + y * y if len(heap) < k: heapq.heappush(heap, (-dist, [x, y])) else: heapq.heappushpop(heap, (-dist, [x, y])) return [point for (_, point) in heap]"},{"question":"# Problem Statement A company stores data about their employees in a special structure. Each employee has a unique ID and reports to a manager, who is also an employee. The company\'s hierarchy is structured in a tree where the CEO (who has no manager) is the root. You are tasked with implementing a function `num_reportees` that, given the dictionary representing the hierarchy and an employee ID, returns the total number of direct and indirect reportees (all levels of subordinates) that report to the given employee. # Function Signature ```python def num_reportees(emp_hierarchy: dict, emp_id: int) -> int: ``` # Input * `emp_hierarchy`: a dictionary where keys are employee IDs (int), and values are lists of employee IDs representing direct reportees. * `emp_id`: an integer representing the employee ID whose reportees you want to count. # Output * An integer representing the total number of direct and indirect reportees of the given employee. # Constraints * 1 <= number of employees <= 10,000 * Employee IDs are unique positive integers. * The `emp_id` provided is guaranteed to be a valid employee ID within the hierarchy. * It is guaranteed that the hierarchy forms a valid tree structure with one root (CEO). # Performance Requirements * Your implementation should be efficient, ideally operating in O(n) time complexity, where n is the number of employees. # Example ```python emp_hierarchy = { 1: [2, 3, 4], 2: [5, 6], 3: [7], 4: [], 5: [], 6: [], 7: [] } assert num_reportees(emp_hierarchy, 1) == 6 assert num_reportees(emp_hierarchy, 2) == 2 assert num_reportees(emp_hierarchy, 3) == 1 assert num_reportees(emp_hierarchy, 4) == 0 assert num_reportees(emp_hierarchy, 5) == 0 assert num_reportees(emp_hierarchy, 6) == 0 assert num_reportees(emp_hierarchy, 7) == 0 ``` # Notes * Consider using depth-first search (DFS) or breadth-first search (BFS) to traverse the hierarchy tree. * Carefully handle the recursion or iteration to count direct and indirect reportees efficiently. * Ensure to address edge cases such as employees with no reportees.","solution":"def num_reportees(emp_hierarchy: dict, emp_id: int) -> int: Given the dictionary representing the hierarchy and an employee ID, returns the total number of direct and indirect reportees (all levels of subordinates) that report to the given employee. def count_reportees(emp_id): count = 0 if emp_id in emp_hierarchy: for reportee in emp_hierarchy[emp_id]: count += 1 + count_reportees(reportee) return count return count_reportees(emp_id)"},{"question":"Sorting Orders You need to implement a function that can sort a given list according to specific criteria. The function should be able to sort the list either in ascending or descending order depending on the input parameter. # Requirements 1. **Function Name**: `sort_list_custom` 2. **Arguments**: - `arr` (List[int]): A list of integers. - `order` (str): A string that specifies the order criteria. It can be either `\'ascending\'` or `\'descending\'`. 3. **Output**: Return a new list sorted according to the specified order. 4. **Constraints**: - The list can contain up to 10^6 elements. - The integers can range from -10^9 to 10^9. - `arr` should not be modified in place. - If `order` is neither `\'ascending\'` nor `\'descending\'`, raise a `ValueError`. # Examples ```python # Sort in ascending order sort_list_custom([3, 1, 4, 1, 5, 9, 2], \'ascending\') # Output: [1, 1, 2, 3, 4, 5, 9] # Sort in descending order sort_list_custom([3, 1, 4, 1, 5, 9, 2], \'descending\') # Output: [9, 5, 4, 3, 2, 1, 1] # Sort in ascending order (including negative numbers) sort_list_custom([-5, -10, 3, 0, 2, -1], \'ascending\') # Output: [-10, -5, -1, 0, 2, 3] # Invalid order sort_list_custom([3, 2, 1], \'upward\') # Output: ValueError ``` # Implementation Write the function `sort_list_custom` to meet the above requirements. **Function Signature**: ```python from typing import List def sort_list_custom(arr: List[int], order: str) -> List[int]: pass ``` **Notes**: - Make sure the function handles both small and large datasets efficiently. - Ensure the code raises appropriate errors for invalid inputs.","solution":"from typing import List def sort_list_custom(arr: List[int], order: str) -> List[int]: Sorts the given list according to the specified order. Parameters: arr (List[int]): A list of integers to sort. order (str): The order in which to sort the list. Either \'ascending\' or \'descending\'. Returns: List[int]: A new list sorted according to the specified order. Raises: ValueError: If the `order` is neither \'ascending\' nor \'descending\'. if order == \'ascending\': return sorted(arr) elif order == \'descending\': return sorted(arr, reverse=True) else: raise ValueError(\\"`order` must be either \'ascending\' or \'descending\'\\")"},{"question":"# Clustering with K-Means and Custom Distance Metric You are given an implementation of the K-Means clustering algorithm. Your task is to extend its functionality by adding support for a custom distance metric, `manhattan_distance`. Also, implement a method to handle the possibility of empty clusters by reassigning data points to the nearest cluster centers. # Instructions: 1. Implement a function `manhattan_distance(point1, point2)` which computes the Manhattan distance between two points. 2. Modify the `k_means` function to integrate the custom distance metric. * Add a parameter `distance_metric` to allow specifying between Euclidean and Manhattan distance. * Ensure that any empty clusters are managed by reassigning data points from the farthest cluster center. # Input: * A dataset containing data points. * Number of clusters (`k`). * Number of iterations. * The distance metric to be used (\\"euclidean\\" or \\"manhattan\\"). # Output: * Final cluster centers. * Cluster assignments for each data point. # Constraints: * Use numPy for matrix operations. * Handle cases where the dataset points may contain outliers by recalculating only significant values. # Example: ```python data_points = np.array([[2, 3], [5, 8], [1, 2], [8, 8], [9, 10], [10, 12]]) k = 2 iterations = 100 distance_metric = \\"manhattan\\" ``` # Function Signature: ```python def manhattan_distance(point1: np.ndarray, point2: np.ndarray) -> float: pass def k_means(data_points: np.ndarray, k: int, iterations: int, distance_metric: str) -> (np.ndarray, np.ndarray): pass # Usage Example point1 = np.array([2, 3]) point2 = np.array([5, 8]) print(manhattan_distance(point1, point2)) # Should return a float value centers, assignments = k_means(data_points, k, iterations, distance_metric) print(centers) # Should print the final cluster centers print(assignments) # Should print the cluster assignments for each data point ``` This question challenges the understanding and implementation of algorithms and customizations in clustering techniques, aligning with the complexity and scope of the provided sample.","solution":"import numpy as np def manhattan_distance(point1: np.ndarray, point2: np.ndarray) -> float: Computes the Manhattan distance between two points. return np.sum(np.abs(point1 - point2)) def k_means(data_points: np.ndarray, k: int, iterations: int, distance_metric: str = \'euclidean\') -> (np.ndarray, np.ndarray): K-means clustering algorithm supporting custom distance metrics. Parameters: - data_points: np.ndarray; The data points to cluster. - k: int; Number of clusters. - iterations: int; Number of iterations to run the algorithm. - distance_metric: str; Distance metric to use (\\"euclidean\\" or \\"manhattan\\"). Returns: - centers: np.ndarray; Final cluster centers. - assignments: np.ndarray; Cluster assignments for each data point. def distance(point1, point2): if distance_metric == \'euclidean\': return np.linalg.norm(point1 - point2) elif distance_metric == \'manhattan\': return manhattan_distance(point1, point2) else: raise ValueError(\\"Unsupported distance metric\\") # Randomly initialize cluster centers np.random.seed(42) centers = data_points[np.random.choice(data_points.shape[0], k, replace=False)] assignments = np.zeros(data_points.shape[0], dtype=int) for _ in range(iterations): # Assign points to the nearest cluster center for i, point in enumerate(data_points): distances = np.array([distance(point, center) for center in centers]) assignments[i] = np.argmin(distances) # Recompute cluster centers new_centers = np.zeros_like(centers) for i in range(k): assigned_points = data_points[assignments == i] if len(assigned_points) == 0: # If a cluster is empty, reassign some points from the largest cluster. largest_cluster = np.argmax([sum(assignments == j) for j in range(k)]) farthest_points = data_points[assignments == largest_cluster] distances = np.array([distance(point, centers[largest_cluster]) for point in farthest_points]) furthest_point_index = np.argmax(distances) new_centers[i] = farthest_points[furthest_point_index] assignments[furthest_point_index] = i else: new_centers[i] = np.mean(assigned_points, axis=0) centers = new_centers return centers, assignments"},{"question":"# Problem Statement A company wants to analyze its sales data. You are given sales records of employees stored in a dictionary where the keys are employee IDs and the values are lists of sales amounts (floats). Your task is to write a function that calculates the average sales for each employee and returns a dictionary containing these averages. # Input - A dictionary `sales_data` where keys are `employee_id` (strings) and values are `sales` (list of floats). # Output - A dictionary with the same keys (`employee_id`) and float values representing the average sales for each employee. # Constraints - Each `sales` list for every employee will contain at least one float (at least one sale). - Employee IDs are unique. - Sales amounts are non-negative floats. # Function Signature ```python def calculate_average_sales(sales_data: dict) -> dict: ``` # Examples ```python >>> calculate_average_sales({\\"E001\\": [100.0, 200.0, 300.0], \\"E002\\": [150.0, 150.0], \\"E003\\": [50.0, 50.0, 100.0]}) {\'E001\': 200.0, \'E002\': 150.0, \'E003\': 66.66666666666667} >>> calculate_average_sales({\\"E001\\": [123.45], \\"E002\\": [678.90, 321.10], \\"E003\\": [100.0, 100.0, 200.0]}) {\'E001\': 123.45, \'E002\': 500.0, \'E003\': 133.33333333333334} >>> calculate_average_sales({\\"E001\\": [1000.0], \\"E002\\": [500.0, 500.0], \\"E003\\": [750.0]}) {\'E001\': 1000.0, \'E002\': 500.0, \'E003\': 750.0} ``` # Implementation Guidance 1. Iterate through each key-value pair in the `sales_data` dictionary. 2. For each employee, calculate the average of their sales by summing the sales amounts and dividing by the number of sales. 3. Construct and return a new dictionary containing each employee\'s ID and their corresponding average sales. # Note - You can use Python\'s built-in `sum()` and `len()` functions to calculate the average sales. - Ensure your function is efficient and readable.","solution":"def calculate_average_sales(sales_data: dict) -> dict: Calculates average sales for each employee. Args: sales_data (dict): A dictionary where keys are employee IDs and values are lists of sales amounts. Returns: dict: A dictionary with employee IDs as keys and their average sales as values. return {employee_id: sum(sales) / len(sales) for employee_id, sales in sales_data.items()}"},{"question":"# Rotate List Left by K Positions **Context**: In various scenarios, you may need to rotate the elements of a list to the left by a certain number of positions. For example, in data processing and manipulation tasks, realigning data to fit certain criteria might require such rotations. **Task**: Write a Python function `rotate_left(arr: list[int], k: int) -> list[int]` that rotates a list of integers to the left by `k` positions. **Function Specification**: * **Input**: - `arr`: A list of integers. - `k`: An integer representing the number of positions to rotate the list to the left. * **Output**: - A list of integers with elements rotated left by `k` positions. **Examples**: ```python >>> rotate_left([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> rotate_left([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_left([1, 2, 3], 1) [2, 3, 1] >>> rotate_left([1, 2], 3) [2, 1] ``` **Performance Requirements**: * Ensure the function handles edge cases such as empty lists or when `k` is greater than the length of the list. * Optimize for time efficiency, aiming for O(n) complexity where n is the length of the list. Implement the function taking these considerations into account.","solution":"def rotate_left(arr: list[int], k: int) -> list[int]: Rotates the array to the left by k positions. Parameters: arr (list of int): The list of integers to be rotated. k (int): The number of positions to rotate the list. Returns: list of int: The rotated list. n = len(arr) if n == 0: return [] # Normalize k to ensure it\'s within the bounds of the list length k = k % n # Perform the rotation return arr[k:] + arr[:k]"},{"question":"# Coding Question: Validate International Phone Numbers Scenario You are developing a customer contact management system that needs to store and validate international phone numbers. Your task is to create a function that verifies if a given phone number string is a valid international phone number based on specific criteria. Requirements - Implement a function `validate_phone_number` that checks the validity of an international phone number. - The phone number should adhere to the following rules: - It starts with a `+` followed by the country code (1-3 digits). - The country code is followed by a space. - The remaining part of the phone number should consist of digits (8-12 digits). - Ensure that the function handles numbers adhering to the E.164 format. Expected Format ```python def validate_phone_number(phone_number: str) -> bool: # your implementation here pass ``` Constraints 1. The input phone number will be a string and may contain spaces, dashes, or parentheses, which need to be ignored for validation. 2. Follow the O(n) time complexity. Examples Suppose the following examples are given: ```python print(validate_phone_number(\'+1 1234567890\')) # True print(validate_phone_number(\'+91 9876543210\')) # True print(validate_phone_number(\'+44 2079460123\')) # True print(validate_phone_number(\'123456789\')) # False print(validate_phone_number(\'+123 12345678\')) # True print(validate_phone_number(\'+12-3456789012\')) # True print(validate_phone_number(\'+34 (876) 543210\')) # True print(validate_phone_number(\'+990 12345\')) # False ``` Use these examples to verify your implementation.","solution":"import re def validate_phone_number(phone_number: str) -> bool: Validates if the input phone number is a valid international phone number. A valid phone number: - Starts with a `+` followed by the country code (1-3 digits). - The country code is followed by a space. - The remaining part of the phone number consists of digits (8-12 digits). Parameters: phone_number (str): The phone number string to validate. Returns: bool: True if the phone number is valid, False otherwise. # Remove spaces, dashes, and parentheses from the input phone number filtered_number = re.sub(r\'[s-()]\', \'\', phone_number) # Check if the filtered number matches the pattern of a valid phone number pattern = re.compile(r\'^+d{1,3}d{8,12}\') return bool(pattern.match(filtered_number))"},{"question":"# Coding Task: Rotating a List In this task, you are required to write a function that rotates the elements of a given list to the right by a specified number of steps. Rotating a list means shifting its elements to the right and wrapping around the end of the list back to the beginning. # Problem Description Write a function `rotate_list` that takes a list and an integer `k` and returns a new list where the elements have been rotated to the right by `k` steps. # Function Signature ```python def rotate_list(nums: list[int], k: int) -> list[int]: ``` # Input * `nums`: A list of integers. * `k`: An integer representing the number of steps to rotate the list by. # Output * Returns a new list where the elements have been rotated `k` steps to the right. # Constraints * The input list can be empty. * The value of `k` can be zero or positive. * The length of the list can be up to (10^5). * The list elements can be negative, zero, or positive integers. # Performance Requirements Your solution should be efficient. Consider optimizations for time complexity (O(n)) where `n` is the length of the list. # Examples ```python # Example 1 nums = [1, 2, 3, 4, 5] k = 2 print(rotate_list(nums, k)) # Output: [4, 5, 1, 2, 3] # Example 2 nums = [0, 0, 0] k = 1 print(rotate_list(nums, k)) # Output: [0, 0, 0] # Example 3 nums = [-1, -100, 3, 99] k = 2 print(rotate_list(nums, k)) # Output: [3, 99, -1, -100] # Example 4 nums = [1, 2, 3, 4, 5] k = 0 print(rotate_list(nums, k)) # Output: [1, 2, 3, 4, 5] # Example 5 nums = [] k = 3 print(rotate_list(nums, k)) # Output: [] ``` # Instructions 1. Read the problem description and examples carefully. 2. Implement the `rotate_list` function. 3. Ensure your solution is efficient and meets the performance requirements.","solution":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the elements of the list nums to the right by k steps. # If the list is empty or k is 0, just return the list as is if not nums or k == 0: return nums # Normalize k in case it\'s larger than the length of nums k = k % len(nums) # Perform the rotation by slicing the list return nums[-k:] + nums[:-k]"},{"question":"# Linked List Cycle Detection and Removal You are tasked with implementing a function to detect and remove a cycle in a singly linked list. A cycle occurs when a node\'s next reference points back to a previous node in the list, creating an infinite loop. Function: `remove_cycle(head: ListNode) -> None` This function should accept the head node of a linked list and modify the list in-place to remove any cycle present. If no cycle exists, the list should remain unchanged. # Input & Output Format 1. **Input for `remove_cycle`**: The head of the singly linked list (`ListNode`). 2. **Output for `remove_cycle`**: No return value, but the linked list should be modified in-place to remove the cycle if it exists. # Constraints * The linked list can have a maximum of 10,000 nodes. * Memory usage should be minimized, and the solution should ideally work in O(1) space. # Requirements * The `ListNode` class is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` * Your function should correctly handle disconnected sections of the list. * Ensure that edge cases, such as an empty list and single-node list without a cycle, are handled appropriately. # Example ```python # Helper function to detect cycle (for testing purposes) def has_cycle(head: ListNode) -> bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False # Creating a linked list with a cycle for testing head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) head.next = second second.next = third third.next = fourth fourth.next = second # Creates a cycle assert has_cycle(head) == True remove_cycle(head) assert has_cycle(head) == False ``` These example tests indicate what the expected outcome for the given conditions should be. Ensure your implementation passes these checks and can handle other potential scenarios effectively.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_cycle(head: ListNode) -> None: Detects and removes a cycle in a singly linked list, if any. Modifies the list in-place. if not head or not head.next: return slow, fast = head, head # Detect cycle using Floyd’s Cycle-Finding Algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # If no cycle is detected, return return # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next # Find the node before the start of the cycle to remove the cycle while fast.next != slow: fast = fast.next # Remove the cycle fast.next = None"},{"question":"# Coding Assessment Question Scenario: You are a software engineer helping a delivery robot navigate a warehouse. The robot operates in a 7x7 grid, with the goal of delivering packages from a starting position to a delivery point. The warehouse has obstacles represented in the grid, and the robot can only move up, down, left, or right. Task: Implement a function `find_shortest_path(grid, start, delivery)` that finds and returns the shortest path from `start` to `delivery` avoiding obstacles specified in the grid. The grid is represented as a 2D list where `0` is a free cell and `1` is an obstacle. The `start` and `delivery` are tuples representing (x, y) coordinates of the start and delivery positions respectively. Function Signature: ```python def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], delivery: Tuple[int, int]) -> List[Tuple[int, int]]: ``` Input: - `grid`: A 7x7 2D list indicating free cells and obstacles. - `start`: A tuple (x, y) indicating the starting position in the grid. - `delivery`: A tuple (x, y) indicating the delivery position in the grid. Output: - Returns a list of tuples representing the path from `start` to `delivery`. If no path is found, return an empty list. Constraints: - The grid is always a 7x7 matrix. - `start` and `delivery` are guaranteed to be on a free cell. - There may or may not be a path between `start` and `delivery`. Example: ```python grid = [ [0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0] ] start = (0, 0) delivery = (6, 6) print(find_shortest_path(grid, start, delivery)) # Expected Output: [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (1, 6), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6)] ``` Notes: - Ensure your implementation handles edge cases gracefully. - Assume the robot can only move in four directions: up, down, left, and right. - Optimize your implementation to handle the grid size effectively. - The path should be the shortest possible route from `start` to `delivery`.","solution":"from collections import deque from typing import List, Tuple def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], delivery: Tuple[int, int]) -> List[Tuple[int, int]]: Finds the shortest path from start to delivery in a 7x7 grid avoiding obstacles. def is_valid(x, y): return 0 <= x < 7 and 0 <= y < 7 and grid[x][y] == 0 def build_path(came_from, current): path = [] while current: path.append(current) current = came_from.get(current) return path[::-1] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up queue = deque([(start, None)]) came_from = {start: None} visited = {start} while queue: current, parent = queue.popleft() if current == delivery: return build_path(came_from, current) for d in directions: neighbor = (current[0] + d[0], current[1] + d[1]) if is_valid(neighbor[0], neighbor[1]) and neighbor not in visited: queue.append((neighbor, current)) visited.add(neighbor) came_from[neighbor] = current return [] grid = [ [0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0] ] start = (0, 0) delivery = (6, 6) print(find_shortest_path(grid, start, delivery))"},{"question":"# Chemical Reaction Balancing Problem Description A chemical reaction must be balanced to satisfy the law of conservation of mass, which states that the number of atoms of each element must be the same on both sides of the reaction. You are given the unbalanced chemical reaction in the form of a string and need to balance it. Task Requirements Implement the function `balance_reaction(reactants: str, products: str) -> dict[str, int]` that takes: - `reactants`: A string of comma-separated reactant chemical formulas. - `products`: A string of comma-separated product chemical formulas. The function must return a dictionary with two keys: - `\'reactants\'`: A dictionary where keys are reactant formulas and values are their coefficients. - `\'products\'`: A dictionary where keys are product formulas and values are their coefficients. Input and Output - **Input**: Two strings: `reactants` and `products`, where each string contains comma-separated formulas of reactants and products. - **Output**: A dictionary with: - `\'reactants\'`: A dictionary with formulas and their corresponding coefficients. - `\'products\'`: A dictionary with formulas and their corresponding coefficients. Constraints - Each chemical formula consists only of capital and lowercase letters for elements, and subscripts for counts (e.g., H2O). - All provided formulas are valid, and the reaction can always be balanced. - The number of reactants and products is between 1 and 5 inclusive. - The number of elements in any reactant or product is between 1 and 5 inclusive. Example ```python >>> balance_reaction(\\"H2, O2\\", \\"H2O\\") {\'reactants\': {\'H2\': 2, \'O2\': 1}, \'products\': {\'H2O\': 2}} >>> balance_reaction(\\"CH4, O2\\", \\"CO2, H2O\\") {\'reactants\': {\'CH4\': 1, \'O2\': 2}, \'products\': {\'CO2\': 1, \'H2O\': 2}} ```","solution":"import re from collections import defaultdict from sympy import Matrix, lcm def parse_formula(formula): pattern = re.compile(r\\"([A-Z][a-z]*)(d*)\\") elements = defaultdict(int) for element, sub in pattern.findall(formula): elements[element] += int(sub) if sub else 1 return elements def balance_reaction(reactants: str, products: str) -> dict: reactants = reactants.split(\\", \\") products = products.split(\\", \\") # Get all unique elements in the reaction all_elements = set() for formula in reactants + products: all_elements.update(parse_formula(formula).keys()) # Map elements to indices element_index = {element: i for i, element in enumerate(all_elements)} # Build the stoichiometric matrix where rows are elements and columns are compounds num_elements = len(all_elements) num_compounds = len(reactants) + len(products) matrix = [] for formula in reactants: row = [0] * num_elements for element, count in parse_formula(formula).items(): row[element_index[element]] = count matrix.append(row) for formula in products: row = [0] * num_elements for element, count in parse_formula(formula).items(): row[element_index[element]] = -count matrix.append(row) matrix = Matrix(matrix).transpose() coeffs = matrix.nullspace()[0] lcm_value = lcm([term.q for term in coeffs]) coefficients = [int(term * lcm_value) for term in coeffs] balanced_reactants = {reactants[i]: coefficients[i] for i in range(len(reactants))} balanced_products = {products[i]: coefficients[i + len(reactants)] for i in range(len(products))} return {\'reactants\': balanced_reactants, \'products\': balanced_products}"},{"question":"# Substring Count in a String Scenario You are developing a text analysis toolkit. One of the features required is counting how many times a specific substring appears within a given string. This will help in identifying the frequency of certain patterns or words in texts. Task Write a function `count_substring` that takes a string and a substring as inputs and returns the number of times the substring occurs in the string. Substring occurrences can overlap. Function Definition ```python def count_substring(s: str, substring: str) -> int: ``` Input - `s`: A string with length ranging from 1 to 10^5. - `substring`: A string with length ranging from 1 to 10^3. Output - An integer representing the number of times the substring appears in the string `s`. Constraints - The input strings consist only of lowercase English letters (`a-z`). Performance Requirements - The function should work efficiently even for the upper limits of the input sizes. Validation Scenarios To validate your solution, it should pass these examples: ```python assert count_substring(\\"ababab\\", \\"aba\\") == 2 assert count_substring(\\"aaaaa\\", \\"aa\\") == 4 assert count_substring(\\"abcdefg\\", \\"hij\\") == 0 ``` Special Cases - Consider overlapping occurrences of the substring. - If the substring is longer than the main string, it should return 0.","solution":"def count_substring(s: str, substring: str) -> int: Returns the number of times the substring occurs in the string s. count = 0 start = 0 while True: start = s.find(substring, start) if start == -1: break count += 1 start += 1 # move to the next position to account for overlapping substrings return count"},{"question":"# Problem Statement: You are tasked with implementing a feature for a chat application to determine the longest message gap. Given a list of timestamped chat messages, write a function `longest_message_gap(timestamps: List[int]) -> int` that calculates the maximum gap in seconds between any two consecutive messages. # Input: * `timestamps`: A list of integers representing the UNIX timestamps of received messages. The list can be empty or contain up to 10^5 timestamps. # Output: * Returns the maximum gap in seconds between any two consecutive messages. If the list is empty or has only one timestamp, return 0. # Example: ```python >>> longest_message_gap([1609459200, 1609459260, 1609459320, 1609459380]) 60 >>> longest_message_gap([1609459200, 1609459205, 1609459210, 1609459290]) 80 >>> longest_message_gap([]) 0 >>> longest_message_gap([1609459200]) 0 ``` # Constraints: * The list can contain up to 10^5 timestamps. * The timestamps are given in non-decreasing order. # Requirements: * Your function should run in O(n) time complexity. * Ensure that your solution handles edge cases such as an empty list or a single timestamp. # Points to Consider: * Think about how you can efficiently determine the gap between consecutive timestamps. * What assumptions can you make about sorting or initial order of timestamps? * Consider the performance implications of different data structures or algorithms to tackle the problem. # Note: You can define helper functions if needed, but the main function to be evaluated should be `longest_message_gap`.","solution":"from typing import List def longest_message_gap(timestamps: List[int]) -> int: Return the maximum gap in seconds between any two consecutive messages. If the list is empty or has only one timestamp, return 0. # Return 0 if the list is empty or has only one timestamp if len(timestamps) < 2: return 0 max_gap = 0 # Iterate through the timestamps to find the maximum gap for i in range(1, len(timestamps)): max_gap = max(max_gap, timestamps[i] - timestamps[i - 1]) return max_gap"},{"question":"# Problem Statement You have been provided with three types of sorting algorithms: Bubble Sort, Quick Sort, and Merge Sort. For a performance evaluation experiment, you are required to implement a function that returns the time taken to sort an array using each algorithm. # Task Implement a function `evaluate_sorting_algorithms` that sorts a given list using each of Bubble Sort, Quick Sort, and Merge Sort, and returns the time taken by each algorithm to complete the sort in milliseconds. Function Signature ```python def evaluate_sorting_algorithms(data: list) -> dict: ``` Input * `data` (list): A list of integers to be sorted. Output * (dict): A dictionary where keys are the algorithm names (`\\"Bubble Sort\\"`, `\\"Quick Sort\\"`, `\\"Merge Sort\\"`) and values are the time taken in milliseconds for each sorting algorithm. Constraints * The length of the list `data` will be between 1 and 10^4 inclusive. * The elements in the list `data` will be integers in the range [-10^5, 10^5]. # Example ```python data = [64, 34, 25, 12, 22, 11, 90] timings = evaluate_sorting_algorithms(data) print(timings) # Output should be a dictionary with timings, e.g., # { # \\"Bubble Sort\\": 15.63, # \\"Quick Sort\\": 0.12, # \\"Merge Sort\\": 0.09 # } ``` # Notes 1. Ensure to use Python\'s built-in `time` module to measure the time taken by each sorting algorithm. 2. Implement the sorting algorithms as described in textbooks or algorithm guides. 3. Make sure the function returns the time taken in milliseconds with precision up to two decimal places. 4. Document any assumptions or additional considerations within your solution.","solution":"import time def bubble_sort(data): n = len(data) arr = data.copy() for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def quick_sort(data): if len(data) <= 1: return data pivot = data[len(data)//2] left = [x for x in data if x < pivot] middle = [x for x in data if x == pivot] right = [x for x in data if x > pivot] return quick_sort(left) + middle + quick_sort(right) def merge_sort(data): if len(data) <= 1: return data middle = len(data) // 2 left = merge_sort(data[:middle]) right = merge_sort(data[middle:]) return merge(left, right) def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return result def evaluate_sorting_algorithms(data): timings = {} start_time = time.time() bubble_sort(data) end_time = time.time() timings[\\"Bubble Sort\\"] = round((end_time - start_time) * 1000, 2) start_time = time.time() quick_sort(data) end_time = time.time() timings[\\"Quick Sort\\"] = round((end_time - start_time) * 1000, 2) start_time = time.time() merge_sort(data) end_time = time.time() timings[\\"Merge Sort\\"] = round((end_time - start_time) * 1000, 2) return timings"},{"question":"# Task You need to implement a function `merge_lists(l1: list, l2: list) -> list` that merges two sorted lists of integers into a single sorted list without using any built-in sorting functions. # Input - Two lists `l1` and `l2`, both sorted in non-decreasing order. # Output - A single list containing all elements from `l1` and `l2` sorted in non-decreasing order. # Constraints - The length of each list will not exceed (10^5). - The integers in the lists will be in the range of (-10^9) to (10^9). # Performance Requirements - The solution should be efficient, with an expected time complexity of (O(n + m)), where (n) and (m) are the lengths of `l1` and `l2`, respectively. # Scenario Your task is to merge two sorted lists into one while maintaining the sorted order. This is often required in data processing pipelines where you might want to combine datasets or streams of data. # Example ```python >>> merge_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_lists([-5, 0, 2], [-6, -3, 1]) [-6, -5, -3, 0, 1, 2] >>> merge_lists([1, 2, 3], []) [1, 2, 3] >>> merge_lists([], [4, 5, 6]) [4, 5, 6] ``` # Implementation ```python def merge_lists(l1: list, l2: list) -> list: result = [] i, j = 0, 0 n, m = len(l1), len(l2) while i < n and j < m: if l1[i] <= l2[j]: result.append(l1[i]) i += 1 else: result.append(l2[j]) j += 1 while i < n: result.append(l1[i]) i += 1 while j < m: result.append(l2[j]) j += 1 return result ```","solution":"def merge_lists(l1: list, l2: list) -> list: result = [] i, j = 0, 0 n, m = len(l1), len(l2) while i < n and j < m: if l1[i] <= l2[j]: result.append(l1[i]) i += 1 else: result.append(l2[j]) j += 1 while i < n: result.append(l1[i]) i += 1 while j < m: result.append(l2[j]) j += 1 return result"},{"question":"# Question: # Binary Search Tree Insertion and Depth Calculation You are to design a simple binary search tree and implement the functionality to insert elements into the tree while tracking the depth of the tree. The depth of a binary search tree (BST) is defined as the number of edges in the longest path from the root node to a leaf node. Description: - Implement a class `BinarySearchTree` with methods for inserting elements and calculating the tree\'s current depth. - The tree should follow the properties of a binary search tree: - The left subtree of a node contains only nodes with values less than the node\'s value. - The right subtree of a node contains only nodes with values greater than the node\'s value. - Both left and right subtrees must also be binary search trees. Class Definition: ```python class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): Inserts a value into the binary search tree. Parameters: value (int): The value to be inserted. def get_depth(self) -> int: Returns the current depth of the binary search tree. Returns: int: The depth of the tree. ``` Input: - `value`: An integer to be inserted into the binary search tree. Output: - No output for the `insert` method. - An integer representing the depth of the tree for the `get_depth` method. Example: ```python # Creating an instance of the BinarySearchTree class bst = BinarySearchTree() # Inserting elements into the BST bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) # Getting the current depth of the BST depth = bst.get_depth() print(depth) # Output should be 2 ``` Constraints: - The values inserted into the BST will be integers. - The tree is initially empty. - Ensure the methods operate efficiently in terms of time complexity. Implementation Details: - Define the necessary class structures to represent the binary search tree, including nodes. - When inserting, keep the binary search tree properties intact. - Use a helper method to calculate the depth recursively. Implement the `BinarySearchTree` class according to the above specifications.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: # value >= node.value if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def get_depth(self) -> int: return self._get_depth(self.root) def _get_depth(self, node): if node is None: return 0 else: left_depth = self._get_depth(node.left) right_depth = self._get_depth(node.right) return max(left_depth, right_depth) + 1"},{"question":"# Binary Search Implementation on a Rotated Array **Context**: You\'ve been hired by a tech company to optimize their search operations within large datasets. They use a variant of binary search tailored for rotated sorted arrays. Your task is to implement this specialized search algorithm to efficiently find the position of a given target value in a rotated sorted array. **Task**: Implement a function `search_in_rotated_array(arr: List[int], target: int) -> int` that takes a list `arr` of integers and an integer `target`, and returns the index of `target` in the list. If `target` is not found, return `-1`. **Requirements**: 1. Implement the search algorithm using the binary search technique, adapted for rotated sorted arrays. 2. Ensure the function handles edge cases (e.g., empty lists, single-element lists, target not found) appropriately. 3. Optimize the algorithm for performance, aiming for O(log n) time complexity. **Input**: * A rotated sorted list `arr` of integers, where `0 <= len(arr) <= 1000` and integers can be positive, negative, or zero. * An integer `target` that you need to search in the list. **Output**: * An integer representing the index of `target` in the list. If the target is not found, return `-1`. **Constraints**: * The solution should use binary search principles, adjusted for the nature of rotated arrays. * No in-built search functions allowed. **Performance**: * Your solution should aim for O(log n) time complexity. **Example**: ```python arr = [4, 5, 6, 7, 0, 1, 2] target = 0 print(search_in_rotated_array(arr, target)) # Output: 4 arr = [4, 5, 6, 7, 0, 1, 2] target = 3 print(search_in_rotated_array(arr, target)) # Output: -1 arr = [1] target = 1 print(search_in_rotated_array(arr, target)) # Output: 0 ``` **Edge Cases**: - `search_in_rotated_array([], 1)` should return `-1`. - `search_in_rotated_array([1], 1)` should return `0`. - `search_in_rotated_array([1], 2)` should return `-1`.","solution":"def search_in_rotated_array(arr, target): Searches for a target value in a rotated sorted array using binary search and returns its index. :param arr: List[int], a rotated sorted list of integers :param target: int, the target value to search for :return: int, the index of target in the list or -1 if it is not found if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Check if the left half is sorted if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: # target in the left half right = mid - 1 else: # target in the right half left = mid + 1 # Otherwise, the right half must be sorted else: if arr[mid] < target <= arr[right]: # target in the right half left = mid + 1 else: # target in the left half right = mid - 1 return -1"},{"question":"# Question: Implement a class that simulates a simple banking system. The banking system should support operations to create an account, deposit money, withdraw money, and check the balance. Your task is to implement methods for these operations within the `BankAccount` class. **Class Definition**: ```python class BankAccount: def __init__(self, account_number: int, account_holder: str, balance: float = 0.0): Initialize a new bank account. Arguments: account_number -- the unique identifier for the account account_holder -- the name of the account holder balance -- the initial balance of the account def deposit(self, amount: float) -> None: Deposit a certain amount of money into the account. Arguments: amount -- the amount of money to deposit (must be positive) def withdraw(self, amount: float) -> bool: Withdraw a certain amount of money from the account. Arguments: amount -- the amount of money to withdraw (must be positive and less than or equal to the current balance) Returns: bool -- True if the withdrawal was successful, False otherwise def get_balance(self) -> float: Retrieve the current account balance. Returns: float -- the current balance of the account ``` **Example Usage**: ```python >>> account = BankAccount(101, \\"Alice\\", 1000.0) >>> account.deposit(500.0) >>> account.get_balance() 1500.0 >>> account.withdraw(200.0) True >>> account.get_balance() 1300.0 >>> account.withdraw(1500.0) False ``` **Constraints**: - The account number is a unique integer. - The account holder\'s name is a non-empty string. - The initial balance is a non-negative float. - The deposit amount should be a positive float. - The withdrawal amount should be a positive float and cannot exceed the current balance. **Explanation**: - The `BankAccount` class must handle basic banking operations correctly. - The `deposit` method should increase the account balance. - The `withdraw` method should decrease the account balance if sufficient funds are available, and return whether the operation was successful. - The `get_balance` method should return the current balance of the account. **Hints**: 1. Ensure proper validation within each method to correctly handle edge cases. 2. Consider implementing a check in the withdraw method to verify if the withdrawal amount does not exceed the available balance.","solution":"class BankAccount: def __init__(self, account_number: int, account_holder: str, balance: float = 0.0): self.account_number = account_number self.account_holder = account_holder self.balance = balance def deposit(self, amount: float) -> None: if amount > 0: self.balance += amount else: raise ValueError(\\"Deposit amount must be positive\\") def withdraw(self, amount: float) -> bool: if amount > 0 and amount <= self.balance: self.balance -= amount return True return False def get_balance(self) -> float: return self.balance"},{"question":"# Question: Implement a class to handle matrix multiplications and transformations You are given a matrix represented as a list of lists, where each sublist is a row in the matrix. Write a class `Matrix` with the following methods: 1. **Constructor `__init__(self, matrix: list[list[int]])`**: - Initializes the matrix. 2. **Method `multiply(self, other: \'Matrix\') -> \'Matrix\'`**: - Multiplies the current matrix with another matrix (`other`). - If the matrices cannot be multiplied (i.e., the number of columns in the first matrix does not match the number of rows in the second matrix), raises a `ValueError` with a message indicating incompatible dimensions. 3. **Method `transpose(self) -> \'Matrix\'`**: - Returns a new `Matrix` instance which is the transpose of the current matrix. # Example ```python matrix_A = [ [1, 2, 3], [4, 5, 6] ] matrix_B = [ [7, 8], [9, 10], [11, 12] ] mA = Matrix(matrix_A) mB = Matrix(matrix_B) # Case 1: Transpose of matrix_A transpose_A = mA.transpose() print(transpose_A.matrix) # Output: [[1, 4], [2, 5], [3, 6]] # Case 2: Matrix multiplication try: result = mA.multiply(mB) print(result.matrix) # Output: [[58, 64], [139, 154]] since: # [1*7 + 2*9 + 3*11, 1*8 + 2*10 + 3*12] # [4*7 + 5*9 + 6*11, 4*8 + 5*10 + 6*12] except ValueError as e: print(e) # Case 3: Incompatible matrices cannot be multiplied matrix_C = [ [1, 2], [3, 4] ] mC = Matrix(matrix_C) try: result = mA.multiply(mC) except ValueError as e: print(e) # Output: Incompatible dimensions for matrix multiplication ``` # Constraints - All matrices will contain integers. - The number of rows and columns for each matrix will be between 1 and 10. - Matrices will be properly formatted as non-empty lists of non-empty lists. - Matrix dimensions will ensure valid transposition.","solution":"class Matrix: def __init__(self, matrix: list[list[int]]): Initializes the matrix. self.matrix = matrix def multiply(self, other: \'Matrix\') -> \'Matrix\': Multiplies the current matrix with another matrix (other). If the matrices cannot be multiplied, raises a ValueError. # Number of columns in self matrix num_cols_self = len(self.matrix[0]) # Number of rows in other matrix num_rows_other = len(other.matrix) if num_cols_self != num_rows_other: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Perform matrix multiplication result_matrix = [] for row in self.matrix: new_row = [] for col in range(len(other.matrix[0])): element = sum(row[i] * other.matrix[i][col] for i in range(num_cols_self)) new_row.append(element) result_matrix.append(new_row) return Matrix(result_matrix) def transpose(self) -> \'Matrix\': Returns a new Matrix instance which is the transpose of the current matrix. transposed_matrix = [] for col in range(len(self.matrix[0])): new_row = [self.matrix[row][col] for row in range(len(self.matrix))] transposed_matrix.append(new_row) return Matrix(transposed_matrix)"},{"question":"# Problem Statement: Implement a Logger Class with Rate Limiting Implement a `Logger` class that manages log messages with a rate limiting feature to restrict how frequently identical messages can be recorded. # Requirements 1. **Class Signature**: ```python class Logger: def __init__(self): pass def should_log(self, timestamp: int, message: str) -> bool: pass ``` 2. **Inputs**: * `timestamp` (int): The current timestamp in seconds granularity. Assume the timestamp is an incrementally increasing integer. * `message` (str): The message to be logged. 3. **Outputs**: * `should_log` function should return a boolean indicating if the message should be logged at the given `timestamp`. 4. **Constraints**: * A message can be logged only once per 10 seconds. * Timestamps are in non-decreasing order. # Example Usage ```python >>> logger = Logger() >>> logger.should_log(1, \\"foo\\") True >>> logger.should_log(2, \\"bar\\") True >>> logger.should_log(3, \\"foo\\") False >>> logger.should_log(11, \\"foo\\") True >>> logger.should_log(12, \\"bar\\") True ``` # Additional Notes - Ensure the class can handle frequent calls efficiently. - If a message is already logged, subsequent calls within 10 seconds with the same message should return `False`. - The class should maintain a log of messages with their respective timestamps to enforce the rate limit. *Hint*: Consider using a dictionary to store the messages and their last logged timestamps for quick look-up and update.","solution":"class Logger: def __init__(self): self.message_timestamps = {} def should_log(self, timestamp: int, message: str) -> bool: if message not in self.message_timestamps or timestamp - self.message_timestamps[message] >= 10: self.message_timestamps[message] = timestamp return True return False"},{"question":"# Coding Assessment Question You are given a class `Matrix` that implements a 2D matrix along with several methods to perform basic matrix operations such as addition, subtraction, and multiplication. Enhance this class by adding a new method `transpose` that computes the transpose of the given matrix. The transpose of a matrix is a new matrix whose rows are the columns of the original. Write the new `transpose` method within the `Matrix` class. The method should not modify the original matrix but should return a new instance of `Matrix` representing the transposed matrix. Class Signature: ```python class Matrix: def __init__(self, data: list[list[float]]): self.data = data # Existing methods for matrix operations (addition, subtraction, multiplication) def transpose(self) -> \'Matrix\': # Implement transpose logic here ``` # Requirements - **Constructor Parameters**: - `data`: A 2D list where each sublist represents a row in the matrix. - **Method**: - `transpose`: No parameters, returns a new `Matrix` object which is the transpose of the original. - **Constraints**: - Matrix dimensions: The matrix is non-empty and contains valid numerical entries. - Memory: The transpose should create and return a new matrix and should not alter the original matrix. # Examples 1. ```python m = Matrix([[1, 2, 3], [4, 5, 6]]) t = m.transpose() print(t.data) ``` Should output: ``` [[1, 4], [2, 5], [3, 6]] ``` 2. ```python m = Matrix([[7, 8], [9, 10], [11, 12]]) t = m.transpose() print(t.data) ``` Should output: ``` [[7, 9, 11], [8, 10, 12]] ```","solution":"class Matrix: def __init__(self, data: list[list[float]]): self.data = data # Other existing methods for matrix operations would be here def transpose(self) -> \'Matrix\': Returns the transpose of the matrix. # Transpose logic transposed_data = list(map(list, zip(*self.data))) return Matrix(transposed_data)"},{"question":"Task: Implement a Decimal to Binary Converter **Objective**: Write a Python function `dec_to_binary` that converts a given integer into its binary string representation. # Function Signature ```python def dec_to_binary(decimal_num: int) -> str: ``` # Input * An integer `decimal_num` which can be positive or negative. # Output * A string representing the binary equivalent of the input integer. The binary string should be prefixed with \\"0b\\", and in case of a negative number, it should be prefixed with \\"-0b\\". # Constraints * The input integer range is typically within the bounds of a 32-bit signed integer. # Examples ```python >>> dec_to_binary(47) \'0b101111\' >>> dec_to_binary(-10) \'-0b1010\' >>> dec_to_binary(0) \'0b0\' >>> dec_to_binary(256) \'0b100000000\' ``` # Instructions - You are required to implement the `dec_to_binary` function without using any built-in Python functions for converting integers to binary other than `bin()` for bonus points, the pure conversion should be calculated manually. - Ensure the function handles all edge cases such as zero, positive, and negative numbers according to the above examples. - Optimize for readability and maintainability of the code.","solution":"def dec_to_binary(decimal_num: int) -> str: Convert a given integer into its binary string representation. :param decimal_num: Integer input, can be positive, negative, or zero. :return: Binary string representation prefixed with \\"0b\\" or \\"-0b\\". if decimal_num == 0: return \'0b0\' is_negative = decimal_num < 0 decimal_num = abs(decimal_num) binary_str = \'\' while decimal_num > 0: binary_str = str(decimal_num % 2) + binary_str decimal_num = decimal_num // 2 if is_negative: return \'-0b\' + binary_str else: return \'0b\' + binary_str"},{"question":"# Coding Assessment Question You are given a list of integers which contains duplicates. Your task is to implement an algorithm to remove all duplicates such that the relative order of the elements remains the same. Your solution should not use any additional space beyond constant space (i.e., O(1) extra space). Function Signature ```python def remove_duplicates(lst: list[int]) -> list[int]: pass ``` Input - A list of integers `lst` (0 ≤ len(lst) ≤ 10^4) where each integer is in the range from -10^3 to 10^3. Output - A list of integers representing the original list with all duplicates removed, maintaining the order of their first occurrence. # Constraints 1. The input list `lst` can be empty. 2. The relative order of elements in the modified list must be the same as their appearance in the input list. 3. You must not use any additional storage except a few variables (constant space O(1)). # Examples ```python >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 5, 6, 6, 7]) [4, 5, 6, 7] >>> remove_duplicates([1, 2, 3, 4]) [1, 2, 3, 4] >>> remove_duplicates([]) [] >>> remove_duplicates([8, 8, 8, 8, 8]) [8] ``` # Notes 1. You must ensure that the list maintains the order of the elements as they first appeared. 2. Your algorithm should not use any additional data structures except for the list itself.","solution":"def remove_duplicates(lst: list[int]) -> list[int]: Removes duplicates from the list while maintaining the original order of elements. This implementation uses a constant extra space (O(1)), modifying the list in place. if len(lst) <= 1: return lst insertion_index = 1 # The next position to insert a unique element for i in range(1, len(lst)): found_duplicate = False for j in range(insertion_index): if lst[i] == lst[j]: found_duplicate = True break if not found_duplicate: lst[insertion_index] = lst[i] insertion_index += 1 # Trim the list to the new length return lst[:insertion_index]"},{"question":"Problem Statement You are tasked with implementing a function that performs matrix transposition on a given 2D matrix and another function that finds the maximum value in the transposed matrix. # Function Signature ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: # Your implementation here def max_in_transposed(matrix: list[list[int]]) -> int: # Your implementation here ``` # Input - `matrix`: A 2D list (list of lists) representing an m x n matrix with integers. # Output - `transpose_matrix(matrix)`: Returns the transposed matrix as a new 2D list. In the transposed matrix, the rows and columns are swapped from the original matrix. - `max_in_transposed(matrix)`: Returns the maximum value in the transposed matrix. # Constraints - The dimensions of the matrix (m and n) are both between 1 and 500, inclusive. - All elements in the matrix are integers. - The functions should handle edge cases where the matrix has only one row or one column. # Performance Requirements - The `transpose_matrix` function should run in O(m * n) time, where m is the number of rows and n is the number of columns. - The `max_in_transposed` function should also run in O(m * n) time. # Example ```python >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> transpose_matrix(matrix) [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] >>> max_in_transposed(matrix) 9 >>> matrix_2 = [ [10, -2, 15], [7, 6, -5] ] >>> transpose_matrix(matrix_2) [ [10, 7], [-2, 6], [15, -5] ] >>> max_in_transposed(matrix_2) 15 ``` # Additional Information For both functions, ensure you handle matrices with varying row and column counts. Consider edge cases such as matrices with negative and positive values, and matrices containing duplicate values.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Returns the transpose of the given 2D matrix. return [list(row) for row in zip(*matrix)] def max_in_transposed(matrix: list[list[int]]) -> int: Finds the maximum value in the transposed matrix of the given 2D matrix. transposed = transpose_matrix(matrix) max_value = float(\'-inf\') for row in transposed: max_value = max(max_value, *row) return max_value"},{"question":"# Question: Implement a Temperature Conversion Function In this exercise, you are required to implement a Python function that converts a temperature reading from Fahrenheit to Celsius and Kelvin. Function Signature ```python def convert_temperature(temp_f: float) -> tuple: ``` Input * A floating-point number `temp_f` representing the temperature in Fahrenheit. Output * A tuple containing two floating-point numbers: - The first number is the equivalent temperature in Celsius. - The second number is the equivalent temperature in Kelvin. Requirements * The function should perform the following conversions: ``` temp_c = (temp_f - 32) * 5/9 temp_k = temp_c + 273.15 ``` * Ensure the output is formatted to two decimal places for both Celsius and Kelvin values. Example Usage ```python # Example 1 print(convert_temperature(32)) # Output: (0.0, 273.15) # Example 2 print(convert_temperature(100)) # Output: (37.78, 310.93) ```","solution":"def convert_temperature(temp_f: float) -> tuple: Converts a temperature from Fahrenheit to Celsius and Kelvin Parameters: - temp_f: float : Temperature in Fahrenheit Returns: - tuple : A tuple containing the temperature in Celsius and Kelvin temp_c = (temp_f - 32) * 5/9 temp_k = temp_c + 273.15 return round(temp_c, 2), round(temp_k, 2)"},{"question":"# Coding Question: Implementing a Binary Search Tree Traversal **Context**: You are developing a module that deals with searching and maintaining a set of records efficiently. Due to its organized structure, a Binary Search Tree (BST) is optimal for these operations. You are required to implement traversal methods that allow for various ways to access and print the records stored in a BST. **Task**: Implement the following traversal algorithms for a BST - Inorder, Preorder, and Postorder traversals. **Input**: * A binary search tree `root` containing nodes with integer values. **Output**: * Three lists of integers, each representing the node values in the order they are visited for Inorder, Preorder, and Postorder traversals respectively. **Constraints**: * Your implementation should correctly traverse the BST and return lists for each traversal in a clean and readable manner. * Assume the `Node` class is defined as follows and will be used as input: ```python class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` **Specification**: Function Signatures: ```python def inorder_traversal(root: Node) -> list[int]: pass def preorder_traversal(root: Node) -> list[int]: pass def postorder_traversal(root: Node) -> list[int]: pass ``` **Example**: ```python # Sample tree: # 4 # / # 2 5 # / # 1 3 root = Node(4, Node(2, Node(1), Node(3)), Node(5)) >>> inorder_traversal(root) [1, 2, 3, 4, 5] >>> preorder_traversal(root) [4, 2, 1, 3, 5] >>> postorder_traversal(root) [1, 3, 2, 5, 4] ```","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder_traversal(root: Node) -> list[int]: def _inorder(node): if node: yield from _inorder(node.left) yield node.value yield from _inorder(node.right) return list(_inorder(root)) def preorder_traversal(root: Node) -> list[int]: def _preorder(node): if node: yield node.value yield from _preorder(node.left) yield from _preorder(node.right) return list(_preorder(root)) def postorder_traversal(root: Node) -> list[int]: def _postorder(node): if node: yield from _postorder(node.left) yield from _postorder(node.right) yield node.value return list(_postorder(root))"},{"question":"# Scenario A start-up company is developing an inventory management system. As part of their requirements, they need a function to determine the most consecutive days of stock availability given a list of stock status per day. They want a solution that leverages efficient data processing for performance optimization. # Problem Statement Implement the function `longest_stock_availability(stock_status: List[int]) -> int` which takes a list of integers representing the stock status for consecutive days and returns the length of the longest continuous segment where the stock is available (represented by `1`). # Function Signature ```python def longest_stock_availability(stock_status: List[int]) -> int: ``` # Input - `stock_status` (List[int]): A list of integers where `1` indicates stock availability and `0` indicates out of stock for each corresponding day. # Output - `int`: The length of the longest segment of consecutive days where stock is available. # Constraints - The length of `stock_status` will be at least `1`. - The individual elements of `stock_status` will either be `0` or `1`. # Examples ```python longest_stock_availability([1, 0, 1, 1, 0, 1]) -> 2 longest_stock_availability([0, 0, 0, 1]) -> 1 longest_stock_availability([1, 1, 1, 1]) -> 4 longest_stock_availability([0]) -> 0 longest_stock_availability([1, 0, 1, 0, 1, 1, 0, 1]) -> 2 ``` # Guidelines 1. Traverse the list to maintain a count of the longest segment of consecutive `1`s. 2. Use a temporary counter to track current consecutive counts and update the maximum counter accordingly. 3. Ensure edge cases, such as lists with no `1`s or no `0`s, are handled correctly.","solution":"from typing import List def longest_stock_availability(stock_status: List[int]) -> int: max_length = 0 current_length = 0 for status in stock_status: if status == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"# Custom Data Structure Design # Objective: Create a `TimeMap` class that supports setting and retrieving key-value pairs with timestamp-based querying. # Constraints: 1. Assume all inputs are valid. 2. The `set` operation should record a value associated with a key for a given timestamp. 3. The `get` operation should retrieve the value associated with a key for the largest timestamp less than or equal to a given timestamp. 4. Solutions must accommodate large volumes of key-value-timestamp entries efficiently. # Requirements: 1. Implement the `set()` method: * Arguments: a string `key`, a string `value`, and an integer `timestamp`. * Stores the `value` associated with the `key` at the specified `timestamp`. 2. Implement the `get()` method: * Arguments: a string `key` and an integer `timestamp`. * Returns the value associated with the `key` for the largest timestamp `t` such that `t` <= `timestamp`. If no such `timestamp` exists, return an empty string. # Input: - Calls to `TimeMap.set(key, value, timestamp)` for storing key-value-timestamp entries. - Calls to `TimeMap.get(key, timestamp)` for retrieving the value associated with `key` at or before the given `timestamp`. # Output: - For `get` calls, return the corresponding value or an empty string if the key does not exist for the given timestamp. # Example: ```python time_map = TimeMap() time_map.set(\\"foo\\", \\"bar\\", 1) print(time_map.get(\\"foo\\", 1)) # Output: \\"bar\\" print(time_map.get(\\"foo\\", 3)) # Output: \\"bar\\" time_map.set(\\"foo\\", \\"bar2\\", 4) print(time_map.get(\\"foo\\", 4)) # Output: \\"bar2\\" print(time_map.get(\\"foo\\", 5)) # Output: \\"bar2\\" ``` # Edge Cases: 1. Queries with timestamps earlier than any set timestamp for the given key. 2. Multiple `set` operations with the same key and `timestamp`. 3. Large number of entries to test the efficiency of the `TimeMap`. # Performance Notes: - Use efficient data structures (e.g., hash maps, binary search) to ensure both `set` and `get` operations run in logarithmic time complexity. - Manage memory usage to handle potentially large numbers of entries effectively.","solution":"from collections import defaultdict import bisect class TimeMap: def __init__(self): Initialize the data structure. self.store = defaultdict(list) def set(self, key, value, timestamp): Stores the value with the key and the given timestamp. self.store[key].append((timestamp, value)) def get(self, key, timestamp): Retrieves the value associated with the key at or before the given timestamp. if key not in self.store: return \\"\\" values = self.store[key] # Use binary search to find the appropriate timestamp index = bisect.bisect_right(values, (timestamp, chr(127))) if index == 0: return \\"\\" return values[index - 1][1]"},{"question":"# Question: Implement a Circular Queue in Python You are tasked with implementing a Circular Queue class in Python. A Circular Queue is a data structure that uses a fixed-size array, and it links the end of the array back to the beginning to make a circle. # Requirements 1. **Class**: Implement the `CircularQueue` class with the following methods: - `__init__(self, capacity: int)` - `enqueue(self, value: int) -> None` - `dequeue(self) -> int` - `is_full(self) -> bool` - `is_empty(self) -> bool` - `front(self) -> int` - `rear(self) -> int` 2. **Attributes**: - Fixed size `queue` to hold the elements. - `front` index for the front of the queue. - `rear` index for the rear of the queue. - `size` to keep track of the number of elements in the queue. 3. **Edge Cases**: - Handle enqueue operation gracefully when the queue is full. - Handle dequeue operation gracefully when the queue is empty. 4. **Efficiency Requirement**: Achieve constant time complexity for enqueue and dequeue operations, i.e., O(1). # Input - `capacity`: An integer representing the maximum number of elements that the queue can hold (must be positive). - `value`: An integer value to be added to the queue during enqueue. # Output - Methods will not return any values except for `dequeue`, `front`, and `rear` which return integers. # Example Initialization: ```python queue = CircularQueue(3) ``` Operations: ```python queue.enqueue(10) queue.enqueue(20) queue.enqueue(30) print(queue.is_full()) # Output: True print(queue.dequeue()) # Output: 10 queue.enqueue(40) print(queue.front()) # Output: 20 print(queue.rear()) # Output: 40 print(queue.is_empty()) # Output: False print(queue.dequeue()) # Output: 20 print(queue.dequeue()) # Output: 30 print(queue.dequeue()) # Output: 40 print(queue.is_empty()) # Output: True ``` # Additional Notes: - Raise a `ValueError` with an appropriate message if enqueue is attempted on a full queue or dequeue is attempted on an empty queue. - Include tests to validate each method\'s functionality and edge cases.","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.front_index = 0 self.rear_index = -1 self.size = 0 def enqueue(self, value: int) -> None: if self.is_full(): raise ValueError(\\"Enqueue operation failed: Queue is full.\\") self.rear_index = (self.rear_index + 1) % self.capacity self.queue[self.rear_index] = value self.size += 1 def dequeue(self) -> int: if self.is_empty(): raise ValueError(\\"Dequeue operation failed: Queue is empty.\\") value = self.queue[self.front_index] self.queue[self.front_index] = None self.front_index = (self.front_index + 1) % self.capacity self.size -= 1 return value def is_full(self) -> bool: return self.size == self.capacity def is_empty(self) -> bool: return self.size == 0 def front(self) -> int: if self.is_empty(): raise ValueError(\\"Front operation failed: Queue is empty.\\") return self.queue[self.front_index] def rear(self) -> int: if self.is_empty(): raise ValueError(\\"Rear operation failed: Queue is empty.\\") return self.queue[self.rear_index]"},{"question":"# Problem Description: You are provided with a 2D grid representing a forest. Each cell in the grid can either be empty (`0`), contain a tree (`1`), or contain water (`2`). Your task is to determine the minimum steps required to reach from the top-left corner to the bottom-right corner of the grid by only stepping on empty cells (`0`). If it\'s not possible to reach the destination, return `-1`. You can move up, down, left, or right from a cell. # Function Signature: ```python def min_steps_forest(grid: List[List[int]]) -> int: pass ``` # Input: - `grid`: A list of lists of integers representing the forest. # Output: - An integer representing the minimum steps required to reach from the top-left corner to the bottom-right corner, or `-1` if it is not possible. # Constraints: - The grid\'s dimensions are between (1 leq R, C leq 1000) where `R` is the number of rows and `C` is the number of columns. - Each cell in the grid is either a `0` (empty), `1` (tree), or `2` (water). # Example: ```python # Example Usage grid = [ [0, 0, 1], [1, 0, 2], [0, 0, 0] ] print(min_steps_forest(grid)) # Output: 4 ``` # Explanation: In the given example, the shortest path from the top-left corner to the bottom-right corner is of length 4 steps: (0,0) -> (0,1) -> (1,1) -> (2,1) -> (2,2). # Notes: - You may assume the input grid is not empty. - Use Breadth-First Search (BFS) for finding the shortest path in the grid. # Edge Cases: - Consider grids where it is immediately clear no path exists, such as the entire path being obstructed by trees or water. - Handle edge cases where the destination cell itself is not navigable.","solution":"from collections import deque from typing import List def min_steps_forest(grid: List[List[int]]) -> int: if grid[0][0] != 0 or grid[-1][-1] != 0: return -1 ROWS, COLS = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == ROWS - 1 and c == COLS - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < ROWS and 0 <= nc < COLS and (nr, nc) not in visited: if grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"# Coding Question **Objective**: Write a function to determine the results of multiple bitwise AND operations on pairs of integers. # Problem Statement You are given a list of tuples where each tuple contains two integers. Your task is to write a function `evaluate_and_operations(operations: List[Tuple[int, int]]) -> List[int]` that takes this list as input and returns a list of results where each result is the bitwise AND of the corresponding pair of integers. # Input Format - A list of tuples, each containing two integers. - Example: `[(4, 5), (1, 2), (8, 7), (15, 15)]` # Output Format - A list of integers corresponding to the bitwise AND of each pair of integers from the input list. - Example: `[4, 0, 0, 15]` # Constraints - The integers in the tuples will be non-negative and within a practical range considering standard integer limits. - The list can be empty, in which case the output should also be an empty list. - The integer values can be as large as 2^31 - 1 (maximum value for a 32-bit signed integer). # Example ```python assert evaluate_and_operations([(4, 5), (1, 2), (8, 7), (15, 15)]) == [4, 0, 0, 15] assert evaluate_and_operations([]) == [] assert evaluate_and_operations([(12, 3)]) == [0] ``` # Requirements - You must write the core logic using bitwise AND operations. - Ensure that your implementation is efficient and handles all edge cases.","solution":"from typing import List, Tuple def evaluate_and_operations(operations: List[Tuple[int, int]]) -> List[int]: Given a list of tuples, each containing two integers, return a list of results where each result is the bitwise AND of the corresponding pair of integers. return [a & b for a, b in operations]"},{"question":"# Coding Assessment Question Context You are tasked with solving a problem that involves generating Pascal\'s Triangle and computing specific values from it. This problem tests your ability to implement recursive algorithms and understand combinatorial mathematics. Problem Statement Write a function `pascals_triangle_value(row: int, col: int) -> int` that calculates the value at a specific row and column in Pascal\'s Triangle. Pascal\'s Triangle is a triangular array where the value at the row `n` and column `k` corresponds to the binomial coefficient `nCk`. Input * `row` (integer): A non-negative integer representing the row index (0 ≤ row ≤ 30). * `col` (integer): A non-negative integer where 0 ≤ col ≤ row, representing the column index. Output * Returns an integer representing the value at the given row and column in Pascal\'s Triangle. Examples ```python >>> pascals_triangle_value(4, 2) 6 >>> pascals_triangle_value(5, 3) 10 >>> pascals_triangle_value(6, 0) 1 >>> pascals_triangle_value(10, 5) 252 ``` Constraints * Ensure the function can handle the largest inputs within the provided range efficiently. * It would be best to use combinatorial mathematics or a recursive approach with memoization to ensure the solution is optimized.","solution":"def pascals_triangle_value(row: int, col: int) -> int: Returns the value at the specified row and column in Pascal\'s Triangle. def binomial_coefficient(n, k): if k == 0 or k == n: return 1 if k > n - k: # Take advantage of symmetry k = n - k c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c return binomial_coefficient(row, col)"},{"question":"# Task: Implement a function that performs matrix rotation in 90-degree increments. Specifically, given an NxN 2D NumPy array representing an image, rotate the matrix to the right (clockwise) and another function that rotates the matrix to the left (counterclockwise). # Problem Statement: Write two Python functions `rotate_matrix_clockwise(matrix: np.ndarray) -> np.ndarray` and `rotate_matrix_counterclockwise(matrix: np.ndarray) -> np.ndarray` that take an NxN 2D NumPy array and return a new N x N 2D NumPy array which is the rotated version of the input matrix. # Function Signatures: ```python def rotate_matrix_clockwise(matrix: np.ndarray) -> np.ndarray: def rotate_matrix_counterclockwise(matrix: np.ndarray) -> np.ndarray: ``` # Input: * `matrix`: A 2D NumPy array of size NxN representing an image (N >= 2). # Output: * A 2D NumPy array representing the rotated image. # Constraints: * The input matrix will always be a square matrix with N >= 2. # Example: Given a matrix: ``` [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` After a 90-degree clockwise rotation: ``` [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` After a 90-degree counterclockwise rotation: ``` [[3, 6, 9], [2, 5, 8], [1, 4, 7]] ``` # Implementation Details: - You may use NumPy functions to simplify the implementation. - Ensure your functions handle different NxN matrices correctly. # Example Call: Rotate Clockwise: ```python import numpy as np matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) result = rotate_matrix_clockwise(matrix) print(result) ``` # Expected Output: ```python [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` Rotate Counterclockwise: ```python result_ccw = rotate_matrix_counterclockwise(matrix) print(result_ccw) ``` # Expected Output: ```python [[3, 6, 9], [2, 5, 8], [1, 4, 7]] ```","solution":"import numpy as np def rotate_matrix_clockwise(matrix: np.ndarray) -> np.ndarray: Rotates the given NxN 2D NumPy array 90 degrees clockwise. return np.rot90(matrix, k=-1) def rotate_matrix_counterclockwise(matrix: np.ndarray) -> np.ndarray: Rotates the given NxN 2D NumPy array 90 degrees counterclockwise. return np.rot90(matrix, k=1)"},{"question":"# Problem Statement You need to implement a function that takes a string containing a mathematical expression and evaluates it to return the result as an integer. The expression will contain non-negative integers, `+` (addition), and `*` (multiplication) operations, and all operations will follow their natural precedence (i.e., multiplication before addition). # Function Signature ```python def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, \'+\' (addition), and \'*\' (multiplication) operations. Args: expression (str): The mathematical expression to be evaluated. Returns: int: The result of the evaluated expression. ``` # Input Constraints - `expression` is a non-empty string containing only non-negative integers (0-9), `+`, and `*`. - The length of `expression` is between 1 and 1000. - There will be no spaces in the expression. - The input expression is guaranteed to be valid. # Output Format - Return the result of the evaluated expression as an integer. # Example ```python print(evaluate_expression(\\"2+3*4\\")) # Output: 14 print(evaluate_expression(\\"5*3+2\\")) # Output: 17 print(evaluate_expression(\\"0*1+2\\")) # Output: 2 ``` # Evaluation Criteria - Correctness: The function should correctly evaluate the expression following the rules of operator precedence. - Efficiency: The function should run efficiently for large input sizes. - Edge Cases: The function should handle edge cases such as having only one number, maximum multiplication and addition, and combinations thereof effectively.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, \'+\' (addition), and \'*\' (multiplication) operations. Args: expression (str): The mathematical expression to be evaluated. Returns: int: The result of the evaluated expression. # Split the expression by \'+\' to handle addition separately sum_parts = expression.split(\'+\') total = 0 for part in sum_parts: # Split each part by \'*\' to handle multiplication product_parts = part.split(\'*\') product = 1 for num in product_parts: product *= int(num) total += product return total"},{"question":"# Problem Statement You are given a string `s` and a pattern `p`. Your task is to implement a function that finds the starting index of the first occurrence of the pattern `p` in the string `s` using the Knuth-Morris-Pratt (KMP) algorithm. If the pattern is not found, return -1. # Function Signature ```python def kmp_search(s: str, p: str) -> int: ``` # Input * A string ( s ) (1 ≤ |s| ≤ 10^5) * A string ( p ) (1 ≤ |p| ≤ 10^4) # Output * An integer indicating the starting index of the first occurrence of the pattern `p` in the string `s`, or -1 if the pattern is not found. # Constraints * Both `s` and `p` consist of lowercase English letters. # Example ```python assert kmp_search(\\"ababcababcabc\\", \\"abc\\") == 2 assert kmp_search(\\"hello\\", \\"ll\\") == 2 assert kmp_search(\\"aaaaaaa\\", \\"bba\\") == -1 assert kmp_search(\\"mississippi\\", \\"issi\\") == 1 ``` # Explanation For each test case: 1. Construct the prefix table (also known as the \\"partial match\\" table) for the pattern `p`. 2. Use the prefix table to search for the pattern `p` in the string `s` efficiently. # Notes * Your implementation should handle large inputs efficiently. * The function should only use the Knuth-Morris-Pratt algorithm to perform the search. Ensure proper construction of the prefix table and use it correctly for pattern matching.","solution":"def build_kmp_table(p): Build the KMP table for the given pattern. m = len(p) kmp_table = [0] * m j = 0 for i in range(1, m): while j > 0 and p[i] != p[j]: j = kmp_table[j - 1] if p[i] == p[j]: j += 1 kmp_table[i] = j return kmp_table def kmp_search(s: str, p: str) -> int: Returns the starting index of the first occurrence of the pattern `p` in the string `s`. If the pattern is not found, return -1. if not p: return 0 n, m = len(s), len(p) kmp_table = build_kmp_table(p) j = 0 for i in range(n): while j > 0 and s[i] != p[j]: j = kmp_table[j - 1] if s[i] == p[j]: if j == m - 1: return i - m + 1 else: j += 1 return -1"},{"question":"# Question: Daily Step Tracker Optimization You are developing a fitness tracking application that helps users monitor their daily physical activity. One of the key features is to analyze the sequence of daily step counts and identify periods of high activity. Your task is to write a function that finds the maximum sum of steps recorded in any contiguous subarray of a user\'s daily step counts. This will help users to identify the period in which they were most active. **Function Specification** **Function Name**: `max_subarray_steps` **Parameters**: - `steps` (List[int]): A list of integers representing the number of steps taken each day. **Output**: - Returns the maximum sum of steps in any contiguous subarray of the input list. **Constraints**: - The length of the `steps` list can be up to 10,000 elements. - Each element in the `steps` list is an integer between -10,000 and 10,000. - The `steps` list will contain at least one element. **Performance Requirements**: - The function should run in linear time O(n) where n is the length of the input list. **Example Usage**: ```python >>> max_subarray_steps([1, -2, 3, 10, -4, 7, 2, -5]) 18 >>> max_subarray_steps([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_steps([5, 4, -1, 7, 8]) 23 ``` **Error Handling**: - If the `steps` list is empty, the function should raise a `ValueError` with an appropriate message. **Implementation**: Write a function that implements Kadane’s algorithm to find the maximum sum of a contiguous subarray. The algorithm is efficient and runs in linear time, making it suitable for large input lists.","solution":"def max_subarray_steps(steps): Finds the maximum sum of steps in any contiguous subarray of the input list. Parameters: - steps (List[int]): A list of integers representing the number of steps taken each day. Returns: - int: The maximum sum of steps in any contiguous subarray. Raises: - ValueError: If the steps list is empty. if not steps: raise ValueError(\\"The steps list should not be empty.\\") current_max = global_max = steps[0] for step in steps[1:]: current_max = max(step, current_max + step) if current_max > global_max: global_max = current_max return global_max"},{"question":"# Problem Statement You are given a list of integers representing the heights of buildings in a city skyline. The task is to determine the total area of the skyline rectangle formed by these buildings when viewed from the side. Each building has a width of 1 unit. # Function Signature ```python def largestRectangleArea(heights: List[int]) -> int: ``` # Input - `heights` (List[int]): A list of non-negative integers where each integer represents the height of a building. # Output - Return an integer which is the area of the largest rectangle that can be formed in the skyline representation. # Constraints - The number of buildings (1 leq len(heights) leq 10^5). - The height of each building (0 leq heights[i] leq 10^4). # Example ```python heights = [2, 1, 5, 6, 2, 3] print(largestRectangleArea(heights)) # Expected output: 10 ``` # Requirements 1. Implement the function `largestRectangleArea(heights: List[int]) -> int` to find the largest rectangle in the histogram formed by the given building heights. 2. Ensure your function is optimized for efficiency, particularly for handling large inputs. # Tips - Utilize a stack to keep track of building indices. - Maximize area by evaluating potential rectangles at the height of each building when processing.","solution":"def largestRectangleArea(heights): Finds the largest rectangle in the histogram formed by the heights. :param heights: List[int] - list of building heights. :return: int - area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Question: Linear Regression Class Implementation You are required to implement a basic class, `LinearRegression`, which performs simple linear regression on a given dataset. The class should include methods for fitting the model to the data, predicting values based on the model, calculating the coefficient of determination (R²), and handling potential exceptions during initialization and computation. Your task: Implement the `LinearRegression` class with the following functionalities: 1. **Initialization**: - Initialize a linear regression model with empty parameters for slope and intercept. Initialize placeholders for the data (x and y). - If data is provided directly at initialization, ensure it is properly formatted; otherwise, raise a `ValueError`. 2. **Fit Model**: - `fit(self, x: List[float], y: List[float]) -> None`: Calculate and set the slope and intercept for the linear regression model using the least squares method. If x and y have different lengths, raise a `ValueError`. 3. **Predict**: - `predict(self, x: float) -> float`: Predict and return the y value using the linear model for a given x. If the model hasn\'t been fitted yet, raise a `RuntimeError`. 4. **Coefficient of Determination (R²)**: - `r_squared(self) -> float`: Calculate and return the R² value for the fitted model. If the model hasn\'t been fitted yet, raise a `RuntimeError`. Requirements: * Name of the class: `LinearRegression` * The `fit` method should handle invalid data input (e.g., non-numeric or mismatched data lengths) gracefully. * Ensure proper exceptions are raised where necessary. Example Scenarios & Edge Cases: 1. **Edge Cases**: * Fitting with insufficient data points. * Prediction before fitting the model. 2. **Example Usage**: ```python model = LinearRegression() x_data = [1, 2, 3, 4, 5] y_data = [2, 4, 5, 4, 5] model.fit(x_data, y_data) print(model.predict(2.5)) # Expected: Predicted y value for x = 2.5 print(model.r_squared()) # Expected: R² value of the fitted model # Errors try: empty_model = LinearRegression() empty_model.predict(3.0) except RuntimeError as e: print(e) # Expected: \\"Model has not been fitted yet.\\" try: model.fit([1, 2], [1]) except ValueError as e: print(e) # Expected: \\"Mismatched input lengths for x and y.\\" ``` Implement the class with all necessary methods and ensure that it handles edge cases, errors, and outputs correctly as described.","solution":"class LinearRegression: def __init__(self, x=None, y=None): self.slope = None self.intercept = None self.x = [] self.y = [] if x is not None and y is not None: if len(x) != len(y): raise ValueError(\\"Mismatched input lengths for x and y.\\") self.x = x self.y = y self.fit(x, y) def fit(self, x, y): if len(x) != len(y): raise ValueError(\\"Mismatched input lengths for x and y.\\") n = len(x) if n <= 1: raise ValueError(\\"At least two data points are required to fit the model.\\") x_mean = sum(x) / n y_mean = sum(y) / n num = sum((x[i] - x_mean) * (y[i] - y_mean) for i in range(n)) den = sum((x[i] - x_mean) ** 2 for i in range(n)) if den == 0: raise ValueError(\\"Cannot fit a model with zero variance in input data.\\") self.slope = num / den self.intercept = y_mean - self.slope * x_mean def predict(self, x): if self.slope is None or self.intercept is None: raise RuntimeError(\\"Model has not been fitted yet.\\") return self.slope * x + self.intercept def r_squared(self): if self.slope is None or self.intercept is None: raise RuntimeError(\\"Model has not been fitted yet.\\") y_mean = sum(self.y) / len(self.y) total_variance = sum((y - y_mean) ** 2 for y in self.y) explained_variance = sum((self.predict(self.x[i]) - y_mean) ** 2 for i in range(len(self.x))) return explained_variance / total_variance"},{"question":"# Scenario: You\'re tasked with developing a feature for a message board application that identifies the most frequent word in a given text. Words are defined as sequences of characters separated by whitespace. The frequency is determined case-insensitively, meaning that \\"Apple\\" and \\"apple\\" should be counted as the same word. Write a function that takes a string as input and returns the most frequent word in that string. If there are multiple words with the highest frequency, return the lexicographically smallest one. # Function Specification **Function name**: `most_frequent_word` **Input**: - `text` (str): A non-empty string containing words separated by spaces. **Output**: - (str): The most frequent word (case-insensitively). In the case of a tie, return the lexicographically smallest word. **Constraints**: - The input string will contain only alphabetic characters and spaces. - The solution should have a time complexity of O(n log k), where n is the number of characters in the input string, and k is the number of unique words. **Examples**: ```python >>> most_frequent_word(\\"Apple apple banana Banana\\") \\"apple\\" >>> most_frequent_word(\\"Hello hello HELLO\\") \\"hello\\" >>> most_frequent_word(\\"Dog cat Dog CAT dog\\") \\"dog\\" ``` # Task: Complete the implementation of the `most_frequent_word` function to correctly identify the most frequent word as described.","solution":"from collections import Counter def most_frequent_word(text): # Split the text into words and convert to lower case words = text.lower().split() # Count the frequency of each word word_counts = Counter(words) # Find the word with the highest frequency most_frequent = max(word_counts.items(), key=lambda x: (x[1], -ord(x[0][0])))[0] return most_frequent"},{"question":"# Coding Assessment Question You need to implement a function `is_valid_schedule(intervals: List[Tuple[int, int]]) -> bool` to determine if a given list of time intervals can represent a valid schedule without any overlaps. Each time interval is represented as a tuple `(start, end)` where `0 <= start < end <= 10^9`. The function should return `True` if no two intervals overlap, and `False` otherwise. Input - `intervals` (1 <= |intervals| <= 10^4): A list of tuples where each tuple `(start, end)` represents a time interval. Output - Return `True` if the intervals do not overlap, otherwise return `False`. Constraints - Use sorting to solve this problem efficiently. Example ```python from typing import List, Tuple def is_valid_schedule(intervals: List[Tuple[int, int]]) -> bool: # Sort intervals based on start times intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): # If the start of the current interval is less than the end of the previous interval if intervals[i][0] < intervals[i-1][1]: return False return True # Examples print(is_valid_schedule([(1, 3), (2, 4), (5, 6)])) # Output: False print(is_valid_schedule([(1, 2), (2, 3), (3, 4)])) # Output: True print(is_valid_schedule([(5, 10), (0, 5), (15, 20)])) # Output: True print(is_valid_schedule([(1, 5), (3, 7), (6, 8)])) # Output: False print(is_valid_schedule([(7, 8), (1, 3), (4, 5)])) # Output: True ```","solution":"from typing import List, Tuple def is_valid_schedule(intervals: List[Tuple[int, int]]) -> bool: Determines if the given list of time intervals can represent a valid schedule without any overlaps. Parameters: intervals (List[Tuple[int, int]]): A list of tuples where each tuple represents a time interval (start, end). Returns: bool: True if no two intervals overlap, False otherwise. # Sort intervals based on start times intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): # If the start of the current interval is less than the end of the previous interval if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"# Scenario Graph traversal is a fundamental algorithm in computer science, utilized in various domains like network analysis, web crawling, and game development. One specific problem in this area involves finding the shortest path within a weighted graph. # Problem Statement You are tasked with finding the shortest path between two nodes in a weighted, undirected graph. Write a function to determine the shortest distance from the start node to the end node using Dijkstra\'s algorithm. If the end node is unreachable from the start node, the function should return -1. # Function Signature ```python def shortest_path(graph: List[Tuple[int, int, int]], start: int, end: int) -> int: pass ``` # Input * `graph`: A list of tuples where each tuple `(u, v, w)` represents an edge between nodes `u` and `v` with weight `w`. * `start`: An integer that specifies the starting node. * `end`: An integer that specifies the target node. # Output * An integer representing the shortest distance from the start node to the end node. Return -1 if there is no path from `start` to `end`. # Constraints * The graph does not contain more than 10,000 unique nodes. * Edge weights are positive integers. * The graph is undirected, meaning if `(u, v, w)` is an edge, there exists a reverse edge `(v, u, w)` automatically. # Examples ```python assert shortest_path([(1, 2, 5), (2, 3, 10), (1, 3, 15)], 1, 3) == 15 assert shortest_path([(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 5, 3)], 1, 5) == 7 assert shortest_path([(1, 2, 1), (1, 3, 4), (2, 3, 2)], 1, 4) == -1 ``` # Explanation 1. In the first example, the shortest path from node 1 to node 3 is directly 15. 2. In the second example, the shortest path from node 1 to node 5 is `1->2->3->4->5` with a total distance of 7. 3. In the third example, node 4 is unreachable from node 1, hence the return value is -1. # Note Ensure to use an efficient implementation of Dijkstra\'s algorithm, potentially using a priority queue to obtain optimal performance for larger graphs.","solution":"import heapq from typing import List, Tuple def shortest_path(graph: List[Tuple[int, int, int]], start: int, end: int) -> int: # Create adjacency list adj = {} for u, v, w in graph: if u not in adj: adj[u] = [] if v not in adj: adj[v] = [] adj[u].append((v, w)) adj[v].append((u, w)) # Min-heap priority queue pq = [(0, start)] seen = set() dist = {start: 0} while pq: curr_dist, node = heapq.heappop(pq) if node in seen: continue seen.add(node) if node == end: return curr_dist for neighbor, weight in adj.get(node, []): if neighbor not in seen: new_dist = curr_dist + weight if new_dist < dist.get(neighbor, float(\'inf\')): dist[neighbor] = new_dist heapq.heappush(pq, (new_dist, neighbor)) return -1"},{"question":"# Prime Number Sieve Coding Assessment You are tasked to implement the Sieve of Eratosthenes algorithm to find all prime numbers up to a given number `n`. Your function `sieve_of_eratosthenes()` should return the list of prime numbers up to and including `n`. Function Signature ```python def sieve_of_eratosthenes(n: int) -> List[int]: ``` Input * `n` (int): An integer representing the upper limit for which to find all prime numbers. Output * `List[int]`: A list of integers representing all the prime numbers up to and including `n`. Constraints * `n` will be an integer between 2 and 10000 (inclusive). Example ```python n = 10 # Expected Output: [2, 3, 5, 7] print(sieve_of_eratosthenes(n)) # [2, 3, 5, 7] ``` Scenario Prime numbers are fundamental in various areas of computer science and mathematics, including cryptography, coding theory, and algorithms. Implementing the Sieve of Eratosthenes provides an efficient solution for generating a list of prime numbers, which can significantly speed up calculations and problem-solving where prime numbers are involved. **Hint**: Use a boolean list to mark the non-prime numbers efficiently. Initialization starts with marking all numbers as prime, and then iteratively marks multiples of each prime starting from 2. ```python def sieve_of_eratosthenes(n: int) -> List[int]: primes = [True] * (n + 1) p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 return [p for p in range(2, n + 1) if primes[p]] ``` This question assesses your understanding of efficient algorithms for finding prime numbers, loop optimization, and boolean array manipulations.","solution":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: Implements the Sieve of Eratosthenes algorithm and returns a list of primes up to and including n. if n < 2: return [] primes = [True] * (n + 1) p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 return [p for p in range(2, n + 1) if primes[p]]"},{"question":"# Matrix Chain Multiplication You are tasked with implementing an algorithm to find the minimum number of scalar multiplications needed to compute the product of a chain of matrices. This problem is a classic example of the dynamic programming approach to optimization problems, where the goal is to find an optimal way to multiply a given sequence of matrices. Task Write a function `matrix_chain_order` that consumes the following parameter: * `p`: A list of integers where the ith matrix has dimensions p[i-1] x p[i]. The function should return the minimum number of scalar multiplications required to multiply the chain of matrices. Constraints * The length of the list `p` is at least 2 and at most 100. * Each entry in list `p` should be a positive integer. Input Format The input parameter is: 1. `p` (List[int]): List of integers representing the dimensions of the matrices. Output Format The function should return an integer representing the minimum number of scalar multiplications needed. Example ```python p = [1, 2, 3, 4] result = matrix_chain_order(p) print(result) # Output: 18 Explanation: Multiplying the matrices A (1x2), B (2x3) and C (3x4): - Order (A(BC)): 1*2*4 + 1*3*4 = 24 + 12 = 36 - Order ((AB)C): 1*2*3 + 1*3*4 = 6 + 12 = 18 The minimum scalar multiplications are 18. ``` Your implementation should include error handling for invalid input parameters, ensuring the following: - The list `p` contains at least two elements. - All dimensions in the list are positive integers.","solution":"def matrix_chain_order(p): Returns the minimum number of scalar multiplications needed to multiply a chain of matrices. Parameters: p (List[int]): List of integers representing the dimensions of the matrices. Returns: int: Minimum number of scalar multiplications. # Check for valid input if len(p) < 2 or any(not isinstance(x, int) or x <= 0 for x in p): raise ValueError(\\"Invalid input: List \'p\' must contain at least two positive integers.\\") n = len(p) - 1 # Number of matrices # m[i][j] stores the minimum number of multiplications needed to compute the matrix A[i]A[i+1]...A[j] m = [[0 for x in range(n)] for y in range(n)] # l is chain length for l in range(2, n + 1): for i in range(n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + p[i]*p[k+1]*p[j+1] if q < m[i][j]: m[i][j] = q return m[0][n-1] # Return the minimum number of multiplications needed for the entire chain"},{"question":"# Question: Route Optimization for Delivery Trucks # Context: A delivery company wants to optimize its routes to reduce fuel consumption and ensure timely deliveries. Each route consists of multiple stages between delivery points, and the company wants to determine the minimum fuel needed to cover a particular route. Given an algorithm to compute the optimal route based on fuel consumption: # Task: Implement a function `optimal_fuel` that calculates the minimum fuel needed to travel from the start of the route to the end. Each stage of the route consumes a specific amount of fuel. # Function Signature: ```python def optimal_fuel(stages: list[tuple[int, int]]) -> int: pass ``` # Input: * `stages` (list of tuple of int): Each tuple represents a stage of the route. The first element is the start point, and the second element is the fuel consumed to travel from the start to the end of that stage. # Output: * An integer representing the minimum fuel needed to complete the route. * Raises `ValueError` if the stages list is empty or if any stage has negative fuel consumption. # Constraints: * The number of stages will be between 1 and 10^5. * Each stage fuel consumption will be between 1 and 10^5. # Example: ```python >>> optimal_fuel([(1, 50), (2, 20), (3, 30)]) 100 >>> optimal_fuel([(1, 30), (2, 70), (3, 10)]) 110 >>> optimal_fuel([]) Traceback (most recent call last): ... ValueError: Stages list cannot be empty >>> optimal_fuel([(1, -20), (2, 30)]) Traceback (most recent call last): ... ValueError: Fuel consumption for a stage cannot be negative ``` # Notes: * Ensure your implementation handles invalid inputs effectively. * The function should be efficient in handling a large number of stages.","solution":"def optimal_fuel(stages: list[tuple[int, int]]) -> int: Calculate the minimum fuel needed to cover the route. :param stages: List of tuples where each tuple contains the start point and the fuel consumed at that stage. :return: Integer representing the minimum fuel needed. if not stages: raise ValueError(\\"Stages list cannot be empty\\") total_fuel = 0 for stage in stages: if stage[1] < 0: raise ValueError(\\"Fuel consumption for a stage cannot be negative\\") total_fuel += stage[1] return total_fuel"},{"question":"**Title**: Robot Path Planning with Obstacles **Context**: You are programming a robot to navigate a warehouse grid. The robot must move from the top-left corner of the grid to the bottom-right corner. The grid contains obstacles that the robot cannot pass through. **Problem Statement**: Implement the function `robot_path(grid: List[List[int]]) -> int` that reads a 2D grid representing the warehouse. Return the number of unique paths the robot can take to reach the bottom-right corner from the top-left corner, avoiding obstacles. **Input Format**: * `grid`: A list of lists representing rows in a 2D grid. Each cell contains: - `0` for an open space - `1` for an obstacle that the robot cannot cross **Output Format**: * Returns an integer, the number of unique paths from the top-left corner to the bottom-right corner of the grid, avoiding obstacles. **Constraints**: 1. `1 <= m, n <= 100` (Number of rows and columns in the grid) **Example**: ```python grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert robot_path(grid) == 2 ``` **Note**: - The robot can only move either down or right at any point in time. - It is guaranteed that the start (grid[0][0]) and end (grid[m-1][n-1]) are not obstacles. - If no path exists, return 0.","solution":"def robot_path(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Fibonacci Sequence Calculation In this task, you are required to implement functions that calculate the n-th Fibonacci number and generate a list of the first n Fibonacci numbers using different approaches. Part 1: Recursive Fibonacci Calculation Implement a function `fibonacci_recursive` that calculates the n-th Fibonacci number using recursion. Note that while a purely recursive approach is simple, it may become inefficient for large `n`. Part 2: Iterative Fibonacci Calculation Implement a function `fibonacci_iterative` that calculates the n-th Fibonacci number using an iterative approach. This method is more efficient and should handle larger values of `n` better. Part 3: Generating a List of Fibonacci Numbers Implement a function `generate_fibonacci_series` that generates and returns a list of the first `n` Fibonacci numbers using the iterative approach. Function Signatures ```python def fibonacci_recursive(n: int) -> int: Calculates the n-th Fibonacci number using recursion. Parameters: n (int): The position in the Fibonacci sequence to calculate. Returns: int: The n-th Fibonacci number. pass def fibonacci_iterative(n: int) -> int: Calculates the n-th Fibonacci number using iteration. Parameters: n (int): The position in the Fibonacci sequence to calculate. Returns: int: The n-th Fibonacci number. pass def generate_fibonacci_series(n: int) -> list: Generates a list of the first n Fibonacci numbers using iteration. Parameters: n (int): The number of Fibonacci numbers to generate. Returns: list: A list containing the first `n` Fibonacci numbers. pass ``` # Constraints * `n` should be a non-negative integer. * For `fibonacci_recursive`, ensure the function does not stack overflow for reasonably small values of `n` (say, up to 30). * For `fibonacci_iterative` and `generate_fibonacci_series`, ensure they handle larger values of `n` efficiently (e.g., up to 1000). # Example ```python print(fibonacci_recursive(10)) # Output: 55 print(fibonacci_iterative(10)) # Output: 55 print(generate_fibonacci_series(10)) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Requirements 1. Use proper error handling for invalid input values. 2. Comment on the time complexity of both the recursive and iterative approaches in the function\'s docstrings. 3. Optimize for clear and readable code that conforms to standard Python practices.","solution":"def fibonacci_recursive(n: int) -> int: Calculates the n-th Fibonacci number using recursion. Parameters: n (int): The position in the Fibonacci sequence to calculate. Returns: int: The n-th Fibonacci number. Time Complexity: O(2^n), due to the overlapping subproblems in the recursion. Space Complexity: O(n), due to the call stack used by recursion. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 if n == 1: return 1 return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2) def fibonacci_iterative(n: int) -> int: Calculates the n-th Fibonacci number using iteration. Parameters: n (int): The position in the Fibonacci sequence to calculate. Returns: int: The n-th Fibonacci number. Time Complexity: O(n), as we compute each Fibonacci number exactly once. Space Complexity: O(1), as we use a constant amount of space. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def generate_fibonacci_series(n: int) -> list: Generates a list of the first n Fibonacci numbers using iteration. Parameters: n (int): The number of Fibonacci numbers to generate. Returns: list: A list containing the first `n` Fibonacci numbers. Time Complexity: O(n), as we compute each Fibonacci number exactly once. Space Complexity: O(n), due to the storage required for the output list. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") fibonacci_list = [] a, b = 0, 1 for i in range(n): fibonacci_list.append(a) a, b = b, a + b return fibonacci_list"},{"question":"# Problem Statement You are given a set of logs in the form of a list of strings. Each log entry contains a unique identifier followed by a space-separated list of words. Your task is to reorder these logs in the following order: 1. Log entries that are entirely composed of alphabetic words (letter-logs) should come before all log entries that are entirely composed of numeric digits (digit-logs). 2. Among letter-logs, order them lexicographically based on their content; if two logs have the same content, then order them based on their identifiers. 3. Digit-logs should retain their relative ordering from the original input. Implement the function `reorder_log_files` which reorders log files according to the above rules. # Function Signature ```python def reorder_log_files(logs: list[str]) -> list[str]: ``` # Input Format * A single argument, `logs` (list of strs, 0 <= len(logs) <= 100) - a list of log entries. Each log entry is a string composed of a unique identifier followed by space-separated words or digits. # Output Format * Return a list of strs - the reordered log entries. # Constraints * 0 <= len(logs) <= 100 * Each log entry in `logs` will have at most 100 words or digits. * Word and digit logs are guaranteed to be pre-sorted in individual entries. # Example ```python Input reorder_log_files([ \\"dig1 8 1 5 1\\", \\"let1 art can\\", \\"dig2 3 6\\", \\"let2 own kit dig\\", \\"let3 art zero\\" ]) Output [ \\"let1 art can\\", \\"let3 art zero\\", \\"let2 own kit dig\\", \\"dig1 8 1 5 1\\", \\"dig2 3 6\\" ] ``` # Notes * Each log entry is guaranteed to contain at least one word or digit after the identifier. * It is possible to have logs with the same identifier but different content, follow the sorting order rules as stipulated. # Implementation Advice * Split each log into two parts: an identifier and the rest of the content. * Use a custom sorting function to handle the order of letter-logs and digit-logs appropriately. * Use the list method `sort` with a key argument for efficient in-place sorting.","solution":"def reorder_log_files(logs): Reorders log files such that letter-logs come before digit-logs. Letter-logs are ordered lexicographically by content, then by identifiers if the contents are the same. Digit-logs maintain their relative order. from functools import cmp_to_key def log_compare(log1, log2): id1, rest1 = log1.split(\' \', 1) id2, rest2 = log2.split(\' \', 1) # Check if logs are digit-logs or letter-logs is_digit1 = rest1[0].isdigit() is_digit2 = rest2[0].isdigit() if not is_digit1 and not is_digit2: # Both are letter-logs if rest1 != rest2: return -1 if rest1 < rest2 else 1 else: return -1 if id1 < id2 else 1 elif is_digit1 and not is_digit2: # log1 is digit-log, log2 is letter-log return 1 elif not is_digit1 and is_digit2: # log1 is letter-log, log2 is digit-log return -1 else: # Both are digit-logs return 0 logs.sort(key=cmp_to_key(log_compare)) return logs"},{"question":"# String Compression Algorithm In this task, you are required to compress a given string using a basic form of run-length encoding (RLE). The input string consists of only lowercase alphabets. The output should represent consecutive groups of the same character as a single character followed by the count of that character. Input * A string, `s`, consisting of only lowercase alphabets. Output * A compressed string with the run-length encoding format. Function Signature ```python def compress_string(s: str) -> str: Compress the given string using run-length encoding. Parameters: s (str): The input string consisting of only lowercase alphabets. Returns: str: The run-length encoded string. ``` Requirements * If a character appears consecutively more than once, it should be followed by the count of its occurrences. * If a character appears only once, it should not be followed by a count. * Ensure the compressed string is of minimal length. * The algorithm should run in O(n) time complexity, where n is the length of the input string. Example Usage: ```python print(compress_string(\\"aaabbcc\\")) # Output: \\"a3b2c2\\" print(compress_string(\\"abcd\\")) # Output: \\"abcd\\" print(compress_string(\\"zzzzzz\\")) # Output: \\"z6\\" ```","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: if count == 1: compressed.append(current_char) else: compressed.append(current_char + str(count)) current_char = char count = 1 if count == 1: compressed.append(current_char) else: compressed.append(current_char + str(count)) return \'\'.join(compressed)"},{"question":"# Scenario You have been tasked with creating a file management system that processes logs from multiple servers. Each log entry includes a timestamp, a server identifier, and a message. You need to implement functionality that allows for filtering and retrieving specific log entries based on certain criteria. # Task Write a class `LogProcessor` that processes log entries from various servers. The `LogProcessor` class should support adding new log entries and retrieving logs based on time range and server identifiers. # Class Functionality `LogProcessor` - **Methods**: - `add_log(timestamp: str, server_id: str, message: str) -> None`: Adds a log entry to the system. - `get_logs(start_time: str, end_time: str, server_id: Optional[str] = None) -> List[Tuple[str, str, str]]`: Retrieves logs within the specified time range (inclusive). If a `server_id` is provided, only logs from that server are returned. If not, logs from all servers in the time range are returned. # Input/Output - **Input**: - `timestamp` and `start_time`, `end_time` are strings in the format \\"YYYY-MM-DD HH:MM:SS\\". - `server_id` is a string identifier for the server. - `message` is a string containing the log message. - **Output**: - `get_logs` method will return a list of tuples, each containing (`timestamp`, `server_id`, `message`). # Constraints - Ensure the logs are stored efficiently to allow fast retrievals. - Use appropriate data structures to maintain and query the logs. # Example Usage ```python log_processor = LogProcessor() # Adding logs log_processor.add_log(\\"2023-10-01 14:00:00\\", \\"server1\\", \\"Log entry 1\\") log_processor.add_log(\\"2023-10-01 14:05:00\\", \\"server2\\", \\"Log entry 2\\") log_processor.add_log(\\"2023-10-01 14:10:00\\", \\"server1\\", \\"Log entry 3\\") # Retrieving logs from a specific time range logs = log_processor.get_logs(\\"2023-10-01 14:00:00\\", \\"2023-10-01 14:10:00\\") print(logs) # Output: [(\\"2023-10-01 14:00:00\\", \\"server1\\", \\"Log entry 1\\"), ...] # Retrieving logs from a specific server server1_logs = log_processor.get_logs(\\"2023-10-01 14:00:00\\", \\"2023-10-01 14:10:00\\", \\"server1\\") print(server1_logs) # Output: [(\\"2023-10-01 14:00:00\\", \\"server1\\", \\"Log entry 1\\"), (\\"2023-10-01 14:10:00\\", \\"server1\\", \\"Log entry 3\\")] ``` # Function Signature ```python from typing import List, Tuple, Optional class LogProcessor: def __init__(self): pass def add_log(self, timestamp: str, server_id: str, message: str) -> None: pass def get_logs(self, start_time: str, end_time: str, server_id: Optional[str] = None) -> List[Tuple[str, str, str]]: pass ``` # Notes - Logs should be stored in a structure that allows efficient addition and query operations. - Properly handle edge cases, such as overlapping time ranges and absent server IDs during queries.","solution":"from typing import List, Tuple, Optional from collections import defaultdict from bisect import insort from datetime import datetime class LogProcessor: def __init__(self): self.logs = defaultdict(list) self.all_logs = [] def add_log(self, timestamp: str, server_id: str, message: str) -> None: log_entry = (timestamp, server_id, message) insort(self.logs[server_id], log_entry) insort(self.all_logs, log_entry) def get_logs(self, start_time: str, end_time: str, server_id: Optional[str] = None) -> List[Tuple[str, str, str]]: start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") if server_id: relevant_logs = self.logs[server_id] else: relevant_logs = self.all_logs return [(ts, id, msg) for ts, id, msg in relevant_logs if start_dt <= datetime.strptime(ts, \\"%Y-%m-%d %H:%M:%S\\") <= end_dt]"},{"question":"**Question**: You are working on a financial application that requires computing the account balance after applying a series of transactions. Every transaction is represented by a string, and the balance must be updated accordingly. The transactions can be either deposits, withdrawals, or fees, and they follow specific formats. Implement a function `calculate_balance(initial_balance, transactions)` that returns the final account balance after processing a list of transactions. The function should take two parameters: * `initial_balance`: A floating-point number representing the starting balance of the account. * `transactions`: A list of strings where each string represents a transaction in one of the following formats: - `\'D amount\'` for deposits - `\'W amount\'` for withdrawals - `\'F fee\'` for fees applied to the account The function should return the final account balance as a floating-point number formatted to two decimal places. # Constraints: * You can assume all transactions are valid and follow the specified format. * The `amount` or `fee` in each transaction is a positive floating-point number. # Example: ```python >>> calculate_balance(1000.00, [\'D 200.50\', \'W 150.00\', \'F 15.75\']) 1034.75 >>> calculate_balance(1500.00, [\'W 500.00\', \'W 200.00\', \'D 700.00\', \'F 25.50\']) 1474.50 ``` **Explanation**: In the first example, starting with a balance of 1000.00: - A deposit (\'D\') of 200.50 increases the balance to 1200.50. - A withdrawal (\'W\') of 150.00 decreases the balance to 1050.50. - Applying a fee (\'F\') of 15.75 reduces the balance to 1034.75. In the second example, starting with a balance of 1500.00: - A withdrawal of 500.00 reduces the balance to 1000.00. - Another withdrawal of 200.00 reduces it further to 800.00. - A deposit of 700.00 increases the balance to 1500.00. - Applying a fee of 25.50 reduces the balance to 1474.50.","solution":"def calculate_balance(initial_balance, transactions): Computes the final account balance after applying a series of transactions. Parameters: initial_balance (float): The starting balance of the account. transactions (list): A list of strings where each string represents a transaction. Returns: float: The final account balance formatted to two decimal places. balance = initial_balance for transaction in transactions: type_, amount = transaction.split() amount = float(amount) if type_ == \'D\': balance += amount elif type_ == \'W\': balance -= amount elif type_ == \'F\': balance -= amount return round(balance, 2)"},{"question":"# Scenario: You are working on a text processing tool that requires counting the occurrences of each word in a given input string. Your task is to implement this feature with attention to correct case handling and punctuation removal. # Task: Write a function called `word_count` that takes a single argument, a string containing text. The function should return a dictionary where the keys are words (in lowercase) and the values are the counts of their occurrences in the input string. Punctuation should be removed, and words should be considered case-insensitively. # Constraints: * The input string will not be empty. * Ignore punctuation marks such as periods, commas, exclamation points, etc. * Words are separated by whitespace characters. * Convert all words to lowercase before counting. * Ensure the function handles edge cases and invalid input appropriately. # Function Signature: ```python def word_count(text: str) -> dict[str, int]: ``` # Examples: ```python # Example 1 word_count(\\"Hello, world! Hello.\\") # Output: {\\"hello\\": 2, \\"world\\": 1} # Example 2 word_count(\\"The quick brown fox jumps over the lazy dog.\\") # Output: {\\"the\\": 2, \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1, \\"jumps\\": 1, \\"over\\": 1, \\"lazy\\": 1, \\"dog\\": 1} # Example 3 word_count(\\"This is a test. This test is only a test.\\") # Output: {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1} # Example 4 word_count(\\"Python\'s syntax is clear!\\") # Output: {\\"pythons\\": 1, \\"syntax\\": 1, \\"is\\": 1, \\"clear\\": 1} ``` # Requirements: 1. Implement the function `word_count`. 2. Ensure the function handles punctuation and case sensitivity correctly. 3. Optimize your solution for clarity and efficiency.","solution":"import string def word_count(text: str) -> dict[str, int]: Takes a string and returns a dictionary with word frequency count. Handles punctuation removal and case insensitivity. # Remove punctuation from the text translator = str.maketrans(\'\', \'\', string.punctuation) text = text.translate(translator) # Split the text into words and count them ignoring case words = text.lower().split() word_counts = {} for word in words: word_counts[word] = word_counts.get(word, 0) + 1 return word_counts"},{"question":"**Problem Statement:** You are provided with a list of integers representing a sequence where each number denotes the height of a building. A building can trap rainwater above it if there are taller buildings on both its left and right. The amount of trapped water above each building is determined by the height difference between its height and the minimum height of the taller buildings around it. Your goal is to calculate the total amount of trapped rainwater between all the buildings in the sequence. **Function Signature:** ```python def trap_rain_water(heights: List[int]) -> int: pass ``` # Input: - `heights`: A list of integers representing the heights of buildings. # Output: - Returns an integer representing the total amount of trapped rainwater. # Constraints: - The length of `heights` list will be between `0` and `10^4`. - Each height will be a non-negative integer and within the range from `0` to `10^4`. # Example: ```python # Given the sequence of heights: # [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] # # The output should be: # trap_rain_water(heights) -> 6 ``` # Implementation Details: - Consider using two-pointer technique or stack to efficiently compute the trapped rainwater. - It is essential to keep track of the maximum height to the left and right of each building. - Handle edge cases where there are no buildings, only one building, or a flat surface without any valleys. - Be mindful of time complexity to ensure it performs well for the maximum input sizes. # Testing: Test your implementation with a variety of different height sequences, including edge cases such as: - Empty list. - List with only one height. - Uniform heights. - Sequences with multiple valleys and peaks.","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"# Coding Assessment Question Problem Statement You are tasked with writing a function that finds the most frequently occurring word in a given string. If there are multiple words with the same highest frequency, return the one that appears first in the string. The function should be case-insensitive, and the returned word should be in the same case as it appears in the input string. Function Signature ```python def most_frequent_word(input_str: str) -> str: pass ``` Input - A single string `input_str` containing words. Words are separated by spaces and/or punctuation marks. The string can include different whitespace characters and is case-insensitive for comparing word frequencies. Output - A single string representing the most frequently occurring word. Constraints - The input string length will not exceed 1000 characters. - Words can be separated by spaces and may include common punctuation marks such as `.,!?`:. - The string will contain at least one word. Example Usage ```python assert most_frequent_word(\\"apple banana apple! cucumber banana apple.\\") == \\"apple\\" assert most_frequent_word(\\"Hello! Hello! How are you? Hello, I am fine.\\") == \\"Hello\\" assert most_frequent_word(\\"one two two THREE three three Two\\") == \\"two\\" assert most_frequent_word(\\"Punctuation. Does not; change,word!frequencies?\\") == \\"Punctuation\\" ``` Performance Requirements The function should have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input string.","solution":"import re from collections import defaultdict def most_frequent_word(input_str: str) -> str: # Remove punctuation and make the string case-insensitive words = re.findall(r\'bw+b\', input_str.lower()) # Create a dictionary to store frequency of each word freq_dict = defaultdict(int) # Track the original occurrences of each lower-cased word original_words = {} for word in re.findall(r\'bw+b\', input_str): lower_word = word.lower() if lower_word not in original_words: original_words[lower_word] = word freq_dict[lower_word] += 1 # Find the most frequent word max_freq = 0 most_frequent = None for word in words: if freq_dict[word] > max_freq: max_freq = freq_dict[word] most_frequent = original_words[word] return most_frequent"},{"question":"# Question: Detect Cyclic Shifts in Strings Context In this problem, you will address the concept of cyclic shifts in strings. A string `B` is considered a cyclic shift of another string `A` if `B` can be obtained by rotating `A` some number of places. For example, the string \\"cdeab\\" is a cyclic shift of \\"abcde\\" as it can be obtained by rotating \\"abcde\\" two places to the right. Objective Implement a function `is_cyclic_shift` that determines if one string is a cyclic shift of another. Function Signature ```python def is_cyclic_shift(A: str, B: str) -> bool: pass ``` Input and Output - **Input**: - `A` (str): The original string. `1 <= len(A) <= 10^5`. - `B` (str): The candidate cyclic shift string. `1 <= len(B) <= 10^5`. - **Output**: - (bool): Returns `True` if `B` is a cyclic shift of `A`, and `False` otherwise. Example ```python result = is_cyclic_shift(\\"abcde\\", \\"cdeab\\") print(result) # Expected output: True result = is_cyclic_shift(\\"abcde\\", \\"abced\\") print(result) # Expected output: False ``` Constraints - Both strings `A` and `B` only contain lowercase English letters. - Ensure your solution efficiently handles the upper bound within reasonable execution time. Performance Requirements - Aim to handle the worst-case scenario within practical time limits. - Ensure that the solution uses space and time complexity within feasible limits given the input constraints. Approach Recommendations - Consider using string doubling or other efficient methods to determine the cyclic nature without performing actual rotations multiple times.","solution":"def is_cyclic_shift(A: str, B: str) -> bool: Determines if string B is a cyclic shift of string A. if len(A) != len(B): return False # Double the string A and see if B is a substring of it. double_A = A + A return B in double_A"},{"question":"# Coding Assessment Question Context In a robotics simulation, it is crucial to determine how long it will take for a robot to traverse a designated path given its speed and the distance of the path. Your task is to implement a function that calculates the travel time based on the distance and the speed of the robot. Task Implement a function `travel_time(distance: float, speed: float) -> float` that calculates and returns the time required for the robot to travel the given distance at the specified speed. The function should take two parameters: 1. `distance`: The distance the robot needs to travel in meters (distance > 0). 2. `speed`: The speed of the robot in meters per second (speed > 0). Ensure the function correctly handles the specified input constraints and provides accurate results. Input and Output Format **Input**: * `distance`: float - the distance the robot needs to travel in meters. * `speed`: float - the speed of the robot in meters per second. **Output**: * float - time required for the robot to travel the given distance at the specified speed in seconds. Constraints * `distance > 0` * `speed > 0` Examples ```python # Example 1 distance = 100 speed = 5 travel_time(distance, speed) # Expected Output: 20.0 # Example 2 distance = 250 speed = 10 travel_time(distance, speed) # Expected Output: 25.0 # Example 3 distance = 1000 speed = 50 travel_time(distance, speed) # Expected Output: 20.0 ``` You need to ensure that the implementation handles all valid inputs accurately and efficiently.","solution":"def travel_time(distance: float, speed: float) -> float: Calculates and returns the time required for the robot to travel a given distance at a specified speed. Parameters: distance (float): The distance the robot needs to travel in meters. speed (float): The speed of the robot in meters per second. Returns: float: The time required for the robot to travel the given distance at the specified speed in seconds. return distance / speed"},{"question":"# Coding Assessment Question: Scenario: You have been tasked with processing text data in a software application. Specifically, you need to write a function to find the first non-repeating character in a given string. A non-repeating character is one that appears exactly once in the string. Task: Write a function `first_non_repeating_char(s: str) -> str` that: 1. Takes a string `s`. 2. Finds the first character in the string that does not repeat. 3. Returns the character as a string. Input: - A single string `s` where `1 <= len(s) <= 10^5`. Output: - A single character string representing the first non-repeating character. Constraints: - If the input is not a string, raise a `TypeError` with the message: \\"input must be a string\\". - If there are no non-repeating characters, return an empty string `\'\'`. Example: ```python first_non_repeating_char(\\"swiss\\") # Returns \'w\' first_non_repeating_char(\\"repetition\\") # Returns \'r\' first_non_repeating_char(\\"aabbcc\\") # Returns \'\' first_non_repeating_char(\\"abcdef\\") # Returns \'a\' ``` Requirements: - Implement robust error handling for invalid inputs. - Optimize for performance but ensure the code remains clear and maintainable. - Use appropriate data structures to achieve optimal time complexity (Hint: Consider using a hash map for frequency counting).","solution":"def first_non_repeating_char(s: str) -> str: # Verify that input is a string if not isinstance(s, str): raise TypeError(\\"input must be a string\\") # Dictionary to store character counts char_count = {} # Populate the dictionary with character counts for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return empty string return \'\'"},{"question":"# Problem Description: Log File Summarization You are tasked with developing a log file summarization tool that processes large log files and provides an aggregate summary of specific log events. Your goal is to read through a given log file, identify lines containing specific event keywords, and output a summary with the count of each event type. # Requirements 1. **Function Implementation**: Write a function `summarize_log(input_file, output_file, event_keywords)` that processes the given log file and summarizes the log events. 2. The function should: * Read through the input log file line by line. * Identify lines containing any of the specified event keywords. * Keep a count of occurrences for each event keyword. * Write the summary to the output file in a specified format. 3. Ensure your solution can handle the following: * Very large log files that cannot fit into memory. * Different line terminators. * Edge cases where files may be empty or contain lines irrelevant to the event keywords. 4. **Input/Output**: * `input_file`: Path to the input log file. * `output_file`: Path where the summary output file should be saved. * `event_keywords`: A list of keywords representing the event types to be summarized. # Constraints * The log file may be several gigabytes in size. * Log messages will be plain text and can include special characters. * The output file should follow the format: `event_keyword: count`. # Example ```python def summarize_log(input_file, output_file, event_keywords): # Your code goes here pass # Example usage event_keywords = [\\"ERROR\\", \\"WARNING\\", \\"INFO\\"] summarize_log(\\"system.log\\", \\"summary.txt\\", event_keywords) ``` If the `system.log` file contains: ``` INFO: System started ERROR: Failed to load module INFO: User login WARNING: Low disk space INFO: System shutdown ERROR: Disk failure ``` The `summary.txt` would contain: ``` INFO: 3 ERROR: 2 WARNING: 1 ``` Implement the function with efficient file I/O operations to handle large files. Use auxiliary functions as necessary to achieve clean and maintainable code.","solution":"def summarize_log(input_file, output_file, event_keywords): Reads a log file, summarizes the occurrences of specified event keywords, and writes the summary to an output file. Arguments: input_file : str : Path to the input log file. output_file : str : Path where the summary output file should be saved. event_keywords : list : List of keywords representing the event types to be summarized. # Initialize a dictionary to keep the count of each event keyword event_counts = {keyword: 0 for keyword in event_keywords} # Open and read the input file line by line with open(input_file, \'r\') as infile: for line in infile: # Check if any keyword is in the line, and increment its count if found for keyword in event_keywords: if keyword in line: event_counts[keyword] += 1 # Write the summary to the output file with open(output_file, \'w\') as outfile: for keyword, count in event_counts.items(): outfile.write(f\\"{keyword}: {count}n\\")"},{"question":"# Problem Statement You are given a list of integers `nums` where each integer appears exactly three times, except for one integer that appears exactly once. Your task is to write a function `single_number` that identifies and returns the single number that appears only once. # Function Signature ```python def single_number(nums: List[int]) -> int: ``` # Input - `nums`: A list of integers where `1 <= len(nums) <= 3 * 10^4`. # Output - An integer representing the unique number that appears only once. # Constraints - Each integer in the list appears three times except for one. - The integers in `nums` are between -3 * 10^4 and 3 * 10^4. # Example ```python nums = [2, 2, 3, 2] print(single_number(nums)) # Output should be 3 nums = [0, 1, 0, 1, 0, 1, 99] print(single_number(nums)) # Output should be 99 ``` # Notes - Consider using bitwise operations for an optimized solution. - Avoid using additional space to maintain the uniqueness of the solution. # Additional Context This problem tests your knowledge of bitwise operations and the ability to identify patterns that allow efficient resolution of problems typically requiring multiple pass and space complexity. Analyze how the properties of bitwise calculations can be used to solve the problem in a linear pass with consistent space usage.","solution":"def single_number(nums): ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Coding Question Objective Write a Python function that determines whether a list contains any duplicate elements. # Function Signature ```python def contains_duplicates(input_list: list) -> bool: Checks if a list contains any duplicate elements. ``` # Input * A single list `input_list` containing elements of any data type. # Output * Return `True` if there are any duplicates in the list, `False` otherwise. # Constraints * The list can contain elements of mixed data types (integers, floats, strings, etc.). * The function should maintain a time complexity as close to O(n) as possible. # Examples ```python print(contains_duplicates([1, 2, 3, 4, 5])) # False print(contains_duplicates([1, 2, 2, 4, 5])) # True print(contains_duplicates([\'a\', \'b\', \'c\', \'a\'])) # True print(contains_duplicates([1.1, 2.2, 3.3, 1.1])) # True print(contains_duplicates([\'hello\', \'world\', \'hello\'])) # True print(contains_duplicates([])) # False print(contains_duplicates([None, None, 1])) # True ``` Requirements - Implement the function to handle all possible edge cases. - Ensure the function is optimized for performance. - Include a main block to read the input list and print whether it contains duplicates or not.","solution":"def contains_duplicates(input_list: list) -> bool: Checks if a list contains any duplicate elements. seen_elements = set() for element in input_list: if element in seen_elements: return True seen_elements.add(element) return False"},{"question":"# Coding Assessment Question **Context:** In software development, Fibonacci sequences are commonly used in various algorithms and performance benchmarking tasks. Calculating the nth Fibonacci number efficiently can drastically improve performance in recursive algorithms. **Task:** Write a function named `fibonacci` in Python to calculate the nth Fibonacci number using dynamic programming to ensure that the solution is efficient compared to a naive recursive approach. **Function Signature:** ```python def fibonacci(n: int) -> int: ``` **Input:** - `n`: A non-negative integer representing the position in the Fibonacci sequence to compute. **Output:** - An integer which is the nth Fibonacci number. **Constraints:** - `0 <= n <= 10000` **Example:** ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 ``` **Note:** - Ensure your function handles all edge cases, including the smallest and the largest possible values of `n` within the given constraint. - The function should use a bottom-up dynamic programming approach to avoid the exponential time complexity of a naive recursive solution.","solution":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using dynamic programming. if n <= 0: return 0 elif n == 1: return 1 # Initialize the base cases fib = [0] * (n + 1) fib[1] = 1 # Fill the array with Fibonacci numbers up to n for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"Palindrome Permutation Context A palindrome is a word or phrase that reads the same forwards and backwards, ignoring spaces, punctuation, and capitalization. A permutation is a rearrangement of letters. Given a string, determine if any permutation of it forms a palindrome. Task Write a function `can_form_palindrome(s: str) -> bool` that checks if any permutation of the input string can form a palindrome. To solve this problem, you should count the frequency of each character in the string. For the string to be able to form a palindrome: 1. At most one character can have an odd frequency (for odd-length strings). 2. All characters must have even frequencies, or exactly one character can have an odd frequency (for even-length strings). Function Definition ```python def can_form_palindrome(s: str) -> bool: Determines if any permutation of a string can form a palindrome. Args: s : The input string to check. Returns: True if any permutation of the input string can form a palindrome, False otherwise. ... ``` Input Constraints - The input string `s` contains only lowercase alphabets. - Length of the string `1 <= len(s) <= 10^5`. Output - Return `True` if any permutation of the input string can form a palindrome, otherwise return `False`. Examples ```python # Example 1 print(can_form_palindrome(\\"civic\\")) # Output: True # Explanation: \\"civic\\" is already a palindrome. # Example 2 print(can_form_palindrome(\\"ivicc\\")) # Output: True # Explanation: \\"ivicc\\" can be rearranged to \\"civic\\", which is a palindrome. # Example 3 print(can_form_palindrome(\\"hello\\")) # Output: False # Explanation: There is no permutation of \\"hello\\" that can form a palindrome. # Example 4 print(can_form_palindrome(\\"aab\\")) # Output: True # Explanation: \\"aab\\" can be rearranged to \\"aba\\", which is a palindrome. ``` Write your implementation for the `can_form_palindrome` function below. ```python def can_form_palindrome(s: str) -> bool: # Implementation here ```","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Digits in Factorial Objective Implement a function that computes the number of digits in the factorial of a given non-negative integer. Problem Statement Write a function `digits_in_factorial` which takes a single non-negative integer `n` as input and returns the number of digits in `n!` (n factorial). You need to efficiently compute this without explicitly calculating the factorial number for large `n`, as it can grow very quickly and be very large. The required function signature in Python: ```python def digits_in_factorial(n: int) -> int: ``` Constraints * `0 ≤ n ≤ 10^5` * Your implementation should handle the large values of `n` efficiently without causing overflow errors. Input * `n`: An integer, representing the number for which we need to find the number of digits in its factorial. Output * Returns an integer representing the number of digits in the factorial of the given integer `n`. Example ```python def digits_in_factorial(n: int) -> int: import math if n == 0 or n == 1: return 1 digits = 0 for i in range(2, n + 1): digits += math.log10(i) return math.floor(digits) + 1 # Test Examples print(digits_in_factorial(5)) # Expected Output: 3 (120 has 3 digits) print(digits_in_factorial(0)) # Expected Output: 1 (0! is 1, which has 1 digit) print(digits_in_factorial(10)) # Expected Output: 7 (3628800 has 7 digits) print(digits_in_factorial(100)) # Expected Output: 158 ```","solution":"import math def digits_in_factorial(n: int) -> int: Returns the number of digits in the factorial of n. :param n: Non-negative integer :return: Number of digits in n! if n == 0 or n == 1: return 1 digits = 0 for i in range(2, n + 1): digits += math.log10(i) return math.floor(digits) + 1"},{"question":"# Question: Subset Sum Solver You are tasked with implementing a function that finds all unique subsets of a given list of distinct integers that sum up to a target value. Use a backtracking approach to explore all possible subsets. Requirements: - Implement a function `find_subsets(nums: list[int], target: int) -> list[list[int]]` that performs the task. - Do not use Python\'s built-in library functions for combinations or subset generation. - Aim for time complexity and space complexity that are reasonable for the potential exponential number of subsets. Constraints: - The input list `nums` will have distinct integers. - The length of `nums` will not exceed 20. - Values in `nums` and `target` will be positive integers. # Input Example: ```python nums = [2, 3, 6, 7] target = 7 ``` # Output Example: ```python [[7], [2, 3, 2], [2, 2, 3]] ``` # Implementation Challenge: - Take into consideration the need to avoid duplicate subsets in the output. - Ensure your backtracking solution handles the constraints effectively. # Performance Considerations: - Make sure the algorithm efficiently explores possible subsets within the given constraints to find those that sum up to the target. # Additional Notes: - Ensure that your function handles edge cases such as an empty list or when no subsets can meet the target sum.","solution":"def find_subsets(nums, target): def backtrack(start, path, current_sum): if current_sum == target: result.append(path[:]) return if current_sum > target: return for i in range(start, len(nums)): path.append(nums[i]) current_sum += nums[i] backtrack(i, path, current_sum) path.pop() current_sum -= nums[i] result = [] nums.sort() backtrack(0, [], 0) return result"},{"question":"# Coding Question Context The Fibonacci sequence is a well-known series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. However, this can be generalized to create the Tribonacci sequence, where each term is the sum of the three preceding terms, starting from 0, 1, and 1. For instance, the sequence starts 0, 1, 1, 2, 4, 7, 13, and so on. Task Write a function that computes the N-th term in the Tribonacci sequence, given N (0-indexed). Function Signature ```python def tribonacci(n: int) -> int: Computes the N-th term in the Tribonacci sequence. :param n: The index (0-indexed) of the term to compute. :return: The N-th term in the Tribonacci sequence. >>> tribonacci(0) 0 >>> tribonacci(1) 1 >>> tribonacci(5) 7 >>> tribonacci(10) 149 pass ``` Input * An integer `n` (0 <= n <= 37) Output * An integer representing the N-th term in the Tribonacci sequence. Constraints * Ensure efficient computation, especially for higher values of `n`. Example ```python print(tribonacci(0)) # Should return 0 print(tribonacci(1)) # Should return 1 print(tribonacci(5)) # Should return 7 print(tribonacci(10)) # Should return 149 ```","solution":"def tribonacci(n: int) -> int: Computes the N-th term in the Tribonacci sequence. :param n: The index (0-indexed) of the term to compute. :return: The N-th term in the Tribonacci sequence. >>> tribonacci(0) 0 >>> tribonacci(1) 1 >>> tribonacci(5) 7 >>> tribonacci(10) 149 if n == 0: return 0 elif n == 1 or n == 2: return 1 t0, t1, t2 = 0, 1, 1 for i in range(3, n + 1): tn = t0 + t1 + t2 t0, t1, t2 = t1, t2, tn return tn"},{"question":"# Coding Assessment Question: You are given two strings, `s1` and `s2`, and your task is to implement a function `find_intersection` that returns the characters that are common to both strings. The order of characters in the output should be the same as they appear in the first input string, `s1`. The result should contain unique characters only. # Function Signature: ```python def find_intersection(s1: str, s2: str) -> str: pass ``` # Input: * Two strings `s1` and `s2` consisting of printable ASCII characters. * Constraints: The lengths of the strings `s1` and `s2` are 0 <= len(s1), len(s2) <= 10^6. # Output: * Returns a new string containing the characters that appear in both `s1` and `s2`, maintaining the order from `s1`, and ensuring uniqueness. # Examples: ```python >>> find_intersection(\\"hello\\", \\"world\\") \'lo\' >>> find_intersection(\\"abc\\", \\"xyz\\") \'\' >>> find_intersection(\\"abcdef\\", \\"bdfghj\\") \'bdf\' >>> find_intersection(\\"common\\", \\"comment\\") \'comn\' ``` # Performance Requirements: * The solution must have a time complexity of O(n + m) and a space complexity of O(n + m), where n is the length of `s1` and m is the length of `s2`.","solution":"def find_intersection(s1: str, s2: str) -> str: Returns a string containing unique characters that are common to both s1 and s2, preserving the order they appear in s1. # Create a set of characters in s2 for quick lookup s2_set = set(s2) # Store the unique characters from s1 that are also in s2 intersection = [] seen = set() for char in s1: if char in s2_set and char not in seen: intersection.append(char) seen.add(char) # Join the list to form the output string return \'\'.join(intersection)"},{"question":"# Binary Search Tree: Insert and Traversal Problem Statement You are provided with a Binary Search Tree (BST) class. Your task is to extend this implementation to include methods for inserting a new value and performing an in-order traversal of the tree. Requirements 1. **Class**: `BST` - Extend the given implementation with the following methods: 2. **Methods**: - `insert(value: int)`: Inserts a new value into the BST, maintaining the BST properties. - `in_order_traversal() -> List[int]`: Returns a list of all values in the BST in ascending order. Input Format - Multiple calls to `insert(value)` with integer values. - A single call to `in_order_traversal()`. Output Format - A list of integers resulting from the in-order traversal of the BST. Constraints - Values to be inserted are within the range of 32-bit signed integers. Example ```python # Creating an instance of BST bst = BST() # Inserting values into the BST bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(1) bst.insert(4) # Performing in-order traversal print(bst.in_order_traversal()) # Outputs: [1, 3, 4, 5, 7] ``` Signature ```python def insert(self, value: int): # Your code here def in_order_traversal(self) -> List[int]: # Your code here ``` ```python # Implementation of BST class class BST: class Node: def __init__(self, key): self.left = None self.right = None self.value = key def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = BST.Node(value) else: self._insert(value, self.root) def _insert(self, value: int, node: Node): if value < node.value: if node.left is None: node.left = BST.Node(value) else: self._insert(value, node.left) else: if node.right is None: node.right = BST.Node(value) else: self._insert(value, node.right) def in_order_traversal(self) -> List[int]: result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node: Node, result: List[int]): if node is not None: self._in_order_recursive(node.left, result) result.append(node.value) self._in_order_recursive(node.right, result) ``` # Explanation This new question fits the style, length, difficulty, and topic alignment of the provided problem set. It extends a core data structure and its methods, requiring the candidate to implement both an insertion mechanism and a tree traversal method. This requires understanding of recursion and tree properties, making it a suitable addition to the coding assessment.","solution":"class BST: class Node: def __init__(self, key): self.left = None self.right = None self.value = key def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = BST.Node(value) else: self._insert(value, self.root) def _insert(self, value: int, node: Node): if value < node.value: if node.left is None: node.left = BST.Node(value) else: self._insert(value, node.left) else: if node.right is None: node.right = BST.Node(value) else: self._insert(value, node.right) def in_order_traversal(self) -> list: result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node: Node, result: list): if node is not None: self._in_order_recursive(node.left, result) result.append(node.value) self._in_order_recursive(node.right, result)"},{"question":"# Coding Question: Implement a Custom String Partitioning Function **Context**: You are implementing a utility for text processing that requires partitioning user input strings based on a specific substring. The goal is to segment a string into parts around the first occurrence of a given substring, ensuring efficient processing of large inputs. **Problem Statement**: Write a function `partition_string` that splits a string into three parts: the part before the specified separator substring, the separator itself, and the part after the separator. If the separator is not found in the input string, the function should return the original string and two empty strings. **Function Signature**: ```python def partition_string(user_string: str, separator: str) -> tuple: pass ``` **Input**: - `user_string` (str): The input string to be partitioned. - `separator` (str): The substring to partition the string around. **Output**: - A tuple containing three elements: the part before the separator, the separator itself, and the part after the separator. If the separator is not found, the function returns the original string and two empty strings. **Constraints**: - The input string `user_string` will have a maximum length of 10^5. - The separator string will have a maximum length of 10^3. **Additional Requirements**: - Ensure your function handles edge cases, such as an empty input string or an empty separator. - Maintain a linear time complexity, O(n), where n is the length of the input string. - Avoid using built-in `str.partition` or similar methods for partitioning; implement the logic from scratch. **Examples**: ``` partition_string(\\"hello_world\\", \\"_\\") -> (\'hello\', \'_\', \'world\') partition_string(\\"foo:bar:baz\\", \\":\\") -> (\'foo\', \':\', \'bar:baz\') partition_string(\\"example\\", \\"not_found\\") -> (\'example\', \'\', \'\') partition_string(\\"start middle end\\", \\" middle \\") -> (\'start\', \' middle \', \'end\') partition_string(\\"\\", \\"sep\\") -> (\'\', \'\', \'\') ``` **Note**: You should manually implement the partitioning process rather than leveraging built-in functions that perform similar tasks.","solution":"def partition_string(user_string: str, separator: str) -> tuple: Partitions a string into three parts around the first occurrence of a given separator. Parameters: user_string (str): The input string to be partitioned. separator (str): The substring to partition the string around. Returns: tuple: A tuple containing three elements - the part before the separator, the separator itself, and the part after the separator. If the separator is not found, returns the original string and two empty strings. # Safety check for empty separator if not separator: return (user_string, \'\', \'\') # Find the index of the first occurrence of the separator index = user_string.find(separator) if index == -1: return (user_string, \'\', \'\') # Extract the parts before_sep = user_string[:index] after_sep = user_string[index + len(separator):] return (before_sep, separator, after_sep)"},{"question":"# Finding the Second Largest Number # Problem Statement You are required to implement a function `second_largest` which finds and returns the second largest number in a given list of integers. If the list does not have at least two distinct numbers, return `None`. # Function Signature ```python def second_largest(numbers: list) -> int: pass ``` # Input * A list of integers `numbers`, where `0 <= len(numbers) <= 10^6`. # Output * Return the second largest distinct integer in the list. * If the list has fewer than two distinct integers, return `None`. # Constraints * The function should be efficient with respect to time and space complexity. * Input should be validated and appropriate exceptions should be raised for invalid inputs (`ValueError` for non-list inputs or non-integer elements). # Examples ```python >>> second_largest([1, 2, 3, 4, 5]) 4 >>> second_largest([5, 5, 5, 4]) 4 >>> second_largest([1]) None >>> second_largest([1, 1, 1, 1]) None >>> second_largest([5]) None >>> second_largest(\'test\') Traceback (most recent call last): ... ValueError: Input must be a list of integers >>> second_largest([1, 3, -1, -5, 4]) 3 >>> second_largest([2, 1.5, 3]) Traceback (most recent call last): ... ValueError: All elements in the list must be integers ``` # Explanation Consider the examples: * `[1, 2, 3, 4, 5]` -> second largest is `4` * `[5, 5, 5, 4]` -> second largest is `4` since other numbers are not distinct * `[1]` -> `None` since there\'s only one number * `[1, 1, 1, 1]` -> `None` since all elements are the same * `[-1, -5, 4, 1, 3]` -> second largest is `3` * `[\'test\']` -> raises `ValueError` since input is not a list * `[2, 1.5, 3]` -> raises `ValueError` since not all elements are integers You can use sorting or a more efficient approach to solve this problem. # Implementation Notes * Validate input and raise `ValueError` if the input is not a list or contains non-integer elements. * Ensure efficient handling of the list to find the second largest number.","solution":"def second_largest(numbers: list) -> int: if not isinstance(numbers, list): raise ValueError(\\"Input must be a list of integers\\") distinct_numbers = set() for num in numbers: if not isinstance(num, int): raise ValueError(\\"All elements in the list must be integers\\") distinct_numbers.add(num) if len(distinct_numbers) < 2: return None sorted_numbers = sorted(distinct_numbers, reverse=True) return sorted_numbers[1]"},{"question":"# Scenario You are working on a logistics management system that tracks packages being delivered by various carriers. Each carrier has a capacity and delivers packages in a specific order based on their destination. When a new package arrives, it must be assigned to a carrier that can deliver it to its destination efficiently. You need to optimize the process by ensuring that packages are distributed among carriers in a balanced manner without exceeding their capacities. # Problem Given the list of carriers with their capacities and the list of packages with their destinations, implement the function `assign_packages(carriers: list[int], packages: list[int]) -> list[list[int]]` to assign each package to an appropriate carrier. The assignment should be balanced in terms of the number of packages per carrier while considering their capacities. Input * `carriers`: A list of integers where each integer represents the capacity of a carrier. * `packages`: A list of integers where each integer represents the destination of a package. Output * A list of lists where each sublist represents the packages assigned to each carrier (in the order they appear in the carriers list). Constraints * The total number of packages will not exceed the sum of all carrier capacities. * The length of `carriers` will be between 1 and 100. * The length of `packages` will be between 1 and 1000. * Each carrier\'s capacity will be a positive integer. * Each package\'s destination will be a positive integer. # Example ```python def assign_packages(carriers: list[int], packages: list[int]) -> list[list[int]]: # Function body here # Example data carriers = [3, 5, 2] packages = [101, 102, 103, 104, 105, 106, 107, 108] result = assign_packages(carriers, packages) print(result) # Should print package assignments such as [[101, 102, 103], [104, 105, 106, 107, 108], []] ``` Performance Requirement * The solution must efficiently allocate packages to carriers without exceeding their capacities and should be done in O(n) time complexity where `n` is the length of the packages list. # Note You need to ensure that packages are distributed in a balanced manner while not exceeding the capacities of the carriers. The goal is to achieve an efficient and balanced allocation.","solution":"def assign_packages(carriers: list[int], packages: list[int]) -> list[list[int]]: # Initialize the result array with empty lists for each carrier result = [[] for _ in range(len(carriers))] carrier_loads = [0] * len(carriers) # Iterate through each package for package in packages: # Find the best carrier based on current loads for i, capacity in enumerate(carriers): if (carrier_loads[i] < capacity): result[i].append(package) carrier_loads[i] += 1 break return result"},{"question":"Coding Assessment Question You are responsible for creating a simple configuration management system where configuration settings can be retrieved and updated dynamically within a distributed application environment. Your task is to build a function that handles these configurations using a centralized storage. # Function Signature ```python def manage_config(action: str, key: str, value: str = None) -> str: ``` # Objective Implement the `manage_config` function that: 1. Takes `action`, `key`, and an optional `value` as parameters. 2. Performs operations based on the `action` parameter to either retrieve or update configuration settings in a persistent storage. # Input/Output Format * **Input**: * `action` (str): The operation to be performed. It should either be `\\"get\\"` for retrieving a configuration or `\\"set\\"` for updating a configuration. * `key` (str): The configuration setting key. * `value` (str): The configuration setting value to be updated (only required for `\\"set\\"` action). * **Output**: * For `\\"get\\"` action: Return the configuration value as a string. * For `\\"set\\"` action: Return a confirmation message `\\"Configuration updated\\"`. # Constraints * Use a dictionary `config_store` to simulate the persistent storage. * If the `key` does not exist during a `get` operation, return a message `\\"Key not found\\"`. * Ensure all updates (with `\\"set\\"` action) are saved in `config_store`. # Context This function is a part of a larger application that needs to dynamically adjust its configuration settings at runtime. Efficient and safe update and retrieval operations are essential for the smooth functioning of the application. # Performance Requirements * Ensure efficient key-value lookup and update operations. * Handle edge cases where `key` might be missing or `value` is not provided when required. # Implementation Notes * Manage the `config_store` dictionary within the function, ensuring it retains state across function calls. * Utilize basic error handling for missing keys during retrieval and missing values during updates. Design and implement the `manage_config` function based on the above requirements.","solution":"config_store = {} def manage_config(action: str, key: str, value: str = None) -> str: Manages configuration settings by either retrieving or updating based on action. Parameters: - action (str): The operation to be performed (\'get\' or \'set\'). - key (str): The configuration setting key. - value (str, optional): The configuration setting value for \'set\' action. Returns: - str: Configuration value for \'get\' action or confirmation message for \'set\' action. global config_store if action == \'get\': return config_store.get(key, \\"Key not found\\") elif action == \'set\': if value is None: return \\"Value required for \'set\' action\\" config_store[key] = value return \\"Configuration updated\\" else: return \\"Invalid action\\""},{"question":"# Coding Question: Custom Round-off Function Context In programming, the round-off function rounds a floating-point number to the nearest integer. If the fractional component of the number is halfway between two integers, the round-off function rounds it to the nearest even number. You are tasked with designing a custom implementation of the `round_off()` function. This will test your understanding of float-to-integer conversions and handling edge cases. Problem Statement Write a function `round_off(x: float) -> int` that rounds-off `x` to the nearest integer. If `x` is exactly halfway between two integers, it should round to the nearest even integer. Input - A single float value `x`. Output - An integer representing the rounded-off value of `x`. Constraints - Your implementation must mirror the mathematical round-off function\'s behavior. - You should handle edge cases such as positive and negative values, zero, and boundary conditions. - You must implement the logic directly without using any library functions like `round` or `math.round`. Example ```python def round_off(x: float) -> int: # Your implementation here # Examples to test your solution print(round_off(1.1)) # Expected output: 1 print(round_off(1.5)) # Expected output: 2 print(round_off(2.5)) # Expected output: 2 print(round_off(-1.1)) # Expected output: -1 print(round_off(-1.5)) # Expected output: -2 print(round_off(1.0)) # Expected output: 1 print(round_off(-1.0)) # Expected output: -1 print(round_off(0.0)) # Expected output: 0 print(round_off(1_000_000_000.5)) # Expected output: 1_000_000_000 ``` Additional Requirements - Your solution must have a time complexity of O(1). - Ensure that the function works for very large and very small floating-point numbers.","solution":"def round_off(x: float) -> int: Custom round-off function to round a float to the nearest integer. If the fractional part is exactly 0.5, it rounds to the nearest even integer. integer_part = int(x) fractional_part = x - integer_part if fractional_part > 0.5 or (fractional_part == 0.5 and integer_part % 2 != 0): return integer_part + 1 elif fractional_part < -0.5 or (fractional_part == -0.5 and integer_part % 2 != 0): return integer_part - 1 else: return integer_part"},{"question":"# Maze Solver with Breadth-First Search You are given a 2D matrix representing a maze where \'1\' denotes a wall and \'0\' denotes an open path. Your task is to determine if there is a path from the top-left corner of the maze to the bottom-right corner using the Breadth-First Search (BFS) algorithm. Function Signature: ```python def is_path_exists(maze: List[List[int]]) -> bool: ``` Input: - The function takes a single argument `maze`, a 2D list of integers where each integer is either 0 or 1. - The top-left corner of the maze is always the start point, and the bottom-right corner is the end point. Output: - The function returns a boolean value `True` if a path exists from the top-left to the bottom-right corner using BFS, otherwise, it returns `False`. Constraints: - The number of rows and columns in the maze does not exceed (10^3). - The maze contains only 0\'s and 1\'s. Example: ```python maze = [ [0, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0], [1, 0, 1, 0] ] assert is_path_exists(maze) == True maze = [ [0, 1, 0, 0], [1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 1, 0] ] assert is_path_exists(maze) == False ``` Note: - The BFS algorithm will help you explore the possible paths in an optimal way. - You can move up, down, left, or right from any point in the maze. - Make sure to handle edge cases where the start or end point may be blocked.","solution":"from typing import List from collections import deque def is_path_exists(maze: List[List[int]]) -> bool: Returns True if there is a path from the top-left to the bottom-right corner in the maze using BFS, otherwise False. if not maze or maze[0][0] == 1 or maze[-1][-1] == 1: return False rows, cols = len(maze), len(maze[0]) queue = deque([(0, 0)]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set((0, 0)) while queue: current_row, current_col = queue.popleft() if (current_row, current_col) == (rows - 1, cols - 1): return True for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] == 0 and (new_row, new_col) not in visited: queue.append((new_row, new_col)) visited.add((new_row, new_col)) return False"},{"question":"# Question: Optimize String Compression Algorithm You have been provided with a string compression algorithm. The objective of the algorithm is to shorten repetitive sequences in a string by replacing sequences of the same character with the character followed by the count of repeated occurrences. For instance, the string \\"aaabbc\\" would be compressed to \\"a3b2c1\\". Your task is to optimize the existing compression algorithm. Specifically, modify it so that it does not add a count of \\"1\\" when a character does not repeat. For example, \\"abbc\\" should be compressed to \\"ab2c\\" instead of \\"a1b2c1\\". # Function Signature ```python def optimized_compress(s: str) -> str: Arguments: s: A string comprised of lowercase and uppercase alphabets. Returns: A compressed version of the given string. ``` # Expected Input and Output * **Input**: * `s`: A string consisting of n characters where (1 <= n <= 10^6). * **Output**: * A compressed version of the string where sequences of the same character are replaced by the character followed by the count of repeated occurrences. * Single characters that are not part of a repeating sequence will remain unchanged. * **Additional Constraints**: * The input string `s` will only contain alphabetical characters (both lowercase and uppercase). # Example ```python >>> optimized_compress(\\"aaabbc\\") \'a3b2c\' >>> optimized_compress(\\"aaAAaa\\") \'a2A2a2\' >>> optimized_compress(\\"abcd\\") \'abcd\' >>> optimized_compress(\\"aabbccccaaa\\") \'a2b2c4a3\' ``` # Performance Your implementation should efficiently handle strings of length up to 10^6 characters. # Notes * Describe the algorithmic steps in your function. * Ensure your implementation handles common edge cases effectively, such as strings with no repeated characters, strings with all repeated characters, and mixed sequences.","solution":"def optimized_compress(s: str) -> str: Compresses the input string by replacing sequences of the same character with the character followed by the count of repeated occurrences. Single characters that are not part of a repeating sequence will remain unchanged. :param s: A string comprised of lowercase and uppercase alphabets. :return: A compressed version of the given string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1]) if count > 1: compressed.append(str(count)) count = 1 # Handle the last sequence compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return \'\'.join(compressed)"},{"question":"# Coding Question: Genetic Algorithm for String Mutation **Scenario**: You are tasked with evolving a string to match a target string using a genetic algorithm. A genetic algorithm is a search heuristic inspired by the process of natural selection. Your task is to implement the core part of this algorithm: the mutation and selection phases. Write a function `genetic_algorithm_string` that evolves an initial string to match a given target string. The function should use basic genetic algorithm operations, including selection, crossover, and mutation, to iteratively generate new candidate strings. Function Signature ```python def genetic_algorithm_string( initial_population: list, target: str, mutation_rate: float, max_generations: int ) -> str: Args: - initial_population (list): A list of strings representing the initial population of candidates. - target (str): The target string to evolve towards. - mutation_rate (float): The probability (0.0 to 1.0) of mutating each character in a string. - max_generations (int): The maximum number of generations to run the algorithm for. Returns: - str: The evolved string that matches the target or the closest match found within the allowed generations. ``` Inputs - `initial_population`: A list of strings where each string represents a candidate solution. - `target`: A string representing the target string we want to evolve towards. - `mutation_rate`: A float representing the probability (between 0 and 1) of mutating each character in a string during mutation phase. - `max_generations`: An integer representing the maximum number of generations to iterate. Outputs - A string representing the closest match to the target string found within the allowed number of generations. Constraints - The length of each string in the initial population should be equal to the length of the target string. - The mutation process should respect the mutation rate for each character. # Examples ```python # Evolving a string to match the target \\"hello\\" initial_population = [\\"hxllo\\", \\"hellz\\", \\"herlo\\"] target = \\"hello\\" mutation_rate = 0.05 max_generations = 1000 print(genetic_algorithm_string(initial_population, target, mutation_rate, max_generations)) # Evolving a string to match the target \\"world\\" initial_population = [\\"wqrld\\", \\"wrold\\", \\"worlf\\"] target = \\"world\\" mutation_rate = 0.1 max_generations = 500 print(genetic_algorithm_string(initial_population, target, mutation_rate, max_generations)) ``` # Notes - For the selection phase, you may use any suitable fitness function, such as comparing the number of characters matching the target string. - The crossover phase can be implemented using any standard method, such as single-point crossover. - Mutations should be applied based on the given mutation rate to introduce variations among offspring. - Ensure that the algorithm respects the maximum number of generations and returns the best candidate found.","solution":"import random def fitness(candidate, target): Computes the fitness score of a candidate string compared to the target string. return sum(1 for a, b in zip(candidate, target) if a == b) def mutate(candidate, mutation_rate): Mutates a candidate string based on the given mutation rate. candidate = list(candidate) for i in range(len(candidate)): if random.random() < mutation_rate: candidate[i] = chr(random.randint(32, 126)) # ASCII range for common characters return \'\'.join(candidate) def crossover(parent1, parent2): Performs single-point crossover between two parent strings. point = random.randint(0, len(parent1) - 1) child = parent1[:point] + parent2[point:] return child def genetic_algorithm_string(initial_population, target, mutation_rate, max_generations): Evolves an initial population of strings to match a target string using a genetic algorithm. population = initial_population generation = 0 while generation < max_generations: # Evaluate fitness of each candidate fitness_scores = [(candidate, fitness(candidate, target)) for candidate in population] fitness_scores.sort(key=lambda x: x[1], reverse=True) # Check if any candidate has matched the target if fitness_scores[0][1] == len(target): return fitness_scores[0][0] # Select the best (elitism) and generate new candidates new_population = [fitness_scores[0][0]] # Keep the best candidate while len(new_population) < len(population): # Selection - picking two parents parent1 = random.choice(population) parent2 = random.choice(population) # Crossover child = crossover(parent1, parent2) # Mutation child = mutate(child, mutation_rate) new_population.append(child) population = new_population generation += 1 # Return the closest match after reaching max generations return fitness_scores[0][0]"},{"question":"# Character Frequency in Strings Problem Statement: Implement a Python function that computes the frequency of each character in a given input string. The function should return a dictionary where keys are characters and values are their respective counts. Function Specification: * **Function Name**: `char_frequency` * **Input**: A single string `text` - the input string to be analyzed. * **Output**: A dictionary where each key is a character from the string, and its corresponding value is the count of that character in the input string. Constraints: 1. The input `text` can be of any printable ASCII characters, including spaces. 2. The function should handle both lowercase and uppercase characters separately. Example: ```python >>> char_frequency(\\"Hello World\\") {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'W\': 1, \'r\': 1, \'d\': 1} ``` Ensure that your function passes the following assertions: ```python assert char_frequency(\\"aaa\\") == {\'a\': 3} assert char_frequency(\\"ABab\\") == {\'A\': 1, \'B\': 1, \'a\': 1, \'b\': 1} assert char_frequency(\\"Hello\\") == {\'H\': 1, \'e\': 1, \'l\': 2, \'o\': 1} assert char_frequency(\\"\\") == {} assert char_frequency(\\"123 456 123\\") == {\'1\': 2, \'2\': 2, \'3\': 2, \' \': 2, \'4\': 1, \'5\': 1, \'6\': 1} ``` Considerations: 1. Ensure the dictionary is dynamically created and sized according to the input string. 2. Carefully handle edge cases such as an empty string or strings with a variety of character types. 3. Optimize for readability and performance, especially for longer strings. # Notes: 1. Do not use any external libraries for character frequency analysis. 2. Focus on efficiency and correctness in your solution.","solution":"def char_frequency(text): Computes the frequency of each character in the input string. :param text: str - input string to be analyzed. :return: dict - dictionary where each key is a character from the string, and its corresponding value is the count of that character in the input string. frequency = {} for char in text: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Scenario You are developing a capability to compute deterministic variations of input strings, which can be useful in tasks such as lexical analysis, text normalization or cryptographic applications. A useful transformation in this context is the \\"mirror\\" function, which replaces each letter in a string with its \\"mirror\\" letter. In the English alphabet, \'A\' mirrors to \'Z\', \'B\' to \'Y\', and so on. This transformation should ignore non-alphabetic characters and retain their original positions in the output string. # Task Implement a function that applies the mirror transformation to a given string. The function should apply the transformation only to alphabetic characters (both uppercase and lowercase) and leave other characters unchanged. # Specifications * Write a function `mirror_transform` which takes one parameter: - `input_string` (str): A string that may contain alphabetic and non-alphabetic characters. * Output should be a `str` where each alphabetic character has been transformed to its mirror character, while non-alphabetic characters remain unchanged. # Assumptions - The input string `input_string` can contain spaces, punctuation, and other special characters. - The transformation is case-sensitive, meaning that \'A\' should transform to \'Z\', but \'a\' should transform to \'z\'. # Examples ```python >>> mirror_transform(\\"Hello, World!\\") \\"Svool, Dliow!\\" >>> mirror_transform(\\"Programming 101\\") \\"Kiltiznnrmt 101\\" >>> mirror_transform(\\"A-Z a-z\\") \\"Z-A z-a\\" ``` # Explanation The `mirror_transform` function should process each character individually. For alphabetic characters, find their position in the alphabet and map them to their respective mirror characters while preserving the original case. Non-alphabetic characters should remain unchanged in the output.","solution":"def mirror_transform(input_string): Transforms each alphabetic character in the input string to its mirror character in the alphabet. Non-alphabetic characters remain unchanged. For example: \'A\' <-> \'Z\' \'B\' <-> \'Y\' ... \'a\' <-> \'z\' \'b\' <-> \'y\' ... def mirror_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'A\') + (ord(\'Z\') - ord(c))) elif \'a\' <= c <= \'z\': return chr(ord(\'a\') + (ord(\'z\') - ord(c))) else: return c return \'\'.join(mirror_char(c) for c in input_string)"},{"question":"Data Transformation for Log Analysis You are assigned to develop a function that processes a list of log entries, each containing a timestamp, log level, and message. The function should extract and summarize the number of logs per log level within a specific time frame. Function Signature: ```python def summarize_log_levels(logs: List[str], start_time: str, end_time: str) -> Dict[str, int]: pass ``` Requirements: 1. **Parse Logs**: Each log entry is a string in the format: `\\"YYYY-MM-DD HH:MM:SS [<LogLevel>] <Message>\\"`. E.g., `\\"2023-08-15 14:23:05 [INFO] User logged in.\\"` 2. **Filter by Time Frame**: Consider only log entries with timestamps between `start_time` and `end_time`, inclusive. 3. **Summarize Levels**: Count the number of log entries for each log level (e.g., `INFO`, `ERROR`, `DEBUG`). 4. **Return Summary**: Return a dictionary where keys are log levels and values are the respective counts. Constraints: - Assume logs are provided in chronological order. - The function should handle invalid log entries (e.g., incorrectly formatted lines) gracefully, ignoring them without failing. - Timestamps follow the `\\"YYYY-MM-DD HH:MM:SS\\"` format consistently. Input and Output Format: - **Input**: - A list of log entries (`logs`). - A string representing the start time (`start_time`). - A string representing the end time (`end_time`). - **Output**: A dictionary summarizing the counts of different log levels within the specified time frame. Example ```python logs = [ \\"2023-08-15 14:23:05 [INFO] User logged in.\\", \\"2023-08-15 14:24:12 [ERROR] Failed to load page.\\", \\"2023-08-15 14:25:33 [DEBUG] Debug info here.\\", \\"2023-08-15 14:26:47 [INFO] User logged out.\\", \\"2023-08-15 14:28:01 [ERROR] Failed to save document.\\" ] start_time = \\"2023-08-15 14:23:00\\" end_time = \\"2023-08-15 14:25:00\\" result = summarize_log_levels(logs, start_time, end_time) print(result) # Output: # {\'INFO\': 1, \'ERROR\': 1} ``` Additional Notes: - Ensure robust error handling to manage incorrectly formatted log entries. - Efficiently manage time comparisons and consider edge cases where log entries are exactly at the `start_time` or `end_time`.","solution":"from typing import List, Dict from datetime import datetime def summarize_log_levels(logs: List[str], start_time: str, end_time: str) -> Dict[str, int]: Summarizes the number of log entries for each log level within a specific time frame. Args: - logs (List[str]): List of log entries in the format \\"YYYY-MM-DD HH:MM:SS [<LogLevel>] <Message>\\". - start_time (str): Start time in the format \\"YYYY-MM-DD HH:MM:SS\\". - end_time (str): End time in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: - Dict[str, int]: Dictionary summarizing the count of each log level within the specified time frame. summary = {} start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") for log in logs: try: # Split the log entry into components timestamp_str, rest = log.split(\\" [\\", 1) log_level, message = rest.split(\\"] \\", 1) # Parse the timestamp timestamp = datetime.strptime(timestamp_str.strip(), \\"%Y-%m-%d %H:%M:%S\\") # Check if the log is within the given time frame if start_dt <= timestamp <= end_dt: log_level = log_level.strip() if log_level in summary: summary[log_level] += 1 else: summary[log_level] = 1 except (ValueError, IndexError): # Skip any improperly formatted log entries continue return summary"},{"question":"# Coding Assessment Question: Password Strength Validator **Scenario**: In the context of user authentication systems, it\'s crucial to ensure that users choose strong passwords to maintain their security. You\'ll implement an algorithm to validate password strength according to a set of predefined rules. **Objective**: Write a function `validate_password` that takes a string input and returns a boolean indicating whether the password is strong. Your solution must align with the following specifications. **Specifications**: 1. **Input**: - A string representing the password. 2. **Output**: - A boolean value: `True` if the password is strong, `False` otherwise. 3. **Constraints**: - The password must be at least 8 characters long. - The password must contain at least one uppercase letter. - The password must contain at least one lowercase letter. - The password must contain at least one digit. - The password must contain at least one special character (such as `!@#%^&*()_+-=[]{}|;\':\\",./<>?`). - You must handle possible non-string inputs appropriately by raising a `TypeError`. **Implementation Steps**: 1. Create a function `contains_uppercase` to check if the password contains at least one uppercase letter. 2. Create a function `contains_lowercase` to check if the password contains at least one lowercase letter. 3. Create a function `contains_digit` to check if the password contains at least one digit. 4. Create a function `contains_special_char` to check if the password contains at least one special character. 5. Implement the `validate_password` function to verify if the password meets all the specified constraints. **Function Signatures**: ```python def contains_uppercase(password: str) -> bool: Checks if the password contains at least one uppercase letter. pass def contains_lowercase(password: str) -> bool: Checks if the password contains at least one lowercase letter. pass def contains_digit(password: str) -> bool: Checks if the password contains at least one digit. pass def contains_special_char(password: str) -> bool: Checks if the password contains at least one special character. pass def validate_password(password: str) -> bool: Main function to validate the password input. pass ``` **Performance Requirements**: - Efficiently handle the computation within linear time complexity relative to the length of the password (O(n)). **Example Cases**: ```python assert validate_password(\\"Strong1!pass\\") == True assert validate_password(\\"weakpass\\") == False assert validate_password(\\"Short1!\\") == False assert validate_password(\\"NOLOWERCASE1!\\") == False assert validate_password(\\"nouppercase1!\\") == False assert validate_password(\\"NoSpecialChar0\\") == False assert validate_password(12345678) == False # Raises TypeError ```","solution":"import re def contains_uppercase(password: str) -> bool: Checks if the password contains at least one uppercase letter. return any(char.isupper() for char in password) def contains_lowercase(password: str) -> bool: Checks if the password contains at least one lowercase letter. return any(char.islower() for char in password) def contains_digit(password: str) -> bool: Checks if the password contains at least one digit. return any(char.isdigit() for char in password) def contains_special_char(password: str) -> bool: Checks if the password contains at least one special character. return bool(re.search(r\'[^a-zA-Z0-9]\', password)) def validate_password(password: str) -> bool: Main function to validate the password input. if not isinstance(password, str): raise TypeError(\'Password must be a string.\') if len(password) < 8: return False return (contains_uppercase(password) and contains_lowercase(password) and contains_digit(password) and contains_special_char(password))"},{"question":"# Problem Statement You are given a string of digits and a target number. Implement a function that finds all different possible ways to add the binary operators (\'+\', \'-\', or \'\') between the digits so that they evaluate to the target number. Return all possible strings that evaluate to the target. # Function Signature ```python def add_operators(num: str, target: int) -> list[str]: Finds all possible combinations of binary operators (\'+\', \'-\', \'\') to place between the digits in the input string `num` so that the resulting mathematical expression evaluates to `target`. Args: num (str): A string representing a sequence of digits. target (int): The target number the expression should evaluate to. Returns: list[str]: A list of strings representing all different ways to add operators between digits to evaluate to the target. pass ``` # Example Usage ```python num = \\"123\\" target = 6 result = add_operators(num, target) assert result == [\\"1+2+3\\", \\"1*2*3\\"] num = \\"105\\" target = 5 result = add_operators(num, target) assert result == [\\"1*0+5\\", \\"10-5\\"] num = \\"232\\" target = 8 result = add_operators(num, target) assert result == [\\"2*3+2\\", \\"2+3*2\\"] num = \\"00\\" target = 0 result = add_operators(num, target) assert result == [\\"0+0\\", \\"0-0\\", \\"0*0\\"] num = \\"3456237490\\" target = 9191 assert add_operators(num, target) == [] # No valid combinations ``` # Constraints * The input num is a non-empty string representing a non-negative integer without leading zeros. * The target number is an integer. * Implement a solution with a suitable time complexity for the problem size. # Additional Information Consider edge cases such as: * The string only contains one digit. * The result of an operator insertion may lead to starting with zero (e.g., \\"05\\" should not be considered valid if left like that). * Ensure that the generated valid expressions respect standard mathematical operator precedence.","solution":"def add_operators(num: str, target: int) -> list: def helper(path, pos, evaluated, multed): if pos == len(num): if evaluated == target: results.append(path) return for i in range(pos, len(num)): # Avoid numbers with leading zeros if i != pos and num[pos] == \'0\': break cur = int(num[pos:i + 1]) if pos == 0: # First number, pick it without any operator. helper(path + str(cur), i + 1, cur, cur) else: # Try addition helper(path + \\"+\\" + str(cur), i + 1, evaluated + cur, cur) # Try subtraction helper(path + \\"-\\" + str(cur), i + 1, evaluated - cur, -cur) # Try multiplication helper(path + \\"*\\" + str(cur), i + 1, evaluated - multed + multed * cur, multed * cur) results = [] helper(\\"\\", 0, 0, 0) return results"},{"question":"# Problem Statement: You are given an array of integers which may contain duplicate values. Implement a function `find_k_frequent_elements` that finds the `k` most frequent elements in the array. If there are multiple elements with the same frequency, return the smaller elements first. # Function Signature: ```python def find_k_frequent_elements(arr: List[int], k: int) -> List[int]: ``` # Input: - `arr`: A list of integers which may have duplicates. The length of the list is `n` where 1 <= n <= 10^5. - `k`: An integer specifying the number of most frequent elements to return. 1 <= k <= number of unique elements in arr. # Output: - Return a list containing the `k` most frequent elements in descending order of frequency. If frequencies are the same, return the smaller elements first. # Constraints: 1. Optimize the function to ensure a good performance for large inputs. 2. Handle edge cases such as all elements having the same frequency. # Example: ```python assert find_k_frequent_elements([1, 1, 1, 2, 2, 3], 2) == [1, 2] assert find_k_frequent_elements([4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 7, 7], 3) == [4, 7, 5] assert find_k_frequent_elements([1, 2, 3, 4, 5, 6], 1) == [1] assert find_k_frequent_elements([6, 6, 6, 5, 5, 5, 4, 4, 3, 3, 3, 2, 2, 1], 2) == [3, 5] ``` # Notes: - Use efficient data structures to store element frequencies and identify the top `k` frequent elements. - Ensure the algorithm scales well with `n`. # Solution Criteria: - Your solution should demonstrate an understanding of counting frequencies of elements and efficiently retrieving the top `k` elements based on their frequencies. - Ensure the function returns the correct elements in the desired order and with optimal performance.","solution":"from typing import List from collections import Counter import heapq def find_k_frequent_elements(arr: List[int], k: int) -> List[int]: Find the k most frequent elements in the array. If frequencies are the same, smaller elements should come first. # Count the frequency of each element in the array counter = Counter(arr) # Create a data structure to store the frequency along with values freq_heap = [] for num, freq in counter.items(): # Using a negative frequency to transform into a max-heap heapq.heappush(freq_heap, (-freq, num)) # Extract the top k elements based on frequency and element value result = [] for _ in range(k): freq, num = heapq.heappop(freq_heap) result.append(num) return result"},{"question":"# Dijkstra\'s Algorithm Challenge You are given a weighted directed graph with `V` vertices and `E` edges. All weights of the edges are non-negative. Your task is to implement Dijkstra\'s algorithm to find the shortest path from a given source vertex to all other vertices in the graph. # Function Signature: ```python def dijkstra(graph: List[List[Tuple[int, float]]], source: int) -> List[float]: ``` # Input: - An adjacency list `graph`, where `graph[i]` contains a list of tuples `(j, w)`, representing an edge from vertex `i` to vertex `j` with weight `w`. - An integer `source`, representing the index of the source vertex. # Output: - A list `dist` of length `V`, where `dist[i]` represents the shortest distance from the source vertex to vertex `i`. # Example: Input: ```python graph = [ [(1, 2), (2, 4)], [(2, 1), (3, 7)], [(3, 3)], [] ] source = 0 ``` Output: ```python [0, 2, 3, 6] ``` # Constraints: - 1 <= V <= 100 (For simplicity) - 0 <= E <= V*(V-1)/2 - The weights of all edges are non-negative. **Note**: - You may use a priority queue (heap) to efficiently implement Dijkstra\'s algorithm. - Ensure to handle cases where some vertices are not reachable from the source, representing their distances as float(\'inf\').","solution":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, float]]], source: int) -> List[float]: V = len(graph) dist = [float(\'inf\')] * V dist[source] = 0 pq = [(0, source)] # priority queue, initially with source node and distance 0 while pq: current_dist, u = heapq.heappop(pq) # If the popped distance is greater than the stored distance, continue if current_dist > dist[u]: continue # Explore neighbors for neighbor, weight in graph[u]: distance = current_dist + weight # If found a shorter path to the neighbor if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist"},{"question":"# Question You have been provided with an algorithm to find the median of a list of integers. Implement a function to calculate the median of a given unsorted list. Function Signature ```python def find_median(nums: List[int]) -> float: pass ``` Requirements 1. **Input**: - `nums`: A list of integers. The length of `nums` is ( m ). 2. **Output**: - Return a float representing the median of the list `nums`. 3. **Constraints**: - The list `nums` is not empty (i.e., ( m > 0 )). 4. **Performance**: - Aim for a solution that runs efficiently within the constraints provided. Sorting the list is (O(m log m)). Examples ```python # Find median of [1, 3, 4, 2] >>> find_median([1, 3, 4, 2]) Output: 2.5 # Find median of [7, 8, 3, 1] >>> find_median([7, 8, 3, 1]) Output: 5.0 # Find median of [5, 3, 4] >>> find_median([5, 3, 4]) Output: 4.0 ``` Notes * The median of a list of numbers is the value separating the higher half from the lower half. If the list has an odd number of elements, the median is the middle number. If the list has an even number of elements, the median is the average of the two middle numbers. Your solution should handle both cases appropriately.","solution":"from typing import List def find_median(nums: List[int]) -> float: Returns the median of the list of integers. nums.sort() n = len(nums) mid = n // 2 if n % 2 == 0: # Even number of elements, take the average of the middle two return (nums[mid - 1] + nums[mid]) / 2.0 else: # Odd number of elements, take the middle one return float(nums[mid])"},{"question":"Coding Question # Problem You are given an array of integers representing the heights of buildings on a street, where each element in the array corresponds to the height. Your task is to implement a function `calculate_water_trap(heights: list[int]) -> int` that calculates the total amount of water that would be trapped between the buildings after raining. # Input * A list of integers `heights` where `1 <= len(heights) <= 10^5` and `0 <= heights[i] <= 10^4`. # Output * An integer representing the total volume of water trapped. # Constraints * The solution should execute in O(n) time complexity. * You are not allowed to use more than O(n) extra space. # Examples 1. Input: `heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` Output: `6` (The water trapped between the buildings is 6 units.) 2. Input: `heights = [4, 2, 0, 3, 2, 5]` Output: `9` (The total trapped water is 9 units.) # Notes * Pay attention to edge cases where the array length is less than 3, which cannot trap any water. # Implementation Requirements * The function should handle all edge cases and constraints efficiently. * Avoid using nested loops to maintain optimal time complexity.","solution":"def calculate_water_trap(heights): Calculate the total amount of water that can be trapped between the buildings after it rains. :param heights: List of integers representing the heights of buildings. :return: Integer representing the total volume of water trapped. if not heights or len(heights) < 3: return 0 total_water = 0 left_max = [0] * len(heights) right_max = [0] * len(heights) # Fill left_max array left_max[0] = heights[0] for i in range(1, len(heights)): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[-1] = heights[-1] for i in range(len(heights) - 2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water for i in range(len(heights)): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"# Question: Implement a Cache Management System Context In many real-world applications, efficient cache management is crucial for reducing latency and improving performance. A cache is a temporary storage area that holds data for fast access. One common cache replacement policy is Least Recently Used (LRU). An LRU cache evicts the least recently used items when the cache reaches its capacity. Task You are tasked with implementing an LRU cache system. The cache should allow for insertion, retrieval, and deletion of key-value pairs, following the LRU eviction policy when the cache capacity is reached. Implementation Requirements 1. **Input**: * Various operations related to the cache management: - `put(key, value)` to insert or update a key-value pair. - `get(key)` to retrieve the value of the given key if the key exists, otherwise return -1. - `delete(key)` to remove the key-value pair if the key exists. * Cache capacity as an integer, which defines the maximum number of key-value pairs the cache can hold. 2. **Output**: * For `get(key)` operations, return the value associated with the key, or -1 if the key does not exist. * For `put(key, value)` and `delete(key)` operations, there is no output. 3. **Constraints**: * You must implement the cache with a fixed capacity (`capacity`). * When the cache reaches its capacity, it should evict the least recently used item before inserting a new one. 4. **Performance**: * The `get` and `put` operations must run in O(1) average time complexity. Write a class `LRUCache` with the following methods: - `__init__(self, capacity: int)` initializes the LRU cache with a given capacity. - `get(self, key: int) -> int` retrieves the value of the key if the key exists in the cache, otherwise returns -1. - `put(self, key: int, value: int) -> None` inserts or updates the key-value pair into the cache following the LRU policy. - `delete(self, key: int) -> None` removes the key-value pair if the key exists. Example ```python class LRUCache: def __init__(self, capacity: int): # Your initialization here def get(self, key: int) -> int: # Your implementation here def put(self, key: int, value: int) -> None: # Your implementation here def delete(self, key: int) -> None: # Your implementation here # Example usage: cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Expected output: 1 cache.put(3, 3) # Evicts key 2 print(cache.get(2)) # Expected output: -1 (not found) cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Expected output: -1 (not found) print(cache.get(3)) # Expected output: 3 print(cache.get(4)) # Expected output: 4 cache.delete(3) print(cache.get(3)) # Expected output: -1 (not found) ``` In this task, you will design and implement the LRU cache class to handle various operations efficiently, ensuring adherence to the LRU cache replacement policy.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def delete(self, key: int) -> None: if key in self.cache: del self.cache[key]"},{"question":"# Question: You are asked to add a feature to a text processing program that counts the number of unique words in a given string. Your goal is to implement a function that returns the count of unique words, ignoring case sensitivity, punctuation, and extra whitespace. Function Signature ```python def count_unique_words(text: str) -> int: pass ``` # Input: - A string `text` consisting of words and possible punctuation marks. Length of the string will not exceed (10^6) characters. # Output: - An integer representing the count of unique words. # Constraints: - The input text can contain any printable ASCII character. - The words are separated by whitespace characters. - Consider words with different cases (e.g., \'Hello\' and \'hello\') as the same word. # Performance Requirements: - The solution should handle inputs up to the maximum length efficiently. # Examples: - `count_unique_words(\\"Hello world! Hello, universe.\\") -> 3` - `count_unique_words(\\"Python is great. Python, python, python!\\") -> 3` - `count_unique_words(\\"Unique words, unique Words. Unique!\\") -> 2` # Additional Context: For the purpose of this problem: - Words are sequences of characters separated by whitespace. - Punctuation should be stripped out, and words should be converted to lower case to ensure uniqueness is case-insensitive. You might find functions such as `str.lower()` for case conversion, `str.split()` for separating words, and regular expressions for removing punctuation (`re.sub(r\'[^A-Za-z0-9s]\', \'\', text)`) useful to simplify the problem. This feature will be used in scenarios such as text analysis, indexing, and natural language processing applications. Optimize your solution to handle the worst-case inputs efficiently.","solution":"import re def count_unique_words(text: str) -> int: Returns the count of unique words in the given text. The comparison is case insensitive and ignores punctuation and extra whitespace. # Remove punctuation using regular expression text = re.sub(r\'[^ws]\', \'\', text) # Convert to lower case to ensure case insensitivity text = text.lower() # Split text into words words = text.split() # Use a set to count unique words unique_words = set(words) return len(unique_words)"},{"question":"# Coding Assessment Question Scenario You are part of a software development team working on a text processing module for a new document editing application. One of the features you need to implement is a function that processes a piece of text and determines the top N most frequently occurring words. Your algorithm should be efficient and capable of handling large documents. Objectives Your task is to implement a function that returns the top N most frequently occurring words from a given string of text. If multiple words have the same frequency, they should be returned in alphabetical order. Function Signature ```python from typing import List, Tuple def top_n_frequent_words(text: str, n: int) -> List[Tuple[str, int]]: pass ``` Input * A string `text` containing the text to be analyzed. * An integer `n` specifying the number of top frequent words to return. Output * A list of tuples, each containing a word and its frequency, ordered by frequency in descending order. Words with the same frequency should be ordered alphabetically. Constraints * The input text will consist of lowercase letters and spaces only. * Words are separated by one or more spaces. * The input integer `n` will be between 1 and the total number of unique words in the text. Performance Requirements * The function should run in O(m + k log k) time, where `m` is the length of the input text and `k` is the number of unique words. Example ```python >>> top_n_frequent_words(\\"the quick brown fox jumps over the lazy dog the quick\\", 3) [(\'the\', 3), (\'quick\', 2), (\'brown\', 1)] >>> top_n_frequent_words(\\"to be or not to be\\", 2) [(\'be\', 2), (\'to\', 2)] ``` Instructions 1. Tokenize the input text to extract words. 2. Count the frequency of each word. 3. Sort the words based on their frequencies, and then alphabetically for words with the same frequency. 4. Return the top N frequently occurring words as specified.","solution":"from typing import List, Tuple from collections import Counter def top_n_frequent_words(text: str, n: int) -> List[Tuple[str, int]]: # Split the input text into words words = text.split() # Count the frequency of each word word_counts = Counter(words) # Sort the word counts first by frequency (descending) then alphabetically sorted_word_counts = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Return top n elements from sorted_word_counts list return sorted_word_counts[:n]"},{"question":"**Prime Factors Product** # Problem Statement You are tasked with creating a program that computes the product of all unique prime factors of a given integer `m`. # Input - An integer `m` (2 <= m <= 1,000,000) representing the number whose prime factors\' product is to be calculated. # Output - A single integer representing the product of all unique prime factors of `m`. # Constraints - The input integer `m` will not exceed 1,000,000. # Example ``` Input: 10 Output: 10 Explanation: The prime factors of 10 are 2 and 5, and their product is 10. Input: 28 Output: 14 Explanation: The prime factors of 28 are 2 and 7, and their product is 14. Input: 13 Output: 13 Explanation: 13 is a prime number, so its prime factor is itself. Input: 20 Output: 10 Explanation: The prime factors of 20 are 2 and 5, and their product is 10. ``` # Instructions Implement the function `prime_factors_product(m: int) -> int` which takes an integer `m` and returns the product of all unique prime factors of `m`. # Example Function Signature ```python def prime_factors_product(m: int) -> int: # Your code here ``` # Implementation Considerations - Ensure that your solution properly handles edge cases, such as the smallest possible value of `m`. - Consider using efficient algorithms to find the prime factors, as the upper limit of `m` (1,000,000) requires optimization. # Performance Requirement - Your solution should be efficient and handle the upper limit of `m` (1,000,000) within a reasonable time frame.","solution":"def prime_factors_product(m: int) -> int: def sieve(n): Returns a list of primes up to n (inclusive). is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, n + 1) if is_prime[p]] return primes def unique_prime_factors(m, primes): Returns a set of unique prime factors of m using the given list of primes. factors = set() for prime in primes: if prime * prime > m: break while m % prime == 0: factors.add(prime) m //= prime if m > 1: factors.add(m) # If m is prime itself return factors max_check = int(m ** 0.5) + 1 primes = sieve(max_check) prime_factors = unique_prime_factors(m, primes) product = 1 for factor in prime_factors: product *= factor return product"},{"question":"# Sum of Nested List Problem Statement Write a function that calculates the sum of all integers present in a nested list structure. The list can contain other lists, which can further contain lists, forming a deeply nested structure. Ensure the function can correctly handle and traverse through any level of nested lists. Requirements * Input: A nested list containing integers. * Output: An integer that represents the sum of all integers present in the nested list structure. Constraints 1. The nested list may contain zero or more integers or sub-lists. 2. The integers can be positive, negative, or zero. 3. If the list is empty or contains no integers, the function should return 0. 4. Ensure the function handles deep nesting efficiently without hitting maximum recursion depth. Example ```python def nested_sum(nested_lst: list) -> int: pass # Example test cases print(nested_sum([1, 2, 3])) # Output: 6 print(nested_sum([1, [2, [3, 4]]])) # Output: 10 print(nested_sum([1, [-2, [3, [4, 5, -6]]]])) # Output: 5 print(nested_sum([])) # Output: 0 print(nested_sum([[[]], [[[[3]]]]])) # Output: 3 ``` # Additional Notes - Use recursion to navigate through the nested lists. - Ensure that your function handles edge cases such as deeply nested empty lists efficiently. - Avoid using any built-in functions that directly simplify the task. Implement the recursion logic manually.","solution":"def nested_sum(nested_lst): This function calculates the sum of all integers present in a nested list structure. :param nested_lst: A nested list containing integers. :return: Integer, the sum of all integers in the nested list. total = 0 for element in nested_lst: if isinstance(element, list): total += nested_sum(element) else: total += element return total"},{"question":"# Coding Question Scenario You have been assigned to develop a utility that processes sequences of integers to identify patterns. This utility needs to identify the longest subsequence of consecutive integers, regardless of their order in the original list. The goal is to extract the longest series of numbers that can be rearranged into a sequence with each element incremented by one. Problem Statement Write a function `longest_consecutive_subsequence` that finds the length of the longest subsequence of consecutive integers within a provided list of integers. Implementation - Your function `longest_consecutive_subsequence` should accept: - A list of integers `nums`. - The function should return an integer representing the length of the longest subsequence of consecutive integers. Input - `nums`: A list of integers. Output - An integer representing the length of the longest consecutive subsequence in the list. Constraints - The length of `nums` will be between 0 and 10<sup>5</sup>. - The integers in `nums` will be within the range `-10<sup>6</sup>` to `10<sup>6</sup>`. Example ```python def longest_consecutive_subsequence(nums): # implementation here print(longest_consecutive_subsequence([100, 4, 200, 1, 3, 2])) # Output should be 4 (sequence: 1, 2, 3, 4) print(longest_consecutive_subsequence([1, 2, 0, 1])) # Output should be 3 (sequence: 0, 1, 2) ``` You are expected to handle both positive and negative integers within the specified range and aim for an efficient solution that can process large lists within a reasonable time frame. Use appropriate data structures to optimize the identification of consecutive sequences.","solution":"def longest_consecutive_subsequence(nums): This function returns the length of the longest subsequence of consecutive integers. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: # Only start a new sequence if `num` is the start of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Common Divisors Count Write a function to find the count of common divisors of two given positive integers `a` and `b`. **Problem Statement**: Given two positive integers, calculate and return the count of common divisors. Common divisors are those numbers that exactly divide both `a` and `b`. Write a function named `common_divisors_count` that accepts two integers `a` and `b` and returns an integer representing the count of their common divisors. # Function Signature ```python def common_divisors_count(a: int, b: int) -> int: ``` # Input - Two integers `a` and `b` (1 ≤ a, b ≤ 10^9), where `a` and `b` are the two numbers for which to find the common divisors. # Output - An integer representing the count of common divisors of `a` and `b`. # Constraints 1. The function should be efficient enough to handle large values of `a` and `b`. 2. The function should correctly handle edge cases where `a` and `b` have very few or very many common divisors. # Examples 1. **Input**: `a = 12`, `b = 18` - **Output**: `4` 2. **Input**: `a = 100`, `b = 75` - **Output**: `3` 3. **Input**: `a = 36`, `b = 60` - **Output**: `6` 4. **Input**: `a = 7`, `b = 14` - **Output**: `2` # Explanation - For `12` and `18`, the common divisors are `1, 2, 3,` and `6`. - For `100` and `75`, the common divisors are `1, 5,` and `25`. - For `36` and `60`, the common divisors are `1, 2, 3, 4, 6,` and `12`. - For `7` and `14`, the common divisors are `1` and `7`.","solution":"def common_divisors_count(a: int, b: int) -> int: Returns the count of common divisors of two given positive integers a and b. # Calculate the gcd of a and b def gcd(x, y): while y: x, y = y, x % y return x g = gcd(a, b) # Count the divisors of gcd(a, b) count = 0 for i in range(1, int(g ** 0.5) + 1): if g % i == 0: count += 1 if i != g // i: count += 1 return count"},{"question":"# Path-Specified File Copying with Metadata You are developing a file management tool that includes a feature for copying files from one directory to another while preserving their original metadata. The tool should ensure that the metadata, such as creation and modification timestamps, is copied accurately along with the files. # Requirements: 1. **Function Definition**: Implement a function `copy_files_with_metadata(src_directory: str, dest_directory: str, file_list: list) -> dict` that: - **Parameters**: - `src_directory`: Path to the source directory. - `dest_directory`: Path to the destination directory. - `file_list`: List of filenames to be copied. - **Returns**: - A dictionary where keys are filenames and values are booleans indicating whether each file was successfully copied with metadata preserved (`True` for success, `False` for failure). 2. **Input**: - Source directory and destination directory paths should be valid and accessible. - `file_list` will contain valid filenames present in the source directory. 3. **Output**: - Files copied to the destination directory with their metadata preserved. - A dictionary indicating the success or failure of the copying process for each file. 4. **Constraints**: - The function should handle and accurately copy files of different formats (e.g., text files, images, PDFs). - Efficient handling for copying large files without significant performance penalties. - Proper error handling for common issues such as missing files, permission errors, etc. ```python # Define your function here import shutil import os import stat def copy_files_with_metadata(src_directory: str, dest_directory: str, file_list: list) -> dict: Copy specified files from src_directory to dest_directory while preserving metadata. Parameters: - src_directory <type: str>: Path to the source directory. - dest_directory <type: str>: Path to the destination directory. - file_list <type: list>: List of filenames to be copied. Return: - result_dict <type: dict>: A dictionary indicating success (True) or failure (False) for each file. result_dict = {} for file_name in file_list: src_path = os.path.join(src_directory, file_name) dest_path = os.path.join(dest_directory, file_name) try: # Copy file to destination shutil.copy2(src_path, dest_path) # Confirming metadata preservation src_metadata = os.stat(src_path) dest_metadata = os.stat(dest_path) if (src_metadata.st_mode == dest_metadata.st_mode and src_metadata.st_ctime == dest_metadata.st_ctime and src_metadata.st_mtime == dest_metadata.st_mtime): result_dict[file_name] = True else: result_dict[file_name] = False except Exception as e: result_dict[file_name] = False print(f\\"Error copying {file_name}: {e}\\") return result_dict ``` # Scenario: You work for a data management company that regularly handles transferring large batches of files between different storage locations. One of the challenges is to ensure that the file metadata remains intact during these transfers, as it is crucial for tracking and auditing purposes. Your current task is to create a function that facilitates this process. The function should take in a list of filenames to be copied from a specified source directory to a destination directory, accurately preserving the files\' original metadata, and returning a report on the success of each file copy operation. Use the provided function template to implement the solution. Your function will be integrated into a tool that automates file transfers within the company.","solution":"import shutil import os import stat def copy_files_with_metadata(src_directory: str, dest_directory: str, file_list: list) -> dict: Copy specified files from src_directory to dest_directory while preserving metadata. Parameters: - src_directory <type: str>: Path to the source directory. - dest_directory <type: str>: Path to the destination directory. - file_list <type: list>: List of filenames to be copied. Return: - result_dict <type: dict>: A dictionary indicating success (True) or failure (False) for each file. result_dict = {} for file_name in file_list: src_path = os.path.join(src_directory, file_name) dest_path = os.path.join(dest_directory, file_name) try: # Copy file to destination shutil.copy2(src_path, dest_path) # Confirming metadata preservation src_metadata = os.stat(src_path) dest_metadata = os.stat(dest_path) if (src_metadata.st_mode == dest_metadata.st_mode and src_metadata.st_ctime == dest_metadata.st_ctime and src_metadata.st_mtime == dest_metadata.st_mtime): result_dict[file_name] = True else: result_dict[file_name] = False except Exception as e: result_dict[file_name] = False print(f\\"Error copying {file_name}: {e}\\") return result_dict"},{"question":"# Coding Challenge In a certain video game, players are awarded points for collecting various types of items. Each type of item yields a different number of points. The game developers wish to track the total score of a collection of items efficiently. Objective Your task is to implement a function that calculates the total score given a collection of items and their corresponding point values. Requirements - Implement the function `calculate_total_score` that takes a list of items and a dictionary mapping item types to their point values. - The list of items represents the types of items collected and may contain duplicate item types. Function Signature ```python def calculate_total_score(items: List[str], point_values: Dict[str, int]) -> int: pass ``` Input - `items`: A list of strings where each string represents a type of item collected. - Example: [\\"coin\\", \\"gem\\", \\"coin\\", \\"potion\\"] - `point_values`: A dictionary mapping strings (item types) to integers (point values). - Example: {\\"coin\\": 5, \\"gem\\": 20, \\"potion\\": 10} Output - An integer representing the total score for the collection of items. Constraints - Each item type in `items` is guaranteed to have a corresponding entry in `point_values`. - There will be at least one item in the `items` list. Example Here is an example of how your function should work: ```python >>> calculate_total_score([\\"coin\\", \\"gem\\", \\"coin\\", \\"potion\\"], {\\"coin\\": 5, \\"gem\\": 20, \\"potion\\": 10}) 40 >>> calculate_total_score([\\"gem\\", \\"gem\\", \\"coin\\"], {\\"coin\\": 5, \\"gem\\": 20}) 45 ``` Code Template Use the following template to start your implementation: ```python from typing import List, Dict def calculate_total_score(items: List[str], point_values: Dict[str, int]) -> int: total_score = sum(point_values[item] for item in items) return total_score if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List, Dict def calculate_total_score(items: List[str], point_values: Dict[str, int]) -> int: total_score = sum(point_values[item] for item in items) return total_score"},{"question":"**Scenario**: You have been tasked with creating a function to generate all possible anagrams of a given string. An anagram is a rearrangement of the letters in the input string to form a new string. The function should efficiently generate all unique anagrams without duplicating any permutations. **Problem Statement**: Given a string `s`, write a function `generate_anagrams` to return all unique anagrams of the string. The function should handle strings of varying lengths efficiently and avoid producing duplicate anagrams when the input string contains repeated characters. **Function Signature**: ```python def generate_anagrams(s: str) -> List[str]: pass ``` **Input**: - `s` (str): The input string containing alphanumeric characters. **Output**: - List[str]: A list containing all unique anagrams of the input string. **Constraints**: 1. 1 <= len(s) <= 8 2. The input string contains only alphanumeric characters. # Example: ```python # Example usage generate_anagrams(\\"aab\\") # Expected Output [\'aab\', \'aba\', \'baa\'] generate_anagrams(\\"abc\\") # Expected Output [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] ``` **Explanation**: For the input `\\"aab\\"`, there are multiple possible permutations, but only three unique anagrams: `\\"aab\\"`, `\\"aba\\"`, and `\\"baa\\"`. The function should generate all such unique anagrams without producing any duplicates.","solution":"from typing import List from itertools import permutations def generate_anagrams(s: str) -> List[str]: Generate all unique anagrams of the input string s. # Generate all permutations of the string all_permutations = permutations(s) # Use a set to eliminate duplicate anagrams unique_anagrams = set(\'\'.join(p) for p in all_permutations) # Convert the set back to a list and return return list(unique_anagrams)"},{"question":"# Coding Question: Electrical Impedance Computation You are required to write a function that computes the value of one of the parameters (current, voltage, or impedance) in an electrical circuit where the other two parameters are provided. Function Signature ```python def electrical_impedance(current: float, voltage: float, impedance: float) -> dict[str, float]: pass ``` Input Parameters * `current` (float): The current in the circuit in Amperes. Only one parameter out of current, voltage, and impedance can be zero, indicating that this is the parameter to be calculated. * `voltage` (float): The voltage across the circuit in Volts. * `impedance` (float): The impedance of the circuit in Ohms. Output * A dictionary with the name and calculated value of the parameter that was zero. Constraints * Only one of the input parameters will be zero. * The function should raise a `ValueError` if: * More than one argument is zero. * Any value other than zero is negative (i.e., current, voltage, or impedance). Formula * Ohm\'s Law: `V = I * Z` where `V` is the voltage, `I` is the current, and `Z` is the impedance. Doctests ```python >>> electrical_impedance(current=0, voltage=12, impedance=6) {\'current\': 2.0} >>> electrical_impedance(current=1.5, voltage=0, impedance=20) {\'voltage\': 30.0} >>> electrical_impedance(current=2, voltage=10, impedance=0) {\'impedance\': 5.0} ``` The function should raise a `ValueError` for the following cases: ```python >>> electrical_impedance(current=2, voltage=0, impedance=0) Traceback (most recent call last): ... ValueError: One and only one argument must be 0 >>> electrical_impedance(current=-3, voltage=0, impedance=10) Traceback (most recent call last): ... ValueError: Current can not be negative >>> electrical_impedance(current=1.5, voltage=-15, impedance=0) Traceback (most recent call last): ... ValueError: Voltage can not be negative >>> electrical_impedance(current=3, voltage=5, impedance=-10) Traceback (most recent call last): ... ValueError: Impedance can not be negative ``` Ensure your implementation follows the provided formula and guidelines for error handling.","solution":"def electrical_impedance(current: float, voltage: float, impedance: float) -> dict[str, float]: Computes the value of one of the parameters (current, voltage, or impedance) in an electrical circuit using Ohm\'s Law where the other two parameters are provided. Parameters: current (float): The current in the circuit in Amperes. voltage (float): The voltage across the circuit in Volts. impedance (float): The impedance of the circuit in Ohms. Returns: dict[str, float]: A dictionary with the name and calculated value of the parameter that was zero. Raises: ValueError: If more than one argument is zero or any non-zero value is negative. # Check for invalid inputs if (current < 0 or voltage < 0 or impedance < 0): if current < 0: raise ValueError(\\"Current can not be negative\\") if voltage < 0: raise ValueError(\\"Voltage can not be negative\\") if impedance < 0: raise ValueError(\\"Impedance can not be negative\\") zero_count = sum([current == 0, voltage == 0, impedance == 0]) if zero_count != 1: raise ValueError(\\"One and only one argument must be 0\\") if current == 0: current = voltage / impedance return {\'current\': current} elif voltage == 0: voltage = current * impedance return {\'voltage\': voltage} elif impedance == 0: impedance = voltage / current return {\'impedance\': impedance}"},{"question":"# Calculate Fibonacci Efficiently Scenario You are working on a financial modeling application where rapid computations of Fibonacci numbers are crucial. The application relies heavily on the Fibonacci sequence for various predictive models. Given the significance of performance, you need to ensure that the calculation of the N-th Fibonacci number is done efficiently. Task Implement a function to compute the N-th Fibonacci number, ensuring it works efficiently even for large values of N. You are provided with the skeleton of the function, and you need to implement it as described below. Function **Function `fibonacci`:** - **Input**: A single integer `n` where `0 <= n <= 10^5`. - **Output**: An integer representing the N-th Fibonacci number. The function should use an iterative approach or dynamic programming to achieve time complexity of approximately O(N). ```python def fibonacci(n: int) -> int: Compute the N-th Fibonacci number efficiently. Parameters: - n (int): A non-negative integer (0 <= n <= 10^5) Returns: - int: The N-th Fibonacci number # Your code here ``` Examples ```python # Example fibonacci print(fibonacci(0)) # 0 print(fibonacci(1)) # 1 print(fibonacci(2)) # 1 print(fibonacci(3)) # 2 print(fibonacci(10)) # 55 print(fibonacci(50)) # 12586269025 ``` Constraints * Ensure your function handles edge cases such as `n=0` and `n=1` correctly. * The solution should be efficient and not rely on recursion due to potential stack overflow issues with large values of N. * Aim to minimize space complexity; ideally, the solution should use O(1) additional space. **Note:** Precision is not an issue, as Python\'s integer type automatically handles large integers dynamically.","solution":"def fibonacci(n: int) -> int: Compute the N-th Fibonacci number efficiently. Parameters: - n (int): A non-negative integer (0 <= n <= 10^5) Returns: - int: The N-th Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"**Scenario**: You are tasked with developing a module for an inventory management system. One of the essential features is to help warehouse staff identify items that are frequently out of stock. The system should be able to analyze sales data and identify these problematic items. **Task**: Implement the core functionality that calculates the stock-out frequency of items. # Stock-Out Frequency Calculation Function 1. **Function Name**: `calculate_stock_out_frequency` 2. **Input**: - `items`: A list of strings representing item names. - `sales_data`: A list of lists, where each inner list contains sales records for a single day. Each sales record is a dictionary with \\"item\\" (string) and \\"sold_out\\" (boolean) fields. 3. **Output**: A dictionary where keys are item names, and values are floats representing the percentage of days the item was sold out. # Detailed Requirements: 1. **Input validation**: - Each `sales_data` inner list should only contain dictionaries with \\"item\\" and \\"sold_out\\" fields. - The `items` list should not contain duplicate entries. 2. **Output**: - Return the percentage rounded to 2 decimal places for each item. - Include all items in the output, even if they have no sales record in `sales_data` (default should be 0.00%). # Constraints & Performance: - The function should handle a sales record history spanning multiple years efficiently. - Consider edge cases such as no sales data or items never sold out. # Example Function Signature: ```python def calculate_stock_out_frequency(items: list[str], sales_data: list[list[dict[str, bool]]]) -> dict[str, float]: pass ``` # Example Usage: ```python items = [\\"item1\\", \\"item2\\", \\"item3\\"] sales_data = [ [{\\"item\\": \\"item1\\", \\"sold_out\\": True}, {\\"item\\": \\"item2\\", \\"sold_out\\": False}], [{\\"item\\": \\"item1\\", \\"sold_out\\": False}, {\\"item\\": \\"item2\\", \\"sold_out\\": True}], [{\\"item\\": \\"item1\\", \\"sold_out\\": True}, {\\"item\\": \\"item2\\", \\"sold_out\\": True}], [{\\"item\\": \\"item3\\", \\"sold_out\\": False}, {\\"item\\": \\"item1\\", \\"sold_out\\": True}], ] result = calculate_stock_out_frequency(items, sales_data) print(result) # Expected output: {\\"item1\\": 75.00, \\"item2\\": 50.00, \\"item3\\": 0.00} ``` # Additional Notes: - The calculation of stock-out frequency involves checking each day\'s sales record and determining the percentage of days the item was marked as sold out. - Ensure the solution scales well with large datasets and maintains clarity in identifying stock-out patterns.","solution":"def calculate_stock_out_frequency(items, sales_data): Calculates the stock-out frequency of items. :param items: List of item names. :param sales_data: List of lists, where each inner list contains sales records for a single day. Each sales record is a dictionary with \\"item\\" (string) and \\"sold_out\\" (boolean) fields. :return: A dictionary where keys are item names, and values are floats representing the percentage of days the item was sold out, rounded to 2 decimal places. # Initialize a dictionary to keep track of the count of sold-out days for each item sold_out_count = {item: 0 for item in items} total_days = len(sales_data) # Total number of days in the sales data for daily_sales in sales_data: for record in daily_sales: if record[\\"item\\"] in sold_out_count and record[\\"sold_out\\"]: sold_out_count[record[\\"item\\"]] += 1 # Calculating the percentage of sold-out days for each item sold_out_frequency = {item: round((sold_out_count[item] / total_days) * 100, 2) if total_days > 0 else 0.00 for item in items} return sold_out_frequency"},{"question":"# Coding Question: Merge Intervals in a List with a Custom Comparator You need to implement a function that merges overlapping intervals in a list. Each interval is represented as a tuple containing two integer elements: the start and end of the interval. However, instead of using the traditional less-than comparator for sorting intervals, you are required to implement a custom comparator that respects the following rules: - Compare intervals primarily based on their lengths (shorter intervals come first). - If two intervals have the same length, compare based on the start times (earlier start time comes first). - If two intervals have the same length and start time, compare based on the end times (earlier end time comes first). # Task 1. **Implement the Custom Comparator**: - Write a comparator function, `compare_intervals(interval1, interval2)`, that compares two intervals according to the specified rules. 2. **Merge Intervals**: - Using the custom comparator, sort the list of intervals. - Merge the overlapping intervals in the sorted list and return the result. # Function Signature ```python from typing import List, Tuple def compare_intervals(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> int: Compare two intervals based on custom rules. :param interval1: Tuple[int, int], the first interval. :param interval2: Tuple[int, int], the second interval. :return: -1 if interval1 < interval2, 1 if interval1 > interval2, 0 if they are equal. # Implement custom comparator logic here def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping intervals in a list using the custom comparator for sorting. :param intervals: List[Tuple[int, int]], list of intervals to merge. :return: List[Tuple[int, int]], list of merged intervals. # Sort intervals using the custom comparator # Implement interval merging logic here ``` # Constraints 1. Ensure that the custom comparator is correctly implemented. 2. Handle edge cases such as empty list or list with a single interval. 3. The final list of intervals should be sorted according to the custom comparator. # Sample Input ```python intervals = [(1, 3), (2, 4), (5, 7), (6, 8)] ``` # Sample Output ```python [(1, 4), (5, 8)] ``` # Notes - You can use `functools.cmp_to_key` to convert the comparator function into a key function for sorting. - The provided input is just an example. The function should correctly handle different or more complex sets of intervals. - You should include a main testing block to demonstrate the function\'s capability with various test cases. ```python # Example usage: if __name__ == \\"__main__\\": intervals = [(1, 3), (2, 4), (5, 7), (6, 8)] print(merge_intervals(intervals)) # Expected Output: [(1, 4), (5, 8)] ```","solution":"from typing import List, Tuple import functools def compare_intervals(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> int: Compare two intervals based on custom rules. :param interval1: Tuple[int, int], the first interval. :param interval2: Tuple[int, int], the second interval. :return: -1 if interval1 < interval2, 1 if interval1 > interval2, 0 if they are equal. len1 = interval1[1] - interval1[0] len2 = interval2[1] - interval2[0] if len1 < len2: return -1 elif len1 > len2: return 1 else: if interval1[0] < interval2[0]: return -1 elif interval1[0] > interval2[0]: return 1 else: if interval1[1] < interval2[1]: return -1 elif interval1[1] > interval2[1]: return 1 else: return 0 def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping intervals in a list using the custom comparator for sorting. :param intervals: List[Tuple[int, int]], list of intervals to merge. :return: List[Tuple[int, int]], list of merged intervals. if not intervals: return [] intervals = sorted(intervals, key=functools.cmp_to_key(compare_intervals)) merged_intervals = [intervals[0]] for current in intervals[1:]: last = merged_intervals[-1] if current[0] <= last[1]: # Overlapping intervals merged_intervals[-1] = (last[0], max(last[1], current[1])) else: merged_intervals.append(current) return merged_intervals # Example usage: if __name__ == \\"__main__\\": intervals = [(1, 3), (2, 4), (5, 7), (6, 8)] print(merge_intervals(intervals)) # Expected Output: [(1, 4), (5, 8)]"},{"question":"# Coding Question: Shortest Path in a Directed Acyclic Graph (DAG) Context You are tasked with finding the shortest path from a given start node to all other nodes in a directed acyclic graph (DAG) with weighted edges. The graph is represented using an adjacency list format where each edge has a non-negative weight. Task Description Implement the function `shortest_path_dag(graph, start)`, which takes a dictionary representing a graph and a starting node. The graph is represented as follows: * The keys are node identifiers. * The values are dictionaries of adjacent nodes and their respective edge weights. For example: ```python graph = { \'A\': {\'B\': 2, \'C\': 4}, \'B\': {\'C\': 1, \'D\': 7}, \'C\': {\'D\': 3}, \'D\': {} } ``` The result should be a dictionary: * The keys are node identifiers. * The values are the shortest distances from the start node to that node. For example, given the start node \'A\': ```python shortest_paths = { \'A\': 0, \'B\': 2, \'C\': 3, \'D\': 6 } ``` Constraints * All edge weights are non-negative integers. * The number of nodes (V) where V ≤ 1000. * The given graph is a DAG. * The start node will always be a valid node in the graph. Function Signature ```python def shortest_path_dag(graph: dict[str, dict[str, int]], start: str) -> dict[str, int]: pass ``` Requirements 1. Implementation must use a topological sort to determine the order of processing nodes. 2. Use dynamic programming to calculate the shortest paths. 3. Ensure correctness and efficiency for graph operations. Example Scenario Given the input graph and starting node \'A\': ```python graph = { \'A\': {\'B\': 2, \'C\': 4}, \'B\': {\'C\': 1, \'D\': 7}, \'C\': {\'D\': 3}, \'D\': {} } ``` Your function should return: ```python shortest_paths = { \'A\': 0, \'B\': 2, \'C\': 3, \'D\': 6 } ``` Ensure you include appropriate checks and optimizations to handle edge cases and ensure efficiency.","solution":"def shortest_path_dag(graph, start): def topological_sort(graph): visited = set() order = [] def dfs(node): visited.add(node) for neighbor in graph.get(node, {}): if neighbor not in visited: dfs(neighbor) order.append(node) for node in graph: if node not in visited: dfs(node) return order[::-1] order = topological_sort(graph) dist = {node: float(\'inf\') for node in graph} dist[start] = 0 for node in order: if dist[node] != float(\'inf\'): for neighbor, weight in graph[node].items(): if dist[node] + weight < dist[neighbor]: dist[neighbor] = dist[node] + weight return dist"},{"question":"# Question: Find All Articulation Points in an Undirected Graph You are given an undirected graph with `n` nodes and `m` edges. Your task is to implement an algorithm to find all articulation points (or cut vertices) in the graph. An articulation point is a vertex that, when removed along with its associated edges, increases the number of connected components in the graph. Implement the function `find_articulation_points(n: int, edges: list[tuple[int, int]]) -> list[int]`, which takes the number of nodes `n`, and a list of edges `edges`, where each edge is represented as a tuple `(u, v)`, indicating an undirected edge between nodes `u` and `v`. Input: - `n` (1 ≤ n ≤ 100000): The number of nodes. - `edges` (0 ≤ len(edges) ≤ 200000): A list of tuples representing undirected edges in the graph. Output: - A list of integers, where each integer is a node that is an articulation point. # Constraints: - Nodes are indexed from `0` to `n-1`. - All nodes and edges are valid and properly formatted. # Examples: Example 1: **Input**: ```python n = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (1, 3)] ``` **Output**: ```python [1, 3] ``` Example 2: **Input**: ```python n = 4 edges = [(0, 1), (1, 2), (2, 0), (1, 3)] ``` **Output**: ```python [1] ``` # Notes: - If there are no articulation points, return an empty list. - Ensure your function handles all possible edge cases efficiently. # Function Signature: ```python def find_articulation_points(n: int, edges: list[tuple[int, int]]) -> list[int]: pass ```","solution":"def find_articulation_points(n: int, edges: list[tuple[int, int]]) -> list[int]: Find all articulation points in an undirected graph. from collections import defaultdict def dfs(at): nonlocal dfs_timer visited[at] = True ids[at] = low[at] = dfs_timer dfs_timer += 1 children = 0 for to in graph[at]: if to == parent[at]: continue if not visited[to]: parent[to] = at children += 1 dfs(to) low[at] = min(low[at], low[to]) if parent[at] == -1 and children > 1: articulation_points.add(at) if parent[at] != -1 and low[to] >= ids[at]: articulation_points.add(at) else: low[at] = min(low[at], ids[to]) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) ids = [-1] * n low = [-1] * n visited = [False] * n parent = [-1] * n articulation_points = set() dfs_timer = 0 for i in range(n): if not visited[i]: dfs(i) return list(sorted(articulation_points))"},{"question":"# Binary Search for Finding the Square Root of a Number In this task, you are required to implement a binary search algorithm to find the square root of a given non-negative number with a specified precision. Part 1: Integer Square Root Implement a function `integer_square_root` that uses binary search to find the integer part of the square root of a non-negative integer. Part 2: Precise Square Root Implement a function `precise_square_root` that uses binary search to find the square root of a non-negative number with a specified precision. Function Signatures ```python def integer_square_root(n: int) -> int: Finds the integer part of the square root of a non-negative integer using binary search. Parameters: n (int): The non-negative integer whose square root is to be found. Returns: int: The integer part of the square root. pass def precise_square_root(n: float, precision: float) -> float: Finds the square root of a non-negative number up to a specified precision using binary search. Parameters: n (float): The non-negative number whose square root is to be found. precision (float): The precision up to which the square root is to be computed. Returns: float: The square root of the number up to the specified precision. pass ``` # Constraints * `n` should be a non-negative number. * `precision` should be a positive float less than 1. # Example ```python print(integer_square_root(10)) # Output: 3 print(precise_square_root(10.0, 0.0001)) # Output: approximately 3.1622 (with an error margin up to 0.0001) ``` # Requirements 1. Implement the binary search algorithm for both functions. 2. Ensure handling of edge cases, such as `n` equal to 0 or 1. 3. Optimize for performance, balancing search range and precision requirements.","solution":"def integer_square_root(n: int) -> int: if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n in {0, 1}: return n left, right = 0, n while left <= right: mid = (left + right) // 2 if mid * mid == n: return mid elif mid * mid < n: left = mid + 1 else: right = mid - 1 return right def precise_square_root(n: float, precision: float) -> float: if n < 0: raise ValueError(\\"n must be a non-negative number\\") if precision <= 0 or precision >= 1: raise ValueError(\\"precision must be a positive float less than 1\\") if n in {0, 1}: return float(n) left, right = 0.0, n while right - left > precision: mid = (left + right) / 2 if mid * mid == n: return mid elif mid * mid < n: left = mid else: right = mid return (left + right) / 2"},{"question":"# Problem Statement You are given an integer array `nums` and an integer `target`. Your task is to write a function `find_subarray_sum` that returns the length of the smallest contiguous subarray for which the sum is at least `target`. If no such subarray exists, return 0. # Function Signature ```python def find_subarray_sum(nums: list[int], target: int) -> int: pass ``` # Input * `nums` (list of integers): A list of non-negative integers. * `target` (integer): A non-negative integer representing the target sum. # Output * Returns an integer indicating the length of the smallest contiguous subarray with a sum of at least `target`. If no such subarray exists, returns 0. # Constraints * 1 <= len(nums) <= 10^5 * 0 <= nums[i] <= 10^4 * 0 <= target <= 10^9 # Example 1. Input: `nums = [2, 3, 1, 2, 4, 3], target = 7` Output: `2` Explanation: The subarray `[4, 3]` has the smallest length with a sum >= 7. 2. Input: `nums = [1, 4, 4], target = 4` Output: `1` Explanation: The subarray `[4]` has the smallest length with a sum >= 4. 3. Input: `nums = [1, 1, 1, 1, 1, 1, 1], target = 11` Output: `0` Explanation: There is no subarray with a sum >= 11. # Notes 1. You need to ensure efficient processing for large input arrays. 2. If the input list `nums` is empty, return 0. # Hints * Consider using a sliding window approach to find the smallest subarray length. * Maintain two pointers to represent the window and adjust the window size as you iterate through the array.","solution":"def find_subarray_sum(nums: list[int], target: int) -> int: Finds the length of the smallest subarray with a sum of at least `target`. If no such subarray exists, returns 0. n = len(nums) min_length = float(\'inf\') # Initialize with infinity current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"# Coding Assessment Question: Improved Matrix Multiplication Context The provided `Matrix` class currently supports matrix multiplication, following the standard matrix multiplication rules. However, this implementation could be optimized for larger matrices to enhance performance. One way to achieve this is by employing matrix multiplication algorithms such as Strassen\'s algorithm, which can be more efficient than the naïve approach, especially for large matrices. The Strassen algorithm, for instance, reduces the multiplication operations, leading to better performance by breaking matrices into sub-matrices and recursively performing multiplications and additions. Task Enhance the matrix multiplication method in the `Matrix` class to use Strassen\'s algorithm to optimize the performance for large matrices. Function Signature ```python def multiply(self, other: \'Matrix\') -> \'Matrix\': Multiplies the current matrix by another matrix using an optimized algorithm. Args: other (Matrix): The matrix to multiply with. Returns: Matrix: The resultant matrix product. ``` Input - Two matrices that are already initialized using the provided `Matrix` class. - The method `multiply` is invoked using an instance of the matrix, with another matrix as its argument. Output - The function should return a new matrix which is the product of the two input matrices. Constraints - Ensure compatibility with the existing `Matrix` class and its attributes. - Consider edge cases such as non-conformable matrices (where the number of columns in the first matrix does not match the number of rows in the second matrix). - Your implementation should optimize for larger matrices, but remain functional for smaller matrices. Example ```python # Example 1 matrix1 = Matrix([ [1, 2], [3, 4] ]) matrix2 = Matrix([ [5, 6], [7, 8] ]) result = matrix1.multiply(matrix2) print(result) # Expected output: Matrix([ # [19, 22], # [43, 50] # ]) # Example 2 matrix3 = Matrix([ [2, 3, 4], [1, 0, 0] ]) matrix4 = Matrix([ [0, 1000], [1, 100], [0, 10] ]) result = matrix3.multiply(matrix4) print(result) # Expected output: Matrix([ # [3, 2340], # [0, 1000] # ]) # Example 3 matrix5 = Matrix([ [1] ]) matrix6 = Matrix([ [1, 1], [1, 1] ]) result = matrix5.multiply(matrix6) # raise an exception or show an error ``` Additional Notes - You may need to pad matrices to the nearest power of two dimensions to apply Strassen\'s algorithm. - Include base cases and fallback to standard multiplication for small matrices where Strassen\'s might not be efficient.","solution":"import numpy as np class Matrix: def __init__(self, array): self.array = np.array(array) self.rows = self.array.shape[0] self.cols = self.array.shape[1] def __str__(self): return str(self.array) def multiply(self, other: \'Matrix\') -> \'Matrix\': Multiplies the current matrix by another matrix using an optimized algorithm (Strassen\'s algorithm for larger matrices). Args: other (Matrix): The matrix to multiply with. Returns: Matrix: The resultant matrix product. def naive_multiplication(A, B): return np.dot(A, B) def split(matrix): row, col = matrix.shape row2, col2 = row // 2, col // 2 return matrix[:row2, :col2], matrix[:row2, col2:], matrix[row2:, :col2], matrix[row2:, col2:] def strassen(A, B): if min(A.shape[0], A.shape[1], B.shape[0], B.shape[1]) <= 64: return naive_multiplication(A, B) A11, A12, A21, A22 = split(A) B11, B12, B21, B22 = split(B) M1 = strassen(A11 + A22, B11 + B22) M2 = strassen(A21 + A22, B11) M3 = strassen(A11, B12 - B22) M4 = strassen(A22, B21 - B11) M5 = strassen(A11 + A12, B22) M6 = strassen(A21 - A11, B11 + B12) M7 = strassen(A12 - A22, B21 + B22) C11 = M1 + M4 - M5 + M7 C12 = M3 + M5 C21 = M2 + M4 C22 = M1 - M2 + M3 + M6 C = np.vstack((np.hstack((C11, C12)), np.hstack((C21, C22)))) return C assert self.cols == other.rows, \\"Incompatible matrix dimensions for multiplication\\" n = max(self.rows, self.cols, other.cols) m = 1 while m < n: m *= 2 A_padded = np.zeros((m, m)) B_padded = np.zeros((m, m)) A_padded[:self.rows, :self.cols] = self.array B_padded[:other.rows, :other.cols] = other.array C_padded = strassen(A_padded, B_padded) result = C_padded[:self.rows, :other.cols] return Matrix(result)"},{"question":"# Question: Implementing Recursive Algorithm for nth Term of Custom Sequence **Context**: You are tasked with computing the nth term of a custom mathematical sequence using recursion. This sequence is defined as follows: - ( a(0) = 1 ) - ( a(1) = 1 ) - For ( n geq 2 ), ( a(n) = 2 cdot a(n-1) + 3 cdot a(n-2) ) Your goal is to implement an efficient recursive function that calculates the nth term of the given sequence. **Requirements**: 1. Create a recursive function to compute the nth term based on the defined sequence. 2. Optimize the function to avoid excessive recalculations (use memoization). 3. The function should handle large values of n efficiently. **Function Signature**: ```python def custom_sequence(n: int) -> int: pass ``` **Input**: - `n (int)`: The position in the sequence (0 <= n <= 50). **Output**: - Return an integer representing the nth term of the custom sequence. **Constraints**: - The solution should be optimized for performance using memoization techniques to store and reuse previously computed values. **Examples**: ```python >>> custom_sequence(0) 1 >>> custom_sequence(1) 1 >>> custom_sequence(2) 5 >>> custom_sequence(5) 85 ``` **Hint**: Utilize a dictionary or list to store the results of computed terms to prevent repeated work in recursive calls. This will significantly improve the performance of your recursive solution.","solution":"def custom_sequence(n, memo=None): Computes the nth term of the custom sequence using recursion and memoization. :param n: Position in the sequence (0 <= n <= 50) :param memo: Dictionary used for memoization to store computed terms :return: nth term of the sequence if memo is None: memo = {} if n in memo: return memo[n] if n == 0 or n == 1: memo[n] = 1 else: memo[n] = 2 * custom_sequence(n - 1, memo) + 3 * custom_sequence(n - 2, memo) return memo[n]"},{"question":"# Context: In statistics, the z-score is a measure of how many standard deviations an element is from the mean of the population. It is widely used to establish the position of a raw score within a distribution. Calculating z-scores is essential in standardizing data, particularly in evaluating anomalies or for comparative purposes. # Task: Implement a function `z_score` that calculates the z-score of a given value based on the mean and standard deviation of the population. # Input: 1. `value` (float): The specific value for which you want to calculate the z-score. 2. `mean` (float): The mean of the population. 3. `std_dev` (float): The standard deviation of the population. # Output: - A float representing the z-score of the input value. # Constraints: - `std_dev` must be a positive number. # Examples: ```python def z_score(value: float, mean: float, std_dev: float) -> float: Calculates the z-score of a given value. Parameters: - value : float : The specific value to calculate the z-score for - mean : float : The mean of the population - std_dev : float : The standard deviation of the population Returns: - float : The z-score of the given value if std_dev <= 0: raise ValueError(\\"Standard deviation must be a positive number\\") return (value - mean) / std_dev # Example cases assert z_score(95, 85, 7.5) == 1.3333333333333333 assert z_score(70, 75, 5) == -1.0 assert z_score(50, 50, 10) == 0.0 ``` # Requirements: Implement the function as described and ensure that it can handle various edge cases. The function should raise an appropriate error when the standard deviation is not positive.","solution":"def z_score(value: float, mean: float, std_dev: float) -> float: Calculates the z-score of a given value. Parameters: - value : float : The specific value to calculate the z-score for - mean : float : The mean of the population - std_dev : float : The standard deviation of the population Returns: - float : The z-score of the given value if std_dev <= 0: raise ValueError(\\"Standard deviation must be a positive number\\") return (value - mean) / std_dev"},{"question":"Coding Assessment Question Context You are designing an automated delivery system that utilizes drones to deliver packages within a rectangular grid city. To ensure optimal path planning and obstacle avoidance, you need a function to calculate the minimum steps required for a drone to move from one cell to another within the grid, taking into account unmanned air traffic rules where drones can only move horizontally or vertically, not diagonally. Task Implement a function `min_steps` that calculates the minimum number of steps required for a drone to move from a starting cell to a destination cell within a rectangular grid. Function Signature ```python def min_steps(start: tuple, destination: tuple, grid_size: tuple) -> int: pass ``` Input * `start` and `destination` are tuples of two integers (x, y) representing coordinates of the drone\'s starting and destination cells respectively. * `grid_size` is a tuple of two integers (width, height) representing the dimensions of the rectangular grid. Output * Returns an integer representing the minimum number of steps required for the drone to move from the starting cell to the destination cell. Constraints * The coordinates in `start` and `destination` must be within the bounds of the grid defined by `grid_size`. * Raise `ValueError` if coordinates are out of bounds or if the input is invalid (e.g., negative values for coordinates or grid size). Example ```python assert min_steps((0, 0), (3, 3), (5, 5)) == 6 assert min_steps((1, 1), (1, 1), (4, 4)) == 0 assert min_steps((2, 2), (2, 3), (5, 5)) == 1 assert min_steps((0, 0), (0, 4), (1, 5)) == 4 ``` Edge Cases * Out-of-bounds coordinates: `min_steps((0, 0), (6, 6), (5, 5))` should raise `ValueError`. * Invalid grid size: `min_steps((1, 1), (2, 2), (-1, 5))` should raise `ValueError`. * Negative coordinate values: `min_steps((-1, 0), (1, 3), (4, 4))` should raise `ValueError`.","solution":"def min_steps(start: tuple, destination: tuple, grid_size: tuple) -> int: Calculates the minimum number of steps required for a drone to move from start to destination in a grid of given grid_size. Parameters: - start (tuple): A tuple (x, y) representing the starting cell. - destination (tuple): A tuple (x, y) representing the destination cell. - grid_size (tuple): A tuple (width, height) representing the grid dimensions. Returns: - int: The minimum number of steps required to reach the destination. # Unpacking the coordinates and grid size sx, sy = start dx, dy = destination width, height = grid_size # Validate input if any(coord < 0 for coord in [sx, sy, dx, dy]) or width <= 0 or height <= 0: raise ValueError(\\"Coordinates and grid size must be non-negative, and grid size must be positive.\\") if not (0 <= sx < width and 0 <= sy < height and 0 <= dx < width and 0 <= dy < height): raise ValueError(\\"Start or destination coordinates are out of grid bounds.\\") # Calculate the minimum steps using Manhattan distance return abs(dx - sx) + abs(dy - sy)"},{"question":"# Find the Longest Substring with Unique Characters Develop a function to find the length of the longest substring in the given string that contains unique characters. Input: 1. **s**: A string containing lowercase and/or uppercase alphabetical characters. Output: * An integer representing the length of the longest substring with all unique characters. Constraints: 1. The length of the string will not exceed 1000 characters. Example: **Input**: ```python s = \\"abcabcbb\\" ``` **Output**: ```python 3 ``` Explanation: In the input string \\"abcabcbb\\", the longest substring with all unique characters is \\"abc\\", which has a length of 3. # Implementation: Using the provided input, you need to implement the following Python function: ```python def longest_unique_substring(s): # Your code here pass ``` **Requirements**: - Utilize sliding window or hash map techniques to efficiently solve the problem with complexity better than O(n^2). - Ensure that the function handles strings with varying character patterns. - Return the length of the longest substring with unique characters. Provide your implementation of `longest_unique_substring(s)` function below:","solution":"def longest_unique_substring(s): Finds the length of the longest substring with all unique characters. :param s: A string containing lowercase and/or uppercase alphabetical characters. :return: An integer representing the length of the longest substring with unique characters. char_index_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Graph Traversal - Shortest Path Routing In this task, you need to address the problem of finding the shortest path in a weighted graph. This is an essential aspect of network routing and various real-world applications. We will guide you through implementing a shortest path algorithm with a focus on performance optimization and correct functionality. # Requirements 1. Implement the `dijkstra_shortest_path` function to find the shortest path between two nodes in a graph using Dijkstra’s algorithm. 2. Implement adjacency list creation in the `parse_graph` function for efficient graph representation. # Input and Output Formats `dijkstra_shortest_path` * **Input**: - `graph`: A dictionary where keys are node identifiers and values are lists of tuples, each representing a neighbor and the weight of the edge to that neighbor. - `start_node`: The node identifier where the path starts. - `end_node`: The node identifier where the path should end. * **Output**: - A tuple containing the list of nodes representing the shortest path and the total distance of that path. If no path is found, return ([], float(\'inf\')). `parse_graph` * **Input**: - `edges`: A list of tuples. Each tuple contains two nodes and the weight of the edge between them. * **Output**: - A dictionary representing the adjacency list of the graph. # Constraints - Graph nodes are represented by unique identifiers (e.g., integers or strings). - Assume weights are non-negative. - The graph is connected. # Example ```python # Example usage of the `parse_graph` edges = [ (1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 5), (3, 4, 1) ] graph = parse_graph(edges) # Expected Output: {1: [(2, 1), (3, 4)], 2: [(1, 1), (3, 2), (4, 5)], 3: [(1, 4), (2, 2), (4, 1)], 4: [(2, 5), (3, 1)]} # Example usage of `dijkstra_shortest_path` start_node = 1 end_node = 4 result = dijkstra_shortest_path(graph, start_node, end_node) # Expected Output: ([1, 2, 3, 4], 4) ``` # Your Task: 1. Implement the `parse_graph` function to convert a list of edges into an adjacency list representation of the graph. 2. Implement the `dijkstra_shortest_path` function using Dijkstra\'s algorithm to find the shortest path between two nodes in the graph.","solution":"import heapq def parse_graph(edges): Converts a list of edges into an adjacency list representation of the graph. Args: edges (List[Tuple]): A list of tuples where each tuple represents an edge by containing (node1, node2, weight). Returns: Dict: An adjacency list representation of the graph. graph = {} for u, v, weight in edges: if u not in graph: graph[u] = [] if v not in graph: graph[v] = [] graph[u].append((v, weight)) graph[v].append((u, weight)) return graph def dijkstra_shortest_path(graph, start_node, end_node): Finds the shortest path in a weighted graph using Dijkstra\'s algorithm. Args: graph (Dict): Graph represented as an adjacency list where keys are node identifiers and values are lists of tuples representing (neighbor, weight). start_node: The node identifier where the path starts. end_node: The node identifier where the path should end. Returns: Tuple: A tuple containing a list of nodes representing the shortest path and the total distance of that path. If no path is found, return ([], float(\'inf\')). # Priority queue to store (distance, node) and initialize with the start node priority_queue = [(0, start_node)] # Dictionary to store the shortest known distance to each node from the start node distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Dictionary to store the path taken to reach each node previous_nodes = {node: None for node in graph} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end_node: # Reconstruct the path from end_node to start_node path = [] while current_node is not None: path.append(current_node) current_node = previous_nodes[current_node] return (path[::-1], current_distance) for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) return ([], float(\'inf\'))"},{"question":"# Problem Statement Create a function that processes a sequence of query operations to manipulate a dynamic array (which starts off empty) and outputs the results of specific query types. Each query operation can be one of the following: 1. **Insert `(x)`:** Insert the element `x` into the dynamic array. 2. **Delete `(y)`:** Delete the first occurrence of the element `y` in the dynamic array. If the element is not found, do nothing. 3. **GetMax ():** Output the maximum element currently in the dynamic array. # Function Signature ```python def process_queries(queries: list[tuple[str, int]]) -> list[int]: pass ``` # Input * `queries`: A list of tuples where each tuple is formatted as follows: * `(query_type, element)` for `Insert` and `Delete` operations where `query_type` is a string and `element` is an integer. * `(query_type,)` for the `GetMax` operation where `query_type` is a string. * The query types are guaranteed to be valid strings: \\"Insert\\", \\"Delete\\", and \\"GetMax\\". * `1 <= len(queries) <= 10^5` * The elements for `Insert` and `Delete` operations are integers in the range `-10^9` to `10^9`. # Output * Returns a list of integers which are the results of each `GetMax` operation in the order they were performed in the input queries. # Constraints * Ensure that the function efficiently handles up to 100,000 queries. * Consider edge cases where the array might be empty when `GetMax` is called. * Make sure the operations for insertion, deletion, and getting the maximum element are optimized for performance. # Example ```python assert process_queries([(\\"Insert\\", 10), (\\"Insert\\", 5), (\\"GetMax\\",), (\\"Delete\\", 10), (\\"GetMax\\",)]) == [10, 5] assert process_queries([(\\"Insert\\", -1), (\\"Insert\\", -2), (\\"Insert\\", -3), (\\"GetMax\\",), (\\"Delete\\", -1), (\\"GetMax\\",)]) == [-1, -2] assert process_queries([(\\"GetMax\\",)]) == [] ``` # Special Requirements * Ensure your function correctly handles scenarios where elements are not present for deletion or when `GetMax` is called on an empty array. * The function should be designed to perform efficiently even with a large number of queries.","solution":"def process_queries(queries): from collections import deque dynamic_array = deque() results = [] for query in queries: if query[0] == \\"Insert\\": dynamic_array.append(query[1]) elif query[0] == \\"Delete\\": try: dynamic_array.remove(query[1]) except ValueError: pass elif query[0] == \\"GetMax\\": if dynamic_array: results.append(max(dynamic_array)) else: results.append(None) return results"},{"question":"# Question You are assigned to process a sequence of operations used to manipulate a list. The operations include insertion, deletion, and retrieval of elements. Your task is to implement a system that efficiently performs these operations. Problem Statement Write a class `CustomList` that supports the following operations: - `insert(val: int, pos: int) -> None`: Insert `val` at the specified `pos`. - `remove(pos: int) -> None`: Remove the element at the specified `pos`. - `get(pos: int) -> int`: Retrieve the element at the specified `pos`. The operations should be performed with optimal time complexity. Input - `val`: An integer value to be inserted. - `pos`: An integer position in the list where the operation is to be performed. Output - `None` for `insert` and `remove`. - An integer for `get`. Constraints - The list will always have sufficient capacity (1 ≤ length of list < 10^5). - `0 ≤ pos < current length of the list`. - All positions `pos` provided for `remove` and `get` will be valid. Example ```python class CustomList: def __init__(self): ... def insert(self, val: int, pos: int) -> None: ... def remove(self, pos: int) -> None: ... def get(self, pos: int) -> int: ... # Example Usage: lst = CustomList() lst.insert(10, 0) # List becomes [10] lst.insert(20, 1) # List becomes [10, 20] lst.insert(15, 1) # List becomes [10, 15, 20] print(lst.get(1)) # Output: 15 lst.remove(1) # List becomes [10, 20] print(lst.get(1)) # Output: 20 ``` Note * Consider the edge cases where the list might be empty initially or after removal. * Implement the class with proper error handling while accessing positions.","solution":"class CustomList: def __init__(self): self.data = [] def insert(self, val: int, pos: int) -> None: Inserts the value `val` at the given position `pos`. self.data.insert(pos, val) def remove(self, pos: int) -> None: Removes the element at the given position `pos`. if 0 <= pos < len(self.data): self.data.pop(pos) else: raise IndexError(\\"Position out of range\\") def get(self, pos: int) -> int: Retrieves the element at the given position `pos`. if 0 <= pos < len(self.data): return self.data[pos] else: raise IndexError(\\"Position out of range\\")"},{"question":"Problem Statement: Implement a class `Matrix` that provides basic matrix operations for 2D matrices. Specifically, the class should support matrix addition, subtraction, and multiplication. Additionally, the `Matrix` class should be able to raise a `Matrix` to a power using an efficient exponentiation by squaring method. # Task Requirements: 1. Implement the `Matrix` class with the following methods: - `__init__(self, data: List[List[int]])`: Initialize the matrix with a 2D list of integers `data`. - `__add__(self, other: Matrix) -> Matrix`: Matrix addition where the resulting matrix is the sum of `self` and `other`. - `__sub__(self, other: Matrix) -> Matrix`: Matrix subtraction where the resulting matrix is the difference between `self` and `other`. - `__mul__(self, other: Matrix) -> Matrix`: Matrix multiplication where the resulting matrix is the product of `self` and `other`. - `__pow__(self, power: int) -> Matrix`: Matrix exponentiation where the result is `self` raised to the power `power`. # Constraints: 1. Ensure input matrices `self` and `other` have matching dimensions for addition and subtraction. 2. Ensure the number of columns in `self` matches the number of rows in `other` for multiplication. 3. Implement efficient matrix exponentiation to handle powers up to (10^6). 4. All matrices will have dimensions up to (100 times 100). 5. Handle input validation where necessary. # Function Signatures: ```python class Matrix: def __init__(self, data: List[List[int]]): pass def __add__(self, other: Matrix) -> Matrix: pass def __sub__(self, other: Matrix) -> Matrix: pass def __mul__(self, other: Matrix) -> Matrix: pass def __pow__(self, power: int) -> Matrix: pass ``` # Example: ```python matrixA = Matrix([[1, 2], [3, 4]]) matrixB = Matrix([[5, 6], [7, 8]]) assert (matrixA + matrixB).data == [[6, 8], [10, 12]] assert (matrixA - matrixB).data == [[-4, -4], [-4, -4]] assert (matrixA * matrixB).data == [[19, 22], [43, 50]] assert (matrixA ** 2).data == [[7, 10], [15, 22]] ```","solution":"from typing import List class Matrix: def __init__(self, data: List[List[int]]): self.data = data def __add__(self, other: \'Matrix\') -> \'Matrix\': return Matrix([[self.data[i][j] + other.data[i][j] for j in range(len(self.data[0]))] for i in range(len(self.data))]) def __sub__(self, other: \'Matrix\') -> \'Matrix\': return Matrix([[self.data[i][j] - other.data[i][j] for j in range(len(self.data[0]))] for i in range(len(self.data))]) def __mul__(self, other: \'Matrix\') -> \'Matrix\': result = [[0] * len(other.data[0]) for _ in range(len(self.data))] for i in range(len(self.data)): for j in range(len(other.data[0])): for k in range(len(other.data)): result[i][j] += self.data[i][k] * other.data[k][j] return Matrix(result) def __pow__(self, power: int) -> \'Matrix\': def matrix_identity(size: int) -> \'Matrix\': return Matrix([[1 if i == j else 0 for j in range(size)] for i in range(size)]) def matrix_mult(A: \'Matrix\', B: \'Matrix\') -> \'Matrix\': return A * B result = matrix_identity(len(self.data)) base = self while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result def __eq__(self, other: \'Matrix\') -> bool: return self.data == other.data"},{"question":"# Counting Matches in a Grid Problem Statement Consider a grid of size M * N filled with integers. You need to find the number of times a given pattern (a smaller grid) appears in the larger grid. The pattern must appear exactly, meaning all its elements must match the corresponding elements in the same relative positions in the larger grid. Task Write a function `count_pattern_matches` that counts the number of times a given pattern appears in a larger grid. # Function Signature ```python def count_pattern_matches(grid: List[List[int]], pattern: List[List[int]]) -> int: ``` Parameters - `grid` (List[List[int]]): The larger grid containing integers. - `pattern` (List[List[int]]): The smaller grid pattern to find in the larger grid. Returns - `int`: The count of exact matches of the pattern in the larger grid. Example ```python grid = [ [1, 2, 3, 4], [5, 1, 2, 3], [1, 2, 3, 4], [5, 1, 2, 3] ] pattern = [ [1, 2, 3], [5, 1, 2] ] assert count_pattern_matches(grid, pattern) == 2 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] pattern = [ [5, 6], [8, 9] ] assert count_pattern_matches(grid, pattern) == 1 ``` Constraints - 1 ≤ rows of grid, columns of grid ≤ 100 - 1 ≤ rows of pattern, columns of pattern ≤ min(rows of grid, columns of grid) - Negative and positive integers can be present in the grid and pattern. Scenario You are implementing a search function for a graphical design application. The grid represents the pixel values of a large image, and the pattern represents a smaller image segment. The function must efficiently count how many times the smaller segment appears within the larger image.","solution":"def count_pattern_matches(grid, pattern): def is_pattern_found(grid, pattern, start_row, start_col): for i in range(len(pattern)): for j in range(len(pattern[0])): if grid[start_row + i][start_col + j] != pattern[i][j]: return False return True count = 0 rows_grid = len(grid) cols_grid = len(grid[0]) rows_pattern = len(pattern) cols_pattern = len(pattern[0]) for i in range(rows_grid - rows_pattern + 1): for j in range(cols_grid - cols_pattern + 1): if is_pattern_found(grid, pattern, i, j): count += 1 return count"},{"question":"# Maximum Subarray Sum with Divide and Conquer Context: You are given an array of integers representing the profit/loss of a company over a series of days. Your task is to find the maximum possible profit over any subarray of days using a divide and conquer approach. Task: Implement a function to find the maximum subarray sum using the divide and conquer method. Requirements: 1. **Function**: `max_subarray_sum(arr: list[int]) -> int` - Input: A list of integers `arr` where each element represents the profit/loss on a given day. - Output: An integer representing the maximum sum of any contiguous subarray in `arr`. - Constraints: The input list will have at least one element and can contain both positive and negative numbers. Example: ```python arr = [3, -2, 5, -1, 4, -5, 2] result = max_subarray_sum(arr) assert result == 9 # This is the sum of the subarray [3, -2, 5, -1, 4] arr = [-1, -3, -4, -2] result = max_subarray_sum(arr) assert result == -1 # The maximum subarray sum is the least negative number arr = [7, -3, 2, 1, -2, 3, -4] result = max_subarray_sum(arr) assert result == 8 # This is the sum of the subarray [7, -3, 2, 1, -2, 3] ``` Restrictions: - Your solution should employ a divide and conquer strategy to ensure efficient computation. - Aim for a time complexity of O(n log n). By structuring the question like this, it aligns with the complexity, style, and length of the original question, requiring similar skills such as understanding of algorithms, recursion, and efficiency considerations in solving typical array manipulation problems.","solution":"def max_subarray_sum(arr: list[int]) -> int: def max_crossing_sum(arr, left, mid, right): # Include elements on the left of mid left_sum = float(\'-inf\') total = 0 for i in range(mid, left - 1, -1): total += arr[i] if total > left_sum: left_sum = total # Include elements on the right of mid right_sum = float(\'-inf\') total = 0 for i in range(mid + 1, right + 1): total += arr[i] if total > right_sum: right_sum = total # Return sum of elements on left and right of mid # mid element is included in both sums return left_sum + right_sum def max_subarray_sum_rec(arr, left, right): # Base case: only one element if left == right: return arr[left] # Find middle point mid = (left + right) // 2 # Return maximum of following three possible cases # a) Maximum subarray sum in left half # b) Maximum subarray sum in right half # c) Maximum subarray sum such that the subarray crosses the midpoint return max(max_subarray_sum_rec(arr, left, mid), max_subarray_sum_rec(arr, mid + 1, right), max_crossing_sum(arr, left, mid, right)) return max_subarray_sum_rec(arr, 0, len(arr) - 1)"},{"question":"# Scenario You are developing a traffic management system that needs to calculate the time of day when the highest number of vehicles pass through a specific point on the road. For this, you\'ve decided to use historical data from sensors installed at strategic locations. # Task Write a function `find_peak_traffic(data: List[Tuple[str, int]]) -> str` that takes a list of tuples as input, where each tuple contains a timestamp in the format \\"HH:MM\\" and the count of vehicles passing at that time. The function should return the timestamp at which the highest number of vehicles were recorded. If there are multiple such timestamps, return the earliest one. # Input * **data**: A list of tuples, `1 <= len(data) <= 10^5`, where each tuple contains: - A timestamp string `\\"HH:MM\\"` representing the time of day. - An integer (0 <= vehicles <= 1000) representing the number of vehicles recorded at that time. # Output * Return the earliest timestamp with the highest vehicle count as a string in the format `\\"HH:MM\\"`. # Function Signature ```python from typing import List, Tuple def find_peak_traffic(data: List[Tuple[str, int]]) -> str: pass ``` # Examples * `find_peak_traffic([(\\"08:00\\", 50), (\\"09:30\\", 75), (\\"11:00\\", 120), (\\"11:15\\", 120), (\\"14:00\\", 90)])` should return `\\"11:00\\"`. * `find_peak_traffic([(\\"06:00\\", 10), (\\"06:30\\", 15), (\\"07:00\\", 15), (\\"08:00\\", 20), (\\"09:00\\", 20)])` should return `\\"08:00\\"`. # Constraints * Each timestamp in the input list is unique. * The input list is not guaranteed to be sorted by time. # Notes * Ensure the solution efficiently handles the input size constraints. * Consider edge cases where inputs can include the smallest (e.g., `(\\"00:00\\", 0)`) and largest (e.g., `(\\"23:59\\", 1000)`) possible values.","solution":"from typing import List, Tuple def find_peak_traffic(data: List[Tuple[str, int]]) -> str: max_count = -1 peak_time = None for time, count in data: if count > max_count or (count == max_count and time < peak_time): max_count = count peak_time = time return peak_time"},{"question":"# Coding Assessment Question You are developing a scheduling system for a conference. The system needs to allocate meeting rooms to different sessions in such a way that no two sessions overlap in the same room. # Problem Statement Implement a function `schedule_meeting_rooms` that finds the minimum number of meeting rooms required so that no two sessions overlap. # Function Signature ```python def schedule_meeting_rooms(sessions: list[tuple[int, int]]) -> int: pass ``` # Input * `sessions`: A list of tuples, where each tuple `(start, end)` represents the start and end times of a session. Both `start` and `end` are integers representing the time in a 24-hour format. # Output * An integer representing the minimum number of meeting rooms required. # Constraints * The length of `sessions` can be 0 to 10,000. * `0 <= start < end <= 23` # Examples ```python sessions1 = [(0, 30), (5, 10), (15, 20)] assert schedule_meeting_rooms(sessions1) == 2 sessions2 = [(2, 4), (3, 5), (0, 2), (5, 8)] assert schedule_meeting_rooms(sessions2) == 2 sessions3 = [(1, 4), (2, 3)] assert schedule_meeting_rooms(sessions3) == 2 sessions4 = [(6, 10), (1, 3), (2, 4), (4, 7)] assert schedule_meeting_rooms(sessions4) == 2 sessions5 = [] assert schedule_meeting_rooms(sessions5) == 0 ``` In the examples provided: - For `sessions1`, at least two rooms are needed since `(0, 30)` and `(15, 20)` overlap respectively with `(5, 10)` and `(0, 30)`. - For `sessions2`, at most two rooms are required since the intervals can be grouped into two non-overlapping sets: `[(0, 2), (5, 8)]` and `[(2, 4), (3, 5)]`. - For `sessions3`, both sessions overlap at some point. - For `sessions4`, at least two rooms are needed since the intervals `(1, 3)`, `(2, 4)`, and `(4, 7)` overlap at various points with each other. - For `sessions5`, no rooms are required since there are no sessions.","solution":"import heapq def schedule_meeting_rooms(sessions): Finds the minimum number of meeting rooms required so that no two sessions overlap. Args: sessions: A list of tuples, where each tuple (start, end) represents the start and end times of a session. Returns: An integer representing the minimum number of meeting rooms required. if not sessions: return 0 # Sort the sessions by start time sessions.sort(key=lambda x: x[0]) # Use a min-heap to track the end time of sessions currently using a room min_heap = [] heapq.heappush(min_heap, sessions[0][1]) for i in range(1, len(sessions)): # If the current session starts after the earliest ending session if sessions[i][0] >= min_heap[0]: heapq.heappop(min_heap) # Free up a room # Push the end time of the current session into the heap heapq.heappush(min_heap, sessions[i][1]) # The size of the heap is the number of rooms needed return len(min_heap)"},{"question":"# Background Sorting is a fundamental algorithmic task with diverse applications in data processing and analytics. A common twist in sorting problems is to sort data based on custom criteria. In this task, you will implement a sorting algorithm that sorts a list of dictionaries based on multiple criteria. # Task Write a function `custom_sort(data: list, primary_key: str, secondary_key: str) -> list` that sorts a list of dictionaries first by the values associated with `primary_key`, and in case of a tie, by the values associated with `secondary_key`. # Function Signature ```python def custom_sort(data: list, primary_key: str, secondary_key: str) -> list: pass ``` # Input * `data` (list): A list of dictionaries where all dictionaries have the same keys. * `primary_key` (str): The key by which to primarily sort the dictionaries. * `secondary_key` (str): The key by which to secondarily sort the dictionaries in case of ties with the primary key. # Output A list of dictionaries sorted based on the specified keys. # Constraints 1. Each dictionary in `data` will contain the keys `primary_key` and `secondary_key`. 2. The values associated with `primary_key` and `secondary_key` will support standard comparison operations. 3. The input list `data` can have up to (10^5) dictionaries. # Example Usage ```python data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 90}, {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"score\\": 95}, ] sorted_data = custom_sort(data, primary_key=\\"age\\", secondary_key=\\"score\\") # sorted_data should return: # [ # {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"score\\": 95}, # {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"score\\": 85}, # {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 90}, # ] ``` # Performance Requirements * The solution should be optimized for performance, considering efficient sorting algorithms provided by the language\'s standard library. # Notes - Consider edge cases such as empty lists or lists with dictionaries of identical key values. - Test the function with various input sizes to ensure it handles large datasets efficiently. # Additional Examples ```python data = [ {\\"country\\": \\"USA\\", \\"city\\": \\"New York\\", \\"population\\": 8000000}, {\\"country\\": \\"USA\\", \\"city\\": \\"Los Angeles\\", \\"population\\": 4000000}, {\\"country\\": \\"Canada\\", \\"city\\": \\"Toronto\\", \\"population\\": 3000000}, {\\"country\\": \\"Canada\\", \\"city\\": \\"Vancouver\\", \\"population\\": 6000000}, ] sorted_data = custom_sort(data, primary_key=\\"country\\", secondary_key=\\"population\\") # sorted_data should return: # [ # {\\"country\\": \\"Canada\\", \\"city\\": \\"Toronto\\", \\"population\\": 3000000}, # {\\"country\\": \\"Canada\\", \\"city\\": \\"Vancouver\\", \\"population\\": 6000000}, # {\\"country\\": \\"USA\\", \\"city\\": \\"Los Angeles\\", \\"population\\": 4000000}, # {\\"country\\": \\"USA\\", \\"city\\": \\"New York\\", \\"population\\": 8000000}, # ] ```","solution":"def custom_sort(data: list, primary_key: str, secondary_key: str) -> list: Sorts a list of dictionaries based on the primary_key and secondary_key. Parameters: data (list): A list of dictionaries containing the primary_key and secondary_key. primary_key (str): The key by which to primarily sort the dictionaries. secondary_key (str): The key by which to secondarily sort the dictionaries in case of ties with the primary key. Returns: list: A sorted list of dictionaries based on the specified keys. return sorted(data, key=lambda x: (x[primary_key], x[secondary_key]))"},{"question":"# Problem Statement You are working with a linked list and fundamental list operations. Implement functions to perform various tasks on a singly linked list. Your task is to implement the following functions: 1. `reverse_linked_list(head: ListNode) -> ListNode` * **Input**: `ListNode` representing the head of the linked list. * **Output**: `ListNode` representing the head of the reversed linked list. 2. `detect_cycle(head: ListNode) -> bool` * **Input**: `ListNode` representing the head of the linked list. * **Output**: Boolean value indicating whether there is a cycle in the linked list. 3. `merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode` * **Input**: Two `ListNode` representing the heads of two sorted linked lists. * **Output**: `ListNode` representing the head of the merged sorted linked list. 4. `remove_nth_from_end(head: ListNode, n: int) -> ListNode` * **Input**: `ListNode` representing the head of the linked list and an integer `n`. * **Output**: `ListNode` representing the head of the linked list after removing the nth node from the end. # Constraints: * The number of nodes in the linked list is in the range `[0, 1000]`. * `-1000 <= Node.val <= 1000` * The input list may be null which should return appropriate outputs as per the function\'s requirement. # Examples 1. For the reverse_linked_list function: * Given the linked list `1 -> 2 -> 3 -> 4 -> 5`, the function should return the reversed list `5 -> 4 -> 3 -> 2 -> 1`. 2. For the detect_cycle function: * Given the linked list `3 -> 2 -> 0 -> -4`, where the tail connects to the second node, the function should return `true`. 3. For the merge_two_sorted_lists function: * Given two linked lists `1 -> 2 -> 4` and `1 -> 3 -> 4`, the function should return the merged list `1 -> 1 -> 2 -> 3 -> 4 -> 4`. 4. For the remove_nth_from_end function: * Given the linked list `1 -> 2 -> 3 -> 4 -> 5` and `n = 2`, the function should return the list `1 -> 2 -> 3 -> 5`. # Directions: * Implement each function as described. * Aim for optimal time and space complexity. * Consider edge cases like empty lists or lists with only one node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None curr = head while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev def detect_cycle(head: ListNode) -> bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 or l2 return dummy.next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: dummy = ListNode(0, head) first = second = dummy for _ in range(n + 1): first = first.next while first: first = first.next second = second.next second.next = second.next.next return dummy.next"},{"question":"Dynamic Array Implementation and Operations **Objective**: You are required to implement a simplified dynamic array (similar to Python\'s list), which supports basic operations such as addition, deletion, and resizing. # Class: `DynamicArray` **Attributes**: - `capacity`: An integer representing the current capacity of the array. - `size`: An integer representing the number of elements currently stored. - `array`: A list that will store the elements. # Methods: 1. `__init__(self, initial_capacity: int = 2) -> None` **Input**: - `initial_capacity`: An integer representing the initial capacity of the dynamic array (default is 2). **Description**: - Initializes the dynamic array with the given capacity and sets the initial size to 0. 2. `append(self, element: int) -> None` **Input**: - `element`: An integer value to be added to the dynamic array. **Description**: - Adds an element to the end of the array. If the array is full, it doubles its capacity before adding the new element. 3. `remove(self, index: int) -> None` **Input**: - `index`: An integer index of the element to be removed from the array. **Description**: - Removes the element at the specified index and shifts all subsequent elements to the left. If the index is out of bounds, raise an IndexError. 4. `get(self, index: int) -> int` **Input**: - `index`: An integer index of the element to retrieve. **Output**: - Returns the integer value at the specified index. **Description**: - Retrieves the element at the specified index. If the index is out of bounds, raise an IndexError. 5. `resize(self) -> None` **Description**: - Doubles the current capacity of the array and copies the existing elements to the new array with the increased capacity. # Example: ```python >>> da = DynamicArray() >>> da.append(10) >>> da.append(20) >>> da.capacity 2 >>> da.size 2 >>> da.append(30) >>> da.capacity 4 >>> da.get(1) 20 >>> da.remove(1) >>> da.get(1) 30 ``` # Constraints: - Assume all integer operations are within the bounds of typical 32-bit integers. - Ensure operations handle edge cases gracefully, such as resizing when capacity is full and proper index handling. - Optimize for performance where possible without sacrificing clarity or correctness. # Requirements: 1. Implement the `DynamicArray` class with the methods `__init__`, `append`, `remove`, `get`, and `resize`. 2. Ensure the class and methods handle edge cases gracefully (e.g., proper index bounds, capacity doubling). 3. Test your implementation using standard unit tests to verify the correctness of each operation. # Note: 1. Do not provide any file handling code; focus on class and method implementations. 2. Your implementation should be capable of being tested using standard unit tests.","solution":"class DynamicArray: def __init__(self, initial_capacity: int = 2) -> None: self.capacity = initial_capacity self.size = 0 self.array = [0] * self.capacity def append(self, element: int) -> None: if self.size == self.capacity: self.resize() self.array[self.size] = element self.size += 1 def remove(self, index: int) -> None: if index < 0 or index >= self.size: raise IndexError(\\"Index out of bounds\\") for i in range(index, self.size - 1): self.array[i] = self.array[i + 1] self.size -= 1 self.array[self.size] = 0 # Optional: clear last element def get(self, index: int) -> int: if index < 0 or index >= self.size: raise IndexError(\\"Index out of bounds\\") return self.array[index] def resize(self) -> None: self.capacity *= 2 new_array = [0] * self.capacity for i in range(self.size): new_array[i] = self.array[i] self.array = new_array"},{"question":"# Coding Assessment Question: Unique Pairs Sum to Target Problem Statement: Write a function that takes an array of integers and a target integer value. The function should return all unique pairs of integers from the array that sum up to the target value. The pairs should be returned as a list of tuples, where each tuple contains exactly two integers. Function Signature: ```python def find_unique_pairs(nums: list, target: int) -> list: pass ``` Example: ```python assert find_unique_pairs([1, 2, 3, 4, 5], 5) == [(1, 4), (2, 3)] assert find_unique_pairs([3, 1, 4, 1, 5], 6) == [(1, 5), (3, 3)] assert find_unique_pairs([1, 1, 1, 1], 2) == [(1, 1)] assert find_unique_pairs([], 1) == [] assert find_unique_pairs([10, -10, 20, -20, 30, -30, 0], 0) == [(-10, 10), (10, -10), (-20, 20), (20, -20), (-30, 30), (30, -30)] ``` Constraints: 1. The input list `nums` will have elements in the range of ([-10^9, 10^9]). 2. The length of the input list `nums` will be between 0 and (10^4). 3. The solution should avoid considering the same pair more than once (i.e., `[1,4]` and `[4,1]` should be considered as the same pair). 4. Each pair in the result should be sorted in ascending order. 5. The pairs themselves should be sorted in ascending order based on the first element of the pair. Expected Input and Output: * **Input**: * `nums`: A list of integers. * `target`: An integer representing the target sum. * **Output**: * A list of tuples, where each tuple contains two integers from `nums` that sum up to `target`. * The pairs should be unique and sorted as per the constraints described. Implementation Guidance: To solve this problem: 1. Iterate through the list keeping track of the visited numbers and their counts. 2. Use a set to maintain the unique pairs found. 3. Check if the complement of the current number (i.e., `target - current number`) exists in the visited numbers. 4. If a valid pair is found, add it to the set. 5. Ensure the pairs and the list are returned in the required sorted order.","solution":"def find_unique_pairs(nums: list, target: int) -> list: seen = {} pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen[num] = seen.get(num, 0) + 1 return sorted(pairs)"},{"question":"# Matrix Transform Sum **Context**: Matrix manipulation is a key aspect of various algorithmic challenges. This problem involves performing a series of transformations on a matrix, followed by operations that sum specific elements based on given queries. **Task**: Write a program that performs multiple transformations on a square matrix and then processes a series of queries to return sums of selected elements. The transformations and queries are specified as follows: 1. Rotate the entire matrix 90 degrees clockwise. 2. Reflect the entire matrix horizontally. 3. Calculate the sum of elements in a specified row or column after performing a series of the above transformations. # Input: 1. An integer ( n ) representing the order of the matrix. 2. A ( n times n ) integer matrix representing the initial matrix. 3. An integer ( t ) representing the number of transformations. 4. A list of ( t ) strings where each string is either \'R\' (rotate 90 degrees clockwise) or \'H\' (reflect horizontally). 5. An integer ( q ) representing the number of queries. 6. A list of ( q ) strings where each string is in the format `R i` (sum of row ( i )) or `C j` (sum of column ( j )). # Output: - For each query, output the sum of the specified row or column after performing all transformations. # Example: ```python Input: n = 3 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] t = 2 transformations = [\'R\', \'H\'] q = 2 queries = [\'R 1\', \'C 2\'] Output: sum at row 1: 24 sum at column 2: 15 ``` **Constraints**: - The order of the matrix ( n ) is between 1 and 100. - The number of transformations ( t ) and queries ( q ) will each be between 1 and 100. - The matrix elements will be integers ranging from -1000 to 1000. - The queries will be in the range of valid row and column indices after transformations. **Note**: - Ensure your solution correctly handles the change in indices due to transformations. - Optimize for performance given the potential matrix size and number of operations. # Explanation: 1. The first transformation \'R\' rotates the matrix: ``` [1, 2, 3] [7, 4, 1] [4, 5, 6] -> [8, 5, 2] [7, 8, 9] [9, 6, 3] ``` 2. The second transformation \'H\' reflects the rotated matrix horizontally: ``` [7, 4, 1] -> [9, 6, 3] [8, 5, 2] [8, 5, 2] [9, 6, 3] [7, 4, 1] ``` 3. Query \'R 1\' calculates the sum of the second row: `8 + 5 + 2 = 15`. 4. Query \'C 2\' calculates the sum of the third column: `3 + 2 + 1 = 6`.","solution":"def rotate_90_clockwise(matrix): n = len(matrix) new_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n-i-1] = matrix[i][j] return new_matrix def reflect_horizontally(matrix): n = len(matrix) new_matrix = [[0]*n for _ in range(n)] for i in range(n): new_matrix[n-i-1] = matrix[i] return new_matrix def process_queries(matrix, queries): results = [] for query in queries: type_, index = query.split() index = int(index) if type_ == \'R\': results.append(sum(matrix[index])) elif type_ == \'C\': results.append(sum(row[index] for row in matrix)) return results def matrix_transform_sum(n, matrix, t, transformations, q, queries): for transformation in transformations: if transformation == \'R\': matrix = rotate_90_clockwise(matrix) elif transformation == \'H\': matrix = reflect_horizontally(matrix) return process_queries(matrix, queries)"},{"question":"# Context You are given a singly linked list, and you need to implement operations involving reordering the list. A singly linked list is a linear data structure where each element (node) points to the next node in the sequence. # Task Implement a function to reorder a singly linked list such that nodes are arranged in a specific order. Specifically, from the first position, it should be followed by the last position, then the second position, then the second last, and so on. **Function Signature**: ```python def reorder_list(head: ListNode) -> None: # Write your code here ``` # Input - `head` (ListNode): The head of the singly linked list. # Output - This function should reorder the list in place and return None. The list itself should be modified. # Constraints - The number of nodes in the linked list will be in the range `[1, 1000]`. - Each node\'s value will be in the range `[1, 1000]`. # Example ```python # Example 1: # Input: 1 -> 2 -> 3 -> 4 -> 5 # Output: 1 -> 5 -> 2 -> 4 -> 3 # Example 2: # Input: 1 -> 2 -> 3 -> 4 # Output: 1 -> 4 -> 2 -> 3 ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): if not head or not head.next: return # Find the middle of the list (using the slow and fast pointer technique) slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Merge the two halves first, second = head, prev while second.next: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first = tmp1 second = tmp2"},{"question":"# String Matching with Wildcards **Problem Statement**: Implement a function that performs string matching with support for the wildcard characters `*` and `?`. The character `*` matches zero or more characters, while the character `?` matches exactly one character. Given a pattern and a string, determine if the pattern matches the string. **Inputs**: 1. **pattern**: A string that may contain wildcard characters `*` and `?`. 2. **text**: A string that is to be matched against the pattern. **Outputs**: 1. **is_match**: Boolean value indicating whether the pattern matches the text. **Constraints**: - 1 <= len(pattern) <= 1000 - 1 <= len(text) <= 1000 - The pattern and text will contain only alphanumeric characters and the wildcard characters (`*`, `?`) in the case of the pattern. **Performance Requirements**: - Aim for an efficient algorithm with an optimal time complexity, considering that the pattern and text can each be up to 1000 characters long. **Function Signature**: ```python def is_match(pattern: str, text: str) -> bool: pass ``` # Example: ```python # Example input pattern and text pattern = \\"a*?b\\" text = \\"aaab\\" # Example run result = is_match(pattern, text) # Expected output: # result: True ``` **Notes**: - The function should handle edge cases such as an empty text or pattern. - Different sequences of `*` in the pattern should be appropriately handled to prevent redundant checks. - Clearly document any assumptions and decisions in the code comments.","solution":"def is_match(pattern: str, text: str) -> bool: Determines if the given pattern matches the text. Pattern can contain wildcards \'*\' and \'?\' :param pattern: str: The pattern to match, containing \'*\' and \'?\' as wildcards :param text: str: The text to match against the pattern :return: bool: True if pattern matches the text, False otherwise # Table to keep track of matches dp = [[False] * (len(text) + 1) for _ in range(len(pattern) + 1)] # Empty pattern matches empty text dp[0][0] = True # Matching empty text with pattern which has \'*\' in the front part for i in range(1, len(pattern) + 1): if pattern[i - 1] == \'*\': dp[i][0] = dp[i - 1][0] for i in range(1, len(pattern) + 1): for j in range(1, len(text) + 1): if pattern[i - 1] == \'*\': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif pattern[i - 1] == \'?\' or pattern[i - 1] == text[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[len(pattern)][len(text)] # Example pattern = \\"a*?b\\" text = \\"aaab\\" print(is_match(pattern, text)) # Expect True"},{"question":"Sum of Multiples # Scenario You are developing a program to calculate the sum of all multiples of a given integer up to a specified limit. This problem will help in understanding loops, conditional checks, and arithmetic sum calculations. # Function to Implement You need to write a function, `sum_of_multiples`, which will accept two integers: a base number and a limit. The function should compute and return the sum of all multiples of the base number that are less than or equal to the limit. # Function Signature ```python def sum_of_multiples(base: int, limit: int) -> int: pass ``` # Input - An integer `base` representing the base number (1 ≤ `base` ≤ 100) - An integer `limit` representing the upper limit (1 ≤ `limit` ≤ 10,000) # Output - An integer representing the sum of all multiples of `base` that are less than or equal to `limit`. # Example ```python sum_of_multiples(3, 10) ``` Output: ```python 18 ``` Explanation: The multiples of 3 up to 10 are 3, 6, and 9. Their sum is 3 + 6 + 9 = 18. ```python sum_of_multiples(5, 15) ``` Output: ```python 30 ``` Explanation: The multiples of 5 up to 15 are 5, 10, and 15. Their sum is 5 + 10 + 15 = 30. ```python sum_of_multiples(7, 20) ``` Output: ```python 42 ``` Explanation: The multiples of 7 up to 20 are 7 and 14. Their sum is 7 + 14 = 21. # Notes - Make sure the function handles edge cases, such as when the limit is less than the base number, returning 0 in such cases (since there would be no multiples in the specified range). - Optimize the function for efficiency, ensuring it works within acceptable time limits for larger values.","solution":"def sum_of_multiples(base: int, limit: int) -> int: Computes the sum of all multiples of the base number that are less than or equal to the limit. Parameters: base (int): The base number whose multiples are summed. limit (int): The upper limit for the multiples. Returns: int: The sum of all multiples of the base number that are <= limit. sum_multiples = 0 for i in range(1, limit + 1): if i * base > limit: break sum_multiples += i * base return sum_multiples"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the sum of the maximum elements from each row of a given 2D array. The function should return the cumulative sum of these maximum values. # Function Signature ```python def sum_of_row_max(arr: List[List[int]]) -> int: ... ``` # Input - `arr`: A 2D list of integers `arr` where `1 <= len(arr) <= 1000` and `1 <= len(arr[i]) <= 1000` for each row `arr[i]`. # Output An integer representing the sum of the maximum elements from each row of the array. # Constraints - The elements of the array will be integers within the range of `−10^6` to `10^6`. - The function should handle edge cases, such as arrays with a single element and arrays with rows of varying lengths. # Requirements 1. The function should efficiently process large 2D arrays. 2. It should accurately handle the specified input constraints. 3. Ensure the function is optimized for performance given the potential input size. # Example ```python >>> sum_of_row_max([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 18 # Explanation: 3 (max of first row) + 6 (max of second row) + 9 (max of third row) = 18 >>> sum_of_row_max([[10, -1, 20], [15], [-50, -100, -25]]) 25 # Explanation: 20 (max of first row) + 15 (max of second row) + -25 (max of third row) = 10 >>> sum_of_row_max([[-5, -2, -3], [-4], [-6, -7, -8]]) -11 # Explanation: -2 (max of first row) + -4 (max of second row) + -6 (max of third row) = -11 >>> sum_of_row_max([[10**6]]) 1000000 # Explanation: 1000000 (max and only element of the only row) = 1000000 >>> sum_of_row_max([[3, 4, 5], [1, 3], [0, 0, 0]]) 8 # Explanation: 5 (max of first row) + 3 (max of second row) + 0 (max of third row) = 8 ``` # Notes Ensure that your implementation is able to handle the provided constraints and edge cases effectively. Optimize for performance to accommodate maximum array sizes.","solution":"from typing import List def sum_of_row_max(arr: List[List[int]]) -> int: This function calculates the sum of the maximum elements from each row of a given 2D array. Parameters: arr (List[List[int]]): A 2D list of integers. Returns: int: The sum of the maximum elements from each row. return sum(max(row) for row in arr)"},{"question":"**Problem Statement:** Given a positive integer `n`, your task is to find the largest prime number that is less than a given number `n`. You need to write a function that efficiently finds this prime number. **Write a function:** ```python def largest_prime_less_than(n: int) -> int: Given a positive integer n, find the largest prime number that is less than n. :param n: An integer representing the upper limit (n > 2) :return: An integer, representing the largest prime number less than n Example: >>> largest_prime_less_than(10) 7 >>> largest_prime_less_than(30) 29 >>> largest_prime_less_than(100) 97 pass ``` # Input - An integer `n` (3 <= n <= 10000) # Output - An integer representing the largest prime number that is less than `n`. # Constraints - The function must handle values up to 10000 efficiently. - The function should return correct results for edge cases, including small primes and large limits. # Scenario This problem aims to test your ability to work with prime numbers and implement efficient algorithms. You need to identify prime numbers and use an optimal method to find the largest one less than a given threshold. # Hints: - Consider using the Sieve of Eratosthenes to precompute prime numbers efficiently. - Remember to check for prime numbers in descending order less than `n`. **Testing:** Ensure that your solution passes the given examples and consider additional edge cases, for instance: - `largest_prime_less_than(3) -> 2` - `largest_prime_less_than(20) -> 19` - `largest_prime_less_than(2) -> No valid output (input constraint)` You should also account for the upper limit efficiently: - `largest_prime_less_than(10000) -> e.g., 9973`","solution":"def largest_prime_less_than(n: int) -> int: Given a positive integer n, find the largest prime number that is less than n. :param n: An integer representing the upper limit (n > 2) :return: An integer, representing the largest prime number less than n def sieve(limit): is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if is_prime[p] == True: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False # 0 and 1 are not prime numbers return [p for p in range(limit + 1) if is_prime[p]] primes = sieve(n - 1) return max(primes) if primes else None"},{"question":"# Simple Interest Calculation Given the formula for calculating simple interest (SI = frac{P cdot R cdot T}{100}), where (P) is the principal amount, (R) is the annual interest rate, and (T) is the time in years: Write a Python function `calculate_simple_interest(principal: float, rate: float, time: float) -> float` that: 1. Accepts the principal amount (in dollars), annual interest rate (as a percentage), and time (in years) as input parameters. 2. Computes and returns the simple interest. 3. Handles the following constraints: - The principal, rate, and time should be non-negative. If any of these values is negative, an appropriate exception with a meaningful message should be raised. # Input * Three floating-point numbers representing the principal amount, annual interest rate, and time in years. # Output * A floating-point number representing the simple interest in dollars. # Example ```python >>> calculate_simple_interest(1000, 5, 2) 100.0 >>> calculate_simple_interest(1500, 4, 3) 180.0 >>> calculate_simple_interest(2000, 3.5, 1.5) 105.0 ``` # Constraints * (0 leq text{principal} leq 10^7) * (0 leq text{rate} leq 100) * (0 leq text{time} leq 100) Create the function `calculate_simple_interest` to meet the specifications above and include input validation to handle incorrect input values.","solution":"def calculate_simple_interest(principal: float, rate: float, time: float) -> float: Calculate the simple interest based on the provided principal amount, annual interest rate, and time in years. Parameters: principal (float): The principal amount in dollars. rate (float): The annual interest rate as a percentage. time (float): The time in years. Returns: float: The calculated simple interest. Raises: ValueError: If any of the principal, rate, or time are negative. if principal < 0: raise ValueError(\\"Principal amount cannot be negative.\\") if rate < 0: raise ValueError(\\"Annual interest rate cannot be negative.\\") if time < 0: raise ValueError(\\"Time in years cannot be negative.\\") simple_interest = (principal * rate * time) / 100 return simple_interest"},{"question":"# Matrix Rotation Task You have been asked to implement a feature for an image processing tool that involves rotating a matrix. Specifically, you need to rotate a 2D matrix 90 degrees clockwise. Implement the following function: 1. **rotate_matrix**: This function should take a 2D matrix (list of lists) as input and return a new matrix that represents the input matrix rotated 90 degrees clockwise. * **Input**: A 2D matrix (list of lists) with dimensions NxN, where 1 ≤ N ≤ 100. * **Output**: A new 2D matrix (list of lists) of the same dimensions, rotated 90 degrees clockwise. * **Constraints**: - Preserve the elements of the matrix exactly as in the input, only their positions change. - Ensure the function handles both odd and even dimensioned matrices efficiently. - Avoid using built-in functions or libraries for matrix manipulation to demonstrate your algorithmic skills. # Examples ```python # Example 1 input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] output_matrix = rotate_matrix(input_matrix) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2 input_matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] output_matrix = rotate_matrix(input_matrix) # Output should be: # [ # [13, 9, 5, 1], # [14, 10, 6, 2], # [15, 11, 7, 3], # [16, 12, 8, 4] # ] ``` # Notes - Address edge cases such as very small matrices (e.g., 1x1) and ensure no index-out-of-bound errors occur. - Properly comment the code to explain the logic and steps involved. - Consider the performance of your algorithm, particularly in handling the upper limit of the input size efficiently.","solution":"def rotate_matrix(matrix): Rotates a given NxN 2D matrix 90 degrees clockwise. Args: matrix (list of lists): NxN 2D matrix to be rotated. Returns: list of lists: Rotated NxN matrix. n = len(matrix) # Create a new matrix with the same dimensions rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): # The new position for matrix[i][j] after 90 degree rotation rotated_matrix[j][n - i - 1] = matrix[i][j] return rotated_matrix"},{"question":"# Problem Statement You are given a `CircularQueue` class implementation that facilitates creating and managing a circular queue with a fixed size. Your task is to extend this class to add the following features: 1. Dynamic resizing of the queue when it becomes full. 2. Adding a method to reverse the order of elements in the queue. # Requirements Dynamic Resizing - Modify the `enqueue` method to dynamically resize the queue when it is full. Double the current size of the underlying array and reallocate the existing elements properly. Reversing Queue - Add a method to reverse the elements in the queue without using additional space proportional to the number of elements (i.e., in-place reversal). # Function Signatures You will need to modify the existing methods and possibly add new ones to the `CircularQueue` class. 1. `enqueue(self, value: T) -> None`: - Adds `value` to the end of the queue. Resizes the queue dynamically if it is full. 2. `reverse(self) -> None`: - Reverses the order of elements in the queue in-place. # Constraints - Elements in the queue are comparable and can be of any data type. - Assume initial size of the queue is manageable within typical integer ranges. # Example Usage ```python queue = CircularQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.to_list() == [1, 2, 3] # Enqueue when full should resize the queue dynamically queue.enqueue(4) assert queue.to_list() == [1, 2, 3, 4] queue.reverse() assert queue.to_list() == [4, 3, 2, 1] # Add more tests to ensure your implementation works correctly # and does not break existing functionalities. if __name__ == \\"__main__\\": unittest.main() ``` # Notes - Ensure your new methods adhere to and extend the existing class design. - Your changes should not break the existing circular queue functionality. - Write new tests to cover the added features and ensure comprehensive testing.","solution":"class CircularQueue: def __init__(self, max_size): self.max_size = max_size self.queue = [None] * max_size self.front = self.rear = -1 def is_full(self): return (self.rear + 1) % self.max_size == self.front def is_empty(self): return self.front == -1 def enqueue(self, value): if self.is_full(): self.resize() if self.front == -1: # Queue is empty self.front = 0 self.rear = (self.rear + 1) % self.max_size self.queue[self.rear] = value def resize(self): new_max_size = self.max_size * 2 new_queue = [None] * new_max_size idx = 0 i = self.front while True: new_queue[idx] = self.queue[i] if i == self.rear: break i = (i + 1) % self.max_size idx += 1 self.queue = new_queue self.front = 0 self.rear = idx self.max_size = new_max_size def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.max_size return value def reverse(self): if self.is_empty(): return start = self.front end = self.rear while start != end and (start - 1) % self.max_size != end: self.queue[start], self.queue[end] = self.queue[end], self.queue[start] start = (start + 1) % self.max_size end = (end - 1) % self.max_size def to_list(self): if self.is_empty(): return [] result = [] i = self.front while True: result.append(self.queue[i]) if i == self.rear: break i = (i + 1) % self.max_size return result"},{"question":"# Scenario You are working on a module for an e-commerce platform to optimize its order processing system. One of the key features is to process a list of orders and determine a shipping schedule based on the weight and priority of items. Each order has a weight and a priority level. Higher priority orders should be processed first, followed by lighter orders when priorities are the same. # Task Implement a function `process_orders` which takes a list of orders, where each order is a dictionary containing two keys: `weight` (an integer representing the weight of the order in grams) and `priority` (an integer representing the priority level of the order, with higher numbers indicating higher priority). The function should return a list of orders sorted first by priority (descending), then by weight (ascending) when priorities are the same. # Input - A list of dictionaries, each containing: - `weight` (an integer): the weight of the order in grams - `priority` (an integer): the priority level of the order # Output - A list of dictionaries, sorted by priority and weight as described. # Constraints - The list may contain up to 100,000 orders. - The weight of each order is between 1 and 10,000 grams. - The priority level is between 1 and 10. # Example ```python orders = [ {\\"weight\\": 2000, \\"priority\\": 3}, {\\"weight\\": 1000, \\"priority\\": 1}, {\\"weight\\": 1500, \\"priority\\": 3}, {\\"weight\\": 700, \\"priority\\": 2}, {\\"weight\\": 3000, \\"priority\\": 3}, {\\"weight\\": 500, \\"priority\\": 1} ] result = process_orders(orders) print(result) ``` Output: ```python [ {\\"weight\\": 1500, \\"priority\\": 3}, {\\"weight\\": 2000, \\"priority\\": 3}, {\\"weight\\": 3000, \\"priority\\": 3}, {\\"weight\\": 700, \\"priority\\": 2}, {\\"weight\\": 500, \\"priority\\": 1}, {\\"weight\\": 1000, \\"priority\\": 1} ] ``` # Note Ensure that the function works efficiently for large lists of orders. ```python def process_orders(orders): Sort a list of orders first by priority (descending) and then by weight (ascending). Args: orders (list of dict): List of dictionaries where each dictionary represents an order with \'weight\' and \'priority\' keys. Returns: list of dict: Sorted list of orders. return sorted(orders, key=lambda x: (-x[\\"priority\\"], x[\\"weight\\"])) ```","solution":"def process_orders(orders): Sort a list of orders first by priority (descending) and then by weight (ascending). Args: orders (list of dict): List of dictionaries where each dictionary represents an order with \'weight\' and \'priority\' keys. Returns: list of dict: Sorted list of orders. return sorted(orders, key=lambda x: (-x[\\"priority\\"], x[\\"weight\\"]))"},{"question":"Fibonacci Sequence Calculation Write a function `fibonacci_sequence(n: int) -> List[int]` that returns the first `n` numbers of the Fibonacci sequence. # Function Signature ```python def fibonacci_sequence(n: int) -> List[int]: pass ``` # Input - `n` (int): An integer representing the number of Fibonacci numbers to be returned. (1 <= n <= 1000) # Output - A list of `n` integers where each integer is a number in the Fibonacci sequence up to the `n`-th term. # Constraints - Ensure that the solution is optimized for execution time and memory usage. # Example ```python print(fibonacci_sequence(10)) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Notes - The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n >= 2 - Consider edge cases such as `n = 1` and `n = 2`. # Hints 1. Using an iterative approach will help avoid the pitfalls of recursion stack overflow for large `n`. 2. Think about how you can store the previous two numbers in the sequence to generate the next one efficiently.","solution":"from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n numbers of the Fibonacci sequence. if n <= 0: raise ValueError(\\"n must be a positive integer\\") fib_seq = [] a, b = 0, 1 for _ in range(n): fib_seq.append(a) a, b = b, a + b return fib_seq"},{"question":"# Maximal Rectangle in Binary Matrix Objective Write a function `maximalRectangle` that takes a matrix of \'0\'s and \'1\'s and returns the area of the largest rectangle containing only \'1\'s. Expected Input and Output Formats * **Input**: * A 2D list called `matrix` representing the binary matrix. * **Output**: * An integer representing the area of the largest rectangle containing only \'1\'s. Constraints and Limitations * The number of rows (m) in the matrix should be in the range [1, 200]. * The number of columns (n) in the matrix should be in the range [1, 200]. * The matrix elements are either \'0\' or \'1\'. Performance Requirements * The function should efficiently handle the maximum input sizes stipulated by the constraints. Scenario You are tasked with designing an algorithm that will help in detecting the largest contiguous area occupied by objects (represented as \'1\'s) in a binary storage layout represented as a matrix. The goal is to find the maximal rectangular area formed by these objects. # Function Requirements The function should be structured as follows: 1. **Function Name:** `maximalRectangle` 2. **Parameters:** `matrix: List[List[str]]` 3. **Returns:** An integer representing the area of the maximal rectangle containing only \'1\'s. Implement the `maximalRectangle` function to solve the problem within the constraints. ```python from typing import List def maximalRectangle(matrix: List[List[str]]) -> int: if not matrix: return 0 m, n = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * (n + 1) for row in matrix: for i in range(n): heights[i] = heights[i] + 1 if row[i] == \'1\' else 0 stack = [-1] for i in range(n + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area # Example Usage if __name__ == \\"__main__\\": matrix = [ [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"1\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\"] ] print(maximalRectangle(matrix)) # Output: 6 ```","solution":"from typing import List def maximalRectangle(matrix: List[List[str]]) -> int: if not matrix: return 0 m, n = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * (n + 1) for row in matrix: for i in range(n): heights[i] = heights[i] + 1 if row[i] == \'1\' else 0 stack = [-1] for i in range(n + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"# Merge Two Sorted Lists Write a function `merge_sorted_lists` that takes two sorted lists of integers and returns a single merged and sorted list containing all the integers from both input lists. Requirements: 1. The input lists will be sorted in non-decreasing order. 2. The output list should also be in non-decreasing order. 3. You must not use built-in sorting methods. 4. Solve the problem with an efficient approach using the principles of the two-pointer technique. Input: * Two sorted input lists, `list1` and `list2`. Output: * A single sorted list containing all elements from `list1` and `list2`. Example: Input: ```python list1 = [1, 3, 5, 7] list2 = [2, 4, 6, 8] ``` Output: ```python [1, 2, 3, 4, 5, 6, 7, 8] ``` Implementation Implement the following function: ```python def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merge two sorted lists into one sorted list. Parameters: list1 (list[int]): The first sorted list. list2 (list[int]): The second sorted list. Returns: list[int]: The merged sorted list containing all elements of list1 and list2. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list # Example of usage: # merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) ``` **Explanation:** This additional question focuses on merging two sorted lists, a fundamental exercise in understanding list manipulation and the two-pointer technique, which aligns with the complexity and skill level of the given question set. The problem ensures the implementation of an efficient approach through careful iteration and conditional checks, maintaining consistency in difficulty, length, and topic alignment.","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merge two sorted lists into one sorted list. Parameters: list1 (list[int]): The first sorted list. list2 (list[int]): The second sorted list. Returns: list[int]: The merged sorted list containing all elements of list1 and list2. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list # Example of usage: # merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8])"},{"question":"# Ransom Note Creation You are given a ransom note string and a magazine string. Your task is to write a function to determine if the ransom note can be constructed from the magazine. Each character in the magazine string can only be used once in your ransom note. The function should be defined as: ```python def can_construct(ransom_note: str, magazine: str) -> bool: pass ``` # Input - `ransom_note`: A string representing the ransom note you need to create. - `magazine`: A string representing the letters available in the magazine. # Output - Return a boolean value (`True` or `False`) indicating whether the ransom note can be constructed from the magazine. # Constraints - 1 ≤ len(ransom_note) ≤ 10000 - 1 ≤ len(magazine) ≤ 10000 - Both strings consist only of lowercase English letters. # Example Input ```python ransom_note = \\"aab\\" magazine = \\"baa\\" ``` # Example Output ```python True ``` # Example Input ```python ransom_note = \\"abc\\" magazine = \\"ab\\" ``` # Example Output ```python False ``` # Instructions 1. Implement your function inside the provided template. 2. Optimize your solution for efficiency considering the given constraints. 3. Consider various edge cases including cases with insufficient characters or all characters being just about enough.","solution":"def can_construct(ransom_note: str, magazine: str) -> bool: from collections import Counter ransom_note_count = Counter(ransom_note) magazine_count = Counter(magazine) # Check if magazine has all characters required by ransom note in the necessary quantities for char, count in ransom_note_count.items(): if magazine_count[char] < count: return False return True"},{"question":"# Coding Assessment Question Problem Description Write a function `merge_sorted_arrays` that takes two sorted lists and returns a single sorted list by merging the two input lists. The function should use the concept of the merge step from the merge sort algorithm to efficiently combine both lists. Function Signature ```python def merge_sorted_arrays(list1: list[int], list2: list[int]) -> list[int]: pass ``` Input - `list1 (list[int])`: A list of integers sorted in non-decreasing order. - `list2 (list[int])`: A list of integers sorted in non-decreasing order. Output - Returns a single list of integers that contains all elements from `list1` and `list2` in non-decreasing order. Constraints 1. The function should perform the merge efficiently with respect to time and space. 2. Assume that both lists are already sorted in non-decreasing order. Example ```python >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], [4, 5, 6]) [4, 5, 6] >>> merge_sorted_arrays([1, 2, 2], [2, 2, 3]) [1, 2, 2, 2, 2, 3] ``` Performance Requirements - The solution should handle edge cases such as one or both empty input lists efficiently. - The function should run in O(n + m) time complexity, where n is the length of `list1` and m is the length of `list2`. - The function should maintain O(n + m) space complexity, where the space is utilized to create the resulting merged list. Edge Cases to Consider 1. Both input lists are empty: `[], []` 2. One input list is empty: `[1, 3, 5], []` or `[], [2, 4, 6]` 3. Lists with duplicate elements: `[2, 2, 3], [2, 2, 4]` 4. Lists with no overlapping elements: `[1, 2, 3], [4, 5, 6]` 5. Lists with overlapping elements: `[1, 3, 5], [2, 4, 5]` Good luck!","solution":"def merge_sorted_arrays(list1: list[int], list2: list[int]) -> list[int]: merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are any remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are any remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Question: Optimizing Character Replacement to Form Palindromes Context In string manipulation tasks, ensuring a string is a palindrome can be computationally intensive if not handled with efficient algorithms. A palindrome is a string that reads the same backward as forward. Your task is to implement an optimized algorithm to determine the minimum number of character replacements needed to convert a given string into a palindrome. Task Write a Python function `min_replacements_to_palindrome(s: str) -> int` that efficiently calculates the minimum number of character replacements required to make the given string a palindrome. Implementation Details - **Input**: - `s` (str): A non-empty string of lowercase English letters. - **Output**: - Return the minimum number of character replacements required to convert the string into a palindrome. Constraints - You must use an optimized solution that minimizes the number of comparisons and replacements. - The length of the string `s` can be up to ( 10^5 ), requiring performance considerations for large inputs. Example ```python assert min_replacements_to_palindrome(\\"abca\\") == 1 assert min_replacements_to_palindrome(\\"racecar\\") == 0 assert min_replacements_to_palindrome(\\"abcdef\\") == 3 ``` Hints - Utilize two-pointers or greedy algorithms to minimize the number of comparisons and replacements needed to achieve the palindrome state. - Analyze the string symmetrically from both ends towards the center. **Note**: Aim for an efficient approach that reduces the time complexity compared to checking and replacing each character individually.","solution":"def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of character replacements required to make the given string a palindrome. left = 0 right = len(s) - 1 replacements = 0 while left < right: if s[left] != s[right]: replacements += 1 left += 1 right -= 1 return replacements"},{"question":"# Question: Subset Sum Problem You are asked to implement a function to solve the Subset Sum Problem. Given a list of non-negative integers, determine if there is a subset of the given list with a sum equal to a given target value. Requirements: - Implement a function `is_subset_sum(nums: list[int], target: int) -> bool` that performs the task. - Use a dynamic programming approach to solve the problem. Constraints: - The input list `nums` will have non-negative integers. - The length of `nums` will not exceed 20. - The `target` value will be a non-negative integer and will not exceed 1000. # Input Example: ```python nums = [3, 34, 4, 12, 5, 2] target = 9 ``` # Output Example: ```python True ``` # Implementation Challenge: - Consider all edge cases, including an empty input list or a target of zero. # Performance Considerations: - Ensure that your solution efficiently handles the dynamic programming table within the given constraints.","solution":"def is_subset_sum(nums, target): Determines if there is a subset of the given list with a sum equal to the target value. Uses a dynamic programming approach. Args: nums : list[int] - A list of non-negative integers. target : int - The target sum we are trying to achieve with a subset of nums. Returns: bool - True if there is a subset with sum equals to target, False otherwise. n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"# Graph Implementation and Shortest Path Calculation Objective Implement a Graph and provide a function to calculate the shortest path between two nodes using Dijkstra\'s algorithm. The Graph should support the addition of nodes, edges, and retrieving the shortest path between any two nodes. Problem Statement You are required to enhance the given Graph structure to support the following additional operations: 1. **Shortest Path Calculation**: Given a source node and a destination node, return the shortest path and its length. Function Specifications 1. **shortest_path(source: str, destination: str) -> Tuple[List[str], int]**: This function will take a string `source` and a string `destination` and return a tuple containing a list of nodes representing the shortest path from source to destination and the total length of the path. Input and Output - **Input**: - String `source` and string `destination` for the `shortest_path` function. - **Output**: - A tuple where the first element is a list of strings representing the shortest path and the second element is an integer indicating the total path length. Example ```python # Create a new Graph instance graph = Graph() # Add nodes and edges to the Graph graph.add_edge(\\"A\\", \\"B\\", 1) graph.add_edge(\\"A\\", \\"C\\", 4) graph.add_edge(\\"B\\", \\"C\\", 2) graph.add_edge(\\"B\\", \\"D\\", 5) graph.add_edge(\\"C\\", \\"D\\", 1) # Shortest path example print(graph.shortest_path(\\"A\\", \\"D\\")) # Output: ([\'A\', \'B\', \'C\', \'D\'], 4) print(graph.shortest_path(\\"A\\", \\"C\\")) # Output: ([\'A\', \'C\'], 4) ``` Constraints - All input node names are strings and are case-sensitive. - Edge weights are positive integers. - Implement efficient solutions with respect to time and space complexity, targeting an implementation of Dijkstra\'s algorithm. Graph Class Specification Implement the Graph class with the following methods: - `add_node(node: str) -> None`: Add a node to the graph. - `add_edge(node1: str, node2: str, weight: int) -> None`: Add a directed edge with a weight from `node1` to `node2`. - `shortest_path(source: str, destination: str) -> Tuple[List[str], int]`: Find the shortest path from `source` to `destination`. You can utilize an appropriate data structure to maintain adjacency lists for efficient edge and node management.","solution":"import heapq from typing import List, Tuple, Dict class Graph: def __init__(self): self.adjacency_list = {} def add_node(self, node: str) -> None: if node not in self.adjacency_list: self.adjacency_list[node] = [] def add_edge(self, node1: str, node2: str, weight: int) -> None: self.add_node(node1) self.add_node(node2) self.adjacency_list[node1].append((node2, weight)) def shortest_path(self, source: str, destination: str) -> Tuple[List[str], int]: if source not in self.adjacency_list or destination not in self.adjacency_list: return ([], float(\'inf\')) # Priority queue for Dijkstra\'s algorithm heap = [(0, source, [])] visited = set() while heap: (cost, node, path) = heapq.heappop(heap) if node in visited: continue visited.add(node) path = path + [node] if node == destination: return (path, cost) for neighbor, weight in self.adjacency_list[node]: if neighbor not in visited: heapq.heappush(heap, (cost + weight, neighbor, path)) return ([], float(\'inf\'))"},{"question":"# Coding Assessment Question E-commerce platforms constantly strive to optimize their pricing algorithms for better competitive edge and customer satisfaction. Imagine an algorithm developer working on a feature to dynamically adjust product pricing based on real-time inventory data and sales goals. # Problem Context: You are tasked with designing a function that can generate the optimal price for a list of products such that the total revenue meets a specific sales goal while maximizing the utilization of the available inventory. # Task: 1. **Function Definition**: Create a function `calculate_optimal_price` that takes in two lists of integers representing the inventory and base prices of products, along with an integer representing the sales goal in terms of total revenue. The function should return a list of optimal prices for the products. 2. **Input**: - `inventory (List[int])`: A list of integers where each integer represents the available stock of a product. - `base_prices (List[int])`: A list of integers where each integer denotes the base price of the corresponding product. - `sales_goal (int)`: A positive integer representing the desired sales revenue. 3. **Output**: - `List[int]`: A list of optimal prices, where each price is an integer, such that the total revenue approximates the sales goal as closely as possible, without exceeding the limitation of the available inventory. 4. **Constraints**: - Constraints on the length of `inventory` and `base_prices` should be (1 leq len(inventory) = len(base_prices) leq 10^3). - Values within `inventory` and `base_prices` are positive integers. - The `sales_goal` is a positive integer. # Example Scenarios: Example 1: ```python calculate_optimal_price([10, 5], [15, 30], 300) -> [15, 30] ``` Explanation: The total inventory can sufficiently meet the sales goal when each product is sold at its base price. Example 2: ```python calculate_optimal_price([3, 7], [10, 20], 200) -> [15, 20] ``` Explanation: Adjusted prices given the inventory constraints will help meet the sales goal. # Performance Considerations: - Ensure the function performs efficiently within the given constraints. - Handle edge cases, such as when the sales goal is significantly higher than feasible with the given inventory and base prices. # Implementation Guide: 1. Iterate over the inventory and base prices to find the combination that closely matches the target sales goal. 2. Consider possible price adjustments within reasonable boundaries (e.g., small increments) to fine-tune revenue calculation. 3. Ensure the solution approach does not exceed a time complexity of O(n²) given the constraints. # Constraints Simulation: Design the function to systematically and efficiently explore all potential pricing strategies to near-perfectly conform to the given sales target. Validate the function with various test cases to ensure accuracy and optimal performance. Implement and test the `calculate_optimal_price` function under different inventory, base prices, and sales goal values to ensure robustness and precision.","solution":"from typing import List def calculate_optimal_price(inventory: List[int], base_prices: List[int], sales_goal: int) -> List[int]: This function calculates the optimal prices for products to meet a specific sales revenue goal. Parameters: inventory (List[int]): A list of integers representing available stock of products. base_prices (List[int]): A list of integers representing base prices of products. sales_goal (int): The desired sales revenue. Returns: List[int]: A list of optimal prices for the products. n = len(inventory) total_base_revenue = sum(inventory[i] * base_prices[i] for i in range(n)) if total_base_revenue >= sales_goal: return base_prices price_increase = [(sales_goal - total_base_revenue) // sum(inventory) + 1] * n optimal_prices = [base_prices[i] + price_increase[i] for i in range(n)] return optimal_prices"},{"question":"# Radix Sort Algorithm Assessment Context You have been provided with a list of non-negative integers, and you need to sort the list in ascending order efficiently. Your task is to implement the radix sort algorithm to achieve this. Task Write a function `radix_sort` that takes in one parameter: 1. `unsorted_collection`: A list of non-negative integers that need to be sorted. The function should return the sorted list in ascending order. Function Signature: ```python def radix_sort(unsorted_collection: list[int]) -> list[int]: pass ``` Constraints * The input list contains non-negative integers only. * The maximum length of the list is 10^6. * The values in the list are within the range of 0 to 10^9. Input * `unsorted_collection`: A list of non-negative integers. (e.g., [170, 45, 75, 90, 802, 24, 2, 66]) Output * A sorted list of integers in ascending order. (e.g., [2, 24, 45, 66, 75, 90, 170, 802]) Example ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([1, 4, 1, 2, 7, 5, 2]) == [1, 1, 2, 2, 4, 5, 7] assert radix_sort([12, 11, 13, 5, 6, 7]) == [5, 6, 7, 11, 12, 13] assert radix_sort([4]) == [4] assert radix_sort([987654321, 123456789, 1234567890, 987654320]) == [123456789, 987654320, 987654321, 1234567890] assert radix_sort([]) == [] ``` Edges Cases to Consider * Very large numbers. * Duplicate numbers. * Single element list. * Empty list. Performance Requirements Ensure that the solution takes into account the constraints and is optimized for performance, particularly when dealing with very large lists and very large numbers.","solution":"def radix_sort(unsorted_collection: list[int]) -> list[int]: if len(unsorted_collection) == 0: return unsorted_collection # Find the maximum number to determine the maximum number of digits max_number = max(unsorted_collection) # Initialize the exponent to 1 (10^0) exp = 1 while max_number // exp > 0: unsorted_collection = counting_sort(unsorted_collection, exp) exp *= 10 return unsorted_collection def counting_sort(collection, exp): n = len(collection) # Output array to store the sorted numbers output = [0] * n # Initialize count array count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = collection[i] // exp count[index % 10] += 1 # Update count[i] so it now contains the actual position of this digit in the output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = collection[i] // exp output[count[index % 10] - 1] = collection[i] count[index % 10] -= 1 i -= 1 # Copy the output array to collection[], so that collection now # contains sorted numbers according to the current digit for i in range(n): collection[i] = output[i] return collection"},{"question":"You need to implement a method that determines whether a given Binary Search Tree (BST) is a valid BST or not. The method should return a boolean value indicating the validity of the tree. # Task Implement a method `is_valid_BST(self) -> bool` in the `BinarySearchTree` class which checks the validity of the tree. # Input This implementation does not take any explicit input other than the binary search tree instance. The tree is assumed to have nodes inserted using the `put` method. # Output The method returns a boolean value: - `True` if the tree is a valid BST. - `False` otherwise. # Constraints * The BST should satisfy the standard properties: * The left subtree of a node contains only nodes with keys less than the node\'s key. * The right subtree of a node contains only nodes with keys greater than the node\'s key. * Both left and right subtrees must also be binary search trees. # Example Consider the following sequence of events: ```python t = BinarySearchTree() t.put(5) t.put(2) t.put(8) t.put(1) t.put(3) print(t.is_valid_BST()) # Output: True # The BST looks like: # 5 # / # 2 8 # / # 1 3 # Example of an invalid BST: t_invalid = BinarySearchTree() t_invalid.put(5) t_invalid.root.left = TreeNode(8) print(t_invalid.is_valid_BST()) # Output: False # The tree looks like: # 5 # / # 8 # This is not a valid BST because 8 is not less than 5. ``` # Tips 1. Utilize a helper function to recursively verify the validity of the left and right subtrees while maintaining valid key limits. 2. Ensure you pass the correct minimum and maximum values down the recursive calls. Implement your solution inside the `BinarySearchTree` class below.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def put(self, key): if self.root is None: self.root = TreeNode(key) else: self._put(self.root, key) def _put(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._put(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._put(node.right, key) def is_valid_BST(self): def is_valid_node(node, left_limit, right_limit): if not node: return True if not (left_limit < node.val < right_limit): return False return (is_valid_node(node.left, left_limit, node.val) and is_valid_node(node.right, node.val, right_limit)) return is_valid_node(self.root, float(\'-inf\'), float(\'inf\'))"},{"question":"# Coding Assessment Question **Context**: Sorting algorithms are fundamental in computer science and are widely used in various applications. One efficient comparison-based sorting algorithm is QuickSort, which sorts items by partitioning an array and recursively sorting the sub-arrays. **Problem Statement**: You are given an array of integers. Your task is to write an in-place QuickSort function to sort the array in ascending order. Implement the QuickSort algorithm using the Lomuto partition scheme. **Function Signature**: ```python def quicksort(arr: list[int], low: int, high: int) -> None: Sorts the array using the QuickSort algorithm with Lomuto partition scheme. Parameters: arr (list[int]): A list of integers to be sorted. low (int): The starting index of the list to sort. high (int): The ending index of the list to sort. Returns: None: The function sorts the input list in-place. ``` **Input**: 1. **arr**: A list of integers (e.g., [3, 6, 8, 10, 1, 2, 1]) 2. **low**: An integer representing the starting index (e.g., 0) 3. **high**: An integer representing the ending index (e.g., len(arr) - 1) **Output**: - No return value. The input list `arr` should be sorted in-place. **Constraints**: - The length of the array can be between 1 and (10^5). - Elements of the array can be any integers within the range of -(10^9) to (10^9). **Performance Requirements**: - The solution should efficiently handle larger arrays. **Examples**: ```python >>> arr = [3, 6, 8, 10, 1, 2, 1] >>> quicksort(arr, 0, len(arr) - 1) >>> arr [1, 1, 2, 3, 6, 8, 10] >>> arr = [1] >>> quicksort(arr, 0, len(arr) - 1) >>> arr [1] >>> arr = [10, 7, 8, 9, 1, 5] >>> quicksort(arr, 0, len(arr) - 1) >>> arr [1, 5, 7, 8, 9, 10] ``` Ensure your implementation correctly performs partitioning using the Lomuto partition scheme, handles edge cases, and leverages in-place sorting effectively.","solution":"def quicksort(arr, low, high): Sorts the array using the QuickSort algorithm with Lomuto partition scheme. Parameters: arr (list[int]): A list of integers to be sorted. low (int): The starting index of the list to sort. high (int): The ending index of the list to sort. Returns: None: The function sorts the input list in-place. def lomuto_partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 if low < high: p = lomuto_partition(arr, low, high) quicksort(arr, low, p - 1) quicksort(arr, p + 1, high)"},{"question":"# Question: Implement a Function to Find the Longest Unique Substring Write a function that takes a string as input and returns the longest substring that contains unique characters. Requirements: 1. **Input**: * A single string `s` consisting of ASCII characters. 2. **Output**: * A string representing the longest substring without repeating characters. 3. **Constraints**: * The input string length will be between 1 and 10^5. * The input string will only contain printable ASCII characters. Example: ```python s = \\"abcabcbb\\" assert find_longest_unique_substring(s) == \\"abc\\" s = \\"bbbbb\\" assert find_longest_unique_substring(s) == \\"b\\" s = \\"pwwkew\\" assert find_longest_unique_substring(s) == \\"wke\\" ``` Steps to Implement: 1. **Initialize Pointers and Data Structures**: Use two pointers to represent the current window of unique characters. 2. **Expand and Contract Window**: Move the right pointer to expand the window until a duplicate character is found. Then move the left pointer to contract the window until all characters are unique again. 3. **Track the Maximum Length**: Keep track of the longest length and the corresponding substring. 4. **Edge Cases**: Handle edge cases where the string is empty or contains all unique characters. Tips: * Utilize a set or dictionary to efficiently check and keep track of existing characters in the current window. * Ensure your implementation handles large strings efficiently within the given constraints.","solution":"def find_longest_unique_substring(s): Finds and returns the longest substring with all unique characters. Args: s (str): The input string. Returns: str: The longest substring with unique characters. n = len(s) if n == 0: return \\"\\" left = 0 right = 0 max_length = 0 max_substring = \\"\\" char_set = set() while right < n: if s[right] not in char_set: char_set.add(s[right]) right += 1 if right - left > max_length: max_length = right - left max_substring = s[left:right] else: char_set.remove(s[left]) left += 1 return max_substring"},{"question":"# Objective Write a function `flatten_list` to flatten a given nested list of integers, i.e., convert a nested list into a one-dimensional list by extracting elements from any level of nesting. # Input & Output * **Input**: A single nested list of integers. * **Output**: A one-dimensional list with all the integers from the input list. # Constraints 1. The nested list can have any level of nesting. 2. Assume the input is always a valid nested list of integers and not empty. 3. Optimize the function for readability and maintainability. # Example ```python # Example 1 # Input: [1, [2, 3], [4, [5, 6]]] # Output: [1, 2, 3, 4, 5, 6] # Example 2 # Input: [1, [2, [3, [4, [5]]]]] # Output: [1, 2, 3, 4, 5] # Example 3 # Input: [[1, 2], 3, [[4, 5], 6]] # Output: [1, 2, 3, 4, 5, 6] ``` # Scenario Imagine you are working on a data processing pipeline where the input data is received in a deeply nested list format. To perform further operations and analyses, you need to convert this nested structure into a simple, one-dimensional list. Implementing the `flatten_list` function will facilitate easy manipulation and processing of the data. # Function Signature ```python def flatten_list(nested_list: list) -> list: pass ```","solution":"def flatten_list(nested_list): Flattens a nested list of integers. def _flatten(sub_list): for item in sub_list: if isinstance(item, list): yield from _flatten(item) else: yield item return list(_flatten(nested_list))"},{"question":"# String Permutation Check You are given two strings and need to determine if one string is a permutation of the other. Implement a function `are_permutations()` that receives two strings as inputs and returns a boolean value indicating whether one string is a permutation of the other. Function Signature ```python def are_permutations(str1: str, str2: str) -> bool: ``` Input * `str1` (str): A string consisting of lowercase English letters. * `str2` (str): A string consisting of lowercase English letters. Output * `bool`: `True` if `str1` is a permutation of `str2`, otherwise `False`. Constraints * The length of each string will be between 1 and 1000, inclusive. * Both strings will only contain lowercase English letters. Example ```python str1 = \\"listen\\" str2 = \\"silent\\" # Expected Output: True print(are_permutations(str1, str2)) # True ``` ```python str1 = \\"hello\\" str2 = \\"billion\\" # Expected Output: False print(are_permutations(str1, str2)) # False ``` Scenario In many real-world applications, such as cryptography or data analysis, we often need to verify whether two datasets (in this case, strings) are rearrangements of each other. Implementing an efficient permutation check can be essential in situations where the order does not matter, but the presence of the same elements does. For instance, handling anagrams in natural language processing tasks. **Hint**: Sorting both strings and comparing them is one approach to solve this problem. Alternatively, you can use a frequency count of characters to determine the solution.","solution":"def are_permutations(str1: str, str2: str) -> bool: Returns True if str1 is a permutation of str2, otherwise False. if len(str1) != len(str2): return False # Create frequency counters for characters in both strings counter1 = {} counter2 = {} for char in str1: counter1[char] = counter1.get(char, 0) + 1 for char in str2: counter2[char] = counter2.get(char, 0) + 1 return counter1 == counter2"},{"question":"# Problem Statement You are provided with an implementation of a `BinarySearchTree` class with basic insert and search functionalities. Enhance the class to include additional methods to efficiently perform the following tasks: # Requirements: 1. `find_min(self) -> int`: Find and return the minimum element in the tree. 2. `find_max(self) -> int`: Find and return the maximum element in the tree. 3. `delete(self, key: int) -> None`: Delete an element from the tree. 4. `in_order_traversal(self) -> List[int]`: Return a list of all elements in the tree sorted in ascending order. # Constraints: - The tree can contain up to 10,000 elements. - Element values are unique and non-negative integers. - Handle cases where operations are attempted on an empty tree appropriately. # Input: - No direct input. Use the instance methods to manipulate and access data. # Output: - The `find_min`, `find_max` methods return integers as specified. - The `delete` method does not return any value. - The `in_order_traversal` method returns a list of integers. # Example: ```python bst = BinarySearchTree() bst.insert(10) bst.insert(20) bst.insert(5) bst.insert(3) bst.insert(7) print(bst.find_min()) # Should output 3 print(bst.find_max()) # Should output 20 bst.delete(10) print(bst.in_order_traversal()) # Should output [3, 5, 7, 20] ``` Implement the `BinarySearchTree` class with the specified methods, ensuring correctness and efficiency for all edge cases.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def find_min(self) -> int: if not self.root: raise ValueError(\\"The tree is empty\\") return self._find_min(self.root) def _find_min(self, root) -> int: current = root while current.left is not None: current = current.left return current.val def find_max(self) -> int: if not self.root: raise ValueError(\\"The tree is empty\\") return self._find_max(self.root) def _find_max(self, root) -> int: current = root while current.right is not None: current = current.right return current.val def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, root, key): if not root: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left min_larger_node = self._find_min(root.right) root.val = min_larger_node root.right = self._delete(root.right, root.val) return root def in_order_traversal(self) -> list: result = [] self._in_order_helper(self.root, result) return result def _in_order_helper(self, root, result): if root: self._in_order_helper(root.left, result) result.append(root.val) self._in_order_helper(root.right, result)"},{"question":"# Scenario You are implementing a social media analytics tool that needs to monitor the usage of hashtags in user posts. One of the requirements is to count the frequency of each unique hashtag within a post. The hashtags can consist of alphanumeric characters and underscores, and they are case-insensitive. # Objective Implement a function that counts the occurrences of each unique hashtag in a given post and returns a dictionary with hashtags as keys and their counts as values. # Function Signature ```python def hashtag_occurrence(post: str) -> dict: pass ``` # Input * `post`: A string representing the input post. # Output * A dictionary where each key is a unique hashtag from the post and the value is the number of times that hashtag appears. # Constraints * The post will not contain more than 5,000 characters. * Hashtags are case-insensitive and should be treated as such. # Requirements * Normalize the post to make hashtags case-insensitive. * Only count valid hashtags which start with a `#` followed by alphanumeric characters or underscores. # Example ```python assert hashtag_occurrence(\\"#Hello #hello #World! How #are #you? #world\\") == { \'#hello\': 2, \'#world\': 2, \'#are\': 1, \'#you\': 1 } assert hashtag_occurrence(\\"Check out #Python and #python3. Also, use #PYTHON and #PyThOn!\\") == { \'#python\': 3, \'#python3\': 1 } assert hashtag_occurrence(\\"Today is a #GreatDay for #coding. #Great_Day indeed!\\") == { \'#greatday\': 1, \'#coding\': 1, \'#great_day\': 1 } ```","solution":"import re def hashtag_occurrence(post: str) -> dict: Counts the occurrences of each unique hashtag in the given post. Hashtags are case-insensitive and consist of alphanumeric characters and underscores. Parameters: post (str): The input post containing hashtags. Returns: dict: A dictionary with hashtags as keys and their counts as values. # Normalize the post to lowercase post = post.lower() # Find all valid hashtags using regular expression hashtags = re.findall(r\'#w+\', post) # Count occurrences of each hashtag hashtag_counts = {} for hashtag in hashtags: if hashtag in hashtag_counts: hashtag_counts[hashtag] += 1 else: hashtag_counts[hashtag] = 1 return hashtag_counts"},{"question":"# Multi-threaded Matrix Multiplication Given two matrices, you are required to implement multi-threaded matrix multiplication to enhance performance. Each thread should compute a portion of the resulting matrix. **Task**: 1. Write a class `ThreadedMatrixMultiplication` that performs matrix multiplication using multiple threads. 2. Implement a method to divide the multiplication task among the given number of threads. 3. Implement a method to recombine the results from the threads to get the final matrix result. **Function Signatures**: 1. `class ThreadedMatrixMultiplication:` 2. `def __init__(self, matrix_a: np.ndarray, matrix_b: np.ndarray, num_threads: int) -> None:` 3. `def multiply(self) -> np.ndarray:` **Input Format**: - `matrix_a`: A 2D numpy array (dtype: `np.float32`). - `matrix_b`: A 2D numpy array (dtype: `np.float32`). - `num_threads`: An integer specifying the number of threads to use for multiplication. **Output Format**: - A 2D numpy array representing the result of the matrix multiplication. **Constraints**: - The number of columns in `matrix_a` must equal the number of rows in `matrix_b`. - Both `matrix_a` and `matrix_b` should have the same datatype (`np.float32`). - You should use standard Python threading libraries for multi-threading. **Performance Requirement**: - The multiplication should make effective use of the specified number of threads to improve performance over single-threaded multiplication for large matrices. **Example**: ```python # Example Matrices matrix_a = np.array([ [1.0, 2.0], [3.0, 4.0] ], dtype=np.float32) matrix_b = np.array([ [2.0, 0.0], [1.0, 3.0] ], dtype=np.float32) # Number of Threads num_threads = 2 # Expected Output result_matrix = ThreadedMatrixMultiplication(matrix_a, matrix_b, num_threads).multiply() # Output: np.array([ # [4.0, 6.0], # [10.0, 12.0] #], dtype=np.float32) ```","solution":"import numpy as np from threading import Thread class ThreadedMatrixMultiplication: def __init__(self, matrix_a: np.ndarray, matrix_b: np.ndarray, num_threads: int) -> None: self.matrix_a = matrix_a self.matrix_b = matrix_b self.num_threads = num_threads self.result = np.zeros((matrix_a.shape[0], matrix_b.shape[1]), dtype=np.float32) self.threads = [] self._divide_and_conquer() def _divide_and_conquer(self): rows_per_thread = self.matrix_a.shape[0] // self.num_threads extra_rows = self.matrix_a.shape[0] % self.num_threads start_row = 0 for i in range(self.num_threads): end_row = start_row + rows_per_thread + (1 if i < extra_rows else 0) thread = Thread(target=self._multiply_partial, args=(start_row, end_row)) self.threads.append(thread) start_row = end_row def _multiply_partial(self, start_row, end_row): for i in range(start_row, end_row): for j in range(self.matrix_b.shape[1]): self.result[i, j] = np.dot(self.matrix_a[i, :], self.matrix_b[:, j]) def multiply(self) -> np.ndarray: for thread in self.threads: thread.start() for thread in self.threads: thread.join() return self.result"},{"question":"**Problem Statement**: You are required to implement a function that finds the `n`-th Fibonacci number, where `f(n)` is defined as follows: - `f(0) = 0` - `f(1) = 1` - `f(n) = f(n-1) + f(n-2)` for `n > 1` The signature of the function is as follows: ```python def nth_fibonacci(n: int) -> int: pass ``` # Input: * An integer `n`, 0 <= n <= 10^4, representing the position in the Fibonacci sequence to retrieve. # Output: * An integer representing the `n`-th Fibonacci number. # Constraints: * The input integer `n` will always be a non-negative integer. # Example: ```python >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(10) 55 >>> nth_fibonacci(20) 6765 ``` **Your task is to implement the function `nth_fibonacci` that adheres to the above specifications.** # Performance Requirements: Your implementation should be efficient enough to handle inputs up to `n = 10^4` within reasonable time and space constraints. Consider using an iterative approach or matrix exponentiation to avoid the inefficiencies of a naive recursive solution.","solution":"def nth_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Subsequence Commonality Checker You are provided with two lists of strings. Your task is to implement a function that checks whether there exists a non-empty common subsequence between any pair of strings across the two lists. A subsequence is a series of characters that appear in the same order within a string, but not necessarily consecutively. The function should return True if such a subsequence exists, otherwise, it should return False. Function Signature: ```python def has_common_subsequence(list1: List[str], list2: List[str]) -> bool: ``` Input: - **list1**: A list of strings. - **list2**: A list of strings. Output: - **Result**: A boolean value indicating whether there exists a non-empty common subsequence between any pair of strings from list1 and list2. Constraints & Notes: - The lengths of the strings in the lists will vary, but will not exceed 1000 characters. - The length of list1 and list2 will not exceed 1000. - The strings will contain only lowercase English letters. Example: **Input**: ```python list1 = [\\"abc\\", \\"def\\", \\"ghij\\"] list2 = [\\"klm\\", \\"nop\\", \\"abcd\\", \\"hijg\\"] ``` **Output**: ```python True ``` **Explanation**: - There is a common subsequence `\\"abc\\"` between `\\"abc\\"` (from `list1`) and `\\"abcd\\"` (from `list2`). - Additionally, there is a common subsequence `\\"hij\\"` between `\\"ghij\\"` (from `list1`) and `\\"hijg\\"` (from `list2`). Implementation Details: - You should efficiently check for the presence of common subsequences, accounting for potential performance issues due to the size of the input. - Ensure that edge cases, such as one or both lists being empty, are handled appropriately. - You may use dynamic programming or any appropriate algorithm to identify common subsequences efficiently.","solution":"def has_common_subsequence(list1, list2): Checks if there exists a non-empty common subsequence between any pair of strings from list1 and list2. def is_subsequence(avail_chars, s): Checks if any character from s is in avail_chars. for char in s: if char in avail_chars: return True return False # Create a set of all characters present in list1 chars_in_list1 = set() for s in list1: chars_in_list1.update(s) # Check if any string in list2 shares at least one character with chars_in_list1 for s in list2: if is_subsequence(chars_in_list1, s): return True return False"},{"question":"# Array Permutation Analyzer In this challenge, you will create a function that determines if two lists are permutations of each other. A permutation is a rearrangement of elements in a list, meaning both lists must contain the same elements with the same frequency, though possibly in different orders. Scenario You are building a software system to validate data integrity. Part of this system requires confirming that two datasets are essentially the same, allowing for different orderings of the elements. Implement a function to perform this check efficiently. Function Signature ```python def are_permutations(list1: list, list2: list) -> bool: This function receives two lists of integers and checks whether they are permutations of each other. Args: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: bool: True if the lists are permutations of each other, False otherwise. ``` Input - Two lists, `list1` and `list2`, each containing integers. Output - A boolean value `True` if the lists are permutations of each other, otherwise `False`. Constraints - Both lists may contain positive, zero, or negative integers. - The lengths of the lists can range from 0 to 100,000 elements. - Aim for a solution that runs in linear time O(n). Examples ```python >>> are_permutations([1, 2, 3], [3, 2, 1]) True >>> are_permutations([1, 2, 3], [4, 5, 6]) False >>> are_permutations([1, 1, 2], [2, 1, 1]) True >>> are_permutations([1, 2, 2, 3], [3, 2, 1]) False >>> are_permutations([], []) True ``` Requirements - Utilize appropriate data structures to achieve an efficient comparison. - Handle edge cases, especially considering empty lists and negative integers. Tips - Consider using a hash map or dictionary to track the frequency of elements in each list. - Ensure to check the lengths of the lists early to quickly rule out non-permutations. Implement the function `are_permutations` and test it with various inputs to ensure correctness and efficiency.","solution":"def are_permutations(list1, list2): This function receives two lists and checks whether they are permutations of each other. Args: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: bool: True if the lists are permutations of each other, False otherwise. if len(list1) != len(list2): return False from collections import Counter counter1 = Counter(list1) counter2 = Counter(list2) return counter1 == counter2"},{"question":"# Question Given an array of integers, implement a Python function `longest_peak(arr)` to find the length of the longest peak. An element in the array is considered a peak if: 1. It is greater than its (optional) left neighbor. 2. It is greater than its (optional) right neighbor. 3. A peak is a part of a \\"peak sequence\\" which is a contiguous subsequence where the elements strictly increase to the peak and then strictly decrease. The function should have the following signature: ```python def longest_peak(arr): pass ``` * **Input**: - `arr`: a list of integers representing the array. * **Output**: - Returns an integer representing the length of the longest peak in the array. If no peak is found, return 0. * **Constraints**: - The length of `arr` will be in the range `1` to `10^5`. - The values in `arr` will be in the range `-10^6` to `10^6`. * **Example**: ```python arr = [1, 2, 3, 4, 3, 2, 1] result = longest_peak(arr) # Example output: 7 arr2 = [1, 2, 2, 2, 2, 1] result2 = longest_peak(arr2) # Example output: 0 ``` * **Explanation**: - In the first example, the longest peak sequence is `[1, 2, 3, 4, 3, 2, 1]` which has a length of 7. - In the second example, there is no peak because the array has equal adjacent elements in the increasing part.","solution":"def longest_peak(arr): if len(arr) < 3: return 0 longest_peak_length = 0 i = 1 while i < len(arr) - 1: # Check if the current element is a peak is_peak = arr[i - 1] < arr[i] > arr[i + 1] if not is_peak: i += 1 continue # Find the left boundary of this peak left_idx = i - 2 while left_idx >= 0 and arr[left_idx] < arr[left_idx + 1]: left_idx -= 1 # Find the right boundary of this peak right_idx = i + 2 while right_idx < len(arr) and arr[right_idx] < arr[right_idx - 1]: right_idx += 1 current_peak_length = right_idx - left_idx - 1 longest_peak_length = max(longest_peak_length, current_peak_length) # Move the pointer to the end of this peak i = right_idx return longest_peak_length"},{"question":"# Scenario: You have been tasked with developing a system to dynamically adjust the prices of products in an e-commerce platform based on the average demand over the past week. The price adjustment is based on a custom algorithm that takes into account the current price, the average daily demand, and a scaling factor to determine the new price. # Task: Write a function that calculates the new price for each product given the current price, the average daily demand for the past week, and a scaling factor that influences the price adjustment. # Function Signature: ```python def adjust_prices( current_prices: List[float], average_daily_demands: List[float], scaling_factor: float ) -> List[float]: pass ``` # Input: - `current_prices`: A list of floating-point numbers representing the current prices of the products. - `average_daily_demands`: A list of floating-point numbers representing the average daily demand for each product over the past week. - `scaling_factor`: A floating-point number that scales the influence of the demand on the price adjustment. # Output: - Returns a list of floating-point numbers representing the new prices for the products after applying the custom adjustment algorithm. # Constraints: - Both `current_prices` and `average_daily_demands` will have the same length, up to 10^5. - The `scaling_factor` is a positive number. - The new price for each product should not fall below 1.0. # Example: ```python >>> current_prices = [120.0, 45.5, 30.0, 80.0] >>> average_daily_demands = [50.0, 10.0, 100.0, 70.0] >>> scaling_factor = 0.05 >>> adjust_prices(current_prices, average_daily_demands, scaling_factor) [122.5, 46.5, 35.0, 83.5] ``` # Notes: - The custom adjustment algorithm multiplies the average daily demand by the scaling factor and adds the result to the current price to calculate the new price. - Ensure the new price is not lower than 1.0, even if the adjustment would result in a lower value.","solution":"from typing import List def adjust_prices( current_prices: List[float], average_daily_demands: List[float], scaling_factor: float ) -> List[float]: new_prices = [] for current_price, average_daily_demand in zip(current_prices, average_daily_demands): new_price = current_price + (average_daily_demand * scaling_factor) new_prices.append(max(new_price, 1.0)) return new_prices"},{"question":"# Scenario You are writing a simulation for a 2D physics engine. For your simulation to work accurately, you need to implement a class `Vector2D` that represents vectors in a 2D plane. Your `Vector2D` class should include methods for common vector operations and a specialized method to determine if two vectors are orthogonal (perpendicular). # Task Implement the `Vector2D` class which supports vector arithmetic operations and a method `is_orthogonal` that checks if two vectors are orthogonal. # Details 1. **Class `Vector2D` Implementation**: * Attributes to store x and y coordinates (`x`, `y`). * Essential operations (`__add__`, `__sub__`, `__mul__` for scalar multiplication, `__truediv__` for scalar division). * Magnitude calculation method `magnitude`. * Dot product method `dot_product`. 2. **Method `is_orthogonal(self, other: \'Vector2D\') -> bool` Implementation**: * Checks if two vectors are orthogonal using the dot product. # Input * `x`, `y`: Numeric values `(float|int)` representing the coordinates of the vector. * `other`: An instance of `Vector2D`. # Output * For `is_orthogonal`, returns a boolean indicating whether the current vector is orthogonal to the `other` vector. # Constraints * Coordinates should be numeric (integers or floating-point values). * Ensure operations handle edge cases and invalid inputs appropriately. * Efficiently support vectors with magnitudes up to a maximum float value. # Example ```python v1 = Vector2D(3, 4) v2 = Vector2D(-4, 3) # Magnitude of Vector v1 print(v1.magnitude()) # Expected output: 5.0 # Dot Product of v1 and v2 print(v1.dot_product(v2)) # Expected output: 0 # Orthogonality check print(v1.is_orthogonal(v2)) # Expected output: True ``` # Notes 1. Ensure comprehensive error handling for invalid operations. 2. Include docstrings and comments explaining key parts of your implementation. --- This new question closely aligns with the initial sample by setting up a similar implementation task involving a class definition and related operations, maintaining the complexity and scope while introducing a novel problem of vector arithmetic and orthogonality checks in a 2D plane.","solution":"import math class Vector2D: def __init__(self, x, y): Initialize a 2D vector with coordinates x and y. self.x = x self.y = y def __add__(self, other): Returns the vector addition of self and other. return Vector2D(self.x + other.x, self.y + other.y) def __sub__(self, other): Returns the vector subtraction of self and other. return Vector2D(self.x - other.x, self.y - other.y) def __mul__(self, scalar): Returns the scalar multiplication of this vector. return Vector2D(self.x * scalar, self.y * scalar) def __truediv__(self, scalar): Returns the scalar division of this vector. if scalar == 0: raise ValueError(\\"Cannot divide by zero\\") return Vector2D(self.x / scalar, self.y / scalar) def magnitude(self): Returns the magnitude of the vector. return math.sqrt(self.x ** 2 + self.y ** 2) def dot_product(self, other): Returns the dot product of self and other. return self.x * other.x + self.y * other.y def is_orthogonal(self, other): Returns True if self and other are orthogonal (dot product is zero). return self.dot_product(other) == 0"},{"question":"# Problem Statement Chessboard BFS (Breadth-First Search) Algorithm: Implement a function to determine the minimum number of moves a knight needs to reach its target position on an ( n times n ) chessboard. A knight moves in an \\"L\\" shape, i.e., it can move two squares in one direction and then one square perpendicular to that direction, or one square in one direction and then two squares perpendicular to that direction. # Function Signature ```python def min_knight_moves(n: int, start: Tuple[int, int], target: Tuple[int, int]) -> int: ``` # Constraints * ( 1 leq n leq 1000 ) * `start` and `target` are tuples representing positions in the format (row, col) * Each position (row, col) satisfies ( 0 leq row, col < n ) # Example ```python # Example 1 print(min_knight_moves(8, (0, 0), (7, 7))) # should return 6 # Example 2 print(min_knight_moves(5, (0, 0), (4, 4))) # should return 4 ``` # Requirements 1. **Algorithm**: Use BFS to ensure the shortest path in an unweighted grid-like graph. 2. **Efficiency**: Your solution should work efficiently within the given constraints. 3. **Edge Cases**: Handle edge cases such as the knight starting at the target position. Ensure your code properly handles the bounds of the board.","solution":"from collections import deque from typing import Tuple def min_knight_moves(n: int, start: Tuple[int, int], target: Tuple[int, int]) -> int: # Directions a knight can move directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] # BFS Setup queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set((start[0], start[1])) # BFS Loop while queue: x, y, steps = queue.popleft() # If the target is reached, return the number of steps if (x, y) == target: return steps # Process all valid movements for dx, dy in directions: nx, ny = x + dx, y + dy # Check that the new position is within the board and not visited if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If no solution found (not really possible with valid chessboard values) return -1"},{"question":"# Question: Implement Prime Number Vector Filter In this task, you will write a function to filter out prime numbers from a given numpy array of integers. A prime number is defined as any integer greater than `1` that is not divisible by any integer other than `1` and itself. Your function should identify and retain only the prime numbers from the input array. Write a Python function `filter_primes(vector: np.ndarray) -> np.ndarray` that takes a numpy array of integers and returns an array containing only the prime numbers found in the input. # Input * A numpy array `vector` consisting of integer values. # Output * A numpy array containing only the prime numbers from the input vector. # Example ```python >>> vector = np.array([10, 15, 3, 7, 6, 11, 13, 20, 25]) >>> filter_primes(vector) array([ 3, 7, 11, 13 ]) ``` # Constraints * The input vector length can be between `0` and `10^6`. * The input vector elements will be valid integers. * Your implementation should be optimized to handle large arrays efficiently. # Note * Recall that `0` and `1` are not prime numbers. * Consider using efficient algorithms for large datasets to determine primality, such as the Sieve of Eratosthenes for precomputation or optimization techniques for individual checks.","solution":"import numpy as np def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(np.sqrt(n)) + 1, 2): if n % i == 0: return False return True def filter_primes(vector: np.ndarray) -> np.ndarray: Filter out the prime numbers from a given numpy array of integers. Args: vector (np.ndarray): Input numpy array of integers. Returns: np.ndarray: Numpy array containing only the prime numbers. prime_vector = np.array([num for num in vector if is_prime(num)]) return prime_vector"},{"question":"# Matrix Rotation and Coordinate Transformation **Scenario**: You are working in a graphics software division, where you need to implement a feature to rotate images. As part of the feature, you need to rotate a matrix representing an image by 90 degrees clockwise. Additionally, you must transform the coordinates of points within the matrix accordingly. # Problem Statement Implement a function that performs a 90-degree clockwise rotation on a square matrix and another function that transforms the coordinates of a given point within this matrix after the rotation. **Function Signature** ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: pass def rotate_coordinate(coordinate: tuple[int, int], n: int) -> tuple[int, int]: pass ``` **Input/Output Format** * **Input**: - `matrix` (list of lists of integers): A square matrix of size `n x n`. - `coordinate` (tuple of two integers): A point within the matrix to transform `(x, y)`. - `n` (integer) representing the size of the square matrix. * **Output**: - The `rotate_matrix` function: Returns the rotated matrix as a list of lists of integers. - The `rotate_coordinate` function: Returns the new coordinates of the point as a tuple. **Examples** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix)) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] coordinate = (1, 2) n = 3 print(rotate_coordinate(coordinate, n)) # Output: (2, 1) ``` **Constraints** 1. The size `n` of the matrix will be between 1 and 10^3. 2. Each integer in the matrix will be between -10^6 and 10^6. 3. The `coordinate` will always be within the bounds of the matrix [0, n-1] x [0, n-1]. # Requirements - Implement the `rotate_matrix` function to rotate the given square matrix by 90 degrees clockwise. - Implement the `rotate_coordinate` function to calculate the new position of a point `(x, y)` after rotating the matrix by 90 degrees clockwise. - Consider edge cases such as a minimal matrix of size 1x1 and large matrices within the given constraints.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates the given n x n matrix by 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n-1-i] = matrix[i][j] return rotated def rotate_coordinate(coordinate: tuple[int, int], n: int) -> tuple[int, int]: Transforms the coordinate (x, y) within an n x n matrix after a 90 degrees clockwise rotation. x, y = coordinate new_x = y new_y = n - 1 - x return (new_x, new_y)"},{"question":"# Coding Assessment Question - Self-Dividing Numbers Scenario: You are developing a feature for a program that analyzes the characteristics of numbers. A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. Your task is to implement a function that identifies if a number is a self-dividing number. Question: **Function Signature:** ```python def is_self_dividing_number(number: int) -> bool: ``` **Input:** * A single integer `number` which is a positive integer. **Output:** * Return `True` if `number` is a self-dividing number. * Return `False` otherwise. **Constraints:** * The input `number` will always be in the range of 1 to 10^4 inclusive. **Examples:** ```python is_self_dividing_number(1) # Expected output: True is_self_dividing_number(12) # Expected output: True is_self_dividing_number(128) # Expected output: True is_self_dividing_number(26) # Expected output: False is_self_dividing_number(101) # Expected output: False ``` **Notes:** * A self-dividing number cannot contain the digit zero. * Ensure that your function handles edge cases efficiently. * Consider performance for the upper limit of the input range. **Hint:** Use modular arithmetic and integer division to check each digit of the number individually and determine if the number is divisible by each of those digits.","solution":"def is_self_dividing_number(number: int) -> bool: Checks if a number is a self-dividing number. A self-dividing number is a number that is divisible by every digit it contains. :param number: Positive integer to check. :return: Boolean indicating whether the number is self-dividing. original_number = number while number > 0: digit = number % 10 if digit == 0 or original_number % digit != 0: return False number //= 10 return True"},{"question":"# Coding Assessment Question **Scenario**: As part of an advanced data analytics team, you are exploring methods to evaluate the shortest path in a weighted graph. The Bellman-Ford algorithm plays a crucial role in finding the shortest paths from a single source vertex to all other vertices, even when some of the weights might be negative. **Problem Statement**: Implement a function `bellman_ford()` that computes the shortest paths from a given source vertex to all other vertices in a weighted directed graph using the Bellman-Ford algorithm. Your task is to create a function `bellman_ford()` that processes the given graph and outputs the shortest distances. Function Signature ```python def bellman_ford(vertices: int, edges: list[tuple[int, int, int]], src: int) -> list[float]: # Implementation here ``` Input & Output Formats - **Input**: - An integer `vertices` where (1 leq text{vertices} leq 100), representing the number of vertices in the graph. - A list of tuples `edges` where each tuple ((u, v, w)) represents a directed edge from vertex `u` to vertex `v` with weight `w` (integer). The graph can have at most (10^4) edges. - An integer `src` representing the source vertex (0 leq text{src} < text{vertices}). - **Output**: A list of floating-point numbers representing the shortest distances from the source vertex `src` to all other vertices. If a vertex is unreachable, the distance should be `float(\'inf\')`. Constraints - The function should handle negative weight edges but should detect if there are any negative weight cycles, and if so, return `None`. Examples ```python >>> bellman_ford(5, [(0, 1, 6), (0, 2, 7), (1, 2, 8), (1, 3, 5), (1, 4, -4), (2, 3, -3), (2, 4, 9), (3, 1, -2), (4, 0, 2), (4, 3, 7)], 0) [0, 2, 7, 4, -2] >>> bellman_ford(5, [(0, 1, 6), (0, 2, -7), (1, 2, 8), (1, 3, 5), (1, 4, 4), (2, 3, -3), (2, 4, 9), (3, 1, -2), (4, 0, 2), (4, 3, 7)], 0) None >>> bellman_ford(3, [(0, 1, 5), (1, 2, 3)], 0) [0, 5, 8] >>> bellman_ford(3, [], 0) [0, inf, inf] >>> bellman_ford(4, [(0, 1, 4), (0, 2, 5), (1, 2, 7), (2, 3, 8), (3, 1, -6)], 0) [0, 4, 5, 13] ``` Notes - Pay special attention to handling edge cases such as graphs with no edges, disconnected vertices, and negative weight edges. - If any negative weight cycle is detected, the function should return `None`, indicating that shortest path computation is not possible.","solution":"def bellman_ford(vertices, edges, src): # Initialize distances from src to all other vertices as infinite and src to itself as 0 dist = [float(\'inf\')] * vertices dist[src] = 0 # Relax all edges |V| - 1 times for i in range(vertices - 1): for u, v, w in edges: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: dist[v] = dist[u] + w # Check for negative-weight cycles for u, v, w in edges: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: return None # Negative cycle detected return dist"},{"question":"# Scenario: You are helping a library system to manage their book collections and ensure efficient checkout processes. One of the problems they face is tracking the number of available copies of each book and updating the inventory as books are borrowed or returned. # Problem Description: Implement a class `Library` that manages a collection of books. The class should provide functionalities to add new books, borrow books, return books, and check the availability of a book. Each book is represented by its title and the number of copies available. # Class Signature: ```python class Library: def __init__(self): pass def add_book(self, title: str, count: int) -> None: pass def borrow_book(self, title: str) -> bool: pass def return_book(self, title: str) -> None: pass def check_availability(self, title: str) -> int: pass ``` # Methods: - `add_book(title: str, count: int) -> None`: Adds `count` copies of the book `title` to the library\'s collection. If the book already exists, it increases the count. - `borrow_book(title: str) -> bool`: Allows borrowing of a book with the given `title`. If the book is available (at least one copy), it decreases the count and returns `True`. If no copies are available, it returns `False`. - `return_book(title: str) -> None`: Allows returning of a book with the given `title`. It increases the count of the book. - `check_availability(title: str) -> int`: Returns the number of available copies of the book with the given `title`. If the book does not exist, it returns 0. # Input: - `title`: A string representing the title of the book. - `count`: An integer representing the number of copies of the book being added. # Output: - `borrow_book`: A boolean indicating if the book was successfully borrowed. - `check_availability`: An integer representing the number of available copies. # Constraints: - You can assume book titles are case-sensitive. - Efficiently handle multiple operations due to the nature of potentially a large number of books being added, borrowed, or returned. # Example: ```python library = Library() library.add_book(\'The Great Gatsby\', 3) library.add_book(\'1984\', 5) print(library.check_availability(\'The Great Gatsby\')) # Output: 3 print(library.borrow_book(\'The Great Gatsby\')) # Output: True print(library.check_availability(\'The Great Gatsby\')) # Output: 2 library.return_book(\'The Great Gatsby\') print(library.check_availability(\'The Great Gatsby\')) # Output: 3 print(library.borrow_book(\'The Catcher in the Rye\')) # Output: False ```","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title: str, count: int) -> None: if title in self.books: self.books[title] += count else: self.books[title] = count def borrow_book(self, title: str) -> bool: if title in self.books and self.books[title] > 0: self.books[title] -= 1 return True return False def return_book(self, title: str) -> None: if title in self.books: self.books[title] += 1 else: self.books[title] = 1 def check_availability(self, title: str) -> int: return self.books.get(title, 0)"},{"question":"# Question: Implement a Time Conversion Function When working with time data in various formats, it is crucial to ensure accurate conversions between standard formats. One common requirement is to convert time given in minutes to the \\"HH:MM\\" format. Your task is to implement a function that converts a given number of minutes into a string representing the same time in the \\"HH:MM\\" format. # Function Signature ```python def minutes_to_time(minutes: int) -> str: ``` # Input - `minutes` (int): A non-negative integer representing the total minutes to be converted. # Output - `str`: A string in the format \\"HH:MM\\" representing the converted time. # Constraints - 0 ≤ minutes < 1440 (since there are 1440 minutes in a day, the input will not exceed this value). # Example ```python >>> minutes_to_time(75) \'01:15\' >>> minutes_to_time(123) \'02:03\' >>> minutes_to_time(0) \'00:00\' >>> minutes_to_time(1439) \'23:59\' ``` # Performance Requirements Ensure your implementation has a constant time complexity O(1), as the conversion involves basic arithmetic operations and string formatting. # Edge Cases - Handling single-digit hours and minutes to ensure proper two-digit formatting. - Handling the case where the input is exactly zero to ensure the output correctly represents \\"00:00\\". **Note**: Include a high-level docstring along with `doctests` to demonstrate the correctness of your implementation.","solution":"def minutes_to_time(minutes: int) -> str: Converts a given number of minutes into a string representing time in \\"HH:MM\\" format. :param minutes: Total minutes to be converted (0 ≤ minutes < 1440). :type minutes: int :return: A string representing the converted time in \\"HH:MM\\" format. :rtype: str >>> minutes_to_time(75) \'01:15\' >>> minutes_to_time(123) \'02:03\' >>> minutes_to_time(0) \'00:00\' >>> minutes_to_time(1439) \'23:59\' hours = minutes // 60 mins = minutes % 60 return f\\"{hours:02}:{mins:02}\\""},{"question":"# Binary Search Tree (BST) Insertion and Search Validation In this task, you are required to implement functions for inserting into a Binary Search Tree (BST) and then validating a given value\'s presence in the tree. Given the root of a BST and a value to be inserted, your code should first insert the value into the BST. Then, you will implement a function to check if a given value exists in the BST. # Input * `root`: A TreeNode representing the root of the BST. It contains: - `val`: An integer representing the value of the node. - `left`: The left child TreeNode or `None` if no child exists. - `right`: The right child TreeNode or `None` if no child exists. * `insert_val`: An integer representing the value to be inserted into the BST. * `search_val`: An integer representing the value to be searched in the BST. # Output A tuple containing: * The updated BST root after insertion. * A boolean indicating whether `search_val` exists in the BST after the insertion. # Constraints * The initial tree may not be empty. * The value to be inserted is guaranteed not to be already present in the BST. # Example ```python class TreeNode: def __init__(self, val:int, left:Optional[TreeNode]=None, right:Optional[TreeNode]=None): self.val = val self.left = left self.right = right # Sample BST # 10 # / # 5 15 # / / # 2 7 12 20 root = TreeNode(10, TreeNode(5, TreeNode(2), TreeNode(7)), TreeNode(15, TreeNode(12), TreeNode(20))) insert_val = 6 search_val = 6 updated_root, exists = insert_and_search(root, insert_val, search_val) print(exists) # Output: True insert_val = 17 search_val = 8 updated_root, exists = insert_and_search(root, insert_val, search_val) print(exists) # Output: False ``` # Task Implement the `insert_and_search` function as described above. ```python from __future__ import annotations from typing import Optional, Tuple class TreeNode: def __init__(self, val: int, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right def insert_and_search(root: TreeNode, insert_val: int, search_val: int) -> Tuple[TreeNode, bool]: def insert(node: TreeNode | None, val: int) -> TreeNode: if node is None: return TreeNode(val) if val < node.val: node.left = insert(node.left, val) else: node.right = insert(node.right, val) return node def search(node: TreeNode | None, val: int) -> bool: if node is None: return False if node.val == val: return True elif val < node.val: return search(node.left, val) else: return search(node.right, val) updated_root = insert(root, insert_val) exists = search(updated_root, search_val) return updated_root, exists ```","solution":"from __future__ import annotations from typing import Optional, Tuple class TreeNode: def __init__(self, val: int, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right def insert_and_search(root: TreeNode, insert_val: int, search_val: int) -> Tuple[TreeNode, bool]: def insert(node: TreeNode | None, val: int) -> TreeNode: if node is None: return TreeNode(val) if val < node.val: node.left = insert(node.left, val) else: node.right = insert(node.right, val) return node def search(node: TreeNode | None, val: int) -> bool: if node is None: return False if node.val == val: return True elif val < node.val: return search(node.left, val) else: return search(node.right, val) updated_root = insert(root, insert_val) exists = search(updated_root, search_val) return updated_root, exists"},{"question":"# Scenario: You have been hired as a software developer by a logistics company to streamline their package delivery tracking system. They require a function to determine the shortest delivery route between different locations while considering some locations as mandatory stops. # Task: Implement a function that finds the shortest route traveling through a series of required stops using Dijkstra\'s algorithm. The function should take the number of locations, a list of edges representing the direct routes between locations with their corresponding travel times, and a list of required stops to be visited along the way. # Function Signature: ```python def find_shortest_route(n: int, edges: List[Tuple[int, int, int]], required_stops: List[int]) -> List[int]: Find the shortest route that visits all required stops. Parameters: - n (int): The number of locations. - edges (List[Tuple[int, int, int]]): The edges where each edge is represented as a tuple (u, v, w) with u and v being the locations and w being the travel time. - required_stops (List[int]): The list of locations that are mandatory stops. Returns: - List[int]: The shortest route as a list of location indices. ``` # Constraints: - The locations are indexed from 0 to n-1. - The list of edges represents an undirected graph with no negative travel times. - Ensure the solution can handle up to 1000 locations and 5000 edges efficiently within a reasonable time limit. # Example: ```python n = 5 edges = [(0, 1, 10), (1, 2, 10), (0, 2, 15), (2, 3, 10), (3, 4, 10)] required_stops = [0, 2, 4] print(find_shortest_route(n, edges, required_stops)) ``` Output: ```python [0, 1, 2, 3, 4] ``` # Performance: - Ensure optimal route calculation leveraging Dijkstra\'s algorithm for efficiency. - Aim for scalability and robustness in edge cases like disconnected graphs or insufficient routes. # Evaluation: - The solution will be evaluated based on correctness, adherence to Dijkstra\'s algorithm implementation, efficiency, and handling of edge cases (e.g., when no feasible route exists through all required stops).","solution":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], start: int) -> List[int]: Implements Dijkstra\'s algorithm to find the shortest path from \'start\' to all other nodes. Parameters: - graph: Adjacency list representation of the graph where graph[u] is a list of tuples (v, w) representing an edge from u to v with weight w. - start: The starting node. Returns: - List of minimum distances from start to each node. n = len(graph) distances = [float(\'inf\')] * n distances[start] = 0 pq = [(0, start)] # priority queue of (distance, node) while pq: current_distance, u = heapq.heappop(pq) if current_distance > distances[u]: continue for neighbor, weight in graph[u]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def find_shortest_route(n: int, edges: List[Tuple[int, int, int]], required_stops: List[int]) -> List[int]: Find the shortest route that visits all required stops. Parameters: - n (int): The number of locations. - edges (List[Tuple[int, int, int]]): The edges where each edge is represented as a tuple (u, v, w) with u and v being the locations and w being the travel time. - required_stops (List[int]): The list of locations that are mandatory stops. Returns: - List[int]: The shortest route as a list of location indices. # Create a graph in adjacency list format graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Compute distances between each pair of required stops using Dijkstra\'s algorithm required_stops = list(set(required_stops)) # Remove duplicates if any distance_between_required = {} for i in range(len(required_stops)): u = required_stops[i] distances = dijkstra(graph, u) for j in range(i + 1, len(required_stops)): v = required_stops[j] distance_between_required[(u, v)] = distances[v] distance_between_required[(v, u)] = distances[v] # Since it\'s undirected # Note: Implement a strategy to find the shortest path visiting all required stops (e.g., TSP approximation) # Placeholder for the required route finding logic # Assuming we visit them in the given order in `required_stops`: return required_stops"},{"question":"# Problem Description Write a function to determine the minimum number of operations required to reduce a given positive integer `n` to 1. The possible operations are: subtracting 1, dividing by 2 (if even), or dividing by 3 (if divisible by 3). # Function Signature ```python def min_operations(n: int) -> int: Find the minimum number of operations to reduce n to 1. Args: n : An integer representing the starting number. Returns: An integer representing the minimum number of operations. Examples: >>> min_operations(10) 3 # (10 -> 9 -> 3 -> 1) >>> min_operations(15) 4 # (15 -> 5 -> 4 -> 2 -> 1) >>> min_operations(1) 0 # Already 1 ``` # Input * A single integer `n` (1 ≤ `n` ≤ 10^6). # Output * The minimum number of operations required to reduce `n` to 1. # Example ```python assert min_operations(10) == 3 # 10 -> 9 -> 3 -> 1 assert min_operations(15) == 4 # 15 -> 5 -> 4 -> 2 -> 1 assert min_operations(1) == 0 # Already 1 ``` # Constraints * Implement the function using an efficient approach, keeping the time complexity in mind. # Notes - The function should handle various edge cases, such as already having `n` equal to 1, and large values efficiently. - Utilize a method like memoization or dynamic programming to store subproblem results and optimize the solution. # Performance Requirements * The solution should aim to operate within a time complexity of approximately (O(log n)) using iterative or dynamic programming techniques.","solution":"def min_operations(n: int) -> int: Find the minimum number of operations to reduce n to 1. Args: n : An integer representing the starting number. Returns: An integer representing the minimum number of operations. if n == 1: return 0 # Dictionary to store minimum operations for each number operations = {1: 0} for i in range(2, n + 1): # Start with subtracting 1 min_ops = operations[i - 1] + 1 # If divisible by 2, compare the operations count if i % 2 == 0: min_ops = min(min_ops, operations[i // 2] + 1) # If divisible by 3, compare the operations count if i % 3 == 0: min_ops = min(min_ops, operations[i // 3] + 1) # Store the minimum operations count for the current number operations[i] = min_ops return operations[n]"},{"question":"# Coding Assessment Question You are given an array of integers representing the heights of buildings, where the width of each building is 1 unit. Your task is to calculate the amount of rainwater that can be trapped between these buildings after a rainfall. Input - A list of integers `heights` where `heights[i]` represents the height of the i-th building. Output - An integer representing the total amount of trapped rainwater. Constraints - The length of `heights` will be between 1 and 10^5. - All integers in `heights` are non-negative and will not exceed 10^4. Performance Requirements - The implemented algorithm should run in linear time complexity relative to the number of buildings. Example Input: ```python heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] ``` Output: ```python 6 ``` Explanation: - The structure of the buildings is represented as `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`. - A total of 6 units of rainwater are trapped between the buildings. Requirements Implement the following function: ```python def calculate_trapped_rainwater(heights: list[int]) -> int: This function calculates the total amount of rainwater that can be trapped between buildings. Parameters: heights (list[int]): The list of heights of the buildings. Returns: int: The total amount of trapped rainwater. # Your implementation here ``` Make sure to handle all edge cases related to input validity and ensure your implementation adheres to the expected complexity.","solution":"def calculate_trapped_rainwater(heights): This function calculates the total amount of rainwater that can be trapped between buildings. Parameters: heights (list[int]): The list of heights of the buildings. Returns: int: The total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Calculate left max for each position left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Calculate right max for each position right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the total amount of trapped rainwater total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"Merging Sorted Lists You are tasked with implementing a function `merge_sorted_lists(lists: List[List[int]]) -> List[int]` that merges multiple sorted lists into a single sorted list. Your implementation should leverage the inherent ordering of the input lists to achieve this efficiently. Requirements: 1. The function will take a list of lists, where each inner list is sorted in non-decreasing order. 2. The function should return a single list that contains all elements from the input lists, also in non-decreasing order. 3. If the input contains an empty list or all lists are empty, the function should return an empty list. 4. The function should handle large lists and efficiently merge them. Constraints: - Each individual list and the total number of lists can be very large. - Input lists are sorted in non-decreasing order. - The solution should aim for optimal time complexity. Input: - `lists: List[List[int]]` - a list of lists of integers, where each individual list is sorted. Output: - `List[int]` - a single list sorted in non-decreasing order containing all elements from the input lists. Example: ```python assert merge_sorted_lists([[1, 3, 5], [2, 4, 6], [0, 7, 8]]) == [0, 1, 2, 3, 4, 5, 6, 7, 8] assert merge_sorted_lists([]) == [] assert merge_sorted_lists([[], [], []]) == [] assert merge_sorted_lists([[1, 2, 3], [3, 4], [5, 6, 7]]) == [1, 2, 3, 3, 4, 5, 6, 7] ``` # Function Signature: ```python from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: pass ```","solution":"from typing import List import heapq def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into a single sorted list. Args: lists (List[List[int]]): A list of lists of integers where each inner list is sorted. Returns: List[int]: A single list sorted in non-decreasing order containing all elements from the input lists. if not lists: return [] merged_list = [] min_heap = [] # Initialize the heap with the first element of each list. for i, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst[0], i, 0)) while min_heap: value, list_index, element_index = heapq.heappop(min_heap) merged_list.append(value) # If the popped element was not the last one in its list, add the next element from the same list to the heap. if element_index + 1 < len(lists[list_index]): next_value = lists[list_index][element_index + 1] heapq.heappush(min_heap, (next_value, list_index, element_index + 1)) return merged_list"},{"question":"# Question: Implement Bubble Sort for Numerical Data You are working on a sorting feature for a numerical data processing application. Your task is to implement the Bubble Sort algorithm to sort a list of numbers in ascending order. Function Signature `def bubble_sort(nums: list[int | float]) -> list[int | float]` Requirements * The function should implement the Bubble Sort algorithm. * The function should return a new list that contains all the elements of the input list sorted in ascending order. * The function should handle lists of integers, floats, and mixed types. Input * `nums`: A list of integers or floats. Example: `[3, 1, 4, 1, 5, 9]` Output * Return a new list sorted in ascending order. Constraints * The list can be empty. * Elements can be a mix of integers and floats. Examples ```python # Example 1 assert bubble_sort([3, 1, 4, 1, 5, 9]) == [1, 1, 3, 4, 5, 9] # Example 2 assert bubble_sort([-3, -1, -4, -1, -5, -9]) == [-9, -5, -4, -3, -1, -1] # Example 3 assert bubble_sort([2.5, -3.1, 4.8, 0.1]) == [-3.1, 0.1, 2.5, 4.8] # Example 4 assert bubble_sort([]) == [] # Example 5 assert bubble_sort([3]) == [3] ``` Constraints & Limitations * Performance should be O(n^2) in the worst case, as expected for Bubble Sort. * Space complexity should be O(1) as Bubble Sort is an in-place sorting algorithm. * Ensure the function gracefully handles edge cases and provide sufficient test cases in your submission.","solution":"def bubble_sort(nums: list[int | float]) -> list[int | float]: Returns a new list with numbers sorted in ascending order using Bubble Sort algorithm. # Make a copy of the input list to avoid modifying the original list sorted_nums = nums[:] n = len(sorted_nums) # Bubble Sort Algorithm for i in range(n): # Flag to detect any swaps in the current iteration swapped = False for j in range(0, n-i-1): if sorted_nums[j] > sorted_nums[j+1]: # Swap if the current number is greater than the next sorted_nums[j], sorted_nums[j+1] = sorted_nums[j+1], sorted_nums[j] swapped = True # If no two elements were swapped during the last traversal, list is sorted if not swapped: break return sorted_nums"},{"question":"# Data Alignment Verification You are tasked with implementing a function that verifies if two arrays of data have matching elements up to a certain tolerance level. This can be particularly useful in contexts where data might have small errors or variations, and you need to determine if two datasets are essentially the same. Function Signature ```python def verify_data_alignment( array1: List[float], array2: List[float], tolerance: float ) -> bool: pass ``` # Input - `array1` (List[float]): The first list of floating-point numbers. - `array2` (List[float]): The second list of floating-point numbers. - `tolerance` (float): The maximum allowable difference between corresponding elements in the two arrays. # Output - `bool`: Returns `True` if the absolute difference between each corresponding element in `array1` and `array2` does not exceed the `tolerance`. Otherwise, returns `False`. # Constraints - Both `array1` and `array2` will have the same length. - Each element in `array1` and `array2` will be a valid floating-point number. - `tolerance` will be a non-negative floating-point number. # Examples * `verify_data_alignment([1.0, 2.0, 3.0], [1.1, 2.1, 3.1], 0.15)` should return `True`. * `verify_data_alignment([1.0, 2.0, 3.0], [1.2, 2.1, 3.1], 0.15)` should return `False`. * `verify_data_alignment([1.0, 2.0, 3.0, 4.0], [1.05, 2.05, 3.00, 4.10], 0.1)` should return `True`. * `verify_data_alignment([1.0], [2.0], 2.0)` should return `True`. Implement this function ensuring that it adheres to the constraints and handles all edge cases and invalid inputs appropriately.","solution":"from typing import List def verify_data_alignment(array1: List[float], array2: List[float], tolerance: float) -> bool: Verifies if the data in array1 aligns with the data in array2 within the given tolerance. Parameters: array1 (List[float]): The first list of floating-point numbers. array2 (List[float]): The second list of floating-point numbers. tolerance (float): The maximum allowable difference between corresponding elements in the two arrays. Returns: bool: True if the absolute difference between each corresponding element in array1 and array2 does not exceed the tolerance, else False. if len(array1) != len(array2): return False for a, b in zip(array1, array2): if abs(a - b) > tolerance: return False return True"},{"question":"# Problem Scenario Your task is to implement a basic 2D physics engine that simulates the movement of a particle under the influence of gravity. This engine should update the position of the particle based on its velocity and the constant acceleration due to gravity. # Task: Implement a class `Particle` that models a particle in a 2D space. The class should support initializing the particle with a given position and velocity, and updating the particle\'s position based on its velocity and gravity over a specified time interval. # Key Requirements: 1. Initialize the particle with a given position and velocity. 2. Update the position of the particle based on its velocity and a constant gravitational acceleration over a given time step. 3. Retrieve the current position of the particle. # Specifications: 1. **Class**: `Particle` 2. **Methods**: * `__init__(self, x: float, y: float, vx: float, vy: float)`: Initializes the particle with the given position `(x, y)` and velocity `(vx, vy)`. * `update(self, dt: float)`: Updates the position of the particle after `dt` time has elapsed, considering gravity. * `get_position(self) -> tuple`: Returns the current position of the particle as a tuple `(x, y)`. 3. **Input/Output**: * The `__init__` method takes four floats: the initial position `(x, y)` and initial velocity `(vx, vy)` of the particle. * The `update` method takes a single float `dt`, representing the time step in seconds. * The `get_position` method returns a tuple of two floats `(x, y)`, representing the current position of the particle. # Constraints: * The gravitational acceleration `g` is a constant value of `9.81 m/s^2` downward. * All input values provided are valid floats. # Example: ```python # Example Usage particle = Particle(0.0, 0.0, 10.0, 10.0) # Simulate particle movement for 1 second particle.update(1.0) print(particle.get_position()) # Outputs: (10.0, 0.095) # Simulate another second particle.update(1.0) print(particle.get_position()) # Outputs: (20.0, -9.62) ``` # Notes: * The new velocity in the y-direction should be updated by the formula `vy_new = vy_old - g * dt`. * The new position should be computed using the updated velocity. * Ensure that the update method correctly applies the gravitational effect at each time step.","solution":"class Particle: GRAVITY = 9.81 def __init__(self, x: float, y: float, vx: float, vy: float): Initializes the particle with the given position (x, y) and velocity (vx, vy). self.x = x self.y = y self.vx = vx self.vy = vy def update(self, dt: float): Updates the position of the particle after `dt` time has elapsed, considering gravity. # Update the velocity with gravity self.vy -= self.GRAVITY * dt # Update the position with the new velocity self.x += self.vx * dt self.y += self.vy * dt def get_position(self) -> tuple: Returns the current position of the particle as a tuple (x, y). return (self.x, self.y)"},{"question":"# Coding Question: Generate Fibonacci Sequence Up to a Limit Imagine you are developing a program for a mathematical tool that needs to generate elements in the Fibonacci sequence, but only up to a certain limit for any number provided by the user. The Fibonacci sequence starts with the numbers 0 and 1, and each subsequent number is the sum of the two preceding ones. Write a function `generate_fibonacci` that takes one argument: the limit (`n`). The function should: 1. Generate the Fibonacci sequence starting from 0, and continue to generate numbers until it reaches or exceeds the given limit `n`. 2. Stop the sequence generation if the next Fibonacci number exceeds `n`. 3. Return a list of Fibonacci numbers in the sequence up to the limit `n`. # Example ```python >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8] >>> generate_fibonacci(20) [0, 1, 1, 2, 3, 5, 8, 13] >>> generate_fibonacci(0) [0] ``` Explanation: - For `n=10`, the function returns `[0, 1, 1, 2, 3, 5, 8]` because the next number (13) exceeds 10. - For `n=20`, the function returns `[0, 1, 1, 2, 3, 5, 8, 13]` because the next number (21) exceeds 20. - For `n=0`, the function returns `[0]`. # Constraints 1. The limit (`n`) will be a non-negative integer. 2. The function should handle edge cases where `n` is extremely small (e.g., 0 or 1). # Input - `n`: a non-negative integer representing the limit of the Fibonacci sequence. # Output - Returns a list of integers representing the Fibonacci sequence up to the limit `n`. ```python def generate_fibonacci(n: int) -> list: # Your implementation here ```","solution":"def generate_fibonacci(n: int) -> list: Generate the Fibonacci sequence up to the given limit `n`. Parameters: n (int): The limit up to which the sequence should be generated. Returns: list: A list of integers representing the Fibonacci sequence up to `n`. if n == 0: return [0] fibonacci_list = [0, 1] while True: next_value = fibonacci_list[-1] + fibonacci_list[-2] if next_value > n: break fibonacci_list.append(next_value) return fibonacci_list"},{"question":"# Context You are developing an application that helps automate payroll calculations for a company\'s employees. The application needs a function that calculates the total monthly salary based on the employee\'s working hours and their hourly wage, taking into account potential overtime. Overtime hours are paid at 1.5 times the regular hourly rate. # Task Implement the `calculate_total_salary(employees: List[Tuple[str, int, float]]) -> Dict[str, float]` function, which takes a list of tuples representing employees and returns a dictionary with their total monthly salary. # Input - `employees`: A list of tuples where each tuple contains: - `name`: A string representing the employee\'s name. - `hours_worked`: An integer representing the number of hours worked in the month. - `hourly_wage`: A float representing the hourly wage of the employee. # Output - The function should return a dictionary where the keys are the employee names and the values are their total monthly salary. # Constraints - The number of hours worked is an integer in the range [0, 300]. - The hourly wage is a float in the range [10.0, 100.0]. - Overtime is considered for any hours worked beyond 160 hours in a month. # Example ```python employees = [ (\\"Alice\\", 170, 20.0), (\\"Bob\\", 160, 15.5), (\\"Charlie\\", 180, 30.0) ] # Calculating total salaries # For Alice: # Regular hours = 160 # Overtime hours = 170 - 160 = 10 # Total salary = (160 * 20.0) + (10 * 20.0 * 1.5) = 3200 + 300 = 3500.0 # For Bob: # Regular hours = 160 # Overtime hours = 0 # Total salary = 160 * 15.5 = 2480.0 # For Charlie: # Regular hours = 160 # Overtime hours = 180 - 160 = 20 # Total salary = (160 * 30.0) + (20 * 30.0 * 1.5) = 4800 + 900 = 5700.0 assert calculate_total_salary(employees) == { \\"Alice\\": 3500.0, \\"Bob\\": 2480.0, \\"Charlie\\": 5700.0 } ``` # Functional Requirements - Identify and separate regular hours (up to 160 per month) and overtime hours (above 160 per month). - Calculate the total salary considering the regular hourly wage for up to 160 hours and 1.5 times the hourly wage for overtime hours. - Return the result as a dictionary with employee names as keys and their respective total monthly salary as values. # Edge Cases - Employees who worked 0 hours should have a total salary of 0. - Ensure the function handles employees whose hours worked are exactly on the boundary of regular and overtime (e.g., 160 hours). - Verify the function deals correctly with various hourly wage values, including boundary values (lower and upper limits). # Optimization Considerations Given the potential number of employees, ensure the function performs efficiently, particularly with large lists of employees. Avoid unnecessary computations and loops by directly computing the salaries based on the provided conditions.","solution":"from typing import List, Tuple, Dict def calculate_total_salary(employees: List[Tuple[str, int, float]]) -> Dict[str, float]: Calculates the total monthly salary for each employee, considering overtime pay. Parameters: employees (List[Tuple[str, int, float]]): A list of tuples where each tuple contains: - name (str): Employee\'s name - hours_worked (int): Hours worked in the month - hourly_wage (float): Employee\'s hourly wage Returns: Dict[str, float]: A dictionary where the keys are employee names and the values are their total monthly salary. salaries = {} for name, hours_worked, hourly_wage in employees: if hours_worked > 160: overtime_hours = hours_worked - 160 total_salary = (160 * hourly_wage) + (overtime_hours * hourly_wage * 1.5) else: total_salary = hours_worked * hourly_wage salaries[name] = total_salary return salaries"},{"question":"# Problem Statement You are provided with an implementation of a basic queue using two stacks. This queue has methods for enqueuing, dequeuing, and checking if it is empty. Your task is to implement an additional method that returns the front element of the queue without removing it, maintaining the properties of a queue. Given the class `QueueUsingStacks`, implement the method `peek` which returns the front element of the queue without dequeuing it. # Class and Method Specifications Class Signature ```python class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: pass def dequeue(self) -> int: pass def is_empty(self) -> bool: pass def peek(self) -> int: pass ``` Method Descriptions - `__init__(self)`: Initializes two empty stacks. - `enqueue(self, x: int) -> None`: Adds the element `x` to the end of the queue. - `dequeue(self) -> int`: Removes the element from the front of the queue and returns it. - `is_empty(self) -> bool`: Checks if the queue is empty and returns True if it is, False otherwise. - `peek(self) -> int`: Returns the element at the front of the queue without removing it. # Constraints - No constraints on the size of the queue or the integers enqueued. # Example ```python queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) # Call your peek method front_element = queue.peek() print(front_element) # Output: 1 # Ensure the front element is not removed dequeued_element = queue.dequeue() print(dequeued_element) # Output: 1 ``` # Notes - You must maintain the order of elements in the queue, ensuring FIFO (First In, First Out) behavior. - The `peek` method should not alter the state of the queue. - Make sure your implementation is efficient, particularly in terms of time complexity for common operations.","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: self.stack1.append(x) def dequeue(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() if self.stack2 else None def is_empty(self) -> bool: return not self.stack1 and not self.stack2 def peek(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] if self.stack2 else None"},{"question":"# Array Rotation Scenario: You are tasked with developing a utility function for an application that processes large datasets. One common operation is rotating an array (or list) of integers either to the left or to the right by a given number of steps. # Task Write a Python function that rotates the array to the left or right by a specified number of steps. The direction of rotation and the number of steps should be flexible, allowing the function to handle various patterns of usage. Function Signature ```python def rotate_array(arr: list, direction: str, steps: int) -> list: pass ``` Input * `arr` (list): A list of integers. * `direction` (str): A string that specifies the direction of rotation. It can be either \\"left\\" or \\"right\\". * `steps` (int): A non-negative integer specifying the number of steps to rotate. Output * Returns a new list of integers that is the result of rotating the input array in the specified direction by the given number of steps. Constraints * `0 <= len(arr) <= 10^5` * `steps >= 0` * `direction` must be either \\"left\\" or \\"right\\". Examples ```python >>> rotate_array([1, 2, 3, 4, 5], \'left\', 2) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], \'right\', 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], \'left\', 0) [1, 2, 3, 4, 5] >>> rotate_array([], \'right\', 5) [] ``` Validation and Error Handling Your function should raise appropriate exceptions for the following conditions: * If `direction` is not \\"left\\" or \\"right\\", raise `Exception: Direction must be either \\"left\\" or \\"right\\"` * If `steps` is negative, raise `Exception: Number of steps must be non-negative` Explanation - Rotating the array `[1, 2, 3, 4, 5]` to the left by 2 steps results in `[3, 4, 5, 1, 2]`. - Rotating the array `[1, 2, 3, 4, 5]` to the right by 2 steps results in `[4, 5, 1, 2, 3]`. - Rotating the array `[1, 2, 3, 4, 5]` to the left by 0 steps leaves it unchanged as `[1, 2, 3, 4, 5]`. - Rotating an empty array always returns an empty array. Ensure your function is efficient and handles both small and large inputs correctly.","solution":"def rotate_array(arr: list, direction: str, steps: int) -> list: Rotates the array to the left or right by a specified number of steps. Parameters: arr (list): A list of integers. direction (str): The direction of rotation (\\"left\\" or \\"right\\"). steps (int): The number of steps to rotate. Returns: list: The rotated array. if direction not in (\\"left\\", \\"right\\"): raise Exception(\\"Direction must be either \'left\' or \'right\'\\") if steps < 0: raise Exception(\\"Number of steps must be non-negative\\") n = len(arr) if n == 0: return arr steps = steps % n # to handle cases where steps > n if direction == \\"left\\": return arr[steps:] + arr[:steps] elif direction == \\"right\\": return arr[-steps:] + arr[:-steps]"},{"question":"# Programming Assessment Question **Title:** First Missing Positive Integer in an Array **Objective**: Write a function that finds the smallest positive integer that is missing from an unsorted array of integers. **Requirements**: - **Function Signature:** `def first_missing_positive(nums: List[int]) -> int` **Input**: - `nums` (list of integers): An unsorted list of integers which can be both positive and negative. **Output**: - Returns the smallest positive integer that does not appear in the array. **Constraints**: - The list can be empty, and in this case, the smallest missing positive integer is `1`. - The solution should be optimized to run in O(n) time and use constant extra space. **Examples**: ```python >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([]) 1 >>> first_missing_positive([1, 100, 1000]) 2 ``` **Performance**: Your solution should be efficient, leveraging in-place operations to achieve a linear run-time complexity and minimal extra space usage. **Scenario**: Imagine you are dealing with an array of integers that may be jumbled and contain irrelevant values, including negative numbers and duplicates. Your task is to identify the smallest positive integer that is not present in the array. This problem tests your ability to handle array manipulation, optimize for time complexity, and manage edge cases effectively. **HINT**: 1. Consider using index-based placement and swapping to position values correctly within the array. 2. Focus on arranging the numbers such that each positive number is in the index equivalent to its value minus one, which will help in quickly identifying the missing positive integer.","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Problem Statement Imagine you are implementing a social networking platform. You need to handle the functionality of identifying mutual friends between two users. Write a function `mutual_friends(user1: str, user2: str, friends: dict) -> list` that takes in the usernames of two users and a dictionary representing the friends of each user, and returns a list of usernames that are mutual friends of both users. # Function Signature ```python def mutual_friends(user1: str, user2: str, friends: dict) -> list: pass ``` # Input: - `user1` (str): A string representing the username of the first user. - `user2` (str): A string representing the username of the second user. - `friends` (dict): A dictionary where the keys are usernames (str), and the values are lists of usernames (str) representing the friends of the corresponding key. # Output: - A list of usernames (str) that are mutual friends of both `user1` and `user2`. # Constraints: - Users have unique usernames. - A user cannot be a friend of themselves. - The input dictionary can have up to 1000 users, and each user can have up to 500 friends. - All usernames are alphanumeric strings. # Example Given the following dictionary representing users and their friends: ```python friends = { \'Alice\': [\'Bob\', \'Charlie\', \'David\'], \'Bob\': [\'Alice\', \'Charlie\', \'Eve\'], \'Charlie\': [\'Alice\', \'Bob\', \'David\', \'Eve\'], \'David\': [\'Alice\', \'Charlie\'], \'Eve\': [\'Bob\', \'Charlie\'] } ``` The result would be: ```python mutual_friends(\'Alice\', \'Bob\', friends) -> [\'Charlie\'] mutual_friends(\'Alice\', \'Charlie\', friends) -> [\'Bob\', \'David\'] mutual_friends(\'Bob\', \'Eve\', friends) -> [\'Charlie\'] ``` # Notes: - Ensure that the output list is sorted in alphabetical order. - Handle cases where a user may not have any friends or where there are no mutual friends between the two users gracefully. In such cases, return an empty list. - The solution should be efficient even for the maximum constraints.","solution":"def mutual_friends(user1: str, user2: str, friends: dict) -> list: Returns a list of usernames that are mutual friends of both user1 and user2, sorted alphabetically. if user1 not in friends or user2 not in friends: return [] mutuals = set(friends[user1]).intersection(set(friends[user2])) return sorted(mutuals)"},{"question":"# Sum of Unique Elements in a List Problem Statement: You need to implement a function that calculates the sum of all unique elements in a list. The function should iterate through the given list and add up only those elements that appear exactly once. Function Signature: ```python def sum_unique_elements(lst: list) -> int: Computes the sum of all elements that appear exactly once in the list. Args: lst (list): The list of integers. Returns: int: The sum of all unique elements in the list. ``` Input: * `lst` (list): A list of integers, which can be empty or contain negative numbers, zero, and positive numbers. Output: * Return an integer representing the sum of all unique elements within the list. If there are no unique elements, return 0. Constraints: * The list can contain up to 1000 elements. Examples: ```python >>> sum_unique_elements([1, 2, 2, 3, 4, 4, 5]) 9 # (1 + 3 + 5) >>> sum_unique_elements([0, -1, -1, 2]) 2 # (0 + 2) >>> sum_unique_elements([]) 0 # No elements in the list >>> sum_unique_elements([7, 7, 7, 7]) 0 # No unique elements in the list >>> sum_unique_elements([4, 5, 6, 5, 6]) 4 # Only 4 is unique ``` # Guidelines: 1. Use data structures that allow effective counting of elements, such as dictionaries. 2. Iterate through the list to identify and sum unique elements. 3. Ensure the solution handles edge cases, such as empty lists or lists with all duplicate elements. 4. Write a clear and efficient algorithm to maintain good performance with the maximum constraint of 1000 elements.","solution":"def sum_unique_elements(lst: list) -> int: Computes the sum of all elements that appear exactly once in the list. Args: lst (list): The list of integers. Returns: int: The sum of all unique elements in the list. from collections import Counter element_count = Counter(lst) unique_sum = 0 for element, count in element_count.items(): if count == 1: unique_sum += element return unique_sum"},{"question":"# Sorting Words by Length and Lexicographical Order Implement a function that takes a list of words and returns a list of words sorted by their length in ascending order. If two words have the same length, they should be sorted lexicographically. # Function Signature ```python def sort_words(words: list[str]) -> list[str]: ``` # Input * `words` (List[str]): A list of words, where each word is a non-empty string containing only lowercase letters. # Output * A list of words sorted first by length, and then lexicographically for words of the same length. # Constraints * The number of words in the list can range from `1` to `10^5`. * Each word in the list can have a length from `1` to `100`. # Example ```python >>> sort_words([\\"apple\\", \\"bat\\", \\"batman\\", \\"apricot\\", \\"batman\\", \\"ball\\"]) [\'bat\', \'bat\', \'ball\', \'apple\', \'apricot\', \'batman\', \'batman\'] ``` # Description: Your task is to write a function `sort_words` that takes a list of words and returns them sorted primarily by their length in ascending order, and if two words have the same length, they should be sorted lexicographically. Considerations: * The function needs to handle large lists efficiently. * Words are composed of lowercase letters only, and there are no empty strings in the input list. * The output should consistently respect the sorting rules specified. The function must return the results in the correct order and be optimized for performance, given the constraints on the number of words and their lengths.","solution":"def sort_words(words): Sorts a list of words by their length in ascending order. If two words have the same length, they are sorted lexicographically. :param words: List of words to be sorted. :return: List of words sorted by length and lexicographically. return sorted(words, key=lambda word: (len(word), word))"},{"question":"# Longest Common Substring Write a function that returns the length of the longest common substring between two given strings (A) and (B). A substring is a contiguous sequence of characters within a string. Function Signature ```python def longest_common_substring_length(A: str, B: str) -> int: Returns the length of the longest common substring between two given strings. :param A: str - First input string :param B: str - Second input string :return: int - The length of the longest common substring ``` Input - A string (A) (1 ≤ |A| ≤ 1000): The first input string. - A string (B) (1 ≤ |B| ≤ 1000): The second input string. Output - Return the length of the longest common substring between (A) and (B). Constraints - The function should efficiently handle the input size within the given constraints. - Analyze and utilize appropriate algorithms to ensure optimal performance. Example ```python >>> longest_common_substring_length(\\"abcde\\", \\"abfce\\") 2 >>> longest_common_substring_length(\\"geeksforgeeks\\", \\"geeksquiz\\") 5 ``` Given the strings \\"abcde\\" and \\"abfce\\", the longest common substring is \\"ab\\", which has a length of 2. For \\"geeksforgeeks\\" and \\"geeksquiz\\", the longest common substring is \\"geeks\\", which has a length of 5.","solution":"def longest_common_substring_length(A: str, B: str) -> int: Returns the length of the longest common substring between two given strings. :param A: str - First input string :param B: str - Second input string :return: int - The length of the longest common substring n = len(A) m = len(B) # Create a 2D array to store lengths of longest common suffixes of substrings # LCSubstr[i][j] contains the length of longest common suffix of A[0...i-1] and B[0...j-1] LCSubstr = [[0] * (m + 1) for i in range(n + 1)] # To store the length of the longest common substring longest_length = 0 # Building the LCSubstr matrix in bottom-up fashion for i in range(1, n + 1): for j in range(1, m + 1): if A[i - 1] == B[j - 1]: LCSubstr[i][j] = LCSubstr[i - 1][j - 1] + 1 longest_length = max(longest_length, LCSubstr[i][j]) else: LCSubstr[i][j] = 0 return longest_length"},{"question":"# Coding Assessment Question Problem Description Write a function that takes an integer `n` and returns a list of all prime numbers less than `n`. A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. Function Signature ```python def primes_below(n: int) -> list: ``` Input - An integer `n` (2 ≤ n ≤ 10^6) representing the upper limit (exclusive). Output - A list containing all the prime numbers below `n`. Example ```python >>> primes_below(10) [2, 3, 5, 7] >>> primes_below(20) [2, 3, 5, 7, 11, 13, 17, 19] ``` Constraints - The function should handle large inputs efficiently. - Utilize an efficient algorithm such as the Sieve of Eratosthenes for optimal performance. - Aim for a time complexity of O(n log log n) and a space complexity of O(n). Additional Notes 1. Consider edge cases where `n` is just above the smallest prime numbers. 2. Ensure the function is optimized for scenarios with very large limits. 3. Write clear and maintainable code while adhering to best practices in algorithm design.","solution":"def primes_below(n: int) -> list: Returns a list of all prime numbers less than n. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"# Problem Statement You are developing a simulation for a set of basic string operations. The first task is to implement a function that checks if two strings are anagrams of each other. Two strings are considered anagrams if they contain the same characters in the same frequency, but possibly in a different order. Create a function `are_anagrams(s1: str, s2: str) -> bool` that takes two strings `s1` and `s2` as input and returns `True` if they are anagrams, and `False` otherwise. # Input - Two strings `s1` and `s2`, each consisting of lowercase English letters. # Output - The function should return `True` if `s1` and `s2` are anagrams, and `False` otherwise. # Constraints - The length of each string will be between 1 and 1000. # Example - `are_anagrams(\\"listen\\", \\"silent\\")` should return `True`. - `are_anagrams(\\"hello\\", \\"world\\")` should return `False`. # Implementation Note Ensure that your implementation efficiently compares the character frequencies of the two strings using appropriate data structures such as dictionaries or counters.","solution":"from collections import Counter def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams, False otherwise. # Use Counter from collections module to count character frequencies return Counter(s1) == Counter(s2)"},{"question":"# Question: Implement a Multi-Head Self-Attention Mechanism with Gradient Computation You have been tasked with implementing a multi-head self-attention mechanism, which is a core component of the transformer architecture in natural language processing. Additionally, the function should compute the gradients of the output with respect to the input. Task Implement the function `multi_head_self_attention_with_gradient(inputs, num_heads, d_k, d_v)` in Python. This function should return both the multi-head self-attention output and the gradients. Function Details - **Input**: - `inputs` (np.ndarray): Input tensor of shape `(batch_size, seq_length, d_model)`. - `num_heads` (int): Number of attention heads. - `d_k` (int): Dimensionality of the queries and keys. - `d_v` (int): Dimensionality of the values. - **Output**: - A tuple consisting of: - `output` (np.ndarray): The output of the multi-head self-attention mechanism of shape `(batch_size, seq_length, d_model)`. - `gradients` (np.ndarray): Array of gradients of shape `(batch_size, seq_length, d_model)` with respect to the input `inputs`. Constraints - The dimensionality of the input (d_model) must be divisible by the number of heads (num_heads). - Ensure to add necessary padding and masking for attention scores where appropriate. - Use suitable initializers for the query, key, and value weight matrices. Example ```python inputs = np.random.rand(2, 5, 8) # 2 batches, 5 sequence length, 8 dimensionality num_heads = 2 d_k = 4 d_v = 4 output, gradients = multi_head_self_attention_with_gradient(inputs, num_heads, d_k, d_v) print(output.shape) # Expected Output: (2, 5, 8) print(gradients.shape) # Expected Output: (2, 5, 8) ``` Additional Notes - Perform any necessary reshaping from `(batch_size, seq_length, d_model)` to handle multi-head computation. - Implement the attention score calculation carefully to ensure gradients are computed correctly. - Test the implementation with different batch sizes, sequence lengths, and model dimensions to ensure robustness.","solution":"import numpy as np def multi_head_self_attention_with_gradient(inputs, num_heads, d_k, d_v): Perform multi-head self-attention mechanism and compute gradients with respect to the input. Args: inputs: Input tensor of shape (batch_size, seq_length, d_model). num_heads: Number of attention heads. d_k: Dimensionality of the queries and keys. d_v: Dimensionality of the values. Returns: A tuple (output, gradients). - output: The multi-head self-attention output of shape (batch_size, seq_length, d_model). - gradients: Gradients with respect to the input, of shape (batch_size, seq_length, d_model). batch_size, seq_length, d_model = inputs.shape assert d_model % num_heads == 0, \\"The dimensionality of the model (d_model) must be divisible by the number of heads.\\" d_head = d_model // num_heads def split_heads(x, batch_size, num_heads, seq_length, d_head): return x.reshape(batch_size, seq_length, num_heads, d_head).transpose(0, 2, 1, 3) def combine_heads(x, batch_size, seq_length, d_model): return x.transpose(0, 2, 1, 3).reshape(batch_size, seq_length, d_model) # Initialize weight matrices W_q = np.random.rand(d_model, num_heads * d_k) W_k = np.random.rand(d_model, num_heads * d_k) W_v = np.random.rand(d_model, num_heads * d_v) W_o = np.random.rand(num_heads * d_v, d_model) Q = np.dot(inputs, W_q) K = np.dot(inputs, W_k) V = np.dot(inputs, W_v) Q = split_heads(Q, batch_size, num_heads, seq_length, d_k) K = split_heads(K, batch_size, num_heads, seq_length, d_k) V = split_heads(V, batch_size, num_heads, seq_length, d_v) scaled_attention_logits = np.matmul(Q, K.transpose(0, 1, 3, 2)) / np.sqrt(d_k) attention_weights = np.exp(scaled_attention_logits) / np.sum(np.exp(scaled_attention_logits), axis=-1, keepdims=True) context_layer = np.matmul(attention_weights, V) context_layer = combine_heads(context_layer, batch_size, seq_length, num_heads * d_v) output = np.dot(context_layer, W_o) # Compute gradients gradients = np.zeros_like(inputs) # A placeholder for gradient computation logic as this is highly dependent on differentiation backend/framework return output, gradients"},{"question":"# Task: Weather Data Aggregator Scenario You are working on a weather application that provides users with summarized weather data for a specific city over a week. Your task is to write a function that fetches weather data from a weather API, processes it, and returns a summarized report. Construct a function `weekly_weather_summary(city: str) -> str` which, given a city name, returns a summary of the weather for the upcoming week. The summary should include the average temperature, total precipitation, and a list of days with weather descriptions. Input - `city` (str): A valid city name (e.g., \\"London\\", \\"New York\\"). Output - Returns a summary string for the week\'s weather, including the average temperature, total precipitation, and a list of days with weather descriptions (e.g., \\"Average Temp: 20°C, Total Precipitation: 30mm, Weather: [\'Sunny\', \'Rainy\', \'Cloudy\']\\"). - Returns an error message string if the city name is invalid or if the weather data cannot be found (e.g., \\"Invalid city name\\" or \\"Weather data not found\\"). Constraints - The function should complete within a reasonable time (consider a network timeout of 10 seconds). - Assume the `requests` library is available. Performance Requirements - The function should handle up to 100 weather data requests per hour without significant performance degradation. # Implementation Implement the function following these requirements and consider the described edge cases, performance bottlenecks, and potential error scenarios. Example ```python print(weekly_weather_summary(\\"London\\")) # Returns a summary string, e.g., \\"Average Temp: 15°C, Total Precipitation: 25mm, Weather: [\'Sunny\', \'Cloudy\', \'Rainy\', \'Sunny\', \'Rainy\', \'Cloudy\', \'Sunny\']\\" print(weekly_weather_summary(\\"INVALID\\")) # Returns an error message, e.g., \\"Invalid city name\\" ```","solution":"import requests def weekly_weather_summary(city: str) -> str: Fetches weather data for a week and summarizes it. Args: city (str): The name of the city. Returns: str: A summary of the weather for the week or an error message. # Simulated API endpoint and key, these would be replaced with real ones. API_KEY = \'your_api_key\' API_ENDPOINT = f\'http://api.weatherapi.com/v1/forecast.json?key={API_KEY}&q={city}&days=7\' try: response = requests.get(API_ENDPOINT, timeout=10) if response.status_code == 200: data = response.json() forecast_days = data[\'forecast\'][\'forecastday\'] total_temp = 0 total_precipitation = 0 descriptions = [] for day in forecast_days: total_temp += day[\'day\'][\'avgtemp_c\'] total_precipitation += day[\'day\'][\'totalprecip_mm\'] descriptions.append(day[\'day\'][\'condition\'][\'text\']) avg_temp = total_temp / len(forecast_days) summary = (f\\"Average Temp: {avg_temp:.1f}°C, Total Precipitation: {total_precipitation}mm, \\" f\\"Weather: {descriptions}\\") return summary else: return \\"Invalid city name or could not retrieve weather data\\" except (requests.exceptions.RequestException, KeyError): return \\"Weather data not found or another error occurred\\""},{"question":"# Problem Statement In this task, you are required to develop a function that finds the nth number in the Fibonacci sequence. The goal is to assess your ability to implement iterative algorithms and handle large results in Python. # Function Signature ```python def nth_fibonacci(n: int) -> int: This function takes an integer n and returns the nth number in the Fibonacci sequence. :param n: An integer representing the position in the Fibonacci sequence. :return: An integer representing the nth Fibonacci number. ``` # Expected Input and Output - **Input**: A single integer `n` where 0 ≤ n ≤ 10000. - Example: `nth_fibonacci(15)` - **Output**: A single integer representing the nth Fibonacci number. - Example: `610` (since the 15th Fibonacci number is 610) # Constraints and Limitations 1. Ensure that the input is a non-negative integer and within the specified range (0 ≤ n ≤ 10000). 2. Handle edge cases, particularly: - When `n` is 0 (should return 0). - When `n` is 1 (should return 1). - Extreme values such as `10000` should be handled efficiently. # Example Scenarios 1. **Scenario 1**: - Input: `nth_fibonacci(0)` - Output: `0` 2. **Scenario 2**: - Input: `nth_fibonacci(1)` - Output: `1` 3. **Scenario 3**: - Input: `nth_fibonacci(20)` - Output: `6765` 4. **Scenario 4**: - Input: `nth_fibonacci(100)` - Output: `354224848179261915075` # Performance Requirements Ensure your implementation is efficient and can handle the input size within a reasonable time frame. The constraints guarantee calculations with large numbers, so consider iterative techniques and optimized Fibonacci sequence algorithms to avoid excessive computational cost.","solution":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number. :param n: An integer representing the position in the Fibonacci sequence. :return: An integer representing the nth Fibonacci number. if n < 0: raise ValueError(\\"Input should be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Description You are required to implement a system for managing tasks in a to-do list, which allows tasks to be added, marked as completed, and retrieved based on their status. This will involve handling tasks via unique IDs, along with their description and completion status. # Requirements 1. **Function 1: `add_task`** - **Input**: A dictionary `tasks` and a string `description`. - **Output**: None. - **Behavior**: Add a new task to the `tasks` dictionary with a unique ID (integer starting from 1) and set its completion status to `False`. 2. **Function 2: `mark_completed`** - **Input**: A dictionary `tasks` and an integer `task_id`. - **Output**: None. - **Behavior**: Mark the specified task as completed by setting its completion status to `True`. 3. **Function 3: `get_tasks`** - **Input**: A dictionary `tasks` and a boolean `completed`. - **Output**: A list of strings (task descriptions). - **Behavior**: Return a list of task descriptions that match the completion status specified by the `completed` parameter. If `completed` is `True`, return only the tasks that are completed; otherwise, return only the tasks that are not completed. 4. **Function 4: `generate_summary`** - **Input**: A dictionary `tasks`. - **Output**: A string summarizing the task list. - **Behavior**: Generate a summary of the task list, indicating the number of tasks, the number of completed tasks, and the number of pending tasks. # Input and Output Formats - Inputs will be managed via function calls with appropriate parameters. - Outputs will be in the form of return values from the functions. # Example ```python tasks = {} add_task(tasks, \\"Buy groceries\\") add_task(tasks, \\"Read a book\\") add_task(tasks, \\"Write code\\") mark_completed(tasks, 2) print(get_tasks(tasks, completed=False)) # Output: [\'Buy groceries\', \'Write code\'] print(get_tasks(tasks, completed=True)) # Output: [\'Read a book\'] print(generate_summary(tasks)) # Output: \'Total tasks: 3, Completed: 1, Pending: 2\' ``` # Constraints - Task descriptions will be non-empty strings. - Task IDs will be unique and increment sequentially starting from 1. - The `tasks` dictionary will initially be empty and managed within the function calls. # Task Implement these functions in Python to create and manage the to-do list as described.","solution":"def add_task(tasks, description): Adds a new task to the tasks dictionary with a unique ID starting from 1 and set its completion status to False. task_id = len(tasks) + 1 tasks[task_id] = {\'description\': description, \'completed\': False} def mark_completed(tasks, task_id): Marks the specified task as completed by setting its completion status to True. if task_id in tasks: tasks[task_id][\'completed\'] = True def get_tasks(tasks, completed): Returns a list of task descriptions that match the completion status specified by the completed parameter. return [task[\'description\'] for task in tasks.values() if task[\'completed\'] == completed] def generate_summary(tasks): Generates a summary of the task list, indicating the number of tasks, completed tasks, and pending tasks. total_tasks = len(tasks) completed_tasks = len([task for task in tasks.values() if task[\'completed\']]) pending_tasks = total_tasks - completed_tasks return f\'Total tasks: {total_tasks}, Completed: {completed_tasks}, Pending: {pending_tasks}\'"},{"question":"# Rotating Logger Application Scenario You are working on a logging system for a server. The logger stores log messages with their associated timestamps. To efficiently manage memory and prevent infinite growth, the logger employs a rotating buffer where it overwrites the oldest logs once a specified capacity is reached. Task You are required to implement functionalities of a RotatingLogger. Function Signature ```python class RotatingLogger: def __init__(self, capacity: int) -> None: pass def log(self, timestamp: int, message: str) -> None: pass def get_logs(self) -> List[Tuple[int, str]]: pass ``` Requirements 1. **Initialization**: Initialize the logger with a specified capacity. 2. **Log**: Add a new log entry with a timestamp and message. * If the number of log entries has reached the specified capacity, overwrite the oldest log entry with the new one. 3. **Get Logs**: Retrieve the list of log entries in the order they were logged (oldest first). Constraints * 1 ≤ capacity ≤ 10^5 * 1 ≤ timestamp ≤ 10^9 * Each `log` and `get_logs` operation should run in O(1) average time complexity. Examples ```python # Example 1 logger = RotatingLogger(3) # Logger capacity of 3 logger.log(1, \\"First log\\") # Logs = [(1, \\"First log\\")] logger.log(2, \\"Second log\\") # Logs = [(1, \\"First log\\"), (2, \\"Second log\\")] logger.log(3, \\"Third log\\") # Logs = [(1, \\"First log\\"), (2, \\"Second log\\"), (3, \\"Third log\\")] logger.get_logs() # Returns: [(1, \\"First log\\"), (2, \\"Second log\\"), (3, \\"Third log\\")] # Example 2 logger = RotatingLogger(2) # Logger capacity of 2 logger.log(4, \\"Log A\\") # Logs = [(4, \\"Log A\\")] logger.log(5, \\"Log B\\") # Logs = [(4, \\"Log A\\"), (5, \\"Log B\\")] logger.log(6, \\"Log C\\") # Logs = [(5, \\"Log B\\"), (6, \\"Log C\\")] (oldest log (4, \\"Log A\\") is overwritten) logger.get_logs() # Returns: [(5, \\"Log B\\"), (6, \\"Log C\\")] logger.log(7, \\"Log D\\") # Logs = [(6, \\"Log C\\"), (7, \\"Log D\\")] (oldest log (5, \\"Log B\\") is overwritten) logger.get_logs() # Returns: [(6, \\"Log C\\"), (7, \\"Log D\\")] ```","solution":"from typing import List, Tuple class RotatingLogger: def __init__(self, capacity: int) -> None: self.capacity = capacity self.buffer = [] self.index = 0 def log(self, timestamp: int, message: str) -> None: if len(self.buffer) < self.capacity: self.buffer.append((timestamp, message)) else: self.buffer[self.index] = (timestamp, message) self.index = (self.index + 1) % self.capacity def get_logs(self) -> List[Tuple[int, str]]: if len(self.buffer) < self.capacity: return self.buffer[:] return self.buffer[self.index:] + self.buffer[:self.index]"},{"question":"Matrix Rotation by 90 Degrees # Context: Rotating a matrix by 90 degrees is a common operation in image processing and computer graphics. The task is to rotate a given ( n times n ) matrix by 90 degrees clockwise. # Task: Implement a function `rotate_matrix(matrix: List[List[int]]) -> None`. This function should modify the matrix in place to achieve the 90-degree clockwise rotation. # Function Signature: ```python from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: ``` # Input: * **matrix (List[List[int]])**: A ( n times n ) matrix (2D list of integers) where ( 1 le n le 1000 ) and each element is a non-negative integer (0 le text{matrix[i][j]} le 10^6). # Output: * **None**: The matrix should be modified in place to its 90-degree rotated version. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix) assert matrix == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` # Notes: To rotate the matrix by 90 degrees clockwise, consider the following steps: 1. **Transpose the matrix**: Swap element ([i][j]) with ([j][i]). 2. **Reverse each row**: Reverse the elements in each row. Ensure that you handle edge cases such as an empty matrix or a matrix with minimal size. Good luck! Optimize your solution for large matrices to remain within acceptable time limits.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"**Context**: Sorting algorithms are a fundamental topic in computer science, often used to arrange data in a specified order. One common sorting algorithm is Merge Sort, which employs a divide-and-conquer strategy to sort elements efficiently. **Objective**: Your task is to implement the Merge Sort algorithm. Given an input list of integers, the function should return a new list with the elements sorted in non-decreasing order. Implementing this function will help you understand recursion, as well as the efficiency of D&C (Divide and Conquer) algorithms. # Task Description: Implement the function `merge_sort(arr: List[int]) -> List[int]` that sorts an array of integers using the Merge Sort algorithm. # Input Format: *A single argument: `arr` (type: `List[int]`). The list of integers that needs to be sorted. # Output Format: * Returns a `List[int]` where the elements of the input array are sorted in non-decreasing order. # Constraints: 1. The input list can have up to (10^6) elements. 2. The input list can contain both positive and negative integers, including zero. 3. Aim for an efficient implementation with (O(n log n)) time complexity. # Examples: ```python # Example 1 arr = [38, 27, 43, 3, 9, 82, 10] print(merge_sort(arr)) # Output: [3, 9, 10, 27, 38, 43, 82] # Example 2 arr = [-5, -10, 0, -3, 8, 5, -1, 10] print(merge_sort(arr)) # Output: [-10, -5, -3, -1, 0, 5, 8, 10] ```","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers in non-decreasing order using the Merge Sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Context You are now familiar with sorting algorithms and their various implementations. Sorting is a fundamental operation in computer science, being the backbone of many algorithms and applications. # Problem Your task is to implement a sorting algorithm that sorts an array of integers in ascending order. Additionally, implement a function that sorts an array of strings based on their lengths, in ascending order. If two strings have the same length, they should remain in their original relative order (i.e., maintain stability). # Task 1. Implement the function `sort_integers(arr: List[int]) -> List[int]` which sorts an array of integers in ascending order. 2. Implement the function `sort_by_length(arr: List[str]) -> List[str]` which sorts an array of strings based on their lengths in ascending order. # Requirements 1. **Function 1**: `sort_integers` - **Input**: A list of integers `arr`. (0 ≤ len(arr) ≤ (10^5), (|arr_i| ≤ 10^9)) - **Output**: Returns a list of integers sorted in ascending order. 2. **Function 2**: `sort_by_length` - **Input**: A list of strings `arr`. (0 ≤ len(arr) ≤ (10^5), 0 ≤ len(arr_i) ≤ (10^3)) - **Output**: Returns a list of strings sorted by their lengths in ascending order. - **Constraints**: - Maintain the relative order of strings with the same length. # Examples ```python # Function 1 assert sort_integers([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert sort_integers([]) == [] assert sort_integers([0]) == [0] assert sort_integers([10, -3, 8, 7, -1]) == [-3, -1, 7, 8, 10] assert sort_integers([-2, -2, -2]) == [-2, -2, -2] # Function 2 assert sort_by_length([\\"apple\\", \\"banana\\", \\"pear\\", \\"kiwi\\"]) == [\\"pear\\", \\"kiwi\\", \\"apple\\", \\"banana\\"] assert sort_by_length([]) == [] assert sort_by_length([\\"a\\"]) == [\\"a\\"] assert sort_by_length([\\"two\\", \\"one\\", \\"three\\", \\"four\\"]) == [\\"two\\", \\"one\\", \\"four\\", \\"three\\"] assert sort_by_length([\\"short\\", \\"a\\", \\"bit\\", \\"longer\\", \\"longest\\"]) == [\\"a\\", \\"bit\\", \\"short\\", \\"longer\\", \\"longest\\"] ```","solution":"from typing import List def sort_integers(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order. :param arr: List of integers. :return: List of integers sorted in ascending order. return sorted(arr) def sort_by_length(arr: List[str]) -> List[str]: Sorts a list of strings based on their lengths in ascending order. Maintains the relative order of strings with the same length. :param arr: List of strings. :return: List of strings sorted by their lengths in ascending order. return sorted(arr, key=len)"},{"question":"# Problem Statement You are given a matrix of integers `matrix` of size `m x n`. Your task is to find the maximum sum of any hourglass in the matrix. An hourglass is defined as a subset of values with indices falling in this pattern in the matrix: a b c d e f g Specifically, an hourglass consists of 7 values that are relatively arranged in the aforementioned structure. Implement the function `max_hourglass_sum(matrix: List[List[int]]) -> int` that returns the maximum sum of any hourglass in the matrix. # Input - A 2D list of integers `matrix` where `matrix` is of size `m x n` and `3 <= m,n <= 10^3`. # Output - An integer representing the maximum sum of any hourglass in the input matrix. # Example ```python >>> max_hourglass_sum([ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ]) 19 >>> max_hourglass_sum([ ... [-9, -9, -9, 1, 1, 1], ... [ 0, -9, 0, 4, 3, 2], ... [-9, -9, -9, 1, 2, 3], ... [ 0, 0, 8, 6, 6, 0], ... [ 0, 0, 0, -2, 0, 0], ... [ 0, 0, 1, 2, 4, 0] ... ]) 28 ``` # Constraints - The matrix will have at least `3` rows and `3` columns. - Each element of the matrix will be an integer between `-10^6` and `10^6`. # Performance Requirements - Your implementation should efficiently handle matrices up to the maximum given size. Ensure the solution avoids unnecessary computations and terminates within a reasonable amount of time. # Notes - Consider edge cases where the elements of the matrix are at their minimum or maximum values. - Be mindful of the matrix boundaries when calculating the sums of hourglasses to avoid out-of-bound errors.","solution":"from typing import List def max_hourglass_sum(matrix: List[List[int]]) -> int: max_sum = float(\'-inf\') rows = len(matrix) cols = len(matrix[0]) for i in range(rows - 2): for j in range(cols - 2): top = matrix[i][j] + matrix[i][j+1] + matrix[i][j+2] middle = matrix[i+1][j+1] bottom = matrix[i+2][j] + matrix[i+2][j+1] + matrix[i+2][j+2] hourglass_sum = top + middle + bottom max_sum = max(max_sum, hourglass_sum) return max_sum"},{"question":"# Context A logistics company uses a system that monitors the movements of its delivery drones. The drones need to report positions in the coordinate space after completing their delivery routes. The company needs a function to determine if a given route, consisting of a sequence of moves, brings the drone back to the starting point (the origin). # Problem Statement Write a function `is_back_to_origin(moves: str) -> bool` that takes a string of moves and returns `True` if the drone returns to the origin (0, 0) after completing its route and `False` otherwise. The moves are represented by characters: \'U\' (up), \'D\' (down), \'L\' (left), and \'R\' (right). # Function Signature ```python def is_back_to_origin(moves: str) -> bool: pass ``` # Input 1. `moves` - a string consisting of characters \'U\', \'D\', \'L\', \'R\' that represent the moves of the drone. # Output * A boolean value: `True` if the drone returns to the origin, `False` otherwise. # Examples 1. `is_back_to_origin(\\"UD\\")` should return `True`. 2. `is_back_to_origin(\\"LL\\")` should return `False`. 3. `is_back_to_origin(\\"URURDLDL\\")` should return `True`. 4. `is_back_to_origin(\\"RLUUDD\\")` should return `True`. # Constraints * The `moves` string will have a length between 1 and 10^4. # Notes * The function should be case-sensitive and only contain valid move characters (\'U\', \'D\', \'L\', \'R\'). * Consider using counters or coordinate tracking to determine the final position of the drone relative to the origin. * Optimize the function to handle the upper limit of the input size efficiently.","solution":"def is_back_to_origin(moves: str) -> bool: Determines if a given route brings the drone back to the origin. Args: moves (str): A string of moves consisting of \'U\' (up), \'D\' (down), \'L\' (left), and \'R\' (right). Returns: bool: True if the route returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Coding Assessment Problem: You are tasked with building a function that can determine the maximum possible depth of a nested data structure while maintaining its integrity. The nested data structure is composed of dictionaries and lists, and your job is to parse through them to find the deepest nesting level. # Problem Statement **Objective**: Write a function `max_depth(nested_structure: Union[List, Dict]) -> int` that returns the maximum depth of the given nested data structure. # Input and Output: * **Input**: * `nested_structure` - A nested data structure (either a list or dictionary) which could contain further lists or dictionaries. * **Output**: * An integer representing the maximum depth of nesting within the given data structure. # Constraints: * The structure can be arbitrarily nested up to reasonable memory limits. * The input will always be either a list or a dictionary. * Your solution should be able to handle deeply nested structures efficiently. # Example: ```python def test_max_depth(): assert max_depth([1, [2, 3], [[4, 5], 6], [[[7]]]]) == 4 assert max_depth({\'a\': 1, \'b\': {\'c\': 2, \'d\': {\'e\': 3}}}) == 3 assert max_depth([]) == 1 assert max_depth({\'key\': []}) == 2 ``` # Requirements: 1. **Function Implementation**: Implement the required function with the provided signature. 2. **Complexity Consideration**: Consider the coding and complexity aspects to ensure it runs efficiently, even for highly nested structures. 3. **Edge Cases**: Consider cases where the structure is shallow or highly complex. # Additional Information: - You can assume lists and dictionaries do not reference themselves directly to avoid infinite loops. - Focus on measuring depth specifically, not the size of the structure or content types beyond lists and dictionaries. Good luck, and happy nesting!","solution":"from typing import Union, List, Dict def max_depth(nested_structure: Union[List, Dict]) -> int: Determine the maximum depth of a nested data structure composed of lists and dictionaries. if isinstance(nested_structure, list): # If it\'s a list, check the depth of each element if not nested_structure: # An empty list has a depth of 1 return 1 return 1 + max(max_depth(element) for element in nested_structure) elif isinstance(nested_structure, dict): # If it\'s a dict, check the depth of each value if not nested_structure: # An empty dictionary has a depth of 1 return 1 return 1 + max(max_depth(value) for value in nested_structure.values()) else: # If it\'s neither a list nor a dict, it has no further depth return 0"},{"question":"# Meeting Scheduler Problem Statement: You are managing schedules for a team of employees and need to find the longest possible meeting time that can be accommodated for all employees within a given day. Each employee\'s schedule is represented by a list of tuples, where each tuple indicates a block of time during which the employee is unavailable. Your task is to determine the maximum duration of a meeting that can be scheduled during the day when all employees are available. Function Signature: ```python def max_meeting_duration(schedules: List[List[Tuple[int, int]]], day_start: int, day_end: int) -> int: ``` Input: - `schedules`: A list of lists, where each inner list contains tuples `(start, end)` representing the time intervals when an employee is unavailable. Times are in a 24-hour format as integers (for example, `9` for 9:00 AM and `13` for 1:00 PM). - `day_start`: An integer representing the start of the working day (0 <= day_start < 24). - `day_end`: An integer representing the end of the working day (0 < day_end <= 24). Output: - Return the maximum duration (in hours) that a meeting can be scheduled when all employees are available. Constraints: - The list `schedules` will contain m employees (0 <= m <= 10^5). - Each inner list contains k unavailable times (0 <= k <= 10^5). - Each `(start, end)` pair will satisfy (day_start <= start < end <= day_end). Example: ```python >>> max_meeting_duration([[(9, 10), (12, 13)], [(10, 11), (13, 15)]], 9, 17) 2 >>> max_meeting_duration([[(9, 12)], [(13, 14)], [(14, 16)]], 9, 17) 1 ``` Notes: - You may wish to consolidate all the busy times into a single list of tuples and sort them to make calculations easier. - Consider edge cases such as when no employees have schedules, or the working day is extremely short. - Think about how to merge overlapping or adjacent intervals of busy times to get the true available slots. Write a function `max_meeting_duration` that implements this algorithm, taking into account the guidelines and constraints provided.","solution":"from typing import List, Tuple def max_meeting_duration(schedules: List[List[Tuple[int, int]]], day_start: int, day_end: int) -> int: busy_times = [interval for schedule in schedules for interval in schedule] if not busy_times: return day_end - day_start busy_times.sort() merged_busy_times = [] for start, end in busy_times: if merged_busy_times and merged_busy_times[-1][1] >= start: merged_busy_times[-1] = (merged_busy_times[-1][0], max(merged_busy_times[-1][1], end)) else: merged_busy_times.append((start, end)) max_meeting_duration = 0 previous_end = day_start for start, end in merged_busy_times: if previous_end < start: max_meeting_duration = max(max_meeting_duration, start - previous_end) previous_end = max(previous_end, end) max_meeting_duration = max(max_meeting_duration, day_end - previous_end) return max_meeting_duration"},{"question":"# Question: Calculate the Perimeter of Shapes in a Matrix You are tasked with calculating the perimeter of \\"shapes\\" in a binary matrix. In the matrix, 1s represent parts of a shape and 0s represent empty space. Shapes are formed by adjacent (horizontally or vertically connected) 1s. A shape\'s perimeter is calculated as the total number of edges around all 1s in the shape that are either next to a 0 or the boundary of the matrix. Function to Implement: **Perimeter Calculator** - Computes the total perimeter of shapes in the matrix. - **Input**: A 2D binary matrix `matrix: List[List[int]]`. - **Output**: `int` total perimeter of all shapes in the matrix. **Constraints**: - The matrix size will be `1 <= rows, cols <= 100`. - Matrix elements will be either 0 or 1. **Example:** Input: ```python matrix = [ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0] ] ``` Output: ```python 16 # The total perimeter of the shapes in the matrix ``` Implement the following function: ```python def calculate_perimeter(matrix: List[List[int]]) -> int: pass ``` Hint: - Treat each 1-cell separately to count contributions to the perimeter. - Use exploration methods to identify shapes and their boundary edges within the matrix.","solution":"def calculate_perimeter(matrix): rows, cols = len(matrix), len(matrix[0]) perimeter = 0 def is_water_or_boundary(r, c): return r < 0 or r >= rows or c < 0 or c >= cols or matrix[r][c] == 0 for r in range(rows): for c in range(cols): if matrix[r][c] == 1: # Check all four directions if is_water_or_boundary(r-1, c): perimeter += 1 if is_water_or_boundary(r+1, c): perimeter += 1 if is_water_or_boundary(r, c-1): perimeter += 1 if is_water_or_boundary(r, c+1): perimeter += 1 return perimeter"},{"question":"# Coding Assessment Question Scenario: Optimizing a Text Data Processing System using Multiprocessing You are enhancing a text data processing system by introducing parallel processing to handle large datasets efficiently. Your task is to implement a function that leverages multiprocessing to count the frequency of each word in a text file. Task Implement a function `word_frequency_counter(file_path)` that reads a text file, counts the frequency of each word, and returns a dictionary with words as keys and their respective counts as values. The function should use multiprocessing to process the text data in parallel. Function Signature ```python def word_frequency_counter(file_path: str) -> dict: Counts the frequency of each word in the text file located at file_path. Parameters: file_path (str): The path to the text file. Returns: dict: A dictionary with words as keys and their frequency count as values. ``` Input - `file_path`: A string representing the path to a text file. Output - A dictionary with words as keys and their frequency count as values. Constraints - Ensure the function handles large text files efficiently using multiprocessing. - Pay attention to concurrency issues, such as process synchronization. - Words should be considered case-insensitively (e.g., \\"Word\\" and \\"word\\" should be counted as the same word). - Handle punctuation and special characters appropriately (e.g., \\"word,\\" and \\"word\\" should be counted as the same word). - Implement error handling for file reading operations. Example ```python # Example function call file_path = \'sample.txt\' word_count = word_frequency_counter(file_path) print(word_count) # Output: {\'the\': 10, \'quick\': 5, \'brown\': 3, \'fox\': 7, \'jumps\': 4, \'over\': 4, \'lazy\': 3, \'dog\': 5} ``` Guidelines - Use the `multiprocessing` module to achieve parallel processing. - Process the text file in chunks to distribute the workload evenly across multiple processes. - Ensure proper synchronization between processes to avoid race conditions in updating the shared frequency dictionary. - Address edge cases such as empty files, files with only punctuation, and highly repetitive words. - Aim for a robust implementation that gracefully handles potential errors, such as file not found.","solution":"import multiprocessing from collections import Counter import re def process_chunk(chunk): Function to process each chunk of text, count the word frequencies, and return a Counter object. # Convert to lower case and use regex to remove punctuation clean_text = re.sub(r\'[^ws]\', \'\', chunk.lower()) words = clean_text.split() return Counter(words) def chunkify(file_path, size=1024*1024): Function to yield chunks of text from the file of given size. with open(file_path, \'r\', encoding=\'utf-8\') as file: while True: chunk = file.read(size) if not chunk: break yield chunk def word_frequency_counter(file_path: str) -> dict: Counts the frequency of each word in the text file located at file_path. Parameters: file_path (str): The path to the text file. Returns: dict: A dictionary with words as keys and their frequency count as values. pool = multiprocessing.Pool(multiprocessing.cpu_count()) chunks = list(chunkify(file_path)) word_counts = pool.map(process_chunk, chunks) pool.close() pool.join() # Combining all the Counter objects from word_counts total_counts = Counter() for count in word_counts: total_counts.update(count) return dict(total_counts)"},{"question":"Scenario: You are given a grid of characters, and you need to search for a specific word within this grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. You cannot use the same cell more than once in a single word construction. Problem Statement: Write a Python function `find_word_in_grid(grid: List[List[str]], word: str) -> bool` that returns `True` if the word exists in the grid, or `False` otherwise. The function must search for the exact sequence of characters from the word in the grid following the adjacency constraints mentioned. You are only allowed to move left, right, up, or down from a cell; diagonal movements are not allowed. Input: - `grid` (List[List[str]]): A 2D list of characters, where each sublist is a row in the grid. - `word` (str): The word you need to search for in the grid. Output: - Returns a boolean value: `True` if the word can be formed in the grid according to the rules, `False` otherwise. Constraints: - The grid consists of at least 1 row and 1 column and at most 100 rows and 100 columns. - Each cell in the grid contains only lowercase alphabets (\'a\' to \'z\'). - The word consists of at least 1 character and at most 100 characters. Example: ```python grid = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] word = \\"ABCCED\\" find_word_in_grid(grid, word) # Should return True word = \\"SEE\\" find_word_in_grid(grid, word) # Should return True word = \\"ABCB\\" find_word_in_grid(grid, word) # Should return False ``` Notes: - A backtracking algorithm is an effective approach for this problem. - Ensure to handle cases where the word is not found or the grid does not contain enough characters. - Be cautious about revisiting cells: once a cell is used in forming the word, it cannot be reused within the same search path. Implementation: ```python def find_word_in_grid(grid: List[List[str]], word: str) -> bool: rows, cols = len(grid), len(grid[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[i]: return False temp, grid[r][c] = grid[r][c], \'#\' # mark as visited found = (dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1)) grid[r][c] = temp # unmark return found for r in range(rows): for c in range(cols): if dfs(r, c, 0): return True return False ```","solution":"from typing import List def find_word_in_grid(grid: List[List[str]], word: str) -> bool: rows, cols = len(grid), len(grid[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[i]: return False temp, grid[r][c] = grid[r][c], \'#\' # mark as visited found = ( dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1) ) grid[r][c] = temp # unmark return found for r in range(rows): for c in range(cols): if dfs(r, c, 0): return True return False"},{"question":"Question: Implementing a Simple URL Shortener # Scenario You have been hired to create a lightweight URL shortening service for a growing startup. Your task is to develop a pair of functions to encode and decode URLs. A shortened URL should be in the form of `http://short.url/unique_key`, where `unique_key` is a unique identifier that you generate for each URL. # Implementation Requirements - Implement a `UrlShortener` class that has the following methods: - `encode(long_url: str) -> str`: Takes a long URL and returns a shortened URL. - `decode(short_url: str) -> str`: Takes a shortened URL and returns the original long URL. # Inputs and Outputs - `long_url` (str): A long URL to be shortened. - `short_url` (str): A shortened URL that needs to be decoded. # Function Behavior - `encode`: Generate a shortened URL with a unique key for the long URL and return it. - `decode`: Return the long URL associated with the given shortened URL. # Constraints - The input URLs must be valid and non-empty. - The unique keys must be unique for each long URL. - There should be a fixed base URL, for example, `http://short.url/`. # Example ```python shortener = UrlShortener() long_url = \\"https://www.example.com/some/long/path\\" short_url = shortener.encode(long_url) print(short_url) # Output might be: http://short.url/abc123 decoded_url = shortener.decode(short_url) print(decoded_url) # Output: https://www.example.com/some/long/path ``` # Edge Cases - Ensure that `decode` can handle cases where the short URL does not exist, and return an appropriate error or message. - Handle input validations within both methods appropriately. - The service should efficiently handle a large number of URLs and provide quick encoding and decoding. # Implementation Example Here is a possible implementation skeleton: ```python class UrlShortener: def __init__(self): self.url_mapping = {} self.base_url = \\"http://short.url/\\" self.counter = 0 def encode(self, long_url: str) -> str: unique_key = self._generate_unique_key() short_url = self.base_url + unique_key self.url_mapping[short_url] = long_url return short_url def decode(self, short_url: str) -> str: return self.url_mapping.get(short_url, \\"Error: URL not found\\") def _generate_unique_key(self) -> str: self.counter += 1 return base62_encode(self.counter) def base62_encode(number: int) -> str: # Helper function to encode a number to base62 string. # (Implementation detail omitted for brevity) pass # Example usage shortener = UrlShortener() long_url = \\"https://www.example.com/some/long/path\\" short_url = shortener.encode(long_url) print(short_url) decoded_url = shortener.decode(short_url) print(decoded_url) ```","solution":"import string class UrlShortener: def __init__(self): self.url_mapping = {} self.base_url = \\"http://short.url/\\" self.counter = 0 def encode(self, long_url: str) -> str: # Generate a unique key for the long URL unique_key = self._generate_unique_key() short_url = self.base_url + unique_key self.url_mapping[short_url] = long_url return short_url def decode(self, short_url: str) -> str: if short_url in self.url_mapping: return self.url_mapping[short_url] else: return \\"Error: URL not found\\" def _generate_unique_key(self) -> str: self.counter += 1 return self._base62_encode(self.counter) def _base62_encode(self, number: int) -> str: characters = string.digits + string.ascii_letters base = len(characters) encoded_string = [] while number > 0: number, remainder = divmod(number, base) encoded_string.append(characters[remainder]) return \'\'.join(reversed(encoded_string))"},{"question":"# Linked List Reversal and Rotation You are tasked with implementing and enhancing a linked list data structure with two critical functionalities: reversing the list and rotating the list clockwise by a given number of nodes. # Requirements: 1. **Linked List Implementation**: - Implement a singly linked list with basic functionalities including insertion and displaying the list. 2. **Reverse Linked List**: - Implement a method to reverse the linked list. 3. **Rotate Linked List**: - Implement a method to rotate the linked list to the right by k nodes. For example, if the list is `1 -> 2 -> 3 -> 4 -> 5` and k is 2, the list should become `4 -> 5 -> 1 -> 2 -> 3`. 4. **Edge Case Handling**: - Ensure the methods handle edge cases such as an empty list, rotating by zero nodes, or rotating by a number greater than the length of the list. 5. **Documentation**: - Provide thorough documentation and comments for each function explaining its purpose and logic. # Specification: - Input: Function for inserting a node (`insert`), function for reversing the list (`reverse`), and function for rotating the list (`rotate`). - Output: Print representation of the linked list before and after applying operations. - Constraints: - The linked list can have any number of nodes. - The rotate function should handle any integer value for k. - Performance: The implemented methods should be efficient and maintain a time complexity appropriate for linked list operations (e.g., O(n) where n is the number of nodes). # Deliverables: - Implement the linked list class with the specified methods. - Demonstrate the functionalities by creating a linked list, inserting nodes, reversing it, and rotating it by a specified number of nodes. - Provide sample print outputs verifying the correct functionality of the methods. ```python Linked List Reversal and Rotation Implementation class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): new_node = Node(data) if not self.head: self.head = new_node return last_node = self.head while last_node.next: last_node = last_node.next last_node.next = new_node def display(self): current = self.head while current: print(current.data, end=\\" -> \\") current = current.next print(\\"None\\") def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def rotate(self, k): if not self.head or k == 0: return # Compute length of the list length = 1 current = self.head while current.next: length += 1 current = current.next # Make the linked list circular current.next = self.head # Find the point of rotation rotate_point = length - k % length # Traverse to the point of rotation current = self.head for _ in range(rotate_point - 1): current = current.next # Break the circle and set new head self.head = current.next current.next = None if __name__ == \\"__main__\\": Example demonstrating the functionality. # Create a linked list and insert some nodes ll = LinkedList() for i in range(1, 6): ll.insert(i) print(\\"Original Linked List:\\") ll.display() # Reverse the linked list ll.reverse() print(\\"Reversed Linked List:\\") ll.display() # Rotate the linked list by 2 nodes ll.rotate(2) print(\\"Rotated Linked List by 2 nodes:\\") ll.display() ```","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): Inserts a new node with the given data at the end of the linked list. new_node = Node(data) if not self.head: self.head = new_node return last_node = self.head while last_node.next: last_node = last_node.next last_node.next = new_node def display(self): Prints the elements of the linked list. current = self.head elements = [] while current: elements.append(str(current.data)) current = current.next print(\\" -> \\".join(elements) + \\" -> None\\") def reverse(self): Reverses the linked list. prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def rotate(self, k): Rotates the linked list to the right by k nodes. if not self.head or k == 0: return # Compute length of the list length = 1 current = self.head while current.next: length += 1 current = current.next # Make the linked list circular current.next = self.head # Find the point of rotation rotate_point = length - k % length # Traverse to the point of rotation current = self.head for _ in range(rotate_point - 1): current = current.next # Break the circle and set new head self.head = current.next current.next = None"},{"question":"# Coding Assessment Question: Fibonacci Sequence Analysis Context The Fibonacci sequence is an important series in mathematics, defined by the recurrence relation F(n) = F(n-1) + F(n-2), with seed values F(0) = 0 and F(1) = 1. The sequence appears in various domains such as algorithm analysis, financial models, and computational studies. Task 1. **Function 1 - Fibonacci Check (FiboCheck)** Implement the function `is_fibonacci(number: int) -> bool:` which determines whether a given number is a Fibonacci number. - **Input**: An integer `number`. - **Output**: A boolean value `True` if the number is a Fibonacci number, otherwise `False`. 2. **Function 2 - nth Fibonacci** Implement the function `nth_fibonacci(n: int) -> int:` that returns the nth number in the Fibonacci sequence. - **Input**: An integer `n`. - **Output**: The nth Fibonacci number as an integer. - **Constraints**: `n` must be a non-negative integer (0 or greater). Requirements - For `is_fibonacci`, avoid generating the entire sequence up to the given number by using mathematical properties of Fibonacci numbers to check efficiently. - For `nth_fibonacci`, optimize your solution to handle larger values of `n` efficiently (for example, up to n = 30). Examples ```python # Example for is_fibonacci assert is_fibonacci(8) == True assert is_fibonacci(10) == False assert is_fibonacci(21) == True # Example for nth_fibonacci assert nth_fibonacci(0) == 0 assert nth_fibonacci(1) == 1 assert nth_fibonacci(10) == 55 assert nth_fibonacci(30) == 832040 # Edge case assert is_fibonacci(0) == True assert is_fibonacci(1) == True assert nth_fibonacci(-1) # should raise ValueError ``` Implement both functions in your solution and make sure to handle edge cases appropriately. Validate your functions with a variety of inputs to ensure correctness and performance. # Explanation: - The `is_fibonacci` function should identify if a number is part of the Fibonacci sequence. Utilize properties such as whether 5*n^2 + 4 or 5*n^2 - 4 is a perfect square to make this determination. - The `nth_fibonacci` function must compute the nth Fibonacci number, using iterative or optimized methods such as matrix exponentiation to enhance performance for larger inputs.","solution":"import math def is_fibonacci(number: int) -> bool: Determines whether a given number is a Fibonacci number. if number < 0: return False # A number is a Fibonacci number if and only if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square def is_perfect_square(x): s = int(math.isqrt(x)) return s*s == x return is_perfect_square(5 * number * number + 4) or is_perfect_square(5 * number * number - 4) def nth_fibonacci(n: int) -> int: Returns the nth number in the Fibonacci sequence. if n < 0: raise ValueError(\\"Input should be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(n-1): a, b = b, a + b return b"},{"question":"# Question You are tasked with creating a function that simulates a simplified version of a popular pathfinding algorithm, A*. The goal is to find the shortest path between two points on a 2D grid, avoiding obstacles. # Function Specification **Function Signature** ```python def a_star(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` **Input** - `grid` (List[List[int]]): A 2D list representing the grid, where 0 indicates an open cell and 1 indicates an obstacle. - `start` (Tuple[int, int]): The starting cell coordinates (x, y). - `goal` (Tuple[int, int]): The goal cell coordinates (x, y). **Output** - Returns a list of tuples representing the coordinates (x, y) of the cells in the path from `start` to `goal`, inclusive. If no path exists, return an empty list. **Constraints** - The grid is always rectangular and non-empty. - The start and goal points are within the grid and are not on obstacles. - Diagonal moves are not allowed; only up, down, left, and right moves are permitted. - If multiple paths exist, any one of the shortest paths can be returned. # Example ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) path = a_star(grid, start, goal) print(path) # Example output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ``` **Explanation** - The function will find a path from the top-left corner (0, 0) to the bottom-right corner (4, 4) avoiding obstacles. - Returns an example shortest path that navigates through open cells (0). # Instructions 1. Implement the A* algorithm using a priority queue to manage the open set of nodes. 2. Use a heuristic to estimate the cost from the current node to the goal (e.g., Manhattan distance). 3. Write the function to handle grids with varying dimensions and obstacles. 4. Ensure the function returns an empty list if no path to the goal exists. 5. Test the function with different scenarios to ensure its accuracy and robustness. --- This new question maintains the style, complexity, and scope of the original set, offering a programming challenge that involves algorithms and data structures relevant in a real-world context.","solution":"from heapq import heappop, heappush from typing import List, Tuple def a_star(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(pos): neighbors = [] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_pos = (pos[0] + dx, pos[1] + dy) if 0 <= new_pos[0] < len(grid) and 0 <= new_pos[1] < len(grid[0]) and grid[new_pos[0]][new_pos[1]] == 0: neighbors.append(new_pos) return neighbors open_set = [] heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: _, current = heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for neighbor in get_neighbors(current): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal) heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Problem Statement: # Context: You are developing a text-processing utility that identifies the most frequently occurring word(s) within a given string of text, disregarding case sensitivity and punctuation. **Purpose**: Implement a function that finds the word(s) that appear the most in a given string. # Task: Write a function `most_common_words(text: str) -> List[str]` that takes in one argument: 1. A string `text` that represents a paragraph of English text. The function should return a list containing the word or words that appear the most frequently in the text, sorted in lexicographical order. All comparisons should be case-insensitive, and any punctuation marks should be ignored. If multiple words have the same highest frequency, include all of them in the output list. # Input: - A string `text` containing up to 10^6 characters. # Output: - A list of strings containing the most frequent word(s) in lexicographical order. # Constraints: - The function should handle large paragraphs efficiently. - Ignore differences in case and punctuation marks in the input text. # Example: ```python >>> most_common_words(\\"In a village of La Mancha, the name of which I have no desire to call to mind, there lived not long since one of those gentlemen that keep a lance in the lance-rack, an old buckler, a lean hack, and a greyhound for course.\\") [\'a\', \'of\'] >>> most_common_words(\\"The quick brown fox jumps over the lazy dog. The dog was not happy.\\") [\'the\'] ``` **Note**: Ensure your function adequately strips punctuation and normalizes case for accurate word frequency counting. Use efficient data structures to manage word counting and retrieval.","solution":"from typing import List import re from collections import Counter def most_common_words(text: str) -> List[str]: Return the word(s) that appear the most frequently in the text. The result is sorted in lexicographical order. # Remove punctuation and convert to lowercase text = re.sub(r\'[^ws]\', \'\', text).lower() # Split text into words words = text.split() # Count frequency of each word word_count = Counter(words) # Find the maximum frequency max_freq = max(word_count.values()) # Find all words with the maximum frequency most_common = [word for word, freq in word_count.items() if freq == max_freq] # Return the words sorted lexicographically return sorted(most_common)"},{"question":"# Problem Statement You are tasked with writing a function that rotates a list of integers to the right by a given number of steps. Specifically, you need to implement a function `rotate_list` that adheres to the following requirements: 1. **Input**: - A list of integers. - An integer `k` which represents the number of steps to rotate the list. 2. **Output**: - The list of integers rotated to the right by `k` steps. 3. **Constraints**: - The input list may be empty. - The integer `k` may be zero, positive, or negative. - The function should have an average time complexity of O(n) where n is the number of elements in the list. - Negative values of `k` should rotate the list to the left by `|k|` steps. - You must handle cases where `k` is larger than the length of the list appropriately. # Function Signature: ```python def rotate_list(nums: list, k: int) -> list: pass ``` # Examples: ```python >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list([], 3) [] >>> rotate_list([1, 2, 3], 0) [1, 2, 3] ``` # Additional Notes: - Ensure your function efficiently handles cases where `k` is negative or zero. - Consider the list\'s length in your implementation to optimize for cases where `k` is significantly larger or smaller than the list\'s length. - Aim for clarity and conciseness in your implementation while ensuring all edge cases are addressed.","solution":"def rotate_list(nums: list, k: int) -> list: Rotates the list nums to the right by k steps. Negative values of k rotate the list to the left by |k| steps. n = len(nums) if n == 0: return nums k = k % n # Normalize k to be within the range of 0 to n-1 return nums[-k:] + nums[:-k]"},{"question":"# Coding Assessment Question Context You are required to extend a binary search tree (BST) to include a method that checks if the tree is balanced. A balanced binary search tree is defined as a tree where the depths of the two subtrees of every node never differ by more than one. The goal is to ensure you understand tree traversal and the concept of balanced trees. Task Implement a method `is_balanced` within the `BST` class that returns a boolean indicating whether the tree is balanced or not. Function Specification ```python def is_balanced(self) -> bool: Checks if the binary search tree is balanced. Examples: >>> bst = BST() >>> bst.insert(3) >>> bst.insert(1) >>> bst.insert(4) >>> bst.insert(2) >>> bst.is_balanced() True >>> bst.insert(0) >>> bst.is_balanced() False When the tree is empty: >>> bst = BST() >>> bst.is_balanced() True When the tree has one element: >>> bst = BST() >>> bst.insert(1) >>> bst.is_balanced() True Returns: bool: True if the tree is balanced, False otherwise. pass ``` Constraints * Your solution should use efficient tree traversal techniques, minimizing redundant calculations. * The time complexity should aim to be O(n), where n is the number of nodes in the tree. * Aim for an O(h) space complexity, where h is the height of the tree due to recursion. Input Format A method `is_balanced` is added to the `BST` class with no input parameters. Output Format The method returns a boolean value indicating if the tree is balanced. Examples * Input: BST with nodes in the following structure: ``` 3 / 1 4 2 ``` * Expected Output: `True` * Input: BST with nodes in the following structure: ``` 3 / 1 / 0 ``` * Expected Output: `False`","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if root.val < key: root.right = self._insert(root.right, key) else: root.left = self._insert(root.left, key) return root def is_balanced(self) -> bool: def check_balance(node): if node is None: return 0, True left_height, left_balance = check_balance(node.left) right_height, right_balance = check_balance(node.right) current_height = max(left_height, right_height) + 1 current_balance = left_balance and right_balance and abs(left_height - right_height) <= 1 return current_height, current_balance _, is_bal = check_balance(self.root) return is_bal"},{"question":"# Rotate Matrix 90 Degrees You are tasked with implementing a method to rotate a given n x n matrix 90 degrees clockwise. **Task**: Add the following method to the `MatrixManipulation` class: ```python def rotate_90_clockwise(self): Rotates the given n x n matrix 90 degrees clockwise. :return: Rotated matrix return [list(reversed(col)) for col in zip(*self.matrix)] ``` **Objective**: You need to define this method such that it rotates the matrix (stored within the class as an attribute `self.matrix`) 90 degrees clockwise and returns the resulting matrix. **Input/Output**: * **Input**: The method operates on the class\'s internal attribute `self.matrix`, which is a list of n lists, each containing n integers. * **Output**: A new list of n lists, each containing n integers, representing the rotated matrix. **Constraints**: * `self.matrix` is a list of n lists, where each list has precisely n elements (i.e., an n x n matrix). * `self.matrix` contains only integer values. **Performance**: Ensure your implementation efficiently rotates the matrix, even for large values of n. **Scenario**: You are developing part of an image processing software that needs to rotate square images (represented as n x n matrices of pixel values) by 90 degrees clockwise for a specific filter effect. The provided method should accomplish this transformation. Example: ```python # Given input matrix matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # Expected Output # Rotated matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` Add your method definition to the `MatrixManipulation` class and verify its correctness based on the provided example.","solution":"class MatrixManipulation: def __init__(self, matrix): self.matrix = matrix def rotate_90_clockwise(self): Rotates the given n x n matrix 90 degrees clockwise. :return: Rotated matrix return [list(reversed(col)) for col in zip(*self.matrix)]"},{"question":"# Prime Number Sum Finder Problem Statement You are tasked with creating a function that finds and sums all prime numbers up to a specified limit. Your function should include the following: 1. **sum_of_primes(limit: int) -> int** This function should: - Calculate the sum of all prime numbers that are less than or equal to the given limit. - Validate that the input `limit` is a non-negative integer. - Raise a `ValueError` if the input `limit` is negative. Example Usage ```python >>> sum_of_primes(10) 17 >>> sum_of_primes(0) 0 >>> sum_of_primes(20) 77 >>> sum_of_primes(1) 0 >>> sum_of_primes(-5) Traceback (most recent call last): ... ValueError: limit must be a non-negative integer ``` Constraints - The input `limit` must be a non-negative integer. - If the `limit` is less than 2, the sum should be 0 as there are no prime numbers less than 2. Notes - A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. - Implement an efficient prime-checking algorithm to ensure the function performs well even for larger limits. Implementation Implement the `sum_of_primes` function in Python. ```python def sum_of_primes(limit: int) -> int: if limit < 0: raise ValueError(\\"limit must be a non-negative integer\\") def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True prime_sum = 0 for number in range(2, limit + 1): if is_prime(number): prime_sum += number return prime_sum ```","solution":"def sum_of_primes(limit: int) -> int: if limit < 0: raise ValueError(\\"limit must be a non-negative integer\\") def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True prime_sum = 0 for number in range(2, limit + 1): if is_prime(number): prime_sum += number return prime_sum"},{"question":"# Question: Temperature Conversion and Classification As a scientist working on climate data, you need to write functions to convert temperatures between different scales and classify them into categories. Your task is to implement two functions: 1. **celsius_to_fahrenheit(celsius_temperature)**: - **Input**: A float `celsius_temperature`. - **Output**: The temperature in Fahrenheit as a float. - **Example**: ```python >>> celsius_to_fahrenheit(0) 32.0 >>> celsius_to_fahrenheit(100) 212.0 ``` 2. **classify_temperature(fahrenheit_temperature)**: - **Input**: A float `fahrenheit_temperature`. - **Output**: A string representing the temperature category: - \\"Freezing\\" for temperatures below 32°F - \\"Cold\\" for temperatures between 32°F and 59°F (inclusive) - \\"Warm\\" for temperatures between 60°F and 89°F (inclusive) - \\"Hot\\" for temperatures above 89°F - **Example**: ```python >>> classify_temperature(32) \'Cold\' >>> classify_temperature(60) \'Warm\' ``` # Implementation Requirements - Ensure the function `celsius_to_fahrenheit(celsius_temperature)` returns the temperature converted from Celsius to Fahrenheit using the formula ( °F = °C times frac{9}{5} + 32 ). - Ensure the function `classify_temperature(fahrenheit_temperature)` classifies the given Fahrenheit temperature correctly according to the specified categories. # Test Cases You should test your functions with the following cases: ```python assert celsius_to_fahrenheit(0) == 32.0 assert celsius_to_fahrenheit(37) == 98.6 assert celsius_to_fahrenheit(100) == 212.0 assert classify_temperature(31) == \\"Freezing\\" assert classify_temperature(32) == \\"Cold\\" assert classify_temperature(59) == \\"Cold\\" assert classify_temperature(60) == \\"Warm\\" assert classify_temperature(89) == \\"Warm\\" assert classify_temperature(90) == \\"Hot\\" ```","solution":"def celsius_to_fahrenheit(celsius_temperature): Converts Celsius temperature to Fahrenheit. Parameters: celsius_temperature (float): Temperature in Celsius. Returns: float: Temperature in Fahrenheit. return (celsius_temperature * 9 / 5) + 32 def classify_temperature(fahrenheit_temperature): Classifies the temperature in Fahrenheit into categories. Parameters: fahrenheit_temperature (float): Temperature in Fahrenheit. Returns: str: Temperature category (\\"Freezing\\", \\"Cold\\", \\"Warm\\", \\"Hot\\"). if fahrenheit_temperature < 32: return \\"Freezing\\" elif 32 <= fahrenheit_temperature <= 59: return \\"Cold\\" elif 60 <= fahrenheit_temperature <= 89: return \\"Warm\\" else: return \\"Hot\\""},{"question":"# Question You are tasked with developing a function that takes a binary search tree (BST) and returns the height of the tree. The height of a binary tree is the number of edges on the longest path from the root to a leaf. # Function Signature ```python def bst_height(node: TreeNode) -> int: pass ``` # Input - `node`: A `TreeNode` object representing the root of the binary search tree. Each `TreeNode` has the following attributes: - `data`: An integer representing the value of the node. - `left`: A `TreeNode` object representing the left child (or `None` if there is no left child). - `right`: A `TreeNode` object representing the right child (or `None` if there is no right child). # Output - An integer representing the height of the binary search tree. # Example ```python class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None # Example Tree: # 10 # / # 5 20 # / / # 3 7 15 25 # / # 2 root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(20) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.left = TreeNode(15) root.right.right = TreeNode(25) root.left.left.left = TreeNode(2) print(bst_height(root)) # Output: 3 ``` # Constraints - The number of nodes in the binary search tree will not exceed `10^4`. - The values of the nodes will be in the range `[-10^5, 10^5]`. # Requirements - Ensure your solution is optimized for performance to handle large trees efficiently. - Take care to handle edge cases, such as an empty tree.","solution":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None def bst_height(node: TreeNode) -> int: if node is None: return -1 left_height = bst_height(node.left) right_height = bst_height(node.right) return max(left_height, right_height) + 1"},{"question":"# Coding Assessment Question **Objective**: Implement a function that finds the maximum sum of any subarray of a given list of integers. **Function Signature**: ```python def max_subarray_sum(nums: list) -> int: pass ``` # Input & Output * **Input Format**: * `nums`: A list of integers. * **Output Format**: * An integer representing the maximum sum of any subarray within the given list. # Constraints * The length of the list `nums` does not exceed (10^5). * The elements in `nums` are between (-10^4) and (10^4). # Performance Requirements * Your implementation should be able to handle the length efficiently within the given constraints. # Example 1. **Example 1**: * Input: `[-2, 1, -3, 4, -1, 2, 1, -5, 4]` * Output: `6` Explanation: The subarray `[4, -1, 2, 1]` has the maximum sum of 6. 2. **Example 2**: * Input: `[1]` * Output: `1` Explanation: The subarray `[1]` has the maximum sum of 1. 3. **Example 3**: * Input: `[-1, -2, -3, -4]` * Output: `-1` Explanation: The subarray `[-1]` has the maximum sum of -1. 4. **Example 4**: * Input: `[5, 4, -1, 7, 8]` * Output: `23` Explanation: The subarray `[5, 4, -1, 7, 8]` has the maximum sum of 23. # Instructions * Implement the `max_subarray_sum` function according to the given requirements. * Ensure your function is efficient and handles edge cases effectively. * Do not print anything in the function; return the result directly.","solution":"def max_subarray_sum(nums): Finds the maximum sum of any subarray of the given list of integers. Args: nums: list of integers. Returns: An integer representing the maximum sum of any subarray within the given list. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Coding Assessment Question Imagine you are tasked with developing a library management system. One key feature of this system is to track and manage book borrowings by library members. You need to create a function that records and retrieves borrowing details, ensuring that a member does not borrow more than a specified number of books at any one time. Function Specification **Function Name**: `track_borrowings` **Input Parameters**: 1. `member_id`: (str) Unique identifier for the library member. 2. `book_id`: (str) Unique identifier for the book. 3. `action`: (str) Either \\"borrow\\" to record a borrowing or \\"return\\" to mark a book as returned. **Output**: - If the action is successful, returns a dictionary with the member’s current borrowing status, specifying how many books they have borrowed. - If the action cannot be completed (e.g., limit exceeded or no record of borrowing for the return), returns an appropriate error message. **Constraints**: - Each member can borrow up to a maximum of 5 books at a time. - A member cannot return a book they haven\'t borrowed. - The function should maintain the borrowing records in an efficient data structure for quick retrieval and updates. Example Usage ```python def track_borrowings(member_id: str, book_id: str, action: str) -> dict: # Your implementation here pass # Example calls status = track_borrowings(\\"member_01\\", \\"book_01\\", \\"borrow\\") print(status) status = track_borrowings(\\"member_01\\", \\"book_01\\", \\"return\\") print(status) ``` # Requirements: 1. **Action Validation**: Ensure that borrow and return actions respect the constraints of the system (e.g., borrowing limit and valid return). 2. **Data Structure**: Use an efficient data structure to manage and track borrowings, ensuring quick updates and retrievals. 3. **Error Handling**: Implement error handling for invalid actions, such as trying to return a book that wasn\'t borrowed or exceeding the borrow limit. 4. **Clear Documentation and Code**: Ensure your function and variables names are meaningful, and the code is well-commented for clarity. You have 2 hours to complete this task. Good luck!","solution":"class LibraryManagement: def __init__(self): # To track borrowed books for each member self.borrowing_records = {} def track_borrowings(self, member_id: str, book_id: str, action: str) -> dict: # Initialize member record if they do not exist if member_id not in self.borrowing_records: self.borrowing_records[member_id] = [] # Get current borrowings for the member current_borrowings = self.borrowing_records[member_id] if action == \\"borrow\\": # Check if member has already borrowed the maximum number of books if len(current_borrowings) >= 5: return {\\"error\\": \\"Borrow limit exceeded.\\"} # Check if the book is already borrowed by the member if book_id in current_borrowings: return {\\"error\\": \\"Book already borrowed.\\"} # Add book to the member\'s borrowings current_borrowings.append(book_id) return {\\"success\\": True, \\"borrowed_books\\": current_borrowings} elif action == \\"return\\": # Check if the member has borrowed the book if book_id not in current_borrowings: return {\\"error\\": \\"Book was not borrowed.\\"} # Remove book from the member\'s borrowings current_borrowings.remove(book_id) return {\\"success\\": True, \\"borrowed_books\\": current_borrowings} else: return {\\"error\\": \\"Invalid action.\\"}"},{"question":"# Objective Write a function to determine the minimal number of operations required to transform one binary tree into another. The allowed operations are insertions, deletions, and changes of values of nodes. # Specifications * **Function Name**: min_operations_to_transform_tree * **Input**: * `root1` (TreeNode): The root node of the first binary tree. * `root2` (TreeNode): The root node of the second binary tree. * **Output**: * (int): The minimal number of operations required. # Constraints * The number of nodes in either tree will not exceed 1000. * The value of each node in the trees is an integer. # Performance * The implementation should aim to be efficient, ideally operating within a time complexity of O(n * m), where n and m represent the number of nodes in the respective trees. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_operations_to_transform_tree(root1: TreeNode, root2: TreeNode) -> int: # Your implementation goes here # Example Usage # Tree 1: Tree 2: # 1 1 # / / # 2 3 4 5 # Tree1: root1 = TreeNode(1, TreeNode(2), TreeNode(3)) # Tree2: root2 = TreeNode(1, TreeNode(4), TreeNode(5)) root1 = TreeNode(1, TreeNode(2), TreeNode(3)) root2 = TreeNode(1, TreeNode(4), TreeNode(5)) print(min_operations_to_transform_tree(root1, root2)) # Output: 2 # Tree 1: Tree 2: # 1 1 # # 3 2 root1 = TreeNode(1, None, TreeNode(3)) root2 = TreeNode(1, None, TreeNode(2)) print(min_operations_to_transform_tree(root1, root2)) # Output: 1 ``` # Additional Notes 1. Ensure your solution can handle edge cases, such as when one or both of the trees are empty. 2. Pay careful attention to both the structure and the values of nodes in the trees during your transformations.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_operations_to_transform_tree(root1: TreeNode, root2: TreeNode) -> int: def min_operations(n1, n2): if not n1 and not n2: return 0 if not n1: return 1 + min_operations(None, n2.left) + min_operations(None, n2.right) if not n2: return 1 + min_operations(n1.left, None) + min_operations(n1.right, None) if n1.val != n2.val: op_replace = 1 + min_operations(n1.left, n2.left) + min_operations(n1.right, n2.right) else: op_replace = min_operations(n1.left, n2.left) + min_operations(n1.right, n2.right) op_insert_delete = 1 + min_operations(None, n2.left) + min_operations(None, n2.right) op_insert_delete += 1 + min_operations(n1.left, None) + min_operations(n1.right, None) return min(op_replace, op_insert_delete) return min_operations(root1, root2)"},{"question":"Task **Context**: You are developing a user management system for a file sharing service. One of the essential features is to efficiently check file system permissions for different users. Each file and directory has different access control settings defining which users can read, write, or execute them. This feature is crucial for maintaining security and privacy in the service. **Objective**: Write a function that verifies whether a user has a particular permission on a file or directory. The function will check if the user has the required permissions to perform an operation based on predefined access control entries. **Function Signature**: ```python def check_permission(permissions: Dict[str, Dict[str, List[str]]], user: str, target: str, operation: str) -> bool: pass ``` **Input**: * `permissions`: A dictionary where keys are file or directory names (strings), and values are dictionaries. The inner dictionary keys are user names (strings), and values are lists of permissible operations for the user on the file or directory. * `user`: A string representing the user name for whom the check is to be performed. * `target`: A string representing the file or directory name whose permissions need to be checked. * `operation`: A string representing the requested operation which can be \\"read\\", \\"write\\", or \\"execute\\". **Output**: * A boolean value indicating whether the specified user has the required permission on the target file or directory for the given operation. **Constraints**: * The permissions dictionary contains at most 500 entries (files or directories). * Each file or directory entry affects at most 100 users. **Example**: ```python permissions = { \\"file1.txt\\": { \\"alice\\": [\\"read\\", \\"write\\"], \\"bob\\": [\\"read\\"], }, \\"docs\\": { \\"admin\\": [\\"read\\", \\"write\\", \\"execute\\"], \\"ubuntu\\": [\\"execute\\"], } } user = \\"bob\\" target = \\"file1.txt\\" operation = \\"write\\" result = check_permission(permissions, user, target, operation) assert result == False ``` **Additional Notes**: * Users can have multiple permissions on a file or directory. * Ensure that the function handles cases where the user or the file/directory is not defined in the permissions dictionary. * Aim for the function to efficiently check permissions within the provided constraints.","solution":"def check_permission(permissions, user, target, operation): Verifies whether a user has a particular permission on a file or directory. Parameters: - permissions: Dictionary describing permissions of files/directories. - user: The user name whose permissions are to be checked. - target: The file or directory name to check permissions on. - operation: The requested operation (e.g., \\"read\\", \\"write\\", or \\"execute\\"). Returns: - Boolean indicating whether the user has the required permission. # Check if the target exists in the permission dictionary. if target in permissions: # Check if the user has specific permissions for the target. if user in permissions[target]: # Check if the requested operation is in the list of permissible operations for the user. if operation in permissions[target][user]: return True return False"},{"question":"**[Question 2]: Shortest Path in a Grid with Obstacles** # Problem Statement You are given a 2D grid representing a map with obstacles, and your task is to compute the length of the shortest path from the top-left corner to the bottom-right corner while avoiding the obstacles. You can move horizontally or vertically but not diagonally. The grid is represented by a list of lists, where each element is either 0 (empty cell) or 1 (obstacle). Your starting position is (0, 0) and your destination is the bottom-right corner of the grid. # Input - A list of lists named `grid` where each element is either 0 or 1. - 0 represents an empty cell. - 1 represents an obstacle. - The dimensions of the grid are `m x n` (1 <= m, n <= 100). # Output - A single integer representing the length of the shortest path from the top-left corner to the bottom-right corner. If there is no such path, return -1. # Constraints - The dimensions of the grid, `m` and `n`, will not exceed 100. - You cannot move diagonally. - Both the start (0,0) and end (m-1, n-1) positions are always empty cells (0). # Example ```python Input: [[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]] Output: 9 Input: [[0, 1], [1, 0]] Output: -1 Input: [[0, 0], [0, 0]] Output: 2 ``` # Instructions Implement the function `shortest_path(grid: List[List[int]]) -> int` which takes a 2D list of integers `grid` and returns the length of the shortest path from the top-left corner to the bottom-right corner. If there is no path, return -1. # Example Function Signature ```python def shortest_path(grid: List[List[int]]) -> int: # Your code here ``` # Implementation Considerations - Use Breadth-First Search (BFS) to find the shortest path in the grid. - Consider edge cases such as where the grid is completely filled with obstacles except the starting and ending points. - Pay attention to the performance, especially given the constraints of the grid dimensions.","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) # Directions for moving right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Initialize the BFS queue queue = deque([(0, 0, 1)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we\'ve reached the bottom-right corner if x == m - 1 and y == n - 1: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy # Check boundaries and whether the cell is an obstacle or already visited if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Programming Assessment Question **Context**: As part of developing a recommendation system, you have to process user interactions with items (e.g., products, articles). A common task is to rank items based on user interactions. Your task is to design a system that ranks items by the number of interactions they receive. **Task**: Implement a function `rank_items_by_interactions()` that receives a list of tuples representing user interactions and returns a list of items ranked by the number of interactions in non-increasing order. Function Signature: ```python def rank_items_by_interactions(interactions: list[tuple[str, str]]) -> list[str]: pass ``` Input: * `interactions`: List of tuples, where each tuple contains two strings: a user ID and an item ID. Each tuple represents a user-item interaction. Output: * List of strings, representing the item IDs ranked by the number of interactions in non-increasing order. If two items have the same number of interactions, they can appear in any order relative to each other. Constraints: * The input list `interactions` will contain at most 1,000,000 tuples. * Each user ID and item ID in a tuple has a maximum length of 100 characters. Requirements: * Ensure the function is optimized for efficiency given the large input size. * If the list of `interactions` is empty, return an empty list. Example: ```python rank_items_by_interactions([(\'user1\', \'item1\'), (\'user2\', \'item1\'), (\'user3\', \'item2\'), (\'user1\', \'item2\'), (\'user2\', \'item3\')]) # Output: [\'item1\', \'item2\', \'item3\'] or [\'item1\', \'item2\', \'item3\'] rank_items_by_interactions([(\'u1\', \'i1\'), (\'u2\', \'i2\'), (\'u3\', \'i3\'), (\'u1\', \'i1\'), (\'u3\', \'i3\'), (\'u2\', \'i1\')]) # Output: [\'i1\', \'i3\', \'i2\'] or [\'i1\', \'i3\', \'i2\'] rank_items_by_interactions([]) # Output: [] ``` Additional Notes: * Ensure your implementation makes efficient use of data structures suitable for counting item interactions and sorting them by interaction frequency. * Handle edge cases such as an empty interaction list carefully. * The ranking should prioritize the number of interactions but handle ties in any consistent manner.","solution":"from collections import Counter def rank_items_by_interactions(interactions): Returns a list of items ranked by the number of interactions in non-increasing order. Parameters: interactions (list of tuples): Each tuple contains a user ID and an item ID representing a user-item interaction Returns: list of strings: Item IDs ranked by the number of interactions if not interactions: return [] # Create a counter for item interactions interaction_counter = Counter(item for user, item in interactions) # Sort items by number of interactions in non-increasing order sorted_items = sorted(interaction_counter, key=lambda x: interaction_counter[x], reverse=True) return sorted_items"},{"question":"# Implementing a Decision Tree from Scratch You are required to write a function `custom_decision_tree` that builds a Decision Tree classifier for a given dataset. The function should include detailed logging for each step of the tree construction process and handle edge cases gracefully. Function Signature ```python def custom_decision_tree(data: np.ndarray, labels: np.ndarray, max_depth: int = 10, min_samples_split: int = 2, verbose: bool = False) -> dict: Build a decision tree classifier. Parameters: data (np.ndarray): A 2D numpy array where each row is a data point. labels (np.ndarray): A 1D numpy array containing the class labels for each data point. max_depth (int, optional): The maximum depth of the tree. Default is 10. min_samples_split (int, optional): The minimum number of samples required to split an internal node. Default is 2. verbose (bool, optional): If True, print detailed log messages. Default is False. Returns: dict: A dictionary representing the decision tree. pass ``` Requirements 1. **Input/Output**: - **Input**: - `data` (np.ndarray): A 2D numpy array where each row represents a data point. - `labels` (np.ndarray): A 1D numpy array containing the class labels for each data point. - `max_depth` (int, optional): The maximum depth of the tree. Default is 10. - `min_samples_split` (int, optional): The minimum number of samples required to split an internal node. Default is 2. - `verbose` (bool, optional): Flag to enable/disable verbose logging. - **Output**: - A dictionary representing the decision tree structure. 2. **Implementation Details**: - Include functions for calculating impurity (Gini index or entropy), finding the best split, and recursively constructing the tree. - Incorporate logging to trace decisions during tree construction when `verbose` is True. - Ensure the algorithm handles edge cases where the dataset size is small or has identical data points. - Stop splitting nodes when maximum depth is reached or if the minimum samples split criteria is not met. 3. **Performance**: - Optimize for efficient performance while maintaining clarity and readability. Example ```python import numpy as np # Sample data (features and corresponding labels) data = np.array([ [2.771244718, 1.784783929], [1.728571309, 1.169761413], [3.678319846, 2.81281357], [3.961043357, 2.61995032], [2.999208922, 2.209014212], [7.497545867, 3.162953546], [9.00220326, 3.339047188], [7.444542326, 0.476683375], [10.12493903, 3.234550982], [6.642287351, 3.319983761], ]) labels = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1]) tree = custom_decision_tree(data, labels, max_depth=3, min_samples_split=2, verbose=True) print(tree) ``` Your task is to implement the `custom_decision_tree` function to achieve the expected functionality.","solution":"import numpy as np def gini_impurity(labels): Calculate the Gini impurity for a list of labels. unique_labels, counts = np.unique(labels, return_counts=True) probabilities = counts / len(labels) gini = 1 - np.sum(probabilities ** 2) return gini def find_best_split(data, labels): Find the best feature and threshold to split on. best_gini = float(\'inf\') best_split = None n_features = data.shape[1] for feature in range(n_features): thresholds = np.unique(data[:, feature]) for threshold in thresholds: left_mask = data[:, feature] <= threshold right_mask = ~left_mask left_labels, right_labels = labels[left_mask], labels[right_mask] if len(left_labels) == 0 or len(right_labels) == 0: continue left_gini = gini_impurity(left_labels) right_gini = gini_impurity(right_labels) gini = (len(left_labels) * left_gini + len(right_labels) * right_gini) / len(labels) if gini < best_gini: best_gini = gini best_split = (feature, threshold) return best_split def build_tree(data, labels, depth, max_depth, min_samples_split, verbose): Recursively build the decision tree. if len(labels) < min_samples_split or depth >= max_depth or len(np.unique(labels)) == 1: return np.argmax(np.bincount(labels)) best_split = find_best_split(data, labels) if not best_split: return np.argmax(np.bincount(labels)) feature, threshold = best_split left_mask = data[:, feature] <= threshold right_mask = ~left_mask if verbose: print(f\\"{\' \' * depth}Depth {depth}: Split on feature {feature} <= {threshold}\\") left_subtree = build_tree(data[left_mask], labels[left_mask], depth + 1, max_depth, min_samples_split, verbose) right_subtree = build_tree(data[right_mask], labels[right_mask], depth + 1, max_depth, min_samples_split, verbose) return {\'feature\': feature, \'threshold\': threshold, \'left\': left_subtree, \'right\': right_subtree} def custom_decision_tree(data: np.ndarray, labels: np.ndarray, max_depth: int = 10, min_samples_split: int = 2, verbose: bool = False) -> dict: Build a decision tree classifier. Parameters: data (np.ndarray): A 2D numpy array where each row is a data point. labels (np.ndarray): A 1D numpy array containing the class labels for each data point. max_depth (int, optional): The maximum depth of the tree. Default is 10. min_samples_split (int, optional): The minimum number of samples required to split an internal node. Default is 2. verbose (bool, optional): If True, print detailed log messages. Default is False. Returns: dict: A dictionary representing the decision tree. return build_tree(data, labels, 0, max_depth, min_samples_split, verbose)"},{"question":"# Matrix Rotation and Reflection In various graphics and mathematical applications, manipulating matrices is a common task. Specifically, rotating and reflecting a matrix can achieve various transformations. Task Implement a function that takes in a square matrix and performs a specific sequence of operations: first, rotate the matrix 90 degrees clockwise, and then reflect the matrix along the main diagonal (northwest-southeast). Function Signature ```python def transform_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input - A 2D list `matrix`, which is an `N x N` matrix where `1 ≤ N ≤ 100`. Output - A 2D list of the same dimensions representing the transformed matrix. Constraints - Only standard Python libraries should be used. - The elements of the matrix are integers. Example ```python >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> transform_matrix(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` In this example, rotating the matrix 90 degrees clockwise results in: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Reflecting along the main diagonal then results in: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Explanation - **Rotate 90 degrees clockwise**: Transpose the matrix, then reverse each row. - **Reflect along the main diagonal**: Swap elements `[i][j]` with `[j][i]` for `i < j`. This step would be redundant here as the initial rotation results directly in the required output for such a transformation.","solution":"from typing import List def transform_matrix(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) # Step 1: Rotate the matrix 90 degrees clockwise # This can be done by first transposing the matrix and then reversing each row for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Graph Connectivity Query You are given a class `Graph` representing an undirected graph using an adjacency list. The class supports adding vertices, adding edges, and basic searching algorithms. Your task is to enhance this graph implementation with a new method that checks whether two given vertices are connected. Two vertices are considered connected if there is a path between them. # Requirements 1. Implement a method `are_connected(vertex1, vertex2)` which returns a boolean value indicating whether `vertex1` and `vertex2` are connected. 2. Utilize either Depth-First Search (DFS) or Breadth-First Search (BFS) to determine connectivity. # Input - The method `are_connected` takes two integers `vertex1` and `vertex2` representing the vertices you need to check for connectivity. # Output - Return `True` if `vertex1` and `vertex2` are connected; otherwise, return `False`. # Example ```python # Graph instance g g.add_vertex(1) g.add_vertex(2) g.add_vertex(3) g.add_vertex(4) g.add_edge(1, 2) g.add_edge(2, 3) # The graph looks like this: # 1 - 2 - 3 # 4 (disconnected) # Calling your are_connected method g.are_connected(1, 3) # Output should be: True g.are_connected(1, 4) # Output should be: False ``` # Constraints 1. The graph is undirected. 2. Ensure your method efficiently checks connectivity for graphs with up to 10^4 vertices and 10^5 edges. 3. Avoid modifying the existing graph structure or methods.","solution":"class Graph: def __init__(self): self.adj_list = {} def add_vertex(self, vertex): if vertex not in self.adj_list: self.adj_list[vertex] = [] def add_edge(self, vertex1, vertex2): if vertex1 in self.adj_list and vertex2 in self.adj_list: self.adj_list[vertex1].append(vertex2) self.adj_list[vertex2].append(vertex1) def are_connected(self, vertex1, vertex2): if vertex1 not in self.adj_list or vertex2 not in self.adj_list: return False visited = set() stack = [vertex1] while stack: current = stack.pop() if current == vertex2: return True if current not in visited: visited.add(current) stack.extend([neighbor for neighbor in self.adj_list[current] if neighbor not in visited]) return False"},{"question":"# String Manipulation with Custom Format You are tasked with implementing a text processing program that detects and transforms specific patterns in a string. Using Python, you will write functions to identify and modify occurrences of a specific format, then reverse the modifications. Requirements: 1. **Pattern Detection and Transformation Functions** - Write two functions to detect and transform patterns in text. - `transform_text(original_text: str) -> str` - `reverse_transform(transformed_text: str) -> str` 2. **Specific Pattern and Transformation Rules** - The transformation function should identify all occurrences of the format `<tag>some_text</tag>` and replace them with `[TAG]some_text[/TAG]`. - The reverse transformation function should revert `[TAG]some_text[/TAG]` back to `<tag>some_text</tag>`. 3. **File Handling Functions** - Write functions to handle the reading of input text from a file, applying the transformation, and writing the output to another file. - `apply_transformation_to_file(input_filename: str, output_filename: str) -> None` - `reverse_transformation_from_file(input_filename: str, output_filename: str) -> None` # Constraints: - Handle nested or overlapping tags gracefully by only transforming the outermost tags. - Assume the input text contains well-formed tags. - The functions should handle file read/write errors gracefully. # Example Usage: ```python def main() -> None: input_filename = \\"input_text.txt\\" output_filename = \\"output_text.txt\\" response = input(r\\"TransformReverse [tr]: \\") if response.lower().startswith(\\"t\\"): apply_transformation_to_file(input_filename, output_filename) print(f\\"Transformed text written to {output_filename}\\") elif response.lower().startswith(\\"r\\"): reverse_transformation_from_file(output_filename, \\"reversed_text.txt\\") print(f\\"Reversed text written to reversed_text.txt\\") if __name__ == \'__main__\': main() ``` # Example Input and Output: Input File (input_text.txt): ```plaintext This is a sample text with <tag>example text inside</tag> of a tag. There is also another <tag>nested <tag>example</tag> text</tag> in it. ``` Transformed Output File (output_text.txt): ```plaintext This is a sample text with [TAG]example text inside[/TAG] of a tag. There is also another [TAG]nested <tag>example</tag> text[/TAG] in it. ``` Reversed Output File (reversed_text.txt): ```plaintext This is a sample text with <tag>example text inside</tag> of a tag. There is also another <tag>nested <tag>example</tag> text</tag> in it. ``` Implement these functions and test with appropriate input files to ensure correctness and performance.","solution":"def transform_text(original_text: str) -> str: Transforms occurrences of <tag> to [TAG] and </tag> to [/TAG] in the text. transformed_text = original_text.replace(\'<tag>\', \'[TAG]\').replace(\'</tag>\', \'[/TAG]\') return transformed_text def reverse_transform(transformed_text: str) -> str: Reverts occurrences of [TAG] to <tag> and [/TAG] to </tag> in the text. original_text = transformed_text.replace(\'[TAG]\', \'<tag>\').replace(\'[/TAG]\', \'</tag>\') return original_text def apply_transformation_to_file(input_filename: str, output_filename: str) -> None: Reads text from an input file, applies the transformation, and writes it to an output file. try: with open(input_filename, \'r\') as input_file: original_text = input_file.read() transformed_text = transform_text(original_text) with open(output_filename, \'w\') as output_file: output_file.write(transformed_text) except Exception as e: print(f\\"An error occurred: {e}\\") def reverse_transformation_from_file(input_filename: str, output_filename: str) -> None: Reads text from an input file, applies the reverse transformation, and writes it to an output file. try: with open(input_filename, \'r\') as input_file: transformed_text = input_file.read() original_text = reverse_transform(transformed_text) with open(output_filename, \'w\') as output_file: output_file.write(original_text) except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"# Introduction The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. Typically it starts with 0 and 1, and then each subsequent number in the sequence is the sum of the two preceding ones. # Task Write a function named `nth_fibonacci(n: int) -> int` that returns the n-th number in the Fibonacci sequence. For this task, the Fibonacci sequence starts with 0, i.e., `F(0) = 0`, `F(1) = 1`, and so on. # Requirements * **Function Signature**: `def nth_fibonacci(n: int) -> int:` * **Input**: An integer `n` representing the position (0-indexed) in the Fibonacci sequence. * **Output**: A single integer representing the n-th number in the Fibonacci sequence. # Constraints 1. The input `n` will be a non-negative integer. 2. You should implement an efficient solution with a time complexity of O(n). # Examples ```python >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(2) 1 >>> nth_fibonacci(3) 2 >>> nth_fibonacci(4) 3 >>> nth_fibonacci(5) 5 >>> nth_fibonacci(10) 55 >>> nth_fibonacci(20) 6765 >>> nth_fibonacci(30) 832040 >>> nth_fibonacci(50) 12586269025 ``` # Additional Notes * Your function needs to handle large values of `n` efficiently. * Consider using dynamic programming (bottom-up approach) to achieve the desired time complexity. * Recursion without memoization or iterative solutions with repeated calculations might lead to time limit exceeded errors for larger values of `n`, so please avoid such approaches.","solution":"def nth_fibonacci(n: int) -> int: Returns the n-th number in the Fibonacci sequence. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question In the context of image processing, you need to implement a function that calculates the average saturation of all pixels in a provided image. The image is represented as a 2D list of pixels, where each pixel is given in HSV (Hue, Saturation, Value) format. Your task is to implement the function `average_saturation` that computes the average value of the saturation component from all the pixels in the image. Function Signature ```python def average_saturation(image: list[list[tuple[float, float, float]]]) -> float: pass ``` # Input - `image` (2D list of `tuple[float, float, float]`): A 2D list representing the image, where each pixel is a tuple of three floats (H, S, V), each ranging from 0.0 to 1.0. # Output - The function should return a `float` value representing the average saturation of all the pixels in the image. # Constraints - `0 < len(image) <= 1000`: The number of rows in the image. - `0 < len(image[0]) <= 1000`: The number of columns in the image. - Each tuple (pixel) contains three values (H, S, V) where `0.0 <= H, S, V <= 1.0`. # Error Handling - If a pixel component is out of the valid range [0.0, 1.0], raise a `ValueError` with a message indicating the coordinates of the problematic pixel. - If the input image is empty, raise a `ValueError` with the message: \\"Empty image provided!\\". # Performance Requirements - The solution should efficiently compute the average saturation with a time complexity of O(m * n) where `m` is the number of rows and `n` is the number of columns. # Example ```python image = [ [(0.5, 0.8, 0.9), (0.4, 0.7, 0.6), (0.1, 0.3, 0.9)], [(0.3, 0.6, 0.5), (0.2, 0.3, 0.7), (0.6, 0.9, 0.2)] ] average_saturation(image) # Expected output: 0.6 ``` # Additional Context - The HSV (Hue, Saturation, Value) color model is often used in image processing because it is more perceptually relevant. Ensure to test your function thoroughly with both expected inputs and edge cases to validate your implementation.","solution":"def average_saturation(image): Returns the average saturation of all pixels in the given image. Args: image (2D list of tuple[float, float, float]): A 2D list representing an image in HSV format. Returns: float: The average saturation value across all pixels. if not image or not image[0]: raise ValueError(\\"Empty image provided!\\") total_saturation = 0.0 total_pixels = 0 for row_idx, row in enumerate(image): for col_idx, (h, s, v) in enumerate(row): if not (0.0 <= s <= 1.0): raise ValueError(f\\"Saturation value out of range at pixel ({row_idx}, {col_idx})\\") total_saturation += s total_pixels += 1 return total_saturation / total_pixels"},{"question":"# Coding Assessment Question Context You are tasked with manipulating a dataset of student grade information stored in a CSV file. Each record stores information for a student, including their name, student ID, and grades for different subjects. You need to implement functionality that processes this data to find and return the student with the highest average grade, excluding any grades below a given threshold. Question Write a Python function called `find_top_student` that reads student grade data from a CSV file, calculates the average grade for each student (excluding grades below a specified threshold), and returns the name and student ID of the top-performing student based on the highest average grade. The CSV file format will be as follows: - The first row is the header containing columns names (\\"name\\", \\"student_id\\", \\"subject1\\", \\"subject2\\", ..., \\"subjectN\\"). - Each subsequent row contains the student\'s name, student ID, and their grades for the respective subjects. Function Signature ```python import csv def find_top_student(file_path: str, grade_threshold: float) -> tuple[str, str]: pass ``` Input - `file_path` (str): The path to the CSV file containing student grade data. - `grade_threshold` (float): The minimum grade that should be considered when calculating averages. Output - A tuple containing: - `name` (str): The name of the top-performing student. - `student_id` (str): The student ID of the top-performing student. Constraints - Grades are numeric and in the range of 0 to 100. - If a student has no grades above the threshold, their average grade should be considered as zero. - Assume there will always be at least one student with grades above the threshold. - Handle edge cases such as missing values or invalid data smoothly. Example ```python # Assume \'grades.csv\' contains the following data: # name,student_id,math,science,english # Alice,12345,88,92,87 # Bob,67890,75,50,80 # Carol,13579,90,85,93 # Dave,24680,70,72,65 top_student = find_top_student(\'grades.csv\', 60) print(top_student) # Output: (\'Carol\', \'13579\') ``` Guidelines - Use the `csv` module for reading the CSV file. - Ensure robust error handling for file I/O operations. - Filter and calculate the averages accurately, disregarding grades below the threshold. - Optimize for readability and maintainability.","solution":"import csv def find_top_student(file_path: str, grade_threshold: float) -> tuple[str, str]: Reads student grade data from a CSV file, calculates the average grade for each student excluding grades below the grade_threshold, and returns the name and student ID of the student with the highest average grade. top_student = None highest_avg_grade = 0 try: with open(file_path, mode=\'r\') as file: csv_reader = csv.DictReader(file) for row in csv_reader: name = row[\'name\'] student_id = row[\'student_id\'] grades = [ float(value) for key, value in row.items() if key not in [\'name\', \'student_id\'] and value ] valid_grades = [grade for grade in grades if grade >= grade_threshold] if valid_grades: avg_grade = sum(valid_grades) / len(valid_grades) else: avg_grade = 0 if avg_grade > highest_avg_grade: highest_avg_grade = avg_grade top_student = (name, student_id) return top_student except Exception as e: print(f\\"Error reading file: {e}\\") return None"},{"question":"# Coding Assessment Question Scenario You are developing a software for a text editor that adjusts the formatting of text blocks. One feature users have requested is the ability to left-align a block of text so that each line starts at the same column, while preserving words and their order. Objective Implement a function `left_align_text(text: str, width: int) -> List[str]` that adjusts the text to be left-aligned within a given width. Description Your task is to format a block of text such that it fits within the specified width and aligns to the left. The text should be divided into multiple lines if necessary, ensuring that words are not broken in the middle. Spaces at the beginning or end of a line should be removed. # Requirements * Each word in the input text must be fully included in each output line. Words should not be split across lines. * Ensure that no output line exceeds the specified width. * Maintain the order of words in the text. # Input and Output * **Input**: * `text` (str): The block of text to be formatted. * `width` (int): The maximum width of each line. * **Output**: * `List[str]`: A list of strings, where each string is a left-aligned line of text. # Constraints * The input string contains printable ASCII characters. * The input text has a length of at most 5000 characters. * The width is a positive integer between 10 and 100 inclusive. # Example * `text = \\"The quick brown fox jumps over the lazy dog.\\"`, `width = 20` would return `[\\"The quick brown fox\\", \\"jumps over the lazy\\", \\"dog.\\"]`. # Implementation Details You should implement the solution efficiently, ensuring that the text is properly formatted within the given constraints. ```python from typing import List def left_align_text(text: str, width: int) -> List[str]: words = text.split() result = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > width: result.append(\' \'.join(current_line)) current_line = [] current_length = 0 current_line.append(word) current_length += len(word) if current_line: result.append(\' \'.join(current_line)) return result # Test the solution with the given example text = \\"The quick brown fox jumps over the lazy dog.\\" width = 20 print(left_align_text(text, width)) # Output: [\\"The quick brown fox\\", \\"jumps over the lazy\\", \\"dog.\\"] ```","solution":"from typing import List def left_align_text(text: str, width: int) -> List[str]: words = text.split() result = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > width: result.append(\' \'.join(current_line)) current_line = [] current_length = 0 current_line.append(word) current_length += len(word) if current_line: result.append(\' \'.join(current_line)) return result"},{"question":"# Question: Implement a List Reversal Using Iterative and Recursive Methods You are developing a utility for applications that require reversing sequences of data. Your task is to implement two functions to reverse a list of elements. You will write one function using an **iterative approach** and another function using a **recursive approach**. Function Signatures 1. `def reverse_iterative(lst: list[int | float | str]) -> list[int | float | str]` 2. `def reverse_recursive(lst: list[int | float | str], start: int, end: int) -> list[int | float | str]` Requirements * The iterative function should reverse the list using a loop. * The recursive function should reverse the list using recursion by swapping elements from the beginning and the end, moving towards the center. * Both functions should raise a `ValueError` if the input list is empty. * The recursive function should raise an `IndexError` if the start or end indices are out of range. Input * `lst`: A list of integers, floats, or strings. Example: `[1, 2, 3, 4, 5]` * `start`: The starting index for the recursive function. * `end`: The ending index for the recursive function. Output * Return the reversed list. Constraints * Elements can be a mix of integers, floats, and strings. * The indices for the recursive function must be valid, otherwise raise `IndexError`. Examples ```python # Iterative Examples assert reverse_iterative([1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1] assert reverse_iterative([\'a\', \'b\', \'c\']) == [\'c\', \'b\', \'a\'] assert reverse_iterative([1.1, 2.2, 3.3]) == [3.3, 2.2, 1.1] try: reverse_iterative([]) except ValueError: pass # This is expected # Recursive Examples assert reverse_recursive([1, 2, 3, 4, 5], 0, 4) == [5, 4, 3, 2, 1] assert reverse_recursive([\'a\', \'b\', \'c\'], 0, 2) == [\'c\', \'b\', \'a\'] assert reverse_recursive([1.1, 2.2, 3.3], 0, 2) == [3.3, 2.2, 1.1] try: reverse_recursive([], 0, 0) except ValueError: pass # This is expected try: reverse_recursive([1, 2, 3], -1, 2) except IndexError: pass # This is expected ``` Constraints & Limitations * Performance should be O(n) for both functions. * Space complexity should follow the characteristics of iterative or recursive implementations. * Ensure that your implementations handle edge cases correctly; provide enough test cases in your submission.","solution":"def reverse_iterative(lst): Reverse the list using an iterative approach. Args: lst (list of int | float | str): The list to reverse. Returns: list of int | float | str: The reversed list. Raises: ValueError: If the input list is empty. if not lst: raise ValueError(\\"Input list is empty\\") left, right = 0, len(lst) - 1 while left < right: lst[left], lst[right] = lst[right], lst[left] left += 1 right -= 1 return lst def reverse_recursive(lst, start, end): Reverse the list using a recursive approach. Args: lst (list of int | float | str): The list to reverse. start (int): The starting index. end (int): The ending index. Returns: list of int | float | str: The reversed list. Raises: ValueError: If the input list is empty. IndexError: If the start or end indices are out of range. if not lst: raise ValueError(\\"Input list is empty\\") if start < 0 or end >= len(lst): raise IndexError(\\"Index out of range\\") if start >= end: return lst lst[start], lst[end] = lst[end], lst[start] return reverse_recursive(lst, start + 1, end - 1)"},{"question":"# Question You have been tasked with implementing a library management system. One of the features required is to find overdue books from a list of borrowed books and their due dates. Implement a function `find_overdue_books` that takes in a list of tuples representing borrowed books and determines which books are overdue based on a given current date. # Requirements * **Function Signature**: `def find_overdue_books(borrowed_books: list[tuple[str, str]], current_date: str) -> list[str]:` * **Parameters**: - `borrowed_books`: A list of tuples, where each tuple represents a borrowed book and its due date in the format `(book_title: str, due_date: str)`. Both `book_title` and `due_date` are strings. The `due_date` is formatted as `\'YYYY-MM-DD\'`. - `current_date`: A string representing the current date in the format `\'YYYY-MM-DD\'`. * **Returns**: A list of book titles that are overdue as of the `current_date`. # Constraints 1. The date format in both `borrowed_books` and `current_date` will always be `\'YYYY-MM-DD\'`. 2. Assume all dates are valid dates. 3. The `borrowed_books` list can be empty, in which case the function should return an empty list. # Example ```python borrowed_books = [ (\\"The Great Gatsby\\", \\"2023-03-15\\"), (\\"1984\\", \\"2023-10-01\\"), (\\"To Kill a Mockingbird\\", \\"2023-04-22\\"), (\\"The Catcher in the Rye\\", \\"2023-01-10\\") ] current_date = \\"2023-06-01\\" print(find_overdue_books(borrowed_books, current_date)) # Output should be [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\"] current_date = \\"2023-02-01\\" print(find_overdue_books(borrowed_books, current_date)) # Output should be [\\"The Catcher in the Rye\\"] ``` # Implementation Guidelines * Parse the date strings and compare them to determine if a book is overdue. * Use Python’s `datetime` module to manage and compare date strings. * Ensure the code handles edge cases, such as empty lists and dates on the boundary of being overdue (i.e., the due date is the same as the current date).","solution":"from datetime import datetime def find_overdue_books(borrowed_books, current_date): Returns a list of book titles that are overdue as of the current_date. :param borrowed_books: List of tuples where each tuple contains the book title and its due date. :param current_date: The current date against which to check overdue status in \'YYYY-MM-DD\' format. :return: A list of overdue book titles. current_date_obj = datetime.strptime(current_date, \'%Y-%m-%d\') overdue_books = [ book_title for book_title, due_date in borrowed_books if datetime.strptime(due_date, \'%Y-%m-%d\') < current_date_obj ] return overdue_books"},{"question":"# Coding Assessment Question: Scenario: You are a software developer at a data analysis firm. Your team is creating a tool that needs to efficiently identify anomalies in data streams. Specifically, you need to verify if a sequence of numbers contains a subsequence where the sum of the numbers is a particular target value. Task: Write a function `has_subsequence_with_sum(arr: List[int], target: int) -> bool` that takes in an array of integers and a target value, and returns `True` if there exists a contiguous subsequence in the array that sums to the target value, and `False` otherwise. Input: - A list of integers, `arr`, which may contain both positive and negative numbers. - An integer `target` representing the sum to be checked against contiguous subsequences. Output: - A boolean `True` if there is a contiguous subsequence that sums to the target, `False` otherwise. Constraints: - The length of the array (`arr`) will be between 1 and 10^5. - Each integer in the array will be between -10^4 and 10^4. Examples: ```python has_subsequence_with_sum([1, 4, 20, 3, 10, 5], 33) # Returns: True (because 20+3+10=33) has_subsequence_with_sum([-10, 2, 3, -2, 0, 5, 1], 8) # Returns: True (because 3-2+0+5+1=7) has_subsequence_with_sum([1, 4, -2, -3, 5, 6], 5) # Returns: True (because 1+4=5) has_subsequence_with_sum([-1, -1, -1, -1], -4) # Returns: True (because -1-1-1-1=-4) has_subsequence_with_sum([1, 2, 3], 7) # Returns: False ``` # Additional Information: - The function should have a time complexity close to O(n). - You should avoid using nested loops to maintain efficiency. - Make use of hashing or sliding window techniques to achieve optimal performance. Example Testing Code: ```python # Test case 1 assert has_subsequence_with_sum([1, 4, 20, 3, 10, 5], 33) == True # Test case 2 assert has_subsequence_with_sum([-10, 2, 3, -2, 0, 5, 1], 8) == True # Test case 3 assert has_subsequence_with_sum([1, 4, -2, -3, 5, 6], 5) == True # Test case 4 assert has_subsequence_with_sum([-1, -1, -1, -1], -4) == True # Test case 5 assert has_subsequence_with_sum([1, 2, 3], 7) == False print(\\"All test cases pass\\") ``` Use this function definition to write your code: ```python from typing import List def has_subsequence_with_sum(arr: List[int], target: int) -> bool: # Your code here pass ```","solution":"from typing import List def has_subsequence_with_sum(arr: List[int], target: int) -> bool: current_sum = 0 sum_set = set() for num in arr: current_sum += num if current_sum == target: return True if (current_sum - target) in sum_set: return True sum_set.add(current_sum) return False"},{"question":"# Matrix Spiral Sum Given an `m x n` matrix with non-negative integer elements, traverse the matrix in a spiral order and return the sum of the elements encountered during the traversal. The traversal begins at the top-left corner and proceeds as follows: 1. Right across the topmost remaining row. 2. Down the rightmost remaining column. 3. Left across the bottommost remaining row. 4. Up the leftmost remaining column. 5. Repeat steps 1-4 until all elements are traversed. **Objective**: Write a Python function `spiral_sum(matrix: List[List[int]]) -> int` that: 1. Traverses the matrix in spiral order. 2. Returns the sum of the elements encountered during the traversal. **Function Signature**: ```python def spiral_sum(matrix: List[List[int]]) -> int: pass ``` # Input - `matrix`: A list of lists of non-negative integers representing the `m x n` matrix. # Output - An integer, the sum of elements encountered during the spiral traversal. # Example: Suppose the `matrix` is: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The traversal is: 1 -> 2 -> 3 -> 6 -> 9 -> 8 -> 7 -> 4 -> 5 And the sum is: 1 + 2 + 3 + 6 + 9 + 8 + 7 + 4 + 5 = 45 # Constraints: - The dimensions of the matrix `m` and `n` are such that 1 ≤ m, n ≤ 100. - The matrix elements are within the range [0, 1000]. # Notes: - Handle edge cases such as an empty matrix or a matrix with one row or one column. - Ensure the function returns the correct sum in an optimal manner.","solution":"from typing import List def spiral_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 total_sum = 0 top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): total_sum += matrix[top][i] top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): total_sum += matrix[i][right] right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): total_sum += matrix[bottom][i] bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): total_sum += matrix[i][left] left += 1 return total_sum"},{"question":"Collision Detection in a 2D Space Shooter Game **Objective**: Implement a robust collision detection system for a 2D space shooter game that accurately determines when and where objects in the game collide. # Problem Statement You are given a partially completed 2D space shooter game. The game involves various objects such as the player\'s spaceship, enemies, and projectiles. Your task is to implement the collision detection functionality to handle interactions between these objects effectively. # Expected Input and Output * **Input**: - The current positions and dimensions (width, height) of each object. - Object types (e.g., spaceship, enemy, projectile). * **Output**: - Collision events, specifying the objects involved and the collision points. - Update the game state based on the detected collisions (e.g., removing destroyed objects, updating scores). # Constraints 1. (1 leq text{number of objects} leq 10^4) 2. Positions and dimensions are floating-point numbers. 3. Objects are rectangular and aligned along the axes. 4. The game world is bounded, with x and y coordinates typically ranging from 0 to a specified maximum (e.g., 0 ≤ x, y ≤ 1000). # Function Definitions Implement the following functions within the `GameEngine` class to manage collision detection and state updates: ```python class GameObject: def __init__(self, x: float, y: float, width: float, height: float, obj_type: str): self.x = x self.y = y self.width = width self.height = height self.obj_type = obj_type class GameEngine: def __init__(self): self.objects = [] def add_object(self, obj: GameObject) -> None: Add a new game object to the engine. self.objects.append(obj) def detect_collisions(self) -> List[Tuple[GameObject, GameObject]]: Detect collisions between objects and return a list of collision pairs. collisions = [] n = len(self.objects) for i in range(n): for j in range(i + 1, n): if self.is_collision(self.objects[i], self.objects[j]): collisions.append((self.objects[i], self.objects[j])) return collisions def is_collision(self, obj1: GameObject, obj2: GameObject) -> bool: Check if two given objects collide. return not (obj1.x + obj1.width < obj2.x or obj1.x > obj2.x + obj2.width or obj1.y + obj1.height < obj2.y or obj1.y > obj2.y + obj2.height) def update_game_state(self) -> None: Update the game state based on detected collisions. collisions = self.detect_collisions() for obj1, obj2 in collisions: if obj1.obj_type == \'projectile\' or obj2.obj_type == \'projectile\': self.objects.remove(obj1) self.objects.remove(obj2) # Update score or any other game logic # For simplicity, handle each collision by removing the involved objects ``` # Example Scenario Consider a scenario with three objects: 1. Player spaceship: Positioned at (100, 150), width = 50, height = 50. 2. Enemy spaceship: Positioned at (130, 150), width = 50, height = 50. 3. Projectile: Positioned at (110, 160), width = 5, height = 5. **Simulation Steps**: 1. Add these objects to the game engine. 2. Detect collisions and update the game state. 3. Verify that the projectile collides with the player spaceship and both are removed from the game state. The enemy spaceship remains unaffected. # Example Code ```python player_ship = GameObject(100, 150, 50, 50, \\"spaceship\\") enemy_ship = GameObject(130, 150, 50, 50, \\"enemy\\") projectile = GameObject(110, 160, 5, 5, \\"projectile\\") engine = GameEngine() engine.add_object(player_ship) engine.add_object(enemy_ship) engine.add_object(projectile) engine.update_game_state() print(len(engine.objects)) # Expected output: 1 (only enemy_ship should remain) ``` Implement the collision detection system to ensure accurate and efficient game state management, thereby enhancing the gameplay experience.","solution":"from typing import List, Tuple class GameObject: def __init__(self, x: float, y: float, width: float, height: float, obj_type: str): self.x = x self.y = y self.width = width self.height = height self.obj_type = obj_type class GameEngine: def __init__(self): self.objects = [] def add_object(self, obj: GameObject) -> None: Add a new game object to the engine. self.objects.append(obj) def detect_collisions(self) -> List[Tuple[GameObject, GameObject]]: Detect collisions between objects and return a list of collision pairs. collisions = [] n = len(self.objects) for i in range(n): for j in range(i + 1, n): if self.is_collision(self.objects[i], self.objects[j]): collisions.append((self.objects[i], self.objects[j])) return collisions def is_collision(self, obj1: GameObject, obj2: GameObject) -> bool: Check if two given objects collide. return not (obj1.x + obj1.width < obj2.x or obj1.x > obj2.x + obj2.width or obj1.y + obj1.height < obj2.y or obj1.y > obj2.y + obj2.height) def update_game_state(self) -> None: Update the game state based on detected collisions. collisions = self.detect_collisions() for obj1, obj2 in collisions: if \'projectile\' in (obj1.obj_type, obj2.obj_type): if obj1 in self.objects: self.objects.remove(obj1) if obj2 in self.objects: self.objects.remove(obj2) # Update score or any other game logic"},{"question":"# Secure Chat Server with Asynchronous IO and Authentication You are required to build a secure chat server that allows multiple clients to connect and communicate with each other in a chat room. The server should use asynchronous I/O and implement basic user authentication. Function Specification: Implement the function `start_chat_server(port: int = 12345, auth_file: str = \\"users.txt\\") -> None`. This function should: 1. Create an asynchronous I/O server socket that listens for incoming client connections on the specified port. 2. When a client connects, prompt them for a username and password, and authenticate the user against a simple text file (`auth_file`). 3. Once authenticated, allow the user to send and receive messages to/from other connected clients in real-time. 4. Implement error handling to manage connection issues and disconnections gracefully. 5. Ensure the server can handle multiple clients simultaneously, with efficient message broadcasting. 6. Add logging to track connection events, authentication attempts, message broadcasts, and errors. Input: - `port` (int): The port number on which the server listens for incoming connections. Defaults to `12345`. - `auth_file` (str): The name of the file containing user credentials in the format `username:password` on each line. Defaults to `\\"users.txt\\"`. Constraints: - The `auth_file` format is simple, with each line containing `username:password` pairs. - The server should handle multiple clients concurrently. - Clients should be able to send messages to the server, which broadcasts them to all other connected clients. - Implement proper error handling and cleanup for client disconnections. - Use asynchronous I/O operations to handle socket interactions. - Ensure the server can be terminated gracefully (e.g., using signal handlers for SIGINT). Example Usage: ```python if __name__ == \\"__main__\\": start_chat_server(12345, \\"users.txt\\") ``` In this example, the server will start, listen for incoming connections on port `12345`, and authenticate users against the `users.txt` file before allowing them to join the chat room. Notes: - You do not need to implement the client-side code, but you may write it for your testing purposes. - Consider Python\'s `asyncio` module for managing asynchronous I/O operations. - Make sure to handle user authentication securely and efficiently. - Ensure the server gracefully handles SIGINT termination and client disconnections. ```python import asyncio import logging import signal # Implement the start_chat_server function here if __name__ == \\"__main__\\": start_chat_server(12345, \\"users.txt\\") ```","solution":"import asyncio import logging import signal logging.basicConfig(level=logging.INFO) CLIENTS = {} async def handle_client(reader, writer): addr = writer.get_extra_info(\'peername\') logging.info(f\\"Connection from {addr}\\") if not await authenticate_user(reader, writer): logging.info(f\\"Authentication failed for {addr}\\") writer.close() await writer.wait_closed() return try: while True: data = await reader.read(100) if not data: logging.info(f\\"Disconnected from {addr}\\") break message = data.decode() logging.info(f\\"Received {message} from {addr}\\") await broadcast_message(message, addr) except asyncio.CancelledError: logging.info(f\\"Handling client {addr} was cancelled\\") finally: writer.close() await writer.wait_closed() del CLIENTS[writer] logging.info(f\\"Closed connection from {addr}\\") async def broadcast_message(message, sender_addr): for writer in CLIENTS.values(): if writer.get_extra_info(\'peername\') != sender_addr: writer.write(f\\"{sender_addr}: {message}\\".encode()) await writer.drain() async def authenticate_user(reader, writer): writer.write(\\"Username: \\".encode()) await writer.drain() username = (await reader.read(100)).decode().strip() writer.write(\\"Password: \\".encode()) await writer.drain() password = (await reader.read(100)).decode().strip() with open(\\"users.txt\\", \\"r\\") as f: for line in f: stored_user, stored_pass = line.strip().split(\\":\\") if username == stored_user and password == stored_pass: writer.write(f\\"Welcome {username}!n\\".encode()) CLIENTS[writer] = writer return True writer.write(\\"Authentication failed. Goodbye!n\\".encode()) await writer.drain() return False async def start_chat_server(port=12345, auth_file=\\"users.txt\\"): server = await asyncio.start_server(handle_client, \'127.0.0.1\', port) async with server: logging.info(f\\"Chat server running on port {port}\\") await server.serve_forever() def main(): loop = asyncio.get_event_loop() for sig in (signal.SIGINT, signal.SIGTERM): loop.add_signal_handler(sig, lambda: asyncio.ensure_future(shutdown(loop))) try: loop.run_until_complete(start_chat_server()) finally: loop.close() async def shutdown(loop): logging.info(\\"Shutting down server...\\") tasks = [t for t in asyncio.all_tasks() if t is not asyncio.current_task()] list(map(lambda task: task.cancel(), tasks)) await asyncio.gather(*tasks, return_exceptions=True) loop.stop() if __name__ == \\"__main__\\": main()"},{"question":"**Problem Statement:** You are tasked with implementing and testing a Min Heap data structure. The heap should have the following functionalities: 1. `__init__(self)`: Initializes an empty heap. 2. `insert(self, element: int) -> None`: Inserts an element into the heap. 3. `get_min(self) -> int`: Returns the smallest element in the heap without removing it. Raises an `Exception` with the message `\\"Empty Heap\\"` if the heap is empty. 4. `extract_min(self) -> int`: Removes and returns the smallest element in the heap. Raises an `Exception` with the message `\\"Empty Heap\\"` if the heap is empty. 5. `is_empty(self) -> bool`: Returns `True` if the heap is empty, `False` otherwise. # Input and Output Format: * **Input**: * The `insert` method takes one argument which is the item to be added to the heap. * The `get_min`, `extract_min`, and `is_empty` methods do not take any arguments. * **Output**: * The `insert` method does not return any value. * The `get_min` and `extract_min` methods return the smallest element in the heap. If the heap is empty, these functions should raise an `Exception` with the message `\\"Empty Heap\\"`. * The `is_empty` method returns a boolean indicating whether the heap is empty. # Constraints: * The heap should maintain the min-heap property, where each parent node is smaller than or equal to its child nodes. * Ensure that you handle edge cases gracefully such as attempting to extract the minimum from an empty heap or getting the minimum from an empty heap. # Example: ```python heap = MinHeap() assert heap.is_empty() heap.insert(10) heap.insert(5) heap.insert(14) assert heap.get_min() == 5 assert not heap.is_empty() assert heap.extract_min() == 5 assert heap.get_min() == 10 heap.insert(7) assert heap.extract_min() == 7 assert heap.extract_min() == 10 assert heap.extract_min() == 14 try: heap.get_min() except Exception as e: assert str(e) == \\"Empty Heap\\" try: heap.extract_min() except Exception as e: assert str(e) == \\"Empty Heap\\" ``` Implement the `MinHeap` class in Python with the methods specified above.","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] def insert(self, element: int) -> None: heapq.heappush(self.heap, element) def get_min(self) -> int: if not self.heap: raise Exception(\\"Empty Heap\\") return self.heap[0] def extract_min(self) -> int: if not self.heap: raise Exception(\\"Empty Heap\\") return heapq.heappop(self.heap) def is_empty(self) -> bool: return len(self.heap) == 0"},{"question":"**Problem Statement**: You are given a list of strings representing log entries from a server. The log entries are formatted as `<timestamp> <log_level> <message>`, where `<timestamp>` is the time in a `YYYY-MM-DD HH:MM:SS` format, `<log_level>` is one of `INFO`, `WARN`, or `ERROR`, and `<message>` is the log message. Your task is to write a function that filters out all log entries of a specific log level while preserving the chronological order. **Function Signature**: ```python def filter_logs(logs: list[str], log_level: str) -> list[str]: ``` **Inputs**: - `logs`: A list of strings representing the log entries. Each log entry string follows the format `<timestamp> <log_level> <message>`. The list can have up to 100,000 log entries. - `log_level`: A string indicating the log level to filter out. This will be one of `INFO`, `WARN`, or `ERROR`. **Outputs**: - Return a list of log entries that do not contain the given `log_level`. **Constraints**: - Ensure that the preserved log entries are in the same order as they appeared in the original list. - Validate that the input `log_level` is one of the specified valid levels; otherwise, raise a `ValueError`. - Aim for an O(n) time complexity. **Scenario**: Imagine you are an engineer analyzing server logs to track issues and behavior. You need to filter out irrelevant log entries of a specific level to focus on more critical information. **Examples**: ```python >>> filter_logs([\\"2023-01-10 10:00:00 INFO System started\\", ... \\"2023-01-10 10:01:00 ERROR Connection failed\\", ... \\"2023-01-10 10:02:00 WARN Disk space low\\", ... \\"2023-01-10 10:03:00 INFO User login\\"], ... \\"INFO\\") [\'2023-01-10 10:01:00 ERROR Connection failed\', \'2023-01-10 10:02:00 WARN Disk space low\'] >>> filter_logs([\\"2023-02-15 12:34:56 INFO Service rebooted\\", ... \\"2023-02-15 13:00:00 ERROR Disk error\\"], ... \\"ERROR\\") [\'2023-02-15 12:34:56 INFO Service rebooted\'] >>> filter_logs([\\"2023-03-10 14:00:00 WARN High memory usage\\", ... \\"2023-03-10 14:01:00 INFO CPU load normal\\"], ... \\"DEBUG\\") Traceback (most recent call last): ... ValueError: Invalid log level ``` **Requirements**: - Raise a `ValueError` if the provided `log_level` is not one of `INFO`, `WARN`, or `ERROR`. - The solution should be efficient in terms of both time and space complexity.","solution":"def filter_logs(logs: list[str], log_level: str) -> list[str]: Filters out log entries of the specified log level. Parameters: logs (list of str): List of log entries. log_level (str): The log level to filter out (INFO, WARN, or ERROR). Returns: list of str: List of log entries that do not contain the specified log level. valid_levels = {\\"INFO\\", \\"WARN\\", \\"ERROR\\"} if log_level not in valid_levels: raise ValueError(\\"Invalid log level\\") return [log for log in logs if not log.startswith(f\\"{log[:19]} {log_level}\\")] # Example Usage: # logs = [ # \\"2023-01-10 10:00:00 INFO System started\\", # \\"2023-01-10 10:01:00 ERROR Connection failed\\", # \\"2023-01-10 10:02:00 WARN Disk space low\\", # \\"2023-01-10 10:03:00 INFO User login\\" # ] # log_level = \\"INFO\\" # print(filter_logs(logs, log_level)) # Output: [\'2023-01-10 10:01:00 ERROR Connection failed\', \'2023-01-10 10:02:00 WARN Disk space low\']"},{"question":"# Scenario: You are a developer tasked with creating a function to optimize the operations performed on a list of students\' records. Each student record includes an ID, name, and score. The function should efficiently handle updates to the records and provide the ability to retrieve the top-k scoring students. # Task: Write a class `StudentRecords` that manages the list of student records and has the following methods: 1. `add_student(id: int, name: str, score: int)`: Adds a new student record. 2. `update_score(id: int, new_score: int)`: Updates the score of an existing student by their ID. 3. `get_top_k_students(k: int) -> list[tuple[int, str, int]]`: Retrieves the top-k scoring students sorted in descending order by their scores. If two students have the same score, sort them by their ID in ascending order. # Input Formats: - The `id` is a unique integer for each student. - The `name` is a string of the student\'s name. - The `score` is an integer representing the student\'s score. - `k` is an integer specifying the number of top students to retrieve. # Output Format: - The `get_top_k_students` method should return a list of tuples, each containing the ID, name, and score of the top-k students. # Constraints: - Each ID is unique. - The operations must be efficient considering there can be up to 100,000 students. - Scores can range from 0 to 100. # Example: ```python records = StudentRecords() records.add_student(1, \\"Alice\\", 91) records.add_student(2, \\"Bob\\", 85) records.add_student(3, \\"Charlie\\", 91) records.add_student(4, \\"David\\", 78) records.update_score(2, 95) # Expected Output (Top 3 students): # [(2, \\"Bob\\", 95), (1, \\"Alice\\", 91), (3, \\"Charlie\\", 91)] top_students = records.get_top_k_students(3) print(top_students) ``` # Implementation: Implement the `StudentRecords` class according to the described functionality. ```python from heapq import nlargest class StudentRecords: def __init__(self): self.records = {} def add_student(self, id: int, name: str, score: int): self.records[id] = (name, score) def update_score(self, id: int, new_score: int): if id in self.records: name = self.records[id][0] self.records[id] = (name, new_score) def get_top_k_students(self, k: int) -> list[tuple[int, str, int]]: sorted_records = nlargest(k, self.records.items(), key=lambda x: (x[1][1], -x[0])) return [(id, name, score) for id, (name, score) in sorted_records] # Example usage: records = StudentRecords() records.add_student(1, \\"Alice\\", 91) records.add_student(2, \\"Bob\\", 85) records.add_student(3, \\"Charlie\\", 91) records.add_student(4, \\"David\\", 78) records.update_score(2, 95) # Expected Output (Top 3 students): # [(2, \\"Bob\\", 95), (1, \\"Alice\\", 91), (3, \\"Charlie\\", 91)] top_students = records.get_top_k_students(3) print(top_students) ```","solution":"from heapq import nlargest class StudentRecords: def __init__(self): self.records = {} def add_student(self, id: int, name: str, score: int): self.records[id] = (name, score) def update_score(self, id: int, new_score: int): if id in self.records: name = self.records[id][0] self.records[id] = (name, new_score) def get_top_k_students(self, k: int) -> list[tuple[int, str, int]]: sorted_records = nlargest(k, self.records.items(), key=lambda x: (x[1][1], -x[0])) return [(id, name, score) for id, (name, score) in sorted_records]"},{"question":"# Description: Create a function that parses a string containing a mathematical expression into a list of the individual components (numbers and operators) while preserving the order. This task focuses on your ability to handle string manipulation and parsing. # Objective: Write a function `parse_expression(expression: str) -> list` that takes a string containing a mathematical expression and returns a list of its numeric and operator elements in the order they appear. The expression will contain integers, addition, subtraction, multiplication, and division operators. # Input: * A string `expression`, representing a mathematical expression consisting of integers and the operators `+`, `-`, `*`, `/`. # Output: * A list of strings, where each string is either an integer or one of the operators `+`, `-`, `*`, `/`. # Requirements: * Ensure the solution can correctly parse a valid mathematical expression. * Handle invalid characters or empty strings by raising an appropriate error. * The function must be efficient and readable. # Constraints: * The input string can have leading, trailing, or intermediate spaces which should be ignored. * The operators and integers will always be separated by at least one space. Example: ``` >>> parse_expression(\\"10 + 24 - 5 * 3\\") [\'10\', \'+\', \'24\', \'-\', \'5\', \'*\', \'3\'] >>> parse_expression(\\"72 / 8 + 6\\") [\'72\', \'/\', \'8\', \'+\', \'6\'] >>> parse_expression(\\"100 -50 *2\\") Traceback (most recent call last): ... ValueError: Invalid input expression >>> parse_expression(\\"\\") Traceback (most recent call last): ... ValueError: Empty input expression ``` Test Cases to Validate: ```python assert parse_expression(\\"10 + 24 - 5 * 3\\") == [\'10\', \'+\', \'24\', \'-\', \'5\', \'*\', \'3\'] assert parse_expression(\\"72 / 8 + 6\\") == [\'72\', \'/\', \'8\', \'+\', \'6\'] assert parse_expression(\\"123 * 456 / 789\\") == [\'123\', \'*\', \'456\', \'/\', \'789\'] assert parse_expression(\\" 1 + 2 \\") == [\'1\', \'+\', \'2\'] try: parse_expression(\\"\\") except ValueError as e: assert str(e) == \\"Empty input expression\\" try: parse_expression(\\"100 -50 *2\\") except ValueError as e: assert str(e) == \\"Invalid input expression\\" try: parse_expression(\\"10 + a - 3\\") except ValueError as e: assert str(e) == \\"Invalid input expression\\" ``` # Implementation Function Stub ```python def parse_expression(expression: str) -> list: import re if not expression.strip(): raise ValueError(\\"Empty input expression\\") pattern = re.compile(r\'d+|[+-*/]\') tokens = pattern.findall(expression) if not tokens or any(not re.match(r\'^d+|^[+-*/]\', token) for token in tokens): raise ValueError(\\"Invalid input expression\\") return tokens ```","solution":"import re def parse_expression(expression: str) -> list: if not expression.strip(): raise ValueError(\\"Empty input expression\\") # Remove leading and trailing spaces and split into list of potential tokens parts = expression.strip().split() # Check if any part contains invalid characters for part in parts: if not re.fullmatch(r\'d+|[+-*/]\', part): raise ValueError(\\"Invalid input expression\\") return parts"},{"question":"# Question You are tasked with implementing a function that computes the edit distance between two strings using dynamic programming. The edit distance is a way of quantifying how dissimilar two strings are to one another by counting the minimum number of operations required to transform one string into the other. The allowed operations are insertion, deletion, and substitution of a single character. # Function Signature ```python def edit_distance(str1: str, str2: str) -> int: ``` # Input * `str1: str` - The first string. * `str2: str` - The second string. # Output * `int` - The minimum number of edit operations needed to transform `str1` into `str2`. # Constraints * Both strings are non-empty and their lengths do not exceed 1000 characters. # Examples ```python assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance(\\"intention\\", \\"execution\\") == 5 assert edit_distance(\\"apple\\", \\"apple\\") == 0 ``` # Implementation Guide 1. **Initialize a DP Table**: Create a 2D array `dp` where `dp[i][j]` represents the edit distance between the first `i` characters of `str1` and the first `j` characters of `str2`. 2. **Base Cases**: - The edit distance of an empty `str1` to `str2` of length `j` is `j` (all insertions). - The edit distance of `str1` of length `i` to an empty `str2` is `i` (all deletions). 3. **Fill the Table**: - For each pair of indices `(i, j)`, if `str1[i-1] == str2[j-1]`, then `dp[i][j] = dp[i-1][j-1]` (no new operation needed). - Otherwise, consider the three possible operations (insertion, deletion, substitution) and take the minimum count plus one operation. 4. **Return the Result**: The value at `dp[len(str1)][len(str2)]` will be the minimum edit distance required. # Note - Ensure that your solution has a time and space complexity of roughly `O(m*n)` where `m` is the length of `str1` and `n` is the length of `str2`. - You should handle edge cases where one or both strings might be empty.","solution":"def edit_distance(str1: str, str2: str) -> int: Computes the minimum edit distance between two strings using dynamic programming. len1, len2 = len(str1), len(str2) # Create a 2D array to store results of subproblems dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Initialize the table with base cases for i in range(len1 + 1): dp[i][0] = i # Deletion operation from str1 to empty str2 for j in range(len2 + 1): dp[0][j] = j # Insertion operation from empty str1 to str2 # Fill the table using the optimal substructure for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation needed else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Substitution return dp[len1][len2]"},{"question":"# Question: As a data analyst, you are working with a dataset represented as a list of tuples. Each tuple consists of two elements: an ID (integer) and a score (float). Your task is to write a function that finds and returns the tuple that contains the highest score. If there are multiple tuples with the highest score, return the one with the smallest ID. Function Signature: ```python def find_highest_score(data: List[Tuple[int, float]]) -> Tuple[int, float]: ``` # Requirements: 1. Implement the `find_highest_score` function to efficiently find the tuple with the highest score. 2. If multiple tuples have the highest score, return the one with the smallest ID. 3. Handle edge cases such as: - Empty list. - Lists with all tuples having the same score. # Expected input and output formats: - **Input**: A list of tuples where each tuple is of form `(ID, score)`. - **Output**: A tuple representing the ID and score of the highest scoring entry. # Performance requirements: - **Aim for O(n)** time complexity for `find_highest_score`, where `n` is the length of the list. # Sample Test Cases: ```python assert find_highest_score([(1, 95.2), (2, 95.2), (3, 94.9)]) == (1, 95.2) assert find_highest_score([(3, 85.5), (2, 90.0), (1, 90.0)]) == (1, 90.0) assert find_highest_score([(1, 100.0), (2, 100.0)]) == (1, 100.0) assert find_highest_score([]) == () ``` # Additional Context: - Ensure the function handles large datasets efficiently. - Use built-in Python functions and data structures for optimal performance. - Consider edge cases and provide additional test cases to validate accuracy.","solution":"def find_highest_score(data): Returns the tuple with the highest score. If multiple tuples have the highest score, returns the one with the smallest ID. Parameters: data (List[Tuple[int, float]]): List of tuples where each tuple consists of an ID and a score. Returns: Tuple[int, float]: Tuple with the highest score. If multiple tuples have the same score, smallest ID is prioritized. if not data: return () highest_score = float(\'-inf\') best_tuple = () for t in data: id, score = t if score > highest_score or (score == highest_score and id < best_tuple[0]): highest_score = score best_tuple = t return best_tuple"},{"question":"# Coding Assessment Question You need to design and implement a function that calculates the product of all elements in a list except for the element at a specified index. Essentially, the function should return a new list where each element at index `i` is the product of all numbers in the original list except the one at `i`. # Task Your function should meet the following requirements: 1. **Function Name**: `product_except_self` 2. **Input**: * `nums` (List[int]): A list of integers. 3. **Output**: * A new list where each element at index `i` contains the product of all elements in `nums` except `nums[i]`. # Example ```python nums = [1, 2, 3, 4] print(product_except_self(nums)) # Output: [24, 12, 8, 6] nums = [0, 1, 2, 3, 4] print(product_except_self(nums)) # Output: [24, 0, 0, 0, 0] ``` # Constraints * The length of `nums` will be in the range `[2, 10^4]`. * All elements of `nums` are integers within the range `[-10^2, 10^2]`. * You must solve this problem without using division and in O(n) time complexity. # Notes * Handle edge cases, especially with zero values intelligently. * Make sure your implementation is efficient and optimized for large input sizes. Good luck!","solution":"def product_except_self(nums): Returns a list where each element at index `i` is the product of all elements in the input list except for the element at index `i`. length = len(nums) # Initialize a result array with ones result = [1] * length # Calculate prefixes prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] # Calculate suffixes and multiply with prefixes suffix = 1 for i in range(length - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"# Question: Implement Balanced Binary Search Tree (BST) Validator As a skilled software engineer, you are required to implement a function that validates whether a given binary tree is a balanced Binary Search Tree (BST). A balanced BST is defined as a binary tree in which the height of the two subtrees of every node never differs by more than one and the tree should satisfy the BST property where each node value must be greater than all the values in its left subtree and less than all the values in its right subtree. Requirements: 1. **Function Signature**: Implement the function `is_balanced_bst(root: Optional[TreeNode]) -> bool`. 2. **Input**: The function takes the root node of a binary tree, `root`. The binary tree is represented using the following `TreeNode` class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 3. **Output**: Return a boolean indicating if the given binary tree is a balanced BST. 4. **Time Complexity**: Aim for an optimal time complexity, ideally O(n), where n is the number of nodes in the tree. 5. **Constraints**: * The number of nodes in the tree can be up to 10^4. * Each node\'s value will be in the range [-10^4, 10^4]. Edge Cases to Handle: * The tree is empty (i.e., `root` is `None`). * The tree has only one node. * The tree is not balanced. * The tree does not satisfy the BST property. * The tree has duplicates. Example: ```python >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> is_balanced_bst(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> is_balanced_bst(root) False >>> root = TreeNode(10) >>> root.left = TreeNode(6) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(8) >>> root.right.left = TreeNode(12) >>> root.right.right = TreeNode(17) >>> is_balanced_bst(root) True >>> is_balanced_bst(None) True ``` **Note**: Ensure to follow best coding practices, addressing all edge cases, and optimizing the function for both correctness and performance.","solution":"from typing import Optional, Tuple class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_bst(root: Optional[TreeNode]) -> bool: def helper(node: Optional[TreeNode]) -> Tuple[bool, int, int, int]: if not node: return True, 0, float(\'inf\'), float(\'-inf\') left_is_bst, left_height, left_min, left_max = helper(node.left) right_is_bst, right_height, right_min, right_max = helper(node.right) current_is_bst = (left_is_bst and right_is_bst and left_max < node.val < right_min) current_height = max(left_height, right_height) + 1 is_balanced = abs(left_height - right_height) <= 1 overall_is_bst = current_is_bst and is_balanced current_min = min(node.val, left_min) current_max = max(node.val, right_max) return overall_is_bst, current_height, current_min, current_max return helper(root)[0]"},{"question":"You are working on a system that handles network packets with different priorities. Your task is to develop functions that manage the priority queue and to process packets according to their priority using a preemptive Priority Scheduling algorithm. # Function Specifications **Function 1**: ```python def insert_packet(priority_queue: list[tuple[int, int]], packet: tuple[int, int]) -> None: pass ``` **Function 2**: ```python def process_packets(priority_queue: list[tuple[int, int]], current_time: int) -> tuple[list[int], list[int]]: pass ``` # Input * `priority_queue`: A list of tuples where each tuple contains two integers representing the packet\'s priority and its burst/execution time respectively. * `packet`: A tuple containing two integers representing the priority and burst time of a new packet to be added to the priority queue. * `current_time`: An integer representing the current time at which the packet processing is simulated to start. # Output * For `insert_packet`: The function doesn\'t return anything but it should insert the packet into the priority queue at the correct position based on priority. * For `process_packets`: A tuple of two lists: * The first list contains integers representing the time each packet starts processing. * The second list contains integers representing the time each packet finishes processing. # Constraints * 1 ≤ number of packets ≤ 1000 * 0 ≤ priority ≤ 10 * 1 ≤ burst_time ≤ 1000 # Requirements * Implement `insert_packet` function to maintain a priority queue where packets are ordered by their priority (lower number means higher priority). * Implement `process_packets` function to simulate the processing of packets in the priority queue based on their priority and preemptively switching between packets if necessary. * Ensure the functions handle all edge cases, such as packets with the same priority or burst time. * Maintain the integrity of packet processing order particularly when processing, considering the current time. # Example ```python # Inputs priority_queue = [(3, 4), (1, 10), (2, 5)] packet = (1, 3) current_time = 0 # Function 1: insert_packet insert_packet(priority_queue, packet) # Priority Queue Output: [(1, 3), (1, 10), (2, 5), (3, 4)] # Function 2: process_packets start_times, finish_times = process_packets(priority_queue, current_time) # Start Times Output: [0, 3, 13, 18] # Finish Times Output: [3, 13, 18, 22] # Explanation: # Packet (1, 3) starts at 0 and finishes at 3 # Packet (1, 10) starts at 3 and finishes at 13 # Packet (2, 5) starts at 13 and finishes at 18 # Packet (3, 4) starts at 18 and finishes at 22 ```","solution":"def insert_packet(priority_queue: list[tuple[int, int]], packet: tuple[int, int]) -> None: Inserts a packet (priority, burst_time) into the priority_queue at the correct position based on the priority. priority_queue.append(packet) priority_queue.sort(key=lambda x: (x[0], x[1])) def process_packets(priority_queue: list[tuple[int, int]], current_time: int) -> tuple[list[int], list[int]]: Processes the packets in the priority_queue according to their priority and preemptively switching between packets if necessary. Args: priority_queue (list): A list of tuples, where each tuple contains (priority, burst_time). current_time (int): The current time to start processing. Returns: tuple: Two lists; the first contains the start times and the second contains the finish times of packets. start_times = [] finish_times = [] for priority, burst_time in priority_queue: start_times.append(current_time) current_time += burst_time finish_times.append(current_time) return (start_times, finish_times)"},{"question":"# Image Processing - Edge Detection You are required to develop a function that performs edge detection on a grayscale image using the Sobel operator. The function should identify and highlight edges within the image, thereby enhancing its structural features. # Requirements: 1. **Input**: A 2D list of integers representing a grayscale image where each integer ranges from 0 to 255. 2. **Output**: A 2D list of integers representing the edges detected in the image, with the same dimensions as the input image. The pixel values should be normalized to the range 0 to 255. 3. **Function Implementation**: Write a function `sobel_edge_detection(image: list[list[int]]) -> list[list[int]]`. # Constraints: 1. The function should handle edge cases like the boundaries of the image appropriately. 2. Implement the Sobel operator for both horizontal (Gx) and vertical (Gy) gradients. 3. Compute the gradient magnitude and normalize the output pixel values. # Example: ```python def sobel_edge_detection(image: list[list[int]]) -> list[list[int]]: # Your implementation # Test case grayscale_image = [ [200, 200, 200, 200, 200], [200, 50, 50, 50, 200], [200, 50, 200, 50, 200], [200, 50, 50, 50, 200], [200, 200, 200, 200, 200] ] edges = sobel_edge_detection(grayscale_image) for row in edges: print(row) ``` # Scenario: Consider an application in which you are developing software to process and analyze medical images. You need to implement edge detection to highlight key structural elements in grayscale images such as CT scans or X-rays. Your function should efficiently and accurately identify edges to aid in subsequent image analysis tasks. # Notes: - Utilize the Sobel kernels for calculating the horizontal and vertical gradients. - The Sobel kernels are defined as: ```plaintext Gx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]] Gy = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]] ``` - Combine the gradients to compute the edge intensity. - Ensure the output values are properly normalized to the range 0 to 255. - Handle different sizes and edge cases in the input images appropriately.","solution":"import numpy as np def sobel_edge_detection(image: list[list[int]]) -> list[list[int]]: Gx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]] Gy = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]] image = np.array(image, dtype=np.float32) height, width = image.shape edges = np.zeros((height, width), dtype=np.float32) for i in range(1, height - 1): for j in range(1, width - 1): sub_matrix = image[i-1:i+2, j-1:j+2] gx = np.sum(Gx * sub_matrix) gy = np.sum(Gy * sub_matrix) edges[i, j] = np.sqrt(gx**2 + gy**2) # Normalize to 0-255 edges = np.clip(edges, 0, 255) edges = (edges / edges.max()) * 255 edges = edges.astype(np.uint8) return edges.tolist()"},{"question":"# Question: You are developing a music streaming service that allows users to create and customize their own playlists. Each playlist is represented as a list of song IDs, and each song ID is a unique integer. Users can mark their favorite songs, which are also uniquely identified integers, not necessarily in any playlist. Your task is to write a function that checks whether all the favorite songs of a user are included in at least one of their playlists. # Function Signature ```python def are_favorites_in_playlists(playlists: List[List[int]], favorites: List[int]) -> bool: pass ``` # Input * **playlists**: a list of lists of integers, where each inner list denotes a playlist (0 ≤ len(playlists) ≤ 10^4, 0 ≤ len(playlists[i]) ≤ 10^4). * **favorites**: a list of integers representing the user\'s favorite songs (0 ≤ len(favorites) ≤ 10^4). # Output * **Returns**: a boolean value, where `True` indicates that all favorite songs are in at least one playlist, and `False` otherwise. # Constraints * The maximum possible total number of song IDs across all playlists is 10^6. # Example ```python >>> are_favorites_in_playlists([[1, 2, 3], [4, 5, 6]], [1, 4, 6]) True >>> are_favorites_in_playlists([[10, 20, 30], [40, 50]], [1, 10, 50]) False >>> are_favorites_in_playlists([], [1, 2]) False >>> are_favorites_in_playlists([[1, 1, 2], [2, 3, 4]], [3, 2]) True >>> are_favorites_in_playlists([[100, 200, 300]], []) True ``` # Explanation * For the first example, all the favorite songs (1, 4, and 6) are present in the playlists, so the function returns `True`. * In the second example, the favorite song 1 is not in any playlist, so the function returns `False`. * In the third example, there are no playlists, but there are favorite songs, so the function returns `False`. * In the fourth example, though song 2 appears twice in the playlists, it does not affect the result, all favorites are present, so the function returns `True`. * In the fifth example, there are no favorite songs, so the function trivially returns `True`.","solution":"from typing import List def are_favorites_in_playlists(playlists: List[List[int]], favorites: List[int]) -> bool: # Create a set to store all unique songs across all playlists all_songs = set() # Add all songs in playlists to the set for playlist in playlists: all_songs.update(playlist) # Check if all favorite songs are in the set of all songs for favorite in favorites: if favorite not in all_songs: return False return True"},{"question":"# Coding Assessment Question You are required to implement a function to manage a student\'s academic records. The function will allow adding grades, calculating the GPA, and retrieving a grade report. Ensure the function supports input validation, handles error scenarios, and accurately computes the results. Task Implement a class `StudentRecord` to manage a student\'s academic grades. The class should have the following properties and methods: Class Definition ```python class StudentRecord: def __init__(self, name: str): pass def add_grade(self, course: str, grade: float) -> None: pass def calculate_gpa(self) -> float: pass def grade_report(self) -> dict[str, float]: pass ``` Parameters - `name` (str): The student\'s name. Must be a non-empty string. Methods - `add_grade(course: str, grade: float) -> None`: Adds a new grade for a course. - `course` (str): The name of the course. Must be a non-empty string. - `grade` (float): The grade achieved by the student. Must be between 0.0 and 4.0 inclusive. - `calculate_gpa() -> float`: Calculates and returns the student\'s GPA. - GPA is the average of all grades. - `grade_report() -> dict[str, float]`: Returns the student\'s grade report. - The report is a dictionary where the keys are course names, and the values are the grades. Constraints - Raise a `ValueError` if the `name` is an empty string during instantiation. - Raise a `ValueError` if `course` is an empty string or if `grade` is not between 0.0 and 4.0 inclusive. - If no grades are available, `calculate_gpa` should return 0.0. Example ```python >>> student = StudentRecord(\\"Alice\\") >>> student.add_grade(\\"Math\\", 3.5) >>> student.add_grade(\\"English\\", 4.0) >>> student.add_grade(\\"Physics\\", 3.0) >>> student.calculate_gpa() 3.5 >>> student.grade_report() {\'Math\': 3.5, \'English\': 4.0, \'Physics\': 3.0} >>> student2 = StudentRecord(\\"Bob\\") >>> student2.calculate_gpa() 0.0 >>> student2.grade_report() {} ``` Notes: - Ensure the class correctly manages multiple grades for different courses. - Consider proper error handling and input validation to prevent invalid input values. - The GPA should be a float rounded to two decimal places.","solution":"class StudentRecord: def __init__(self, name: str): if not name: raise ValueError(\\"Student name must be a non-empty string\\") self.name = name self.grades = {} def add_grade(self, course: str, grade: float) -> None: if not course: raise ValueError(\\"Course name must be a non-empty string\\") if not (0.0 <= grade <= 4.0): raise ValueError(\\"Grade must be between 0.0 and 4.0 inclusive\\") self.grades[course] = grade def calculate_gpa(self) -> float: if not self.grades: return 0.0 total_grades = sum(self.grades.values()) return round(total_grades / len(self.grades), 2) def grade_report(self) -> dict: return self.grades"},{"question":"# List Rotator Create a function that will rotate a given list to the right by a specified number of steps. A rotation by one step moves each element of the list one position to the right, with the last element wrapping around to the first position. Function Signature ```python def rotate_list(nums: list, steps: int) -> list: ``` Inputs - `nums` (list): The list of elements to be rotated. - `steps` (int): The number of steps to rotate the list to the right. Output - (list): The list after being rotated the specified number of steps. Constraints - The list can be empty (`[]`). - The steps will be a non-negative integer. - If `steps` is larger than the length of the list, rotations should wrap around appropriately. Example Usage ```python >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list([], 3) [] ``` Explanation Write a function that: 1. Handles the case where the list is empty by directly returning an empty list. 2. Modulo the number of steps by the length of the list to account for full rotations that just return the original list. 3. Reconstructs the list by slicing and concatenating the appropriate segments after rotation. Ensure your solution is efficient and handles edge cases such as non-existent rotations or multiple full rotations properly.","solution":"def rotate_list(nums: list, steps: int) -> list: Rotate the list nums to the right by the specified number of steps. Parameters: nums (list): The list to be rotated. steps (int): The number of steps to rotate the list. Returns: list: The rotated list. if not nums: return nums n = len(nums) steps = steps % n # Adjust steps if larger than list length return nums[-steps:] + nums[:-steps]"},{"question":"# Binary Tree Traversal with Specific Constraints **Scenario**: You are developing an application that analyzes binary trees for various properties. You need to implement a class that supports in-order, pre-order, and post-order traversal but with an additional constraint: the traversal should only include nodes whose values are even numbers. **Task**: Implement the `CustomBinaryTree` class with methods to traverse the tree according to the specified traversal types while adhering to the constraint on even number values. **Function Signatures**: ```python class CustomBinaryTree: def __init__(self, value: int): self.value = value self.left = None self.right = None def insert_left(self, value: int) -> None: pass def insert_right(self, value: int) -> None: pass def in_order(self) -> list[int]: pass def pre_order(self) -> list[int]: pass def post_order(self) -> list[int]: pass ``` **Requirements**: 1. **Insertion Functions (`insert_left` and `insert_right`)**: - These methods will insert left and right children respectively. - The children should be instances of the `CustomBinaryTree` class. 2. **Traversal Functions (`in_order`, `pre_order`, `post_order`)**: - Each of these methods returns a list of integers. - The integers should represent the values of nodes encountered in the specified traversal order, but only include even-valued nodes. - Follow the traditional definitions of in-order, pre-order, and post-order traversal. **Constraints**: - Each node\'s value will be an integer between -10,000 and 10,000. - The binary tree will contain up to 10,000 nodes. **Example**: ```python # Sample Usage tree = CustomBinaryTree(6) tree.insert_left(3) tree.insert_right(8) tree.left.insert_left(4) tree.left.insert_right(7) tree.right.insert_right(10) # Expected traversals with only even values included: tree.in_order() # [4, 6, 8, 10] tree.pre_order() # [6, 4, 8, 10] tree.post_order() # [4, 10, 8, 6] ``` Ensure your implementation is efficient, correctly filters even numbers, and handles various edge cases. Validate your solution with multiple test cases covering different tree structures.","solution":"class CustomBinaryTree: def __init__(self, value: int): self.value = value self.left = None self.right = None def insert_left(self, value: int) -> None: self.left = CustomBinaryTree(value) def insert_right(self, value: int) -> None: self.right = CustomBinaryTree(value) def _in_order_helper(self, node, result): if node: self._in_order_helper(node.left, result) if node.value % 2 == 0: result.append(node.value) self._in_order_helper(node.right, result) def in_order(self) -> list[int]: result = [] self._in_order_helper(self, result) return result def _pre_order_helper(self, node, result): if node: if node.value % 2 == 0: result.append(node.value) self._pre_order_helper(node.left, result) self._pre_order_helper(node.right, result) def pre_order(self) -> list[int]: result = [] self._pre_order_helper(self, result) return result def _post_order_helper(self, node, result): if node: self._post_order_helper(node.left, result) self._post_order_helper(node.right, result) if node.value % 2 == 0: result.append(node.value) def post_order(self) -> list[int]: result = [] self._post_order_helper(self, result) return result"},{"question":"# Coding Assessment Question Context You are working on an algorithm to manage batch processing of tasks in a manufacturing system. Each task can have different dependencies, meaning some tasks cannot start until other specific tasks are completed. Given the list of tasks and their respective dependencies, you need to determine the order in which the tasks should be executed to ensure all dependencies are respected. Task Implement a function `find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]` that determines the execution order of tasks. - `num_tasks`: An integer representing the total number of tasks, numbered from 0 to `num_tasks - 1`. - `dependencies`: A list of tuples, where each tuple (a, b) means task `b` must be completed before task `a`. The goal is to return a list representing the order in which tasks should be executed. If no valid order exists due to a circular dependency, return an empty list. Input - An integer `num_tasks` (2 ≤ num_tasks ≤ 1000) - A list of tuples `dependencies` representing the dependencies. Output - A list of integers representing the task execution order, or an empty list if no valid order exists. Example ```python def find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: pass # Example Usage num_tasks = 4 dependencies = [(1, 0), (2, 1), (3, 2)] assert find_task_order(num_tasks, dependencies) == [0, 1, 2, 3] num_tasks = 3 dependencies = [(0, 1), (1, 2), (2, 0)] assert find_task_order(num_tasks, dependencies) == [] ``` Requirements - Your implementation should use a topological sorting approach to solve the problem. - Consider edge cases, such as when there are no dependencies or when circular dependencies exist. Constraints - Ensure your solution is efficient and can handle the constraints given.","solution":"from typing import List, Tuple from collections import deque, defaultdict def find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: # Initialize the in-degree and adjacency list in_degree = [0] * num_tasks adj_list = defaultdict(list) # Populate the in-degree and adjacency list based on dependencies for a, b in dependencies: adj_list[b].append(a) in_degree[a] += 1 # Initialize the queue with tasks having 0 in-degree zero_in_degree_queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) order = [] # Process the queue while zero_in_degree_queue: current_task = zero_in_degree_queue.popleft() order.append(current_task) # Decrease the in-degree of neighboring tasks for neighbor in adj_list[current_task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the order includes all tasks, return it if len(order) == num_tasks: return order else: return []"},{"question":"# Coding Question You are given an array of integers `arr` representing the heapified structure of a binary min-heap. Your task is to implement an operation to increase the key of a given element and maintain the min-heap property. To do this, you will need to implement a decrease_key operation in a class representing a Min-Heap. Function Signature ```python class MinHeap: def __init__(self, heap: List[int]): self.heap = heap def decrease_key(self, index: int, new_value: int) -> None: pass def heapify_down(self, index: int) -> None: pass ``` Task 1. **Decrease Key**: - Implement a `decrease_key` method that takes an `index` at which the key is to be decreased and the `new_value` which will be the updated key value. - If the `new_value` is greater than the current value at `index`, raise a ValueError since it is not a decrease. 2. **Heapify Down**: - Implement a `heapify_down` method that maintains the min-heap property starting from the given `index`. - This method may be used to restore the min-heap property after the key has been decreased. Input - An instance of the `MinHeap` is initialized with the `heap`, a list of integers representing a min-heap. - The `decrease_key(index, new_value)` method is called with an integer `index` and integer `new_value`. Output - The `decrease_key` method modifies the heap in place to reflect the updated key while maintaining the min-heap property. Constraints - `1 <= len(arr) <= 10^5` - `0 <= index < len(arr)` - `new_value` is an integer Example Usage ```python heap = MinHeap([1, 3, 6, 5, 9, 8]) heap.decrease_key(3, 2) # The heap should rearrange to maintain min-heap property assert heap.heap == [1, 2, 6, 5, 9, 8] heap = MinHeap([1, 2, 3, 4, 5, 6]) heap.decrease_key(4, 1) # The heap will rearrange to [1, 1, 3, 4, 2, 6] assert heap.heap == [1, 1, 3, 4, 2, 6] try: heap.decrease_key(2, 10) # This should raise a ValueError since 10 is not a decrease except ValueError: pass ``` Notes - You are required to write both methods in the `MinHeap` class. - Ensure optimal performance while maintaining the min-heap property efficiently.","solution":"from typing import List class MinHeap: def __init__(self, heap: List[int]): self.heap = heap def decrease_key(self, index: int, new_value: int) -> None: if new_value > self.heap[index]: raise ValueError(\\"new_value is greater than the current value at the specified index\\") self.heap[index] = new_value self.heapify_up(index) def heapify_up(self, index: int) -> None: parent = (index - 1) // 2 while index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent parent = (index - 1) // 2"},{"question":"# Problem: Calculate Rectangular to Polar Coordinates Conversion As a physics student analyzing waveforms and signal processing, you often need to convert complex numbers from rectangular coordinates to polar coordinates. The rectangular coordinates are given as real and imaginary parts of a complex number, while the polar coordinates are represented by the magnitude and phase angle. The provided function should take the real and imaginary parts of a complex number and return its magnitude and phase angle in degrees. # Conversion Formulas - The magnitude (r) of a complex number is calculated using: [ r = sqrt{a^2 + b^2} ] - The phase angle (θ) in degrees is calculated using: [ theta = text{atan2}(b, a) times frac{180}{pi} ] where: * `a` is the real part of the complex number, * `b` is the imaginary part of the complex number. # Function Signature ```python def rectangular_to_polar(a: float, b: float) -> (float, float): ``` # Input * `a`: A float representing the real part of the complex number. * `b`: A float representing the imaginary part of the complex number. # Output * Returns a tuple (magnitude, angle) where: - `magnitude` is a float representing the magnitude of the complex number. - `angle` is a float representing the phase angle in degrees. # Constraints * Both inputs are guaranteed to be real numbers. * The output should be accurate to at least 5 decimal places. # Examples ```python >>> rectangular_to_polar(3, 4) (5.0, 53.1301) >>> rectangular_to_polar(1, 1) (1.41421, 45.0) >>> rectangular_to_polar(-1, -1) (1.41421, -135.0) >>> rectangular_to_polar(0, 5) (5.0, 90.0) ``` # Performance Requirement Your function should utilize an efficient approach to ensure O(1) time complexity.","solution":"import math def rectangular_to_polar(a: float, b: float) -> (float, float): Converts a complex number from rectangular to polar coordinates. Parameters: a (float): The real part of the complex number. b (float): The imaginary part of the complex number. Returns: (float, float): A tuple where the first element is the magnitude and the second element is the angle in degrees. magnitude = math.sqrt(a**2 + b**2) angle = math.atan2(b, a) * (180 / math.pi) return round(magnitude, 5), round(angle, 5)"},{"question":"# Question: Reverse a Linked List You are given a singly linked list. Your task is to implement a function that reverses the linked list iteratively and returns the head of the reversed list. **Input**: 1. A singly linked list, represented by its head node `head`. **Output**: - The head node of the reversed linked list. **Function Signature**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: pass ``` # Constraints: 1. The number of nodes in the list is in the range `[0, 5000]`. 2. `-100 <= Node.val <= 100` # Example: ```python # Example of linked list creation node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 head = node1 # Function call new_head = reverse_linked_list(head) # Printing reversed list result = [] while new_head: result.append(new_head.val) new_head = new_head.next print(result) # Output should be [5, 4, 3, 2, 1] ``` # Explanation: - The linked list: `1 -> 2 -> 3 -> 4 -> 5` gets reversed to `5 -> 4 -> 3 -> 2 -> 1`. - The output should represent the values in the nodes of the reversed list. - Handle edge cases such as an empty list (input `head` is `None`) or a list with a single node. Implement your function to efficiently reverse the linked list using an iterative approach, ensuring that the constraints are respected and edge cases are covered.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None current = head while current is not None: next_node = current.next # store next node current.next = prev # reverse the link prev = current # move prev to current current = next_node # move to next node return prev"},{"question":"# Data Preprocessing Before Regression Analysis As a data scientist working on a regression analysis task, you are responsible for preparing a dataset before feeding it into a regression model. The task involves data normalization and fitting the processed data to a simple linear regression model. Your task involves the following steps: 1. **Data Normalization**: Write a function `normalize_and_predict(X_train, y_train, X_test)` that: * Takes as input: * `X_train`, a list of training input samples (each sample itself a list of feature values). * `y_train`, a list of training labels (continuous values). * `X_test`, a list of input samples to be used for testing the trained model. * Normalizes the features in both `X_train` and `X_test` using Min-Max scaling. 2. **Fit Regression Model**: The function should fit a simple linear regression model on the normalized training data. 3. **Make Predictions**: The function should return the predicted labels (continuous values) for the `X_test` data based on the trained model. **Input and Output Format:** Input: ```python X_train = [[1, 2], [2, 3], [4, 5], [3, 6]] y_train = [3.5, 4.5, 7.0, 6.0] X_test = [[2, 3], [3, 4]] ``` Output: ```python [4.5, 5.5] ``` Your implementation must account for the following constraints and ensure it performs these operations correctly and efficiently. ```python from sklearn.preprocessing import MinMaxScaler from sklearn.linear_model import LinearRegression def normalize_and_predict(X_train, y_train, X_test): Normalize the dataset and train a linear regression model. Args: X_train (list of list of float): Training input samples. y_train (list of float): Training labels. X_test (list of list of float): Test input samples. Returns: list of float: Predicted labels for the test data. # Step 1: Normalize the data scaler = MinMaxScaler() X_train_normalized = scaler.fit_transform(X_train) X_test_normalized = scaler.transform(X_test) # Step 2: Fit the regression model model = LinearRegression() model.fit(X_train_normalized, y_train) # Step 3: Make predictions on the test data predictions = model.predict(X_test_normalized) return predictions.tolist() # Example usage (you can use this for testing your function): X_train = [[1, 2], [2, 3], [4, 5], [3, 6]] y_train = [3.5, 4.5, 7.0, 6.0] X_test = [[2, 3], [3, 4]] predictions = normalize_and_predict(X_train, y_train, X_test) print(predictions) # Expected output: [4.5, 5.5] ```","solution":"from sklearn.preprocessing import MinMaxScaler from sklearn.linear_model import LinearRegression def normalize_and_predict(X_train, y_train, X_test): Normalize the dataset and train a linear regression model. Args: X_train (list of list of float): Training input samples. y_train (list of float): Training labels. X_test (list of list of float): Test input samples. Returns: list of float: Predicted labels for the test data. # Step 1: Normalize the data scaler = MinMaxScaler() X_train_normalized = scaler.fit_transform(X_train) X_test_normalized = scaler.transform(X_test) # Step 2: Fit the regression model model = LinearRegression() model.fit(X_train_normalized, y_train) # Step 3: Make predictions on the test data predictions = model.predict(X_test_normalized) return predictions.tolist()"},{"question":"# Unique Character Substring Finder Scenario: You are designing a feature for a text processing application that needs to find the longest substring of a given string containing only unique characters. Your task is to write a function that returns the longest substring with all unique characters from the input string. Task: Implement the function `longest_unique_substring(s: str) -> str`, which returns the longest substring of `s` that contains only unique characters. Details: - If there are multiple substrings of the same maximum length, return the first one encountered. - The input string `s` contains only lowercase letters. Input: 1. **s (str)** - the input string with `1 <= len(s) <= 10^5`. Output: - **str** - the longest substring with all unique characters. Examples: ```python # Example 1 s = \\"abcabcbb\\" # Longest substrings with unique characters are \\"abc\\", \\"bca\\", \\"cab\\" # Return the first one encountered, which is \\"abc\\". print(longest_unique_substring(\\"abcabcbb\\")) # Output: \\"abc\\" # Example 2 s = \\"bbbbb\\" # The longest substring with unique characters is \\"b\\". print(longest_unique_substring(\\"bbbbb\\")) # Output: \\"b\\" # Example 3 s = \\"pwwkew\\" # Longest substrings with unique characters are \\"wke\\", \\"kew\\" # Return the first one encountered, which is \\"wke\\". print(longest_unique_substring(\\"pwwkew\\")) # Output: \\"wke\\" ``` Constraints: - Your solution should have a time complexity of O(n), where `n` is the length of the string. Tips: 1. Use a sliding window approach to maintain a window of unique characters. 2. Use a set to track the characters in the current window. 3. Expand the window by moving a right pointer, and contract the window by moving a left pointer if a duplicate character is found.","solution":"def longest_unique_substring(s: str) -> str: Finds the longest substring with all unique characters in a given string. Args: s (str): The input string. Returns: str: The longest substring with all unique characters. start = 0 max_len = 0 max_substr = \\"\\" char_index_map = {} for end in range(len(s)): if s[end] in char_index_map: # Update the start position if current character is already in the window start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end # Update maximum length and substring if necessary if end - start + 1 > max_len: max_len = end - start + 1 max_substr = s[start:end+1] return max_substr"},{"question":"# Question: Implement a Morse Code Translator **Context**: Morse code is a method used in telecommunication to encode text characters as sequences of dots and dashes. Your task is to implement functions that translate text to Morse code and Morse code back to text. **Function 1**: `text_to_morse(text: str) -> str` **Function 2**: `morse_to_text(morse: str) -> str` **Input**: 1. `text` (string) - A message containing only alphabetic characters (both uppercase and lowercase), digits (0-9), and spaces. * The conversion should be case-insensitive. * Spaces in text should be preserved in the encoded Morse code with a space between Morse code of each character. 2. `morse` (string) - A Morse code message containing sequences of dots (\'.\'), dashes (\'-\'), and spaces. * A single space (\' \') separates Morse code for each character. * Three spaces (\' \') separate Morse code for words. **Output**: 1. `text_to_morse` returns a string which is the Morse code translation of the input text. 2. `morse_to_text` returns a string which is the decoded text message from the input Morse code. **Constraints**: * Text input will only include alphabetic characters, digits, and space. * Morse code input will follow the specified format (dots, dashes, and spaces). * The encoding and decoding should preserve the structure of words and characters as described in the input. **Examples**: 1. `text_to_morse(\\"HELLO WORLD\\")` returns `\\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\"` 2. `morse_to_text(\\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\")` returns `\\"HELLO WORLD\\"` 3. `text_to_morse(\\"SOS\\")` returns `\\"... --- ...\\"` 4. `morse_to_text(\\"... --- ...\\")` returns `\\"SOS\\"` **Performance Requirements**: * The implementation should efficiently handle string operations and ensure accurate translation between text and Morse code.","solution":"# Morse Code Dictionary MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \' \': \' \' } # Reverse Morse Code Dictionary for decoding REVERSE_MORSE_CODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()} def text_to_morse(text: str) -> str: Converts text to Morse code. text = text.upper() morse_code = \' \'.join(MORSE_CODE_DICT[char] for char in text) return morse_code def morse_to_text(morse: str) -> str: Converts Morse code to text. words = morse.split(\' \') decoded_message = [] for word in words: decoded_message.append(\'\'.join(REVERSE_MORSE_CODE_DICT[char] for char in word.split())) return \' \'.join(decoded_message)"},{"question":"# Problem Statement: Scenario: You are tasked with developing an inventory tracking system for a small bookstore. The system should manage the inventory of books, including adding new books, updating stock quantities, and retrieving information about a specific book. Function Signature: ```python class Bookstore: def __init__(self): pass def add_book(self, title: str, author: str, quantity: int) -> bool: pass def update_stock(self, title: str, quantity: int) -> bool: pass def get_book_info(self, title: str) -> dict: pass ``` Input and Output: 1. **add_book**: - **title** (str): The title of the book. - **author** (str): The author of the book. - **quantity** (int): The number of books to be added to the inventory. - **Output** (bool): Returns `True` if the book was added successfully, and `False` if the book already exists. 2. **update_stock**: - **title** (str): The title of the book. - **quantity** (int): The new quantity of books in stock. - **Output** (bool): Returns `True` if the stock was updated successfully, and `False` if the book does not exist in the inventory. 3. **get_book_info**: - **title** (str): The title of the book. - **Output** (dict): Returns a dictionary with the book\'s title, author, and quantity. If the book is not found, return an empty dictionary. Constraints: - The title and author strings must be at least 1 character long and contain only alphanumeric characters and spaces. - Quantity should be a non-negative integer. Example: ```python bookstore = Bookstore() # Add new books print(bookstore.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 10)) # Expected output: True print(bookstore.add_book(\\"1984\\", \\"George Orwell\\", 5)) # Expected output: True print(bookstore.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 10)) # Expected output: False # Update stock print(bookstore.update_stock(\\"1984\\", 15)) # Expected output: True print(bookstore.update_stock(\\"The Great Gatsby\\", 7)) # Expected output: False # Get book info print(bookstore.get_book_info(\\"1984\\")) # Expected output: {\'title\': \'1984\', \'author\': \'George Orwell\', \'quantity\': \'15\'} print(bookstore.get_book_info(\\"The Great Gatsby\\")) # Expected output: {} # Error Cases print(bookstore.add_book(\\"1984\\", \\"George Orwell\\", -5)) # Expected output: False (Invalid quantity) ``` Notes: - Ensure robust error handling for invalid inputs such as empty titles, authors or negative quantities. - The class should maintain an internal data structure, such as a dictionary, to keep track of the books and their respective details. - Implement methods to add, update, and retrieve book information adhering to the constraints mentioned.","solution":"class Bookstore: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, quantity: int) -> bool: if not (title and author and isinstance(quantity, int) and quantity >= 0): return False if title in self.inventory: return False self.inventory[title] = {\'author\': author, \'quantity\': quantity} return True def update_stock(self, title: str, quantity: int) -> bool: if title in self.inventory and isinstance(quantity, int) and quantity >= 0: self.inventory[title][\'quantity\'] = quantity return True return False def get_book_info(self, title: str) -> dict: if title in self.inventory: return {\'title\': title, \'author\': self.inventory[title][\'author\'], \'quantity\': self.inventory[title][\'quantity\']} return {}"},{"question":"**Recursive Sequence Sum** # Problem Description You are to write a function to calculate the sum of a specific type of recursive sequence. The sequence is defined as follows: - The first term `a(0)` is always `1`. - The second term `a(1)` is always `1`. - For any `n >= 2`, the term `a(n)` is the sum of all preceding terms. # Task Write a function that: 1. Computes the nth term of this sequence. 2. Returns the sum of all terms in the sequence up to and including `a(n)`. # Function Signature ```python def sequence_sum(n: int) -> int: pass ``` # Input - `n` (int): The term to compute the sum up to (0 <= n <= 30). # Output - Returns the sum of all terms in the sequence up to and including `a(n)`. # Explanation Each term is the sum of all previous terms: - `a(0) = 1` - `a(1) = 1` - `a(2) = a(0) + a(1) = 1 + 1 = 2` - `a(3) = a(0) + a(1) + a(2) = 1 + 1 + 2 = 4` - `a(4) = a(0) + a(1) + a(2) + a(3) = 1 + 1 + 2 + 4 = 8` - And so on... # Example ```python >>> sequence_sum(0) 1 >>> sequence_sum(1) 2 >>> sequence_sum(2) 4 >>> sequence_sum(3) 8 >>> sequence_sum(4) 16 ``` # Constraints - Ensure the function handles the largest possible `n` value efficiently. - The sequence must be calculated recursively, and the sum of the terms up to `a(n)` must be returned. # Notes - Since `n` is relatively small, an iterative approach can be used to build the sequence efficiently.","solution":"def sequence_sum(n: int) -> int: Computes the nth term of the specified sequence and returns the sum of all terms in the sequence up to and including the nth term. if n == 0: return 1 if n == 1: return 2 # Sequence cache to store already computed terms sequence = [1, 1] for i in range(2, n + 1): next_term = sum(sequence) sequence.append(next_term) return sum(sequence)"},{"question":"# Graph Connectivity Check **Context**: You\'re working on a project involving network theory and need to verify the connectivity of a graph. This operation is crucial for ensuring that all nodes in the graph are reachable, which can be important in applications like social network analysis, telecommunications, and transportation. **Problem Statement**: Implement a function `is_connected` that checks whether an undirected graph is connected. The graph is represented as an adjacency matrix, where a value of 1 indicates an edge between nodes and 0 indicates no edge. # Function Signature ```python def is_connected(adj_matrix: List[List[int]]) -> bool: pass ``` # Input - **adj_matrix (List[List[int]])**: A square adjacency matrix representing an undirected graph. `adj_matrix[i][j]` is 1 if there is an edge between node `i` and node `j`, otherwise 0. # Output - **bool**: Returns `True` if the graph is connected, `False` otherwise. # Constraints 1. The adjacency matrix will be of dimension `n x n`, where `n` is the number of nodes and `n <= 100`. 2. The matrix will be symmetric (`adj_matrix[i][j]` will equal `adj_matrix[j][i]`). # Examples ```python # Example 1 adj_matrix_1 = [ [0, 1, 0, 0, 1], [1, 0, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 0, 1], [1, 0, 0, 1, 0], ] print(is_connected(adj_matrix_1)) # Output: True # Example 2 adj_matrix_2 = [ [0, 1, 0], [1, 0, 0], [0, 0, 0], ] print(is_connected(adj_matrix_2)) # Output: False ``` # Notes * Your function should return `True` if every node in the graph can be reached from any other node. * You can use graph traversal algorithms such as Depth-First Search (DFS) or Breadth-First Search (BFS) to determine connectivity. * Consider edge cases such as a graph with a single node and an empty (no edges) but valid adjacency matrix of larger size. **Testing**: Besides the provided examples, create additional test cases to validate your implementation, including edge cases such as: 1. Graphs with varying numbers of nodes up to the maximum constraint. 2. Completely disconnected graphs (no edges at all). 3. Graphs with exactly one disconnected component.","solution":"from typing import List def is_connected(adj_matrix: List[List[int]]) -> bool: Checks whether the undirected graph represented by adj_matrix is connected. n = len(adj_matrix) visited = [False] * n def dfs(node): visited[node] = True for neighbor, has_edge in enumerate(adj_matrix[node]): if has_edge and not visited[neighbor]: dfs(neighbor) # Start DFS from the first node dfs(0) # Check if all nodes are visited return all(visited)"},{"question":"Scenario Graph traversal algorithms are fundamental in computer science, powering numerous applications such as network analysis, pathfinding in AI, and more. Your task is to create an implementation that leverages breadth-first search to solve a practical problem involving a directed graph. This problem evaluates your knowledge of graph data structures, traversal techniques, and algorithm optimization. Problem Statement Given a directed graph represented as an adjacency list and a start node, implement the function `reachable_nodes(graph: Dict[int, List[int]], start_node: int) -> List[int]` to return a sorted list of all nodes that can be reached from the `start_node` using the breadth-first search algorithm. Input - `graph` (dictionary): A dictionary where keys are node identifiers (integers), and values are lists of integers representing the nodes that can be directly reached from the key node. - `start_node` (integer): The starting node for the breadth-first search. Output - Returns a sorted list of integers representing all nodes that are reachable from the `start_node` in the graph. Function Signature ```python def reachable_nodes(graph: Dict[int, List[int]], start_node: int) -> List[int]: pass ``` Example ```python >>> reachable_nodes({0: [1, 2], 1: [2], 2: [3], 3: []}, 0) [0, 1, 2, 3] >>> reachable_nodes({0: [1], 1: [2], 2: [], 3: [4], 4: []}, 3) [3, 4] >>> reachable_nodes({}, 0) [] ``` Constraints - The graph may contain up to 1000 nodes. - `start_node` is guaranteed to be a key in the `graph` if the graph is not empty. - Nodes are identified by non-negative integers. Note Ensure that your implementation can handle the largest possible graph within reasonable time limits.","solution":"from typing import List, Dict from collections import deque def reachable_nodes(graph: Dict[int, List[int]], start_node: int) -> List[int]: Returns a sorted list of all nodes that can be reached from the start_node in the given directed graph using breadth-first search. if not graph: return [] visited = set() queue = deque([start_node]) reachable = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) reachable.append(node) for neighbour in graph.get(node, []): if neighbour not in visited: queue.append(neighbour) reachable.sort() return reachable"},{"question":"# Problem Statement You are managing a logistics company and need to optimize the daily delivery route for a single delivery truck. The truck starts from the depot (origin point) and must visit all customer locations exactly once and then return to the depot. This problem is conceptually known as the Traveling Salesman Problem (TSP) and is NP-hard. To keep things simple, you will implement a heuristic solution using the nearest neighbor algorithm: Starting from the depot, always visit the nearest unvisited customer until all customers have been visited, then return to the depot. # Function Signature ```python def nearest_neighbor_tsp(locations: list[tuple[int, int]]) -> list[int]: ``` # Input Format * A single argument: `locations` (list of tuples) - a list of `(x, y)` coordinates of the delivery locations, including the depot as the first location. # Output Format * Return a list of integers - the indices of locations in the order they are visited, starting and ending at the depot. # Constraints * 1 <= len(locations) <= 100 * Each location `(x, y)` consists of two integers -10^6 <= x, y <= 10^6 # Example ```python Input nearest_neighbor_tsp([(0, 0), (2, 3), (5, 4), (6, 1), (8, 2)]) Output [0, 1, 2, 3, 4, 0] ``` # Notes * The depot is always the first location in the list. * You must calculate the Euclidean distance between locations to determine the nearest neighbor. * Ensure the result starts and ends at the depot, reflecting a complete cycle. # Implementation Advice * Use standard distance formula: `distance = sqrt((x2 - x1)**2 + (y2 - y1)**2)` * Keep track of visited locations to avoid revisits. * Carefully initialize variables to implement the nearest neighbor heuristic accurately.","solution":"import math from typing import List, Tuple def calculate_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def nearest_neighbor_tsp(locations: List[Tuple[int, int]]) -> List[int]: n = len(locations) if n == 1: return [0, 0] visited = [False] * n route = [0] # start at depot visited[0] = True current_location = 0 for _ in range(1, n): nearest_distance = float(\'inf\') nearest_index = -1 for i in range(1, n): if not visited[i]: distance = calculate_distance(locations[current_location], locations[i]) if distance < nearest_distance: nearest_distance = distance nearest_index = i route.append(nearest_index) current_location = nearest_index visited[current_location] = True route.append(0) # return to depot return route"},{"question":"# Question You need to write a function that identifies the longest substring with no repeating characters in a given string. **Function Signature:** ```python def longest_unique_substring(s: str) -> str: ``` **Input:** - `s` (string): A string consisting of alphabetic characters (both uppercase and lowercase) and digits (0-9). **Output:** - Return the longest substring that contains no repeating characters. - If there are multiple substrings of the maximum length, return the one that appears first. **Examples:** ```python assert longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" assert longest_unique_substring(\\"bbbbb\\") == \\"b\\" assert longest_unique_substring(\\"pwwkew\\") == \\"wke\\" assert longest_unique_substring(\\"abcdefg\\") == \\"abcdefg\\" ``` **Constraints and Notes:** - Input string length will not exceed 10,000 characters. - The solution should efficiently handle large strings by considering sliding window or two-pointer techniques. - The function should be case-sensitive, therefore \'A\' and \'a\' are considered distinct characters. # Evaluation Criteria: - Correctness of the function under various test cases, including edge cases. - Efficiency of the algorithm to ensure it runs within reasonable time limits for large inputs. - Clarity and readability of the code, with appropriate use of comments if necessary.","solution":"def longest_unique_substring(s: str) -> str: if not s: return \\"\\" start = 0 max_length = 0 max_start = 0 used_chars = {} for end, char in enumerate(s): if char in used_chars and used_chars[char] >= start: start = used_chars[char] + 1 used_chars[char] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_start = start return s[max_start:max_start + max_length]"},{"question":"# Scenario: You are developing software for a bookstore to categorize their books based on the number of pages. Books are classified into three categories: \\"short\\", \\"medium\\" and \\"long\\". The bookstore requires an automatic way to categorize books for efficient sorting and listing. # Task: Implement the function `categorize_book(pages: int) -> str` that categorizes books based on the following rules: - \\"short\\" if the book has fewer than 100 pages - \\"medium\\" if the book has between 100 and 299 pages (inclusive) - \\"long\\" if the book has 300 pages or more # Input: - `pages` (int): A positive integer representing the number of pages in the book. # Output: - Returns a string \\"short\\", \\"medium\\", or \\"long\\" based on the number of pages in the book. # Constraints: - Ensure the input parameter `pages` is a positive integer. # Performance Requirements: - The function should have a constant time complexity O(1). # Example: ```python >>> categorize_book(50) \\"short\\" >>> categorize_book(150) \\"medium\\" >>> categorize_book(300) \\"long\\" >>> categorize_book(99) \\"short\\" >>> categorize_book(299) \\"medium\\" ```","solution":"def categorize_book(pages: int) -> str: Categorizes a book based on the number of pages. Args: pages (int): A positive integer representing the number of pages in the book. Returns: str: \\"short\\", \\"medium\\", or \\"long\\" based on the number of pages in the book. if pages < 100: return \\"short\\" elif pages < 300: return \\"medium\\" else: return \\"long\\""},{"question":"# Problem Statement You are given a list of integers and a target sum. Implement a function `find_subarray_with_sum` to determine whether there exists a contiguous subarray within the given list that sums up to the target sum. # Function Signature ```python def find_subarray_with_sum(arr: list[int], target: int) -> bool: pass ``` # Input - `arr`: A list of integers where the length of the list is between 1 and 10^5 and the integers range from -10^4 to 10^4. - `target`: An integer representing the target sum. # Output - Returns `True` if there is a contiguous subarray that sums up to the target sum; otherwise, returns `False`. # Constraints - The function should handle invalid inputs by throwing appropriate exceptions. - Ensure the function can efficiently process large lists within time limits. # Example ```python arr = [1, 2, 3, 7, 5] target = 12 print(find_subarray_with_sum(arr, target)) # Output: True arr2 = [1, 2, 3, 4, 5] target2 = 9 print(find_subarray_with_sum(arr2, target2)) # Output: True arr3 = [-1, 2, 3, -4, 5] target3 = 8 print(find_subarray_with_sum(arr3, target3)) # Output: False ``` # Requirements - The solution should efficiently handle large lists and targets within the given constraints. - Address invalid inputs by raising appropriate exceptions with clear error messages. - Optimize the performance to minimize time complexity from the naive worst-case scenario.","solution":"def find_subarray_with_sum(arr, target): Determine if there exists a contiguous subarray within the given list that sums up to the target sum. if not isinstance(arr, list) or not isinstance(target, (int, float)): raise ValueError(\\"Invalid input: arr must be a list and target must be a number.\\") if not arr: return False current_sum = 0 sum_set = set() for num in arr: current_sum += num if current_sum == target or (current_sum - target) in sum_set: return True sum_set.add(current_sum) return False"},{"question":"# Question Create a function that implements the merge sort algorithm to sort a list of integers. Merge sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts both halves, and then merges them to create the final sorted list. Specific Requirements: 1. **Function Name**: merge_sort 2. **Input**: A list of integers 3. **Output**: A new list of integers that is sorted in ascending order 4. **Constraints**: * The input list can contain any integer within the range -10^6 to 10^6. * The solution should handle lists with up to 10^5 elements efficiently. Performance Requirements: * **Time Complexity**: O(n log n) * **Space Complexity**: O(n) # Example Usage: ```python print(merge_sort([34, 7, 23, 32, 5, 62])) # Output: [5, 7, 23, 32, 34, 62] print(merge_sort([4, 1, 3, 9, 7])) # Output: [1, 3, 4, 7, 9] print(merge_sort([])) # Output: [] print(merge_sort([1])) # Output: [1] print(merge_sort([-3, -1, -2, -4, -5])) # Output: [-5, -4, -3, -2, -1] ``` # Implementation Details: - Define a function `merge_sort` that takes a list of integers as input. - Use auxiliary functions as needed to facilitate the merging process. - Ensure that the original list is not modified; instead, return a new sorted list.","solution":"def merge_sort(arr): Sorts a list of integers using the merge sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A new list of integers sorted in ascending order. if len(arr) <= 1: return arr # Divide the list into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. Parameters: left (list): A sorted list of integers. right (list): Another sorted list of integers. Returns: list: A merged and sorted list containing all elements from both input lists. sorted_list = [] i = j = 0 # Merge the two lists while comparing elements while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append any remaining elements from the left list while i < len(left): sorted_list.append(left[i]) i += 1 # Append any remaining elements from the right list while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"# Sorting Employee Records Context: You are developing a piece of HR software that needs to display employee records sorted by various criteria. Employees have attributes like name, age, and salary. To facilitate different sorting options, you need to implement a sorting function. Task: Implement a function that sorts a list of employee records based on a specified attribute and order (ascending or descending). **Function**: `sort_employees(employees: List[Dict[str, Any]], sort_by: str, descending: bool) -> List[Dict[str, Any]]` - **Input**: - `employees`: A list of dictionaries, where each dictionary represents an employee with keys \\"name\\", \\"age\\", and \\"salary\\". - `sort_by`: A string that specifies the attribute to sort by (\\"name\\", \\"age\\", or \\"salary\\"). - `descending`: A boolean that specifies the order of sorting (True for descending, False for ascending). - **Output**: A list of dictionaries representing the sorted employee records. Constraints: 1. The function should handle empty lists gracefully and return an empty list. 2. All employee records are guaranteed to have \\"name\\", \\"age\\", and \\"salary\\" keys. 3. \\"name\\" is a string, \\"age\\" is an integer, and \\"salary\\" is a float. 4. The sorting should be stable, meaning that the relative order of records with equal keys should be preserved. Example: ```python >>> employees = [ ... {\\"name\\": \\"John\\", \\"age\\": 25, \\"salary\\": 50000.0}, ... {\\"name\\": \\"Doe\\", \\"age\\": 30, \\"salary\\": 60000.0}, ... {\\"name\\": \\"Jane\\", \\"age\\": 22, \\"salary\\": 70000.0}, ... {\\"name\\": \\"Smith\\", \\"age\\": 26, \\"salary\\": 50000.0} ... ] >>> sort_employees(employees, \\"age\\", False) [{\'name\': \'Jane\', \'age\': 22, \'salary\': 70000.0}, {\'name\': \'John\', \'age\': 25, \'salary\': 50000.0}, {\'name\': \'Smith\', \'age\': 26, \'salary\': 50000.0}, {\'name\': \'Doe\', \'age\': 30, \'salary\': 60000.0}] >>> sort_employees(employees, \\"salary\\", True) [{\'name\': \'Jane\', \'age\': 22, \'salary\': 70000.0}, {\'name\': \'Doe\', \'age\': 30, \'salary\': 60000.0}, {\'name\': \'John\', \'age\': 25, \'salary\': 50000.0}, {\'name\': \'Smith\', \'age\': 26, \'salary\': 50000.0}] ``` Implement the function ensuring accurate, efficient, and stable sorting of the employee records based on the given attribute and order.","solution":"from typing import List, Dict, Any def sort_employees(employees: List[Dict[str, Any]], sort_by: str, descending: bool) -> List[Dict[str, Any]]: Sorts a list of employee records based on a specified attribute and order. :param employees: List of dictionaries, each representing an employee with keys \\"name\\", \\"age\\", and \\"salary\\". :param sort_by: A string specifying the attribute to sort by (\\"name\\", \\"age\\", or \\"salary\\"). :param descending: A boolean specifying the order of sorting (True for descending, False for ascending). :return: A list of dictionaries representing the sorted employee records. return sorted(employees, key=lambda x: x[sort_by], reverse=descending)"},{"question":"# Scenario: You are helping a company automate the process of categorizing customer feedback messages based on sentiment. The objective is to implement a function that reviews customer feedback and categorizes each message as \\"positive\\", \\"negative\\", or \\"neutral\\" based on specific keywords associated with these sentiments. # Task: Implement a Python function `categorize_feedback(feedback: List[str], keywords: Dict[str, List[str]]) -> Dict[str, List[str]]` that: 1. Accepts a list of feedback messages and a dictionary of keywords. 2. Categorizes each feedback message based on the keywords provided. 3. Returns a dictionary where the keys are the sentiment categories (`\\"positive\\"`, `\\"negative\\"`, `\\"neutral\\"`) and the values are lists of feedback messages corresponding to each category. # Input: - `feedback` (List[str]): A list of feedback message strings. - `keywords` (Dict[str, List[str]]): A dictionary with three keys: `\\"positive\\"`, `\\"negative\\"`, `\\"neutral\\"`. Each key maps to a list of keywords associated with that sentiment. # Output: - (Dict[str, List[str]]): A dictionary with lists of feedback messages categorized by sentiment. # Constraints: - The feedback messages will be non-empty strings. - The keywords dictionary will always contain the keys `\\"positive\\"`, `\\"negative\\"`, and `\\"neutral\\"` with respective keyword lists. - Each feedback message will be categorized according to the first matching sentiment keyword it contains. # Example: ```python feedback = [ \\"I love the new feature!\\", \\"This is the worst experience I\'ve ever had.\\", \\"The support was okay, nothing exceptional.\\", \\"The product quality is superb.\\", \\"I am dissatisfied with the current service.\\", \\"It\'s fine, could be better.\\", \\"You have exceeded my expectations!\\" ] keywords = { \\"positive\\": [\\"love\\", \\"superb\\", \\"exceeded\\"], \\"negative\\": [\\"worst\\", \\"dissatisfied\\"], \\"neutral\\": [\\"okay\\", \\"fine\\"] } result = categorize_feedback(feedback, keywords) # Expected result: # { # \\"positive\\": [\\"I love the new feature!\\", \\"The product quality is superb.\\", \\"You have exceeded my expectations!\\"], # \\"negative\\": [\\"This is the worst experience I\'ve ever had.\\", \\"I am dissatisfied with the current service.\\"], # \\"neutral\\": [\\"The support was okay, nothing exceptional.\\", \\"It\'s fine, could be better.\\"] # } ``` # Notes: - If a feedback message does not contain any keywords, it will not appear in the returned dictionary. - Ensure that your function handles messages with varying lengths and different sets of keywords. - Be aware of case sensitivity when matching keywords to feedback messages.","solution":"def categorize_feedback(feedback, keywords): Categorizes feedback messages based on sentiment keywords. Parameters: - feedback (list of str): List of feedback messages. - keywords (dict of str: list of str): Dictionary with keys `\\"positive\\"`, `\\"negative\\"`, `\\"neutral\\"` mapping to lists of keywords. Returns: - dict of str: list of str: Dictionary with categorized feedback lists. categorized_feedback = {\\"positive\\": [], \\"negative\\": [], \\"neutral\\": []} for message in feedback: # Flag to check if a message is categorized categorized = False # Check each category and its keywords for category, words in keywords.items(): if any(word.lower() in message.lower() for word in words): categorized_feedback[category].append(message) categorized = True break if not categorized: # If there is no matched keyword, categorize as unknown or anything else if needed continue return categorized_feedback"},{"question":"# Frequency of Characters in Conditions Write a program that processes a list of conditions and determines the frequency of each character in these conditions, ignoring spaces. A condition in this context is a string consisting of letters, optional comparison operators (`<`, `>`, `<=`, `>=`, `==`, `!=`), and digits. Note that comparison operators should be treated as part of the context but ignored during the frequency calculation. Function Signature ```python def character_frequency_in_conditions(conditions: list[str]) -> dict[str, int]: Parameters: - conditions (list[str]): A list of strings where each string is a condition. Returns: - dict[str, int]: A dictionary where the keys are characters and the values are their frequencies across all conditions in the list. Constraints: - Must handle large lists efficiently. - Conditions will be non-empty strings. ``` Input - A list of strings `conditions`, where each string represents a condition. Output - A dictionary where: * Each key is a character (ignoring spaces and comparison operators). * Each value is the count of how many times that character appears in the list of conditions. Example ```python >>> character_frequency_in_conditions([\\"a < b\\", \\"c <= a\\", \\"a == d\\"]) {\'a\': 3, \'b\': 1, \'c\': 1, \'d\': 1} >>> character_frequency_in_conditions([\\"x != y\\", \\"y > x\\"]) {\'x\': 2, \'y\': 2} >>> character_frequency_in_conditions([\\"p == q\\", \\"q >= r\\", \\"r <= s\\", \\"p != p\\"]) {\'p\': 3, \'q\': 2, \'r\': 2, \'s\': 1} ``` Constraints - Strings in `conditions` contain only printable ASCII characters. - Valid comparison operators to ignore: `\\"<\\", \\">\\", \\"<=\\", \\">=\\", \\"==\\", \\"!=\\"`. - You need to handle cases where conditions might have varying whitespaces.","solution":"def character_frequency_in_conditions(conditions: list[str]) -> dict[str, int]: Determines the frequency of each character in the given list of conditions, ignoring spaces and comparison operators. Parameters: - conditions (list[str]): A list of strings where each string is a condition. Returns: - dict[str, int]: A dictionary where the keys are characters and the values are their frequencies across all conditions in the list. ignore_chars = set(\' <=>!\') # characters to ignore frequency = {} for condition in conditions: for char in condition: if char not in ignore_chars: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Task Description You are required to implement a function `find_missing_number(numbers: List[int], n: int) -> int` that takes a list of unique integers ranging from 0 to n (inclusive) with exactly one number missing and returns the missing number. The input list `numbers` is not necessarily sorted. # Function Signature ```python def find_missing_number(numbers: List[int], n: int) -> int: pass ``` # Input - A list of integers `numbers`, which includes all numbers from 0 to n except one missing number. - An integer `n` representing the upper limit of the range. # Output - The missing integer that is not in the list `numbers`. # Constraints - The length of `numbers` list will be `n`. - The list `numbers` contains exactly one missing number within the range [0, n]. - All elements in `numbers` are unique. # Performance Requirements - The solution must have a time complexity of O(n) and space complexity of O(1). # Examples 1. `find_missing_number([0, 1, 3], 3)` returns `2`. 2. `find_missing_number([0, 1, 2, 4, 5], 5)` returns `3`. 3. `find_missing_number([3, 0, 1], 3)` returns `2`. 4. `find_missing_number([0], 1)` returns `1`. # Notes - You are not allowed to use any built-in functions that directly find the missing number. - Ensure that your function gracefully handles edge cases, such as the smallest and largest possible missing number. # Example Usage ```python # Valid usage print(find_missing_number([4, 2, 3, 0], 4)) # Output: 1 print(find_missing_number([0, 1, 3], 3)) # Output: 2 # Edge case handling print(find_missing_number([1], 1)) # Output: 0 print(find_missing_number([0], 1)) # Output: 1 ```","solution":"from typing import List def find_missing_number(numbers: List[int], n: int) -> int: Finds the missing number in the list of numbers from 0 to n. :param numbers: List containing n unique numbers ranging from 0 to n (inclusive) except one missing number. :param n: The upper limit of the range. :return: The missing number. expected_sum = n * (n + 1) // 2 actual_sum = sum(numbers) return expected_sum - actual_sum"},{"question":"# Question Implement a Python function called `find_most_frequent_word` that accepts a string of text and returns the most frequently occurring word. In the event of a tie, return the alphabetically smallest word. Function Signature ```python def find_most_frequent_word(text: str) -> str: pass ``` # Input * `text`: A string containing a sequence of words, which may include punctuation marks. Words are separated by spaces. # Output * The most frequently occurring word as a string. # Constraints * The length of `text` will be in the range [0, 10^5]. * Each word consists of lowercase and uppercase English letters and may end with punctuation marks such as \'.\', \',\', \'!\', \'?\'. * Your function should be case-insensitive, treating \'Word\' and \'word\' as identical. * If `text` is an empty string, return an empty string. # Requirements * Normalize the words by converting all letters to lowercase and removing any trailing punctuation marks. * Handle ties by returning the alphabetically smallest word. # Example ```python >>> find_most_frequent_word(\\"Hello world! Hello everyone. Welcome to the world.\\") \'hello\' >>> find_most_frequent_word(\\"One Fish, Two Fish, Red Fish, Blue Fish.\\") \'fish\' >>> find_most_frequent_word(\\"It is what it is.\\") \'it\' >>> find_most_frequent_word(\\"\\") \'\' ``` # Notes * Pay attention to punctuation and normalize the text to ensure accurate word counting. * Using Python\'s built-in string methods like `str.lower()` and `str.strip()` can help manage character casing and punctuation.","solution":"import re from collections import Counter def find_most_frequent_word(text: str) -> str: Returns the most frequently occurring word in the input text. In case of a tie, return the alphabetically smallest word. if not text: return \\"\\" # Normalize the text by converting to lowercase and removing trailing punctuations words = re.findall(r\'bw+b\', text.lower()) # Count the frequency of each word word_counts = Counter(words) # Find the most frequent word(s) max_frequency = max(word_counts.values()) most_frequent_words = [word for word, count in word_counts.items() if count == max_frequency] # Return the alphabetically smallest word in case of tie return min(most_frequent_words)"},{"question":"# Problem Statement: Smallest K-Substring Concatenation Check Given a string `s` and an integer `k`, determine if there exists a set of `k` unique substrings of `s` that, when concatenated in any order, form the original string `s`. Requirements 1. **Function Signature**: ```python def can_form_string_from_k_substrings(s: str, k: int) -> bool: ``` 2. **Parameters**: - `s` (str): The input string. - `k` (int): The number of unique substrings. 3. **Output**: - The function should return `True` if it\'s possible to find `k` unique substrings of `s` such that concatenating them in some order results in the original string `s`. Otherwise, return `False`. 4. **Constraints**: - The length of the input string `s` is between 1 and 100, inclusive. - The value of `k` is between 1 and the length of `s`, inclusive. 5. **Examples**: ```python # Example 1 s = \\"abac\\" k = 2 assert can_form_string_from_k_substrings(s, k) == True # Explanation: One possible set of substrings is [\\"a\\", \\"bac\\"]. Concatenating \\"a\\" and \\"bac\\" in any order results in the original string \\"abac\\". # Example 2 s = \\"aaaa\\" k = 4 assert can_form_string_from_k_substrings(s, k) == True # Explanation: The substrings can be [\\"a\\", \\"a\\", \\"a\\", \\"a\\"]. # Example 3 s = \\"abc\\" k = 5 assert can_form_string_from_k_substrings(s, k) == False # Explanation: It is not possible to split a 3-character string into 5 unique substrings. ``` # Notes: - The function should handle edge cases where `k` is 1 (which would mean the entire string itself) or where `k` equals the length of the string (each character being a substring). - Consider possible efficient approaches to solving the problem, such as using backtracking or dynamic programming.","solution":"def can_form_string_from_k_substrings(s: str, k: int) -> bool: Determine if there are k unique substrings of s that can be concatenated to form s. from collections import Counter # If k is greater than the length of s, it\'s impossible to have k unique substrings if k > len(s): return False # Use a set to find all possible substrings of s substring_set = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substring_set.add(s[i:j]) # We need at least k unique substrings to form s return len(substring_set) >= k"},{"question":"# Spreadsheet Column Title Converter You are tasked with implementing a function that converts an integer to its corresponding column title as it would appear in an Excel spreadsheet. The columns are labeled alphabetically from \'A\' to \'Z\', then \'AA\', \'AB\', and so on. **Function Signature**: ```python def convert_to_title(column_number: int) -> str: pass ``` # Constraints and Rules 1. The input `column_number` will be a positive integer, `(1 <= column_number <= 2^31 - 1)`. 2. The function should map the column number to the corresponding Excel column title. # Expected Input and Output Formats **Input**: - An integer `column_number` representing the column number. **Output**: - A string representing the corresponding Excel column title. # Example ```python assert convert_to_title(1) == \\"A\\" assert convert_to_title(28) == \\"AB\\" assert convert_to_title(701) == \\"ZY\\" assert convert_to_title(2147483647) == \\"FXSHRXW\\" ``` # Explanation To convert the number into the corresponding column title as in Excel: 1. Take modulo 26 to find the rightmost character (considering 1-indexed characters A-Z). 2. Update the column number by reducing it appropriately. 3. Repeat the steps until the entire number is processed. The function should handle large values efficiently and return the accurate column title for the given integer input.","solution":"def convert_to_title(column_number: int) -> str: Given a positive integer column_number, generate the corresponding Excel column title. result = [] while column_number > 0: column_number -= 1 remainder = column_number % 26 result.append(chr(65 + remainder)) column_number //= 26 return \'\'.join(result[::-1])"}]'),O={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},F={class:"card-container"},R={key:0,class:"empty-state"},L=["disabled"],z={key:0},D={key:1};function P(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",z,"See more"))],8,L)):u("",!0)])}const Y=h(O,[["render",P],["__scopeId","data-v-72557845"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/55.md","filePath":"quotes/55.md"}'),j={name:"quotes/55.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,V as default};
