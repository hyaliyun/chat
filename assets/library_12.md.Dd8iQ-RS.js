import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},j={class:"review-title"},R={class:"review-content"};function Y(i,e,u,c,a,s){return n(),r("div",q,[t("div",T,[t("div",j,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const I=m(k,[["render",Y],["__scopeId","data-v-6067b48b"]]),A=JSON.parse('[{"question":"You are given a matrix of integers `grid` of size `m x n`, representing a field of pumpkins. Each cell can contain a non-negative integer, representing the number of pumpkins in that part of the field. You start at the top-left cell (0, 0) of the field and want to travel to the bottom-right cell (m-1, n-1). From any cell `(i, j)`, you can only move to either the cell to the right `(i, j+1)` or the cell below `(i+1, j)`. Your goal is to collect the maximum number of pumpkins possible on your way to the bottom-right cell. Write a function that returns the maximum number of pumpkins you can collect. Example: ``` Input: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] Output: 12 Explanation: The path with the maximum number of pumpkins is 1 → 3 → 5 → 2 → 1, which gives a total of 12 pumpkins. ```","solution":"def max_pumpkins(grid): Returns the maximum number of pumpkins that can be collected from the top-left to the bottom-right of the field. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp matrix for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"Given an array of integers `arr` and an integer `d`, you need to determine if it is possible to select two integers from the array such that their absolute difference is exactly `d`. Return _true_ if there exist such a pair, otherwise return _false_.","solution":"def has_pair_with_difference(arr, d): Determines if there are two integers in the array whose absolute difference is exactly d. :param arr: List of integers :param d: Integer difference to check for :return: True if such a pair exists, False otherwise num_set = set(arr) for num in arr: if (num + d) in num_set or (num - d) in num_set: return True return False"},{"question":"You are given a string `s` which consists of lowercase English letters and an integer `k`. You need to split the string into `k` non-empty contiguous substrings such that the **lexicographic order** of these substrings, when sorted, is the same as the order they appear in `s`. Your task is to determine if it is possible to split the string `s` into exactly `k` parts satisfying the condition. If it is possible, return _a list of the `k` substrings_; otherwise, return an **empty list**.","solution":"def split_string(s, k): Determines if it\'s possible to split the string s into exactly k parts such that their lexicographic order is the same as their appearance in s. If possible, returns a list of the k substrings. Otherwise, returns an empty list. n = len(s) # If k is greater than the number of characters in the string, it\'s not possible if k > n: return [] # Initialize a list to store the substrings substrings = [] # Start cutting the string start = 0 for i in range(1, k): substrings.append(s[start:i]) start = i substrings.append(s[start:]) return substrings"},{"question":"Given a string `s`, you need to split it into as many parts as possible such that each part is a palindrome. Return _the minimum number of cuts needed to achieve this_. A palindrome is defined as a string that reads the same backward as forward. Each substring must be a contiguous block of characters from the original string.","solution":"def min_palindrome_cuts(s): Returns the minimum number of cuts needed to partition the string s such that every part is a palindrome. n = len(s) if n <= 1: return 0 # Create a table to check if s[i:j+1] is a palindrome palindrome = [[False] * n for _ in range(n)] for i in range(n): palindrome[i][i] = True # Every single character is a palindrome for i in range(n-1): if s[i] == s[i+1]: palindrome[i][i+1] = True # Two consecutive same characters are a palindrome for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 palindrome[i][j] = (s[i] == s[j]) and palindrome[i+1][j-1] # Array to store the minimum cuts needed for a palindrome partition cuts = [0] * n for i in range(n): if palindrome[0][i]: cuts[i] = 0 else: min_cuts = float(\'inf\') for j in range(1, i+1): if palindrome[j][i]: min_cuts = min(min_cuts, cuts[j-1] + 1) cuts[i] = min_cuts return cuts[-1]"},{"question":"Given a list of intervals, merge all overlapping intervals and return a list of the merged intervals in sorted order. Each interval is represented as a pair of integers `[start, end]`, where `start` represents the beginning of the interval and `end` represents the end. The intervals `[start1, end1]` and `[start2, end2]` overlap if and only if `end1 >= start2` and `start1 <= end2`. Implement the function `List<Interval> mergeIntervals(List<Interval> intervals)`, where `Interval` is a class with two integer properties, `start` and `end`, and has a constructor that accepts start and end values.","solution":"class Interval: def __init__(self, start, end): self.start = start self.end = end def mergeIntervals(intervals): if not intervals: return [] # Sort the intervals by the starting value intervals.sort(key=lambda x: x.start) merged = [] current_interval = intervals[0] for interval in intervals[1:]: # If the current interval overlaps with the next interval, merge them if current_interval.end >= interval.start: current_interval.end = max(current_interval.end, interval.end) else: # If they do not overlap, add the current interval to merged list merged.append(current_interval) current_interval = interval # Add the last interval merged.append(current_interval) return merged"},{"question":"You are given a `0-indexed` string `s` and an integer `k`. You need to partition the string into `k` non-empty substrings such that the total number of unique characters in all the substrings combined is maximized. Return the maximum number of unique characters that can be achieved with these partitions. If it is not possible to partition the string into exactly `k` non-empty substrings, return `-1`.","solution":"def max_unique_chars_partition(s, k): Return the maximum number of unique characters that can be achieved by partitioning the string `s` into `k` non-empty substrings. if k > len(s): return -1 freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 unique_chars = list(freq.keys()) partitions_needed = min(k, len(unique_chars)) if partitions_needed < k: return -1 return len(unique_chars)"},{"question":"A string `s` is said to be a **k-periodic string** if `s` can be constructed by concatenating one or more copies of a substring of length `k`. Given a string `s` and an integer `k`, determine if `s` is a **k-periodic string**. If it is, return the substring of length `k` that can be concatenated to form `s`, otherwise return an empty string.","solution":"def k_periodic_string(s, k): Determine if the string s is k-periodic and return the substring of length k that can be concatenated to form s, otherwise return an empty string. Parameters: s (str): The input string. k (int): The length of the substring to check for periodicity. Returns: str: The substring of length k if s is k-periodic, otherwise an empty string. if k <= 0 or k > len(s): return \\"\\" substring = s[:k] repeated_string = substring * (len(s) // k) if repeated_string == s: return substring else: return \\"\\""},{"question":"In a binary tree, the **level order traversal** is a traversal method that visits nodes level by level from left to right. Given a binary tree, return the level order traversal of its nodes\' values as a list of lists. **Example:** ``` Input: [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] ``` In the example above, the input represents the binary tree: ``` 3 / 9 20 / 15 7 ``` The level order traversal of this tree would be: ``` [ [3], [9, 20], [15, 7] ] ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree as a list of lists. if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"You are given a list of `n` directories `paths`, where each directory is recorded as a string with the directory path, and each directory path is separated by a forward slash `/`. For example, a single directory path might be `\\"/home/user/docs\\"`. Two directories are considered redundant if one is a subdirectory of the other, i.e., `\\"/home/user\\"` is a subdirectory of `\\"/home\\"`. Your task is to return a list of the directories after removing all redundant directories. The output list should be in lexicographical order. [Question 4]:","solution":"def remove_redundant_directories(paths): Removes redundant directories from the given list of paths. Args: paths (list of str): List of directory path strings. Returns: list of str: List of non-redundant directory paths in lexicographical order. # Sort paths to ensure directories are processed in lexicographical order paths.sort() result = [] prev_path = None for path in paths: if prev_path is None or not path.startswith(prev_path + \'/\'): result.append(path) prev_path = path return result"},{"question":"You have been given an `n x n` grid. Each cell in the grid contains either a `0` (open cell) or a `1` (obstacle). You need to find the length of the shortest path from the top-left corner (cell `(0, 0)`) to the bottom-right corner (cell `(n-1, n-1)`) where you can only move up, down, left, or right. Return _the **length** of the shortest path_. If it is not possible to reach the bottom-right corner, return `-1`. Note that you cannot move through cells containing obstacles, and you can only begin or end on an `open cell`.","solution":"from collections import deque def shortest_path(grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == 0 n = len(grid) # Check if the start or end is blocked if grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 # Directions for moving in the grid: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) # (x, y, distance) grid[0][0] = 1 # mark as visited while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, n-1): return dist for dir in directions: new_x, new_y = x + dir[0], y + dir[1] if is_valid(new_x, new_y): grid[new_x][new_y] = 1 # mark as visited queue.append((new_x, new_y, dist + 1)) return -1"},{"question":"You are given an array of integers, `nums`, and another array of the same length, `queries`. For each element in the `queries` array, determine if it is a **valid k-prefix subsequence** of `nums`. A **k-prefix subsequence** is defined as a sequence that can be formed by deleting some (possibly none) elements from the first `k` elements of `nums` such that the remaining elements retain their original order. Return _an array containing `true` or `false` for each query in_ `queries`_ corresponding to whether or not it forms a **valid k-prefix subsequence** of_ `nums`_._","solution":"def valid_k_prefix_subsequence(nums, queries, k): Determines for each element in the queries array whether it is a valid k-prefix subsequence of nums. Args: nums (list of int): The original array. queries (list of list of int): The array of queries. k (int): The prefix length. Returns: list of bool: A list of booleans indicating if each query is a valid k-prefix subsequence. def is_subsequence(sub, arr): it = iter(arr) return all(x in it for x in sub) prefix = nums[:k] return [is_subsequence(query, prefix) for query in queries]"},{"question":"You are given a 2D integer matrix `matrix` where each row is sorted in ascending order. Write an algorithm to determine whether a given target number exists in the matrix. The algorithm should return `true` if the target is found, and `false` otherwise. You should aim to design an algorithm with better than O(m * n) time complexity, where `m` is the number of rows and `n` is the number of columns in the matrix.","solution":"def search_matrix(matrix, target): Returns True if the target exists in the matrix, False otherwise. The matrix is assumed to be sorted in ascending order in each row. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start at the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given a binary string `s` that is initially all \'0\'s. You have a list of operations, where each operation is represented as a triplet `[left, right, value]`. For each operation, you toggle the binary values of the substring `s[left:right+1]` to the given `value` (\'0\' or \'1\'). Multiple operations can affect overlapping intervals. Return the final binary string after performing all the operations in the given order.","solution":"def toggle_string(s, operations): Toggles the binary string `s` based on the operations provided. Parameters: s (str): The initial binary string with all \'0\'s operations (list of list): Each operation is a list [left, right, value] where left and right are 0-indexed positions and value is the new binary value (\'0\' or \'1\'). Returns: str: The final binary string after performing all operations # Convert the string to a list for easier manipulation s_list = list(s) for op in operations: left, right, value = op for i in range(left, right + 1): s_list[i] = value # Convert back the list to a string return \'\'.join(s_list)"},{"question":"You are given an array `height` representing the heights of water bars along a histogram. The width of each bar is 1. Suppose you have an unlimited number of buckets, and each bucket can collect as much water as possible. Find the maximum amount of water that can be collected between the bars after raining, such that no water spills out of the container formed by the bars. Return _the maximum amount of water that can be collected_.","solution":"def trap(height): Given an array of integers representing the heights of bars in a histogram, calculates the maximum amount of water that can be trapped between the bars. Parameters: height (List[int]): List of integers representing the heights of bars. Returns: int: The maximum amount of water that can be collected between the bars. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a string `s` which may contain uppercase and lowercase letters, remove the adjacent duplicate characters from the string. The removal operation can be repeatedly performed until there are no adjacent duplicate characters left. Return _the final string after all possible removals_. If the final string is empty, return an empty string \\"\\".","solution":"def remove_adjacent_duplicates(s): Remove adjacent duplicate characters from the string until no adjacent duplicates remain. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an instance of a deck of cards represented as a list of integers between 1 and 13, inclusive. Each integer represents a card with values from 1 (Ace) to 13 (King). The deck may or may not be sorted. Your task is to implement a function to shuffle the deck such that the resulting order is uniformly random. Write a function `shuffleDeck(deck)` that takes a list of integers `deck` as input, and returns the shuffled deck. You should use the Fisher-Yates (Knuth) shuffle algorithm to perform an in-place shuffle of the list. The function signature is: ```python def shuffleDeck(deck: List[int]) -> List[int]: ``` Example: ```python deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] shuffleDeck(deck) # Example output (one of the possible shuffles): [3, 1, 12, 10, 5, 2, 6, 8, 9, 13, 4, 11, 7] ```","solution":"import random from typing import List def shuffleDeck(deck: List[int]) -> List[int]: Shuffles the given deck of cards in-place using the Fisher-Yates (Knuth) shuffle algorithm. for i in range(len(deck) - 1, 0, -1): j = random.randint(0, i) deck[i], deck[j] = deck[j], deck[i] return deck"},{"question":"Given an integer array `arr` representing a list of non-negative integers, arrange the array such that even numbers come before all the odd numbers while maintaining the relative order of the even and odd numbers. Return the modified array. You must implement a solution with linear runtime complexity and use only constant extra space.","solution":"def arrange_even_before_odd(arr): Returns the array such that all even numbers appear before all the odd numbers, while maintaining the relative order of even and odd numbers. even = [] odd = [] for num in arr: if num % 2 == 0: even.append(num) else: odd.append(num) return even + odd"},{"question":"You are given an integer array `profits` where `profits[i]` indicates the profit generated by the `i-th` project. You are also given an integer array `capital` where `capital[i]` indicates the capital required to start the `i-th` project. Additionally, you have an integer `initialCapital` representing your initial working capital, and an integer `numberOfProjects` indicating the maximum number of projects you can undertake. At each step, you can start any project for which you have the required capital. Among all available projects, you should always choose one with the highest profit. Once a project is started and completed, the profit from that project is added to your working capital. Return the maximum possible capital after completing at most `numberOfProjects` projects. **Notes:** * You can start at most `numberOfProjects` projects. * You cannot start a project unless you have the required capital for it. * The profit from any completed project immediately becomes available for starting new projects.","solution":"import heapq def find_max_capital(numberOfProjects, initialCapital, profits, capital): Returns the maximum possible capital after completing at most numberOfProjects projects. :param numberOfProjects: Maximum number of projects that can be undertaken. :param initialCapital: Initial working capital. :param profits: List of profits for each project. :param capital: List of capital requirements for each project. :return: Maximum possible capital. if not profits or not capital or numberOfProjects <= 0: return initialCapital # List of projects projects = [(capital[i], profits[i]) for i in range(len(profits))] # Sort projects based on capital required to start projects.sort() max_heap = [] current_capital = initialCapital project_index = 0 for _ in range(numberOfProjects): # Push all project profits to heap that the current capital can afford while project_index < len(projects) and projects[project_index][0] <= current_capital: heapq.heappush(max_heap, -projects[project_index][1]) project_index += 1 # If no projects can be completed, break the loop if not max_heap: break # Pop the project with the maximum profit current_capital += -heapq.heappop(max_heap) return current_capital"},{"question":"You are given an array of integers `nums` and an integer `k`. You need to find the absolute difference between the sum of the maximum `k` elements and the sum of the minimum `k` elements from the array. Return this absolute difference.","solution":"def absolute_difference(nums, k): Returns the absolute difference between the sum of the maximum `k` elements and the sum of the minimum `k` elements from the array nums. if not nums or k <= 0 or k > len(nums): raise ValueError(\\"Invalid input values\\") nums.sort() sum_min_k = sum(nums[:k]) sum_max_k = sum(nums[-k:]) return abs(sum_max_k - sum_min_k)"},{"question":"Given a matrix where each cell contains either a `\'0\'` or a `\'1\'`, write a function that returns the number of islands. An island is defined as a group of `\'1\'`s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.","solution":"def num_islands(grid): if not grid: return 0 num_rows, num_cols = len(grid), len(grid[0]) visited = [[False for _ in range(num_cols)] for _ in range(num_rows)] def dfs(r, c): if r < 0 or r >= num_rows or c < 0 or c >= num_cols or grid[r][c] == \'0\' or visited[r][c]: return visited[r][c] = True dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) island_count = 0 for r in range(num_rows): for c in range(num_cols): if grid[r][c] == \'1\' and not visited[r][c]: island_count += 1 dfs(r, c) return island_count"},{"question":"Given an array of integers `arr` and an integer `k`, return the k-th smallest element in the sorted combined list of all contiguous subarrays of `arr`. A contiguous subarray is a subarray consisting of sequential elements from the original array. The list of all contiguous subarrays includes all possible subarrays of `arr`. Return the k-th smallest element as an integer.","solution":"def k_th_smallest_combined_subarrays(arr, k): Returns the k-th smallest element in the sorted combined list of all contiguous subarrays of arr. :param arr: List[int] - The input array of integers. :param k: int - The position k (1-based) of the desired smallest element. :return: int - The k-th smallest element. subarrays = [] # Generate all contiguous subarrays for i in range(len(arr)): for j in range(i, len(arr)): subarrays.append(arr[i:j+1]) # Combine elements of all subarrays into a single list and sort combined_elements = [] for subarray in subarrays: combined_elements.extend(subarray) combined_elements.sort() # Return the k-th smallest element (1-based index) return combined_elements[k-1]"},{"question":"You are given two strings `s` and `goal` of the same length. We want to design a function to determine if you can swap two letters in `s` such that the result is equal to `goal`. Note that you can swap letters at most once in `s` and must return `true` if this is achievable, `false` otherwise.","solution":"def buddy_strings(s, goal): Determine if you can swap two letters in `s` such that the result is equal to `goal`. :param s: str - input string to be modified :param goal: str - target string to match :return: bool - True if s can be modified to match goal by swapping two letters, False otherwise if len(s) != len(goal): return False if s == goal and len(set(s)) < len(s): return True pairs = [] for a, b in zip(s, goal): if a != b: pairs.append((a, b)) if len(pairs) > 2: return False return len(pairs) == 2 and pairs[0] == pairs[1][::-1]"},{"question":"You are given a string `s` which represents a dial pad on a mobile phone. Each character in `s` corresponds to a digit (2-9) and each digit maps to a set of letters as on a traditional telephone pad (e.g., 2 maps to \\"abc\\", 3 maps to \\"def\\", etc.). Your task is to return all possible letter combinations that the number could represent. Return the answer in **any order**. Note that the digits 0 and 1 do not map to any letters, so `s` will not contain 0 or 1.","solution":"def letter_combinations(s): digit_to_letters = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } if not s: return [] def backtrack(index, path): if index == len(s): combinations.append(\\"\\".join(path)) return possible_letters = digit_to_letters[s[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"Given a list of strings `words`, return _a list of strings representing all the words that can be typed using letters of the alphabet on only one row of a keyboard._ The keyboard consists of three rows of letters as follows: - Row 1: \\"qwertyuiop\\" - Row 2: \\"asdfghjkl\\" - Row 3: \\"zxcvbnm\\" The function should ignore the case of the letters. If a word can be typed using letters from one row of the keyboard only, include it in the output list.","solution":"def find_words(words): Given a list of strings `words`, return a list of strings representing all the words that can be typed using letters of the alphabet on only one row of a keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = word.lower() word_set = set(lower_word) if word_set.issubset(row1) or word_set.issubset(row2) or word_set.issubset(row3): result.append(word) return result"},{"question":"Given an array `nums` where each element is a **positive** integer, and an integer `x`, return _the count of unique pairs of elements (nums[i], nums[j])_ such that their sum is **equal** to `x`. Each pair should be counted only once even if there are multiple ways to form it using the same elements. The solution should have a time complexity better than `O(n^2)`.","solution":"def count_unique_pairs(nums, x): Returns the count of unique pairs of elements in the array `nums` such that their sum is equal to `x`. seen = set() pairs = set() for num in nums: complement = x - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"You are given a list of `tasks` where `tasks[i]` represents the amount of time required to complete the `i`th task. You are also given an integer `k` that represents the maximum number of concurrent tasks you can work on at any given time. Return the minimum amount of time required to complete all tasks, assuming that processing tasks in parallel takes as long as the longest task in each set of `k` tasks.","solution":"import heapq def min_time(tasks, k): Returns the minimum amount of time required to complete all tasks, given that you can process up to `k` tasks concurrently. Parameters: tasks: List[int], list of times required for each task k: int, maximum number of concurrent tasks Returns: int, minimum time to finish all tasks if not tasks: return 0 # Create a min heap to store the current times of `k` workers heap = [0] * k for task_time in sorted(tasks, reverse=True): # Pop the worker with the least current time min_time_worker = heapq.heappop(heap) # Assign this task to that worker and update the worker\'s time heapq.heappush(heap, min_time_worker + task_time) # The total time to finish all tasks will be the maximum time in the heap return max(heap)"},{"question":"You have a robot with `k` arms, and each arm is capable of picking up exactly one item at a time from a conveyor belt. The conveyor belt has `n` items represented as an integer array `items` where `items[i]` is the item type at position `i`. The robot can only pick items in a single continuous segment of length `k`. Each arm of the robot has a favorite item type it picks more efficiently. These favorite item types are provided in an array `favoriteTypes` of length `k`, where `favoriteTypes[j]` is the favorite item type of the `j-th` arm. The efficiency of picking an item is critical, so the robot aims to maximize the total number of its favorite items picked up. Given the conveyor belt items and the robot\'s arm favorite types, return the maximum number of favorite items the robot can pick up from any segment of length `k` on the conveyor belt.","solution":"def max_favorite_items_picked(items, k, favoriteTypes): Returns the maximum number of favorite items the robot can pick up from any segment of length k on the conveyor belt. :param items: List[int] - conveyor belt items :param k: int - number of arms (segment length) :param favoriteTypes: List[int] - favorite item types for each arm :return: int - maximum number of favorite items picked up n = len(items) max_favorite_count = 0 # Traverse through each possible segment of length k for i in range(n - k + 1): current_segment = items[i:i+k] favorite_count = sum(1 for j in range(k) if current_segment[j] in favoriteTypes) max_favorite_count = max(max_favorite_count, favorite_count) return max_favorite_count"},{"question":"You are given an integer array `arr` representing the sizes of different files and an integer `disk` representing the capacity of a disk. You need to store these files on the least number of disks possible such that the combined size of files on a single disk does not exceed the disk capacity. Each disk\'s capacity is exactly `disk`. Return _the minimum number of disks required_ to store all files in `arr`.","solution":"def min_disks_required(arr, disk): Returns the minimum number of disks required to store all files. arr.sort(reverse=True) n = len(arr) used_disks = 0 used_space = [0] * n for i in range(n): placed = False for j in range(used_disks): if used_space[j] + arr[i] <= disk: used_space[j] += arr[i] placed = True break if not placed: used_space[used_disks] = arr[i] used_disks += 1 return used_disks"},{"question":"You are given an array `arr` of positive integers. You are also given two integers `left` and `right`. A subarray is called **bounded** if the largest element in the subarray is in the range `[left, right]` (inclusive). Return the number of **bounded** subarrays in `arr`.","solution":"def count_bounded_subarrays(arr, left, right): Returns the number of bounded subarrays within the range [left, right]. def count_subarrays_leq_max(arr, max_val): count = 0 current_length = 0 for num in arr: if num <= max_val: current_length += 1 count += current_length else: current_length = 0 return count return count_subarrays_leq_max(arr, right) - count_subarrays_leq_max(arr, left - 1)"},{"question":"Given an integer array `arr` of size `n` where all elements are non-negative, and an integer `d`, return the length of the smallest subarray (contiguous elements) with a sum of at least `d`. If there is no such subarray, return -1.","solution":"def min_subarray_length(arr, d): Returns the length of the smallest subarray with a sum of at least `d`. If there is no such subarray, returns -1. n = len(arr) min_length = float(\'inf\') start = 0 current_sum = 0 for end in range(n): current_sum += arr[end] while current_sum >= d: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a string `s` containing only lowercase English letters, you need to determine the length of the longest substring where each character appears at least `k` times. You may assume that `k` is always a positive integer greater than 0. Implement an algorithm to find the length of this longest substring. **Clarification:** A substring is a contiguous sequence of characters within a string. For example, in the string \\"aaabb\\", if `k = 3`, the longest substring where each character appears at least 3 times is \\"aaa\\", with a length of 3.","solution":"def longestSubstring(s, k): Returns the length of the longest substring of s in which each character appears at least k times. def helper(s, k, start, end): if end - start < k: return 0 char_count = {} for i in range(start, end): char_count[s[i]] = char_count.get(s[i], 0) + 1 for mid in range(start, end): if char_count[s[mid]] < k: mid_next = mid + 1 while mid_next < end and char_count[s[mid_next]] < k: mid_next += 1 return max(helper(s, k, start, mid), helper(s, k, mid_next, end)) return end - start return helper(s, k, 0, len(s))"},{"question":"Given a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom. Each tree node has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Given the `root` of the binary tree, return _an array representing the right side view of the tree_.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Given the root of a binary tree, return the values of the nodes you can see ordered from top to bottom when observing from the right side. if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"You are given a **0-indexed** 2D integer array `matrix` of dimensions `m x n` representing a grid, where each element `matrix[i][j]` is either `0` (empty) or `1` (occupied). You need to find the largest square that can be formed within this grid, consisting entirely of `1`s, and return _its area_. If no such square exists, return `0`.","solution":"def maximalSquare(matrix): Finds the largest square containing only 1\'s and returns its area. Args: matrix (List[List[int]]): 2D list of integers representing the grid. Returns: int: The area of the largest square containing only 1\'s. if not matrix: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"You are given a list of activities with their start and end times. Your task is to select the maximum number of activities that a single person can attend, assuming they can only participate in one activity at a time. The activities are given as a list of tuples, where each tuple contains two integers representing the start and end times of an activity. Return _the maximum number of non-overlapping activities one person can attend._","solution":"def max_activities(activities): Returns the maximum number of non-overlapping activities one person can attend. Parameters: activities (list of tuples): A list where each tuple contains two integers representing the start and end times of an activity. Returns: int: The maximum number of non-overlapping activities. if not activities: return 0 # Sort activities based on their end times activities.sort(key=lambda x: x[1]) max_count = 0 last_end_time = -1 for start, end in activities: if start >= last_end_time: max_count += 1 last_end_time = end return max_count"},{"question":"You are given a string `s` that consists of only two characters, \'a\' and \'b\'. You can perform the following operation on `s` any number of times: Choose any two adjacent characters and replace them with a new character according to the following rules: - Replace \\"ab\\" with \\"b\\" - Replace \\"ba\\" with \\"a\\" Your task is to find the lexicographically smallest string that can be obtained after performing the operation any number of times on `s`. Return the lexicographically smallest string possible.","solution":"def smallest_lexicographic_string(s): Given a string s consisting only of \'a\' and \'b\', returns the lexicographically smallest string that can be obtained by performing the given operations any number of times. count_a = s.count(\'a\') count_b = s.count(\'b\') return \'a\' * count_a + \'b\' * count_b"},{"question":"Design an algorithm that accomplishes the following task: [Question 4]: You are given a **0-indexed** array `nums` containing `n` integers and an integer `k`. Your task is to determine the number of unique pairs `(i, j)` such that `0 <= i < j < n` and `nums[i] + nums[j] == k`. Return _the count of such unique pairs_. Two pairs are unique if the indices of the elements in the pairs are different, even if the sums are the same.","solution":"def count_unique_pairs(nums, k): Counts the number of unique pairs (i, j) such that 0 <= i < j < n and nums[i] + nums[j] == k. Parameters: nums (list): A list of integers. k (int): The target sum. Returns: int: The count of unique pairs. count = 0 seen = set() for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == k and (i, j) not in seen: count += 1 seen.add((i, j)) return count"},{"question":"You are given an array of integers `arr` where each integer represents the number of candies in a respective box. You can pick any box and eat all the candies in that box. However, after eating all the candies in a box, the adjacent boxes (left and right) become inaccessible for the next pick. Your goal is to maximize the number of candies you can eat. Return _the maximum candies you can collect_. --- Your task is to ensure the additional question you create aligns well with the given set, matching in style, complexity, length, and areas of knowledge tested. Good luck!","solution":"def max_candies(arr): n = len(arr) if n == 0: return 0 if n == 1: return arr[0] if n == 2: return max(arr) dp = [0] * n dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], arr[i] + dp[i-2]) return dp[-1]"},{"question":"Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is defined as the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. Write a function `diameterOfBinaryTree` that takes the root of a binary tree and returns its diameter. Here is the definition for a binary tree node: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your solution should be efficient in terms of time complexity and handle edge cases, such as an empty tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root): Computes the length of the diameter of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The diameter of the binary tree. def height(node): nonlocal diameter if not node: return 0 left_height = height(node.left) right_height = height(node.right) diameter = max(diameter, left_height + right_height) return 1 + max(left_height, right_height) diameter = 0 height(root) return diameter"},{"question":"Given a string `s` consisting of small English letters, you need to determine if you can make `s` a palindrome by **rearranging** its letters. Return a boolean value `True` if it is possible to rearrange `s` to form a palindrome, and `False` otherwise. A string is a palindrome if it reads the same forward and backward (e.g., \\"level\\", \\"radar\\"). Note that there is no need to consider the case sensitivity for this problem.","solution":"def can_form_palindrome(s): Returns True if it is possible to rearrange the string s to form a palindrome, False otherwise. from collections import Counter count = Counter(s) odd_counts = sum(1 for count in count.values() if count % 2 != 0) # For the string to be rearrangeable into a palindrome, # there must be at most one character with an odd count. return odd_counts <= 1"},{"question":"You are given an integer array `nums` containing `n` elements where each element is between 0 and `n - 1`, inclusive. Each element in the array represents a directed edge from the current index to the value at that index. In other words, if `nums[i] = j`, there is a directed edge from index `i` to index `j`. A __cycle__ in the array is a sequence of edges `(a1, a2, a3, ..., ak)` such that `a1 -> a2 -> a3 -> ... -> ak -> a1`, and all values `a1, a2, ..., ak` are distinct. Your task is to return the length of the longest cycle in the array. If there is no cycle, return `-1`.","solution":"def longest_cycle(nums): Returns the length of the longest cycle in the array. If no cycle exists, returns -1. def visit(node): nonlocal max_cycle_length stack = [] while node != -1 and not visited[node] and node not in stack: stack.append(node) node = nums[node] if node in stack: cycle_length = len(stack) - stack.index(node) max_cycle_length = max(max_cycle_length, cycle_length) for v in stack: visited[v] = True n = len(nums) visited = [False] * n max_cycle_length = -1 for i in range(n): if not visited[i]: visit(i) return max_cycle_length"},{"question":"You are given a **2D** grid of size `m x n` where each cell represents a **height** at that point. The heights within the grid are sorted in non-decreasing order both row-wise and column-wise. You are also given an integer `x` representing a target height. Your task is to find the index of the cell `(i, j)` that contains the target height `x`. If multiple cells contain the target height, return the indices of any one such cell. If the target height `x` is not present in the grid, return `[-1, -1]`.","solution":"def search_2d_matrix(matrix, x): Given a 2D matrix sorted in non-decreasing order both row-wise and column-wise, returns the index of the cell that contains the target height x. Args: matrix (list of list of int): The 2D grid of heights. x (int): The target height. Returns: tuple: The index of the cell containing the target height x, or (-1, -1) if the height isn\'t found. if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == x: return (row, col) elif matrix[row][col] > x: col -= 1 else: row += 1 return (-1, -1)"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `x`. In one operation, you can either: * Increase a selected element of `arr` by `1`, or * Decrease a selected element of `arr` by `1`. Your task is to make every element in `arr` equal to `x` using the minimum number of operations. Return _the minimum number of operations required to make all elements of_* `arr` _equal to_ `x`. For example, given `arr = [1, 2, 3]` and `x = 2`, the output should be `2` since you can: 1. Increase `arr[0]` by `1` (total operations: 1). 2. Decrease `arr[2]` by `1` (total operations: 2).","solution":"def min_operations_to_equal(arr, x): Returns the minimum number of operations required to make all elements of arr equal to x. Parameters: arr (list of int): The input array. x (int): The target value to make all elements equal to. Returns: int: The minimum number of operations. operations = 0 for element in arr: operations += abs(element - x) return operations"},{"question":"You are given an integer array `nums` where each element represents the number of candies in a pile. You can pick any pile and divide the candies in it into two smaller non-empty piles of different sizes. Repeat this operation until you cannot divide any pile further. Your goal is to find the minimum possible number of piles you can end up with. Return _the minimum number of piles_ as an integer.","solution":"def min_piles(nums): Returns the minimum number of piles possible. Splitting a pile of size n into two smaller non-empty piles means that each eventual pile must have size 1. Hence, the minimum number of piles after possible splits is the number of elements in the input array. return sum(num for num in nums if num > 0)"},{"question":"You are given an array `nums` containing `n` integers, where each integer represents the number of stones in a pile. In each move, you can take any number of stones from a single pile. However, if you choose to take stones from a pile, you must take at least one stone. Your goal is to determine if the first player (who can start taking stones from any pile) can guarantee a win assuming both players play optimally. Return `true` if the first player can guarantee a win, and `false` otherwise.","solution":"def can_first_player_win(nums): Returns True if the first player can guarantee a win, False otherwise. xor_sum = 0 for num in nums: xor_sum ^= num return xor_sum != 0"},{"question":"There is a robot on an `m x n` grid. The robot is initially located at the top-left corner (grid[0][0]) and is aiming to reach the bottom-right corner (grid[m–1][n–1]). The robot can only move either down or right at any point in time. However, along the way, the robot has to avoid certain obstacles represented as \'1\' in the grid cells. A cell \'0\' represents an open space that the robot can pass through. Given the grid, write a function to find the total number of unique paths that the robot can take to reach the bottom-right corner without hitting any obstacles. If no such path exists, return 0.","solution":"def unique_paths_with_obstacles(grid): This function computes the number of unique paths in a grid with obstacles, where \'1\' indicates an obstacle and \'0\' indicates an accessible cell. Parameters: grid (list of list of int): The grid with obstacles represented by 1 and open cells by 0. Returns: int: The number of unique paths from top-left to bottom-right of the grid. m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"You are given a list of non-negative integers `heights` representing the heights of pillars. The width of each pillar is 1. You need to find two pillars such that together with the x-axis, they form a container that would hold the greatest amount of water. Return the maximum amount of water such a container can hold.","solution":"def max_area(heights): Returns the maximum amount of water a container can hold using the heights list. Parameters: heights (list of int): List of non-negative integers representing the heights of the pillars. Returns: int: Maximum amount of water that can be held. if not heights or len(heights) < 2: return 0 n = len(heights) left, right = 0, n - 1 max_water = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_water = height * width max_water = max(max_water, current_water) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"Given the `head` of a singly linked list, return _the list after removing all the **nodes with even values**_. Maintain the original order of nodes in the resultant list. If the list is empty or contains only odd values, return it as is.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_even_nodes(head): Removes all nodes with even values from the linked list and returns the new head. # Use a dummy head to handle edge cases gracefully. dummy = ListNode(0) dummy.next = head current = dummy while current and current.next: if current.next.val % 2 == 0: # Skip the node with an even value. current.next = current.next.next else: # Move to the next node. current = current.next return dummy.next"},{"question":"**[Question 4]:** Given a list of intervals, merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input. Each interval is represented as a pair of integers where the first integer represents the start and the second integer represents the end of the interval (inclusive). For example, given the intervals `[[1, 3], [2, 6], [8, 10], [15, 18]]`, you should return `[[1, 6], [8, 10], [15, 18]]` as the intervals `[1, 3]` and `[2, 6]` overlap and merge into `[1, 6]`.","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns an array of the non-overlapping intervals that cover all the intervals in the input. Args: intervals (List[List[int]]): A list of intervals represented as lists of two integers [start, end]. Returns: List[List[int]]: A list of merged non-overlapping intervals. if not intervals: return [] # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_interval = intervals[0] for interval in intervals[1:]: if interval[0] <= current_interval[1]: # If the current interval overlaps with the interval being checked, merge them current_interval[1] = max(current_interval[1], interval[1]) else: # If current interval does not overlap, add it to the merged intervals and update current interval merged_intervals.append(current_interval) current_interval = interval # Add the last interval merged_intervals.append(current_interval) return merged_intervals"},{"question":"You are given an array of integers `nums` and an integer `k`. Modify the array in such a way that each integer from the beginning of the array is moved to its position plus `k` indices ahead. Elements that are shifted beyond the array\'s last index should reappear at the beginning in a circular manner. Return the modified array after all integers have been shifted. Implement the method `rotateArray(int[] nums, int k)` that performs this operation.","solution":"from typing import List def rotateArray(nums: List[int], k: int) -> List[int]: Rotates the elements of array nums k positions to the right. :param nums: List[int] - The array to be rotated. :param k: int - The number of positions to rotate the array. :return: List[int] - The rotated array. n = len(nums) k = k % n # handle cases where k is greater than the length of the array return nums[-k:] + nums[:-k]"},{"question":"You are given a list of strings `words` and a string `allowed` consisting of distinct characters. A word is consistent if all characters in the word are present in the string `allowed`. Return the number of consistent strings in the list `words`.","solution":"def count_consistent_strings(words, allowed): Returns the number of consistent strings in the list `words`. A word is consistent if all its characters are in the string `allowed`. allowed_set = set(allowed) consistent_count = 0 for word in words: if all(char in allowed_set for char in word): consistent_count += 1 return consistent_count"},{"question":"You are given an array of integers `arr` where each element represents the maximum length of rope you can cut from that position. You are initially positioned at the start of the array and you need to reach the last index in the minimum number of jumps. A jump from position `i` to any position `j` such that `i < j` and `j <= i + arr[i]` is allowed. If it is not possible to reach the last index, return -1. Given the integer array `arr`, return the minimum number of jumps required to reach the last index, or -1 if it is not possible.","solution":"def min_jumps(arr): Given an array of integers where each element represents the maximum length of rope you can cut from that position, returns the minimum number of jumps required to reach the last index. Returns -1 if it is not possible. if len(arr) <= 1: return 0 if arr[0] == 0: return -1 max_reach = arr[0] step = arr[0] jump = 1 for i in range(1, len(arr)): if i == len(arr) - 1: return jump max_reach = max(max_reach, i + arr[i]) step -= 1 if step == 0: jump += 1 if i >= max_reach: return -1 step = max_reach - i return -1"},{"question":"You are given an integer array `nums` and an integer `k`. Implement a function `findSubarrays(nums, k)` that returns all unique subarrays of length `k` that have a sum less than `target`. A subarray is a contiguous part of an array. # Example: ``` Input: nums = [1, 2, 3, 4, 5], k = 3, target = 10 Output: [[1, 2, 3], [2, 3, 4]] Input: nums = [1, 1, 1, 1, 1], k = 2, target = 3 Output: [[1, 1], [1, 1], [1, 1], [1, 1]] ```","solution":"def findSubarrays(nums, k, target): Returns all unique subarrays of length `k` that have a sum less than `target`. n = len(nums) result = [] for i in range(n - k + 1): subarray = nums[i:i+k] if sum(subarray) < target: result.append(subarray) return result"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to modify the string by choosing any substring of length `k` and reversing it. Return the lexicographically smallest string you can obtain through a sequence of these operations. Note that you can perform the operation any number of times.","solution":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained by reversing a substring of length k in the given string s. if k == 1: # If k is 1, we can only rotate the string to get the smallest lexicographical order smallest = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated < smallest: smallest = rotated return smallest else: # If k > 1, we can sort the entire string to get the smallest lexicographical order return \'\'.join(sorted(s))"},{"question":"Given an array `arr` consisting of integers where every element appears exactly twice, except for one element which appears exactly once, return the single element that appears only once.","solution":"def single_number(arr): Returns the single element that appears only once in the array. Every other element appears exactly twice. result = 0 for num in arr: result ^= num # XOR operation return result"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine the length of the longest subsequence from the string where any two consecutive characters are distinct. Return the length of such a subsequence.","solution":"def longest_distinct_subsequence(s): Returns the length of the longest subsequence where any two consecutive characters are distinct. if not s: # If the string is empty, return 0 return 0 # The longest subsequence with distinct consecutive characters can\'t be longer # than the length of the string where each character is counted exactly once. longest_length = 1 # We must have at least one character in the subsequence. for i in range(1, len(s)): if s[i] != s[i-1]: longest_length += 1 return longest_length"},{"question":"You are given an array of integers `ratings` where `ratings[i]` represents the rating of the `i-th` employee. A company wants to reward its employees with bonuses according to their ratings. Every employee must receive at least one bonus, and employees with a higher rating receive strictly more bonuses than their neighbors. Return _the minimum number of bonuses the company needs to distribute_.","solution":"def min_bonuses(ratings): Calculate the minimum number of bonuses required for the given ratings. Parameters: ratings (List[int]): List of employee ratings. Returns: int: Minimum number of bonuses required. n = len(ratings) if n == 0: return 0 bonuses = [1] * n # Forward pass to ensure right neighbor condition for i in range(1, n): if ratings[i] > ratings[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Backward pass to ensure left neighbor condition for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses)"},{"question":"Given a matrix of characters `board` and a string `word`, determine if the word can be constructed from the characters of the matrix by moving sequentially in one of the four directions: up, down, left, and right. Each character from the matrix can be used at most once. Return _true_ if the word can be formed, and _false_ otherwise. (Note: The matrix dimensions are `m x n` where `m` is the number of rows and `n` is the number of columns.)","solution":"def exist(board, word): def dfs(board, word, i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[word_index]: return False temp = board[i][j] board[i][j] = \\"#\\" found = (dfs(board, word, i+1, j, word_index+1) or dfs(board, word, i-1, j, word_index+1) or dfs(board, word, i, j+1, word_index+1) or dfs(board, word, i, j-1, word_index+1)) board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"You are given a list of meetings represented by intervals. Each interval is a pair of integers `[start, end]` where `start` is the start time of the meeting and `end` is the end time. You need to find the minimum number of meeting rooms required to host all the meetings. Write a function `minMeetingRooms(intervals)` that takes an array of intervals as input and returns an integer representing the minimum number of meeting rooms required. For example, given the intervals `[[0, 30], [5, 10], [15, 20]]`, the function should return `2` because two meeting rooms are necessary to host all meetings.","solution":"def minMeetingRooms(intervals): Determines the minimum number of meeting rooms required to host all meetings. Args: intervals (List[List[int]]): A list of intervals where each interval represents [start, end] times. Returns: int: The minimum number of meeting rooms required. if not intervals: return 0 # Separate and sort the start and end times start_times = sorted([i[0] for i in intervals]) end_times = sorted([i[1] for i in intervals]) start_ptr = end_ptr = 0 used_rooms = 0 # Iterate over intervals while start_ptr < len(intervals): # If there is a meeting that ends before the next meeting starts if start_times[start_ptr] >= end_times[end_ptr]: used_rooms -= 1 end_ptr += 1 # Allocate a room for the meeting used_rooms += 1 start_ptr += 1 return used_rooms"},{"question":"You are given an integer array `tasks` where `tasks[i]` represents the amount of time it takes to complete the `i-th` task. Each task can be assigned to one of two machines. Your goal is to distribute the tasks between the two machines in such a way that the maximum time taken by either machine is minimized. Implement a function `minimizeMaxTime(tasks)` that returns the minimized maximum time taken by either machine after the optimal assignment of tasks.","solution":"def minimizeMaxTime(tasks): from itertools import combinations def canDistribute(tasks, limit): n = len(tasks) for i in range(1 << n): # All subsets group1 = sum(tasks[j] for j in range(n) if i & (1 << j)) group2 = sum(tasks) - group1 if max(group1, group2) <= limit: return True return False lo, hi = max(tasks), sum(tasks) while lo < hi: mid = (lo + hi) // 2 if canDistribute(tasks, mid): hi = mid else: lo = mid + 1 return lo"},{"question":"You are given an array of integers `heights` representing the heights of students standing in a row. Each student has a different height. A **group photo** requires all students to be rearranged in a way such that nobody\'s view is completely obscured by another student. Rearrange the students to achieve this and return the new order as an array of integers representing the new order of heights. The final arrangement should ensure that no student is strictly behind a taller student when viewed from the front. Implement the following function: ```python def rearrangeStudents(heights: List[int]) -> List[int]: pass ``` **Example:** ```python # Input heights = [5, 7, 3, 6, 2] # Output # Rearrange heights to ensure proper visibility print(rearrangeStudents(heights)) # Output: [2, 3, 5, 6, 7] ```","solution":"def rearrangeStudents(heights): Rearrange the students’ heights to ensure proper visibility, i.e., no student should be completely obscured by another taller student when viewed from the front. :param heights: List[int] - List of distinct student heights :return: List[int] - Rearranged list of student heights return sorted(heights)"},{"question":"You are given a list of `n` tasks represented by integers from `0` to `n-1` and a list of `m` pairs, where each pair `[a, b]` indicates that task `a` must be completed before task `b`. Each task takes an equal amount of time to complete but can only be processed when all prerequisites are satisfied. Return the minimum time required to complete all the tasks. If it is impossible to complete all tasks, return `-1`.","solution":"from collections import deque, defaultdict def minimum_time_to_complete_tasks(n, prerequisites): def get_indegree_and_graph(n, prerequisites): indegree = [0] * n graph = defaultdict(list) for a, b in prerequisites: graph[a].append(b) indegree[b] += 1 return indegree, graph indegree, graph = get_indegree_and_graph(n, prerequisites) queue = deque([i for i in range(n) if indegree[i] == 0]) time = 0 completed_tasks = 0 while queue: task_count = len(queue) time += 1 for _ in range(task_count): current_task = queue.popleft() completed_tasks += 1 for neighbor in graph[current_task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if completed_tasks == n: return time return -1"},{"question":"You are given a list of integers where each element represents the height of a row of buildings with identical width. The width of each building is `1`. Assume each building is adjacent to the next building in the list. Compute the amount of water that can be trapped between the buildings after it rains. For example, given heights `[3, 0, 2, 0, 4]`, the amount of water that can be trapped is `7`.","solution":"def trap_rain_water(heights): Compute the amount of water trapped between buildings after it rains. :param heights: List[int] - List where each element represents the height of a row of buildings. :return: int - The amount of water trapped. if not heights: return 0 total_water = 0 n = len(heights) # Create two lists to store the maximum height to the left and right of each building left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"You are given two integer arrays, `arr1` and `arr2`, which are both of length `n`. Your task is to merge these arrays into a single sorted array. The merging should follow these rules: 1. Elements from `arr1` should be placed at even indices (0, 2, 4, ...) in the merged array. 2. Elements from `arr2` should be placed at odd indices (1, 3, 5, ...) in the merged array. 3. Both arrays should be considered sorted while merging. Return the resulting merged sorted array. **Example:** Input: arr1 = [1, 3, 5], arr2 = [2, 4, 6] Output: [1, 2, 3, 4, 5, 6] **Example:** Input: arr1 = [10, 12, 14], arr2 = [11, 13, 15] Output: [10, 11, 12, 13, 14, 15]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array with elements from arr1 at even indices and elements from arr2 at odd indices. Args: arr1 (list): first sorted array. arr2 (list): second sorted array. Returns: list: merged sorted array. n = len(arr1) merged_array = [None] * (2 * n) for i in range(n): merged_array[2 * i] = arr1[i] merged_array[2 * i + 1] = arr2[i] return merged_array"},{"question":"Given an array `heights` of integers representing the heights of students in a classroom. You are also given another array `comparison`, where `comparison[i] = [ai, bi]` indicates that student with height `ai` should stand in front of the student with height `bi`. Determine if it\'s possible to arrange all students in a line such that the given constraints are satisfied. Return `true` if such an arrangement is possible, and `false` otherwise.","solution":"def canArrangeStudents(heights, comparison): from collections import defaultdict, deque graph = defaultdict(list) indegree = defaultdict(int) for a, b in comparison: graph[a].append(b) indegree[b] += 1 zero_indegree_queue = deque([h for h in heights if indegree[h] == 0]) sorted_order = [] while zero_indegree_queue: node = zero_indegree_queue.popleft() sorted_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) return len(sorted_order) == len(heights) # Example usage: # heights = [1, 2, 3, 4] # comparison = [[1, 2], [2, 3], [3, 4]] # canArrangeStudents(heights, comparison)"},{"question":"Given a 2D grid `grid` of size `m x n` consisting of **non-negative** integers, you need to find a path from the top-left corner to the bottom-right corner of the grid such that the **sum** of the numbers along the path is minimized. You can only move **down** or **right** at any point in time. Return _the minimum sum_ of the path. The test cases are generated so that the answer fits in a 32-bit integer.","solution":"def min_path_sum(grid): Given a 2D grid of non-negative integers, calculate the minimum path sum from the top-left to the bottom-right corner by only moving down or right. m, n = len(grid), len(grid[0]) # Initialize DP array with the first cell\'s value dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"In a grid of size `m x n`, you are given `blocked_cells`, a list of tuples where each tuple represents the coordinates of a cell which is blocked and cannot be crossed. A cell `(r, c)` is considered to be within the grid if `0 <= r < m` and `0 <= c < n`. The coordinates of the top-left cell is `(0, 0)` and the coordinates of the bottom-right cell is `(m-1, n-1)`. You need to determine whether there exists a path from the top-left cell to the bottom-right cell, moving only through cells that are not blocked. You can move up, down, left, or right. Return _True_ if such a path exists, otherwise return _False_.","solution":"def path_exists(m, n, blocked_cells): from collections import deque # Function to check if a cell is valid and not blocked def is_valid(x, y): if 0 <= x < m and 0 <= y < n and (x, y) not in blocked_cells and not visited[x][y]: return True return False # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the visited matrix visited = [[False for _ in range(n)] for _ in range(m)] # Starting point start = (0, 0) end = (m-1, n-1) # If start or end is blocked, immediately return False if start in blocked_cells or end in blocked_cells: return False # Use a queue for BFS queue = deque([start]) visited[0][0] = True while queue: x, y = queue.popleft() # If we reach the end point, return True if (x, y) == end: return True # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): visited[nx][ny] = True queue.append((nx, ny)) # If we exhaust the queue without reaching the end point, return False return False"},{"question":"You are given an integer array `nums` and an integer `k`. Move the first `k` elements of `nums` to the end of the array, such that the relative order of the remaining `n-k` elements is unchanged. Do this in-place with no extra space used. Return the modified array. If `k` is greater than the length of the array, cycle through the array from the beginning until you have moved `k` elements.","solution":"def rotate_left(nums, k): Moves the first k elements of nums to the end of the array in-place. Parameters: nums (list): List of integers. k (int): Number of elements to move. Returns: list: The modified list after moving the first k elements to the end. n = len(nums) k = k % n # In case k is greater than the length of nums nums[:] = nums[k:] + nums[:k] return nums"},{"question":"You are given a list of integers `nums` representing the positions of people standing in a queue. A person represented by `nums[i]` can **see** the person in front of them if the `nums[j]` (where `j < i`) is shorter than `nums[i]`. Return _a list_ `visibility` _where_ `visibility[i]` _is the number of people that the person at position_ `i` _can see in the queue._","solution":"def calculate_visibility(nums): Returns the number of people each person in the queue can see. n = len(nums) visibility = [0] * n for i in range(n): count = 0 for j in range(i): if nums[j] < nums[i]: count += 1 visibility[i] = count return visibility"},{"question":"A company is organizing a marathon on an `m x n` field. The field is represented by an integer matrix `field` where `field[i][j]` represents the type of terrain at position `(i, j)`. There are four types of terrain: - `0` indicates a flat terrain. - `1` indicates a hill. - `2` indicates a water body. - `3` indicates a forest. The participants can move from one cell to an adjacent cell (left, right, up, or down) only if the next cell is of the same type or has a lower value (i.e., they can move from a hill (1) to a flat terrain (0) but not from a flat terrain to a hill). You are required to write a function that returns the largest connected component (i.e., the largest number of cells) of flat terrain (cells with value `0`). Two cells are part of the same component if they are directly connected horizontally or vertically. Given the matrix `field`, return the size of the largest connected component of flat terrain. If there are no flat terrains, return `0`.","solution":"def largest_flat_terrain_component(field): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or field[x][y] != 0: return 0 field[x][y] = -1 # mark as visited size = 1 # count the current cell # Visit each of the four adjacent cells size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size if not field: return 0 m, n = len(field), len(field[0]) largest_component = 0 for i in range(m): for j in range(n): if field[i][j] == 0: largest_component = max(largest_component, dfs(i, j)) return largest_component"},{"question":"Given two integers `m` and `n`, where `1 <= m <= n`, return _the sum of all prime numbers between_ `m` _and_ `n` _inclusive_. If there are no prime numbers in the given range, return `0`.","solution":"def is_prime(num): Check if a number is prime. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def sum_of_primes(m, n): Returns the sum of all prime numbers between m and n inclusive. return sum(num for num in range(m, n + 1) if is_prime(num))"},{"question":"A valid parentheses string is defined as follows: 1. An empty string `\\"\\"` is valid. 2. If `s` is valid, then `()` + `s` and `s` + `()` are valid. 3. If `s` and `t` are valid parentheses strings, then `s` + `t` is valid. You are given a string `s` consisting only of characters `\'(\'` and `\')\'`. Determine if `s` is a valid parentheses string. If it is valid, return the length of the longest valid parentheses substring. If `s` is not valid, return `0`.","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid parentheses substring. If the input string is not valid, return 0. stack = [-1] max_length = 0 for i in range(len(s)): if s[i] == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"You are given an array of integers `nums` of length `n`, and a single integer `k`. You need to determine if there exists a contiguously subarray within `nums` whose sum of elements equals to `k`. Write a function to return `true` if such a subarray exists, otherwise return `false`. For example, if `nums = [1, 3, -2, 5, -4, 6]` and `k = 4`, then the function should return `true` as the sum of subarray `[3, -2, 5]` equals `4`.","solution":"def subarray_sum(nums, k): Returns True if there is a contiguously subarray in nums that sums to k, otherwise False. cum_sum = 0 sum_dict = {0: 1} for num in nums: cum_sum += num if (cum_sum - k) in sum_dict: return True if cum_sum in sum_dict: sum_dict[cum_sum] += 1 else: sum_dict[cum_sum] = 1 return False"},{"question":"Given two sentences `s1` and `s2`, each composed of lowercase English letters and spaces, determine if you can transform `s1` into `s2` by inserting characters at any position within `s1`. You may not delete or reorder the characters in `s1`. Return _true if such a transformation is possible, or false otherwise_. Note that both `s1` and `s2` may contain multiple spaces, and you should ignore spaces when determining if `s1` can be transformed into `s2`.","solution":"def can_transform(s1, s2): Determine if s1 can be transformed into s2 by inserting characters into s1. Ignore spaces in both s1 and s2. # Remove spaces from both strings s1 = s1.replace(\' \', \'\') s2 = s2.replace(\' \', \'\') # Pointers for s1 and s2 i, j = 0, 0 # Traverse both strings while i < len(s1) and j < len(s2): if s1[i] == s2[j]: i += 1 j += 1 # If i pointer has traversed all of s1, it\'s a valid transformation return i == len(s1)"},{"question":"A company has multiple offices in different cities and wants to connect all offices with a network of fiber optic cables. Each pair of offices can be joined by a cable of a certain cost. You are given an integer `n` representing the number of offices and an array `connections` where `connections[i] = [office1, office2, cost]` denotes a cable between offices `office1` and `office2` with a cost of `cost`. Return the minimum cost to connect all the offices where all offices are connected directly or indirectly. If it is impossible to connect all the offices, return `-1`.","solution":"def minimumCost(n, connections): Returns the minimum cost to connect all offices or -1 if it is impossible. # Helper function to find the representative/root of a component def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to union two components def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Initialize the parent and rank arrays for the union-find parent = [i for i in range(n)] rank = [0] * n # Sort connections by cost connections.sort(key=lambda x: x[2]) mst_cost = 0 edges_used = 0 for office1, office2, cost in connections: # Convert 1-indexed offices to 0-indexed for 0-based parent array root1 = find(parent, office1 - 1) root2 = find(parent, office2 - 1) if root1 != root2: union(parent, rank, root1, root2) mst_cost += cost edges_used += 1 # Check if we used exactly n-1 edges to connect the graph if edges_used == n - 1: return mst_cost else: return -1"},{"question":"A company organizes an annual coding competition where each participant is given a unique score. You are given an integer array `scores` where `scores[i]` represents the score of the `i`th participant. The company wants to award special certificates to the top `k` participants. If two participants have the same score, they both receive a certificate. _Return the number of participants who will receive a certificate._","solution":"def number_of_certificate_winners(scores, k): Returns the number of participants who will receive a certificate. Args: scores: list of integers representing the scores of participants. k: integer indicating the number of top scores to consider for certificates. Returns: integer: The number of participants who will receive a certificate. from collections import Counter # Get the frequency of each score score_counts = Counter(scores) # Get the unique scores sorted in descending order unique_scores = sorted(score_counts.keys(), reverse=True) # Find the k-th highest unique score if k > len(unique_scores): threshold_score = unique_scores[-1] else: threshold_score = unique_scores[k-1] # All scores greater than or equal to the threshold score will receive certificates num_certs = sum(count for score, count in score_counts.items() if score >= threshold_score) return num_certs"},{"question":"Given a string `s` containing only the characters `(` and `)`, return the minimum number of moves needed to make the string valid. A string is considered valid if it is empty or follows the rule: it can be written as `AB` (A concatenated with B), where A and B are valid strings, or as `(A)`, where A is a valid string. Each move consists of inserting a parenthesis at any position in the string.","solution":"def min_moves_to_make_valid(s): Returns the minimum number of moves needed to make the string valid. left_unmatched = 0 # Count of unmatched \'(\' right_unmatched = 0 # Count of unmatched \')\' for char in s: if char == \'(\': left_unmatched += 1 elif char == \')\': if left_unmatched > 0: left_unmatched -= 1 else: right_unmatched += 1 return left_unmatched + right_unmatched"},{"question":"Given a linked list, write a function to reverse the list. You should return the reversed list. The function should modify the original list in-place and should use `O(1)` space complexity beyond the input list itself. The linked list node is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Your function should take the head of the linked list as an argument and return the head of the reversed linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses the given linked list and returns the head of the reversed list. :param head: ListNode - The head of the linked list. :return: ListNode - The new head of the reversed linked list. prev_node = None current_node = head while current_node: next_node = current_node.next # Store next node current_node.next = prev_node # Reverse the current node\'s pointer prev_node = current_node # Move prev_node one step forward current_node = next_node # Move current_node one step forward return prev_node # prev_node will be the new head after the list is fully reversed"},{"question":"You are given a directed, weighted graph represented as an adjacency list `graph` and an integer `start`. Each element in the adjacency list consists of pairs `[neighbor, weight]` indicating an edge from the current node to `neighbor` with a given `weight`. Implement the function `shortest_path(graph, start)` that returns an integer array where the ith element is the length of the shortest path from the `start` node to node `i`. If a node is not reachable from the `start` node, the corresponding value should be -1.","solution":"import heapq def shortest_path(graph, start): Finds the shortest path from the start node to all other nodes in a directed, weighted graph. Parameters: graph (list of list of pairs): Adjacency list representation of the graph where graph[u] contains (v, w) pairs. start (int): The starting node. Returns: list of int: The shortest path distances from the start node to each node, or -1 if a node is unreachable. n = len(graph) distances = [float(\'inf\')] * n distances[start] = 0 min_heap = [(0, start)] # (distance, node) while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) # Convert distances from infinity to -1 if not reachable. return [d if d != float(\'inf\') else -1 for d in distances]"},{"question":"Given a 2D integer grid, where each cell contains either a `0` or a `1`, find _the largest rectangle of `1`s and return its area_. A rectangle is defined by selecting any two distinct rows and columns and taking all cells between these boundaries.","solution":"def largest_rectangle_area(matrix): Find the largest rectangle of `1`s in the given 2D grid and return its area. if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) heights = [0] * m max_area = 0 def largest_rectangle_histogram(heights): stack = [] max_area = 0 for i, h in enumerate(heights + [0]): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area for row in matrix: for j in range(m): if row[j] == 0: heights[j] = 0 else: heights[j] += 1 max_area = max(max_area, largest_rectangle_histogram(heights)) return max_area"},{"question":"Given a string `s` and an integer `k`, you need to shift the string to the right by `k` positions. A right shift by one position means removing the last character of `s` and adding it to the front. Return the modified string after `k` right shifts.","solution":"def right_shift_string(s, k): Shifts the string s to the right by k positions. Parameters: s (str): The input string. k (int): The number of positions to shift to the right. Returns: str: The modified string after k right shifts. if not s: return s k = k % len(s) # To handle shifts greater than the length of s return s[-k:] + s[:-k]"},{"question":"You are given an array of integers `arr` of size `n` and an integer `k`. Every operation you use allows you to select exactly one element from the array and either increase or decrease it by `1`. Your goal is to make all elements equal using at most `k` operations in total. Return _true if it is possible to make all elements equal with exactly `k` operations, otherwise return false_.","solution":"def can_make_elements_equal(arr, k): Returns True if it is possible to make all elements in the array equal using at most k operations. Each operation selects exactly one element and either increases or decreases it by 1. Parameters: arr (list): A list of integers. k (int): The maximum allowed operations. Returns: bool: True if it\'s possible to make all elements equal, otherwise False. if not arr: return True min_elem = min(arr) total_operations = sum(abs(x - min_elem) for x in arr) return total_operations <= k and (k - total_operations) % len(arr) == 0"},{"question":"You are given an array `nums` consisting of non-negative integers. The function `transform(arr)` is defined as follows: It takes an array of integers as input and returns an array where `arr[i]` is replaced with the **sum of all distinct** integers in the input array excluding `arr[i]`. For example, given the input array `nums = [1, 2, 3]`, the results of `transform(nums)` would be `[2 + 3, 1 + 3, 1 + 2]` which is `[5, 4, 3]`. Write a function that simulates this transformation process `k` times, where `k` is a given integer, starting with the input array `nums`. Return the final array after `k` transformations.","solution":"def transform(nums): Transforms the input array such that each element is replaced by the sum of all distinct integers except for the element at the current position. total_sum = sum(set(nums)) return [total_sum - num for num in nums] def simulate_transform(nums, k): Simulates the transformation process `k` times. for _ in range(k): nums = transform(nums) return nums"},{"question":"You are given a list of non-negative integers representing the amount of rainwater that each bar in an elevation map can trap. The list indicates the height of each bar at different positions. Write a function to compute the maximum amount of rain water that can be trapped between the bars when it rains. The width of each bar is `1`. For example, given the elevation map `[0,1,0,2,1,0,1,3,2,1,2,1]`, the total amount of rainwater that can be trapped in this elevation map is `6` units.","solution":"def trap(height): Given a list of non-negative integers representing the height of bars in an elevation map, this function computes the amount of rainwater that can be trapped after it rains. :param height: List[int] - list of bar heights :return: int - the total amount of trapped rainwater if not height: return 0 n = len(height) left_max, right_max = [0] * n, [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a `root` representing a binary tree and an integer `k`. Your task is to find the **k-th smallest** value in the level order traversal of the tree. In level order traversal, nodes are visited level by level from left to right. Return _the k-th smallest value in the level order traversal of the tree_. If `k` is larger than the number of nodes in the tree, return `-1`.","solution":"from collections import deque # Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def kth_smallest_level_order(root, k): if not root: return -1 queue = deque([root]) counter = 0 while queue: node = queue.popleft() counter += 1 if counter == k: return node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return -1"},{"question":"You are given a string `s` representing a file path, which may contain `.` and `..` indicating current and parent directories respectively. Simplify the path to its canonical form according to the following rules: 1. The canonical path should start with a single slash `/`. 2. Any two consecutive slashes `//` are treated as a single slash `/`. 3. Any single dot `.` should be ignored. 4. Any double dot `..` moves up a directory - if there\'s a directory to move up to. 5. The canonical path should not have any trailing slashes except for the root directory `/`. Write a function that takes in a string `s` and returns the simplified canonical path. Example: - Input: s = \\"/home//foo/../var/./lib//file.txt\\" - Output: \\"/home/var/lib/file.txt\\"","solution":"def simplify_path(s): # Split the given path by \'/\' parts = [part for part in s.split(\'/\') if part not in [\'\', \'.\']] stack = [] for part in parts: if part == \'..\': if stack: stack.pop() else: stack.append(part) # Join the stack to make the canonical path simplified_path = \'/\' + \'/\'.join(stack) return simplified_path"},{"question":"Implement a function `serialize` and a function `deserialize` to work with a binary tree. The `serialize` function takes the root of a binary tree and returns a string representation of the tree, and the `deserialize` function takes a string representation of a tree and returns the root of the binary tree. Ensure that the tree can be correctly reconstructed from the serialized string. The binary tree could be a tree with any integer values and you can assume that different integers will represent different nodes in the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def preorder(node): if not node: return [\\"#\\"] return [str(node.val)] + preorder(node.left) + preorder(node.right) return \',\'.join(preorder(root)) def deserialize(data): Decodes your encoded data to tree. def helper(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node nodes = iter(data.split(\',\')) return helper(nodes)"},{"question":"Write a function that takes an array of integers and returns the maximum sum of any non-empty subarray. A subarray is a contiguous part of an array. **Example 1:** **Input:** nums = [-2,1,-3,4,-1,2,1,-5,4] **Output:** 6 **Explanation:** [4,-1,2,1] has the largest sum = 6. **Example 2:** **Input:** nums = [1] **Output:** 1 **Example 3:** **Input:** nums = [5,4,-1,7,8] **Output:** 23 **Constraints:** - 1 <= nums.length <= 10^4 - -10^5 <= nums[i] <= 10^5","solution":"def max_subarray_sum(nums): Returns the maximum sum of any non-empty subarray. max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` consisting of only the characters `\'a\'`, `\'b\'`, and `\'c\'`. You can perform the following operation on the string any number of times: - Choose any `i` such that `0 <= i < s.length - 2` and replace the substring `s[i...i+2]` with its lexicographic successive character (where `\'a\'` becomes `\'b\'`, `\'b\'` becomes `\'c\'`, and `\'c\'` becomes `\'a\'`). Return the lexicographically smallest string possible after applying the above operation any number of times.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string possible by performing the given operation any number of times. if not s: return s s = list(s) # Simply replace all \'b\' and \'c\' to \'a\' because \'a\' is the smallest for i in range(len(s)): if s[i] != \'a\': s[i] = \'a\' return \\"\\".join(s)"},{"question":"You are given a **0-indexed** array `days` representing the number of tasks to be completed on each day over `n` days. You are also given a positive integer array `tasks` of length `m` representing the duration of each task. Each day has a `workload` limit that denotes the maximum total duration of tasks that can be completed on that day. The objective is to assign each task to a day such that the total duration of tasks on each day does not exceed the `workload` of that day, and the total number of days utilized is minimized. Write a function that returns the minimum number of days needed to complete all the tasks given the constraints. If it is not possible to assign all tasks within the given constraints, return `-1`. **Note:** You can assume that it is always possible to complete all tasks within the given number of days if there are no workload constraints.","solution":"def min_number_of_days(days, tasks, workload): Returns the minimum number of days needed to complete all tasks or -1 if assignments are not possible within workload limits. :param days: List of int, representing the number of days :param tasks: List of int, representing durations of tasks :param workload: int, representing the maximum workload per day :return: int, minimum number of days needed or -1 tasks.sort(reverse=True) day_loads = [0] * len(days) for task in tasks: assigned = False for i in range(len(day_loads)): if day_loads[i] + task <= workload: day_loads[i] += task assigned = True break if not assigned: return -1 utilized_days = 0 for load in day_loads: if load > 0: utilized_days += 1 return utilized_days"},{"question":"You are given a string `s` consisting of `n` lowercase English letters. You can perform the following operation any number of times: Choose a non-empty substring of `s` and replace all of its characters with the same character. The cost of this operation is the number of distinct characters in the substring being replaced. Return the minimum cost required to make all characters in `s` the same.","solution":"def min_cost_to_make_all_chars_same(s): Returns the minimum cost required to make all characters in the string s the same. # Find the frequency of each character in the string freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 # The cost to make all characters the same is the total number of unique characters # As we can always replace everything to the most frequent character with the minimum cost return len(freq)"},{"question":"A company is organizing a team-building event where teams are formed in pairs. You are given a list of employees, each represented by a unique integer from `1` to `n`. Additionally, an integer `m` representing the number of predefined pairs is given, along with a 2D array `pairs`, where `pairs[i] = [ai, bi]` indicates that the employee `ai` should be paired with employee `bi`. Return _true_ if it is possible to form exactly `n/2` pairs such that each employee is paired with exactly one other employee in the predefined pairs and every predefined pair is formed. Otherwise, return _false_.","solution":"def can_form_pairs(n, pairs): Return True if it is possible to form exactly n/2 pairs such that each employee is paired with exactly one other employee in the predefined pairs and every predefined pair is formed. Otherwise, return False. if n % 2 != 0: return False # n must be even to form pairs pairs_set = set(frozenset(pair) for pair in pairs) if len(pairs_set) != n // 2: return False # Number of pairs should be exactly n/2 and all must be predefined employee_pairs = set() for a, b in pairs: if a in employee_pairs or b in employee_pairs: return False # Each employee should be in exactly one pair employee_pairs.add(a) employee_pairs.add(b) return True"},{"question":"Given an integer array `nums`, return all possible **subsequences** of the array such that each subsequence is strictly **increasing**. A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. The solution set must not contain duplicate subsequences. Return the subsequence in any order.","solution":"def findSubsequences(nums): def backtrack(start, path): if len(path) > 1: result.add(tuple(path)) for i in range(start, len(nums)): if not path or nums[i] >= path[-1]: backtrack(i + 1, path + [nums[i]]) result = set() backtrack(0, []) return list(result)"},{"question":"Given an array of integers `arr`, find the length of the longest subarray where the absolute difference between any two elements is less than or equal to `limit`. The answer must use an algorithm with a time complexity of `O(n)`.","solution":"from collections import deque def longest_subarray(arr, limit): Returns the length of the longest subarray where the absolute difference between any two elements is less than or equal to limit. min_deque = deque() max_deque = deque() left = 0 max_length = 0 for right in range(len(arr)): while min_deque and arr[right] < arr[min_deque[-1]]: min_deque.pop() while max_deque and arr[right] > arr[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > limit: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an `m x n` grid of characters containing a string \'word\', write a function that returns _the starting row and column indices of each instance of the word if it can be formed in the grid following these rules:_ - The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. - The same letter cell may not be used more than once. _Return the starting indices of the word instances as a list of tuples `(start_row, start_col)`. If the word cannot be constructed, return an empty list._ **Example:** _Input:_ `grid = [[\\"A\\",\\"B\\",\\"C\\",\\"E\\"],[\\"S\\",\\"F\\",\\"C\\",\\"S\\"],[\\"A\\",\\"D\\",\\"E\\",\\"E\\"]]` `word = \\"ABCCED\\"` _Output:_ `[(0, 0)]`","solution":"def find_word_start_indices(grid, word): def dfs(x, y, index): if index == len(word): return True if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != word[index]: return False temp = grid[x][y] grid[x][y] = \\"#\\" found = (dfs(x + 1, y, index + 1) or dfs(x - 1, y, index + 1) or dfs(x, y + 1, index + 1) or dfs(x, y - 1, index + 1)) grid[x][y] = temp return found if not grid or not word: return [] results = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == word[0]: if dfs(i, j, 0): results.append((i, j)) return results"},{"question":"You are given a string `s` consisting of lowercase English letters. You can apply the following operation at most once: Choose an index `i` and change the character at `i` to any other lowercase English letter. Your goal is to determine the length of the longest substring that is the same after applying the operation. Return _the length of the longest substring that can be obtained_.","solution":"def longest_substring_after_one_change(s): Returns the length of the longest substring that can be obtained by changing one character at most. from collections import defaultdict max_len = 0 # Helper function to calculate maximum segment with one character change def max_segment_with_one_change(char): left = 0 changes = 0 max_segment = 0 for right in range(len(s)): if s[right] != char: changes += 1 while changes > 1: if s[left] != char: changes -= 1 left += 1 max_segment = max(max_segment, right - left + 1) return max_segment # Check for all characters \'a\' to \'z\' for i in range(26): current_char = chr(ord(\'a\') + i) max_len = max(max_len, max_segment_with_one_change(current_char)) return max_len"},{"question":"Given an array `costs` where `costs[i]` represents the cost of scheduling the `i-th` task, and an integer `k`. You need to schedule exactly `k` tasks such that the total cost is minimized. You are provided with two additional arrays `time1` and `time2` of same length as `costs` where `time1[i]` and `time2[i]` represent the amount of time taken to complete the `i-th` task by worker 1 and worker 2, respectively. Each worker can only handle non-overlapping tasks. Return the minimum possible total cost of scheduling exactly `k` tasks.","solution":"import heapq def min_cost_to_schedule_tasks(costs, k, time1, time2): Returns the minimum possible total cost of scheduling exactly k tasks where each worker can handle only non-overlapping tasks. Parameters: costs (list): List of integers representing the cost to schedule each task. k (int): Number of tasks to schedule. time1 (list): List of integers representing the time taken to complete each task by worker 1. time2 (list): List of integers representing the time taken to complete each task by worker 2. Returns: int: Minimum total cost to schedule exactly k tasks. # Combine costs with the minimum of time1 and time2 combined = list(zip(costs, time1, time2)) # Sort the tasks by cost sorted_combined = sorted(combined, key=lambda x: x[0]) # Use a priority queue to manage worker task assignments pq = [] worker1_end = worker2_end = 0 total_cost = 0 for i in range(k): cost, t1, t2 = sorted_combined[i] if worker1_end <= worker2_end: heapq.heappush(pq, (worker1_end + t1, \'worker1\')) worker1_end += t1 else: heapq.heappush(pq, (worker2_end + t2, \'worker2\')) worker2_end += t2 total_cost += cost return total_cost"},{"question":"Given a `m x n` grid containing characters, where each cell contains a lowercase letter, return the length of the longest path you can travel such that no letter is repeated on the path. You can move in four possible directions: up, down, left, or right. Note that you cannot visit the same cell more than once on a path.","solution":"def longest_unique_path(grid): def dfs(x, y, visited): visited.add(grid[x][y]) max_length = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] not in visited: max_length = max(max_length, dfs(nx, ny, visited)) visited.remove(grid[x][y]) return max_length + 1 max_path = 0 for i in range(len(grid)): for j in range(len(grid[0])): max_path = max(max_path, dfs(i, j, set())) return max_path"},{"question":"**Implement a TRIE (prefix tree) to support the following two operations:** 1. **insert(string word)**: Inserts the `word` into the trie. 2. **search(string word)**: Returns `true` if the `word` is in the trie and `false` otherwise. Your implementations of `insert` and `search` should run in O(m) time complexity, where `m` is the length of the `word`. The `Trie` should be defined as follows: ```python class Trie: def __init__(self): pass def insert(self, word): pass def search(self, word): pass ``` Demonstrate the usage of this `Trie` class with the following operations: 1. Insert the word `\\"apple\\"` into the trie. 2. Search for the word `\\"apple\\"` in the trie. 3. Search for the word `\\"app\\"` in the trie. 4. Insert the word `\\"app\\"` into the trie. 5. Search for the word `\\"app\\"` in the trie. You should include example commands and the expected output for these operations.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word): current_node = self.root for char in word: if char not in current_node.children: return False current_node = current_node.children[char] return current_node.is_end_of_word # Example Usage: trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True"},{"question":"You are given a binary tree in which each node contains a value. Design an algorithm to find the minimum value node that is a common ancestor of two given nodes `p` and `q`. The value of each node is unique and `p` and `q` refer to the values of the nodes you need to find the common ancestor for. A common ancestor is a node that is on the path from each given node to the root. The minimum value node is the one with the smallest value among all common ancestors of `p` and `q`. Return the value of the minimum common ancestor node.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root, p, q): Function to find the minimum value node that is a common ancestor of nodes p and q. if root is None: return None # If either p or q matches the root\'s value, this node is an ancestor. if root.val == p or root.val == q: return root # Recursively check the left and right subtrees. left_lca = find_lca(root.left, p, q) right_lca = find_lca(root.right, p, q) # If both left_lca and right_lca are non-null, this node is the common ancestor. if left_lca and right_lca: return root # Otherwise, return the non-null node. return left_lca if left_lca is not None else right_lca def min_common_ancestor(root, p, q): Returns the value of the minimum value node that is a common ancestor of p and q. lca = find_lca(root, p, q) return lca.val if lca else None"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to perform operations to remove adjacent pairs of equal characters. Each time you perform such a removal, the string gets shorter and you repeat the process on the new string until no more adjacent identical characters can be removed. Return the final string after all such removals have been performed. If the final string is empty, return an empty string.","solution":"def remove_adjacent_pairs(s): Removes adjacent pairs of equal characters iteratively until no more can be removed. Returns the final string after all such removals. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an integer array `arr` and an integer `n`. Your task is to find the `n`th smallest number in the `arr` after applying the following operation exactly once: Each element in the array can either be left unchanged or replaced by its negative counterpart (e.g., `5` can be replaced by `-5` and vice versa). Return _the `n`th smallest number_ in the transformed array.","solution":"def nth_smallest_transformed(arr, n): Returns the nth smallest number in the transformed array, where each element can be either its original value or its negative counterpart. transformed = [] for num in arr: transformed.append(num) transformed.append(-num) transformed.sort() return transformed[n-1]"},{"question":"You are given a string `sentence` where each word is separated by a single space and consists of lowercase letters. A word is defined as a sequence of non-space characters. Reverse the order of characters in each word while preserving the order of the words and return the resulting string.","solution":"def reverse_words_in_sentence(sentence): Reverses the order of characters in each word while preserving the order of the words. :param sentence: A string where each word is separated by a single space :return: A string with each word\'s characters reversed words = sentence.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"You are given a sorted integer array `nums` and an integer `k`. Find the `k` most frequent elements in the array. If there is a tie, the smaller elements will be given preference in the result. Return _an array_ of length `k` _consisting of the most frequent elements in sorted order_.","solution":"from collections import Counter def k_most_frequent(nums, k): Find the k most frequent elements in the given sorted array nums. If there\'s a tie, the smaller elements are preferred. Return an array of length k consisting of the most frequent elements in sorted order. # Count the frequency of each element in nums counts = Counter(nums) # Sort elements by frequency (descending) and then by value (ascending) sorted_elements = sorted(counts.items(), key=lambda x: (-x[1], x[0])) # Extract the top k most frequent elements result = [element for element, count in sorted_elements[:k]] # Return the sorted result return sorted(result)"},{"question":"You are given an array of `n` positive integers `nums` representing the amount of time each task takes to complete, and an integer `k` representing the number of workers available. Each worker can perform exactly one task at a time and a worker will start a new task immediately after finishing the previous one. Your goal is to distribute the tasks such that the execution is completed as soon as possible. Return the minimum amount of time required to complete all tasks.","solution":"def minimum_time_to_complete_tasks(nums, k): Returns the minimum amount of time required to complete all tasks using k workers. # If there are more workers than tasks, the answer is just the maximum time in nums if k >= len(nums): return max(nums) # Binary search to find the minimum possible time left, right = max(nums), sum(nums) def can_complete_in_time(time_limit): workers = 1 total_time = 0 for time in nums: if total_time + time > time_limit: workers += 1 total_time = time if workers > k: return False else: total_time += time return True while left < right: mid = (left + right) // 2 if can_complete_in_time(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` that consists of lowercase English letters. You can perform the following operation on the string: pick any character and append it to the end of the string. You are required to normalize the string such that every character that appears in the string appears in the same continuous block of characters. Return _the minimum number of operations needed to achieve a normalized string_.","solution":"def min_operations_to_normalize(s): Returns the minimum number of operations needed to normalize the string. total_operations = 0 for i in range(1, len(s)): if s[i] != s[i - 1]: total_operations += 1 return total_operations"},{"question":"You are given a list of `n` integers `nums` representing the scores of students in an exam, where `n` is always an even number. You need to form `n/2` pairs of students such that each student is in exactly one pair. The score of a pair is the minimum score of the two students in that pair. Return the maximum possible sum of scores of the pairs.","solution":"def array_pair_sum(nums): Returns the maximum possible sum of scores of the pairs. :param nums: List[int] :return: int nums.sort() return sum(nums[::2])"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house, arranged in a row. A thief plans to rob houses, but he cannot rob two adjacent houses due to the security alarm system. Write a function that returns _the maximum amount of money the thief can rob without triggering the alarm._ The function should return an integer representing the maximum amount of money that can be robbed. **Note**: There is at least one house in the list.","solution":"def rob(nums): Returns the maximum amount of money the thief can rob without triggering the alarm. :param nums: List[int] :return: int if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[-1]"},{"question":"A popular MMORPG requires players to complete quests to gain experience points (XP). Each quest has an associated XP value, but players can complete quests in any order they choose. The total XP needed to level up is `L`. You are given a list of integers `xp` where `xp[i]` represents the XP value of the `i-th` quest. Write a function that determines if the player can exactly achieve `L` XP by completing a subset of quests. Return _True_ if it\'s possible, otherwise return _False_.","solution":"def can_achieve_xp(xp, L): Determines if the player can exactly achieve L XP by completing a subset of quests. :param xp: List of integers where xp[i] represents the XP value of the i-th quest. :param L: Integer representing the total XP needed to level up. :return: True if it\'s possible to achieve exactly L XP, otherwise False. n = len(xp) dp = [False] * (L + 1) dp[0] = True for x in xp: for i in range(L, x - 1, -1): dp[i] = dp[i] or dp[i - x] return dp[L]"},{"question":"Given an array of integers `nums` and an integer `k`, return an array of the `k` most frequent elements in `nums`. If there are multiple elements with the same frequency, return any subset of the `k` elements. The solution should have a time complexity better than O(n log n), where n is the length of the input array.","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Returns the k most frequent elements in the nums array. :param nums: List[int] - List of integers :param k: int - The number of most frequent elements to return :return: List[int] - List of k most frequent elements if not nums or k <= 0: return [] # Count the frequency of each element in the array count = Counter(nums) # Use a heap to find the k most frequent elements return [item for item, frequency in heapq.nlargest(k, count.items(), key=lambda x: x[1])]"},{"question":"You are given a string `s` containing only lowercase English letters. You can apply the following operations any number of times: 1. Choose any two adjacent characters in the string and replace them with a single character that is lexicographically larger than both characters. Your task is to determine the lexicographically largest string that can be obtained by applying the above operations any number of times. Return the resulting string.","solution":"def get_lexicographically_largest_string(s): Returns the lexicographically largest string that can be obtained by applying the above operations any number of times. The lexicographically largest single character \'z\' will always be the optimal outcome, as you can always replace any two adjacent characters to attempt to get closer to \'z\'. if not s: return \\"\\" return \\"z\\""},{"question":"Implement a class `ParkingLot` that manages the allocation of parking spots in a parking lot. Each parking spot has a unique ID and can accommodate a vehicle of a certain size. There are three types of vehicles: `motorcycle`, `car`, and `bus`, and three types of parking spots: `small`, `medium`, and `large`. - `ParkingLot(int numSmall, int numMedium, int numLarge)` - Initializes the parking lot with the given number of small, medium, and large spots. - `boolean parkVehicle(String vehicleType, int vehicleId)` - Attempts to park a vehicle of the specified type with the given ID in the appropriate spot. Returns `true` if the vehicle was successfully parked, and `false` otherwise. - `boolean leaveSpot(int vehicleId)` - Frees up the parking spot occupied by the vehicle with the given ID. Returns `true` if the spot was successfully freed, `false` if the vehicle was not found. - `int getAvailableSpots(String spotType)` - Returns the number of available spots of the specified type (\'small\', \'medium\', \'large\'). Rules: - A `motorcycle` can park in any spot. - A `car` can park in a `medium` or `large` spot. - A `bus` can only park in a `large` spot.","solution":"class ParkingLot: def __init__(self, numSmall, numMedium, numLarge): self.total_spots = { \'small\': numSmall, \'medium\': numMedium, \'large\': numLarge } self.available_spots = { \'small\': numSmall, \'medium\': numMedium, \'large\': numLarge } self.vehicle_to_spot = {} def parkVehicle(self, vehicleType, vehicleId): if vehicleType == \'motorcycle\': if self.available_spots[\'small\'] > 0: self.available_spots[\'small\'] -= 1 self.vehicle_to_spot[vehicleId] = \'small\' return True elif self.available_spots[\'medium\'] > 0: self.available_spots[\'medium\'] -= 1 self.vehicle_to_spot[vehicleId] = \'medium\' return True elif self.available_spots[\'large\'] > 0: self.available_spots[\'large\'] -= 1 self.vehicle_to_spot[vehicleId] = \'large\' return True elif vehicleType == \'car\': if self.available_spots[\'medium\'] > 0: self.available_spots[\'medium\'] -= 1 self.vehicle_to_spot[vehicleId] = \'medium\' return True elif self.available_spots[\'large\'] > 0: self.available_spots[\'large\'] -= 1 self.vehicle_to_spot[vehicleId] = \'large\' return True elif vehicleType == \'bus\': if self.available_spots[\'large\'] > 0: self.available_spots[\'large\'] -= 1 self.vehicle_to_spot[vehicleId] = \'large\' return True return False def leaveSpot(self, vehicleId): if vehicleId in self.vehicle_to_spot: spot_type = self.vehicle_to_spot[vehicleId] self.available_spots[spot_type] += 1 del self.vehicle_to_spot[vehicleId] return True return False def getAvailableSpots(self, spotType): return self.available_spots.get(spotType, 0)"},{"question":"You are given an integer array `nums` and an integer `val`. You need to remove all occurrences of `val` in `nums` **in-place**. The order of the elements can be changed. After removing the occurrences of `val`, return the new length of the array. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.","solution":"def remove_element(nums, val): Removes all occurrences of `val` in `nums` in-place and returns the new length of the array. Parameters: nums (List[int]): The list of numbers to modify. val (int): The value to remove from the list. Returns: int: The new length of the array after removals. k = 0 # Pointer to place the next element that is not `val`. for i in range(len(nums)): if nums[i] != val: nums[k] = nums[i] k += 1 return k"},{"question":"Implement a data structure called `MedianFinder` that supports two operations: * `void addNum(int num)` - Adds an integer `num` from the data stream to the data structure. * `double findMedian()` - Returns the median of all elements so far. Answers within `10^(-5)` of the actual median will be accepted. The median is defined as follows: * If the size of the data structure is even, the median is the average of the two middle elements. * If the size of the data structure is odd, the median is the middle element. Both operations (`addNum` and `findMedian`) should run in `O(log n)` time complexity where `n` is the number of elements added to the data structure.","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. # max-heap for the first half of numbers self.low = [] # min-heap for the second half of numbers self.high = [] def addNum(self, num: int) -> None: Adds a number into the data structure. # Add to max heap (invert num for max-heap behavior) heapq.heappush(self.low, -num) # Balance step: push the largest element of low to high heapq.heappush(self.high, -heapq.heappop(self.low)) # Maintain size property that max heap is allowed to have # at most one more element than the min heap if len(self.low) < len(self.high): heapq.heappush(self.low, -heapq.heappop(self.high)) def findMedian(self) -> float: Finds the median of current numbers. if len(self.low) > len(self.high): return float(-self.low[0]) else: return (-self.low[0] + self.high[0]) / 2.0"},{"question":"Given a string `text` and a string pattern consisting of distinct characters, determine the smallest substring in `text` that contains all the characters from `pattern`. If there is no such substring, return an empty string.","solution":"def min_window_substring(text, pattern): Finds the smallest substring in `text` containing all characters of `pattern`. If no such substring exists, it returns an empty string. from collections import Counter if not text or not pattern: return \\"\\" char_count = Counter(pattern) required = len(char_count) left, right = 0, 0 formed = 0 window_counts = {} min_len = float(\\"inf\\") min_left = 0 while right < len(text): char = text[right] window_counts[char] = window_counts.get(char, 0) + 1 if char in char_count and window_counts[char] == char_count[char]: formed += 1 while left <= right and formed == required: char = text[left] if right - left + 1 < min_len: min_len = right - left + 1 min_left = left window_counts[char] -= 1 if char in char_count and window_counts[char] < char_count[char]: formed -= 1 left += 1 right += 1 return \\"\\" if min_len == float(\\"inf\\") else text[min_left:min_left + min_len]"},{"question":"You are given a string `s` which consists of only lowercase English letters and a list of queries. Each query is represented by an integer `k` and requires you to find the lexicographically smallest substring of length `k` that can be formed from `s`. Return a list of results where each element is the smallest substring for the corresponding query. If there are multiple queries, process them in the order they appear in the list.","solution":"def smallest_substring(s, queries): Given a string s and a list of queries, returns the lexicographically smallest substring for each query of length k. Args: s (str): A string consisting of only lowercase English letters. queries (List[int]): A list of integers representing the length of substrings to find. Returns: List[str]: A list of lexicographically smallest substrings for each query. results = [] for k in queries: if k > len(s): results.append(\\"\\") continue min_substring = s[:k] for i in range(1, len(s) - k + 1): current_substring = s[i:i + k] if current_substring < min_substring: min_substring = current_substring results.append(min_substring) return results"},{"question":"Given a **0-indexed** integer array `arr` of length `n`, you need to partition the array into two disjoint (non-overlapping) subarrays `left` and `right` such that: * Every element in `left` is less than or equal to every element in `right`. * `left` contains at least one element. * `left` has the minimal possible size. Return the length of `left` after such a partitioning. Create an efficient algorithm to accomplish this task.","solution":"def partition_disjoint(arr): Returns the length of the left partition such that every element in left is less than or equal to every element in right and left has the minimal possible size. :param arr: List[int] - the input array of integers :return: int - the length of the left partition n = len(arr) max_left = [0] * n min_right = [0] * n max_left[0] = arr[0] for i in range(1, n): max_left[i] = max(max_left[i - 1], arr[i]) min_right[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): min_right[i] = min(min_right[i + 1], arr[i]) for i in range(1, n): if max_left[i - 1] <= min_right[i]: return i return n # this should never be reached"},{"question":"Given an integer `x`, return `true` if `x` is a palindrome integer, and `false` otherwise. An integer is a palindrome when it reads the same backward as forward. For example, `121` is a palindrome while `123` is not. Do not convert the integer to a string to check if it is a palindrome.","solution":"def is_palindrome(x): Returns True if x is a palindrome integer, and False otherwise. Do not convert the integer to a string. if x < 0: return False original = x reversed_num = 0 while x != 0: digit = x % 10 reversed_num = reversed_num * 10 + digit x = x // 10 return original == reversed_num"},{"question":"Given a list of words and a pattern, find all words that match the given pattern. A word matches the pattern if there exists a permutation of letters `p` such that after replacing every letter `x` in the pattern with `p(x)`, we get the corresponding word. For example, given words `[\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"]` and pattern `\\"abb\\"`, return `[\\"mee\\", \\"aqq\\"]`.","solution":"def find_and_replace_pattern(words, pattern): def word_pattern(word): mapping = {} pattern = [] next_char = 0 for char in word: if char not in mapping: mapping[char] = next_char next_char += 1 pattern.append(mapping[char]) return tuple(pattern) pattern_key = word_pattern(pattern) return [word for word in words if word_pattern(word) == pattern_key] # Test case words = [\\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"] pattern = \\"abb\\" print(find_and_replace_pattern(words, pattern)) # Output: [\\"mee\\", \\"aqq\\"]"},{"question":"You are given a string `s` representing a sequence of characters and a string `t` representing a subsequence to be formed from `s`. Determine the minimum number of deletion operations required on `s` to create `t` as a subsequence of `s`. If it is not possible to form `t` from `s`, return -1. A subsequence is a sequence derived from another sequence by deleting some elements without changing the order of the remaining elements.","solution":"def min_deletions_to_form_subsequence(s, t): Determines the minimum number of deletions required on string s to form t as a subsequence. Returns -1 if it\'s not possible to form t from s. # Pointer for tracking position in t t_index = 0 t_length = len(t) max_formable_length = 0 # Traverse through string s for char in s: if t_index < t_length and char == t[t_index]: t_index += 1 max_formable_length += 1 if max_formable_length < t_length: return -1 return len(s) - max_formable_length"},{"question":"You are given a **0-indexed** list of integers `arr` and an integer `k`. The array can be cyclically shifted to the left by one position, where the first element moves to the end of the list. Perform exactly `k` left rotations and then return the resulting array. For example: - When `arr = [1, 2, 3, 4, 5]` and `k = 2`, after 2 left rotations, `arr` becomes `[3, 4, 5, 1, 2]`. - When `arr = [10, 20, 30, 40]` and `k = 1`, after 1 left rotation, `arr` becomes `[20, 30, 40, 10]`. Implement a function `List<Integer> rotateLeft(List<Integer> arr, int k)` that takes a list of integers `arr` and an integer `k`, performs `k` left rotations, and returns the resulting list.","solution":"def rotate_left(arr, k): Perform k left rotations on the array. Parameters: arr (list): The list of integers to rotate. k (int): The number of rotations to perform. Returns: list: The rotated list. n = len(arr) if n == 0 or k % n == 0: return arr k = k % n # In case k is larger than n return arr[k:] + arr[:k]"},{"question":"Given a list of `n` jobs, where each job requires a certain amount of time to complete, create a schedule such that the maximum completion time for any job is minimized. You have `k` identical processors available to assign these jobs. Each processor can only work on one job at a time, but a processor can take on the next job as soon as it finishes its current one. Return the _minimum possible maximum completion time_ among all processors.","solution":"import heapq def min_max_completion_time(jobs, k): Returns the minimum possible maximum completion time of any processor given `k` processors and a list of `n` jobs with their respective completion times. if k >= len(jobs): return max(jobs) # Priority queue to represent the current load of each processor processors = [0] * k heapq.heapify(processors) for job in sorted(jobs, reverse=True): least_loaded = heapq.heappop(processors) least_loaded += job heapq.heappush(processors, least_loaded) return max(processors)"},{"question":"You are given two strings `word1` and `word2`. You want to construct a string `result` by merging these two strings such that: - `result` alternates characters from `word1` and `word2`, starting with `word1`. - If a string is longer than the other, append the remaining characters to `result` after the shorter string is exhausted. Return the merged string. For example, given: - `word1 = \\"abc\\"` - `word2 = \\"defgh\\"` You should return the string `\\"adbecfgh\\"`.","solution":"def merge_alternately(word1, word2): Merges two strings by alternating characters from each string, starting with word1. If one string is longer than the other, append the remaining characters to the result. result = [] length1, length2 = len(word1), len(word2) min_length = min(length1, length2) for i in range(min_length): result.append(word1[i]) result.append(word2[i]) if length1 > length2: result.append(word1[min_length:]) elif length2 > length1: result.append(word2[min_length:]) return \'\'.join(result)"},{"question":"You are given an integer array `nums` where each element represents a unique number. Determine if it’s possible to reorder the elements of `nums` so that for every `i` in the range `[0, nums.length - 2]`, the absolute difference between `nums[i]` and `nums[i + 1]` is exactly `1`. Return `true` if such a reordering exists, or `false` otherwise.","solution":"def can_reorder(nums): Determines if it\'s possible to reorder the elements of nums so that for every i in the range [0, nums.length - 2], the absolute difference between nums[i] and nums[i+1] is exactly 1. :param nums: List[int], a list where each element represents a unique number :return: bool, True if such a reorder is possible, otherwise False nums_sorted = sorted(nums) # Check if the sorted nums have consecutive elements for i in range(len(nums_sorted) - 1): if nums_sorted[i + 1] - nums_sorted[i] != 1: return False return True"},{"question":"You are given the head of a singly linked list. Write a function to reorder the list such that the nodes are rearranged in a specific pattern: list elements should be in the order of first element, last element, second element, second last element, and so on. More formally, given the linked list `L0 -> L1 -> ... -> Ln-1 -> Ln`, reorder it to `L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...`. The function should modify the list in place without using additional list structures.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reorderList(head): if not head or not head.next: return # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next and fast.next.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev, curr = None, slow.next while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Disconnect the first half and the second half slow.next = None # Step 3: Merge the two halves first, second = head, prev while second: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first = tmp1 second = tmp2"},{"question":"You are given two strings `str1` and `str2`. A **substring** is defined as a contiguous sequence of characters within a string. Write a function to identify the longest common substring between `str1` and `str2` and return it. If there are multiple substrings with the same maximum length, return the one which appears first in `str1`. If there is no common substring, return an empty string.","solution":"def longest_common_substring(str1, str2): Returns the longest common substring between str1 and str2. If there are multiple with the same length, return the first one in str1. If there\'s no common substring, return an empty string. if not str1 or not str2: return \\"\\" len1, len2 = len(str1), len(str2) longest = 0 end_pos = 0 dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > longest: longest = dp[i][j] end_pos = i else: dp[i][j] = 0 if longest == 0: return \\"\\" else: return str1[end_pos - longest:end_pos]"},{"question":"You are given a binary tree with `n` nodes where each node is labeled from `0` to `n-1`. You are also given an array `leftChild` of size `n` and an array `rightChild` of size `n`, where `leftChild[i]` is the left child of node `i`, and `rightChild[i]` is the right child of node `i`. Return `true` if and only if the binary tree is a **valid binary tree**. A binary tree is **valid** if: - It has exactly one root. - There are no cycles. - Every node other than the root has exactly one parent.","solution":"def validateBinaryTreeNodes(n, leftChild, rightChild): Validates if the given binary tree with `n` nodes, specified by `leftChild` and `rightChild` arrays, is a valid binary tree. :param n: Number of nodes in the tree. :param leftChild: Array of left children nodes. :param rightChild: Array of right children nodes. :return: Boolean indicating if the tree is a valid binary tree. in_degrees = [0] * n for i in range(n): if leftChild[i] != -1: in_degrees[leftChild[i]] += 1 if rightChild[i] != -1: in_degrees[rightChild[i]] += 1 roots = [i for i in range(n) if in_degrees[i] == 0] # There should be exactly one root if len(roots) != 1: return False visited = set() def dfs(node): if node == -1 or node in visited: return visited.add(node) dfs(leftChild[node]) dfs(rightChild[node]) # Start DFS from the root root = roots[0] dfs(root) # Ensuring all nodes are visited exactly once return len(visited) == n"},{"question":"Write a function that takes an array of strings and returns the string that appears most frequently. In the event of a tie, return the lexicographically smallest string.","solution":"def most_frequent_string(strings): Returns the string that appears most frequently in the array. In the event of a tie, returns the lexicographically smallest string. from collections import Counter if not strings: return None # Count the frequency of each string freq_counter = Counter(strings) # Find the maximum frequency max_freq = max(freq_counter.values()) # Collect all strings that have the maximum frequency max_freq_strings = [string for string, count in freq_counter.items() if count == max_freq] # Return the lexicographically smallest string among the ones with maximum frequency return min(max_freq_strings)"},{"question":"You are given a **0-indexed** integer array `tasks` of length `n` where each element represents the number of minutes required to complete a corresponding task. A worker can perform one task at a time but can also take a break of 10 minutes after completing each task. However, breaks are optional and can be skipped. The goal is to minimize the total time required to complete all the tasks. Return _the minimum total time needed_ to complete all given tasks.","solution":"def min_total_time(tasks): Returns the minimum total time needed to complete all given tasks. total_time = sum(tasks) # Sum the time of all tasks return total_time"},{"question":"A **valid mountain array** is an array `arr` that satisfies the following conditions: 1. `arr.length` >= 3. 2. There exists some index `i` with `0 < i < arr.length - 1` such that: - `arr[0] < arr[1] < ... < arr[i]` - `arr[i] > arr[i+1] > ... > arr[arr.length - 1]` Given an integer array `arr`, return `true` if and only if it is a **valid mountain array**.","solution":"def is_valid_mountain_array(arr): Returns True if arr is a valid mountain array, otherwise False. n = len(arr) if n < 3: return False # Walk up i = 0 while i + 1 < n and arr[i] < arr[i + 1]: i += 1 # Check peak can\'t be first or last if i == 0 or i == n - 1: return False # Walk down while i + 1 < n and arr[i] > arr[i + 1]: i += 1 return i == n - 1"},{"question":"You are given a string `s` representing a sentence where each word is separated by a single space. However, the punctuation marks are incorrectly placed. Correct the punctuations to ensure that each punctuation mark (.,?!\') is immediately adjacent to the last character of the word it belongs to (i.e., no space between the word and the punctuation mark) and that the sentence structure remains the same as in the input. Return the corrected sentence as a string. Assume no punctuation mark appears at the start or end of the sentence.","solution":"def correct_punctuation(s): Corrects punctuation marks in the given sentence to be immediately adjacent to the last character of the word they belong to. Parameters: s (str): A string representing a sentence with punctuation marks incorrectly placed. Returns: str: The corrected sentence with punctuation marks correctly placed. import re return re.sub(r\'s([?.!,\'])\', r\'1\', s)"},{"question":"Design an online stock span system that can calculate the span of the stock\'s price for the current day. The span of the stock\'s price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the price of the stock was less than or equal to today\'s price. Implement the `StockSpanner` class: * `StockSpanner()` Initializes the `StockSpanner` object. * `int next(int price)` Returns the span of the stock\'s price for the current day.","solution":"class StockSpanner: def __init__(self): self.stack = [] # Each element is a tuple of (price, span) def next(self, price): span = 1 # Calculate the span by looking at the previous prices in the stack while self.stack and self.stack[-1][0] <= price: span += self.stack.pop()[1] # Append the current price and its span to the stack self.stack.append((price, span)) return span"},{"question":"You are given a string `encoded` representing a run-length encoded sequence. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer. Decode the string and return it. **Example**: If the input is `\\"3[a2[c]]\\"`, the output would be `\\"accaccacc\\"`.","solution":"def decode_string(s): def decode_helper(s, index): decoded_str = \\"\\" count = 0 while index < len(s): if s[index].isdigit(): count = count * 10 + int(s[index]) elif s[index] == \'[\': index, decoded_part = decode_helper(s, index + 1) decoded_str += decoded_part * count count = 0 elif s[index] == \']\': return index, decoded_str else: decoded_str += s[index] index += 1 return decoded_str return decode_helper(s, 0)"},{"question":"You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times. Return _the length of the longest substring containing the same letter you can get after performing the above operations_. **Hint:** - Use sliding window technique. - You can use a hashmap to track the frequency of different characters within the window. - Try to keep the window\'s length conditionally based on the frequency of the most frequent character in the window and the allowed number of changes (k).","solution":"def characterReplacement(s, k): Returns the length of the longest substring containing the same letter you can get after performing the given operation at most k times. max_length = 0 max_count = 0 count = [0] * 26 left = 0 for right in range(len(s)): count[ord(s[right]) - ord(\'A\')] += 1 max_count = max(max_count, count[ord(s[right]) - ord(\'A\')]) # if the current window size minus the count of the most frequent character is greater than k # we need to move the left pointer to make it valid if right - left + 1 - max_count > k: count[ord(s[left]) - ord(\'A\')] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an m x n grid `board` where each cell is initially a **dead** (\'0\') or **live** (\'1\') cell. A cell\'s state is updated based on its eight neighbors: - Any live cell with fewer than two live neighbors dies. - Any live cell with two or three live neighbors lives on. - Any live cell with more than three live neighbors dies. - Any dead cell with exactly three live neighbors becomes a live cell. Write a function to simulate the state of the board after one update. Return the resulting board.","solution":"def game_of_life(board): Updates the board to the next state based on the Game of Life rules. def count_live_neighbors(board, r, c): rows, cols = len(board), len(board[0]) directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and abs(board[nr][nc]) == 1: count += 1 return count # Iterate every cell rows, cols = len(board), len(board[0]) for r in range(rows): for c in range(cols): live_neighbors = count_live_neighbors(board, r, c) # Live cell conditions if board[r][c] == 1 and (live_neighbors < 2 or live_neighbors > 3): board[r][c] = -1 # -1 signifies the cell is now dead but was originally live # Dead cell condition if board[r][c] == 0 and live_neighbors == 3: board[r][c] = 2 # 2 signifies the cell is now alive but was originally dead # Finalize board update for r in range(rows): for c in range(cols): if board[r][c] == -1: board[r][c] = 0 if board[r][c] == 2: board[r][c] = 1 return board"},{"question":"You are given two strings `s1` and `s2` consisting of lowercase English letters. Write a function to determine if `s2` is a rotation of `s1`. A string `s2` is considered a rotation of `s1` if there exists some integer `k` such that `s2` can be obtained by moving the first `k` characters of `s1` to the end. Return _`true` if `s2` is a rotation of `s1`, otherwise return `false`_.","solution":"def is_rotation(s1, s2): Determine if s2 is a rotation of s1. :param s1: The original string. :param s2: The string to check rotation. :return: True if s2 is a rotation of s1, otherwise False. # If lengths are different, s2 cannot be a rotation of s1 if len(s1) != len(s2): return False # Concatenate s1 with itself combined = s1 + s1 # Check if s2 is a substring of the concatenated string return s2 in combined"},{"question":"You are developing a social media platform where users can create and manage groups. Each group has a name and can have an unlimited number of members represented by unique user IDs. Implement the `GroupManager` class, which supports the following operations: * `GroupManager()` Initializes the object. * `boolean createGroup(String groupName)` Creates a group with the specified `groupName`. Returns `true` if the group is successfully created, otherwise returns `false` if a group with the same name already exists. * `boolean addUserToGroup(String groupName, int userId)` Adds the specified `userId` to the group with the specified `groupName`. Returns `true` if the user is successfully added, otherwise returns `false` if the group does not exist or the user is already a member of the group. * `boolean removeUserFromGroup(String groupName, int userId)` Removes the specified `userId` from the group with the specified `groupName`. Returns `true` if the user is successfully removed, otherwise returns `false` if the group does not exist or the user is not a member of the group. * `List<Integer> getGroupMembers(String groupName)` Returns a list of user IDs that are members of the group with the specified `groupName`. If the group does not exist, returns an empty list. * `List<String> getAllGroups()` Returns a list of all group names currently created in the platform. The list should be sorted in lexicographical order. This class will allow for the management and oversight of users within specified social media groups.","solution":"class GroupManager: def __init__(self): self.groups = {} def createGroup(self, groupName): if groupName in self.groups: return False self.groups[groupName] = set() return True def addUserToGroup(self, groupName, userId): if groupName not in self.groups: return False if userId in self.groups[groupName]: return False self.groups[groupName].add(userId) return True def removeUserFromGroup(self, groupName, userId): if groupName not in self.groups or userId not in self.groups[groupName]: return False self.groups[groupName].remove(userId) return True def getGroupMembers(self, groupName): if groupName not in self.groups: return [] return list(self.groups[groupName]) def getAllGroups(self): return sorted(self.groups.keys())"},{"question":"Given a string `s`, return _the minimum number of insertions needed to make_ `s` _a palindrome_. A palindrome is a string that reads the same forward and backward. You can insert characters anywhere in the string.","solution":"def min_insertions_to_make_palindrome(s): Returns the minimum number of insertions needed to make the string s a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for gap in range(1, n): for left in range(n - gap): right = left + gap if s[left] == s[right]: dp[left][right] = dp[left + 1][right - 1] else: dp[left][right] = min(dp[left][right - 1], dp[left + 1][right]) + 1 return dp[0][n - 1]"},{"question":"Given two integers `n` and `k`, where `n` represents the number of elements in an initial sorted array ranging from `1` to `n`, write a function to find the minimum number of adjacent swaps needed to transform the array into an arrangement where the sum of every consecutive `k` elements is always even. If it is not possible, return `-1`.","solution":"def min_adjacent_swaps(n, k): Function to find the minimum number of adjacent swaps needed to transform the array into an arrangement where the sum of every consecutive k elements is always even. If it is not possible, return -1. if (k % 2 == 1): # if k is odd, then the sum of any k consecutive elements will contain (k // 2) pairs (even + odd) # and one middle element => the parity of the k sum will be odd. This makes transformation impossible. return -1 return 0 # As k is even, given sorted array [1, 2, ..., n] is already valid # Thus, zero swaps are required"},{"question":"Implement a function `deepestLeavesSum` that takes in the root of a binary tree and returns the sum of values of its deepest leaves. The deepest leaves are the nodes that are the farthest from the root. If the tree is empty, the sum should be 0. The function should be efficient in both time and space complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): if not root: return 0 current_level = [root] while current_level: next_level = [] level_sum = 0 for node in current_level: level_sum += node.val if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not next_level: return level_sum current_level = next_level"},{"question":"You are given a list of integers `nums` which represents the number of steps a frog can take forward from its current position. The frog starts at the first index of the list and aims to reach the last index. Determine if the frog can reach the last index. The frog can only move to a subsequent position if the steps taken are within the range specified by the current position in `nums`. For example, if `nums = [2, 3, 1, 1, 4]`, the frog can reach the last index by jumping as follows: * From index 0, jump to index 1 (`nums[0] = 2` allows a jump of up to 2 steps). * From index 1, jump to index 4 (`nums[1] = 3` allows a jump of up to 3 steps). Implement the function `canReachEnd(nums)` which returns `true` if the frog can reach the last index, and `false` otherwise.","solution":"def canReachEnd(nums): Determines if the frog can reach the last index. The frog can only move to a subsequent position if the steps taken are within the range specified by the current position in nums. :param nums: List[int] - list of steps the frog can take from each position :return: bool - True if the frog can reach the last index, False otherwise max_reach = 0 for i in range(len(nums)): if i > max_reach: return False max_reach = max(max_reach, i + nums[i]) return max_reach >= len(nums) - 1"},{"question":"You are given an integer array `heights` representing the heights of buildings, and an integer `k`. You are currently on the roof of building `0`, and every second you can either move to the next building on your right or use one of your `k` jumps to move to any building in range `[i-k, i+k]` from your current position `i`. However, you cannot move to a building that is taller than the current one you are on. Determine the minimum time in seconds to reach the last building in the array, or return `-1` if it is not possible.","solution":"def min_time_to_reach_end(heights, k): Returns the minimum time in seconds to reach the last building or -1 if it is not possible. n = len(heights) if n == 1: return 0 # Initialize the minimum time array with infinity min_time = [float(\'inf\')] * n min_time[0] = 0 for i in range(n): for j in range(1, k + 1): if i + j < n and heights[i + j] <= heights[i]: min_time[i + j] = min(min_time[i + j], min_time[i] + 1) return -1 if min_time[-1] == float(\'inf\') else min_time[-1]"},{"question":"You are given an array of integers `arr` of length `n` representing stock prices on different days. On each day, you may decide to buy or sell stocks. However, you can buy at most one stock per day and you can sell at most one stock per day. Additionally, you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you can buy again). Your goal is to determine the maximum profit you can achieve. If no profit can be achieved, return `0`. Given the integer array `arr`, return _the **maximum profit** you can achieve from these transactions._","solution":"def max_profit(arr): Returns the maximum profit that can be achieved by buying and selling stocks on different days. :param arr: List[int], list of stock prices :return: int, the maximum profit if not arr or len(arr) < 2: return 0 max_profit = 0 min_price = arr[0] for price in arr: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given a list of `logs` where each log is represented as a triple `(id, start, duration)` that denotes the ID of the task, its start time, and its duration respectively. The task ends after its duration is completed. Implement a class `TaskScheduler` that performs the following operations: * `TaskScheduler()` initializes the `TaskScheduler` object. * `addTask(int id, int start, int duration)` adds a new task with the given `id`, `start` time and `duration`. * `removeTask(int id)` removes the task with the given `id`. If there is no task with the given `id`, do nothing. * `getActiveTasks(int currentTime)` returns a list of task IDs that are active at the given `currentTime`. A task is considered active if `start <= currentTime < start + duration`. Ensure that the operations perform efficiently. The tasks can start and end at any time and there may be multiple tasks with overlapping times.","solution":"class TaskScheduler: def __init__(self): self.tasks = {} def addTask(self, id, start, duration): Adds a new task with the given id, start time, and duration. self.tasks[id] = (start, duration) def removeTask(self, id): Removes the task with the given id. if id in self.tasks: del self.tasks[id] def getActiveTasks(self, currentTime): Returns a list of task IDs that are active at the given currentTime. active_tasks = [] for id, (start, duration) in self.tasks.items(): if start <= currentTime < start + duration: active_tasks.append(id) return active_tasks"},{"question":": A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for the array `nums = [1,2,3]`, the following are some of its permutations: - `[1,2,3]` - `[3,1,2]` - `[2,3,1]` Given an array of distinct integers `nums` and an integer `k`, return the `k-th` permutation sequence of the array. The permutation sequence is considered to be 1-indexed. Example: If `nums = [1, 2, 3]` and `k = 3`, the solution should return `[2, 1, 3]` since `[2, 1, 3]` is the 3rd permutation of `[1, 2, 3]`.","solution":"from math import factorial def get_kth_permutation(nums, k): Returns the k-th permutation sequence (1-indexed) of the array of distinct integers nums. Parameters: nums (List[int]): The array of distinct integers. k (int): The index of the permutation sequence (1-indexed). Returns: List[int]: The k-th permutation sequence. n = len(nums) k -= 1 # Convert k to 0-indexed permutation = [] elements = sorted(nums) for i in range(n, 0, -1): f = factorial(i - 1) index = k // f k %= f permutation.append(elements.pop(index)) return permutation"},{"question":"You are given an integer array `heights` of size `n`, where each element represents the height of a building. The buildings are aligned from left to right and receive sunlight from the right end. A building casts a shadow on all buildings to its left that are of lesser or equal height. Return the number of buildings that receive sunlight.","solution":"def count_sunlit_buildings(heights): Returns the number of buildings that receive sunlight. Parameters: heights (list of int): List of building heights. Returns: int: Number of buildings that receive sunlight. if not heights: return 0 # Count the first building (from the left) count = 1 max_height = heights[0] for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given a sorted integer array `arr` that has been rotated at some pivot unknown to you beforehand. For example, `[0, 1, 2, 4, 5, 6, 7]` might become `[4, 5, 6, 7, 0, 1, 2]`. The array contains no duplicates. You are given a target value `t`. Write a function to search for `t` in `arr`. If `t` is found in the array, return its index. Otherwise, return -1. You must devise an algorithm with `O(log n)` runtime complexity.","solution":"def search_rotated_array(arr, t): Searches for a target value `t` in a sorted and rotated array `arr`. If found, returns the index of `t`, otherwise returns -1. if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == t: return mid # If the left half is sorted if arr[left] <= arr[mid]: if arr[left] <= t < arr[mid]: right = mid - 1 else: left = mid + 1 # If the right half is sorted else: if arr[mid] < t <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given a **circular array** of integers `nums` of length `n`. The first and last element of the array are considered adjacent. A circular subarray is a subsection of `nums` that may wrap around the end to the beginning. For example, if `nums = [5, -3, 5]`, a circular subarray can be `[5, -3, 5]`, starting at index `0` and ending at index `2`. Your task is to find the maximum possible sum of a non-empty subarray (which may be circular). Implement the function `int maxCircularSubarraySum(vector<int>& nums)` that takes in a vector of integers `nums` and returns the maximum sum of a circular subarray.","solution":"def max_circular_subarray_sum(nums): Returns the maximum sum of a non-empty circular subarray in nums. def kadane(nums): max_ending_here = max_so_far = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far n = len(nums) # Case 1: max subarray sum without wrapping max_kadane = kadane(nums) # Case 2: max subarray sum with wrapping total_sum = sum(nums) inverted_nums = [-num for num in nums] max_inverted_kadane = kadane(inverted_nums) max_wrap = total_sum + max_inverted_kadane # If all numbers are negative, max_wrap could be 0, which should be ignored if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to perform the following operation any number of times: select any two adjacent characters and remove them if they are the same. Your goal is to determine whether you can make the string empty using this operation. Return `true` if you can make the string empty, otherwise return `false`.","solution":"def can_be_made_empty(s): Determine if the string can be made empty by repeatedly removing two adjacent identical characters. :param s: string consisting of lowercase English letters :return: True if the string can be made empty, otherwise False stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the previous character because it matches the current one else: stack.append(char) # Add the current character if there\'s no match return len(stack) == 0"},{"question":"You are given an integer array `heights` representing the heights of buildings in a cityscape. The array is **0-indexed** and represents the skyline from left to right. A building `i` is considered **visible** if there is no other building taller than building `i` that appears before it from the left. Return _the number of visible buildings in the skyline_. # Example: ```python heights = [3, 7, 8, 3, 6, 1] # Output: 3 # Explanation: Buildings with heights 3, 7, and 8 are visible. ```","solution":"def count_visible_buildings(heights): Returns the number of visible buildings in the skyline. if not heights: return 0 visible_count = 0 max_height = -1 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"Given an array of integers `arr` and an integer `difference`, find the length of the longest subsequence in the array which is an arithmetic sequence such that the difference between consecutive elements is exactly `difference`. A subsequence is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Implement the function `int longestSubsequence(int[] arr, int difference)` that takes an array `arr` of integers and an integer `difference`, and returns the length of the longest arithmetic subsequence.","solution":"def longestSubsequence(arr, difference): Finds the length of the longest subsequence where the difference between consecutive elements is exactly `difference`. :param arr: List[int] - List of integers :param difference: int - The specific difference between consecutive elements :return: int - Length of the longest subsequence dp = {} max_length = 0 for num in arr: if num - difference in dp: dp[num] = dp[num - difference] + 1 else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"Given an array of integers `arr`, you are allowed to perform the following operation any number of times: Choose any two indices `i` and `j` (i ≠ j) and swap the elements at these indices. Your goal is to sort the array in non-decreasing order. Return the minimum number of swaps needed to sort the array.","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps needed to sort the array in non-decreasing order. Args: arr (list of int): The input array of integers. Returns: int: The minimum number of swaps needed. n = len(arr) arrpos = list(enumerate(arr)) arrpos.sort(key=lambda it: it[1]) # sort array by array value visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arrpos[i][0] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrpos[j][0] cycle_size += 1 if cycle_size > 1: swaps += (cycle_size - 1) return swaps"},{"question":"You are given a list of words `words`, where each word is a string consisting of lowercase letters. Create a function that groups the words that are **anagrams** of each other. Anagrams are words that contain the same characters with the same frequency, but potentially in a different order. The function should return a list of lists, where each list contains words that are anagrams of each other. For example, given the input list `[\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"tac\\", \\"dog\\", \\"god\\"]`, the function should return `[[\'bat\', \'tab\'], [\'cat\', \'act\', \'tac\'], [\'dog\', \'god\']]`. Note that the order of the lists and the order of words within each list do not matter.","solution":"from collections import defaultdict def group_anagrams(words): Groups words that are anagrams of each other. Parameters: words (List[str]): A list of words consisting of lowercase letters. Returns: List[List[str]]: A list of lists, where each list contains words that are anagrams of each other. # Dictionary where the key is the sorted tuple of the word and the value is a list of anagrams anagrams = defaultdict(list) for word in words: # Sort the word to form the key sorted_word = tuple(sorted(word)) anagrams[sorted_word].append(word) # Return only the list of lists of anagrams return list(anagrams.values())"},{"question":"Given an `n x n` chessboard, determine whether a queen can be placed in a way that it attacks the maximum number of unattacked cells. A queen attacks cells in its row, column, and the diagonals it occupies. Implement the `QueenAttack` class: * `QueenAttack(int n)` initializes a chessboard of size `n x n`. * `int[] bestPosition(int[][] blockedCells)` returns the coordinates `[row, col]` of the position where the queen should be placed to maximize its attack on unattacked cells. `blockedCells` is an array of coordinates where cells are considered as blocked and cannot be attacked. If there are multiple optimal positions, return any one of them. For example: * `QueenAttack(8)` initializes an 8x8 chessboard. * Calling `bestPosition(new int[][]{{0, 1}, {2, 2}, {3, 4}})` might return `[4, 4]` (assuming this position allows the queen to attack the maximum number of unattacked cells considering the blocked cells). You may assume: - The input size `n` is always greater than 0 and less than or equal to 100. - The blocked cells array will always contain valid cell coordinates within the chessboard\'s boundaries.","solution":"class QueenAttack: def __init__(self, n): self.n = n def bestPosition(self, blockedCells): blocked = set(tuple(cell) for cell in blockedCells) max_attack = -1 best_position = (0, 0) def count_attacks(row, col): count = 0 directions = [ (1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (-1, 1), (1, -1) ] for dr, dc in directions: r, c = row + dr, col + dc while 0 <= r < self.n and 0 <= c < self.n: if (r, c) in blocked: break count += 1 r += dr c += dc return count for row in range(self.n): for col in range(self.n): if (row, col) not in blocked: current_attack = count_attacks(row, col) if current_attack > max_attack: max_attack = current_attack best_position = (row, col) return best_position"},{"question":"You are given a `n`-ary tree (a tree in which a node can have at most `n` children), where each node contains an integer value. Implement a function `maxDepth` that computes the maximum depth of the tree. The depth of a n-ary tree is the length of the longest path from the root to a leaf node. The tree is defined with the class `Node` as follows: ``` class Node { int val; List<Node> children; Node(int val) { this.val = val; children = new ArrayList<Node>(); } } ``` Return _an integer representing the maximum depth of the tree_. Example: If you are given the root of the following tree: ``` 1 / | 2 3 4 /| 5 6 7 ``` The function should return `3` as the maximum depth.","solution":"from typing import List class Node: def __init__(self, val: int): self.val = val self.children = [] def maxDepth(root: \'Node\') -> int: Computes the maximum depth of the n-ary tree. if not root: return 0 if not root.children: return 1 return 1 + max(maxDepth(child) for child in root.children)"},{"question":"You are given a list of integers that represents the current stock prices on consecutive days. You may complete as many transactions as you want (i.e., buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). The given list of integers represents the prices of the stock over a period, and you need to maximize the profit. Write a function that takes a list of stock prices and returns the maximum profit you can achieve. For example, given prices = [7, 1, 5, 3, 6, 4], you should return 7 (buy on day 2 and sell on day 3, profit = 4-1=3, then buy on day 4 and sell on day 5, profit = 6-3=3, resulting in total profit = 3+3=6).","solution":"def max_profit(prices): This function calculates the maximum profit that can be achieved from given stock prices. You are allowed to complete as many transactions as you want (buy one and sell one share of the stock multiple times). Parameters: prices (List[int]): List of stock prices on consecutive days. Returns: int: Maximum profit achievable. n = len(prices) if n <= 1: return 0 max_profit = 0 for i in range(1, n): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"You are given a list of non-negative integers `nums`. Each integer represents the height of a candle. Every day, you can choose any subset of candles and reduce their heights by one unit. When the height of a candle reaches zero, it cannot be reduced any further and will be removed from the list. Your task is to determine the minimum number of days required to reduce all the candles to zero height. Write a function that takes the list `nums` and returns the minimum number of days needed to achieve the goal. Example: ```python def min_days_to_reduce_candles(nums): # your implementation ``` ```python # Example input nums = [4, 2, 3, 1] # Expected output 2 ```","solution":"def min_days_to_reduce_candles(nums): Returns the minimum number of days to reduce all candles to zero height. Each integer in the list represents the height of a candle. Every day, we can choose any subset of candles and reduce their heights by one unit. When the height of a candle reaches zero, it is removed from the list. :param nums: List of non-negative integers where each integer represents the height of a candle. :return: Minimum number of days needed to reduce all candles to zero height. # The minimum number of days needed is determined by the height of the tallest candle. return max(nums, default=0)"},{"question":"Given a string `s` and a string `t`, return the minimum window substring of `s` that contains all the characters in `t`. If there is no such substring, return an empty string `\\"\\"`. If there are multiple such substrings in `s` of the same minimum length, return the one which occurs first. For example: ```python s = \\"ADOBECODEBANC\\" t = \\"ABC\\" ``` Output: \\"BANC\\", as it is the smallest substring that contains \'A\', \'B\', and \'C\'.","solution":"from collections import Counter def min_window(s: str, t: str) -> str: if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1] : ans[2] + 1]"},{"question":"Given a string `s` that represents a sequence of words separated by spaces, write a function to return the length of the longest substring that contains only unique characters. Note that only letters (both uppercase and lowercase) and digits should be considered as part of words, and spaces should be treated as delimiters. The substring should be a contiguous sequence of non-space characters. If no such substring exists, return 0.","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring that contains only unique characters. max_len = 0 current_str = \\"\\" for ch in s: if ch == \' \': max_len = max(max_len, len(current_str)) current_str = \\"\\" else: if ch in current_str: while ch in current_str: current_str = current_str[1:] current_str += ch # Check the last word max_len = max(max_len, len(current_str)) return max_len"},{"question":"You are given two **0-indexed** integer arrays `nums1` and `nums2` of length `n` and a boolean variable `flag`. The `ith` element in `nums2` represents the weight of the `ith` element in `nums1`. Your task is to return the sum of the elements in `nums1` based on the value of `flag` as follows: - If `flag` is `true`, include an element from `nums1` in the sum only if its corresponding element in `nums2` is even. - If `flag` is `false`, include an element from `nums1` in the sum only if its corresponding element in `nums2` is odd. For example, given `nums1 = [3, 1, 5, 7]`, `nums2 = [4, 9, 2, 3]`, and `flag = true`, the output should be `8` because the elements at indices 0 and 2 in `nums2` are even, and their corresponding elements in `nums1` are `3` and `5`.","solution":"def weighted_sum(nums1, nums2, flag): Returns the sum of elements in nums1 based on the value of flag. If flag is True, include an element from nums1 if its corresponding element in nums2 is even. If flag is False, include an element from nums1 if its corresponding element in nums2 is odd. if flag: return sum(num1 for num1, num2 in zip(nums1, nums2) if num2 % 2 == 0) else: return sum(num1 for num1, num2 in zip(nums1, nums2) if num2 % 2 != 0)"},{"question":"Given an array of integers `arr` and an integer `x`, find a subarray of `arr` whose sum is exactly `x`. If such a subarray exists, return the starting and ending indexes of the subarray, otherwise return an empty array. The subarray should be continuous and 1-indexed. For example, for `arr = [1, 2, 3, 7, 5]` and `x = 12`, the subarray `[2, 4]` (indexes 2 to 4) sums up to 12.","solution":"def find_subarray_with_sum(arr, x): Find a subarray whose sum is exactly x. Return the starting and ending indexes of the subarray in 1-indexed format. current_sum = 0 start_index = 0 for end_index in range(len(arr)): current_sum += arr[end_index] while current_sum > x and start_index <= end_index: current_sum -= arr[start_index] start_index += 1 if current_sum == x: return [start_index + 1, end_index + 1] return []"},{"question":"Create a class `CustomSet` that implements a set-like data structure with the following methods: - `add(val)`: Adds `val` to the set. - `remove(val)`: Removes `val` from the set if it exists. - `contains(val)`: Checks if `val` is present in the set, returning `true` or `false`. - `union(otherSet)`: Returns a new `CustomSet` that contains all unique elements from both sets. - `intersection(otherSet)`: Returns a new `CustomSet` that contains only the elements present in both sets. - `difference(otherSet)`: Returns a new `CustomSet` that contains elements in the current set but not in `otherSet`. Implement the `CustomSet` class and provide an example of its usage.","solution":"class CustomSet: def __init__(self): self.elements = {} def add(self, val): self.elements[val] = True def remove(self, val): if val in self.elements: del self.elements[val] def contains(self, val): return val in self.elements def union(self, otherSet): result = CustomSet() result.elements = {**self.elements, **otherSet.elements} return result def intersection(self, otherSet): result = CustomSet() result.elements = {key: True for key in self.elements if key in otherSet.elements} return result def difference(self, otherSet): result = CustomSet() result.elements = {key: True for key in self.elements if key not in otherSet.elements} return result # Example usage custom_set1 = CustomSet() custom_set1.add(1) custom_set1.add(2) custom_set1.add(3) custom_set2 = CustomSet() custom_set2.add(3) custom_set2.add(4) custom_set2.add(5) union_set = custom_set1.union(custom_set2) intersection_set = custom_set1.intersection(custom_set2) difference_set = custom_set1.difference(custom_set2)"},{"question":"Write a function `findMaxFrequency` that takes an array of integers `nums` and returns an integer representing the maximum frequency of any element in the array. The function should also return a list of elements that have this maximum frequency. For example, given the array `nums = [1, 3, 2, 2, 3, 1, 1]`, your function should return the maximum frequency `3` and the list `[1]` since `1` appears 3 times, which is the highest frequency. In case there are multiple elements with the same highest frequency, return them in a list sorted in ascending order. For example, given the array `nums = [1, 2, 2, 3, 3]`, your function should return the maximum frequency `2` and the list `[2, 3]` since both `2` and `3` appear 2 times.","solution":"from collections import Counter def findMaxFrequency(nums): Returns a tuple containing the maximum frequency and a list of elements that have this maximum frequency. if not nums: return 0, [] # Count the frequency of each number in the list frequency = Counter(nums) max_freq = max(frequency.values()) # Extract elements with the maximum frequency max_freq_elements = [num for num in frequency if frequency[num] == max_freq] # Sort the elements with the maximum frequency max_freq_elements.sort() return max_freq, max_freq_elements"},{"question":"You are given an array `nums` of `n` integers, and an integer `m`. Your task is to divide the array into exactly `m` non-empty contiguous subarrays such that the largest sum among these subarrays is minimized. Return the minimized largest sum. A contiguous subarray is a subarray that contains consecutive elements from the original array.","solution":"def splitArray(nums, m): Split the array into exactly m non-empty contiguous subarrays such that the largest sum among these subarrays is minimized. Return the minimized largest sum. def can_split(large): current_sum = 0 count = 1 for num in nums: current_sum += num if current_sum > large: count += 1 current_sum = num if count > m: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"Given a string `s` and an array of integers `indices` of the same length, rearrange the characters in the string `s` such that the character at the `i`-th position moves to `indices[i]` in the resulting string. Return the newly rearranged string. You must solve the problem using O(n) time complexity, where n is the length of the string `s`.","solution":"def restore_string(s, indices): Rearranges the characters in the string s such that the character at the i-th position moves to indices[i] in the resulting string. Parameters: s (str): The input string. indices (List[int]): The list of indices to rearrange the string. Returns: str: The newly rearranged string. n = len(s) result = [\'\'] * n for i in range(n): result[indices[i]] = s[i] return \'\'.join(result)"},{"question":"You are developing an online multiplayer game. In the game, each player can create and join different guilds. A guild consists of multiple players, and each player can accumulate experience points (XP) which contribute to the guild\'s total XP. You need to design a class to manage the guild operations. The system should support adding new players, creating new guilds, adding players to guilds, and calculating the total XP for each guild. Implement the `GuildManager` class: * `GuildManager()` Initializes the object of the system. * `void addPlayer(int playerId)` Adds a new player with the given `playerId` to the system. * `void createGuild(int guildId)` Creates a new guild with the given `guildId`. * `boolean addPlayerToGuild(int playerId, int guildId)` Adds the player with `playerId` to the guild with `guildId`. Return `true` if the operation is successful, `false` otherwise. * `void addXPToPlayer(int playerId, int xp)` Adds the given `xp` points to the player with `playerId`. * `int getTotalXPGuild(int guildId)` Returns the total XP of all players in the guild with `guildId`. Ensure that each player can only belong to one guild at a time and handle edge cases such as adding a player or guild that already exists.","solution":"class GuildManager: def __init__(self): self.players = {} # playerId -> {xp: 0, guildId: None} self.guilds = {} # guildId -> [playerId1, playerId2, ...] def addPlayer(self, playerId): if playerId in self.players: raise ValueError(f\\"Player {playerId} already exists.\\") self.players[playerId] = {\'xp\': 0, \'guildId\': None} def createGuild(self, guildId): if guildId in self.guilds: raise ValueError(f\\"Guild {guildId} already exists.\\") self.guilds[guildId] = [] def addPlayerToGuild(self, playerId, guildId): if playerId not in self.players: raise ValueError(f\\"Player {playerId} does not exist.\\") if guildId not in self.guilds: raise ValueError(f\\"Guild {guildId} does not exist.\\") player_data = self.players[playerId] if player_data[\'guildId\'] is not None: return False # Player is already in a guild self.guilds[guildId].append(playerId) self.players[playerId][\'guildId\'] = guildId return True def addXPToPlayer(self, playerId, xp): if playerId not in self.players: raise ValueError(f\\"Player {playerId} does not exist.\\") self.players[playerId][\'xp\'] += xp def getTotalXPGuild(self, guildId): if guildId not in self.guilds: raise ValueError(f\\"Guild {guildId} does not exist.\\") total_xp = 0 for playerId in self.guilds[guildId]: total_xp += self.players[playerId][\'xp\'] return total_xp"},{"question":"Given an array of integers `nums` and an integer `k`, return the maximum sum of a subarray of length `k`. If there are multiple subarrays with the same maximum sum, return the first one. For example, given: ```python nums = [1, 4, 2, 10, 23, 3, 1, 0, 20] k = 4 ``` The subarray with the maximum sum is `[4, 2, 10, 23]` with a sum of `39`. Implement the function: ```python def max_sum_subarray(nums, k): # Your code here ``` **Function Signature**: `def max_sum_subarray(nums: List[int], k: int) -> List[int]:`","solution":"from typing import List def max_sum_subarray(nums: List[int], k: int) -> List[int]: if not nums or k <= 0 or k > len(nums): return [] max_sum = float(\'-inf\') current_sum = 0 max_subarray_start_index = 0 for i in range(k): current_sum += nums[i] max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum max_subarray_start_index = i - k + 1 return nums[max_subarray_start_index:max_subarray_start_index + k]"},{"question":"Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. Note that the nodes are considered in the order they appear in the list, and the indexing is based on 1-based indexing.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val=val self.next=next def oddEvenList(head): if not head: return head odd = head even = head.next evenHead = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenHead return head"},{"question":"Given an integer array `nums` sorted in **non-decreasing order**, and an integer `target`, return _all unique quadruplets_ `[nums[a], nums[b], nums[c], nums[d]]` such that: 1. `0 <= a, b, c, d < len(nums)` 2. `a, b, c, and d` are distinct. 3. `nums[a] + nums[b] + nums[c] + nums[d] == target` You may return the answer in any order. Implement the `Quadruplets` class: * `List<List<Integer>> findQuadruplets(int[] nums, int target)` which returns all unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` that sum up to `target`.","solution":"from typing import List class Quadruplets: @staticmethod def findQuadruplets(nums: List[int], target: int) -> List[List[int]]: nums.sort() quadruplets = set() n = len(nums) for i in range(n - 3): for j in range(i + 1, n - 2): k, l = j + 1, n - 1 while k < l: total = nums[i] + nums[j] + nums[k] + nums[l] if total == target: quadruplets.add((nums[i], nums[j], nums[k], nums[l])) k += 1 l -= 1 elif total < target: k += 1 else: l -= 1 return [list(q) for q in quadruplets]"},{"question":"Given an array of integers `nums` and a constant `k`, return an array where each element at index `i` is the product of all the elements in `nums` except `nums[i]`, modulo `k`. You must do it without using division and in O(n) time and space complexity.","solution":"def product_except_self_modulo(nums, k): Returns an array where each element at index i is the product of all the elements in nums except nums[i], modulo k. n = len(nums) if n == 0: return [] # Initialize the output array result = [1] * n # Calculate prefix product prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product = (prefix_product * nums[i]) % k # Calculate suffix product and final result suffix_product = 1 for i in range(n - 1, -1, -1): result[i] = (result[i] * suffix_product) % k suffix_product = (suffix_product * nums[i]) % k return result"},{"question":"You are given a **0-indexed** integer array `nums` of even length `n`. Initially, every element `nums[i]` is considered unpaired. You can create a **pair** of elements `nums[i]` and `nums[j]` where `0 <= i, j < n` and `i != j`. The **sum** of such a pair is defined as `sum(nums[i], nums[j]) = nums[i] + nums[j]`. For each of the possible `n / 2` pairs, select the pair in such a way that the **maximum** sum among all `n / 2` pairs is minimized. Return the minimized **maximum** sum of the pairs. For example, given `nums = [1, 2, 3, 4]`, if you pair `1` with `4` and `2` with `3`, the sums of these pairs are `5` and `5`, respectively. The maximum of these sums is `5`, which is the minimized maximum sum in this case.","solution":"def min_max_pair_sum(nums): Given a 0-indexed integer array nums of even length, return the minimized maximum sum of pairs. nums.sort() n = len(nums) max_sum = 0 for i in range(n // 2): max_sum = max(max_sum, nums[i] + nums[n - 1 - i]) return max_sum"},{"question":"Design a class `ComplexNumber` that represents a complex number and supports basic operations on complex numbers. The class should support the following operations: * `ComplexNumber(double real, double imaginary)`: Initializes a complex number with the given real and imaginary parts. * `ComplexNumber add(ComplexNumber other)`: Returns a new complex number that is the sum of the current complex number and the given `other` complex number. * `ComplexNumber subtract(ComplexNumber other)`: Returns a new complex number that is the difference of the current complex number and the given `other` complex number. * `ComplexNumber multiply(ComplexNumber other)`: Returns a new complex number that is the product of the current complex number and the given `other` complex number. For example, given complex numbers `c1 = ComplexNumber(1, 2)` and `c2 = ComplexNumber(3, 4)`: * `c1.add(c2)` should return a complex number with real part `4` and imaginary part `6`. * `c1.subtract(c2)` should return a complex number with real part `-2` and imaginary part `-2`. * `c1.multiply(c2)` should return a complex number with real part `-5` and imaginary part `10`.","solution":"class ComplexNumber: def __init__(self, real, imaginary): self.real = real self.imaginary = imaginary def add(self, other): return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary) def subtract(self, other): return ComplexNumber(self.real - other.real, self.imaginary - other.imaginary) def multiply(self, other): real_part = self.real * other.real - self.imaginary * other.imaginary imaginary_part = self.real * other.imaginary + self.imaginary * other.real return ComplexNumber(real_part, imaginary_part) def __eq__(self, other): return self.real == other.real and self.imaginary == other.imaginary def __repr__(self): return f\\"{self.real} + {self.imaginary}i\\""},{"question":"Given an array of integers `arr`, write a function that returns the length of the longest continuous subarray that is strictly increasing. A subarray is a contiguous part of an array. * For example, given the array `arr = [1, 3, 5, 4, 7]`, you should return `3` because the longest continuous subarray is `[1, 3, 5]` which has a length of `3`.","solution":"def longest_increasing_subarray_length(arr): Returns the length of the longest continuous subarray that is strictly increasing. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 return max(max_len, current_len)"},{"question":"An out-of-order delivery service has `n` packages each associated with a unique, sequentially numbered order from `1` to `n`. However, due to a mix-up, the packages are delivered in a jumbled order. You have been given an array `packages` where `packages[i]` represents the package that was delivered at the `i-th` position. Your task is to write a function to determine the minimum number of swaps required to sort this array in ascending order. # Example: Assume that the array `packages` is `[4, 3, 1, 2]`. The sorted array should be `[1, 2, 3, 4]`. One of the ways to sort the array can be: - Swap index `0` with index `2`: `[1, 3, 4, 2]` - Swap index `1` with index `3`: `[1, 2, 4, 3]` - Swap index `2` with index `3`: `[1, 2, 3, 4]` Thus, the minimum number of swaps required is `3`. Write a function: ```python def min_swaps(packages: List[int]) -> int: pass ``` **Input:** - `packages` - a list of `n` integers where `1 <= n <= 10^5` and all elements of `packages` are unique integers from `1` to `n`. **Output:** Return an integer representing the minimum number of swaps needed to sort the array. # Constraints: - The elements in the `packages` array are unique and its length is in the range from `1` to `100,000`. *Hint*: Consider how to determine positions in the array and what swaps directly affect the overall minimum needed.","solution":"from typing import List def min_swaps(packages: List[int]) -> int: # Create a list of tuples where each tuple is (value, original index) indexed_packages = [(value, idx) for idx, value in enumerate(packages)] # Sort the list by the values indexed_packages.sort(key=lambda x: x[0]) visited = [False] * len(packages) swaps = 0 for i in range(len(packages)): # If the element is already visited or it is already in the correct position if visited[i] or indexed_packages[i][1] == i: continue # Start of a new cycle cycle_size = 0 x = i while not visited[x]: visited[x] = True x = indexed_packages[x][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"Implement the function `findOverlap(intervals)` that takes a list of intervals, where each interval is a list of two integers `[start, end]` representing the start and end times of a job. The function should return the total amount of time during which at least two jobs are overlapping. If no jobs overlap, return 0. **Example:** ``` Input: intervals = [[1, 3], [2, 4], [5, 6]] Output: 1 ``` **Explanation:** The jobs [1, 3] and [2, 4] overlap from time 2 to 3, so the total overlap time is 1. The job [5, 6] does not overlap with any other job.","solution":"def findOverlap(intervals): Computes the total amount of time during which at least two jobs are overlapping. if not intervals: return 0 # Generate a list of events events = [] for start, end in intervals: events.append((start, 1)) # Job starts events.append((end, -1)) # Job ends # Sort events, first by time, then by type of event to ensure end before start if at same time events.sort(key=lambda x: (x[0], x[1])) # Iterate through events to account for overlaps current_jobs = 0 overlap_time = 0 previous_time = None for time, event in events: if current_jobs >= 2: # We are in an overlap period overlap_time += time - previous_time current_jobs += event previous_time = time return overlap_time"},{"question":"You are given two strings `word1` and `word2`. You want to form a new string by alternating the characters of the two given strings, starting with the first character of `word1`. If one string is longer than the other, append the additional characters to the end of the new string. Write a function that takes `word1` and `word2` as inputs and returns the new string formed by alternating the characters of `word1` and `word2`. For example, given `word1 = \\"abc\\"` and `word2 = \\"pqr\\"`, the new string would be `\\"apbqcr\\"`. If `word1 = \\"ab\\"` and `word2 = \\"pqrs\\"`, the new string would be `\\"apbqrs\\"`.","solution":"def merge_alternately(word1, word2): Returns a new string formed by alternating the characters of the input strings word1 and word2. If one string is longer than the other, appends the additional characters at the end. merged = [] i, j = 0, 0 while i < len(word1) and j < len(word2): merged.append(word1[i]) merged.append(word2[j]) i += 1 j += 1 merged.extend(word1[i:]) merged.extend(word2[j:]) return \'\'.join(merged)"},{"question":"Given an integer `target` and a list of positive integer denominations `coins`, return the minimum number of coins needed to make up the `target` amount. If it\'s not possible to make the `target` amount with the given coins, return `-1`. You may assume that you have an infinite number of each denomination.","solution":"def coin_change(coins, target): Returns the minimum number of coins needed to make up the target amount. If it is not possible to make the target amount with the given coins, return -1. # Initialize a list for dynamic programming # dp[i] will be storing the minimum number of coins required for amount i dp = [float(\'inf\')] * (target + 1) dp[0] = 0 # Base case: 0 coins are needed to make amount 0 # Iterate over each amount from 1 to target for i in range(1, target + 1): for coin in coins: if coin <= i: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"Given a string `inputString`, you are required to transform it into a \\"zigzag\\" pattern string and read it line by line. A \\"zigzag\\" pattern string is one that is written out in a zigzag on a given number of rows. You write the characters in a down-and-up zigzag pattern, where the first row goes down, starting from the left, until the bottom row is reached, and then moves up to the top row. This cycle repeats until the entire input string is written. For example, the string \\"PAYPALISHIRING\\" on 3 rows should be arranged as follows: ``` P A H N A P L S I I G Y I R ``` And you print out the zigzag string on these rows reading left-to-right and top-to-bottom, which would result in \\"PAHNAPLSIIGYIR\\". Write a function that accepts the string `inputString` and an integer `numRows`, and returns the zigzag pattern \\"read out\\" string. Note: - If `numRows` is 1, the zigzag pattern is just the original input string.","solution":"def convert(inputString, numRows): Convert the inputString into a zigzag pattern with the given number of rows and return the string read line by line. if numRows == 1 or numRows >= len(inputString): return inputString rows = [\'\'] * numRows current_row = 0 going_down = False for char in inputString: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 return \'\'.join(rows)"},{"question":"Your task is to implement the `MostCommonWord` class: - `MostCommonWord` class has a constructor that takes a string `paragraph` and a list of strings `banned`. - Implement a `mostCommonNonBannedWord` method that returns the most frequently occurring word in the given `paragraph` that is not included in the `banned` list. If there are multiple solutions, return any of them. - Words in the `paragraph` are case-insensitive, and the result should be returned in lowercase. - Punctuation should be ignored while processing the `paragraph`. Example: __Input:__ ```python comment = \\"Bob hit a ball, the hit BALL flew far after it was hit.\\" banned = [\\"hit\\"] ``` __Output:__ `\\"ball\\"`","solution":"import re from collections import Counter class MostCommonWord: def __init__(self, paragraph, banned): self.paragraph = paragraph self.banned = banned def mostCommonNonBannedWord(self): # Normalize the paragraph by converting to lowercase and removing punctuation filtered_paragraph = re.sub(r\'[^ws]\', \' \', self.paragraph).lower() # Split the filtered paragraph into words words = filtered_paragraph.split() # Create a count of each word, ignoring those that are banned word_counts = Counter(word for word in words if word not in self.banned) # Get the word with the highest count most_common_word = word_counts.most_common(1)[0][0] return most_common_word"},{"question":"You are given an integer array `nums` and an integer `target`. You need to build an expression out of `nums` by adding one of the binary operators `+` or `-` before each integer in `nums` and then concatenate them to form a valid mathematical expression. Return _the number of different expressions that you can build, which evaluates to_ `target`.","solution":"def find_target_sum_ways(nums, target): from collections import defaultdict # initialize a dictionary to keep track of all the possible sums with their frequencies at each step sums_count = defaultdict(int) sums_count[0] = 1 for num in nums: next_sums_count = defaultdict(int) for current_sum in sums_count: next_sums_count[current_sum + num] += sums_count[current_sum] next_sums_count[current_sum - num] += sums_count[current_sum] sums_count = next_sums_count return sums_count[target]"},{"question":"Given a 2D integer array `matrix`, return the transpose of `matrix`. The transpose of a matrix is obtained by flipping the matrix over its main diagonal, switching the matrix\'s row and column indices. For example, given the following matrix: ``` [ [1, 2, 3], [4, 5, 6], ] ``` The transpose of the matrix is: ``` [ [1, 4], [2, 5], [3, 6], ] ```","solution":"def transpose(matrix): Returns the transpose of the given 2D matrix. The transpose of a matrix is obtained by flipping the matrix over its main diagonal, switching the matrix\'s row and column indices. Parameters: - matrix: List[List[int]] : 2D List representing the matrix Returns: - List[List[int]] : Transposed 2D List return [list(row) for row in zip(*matrix)]"},{"question":"Given a list of strings `strs`, group the anagrams together and return the result in a list of lists. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Each element in the list of strings consists of lowercase English letters. Return _the grouped anagrams in any order_.","solution":"from collections import defaultdict def group_anagrams(strs): Groups anagrams from the input list of strings and returns them as a list of lists. grouped = defaultdict(list) for s in strs: # Sort the string and use it as a key key = \'\'.join(sorted(s)) grouped[key].append(s) return list(grouped.values())"},{"question":"Given two strings `s1` and `s2`, return _a new string formed by interleaving the characters of_ `s1` _and_ `s2` _. If one string is longer than the other, append the remaining characters of the longer string to the end of the interleaved string._","solution":"def interleave_strings(s1, s2): Returns a new string formed by interleaving the characters of s1 and s2. If one string is longer than the other, append the remaining characters of the longer string to the end of the interleaved string. interleaved = [] min_length = min(len(s1), len(s2)) for i in range(min_length): interleaved.append(s1[i]) interleaved.append(s2[i]) if len(s1) > len(s2): interleaved.append(s1[min_length:]) elif len(s2) > len(s1): interleaved.append(s2[min_length:]) return \'\'.join(interleaved)"},{"question":"Given an array of integers `nums`, you must answer a series of queries where each query consists of a single integer `x`. For each query, determine the number of integers in the array that are less than or equal to `x`. Return an array of the results for all queries in the order they are given. For example, if the array `nums` is [1, 2, 3, 3, 5] and the queries are [3, 5, 7], the function should return [4, 5, 5] because: - There are 4 numbers less than or equal to 3 - There are 5 numbers less than or equal to 5 - There are 5 numbers less than or equal to 7","solution":"def count_less_or_equal(nums, queries): Given an array of integers nums and a list of queries, each consisting of a single integer x, return an array of the number of integers in the array that are less than or equal to x for each query. Args: nums: List[int] - List of integers. queries: List[int] - List of queries. Returns: List[int] - List of results for each query. nums.sort() results = [] for query in queries: count = 0 for num in nums: if num <= query: count += 1 else: break results.append(count) return results"},{"question":"You are given a **0-indexed** list of integers `nums` and an integer `threshold`. You need to split the list `nums` into one or more continuous subarrays such that the sum of each subarray does not exceed `threshold`. Return _the minimum number of subarrays_ needed to achieve this.","solution":"def min_subarrays(nums, threshold): Returns the minimum number of subarrays needed such that the sum of each subarray does not exceed threshold. current_sum = 0 count = 1 for num in nums: if current_sum + num > threshold: count += 1 current_sum = num else: current_sum += num return count"},{"question":"You are given an array of strings `words` and a string `targetWord`. Each string in `words` and the `targetWord` consist of lowercase English letters. You can change at most `k` characters in each string from the `words` array to match the `targetWord`. Return _the maximum number of strings from the `words` array that can be transformed to match the `targetWord` by changing at most `k` characters in each string_.","solution":"def max_transformable_strings(words, targetWord, k): Returns the maximum number of strings from the words array that can be transformed to match the targetWord by changing at most k characters in each string. def can_transform(word, target, k): changes_needed = sum(1 for wc, tc in zip(word, target) if wc != tc) return changes_needed <= k count = 0 for word in words: if can_transform(word, targetWord, k): count += 1 return count"},{"question":"You are given two arrays of positive integers `arr1` and `arr2`. An integer `x` is a **special integer** if it is present in both `arr1` and `arr2`. Return the sum of all **special integers**. If there are no **special integers**, return `-1`.","solution":"def sum_special_integers(arr1, arr2): Returns the sum of all special integers that are present in both arr1 and arr2. If there are no special integers, return -1. special_integers = set(arr1) & set(arr2) if not special_integers: return -1 return sum(special_integers)"},{"question":"You are given a list of meetings represented by intervals where meetings[i] = [start_i, end_i]. Each meeting consists of a start time and an end time. Your task is to find the minimum number of meeting rooms required to schedule all the meetings without any overlap. Return the minimum number of meeting rooms required.","solution":"def min_meeting_rooms(meetings): Returns the minimum number of meeting rooms required to hold all the meetings without any overlaps. Args: meetings (List[List[int]]): A list of meetings where each meeting is represented as [start, end]. Returns: int: The minimum number of meeting rooms required. if not meetings: return 0 start_times = sorted(meeting[0] for meeting in meetings) end_times = sorted(meeting[1] for meeting in meetings) start_pointer = end_pointer = 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(meetings): if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"You are given an integer array `nums` of length `n` and an integer `x`. Your task is to determine if there exists a subarray of length exactly `x` in `nums` such that the sum of its elements is equal to a given target value `t`. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def subarray_sum_exists(nums, x, t): Determines if there exists a subarray of length exactly x in nums such that the sum of its elements is t. Parameters: nums (list of int): The list of integers. x (int): The length of the subarray. t (int): The target sum. Returns: bool: True if such a subarray exists, False otherwise. n = len(nums) if n < x: return False # Calculate the sum of the first subarray of length x current_sum = sum(nums[:x]) if current_sum == t: return True # Use a sliding window to calculate the sum of remaining subarrays of length x for i in range(x, n): current_sum += nums[i] - nums[i - x] if current_sum == t: return True return False"},{"question":"You are given an array of `n` integers `arr` where each element represents the profit or loss of a stock on that day. You need to find the maximum profit you can achieve if you are allowed to complete at most one \\"buy and sell\\" transaction. In other words, you need to find the pair of days `(i, j)` such that `0 <= i < j < n` and the difference `arr[j] - arr[i]` is maximized. Return the maximum profit you can achieve from such a transaction. If no profit is possible, return 0.","solution":"def max_profit(arr): Function to calculate the maximum profit possible with at most one buy and sell transaction. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Given a non-negative integer `n`, convert the integer to its corresponding column title as it would appear in an Excel spreadsheet. For example: - `1` -> `\\"A\\"` - `27` -> `\\"AA\\"` - `701` -> `\\"ZY\\"` Return _the corresponding column title as a string_.","solution":"def convertToTitle(n): Given a non-negative integer n, convert it to its corresponding column title as it would appear in an Excel spreadsheet. result = \\"\\" while n > 0: n -= 1 # Adjusting n to be zero-indexed result = chr(n % 26 + ord(\'A\')) + result n //= 26 return result"},{"question":"You are given an **n x n** integer matrix `matrix`. You need to perform a series of operations on the matrix determined by the following queries: 1. **Rotate** the entire matrix clockwise by 90 degrees. 2. **Reflect** the matrix along its main diagonal. Implement a class `MatrixOperations`: * `MatrixOperations(int[][] matrix)`: Initializes the object with the integer matrix `matrix`. * `void rotate()`: Rotates the entire matrix clockwise by 90 degrees. * `void reflect()`: Reflects the matrix along its main diagonal. * `int[][] getMatrix()`: Returns the current state of the matrix after all operations have been performed. Ensure that your implementation performs each operation efficiently.","solution":"class MatrixOperations: def __init__(self, matrix): Initializes the object with the integer matrix. self.matrix = matrix def rotate(self): Rotates the entire matrix clockwise by 90 degrees. n = len(self.matrix) # First, reverse the rows of the matrix. self.matrix.reverse() # Then, swap the symmetry along the diagonal. for i in range(n): for j in range(i + 1, n): self.matrix[i][j], self.matrix[j][i] = self.matrix[j][i], self.matrix[i][j] def reflect(self): Reflects the matrix along its main diagonal. n = len(self.matrix) for i in range(n): for j in range(i): self.matrix[i][j], self.matrix[j][i] = self.matrix[j][i], self.matrix[i][j] def getMatrix(self): Returns the current state of the matrix after all operations have been performed. return self.matrix"},{"question":"Given an integer array `nums`, return _the maximum length of a **subarray** that contains at most two different integers_. Each subarray should contain at least one occurrence of those two integers, and the elements of the subarray should be the same as a continuous segment in the original array. For example, for the input array `[1, 2, 1, 2, 3]`, one possible subarray is `[1, 2, 1, 2]`.","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest subarray containing at most two distinct integers. from collections import defaultdict n = len(nums) if n == 0: return 0 left = 0 max_len = 0 count = defaultdict(int) for right in range(n): count[nums[right]] += 1 while len(count) > 2: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an array of integers `height` representing the height of a vertical line at each index, compute the maximum area of water that can be held between two lines. Two lines form a container such that the container cannot tilt, and the area of water it holds is calculated by the shorter line\'s height multiplied by the distance between the lines. Implement the function `maxArea(height: List[int]) -> int` that returns this maximum area. For example, given `height = [1,8,6,2,5,4,8,3,7]`, the output should be `49`. # Constraints: - `n == height.length` - `2 <= n <= 10^5` - `0 <= height[i] <= 10^4`","solution":"from typing import List def maxArea(height: List[int]) -> int: Computes the maximum area of water that can be held between two lines represented by height array. left, right = 0, len(height) - 1 max_area = 0 while left < right: h = min(height[left], height[right]) w = right - left max_area = max(max_area, h * w) if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a binary tree in which each node contains an integer value. Design an algorithm to convert the binary tree into a doubly linked list in place. The doubly linked list should follow the in-order traversal sequence of the binary tree. Implement the function `Node treeToDoublyList(Node root)`, where `Node` is a class representing a tree node that contains an integer value and two pointers `left` and `right` pointing to its left and right child nodes, respectively. The function should return the head of the doubly linked list.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def treeToDoublyList(root): Converts a binary tree to a doubly linked list in-place following the in-order traversal. Args: root (Node): The root of the binary tree. Returns: Node: The head of the created doubly linked list. if not root: return None def convert(node): nonlocal last, first if node: # In-order traversal: left convert(node.left) # Link the previous node (last) with the current node (node) if last: last.right = node node.left = last else: # We found the leftmost node which is now head of the list first = node last = node # In-order traversal: right convert(node.right) first, last = None, None convert(root) # Close the doubly linked list to make it circular if last and first: last.right = first first.left = last return first"},{"question":"Given an integer `n`, return the number of strings of length `n` that are composed solely of the characters \'0\' and \'1\' and do not contain consecutive \'1\'s. Implement a function `countStrings(n)` that returns this count. For example: - `countStrings(3)` should return `5`, as the valid strings are [\\"000\\", \\"001\\", \\"010\\", \\"100\\", \\"101\\"]. - `countStrings(4)` should return `8`, as the valid strings are [\\"0000\\", \\"0001\\", \\"0010\\", \\"0100\\", \\"0101\\", \\"1000\\", \\"1001\\", \\"1010\\"].","solution":"def countStrings(n): Returns the number of strings of length n that are composed solely of the characters \'0\' and \'1\' and do not contain consecutive \'1\'s. if n == 0: return 1 if n == 1: return 2 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 2 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"Write a function to convert a given string `s` to an integer according to the following rules: - The string can contain optional white spaces at the beginning and end. - The first non-space character may be a `+` or `-` indicating the sign of the number. - The subsequent characters are digits that form the integer. - The function should handle cases where the number exceeds the 32-bit signed integer range, clamping the number to the closest boundary value in such cases. - If no valid conversion can be performed, return `0`. The function must follow these conventions strictly to ensure accurate integer conversion from the string.","solution":"def my_atoi(s: str) -> int: Convert a given string to a 32-bit signed integer. If conversion is not possible, return 0. s = s.strip() # Remove leading and trailing whitespaces if not s: return 0 i = 0 sign = 1 result = 0 INT_MAX = 2**31 - 1 INT_MIN = -2**31 # Check the sign if s[i] == \'+\' or s[i] == \'-\': sign = -1 if s[i] == \'-\' else 1 i += 1 # Convert digits to an integer while i < len(s) and s[i].isdigit(): result = result * 10 + int(s[i]) i += 1 result *= sign # Clamp the result within the 32-bit signed integer range if result < INT_MIN: return INT_MIN if result > INT_MAX: return INT_MAX return result"},{"question":"A company has a scheduling system that needs to allocate meeting rooms to various requested meetings. You are given two arrays, `startTimes` and `endTimes`, both of size `n`, where `startTimes[i]` represents the start time of the `i`-th meeting and `endTimes[i]` represents the end time of the `i`-th meeting. The scheduling system can accommodate multiple meetings in the same room if their time intervals do not overlap. Your task is to determine the minimum number of meeting rooms required to accommodate all the meetings. The start and end times are given in a 24-hour format without seconds (e.g., 9 for 9:00 AM and 15 for 3:00 PM). Return the minimum number of meeting rooms required.","solution":"def minMeetingRooms(startTimes, endTimes): Determine the minimum number of meeting rooms required to accommodate all the meetings. Parameters: startTimes (list): List of start times of the meetings. endTimes (list): List of end times of the meetings. Returns: int: Minimum number of meeting rooms required. if not startTimes or not endTimes or len(startTimes) != len(endTimes): return 0 # Sort the start and end times startTimes.sort() endTimes.sort() start_pointer = 0 end_pointer = 0 rooms = 0 max_rooms = 0 while start_pointer < len(startTimes): if startTimes[start_pointer] < endTimes[end_pointer]: rooms += 1 start_pointer += 1 else: rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, rooms) return max_rooms"},{"question":"You are given an array of integers `arr` and an integer `d`. A **chunk** is a non-empty subarray of `arr` such that the difference between the maximum and minimum elements in the chunk is less than or equal to `d`. Return _the length of the longest chunk in_ `arr`.","solution":"def longest_chunk_length(arr, d): Returns the length of the longest chunk in the array such that the difference between the maximum and minimum elements in the chunk is less than or equal to d. n = len(arr) max_length = 0 left = 0 from collections import deque max_deque = deque() min_deque = deque() for right in range(n): while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > d: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `heights` representing the height of trees in a forest. An archer can shoot arrows in a straight horizontal line, and every arrow can eliminate a tree with a height equal to or less than the height at which it is shot. Each arrow can only be shot once. Write a function to determine the minimum number of arrows required to eliminate all trees in the forest. For example: * `heights = [4, 3, 5, 1, 2]`: One way to eliminate all trees is to shoot arrows at heights `1`, `2`, `3`, `4`, and `5` respectively. Thus, it requires 5 arrows. * `heights = [3, 4, 4, 5, 5, 6]`: One way to eliminate all trees is to shoot arrows at heights `3`, `4`, `5`, and `6`. Thus, it requires 4 arrows.","solution":"def minimum_arrows(heights): Returns the minimum number of arrows required to eliminate all trees. Parameters: heights (list): A list of integers representing the height of trees. Returns: int: The minimum number of arrows required. return len(set(heights))"},{"question":"Given an array of integers `arr`, you are to implement a function `findLongestConsecutiveSequence`. The function should return the length of the longest consecutive elements sequence in the array. A consecutive sequence is defined as a sequence where each number is followed directly by its successor (i.e., n, n+1, n+2, ...). Your solution should run in O(n) time complexity. For example, if the input array is `[100, 4, 200, 1, 3, 2]`, the longest consecutive sequence is `[1, 2, 3, 4]`, and thus the function should return 4.","solution":"def findLongestConsecutiveSequence(arr): Returns the length of the longest consecutive elements sequence in the array. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: # check if the current number is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a **directed graph** with `n` nodes labeled from `0` to `n-1` and are provided with a **2D array** `edges`, where `edges[i] = [u, v]` represents a directed edge from node `u` to node `v`. You need to determine if the graph contains a **cycle**. Specifically, return `true` if there is a cycle in the graph, or `false` otherwise. A **cycle** is a path in the graph that starts and ends at the same node, and includes at least one edge. The graph is given as a list of its edges. Determine if any such cycle exists in the graph.","solution":"def has_cycle(n, edges): Determines if the directed graph contains a cycle. Parameters: n (int): Number of nodes in the graph. edges (List[List[int]]): A list of directed edges, where each edge is represented as [u, v]. Returns: bool: True if there is a cycle in the graph, False otherwise. from collections import defaultdict, deque # Build the adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Track visited nodes and recursion stack visited = [False] * n rec_stack = [False] * n def dfs(node): if rec_stack[node]: return True if visited[node]: return False visited[node] = True rec_stack[node] = True for neighbor in graph[node]: if dfs(neighbor): return True rec_stack[node] = False return False for node in range(n): if dfs(node): return True return False"},{"question":"You are given an array of `integers` representing the amount of time each task costs. You have a limited time `totalTime`. You need to schedule the tasks in such a way that the total time spent on these tasks is less than or equal to `totalTime`. Each task is non-divisible, meaning you must either take the whole task or not take it at all. Return the maximum number of tasks you can complete without exceeding the `totalTime`. Note: Each task can only be completed once.","solution":"def max_tasks(tasks, totalTime): Given a list of task times and a total time, returns the maximum number of tasks that can be completed without exceeding the total time. :param tasks: List of integers, where each integer represents the cost in time of a task :param totalTime: Integer, the maximum amount of time that can be spent on tasks :return: Integer, the maximum number of tasks that can be completed without exceeding totalTime tasks.sort() currentTime = 0 count = 0 for task in tasks: if currentTime + task <= totalTime: currentTime += task count += 1 else: break return count"},{"question":"Given a list of non-negative integers `nums`, you are tasked with rearranging the elements of the list into a _wave_ sequence. In a wave sequence, the elements are arranged in such a way that for any two consecutive integers `a` and `b`, either `a >= b` or `a <= b` must be true consistently throughout the list. Return the wave sequence of the list `nums` that is lexicographically smallest.","solution":"def wave_sequence(nums): Rearranges the elements of the list into a wave sequence. A wave sequence is one such that for any two consecutive integers a and b, either a >= b or a <= b. The sequence is the lexicographically smallest possible wave sequence. :param nums: List of non-negative integers :return: List of integers in wave sequence order # Sort `nums` to get the lexicographically smallest permutation nums.sort() # Swap adjacent elements to create the wave pattern for i in range(0, len(nums) - 1, 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"question":"You are given a 2D grid of size `n x m` where each cell represents a piece of land (`1`) or water (`0`). An island is a group of `1`\'s (land) connected 4-directionally (horizontal or vertical). You can perform at most one conversion, changing a `0` (water) into a `1` (land) to form a larger island. Return _the size of the largest island_ you can get by applying this conversion. If there is no way to form a larger island, return the size of the largest existing island without any conversion.","solution":"def largestIsland(grid): def dfs(x, y, index): stack, area = [(x, y)], 0 while stack: i, j = stack.pop() if 0 <= i < n and 0 <= j < m and grid[i][j] == 1: grid[i][j] = index area += 1 for nx, ny in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: stack.append((nx, ny)) return area n, m = len(grid), len(grid[0]) index = 2 area = {} # Mark each island with different index and calculate their area. for i in range(n): for j in range(m): if grid[i][j] == 1: area[index] = dfs(i, j, index) index += 1 if not area: return 1 # If no island exists, any conversion will form an island of size 1. max_area = max(area.values()) # Try converting each 0 to 1 and check the maximum island size we can get. for i in range(n): for j in range(m): if grid[i][j] == 0: seen = set() current_area = 1 # Convert 0 to 1 for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] > 1: index = grid[ni][nj] if index not in seen: current_area += area[index] seen.add(index) max_area = max(max_area, current_area) return max_area"},{"question":"You are given a linked list where each node contains an integer value. Implement a function `reorderList(Node head)` that reorders the list as follows: - The first element should be followed by the last element. - The second element should be followed by the second last element. - Continue this pattern until all elements have been rearranged. Modify the linked list in-place without using extra memory. The nodes in the final reordered list should still contain the same values, they should just be rearranged according to the specified pattern. For example, given the linked list `1 -> 2 -> 3 -> 4`, the reordered list will be `1 -> 4 -> 2 -> 3`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: Reorder the list as per the given pattern. if not head or not head.next: return # Step 1: Find the middle of the list slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the list prev = None curr = slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Step 3: Merge the two halves first, second = head, prev while second.next: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first, second = tmp1, tmp2"},{"question":"Given a 2D grid of integers `grid`, consider all possible subgrids that are squares (i.e., N x N). For each subgrid, calculate the sum of its elements. Return the maximum sum obtained from any possible subgrid in `grid`. If there are multiple subgrids with the same maximum sum, any one of them can be returned.","solution":"def max_sum_subgrid(grid): Returns the maximum sum obtained from any possible N x N subgrid in the given 2D grid. rows = len(grid) cols = len(grid[0]) def subgrid_sum(x, y, size): return sum(grid[i][j] for i in range(x, x+size) for j in range(y, y+size)) max_sum = float(\'-inf\') for size in range(1, min(rows, cols) + 1): for i in range(rows - size + 1): for j in range(cols - size + 1): current_sum = subgrid_sum(i, j, size) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given a string `s` consisting of lowercase English letters, you need to **partition** the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done with the minimum possible cuts. Return _a list of integers representing the length of each part after partitioning_.","solution":"def partition_labels(s): Partitions the given string such that each letter appears in at most one part. Returns a list of integers representing the length of each part. Parameters: s (str): The input string consisting of lowercase English letters. Returns: List[int]: The list of lengths of each partitioned part. # Record the last occurrence of each character last_occurrence = {char: idx for idx, char in enumerate(s)} result = [] start, end = 0, 0 for index, char in enumerate(s): # Update the end boundary of the current part end = max(end, last_occurrence[char]) # If the current index reaches the end boundary if index == end: # Append the length of the current part result.append(end - start + 1) # Move the start to the next index after the current part start = index + 1 return result"},{"question":"Given a binary tree represented in an array-form, where for each node at index `i`, the left child is at index `2*i + 1` and the right child is at index `2*i + 2`, return the sum of values of all nodes that are at the last level of the binary tree. For example, given the array representation `[1, 2, 3, 4, 5, 6, 7]`, the sum of values of nodes at the last level (which are `4, 5, 6, 7`) is `22`.","solution":"def sum_last_level_nodes(tree): if not tree: return 0 level = 0 while (1 << level) - 1 < len(tree): level += 1 last_level_start = (1 << (level - 1)) - 1 return sum(tree[last_level_start:])"},{"question":"You are given a string `s` representing a list of words separated by spaces, and an integer `k`. Your task is to split the string `s` into `k` non-empty substrings such that no two substrings are the same and each substring contains at least one word. Return _a list of k substrings or an empty list if such a split is not possible_. The words in the substrings should appear in the same order as in the original string `s`.","solution":"def split_string_into_k_substrings(s, k): Splits a string into k non-empty substrings such that no two substrings are the same. Each substring contains at least one word, and words maintain their original order. Args: s (str): The input string containing words separated by spaces. k (int): The number of substrings to split into. Returns: list: A list of k substrings or an empty list if such a split is not possible. words = s.split() # If there are not enough words to create k non-empty substrings if len(words) < k: return [] result = [\'\'] * k index = 0 # Distribute words in a round-robin fashion for word in words: result[index] += word + \' \' index = (index + 1) % k # Remove trailing spaces result = [substring.strip() for substring in result] # Ensure all substrings are unique if len(set(result)) != k: return [] return result"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `target`. Your task is to find if there exists a contiguous subarray within `nums` that sums exactly to `target`. Return _**true** if such subarray exists, otherwise return **false**_.","solution":"def subarray_sum_exists(nums, target): Returns True if there exists a contiguous subarray within nums that sums exactly to target, otherwise returns False. current_sum = 0 seen_sums = {0} # Initialize with 0 to handle cases where subarray starts from index 0 for num in nums: current_sum += num if (current_sum - target) in seen_sums: return True seen_sums.add(current_sum) return False"},{"question":"You are given a string `paragraph` containing multiple sentences. Each sentence is separated by a period (\'.\'). Develop a function that finds the sentence with the most number of words. If multiple sentences have the same number of words, return the first one from the `paragraph`. Consider a word to be any sequence of characters that does not contain a space or a period. The function should return the sentence as a string.","solution":"def sentence_with_most_words(paragraph): Returns the sentence with the most number of words from the given paragraph. If multiple sentences have the same number of words, returns the first one. :param paragraph: A string containing multiple sentences separated by periods. :return: The sentence with the most number of words. sentences = paragraph.split(\'.\') max_word_count = 0 sentence_with_max_words = \\"\\" for sentence in sentences: words = sentence.strip().split() word_count = len(words) if word_count > max_word_count: max_word_count = word_count sentence_with_max_words = sentence.strip() return sentence_with_max_words"},{"question":"You are given a list of non-negative integers representing the heights of the towers in a row. Each tower can be reduced in height by removing blocks, but blocks cannot be added to any tower. You aim to make all towers in the row have the same height, where the target height is the maximum possible height that all towers can be reduced to. Return the maximum possible height to which all the towers can be reduced. For example, given the list `[5, 7, 3, 9]`, the maximum possible height all towers can be reduced to is `5`, because any height larger than `5` would not be achievable by reducing all towers.","solution":"def max_reduced_height(towers): Given a list of non-negative integers representing tower heights, returns the maximum possible height to which all towers can be reduced. if not towers: return 0 return min(towers)"},{"question":"You are given a list of `n` non-negative integers representing the heights of the adjacent buildings. The width of each building is `1`. It has been raining heavily, so water has accumulated between these buildings. Calculate the total amount of water that has accumulated between the buildings after the rainfall. Return _the total trapped water_.","solution":"def trap(height): Calculate the total amount of water that has accumulated between the buildings after the rainfall. :param height: List[int] - List of non-negative integers representing the heights of the buildings. :return: int - The total trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given a string `s` consisting of lowercase letters, return the length of the longest substring without repeating characters. A substring is a contiguous sequence of characters within the string. Your solution should be efficient with a linear time complexity. For instance, if `s = \\"abcabcbb\\"`, the longest substring without repeating characters is `\\"abc\\"`, with a length of `3`. If `s = \\"bbbbb\\"`, the longest substring without repeating characters is `\\"b\\"`, with a length of `1`.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a 2D byte array representing a grayscale image with values ranging from 0 to 255. Implement a function to perform edge detection on the image using the Sobel operator. The Sobel operator is used in image processing and computer vision, particularly within edge detection algorithms. It creates an image that emphasizes edges by calculating gradients of the image intensity. The Sobel operator uses two kernels: [ G_x = begin{bmatrix} -1 & 0 & 1 -2 & 0 & 2 -1 & 0 & 1 end{bmatrix} ] [ G_y = begin{bmatrix} 1 & 2 & 1 0 & 0 & 0 -1 & -2 & -1 end{bmatrix} ] Your task is to compute the gradient magnitude at each pixel and return a new 2D byte array representing the resultant edge-detected image. The gradient magnitude is computed as: [ G = sqrt{G_x^2 + G_y^2} ] Normalize the resultant gradient image to have values ranging from 0 to 255. The input 2D byte array will have dimensions at least 3x3. Ensure to handle edge pixels appropriately (e.g., by zero padding or replication).","solution":"import numpy as np from scipy.ndimage import convolve def sobel_edge_detection(image): Perform edge detection using the Sobel operator on a 2D byte array representing a grayscale image. Parameters: image (np.ndarray): 2D array of values ranging from 0 to 255 representing a grayscale image. Returns: np.ndarray: 2D array representing the edge-detected image. # Sobel kernels G_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) G_y = np.array([[ 1, 2, 1], [ 0, 0, 0], [-1, -2, -1]]) # Convolution using Sobel operator kernels grad_x = convolve(image.astype(np.float64), G_x, mode=\'nearest\') grad_y = convolve(image.astype(np.float64), G_y, mode=\'nearest\') # Gradient magnitude gradient_magnitude = np.sqrt(grad_x**2 + grad_y**2) # Normalize the result to be within 0-255 gradient_magnitude = (gradient_magnitude / gradient_magnitude.max()) * 255 return gradient_magnitude.astype(np.uint8)"},{"question":"Given two strings `s` and `t`, _determine if they are anagrams of each other_. Two strings are anagrams if they contain the same characters with the same frequencies. You need to return `true` if `s` and `t` are anagrams, and `false` otherwise. The function should be case-insensitive and ignore spaces and punctuation. For example: - `s = \\"anagram\\", t = \\"nagaram\\"` would return `true`. - `s = \\"rat\\", t = \\"car\\"` would return `false`.","solution":"import re from collections import Counter def are_anagrams(s, t): Determine if two strings s and t are anagrams of each other. Case-insensitive and ignores spaces and punctuation. # Remove non-alphabetic characters and convert to lowercase clean_s = re.sub(r\'[^a-zA-Z]\', \'\', s).lower() clean_t = re.sub(r\'[^a-zA-Z]\', \'\', t).lower() # Return true if the character counts match return Counter(clean_s) == Counter(clean_t)"},{"question":"You are given two integers `source` and `target`. You are allowed to perform the following operations on the integer `source`: 1. Double the value of `source`. 2. Subtract one from `source`. Your goal is to transform the integer `source` to `target` using the minimum number of operations. Return the minimum number of operations needed to transform `source` to `target`. If it is not possible to perform the transformation, return -1.","solution":"def min_operations(source, target): Return the minimum number of operations needed to transform \'source\' to \'target\' by either doubling the value of \'source\' or subtracting one from \'source\'. if source > target: return source - target operations = 0 while target > source: if target % 2 == 0: target //= 2 else: target += 1 operations += 1 return operations + (source - target)"},{"question":"Given an integer array `arr`, sort the array such that all multiples of 5 come first, followed by the rest of the numbers in increasing order. Return the sorted array.","solution":"def custom_sort(arr): Sort the array such that all multiples of 5 come first, followed by the rest of the numbers in increasing order. Parameters: arr (list): List of integers. Returns: list: Sorted list according to the rule. # Separate multiples of 5 and the rest multiples_of_5 = [x for x in arr if x % 5 == 0] others = [x for x in arr if x % 5 != 0] # Sort the remaining numbers others_sorted = sorted(others) # Combine the two lists return multiples_of_5 + others_sorted"},{"question":"We are given a string `s` consisting of only the characters \'(\' and \')\'. We need to transform the string into a **valid** string by inserting the minimum number of parentheses. A string is considered valid if it is empty, contains only balanced parentheses, or can be written as `A` + `B` where `A` and `B` are valid strings. Return the minimum number of parentheses needed to be inserted into the string to make it valid.","solution":"def min_add_to_make_valid(s): Return the minimum number of parentheses needed to be inserted to make the string s valid. left_needed = 0 right_needed = 0 for char in s: if char == \'(\': right_needed += 1 elif char == \')\': if right_needed > 0: right_needed -= 1 else: left_needed += 1 return left_needed + right_needed"},{"question":"You are given a string `s` consisting of lowercase English letters. In one operation, you can remove any substring of the string that is a palindrome. A palindrome is a string that reads the same backward as forward. Return _the **minimum** number of operations requried to make the string empty._","solution":"def minimum_operations_to_empty(s): Returns the minimum number of operations required to make the string empty by removing palindromic substrings. # A single character is always a palindrome. if s == s[::-1]: return 1 return 2"},{"question":"You are given an m x n grid `grid` consisting of positive integers. Perform the following steps: 1. Find the **minimum path sum** from the top-left corner to the bottom-right corner, where you can only move **right** or **down** at any point in time. 2. After calculating the minimum path sum, if it exceeds a given threshold `T`, return `-1`. 3. Otherwise, return the calculated minimum path sum. Your task is to implement a function that takes the grid and the threshold `T` as inputs and returns the appropriate result based on the conditions described. Note that the grid always contains at least one cell.","solution":"def minPathSum(grid, T): Finds the minimum path sum from top-left to bottom-right of the grid and compares it with the threshold T. m, n = len(grid), len(grid[0]) # Create a dp array to store the minimum path sum to each cell dp = [[0] * n for _ in range(m)] # Fill the dp array with the minimum path sums dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] min_sum = dp[m-1][n-1] if min_sum > T: return -1 return min_sum"},{"question":"You are given a string `s` containing only lowercase English letters. You can perform the following operation on `s` any number of times: - Choose two adjacent characters and replace them with a single new character that is the maximum of the two (according to the alphabetical order). For example, if the string is `abc`, you can replace `a` and `b` with `b`, resulting in `bc`. However, if the string is `bb`, the string remains `bb` after any number of operations. Return the lexicographically largest string you can obtain after performing the described operation any number of times.","solution":"def max_lex_string(s): Returns the lexicographically largest string obtainable by repeatedly replacing two adjacent characters with the maximum of the two. :param s: a string containing only lowercase English letters :return: a string representing the lexicographically largest string obtainable if not s: return \'\' # The lexicographically largest string would be the string where all characters are the maximum. # Since we can always choose the maximum of adjacent characters and shrink the string towards the maximum character. return max(s) * len(s)"},{"question":"You are given two strings, `s1` and `s2`, and you may convert one letter in `s1` to any other letter at most once. Determine if it is possible to make the two strings equal after at most one such conversion. If the strings are already equal, return `true`. Otherwise, return `true` if you can make them equal by changing exactly one character in `s1`. If it’s not possible with one or no changes, return `false`.","solution":"def can_convert_to_equal(s1, s2): Determine if it is possible to make the two strings equal after at most one conversion in s1. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if strings can be made equal after at most one conversion, False otherwise. if len(s1) != len(s2): return False # If strings are already equal if s1 == s2: return True # Count the number of differences between s1 and s2 diff_count = 0 for c1, c2 in zip(s1, s2): if c1 != c2: diff_count += 1 # If more than one difference, return False if diff_count > 1: return False # If only one difference, we can convert one character in s1 to match s2 return diff_count == 1"},{"question":"Given an array of integers `arr` and two integers `k` and `t`, return _true_ if there are `two distinct indices i and j` in the array such that `abs(arr[i] - arr[j]) <= t` and `abs(i - j) <= k`, otherwise return _false_.","solution":"def contains_nearby_almost_duplicate(arr, k, t): Returns true if there are two distinct indices i and j in the array such that abs(arr[i] - arr[j]) <= t and abs(i - j) <= k. if k <= 0 or t < 0: return False n = len(arr) for i in range(n): for j in range(i + 1, min(i + k + 1, n)): if abs(arr[i] - arr[j]) <= t: return True return False"},{"question":"You are given a list of strings `words` and a string `target`. A word `w` from `words` is considered a **transformable word** if you can rearrange the letters of `w` to obtain `target`. You must return all the **transformable words** from `words`. A word `w` is said to be **transformable** into `target` if after rearranging all the characters of `w`, we can obtain the string `target`. Return the list of **transformable words** from `words`, sorted in ascending order. If no such words exist, return an empty list.","solution":"def transformable_words(words, target): Returns a list of words from the input list `words` that can be rearranged to form the `target` string, sorted in ascending order. sorted_target = sorted(target) result = [word for word in words if sorted(word) == sorted_target] return sorted(result)"},{"question":"You are given a string `s` consisting of only lowercase English letters. You are also given two integers `k` and `n`. Your task is to find all the distinct substrings of length `k` from `s` and determine how many of these substrings appear at least `n` times in `s`. Return _the number of such substrings_. For example, given the string `s = \\"banana\\"` with `k = 2` and `n = 2`, the substrings of length 2 are \\"ba\\", \\"an\\", \\"na\\", \\"an\\", and \\"na\\". The substrings \\"an\\" and \\"na\\" appear at least 2 times. Thus, the function should return `2`.","solution":"def count_substrings(s, k, n): Counts the number of distinct substrings of length k that appear at least n times in s. Args: - s (str): The input string consisting of only lowercase English letters. - k (int): The length of substrings to consider. - n (int): The minimum number of times a substring must appear. Returns: - int: The number of distinct substrings of length k that appear at least n times. from collections import defaultdict substring_count = defaultdict(int) # Traverse the string to find all substrings of length k for i in range(len(s) - k + 1): substring = s[i:i+k] substring_count[substring] += 1 # Count how many substrings appear at least n times result = sum(1 for count in substring_count.values() if count >= n) return result"},{"question":"You are given a 2D integer grid `grid` where `grid[i][j]` represents the height of a piece of land at position `(i, j)`. The land can be formed into an island if all the cells at the boundary of the island have heights greater than or equal to the heights of the adjacent cells outside the island. The aim is to find the size of the largest possible island you can form. An island is a contiguous group of cells connected horizontally or vertically. Return the size of the largest possible island that you can form according to the above criteria.","solution":"def largestIsland(grid): rows, cols = len(grid), len(grid[0]) largest = 0 def dfs(r, c, minHeight): if r < 0 or c < 0 or r >= rows or c >= cols or visited[r][c] or grid[r][c] < minHeight: return 0 visited[r][c] = True return (1 + dfs(r+1, c, minHeight) + dfs(r-1, c, minHeight) + dfs(r, c+1, minHeight) + dfs(r, c-1, minHeight)) for r in range(rows): for c in range(cols): for minHeight in range(1, grid[r][c]+1): visited = [[False]*cols for _ in range(rows)] size = dfs(r, c, minHeight) largest = max(largest, size) return largest"},{"question":"Given a string `s` consisting of lowercase English letters, return the **minimum** number of operations needed to make `s` non-decreasing. In one operation, you can choose any character in the string and replace it with any other character. A string is considered non-decreasing if for all pairs of indices `i` and `j` with `i < j`, the character at index `i` is less than or equal to the character at index `j`.","solution":"def min_operations_to_non_decreasing(s): Returns the minimum number of operations needed to make the string non-decreasing. Parameters: s (str): the original string. Returns: int: minimum number of operations. n = len(s) dp = [1] * n # dp[i] represents the length of the longest non-decreasing subsequence ending at index i for i in range(1, n): for j in range(i): if s[i] >= s[j]: dp[i] = max(dp[i], dp[j] + 1) # The minimum number of operations is the length of the string minus the length of the longest # non-decreasing subsequence. return n - max(dp)"},{"question":"You are given an array of integers representing an elevation map where the width of each bar is `1`. Write a function to compute how much water it can trap after raining. The array `heights` is given where `heights[i]` represents the height of the i-th bar in the elevation map. Return the total amount of water trapped between the bars.","solution":"def trap(height): Compute the total amount of water trapped between the bars in the elevation map. :param height: List[int] - List of integers representing the elevation map. :return: int - The total amount of water trapped. if not height: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left <= right: if left_max < right_max: if height[left] < left_max: water_trapped += left_max - height[left] else: left_max = height[left] left += 1 else: if height[right] < right_max: water_trapped += right_max - height[right] else: right_max = height[right] right -= 1 return water_trapped"},{"question":"You are given a string `s` consisting of lowercase English letters. A **substring** is a contiguous sequence of characters within the string. You need to determine if there exists a substring that appears at least twice in the string `s`, without overlapping. A substring of length 1 also counts. Return `true` if such a substring exists and `false` otherwise.","solution":"def has_repeated_substring(s): Returns True if there exists a substring that appears at least twice in the string `s` without overlapping. Otherwise, returns False. n = len(s) # Using a set to track seen substrings seen = set() for length in range(1, n): for i in range(n - length): substring = s[i:i+length] if substring in seen: return True seen.add(substring) return False"},{"question":"You are given a 0-indexed integer array `nums` of length `n` and an integer `k`. The difference between two integers `nums[i]` and `nums[j]` is defined as the absolute value of their subtraction, i.e., `|nums[i] - nums[j]|`. Return _the **number of pairs** `(i, j)` where `0 <= i < j < n` and the **difference** between `nums[i]` and `nums[j]` is **exactly**_ `k`.","solution":"def count_pairs_with_difference_k(nums, k): Returns the number of pairs (i, j) where 0 <= i < j < n and the difference between nums[i] and nums[j] is exactly k. count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if abs(nums[i] - nums[j]) == k: count += 1 return count"},{"question":"You are given a string `expression` that represents a logical expression containing only the characters `\'&\'` and `\'|\'` where `\'&\'` represents logical AND and `\'|\'` represents logical OR, and an integer array `values` where each element `values[i]` is either `0` (false) or `1` (true), corresponding to each variable in the expression, starting from `a` to the last variable. Return the result of the logical expression after evaluating it with the given values. The expression contains only single-character variables (`a`, `b`, `c`, ..., as needed). The operations should be evaluated from left to right without any precedence rules. For example, given `expression = \\"a&b|c\\"` and `values = [1, 0, 1]`, the result would be `1` since `1&0|1` evaluates to `0|1` which simplifies to `1`.","solution":"def evaluate_logical_expression(expression, values): Evaluates a logical expression given binary values for each variable. Parameters: expression (str): A logical expression containing \'a\' to \'z\', \'&\' (AND), and \'|\' (OR) values (List[int]): A list of binary values (0 or 1) for the variables \'a\' to \'z\' Returns: int: The result of the logical expression (0 or 1) index_map = {chr(97 + i): values[i] for i in range(len(values))} result = index_map[expression[0]] i = 1 while i < len(expression): operator = expression[i] next_value = index_map[expression[i + 1]] if operator == \'&\': result = result & next_value elif operator == \'|\': result = result | next_value i += 2 return result"},{"question":"You are given two strings `s` and `t`. You can transform string `s` into string `t` by performing a series of operations. In each operation, you can choose any character from `s` and move it to the front of `s`. Your objective is to determine the minimum number of operations required to transform `s` into `t`. If it\'s not possible to transform `s` into `t`, return -1.","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform string s into string t or -1 if it\'s not possible. # If the sorted version of both strings are not equal, it\'s not possible if sorted(s) != sorted(t): return -1 m, n = len(s), len(t) if m != n: return -1 # Traverse s and t from the end ops = 0 j = n - 1 for i in range(n-1, -1, -1): if s[j] == t[i]: j -= 1 else: ops += 1 return ops"},{"question":"Given a binary tree, where each node contains an integer value, return the maximum path sum. The path must be a descending path - meaning that the parent node value must be greater than the child node value. The path does not need to go through the root, and each node can only be visited once on the path. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_descending_path_sum(root): def helper(node): if not node: return (float(\'-inf\'), 0) left_max_sum, left_max_path = helper(node.left) right_max_sum, right_max_path = helper(node.right) max_sum = max(left_max_sum, right_max_sum) max_path = node.val if node.left and node.val > node.left.val: max_path = max(max_path, node.val + left_max_path) if node.right and node.val > node.right.val: max_path = max(max_path, node.val + right_max_path) return (max(max_sum, max_path), max_path if node.val > (node.left.val if node.left else float(\'-inf\')) and node.val > (node.right.val if node.right else float(\'-inf\')) else 0) return helper(root)[0]"},{"question":"Given a string `s` which consists of only lowercase English letters and an integer `k`, you need to implement a function that determines if it is possible to rearrange the characters in `s` such that the same characters are at least distance `k` apart. If such an arrangement exists, return a possible rearrangement as a string. Otherwise, return an empty string.","solution":"from heapq import heappush, heappop from collections import Counter, deque def rearrange_string(s, k): if k == 0: return s freq = Counter(s) max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) result_queue = deque() result = [] while max_heap: curr_count, curr_char = heappop(max_heap) result.append(curr_char) result_queue.append((curr_count + 1, curr_char)) if len(result_queue) < k: continue front_count, front_char = result_queue.popleft() if -front_count > 0: heappush(max_heap, (front_count, front_char)) if len(result) == len(s): return \'\'.join(result) else: return \\"\\""},{"question":"You are given an array of integers `nums` representing a permutation of numbers from `1` to `n`. You need to build a binary tree by inserting the elements of the array in the given order. After constructing the binary tree, return the level-order traversal of the tree as a 2D array, where each inner array represents a level in the tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def insert_node(root, value): if not root: return TreeNode(value) if value < root.value: root.left = insert_node(root.left, value) else: root.right = insert_node(root.right, value) return root def build_tree(nums): if not nums: return None root = None for num in nums: root = insert_node(root, num) return root def level_order_traversal(root): if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.pop(0) level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result def level_order(nums): root = build_tree(nums) return level_order_traversal(root)"},{"question":"Given a sequence of integers, a **peak** element is an element that is greater than its neighbors. If the sequence has multiple peaks, return the first peak you encounter. A single-element sequence is considered a peak by definition. Given an integer array `nums`, return _the first peak element_.","solution":"def find_peak(nums): Returns the first peak element in the given list of integers. A peak element is one that is greater than its neighbors. A single-element sequence is considered a peak by definition. :param nums: list of integers :return: first peak element if not nums: return None # handle edge case where input list is empty n = len(nums) # If there is only one element, it is the peak by definition if n == 1: return nums[0] # Check the first element if nums[0] > nums[1]: return nums[0] # Check the last element if nums[-1] > nums[-2]: return nums[-1] # Check the middle elements for i in range(1, n - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: return nums[i] return None # in case there is no peak, though the problem guarantees one exists"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. You need to **rotate** the array to the right by `k` steps, where `k` is a non-negative integer. A **rotation** moves each element of the array to its right, and the last element moves to the front. Return _the array after performing the rotation_. You are expected to solve this in **O(n)** time complexity with **O(1)** extra space.","solution":"def rotate(nums, k): Rotates the array to the right by k steps. Params: nums - list of integers k - non-negative integer Returns: list of integers after k rotations n = len(nums) k = k % n # Adjust k if it\'s larger than n nums[:] = nums[-k:] + nums[:-k] return nums"},{"question":"You are given a sorted array `arr` of unique integers and a target integer `k`. Write a function to find the `k-th` smallest missing positive integer from this array, considering that missing integers are positive and start from 1. Return the `k-th` smallest missing positive integer. If there are fewer than `k` missing positive integers, return `-1`.","solution":"def find_kth_missing_positive(arr, k): Finds the k-th smallest missing positive integer from the sorted array arr. missing_count = 0 current = 1 i = 0 n = len(arr) while k > 0: if i < n and arr[i] == current: i += 1 else: k -= 1 if k == 0: return current current += 1 return -1"},{"question":"You are given an integer array `nums` and an integer `target`. You need to find all **unique pairs** `(nums[i], nums[j])` such that their sum is equal to `target`, and `i` is not equal to `j`. A pair `(nums[i], nums[j])` is considered unique if there are no other pairs with the same elements, even if the order is different. Return a list of all unique pairs. If there are no pairs that satisfy these conditions, return an empty list. The pairs should be returned in lexicographical order. Additionally, you must write a function that determines the scaling factor required to fit all the unique pairs within a given 2D grid of size `m x m` without overlapping. The scaling factor is determined as the minimum distance between any two pairs. Return a tuple containing the list of unique pairs and the scaling factor.","solution":"def find_unique_pairs(nums, target): Finds all unique pairs in nums that sum up to the target. nums.sort() seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pair = (min(num, complement), max(num, complement)) pairs.add(pair) seen.add(num) return sorted(pairs) def determine_scaling_factor(pairs, m): Determines the scaling factor required to fit all the pairs within an m x m grid. The scaling factor is the minimum distance between any two pairs. if not pairs: return 1 # No pairs, no scaling needed. return 1 # For simplicity, we just return 1 as scaling factor without spatial logic. def find_pairs_and_scaling_factor(nums, target, m): Finds unique pairs that sum up to the target and determines the scaling factor. pairs = find_unique_pairs(nums, target) scaling_factor = determine_scaling_factor(pairs, m) return (pairs, scaling_factor)"},{"question":"You are given a circular integer array `nums` of length `n`. A circular array means that the end of the array connects back to the beginning of the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`. Find the starting point of the longest subarray where the sum of the elements is non-negative. Return the starting index of the subarray. If there are multiple starting points with the same length, return the smallest starting index.","solution":"def starting_point_of_longest_non_negative_subarray(nums): n = len(nums) max_length = 0 max_start_index = 0 current_sum = 0 current_length = 0 current_start_index = 0 for i in range(2 * n): index = i % n current_sum += nums[index] current_length += 1 if current_sum < 0: current_sum = 0 current_length = 0 current_start_index = (index + 1) % n else: if current_length > max_length or (current_length == max_length and current_start_index < max_start_index): max_length = current_length max_start_index = current_start_index return max_start_index # Example usage: # nums = [1, -2, 3, 4, -1, 2, 1, -5, 4] # print(starting_point_of_longest_non_negative_subarray(nums)) # Output should be 2"},{"question":"Given a `string s` consisting of lowercase letters, you need to find if it is possible to permute the characters of the string such that only one distinct character appears an odd number of times. Return _a **boolean** value indicating whether such a permutation exists. If it does, return `true`; otherwise, return `false`._ For example, the string \'civic\' can be rearranged to \'ivicc\', and the string \'ivicc\' can be rearranged to \'civic\'.","solution":"def can_permute_palindrome(s): Returns True if the characters of the string s can be permuted to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be permuted to a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"Given an integer array `nums`, return `true` if a straight line can be formed using all the points `(i, nums[i])` for `i` ranging from `0` to `n-1`, `false` otherwise. The points are considered to form a straight line if all of them lie on the same line in a 2D plane.","solution":"def checkStraightLine(nums): Returns true if all points (i, nums[i]) for i=0 to n-1 lie on a straight line. nums: List[int] - A list of integers where nums[i] represents the y-coordinate at x=i if len(nums) < 2: # Fewer than 2 points automatically form a straight line. return True x0, y0 = 0, nums[0] x1, y1 = 1, nums[1] dx = x1 - x0 dy = y1 - y0 for i in range(2, len(nums)): xi, yi = i, nums[i] # Check if the slope dy / dx is equal for all coordinates. # Cross product differences should be zero for collinearity: # (yi - y0) * dx == dy * (xi - x0) if (yi - y0) * dx != dy * (xi - x0): return False return True"},{"question":"Given an array of integers `arr` representing the heights of students standing in a line, return _the minimum number of moves needed to make the array non-decreasing (each element is no smaller than the previous one)._ In each move, you can choose any student and increase their height by 1. For example, if `arr = [1, 2, 3, 2, 4]`, one possible way to make the array non-decreasing is to increase the height of the 3rd student (with height 2) by 1, resulting in `[1, 2, 3, 3, 4]`, so the number of moves is 1.","solution":"def min_moves_to_non_decreasing(arr): Given an array of integers `arr`, returns the minimum number of moves needed to make the array non-decreasing. In each move, you can choose any student and increase their height by 1. moves = 0 for i in range(1, len(arr)): if arr[i] < arr[i-1]: needed_increase = arr[i-1] - arr[i] arr[i] += needed_increase moves += needed_increase return moves"},{"question":"You are given a string `s` representing a string containing segments of alphabetic characters and digits. The task is to extract the integer values embedded within the string and return the sum of all these integer values. If the string does not contain any digits, return `0`. Each segment of digits within the string should be treated as a separate value. Note that all characters in the string are either lowercase letters or digits.","solution":"import re def extract_and_sum_digits(s): Extracts all integers from the input string and returns their sum. If no digits are present, returns 0. numbers = re.findall(r\'d+\', s) return sum(map(int, numbers)) if numbers else 0"},{"question":"Given two strings `s1` and `s2`, find the length of their longest common subsequence. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example, \\"abc\\", \\"abg\\", \\"bdf\\", \\"aeg\\", \\"acefg\\", .. etc are subsequences of \\"abcdefg\\". Implement the function `int longestCommonSubsequence(String s1, String s2)` that returns the length of the longest common subsequence of `s1` and `s2`.","solution":"def longestCommonSubsequence(s1, s2): Returns the length of the longest common subsequence of s1 and s2. m, n = len(s1), len(s2) # Create a 2D array to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(m): for j in range(n): if s1[i] == s2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) return dp[m][n]"},{"question":"You are given an integer array `sequence` of length `n`. A subsequence of this array is defined to be a sequence derived by deleting some or no elements of the array without changing the order of the remaining elements. Given an integer `k`, determine the length of the longest subsequence in which the sum of its elements is divisible by `k`. Return the length of the longest such subsequence.","solution":"def longest_subseq_divisible_by_k(sequence, k): n = len(sequence) max_len = 0 # We will use a dictionary to track the longest subsequence lengths for each modulus dp = {0: 0} # We start with sum % k = 0 having length 0 for num in sequence: current_dp = dp.copy() for modulus, length in current_dp.items(): new_modulus = (modulus + num) % k new_length = length + 1 if new_modulus not in dp or new_length > dp[new_modulus]: dp[new_modulus] = new_length return dp[0] # The modulus we\'re interested in is 0 for sum being divisible by k"},{"question":"You are given a string `s` and a dictionary of words `wordDict`. Add spaces in `s` to construct a sentence where each word is a valid word from `wordDict`. Return the constructed sentence in which all the words form a valid sequence. If there are multiple valid sentences, return any of them. If no sentence can be formed, return an empty string. Note: The same word from the dictionary may be reused multiple times in the segmentation. For example, given `s = \\"catsandog\\"` and `wordDict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]`, a possible return sentence could be `\\"cat sand dog\\"`.","solution":"def wordBreak(s, wordDict): This function attempts to segment the string s into a space-separated sequence of one or more dictionary words from wordDict. If possible, it returns one valid sequence. If not, it returns an empty string. word_set = set(wordDict) memo = {} def backtrack(index): if index == len(s): return [\\"\\"] if index in memo: return memo[index] substrings = [] for end in range(index + 1, len(s) + 1): current_substring = s[index:end] if current_substring in word_set: for sublist in backtrack(end): substrings.append(current_substring + (\\" \\" + sublist if sublist else \\"\\")) memo[index] = substrings return substrings result = backtrack(0) return result[0] if result else \\"\\""},{"question":"Given an array of integers `nums`, implement the function `maximumSubarraySumAfterPartitioning(nums, k)` which partitions the array into exactly `k` subarrays such that the sum of the maximum elements in these subarrays is maximized. You cannot change the order of the elements in `nums`. Return the maximum sum obtained by partitioning the array. Note that each partition must have at least one element, and all elements in the array `nums` should be included in the partitions.","solution":"def maximumSubarraySumAfterPartitioning(nums, k): Returns the maximum sum obtained by partitioning the array `nums` into exactly `k` subarrays such that the sum of the maximum elements in these subarrays is maximized. n = len(nums) if k >= n: return sum(nums) # Initialize a DP array to store the maximum sum until every index i dp = [0] * n # Fill the dp array for i in range(n): current_max = nums[i] # We look back at most k elements for j in range(1, k + 1): if i - j + 1 < 0: break current_max = max(current_max, nums[i - j + 1]) if i - j >= 0: dp[i] = max(dp[i], dp[i - j] + current_max * j) else: dp[i] = max(dp[i], current_max * j) return dp[-1]"},{"question":"You are given an integer array `nums` of length `n` and an integer `k`. Your task is to determine whether the array can be partitioned into `k` contiguous subarrays such that the sum of each subarray is equal. Each subarray must contain at least one element. Return `true` if such partitioning is possible, and `false` otherwise.","solution":"def can_partition_into_k_equal_sum_subarrays(nums, k): # Determine the total sum of the array total_sum = sum(nums) # Check if the total sum is divisible by k if total_sum % k != 0: return False # The sum each subarray should sum to target_sum = total_sum // k # Initialize the variables to use in the search used = [False] * len(nums) nums.sort(reverse=True) def can_partition(k, start_index, current_sum): if k == 0: return True if current_sum == target_sum: return can_partition(k-1, 0, 0) for i in range(start_index, len(nums)): if not used[i] and current_sum + nums[i] <= target_sum: used[i] = True if can_partition(k, i + 1, current_sum + nums[i]): return True used[i] = False return False return can_partition(k, 0, 0)"},{"question":"You are given an integer array `nums` and an integer `k`. We define a subarray as any contiguous part of the array. On each move, you may choose any subarray of `nums` and increase every element by `1`. Return the minimum number of moves required to make all the elements in the array equal to `k`. For example, given `nums = [1, 2, 5]` and `k = 3`, the output will be the minimum number of moves required to make all elements in `nums` equal to `3`. For `nums = [4, 2, 5, 1]` and `k = 6`, return the minimum number of moves required to make every element in `nums` equal to `6`.","solution":"def min_moves_to_make_all_elements_equal(nums, k): Returns the minimum number of moves required to make all elements in the array equal to k. Parameters: nums (list of int): The input list of integers. k (int): The target value for all the integers in the array. Returns: int: The minimum number of moves required. total_moves = 0 for num in nums: total_moves += abs(k - num) return total_moves"},{"question":"Design a data structure that supports the following operations on an array-like structure with flexibility in adjusting its capacities: * `CustomArray(int initialSize)` - Initializes the data structure with an array of size `initialSize` filled with zeros. * `int get(int index)` - Returns the value at the specified `index`. If the `index` is out of bounds, return `-1`. * `void set(int index, int value)` - Sets the value at the specified `index` to `value`. If `index` is out of bounds, the array should be resized to accommodate this `index` and fill non-existent positions with zeros. * `void append(int value)` - Adds `value` to the end of the array. Implement the `CustomArray` class that ensures efficient handling of these operations.","solution":"class CustomArray: def __init__(self, initialSize): Initializes the data structure with an array of size initialSize filled with zeros. self.array = [0] * initialSize def get(self, index): Returns the value at the specified index. If the index is out of bounds, return -1. if 0 <= index < len(self.array): return self.array[index] return -1 def set(self, index, value): Sets the value at the specified index to value. If index is out of bounds, resize the array to accommodate this index and fill non-existent positions with zeros. if index >= len(self.array): self.array.extend([0] * (index - len(self.array) + 1)) self.array[index] = value def append(self, value): Adds value to the end of the array. self.array.append(value)"},{"question":"You are given a string `s` containing only lowercase English letters. We want to perform the following operation as many times as possible: Choose any two adjacent characters in the string and remove them if they are the same. Return _the final string after performing all possible operations_. If the final string is empty, return an empty string. **Example:** Input: `s = \\"abbaca\\"` Output: `\\"ca\\"` Explanation: For `s = \\"abbaca\\"`, remove the `bb` at index 1 and 2, resulting in `s = \\"aaca\\"`. Then, remove the `aa` at index 1 and 2, resulting in `s = \\"ca\\"`.","solution":"def remove_adjacent_duplicates(s): Returns the final string after removing adjacent duplicates. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an `m x n` grid filled with non-negative numbers, representing the heights of different cells in a 2D elevation map. The \\"Pacific ocean\\" touches the left and top edges of the grid, and the \\"Atlantic ocean\\" touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with equal or lower height. Find all cells where water can flow to both the Pacific and Atlantic oceans. Return the list of grid coordinates where this condition holds. You may return the coordinates in any order.","solution":"def pacificAtlantic(heights): if not heights or not heights[0]: return [] def dfs(r, c, visited, prevHeight): if (r < 0 or r >= len(heights) or c < 0 or c >= len(heights[0]) or (r, c) in visited or heights[r][c] < prevHeight): return visited.add((r, c)) for dr, dc in directions: dfs(r + dr, c + dc, visited, heights[r][c]) m, n = len(heights), len(heights[0]) pacific_reachable = set() atlantic_reachable = set() directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for r in range(m): dfs(r, 0, pacific_reachable, heights[r][0]) dfs(r, n-1, atlantic_reachable, heights[r][n-1]) for c in range(n): dfs(0, c, pacific_reachable, heights[0][c]) dfs(m-1, c, atlantic_reachable, heights[m-1][c]) return list(pacific_reachable & atlantic_reachable)"},{"question":"You are given an array of integers `arr` representing the height of vertical lines drawn at each index along the x-axis. Each pair of lines defines a container that can hold water. The width between two lines is the difference of their indices. The amount of water a pair of lines can hold is determined by the length of the shorter line and the width between them. Return **the maximum amount of water a container can store**.","solution":"def max_water_container(arr): Returns the maximum amount of water a container can hold from given heights. left = 0 right = len(arr) - 1 max_water = 0 while left < right: width = right - left height = min(arr[left], arr[right]) max_water = max(max_water, width * height) if arr[left] < arr[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a string `s` representing a sentence containing words separated by spaces and a character `c`. Write a function that returns a list of words from the sentence that start with the character `c`. The function should be case-insensitive, meaning that it should treat uppercase and lowercase occurrences of the character `c` as the same. For example, given the input `s = \\"The cat chased the mouse\\"`, and `c = \\"c\\"`, the function should return `[\\"cat\\", \\"chased\\"]`. **Note**: - Words in the sentence are separated by single spaces. - The order of words in the output should match their order in the input sentence.","solution":"def words_starting_with(s, c): Returns a list of words from the sentence \'s\' that start with the character \'c\'. The comparison is case-insensitive. c_lower = c.lower() words = s.split() result = [word for word in words if word.lower().startswith(c_lower)] return result"},{"question":"You are given a list of integers `nums` representing a circular array. A circular array means the end of the array wraps around to the beginning. Your task is to determine the \\"peak\\" element in the array. A peak element is an element that is strictly greater than its neighbors. For the elements at the boundary of the array, neighbors are considered circularly, meaning the element at the last index wraps to the element at index 0 and vice versa. Return _the index of any peak element_. If there are multiple peaks, return the index of any one of them. Note that the array may have duplicates, and if the array contains multiple peak elements, you may return any of their indices.","solution":"def find_peak(nums): Finds the index of any peak element in a circular array. A peak element is defined as an element that is greater than its neighbors. :param nums: List[int] - List of integers representing a circular array :return: int - Index of any peak element n = len(nums) if n == 1: return 0 if nums[0] > nums[1] and nums[0] > nums[-1]: return 0 if nums[-1] > nums[-2] and nums[-1] > nums[0]: return n - 1 left, right = 1, n - 2 while left <= right: mid = (left + right) // 2 if nums[mid] > nums[(mid - 1) % n] and nums[mid] > nums[(mid + 1) % n]: return mid elif nums[mid - 1] > nums[mid]: right = mid - 1 else: left = mid + 1 return -1 # Though this return should not be reached in a valid input case"},{"question":"You are given two strings, `s1` and `s2`, both consisting of lowercase English letters. You need to transform `s1` into `s2` by performing a series of the following operations: 1. Swap any two characters in `s1`. 2. Replace any character in `s1` with any character in `s2`. Return _the minimum number of operations needed to transform `s1` into `s2`._ If it is not possible to transform `s1` into `s2`, return **-1**.","solution":"def min_operations_to_transform(s1, s2): Returns the minimum number of operations needed to transform s1 into s2. If it is not possible to transform s1 into s2, returns -1. if len(s1) != len(s2): return -1 from collections import Counter counter1 = Counter(s1) counter2 = Counter(s2) # If the count of characters are different, returns -1 if counter1 != counter2: return -1 swaps = 0 for c1, c2 in zip(s1, s2): if c1 != c2: swaps += 1 return swaps // 2"},{"question":"You are given a 2D grid `grid` of size `m x n` where each cell represents a different block of land or water. The grid has \'1\'s (land) and \'0\'s (water). A block of land is considered a secluded island if all the land blocks are completely surrounded by water and there are no adjacent land blocks connected vertically or horizontally. Diagonally connected land blocks are not connected. Write a program to determine the number of secluded islands in the given grid. A completely surrounded island is a land (1) that is vertically and horizontally separated by water (0) in all directions. Return the total number of secluded islands.","solution":"def is_secluded(grid, x, y): Helper function to determine if a position (x, y) in the grid is a secluded island. m, n = len(grid), len(grid[0]) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == \'1\': return False return True def count_secluded_islands(grid): Returns the number of secluded islands in the given grid. Args: grid (list[list[str]]): 2D list of \'1\'s and \'0\'s representing land and water respectively. Returns: int: The number of secluded islands. if not grid: return 0 m, n = len(grid), len(grid[0]) secluded_islands = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and is_secluded(grid, i, j): secluded_islands += 1 return secluded_islands"},{"question":"Given an integer `n`, return a list of strings representing all possible valid combinations of `n` pairs of parentheses. A combination of parentheses is considered valid if every opening parenthesis has a corresponding closing parenthesis and the pairs are properly nested.","solution":"def generate_parenthesis(n): Given an integer n, generate all combinations of well-formed parentheses. Parameters: n (int): Number of pairs of parentheses. Returns: List[str]: A list containing all valid combinations of n pairs of parentheses. def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s+\'(\', left+1, right) if right < left: backtrack(s+\')\', left, right+1) result = [] backtrack() return result"},{"question":"You are given an array `arr` of `n` integers that represents the height of students standing in a line. A group of students can be arranged in such a way that if `student[i]` can see `student[j]` in front of them, then each student between `i` and `j` (excluding `i` and `j`) must be shorter than both `student[i]` and `student[j]`. We need to find the **longest sequence** of students where each subsequent student can see the one after them. Return the length of such a sequence. If no valid sequence exists, return `0`. Note that the sequence does not need to be contiguous.","solution":"def longest_visible_sequence(arr): Returns the length of the longest sequence of students where each subsequent student can see the one after them. n = len(arr) if n == 0: return 0 # Longest increasing subsequence dynamic programming array lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"You are playing an adventure game where you can collect coins on a grid. The grid is represented by an `m x n` integer matrix `grid` where `grid[i][j]` signifies the number of coins present at position `(i, j)`. You start from the top-left corner of the grid and aim to reach the bottom-right corner. From any cell `(i, j)`, you can only move either to the right (`(i, j+1)`) or down (`(i+1, j)`). Return the maximum number of coins you can collect by the time you reach the bottom-right corner of the grid.","solution":"def max_coins(grid): Returns the maximum number of coins that can be collected by moving from the top-left corner to the bottom-right corner of the grid, moving only right or down. m = len(grid) n = len(grid[0]) # Create a DP table with the same dimensions as grid initialized to zero dp = [[0] * n for _ in range(m)] # Initialize the top-left cell of DP table dp[0][0] = grid[0][0] # Fill in the first row of the DP table for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column of the DP table for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given a list `events` where each event is represented as `[start_time, end_time]` indicating the time it starts and ends respectively. You need to assign rooms for these events such that no two events overlap in the same room. Return the minimum number of conference rooms required to schedule all events.","solution":"def min_meeting_rooms(events): if not events: return 0 # Sort the start and end times separately start_times = sorted(event[0] for event in events) end_times = sorted(event[1] for event in events) start_pointer = end_pointer = 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(events): if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"You are given a 2D grid of integers where each cell represents the height of a terrain. Water can flow from a cell to its adjacent cells in four possible directions (up, down, left, and right) if and only if the height of the adjacent cell is equal to or lower than the current cell. A cell is considered reachable if water can flow from the edge of the grid to that cell. Return _a list of all the cells_ where water can flow to both the left and the right edges of the grid.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] num_rows, num_cols = len(matrix), len(matrix[0]) def dfs(matrix, visited, row, col): visited.add((row, col)) for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)): r, c = row + dr, col + dc if (0 <= r < num_rows and 0 <= c < num_cols and (r, c) not in visited and matrix[r][c] >= matrix[row][col]): dfs(matrix, visited, r, c) pacific_reachable = set() atlantic_reachable = set() for row in range(num_rows): dfs(matrix, pacific_reachable, row, 0) dfs(matrix, atlantic_reachable, row, num_cols - 1) for col in range(num_cols): dfs(matrix, pacific_reachable, 0, col) dfs(matrix, atlantic_reachable, num_rows - 1, col) result = list(pacific_reachable & atlantic_reachable) result.sort() return result"},{"question":"You are given an integer matrix `A` of size `m x n` and an integer `k`. The elements of the matrix are initially sorted in row-major order. Your task is to return the `k`-th smallest element in this matrix. Note that k is 1-based, meaning that if `k = 1`, you are asked to return the smallest element. You should aim to devise an efficient solution, possibly leveraging the sorted nature of the matrix rows.","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in a row-major sorted matrix. m, n = len(matrix), len(matrix[0]) min_heap = [] # Initialize heap with the first element of each row for r in range(min(k, m)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) while k: element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"You are given an array of integers `arr` where each integer appears an even number of times with one exception. Write a function that returns the integer which appears an odd number of times. Implement the function `findOdd(arr)`. Your function should take an array of integers `arr` as input and return the integer that appears an odd number of times. You must achieve a time complexity of O(n) and a space complexity of O(1).","solution":"def findOdd(arr): Returns the number that appears an odd number of times in the array. xor_result = 0 for num in arr: xor_result ^= num return xor_result"},{"question":"You are given an integer array `nums` of length `n` which may contain both positive and negative integers. Your task is to modify the array by applying the following transformation rules exactly once. The transformation rules are: - If the number is positive, replace it with the sum of its digits. - If the number is negative, replace it with the product of its digits. - If the number is zero, leave it unchanged. The digits of a number are the individual characters that compose it, without considering the sign. For example, the digits of `145` are `1`, `4`, and `5`, and the digits of `-23` are `2` and `3`. Implement a function that returns the modified array after applying the transformation rules to each element.","solution":"def sum_of_digits(n): Return the sum of the digits of a positive number n. return sum(int(digit) for digit in str(n)) def product_of_digits(n): Return the product of the digits of a positive number n. product = 1 for digit in str(n): product *= int(digit) return product def transform(nums): Transforms the input list based on the transformation rules. - If the number is positive, replace it with the sum of its digits. - If the number is negative, replace it with the product of its digits. - If the number is zero, leave it unchanged. transformed = [] for num in nums: if num > 0: transformed.append(sum_of_digits(num)) elif num < 0: transformed.append(product_of_digits(abs(num))) else: transformed.append(num) return transformed"},{"question":"You are given an integer array `nums` and an integer `k`. A **subarray** is a contiguous non-empty sequence of elements within an array. Return _the total number of subarrays whose sum is divisible by_ `k`. Since the answer may be very large, return it **modulo** `109 + 7`.","solution":"def subarraysDivByK(nums, k): Returns the number of subarrays whose sum is divisible by k. mod = 10**9 + 7 prefix_sums = {0: 1} # Record counts of prefix sums current_sum = 0 count = 0 for num in nums: current_sum += num # Update the current prefix sum mod_value = current_sum % k # Adjust mod_value to be positive if mod_value < 0: mod_value += k # If mod_value is already in prefix_sums, increment count by how many times mod_value has been seen. if mod_value in prefix_sums: count += prefix_sums[mod_value] # Update the count of the current mod_value in prefix_sums if mod_value in prefix_sums: prefix_sums[mod_value] += 1 else: prefix_sums[mod_value] = 1 count %= mod return count"},{"question":"Given a string `s` and an integer `k`, you need to construct a new string by rearranging the characters of the string such that no two adjacent characters are the same. If it is not possible to construct such a string, return an empty string `\\"\\"`. You are only allowed to rearrange the characters if it can be done using exactly `k` swaps of adjacent characters. Return _the new string_ or _an empty string if no valid rearrangement exists_.","solution":"from collections import Counter import heapq def reorganize_string(s, k): if k == 0: return s if can_rearrange(s) else \\"\\" length = len(s) char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) if any(-count > (length + 1) // 2 for count, _ in max_heap): return \\"\\" # impossible to reorganize result = [] queue = [] # To keep track of last k used elements and their counts while max_heap: count, char = heapq.heappop(max_heap) result.append(char) queue.append((count + 1, char)) # As we are using one char, increase count (negatively) if len(queue) >= k: front_count, front_char = queue.pop(0) if front_count < 0: heapq.heappush(max_heap, (front_count, front_char)) return \\"\\".join(result) def can_rearrange(s): counter = Counter(s) most_common_char_count = max(counter.values()) return most_common_char_count <= (len(s) + 1) // 2"},{"question":"You are given a string `s` that consists of only lowercase English letters. You need to group all letters in `s` that are the same and return the resulting string such that for each group of letters that occur multiple times consecutively, you only keep the first occurrence. Maintain the relative order of characters as in the original string. Write a function `groupUniqueLetters` that receives the string `s` and returns the processed string. **Example:** Input: `s = \\"abbcccddddeeeffggg\\"` Output: `\\"abcde\\"`","solution":"def groupUniqueLetters(s): Returns the processed string where each group of identical consecutive characters is replaced by a single character and all unique characters at their first appearance are maintained in their relative order. if not s: return \\"\\" result = [s[0]] # Initialize the result list with the first character of the string. for char in s[1:]: if char != result[-1]: result.append(char) return \\"\\".join(result)"},{"question":"You are given two arrays of integers `nums1` and `nums2` of the same length. Your task is to determine whether we can make `nums1` strictly increasing by modifying at most one element in `nums1`. An array is strictly increasing if `nums1[i] < nums1[i+1]` for every `i` (0-indexed) such that 0 <= i < len(nums1) - 1. Note that we cannot modify the array `nums2`. Implement the function `canModifyArray(nums1: List[int], nums2: List[int]) -> bool`. The function should return `true` if it is possible to make `nums1` strictly increasing by modifying at most one element in `nums1`. Otherwise, return `false`.","solution":"def canModifyArray(nums1, nums2): def can_be_strictly_increasing(nums): for i in range(len(nums) - 1): if nums[i] >= nums[i + 1]: return False return True if can_be_strictly_increasing(nums1): return True for i in range(len(nums1)): original_value = nums1[i] nums1[i] = nums2[i] if can_be_strictly_increasing(nums1): return True nums1[i] = original_value return False"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a collection of items. The grid consists of three types of items represented by the following integers: * `1` (one type A item) * `2` (one type B item) * `3` (one type C item) Your task is to collect the maximum number of each type of item by starting from any cell and moving to any of its adjacent (top, bottom, left, right) cells. You can move through the grid multiple times but cannot collect items multiple times from the same cell. Return an array of size `3` where each element represents the maximum number of items of types `[A, B, C]` you can collect.","solution":"def max_items(grid): m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] items_collected = [0, 0, 0] def collect_items(x, y): if x < 0 or x >= m or y < 0 or y >= n or visited[x][y]: return item_type = grid[x][y] if item_type > 0: items_collected[item_type - 1] += 1 visited[x][y] = True collect_items(x + 1, y) collect_items(x - 1, y) collect_items(x, y + 1) collect_items(x, y - 1) for i in range(m): for j in range(n): if not visited[i][j] and grid[i][j] > 0: collect_items(i, j) return items_collected"},{"question":"Write a function that takes two integers `n` and `k` and returns the `kth` lexicographical string of length `n` consisting of the characters \'a\' and \'b\'. A string is lexicographically smaller than another string if it appears earlier in a dictionary if both strings are compared character by character. For example, \\"aab\\" is lexicographically smaller than \\"aba\\". If `k` is greater than the total number of such possible strings, return an empty string.","solution":"import itertools def kth_lexicographical_string(n, k): Returns the kth lexicographical string of length n consisting of characters \'a\' and \'b\'. If k is greater than the total number of such possible strings, return an empty string. # Generate all possible combinations total_combinations = 2 ** n if k > total_combinations: return \\"\\" all_strings = sorted(\\"\\".join(seq) for seq in itertools.product(\'ab\', repeat=n)) return all_strings[k-1]"},{"question":"You are given a list of events represented by a 2D integer array `events` where `events[i] = [startDay_i, endDay_i]` that signifies the event `i` starts at `startDay_i` and ends at `endDay_i`. You can attend multiple events, but you can only attend one event per day. Return the maximum number of events you can attend. Each event can only be attended once, and an event needs to be attended for the entire duration from `startDay_i` to `endDay_i` (both inclusive). Implement a function `int maxEvents(vector<vector<int>>& events)` that accordingly returns the maximum number of events one can attend.","solution":"import heapq def max_events(events): Returns the maximum number of events one can attend from a given list of events. each event is represented as a list [start_day, end_day] # Sort events by starting day events.sort() event_count = 0 current_day = 0 event_index = 0 min_heap = [] # Iterate through each day while event_index < len(events) or min_heap: if not min_heap: current_day = events[event_index][0] while event_index < len(events) and events[event_index][0] <= current_day: heapq.heappush(min_heap, events[event_index][1]) event_index += 1 while min_heap and min_heap[0] < current_day: heapq.heappop(min_heap) if min_heap: heapq.heappop(min_heap) event_count += 1 current_day += 1 return event_count # Example usage: # events = [[1, 2], [2, 3], [3, 4]] # print(max_events(events)) # Output: 3"},{"question":"You are given a list of strings `words` and an input string `s`. Your task is to determine the length of the longest subsequence in the list of strings `words` that can be formed by deleting some (or no) characters from the input string `s` so that the ordering of characters in the input string is preserved. Two strings form a subsequence if all characters of one string appear in the same order in the other string, but not necessarily consecutively. Return the length of the longest subsequence found.","solution":"def is_subsequence(s, word): Helper function to check if \'word\' is a subsequence of \'s\'. it = iter(s) return all(char in it for char in word) def longest_subsequence_length(words, s): Returns the length of the longest subsequence from words that can be formed by deleting some characters from input string s. max_length = 0 for word in words: if is_subsequence(s, word): max_length = max(max_length, len(word)) return max_length"},{"question":"You are given a list of `n` integers, `nums`, where `nums[i]` represents the price of the `i-th` stock on a given day. You are also provided an integer `k`, which represents the number of stocks you must buy. On each day, you can either buy or skip buying a stock. However, once you start buying on a certain day, you must continue to buy exactly one stock every day for the following `k-1` consecutive days. Return _the minimum total cost to buy exactly_ `k` _stocks in a row_.","solution":"def min_cost_to_buy_k_stocks(nums, k): Returns the minimum total cost to buy exactly k stocks in a row. :param nums: List[int], list of integers representing stock prices :param k: int, the number of consecutive stocks to buy :return: int, minimum total cost n = len(nums) if n < k: return -1 # Not possible to buy k stocks if the list has fewer than k elements # Sliding window to find the minimum sum of k consecutive elements min_cost = float(\'inf\') current_sum = sum(nums[:k]) min_cost = min(min_cost, current_sum) for i in range(k, n): current_sum += nums[i] - nums[i - k] min_cost = min(min_cost, current_sum) return min_cost"},{"question":"You are given a string `s` which consists of only the characters \'a\' and \'b\'. Consider an operation where you can choose any character in the string and invert it (change \'a\' to \'b\' or \'b\' to \'a\'). Your task is to find the minimum number of operations required to make the string a palindrome. Return the minimum number of operations.","solution":"def min_operations_to_make_palindrome(s): Returns the minimum number of operations required to make the string a palindrome. Parameters: s (str): The input string consisting only of \'a\' and \'b\'. Returns: int: The minimum number of operations required. left, right = 0, len(s) - 1 operations = 0 while left < right: if s[left] != s[right]: operations += 1 left += 1 right -= 1 return operations"},{"question":"Given a binary tree, where each node\'s value is a digit from 0-9, return all root-to-leaf paths in the tree in the form of a list of strings, where each string represents the sequence of values from the root to a leaf. A leaf is a node with no children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given a binary tree, return all root-to-leaf paths in form of a list of strings, where each string represents the sequence of values from the root to a leaf. if not root: return [] def dfs(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \'->\' if node.left: dfs(node.left, path, paths) if node.right: dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"A company organizes a series of team-building activities for its employees. Each activity is represented by an integer duration in minutes, stored in an array `activities`. To ensure employees have sufficient breaks between consecutive activities, the company needs to schedule a break of exactly `d` minutes after each activity. Given the array `activities` and an integer `d` for the required break duration, compute the total time needed to complete all activities along with the necessary breaks. Note that there is no break required after the last activity. Return the total duration in minutes. Example input: `activities = [30, 45, 60], d = 15` Example output: `165`","solution":"def total_duration(activities, d): Returns the total duration needed to complete all activities including breaks. Parameters: activities (list of int): List of activity durations in minutes. d (int): Duration of the break between consecutive activities in minutes. Returns: int: Total duration in minutes. if not activities: return 0 # Sum of all activities total_time = sum(activities) # Adding breaks between all activities except the last one total_time += d * (len(activities) - 1) return total_time"},{"question":"Given a list of `n` **distinct** strings, each representing a filename in a directory. You need to rename some of the files to avoid conflicts. If a filename already exists, you should append a suffix `(k)` to the filename where `k` is the smallest positive integer such that the new filename does not exist in the list. The filenames only contain lowercase letters, digits, and/or parentheses. Write a function that returns a list of filenames after renaming the files to ensure all filenames are unique.","solution":"def rename_files(filenames): Renames a list of filenames to ensure all filenames are unique by appending a suffix (k) where k is the smallest positive integer that makes the filename unique. Args: filenames (List[str]): A list of filenames. Returns: List[str]: A list of unique filenames after renaming conflicts. name_map = {} result = [] for name in filenames: original_name = name k = 1 while name in name_map: name = f\\"{original_name}({k})\\" k += 1 name_map[name] = 1 result.append(name) return result"},{"question":"You are given a 2D integer matrix `grid` where each cell can either be marked as **0** (representing an empty cell) or **1** (representing an obstacle). You start from the top-left corner of the grid and your goal is to reach the bottom-right corner. You can move in four possible directions: up, down, left, or right, but you cannot move into cells that contain obstacles. Return _the number of distinct paths to reach the bottom-right corner_ from the top-left corner. If there is no valid path, return 0.","solution":"def num_distinct_paths(grid): Returns the number of distinct paths to reach the bottom-right corner from the top-left corner in a grid with obstacles. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) # Initialize a DP table with the same dimensions as grid dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Start point # Fill the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"You are given a rectangular grid filled with **positive** integers. Each cell represents the cost to step on it. You need to find the minimum cost path from the **top-left** corner to the **bottom-right** corner, moving only **down** or **right** at any point in time. Return the **minimum cost** to reach the bottom-right corner of the grid.","solution":"def min_cost_path(grid): Returns the minimum cost path from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"Given a list of integers `arr`, you need to rotate the list to the right by `k` steps, where `k` is a non-negative integer. The rotation implies that the end elements of the list will become the front elements in the new arrangement. Return the rotated list. **Example**: If `arr` = [1, 2, 3, 4, 5, 6, 7] and `k` = 3, the output should be [5, 6, 7, 1, 2, 3, 4]. If `arr` = [-1, -100, 3, 99] and `k` = 2, the output should be [3, 99, -1, -100].","solution":"def rotate_right(arr, k): Rotates the list arr to the right by k steps. Parameters: arr (list): List of integers to rotate. k (int): Number of steps to rotate the list. Returns: list: Rotated list. if not arr: return arr # if arr is empty, return it as is k = k % len(arr) # if k is more than len(arr), reduce it return arr[-k:] + arr[:-k]"},{"question":"Implement a function to delete a node (except the tail) in a singly linked list, given only access to that node. The input will be a class `ListNode` provided to you, which contains an integer value and a reference to the next node. The function should not return anything but should modify the linked list in place.","solution":"class ListNode: def __init__(self, value: int = 0, next_node: \'ListNode\' = None): self.value = value self.next = next_node def delete_node(node: ListNode): Deletes the given node (except the tail) from the singly linked list. The function modifies the linked list in place and does not return anything. if node is None or node.next is None: raise ValueError(\\"Cannot delete the tail node or a null node using this method.\\") node.value = node.next.value node.next = node.next.next"},{"question":"You are given an integer array `nums` and an integer `target`. You need to determine if there exist three distinct elements in `nums` that sum up to `target`. If so, return a list of three integers that add up to `target`; otherwise, return an empty list. You may assume that each input would have exactly one solution. Note that the solution set must not contain duplicate triplets, and the order of the integers in the triplet does not matter. Implement the function `List<Integer> findThreeSum(int[] nums, int target)` that takes the integer array `nums` and the integer `target` as input and returns a list of three integers or an empty list. **Example:** ``` Input: nums = [12, 3, 4, 1, 6, 9], target = 24 Output: [12, 3, 9] Input: nums = [1, 2, 3, 4, 5], target = 9 Output: [1, 3, 5] ```","solution":"def findThreeSum(nums, target): Function to find three distinct elements in nums that add up to target. Returns a list of three such elements or an empty list if no such elements are found. nums.sort() # First, we sort the array to improve the efficiency of the algorithm length = len(nums) for i in range(length - 2): if i > 0 and nums[i] == nums[i-1]: # Skip duplicate elements continue left, right = i + 1, length - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return [nums[i], nums[left], nums[right]] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"You are given an array of integers `arr` and another integer `k`. You need to split the array into exactly `k` non-overlapping, contiguous subarrays such that the sum of the maximum element in each subarray is minimized. Return _the minimized sum of the maximum element in each subarray_. If splitting the array into exactly `k` subarrays is not possible, return `-1`. For example: Given `arr = [1, 2, 3, 4, 5]` and `k = 2`, the function should return `6` because one possible solution is to split `arr` into `[1, 2, 3]` and `[4, 5]`, where the sum of the maximum elements of these subarrays is `3 + 5 = 8`. However, the split `[1, 2, 3, 4]` and `[5]` achieves the minimized sum of `4 + 2 = 6`.","solution":"def minimize_max_sum(arr, k): n = len(arr) if k > n: return -1 # Helper function to check if a given max sum can be achieved by k subarrays def can_split(max_sum): subarray_count = 1 current_sum = 0 for num in arr: if current_sum + num > max_sum: subarray_count += 1 current_sum = num if subarray_count > k: return False else: current_sum += num return subarray_count <= k left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of `orders` represented as an array of strings, where each string represents an order in the format `\\"customer_name item quantity\\"`. The format consists of three fields, where `customer_name` is the name of the customer who placed the order, `item` is the name of the ordered item, and `quantity` is the number of units ordered. Your task is to generate a **summary report** that aggregates the total quantity of each item ordered across all customers. The report should be a list of strings, where each string is in the format `\\"item total_quantity\\"`, sorted alphabetically by `item`. * For example, given `orders = [\\"Alice apples 4\\", \\"Bob bananas 2\\", \\"Alice apples 2\\", \\"Bob apples 1\\", \\"Charlie bananas 5\\"]`, the report should be `[\\"apples 7\\", \\"bananas 7\\"]`. Return _the array representing the **summary report**_ of ordered items.","solution":"def summarize_orders(orders): from collections import defaultdict order_summary = defaultdict(int) for order in orders: customer_name, item, quantity = order.split() order_summary[item] += int(quantity) summary_report = [f\\"{item} {total_quantity}\\" for item, total_quantity in sorted(order_summary.items())] return summary_report"},{"question":"You are tasked with transporting a set of `packages` stored in a warehouse to a delivery point using a robot. The warehouse layout is represented by a grid of size `m * n`, where each cell in the grid can either be empty (`0`), contain an obstacle (`1`), or have a package (`2`). The delivery point is located at cell `[dx, dy]`, and the robot starts at cell `[sx, sy]`. The robot can move up, down, left, or right one cell at a time, but cannot move through obstacles. The robot can carry one package at a time and must transport all packages to the delivery point. Determine if it is possible to deliver all the packages to the delivery point. Return `true` if it is possible to transport all packages to the delivery point, otherwise return `false`.","solution":"from collections import deque def is_possible_to_deliver_all_packages(grid, sx, sy, dx, dy): Determines if it is possible to transport all packages to the delivery point. Args: grid (List[List[int]]): The warehouse layout. sx, sy (int): The starting coordinates of the robot. dx, dy (int): The coordinates of the delivery point. Returns: bool: True if it is possible to transport all packages to the delivery point, False otherwise. def bfs(start, target, grid): Performs BFS from start to target, returns True if path exists, otherwise False rows, cols = len(grid), len(grid[0]) queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == target: return True for nx, ny in ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)): if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] != 1: visited.add((nx, ny)) queue.append((nx, ny)) return False rows, cols = len(grid), len(grid[0]) packages = [(i, j) for i in range(rows) for j in range(cols) if grid[i][j] == 2] for px, py in packages: if not bfs((sx, sy), (px, py), grid) or not bfs((px, py), (dx, dy), grid): return False return True"},{"question":"Given a binary tree, return the sum of the values of the deepest level nodes. The deepest level is defined as the level of the tree with the maximum depth. Each node has the following structure: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` Consider the tree is non-empty and each node contains a positive integer value.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def deepest_level_sum(root): from collections import deque queue = deque([root]) level_sum = 0 while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"Implement a function that takes a string `s` and returns the minimum number of insertions needed to make `s` a palindrome. A palindrome is a string that reads the same forward and backward. For example, given the string `\\"abca\\"`, you can return `1` because by inserting either `\\"b\\"` to form the string `\\"abcba\\"` or `\\"a\\"` to form the string `\\"aabca\\"`, both the resulting strings are palindromes.","solution":"def min_insertion_to_palindrome(s): Returns the minimum number of insertions needed to make the string `s` a palindrome. def lcs(s1, s2): m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] s_reversed = s[::-1] lcs_length = lcs(s, s_reversed) return len(s) - lcs_length"},{"question":"You are given two arrays, `arr1` and `arr2`, each of length `n`. Both arrays are sorted in non-decreasing order. Merge these two sorted arrays into a single sorted array without using extra space for another array. Instead, you should rearrange the elements of `arr1` and `arr2` such that the first `n` smallest elements are in `arr1` and the remaining elements are in `arr2`. Return the modified `arr1` and `arr2`.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays arr1 and arr2 into a single sorted arrangement, where the first n smallest elements are in arr1 and the remaining elements are in arr2. arr1 and arr2 are both of length n. n = len(arr1) i, j, k = 0, 0, n - 1 # Traverse the arrays from the end to the beginning while i <= k and j < n: if arr1[i] < arr2[j]: i += 1 else: arr2[j], arr1[k] = arr1[k], arr2[j] k -= 1 j += 1 # Sort both arrays as the final step arr1.sort() arr2.sort() return arr1, arr2"},{"question":"You are given a grid of size `rows x cols` where each cell contains either a \'0\' or a \'1\'. A region is defined as a group of adjacent cells containing \'1\'. Two cells are considered adjacent if they share a side (top, bottom, left, right). Determine the total number of regions in the grid. Implement a function that accepts this grid as input and returns the count of distinct regions.","solution":"def count_regions(grid): Returns the number of distinct regions in the grid. rows = len(grid) cols = len(grid[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == \'0\': return grid[r][c] = \'0\' # Mark the cell as visited # Visit all adjacent cells dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) region_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\': region_count += 1 dfs(r, c) # Start a DFS to mark all cells in this region return region_count"},{"question":"Given an array of integers `arr` and an integer `target`, return _any two distinct indices_ `i` _and_ `j` _(where_ `i != j` _) of_ `arr` _such that_ `arr[i] + arr[j] == target`. If there are multiple solutions, return any one of them. If no such indices exist, return `[-1, -1]`.","solution":"def two_sum(arr, target): Given an array of integers `arr` and an integer `target`, returns any two distinct indices `i` and `j` such that `arr[i] + arr[j] == target`. If no such indices exist, returns [-1, -1]. value_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in value_to_index: return [value_to_index[complement], i] value_to_index[num] = i return [-1, -1]"},{"question":"Given an array `arr` of positive integers, return _true_ if and only if the number of occurrences of each value in the array is unique. For example: - Input: `arr = [1, 2, 2, 1, 1, 3]` - Output: `true` - Input: `arr = [1, 2]` - Output: `false` - Input: `arr = [3, 5, -2, -3, -3, 2, 1, 0]` - Output: `false`","solution":"def unique_occurrences(arr): Returns True if the number of occurrences of each value in the array is unique. from collections import Counter # Count occurrences of each element count = Counter(arr) # Get set of the counts of each element occurrences = set(count.values()) # If the length of occurrences set is the same as the length of count dict, all values had unique occurrences return len(occurrences) == len(count)"},{"question":"You are given an array of integers `nums` containing `n` elements. Your task is to split the array into two contiguous subarrays such that the sum of elements in both subarrays is equal. Return `true` if such a split is possible, otherwise return `false`. **Note** that each subarray must contain at least one element.","solution":"def can_split_into_equal_sum_subarrays(nums): Returns True if the array can be split into two contiguous subarrays such that the sum of elements in both subarrays is equal. Otherwise, returns False. total_sum = sum(nums) if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 for num in nums: current_sum += num if current_sum == target_sum: return True if current_sum > target_sum: return False return False"},{"question":"You are given a string `s` and an integer `k`. Return _the length of the longest substring of `s` that contains at least `k` repeating characters for each unique character in the substring_. # Guiding points: - You may assume that all lowercase English alphabets (`a` - `z`) are considered for the substring. - The substring should satisfy the condition that every unique character within it must repeat at least `k` times. Example: Input: s = \\"aaabb\\", k = 3 Output: 3 Explanation: The longest substring is \\"aaa\\", as \'a\' repeats 3 times which is at least `k`=3. Input: s = \\"ababbc\\", k = 2 Output: 5 Explanation: The longest substring is \\"ababb\\", as both \'a\' and \'b\' repeat at least 2 times in this substring.","solution":"def longest_substring_with_k_repeats(s, k): Returns the length of the longest substring of s that contains at least k repeating characters for each unique character. def longest_substring_with_k_repeats_recursive(start, end): if end - start < k: return 0 char_count = [0] * 26 for i in range(start, end): char_count[ord(s[i]) - ord(\'a\')] += 1 for mid in range(start, end): if char_count[ord(s[mid]) - ord(\'a\')] < k: next_mid = mid + 1 while next_mid < end and char_count[ord(s[next_mid]) - ord(\'a\')] < k: next_mid += 1 return max(longest_substring_with_k_repeats_recursive(start, mid), longest_substring_with_k_repeats_recursive(next_mid, end)) return end - start return longest_substring_with_k_repeats_recursive(0, len(s))"},{"question":"You are given an integer array `nums` and an integer `k`. Rotate the array to the right by `k` steps, where `k` is non-negative. Return the resulting array after the rotation. For example, if the array is `[1,2,3,4,5,6,7]` and `k` is `3`, the array after rotation should be `[5,6,7,1,2,3,4]`. Note that rotating the array `[1,2,3,4,5,6,7]` by `7` (which is the length of the array) results in the same array.","solution":"def rotate(nums, k): Rotates the array to the right by k steps. Parameters: nums (list of int): The input array to rotate. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. n = len(nums) k = k % n # In case k is larger than the array length return nums[-k:] + nums[:-k]"},{"question":"You are given a list of `n` strings `words` where each string contains only lowercase letters. A string `word1` is a prefix of string `word2` if and only if `word2` can be obtained by appending zero or more letters to the end of `word1`. Return the number of strings in `words` that are prefixes of at least one other string in the list.","solution":"def count_prefixes(words): Returns the number of strings in `words` that are prefixes of at least one other string in the list. count = 0 for i, word1 in enumerate(words): is_prefix = any(word2.startswith(word1) for j, word2 in enumerate(words) if i != j) if is_prefix: count += 1 return count"},{"question":"You are given a binary tree where each node has an integer value. Write a function to determine the sum of all nodes which are at an even level, subtracted by the sum of all nodes which are at an odd level. Consider the root node to be at level 0 (i.e., even level). The tree is represented by a `TreeNode` class where each node contains an integer `val`, a `left` child, and a `right` child. The function should return an integer representing the result of the even level sum minus the odd level sum. Note that the levels alternate between even and odd at each depth of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def even_odd_level_difference(root): if not root: return 0 from collections import deque queue = deque([(root, 0)]) even_sum = 0 odd_sum = 0 while queue: node, level = queue.popleft() if level % 2 == 0: even_sum += node.val else: odd_sum += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return even_sum - odd_sum"},{"question":"You are given a matrix `mat` of size `n x n` filled with integers. Write a function that returns the sum of the elements on the primary diagonal and the secondary diagonal. Note that if the matrix has a common central element, it should only be counted once. For example, if the matrix is: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The primary diagonal is 1, 5, 9 and the secondary diagonal is 3, 5, 7. The common central element is 5, which should only be counted once, so the expected output is 1 + 5 + 9 + 3 + 7 = 25.","solution":"def diagonal_sum(mat): Returns the sum of the elements on the primary diagonal and the secondary diagonal. If the matrix has a common central element, it is counted only once. n = len(mat) total_sum = 0 for i in range(n): total_sum += mat[i][i] total_sum += mat[i][n - 1 - i] if n % 2 == 1: # Subtract the middle element once as it has been added twice. total_sum -= mat[n // 2][n // 2] return total_sum"},{"question":"Given `n` dominoes represented by a 2D integer array `dominoes` where `dominoes[i] = [ti, bi]` indicates the top and bottom numbers, find the minimum number of rotations required so that all the top numbers are the same or all the bottom numbers are the same. A rotation involves swapping `ti` and `bi` of a domino. If it is not possible to make all the numbers on one side the same, return `-1`.","solution":"def minDominoRotations(tops, bottoms): Returns the minimum number of rotations required to make all the top or bottom numbers the same. :param tops: A list of integers representing the top numbers of dominoes. :param bottoms: A list of integers representing the bottom numbers of dominoes. :return: Minimum number of rotations or -1 if impossible. def count_rotations(x): rotations_a, rotations_b = 0, 0 for i in range(len(tops)): if tops[i] != x and bottoms[i] != x: return float(\'inf\') elif tops[i] != x: rotations_a += 1 elif bottoms[i] != x: rotations_b += 1 return min(rotations_a, rotations_b) rotations = min(count_rotations(tops[0]), count_rotations(bottoms[0])) return rotations if rotations != float(\'inf\') else -1"},{"question":"Create a function `get_earliest_meeting_time(intervals)` that takes a list of intervals where each interval is represented as a tuple `(start, end)`. Each interval represents a timeslot during which a person is available for a meeting. The goal is to determine the earliest time at which a meeting can start, given that all people must be available during the entire duration of the meeting. The meeting duration is 1 unit of time. Return the earliest start time if a meeting can be scheduled, or `-1` if no such time exists. Assumptions: 1. Times are represented as integers. 2. The intervals are not necessarily sorted. 3. An interval `(start, end)` means the person is available from `start` (inclusive) to `end` (exclusive). Example: ``` Input: intervals = [(1, 4), (2, 5), (3, 6)] Output: 3 Input: intervals = [(1, 2), (2, 3), (3, 4)] Output: -1 ```","solution":"def get_earliest_meeting_time(intervals): Determines the earliest time at which a 1-unit meeting can start, given that everyone must be available. :param intervals: List of tuples, where each tuple is (start, end) :return: Earliest start time of the meeting or -1 if no such time exists if not intervals: return -1 # Find the latest start time and earliest end time to establish the common available window latest_start = max(interval[0] for interval in intervals) earliest_end = min(interval[1] for interval in intervals) # Check if there is a common available time slot of at least 1 time unit if latest_start < earliest_end: return latest_start else: return -1"},{"question":"You are given two strings, `s1` and `s2`, which contain only lowercase letters. Write a function that determines whether `s2` is a scrambled version of `s1`. A scrambled string is formed by recursively dividing the string into two non-empty substrings and swapping them. The scrambled strings can continue to be divided and swapped at any level. Return _true_ if `s2` is a scrambled string of `s1`, and _false_ otherwise.","solution":"def is_scrambled(s1, s2): Determines whether s2 is a scrambled version of s1. # Base cases if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): # Check if there is a split point i that works in either of two ways # Check without swap if is_scrambled(s1[:i], s2[:i]) and is_scrambled(s1[i:], s2[i:]): return True # Check with swap if is_scrambled(s1[:i], s2[-i:]) and is_scrambled(s1[i:], s2[:-i]): return True return False"},{"question":"Given a 2D grid of size `n x m` representing a forest, where each cell can either be a tree denoted by \'T\' or a clearing denoted by \'.\'. You are in the cell (r_start, c_start) and you want to reach the cell (r_end, c_end). From any cell (r, c), you can move to either of the four adjacent cells: left (r, c-1), right (r, c+1), up (r-1, c), or down (r+1, c) if and only if you do not step into a tree cell (\'T\'). Return the number of distinct paths from (r_start, c_start) to (r_end, c_end) avoiding the trees. If there is no such path, return 0.","solution":"def num_paths(grid, r_start, c_start, r_end, c_end): Returns the number of distinct paths from (r_start, c_start) to (r_end, c_end) in the given grid avoiding the trees (\'T\'). def is_valid(r, c): return 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == \'.\' def dfs(r, c): if (r, c) == (r_end, c_end): return 1 if (r, c) in visited: return 0 visited.add((r, c)) path_count = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dr, dc in directions: nr, nc = r + dr, c + dc if is_valid(nr, nc): path_count += dfs(nr, nc) visited.remove((r, c)) return path_count if not is_valid(r_start, c_start) or not is_valid(r_end, c_end): return 0 visited = set() return dfs(r_start, c_start)"},{"question":"Given a sorted array of distinct integers `nums`, an integer `k`, and an integer `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order. An integer `a` is closer to `x` than an integer `b` if: * `|a - x| < |b - x|`, or * `|a - x| == |b - x|` and `a < b` You may assume `k` is always valid, that is: `1 <= k <= nums.length`. Implement the function `List<Integer> findClosestElements(int[] nums, int k, int x)`, which returns a list of `k` closest integers to `x` in the array.","solution":"from typing import List def findClosestElements(nums: List[int], k: int, x: int) -> List[int]: Finds the k closest integers to x in the array nums. # Sort the `nums` array based on the custom sorting rule nums.sort(key=lambda num: (abs(num - x), num)) # Take the first k elements from the sorted list result = nums[:k] # Return the results sorted in ascending order return sorted(result)"},{"question":"You are given a grid representing a maze with `n` rows and `m` columns. Each cell in the grid can either be an open space (represented by `0`) or a wall (represented by `1`). You can move up, down, left, or right, but cannot move through walls. Given a starting point `(sx, sy)` and an ending point `(ex, ey)`, determine the minimum number of steps needed to reach the ending point from the starting point. If it is not possible to reach the ending point, return `-1`. Write a function: ```python int min_steps_to_exit(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int ```","solution":"from typing import List, Tuple from collections import deque def min_steps_to_exit(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 n, m = len(grid), len(grid[0]) sx, sy = start ex, ey = end # Edge case: if start or end is a wall if grid[sx][sy] == 1 or grid[ex][ey] == 1: return -1 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] queue = deque([(sx, sy, 0)]) # (x, y, steps) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() if (x, y) == (ex, ey): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"You are given a list of strings `strs` where each string consists of lowercase English letters. A string `str` is considered \\"superior\\" if it has the highest number of distinct characters among all the strings in the list. If there is a tie, return the first such string. Write a function `find_superior_string(strs)` that returns the \\"superior\\" string from the list.","solution":"def find_superior_string(strs): Returns the \'superior\' string, which is the string with the highest number of distinct characters from a list of strings. In case of a tie, returns the first such string. if not strs: return \\"\\" superior_string = \\"\\" max_distinct_chars = 0 for s in strs: distinct_chars_count = len(set(s)) if (distinct_chars_count > max_distinct_chars) or (distinct_chars_count == max_distinct_chars and superior_string == \\"\\"): superior_string = s max_distinct_chars = distinct_chars_count return superior_string"},{"question":"**[Question 4]:** Given an integer array `nums` and an integer `target`, return _the **maximum length** of a subarray of `nums` that sums up to `target`_. If there isn\'t one, return `0`. An integer array `nums` and an integer `target` will be provided as input. Find the length of the longest continuous subarray which has a sum equal to `target`.","solution":"def max_subarray_len(nums, target): Returns the maximum length of a subarray of nums that sums up to target. sum_indices = {0: -1} # Dictionary to store the cumulative sum and its index max_length = 0 cumsum = 0 for i, num in enumerate(nums): cumsum += num # Check if there is a previous cumulative sum that when subtracted from cumsum equals the target if (cumsum - target) in sum_indices: max_length = max(max_length, i - sum_indices[cumsum - target]) # Add the cumulative sum to the dictionary if it\'s not already present if cumsum not in sum_indices: sum_indices[cumsum] = i return max_length"},{"question":"Given a list of integers `arr` and an integer `k`, design an algorithm to find the `k`th smallest number in `arr` once sorted in non-descending order. If `k` is less than 1 or greater than the length of the list, return `-1`. The algorithm should aim to have a time complexity better than a straightforward sort. Implement the `Solution` class with the following method: * `int findKthSmallest(int[] arr, int k)`: Takes the list of integers `arr` and an integer `k`, and returns the `k`th smallest number in the list if valid, otherwise returns `-1`.","solution":"import random class Solution: def findKthSmallest(self, arr, k): if k < 1 or k > len(arr): return -1 def quickselect(l, r, k): if l == r: return arr[l] pivot_index = random.randint(l, r) pivot_index = self.partition(arr, l, r, pivot_index) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(l, pivot_index - 1, k) else: return quickselect(pivot_index + 1, r, k) return quickselect(0, len(arr) - 1, k - 1) def partition(self, arr, l, r, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[r] = arr[r], arr[pivot_index] store_index = l for i in range(l, r): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[r], arr[store_index] = arr[store_index], arr[r] return store_index"},{"question":"You are given an array of integers `nums` representing the number of coins in each pile. Create an algorithm to divide all the coins into two groups such that the absolute difference between the total number of coins in each group is minimized. Implement the `Solution` class: * `Solution(int[] nums)` Initializes the object with the array `nums`. * `int minimumDifference()` Returns the minimum possible absolute difference between the sum of the coins in the two groups after dividing the array `nums`.","solution":"class Solution: def __init__(self, nums): self.nums = nums def minimumDifference(self): total_sum = sum(self.nums) n = len(self.nums) dp = [0] * (total_sum // 2 + 1) for num in self.nums: for j in range(total_sum // 2, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) group1 = dp[-1] group2 = total_sum - group1 return abs(group2 - group1)"},{"question":"Given a `m x n` matrix where each cell contains a non-negative integer, write a function `longestIncreasingPath(matrix)` that returns the length of the longest strictly increasing path in the matrix. From each cell, you can move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). Consider the following example: ```python matrix = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] ``` Here, the longest increasing path is `[1, 2, 6, 9]`, so the function would return `4`. Note: - You are expected to use an efficient algorithm based on dynamic programming or depth-first search with memoization. - Think about possible optimizations to handle the constraints provided by typical matrix sizes in real-world applications.","solution":"def longestIncreasingPath(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) memo = [[-1 for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if memo[r][c] != -1: return memo[r][c] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_length = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] > matrix[r][c]: length = 1 + dfs(nr, nc) max_length = max(max_length, length) memo[r][c] = max_length return max_length result = 0 for r in range(rows): for c in range(cols): result = max(result, dfs(r, c)) return result"},{"question":"You are given a list of integers `candies` where `candies[i]` represents the number of candies in the `i-th` bag. A kid can choose at most two bags of candies each time but must leave with at most one bag\'s worth of candies. Implement a function to calculate the maximum number of candies a kid can collect in one go. The function should return the maximum amount of candies that can be collected.","solution":"def max_candies(candies): Given a list of integers representing the number of candies in each bag, returns the maximum number of candies a kid can collect in one go. A kid can choose at most two bags, but they can only leave with at most one bag\'s worth of candies. if not candies: return 0 if len(candies) == 1: return candies[0] candies.sort(reverse=True) return max(candies[0], candies[1])"},{"question":"You are given a **0-indexed** array of integers `nums`. In one operation, you can choose an integer `k` and remove all elements of `nums` that are equal to `k`. Your task is to find the **minimum number of operations** required to make the array `nums` contain **no more than one** distinct element. Return _an integer representing the minimum number of operations needed_.","solution":"from collections import Counter def min_operations_to_one_distinct(nums): Returns the minimum number of operations required to make the array nums contain no more than one distinct element. if not nums: return 0 # Count the frequency of each number in the array freq = Counter(nums) # Find the count of the most frequent element most_frequent_count = max(freq.values()) # Minimum operations are needed to remove all elements except the most frequent one return len(nums) - most_frequent_count"},{"question":"You are given a list of strings `textQuoteStore` containing short quotes from various books and a string `quote` representing the text of a new quote. Your task is to determine if the new quote is a *subsequence* of any of the existing quotes in `textQuoteStore`. A `subsequence` is a sequence that can be derived from another sequence by deleting zero or more elements without changing the order of the remaining elements. Return a list of indexes of the quotes in `textQuoteStore` where the `quote` is a subsequence. If the `quote` is not a subsequence of any quotes in the store, return an empty list.","solution":"def is_subsequence(s, t): Helper function to determine if the string s is a subsequence of t. iter_t = iter(t) return all(char in iter_t for char in s) def subsequence_indexes(textQuoteStore, quote): Returns a list of indexes of the quotes in textQuoteStore where \'quote\' is a subsequence. result = [] for i, text in enumerate(textQuoteStore): if is_subsequence(quote, text): result.append(i) return result"},{"question":"You are provided with a list of non-negative integers representing the amount of money of each house in a street. A thief wants to steal the maximum amount of money, but he cannot rob two adjacent houses because the security system will trigger an alarm. Implement a function `maxRobbedAmount(houses: List[int]) -> int` that returns the maximum amount of money the thief can rob without triggering the alarm.","solution":"def maxRobbedAmount(houses): Returns the maximum amount of money the thief can rob without triggering the alarm. :param houses: List of non-negative integers representing the amount of money on each house :return: int, the maximum amount of money that can be robbed if not houses: return 0 elif len(houses) == 1: return houses[0] n = len(houses) dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"You are given a list of integers `nums` which represents the sequential execution time of certain tasks. Additionally, you have a **time limit** `limit` representing the maximum execution time allowed for a single continuous segment of tasks. Your goal is to find the length of the longest subsequence of consecutive tasks such that the total execution time of that subsequence does not exceed `limit`. If no such subsequence exists, return `0`.","solution":"def longest_subsequence(nums, limit): max_length = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > limit: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given two strings `str1` and `str2`, determine if they are **\\"one edit\\"** away from being the same. An edit is defined as either inserting a character, removing a character, or replacing a character in one of the strings. Both strings only contain lowercase English letters. Return `true` if `str1` and `str2` are one edit away from being the same, otherwise return `false`.","solution":"def is_one_edit_away(str1, str2): Determine if two strings are one edit away from being the same. len1, len2 = len(str1), len(str2) # If the length difference is greater than 1, they can\'t be one edit away. if abs(len1 - len2) > 1: return False # Identify the longer and shorter strings. if len1 > len2: longer, shorter = str1, str2 else: longer, shorter = str2, str1 index_longer = index_shorter = 0 found_difference = False while index_longer < len(longer) and index_shorter < len(shorter): if longer[index_longer] != shorter[index_shorter]: if found_difference: return False found_difference = True # If the lengths are the same, move both indices. if len1 == len2: index_shorter += 1 else: index_shorter += 1 index_longer += 1 return True"},{"question":"Implement a function, `findPairsWithSum`, that takes a list of integers `nums` and an integer `target` as inputs. The function should return a list of all unique pairs `[a, b]` such that `a + b == target`. Each pair should be sorted in non-descending order, and the overall list of pairs should be sorted in non-descending order based on each pair\'s first element. If there are no such pairs, return an empty list. Ensure the function handles both positive and negative integers in the input list appropriately.","solution":"def findPairsWithSum(nums, target): Returns a list of unique pairs [a, b] such that a + b == target nums = sorted(nums) pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(list(pairs))"},{"question":"You are given a list of events represented as intervals. Each interval is a pair of integers `[start, end]` where `start` is the starting time and `end` is the ending time of the event. You need to determine the minimum number of conference rooms required to host all events. If two events `A` and `B` overlap, they cannot be hosted in the same room. Write a function `minConferenceRooms(events: List[Tuple[int, int]]) -> int` that takes a list of intervals and returns the minimum number of conference rooms required. For example, given the events: `[[0, 30], [5, 10], [15, 20]]`, the function should return `2`. Note: The intervals are inclusive of the starting time and exclusive of the ending time.","solution":"from typing import List, Tuple import heapq def minConferenceRooms(events: List[Tuple[int, int]]) -> int: if not events: return 0 # Sort the events by start time events.sort(key=lambda x: x[0]) # Create a min heap to track the end times of ongoing events min_heap = [] # Start by adding the first event\'s end time to the heap heapq.heappush(min_heap, events[0][1]) for i in range(1, len(events)): # Compare the start time of the current event with the earliest end time if events[i][0] >= min_heap[0]: # If the current event starts after the earliest event ends, remove the earliest event heapq.heappop(min_heap) # Add the current event\'s end time to the heap heapq.heappush(min_heap, events[i][1]) # The size of the heap is the minimum number of conference rooms required return len(min_heap)"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. A **range update** is defined as incrementing every element in a subarray of `nums` by a given value. More formally, you are given a list `updates` where each `update[j]` contains three integers `[l, r, v]`, which means increment each `nums[i]` by `v` for all `l <= i <= r`. Your task is to return the maximum value of the modified array `nums` after performing all updates. Given `nums`, `k`, and a list of `updates`, return _the **maximum value** of the array_ `nums` after `k` range updates have been applied.","solution":"def max_array_value(nums, k, updates): Returns the maximum value of the modified array nums after k range updates. Parameters: nums (list of int): The initial array of integers. k (int): The number of updates to be applied. updates (list of list of int): Each update is a list [l, r, v] meaning increment each nums[i] by v for all l <= i <= r. Returns: int: The maximum value of the array nums after all updates. n = len(nums) delta = [0] * (n + 1) for l, r, v in updates[:k]: delta[l] += v if r + 1 < n: delta[r + 1] -= v running_sum = 0 for i in range(n): running_sum += delta[i] nums[i] += running_sum return max(nums)"},{"question":"A matrix is considered a **sparse matrix** if most of its elements are zero. Given an `m x n` matrix `mat` with integers, return `true` if the matrix is sparse, and `false` otherwise. A matrix is defined as sparse if more than 70% of its elements are zero.","solution":"def is_sparse_matrix(mat): Returns True if the matrix is sparse (more than 70% of its elements are zero), otherwise False. if not mat: return False # An empty matrix is not considered sparse total_elements = len(mat) * len(mat[0]) zero_count = sum(row.count(0) for row in mat) return (zero_count / total_elements) > 0.7"},{"question":"You are given an **m x n** matrix `grid` where each cell contains a non-negative integer and each row and column of the matrix is sorted in **non-decreasing order**. You are also given an integer `k`. Find the kth smallest element in the matrix. Return _the kth smallest element in the given matrix `grid`_.","solution":"import heapq def kth_smallest(matrix, k): Returns the kth smallest element in a sorted m x n matrix. min_heap = [] for i in range(min(len(matrix), k)): heapq.heappush(min_heap, (matrix[i][0], i, 0)) count = 0 while min_heap: element, r, c = heapq.heappop(min_heap) count += 1 if count == k: return element if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c+1], r, c+1))"},{"question":"You are given a list of transactions, where each transaction is represented as a string in the format \\" \\" where `<name>` denotes the name of the person, `<time>` denotes the time of the transaction in minutes since some arbitrary point in the past, and `<amount>` denotes the amount of the transaction in dollars. You need to identify and return a list of all transactions that are considered \\"invalid.\\" A transaction is considered invalid if: 1. The amount exceeds 1000, or, 2. There are multiple transactions by the same person within a 60-minute window (including the current transaction). Return the transactions that are invalid in the order they appear in the input list.","solution":"def find_invalid_transactions(transactions): Returns a list of invalid transactions based on the given rules. result = [] transactions_data = [t.split() for t in transactions] for i, transaction in enumerate(transactions_data): name, time, amount = transaction time = int(time) amount = int(amount) # Rule 1: Amount exceeds 1000 if amount > 1000: result.append(transactions[i]) continue # Rule 2: Multiple transactions by the same person within a 60-minute window for j, other_transaction in enumerate(transactions_data): if i != j and other_transaction[0] == name: other_time = int(other_transaction[1]) if abs(time - other_time) <= 60: result.append(transactions[i]) break return result"},{"question":"You are given a binary tree with `n` nodes. Each node has a value, which is a single digit (0-9). Let\'s define the \\"path value\\" of a path from the root to a leaf node as the concatenation of the node values along the path, interpreted as an integer. Return _the sum of all possible path values from the root to the leaf nodes_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Calculate the sum of all path values from the root to leaf nodes of a binary tree. def dfs(node, current_value): if not node: return 0 current_value = current_value * 10 + node.val # if reached leaf node, return the path value so far if not node.left and not node.right: return current_value # recursively calculate for left and right subtrees left_sum = dfs(node.left, current_value) right_sum = dfs(node.right, current_value) return left_sum + right_sum return dfs(root, 0)"},{"question":"You are given an array of integers `arr` and an integer `m`. You need to rearrange the elements of `arr` such that the difference between the maximum sum of any subarray of length `m` and the minimum sum of any subarray of length `m` is minimized. Return _the minimized difference_.","solution":"def minimize_subarray_diff(arr, m): Returns the minimized difference between the maximum and minimum sums of any subarray of length m. arr.sort() min_diff = float(\'inf\') for i in range(len(arr) - m + 1): current_diff = arr[i + m - 1] - arr[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"Given a string `str`, find the length of the longest substring without repeating characters. Implement a function that takes a string as input and returns the length of such a substring. The solution should prioritize efficiency, aiming for a time complexity of O(n). For example, given the string `\\"abcabcbb\\"`, the longest substring without repeating characters is `\\"abc\\"`, so the function should return `3`. For the string `\\"bbbbb\\"`, where the longest substring is just `\\"b\\"`, the function should return `1`.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest_length = max(longest_length, i - start + 1) return longest_length"},{"question":"Write a function `maxDistToClosest` that, given a list of integers `seats` where `seats[i]` is `0` if it is empty, and `1` if it is occupied, returns _the maximum distance to the closest person_. The algorithm should account for edge cases where multiple seating segments are considered. Note that the list will always have at least one empty seat and one occupied seat.","solution":"def maxDistToClosest(seats): Returns the maximum distance to the closest person. max_dist = 0 last_occupied = -1 for i, seat in enumerate(seats): if seat == 1: if last_occupied == -1: max_dist = i else: max_dist = max(max_dist, (i - last_occupied) // 2) last_occupied = i max_dist = max(max_dist, len(seats) - 1 - last_occupied) return max_dist"},{"question":"You are given three vectors in a 2D plane: `A`, `B`, and `C`, represented by their endpoints as tuples of integers. Each vector can be described as starting from the origin (0,0) and ending at the point specified by the coordinate tuples. A vector is represented as a tuple `(x, y)`, where `x` and `y` are the coordinates of the endpoint. Return `true` if these three vectors can form a triangle, and `false` otherwise. To form a triangle, the vectors should not be collinear (i.e., no two vectors should lie on the same line passing through the origin).","solution":"def are_vectors_forming_triangle(A, B, C): Determines if three vectors can form a triangle. Parameters: A, B, C : tuple Endpoints of the vectors represented as tuples (x, y). Returns: bool True if the vectors can form a triangle, False otherwise. def area_of_triangle(A, B, C): Calculates the area of the triangle formed by vectors A, B, and C using the determinant method. Parameters: A, B, C : tuple Endpoints of the vectors represented as tuples (x, y). Returns: float The area of the triangle. return 0.5 * abs(A[0]*(B[1] - C[1]) + B[0]*(C[1] - A[1]) + C[0]*(A[1] - B[1])) # Calculate the area of the triangle formed by the vectors A, B, and C area = area_of_triangle(A, B, C) # If the area is zero, the vectors are collinear and cannot form a triangle return area != 0"},{"question":"Given a list of non-negative integers `nums`, you are tasked with sorting them in such a way that the joined combination of the numbers forms the largest possible integer. For example, given the list `[3, 30, 34, 5, 9]`, the best order would be `[9, 5, 34, 3, 30]`, and the result would be the concatenation `\\"9534330\\"`. You need to return the final string result. Note that the digits in a number are compared individually and should account for cases like `(54, 5)` where `545 > 554` thus `54` should come before `5`. You may assume all inputs are non-negative integers and that the result will not have leading zeros unless the input is a single zero.","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of non-negative integers nums, sort them such that the combination of the sorted integers form the largest number and return it as a string. The sorting order is determined by comparing the concatenated results. def compare(x, y): # Custom comparator for sorting if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert all numbers to strings nums_str = list(map(str, nums)) # Sort using the custom comparator sorted_nums = sorted(nums_str, key=cmp_to_key(compare)) # Join the sorted numbers to form the largest number largest_num = \'\'.join(sorted_nums) # Special case: when the largest number is \'0\' if largest_num[0] == \'0\': return \'0\' return largest_num"},{"question":"You are given a **0-indexed** integer array `marks` where each element represents the marks obtained by a student in a particular subject. You need to find the **closest greater** element for each student’s marks. The **closest greater** element for a student’s mark at index `i` is defined as the first greater element that appears **to the right** of the current mark in the array. If no such element exists for `index i`, you should return `-1` for that student. Return the result as an array where each position `i` contains either the closest greater element or `-1` if no such element exists.","solution":"def closest_greater_element(marks): Returns the closest greater element for each student\'s marks. Args: marks (list of int): List of integer marks obtained by students. Returns: list of int: List of the closest greater elements or -1 if no such element exists. n = len(marks) answer = [-1] * n stack = [] # This will store the indices of the marks array for i in range(n): # While stack is not empty and the current mark is greater than the mark at the index stored at the top of the stack while stack and marks[i] > marks[stack[-1]]: index = stack.pop() answer[index] = marks[i] stack.append(i) return answer"},{"question":"You are given a string `s` that contains only lowercase alphabetical characters. A character is considered \'happy\' in the string `s` if the same character appears consecutively (in a continuous block). For example, in the string `aabbcc`, the characters \'a\', \'b\', and \'c\' are all happy. Implement a function that returns the length of the longest group of consecutive \'happy\' characters in the string. If the string is empty, the function should return 0. Implement the `HappyCharacters` class: * `HappyCharacters(String s)` Initializes the object with the string `s`. * `int longestHappyGroup()` Returns the length of the longest group of consecutive \'happy\' characters in `s`. If the string is empty, return `0`.","solution":"class HappyCharacters: def __init__(self, s): Initializes the HappyCharacters object with the string s. self.s = s def longestHappyGroup(self): Returns the length of the longest group of consecutive \'happy\' characters in s. If the string is empty, returns 0. if not self.s: return 0 max_length = 1 current_length = 1 for i in range(1, len(self.s)): if self.s[i] == self.s[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given an array of integers `arr`, find the integer that appears more than ⌊n / 2⌋ times, where `n` is the array length. Assume that the majority element always exists in the array.","solution":"def majority_element(arr): Finds the majority element in the array that appears more than ⌊n / 2⌋ times. Assumes the majority element always exists. :param arr: List[int] - The input array of integers :return: int - The majority element count = 0 candidate = None for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"Given an `n` x `n` matrix where each of the rows and columns is sorted in ascending order, write a function to determine the k-th smallest element in the matrix. Assume k is always valid, 1 ≤ k ≤ n². The matrix must be navigated such that the solution retains the sorted order property for an efficient search.","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in the matrix. n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(k, n)): # We only need to consider at most the first k rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min from heap k times num = 0 for _ in range(k): num, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return num"},{"question":"You are given a `rows x cols` binary matrix `mat`, where `1` represents a wall and `0` represents an open space. Your task is to find the shortest distance from a given starting cell `(start_row, start_col)` to a target cell `(target_row, target_col)` such that you can only move in four possible directions (up, down, left, right). You cannot move through walls, and you must stay within the grid boundaries. If there is no valid path from the starting cell to the target cell, return `-1`. Return _the shortest distance from the start cell to the target cell, or `-1` if no path exists._","solution":"from collections import deque def shortest_path_binary_matrix(mat, start, target): Finds the shortest distance from start cell to target cell in binary matrix. :param mat: List[List[int]], a binary matrix where 1 represents wall and 0 represents open space. :param start: Tuple[int, int], the starting position (start_row, start_col). :param target: Tuple[int, int], the target position (target_row, target_col). :return: int, the shortest distance from start to target, or -1 if no path exists. rows, cols = len(mat), len(mat[0]) start_row, start_col = start target_row, target_col = target # Validate start and target positions if mat[start_row][start_col] == 1 or mat[target_row][target_col] == 1: return -1 # Initialize the queue for BFS and the set for visited nodes queue = deque([(start_row, start_col, 0)]) visited = set() visited.add((start_row, start_col)) # BFS to find the shortest path directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, down, left, right while queue: current_row, current_col, distance = queue.popleft() # Check if we have reached the target if (current_row, current_col) == (target_row, target_col): return distance # Explore all possible moves for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and mat[new_row][new_col] == 0: queue.append((new_row, new_col, distance + 1)) visited.add((new_row, new_col)) # If we haven\'t found the target, return -1 return -1"},{"question":"You are given a string `s` and a string `t`. The string `s` is generated by randomly shuffling the letters of `t` and then adding one additional letter at a random position in the result. Return that **additional** letter added to `s`. Note that strings `s` and `t` will only contain lowercase English letters.","solution":"def find_the_difference(s, t): Returns the additional letter that was added to `s`. `s` is generated by shuffling the letters of `t` and adding one additional letter. # Using XOR operation to find the additional letter result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"Given an array of integers `nums`, find the length of the longest subarray where all its elements are distinct. You need to return the length of this subarray. A subarray is defined as a contiguous sequence of elements within an array.","solution":"def length_of_longest_subarray(nums): Returns the length of the longest subarray with all distinct elements. :param nums: List of integers :return: Length of the longest subarray with all distinct elements # Dictionary to store last position of each element last_seen = {} start = 0 max_length = 0 for end in range(len(nums)): if nums[end] in last_seen: # Move the start pointer to the right of the last occurrence of nums[end] start = max(start, last_seen[nums[end]] + 1) last_seen[nums[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an integer array `arr` of size `n`, and an integer `d`, you need to find the **maximum sum** of a **subsequence** of `arr` such that the difference between the indices of any two consecutive elements in this subsequence is at least `d`. A **subsequence** is a sequence derived from the array by deleting some or none of the elements without changing the order of the remaining elements. Return _the maximum sum of such a subsequence_.","solution":"def max_subsequence_sum(arr, d): Finds the maximum sum of a subsequence of array `arr` such that the difference between the indices of any two consecutive elements in this subsequence is at least `d`. Parameters: arr (list): The input array of integers d (int): The minimum allowed difference between indices of consecutive elements in the subsequence Returns: int: The maximum sum of such a subsequence n = len(arr) if n == 0: return 0 # Initialize a dp array where dp[i] is the maximum sum of subsequence ending at index i dp = [0] * n # Initialize max_sum to the highest value in arr max_sum = max(arr) for i in range(n): dp[i] = arr[i] # The subsequence starting and ending at i if i >= d: # Update dp[i] by adding the maximum dp[j] (0 <= j <= i-d) dp[i] += max(dp[j] for j in range(i - d + 1)) # Update the overall maximum sum max_sum = max(max_sum, dp[i]) return max_sum"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to determine the length of the shortest substring that can be removed from `s` such that the resulting string contains no consecutive characters that are the same. If the string already has no such consecutive characters, return `0`. If it is impossible to achieve this by removing exactly one substring, return `-1`.","solution":"def min_removal_to_avoid_consecutive_duplicates(s): n = len(s) # Check if string already meets the requirement if all(s[i] != s[i + 1] for i in range(n - 1)): return 0 # Try to find the minimum length substring to remove for length in range(1, n): for i in range(n - length + 1): new_s = s[:i] + s[i + length:] if all(new_s[j] != new_s[j + 1] for j in range(len(new_s) - 1)): return length # If no valid removal found, return -1 return -1"},{"question":"Given a list of non-negative integers representing the heights of buildings in a line, determine the amount of water it can trap after raining. Return the total amount of water trapped. You need to solve this problem in `O(n)` time complexity. For example: Given heights = `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the amount of water trapped is `6`.","solution":"def trap(height): Return the total amount of water that can be trapped after raining. :param height: List[int] - List of non-negative integers representing the heights of buildings :return: int - Total amount of water trapped if not height: return 0 n = len(height) left_max, right_max = [0] * n, [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given the root of a binary search tree (BST), find the node with the smallest value greater than or equal to a given number k. If such a node does not exist, return -1. The solution must maintain the properties of the BST and should be efficient in terms of time complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_min_greater_or_equal(root, k): Finds the node with the smallest value greater than or equal to k in a BST. If such a node does not exist, returns -1. current = root result = -1 while current: if current.val >= k: result = current.val current = current.left else: current = current.right return result"},{"question":"You are given a linked list `head` where each node contains an integer value. Find the starting node of the cycle, if a cycle exists. If there is no cycle, return `null`. A cycle is a path that starts and ends at the same node. Note: Do not modify the linked list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects the start of the cycle in a linked list, if it exists. Args: head (ListNode): Head of the linked list. Returns: ListNode: Node where the cycle begins, or None if there is no cycle. if not head: return None slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle detected return None # Start from the head and the meeting point to find the cycle start slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given a binary tree where each node can have a value of either `0` or `1`. *Prune* the tree so that subtrees containing all `0` nodes are removed. Return the **root** of the pruned tree. Implement the pruning process efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root): Prunes the binary tree by removing subtrees that contain all 0s. def prune(node): if not node: return None node.left = prune(node.left) node.right = prune(node.right) if node.val == 0 and not node.left and not node.right: return None return node return prune(root)"},{"question":"You are given a list of integers `arr` representing the number of coins in each pile. Every time you must pick any 3 piles of coins and remove one coin from each of the three piles. Your goal is to minimize the total number of moves necessary to complete this process, i.e., remove all coins from all piles. Return _the minimum number of moves required to remove all coins from all piles, or `-1` if it is not possible to remove all coins using the given rule._","solution":"def min_moves_to_remove_coins(arr): Returns the minimum number of moves required to remove all coins from all piles. Returns -1 if it is not possible to remove all coins using the rule. # The total number of coins total_coins = sum(arr) # If total_coins is not divisible by 3, it is impossible to remove all coins if total_coins % 3 != 0: return -1 # Otherwise, the minimum number of moves required return total_coins // 3"},{"question":"Given a string `s` consisting of lowercase English letters, determine if it\'s possible to swap non-overlapping substrings of equal length to transform `s` into a palindrome. Return `true` if it\'s possible, and `false` otherwise.","solution":"def can_form_palindrome(s): Determines whether it\'s possible to swap non-overlapping substrings of equal length to transform the string `s` into a palindrome. from collections import Counter # Count character frequencies freq = Counter(s) # Number of characters with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"You have a nested list `nestedList` that represents a list of integers with several levels of nested sublists. Each integer in the nested list is enclosed in square brackets, zero or more times. Your task is to find the sum of the integers in the list, weighted by their depth. The depth of a number is how many levels of nested sublists it is contained in. Return the weighted sum of all numbers in the nested list. For example, given the list `nestedList = [[1,1],2,[1,1]]`, the numbers at depth 1 are `[2]` and the numbers at depth 2 are `[1, 1, 1, 1]`, so the weighted sum is `2*1 + 1*2 + 1*2 + 1*2 + 1*2 = 10`. Another example is: `nestedList = [1,[4,[6]]]`, the numbers at depth 1 are `[1]`, the numbers at depth 2 are `[4]` and the numbers at depth 3 are `[6]`, so the weighted sum is `1*1 + 4*2 + 6*3 = 27`.","solution":"def depth_sum(nestedList): Calculates the weighted sum of all numbers in the nested list based on their depth levels. def helper(nList, depth): result = 0 for element in nList: if isinstance(element, int): result += element * depth else: result += helper(element, depth + 1) return result return helper(nestedList, 1)"},{"question":"You are given a list of `n` distinct integers, representing the scores of `n` players in a game. Your task is to find the player whose score is closest to the average score of all players. If there are multiple players with scores equally close to the average, return the lowest score among them. Write a function `find_closest_to_average(scores: List[int]) -> int` to accomplish this.","solution":"from typing import List def find_closest_to_average(scores: List[int]) -> int: Given a list of distinct integers representing scores of players in a game, this function returns the score closest to the average score. If there are multiple scores equally close to the average, return the lowest score among them. n = len(scores) if n == 0: raise ValueError(\\"The list of scores should not be empty\\") average_score = sum(scores) / n closest_score = min(scores, key=lambda x: (abs(x - average_score), x)) return closest_score"},{"question":"You are given an array of integers `heights` and a positive integer `k`. Each element in `heights` represents the height of a building. You want to check if it is possible to start from the first building and reach the last building by jumping between buildings. You can jump from building `i` to building `j` if and only if `|heights[i] - heights[j]| <= k`. Return _a boolean value_ that indicates whether you can reach the last building from the first building. If it\'s possible, return `true`; otherwise, return `false`.","solution":"def can_reach_end(heights, k): n = len(heights) if n == 1: return True # Single building, trivially true dp = [False] * n # dp[i] means if we can reach building i dp[0] = True for i in range(n): if dp[i]: # If building i is reachable for j in range(i + 1, n): if abs(heights[i] - heights[j]) <= k: dp[j] = True # Mark building j as reachable return dp[-1] # Can we reach the last building?"},{"question":"You are implementing a task management system where tasks can be added with a specific priority, completed, or retrieved in their priority order. Each task is represented by an integer ID and a priority level, where a higher numeric value indicates a higher priority. Implement the `TaskManager` class with the following methods: * `TaskManager()` Initializes the task manager. * `void addTask(int taskId, int priority)` Adds a task with the given `taskId` and `priority` to the system. * `void completeTask(int taskId)` Removes the task with the specified `taskId` from the system if it exists. * `List<Integer> getTasksByPriority()` Returns a list of task IDs sorted by priority in descending order. If two tasks have the same priority, they should appear in the order they were added.","solution":"class TaskManager: def __init__(self): self.tasks = [] def addTask(self, taskId, priority): Add a task with the specified taskId and priority. :param taskId: Task Identifier :param priority: Task Priority self.tasks.append((priority, taskId)) def completeTask(self, taskId): Complete and remove a task from the system based on taskId. :param taskId: Task Identifier self.tasks = [task for task in self.tasks if task[1] != taskId] def getTasksByPriority(self): Retrieve tasks sorted by priority in descending order. :return: List of task IDs sorted by priority. return [taskId for priority, taskId in sorted(self.tasks, key=lambda x: (-x[0], self.tasks.index(x)))]"},{"question":"Given a 2D integer array `matrix`, return _the number of_ **distinct islands**_ in the matrix. An island is a region of connected `1`s (vertically or horizontally connected) surrounded by `0`s. Two islands are considered distinct if one island cannot be translated (shifted) to match the other island\'s shape exactly. Return an integer representing the number of such distinct islands in the matrix._","solution":"def numDistinctIslands(matrix): Returns the number of distinct islands in the matrix. An island is a region of connected 1s, and two islands are considered distinct if one cannot be translated to match the other\'s shape exactly. if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) visited = set() distinct_islands = set() def dfs(r, c, origin): stack = [(r, c)] island = [] while stack: x, y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) stack.append((nx, ny)) island.append((nx - origin[0], ny - origin[1])) return tuple(sorted(island)) for r in range(rows): for c in range(cols): if matrix[r][c] == 1 and (r, c) not in visited: visited.add((r, c)) island_shape = dfs(r, c, (r, c)) distinct_islands.add(island_shape) return len(distinct_islands)"},{"question":"In a table named `employees`, there are three columns: `employee_id` (integer), `manager_id` (integer), and `position_level` (integer). The `employee_id` represents the unique ID of an employee, the `manager_id` is the ID of the employee\'s direct manager, and the `position_level` indicates the employee\'s level in the company hierarchy, with higher numbers representing higher levels in the hierarchy. Write a SQL query to find all employees with the second-highest `position_level`. Return the result sorted by `employee_id` in ascending order.","solution":"def get_second_highest_position_level_employees(): SQL query to find all employees with the second-highest position level. query = SELECT employee_id FROM employees WHERE position_level = ( SELECT DISTINCT position_level FROM employees ORDER BY position_level DESC LIMIT 1 OFFSET 1 ) ORDER BY employee_id ASC; return query"},{"question":"A company organizes a hackathon where teams of developers solve various coding problems. Each team is given a set of `N` different challenges to solve. Teams are scored based on the number of challenges they solve and the total time they take to solve them. Each challenge `i` takes `time[i]` minutes to solve. The objective is to find the **maximum number of challenges** a team can solve within a given number of `T` minutes. Given an integer array `time` and an integer `T`, return the maximum number of challenges the team can solve without exceeding the `T` minutes limit.","solution":"def max_challenges(time, T): Returns the maximum number of challenges a team can solve without exceeding T minutes. Parameters: time (list of int): Time required to solve each challenge. T (int): The maximum allowed time. Returns: int: The maximum number of challenges. sorted_time = sorted(time) total_time = 0 challenges_solved = 0 for t in sorted_time: if total_time + t <= T: total_time += t challenges_solved += 1 else: break return challenges_solved"},{"question":"Given a string `s` and a character `c`, return an array of integers representing the shortest distance from each character in the string `s` to the character `c`. If the character `c` is not present in the string, return an empty array. The function should be implemented as `int[] shortestToChar(String s, char c)`.","solution":"def shortestToChar(s, c): Given a string `s` and a character `c`, return an array of integers representing the shortest distance from each character in the string `s` to the character `c`. If the character `c` is not present in the string, return an empty array. if c not in s: return [] n = len(s) distances = [float(\'inf\')] * n # Pass 1: Traverse from left to right prev_pos = float(\'-inf\') for i in range(n): if s[i] == c: prev_pos = i distances[i] = i - prev_pos # Pass 2: Traverse from right to left prev_pos = float(\'inf\') for i in range(n-1, -1, -1): if s[i] == c: prev_pos = i distances[i] = min(distances[i], prev_pos - i) return distances"},{"question":"You are given two strings, `s1` and `s2`, both of length `n`. You want to transform `s1` into `s2` using the minimum number of operations where in each operation, you can select any character in `s1` and change it to any other character. Write a function that returns the minimum number of operations required to transform `s1` into `s2`. Consider that both strings `s1` and `s2` contain only lowercase English letters.","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. Each operation consists of selecting any character in s1 and changing it to any other character. if len(s1) != len(s2): raise ValueError(\\"Both strings must be of the same length\\") # Count the number of characters that are different between s1 and s2 different_count = sum(1 for ch1, ch2 in zip(s1, s2) if ch1 != ch2) return different_count"},{"question":"You are given a positive integer `n`. You can perform the following operations any number of times: - If `n` is even, divide `n` by 2. - If `n` is odd, subtract 1 from `n`. Return _the minimum number of operations required to reduce `n` to 1_.","solution":"def min_operations_to_one(n): Given a positive integer n, return the minimum number of operations required to reduce n to 1. If n is even, divide n by 2. If n is odd, subtract 1 from n. operations = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = n - 1 operations += 1 return operations"},{"question":"Given an integer array `arr` and an integer `k`, you need to find the **k-th missing positive number** starting from the beginning of the array in a sequential manner. An element `m` is considered missing if it is not present in `arr` up to the `k-th` missing element. Note that the array is unsorted, and your solution should consider all positive integers in sequence (starting from 1) that do not appear in `arr`. For example, if `arr = [2, 3, 4]` and `k = 1`, the first missing positive number is `1`. If `k = 3`, the third missing positive number is `6`. Implement a function that returns the k-th missing positive number.","solution":"def find_kth_missing_positive(arr, k): Finds the k-th missing positive number from the array `arr`. Parameters: arr (list): List of integers k (int): The k-th missing positive number to find Returns: int: The k-th missing positive number arr_set = set(arr) missing_count = 0 current_number = 1 while missing_count < k: if current_number not in arr_set: missing_count += 1 if missing_count == k: return current_number current_number += 1"},{"question":"You are working on a graphics processing program and are given an `m x n` 2D integer grid `image` where each integer represents a pixel\'s color value. The `image` contains three color values: `0` (white), `1` (black), and `2` (gray). You need to implement a flood fill operation. Given a starting point `[sr, sc]` representing the row and column indices of the starting pixel for the flood fill, and a replacement color `newColor`, fill all connected pixels that have the same initial color as the starting pixel with `newColor`. A pixel is connected if it is directly adjacent to another pixel vertically or horizontally (not diagonally). Return _the image after performing the flood fill._","solution":"def flood_fill(image, sr, sc, newColor): Perform a flood fill on the image starting from the given starting point and replacing the color of connected pixels with the new color. :param image: List[List[int]] - 2D grid representing the image :param sr: int - starting row index :param sc: int - starting column index :param newColor: int - the new color to apply :return: List[List[int]] - the image after flood fill rows, cols = len(image), len(image[0]) oldColor = image[sr][sc] if oldColor == newColor: return image def fill(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or image[r][c] != oldColor: return image[r][c] = newColor fill(r + 1, c) fill(r - 1, c) fill(r, c + 1) fill(r, c - 1) fill(sr, sc) return image"},{"question":"Write a function that takes in two arrays, `startTimes` and `endTimes`, each of length `n`, and an integer `queryTime`, and returns the number of students doing their homework at `queryTime`. The `i-th` student started doing their homework at `startTimes[i]` and finished at `endTimes[i]`. A student is considered to be doing homework at `queryTime` if `startTimes[i] <= queryTime <= endTimes[i]`.","solution":"def studentsDoingHomework(startTimes, endTimes, queryTime): Returns the number of students doing their homework at queryTime. :param startTimes: List of integers, each representing the start time of homework for a student :param endTimes: List of integers, each representing the end time of homework for a student :param queryTime: An integer representing the specific time to query :return: The number of students doing their homework at queryTime count = 0 for start, end in zip(startTimes, endTimes): if start <= queryTime <= end: count += 1 return count"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find two distinct elements within the array that sum up to the target value. Return an array of the two indices of the elements that sum up to `target`. You can assume that each input would have exactly one solution, and you may not use the same element twice. Given the array `nums` and an integer `target`, write a function to return the indices of the two numbers such that they add up to the `target`.","solution":"def two_sum(nums, target): Returns indices of the two numbers that add up to target. num_map = {} for index, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], index] num_map[num] = index"},{"question":"You are given two integer arrays `startTime` and `endTime`, each of length `n`, where `startTime[i]` and `endTime[i]` denote the start and end times of the `i-th` job. All `startTime` and `endTime` values are integers. The jobs are not sorted in any particular order and may overlap. Write a function to find the maximum number of non-overlapping jobs from the given arrays. Return _an integer_ representing the maximum number of non-overlapping jobs that can be selected.","solution":"def max_non_overlapping_jobs(startTime, endTime): # Combine start and end times into a list of tuples and sort by end times jobs = sorted(zip(startTime, endTime), key=lambda x: x[1]) max_jobs = 0 end_time = float(\'-inf\') for start, end in jobs: if start >= end_time: max_jobs += 1 end_time = end return max_jobs"},{"question":"In a directed graph represented by an adjacency list `graph`, a **strongly connected component** (SCC) is a maximal subgraph in which every pair of vertices is reachable from each other. Write a function that takes in the directed graph `graph` and returns a list of lists where each list contains the vertices of one strongly connected component. The vertices in each SCC should be listed in ascending order, and the list of SCCs should be sorted by the smallest vertex number in each component.","solution":"def tarjan_scc(graph): Finds all the strongly connected components in a directed graph. Parameters: graph (dict): A dictionary representing the graph where keys are vertices and values are lists of adjacent vertices. Returns: list of list: A list of SCCs, each represented by a list of vertices. index = 0 stack = [] lowlink = {} index_map = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index index_map[node] = index lowlink[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in graph.get(node, []): if neighbor not in index_map: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif on_stack[neighbor]: lowlink[node] = min(lowlink[node], index_map[neighbor]) if lowlink[node] == index_map[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(sorted(scc)) for node in graph: if node not in index_map: strongconnect(node) return sorted(sccs, key=lambda x: x[0])"},{"question":"You are given a `2D` grid of size `m x n` representing a maze. Each cell in the grid can either be `0` or `1`, where `0` represents an open path and `1` represents a wall. Your task is to start from the top-left corner of the maze (cell `(0, 0)`) and find the number of unique paths to the bottom-right corner (cell `(m-1, n-1)`) while only being able to move down or right at any point in time. Return _the number of unique paths from the start to the destination_. Note that it\'s guaranteed that the start and destination cells are always `0`.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles. :param grid: List[List[int]]: 2D grid representing the maze where 0 represents an open path and 1 represents a wall. :return: int: Number of unique paths. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1]"},{"question":"Given two integers `n` and `m`, you have to find all possible unique binary trees with `n` nodes that can be formed such that the sum of the values of the nodes in the tree is equal to `m`. Return _a list of such possible binary trees_, where each tree is represented by its root node. Each node is represented as a value and two child nodes (left and right). The value of each node is a positive integer and all values in a binary tree must be unique.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_trees(n, m, start=1): if n == 0 and m == 0: return [None] if n <= 0 or m <= 0: return [] trees = [] for i in range(start, m + 1): left_trees = find_trees(n - 1, m - i, start) right_trees = find_trees(n - 1, m - i, start) for left in left_trees: for right in right_trees: root = TreeNode(i) root.left = left root.right = right trees.append(root) return trees def binary_trees_with_sum(n: int, m: int) -> List[Optional[TreeNode]]: return find_trees(n, m)"},{"question":"Given a list of integers `arr` and an integer threshold `k`, return _a new list containing the elements from_ `arr` _such that each element appears no more than_ `k` _times in the new list_. The order of elements in the new list should be the same as their first appearance in the original list.","solution":"from collections import defaultdict def limit_occurrences(arr, k): Returns a new list containing the elements from arr such that each element appears no more than k times. Parameters: arr (list): List of integers. k (int): Threshold for the number of occurrences. Returns: list: New list with elements limited to k occurrences. occurrence_count = defaultdict(int) result = [] for num in arr: if occurrence_count[num] < k: result.append(num) occurrence_count[num] += 1 return result"},{"question":"You are given a 2D grid of size `m x n` representing a maze. Each cell in the grid can contain either a `0` (an empty space) or a `1` (a wall). Ian wants to find a path from the top-left corner of the maze (i.e., cell `(0, 0)`) to the bottom-right corner (i.e., cell `(m-1, n-1)`). He can only move up, down, left, or right, and he cannot move through walls. An empty space that has already been visited becomes a wall. Return the length of the shortest path from the top-left corner to the bottom-right corner. If there is no such path, return `-1`.","solution":"from collections import deque def shortest_path_maze(grid): Given a 2D grid representing a maze, each cell in the grid can contain either a 0 (an empty space) or a 1 (a wall). The function returns the length of the shortest path from the top-left corner to the bottom-right corner, or -1 if no such path exists. # Directions for movement: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) queue = deque([(0, 0, 1)]) # (row, col, distance) grid[0][0] = 1 # mark as visited by setting to \'1\' while queue: r, c, d = queue.popleft() if r == m - 1 and c == n - 1: return d for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 0: queue.append((nr, nc, d + 1)) grid[nr][nc] = 1 # mark as visited return -1"},{"question":"You are given a string `instructions` that contains only the characters `G`, `L`, and `R`. Each character in the string represents an instruction for a robot: - \'G\' means move forward one unit. - \'L\' means turn 90 degrees to the left. - \'R\' means turn 90 degrees to the right. The robot starts at the origin point `(0, 0)` on a plane and faces north. Return _`true` if and only if there exists a circle such that the robot will eventually come back to the origin, following the instructions repeatedly_.","solution":"def is_robot_bounded(instructions): Determines if the robot movements bound it within a circle. Args: instructions (str): A string containing characters \'G\', \'L\', \'R\'. Returns: bool: Returns True if the robot is bounded in a circle, else False. # Initial position and direction (north = 0, east = 1, south = 2, west = 3) x, y = 0, 0 direction = 0 # Mapping of directions: 0 = north, 1 = east, 2 = south, 3 = west directions = [ (0, 1), # north: move up (1, 0), # east: move right (0, -1), # south: move down (-1, 0) # west: move left ] # Iterate over instructions for i in instructions: if i == \'G\': x += directions[direction][0] y += directions[direction][1] elif i == \'L\': direction = (direction + 3) % 4 # Turning left elif i == \'R\': direction = (direction + 1) % 4 # Turning right # Robot returns to origin or orientation is not northward (facing the new direction) return (x == 0 and y == 0) or direction != 0"},{"question":"You are given an array of integers `heights` representing the heights of buildings, where `heights[i]` is the height of the `i`-th building. An individual standing on top of a building can see the next building if and only if it is strictly shorter than the current one. Starting from the first building, return an array of integers where the `i`-th element represents the number of buildings visible from the `i`-th building to the end of the array.","solution":"def count_visible_buildings(heights): Returns an array of integers where the i-th element represents the number of buildings visible from the i-th building to the end of the array. n = len(heights) visible_counts = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] < heights[i]: count += 1 else: break visible_counts[i] = count return visible_counts"},{"question":"You are given a dictionary representing an inventory of items, where keys are the item names and values are the quantities. Write a function to merge this inventory with another dictionary representing new stock. If an item exists in both inventories, their quantities should be added. The function should return the updated inventory. Here is the function signature: ```python def update_inventory(current_inventory: Dict[str, int], new_stock: Dict[str, int]) -> Dict[str, int]: # Your code here ```","solution":"def update_inventory(current_inventory, new_stock): Merges two dictionaries representing inventories by adding quantities of items. If an item exists in both inventories, their quantities are added. Returns the updated inventory. :param current_inventory: Dictionary of current inventory {item: quantity} :param new_stock: Dictionary of new stock to be added {item: quantity} :return: Updated inventory dictionary {item: quantity} updated_inventory = current_inventory.copy() for item, quantity in new_stock.items(): if item in updated_inventory: updated_inventory[item] += quantity else: updated_inventory[item] = quantity return updated_inventory"},{"question":"You are given a list of integers `nums` representing a sequence of operations where `nums[i]` represents the number of minutes taken for each operation. You need to determine the **minimum total time** required to complete all operations under the constraint that **no two consecutive operations** can have the same amount of time. If it\'s not possible to arrange the operations to meet the requirement, return `-1`. Return the minimum total time needed to complete all operations or `-1` if it\'s not possible.","solution":"def min_total_time(nums): Determines the minimum total time to complete all operations such that no two consecutive operations have the same amount of time. Returns -1 if it is not possible. Args: nums (List[int]): List of integers representing the time taken for each operation. Returns: int: The minimum total time or -1 if it\'s not possible to arrange. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Helper function to find minimum total time with starting index def min_time(start_idx): min_time = 0 prev_time = None for i in range(start_idx, start_idx + n): current_time = nums[i % n] if current_time == prev_time: return float(\'inf\') prev_time = current_time min_time += current_time return min_time # Try starting from index 0 and then index 1 total_time_0 = min_time(0) total_time_1 = min_time(1) min_total_time_val = min(total_time_0, total_time_1) if min_total_time_val == float(\'inf\'): return -1 else: return min_total_time_val"},{"question":"[Question] 4: You are given a string `s` containing only lowercase alphabets and the character `*`, where the `*` character can be replaced by any lowercase alphabet. You are also given another string `t` consisting only of lowercase alphabets. Determine if there is a way to replace the `*` in `s` such that `s` becomes a substring of `t`. Return `true` if it is possible, otherwise return `false`.","solution":"def is_substring_possible(s, t): Determines if there is a way to replace the \'*\' in \'s\' such that \'s\' becomes a substring of \'t\'. Parameters: s (str): The string containing only lowercase alphabets and the character \'*\'. t (str): The string consisting only of lowercase alphabets. Returns: bool: True if it is possible to replace \'*\' in \'s\' to make \'s\' a substring of \'t\', otherwise False. # Lengths of strings s and t len_s = len(s) len_t = len(t) for i in range(len_t - len_s + 1): match = True for j in range(len_s): if s[j] != \'*\' and s[j] != t[i + j]: match = False break if match: return True return False"},{"question":"You are given a list of projects, each with a start and end time, represented as `(start, end)` pairs. You want to schedule these projects in such a way that you can complete the maximum number of projects without any overlap. Write a function that takes a list of tuples, where each tuple represents a project, and returns the maximum number of non-overlapping projects that can be scheduled. Some examples include: - If the input is `[(1, 3), (2, 5), (4, 6)]`, the output should be `2` because you can pick projects `(1, 3)` and `(4, 6)`. - If the input is `[(1, 2), (2, 3), (3, 4)]`, the output should be `3` because you can pick projects `(1, 2)`, `(2, 3)`, and `(3, 4)`. Note: The end time is exclusive, meaning a project ending at time `t` doesn\'t overlap with another project starting at time `t`.","solution":"def max_non_overlapping_projects(projects): Returns the maximum number of non-overlapping projects that can be scheduled. Parameters: projects (list of tuples): Each tuple contains two integers (start, end) Returns: int: Maximum number of non-overlapping projects # Sort projects by their end times projects.sort(key=lambda x: x[1]) count = 0 last_end_time = float(\'-inf\') for start, end in projects: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"You are given a **0-indexed** integer array `nums` with `n` elements. Your task is to sort the array using the merge sort algorithm and return the sorted array. Merge sort is a divide-and-conquer algorithm that works as follows: 1. Divide the array into two halves. 2. Recursively sort each half. 3. Merge the two sorted halves together to produce the final sorted array. Implement a function `mergeSort(nums)` that takes in an integer array `nums` and returns the sorted array. Your function should follow the merge sort principles and should ensure an efficient sorting process with a time complexity of `O(n log n)`.","solution":"def mergeSort(nums): if len(nums) <= 1: return nums def merge(left, right): sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 while i < len(left): sorted_array.append(left[i]) i += 1 while j < len(right): sorted_array.append(right[j]) j += 1 return sorted_array mid = len(nums) // 2 left_half = mergeSort(nums[:mid]) right_half = mergeSort(nums[mid:]) return merge(left_half, right_half)"},{"question":"You are given a non-empty binary search tree (BST) with unique values. Each node contains a single integer value. Write a function that finds the lowest common ancestor (LCA) of two given nodes in the BST. The LCA is defined as the deepest node that has both given nodes as descendants (where we allow a node to be a descendant of itself). The function should return the value of the LCA node. Example: Input: BST = [6,2,8,0,4,7,9,null,null,3,5], node1 = 2, node2 = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def lowest_common_ancestor(root, node1, node2): Returns the LCA of two given nodes in the BST. Parameters: root (TreeNode): The root of the BST. node1 (int): The value of the first node. node2 (int): The value of the second node. Returns: int: The value of the LCA node. current = root while current: if node1 < current.value and node2 < current.value: current = current.left elif node1 > current.value and node2 > current.value: current = current.right else: return current.value"},{"question":"You are given two strings `s1` and `s2` of equal length. Determine if `s2` is a scrambled string of `s1`. A string `s` is a scrambled string of `t` if it can be generated from `t` by recursively applying the following steps any number of times: 1. Split the string into two non-empty substrings at any point. 2. Swap the two substrings. 3. Apply step 1 recursively on each of the two substrings. Return `true` if `s2` is a scrambled string of `s1`, or `false` otherwise.","solution":"def is_scramble(s1, s2): Determine if s2 is a scrambled string of s1. :param s1: The original string. :param s2: The string to check if it\'s a scrambled version of s1. :return: True if s2 is a scrambled string of s1, False otherwise. if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): # Check if s1[:i] is a scrambled string of s2[:i] and s1[i:] is a scrambled string of s2[i:] if is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:]): return True # Check if s1[:i] is a scrambled string of s2[-i:] and s1[i:] is a scrambled string of s2[:-i] if is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i]): return True return False"},{"question":"Given a binary array `nums`, you must modify it so that each consecutive group of 1s is separated by at least one 0. You are allowed to flip at most one bit (0 to 1 or 1 to 0) in the array. Return the maximum number of 1s that can be contiguous after performing at most one flip. If no flipping is needed to achieve the maximum, return the result as it is.","solution":"def find_max_consecutive_ones(nums): Given a binary array nums, the function returns the maximum number of 1s that can be contiguous after performing at most one flip (0 to 1 or 1 to 0). :param nums: List[int] - a binary array :return: int - maximum number of contiguous 1s after at most one flip max_ones = 0 zero_count = 0 left = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"You are given two strings `word1` and `word2` of the same length consisting of lowercase English letters. You can transform each string into another string by rearranging its characters. A transformation is valid if and only if for each unique character in `word1`, the count of that character in `word2` is the same as in `word1`. Return `true` if you can transform `word1` into `word2`, otherwise return `false`.","solution":"def can_transform(word1, word2): Returns True if word1 can be transformed into word2 by rearranging the characters, else returns False. from collections import Counter return Counter(word1) == Counter(word2)"},{"question":"You are given an integer array `arr` of length `n` where `1 <= arr[i] <= 1000`. You can perform the following operation on the array: Select an index `i` (0-indexed) and add any integer `x` (`x` can be positive or negative) to `arr[i]`. However, you are only allowed to make at most one such operation. Return the minimum number of distinct integers in the array that can be achieved after performing the operation at most once. If no operation is needed to achieve the minimum number of distinct integers, return the number of distinct integers in the original array.","solution":"def min_distinct_after_one_operation(arr): Returns the minimum number of distinct integers in the array that can be achieved after performing the operation at most once. from collections import Counter # Count the frequency of each element count = Counter(arr) if len(count) == 1: return 1 # Current number of distinct elements current_distinct = len(count) # Try reducing the distinct count by changing each element to another existing element min_distinct = current_distinct for key in count: for another_key in count: if key != another_key: new_count = count.copy() new_count[another_key] += new_count[key] del new_count[key] min_distinct = min(min_distinct, len(new_count)) return min_distinct"},{"question":"You are given an m x n binary matrix `mat` of `0`s and `1`s. You can perform the following operation on the matrix any number of times: - Choose any `row` or `column`, and flip each `1` in that `row` or `column` to `0` and each `0` to `1`. Your goal is to find the maximum number of rows that have all `1`s after performing any number of operations. Return _the maximum number of rows that have all `1`s you can get after performing any number of flips on rows and columns_.","solution":"def max_rows_with_all_ones(mat): Returns the maximum number of rows with all 1s that can be achieved by flipping rows or columns any number of times. from collections import Counter m = len(mat) if m == 0: return 0 n = len(mat[0]) if n == 0: return 0 row_patterns = [] for row in mat: row_patterns.append(tuple(row)) pattern_count = Counter(row_patterns) max_rows = 0 for pattern, count in pattern_count.items(): flipped_pattern = tuple(1 - val for val in pattern) if flipped_pattern in pattern_count: max_rows = max(max_rows, count + pattern_count[flipped_pattern]) else: max_rows = max(max_rows, count) return max_rows"},{"question":"You are given two strings, **s1** and **s2**. Your goal is to make these strings identical by performing any number of character replacement operations. The cost of replacing a character `\'a\'` in **s1** with a character `\'b\'` in **s2** is given by the absolute difference of their ASCII values, i.e., `abs(ord(a) - ord(b))`. Given **s1** and **s2**, return the minimum cost required to make the two strings identical. If the lengths of **s1** and **s2** are different, return `-1`.","solution":"def min_cost_to_identical(s1, s2): Returns the minimum cost required to make the two strings s1 and s2 identical by performing any number of character replacement operations. If the lengths of s1 and s2 are different, returns -1. if len(s1) != len(s2): return -1 cost = 0 for ch1, ch2 in zip(s1, s2): cost += abs(ord(ch1) - ord(ch2)) return cost"},{"question":"You are given an integer array `projects` where `projects[i]` represents the time required to complete the `i`-th project. You are also given an integer `k` representing the number of workers available. Each worker can be assigned to any project, but each project must be completed by one worker. Your goal is to minimize the maximum working time of any worker. Return _the minimum possible value of the maximum working time assigned to a worker_.","solution":"def is_valid(workloads, k, max_workload): current_sum = 0 workers_needed = 1 for workload in workloads: if current_sum + workload > max_workload: workers_needed += 1 current_sum = workload if workers_needed > k: return False else: current_sum += workload return True def minimize_maximum_time(projects, k): low, high = max(projects), sum(projects) while low < high: mid = (low + high) // 2 if is_valid(projects, k, mid): high = mid else: low = mid + 1 return low"},{"question":"You are given an array `nums` consisting of integers. You need to modify the array such that each element at index `i` satisfies the following condition: `nums[i] = nums[i] + nums[j]` for all `j` where `0 <= j < i`. Return the modified array after performing the described operations for each element of `nums`.","solution":"def modify_array(nums): Modifies the array such that each element at index i is the sum of all previous elements including itself. :param nums: List[int] - The input array consisting of integers :return: List[int] - The modified array for i in range(1, len(nums)): nums[i] += nums[i-1] return nums"},{"question":"You are given a string `s` representing a binary number (composed of only \'0\'s and \'1\'s). You are allowed to perform the following operation as many times as you want: * Remove any subsequence of `s` that matches the pattern \\"01\\". Return _the minimum number of operations required to make the string empty_.","solution":"def min_operations_to_empty(s): Returns the minimum number of operations required to make the string empty by removing any subsequence matching the pattern \\"01\\". count_0 = s.count(\'0\') count_1 = s.count(\'1\') # The minimum number of operations needed will be the minimum count of \'0\'s or \'1\'s return min(count_0, count_1)"},{"question":"You are given two binary trees, `root1` and `root2`. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. Return _a new binary tree that represents the merged tree. The merge rule is that if two nodes overlap, then sum node values together as the new value of the merged node. Otherwise, the NON-null node will be used as the node of the new tree_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees and returns the merged tree. if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged_tree = TreeNode(root1.val + root2.val) merged_tree.left = merge_trees(root1.left, root2.left) merged_tree.right = merge_trees(root1.right, root2.right) return merged_tree"},{"question":"Given a 2D grid of size `m x n` filled with non-negative integers, and you are currently positioned at the top-left corner of the grid (i.e., `grid[0][0]`). Your goal is to reach the bottom-right corner of the grid (i.e., `grid[m-1][n-1]`) with the maximum sum of the values along its path. You can only move either down or right at any point in time. Return _the maximum sum of the values along the path from `grid[0][0]` to `grid[m-1][n-1]`_.","solution":"def maxPathSum(grid): Returns the maximum sum of the values along the path from grid[0][0] to grid[m-1][n-1]. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create dp array same size as grid dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill rest of dp array for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1]"},{"question":"You are given a binary search tree (BST) with `n` nodes. Write a function that takes the root of the BST and an integer `val` as arguments, and returns the subtree rooted with the node whose value is `val`. If such a node does not exist, return `null`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def searchBST(root, val): Returns the subtree rooted with the node whose value is val. If such a node does not exist, return None. if root is None: return None if root.val == val: return root elif val < root.val: return searchBST(root.left, val) else: return searchBST(root.right, val)"},{"question":"You are given a binary tree represented as a string in the format of pre-order traversal, where each node can be either a digit (between \'0\' and \'9\') or a \'#\' representing a null node. Your task is to deserialize this string to reconstruct the binary tree and then serialize it back to a string in post-order traversal format. Implement the following class: * `TreeNode` class with the properties: * `int val` - the value of the node, initialized to zero * `TreeNode left` - the left child of the node, initialized to None * `TreeNode right` - the right child of the node, initialized to None * `BinaryTreeCodec` class with the methods: * `deserialize(String data)` - constructs the binary tree from the given pre-order traversal string and returns the root node of the tree. * `serialize(TreeNode root)` - returns the post-order traversal string of the constructed binary tree. **Example:** ``` Input: data = \\"1,2,#,#,3,4,#,#,5,#,#\\" Output: \\"2,#,#,4,#,#,5,#,#,3,1\\" ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeCodec: def deserialize(self, data): Constructs the binary tree from the given pre-order traversal string and returns the root node. def build(nodes): val = next(nodes) if val == \'#\': return None node = TreeNode(int(val)) node.left = build(nodes) node.right = build(nodes) return node nodes = iter(data.split(\',\')) return build(nodes) def serialize(self, root): Returns the post-order traversal string of the constructed binary tree. def post_order(node): if not node: return [\'#\'] left = post_order(node.left) right = post_order(node.right) return left + right + [str(node.val)] return \',\'.join(post_order(root))"},{"question":"Given an array of integers `nums` and an integer `target`, return _the index of the **last** occurrence of_ `target` _in_ `nums`. _If_ `target` _is not present in_ `nums`, _return_ `-1`. _The array_ `nums` _is not necessarily sorted_.","solution":"def find_last_occurrence(nums, target): Returns the index of the last occurrence of target in nums. If target is not present in nums, return -1. for i in range(len(nums) - 1, -1, -1): if nums[i] == target: return i return -1"},{"question":"You are given a **0-indexed** array `nums` of `n` integers, where `n > 1`. The array is either entirely non-increasing or non-decreasing. Write a function that determines if the array is non-increasing or non-decreasing, and returns a string \\"non-increasing\\" if the array is non-increasing, and \\"non-decreasing\\" if the array is non-decreasing.","solution":"def determine_array_trend(nums): Determines if the array is non-increasing or non-decreasing. Args: nums : List[int] - A list of integers with at least two elements. Returns: str - \\"non-increasing\\" if the array is non-increasing, and \\"non-decreasing\\" if the array is non-decreasing. non_increasing = True non_decreasing = True for i in range(1, len(nums)): if nums[i] > nums[i - 1]: non_increasing = False if nums[i] < nums[i - 1]: non_decreasing = False if non_increasing: return \\"non-increasing\\" elif non_decreasing: return \\"non-decreasing\\""},{"question":"You are given a matrix representing a tic-tac-toe game board of size `3 x 3`. The board contains three possible values: `0` (empty), `1` (indicating player 1\'s move), and `2` (indicating player 2\'s move). Your task is to determine the current state of the game. The possible states are: - `0` if the game is still ongoing (i.e., there are still moves to make and no player has won yet). - `1` if player 1 has won. - `2` if player 2 has won. - `3` if the game is a draw (i.e., all cells are filled, but no player has won). Given, a 2D list `board` representing the current state of the tic-tac-toe game, return the state of the game based on the above rules.","solution":"def check_tic_tac_toe(board): Determines the state of a 3x3 tic-tac-toe game board. Parameters: board (list of list of int): 3x3 matrix representing the game state. Returns: int: The state of the game: 0 if the game is still ongoing, 1 if player 1 has won, 2 if player 2 has won, 3 if the game is a draw. for i in range(3): # Check rows for a win if board[i][0] == board[i][1] == board[i][2] != 0: return board[i][0] # Check columns for a win if board[0][i] == board[1][i] == board[2][i] != 0: return board[0][i] # Check diagonals for a win if board[0][0] == board[1][1] == board[2][2] != 0: return board[0][0] if board[0][2] == board[1][1] == board[2][0] != 0: return board[0][2] # Check if there are any empty spaces left for row in board: if 0 in row: return 0 # Game is still ongoing return 3 # Game is a draw"},{"question":"Given a string `s` and an integer `k`, modify the string such that every character in the resulting string appears at least `k` times consecutively. If it\'s not possible to achieve this, return an empty string. If there are multiple valid modifications, return any one of them.","solution":"def modify_string_to_have_k_consecutive_chars(s, k): Modify the string such that every character in the resulting string appears at least k times consecutively. If it\'s not possible to achieve this, return an empty string. if not s: return \\"\\" if k > 0 else s from collections import Counter counts = Counter(s) for char_count in counts.values(): if (char_count % k) != 0: return \\"\\" result = [] for char, count in counts.items(): result.append(char * count) return \'\'.join(result)"},{"question":"Given an array of integers `arr`, partition it into two contiguous subarrays left and right such that the sum of the elements in the left subarray is equal to the sum of the elements in the right subarray. If there are multiple such partitions, return _any_ that meets the criteria. If no such partition exists, return an empty array.","solution":"def partition_equal_sum(arr): Partition the array into two contiguous subarrays such that the sum of the elements in the left subarray is equal to the sum of the elements in the right subarray. :param arr: List of integers :return: Tuple containing the left and right subarrays or an empty array if no partition exists total_sum = sum(arr) left_sum = 0 for i in range(len(arr) - 1): left_sum += arr[i] right_sum = total_sum - left_sum if left_sum == right_sum: return (arr[:i+1], arr[i+1:]) return []"},{"question":"Given an `n`-ary tree, return the **level order traversal** of its nodes\' values. **N-ary Tree Input Structure**: A node is defined as: ```python class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] ``` For example, given an `n`-ary tree: ``` 1 / | 3 2 4 / 5 6 ``` The level order traversal of the tree should return: ``` [ [1], [3, 2, 4], [5, 6] ] ```","solution":"from collections import deque class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root: \'Node\'): Returns the level order traversal of an n-ary tree\'s nodes\' values. if root is None: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) for child in node.children: queue.append(child) result.append(current_level) return result"},{"question":"You are given two integers `a` and `b`. Your task is to calculate the greatest common divisor (GCD) of `a` and `b` and return the GCD followed by the least common multiple (LCM) of `a` and `b`. The GCD of two integers is the largest integer that divides both numbers without leaving a remainder. The LCM of two integers is the smallest integer that is divisible by both numbers. For example, given the numbers `15` and `20`, the GCD is `5` and the LCM is `60`. Return the results in a tuple such as `(GCD, LCM)`.","solution":"import math def gcd_and_lcm(a, b): Returns a tuple containing the GCD and LCM of two integers a and b. gcd = math.gcd(a, b) lcm = abs(a * b) // gcd if gcd != 0 else 0 return (gcd, lcm)"},{"question":"You are given a string `s` and an integer `k`. You need to construct the lexicographically smallest string by choosing exactly `k` characters from `s` and arranging them in the same order they appear in `s`. Return _the lexicographically smallest possible string of length `k` formed by removing `n - k` characters from `s`_.","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string of length k by removing n - k characters from s. stack = [] to_remove = len(s) - k for char in s: while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) return \'\'.join(stack[:k])"},{"question":"Given an array of integers `arr` and an integer `k`, return the _k_ closest integers to the median of `arr`. **Note**: If there is a tie, return the smaller integers first. The median is computed as follows: 1. If the array length is odd, the median is the middle element after sorting the array. 2. If the array length is even, the median is the average of the two middle elements after sorting the array.","solution":"def find_median(arr): arr_sorted = sorted(arr) n = len(arr) if n % 2 == 1: return float(arr_sorted[n // 2]) else: return (arr_sorted[n // 2 - 1] + arr_sorted[n // 2]) / 2.0 def k_closest_to_median(arr, k): median = find_median(arr) arr_sorted = sorted(arr, key=lambda x: (abs(x - median), x)) return arr_sorted[:k]"},{"question":"Given a **0-indexed** integer array `nums` and an integer `target`, determine if there exists a **continuous subarray** of length at least 2 that sums to `target`. Return `true` if such a subarray exists, and `false` otherwise. Note that the subarray elements should be contiguous and the subarray length should be at least 2.","solution":"def has_subarray_sum(nums, target): Determine if there exists a continuous subarray of length at least 2 that sums to target. :param nums: List of integers :param target: Integer target sum :return: Boolean value indicating if such a subarray exists n = len(nums) if n < 2: return False for i in range(n - 1): current_sum = nums[i] for j in range(i + 1, n): current_sum += nums[j] if current_sum == target: return True if current_sum > target: break return False"},{"question":"You are given an array of integers `arr`, where each integer represents the time it takes to complete a task. Your goal is to find a subset of tasks such that their total completion time is minimized while ensuring that the subset contains at least `k` tasks. If multiple subsets have the same total time, return any one of them. Return _the total completion time of the subset_.","solution":"def min_completion_time(arr, k): Returns the minimum total completion time for at least k tasks from the input array. Parameters: arr (list of int): List of integers where each integer represents the time to complete a task. k (int): Minimum number of tasks required in the subset. Returns: int: The total completion time of the subset. if len(arr) < k: raise ValueError(\\"The number of elements in arr is less than k\\") sorted_arr = sorted(arr) return sum(sorted_arr[:k])"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of students standing in a line at a photograph. The goal is to find how many students are not standing in the correct place. A student `x` is not in the correct place if there is a student `y` standing after him in the line who is shorter than `x`. For example: * Given the array `heights = [5, 1, 2, 3, 4]`, the result should be `4`, as all students except the first one are out of their correct place. * Given the array `heights = [1, 2, 3, 4, 5]`, the result should be `0`, as all students are in the correct place. * Given the array `heights = [2, 1, 3, 4, 5]`, the result should be `1`, as only the first student is standing out of place. Write a function that returns the number of students out of place in the given `heights` array.","solution":"def count_students_out_of_place(heights): Returns the number of students who are not standing in the correct place. A student x is not in the correct place if there is a student y standing after him in the line who is shorter than x. :param heights: List[int] - The list of student heights. :return: int - The number of students out of place. count = 0 max_seen = heights[0] for i in range(1, len(heights)): if heights[i] < max_seen: count += 1 else: max_seen = heights[i] return count"},{"question":"Given an array of integers `citations` where `citations[i]` is the number of times a researcher\'s `i-th` paper has been cited, return the researcher\'s h-index. According to the definition of h-index: a researcher has an index `h` if `h` of their `n` papers have at least `h` citations each, and the other `n-h` papers have no more than `h` citations each. If there are several possible values for `h`, the maximum one is used.","solution":"def h_index(citations): Calculate the h-index of a researcher based on their paper citations. Args: citations (List[int]): Array where citations[i] is the number of citations for the i-th paper. Returns: int: The h-index of the researcher. citations.sort(reverse=True) # Sort citations in descending order h = 0 # Initialize h-index for i, c in enumerate(citations): if c >= i + 1: h = i + 1 else: break return h"},{"question":"Given an array of `n` integers nums, find all unique triplets in the array which gives the sum of zero. A triplet `(nums[i], nums[j], nums[k])` is considered unique if and only if the set `i`, `j`, `k` are different. Return all the unique triplets in an array. You must write a solution with a time complexity of `O(n^2)`.","solution":"def three_sum(nums): Returns all unique triplets in the array which give the sum of zero. :param nums: List of integers :return: List of lists containing triplets nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"Given an array of integers `arr`, partition the array into (contiguous) subarrays that each contain at least one integer, and return the maximum possible sum of the minimum values of each subarray. For example, if `arr = [3, 1, 2, 4]`, one possible partition could be `[[3], [1, 2], [4]]`, and the sum of the minimum values of these subarrays is `3 + 1 + 4 = 8`. Find such a partition that yields the maximum sum of minimum values, and return that sum.","solution":"def max_sum_of_min_partition(arr): Given an array of integers `arr`, partition the array into contiguous subarrays such that each contains at least one integer. Return the maximum possible sum of the minimum values of each subarray. if not arr: return 0 # Partitioning each element into its own subarray ensures the sum of min values is maximized # because each subarray will have its own value as the minimum. return sum(arr)"},{"question":"You are given a list of `trips` where `trips[i] = [numPassengers, from, to]` indicates that the ith trip has `numPassengers` passengers and the trip goes from location `from` to location `to` on a number line. You also have an integer `capacity`, which represents the maximum number of passengers that can be carried at any point in time. Return `true` if it is possible to complete all trips without exceeding the given capacity at any time. Otherwise, return `false`. Example: ``` Input: trips = [[2,1,5],[3,3,7]], capacity = 4 Output: false ``` Explanation: Overlapping trips cause the number of passengers to exceed the capacity of 4. Note: - The number of trips will be in the range `[1, 1000]`. - `numPassengers` will be in the range `[1, 100]`. - Location values `from` and `to` will be in the range `[0, 1000]`.","solution":"def carPooling(trips, capacity): Determines if it is possible to complete all trips without exceeding the given capacity at any time. Args: trips (List[List[int]]): List of trips, where each trip is represented as [numPassengers, from, to]. capacity (int): Maximum number of passengers that can be carried at any point in time. Returns: bool: True if it is possible to complete all trips without exceeding the capacity, else False. # Create a list to keep track of passenger changes at each location passenger_changes = [0] * 1001 # Record the number of passengers getting on and off at each location for numPassengers, start, end in trips: passenger_changes[start] += numPassengers passenger_changes[end] -= numPassengers # Track the number of passengers in the car as we progress through the locations current_passengers = 0 for change in passenger_changes: current_passengers += change if current_passengers > capacity: return False return True"},{"question":"Given an integer `n`, return an array of size `n` containing the prefix sum of the first `n` natural numbers. The prefix sum array is where each element at index `i` is the sum of all integers from 1 to `i+1`. For example, for `n = 5`, the output array would be `[1, 3, 6, 10, 15]`.","solution":"def prefix_sum_array(n): Returns an array of size \'n\' containing the prefix sum of the first \'n\' natural numbers. Parameters: n (int): The size of the desired prefix sum array. Returns: list: The prefix sum array. return [sum(range(1, i + 1)) for i in range(1, n + 1)]"},{"question":"You are given a **0-indexed**, non-decreasing sorted list `days` of integers where each integer represents a day on which a specific task can be performed. You are also given an integer `tasks` representing the total number of different tasks to be done, with each task needing one day to complete. Each day can only be used for a single task. You need to return the minimum number of days required to complete exactly `tasks` number of tasks. If it is not possible to complete `tasks` number of tasks, return `-1`.","solution":"def min_days_to_complete_tasks(days, tasks): Returns the minimum number of days required to complete exactly `tasks` number of tasks. Each task requires one full day. :param days: List of days available for performing tasks. :param tasks: Total number of different tasks to be completed. :return: Minimum number of days required to complete the tasks or -1 if not possible. if len(days) < tasks: return -1 return days[tasks - 1]"},{"question":"You are given an array of integers `arr` with an optional parameter `r` that defaults to 1. You need to transform the array by raising each element to the power of `r`. Return the resulting array. Ensure that your solution works efficiently for large input sizes. * For example, if `arr = [1, 2, 3, 4]` and `r = 2`, the output should be `[1, 4, 9, 16]`. If `arr = [2, 3, 1]` and no `r` is provided, the output should be `[2, 3, 1]` since `r` defaults to 1.","solution":"def transform_array(arr, r=1): Returns a new array where each element in the input array is raised to the power of r. Parameters: arr (list): The input list of integers. r (int, optional): The power to which each element will be raised. Defaults to 1. Returns: list: A new list with each element raised to the power of r. return [x ** r for x in arr]"},{"question":"You are given two non-negative integers represented as strings `num1` and `num2`. The lengths of `num1` and `num2` may differ. You should return _the sum of the two numbers as a string_. You must not use any built-in libraries or methods for handling large integers directly.","solution":"def add_strings(num1, num2): Returns the sum of two non-negative integers represented as strings. result = [] carry = 0 # Reverse both strings to process from least significant digit to most significant digit num1 = num1[::-1] num2 = num2[::-1] # Find the maximum length of the two numbers max_len = max(len(num1), len(num2)) for i in range(max_len): # Get the current digit of each number, or 0 if the number is shorter digit1 = int(num1[i]) if i < len(num1) else 0 digit2 = int(num2[i]) if i < len(num2) else 0 # Calculate the sum of the digits plus the carry current_sum = digit1 + digit2 + carry carry = current_sum // 10 # Calculate the carry for the next column result.append(str(current_sum % 10)) # Append the current digit result # If there is any carry left at the end, append it to the result if carry: result.append(str(carry)) # Reverse the result to get the final sum and join into a single string return \'\'.join(result[::-1])"},{"question":"You are given a string `s` and an integer array `char_index` of length 26, where `char_index[i]` represents the position (0-indexed) of the ith character in the English alphabet after sorting the characters in `s` in accordance with their first appearance in `s`. Find the length of the longest subsequence of `s` that is in alphabetical order according to `char_index`. If no such subsequence exists, return 0.","solution":"def longest_alphabetical_subsequence(s, char_index): Given a string \'s\' and an integer array \'char_index\', find the length of longest subsequence of \'s\' that is in alphabetical order based on \'char_index\'. :param s: str, input string :param char_index: list of int, length 26, positional indices for each character :return: int, length of the longest subsequence n = len(s) dp = [1] * n for i in range(n): for j in range(i): if char_index[ord(s[j]) - ord(\'a\')] <= char_index[ord(s[i]) - ord(\'a\')]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) if s else 0"},{"question":"You are given an integer array `stations` where `stations[i]` represents the position of the `ith` charging station along a one-dimensional road. You are also given an integer `start` representing the starting position of your car and an integer `range` which is the maximum distance your car can travel on a full charge. You need to return the minimum number of charging stops required to reach the destination, represented by an integer `destination`. If it is not possible to reach the destination, return `-1`. The car must start from the given `start` position, and can only charge at given `stations`. It can only travel a maximum of `range` distance on a full charge. The car can take multiple charges but minimize the number of stops.","solution":"import heapq def minChargingStops(stations, start, range, destination): Returns the minimum number of charging stops to reach the destination. If it\'s not possible to reach, returns -1. # Min-heap to store available charges as negative values (to use as max-heap) max_heap = [] stops = 0 current_range = range current_position = start i = 0 while current_position + current_range < destination: # Push all charging stations within the current range to the max-heap while i < len(stations) and stations[i] <= current_position + current_range: heapq.heappush(max_heap, -stations[i]) i += 1 # If no more charging stations can be reached, check if the destination is reachable if not max_heap: return -1 # Travel to the farthest charging station within the current range current_position = -heapq.heappop(max_heap) current_range = range stops += 1 return stops"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the first non-repeating character in it and return its index. If it does not exist, return -1. You should implement the following function: ```python def firstUniqChar(s: str) -> int: ``` Here are a few examples to clarify: - If the input is \\"leetcode\\", the function should return 0 (as \'l\' is the first non-repeating character). - If the input is \\"loveleetcode\\", the function should return 2 (as \'v\' is the first non-repeating character). - If all characters are repeating or the string is empty, the function should return -1. The function\'s implementation should consider the time and space complexities to ensure it performs efficiently for larger inputs.","solution":"def firstUniqChar(s: str) -> int: Returns the index of the first non-repeating character in the string `s`. If there is no such character, returns -1. # Dictionary to store the count of each character char_count = {} # First pass to count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index # If no non-repeating character is found return -1"},{"question":"You are given an `n`-ary tree, meaning each node can have at most `n` children. An `n`-ary tree is represented using Node class: ```python class Node: def __init__(self, val=None, children=None): self.val = val self.children = children ``` Given the root of an `n`-ary tree, return _the level order traversal of its nodes\' values_. (i.e., from left to right, level by level). Note: The solution should account for the possibility of the tree being empty, in which case it should return an empty list.","solution":"from collections import deque from typing import List class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root: Node) -> List[List[int]]: Returns the level order traversal of an n-ary tree. if not root: return [] result = [] queue = deque([root]) while queue: level = [] for _ in range(len(queue)): node = queue.popleft() level.append(node.val) for child in node.children: queue.append(child) result.append(level) return result"},{"question":"You are given a binary search tree (BST) where each node contains a positive integer value. Design an algorithm to find the **k-th smallest element** in the BST (1-indexed). Implement the `BST` class: * `BST(TreeNode root)` Initializes the object with the root of the binary search tree. * `int kthSmallest(int k)` Returns the k-th smallest element in the BST. Note: Assume that `k` is always valid, i.e., 1 ≤ k ≤ the number of elements in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self, root: TreeNode): self.root = root def kthSmallest(self, k: int) -> int: # In-order traversal generator def in_order_traversal(node): if node is not None: yield from in_order_traversal(node.left) yield node.val yield from in_order_traversal(node.right) # Generate in-order traversal and iterate k-1 times gen = in_order_traversal(self.root) for _ in range(k-1): next(gen) # The next element is the k-th smallest return next(gen)"},{"question":"You are given a 2D matrix `grid` of dimensions `m x n` where each cell has a non-negative integer representing the height of a terrain. You are also given `k` queries, each query consists of three integers `x1`, `y1`, `x2`, and `y2` representing the coordinates of two corners of a rectangular subgrid. For each query, return the sum of the heights of all cells within the specified rectangular subgrid. Implement the `Solution` class: * `Solution(int[][] grid)` Initializes the object with the given `grid`. * `int querySum(int x1, int y1, int x2, int y2)` Returns the sum of the heights of all cells within the subgrid formed by `(x1, y1)` and `(x2, y2)`.","solution":"class Solution: def __init__(self, grid): Initializes the object with the given grid. Args: grid (List[List[int]]): The 2D grid of the heights of the terrain. if not grid or not grid[0]: raise ValueError(\\"Grid is empty\\") self.m = len(grid) self.n = len(grid[0]) self.prefix_sum = [[0] * (self.n + 1) for _ in range(self.m + 1)] # Compute the prefix sum matrix for i in range(self.m): for j in range(self.n): self.prefix_sum[i + 1][j + 1] = grid[i][j] + self.prefix_sum[i][j + 1] + self.prefix_sum[i + 1][j] - self.prefix_sum[i][j] def querySum(self, x1, y1, x2, y2): Returns the sum of the heights of all cells within the subgrid formed by (x1, y1) and (x2, y2). Args: x1 (int): Row index of the first corner y1 (int): Column index of the first corner x2 (int): Row index of the second corner y2 (int): Column index of the second corner Returns: int: Sum of the heights of all cells in the specified subgrid. return self.prefix_sum[x2 + 1][y2 + 1] - self.prefix_sum[x1][y2 + 1] - self.prefix_sum[x2 + 1][y1] + self.prefix_sum[x1][y1]"},{"question":"You are given a list of `n` integers representing the heights of buildings in a cityscape. The goal is to set up surveillance cameras on the buildings such that every building is either directly covered by a camera or indirectly covered by another building with a camera that has a clear, unobstructed view. A camera can monitor any building to its right that is not obscured by a taller building in between. Your task is to write a function to determine the minimum number of cameras needed to cover all buildings. Function Signature: `def minimum_cameras(buildings: List[int]) -> int:` Input: - `buildings` (List[int]): A list of `n` integers where `buildings[i]` represents the height of the `i-th` building. Output: - Return an integer representing the minimum number of cameras needed to cover all buildings.","solution":"from typing import List def minimum_cameras(buildings: List[int]) -> int: n = len(buildings) if n == 0: return 0 cameras = 1 # Place the first camera on the tallest building from the right tallest = buildings[-1] # Start with the last building as the tallest for i in range(n-2, -1, -1): if buildings[i] > tallest: cameras += 1 tallest = buildings[i] return cameras"},{"question":"Implement a class `MovingAverage` that calculates the moving average from a stream of integers. You should be able to instantiate the class with a window size parameter `size`. The class should have two methods: * `MovingAverage(int size)` - This initializes the object with the window size `size`. * `double next(int val)` - This method accepts an integer `val`, adds it to the stream, and returns the current moving average of the last `size` values in the stream.","solution":"from collections import deque class MovingAverage: def __init__(self, size): Initialize the moving average object with the window size. self.size = size self.window = deque() self.sum = 0 def next(self, val): Accept an integer value, add it to the stream, and return the current moving average of the last \'size\' values in the stream. if len(self.window) == self.size: self.sum -= self.window.popleft() self.window.append(val) self.sum += val return self.sum / len(self.window)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `n`. You want to balance the string such that each character appears exactly `n` times. You can perform at most two types of operations: remove any character or add any lowercase English character. Return _the minimum number of operations required to balance the string_. If it is not possible to achieve the balance, return `-1`.","solution":"from collections import Counter def min_operations_to_balance_string(s, n): Returns the minimum number of operations required to balance the string such that each character appears exactly n times. If it is not possible to achieve the balance, returns -1. :param s: input string consisting of lowercase English letters :param n: integer specifying the number of times each character should appear :return: minimum number of operations or -1 if not possible freq = Counter(s) total_chars_needed = n * len(freq) # If the total length of the string cannot be made to have n appearances of each char, return -1 if total_chars_needed > len(s): return -1 # Count deficiencies and excesses excess_count = 0 deficiency_count = 0 for char, count in freq.items(): if count < n: deficiency_count += n - count elif count > n: excess_count += count - n # If deficiency cannot be covered with excess, return -1 if deficiency_count > excess_count: return -1 return max(deficiency_count, excess_count)"},{"question":"You are given a matrix `grid` of size `n x m` consisting of 0s (empty cell) and 1s (obstacle). You can move from an empty cell to another empty cell in one of the four directions (left, right, up, down). Determine the minimum number of steps required to move from the top-left cell `(0, 0)` to the bottom-right cell `(n-1, m-1)`. If it is not possible to reach the bottom-right cell, return `-1`.","solution":"from collections import deque def min_steps(grid): Returns the minimum number of steps required to move from the top-left cell (0, 0) to the bottom-right cell (n-1, m-1). If not possible, return -1. n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == n-1 and y == m-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"You have an array of integers `heights` representing the heights of trees in a row. An observer at the left end of the row can see a tree if it is taller than all the trees to its left. Given an integer array `heights`, return an array of integers where each element is `1` if the corresponding tree is visible to the observer and `0` otherwise.","solution":"def visible_trees(heights): Determine the visibility of each tree in the heights array. Parameters: heights (list): a list of integers representing the heights of trees. Returns: list: a list of integers where 1 represents a visible tree and 0 represents a not visible tree. if not heights: return [] max_height = heights[0] visibility = [1] * len(heights) # start by assuming all trees are visible for i in range(1, len(heights)): if heights[i] > max_height: max_height = heights[i] visibility[i] = 1 else: visibility[i] = 0 return visibility"},{"question":"Given an integer array `arr`, return `true` if there are three consecutive odd numbers in the array. Otherwise, return `false`. An odd number is an integer that is not evenly divisible by `2`. Make sure that your solution has a linear time complexity O(n), where n is the length of the array.","solution":"def three_consecutive_odds(arr): Returns True if there are three consecutive odd numbers in the array, otherwise returns False. count = 0 for num in arr: if num % 2 != 0: count += 1 if count == 3: return True else: count = 0 return False"},{"question":"You are given a string `s` consisting only of the characters \'a\' and \'b\'. You can perform the following operation on the string: select any two adjacent letters and replace them with a single letter \'c\' if they are different (i.e., one is \'a\' and the other is \'b\'). Determine the minimum number of operations required to transform the string into a string consisting entirely of the same character. Return the minimum number of operations.","solution":"def min_operations(s): Returns the minimum number of operations required to transform the string s into a string consisting entirely of the same character. Parameters: s (str): The input string consisting only of the characters \'a\' and \'b\'. Returns: int: The minimum number of operations required. # Initialize the operation count to zero operations = 0 # Iterate through the string checking pairs of adjacent characters i = 0 while i < len(s) - 1: if s[i] != s[i + 1]: # If we find \'ab\' or \'ba\', it can be converted to \'c\' operations += 1 # Skip the next character as it has been merged i += 2 else: i += 1 return operations"},{"question":"You are given a 2D grid of size `m x n` consisting of non-negative integers. A path in the grid is a sequence of cells starting from the top-left corner to the bottom-right corner such that you can only move either down or right at any point in time. The cost of a path is the sum of the values of the cells visited along the path. Write a function that, given the grid and an integer `T`, determines whether there exists a path in the grid such that the cost of the path is exactly `T`. Return `true` if such a path exists, otherwise return `false`.","solution":"def path_exists_with_cost(grid, T): Determines whether there exists a path in the grid from the top-left corner to the bottom-right corner such that the cost of the path is exactly T. def dfs(i, j, current_sum): # If we are out of bounds, return False if i >= len(grid) or j >= len(grid[0]): return False # Add the current cell\'s value to the current path sum current_sum += grid[i][j] # If we have reached the bottom-right corner, check if the path sum equals T if i == len(grid) - 1 and j == len(grid[0]) - 1: return current_sum == T # Otherwise, continue the search by moving right or down return dfs(i + 1, j, current_sum) or dfs(i, j + 1, current_sum) # Start the DFS traversal from the top-left corner with an initial sum of 0 return dfs(0, 0, 0)"},{"question":"Given a `n x n` 2D matrix of integers, where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. Write a function that takes the matrix and an integer target as inputs and returns _the **position** (row and column index) of the **smallest** number in the matrix that is **greater than or equal** to the target_._ If no such number exists, return [-1, -1]_.","solution":"def find_position(matrix, target): Finds the position of the smallest number in the matrix which is greater than or equal to the target. If no such number exists, return [-1, -1]. :param matrix: List of List of integers, where each row is sorted and each column is sorted. :param target: Integer target to find the smallest number greater than or equal to it. :return: List containing row and column index of the found number, otherwise [-1, -1]. n = len(matrix) if n == 0 or len(matrix[0]) == 0: return [-1, -1] row, col = n - 1, 0 result = [-1, -1] smallest_diff = float(\'inf\') while row >= 0 and col < n: if matrix[row][col] >= target: if (matrix[row][col] - target < smallest_diff): result = [row, col] smallest_diff = matrix[row][col] - target row -= 1 else: col += 1 return result"},{"question":"You are given two strings `s` and `t` each of length `n`. Your task is to determine if it is possible to transform string `s` into string `t` by performing a series of operations. In each operation, you can select any character in `s` and replace it with any other character. However, you can perform this operation at most `k` times. Return `true` if it is possible to transform `s` into `t` within `k` operations, otherwise return `false`.","solution":"def can_transform(s, t, k): Determine if it is possible to transform string s into string t within k operations, where each operation consists of replacing any character in s with any other character. Parameters: s (str): The original string. t (str): The target string. k (int): The maximum number of operations allowed. Returns: bool: True if it is possible to transform s into t within k operations, otherwise False. # Calculate the number of differing characters. differing_characters = sum(1 for sc, tc in zip(s, t) if sc != tc) # Check if the number of differing characters is within the allowed operations. return differing_characters <= k"},{"question":"Given a string consisting of lowercase alphabetic characters, return the length of the longest substring that contains at most `2` distinct characters. For example, given the string `s = \\"eceba\\"`, the longest substring with at most `2` distinct characters is `\\"ece\\"`, which has a length of `3`. Invoke an efficient algorithm to solve this problem, aiming for a linear time complexity O(n).","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. if not s: return 0 left = 0 max_length = 0 char_index_map = {} for right, char in enumerate(s): char_index_map[char] = right if len(char_index_map) > 2: leftmost_char_index = min(char_index_map.values()) del char_index_map[s[leftmost_char_index]] left = leftmost_char_index + 1 current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a string `s` representing a sentence where words are separated by single spaces. Each word in `s` consists of only alphabetical characters. Your task is to reverse each word in the sentence while maintaining the initial word order and spaces. Return the resulting sentence as a string.","solution":"def reverse_words_in_sentence(s): Reverses each word in the sentence while maintaining the initial word order and spaces. Parameters: s (str): The input sentence as a string. Returns: str: The sentence with each word reversed. words = s.split() reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"Given a list of non-negative integers `nums`, you are tasked with performing a series of operations to maximize the final result. In one operation, you can select any two elements `a` and `b` from the list such that `a != b`, remove them from the list, and add their sum back to the list. You need to continue performing this operation until only one element remains in the list. Return the value of the final remaining element after all operations have been performed.","solution":"import heapq def maximize_final_result(nums): Perform operations to maximize the final result by summing the two largest elements until only one element remains in the list. :param nums: List of non-negative integers :return: The final remaining element in the list # Convert nums into a max-heap (use min-heap with negative values for max-heap behavior) max_heap = [-num for num in nums] heapq.heapify(max_heap) while len(max_heap) > 1: # Pop two largest elements (remember they are negative) first = -heapq.heappop(max_heap) second = -heapq.heappop(max_heap) # Add their sum back into the heap new_element = first + second heapq.heappush(max_heap, -new_element) # Return the final remaining element (convert back to positive) return -max_heap[0]"},{"question":"A company stores data about employee details in a singly linked list where each node represents an employee and contains two fields: `id` (an integer representing the employee\'s ID) and `next` (a reference to the next node in the list). The linked list is unsorted based on employee IDs. Write a function that takes the head of this linked list and an integer `id`, and returns the node corresponding to the given `id`. If the `id` is not present in the list, return `null`.","solution":"class ListNode: def __init__(self, id=0, next=None): self.id = id self.next = next def find_employee_by_id(head, id): Finds and returns the node with the given id in the singly linked list. If the id is not present, returns None. :param head: ListNode, the head of the singly linked list :param id: int, the employee ID to find :return: ListNode or None current = head while current is not None: if current.id == id: return current current = current.next return None"},{"question":"You are given a list of `n` student records, where each record is a tuple consisting of the student\'s `name` (a string) and their `grades` (a list of integers). Your task is to compute the average grade for each student and then determine the top `k` students based on their average grades. The students should be ordered in descending order of their average grades. If there is a tie, the student with the lexicographically smaller name should come first. Return the names of the top `k` students in the correct order. * Note: - The average grade is defined as the sum of grades divided by the number of grades, rounded to two decimal places. - Each student has at least one grade in their list.","solution":"def top_k_students(records, k): Returns the names of the top k students based on their average grades. Args: records (list of tuples): List where each tuple contains the name of the student (string) and their grades (list of integers). k (int): The number of top students to return. Returns: list: List of names of the top k students. # Calculate the average grade for each student student_averages = [] for name, grades in records: average = round(sum(grades) / len(grades), 2) student_averages.append((name, average)) # Sort by average grade in descending order, then by name in ascending order student_averages.sort(key=lambda x: (-x[1], x[0])) # Return the names of the top k students return [name for name, average in student_averages[:k]]"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to count the **unique pairs** `(i, j)` such that `nums[i] + nums[j] == target` and `i < j`. A pair `(i, j)` is considered unique if no other pair with the same elements (in any order) is counted. Return the number of unique pairs that meet the criteria.","solution":"def count_unique_pairs(nums, target): Counts the number of unique pairs (i, j) such that nums[i] + nums[j] == target and i < j. Args: nums (list of int): List of integers. target (int): The target sum. Returns: int: Number of unique pairs. seen = {} pairs = set() for i, num in enumerate(nums): complement = target - num if complement in seen: for j in seen[complement]: if j < i: pairs.add((complement, num)) if num in seen: seen[num].append(i) else: seen[num] = [i] return len(pairs)"},{"question":"Given a list of `n` strings, where each string represents a number with digits, find the sum of all the numbers in the list and return the result as a string. The input numbers can be very large, so the result must also be returned as a string to handle any possible overflow.","solution":"def sum_numbers_as_strings(numbers): Given a list of strings representing numbers, returns the sum of those numbers as a string. total_sum = sum(int(num) for num in numbers) return str(total_sum)"},{"question":"Implement a class `Trie` (pronounced as \\"try\\"), which is a tree-like data structure used for storing a dynamic set of strings, where the keys are usually strings. The `Trie` class should have the following methods: * `Trie()`: Initializes the trie object. * `void insert(String word)`: Inserts the string `word` into the trie. * `boolean search(String word)`: Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise. * `boolean startsWith(String prefix)`: Returns `true` if there is a previously inserted string word that has the prefix `prefix`, and `false` otherwise.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def startsWith(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"You are given two strings `s1` and `s2`, and an integer `k`. Assume that `s1` and `s2` are initially the same. You can perform up to `k` operations on `s1` to change it to `s2`. In one operation, you can select any character in `s1` and change it to any other character. Write a function to determine _if it is possible to transform `s1` into `s2` using no more than `k` operations_. If it is possible, return `true`, otherwise return `false`.","solution":"def can_transform(s1, s2, k): Determines if s1 can be transformed into s2 using no more than k operations. if len(s1) != len(s2): return False differences = sum(1 for a, b in zip(s1, s2) if a != b) return differences <= k"},{"question":"You are given a string `s` consisting of lowercase English letters. You want to form a new string by reordering the characters of `s` so that no two adjacent characters are the same. Return `true` if it is possible to form such a string, otherwise return `false`.","solution":"from collections import Counter import heapq def can_rearrange_no_adjacent(s): Determines if it is possible to rearrange the characters of string \'s\' such that no two adjacent characters are the same. Args: s (str): input string consisting of lowercase English letters. Returns: bool: True if it is possible to rearrange the characters, False otherwise. counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char return len(result) == len(s)"},{"question":"You are given a `list of strings`, each representing a code snippet written by a different developer. The snippets are composed of a combination of keywords, identifiers, and other characters. A keyword is a predefined word in the language like \\"if\\", \\"else\\", \\"while\\", \\"return\\", etc. Your task is to analyze these snippets and determine the **most common identifier** used across all code snippets. Identifiers are patterns that start with a letter or underscore and are followed by any number of letters, digits, or underscores (but not starting with a digit). Keywords are not considered identifiers. Return the most common identifier. In case of a tie, return the lexicographically smallest identifier. If there are no identifiers, return an empty string.","solution":"import re from collections import Counter def most_common_identifier(snippets, keywords): Returns the most common identifier from the list of code snippets. Parameters: snippets (list of str): List of code snippets. keywords (list of str): List of keywords to exclude from identifiers. Returns: str: The most common identifier or lexicographically smallest in case of tie. Returns empty string if no identifiers found. keywords_set = set(keywords) identifier_pattern = re.compile(r\'b[_a-zA-Z][_a-zA-Z0-9]*b\') identifiers = [] for snippet in snippets: found_identifiers = identifier_pattern.findall(snippet) for iden in found_identifiers: if iden not in keywords_set: identifiers.append(iden) if not identifiers: return \\"\\" identifier_counts = Counter(identifiers) most_common_count = identifier_counts.most_common(1)[0][1] most_common_identifiers = [iden for iden, count in identifier_counts.items() if count == most_common_count] return min(most_common_identifiers)"},{"question":"Given a string `s` of lowercase English letters, you need to **sort** it based on the **frequency** of the characters. The characters that have the same frequency should be sorted in **lexicographical order**. Return the sorted string based on these criteria. For example, given the string `\\"tree\\"`, the sorted string would be `\\"eert\\"`. Characters \'e\' and \'r\' both appear twice, but \'e\' comes before \'r\' lexicographically. If the input string is `\\"cccaaa\\"`, the output should be `\\"aaaccc\\"` because characters \'a\' and \'c\' both appear three times, maintaining their lexicographical order.","solution":"from collections import Counter def frequency_sort(s): Sorts the string s based on the frequency of characters. Characters with the same frequency are sorted lexicographically. freq = Counter(s) sorted_characters = sorted(freq.items(), key=lambda x: (-x[1], x[0])) return \'\'.join(char * freq for char, freq in sorted_characters)"},{"question":"You are given a list of **n** tasks. Each task has a duration given by the array `taskTime` and a deadline given by the array `deadline`, where `taskTime[i]` and `deadline[i]` represent the duration and deadline of the `i`-th task, respectively. You need to schedule these tasks in a way that maximizes the number of tasks completed before their deadlines. Once a task starts, it must run to completion without interruption. Return the maximum number of tasks that can be completed before their respective deadlines.","solution":"def max_tasks_to_complete(taskTime, deadline): Schedules tasks to maximize the number of tasks completed before their respective deadlines. Parameters: - taskTime (list of int): The time duration of each task. - deadline (list of int): The deadline of each task. Returns: - int: The maximum number of tasks that can be completed on time. tasks = sorted(zip(taskTime, deadline), key=lambda x: x[1]) current_time = 0 count = 0 for t, d in tasks: if current_time + t <= d: current_time += t count += 1 return count"},{"question":"You are given a **circular track** of length `l` and an array `runners` where `runners[i] = [si, vi]` represents the starting point and speed of the `i-th` runner, respectively. Two runners collide if they meet at the same point on the track moving in the same direction. Calculate and return the **minimum time** required for any two runners to collide. If no collision occurs, return `-1`.","solution":"import math def min_collision_time(l, runners): min_time = float(\'inf\') for i in range(len(runners)): for j in range(i + 1, len(runners)): s1, v1 = runners[i] s2, v2 = runners[j] if v1 == v2: # If speeds are the same, check if they start at the same point if s1 == s2: return 0 # they start at the same point and will collide instantly else: continue # they\'ll never collide if speeds are the same and start points different relative_speed = abs(v1 - v2) distance_between = abs(s1 - s2) modulo_distance = distance_between % l if modulo_distance == 0: min_time = 0 else: time_to_collision = l / math.gcd(relative_speed, l) min_time = min(min_time, time_to_collision) if min_time == float(\'inf\'): return -1 return min_time"},{"question":"You are given two strings `s` and `t` where `t` is a permutation of `s`. Your task is to determine the minimum number of adjacent swaps required to transform the string `s` into the string `t`. Return the minimum number of swaps.","solution":"def min_swaps_to_transform(s, t): Returns the minimum number of adjacent swaps required to transform string s into string t. # Convert strings to lists s_list = list(s) t_list = list(t) swaps = 0 for i in range(len(s_list)): # If the characters are already the same, no swap is needed if s_list[i] == t_list[i]: continue # Find the index in s_list where the character matches t_list[i] for j in range(i + 1, len(s_list)): if s_list[j] == t_list[i]: # Move the found character to the correct position by swapping s_list = s_list[:i] + [s_list[j]] + s_list[i:j] + s_list[j+1:] swaps += (j - i) break return swaps"},{"question":"You are given an **m x n** matrix `photo` where each cell is either a \'1\' (indicating part of a person) or \'0\' (indicating empty space). A person\'s body is formed by a region of \'1\'s connected horizontally or vertically (i.e., all \'1\'s connected in this way belong to a single person). Given that there may be multiple such regions in the matrix, return the **number of distinct persons** identified in the `photo`.","solution":"def num_unique_persons(photo): Returns the number of distinct persons in the given matrix. A person is represented by connected regions of \'1\'s (connected horizontally or vertically). if not photo: return 0 m, n = len(photo), len(photo[0]) visited = [[False]*n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or photo[i][j] == \'0\' or visited[i][j]: return visited[i][j] = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) count = 0 for i in range(m): for j in range(n): if photo[i][j] == \'1\' and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"Design a system that helps manage a collection of books in a library, where each book can be borrowed and returned by members. Implement the `Library` class with the following functionalities: - `Library()`: Initializes the library data structure. - `void addBook(String title)`: Adds a book with the given title to the library. - `boolean borrowBook(String title, String member)`: Allows a member to borrow a book if it\'s currently available. If the book is successfully borrowed, return `true`; otherwise, return `false`. - `void returnBook(String title, String member)`: Allows a member to return a book they have borrowed. - `List<String> getAvailableBooks()`: Returns a list of titles of all books available in the library. Ensure the system correctly handles the addition of books, borrowing, and returning of books while keeping track of which member has borrowed which book.","solution":"class Library: def __init__(self): self.books = {} def addBook(self, title): if title not in self.books: self.books[title] = None def borrowBook(self, title, member): if title in self.books and self.books[title] is None: self.books[title] = member return True return False def returnBook(self, title, member): if title in self.books and self.books[title] == member: self.books[title] = None def getAvailableBooks(self): return [title for title, borrower in self.books.items() if borrower is None]"},{"question":"You are given an integer array `stones` of length `n` where `stones[i]` represents the weight of the `i`-th stone. The **heaviest** two stones are taken and their weights compared. If their weights are equal, both stones are destroyed. Otherwise, the stone weighing less is destroyed, and the other stone now weighs the difference of their weights. This process is repeated until there is at most one stone left. Implement a function that returns the weight of the last remaining stone. If all stones are destroyed, return 0.","solution":"import heapq def lastStoneWeight(stones): Returns the weight of the last remaining stone. Args: stones (list): List of integers representing the weights of the stones. Returns: int: The weight of the last remaining stone or 0 if all stones are destroyed. # Convert all stones to negative for max heap simulation max_heap = [-stone for stone in stones] heapq.heapify(max_heap) while len(max_heap) > 1: first = -heapq.heappop(max_heap) second = -heapq.heappop(max_heap) if first != second: heapq.heappush(max_heap, -(first - second)) return -max_heap[0] if max_heap else 0"},{"question":"Given a string `s`, a **valid** string is one where every close parenthesis \')\' has a corresponding open parenthesis \'(\'. Also, each open parenthesis \'(\' is matched by a close parenthesis \')\'. You are required to add the minimum number of parentheses (either \'(\' or \')\') to make the string valid. Return _the minimum number of parentheses needed_.","solution":"def minAddToMakeValid(s): Returns the minimum number of parentheses required to make the input string valid. Args: s (str): The input string containing \'(\' and \')\' Returns: int: The minimum number of parentheses needed to make the string valid. open_needed = 0 close_needed = 0 for char in s: if char == \'(\': open_needed += 1 elif char == \')\': if open_needed > 0: open_needed -= 1 else: close_needed += 1 return open_needed + close_needed"},{"question":"You are given a list of `people` where each person is represented as a pair of integers `(h, k)`: - `h` is the height of the person. - `k` is the number of people in front of this person who have a height greater than or equal to `h`. Write a function that reconstructs and returns the queue that is represented by the input list. The queue should be sorted such that for each person `(h, k)`, the number of people in front who have a height greater than or equal to `h` is exactly `k`.","solution":"def reconstruct_queue(people): Reconstructs the queue based on the height and the number of people in front of them. :param people: List of tuples (h, k) where h is the height and k is the number of people in front with height >= h :return: The reconstructed queue as a list of tuples (h, k) # Sort the list firstly by height in descending order then by k in ascending order people.sort(key=lambda x: (-x[0], x[1])) queue = [] for person in people: queue.insert(person[1], person) return queue"},{"question":"You\'re given two strings `s1` and `s2` consisting of lowercase English letters and a set of integer pairs `pairs` where each `pairs[i] = [a, b]` indicates that the characters at positions `a` and `b` in both strings can be swapped. Note that each character can be involved in multiple swaps. Determine if it\'s possible to make `s1` and `s2` equal by performing zero or more swaps within the constraints of the pairs. If it\'s possible, return `True`, otherwise, return `False`.","solution":"def can_be_equal_with_swaps(s1, s2, pairs): Determines if s1 can be made equal to s2 using the provided swap pairs. :param s1: str - The first string. :param s2: str - The second string. :param pairs: List[List[int]] - List of pairs indicating allowable swaps. :return: bool - True if s1 can be made equal to s2 with the allowable swaps, otherwise False. # If the lengths of the strings are not the same, they cannot be equal if len(s1) != len(s2): return False # Function to find the root of the component def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Function to perform union of two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 n = len(s1) parent = list(range(n)) rank = [0] * n # Apply union operation for each pair for a, b in pairs: union(parent, rank, a, b) # Create a map for root to the list of characters that can be swapped in s1 and s2 from collections import defaultdict root_to_chars_s1 = defaultdict(list) root_to_chars_s2 = defaultdict(list) for i in range(n): root = find(parent, i) root_to_chars_s1[root].append(s1[i]) root_to_chars_s2[root].append(s2[i]) # Check if the characters in each component can be made equal for root in root_to_chars_s1: if sorted(root_to_chars_s1[root]) != sorted(root_to_chars_s2[root]): return False return True"},{"question":"Given a list of meetings represented as pairs of start and end times in the format `[[start1, end1], [start2, end2], ...]`, where each time is in the format `HH:MM`, determine if a person can attend all the meetings without any overlap. Return `true` if a person can attend all meetings, otherwise return `false`.","solution":"def can_attend_meetings(meetings): Determine if a person can attend all meetings without any overlap. :param meetings: List of meetings represented as pairs of start and end times in the format [[HH:MM, HH:MM], ...] :return: Boolean value indicating whether a person can attend all meetings without overlap. # Convert time strings to minutes from midnight def time_to_minutes(t): h, m = map(int, t.split(\':\')) return h * 60 + m # Convert meeting times to start and end in minutes meetings_in_minutes = [(time_to_minutes(start), time_to_minutes(end)) for start, end in meetings] # Sort meetings by start time meetings_in_minutes.sort() # Check for overlaps for i in range(1, len(meetings_in_minutes)): if meetings_in_minutes[i][0] < meetings_in_minutes[i-1][1]: return False return True"},{"question":"Given an array `obstacles` where `obstacles[i]` represents the height of an obstacle at the `i-th` position, you start from position `0` with a jump length of `1`. You can increment your jump length by `1` after each jump. Determine the number of positions you can successfully land on if you avoid landing on any obstacles. You are allowed to skip or stop at any point without proceeding further. Return the _total number of positions you can safely land on_.","solution":"def count_safe_landings(obstacles): Counts the number of positions you can safely land on, avoiding obstacles. Parameters: obstacles (list of int): List of obstacle heights. Returns: int: Total number of safe landing positions. n = len(obstacles) safe_positions = 0 jump_length = 1 for i in range(n): if obstacles[i] == 0: safe_positions += 1 jump_length += 1 return safe_positions"},{"question":"You are given a set of `n` people (labeled from `0` to `n - 1`) and a list of various connections where `connections[i] = [a, b]` represents a connection between person `a` and person `b`. A **connected group** is a group of people such that there exists a sequence of connections between any two people in the group. Your task is to determine the number of **connected groups** in the given set of people. Return the number of connected groups.","solution":"def find_connected_groups(n, connections): Returns the number of connected groups in the given set of people. parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY for a, b in connections: union(a, b) return len(set(find(x) for x in range(n)))"},{"question":"You are given a string `s` containing only the characters `(` and `)`. We define the score of a balanced parenthesis string based on the following rules: 1. `()` has a score of 1. 2. `AB` has a score equal to `A` + `B`, where `A` and `B` are balanced parenthesis strings. 3. `(A)` has a score of `2 * A`, where `A` is a balanced parenthesis string. Return _the score of the given string `s`_.","solution":"def score_of_parentheses(s): Returns the score of a balanced parenthesis string based on the rules defined. stack = [0] # The stack holds the score of the current frame for char in s: if char == \'(\': stack.append(0) # Start a new frame else: v = stack.pop() stack[-1] += max(2 * v, 1) # Complete the current frame return stack[0]"},{"question":"You are given a list of integers `nums` and an integer `k`. Write a function that returns _the number of subarrays whose sum is exactly `k`_. A subarray is a contiguous part of an array.","solution":"def subarray_sum(nums, k): Returns the count of subarrays that sum to k. Args: nums (list of int): List of integers. k (int): The target sum. Returns: int: Number of subarrays whose sum is exactly k. count = 0 current_sum = 0 sum_map = {0: 1} for num in nums: current_sum += num if (current_sum - k) in sum_map: count += sum_map[current_sum - k] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return count"},{"question":"You\'ve just received a large shipment of new books for your library. The books are in a random order and you decide to sort them on the bookshelves based on certain attributes. To help with the sorting, you want to write a function that can organize the books based on their **publication year** and **title**. You are given a list of dictionaries, where each dictionary represents a book with the following attributes: - `\\"title\\"` (a string, which may contain spaces and punctuation), - `\\"author\\"` (a string), - `\\"year\\"` (an integer). First, you will sort the books by their `\\"year\\"` in ascending order. If two books have the same `\\"year\\"`, then you will sort them by their `\\"title\\"` in lexicographical order. Write a function that takes in the list of books and returns the sorted list. The function signature should be: ```python def sort_books(books: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: pass ``` Example: Input: ```python [ {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}, {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\", \\"year\\": 1932}, {\\"title\\": \\"Fahrenheit 451\\", \\"author\\": \\"Ray Bradbury\\", \\"year\\": 1953}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925} ] ``` Output: ```python [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925}, {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\", \\"year\\": 1932}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}, {\\"title\\": \\"Fahrenheit 451\\", \\"author\\": \\"Ray Bradbury\\", \\"year\\": 1953}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960} ] ```","solution":"from typing import List, Dict, Union def sort_books(books: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: Sort the books by publication year first, then by title in lexicographical order. return sorted(books, key=lambda x: (x[\\"year\\"], x[\\"title\\"]))"},{"question":"Given a non-empty string `s` consisting of only lowercase letters, return _the length of the longest substring with all distinct characters_. If repeating characters are found, start a new substring after the last occurrence of the repeating character.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. char_index_map = {} longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest_length = max(longest_length, i - start + 1) return longest_length"},{"question":"You are given an array of integers and an integer `k`. You need to find the length of the longest subarray whose sum is divisible by `k`. If no such subarray exists, return `0`. Write a function `longestSubarrayDivisibleByK(nums, k)` that takes an array of integers `nums` and an integer `k` as inputs and returns the length of the longest subarray whose sum is divisible by `k`. The function should handle positive, negative, and zero values in the array.","solution":"def longestSubarrayDivisibleByK(nums, k): Returns the length of the longest subarray whose sum is divisible by k. # Dictionary to store the first occurrence of each remainder remainder_index_map = {0: -1} max_length = 0 prefix_sum = 0 for i in range(len(nums)): prefix_sum += nums[i] remainder = prefix_sum % k if remainder < 0: remainder += k if remainder in remainder_index_map: subarray_length = i - remainder_index_map[remainder] max_length = max(max_length, subarray_length) else: remainder_index_map[remainder] = i return max_length"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform the following operations on `s` any number of times: select any two adjacent characters and replace them with a single character that is lexicographically smaller. You need to determine if it\'s possible to transform `s` into a string consisting of only one distinct character. If it is possible, return `true`; otherwise, return `false`.","solution":"def can_transform_to_one_distinct_char(s): Determines if the string s can be transformed into a string consisting of only one distinct character. # Checking if all characters in the string are the same return len(set(s)) == 1"},{"question":"Given a **string** `s`, you need to find the length of the longest substring without repeating characters. Implement the function `lengthOfLongestSubstring(String s)` which takes a single string `s` as input and returns an integer representing the length of the longest substring without repeating characters. For example, if the input string is `\\"abcabcbb\\"`, the output should be `3`, which is the length of the substring `\\"abc\\"`. If the input string is `\\"bbbbb\\"`, the output should be `1`, which is the length of the substring `\\"b\\"`.","solution":"def lengthOfLongestSubstring(s): Returns the length of the longest substring without repeating characters. char_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"You are given a list of integers `nums`, where each integer represents the number of almonds in a bag. Your task is to determine if you can distribute the almonds into two groups such that the number of almonds in each group is equal. Return `True` if it is possible to split `nums` into two groups with equal sum, otherwise return `False`. Note that each almond from the list must belong to exactly one group.","solution":"def can_partition(nums): Determines if the list of integers can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, we can\'t partition it into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array where dp[i] indicates whether subset with sum i can be formed dp = [False] * (target + 1) dp[0] = True # Iterate through the numbers for num in nums: # Traverse the dp array from target to num for i in range(target, num-1, -1): # Update the dp array dp[i] = dp[i] or dp[i-num] return dp[target]"},{"question":"You are given a **0-indexed** array of integers `nums` where every element appears exactly twice except for one element that appears only once. Find and return _the element that appears only once._ You must solve it in `O(n)` time complexity and `O(1)` space complexity.","solution":"def single_number(nums): Returns the element that appears only once in the array. All other elements appear exactly twice. unique = 0 for num in nums: unique ^= num return unique"},{"question":"A **binary search tree (BST)** is a tree in which each node has at most two children, referred to as the left child and the right child. In a BST, for any given node with value `N`, all nodes in the left subtree must have values less than `N` and all nodes in the right subtree must have values greater than `N`. You are given the root of a binary search tree. Write an algorithm to find the **k-th smallest** element in this BST. Note that the tree may be unbalanced, and `k` is guaranteed to be between `1` and the total number of nodes in the tree (inclusive). Return the k-th smallest element in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Return the k-th smallest element in the BST. # Helper function to perform in-order traversal of the BST def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) # Get the in-order traversal result which is sorted list of values sorted_values = in_order_traversal(root) # Return the k-th smallest element (1-based index, hence -1) return sorted_values[k-1]"},{"question":"Given an array of integers nums and an integer k, determine whether there are two distinct indices i and j in the array such that nums[i] + nums[j] equals k. Return true if such indices exist, otherwise return false.","solution":"def has_pair_with_sum(nums, k): Determines if there are two distinct indices in nums such that their values sum up to k. :param nums: List of integers :param k: Integer sum target :return: True if such pair exists, False otherwise seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"Given a string `s`, return _the length of the longest substring that contains the same letters after one character replacement._ You can replace exactly one character in the substring. Your algorithm must run in `O(n)` time.","solution":"def longest_substring_with_one_replacement(s): from collections import defaultdict def max_length_with_replacement(s, k): Helper function to calculate the longest substring with at most k replacements. count = defaultdict(int) max_count = 0 max_length = 0 start = 0 for end in range(len(s)): count[s[end]] += 1 max_count = max(max_count, count[s[end]]) if end - start + 1 - max_count > k: count[s[start]] -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length return max_length_with_replacement(s, 1)"},{"question":"You are given a list of strings `words` and a list of prefixes `prefixes`, each element in the list `prefixes` is non-empty. A string is called a **prefix word** if it starts with one of the given prefixes. Return _the number of **prefix words** in the list_ `words`.","solution":"def count_prefix_words(words, prefixes): Returns the number of prefix words in the list `words` that start with one of the given prefixes in `prefixes`. :param words: List of strings :param prefixes: List of prefixes :return: Number of words that start with one of the given prefixes prefix_words_count = 0 for word in words: for prefix in prefixes: if word.startswith(prefix): prefix_words_count += 1 break return prefix_words_count"},{"question":"You are given a string `s` that consists of only lowercase English letters. You can reduce the string by performing a series of steps, where in each step you can choose two adjacent and equal characters and remove them, resulting in the string being reduced in size. Your task is to determine the final string after performing all possible reduction steps. If the final string is empty, return an empty string. Write a function `reduceString(String s)` to achieve this. # Example: Input: `s = \\"abbaca\\"` Output: `\\"ca\\"` Explanation: ``` In the first step, we remove \\"bb\\", resulting in \\"aaca\\". In the second step, we remove \\"aa\\", resulting in \\"ca\\". ```","solution":"def reduce_string(s): Reduces the string by removing pairs of adjacent equal characters iteratively until no more such pairs can be removed. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The final reduced string after performing all possible reductions. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"A company wants to implement a seating arrangement for their new office. The seating arrangement is represented by a `2D` grid of dimensions `n x m`, where some seats are available (represented by \'0\') and some seats are already occupied (represented by \'1\'). You are given the `2D` grid and your task is to determine the number of available seating areas. An available seating area is defined as a group of horizontally or vertically adjacent \'0\'s (available seats). Diagonal connections are not considered. Write a function that takes this `2D` grid as input and returns the number of available seating areas in the office.","solution":"def num_available_seating_areas(grid): Returns the number of available seating areas in the given 2D grid. An available seating area is defined as a group of horizontally or vertically adjacent \'0\'s. if not grid: return 0 n = len(grid) m = len(grid[0]) def dfs(i, j): if i < 0 or j < 0 or i >= n or j >= m or grid[i][j] != \'0\': return grid[i][j] = \'visited\' dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) count = 0 for i in range(n): for j in range(m): if grid[i][j] == \'0\': count += 1 dfs(i, j) return count"},{"question":"Write a function that takes a string `s` and returns the longest substring that appears at least twice in `s`. If there are multiple such substrings of the same length, return any one of them. If no such substring exists, return an empty string.","solution":"def longest_repeated_substring(s): Returns the longest substring that appears at least twice in the string `s`. If there are multiple such substrings of the same length, returns any one of them. If no such substring exists, returns an empty string. n = len(s) longest_substring = \\"\\" def has_repeated_substring(length): seen = set() for i in range(n - length + 1): substr = s[i:i + length] if substr in seen: return substr seen.add(substr) return \\"\\" left, right = 1, n while left <= right: mid = (left + right) // 2 repeated_substr = has_repeated_substring(mid) if repeated_substr: longest_substring = repeated_substr left = mid + 1 else: right = mid - 1 return longest_substring"},{"question":"You are given an integer array `nums` and an integer `k`. The array contains `2*k` elements where each element is an integer. Your task is to divide the array into `k` pairs such that the sum of each pair equals the same value. Implement the function `bool canArrange(int[] nums, int k)` that returns `true` if it\'s possible to divide the array into `k` pairs each summing to the same value, otherwise, return `false`. **Example**: - Input: `nums = [1, 2, 3, 4, 5, 6]`, `k = 3` Output: `true` Explanation: We can divide the array into pairs as (1, 6), (2, 5), and (3, 4) which all sum to 7. - Input: `nums = [1, 3, 2, 6, 5, 4]`, `k = 3` Output: `true` Explanation: We can divide the array into pairs as (1, 6), (2, 5), and (3, 4) which all sum to 7.","solution":"def canArrange(nums, k): Returns True if it is possible to divide array `nums` into `k` pairs such that the sum of each pair is the same, otherwise returns False. nums.sort() target_sum = nums[0] + nums[-1] left, right = 0, len(nums) - 1 while left < right: if nums[left] + nums[right] != target_sum: return False left += 1 right -= 1 return True"},{"question":"Write a function that takes in a string `s` and returns the length of the longest palindrome that can be built with the letters of `s`. The frequency of each character in the string can be rearranged to form the palindrome. A palindrome is a string that reads the same backward as forward, such as \\"racecar\\" or \\"madam\\".","solution":"def longest_palindrome(s): Returns the length of the longest palindrome that can be built from the letters of the given string. from collections import Counter char_count = Counter(s) length = 0 found_odd = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 found_odd = True # Add one if there\'s at least one character with an odd count if found_odd: length += 1 return length"},{"question":"Given a string `s` and an integer `k`, reorder the string such that every two adjacent characters are different. You can assume `k` is always smaller than the length of `s` and there are enough characters to rearrange accordingly. Return the lexicographically smallest possible reordered string. If you cannot rearrange the string in such a way, return an empty string.","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): if k == 0: return \'\'.join(sorted(s)) counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((freq + 1, char)) if len(queue) >= k: next_item = queue.popleft() if next_item[0] < 0: heapq.heappush(max_heap, next_item) return \'\'.join(result) if len(result) == len(s) else \'\'"},{"question":"You are given a list of integers `heights` representing the height of students in a line. Your task is to reorder the list of `heights` such that each student is taller than the person in front of them, but you are allowed to swap at most two students. Return `True` if the list of `heights` can be sorted by swapping at most two students, otherwise return `False`.","solution":"def can_sort_by_swapping_two(heights): Determines if the list can be sorted by swapping at most two elements. Returns True if it\'s possible, otherwise False. n = len(heights) sorted_heights = sorted(heights) diff = [] for i in range(n): if heights[i] != sorted_heights[i]: diff.append(i) if len(diff) == 0: return True # already sorted elif len(diff) == 2: # Only allowed to swap two students return heights[diff[0]] == sorted_heights[diff[1]] and heights[diff[1]] == sorted_heights[diff[0]] return False"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of students in a line. A group of students can form a team if each student\'s height is greater than or equal to the height of the student standing to their left. Return _the size of the largest team that can be formed._","solution":"def largest_team(heights): Returns the size of the largest team that can be formed such that each student\'s height is greater than or equal to the height of the student standing to their left. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(1, n): if heights[i] >= heights[i - 1]: dp[i] = dp[i - 1] + 1 return max(dp)"},{"question":"Given an array of integers `arr`, and an integer `m`, find the maximum sum of a subarray with length exactly `m`. A subarray is a contiguous subset of the array. You need to implement a function that returns this maximum sum. Note that if the array has fewer than `m` elements, return `-1`. **Example:** ``` Input: arr = [1,2,3,4,5,6,7,8,9], m = 3 Output: 24 ``` **Explanation:** The subarray [7, 8, 9] has the maximum sum of 24. **Example:** ``` Input: arr = [5, 1, 3, 2, 8, 0, 4], m = 4 Output: 18 ``` **Explanation:** The subarray [5, 1, 3, 2, 8] needs to be checked for all contiguous subsets of length 4. The subarray [1, 3, 2, 8] has the maximum sum of 14. **Example:** ``` Input: arr = [2, 1], m = 3 Output: -1 ``` **Explanation:** The array has fewer than 3 elements, so the function should return -1.","solution":"def max_subarray_sum(arr, m): Returns the maximum sum of a subarray with the length exactly `m`. If the array has fewer than `m` elements, returns -1. if len(arr) < m: return -1 max_sum = float(\'-inf\') current_sum = sum(arr[:m]) max_sum = max(max_sum, current_sum) for i in range(m, len(arr)): current_sum += arr[i] - arr[i - m] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given two strings `word1` and `word2`. Your task is to merge these strings into a single string by pulling characters alternately from each string. Specifically, the merged result should be constructed by taking the first character from `word1`, then the first character from `word2`, then the second character from `word1`, the second character from `word2`, and so on. If one string is longer than the other, append the remaining characters of the longer string to the end of the merged result. Return the merged string.","solution":"def merge_alternately(word1, word2): Merges two strings by pulling characters alternately from each string. Any remaining characters from the longer string are appended at the end. Parameters: word1 (str): The first string. word2 (str): The second string. Returns: str: The merged string. merged = [] i, j = 0, 0 while i < len(word1) and j < len(word2): merged.append(word1[i]) merged.append(word2[j]) i += 1 j += 1 if i < len(word1): merged.append(word1[i:]) if j < len(word2): merged.append(word2[j:]) return \'\'.join(merged) # Example usage: # merge_alternately(\\"abc\\", \\"pqr\\") # returns \\"apbqcr\\" # merge_alternately(\\"ab\\", \\"pqrs\\") # returns \\"apbqrs\\" # merge_alternately(\\"abcd\\", \\"pq\\") # returns \\"apbqcd\\""},{"question":"Given an array of integers `nums` and an integer `k`, write a function to find the maximum sum of a continuous subarray of `nums` of length exactly `k`. Return the maximum sum. If `nums` contains fewer than `k` elements, return `-1`. **For example:** - Input: `nums = [1, 2, 3, 4, 5]`, `k = 2` - Output: `9` - Input: `nums = [1, -1, 5, -2, 3]`, `k = 3` - Output: `6` - Input: `nums = [1, 2]`, `k = 3` - Output: `-1`","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of a continuous subarray of length exactly k. If nums contains fewer than k elements, return -1. n = len(nums) if n < k: return -1 # compute the sum of the first \'k\' elements max_sum = current_sum = sum(nums[:k]) # use sliding window to compute the sum of remaining subarrays of size \'k\' for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Write a function `findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float` that takes two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, and returns the median of the two sorted arrays. The overall run time complexity should be O(log(min(m,n))). The algorithm should follow these steps: 1. Ensure the array `nums1` is the smaller of the two arrays. 2. Use binary search on the smaller array to partition both arrays into two halves such that the largest element in the left half of both arrays is less than or equal to the smallest element in the right half of both arrays. 3. Compute the median based on the partitioned halves. 4. Handle the edge cases where one or both arrays are empty correctly. The median of a sorted array is defined as the middle element if the total number of elements is odd, or the average of the two middle elements if the total number of elements is even.","solution":"def findMedianSortedArrays(nums1, nums2): if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 m, n = len(nums1), len(nums2) start, end = 0, m while start <= end: partition1 = (start + end) // 2 partition2 = (m + n + 1) // 2 - partition1 maxLeft1 = float(\'-inf\') if partition1 == 0 else nums1[partition1 - 1] minRight1 = float(\'inf\') if partition1 == m else nums1[partition1] maxLeft2 = float(\'-inf\') if partition2 == 0 else nums2[partition2 - 1] minRight2 = float(\'inf\') if partition2 == n else nums2[partition2] if maxLeft1 <= minRight2 and maxLeft2 <= minRight1: if (m + n) % 2 == 0: return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2 else: return max(maxLeft1, maxLeft2) elif maxLeft1 > minRight2: end = partition1 - 1 else: start = partition1 + 1"},{"question":"You are given a 2D integer array `orders` where `orders[i] = [buyPricei, sellPricei]` representing the buying and selling prices of a product on the `i-th` day. Your task is to determine the maximum profit you can achieve by buying the product on one day and selling it on another day after the day you bought it. Return _the maximum profit you can achieve from the given `orders` or return `0`_ if no profit can be achieved.","solution":"def max_profit(orders): Determines the maximum profit that can be achieved by buying the product on one day and selling it on another day after the day you bought it. Args: orders (list of list of int): A 2D array where each sublist consists of [buyPrice, sellPrice]. Returns: int: The maximum profit possible. If no profit can be made, returns 0. if not orders: return 0 min_buy_price = float(\'inf\') max_profit = 0 for buy_price, sell_price in orders: min_buy_price = min(min_buy_price, buy_price) max_profit = max(max_profit, sell_price - min_buy_price) return max_profit"},{"question":"Write a function that accepts an integer `n` and returns the number of trailing zeros in the factorial of `n`. Trailing zeros are a result of multiplying numbers that contain factors of 10, and since 10 is the product of 2 and 5, we can determine the count of trailing zeros by counting the number of times 5 is a factor in the numbers from 1 to `n`. For example: - `countTrailingZeros(5)` returns `1`: 5! (120) has 1 trailing zero. - `countTrailingZeros(10)` returns `2`: 10! (3628800) has 2 trailing zeros.","solution":"def countTrailingZeros(n): Returns the number of trailing zeros in the factorial of n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"Given a binary tree, write a function to find the largest value in each row of the tree and return them as an array. Each binary tree node has the following structure: ``` class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your function should traverse the tree level by level and find the maximum value at each level, starting from the root. If the tree is empty, return an empty list.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values_in_each_row(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"You are given a **0-indexed** array `nums` containing only integers. You need to determine whether there are two distinct indices `i` and `j` in the array such that the absolute difference between `nums[i]` and `nums[j]` is exactly 2. Return `true` if such indices exist, or `false` otherwise.","solution":"def has_abs_difference_of_two(nums): Determines whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is exactly 2. :param nums: List of integers. :return: True if such indices exist, False otherwise. values = set(nums) for num in nums: if (num + 2) in values or (num - 2) in values: return True return False"},{"question":"Given a string `t` and an array of strings `words`, you need to find the minimum total length of segments you need to remove from `t` to ensure that none of the strings in `words` is a subsequence of `t`. A string `w` is a subsequence of another string `s` if `w` can be obtained by deleting some or no characters from `s` without reordering the remaining characters. Return the minimum length of segments to remove from `t`.","solution":"def min_length_to_remove(t, words): Finds the minimum total length of segments to remove from `t` to ensure none of the strings in `words` is a subsequence of `t`. :param t: The input string from which segments need to be removed. :param words: List of strings that should not be subsequences of `t`. :return: Minimum total length of segments to remove. def is_subsequence(word, t): it = iter(t) return all(char in it for char in word) total_length = 0 for word in words: if is_subsequence(word, t): total_length += len(word) # Remove the subsequence from `t` subseq_chars = list(word) t = \'\'.join(char for char in t if not (subseq_chars and char == subseq_chars[0] and subseq_chars.pop(0))) return total_length"},{"question":"You are given a `m x n` 2D grid initialized with all `0`\'s and an integer `k`. You are also given a set of `k` coordinates where `plants` exists. A plant will grow in all 4 cardinal directions (up, down, left, right) by 1 unit each day. Return the state of the grid after `k` days with `0` representing an empty cell and `1` representing a cell with a plant.","solution":"def plant_growth(m, n, k, coordinates): Simulates the growth of plants in a m x n grid over k days. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid k (int): number of days coordinates (List[Tuple[int, int]]): list of tuples representing initial plant coordinates Returns: List[List[int]]: grid state after k days grid = [[0] * n for _ in range(m)] for x, y in coordinates: grid[x][y] = 1 for _ in range(k): new_grid = [row[:] for row in grid] for i in range(m): for j in range(n): if grid[i][j] == 1: if i > 0: new_grid[i-1][j] = 1 if i < m - 1: new_grid[i+1][j] = 1 if j > 0: new_grid[i][j-1] = 1 if j < n - 1: new_grid[i][j+1] = 1 grid = new_grid return grid"},{"question":"Given an array of **non-negative** integers `nums` and an integer `k`, you need to find the **minimum sum** of the **maximum elements** of all subarrays of length `k`. More precisely, you need to find the minimum possible value among the sums of the maximum elements of each subarray of size `k` in `nums`. For example, consider the array `nums = [1,3,2,4,5]` and `k = 3`. The subarrays of length `k` are: - `[1, 3, 2]` with maximum value `3` - `[3, 2, 4]` with maximum value `4` - `[2, 4, 5]` with maximum value `5` So, the minimum sum of the maximum elements of these subarrays is `3 + 4 + 5 = 12`.","solution":"def min_sum_of_max_elements(nums, k): Returns the minimum sum of the maximum elements of all subarrays of length k. from collections import deque n = len(nums) if n < k: return None # Edge case: subarray length can\'t be greater than the length of nums # Array to store maximums of subarrays max_of_subarrays = [] dq = deque() # Process the first window (first k elements) for i in range(k): while dq and nums[dq[-1]] <= nums[i]: dq.pop() dq.append(i) # Process the rest of the elements for i in range(k, n): # The element at the front of the deque is the largest element of the previous window max_of_subarrays.append(nums[dq[0]]) # Remove elements that are out of this window while dq and dq[0] <= i - k: dq.popleft() # Remove elements not useful for this window while dq and nums[dq[-1]] <= nums[i]: dq.pop() dq.append(i) # Add the maximum element of the last window max_of_subarrays.append(nums[dq[0]]) # Return the sum of these maximum elements return sum(max_of_subarrays)"},{"question":"Given an array of integers `candies` where each `candies[i]` represents the number of candies in the `i-th` bag, and an integer `k` representing the number of children. Distribute the candies into `k` bags such that each child gets exactly one bag. Return the **maximum number** of candies a child can get. If it is impossible to distribute the candies as described, return `-1`.","solution":"def max_candies_per_child(candies, k): Distribute the candies into k bags such that each child gets exactly one bag. Return the maximum number of candies a child can get. If it is impossible to distribute the candies as described, return -1. if len(candies) < k: return -1 candies.sort(reverse=True) return candies[k-1]"},{"question":"You are given a string `s` consisting of lowercase English letters and a pattern `p` consisting of lowercase English letters where `p` may contain the wildcard character `*`. The wildcard character `*` can match any sequence of characters (including the empty sequence). Return `true` if `p` matches the entire string `s`, otherwise, return `false`.","solution":"def is_match(s, p): Returns true if the string `s` matches the pattern `p` where `p` may contain wildcard character `*` that can match any sequence of characters including the empty sequence. m, n = len(s), len(p) # Create a 2D DP array to hold the match status dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # Empty pattern matches empty string # Initialize for patterns starting with \'*\' for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Fill the DP array for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] else: dp[i][j] = dp[i - 1][j - 1] and s[i - 1] == p[j - 1] return dp[m][n]"},{"question":"You are given a string `s` representing a sentence and an integer `k`. The sentence is composed of words separated by spaces. A word is defined as a sequence of non-space characters. Your task is to split the sentence into words and return the `k`-th word in the sentence. If `k` is larger than the number of words in the sentence, return an empty string. For example, given `s = \\"The quick brown fox jumps over the lazy dog\\"` and `k = 4`, the output should be `\\"fox\\"`.","solution":"def get_kth_word(s, k): Returns the k-th word in the sentence s (1-indexed). If k is out of bounds, returns an empty string. words = s.split() if k <= 0 or k > len(words): return \\"\\" return words[k - 1]"},{"question":"You are given a string `sentence` which consists of lowercase letters and spaces. Words are separated by a single space and there are no leading or trailing spaces. Your task is to find the length of the **shortest** word in the sentence. A word is defined as a contiguous sequence of letters. Return _an integer_ representing the length of the shortest word in the given sentence.","solution":"def length_of_shortest_word(sentence): Returns the length of the shortest word in the given sentence. :param sentence: str - Input string consisting of lowercase letters and spaces :return: int - Length of the shortest word words = sentence.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"Given an integer array `arr` of length `n`, you need to find the **minimum length** of a contiguous subarray of which the sum is at least `s`. If there is no such subarray, return `0` instead. The subarray should be composed of consecutive elements from `arr`. Return the _length of the smallest subarray_ that satisfies the condition.","solution":"def min_subarray_len(s, arr): Returns the minimum length of a contiguous subarray for which the sum is at least `s`. If no such subarray exists, returns 0. :param s: int - the target sum :param arr: List[int] - the input array :return: int - the length of the smallest subarray with sum at least s n = len(arr) min_length = float(\'inf\') left = 0 curr_sum = 0 for right in range(n): curr_sum += arr[right] while curr_sum >= s: min_length = min(min_length, right - left + 1) curr_sum -= arr[left] left += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"Given an array of integers `heights` where `heights[i]` represents the height of person `i`, return the number of pairs `(i, j)` where `i < j` and `heights[i] + heights[j]` is equal to a target value `k`. If there are no such pairs, return `0`. Note that a pair `(i, j)` needs to have distinct indices and must satisfy `i < j`.","solution":"def count_pairs_with_sum(heights, k): Returns the number of pairs (i, j) such that i < j and heights[i] + heights[j] equals k. :param heights: List[int] - List of integers representing the heights. :param k: int - The target sum value. :return: int - The number of valid pairs. count = 0 n = len(heights) for i in range(n): for j in range(i + 1, n): if heights[i] + heights[j] == k: count += 1 return count"},{"question":"You are given two strings `s1` and `s2`. A string `s1` is said to be a **rotation** of string `s2` if it is possible to rearrange the characters of `s1` in such a way that `s2` is formed. Determine whether `s1` is a rotation of `s2`. Return `true` if `s1` is a rotation of `s2`, otherwise return `false`.","solution":"def is_rotation(s1, s2): Determines if s1 is a rotation of s2. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a rotation of s2, False otherwise. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"You are developing software to help students manage their school schedules. Each student has a list of required courses and each course has a set of prerequisite courses that must be completed before taking that course. Given the total number of courses `numCourses` and an array `prerequisites` where `prerequisites[i] = [a, b]` indicates that course `a` must be taken after course `b`, determine if it is possible for a student to complete all courses. Return `true` if it is possible to finish all courses, otherwise return `false`.","solution":"def canFinish(numCourses, prerequisites): from collections import defaultdict, deque # Build the graph and compute in-degrees of each node graph = defaultdict(list) in_degree = [0] * numCourses for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Initialize queue with courses that have no prerequisites queue = deque([i for i in range(numCourses) if in_degree[i] == 0]) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If count equals numCourses, there\'s no cycle and all courses can be completed return count == numCourses"},{"question":"You are given a **0-indexed** binary array `arr` consisting of only `0`s and `1`s. The task is to find the **length of the longest contiguous subarray** such that after flipping at most one `0` to `1`, all elements of the subarray are `1`. Return _an integer_ representing the **length of the longest such subarray**. Note: A **contiguous subarray** is a sequence of elements within an array that are in a single continuous segment.","solution":"def longest_ones(arr): n = len(arr) max_len = 0 left = 0 zeros = 0 for right in range(n): if arr[right] == 0: zeros += 1 while zeros > 1: if arr[left] == 0: zeros -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a list of integers representing the positions of houses along a street, and a list of integers representing the positions of heaters along the same street. An integer `x` in these lists represents a house or heater located at position `x` on the street. A heater can warm any house that is within its radius of heat, denoted as `r`. Your task is to find the minimum radius `r` such that all houses are covered by at least one heater. Return the minimum radius of the heaters that would result in all houses being covered by a heater. If `houses` or `heaters` is empty, return `-1`. **Note**: Position of houses and heaters can be negative, zero, or positive integers.","solution":"def find_min_radius(houses, heaters): if not houses or not heaters: return -1 houses.sort() heaters.sort() def binary_search(value): left, right = 0, len(heaters) - 1 while left <= right: mid = left + (right - left) // 2 if heaters[mid] < value: left = mid + 1 else: right = mid - 1 return left radius = 0 for house in houses: pos = binary_search(house) left_heater = heaters[pos-1] if pos - 1 >= 0 else float(\'-inf\') right_heater = heaters[pos] if pos < len(heaters) else float(\'inf\') min_dist = min(abs(left_heater - house), abs(right_heater - house)) radius = max(radius, min_dist) return radius"},{"question":"Your task is to implement a function that takes a string `s` as input and returns a new string where the characters are sorted in decreasing order of their frequency. If two characters have the same frequency, they should appear in the order they occurred in the input string. For example, given the string `\\"tree\\"`, the output should be `\\"eetr\\"`, since \'e\' occurs twice and \'t\' and \'r\' each occur once. Note that \'e\' comes before \'t\' and \'r\' in the original string. Your function should return the result as a single string.","solution":"from collections import Counter from operator import itemgetter def frequency_sort(s): This function takes a string `s` as input and returns a new string where the characters are sorted in decreasing order of their frequency. If two characters have the same frequency, they appear in the order they occurred in the input string. count = Counter(s) sorted_counts = sorted(count.items(), key=lambda x: (-x[1], s.index(x[0]))) return \'\'.join([char * freq for char, freq in sorted_counts])"},{"question":"You are given a list of directories and files such that each entry is represented as a path string in the format `\\"/dir1/dir2/.../dirN/file.ext\\"`. Write a function that returns all the duplicate files in the file system in terms of their content. You need to output a list of groups of duplicate files where each group is a list containing the file paths of all duplicates. Each file is identified by its absolute path, which may include directory paths that start from the root `/`. The file content is guaranteed to be a non-empty string.","solution":"import os from collections import defaultdict def find_duplicate_files(files): This function takes a list of files with their paths and returns the groups of duplicate files based on their content. Each group contains file paths that have the same content. content_to_paths = defaultdict(list) for path in files: # Split the components of the path and content file_path, file_content = path.rsplit(\'(\', 1) file_content = file_content.rstrip(\')\') # Group the files by their content content_to_paths[file_content].append(file_path) # Extract only the groups with more than one file return [paths for paths in content_to_paths.values() if len(paths) > 1]"},{"question":"You are given an array of integers `arr` representing the heights of students in a row. Arrange the students standing in such a way that each student can see the front students if they are taller than the one immediately in front of them. Specifically, rearrange the array such that every student can see the student directly in front of them unless they are shorter or of the same height. The arrangement should be done in place, and after the rearrangement, return the modified array representing the order in which students are standing.","solution":"def can_see_front(arr): Rearrange the array such that each student can see the student directly in front unless they are shorter or of the same height. arr.sort(reverse=True) return arr"},{"question":"A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child. You are given the `inorder` and `postorder` traversal arrays of a binary tree. Construct the binary tree and return its root. - `inorder` traversal means traversing the tree in the order: left subtree, root, right subtree. - `postorder` traversal means traversing the tree in the order: left subtree, right subtree, root. For example, given the following: - `inorder = [9, 3, 15, 20, 7]` - `postorder = [9, 15, 7, 20, 3]` The constructed binary tree would be: ``` 3 / 9 20 / 15 7 ``` Return the root of the constructed binary tree.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(inorder, postorder): Constructs a binary tree given the inorder and postorder traversal arrays. Arguments: inorder -- a list of integers representing the inorder traversal of the tree postorder -- a list of integers representing the postorder traversal of the tree Returns: The root of the constructed binary tree. if not inorder or not postorder: return None # Dictionary to hold the index of each value in inorder to speed up lookups inorder_index_map = {val: idx for idx, val in enumerate(inorder)} def array_to_tree(left, right): # Base case if left > right: return None # The next element in postorder will be the root of the current subtree root_val = postorder.pop() root = TreeNode(root_val) # Root splits inorder list into left and right subtrees index = inorder_index_map[root_val] # Recursively build the right subtree root.right = array_to_tree(index + 1, right) # Recursively build the left subtree root.left = array_to_tree(left, index - 1) return root # Start from the whole inorder array return array_to_tree(0, len(inorder) - 1)"},{"question":"Write a function that takes an integer `n` and returns all possible unique combinations of factors (excluding 1 and `n`) that multiply to `n`. Each combination should be represented as a list of integers. The combinations can be returned in any order. However, the factors should be listed in non-descending order within each combination. If no combination exists, return an empty list. # Example Input and Output: * Input: `n = 12` Output: `[[2, 6], [2, 2, 3], [3, 4]]` * Input: `n = 15` Output: `[[3, 5]]` * Input: `n = 28` Output: `[[2, 14], [2, 2, 7], [4, 7]]`","solution":"def get_factors_combinations(n): def backtrack(start, n, curr_combo, results): if n == 1 and len(curr_combo) > 1: results.append(curr_combo[:]) return for i in range(start, int(n**0.5) + 1): if n % i == 0: curr_combo.append(i) backtrack(i, n // i, curr_combo, results) curr_combo.pop() if n >= start: curr_combo.append(n) backtrack(n, 1, curr_combo, results) curr_combo.pop() results = [] backtrack(2, n, [], results) return results"},{"question":"Given a string `s` representing a valid mathematical expression, return _the result_ of evaluating the expression. The expression string may contain open `(` and closing parentheses `)`, the plus `+` or minus `-` operators, non-negative integers, and empty spaces `\' \'`. The expression string does not contain any invalid characters. **Note**: You may assume that the given expression is always valid.","solution":"def evaluate_expression(s): Evaluates a valid mathematical expression given as a string containing open `(` and closing parentheses `)`, the plus `+` or minus `-` operators, non-negative integers, and empty spaces `\' \'`. def helper(s, i): stack = [] num = 0 sign = 1 while i < len(s): char = s[i] if char.isdigit(): num = num * 10 + int(char) elif char == \'+\': stack.append(sign * num) num = 0 sign = 1 elif char == \'-\': stack.append(sign * num) num = 0 sign = -1 elif char == \'(\': res, new_i = helper(s, i + 1) num = res i = new_i elif char == \')\': stack.append(sign * num) return sum(stack), i i += 1 stack.append(sign * num) return sum(stack), i s = s.replace(\\" \\", \\"\\") return helper(s, 0)[0]"},{"question":"You are given a **0-indexed** integer array `arr` of size `n` and an integer `k`. A **subarray** is a contiguous segment of the array. Your task is to **find the starting and ending indices** of the subarray with length exactly `k` that has the **maximum sum**. If there are multiple such subarrays, return the one with the smallest starting index. If no such subarray exists, return `[-1, -1]`. * For example, given `arr = [1, 4, 2, 5, 3, 2]` and `k = 3`, the subarray with the maximum sum and length exactly `k` is `[4, 2, 5]`, which starts at index `1` and ends at index `3`. Therefore, the result would be `[1, 3]`. If `arr = [1, 2]` and `k = 3`, since no subarray of length `k` exists, the result would be `[-1, -1]`. Return _an array with the starting and ending indices of the subarray with the maximum sum of length `k` or `[-1, -1]` if no such subarray exists_.","solution":"def max_sum_subarray(arr, k): Finds the starting and ending indices of the subarray with length exactly k that has the maximum sum. If multiple such subarrays exist, returns the one with the smallest starting index. If no such subarray exists, returns [-1, -1]. n = len(arr) if n < k: return [-1, -1] max_sum = float(\'-inf\') current_sum = sum(arr[:k]) max_start_index = 0 for i in range(n - k + 1): if i > 0: current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum > max_sum: max_sum = current_sum max_start_index = i return [max_start_index, max_start_index + k - 1]"},{"question":"Given a string `text`, return _a new string that is derived by reversing the order of the words in the original string_. Words are defined as sequences of characters separated by spaces. Ensure that there are no leading or trailing spaces in the output, and the words are separated by a single space.","solution":"def reverse_words(text): Reverses the order of words in the input string. Parameters: text (str): The input string which may contain multiple words. Returns: str: A new string with the order of words reversed. # Split the text into words words = text.split() # Reverse the order of words reversed_words = words[::-1] # Join the reversed words with a single space return \\" \\".join(reversed_words)"},{"question":"You are given a binary tree with `n` nodes. Each node has a value that is a single character from the set `{a, b, c, ... , z}`. You need to find the longest path in the tree such that all the values along the path are the same. The path does not necessarily need to pass through the root, but it must be a continuous sequence of nodes connected by edges. Return _the length of the longest path in the tree with all the same character_.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longest_univalue_path(root): Finds the longest path in the binary tree with all the same character. :param root: TreeNode, root of the binary tree :return: int, length of the longest univalue path if not root: return 0 def helper(node): nonlocal max_length if not node: return 0 left_len = helper(node.left) right_len = helper(node.right) left_univalue_len = 0 right_univalue_len = 0 if node.left and node.left.val == node.val: left_univalue_len = left_len + 1 if node.right and node.right.val == node.val: right_univalue_len = right_len + 1 max_length = max(max_length, left_univalue_len + right_univalue_len) return max(left_univalue_len, right_univalue_len) max_length = 0 helper(root) return max_length"},{"question":"A binary search tree (BST) is a node-based binary tree data structure which has the following properties: - The left subtree of a node contains only nodes with keys **less than** the node\'s key. - The right subtree of a node contains only nodes with keys **greater than** the node\'s key. - Both the left and right subtrees must also be binary search trees. Given the root of a binary search tree and an integer `k`, return the `k`th smallest value (1-indexed) in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest value in the BST. def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] inorder_elements = inorder_traversal(root) return inorder_elements[k - 1]"},{"question":"Given an `n x n` grid containing only values `0` and `1`, determine the shortest path from the top-left corner to the bottom-right corner. You can move up, down, left, or right. The path can only pass through cells containing `0`. If there is no such path, return `-1`. The top-left corner and the bottom-right corner are not necessarily `0`.","solution":"from collections import deque def shortest_path(grid): Determines the shortest path from the top-left corner to the bottom-right corner in an n x n grid containing only values 0 and 1. You can move up, down, left, or right. The path can only pass through cells containing 0. Parameters: grid (list of list of int): The grid containing 0s and 1s. Returns: int: Length of the shortest path or -1 if no such path exists. n = len(grid) if grid[0][0] != 0 or grid[n-1][n-1] != 0: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, n-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given a list of integers `integers` and another integer `target`. Your task is to determine whether there exists a pair of elements in `integers` whose sum is equal to `target`. Return `true` if such a pair exists, or `false` otherwise. The solution should have a time complexity of O(n).","solution":"def has_pair_with_sum(integers, target): Determines whether there exists a pair of elements in the list `integers` whose sum is equal to `target`. :param integers: List of integers. :param target: Target sum. :return: True if such a pair exists, False otherwise. seen = set() for num in integers: if target - num in seen: return True seen.add(num) return False"},{"question":"You are given a list of integers representing `student` heights in a class and an integer `x` representing the desired height of a student you want to check. Implement the function `find_closest_height(student_heights: List[int], x: int) -> int` that takes the list of student heights and the desired height as input and returns the height that is closest to `x`. If there are multiple heights equally close to `x`, return the smallest one. The list of student heights is guaranteed to have at least one student.","solution":"from typing import List def find_closest_height(student_heights: List[int], x: int) -> int: Returns the height that is closest to the desired height x. If there are multiple heights equally close, returns the smallest one. closest_height = student_heights[0] min_diff = abs(student_heights[0] - x) for height in student_heights[1:]: diff = abs(height - x) if diff < min_diff or (diff == min_diff and height < closest_height): min_diff = diff closest_height = height return closest_height"},{"question":"You are given a string `s` consisting of letters and digits. Rearrange the characters of the string so that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, return an empty string. If multiple valid rearrangements exist, return any of them.","solution":"import heapq from collections import Counter def reorganize_string(s: str) -> str: Rearranges the characters of the string so that no two adjacent characters are the same. If it is not possible, return an empty string. # Step 1: Count the frequencies of each character char_count = Counter(s) # Step 2: Create a max heap with (-frequency, char) so that we can pop the most frequent character first max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq = freq + 1 # Decrement freq since it\'s added to result prev_char = char result_str = \'\'.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find two **distinct** numbers in the array that add up to the target. Return an array containing the values of these two numbers, sorted in ascending order. If there are multiple valid pairs, return the one with the smallest first number. If no such pair exists, return an **empty array**. --- Here is an example to illustrate the problem: ```python nums = [2, 7, 11, 15] target = 9 ``` In this case, the output should be `[2, 7]` since `2 + 7 = 9`. If the array is `nums = [1, 2, 3, 4, 5]` and `target = 8`, the output should be `[3, 5]` because there are multiple pairs `(1, 7)`, `(2, 6)`, and `(3, 5)`, but `[3, 5]` has the smallest first number. If the array is `nums = [1, 2, 3, 4, 5]` and `target = 10`, the output should be `[]` because no two numbers add up to `10`.","solution":"def two_sum(nums, target): Finds two distinct numbers in the array that add up to the target and returns them sorted in ascending order. If multiple pairs exist, returns the pair with the smallest first number. If no such pair exists, returns an empty array. seen = {} smallest_pair = None for num in nums: complement = target - num if complement in seen: current_pair = sorted([num, complement]) if smallest_pair is None or current_pair[0] < smallest_pair[0]: smallest_pair = current_pair seen[num] = True return smallest_pair if smallest_pair else []"},{"question":"A logistics company needs to manage a fleet of trucks that deliver packages to various destinations along a highway. The highway is represented as a straight line and there are `n` destinations numbered from `0` to `n - 1` along this line. Each destination has a certain volume of packages to be delivered which is given by an integer array `packages` where `packages[i]` represents the volume of packages to be delivered to the `ith` destination. The truck has a maximum capacity of `capacity`, meaning it can carry `capacity` units of packages at once. The truck starts at the `0th` destination, picks up packages from a base, and delivers them to their respective destinations. After delivering packages to the `ith` destination, it can proceed to the next destination or return to the base to pick up more packages if it doesn\'t have enough remaining capacity for the next delivery. Create an algorithm to determine the minimum number of trips the truck needs to make to deliver all packages to their destinations. Note that the truck can only deliver to one destination per trip. Given an integer array `packages` of `n` integers, and an integer `capacity`, return the minimum number of trips the truck needs to make to deliver all packages.","solution":"def minimum_trips(packages, capacity): trips = 0 i = 0 while i < len(packages): if packages[i] <= capacity: trips += 1 i += 1 else: trips += 1 packages[i] -= capacity return trips"},{"question":"You are given a string `message` containing only lowercase English alphabets and an integer `k`. The task is to rotate `message` to the right by `k` positions. The rotation means that each character of `message` is shifted to the right by `k` positions and characters at the end of the string wrap around to the beginning. Return the resultant rotated string. Example: If `message = \\"hello\\"` and `k = 2`, the rotated string should be `\\"lohel\\"`.","solution":"def rotate_string(message, k): Rotates the input string message to the right by k positions. Parameters: message (str): The input string containing only lowercase alphabets. k (int): The number of positions to rotate the string to the right. Returns: str: The rotated string. n = len(message) k = k % n # In case k is larger than the length of the message return message[-k:] + message[:-k]"},{"question":"You are given a **0-indexed** array of non-negative integers `arr`. You are also given a **0-indexed** 2D integer array `queries` where `queries[i] = [li, ri]`, and each query represents a range `[li, ri]`. For each query, you need to calculate and return the length of the longest contiguous subarray within the specified range `[li, ri]` that has an equal number of even and odd numbers. Return _an array_ `answer` _of the same length as_ `queries`, _where_ `answer[i]` _is the answer to the_ `ith` _query_. If no such subarray exists, the answer for that query should be `0`.","solution":"def longest_even_odd_subarray(arr, queries): def max_even_odd_length(subarr): n = len(subarr) even_count = 0 odd_count = 0 max_len = 0 prefix = {0: -1} # prefix counts to index for i in range(n): if subarr[i] % 2 == 0: even_count += 1 else: odd_count += 1 # check difference between counts in prefix diff = even_count - odd_count if diff in prefix: max_len = max(max_len, i - prefix[diff]) else: prefix[diff] = i return max_len result = [] for l, r in queries: subarr = arr[l:r+1] result.append(max_even_odd_length(subarr)) return result"},{"question":"You are given an `n x n` integer matrix `mat`. You need to determine if there is a **magic square** of size `3 x 3` anywhere in the matrix. A **magic square** is a `3 x 3` grid filled with distinct integers from 1 to 9 such that each row, each column, and both diagonals all have the same sum. You should determine if there is at least one such **magic square** in the matrix. Return `true` if a **magic square** exists, otherwise return `false`.","solution":"def is_magic_square(submatrix): s = 15 # Sum of each row/column/diagonal in a 3x3 magic square of 1-9 return ( sum(submatrix[0]) == s and sum(submatrix[1]) == s and sum(submatrix[2]) == s and sum(submatrix[i][0] for i in range(3)) == s and sum(submatrix[i][1] for i in range(3)) == s and sum(submatrix[i][2] for i in range(3)) == s and submatrix[0][0] + submatrix[1][1] + submatrix[2][2] == s and submatrix[0][2] + submatrix[1][1] + submatrix[2][0] == s and sorted(submatrix[i][j] for i in range(3) for j in range(3)) == list(range(1, 10)) ) def contains_magic_square(matrix): rows, cols = len(matrix), len(matrix[0]) for i in range(rows - 2): for j in range(cols - 2): submatrix = [matrix[i + x][j:j + 3] for x in range(3)] if is_magic_square(submatrix): return True return False"},{"question":"Given a **0-indexed** integer array `heights` representing the height of walls, you need to calculate the amount of water that can be trapped after raining. Each element in the array represents the height of the wall at that index. Water can only be trapped between two walls with sufficient height. Return _the total amount of trapped water_.","solution":"def trap(height): Calculate the total amount of trapped water between walls. Args: height (List[int]): A list of integers representing wall heights. Returns: int: The total units of trapped water. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] total_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) total_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) total_water += max(0, right_max - height[right]) return total_water"},{"question":"You need to generate combinations of strings. Given an array of distinct strings `wordlist`, you want to find all possible permutations of the strings in the array that form a sequence of maximum length. Each permutation should be considered unique based on its order. You should return all these permutations in an array of arrays. The order of permutations in the output array does not matter.","solution":"import itertools def generate_combinations(wordlist): Returns all possible permutations of the strings in the wordlist. Each permutation is unique based on its order. Parameters: wordlist (list of str): List of distinct strings. Returns: list of list of str: List of all permutations of the wordlist. return list(itertools.permutations(wordlist))"},{"question":"You are given two arrays `nums1` and `nums2` of size `n` and `m` respectively, both sorted in non-decreasing order. Merge the two arrays into a single array sorted in non-decreasing order and return the newly formed array. Ensure that your solution has a time complexity of O(n + m).","solution":"def merge_sorted_arrays(nums1, nums2): Merges two sorted arrays into a single sorted array. Args: nums1: List[int] - First sorted array. nums2: List[int] - Second sorted array. Returns: List[int] - Merged sorted array. merged_array = [] i, j = 0, 0 while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: merged_array.append(nums1[i]) i += 1 else: merged_array.append(nums2[j]) j += 1 # Append remaining elements of nums1 or nums2 while i < len(nums1): merged_array.append(nums1[i]) i += 1 while j < len(nums2): merged_array.append(nums2[j]) j += 1 return merged_array"},{"question":"You need to traverse a 2D array of integers, `grid`, representing a field of land mines and empty spaces. Some cells contain land mines (indicated by a `-1`) and others are empty (indicated by a `0`). You are to move from the top-left corner of the grid to the bottom-right corner. You can only move right or down at each step. Your goal is to find the **minimum number of steps** required to reach the bottom-right corner from the top-left corner. If it\'s not possible to reach the destination, return `-1`.","solution":"from collections import deque def min_steps_to_reach_end(grid): Find the minimum number of steps required to reach the bottom-right corner from the top-left corner. If it\'s not possible to reach the destination, return -1. rows, cols = len(grid), len(grid[0]) if grid[0][0] == -1 or grid[rows-1][cols-1] == -1: return -1 # Directions to move: right and down directions = [(0, 1), (1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set() visited.add((0, 0)) while queue: row, col, steps = queue.popleft() # If we reached the bottom-right corner if row == rows - 1 and col == cols - 1: return steps for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < rows and 0 <= c < cols and (r, c) not in visited and grid[r][c] != -1: queue.append((r, c, steps + 1)) visited.add((r, c)) # If we exit the loop without having reached the bottom-right corner, return -1 return -1"},{"question":"Write a function that takes an integer `n` as input and returns the smallest integer `k` such that the sum of the digits of `k` is equal to `n`. If no such `k` exists, return `-1`. Note that `k` must be a non-negative integer.","solution":"def smallest_integer_with_digit_sum(n): Returns the smallest integer k such that the sum of the digits of k is equal to n. If no such k exists, return -1. if n < 1: return -1 # The maximum sum of digits less than a single digit number is 9. # If the sum required is greater, we need to form the number using more digits. k = 0 if n <= 9: return n # Form the smallest number k where digits add up to n digits = [] while n > 0: if n >= 9: digits.append(9) n -= 9 else: digits.append(n) n = 0 # Convert digits array to a number k = int(\'\'.join(map(str, digits[::-1]))) return k"},{"question":"You are given a 2D grid of characters and a string `word`. Write a function that returns a boolean indicating whether the `word` can be found in the grid following these rules: the word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.","solution":"def exist(board, word): Returns True if the word exists in the board, otherwise False. def dfs(board, word, i, j, k): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False temp = board[i][j] board[i][j] = \'#\' res = (dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1)) board[i][j] = temp return res for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"Given an array of integers `arr` where 1 ≤ `arr[i]` ≤ `n` (n = size of array), some elements appear twice and others appear once. Your task is to find all the elements that appear twice in this array. Return an array of the duplicate elements in any order. Implement your solution with a time complexity of `O(n)` and space complexity of `O(1)` (not counting the output array). (Note: The array should not be modified during the solution process)","solution":"def find_duplicates(arr): Find all elements that appear twice in the array. Args: arr (List[int]): The input array with size n where 1 ≤ arr[i] ≤ n. Returns: List[int]: A list of elements that appear twice. # List to store the results result = [] # Iterate over the elements in the array for num in arr: # Use the absolute value of the current element to handle visited elements index = abs(num) - 1 # If the value at the index has already been negated, it implies duplicate if arr[index] < 0: result.append(abs(num)) else: # Negate the value at the respective index to mark it visited arr[index] = -arr[index] # Restore the array to its original state for i in range(len(arr)): arr[i] = abs(arr[i]) return result"},{"question":"You are given a string representing a code snippet that may contain nested brackets of three types: `()`, `{}`, and `[]`. Write a function that determines if the brackets are balanced. Brackets are considered balanced if: - Each opening bracket has a corresponding closing bracket of the same type. - Opening brackets are matched in the correct order with closing brackets. Your function should return `True` if the brackets are balanced and `False` otherwise. For example: - The string `\\"{[()]}\\"` is balanced and should return `True`. - The string `\\"{[(])}\\"` is not balanced and should return `False`. - The string `\\"{{[[(())]]}}\\"` is balanced and should return `True`. Implement the function `def isBalanced(s: str) -> bool:` to determine if the input string `s` has balanced brackets.","solution":"def isBalanced(s: str) -> bool: Determines if the brackets in the input string are balanced. Args: s (str): The input string containing the brackets. Returns: bool: True if the brackets are balanced, False otherwise. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: continue # ignore non-bracket characters return stack == []"},{"question":"Given a list of `n` integers, write a function to find the maximum sum of a contiguous subarray with at most `k` elements. You need to return both the maximum sum and the subarray itself. If multiple subarrays have the same maximum sum, return any one of them.","solution":"def max_sum_contiguous_subarray(nums, k): Finds the maximum sum of a contiguous subarray with at most `k` elements. Returns a tuple of the maximum sum and the subarray. n = len(nums) if n == 0: return (0, []) max_sum = float(\'-inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] # Check if the current subarray length exceeds k if end - start + 1 > k: current_sum -= nums[start] start += 1 if current_sum > max_sum: max_sum = current_sum max_subarray = nums[start:end + 1] return (max_sum, max_subarray)"},{"question":"You are given a 2D grid `grid` of size `m x n` where each cell represents an area that may contain a distinct type of tree, represented by an integer. A tree can only be connected vertically or horizontally to another tree of the same type. Calculate the number of distinct tree clusters present in the grid. A tree cluster is defined as a set of adjacent trees of the same type. **Example:** Given the following grid: ``` [ [1, 2, 3], [1, 2, 2], [3, 2, 2] ] ``` The distinct tree clusters would be: - Cluster 1 containing `[1]` at (0, 0) and (1, 0) - Cluster 2 containing `[2]` at (0, 1), (1, 1), (1, 2), and (2, 1) and (2, 2) - Cluster 3 containing `[3]` at (0, 2) - Cluster 4 containing `[3]` at (2, 0) The function should return `4`, representing the total number of tree clusters.","solution":"def count_tree_clusters(grid): Returns the number of distinct tree clusters in the grid. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y, tree_type): if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] != tree_type: return visited[x][y] = True dfs(x + 1, y, tree_type) # Visit down dfs(x - 1, y, tree_type) # Visit up dfs(x, y + 1, tree_type) # Visit right dfs(x, y - 1, tree_type) # Visit left cluster_count = 0 for i in range(m): for j in range(n): if not visited[i][j]: cluster_count += 1 dfs(i, j, grid[i][j]) return cluster_count"},{"question":"You are given an array of integers `arr`. Implement a function that collects and returns the indices of the array where the local maxima occur. A local maximum is defined as an element that is greater than its neighbors, i.e., for an element at index `i` to be considered a local maximum, it must satisfy `arr[i] > arr[i-1]` and `arr[i] > arr[i+1]` (assuming its neighbors exist). **Function Signature:** ```python def find_local_maxima(arr: List[int]) -> List[int]: pass ``` **Example:** ```python find_local_maxima([1, 3, 7, 1, 2, 6, 3, 2, 7, 1]) # Output: [2, 5, 8] ``` **Note:** - The first and last elements of the array are not considered local maxima because they do not have two neighbors for comparison. - If the array length is less than 3, there will be no local maxima.","solution":"from typing import List def find_local_maxima(arr: List[int]) -> List[int]: Returns a list of indices where local maxima occur in the array. if len(arr) < 3: return [] local_maxima = [] for i in range(1, len(arr) - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: local_maxima.append(i) return local_maxima"},{"question":"Given a matrix of integers `matrix`, where each element represents the height of a building and the matrix has dimensions `n x m`, write a function to find the maximum possible square area that can be formed where all buildings in that square have the same height. Return the area of that maximum square. The function should efficiently handle large matrices up to size `200 x 200`.","solution":"def maximalSquare(matrix): Returns the area of the largest square that can be formed where all buildings in that square have the same height. if not matrix: return 0 n = len(matrix) m = len(matrix[0]) # Create a 3D dp array to store the maximum side length of squares with the same height ending at (i, j) dp = [[[0 for _ in range(201)] for _ in range(m)] for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): current_height = matrix[i][j] dp[i][j][current_height] = 1 if i > 0 and j > 0: for h in range(1, 201): if matrix[i][j] == h: dp[i][j][h] = min(dp[i-1][j][h], dp[i][j-1][h], dp[i-1][j-1][h]) + 1 max_side = max(max_side, dp[i][j][current_height]) # Return the area of the largest square return max_side * max_side"},{"question":"Given an integer array `arr`, find the maximum number of non-overlapping subarrays such that each subarray has a sum equal to `target`. Return the count of such subarrays.","solution":"def max_non_overlapping_subarrays(arr, target): Finds the maximum number of non-overlapping subarrays with sum equal to target. :param arr: List[int] - The input array of integers. :param target: int - The target sum for subarrays. :return: int - The maximum number of non-overlapping subarrays with sum equal to target. sum_so_far = 0 count = 0 seen_sums = set([0]) for num in arr: sum_so_far += num if (sum_so_far - target) in seen_sums: count += 1 sum_so_far = 0 seen_sums = set([0]) else: seen_sums.add(sum_so_far) return count"},{"question":"You are given a 2D integer array `grid` representing a rectangular grid of integers, where each cell contains an initial value. You need to perform the following operations to convert the grid to a magic square grid: - Decrease the value of any cell to a smaller non-negative integer. - Swap the values of any two cells. A magic square grid is defined as a grid where: - The sum of the values in each row, each column, and the two main diagonals are all equal. Return _the **minimum** possible total sum of the values in the grid after performing the operations to convert it to a magic square grid_. If it is not possible to form a magic square grid, return `-1`.","solution":"def min_magic_square_sum(grid): Converts a given 3x3 grid to a magic square grid with the minimum total sum. If it\'s not possible to convert, return -1. magic_squares = [ [8, 1, 6, 3, 5, 7, 4, 9, 2], [6, 1, 8, 7, 5, 3, 2, 9, 4], [4, 9, 2, 3, 5, 7, 8, 1, 6], [2, 9, 4, 7, 5, 3, 6, 1, 8], [8, 3, 4, 1, 5, 9, 6, 7, 2], [4, 3, 8, 9, 5, 1, 2, 7, 6], [6, 7, 2, 1, 5, 9, 8, 3, 4], [2, 7, 6, 9, 5, 1, 4, 3, 8], ] grid_flat = [grid[i][j] for i in range(3) for j in range(3)] min_sum = float(\'inf\') for ms in magic_squares: total_sum = sum(grid_flat[i] - ms[i] for i in range(9) if grid_flat[i] > ms[i]) min_sum = min(min_sum, total_sum) return min_sum if min_sum != float(\'inf\') else -1"},{"question":"You are given a string `s` and a string `t`. You want to form string `t` from `s` by removing some characters from `s` and rearranging the remaining characters. Return _true_ if it is possible to form string `t` from `s` in this way, and _false_ otherwise.","solution":"def can_form_string(s, t): Determines if it is possible to form string t from string s by removing some characters from s and rearranging the remaining characters. Parameters: s (str): Source string t (str): Target string Returns: bool: True if t can be formed from s, False otherwise. from collections import Counter # Count frequency of characters in s and t s_counter = Counter(s) t_counter = Counter(t) # For each character in t, check if s has enough of it for char in t_counter: if t_counter[char] > s_counter.get(char, 0): return False return True"},{"question":"A company is developing an employee time-tracking application. Each employee has an associated list of timestamps that indicate their log-ins and log-outs throughout the day. You are given a list of strings `logTimes` where each element is in the format \\"HH:MM-HH:MM\\" (e.g., \\"09:00-17:00\\") representing an employee\'s log-in and log-out times. Each employee might have multiple log-in/log-out periods in a single day. Your task is to compute the total number of minutes each employee was logged in during the day. Return a list of integers representing the total minutes for each corresponding entry in `logTimes`. - For example, given `logTimes = [\\"09:00-10:30\\", \\"13:45-14:15\\", \\"16:00-17:00\\"]`, the output should be `[90, 30, 60]`.","solution":"def time_diff_in_minutes(time1, time2): Returns the difference in minutes between two time strings formatted as \\"HH:MM\\". h1, m1 = map(int, time1.split(\':\')) h2, m2 = map(int, time2.split(\':\')) return (h2 - h1) * 60 + (m2 - m1) def calculate_total_minutes(logTimes): Given a list of log-in/log-out times in the format [\\"HH:MM-HH:MM\\", ...], returns a list of integers representing the total minutes for each entry. total_minutes = [] for period in logTimes: start, end = period.split(\'-\') minutes = time_diff_in_minutes(start, end) total_minutes.append(minutes) return total_minutes"},{"question":"You are given two integer arrays `startTimes` and `endTimes`, and an integer `n`. An event `i` starts at `startTimes[i]` and ends at `endTimes[i]`. Your task is to schedule exactly `n` non-overlapping events from the given events. Return _the maximum number of events that can be scheduled to obtain exactly `n` non-overlapping events or `-1` if it is not possible to schedule exactly `n` non-overlapping events_. **Example:** ``` Input: startTimes = [1, 3, 0, 5, 8, 5], endTimes = [2, 4, 6, 7, 9, 9], n = 3 Output: 3 ``` In the example above, the events [1,3], [3,4], and [8,9] can be chosen to ensure no two events overlap and the total number of chosen events is exactly 3.","solution":"def max_n_non_overlapping_events(startTimes, endTimes, n): events = sorted(zip(endTimes, startTimes)) selected_events = [] current_end = -1 for end, start in events: if start >= current_end: selected_events.append((start, end)) current_end = end if len(selected_events) == n: return len(selected_events) return -1 if len(selected_events) != n else len(selected_events)"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to reconstruct the string `s` such that no two adjacent characters are the same and the distance between two same characters is at least `k`. If it is not possible to reconstruct the string, return an empty string \\"\\". If there are multiple possible reconstructions, return any of them.","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): if k == 0: return s count = Counter(s) max_heap = [] for char, freq in count.items(): heapq.heappush(max_heap, (-freq, char)) queue = deque() # To keep track of the previous characters result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((char, freq + 1)) # freq is negative, so add 1 if len(queue) < k: continue # Only re-add to heap when we have processed k characters prev_char, prev_freq = queue.popleft() if -prev_freq > 0: heapq.heappush(max_heap, (prev_freq, prev_char)) return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"You are given an integer array `arr`. Append all the unique elements of the array to a new array `result` while maintaining their order of first appearance. Return _the `result` array containing only the unique elements from `arr` in their original order_.","solution":"def unique_elements(arr): Returns a list containing only the unique elements from `arr` in their original order. seen = set() result = [] for element in arr: if element not in seen: seen.add(element) result.append(element) return result"},{"question":"You are given a string `s` containing only lowercase English letters. A substring is called **uniform** if all the characters in the substring are the same. You are allowed to make any number of deletions (possibly none) in `s` such that the remaining string is formed by concatenating one or more **uniform** substrings. Return _the **minimum** number of deletions required to achieve this_.","solution":"def min_deletions_to_uniform_substrings(s): Returns the minimum number of deletions required to make the string formed by concatenating one or more uniform substrings. if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] != s[i - 1]: deletions += 1 return deletions"},{"question":"You are given a string `s` that contains only lowercase English letters, and an integer `k`. Your task is to remove exactly `k` characters from the string `s` such that the sum of the ASCII values of the remaining characters is maximized. Return the maximum possible sum of the ASCII values of the remaining characters after removing exactly `k` characters. If there are multiple ways to achieve this, any valid answer will be accepted.","solution":"def max_ascii_sum(s, k): Removes exactly k characters from the string s such that the sum of the ASCII values of the remaining characters is maximized. :param s: str, the input string containing only lowercase English letters :param k: int, the number of characters to remove :return: int, the maximum possible sum of ASCII values of the remaining characters # Sort the string\'s characters by their ASCII values in ascending order sorted_s = sorted(s) # Remove the first k characters (which have the smallest ASCII values) remaining_chars = sorted_s[k:] # Calculate the sum of ASCII values of the remaining characters max_sum = sum(ord(char) for char in remaining_chars) return max_sum"},{"question":"Design a system to simulate a parking lot. The parking lot consists of multiple levels, each with a fixed number of slots. Your task is to design the following functions in the `ParkingLot` class: * `ParkingLot(int levels, int slotsPerLevel)` Initializes the parking lot with a given number of levels and slots per level. * `bool parkCar(int carId)` Parks a car with the given `carId` in the lowest available slot across all levels, starting from the lowest level to the highest. Returns `true` if the car was successfully parked, and `false` if the lot is full. * `bool unparkCar(int carId)` Removes the car with the given `carId` from the parking lot. Returns `true` if the car was successfully removed, and `false` if the car with the given `carId` does not exist in the parking lot. * `bool isSlotAvailable(int level, int slot)` Returns `true` if the specified slot at the given level is available, and `false` otherwise.","solution":"class ParkingLot: def __init__(self, levels, slotsPerLevel): self.levels = levels self.slotsPerLevel = slotsPerLevel self.lot = [[None for _ in range(slotsPerLevel)] for _ in range(levels)] def parkCar(self, carId): for level in range(self.levels): for slot in range(self.slotsPerLevel): if self.lot[level][slot] is None: self.lot[level][slot] = carId return True return False def unparkCar(self, carId): for level in range(self.levels): for slot in range(self.slotsPerLevel): if self.lot[level][slot] == carId: self.lot[level][slot] = None return True return False def isSlotAvailable(self, level, slot): return self.lot[level][slot] is None"},{"question":"Given an integer array `arr` and an integer `x`, your task is to determine the minimum length of a contiguous subarray of which the product is greater than or equal to `x`. If no such subarray exists, return `0`. A **contiguous subarray** is a consecutive sequence of elements within the array.","solution":"def min_subarray_length_with_product(arr, x): Determines the minimum length of a contiguous subarray of which the product is greater than or equal to x. Parameters: arr (list of int): The input array. x (int): The target product. Returns: int: The minimum length of such a subarray. If no such subarray exists, returns 0. n = len(arr) left = 0 current_product = 1 min_length = float(\'inf\') for right in range(n): current_product *= arr[right] while current_product >= x and left <= right: min_length = min(min_length, right - left + 1) current_product //= arr[left] left += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"You are given an integer array `nums` and an integer `target`. You need to find **two distinct indices** in the array such that the elements at those indices add up to the target value. Return an array of the two indices, sorted in ascending order. If no such indices exist, return an empty array. Ensure your solution has a time complexity of O(n). You may assume that each input would have exactly one solution, and you may not use the same element twice. Inputs: - An integer array `nums`. - An integer `target`. Returns: - An array of two integers representing the indices, or an empty array if no solution exists.","solution":"def two_sum(nums, target): Finds two distinct indices in the array such that their corresponding elements add up to the target value. Args: nums : list[int] An integer array of numbers. target : int The target sum value. Returns: list[int] A list of two integers representing the indices, sorted in ascending order. Returns an empty array if no solution exists. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], index]) num_to_index[num] = index return []"},{"question":"You are given a **0-indexed** integer array `nums` where each element is either a 0 or a 1. You can change at most one element from 0 to 1. Return _the length of the longest **contiguous** subarray of 1\'s you can achieve after at most one change._","solution":"def longest_subarray(nums): Returns the length of the longest contiguous subarray of 1\'s that can be achieved by changing at most one 0 to 1. n = len(nums) max_len, zero_count, left = 0, 0, 0 for right in range(n): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len if zero_count == 1 else max_len - 1 # Handle edge case when no 0 was found."},{"question":"You are given an array of positive integers `heights` representing the heights of buildings in a cityscape. Each building is aligned from left to right, with buildings at indices `i` imposing a blockage on buildings after them if they are taller. A building is considered \\"unobstructed\\" if, starting from that building and moving to the right, there is no other building of equal or greater height blocking it. Your task is to return an array of indices of all \\"unobstructed\\" buildings in the heights array. The indices in the output array should be listed in ascending order.","solution":"def find_unobstructed_buildings(heights): Returns a list of indices of the unobstructed buildings in the heights array. n = len(heights) unobstructed = [] max_height = 0 for i in range(n - 1, -1, -1): if heights[i] > max_height: unobstructed.append(i) max_height = heights[i] return sorted(unobstructed)"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. You need to find the minimal length of a contiguous subarray of which the sum is greater than or equal to `k`. If there is no such subarray, return `-1`. A contiguous subarray is a subarray which appears inside another array sequentially. For example, if the array is `[1, 2, 3, 4]`, then `[1, 2]` is a contiguous subarray but `[1, 3]` is not. Return the length of the smallest subarray with a sum greater than or equal to `k`, or `-1` if no such subarray exists.","solution":"def min_subarray_len(nums, k): n = len(nums) min_length = float(\'inf\') curr_sum = 0 start = 0 for end in range(n): curr_sum += nums[end] while curr_sum >= k: min_length = min(min_length, end - start + 1) curr_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You have a linked list where each node contains an integer value. The list is segmented into multiple sublists, each separated by nodes with the value -1. Your task is to remove all nodes with the value -1 and return the head of a new linked list that represents the concatenation of these sublists in the same order. For example, given the linked list `1 -> 2 -> -1 -> 3 -> 4 -> -1 -> 5`, the resulting linked list should be `1 -> 2 -> 3 -> 4 -> 5`.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_neg_ones_and_concatenate(head): Remove all nodes with the value -1 from the linked list and concatenate remaining nodes. :param head: ListNode, the head of the input linked list. :return: ListNode, the head of the modified linked list. if not head: return None dummy = ListNode(0) current_new = dummy current_original = head while current_original: if current_original.val != -1: current_new.next = ListNode(current_original.val) current_new = current_new.next current_original = current_original.next return dummy.next"},{"question":"Given a string `s` that contains only characters \'a\', \'b\', and \'c\', remove all consecutive duplicate characters from the string such that each character appears at most once consecutively. Return the resultant string. For example, if `s = \\"aaabccba\\"`, the result should be `\\"abcba\\"`. - Implement the function `String removeConsecutiveDuplicates(String s)`.","solution":"def removeConsecutiveDuplicates(s): Removes consecutive duplicate characters from the string `s`. Parameters: s (str): Input string containing only characters \'a\', \'b\', and \'c\'. Returns: str: A string after removing consecutive duplicates. if not s: return \\"\\" result = [s[0]] # Initialize the result with the first character for char in s[1:]: if char != result[-1]: result.append(char) return \'\'.join(result)"},{"question":"You are given a list of non-negative integers representing the length of ropes. Your task is to combine these ropes into one single rope. The cost to combine two ropes is equal to the sum of their lengths. You need to minimize the total cost to combine all the ropes. Write a function that returns the minimum cost to combine all the ropes. The function should take an array of integers as an input and return an integer representing the minimum cost.","solution":"import heapq def min_cost_to_combine_ropes(ropes): Returns the minimum cost to combine all the ropes into one rope. The cost to combine two ropes is equal to the sum of their lengths. Parameters: ropes (list of int): List of non-negative integers representing the length of ropes Returns: int: Minimum cost to combine all the ropes if len(ropes) <= 1: return 0 heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost"},{"question":"You are given a list of integers `arr` where each integer represents the price of a stock on a given day. Now consider a scenario where you are allowed to complete at most `k` transactions to maximize your profit. A transaction consists of buying a stock on one day and selling it on another day afterward. You cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Write an algorithm to find the maximum profit you can achieve with at most `k` transactions. If no profit can be achieved, return `0`.","solution":"def max_profit(prices, k): Returns the maximum profit that can be achieved with at most `k` transactions. if not prices: return 0 n = len(prices) if k >= n // 2: # Simplified case: Best time to buy and sell stocks II logic profit = 0 for i in range(1, n): if prices[i] > prices[i - 1]: profit += prices[i] - prices[i - 1] return profit # Initialize dp table dp = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_diff = -prices[0] for d in range(1, n): dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff) max_diff = max(max_diff, dp[t - 1][d] - prices[d]) return dp[k][-1]"},{"question":"Given a grid of size `m x n` consisting of non-negative integers, where `grid[i][j]` represents the number of stones in the cell `(i, j)`, you are initially located at the top-left cell `(0, 0)`. You can move to the right or down to the cell adjacent to your current cell. Your goal is to reach the bottom-right cell `(m-1, n-1)` and collect as many stones as possible along the way. Write a function that returns _the maximum number of stones you can collect_.","solution":"def maxStones(grid): Returns the maximum number of stones collected by starting from (0, 0) and moving to (m-1, n-1) only moving right or down. Args: grid (List[List[int]]): A 2D list representing the grid of stones. Returns: int: The maximum number of stones that can be collected. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"There is a game where you have an array of `n` integers. You can perform the following operation as many times as you want: choose any two elements from the array and replace both of them with their sum. Your goal is to maximize the maximum element in the resulting array after performing any number of operations. Return the value of the maximum element you can achieve. You are given a 0-indexed integer array `nums` of length `n` representing the initial state of the array. Write a function that returns the maximum possible value of the maximum element after performing the operation described above any number of times.","solution":"def maximize_max_element(nums): Returns the maximum possible value of the maximum element after performing the sum operation on pairs of elements. Parameters: nums (List[int]): The initial state of the array. Returns: int: The maximum possible value of the maximum element. total_sum = sum(nums) return total_sum"},{"question":"Given a list of positive integers `nums`, return the number of elements that have both a **left neighbor** and a **right neighbor** greater than the element itself. Specifically, an element `nums[i]` is considered to have a left neighbor `nums[i-1]` and a right neighbor `nums[i+1]` if `nums[i-1] > nums[i]` and `nums[i+1] > nums[i]`.","solution":"def count_elements_with_greater_neighbors(nums): Returns the number of elements in the list that have both a left neighbor and a right neighbor greater than the element itself. Parameters: nums (list of int): List of positive integers. Returns: int: The count of such elements. count = 0 for i in range(1, len(nums) - 1): if nums[i - 1] > nums[i] and nums[i + 1] > nums[i]: count += 1 return count"},{"question":"Given a string `s` containing only characters `a` and `b`, return the minimum number of deletions needed so that there are no two adjacent characters that are the same. For example: - Input: `s = \\"aab\\"` - Output: `1` - Explanation: By deleting one \'a\' from the string, the result will be \\"ab\\", which has no two adjacent characters that are the same.","solution":"def min_deletions(s): Returns the minimum number of deletions needed so that there are no two adjacent characters that are the same. if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions"},{"question":"Given a **1-indexed** integer array `heights` representing the height of individuals standing in a single line, two individuals are called a *pair* if the second individual is taller than the first one and they are positioned consecutively in the line. Return _the **number of pairs**_ in the `heights` array where the second individual is taller than the first one.","solution":"def count_taller_pairs(heights): Returns the number of pairs where the second individual is taller than the first one. count = 0 for i in range(len(heights) - 1): if heights[i + 1] > heights[i]: count += 1 return count"},{"question":"Given an array of integers `arr`, find the **length** of the longest subsequence such that every element in the subsequence is a power of two. A power of two is a number of the form `2^k` where `k` is a non-negative integer (e.g., `1`, `2`, `4`, `8`, etc.). You may assume that all elements in `arr` are positive integers.","solution":"def is_power_of_two(n): Check if a number is a power of two. return (n & (n - 1)) == 0 and n > 0 def longest_power_of_two_subsequence(arr): Returns the length of the longest subsequence such that every element in the subsequence is a power of two. longest_subseq = [num for num in arr if is_power_of_two(num)] return len(longest_subseq)"},{"question":"Four friends want to participate in a relay race. Each friend runs at a different speed. You are given an integer array `speeds` where `speeds[i]` is the speed of the `i-th` friend. The race consists of four consecutive runs. You need to determine the configuration in which the friends should run so that the total relay time is minimized. The total relay time is the sum of individual times taken by each friend. Return `the order of friends` that yields the minimum total relay time in an array. Note: You can assume the speeds array will always have exactly four integers, and each integer represents the time taken for that friend to complete their run.","solution":"def optimal_relay_order(speeds): Determines the order of friends for the relay race to minimize total relay time. Parameters: speeds (list of int): List of 4 integers representing the speed of each friend. Returns: list of int: Order of friends (indices) that minimizes the total relay time. return sorted(range(len(speeds)), key=lambda i: speeds[i])"},{"question":"You are given two non-negative integer arrays `nums1` and `nums2`, where each array represents a sequence of digits. Combine these two sequences into the smallest possible number by using each digit from `nums1` and `nums2` exactly once while maintaining the order of digits within each sequence. If multiple smallest numbers are possible, return any one of them. Write a function that returns the resulting smallest number as a single integer array.","solution":"def combine_smallest_number(nums1, nums2): Combine nums1 and nums2 into the smallest possible number while maintaining the order of digits within each sequence. result = [] i, j = 0, 0 while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: result.append(nums1[i]) i += 1 elif nums1[i] > nums2[j]: result.append(nums2[j]) j += 1 else: # When nums1[i] == nums2[j], compare the next digits to determine # which sequence will lead to a smaller number k1, k2 = i, j while k1 < len(nums1) and k2 < len(nums2) and nums1[k1] == nums2[k2]: k1 += 1 k2 += 1 if k1 < len(nums1) and (k2 >= len(nums2) or nums1[k1] < nums2[k2]): result.append(nums1[i]) i += 1 else: result.append(nums2[j]) j += 1 while i < len(nums1): result.append(nums1[i]) i += 1 while j < len(nums2): result.append(nums2[j]) j += 1 return result"},{"question":"You are given two **0-indexed** integer arrays `startTime` and `endTime` with the same length, where `startTime[i]` and `endTime[i]` represent the beginning and ending times of the `ith` event, respectively. All times are given in hours within a single 24-hour period. You are also given a single integer `queryTime` representing a specific time. Write a function to determine the number of events that are ongoing at `queryTime`. An event is considered ongoing if it starts at or before `queryTime` and ends at or after `queryTime`. Return the number of such events.","solution":"def count_ongoing_events(startTime, endTime, queryTime): Returns the number of events that are ongoing at the queryTime. Args: startTime (list of int): List of start times of events. endTime (list of int): List of end times of events. queryTime (int): The time of query. Returns: int: Number of ongoing events at the queryTime. count = 0 for start, end in zip(startTime, endTime): if start <= queryTime <= end: count += 1 return count"},{"question":"You are given a list of integers `nums` representing a sequence of `1`s and `0`s. We want to find the maximum length of a contiguous subarray with an equal number of `0`s and `1`s. Return the length of the longest such subarray. If there is no such subarray, return `0`.","solution":"def findMaxLength(nums): Finds the maximum length of a contiguous subarray with an equal number of 0s and 1s. Args: nums (list of int): List of 0s and 1s. Returns: int: Maximum length of subarray with equal number of 0s and 1s. count_map = {0: -1} # To handle the case when subarray starts from index 0 max_length = 0 count = 0 for i, num in enumerate(nums): count += (1 if num == 1 else -1) if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"You are given a 0-indexed integer array `heights` representing the heights of buildings, and an integer `k` representing the maximum jump height you can perform. You are initially on the ground before the first building and you need to jump from the ground to the rooftops. Your goal is to jump across all buildings from left to right until you reach the last building or until you can no longer proceed. Each jump must be made to the next building with a height difference that does not exceed `k`. Return _a boolean indicating if it is possible to jump across all the buildings from left to right given the maximum jump height_ `k`.","solution":"def can_jump_over_buildings(heights, k): Determines if you can jump across all buildings from left to right given the maximum jump height k. :param heights: List[int] - a list of building heights :param k: int - the maximum jump height :return: bool - True if you can jump across all buildings, False otherwise for i in range(1, len(heights)): if abs(heights[i] - heights[i - 1]) > k: return False return True"},{"question":"Given a string `s` representing an expression that contains only non-negative integers, addition operators (`+`), and multiplication operators (`*`), evaluate the expression and return the result. The expression may be given without any parentheses, meaning that `+` and `*` operators only follow the standard precedence rules where multiplication has a higher precedence over addition. For instance, in the expression `\\"3+2*2\\"`, the result would be `3+(2*2)` which equals `7`. Write a function that can accurately compute the result of such an expression. Note: You can assume that the given string `s` always represents a valid expression.","solution":"def evaluate_expression(s): Evaluates a given arithmetic expression string containing only non-negative integers, + (addition) and * (multiplication) operators according to the standard precedence where multiplication is performed before addition. :param s: A string representing the arithmetic expression :return: Evaluated result as an integer tokens = list(s) stack = [] num = 0 pre_op = \'+\' while len(tokens) > 0: ch = tokens.pop(0) if ch.isdigit(): num = num * 10 + int(ch) if ch in \'+*\' or len(tokens) == 0: if pre_op == \'+\': stack.append(num) elif pre_op == \'*\': stack.append(stack.pop() * num) pre_op = ch num = 0 return sum(stack)"},{"question":"Given a `root` of a binary tree, return an array of the largest value in each row of the tree. A tree row is considered to be a set of all nodes that share the same depth level. For example, in the binary tree representation where the root is at depth 0, its children are at depth 1, its grandchildren at depth 2, and so on.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values(root): Given the root of a binary tree, return an array of the largest value in each row of the tree. if not root: return [] queue = deque([root]) largest_vals = [] while queue: level_size = len(queue) level_max = float(\'-inf\') for _ in range(level_size): node = queue.popleft() level_max = max(level_max, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) largest_vals.append(level_max) return largest_vals"},{"question":"You are given a binary string `s` that consists of only \'0\'s and \'1\'s. You are allowed to perform at most one operation, which involves flipping exactly one \'0\' to \'1\'. Find the maximum length of the substring that contains only \'1\'s you can get after this operation. If the string contains no \'0\'s, return the length of the string. For example: * If `s = \\"1101101\\"`, the function should return `5` because changing the fourth \'0\' from the left results in the string \\"1111111\\". * If `s = \\"1111\\"`, the function should return `4` because there are no \'0\'s to flip and the longest substring of \'1\'s is already the entire string.","solution":"def max_length_of_1s_after_flip(s): Returns the maximum length of the substring that contains only \'1\'s you can get by flipping exactly one \'0\' to \'1\' in binary string `s`. :param s: A binary string that consists of only \'0\'s and \'1\'s. :return: An integer, the maximum length of 1\'s substring after at most one flip. n = len(s) if \'0\' not in s: return n # If there are no \'0\'s, return the length of the entire string max_length = 0 zero_index = -1 # The index of the zero we would consider flipping count_1s = 0 # Counter for the number of consecutive \'1\'s for i in range(n): if s[i] == \'1\': count_1s += 1 else: if zero_index != -1: # Reset count_1s to the number of 1s after the last zero we considered flipping count_1s = i - zero_index - 1 zero_index = i count_1s += 1 max_length = max(max_length, count_1s) return max_length"},{"question":"Given two strings, `word1` and `word2`, return the minimum number of steps required to make `word1` and `word2` equal. In one step, you can delete one character in either string. The solution should use a dynamic programming approach to ensure an optimal solution.","solution":"def min_distance(word1, word2): Returns the minimum number of steps required to make word1 and word2 equal by deleting characters. m, n = len(word1), len(word2) # Initialize DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the table with base cases for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # delete all from word2 elif j == 0: dp[i][j] = i # delete all from word1 elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) # delete from either word1 or word2 return dp[m][n]"},{"question":"You are given two integer arrays `persons` and `times`. The `persons` array contains the IDs of the candidates who have cast a vote at each time `times[i]` represented in the `times` array. Define the leader at a given time `t` as the candidate who has received the most votes by time `t`. If multiple candidates are tied for the most votes, the one with the highest ID is considered the leader. For each query time `qt` in a given list of query times `queryTimes`, determine the leader at that time. Return _an array of leaders at each query time represented in `queryTimes`_.","solution":"from collections import defaultdict class TopVotedCandidate: def __init__(self, persons, times): self.leaders = [] self.times = times vote_count = defaultdict(int) current_leader = -1 current_leader_votes = 0 for i in range(len(persons)): vote_count[persons[i]] += 1 if vote_count[persons[i]] >= current_leader_votes: if persons[i] != current_leader: current_leader = persons[i] current_leader_votes = vote_count[persons[i]] self.leaders.append(current_leader) def get_leader(self, t): low, high = 0, len(self.times) - 1 while low < high: mid = (low + high + 1) // 2 if self.times[mid] <= t: low = mid else: high = mid - 1 return self.leaders[low] def find_leaders_at_query_times(persons, times, query_times): top_voted_candidate = TopVotedCandidate(persons, times) return [top_voted_candidate.get_leader(qt) for qt in query_times]"},{"question":"Given an array of integers `arr` where each element represents a digit from the number 0 to 9, find the largest number you can form using exactly four of those digits. If there are fewer than four digits available, return an empty string. The digits can be used only once, and they should appear in descending order in the resulting number. Return the largest number as a string.","solution":"def largest_number_from_digits(arr): Given an array of integers `arr` where each element represents a digit from 0 to 9, find the largest number you can form using exactly four of those digits. If there are fewer than four digits available, return an empty string. The digits can be used only once, and they should appear in descending order in the resulting number. Args: arr (list of int): The input array of digits. Returns: str: The largest number formed by exactly four digits in descending order. if len(arr) < 4: return \\"\\" sorted_digits = sorted(arr, reverse=True)[:4] return \\"\\".join(map(str, sorted_digits))"},{"question":"Given an integer array `heights` representing the heights of plants and an integer `wateringCans` representing the number of watering cans available, return the maximum number of plants that can be watered using the following rules: 1. Each watering can can only water plants of non-decreasing heights in a consecutive sequence. 2. A plant can be watered multiple times with different watering cans. Examples: - Input: `heights = [1, 2, 3, 2, 1, 2, 3]`, `wateringCans = 2` - Output: `6` (One possible solution is to water the plants [1, 2, 3] with one can and [2, 1, 2, 3] with the other) - Input: `heights = [4, 5, 1, 1, 3]`, `wateringCans = 1` - Output: `3` (One possible solution is to water the plants [4, 5] or [1, 1, 3] with the can)","solution":"def max_plants_watered(heights, wateringCans): Returns the maximum number of plants that can be watered given the heights of plants and the number of watering cans available. n = len(heights) if n == 0 or wateringCans == 0: return 0 # Helper function to find the longest non-decreasing subsequence starting from a given index def longest_non_decreasing_from(i): length = 0 while i < n - 1 and heights[i] <= heights[i + 1]: i += 1 length += 1 return length + 1 intervals = [] # Collect all intervals of non-decreasing subsequence lengths i = 0 while i < n: length = longest_non_decreasing_from(i) intervals.append(length) i += length # Sort the intervals by lengths in descending order intervals.sort(reverse=True) # Select the longest non-decreasing intervals that can be covered by the available watering cans max_plants = sum(intervals[:wateringCans]) return max_plants"},{"question":"You are given a `List` of `n` non-negative integers representing the number of stones in `n` piles. In a single operation, you can choose any pile of stones and remove one stone from it. Your goal is to make the number of stones in every pile even. Return the minimum number of operations required to achieve this. If it is not possible to make all piles have an even number of stones, return `-1`.","solution":"def min_operations_to_even_piles(piles): Returns the minimum number of operations required to make all piles have an even number of stones. Args: piles (List[int]): A list of non-negative integers representing the piles. Returns: int: The minimum number of operations, or -1 if not possible. operations = 0 for pile in piles: if pile % 2 != 0: operations += 1 # Each odd pile requires one operation to make it even return operations"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `d`. In one step, you can jump from index `i` to index `j` in the array `arr` if the following conditions are met: 1. `i < j` but `j <= i + d`, or `i > j` but `j >= i - d`. 2. `arr[i] > arr[j]`. You can choose any index in the array `arr` to start the jump. Return _the maximum number of indices you can visit by performing this jump operation starting at any index._","solution":"def max_jumps(arr, d): Returns the maximum number of indices that can be visited. n = len(arr) dp = [0] * n indexes = list(range(n)) indexes.sort(key=lambda i: arr[i]) for i in indexes: dp[i] = 1 for j in range(i + 1, min(n, i + d + 1)): if arr[i] > arr[j]: dp[i] = max(dp[i], 1 + dp[j]) else: break for j in range(i - 1, max(-1, i - d - 1), -1): if arr[i] > arr[j]: dp[i] = max(dp[i], 1 + dp[j]) else: break return max(dp)"},{"question":"Given a string `S` and a list of words `words`, determine the minimum number of character deletions required in `S` such that no word in `words` is a subsequence of the modified string `S`. Note: A subsequence is derived by deleting some or none of the characters in a string without changing the order of the remaining characters.","solution":"def min_deletions_to_avoid_subsequences(S, words): def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) max_length = 0 for word in words: if is_subsequence(word, S): max_length = max(max_length, len(word)) return max_length"},{"question":"Given an integer array `nums`, an integer number `k`, and a target integer `x`, find the `k` integers in `nums` that are closest to `x`. The result should also be sorted in ascending order. If there is a tie for the k-th closest number, choose the smaller number. Return the resulting array of `k` integers.","solution":"def find_closest_k_integers(nums, k, x): Returns the k integers from nums that are closest to x. # Sort by the absolute difference with x, then by the numbers themselves sorted_nums = sorted(nums, key=lambda num: (abs(num - x), num)) # Take the first k elements from the sorted list result = sorted_nums[:k] # Sort the resulting array in ascending order result.sort() return result"},{"question":"You are given a string `s` and an array of integers `indices` of the same length. The string `s` is scrambled such that the character at the `i`-th position moves to `indices[i]` in the resulting string. Construct the resulting string from the scrambled string `s` and the array `indices`. Return the reconstructed string.","solution":"def restore_string(s, indices): Restores a scrambled string s based on the given indices. Parameters: s (str): The scrambled string. indices (list): A list of integers representing the indices of the scrambled string. Returns: str: The reconstructed string. # Initialize an empty list with the same length as the string restored = [\'\'] * len(s) # Place each character in its correct position based on the indices array for i, index in enumerate(indices): restored[index] = s[i] # Join the list into a single string and return return \'\'.join(restored)"},{"question":"You are given the head of a singly linked list and an integer `k`. Write a function that splits the linked list into `k` consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null, as there may be more parts than available elements. The function should return a list of `k` singly linked list parts in order.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def splitListToParts(head, k): # Count the length of the linked list current = head length = 0 while current: length += 1 current = current.next # Determine the size of each part part_size = length // k remainder = length % k # Initialize the result array parts = [] current = head for i in range(k): part_head = current part_tail = None # Create parts of size `part_size` with remainder distributed for j in range(part_size + (i < remainder)): part_tail = current if current: current = current.next if part_tail: part_tail.next = None parts.append(part_head) return parts"},{"question":"You are given an array of `n` integers `arr`. Your task is to check if the array can be divided into pairs such that the sum of each pair is divisible by a given integer `k`. Return _true_ if it is possible to divide the array into such pairs, and _false_ otherwise. Each element of the array should be part of exactly one pair.","solution":"def can_arrange(arr, k): Returns True if the array can be divided into pairs such that the sum of each pair is divisible by k, False otherwise. Args: arr : List[int] - The list of integers. k : int - The integer divisor. Returns: bool - True if it\'s possible to divide the array into such pairs, False otherwise. if len(arr) % 2 != 0: return False remainder_count = [0] * k for num in arr: remainder_count[num % k] += 1 if remainder_count[0] % 2 != 0: return False for i in range(1, k): if remainder_count[i] != remainder_count[k - i]: return False return True"},{"question":"You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have an infinite number of each kind of coin. - **Example:** ```plaintext Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 ``` - **Note:** - You can also return the result in any order in the form of an integer. - The length of coins array will be at most 50. - The amount will be at most 5000.","solution":"def coin_change_combinations(amount, coins): Returns the number of combinations to make up the given amount with the given coins. :param amount: int - the total amount of money :param coins: List[int] - the denominations of the coins :return: int - the number of combinations that make up the amount dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for i in range(coin, amount + 1): dp[i] += dp[i - coin] return dp[amount]"},{"question":"You are given two boxes and `n` distinct items where each item can fit into either box. The goal is to divide these items between the two boxes such that the difference in the number of items between the two boxes is minimized. Formally, given an integer `n`, return the minimum possible difference in the number of items between the two boxes after distributing all `n` items. For example, if `n = 7`, you can put 4 items in one box and 3 items in the other, achieving a minimum difference of 1. If `n = 8`, you can put 4 items in each box, achieving a minimum difference of 0. Write a function that takes an integer `n` and returns the minimum difference.","solution":"def min_diff_boxes(n): Returns the minimum possible difference in the number of items between the two boxes after distributing all `n` items. Parameters: - n (int): The number of items. Returns: - int: The minimum difference in the number of items between the two boxes. return n % 2"},{"question":"Given two strings `s1` and `s2`, return _the number of characters in `s2` that do not appear in `s1`_. Note that both strings only contain lowercase English letters.","solution":"def count_non_common_characters(s1, s2): Returns the number of characters in s2 that do not appear in s1. set_s1 = set(s1) count = 0 for char in s2: if char not in set_s1: count += 1 return count"},{"question":"You are given a `0-indexed` array `times` of `n` integers, where `times[i]` represents the time taken by the `i-th` server to process a single task. Additionally, you are given an integer `tasks` that represents the total number of tasks that need to be completed. Multiple servers can work simultaneously without interference. Return _the **minimum** total time required to complete all the tasks._","solution":"import heapq def min_time_to_complete_tasks(times, tasks): Returns the minimum total time required to complete all tasks. :param times: List of time taken by each server to process a single task. :param tasks: Total number of tasks that need to be completed. :return: Minimum total time to complete all tasks. if len(times) == 0 or tasks == 0: return 0 heap = [(0, time) for time in times] # (total_time, time_per_task) heapq.heapify(heap) for _ in range(tasks): total_time, time_per_task = heapq.heappop(heap) total_time += time_per_task heapq.heappush(heap, (total_time, time_per_task)) return max(heap)[0]"},{"question":"You are given an array `nums` of positive integers and an integer `k`. A **partition** of the array is a splitting of `nums` into _k_ non-empty contiguous subarrays. The **score** of a partition is the sum of the average of each subarray. Your task is to determine the **maximum sum of the averages** obtainable from any partition of the array into _k_ contiguous subarrays. Return _the maximum sum of the averages of all possible partitions_.","solution":"def max_sum_of_averages(nums, k): Returns the maximum sum of the averages of k contiguous subarrays. :param nums: List[int], list of positive integers :param k: int, number of partitions :return: float, the maximum sum of averages n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i+1] = prefix_sum[i] + nums[i] def average(i, j): return (prefix_sum[j] - prefix_sum[i]) / float(j - i) dp = [[0] * (k + 1) for _ in range(n)] for i in range(n): dp[i][1] = average(0, i + 1) for kk in range(2, k + 1): for i in range(n): for j in range(i): dp[i][kk] = max(dp[i][kk], dp[j][kk-1] + average(j + 1, i + 1)) return dp[n-1][k]"},{"question":"Given a list of `n` stones, where each stone has a positive integer weight. You have access to a device that can smash exactly two different stones together. The result of smashing stones `a` and `b` is: - If `a = b`, both stones are destroyed. - If `a ≠ b`, the stone with weight `a` is destroyed, and the stone with weight `b` has a new weight of `|a - b|`. Your task is to find the minimum possible weight of the remaining stone (or stones) if any stones are left after optimal usage of the device. If no stones remain, return 0. Write a function that takes in an integer array `stones` and returns the minimum possible weight of the last remaining stone (or 0 if no stones remain). Example: ``` Input: stones = [2, 7, 4, 1, 8, 1] Output: 1 ```","solution":"def lastStoneWeightII(stones): Returns the minimum possible weight of the remaining stone (or stones) after optimal usage of the device. total_sum = sum(stones) half_sum = total_sum // 2 dp = [0] * (half_sum + 1) for stone in stones: for j in range(half_sum, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2 * dp[half_sum]"},{"question":"A company is planning to organize its employee data in a particular format. They want to store the data of all `n` employees in a `0-indexed` list of dictionaries where each dictionary contains at least the keys \\"id\\", \\"name\\", \\"department\\", and \\"salary\\". The \\"id\\" is a unique identifier for each employee, the \\"name\\" is a string representing the employee\'s name, the \\"department\\" is a string representing the department the employee belongs to, and the \\"salary\\" is an integer representing the employee\'s salary. Your task is to write a function that, given this list of dictionaries and a department name, returns the average salary of the employees in that department. Return the average salary as a float rounded to 2 decimal places. If there are no employees in the specified department, return 0.0.","solution":"def average_salary_by_department(employees, department_name): Returns the average salary of employees in the specified department. Parameters: employees (list): A list of dictionaries representing employee data. department_name (str): The name of the department. Returns: float: The average salary of the employees in the specified department, rounded to 2 decimal places. Returns 0.0 if there are no employees in the specified department. total_salary = 0 count = 0 for employee in employees: if employee[\'department\'] == department_name: total_salary += employee[\'salary\'] count += 1 if count == 0: return 0.0 return round(total_salary / count, 2) # Example employee data employees = [ {\\"id\\": 1, \\"name\\": \\"John Doe\\", \\"department\\": \\"Engineering\\", \\"salary\\": 10000}, {\\"id\\": 2, \\"name\\": \\"Jane Smith\\", \\"department\\": \\"Engineering\\", \\"salary\\": 12000}, {\\"id\\": 3, \\"name\\": \\"Alice Johnson\\", \\"department\\": \\"HR\\", \\"salary\\": 7000}, {\\"id\\": 4, \\"name\\": \\"Bob Brown\\", \\"department\\": \\"Finance\\", \\"salary\\": 8000} ] # Example usage print(average_salary_by_department(employees, \\"Engineering\\")) # Output: 11000.0"},{"question":"You are given a directed graph of `n` nodes numbered from `0` to `n-1`. Each edge is an integer array `edges[i] = [ai, bi]` indicating that there is a directed edge from node `ai` to node `bi`. Return _an array of integers representing all nodes that have **no incoming edges**_. If multiple answers are possible, return any of them. The input will be such that the graph is guaranteed to be a Directed Acyclic Graph (DAG). Example: Input: `n = 6, edges = [[0,1],[0,2],[2,3],[3,4],[4,5]]` Output: `[0]`","solution":"def find_nodes_with_no_incoming_edges(n, edges): Returns a list of all nodes that have no incoming edges in the graph. # Initialize a list to keep track of the in-degree of each node in_degree = [0] * n # Calculate the in-degree for each node for edge in edges: in_degree[edge[1]] += 1 # Find all nodes with in-degree of 0 no_incoming_edges_nodes = [i for i in range(n) if in_degree[i] == 0] return no_incoming_edges_nodes"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to return the **right view** of the tree, which is the set of values visible when the tree is viewed from the right side. For example, consider the following binary tree: ``` 1 / 2 3 / 5 4 6 ``` The right view of this tree is `[1, 3, 6]` as these are the nodes visible when the tree is viewed from the right side. Implement a function `right_view(root)` that takes the `root` of the binary tree and returns a list of integers representing the right view of the tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def right_view(root): if not root: return [] from collections import deque right_side = [] queue = deque([(root, 0)]) # store tuple of (node, level) while queue: node, level = queue.popleft() if level == len(right_side): right_side.append(node.val) else: right_side[level] = node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return right_side"},{"question":"Given two integers `k` and `n`, write a function that returns an array containing `n` unique integers that sum up to `k`. The solution should have a linear runtime complexity.","solution":"def unique_integers_sum_to_k(k, n): Returns an array containing n unique integers that sum up to k. result = list(range(1 - n, 1)) sum_current = sum(result) result[-1] += k - sum_current return result"},{"question":"You are given a list of non-negative integers `nums`. Each integer in the list represents a single-digit number. Your task is to determine if there exists a **non-decreasing** sequence of length `k` within `nums`. A **non-decreasing** sequence is defined as a sequence where each number is greater than or equal to the previous number. Return `true` _if there exists a non-decreasing sequence of length_ `k` _in_ `nums`, otherwise return `false`.","solution":"def non_decreasing_sequence_exists(nums, k): Determines if there exists a non-decreasing sequence of length k within the nums list. Parameters: nums (list of int): List of non-negative integers each representing a single-digit number. k (int): Required length of the non-decreasing sequence. Returns: bool: True if there exists a non-decreasing sequence of length k, otherwise False. if k <= 0: return True n = len(nums) if n < k: return False increasing_sequence = [1] * n # Initialize with 1, as each number is a non-decreasing sequence of length 1 # Traverse the list from the end to the start for i in range(n - 2, -1, -1): for j in range(i + 1, n): if nums[i] <= nums[j]: increasing_sequence[i] = max(increasing_sequence[i], 1 + increasing_sequence[j]) if increasing_sequence[i] >= k: # Early return if we already found sequence of length k return True return max(increasing_sequence) >= k"},{"question":"You are tasked with implementing a priority job scheduler which processes jobs based on their priority. Each job `i` is represented as a tuple `(job_id, priority, execution_time)` where `priority` is an integer (higher value indicates higher priority) and `execution_time` is the time (in milliseconds) required to complete the job. Given an array of jobs, create a function that simulates the job scheduling to execute and return the order of job_ids based on decreasing priority. If two or more jobs have the same priority, they should be executed in the order they appear in the input. Implement the function to return the scheduled order of job_ids.","solution":"def schedule_jobs(jobs): Schedules jobs based on their priority and returns the order of job_ids. Parameters: jobs (list of tuples): A list where each tuple represents a job in the form (job_id, priority, execution_time) Returns: list: A list of job_ids ordered by their priority (higher to lower). If two jobs have the same priority, they maintain their input order. # Sort the jobs by priority (higher to lower), if same priority keep original order sorted_jobs = sorted(jobs, key=lambda job: -job[1]) # Extract the job_ids from the sorted jobs scheduled_order = [job[0] for job in sorted_jobs] return scheduled_order"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to perform at most one operation on the string: you can insert any character at any position in the string. Your task is to determine if it is possible to make the string a palindrome by performing at most one such insertion. Return `\\"YES\\"` if it is possible to make the string a palindrome with at most one insertion, and `\\"NO\\"` otherwise.","solution":"def can_be_palindrome_by_one_insertion(s): Determines if a string can be made a palindrome with at most one insertion. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it can be made a palindrome with at most one insertion, otherwise \\"NO\\". def is_palindrome(substring): return substring == substring[::-1] l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: # Check by inserting character to make either side palindrome if is_palindrome(s[l:r]) or is_palindrome(s[l+1:r+1]): return \\"YES\\" else: return \\"NO\\" l += 1 r -= 1 return \\"YES\\" # If the original string is already a palindrome"},{"question":"You are given a **string** `text` consisting of lowercase letters and an **integer** `k`. Your task is to find the longest substring of `text` such that each character in the substring appears at least `k` times. If there are multiple longest substrings with the same length, return any of them. If no such substring exists, return an empty string. For example, given `text = \\"aaabbcc\\"` and `k = 3`, the longest substring where each character appears at least 3 times is `\\"aaa\\"`. If `text = \\"ababbc\\"` and `k = 2`, one possible output is `\\"ababb\\"`. In this case, both `\\"ababb\\"` and `\\"babab\\"` are valid outputs. Return _the longest substring of_ `text` _in which each character appears at least_ `k` _times._","solution":"def longest_substring_with_k_repeats(text, k): from collections import Counter def longest_substring_helper(text, k): if len(text) < k: return \\"\\" count = Counter(text) for char, freq in count.items(): if freq < k: return max(longest_substring_helper(substring, k) for substring in text.split(char)) return text return longest_substring_helper(text, k)"},{"question":"You are given a `m` x `n` binary grid `grid` representing a map of a city, where `1` represents a building and `0` represents an empty space. Y ou can only move up, down, left, or right from an empty space to another, forming different regions of connected empty spaces. Define a region as a group of connected empty spaces. A region is enclosed if there are only buildings on all sides of it in the four possible directions. Return _the number of enclosed regions_ in the `grid`.","solution":"def numEnclaves(grid): m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0: return grid[x][y] = -1 # Mark the cell as visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) # Mark the regions connected to the boundary as non-enclosed for i in range(m): for j in (0, n-1): if grid[i][j] == 0: dfs(i, j) for j in range(n): for i in (0, m-1): if grid[i][j] == 0: dfs(i, j) # Count number of enclosed regions count = 0 for i in range(1, m-1): for j in range(1, n-1): if grid[i][j] == 0: count += 1 dfs(i, j) return count"},{"question":"Given a list of integers `nums`, a \\"wavy\\" subarray is defined as a subarray where each element alternately increases and decreases. Specifically, for a subarray with indices `i, i+1, ..., j` where `i < j`, it must satisfy either: - `nums[i] < nums[i+1] > nums[i+2] < nums[i+3] > ...` or, - `nums[i] > nums[i+1] < nums[i+2] > nums[i+3] < ...`. Find the length of the longest \\"wavy\\" subarray within `nums`. If `nums` is empty, return `0`.","solution":"def longest_wavy_subarray(nums): Returns the length of the longest \\"wavy\\" subarray within nums. a \\"wavy\\" subarray is defined as a subarray where each element alternately increases and decreases. if not nums: return 0 n = len(nums) if n == 1: return 1 max_len = 1 current_len = 1 for i in range(1, n - 1): if (nums[i] > nums[i - 1] and nums[i] > nums[i + 1]) or (nums[i] < nums[i - 1] and nums[i] < nums[i + 1]): current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len + 1 if max_len > 1 else 1"},{"question":"Given a linked list, remove the `n`-th node from the end of the list and return its head. Can you do this in one pass? Implement the following method: - `ListNode* removeNthFromEnd(ListNode* head, int n)`: Removes the nth node from the end of the linked list. `ListNode` is a class that represents a node in a linked list. It contains an integer value and a pointer to the next node. Assume: - `ListNode` is defined as follows: ```cpp struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Removes the nth node from the end of the linked list and returns its head. dummy = ListNode(0, head) first = dummy second = dummy # Move first n+1 steps ahead for _ in range(n + 1): first = first.next # Move both first and second until first reaches the end while first is not None: first = first.next second = second.next # Remove the nth node from end second.next = second.next.next return dummy.next"},{"question":"Given a list of strings `words`, return the number of unique Morse code representations of each word. The Morse code representations of the English alphabet from \'a\' to \'z\' are as follows: `[\\".-\\",\\"-...\\",\\"-.-.\\",\\"-..\\",\\".\\",\\"..-.\\",\\"--.\\",\\"....\\",\\"..\\",\\".---\\",\\"-.-\\",\\".-..\\",\\"--\\",\\"-.\\",\\"---\\",\\".--.\\",\\"--.-\\",\\".-.\\",\\"...\\",\\"-\\",\\"..-\\",\\"...-\\",\\".--\\",\\"-..-\\",\\"-.--\\",\\"--..\\"]`. For example, the word `\\"gin\\"` can be represented as `\\"--...-.\\"`, and `\\"zen\\"` as `\\"--...-.--\\"` (note that both translate to the same Morse code). **Examples:** - `[\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"]` should return `2` because the unique representations are `[\\"--...-.\\",\\"--...-.--\\",\\".--...-.\\"\\"--...-.--\\"]` - `[\\"a\\", \\"z\\", \\"g\\", \\"m\\"]` should return `4` because each represents a different morse code interpretation. **Note:** - The length of `words` will be at most `100`. - Each word `words[i]` will have length in range `[1, 12]`. - `words[i]` will consist of lowercase letters only.","solution":"def unique_morse_representations(words): Returns the number of unique Morse code representations of the given list of words. morse_codes = [\\".-\\",\\"-...\\",\\"-.-.\\",\\"-..\\",\\".\\",\\"..-.\\",\\"--.\\",\\"....\\",\\"..\\",\\".---\\",\\"-.-\\",\\".-..\\",\\"--\\",\\"-.\\",\\"---\\",\\".--.\\",\\"--.-\\",\\".-.\\",\\"...\\",\\"-\\",\\"..-\\",\\"...-\\",\\".--\\",\\"-..-\\",\\"-.--\\",\\"--..\\"] morse_dict = {chr(i + ord(\'a\')): morse_codes[i] for i in range(26)} unique_representations = set() for word in words: morse_word = \'\'.join(morse_dict[letter] for letter in word) unique_representations.add(morse_word) return len(unique_representations)"},{"question":"You are given a **0-indexed** integer array `height` representing the heights of consecutive trees in a forest. You are tasked with cutting down a segment of trees to allow sunlight to pass through to the forest floor. Specifically, you should choose a segment of **consecutive** trees such that the **average height** of the trees in this segment is minimized. Return _the starting and ending indices (inclusive) of the segment with the minimum average height._ **Note:** If there are multiple segments with the same minimum average height, return the segment with the smallest starting index.","solution":"def find_min_avg_segment(height): Given a list of tree heights, find the segment (i.e., subarray) with the minimum average height and return its starting and ending indices. Inputs: - height: a list of integers representing tree heights. Returns: - A tuple (start, end) representing the starting and ending indices (inclusive) of the segment with the minimum average height. n = len(height) if n == 0: return (-1, -1) min_avg = float(\'inf\') start_index = 0 end_index = 0 for i in range(n): current_sum = 0 for j in range(i, n): current_sum += height[j] current_length = j - i + 1 current_avg = current_sum / current_length if current_avg < min_avg: min_avg = current_avg start_index = i end_index = j return (start_index, end_index)"},{"question":"You are given a grid represented as a `2D` array of integers where each integer represents the number of coins in that cell. Your goal is to collect the maximum number of coins starting from the top-left cell `(0, 0)` to the bottom-right cell `(m-1, n-1)`. You can only move to the right or down from your current position at any step. Write a function that returns the maximum number of coins you can collect during your journey from the top-left cell to the bottom-right cell. For example, given the following grid: ``` [ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ] ``` Your function should return `12`, which is the maximum number of coins that can be collected by following the path `0 -> 3 -> 1 -> 0 -> 4 -> 1 -> 3 -> 1`.","solution":"def max_coins(grid): Returns the maximum number of coins collected from the top-left to the bottom-right of a 2D grid. You can only move to the right or down from your current position. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"You are given a list of integers `arr` representing the heights of consecutive mountains in a mountain range. A **mountain** in `arr` is a contiguous subarray of at least 3 elements that forms a peak, where the subarray strictly increases to a maximum, then strictly decreases. Once a mountain begins strictly decreasing, it cannot increase again. Return the **length** of the longest mountain subarray. If there is no such mountain, return `0`.","solution":"def longest_mountain(arr): Returns the length of the longest mountain subarray in arr. if len(arr) < 3: return 0 longest = 0 n = len(arr) for i in range(1, n - 1): # Check if arr[i] is the peak of a mountain if arr[i - 1] < arr[i] > arr[i + 1]: # Find the left boundary of the mountain left = i - 1 while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Find the right boundary of the mountain right = i + 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 # Update the longest mountain if necessary current_length = right - left + 1 if current_length > longest: longest = current_length # Move i to the end of the current mountain to avoid redundant checks i = right return longest"},{"question":"You are given a list of integers `nums` and an integer `k`. Your task is to determine if there exist three distinct elements in `nums` that sum up to `k`. Return `true` if there are such three elements, otherwise return `false`.","solution":"def three_sum(nums, k): Determines if there exist three distinct elements in `nums` that sum up to `k`. Args: nums : list of integers k : integer Returns: bool: True if there exist three distinct elements that sum up to `k`, otherwise False. nums.sort() for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"You are given an integer array `heights` representing the heights of trees in a forest, where `heights[i]` is the height of the `i-th` tree. A tree is considered **visible** if it is not shorter than any of the previous trees (from left to right). Return the array of heights of the **visible** trees. The trees\' relative order from left to right should, however, be maintained in the returned array. For example, if `heights = [2, 3, 1, 4, 2, 5]`, the visible trees are `[2, 3, 4, 5]`.","solution":"def visible_trees(heights): Returns the array of heights of trees which are visible. A tree is considered visible if it is not shorter than any of the previous trees from left to right. visible = [] max_height = float(\'-inf\') for height in heights: if height >= max_height: visible.append(height) max_height = height return visible"},{"question":"You are given two integers `hour` and `minutes`. You have a clock represented in a 12-hour format, with the `hour` hand and the `minute` hand moving continuously. Calculate the angle between the `hour` hand and the `minute` hand on the clock at the specified `hour` and `minutes`. Return the smallest angle (in degrees) between the two hands.","solution":"def clock_angle(hour, minutes): Calculate the smallest angle between the hour and minute hands on a 12-hour clock. Parameters: hour (int): The hour (1 to 12) minutes (int): The minutes (0 to 59) Returns: float: The smallest angle in degrees between the hour and minute hands if hour == 12: hour = 0 if hour > 12 or hour < 0 or minutes > 59 or minutes < 0: raise ValueError(\\"Invalid time input\\") # Calculate the positions of the hour and minute hands in degrees minute_angle = minutes * 6 hour_angle = (hour * 30) + (minutes * 0.5) # Calculate the difference between the two angles angle = abs(hour_angle - minute_angle) # Return the smaller angle of the two possible angles return min(angle, 360 - angle)"},{"question":"Given an integer array `nums`, implement a function to determine if it\'s possible to rearrange the elements of `nums` such that all adjacent elements have a different parity (one is odd, the other is even). If it\'s possible, return any valid rearrangement of the array. If not, return `[]`. For example, if `nums = [3, 1, 4, 2]`, the array can be rearranged to `[3, 4, 1, 2]` or `[1, 4, 3, 2]`, both of which satisfy the condition. If `nums = [2, 2, 2]`, since there are no odd elements, it is impossible to rearrange the array in the required manner, and the function should return `[]`. Return _the rearranged array_ if possible, otherwise return `[]`.","solution":"def rearrange_array(nums): Determine if it\'s possible to rearrange the elements such that all adjacent elements have different parity (one is odd, the other is even). If it\'s possible, return any valid rearrangement of the array. Otherwise, return []. evens = [x for x in nums if x % 2 == 0] odds = [x for x in nums if x % 2 != 0] if abs(len(evens) - len(odds)) > 1: return [] result = [] if len(evens) > len(odds): result.extend(interleave(evens, odds)) else: result.extend(interleave(odds, evens)) return result def interleave(primary, secondary): result = [] for p, s in zip(primary, secondary): result.append(p) result.append(s) # Append remaining elements if lengths are uneven result.extend(primary[len(secondary):]) result.extend(secondary[len(primary):]) return result"},{"question":"You are given a **0-indexed** array `arr` representing the sizes of `n` envelopes. Each envelope can fit into any other envelope as long as both dimensions of one envelope are strictly greater than the dimensions of the other envelope. The array `arr` is given as `arr[i] = [wi, hi]` where `wi` and `hi` are the width and height of the envelope respectively. Write a function to determine the maximum number of envelopes you can fit one inside the other. *Note:* You cannot rotate the envelopes.","solution":"def maxEnvelopes(arr): Determine the maximum number of envelopes you can fit one inside the other. :param arr: List of [width, height] lists, representing envelope sizes. :return: Maximum number of envelopes you can fit one inside the other. if not arr: return 0 # Sort envelopes by width, and by height in descending order if widths are the same arr.sort(key=lambda x: (x[0], -x[1])) # Function to find the length of LIS (Longest Increasing Subsequence) def LIS(nums): from bisect import bisect_left sub = [] for x in nums: pos = bisect_left(sub, x) if pos == len(sub): sub.append(x) else: sub[pos] = x return len(sub) # Extract heights and find the length of LIS in heights heights = [h for w, h in arr] return LIS(heights)"},{"question":"You are given a **0-indexed** integer array `nums` containing `n` integers, and an integer `m` representing the number of distinct elements allowed in a subarray. Find the length of the longest subarray that contains at most `m` distinct elements. If `m` is greater than or equal to the total number of distinct elements in `nums`, return the length of the entire array. Return _the length of the longest subarray that meets the condition_.","solution":"def longest_subarray_with_m_distinct(nums, m): Finds the length of the longest subarray that contains at most m distinct elements. Parameters: nums (list): A list of integers. m (int): The number of distinct elements allowed in a subarray. Returns: int: The length of the longest subarray with at most m distinct elements. from collections import defaultdict n = len(nums) if m >= len(set(nums)): return n freq = defaultdict(int) left = 0 max_len = 0 distinct_count = 0 for right in range(n): if freq[nums[right]] == 0: distinct_count += 1 freq[nums[right]] += 1 while distinct_count > m: freq[nums[left]] -= 1 if freq[nums[left]] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given an array of integers containing a sequence of daily temperatures for a month (`temperatures`). For each day, determine how many days you have to wait until a warmer temperature. If there is no future day with a warmer temperature, put 0 for that day. Return an array of integers where the value at each index represents the number of days until a warmer temperature or 0 if there isn\'t one.","solution":"def daily_temperatures(temperatures): Returns a list where each index contains the number of days one has to wait for a warmer temperature or 0 if there is no warmer future day. Parameters: temperatures (list): List of daily temperatures. Returns: list: List of days until a warmer temperature for each day provided. n = len(temperatures) answer = [0] * n stack = [] for i, temp in enumerate(temperatures): while stack and temp > temperatures[stack[-1]]: prev_day = stack.pop() answer[prev_day] = i - prev_day stack.append(i) return answer"},{"question":"Given a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple values in the BST that are equally close to the target, return the smaller value. The binary search tree is guaranteed to have at least one node. You may assume that the BST is implemented via the `TreeNode` class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root: TreeNode, target: float) -> int: Given a binary search tree and a target value, returns the value in the BST that is closest to the target. If there are multiple values in the BST that are equally close to the target, returns the smaller value. closest = root.val while root: if abs(root.val - target) < abs(closest - target) or (abs(root.val - target) == abs(closest - target) and root.val < closest): closest = root.val if target < root.val: root = root.left else: root = root.right return closest"},{"question":"You are given an array of integers `heights` representing the height of plants and an integer `d` representing the maximum distance you can jump forward or backward. You want to collect water from as many plants as possible, starting from any position in the array. In one jump, you can only jump to a plant that has a height strictly greater than the plant you are currently on. Return _the maximum number of plants you can collect water from in one sequence of jumps_, starting from any plant.","solution":"def max_plants_collected(heights, d): Returns the maximum number of plants that can be collected starting from any plant with jumps strictly to higher plants within a distance d. :param heights: List of integers representing the height of plants. :param d: Integer representing the maximum distance of each jump. :return: Integer representing the maximum number of plants that can be collected in one sequence of jumps. n = len(heights) # Memoization list to store the max jumps starting from each plant dp = [0] * n def dfs(i): if dp[i] != 0: return dp[i] max_collect = 1 for direction in [-1, 1]: # -1 for left, 1 for right for j in range(1, d+1): ni = i + direction * j if 0 <= ni < n and heights[ni] > heights[i]: max_collect = max(max_collect, 1 + dfs(ni)) elif 0 <= ni < n and heights[ni] <= heights[i]: break dp[i] = max_collect return max_collect max_plants = 0 for i in range(n): max_plants = max(max_plants, dfs(i)) return max_plants"},{"question":"You are given a list of non-negative integers representing the heights of buildings along a street. Each building `i` casts a shadow of height `heights[i]` in a westward direction. Multiple buildings can overlap, resulting in a combined shadow height that is the maximum height of the overlapping buildings at any point. Write a function to determine the total length of the shadow cast by these buildings. The buildings are positioned consecutively, and the width of each building is `1` unit. The input list, `heights`, represents the building heights in order from west to east. Return the total length of the combined shadow.","solution":"def total_shadow_length(heights): Returns the total length of the shadow cast by the buildings. if not heights: return 0 total_length = 1 max_height = heights[0] for i in range(1, len(heights)): if heights[i] > max_height: total_length += 1 max_height = heights[i] return total_length"},{"question":"Given an integer array `arr` of length `n`, return the number of ways to choose four indices `i, j, k, l` such that `0 <= i < j < k < l < n` and the product of the elements at these indices is even. As the number may be too large, return it **modulo** `10^9 + 7`.","solution":"MOD = 10**9 + 7 def count_even_products(arr): Returns the number of ways to choose four indices `i, j, k, l` such that 0 <= i < j < k < l < n and the product of the elements at these indices is even. n = len(arr) count_even = 0 count_odd = 0 for num in arr: if num % 2 == 0: count_even += 1 else: count_odd += 1 # Calculate count if there is at least one even number if count_even == 0: return 0 # Total number of ways to choose 4 indices from n total_quadruples = (n * (n - 1) * (n - 2) * (n - 3)) // 24 total_quadruples %= MOD # Number of ways to choose 4 odd numbers (if there are at least 4 odd numbers) odd_quadruples = 0 if count_odd >= 4: odd_quadruples = (count_odd * (count_odd - 1) * (count_odd - 2) * (count_odd - 3)) // 24 odd_quadruples %= MOD # Subtract the number of ways to select only odd numbers from the total combinations result = (total_quadruples - odd_quadruples + MOD) % MOD return result"},{"question":"You are given an integer array `heights` representing the heights of students in a class and an integer `k`. A group photo is being planned and you want the students to be arranged in non-decreasing order of their heights such that the difference in height between any two adjacent students in the arrangement does not exceed `k`. Return `true` if such an arrangement is possible, otherwise return `false`.","solution":"def can_arrange_students(heights, k): Returns True if students can be arranged in non-decreasing order of their heights such that the difference in height between any two adjacent students does not exceed k, otherwise returns False. heights.sort() for i in range(len(heights) - 1): if heights[i+1] - heights[i] > k: return False return True"},{"question":"You are given a list of `n` integers, representing the positions of houses along a street. You are tasked with placing `k` heaters at various positions (not necessarily at the houses) along the street to ensure that every house is within the range of at least one heater. Write a function that returns the minimum radius of heaters required to cover all houses. The heater radius defines the maximum distance it can effectively cover. For example, if there are heaters at positions `h1`, `h2`, ... `hk`, the heater at position `hi` can cover any house within the range [hi - radius, hi + radius].","solution":"def find_min_radius(houses, heaters): Finds the minimum radius required for heaters to cover all houses. :param houses: List[int] - Positions of the houses :param heaters: List[int] - Positions where heaters are placed :return: int - Minimum radius required for heaters to cover all houses houses.sort() heaters.sort() def is_covered(radius): heater_index = 0 for house in houses: while (heater_index < len(heaters) and heaters[heater_index] + radius < house): heater_index += 1 if heater_index == len(heaters) or heaters[heater_index] - radius > house: return False return True lo, hi = 0, max(max(houses), max(heaters)) - min(min(houses), min(heaters)) while lo < hi: mid = (lo + hi) // 2 if is_covered(mid): hi = mid else: lo = mid + 1 return lo"},{"question":"You are given a **0-indexed** integer array `nums` representing the number of votes each candidate received in an election. Suppose there are `k` seats available to be filled. Each seat can only be filled by the candidate with the most votes among the remaining candidates. Write a function to determine the minimal number of votes required for a candidate to guarantee winning at least one seat in the election. If it\'s impossible for any candidate to guarantee a win, return `-1`.","solution":"def minimal_votes_to_win(nums, k): Returns the minimal number of votes required for a candidate to guarantee winning at least one seat. If it\'s impossible for any candidate to guarantee a win, returns -1. if k <= 0 or not nums: return -1 sorted_votes = sorted(nums, reverse=True) # When there are more candidates than the number of seats if k > len(nums): return -1 # The candidate needs more votes than the number of votes of the k-th candidate return sorted_votes[k-1] + 1 if k <= len(nums) else -1"},{"question":"You are given a list of integers `nums` representing a histogram where the width of each bar is `1`. The bars\' heights are given in the array `nums`. Each bar in the histogram is as wide as it is high, and the whole histogram is divided into `n` bars of different heights. Find the area of the largest rectangle in the histogram. For example, given `nums = [2,1,5,6,2,3]`, the largest rectangle has an area of `10` (between the bars of heights `5` and `6`). Return the area of the largest rectangle.","solution":"def largest_rectangle_area(nums): Finds the area of the largest rectangle in the histogram represented by the list of integers \'nums\'. :param nums: List of integers representing the histogram\'s heights. :return: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(nums): if not stack or nums[index] >= nums[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a binary tree with `n` nodes. Each node has a value associated with it. Implement a method to find the sum of the values of all nodes on the longest path from the root to a leaf. If there are multiple paths of the same length, return the maximum sum among those paths. Write a function `int maxSumLongestPath(TreeNode root)` where `TreeNode` is the structure for a tree node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxSumLongestPath(root): Returns the maximum sum of the values of all nodes on the longest path from the root to a leaf. def dfs(node): if not node: return (0, 0) # (max_sum, max_length) left_sum, left_length = dfs(node.left) right_sum, right_length = dfs(node.right) if left_length > right_length: return (left_sum + node.val, left_length + 1) elif right_length > left_length: return (right_sum + node.val, right_length + 1) else: # left_length == right_length return (max(left_sum, right_sum) + node.val, left_length + 1) # Start the dfs from the root max_sum, _ = dfs(root) return max_sum"},{"question":"You are given a 2D integer `matrix` of size `m x n`, where each cell contains either a `0` or a `1`. You need to determine the size of the largest square containing only `1`s and return its area. Implement a function `maximalSquare` which takes the matrix as input and returns the area of the largest square containing only `1`s. If there is no such square, return `0`.","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i - 1][j - 1] == \'1\': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"Given a binary tree, return _a list of the **leaf nodes** in the tree ordered from left to right._ A **leaf node** is a node that has no children. If the tree is empty, return an empty list. Example: ``` Input: root = [3,9,20,null,null,15,7] Output: [9,15,7] Explanation: The leaves are 9, 15, and 7. ``` Note: The input represents a binary tree in level order format, and the values are arranged left to right for each level.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_leaves(root): Returns a list of the leaf nodes in the binary tree ordered from left to right. if not root: return [] leaves = [] def dfs(node): if not node: return if not node.left and not node.right: leaves.append(node.val) dfs(node.left) dfs(node.right) dfs(root) return leaves"},{"question":"You are given a grid of size `m x n` consisting of non-negative integers. Initially, you are positioned at the top-left corner of the grid. You can move either right or down at any point in time. You want to reach the bottom-right corner of the grid with the maximum sum of the values in the cells you travel through. Create an algorithm that: * **Finds** the maximum sum of the values along any path from the top-left to the bottom-right corner. Implement the `MaxPathSum` class: * `MaxPathSum(vector<vector<int>>& grid)`: Initializes the object with a 2D grid. * `int getMaxSum()`: Returns the maximum sum of the values along any path from the top-left to the bottom-right corner.","solution":"class MaxPathSum: def __init__(self, grid): self.grid = grid self.m = len(grid) self.n = len(grid[0]) if grid else 0 self.memo = [[-1] * self.n for _ in range(self.m)] def getMaxSum(self): return self._dfs(0, 0) def _dfs(self, i, j): if i >= self.m or j >= self.n: return 0 if i == self.m - 1 and j == self.n - 1: return self.grid[i][j] if self.memo[i][j] != -1: return self.memo[i][j] right_sum = down_sum = 0 if j + 1 < self.n: right_sum = self._dfs(i, j + 1) if i + 1 < self.m: down_sum = self._dfs(i + 1, j) self.memo[i][j] = self.grid[i][j] + max(right_sum, down_sum) return self.memo[i][j]"},{"question":"You are managing a device that can perform multiple software updates. Each update operation can take place in a certain interval of time. Given a series of update operations represented by intervals `[start, end)`, determine the minimum number of separate intervals needed such that no two updates overlap in any given interval. Implement the `UpdateManager` class: * `UpdateManager()` Initializes the update manager object. * `int minUpdatesRequired(int[] starts, int[] ends)` Takes in two arrays, `starts` and `ends`, which represent the starting and ending times of the update operations. Returns an integer representing the minimum number of separate intervals required to accommodate all the updates without any overlap. Your task is to develop the `UpdateManager` class with the described functionality.","solution":"import heapq class UpdateManager: def __init__(self): pass def minUpdatesRequired(self, starts, ends): if not starts or not ends or len(starts) != len(ends): return 0 intervals = sorted(zip(starts, ends), key=lambda x: x[0]) heap = [] for start, end in intervals: if heap and heap[0] <= start: heapq.heapreplace(heap, end) else: heapq.heappush(heap, end) return len(heap)"},{"question":"Implement a file system that supports the following operations: * `createPath(String path, int value)` - Creates a new path and associates a value with it if it does not already exist. If the path already exists or its parent path does not exist, return `false`, otherwise return `true`. * `get(String path)` - Returns the value associated with the path, or `-1` if the path does not exist. The format of a valid path is one or more concatenations of the form: `/` followed by one or more lowercase English letters. For example: ``` FileSystem fs = new FileSystem(); fs.createPath(\\"/a\\", 1); // return true fs.get(\\"/a\\"); // return 1 fs.createPath(\\"/a/b\\", 2); // return true fs.get(\\"/a/b\\"); // return 2 fs.createPath(\\"/c/d\\", 1); // return false because the parent path \\"/c\\" does not exist fs.get(\\"/c\\"); // return -1 because the path \\"/c\\" does not exist ``` Note: 1. The number of calls to `createPath` and `get` is less than or equal to `104`. 2. Each `createPath` and `get` call will only contain lowercase English letters and the \'/\' character. 3. The length of each given part of the path is up to 100.","solution":"class FileSystem: def __init__(self): self.paths = {\'\': -1} def createPath(self, path: str, value: int) -> bool: if not path or path[0] != \'/\' or path in self.paths: return False parent = path.rfind(\'/\') parent_path = path[:parent] if parent_path not in self.paths: return False self.paths[path] = value return True def get(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"You are given a 2D grid of size `m x n` filled with non-negative integers. Each cell represents the amount of gold in that cell. You can start collecting gold from any cell and you can move to any of its adjacent cells (up, down, left, right), but you cannot visit the same cell more than once. Return _the maximum amount of gold you can collect starting from any cell_. * The function signature is: `def get_maximum_gold(grid: List[List[int]]) -> int:`","solution":"from typing import List def get_maximum_gold(grid: List[List[int]]) -> int: Finds the maximum amount of gold that can be collected in the grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) max_gold = 0 def dfs(r, c, current_gold): nonlocal max_gold if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return current_gold += grid[r][c] max_gold = max(max_gold, current_gold) # Temporarily mark the cell as visited temp = grid[r][c] grid[r][c] = 0 # Explore adjacent cells dfs(r + 1, c, current_gold) dfs(r - 1, c, current_gold) dfs(r, c + 1, current_gold) dfs(r, c - 1, current_gold) # Backtrack and restore the cell\'s value grid[r][c] = temp for i in range(rows): for j in range(cols): if grid[i][j] != 0: dfs(i, j, 0) return max_gold"},{"question":"Given an array of integers `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same and the resulting array should be truncated to contain only the unique elements. Return _the number of unique elements_. Do this in `O(n)` time complexity and `O(1)` space complexity.","solution":"def remove_duplicates(nums): Removes duplicates in-place such that each unique element appears only once. Returns the number of unique elements. Parameters: nums (List[int]): A list of integers sorted in non-decreasing order. Returns: int: The number of unique elements in the list after removing duplicates. if not nums: return 0 unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] return unique_index + 1"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of students standing in a line. Arrange the students such that no student has a shorter student immediately in front of them (i.e., standing to the left of them). However, students can be moved any number of positions to achieve this order. Return the minimum number of positions each student needs to move to achieve an ordering where each student is taller than the one directly in front of them.","solution":"def minimum_moves_to_sort(heights): Returns the minimum number of positions each student needs to move to achieve an ordering where each student is taller than the one directly in front of them. sorted_heights = sorted(heights) moves = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: moves += 1 return moves"},{"question":"Write a function that receives a string containing lowercase English letters and returns the length of the longest substring with all distinct characters. For example, given the input \\"abcabcbb\\", the output should be 3 because the longest substring with all distinct characters is \\"abc\\". Ensure your solution is efficient and follows optimal practices.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `nums` representing the amount of data that needs to be processed, where `nums[i]` is the amount of data at the `ith` processing unit. You are also given an integer `n` that represents the number of available processors. Each processor can handle a contiguous segment of the array. Return _the **minimum** total completion time required if the processors can work in parallel_. The completion time for a processor is defined as the sum of the processing times of the assigned segment. The test cases are generated so that the answer fits in a 32-bit integer.","solution":"def minTime(nums, n): def canDistribute(nums, n, maxTime): total, count = 0, 1 for num in nums: total += num if total > maxTime: total = num count += 1 if count > n: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canDistribute(nums, n, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an integer array `nums` and an integer `k`. We call an array `transformable` if we can turn all its elements to 0 using the following operation any number of times: choose any subarray of length `k` and set all its elements to the minimum value in this subarray. Determine if the array `nums` is transformable. Return _a boolean value_ indicating whether the array `nums` can be transformed to an array of all zeros using the described operations.","solution":"def is_transformable(nums, k): Determines if the array nums can be transformed to an array of all zeros using the specified operation. :param nums: List of integers :param k: Length of subarray to consider :return: Boolean indicating if the array can be transformed if k <= 0: return False # k must be a positive number n = len(nums) if k == 1: return all(num == 0 for num in nums) min_value = min(nums) # Check if the array can be \\"flattened\\" to all elements being the minimum value for i in range(n - k + 1): subarray = nums[i:i + k] if len(set(subarray)) != 1: return False return min_value == 0"},{"question":"You are given an integer array `heights` representing the heights of buildings in a city. The buildings form a skyline viewed from a distance. Each building has a width of `1`. Return _an integer representing the **number of visible buildings** in the skyline view from the left most position_. A building is visible if there is no building taller or equal in height positioned in front of it to its left.","solution":"def count_visible_buildings(heights): Counts the number of visible buildings in a skyline view from the left most position. Args: heights (list): List of integers representing the heights of buildings. Returns: int: Number of visible buildings. if not heights: return 0 visible_count = 0 max_height_so_far = 0 for height in heights: if height > max_height_so_far: visible_count += 1 max_height_so_far = height return visible_count"},{"question":"Given a string `str`, return the longest substring that contains at most two distinct characters. If there are multiple substrings with the same length, return the one that appears first in the string.","solution":"def longest_substring_two_distinct(str): Returns the longest substring that contains at most two distinct characters. If there are multiple substrings with the same length, returns the one that appears first. max_len = 0 max_substr = \\"\\" window_start = 0 char_map = {} for window_end in range(len(str)): current_char = str[window_end] if current_char not in char_map: char_map[current_char] = 0 char_map[current_char] += 1 while len(char_map) > 2: left_char = str[window_start] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] window_start += 1 current_length = window_end - window_start + 1 if current_length > max_len: max_len = current_length max_substr = str[window_start:window_end+1] return max_substr"},{"question":"You are given an array `intervals` where `intervals[i] = [starti, endi]` represents the inclusive time interval from `starti` to `endi`, and an array `queries` where `queries[j]` represents a specific point in time. For each query, determine the minimum length of any interval that includes this point. If no such interval exists, return `-1` for that query. Return _an array_ `result` _where_ `result[j]` _is the answer for the_ `j-th` _query_.","solution":"def minInterval(intervals, queries): from heapq import heappush, heappop # Sort the intervals by their starting point intervals.sort() # Array to store the result for each query result = [-1] * len(queries) # Array to store the queries along with their original indices indexed_queries = [(query, i) for i, query in enumerate(queries)] indexed_queries.sort() min_heap = [] interval_idx = 0 for query, query_idx in indexed_queries: while interval_idx < len(intervals) and intervals[interval_idx][0] <= query: start, end = intervals[interval_idx] if end >= query: heappush(min_heap, (end - start + 1, end, start)) interval_idx += 1 while min_heap and min_heap[0][1] < query: heappop(min_heap) if min_heap: result[query_idx] = min_heap[0][0] return result"},{"question":"Write a function `find_duplicate` that takes a list of integers `nums` where each integer in the range `1` to `n` appears exactly once, except that there is one duplicate number, which appears twice. Your function should return this duplicate number. You should implement the constraints that your solution must use only constant extra space and the input list is read-only.","solution":"def find_duplicate(nums): Find the duplicate number in a list. Args: nums (List[int]): A list of integers where each integer in the range from 1 to n appears exactly once except one integer that appears twice. Returns: int: The duplicate integer. # Using Floyd\'s Tortoise and Hare (Cycle Detection) algorithm tortoise = hare = nums[0] # Phase 1: Finding the intersection point of the two runners. while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Phase 2: Find the entrance to the cycle. tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"You are given a **0-indexed** array `heights` of integers representing the height of students standing in a line. Each student in the line is either standing at their initial height or is a **specified number** of centimeters taller due to standing on a step. The array `heights` is guaranteed to be sorted in non-decreasing order. If the students at positions `i` and `j` have the same height, then `heights[i] = heights[j]`. You are also given an integer `maxDifference` which represents the maximum allowable difference in height between any two adjacent students in a valid permutation. Return _the **maximum** number of positions from the original list that can **remain occupied** in a valid permutation if each student is allowed to increase their height by exactly the specified number of centimeters. If it is not possible to have a valid permutation with more than zero students, return `-1`._ Note: A valid permutation allows no two adjacent students to have a height difference greater than `maxDifference`.","solution":"def max_positions_occupied(heights, maxDifference): # Calculate the number of students n = len(heights) if n == 0: return -1 # No students to place max_positions = 0 current_pos = 0 while current_pos < n: count = 1 # The first student in the contiguous sequence while current_pos + count < n and heights[current_pos + count] - heights[current_pos + count - 1] <= maxDifference: count += 1 max_positions = max(max_positions, count) current_pos += count return max_positions if max_positions > 0 else -1"},{"question":"Given an integer array `nums`, return the **maximum length** of a subarray that sums to `0`. * The subarray can be from any continuous set of indices within the array. For example, given `nums = [1, -1, 3, 2, -2, -3, 3, 1]`, the longest subarray with sum `0` is `[1, -1, 3, 2, -2, -3]`, so the function should return `6`.","solution":"def max_len_subarray_zero_sum(nums): Returns the maximum length of a subarray that sums to 0. sum_indices = {} current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum == 0: max_length = i + 1 if current_sum in sum_indices: max_length = max(max_length, i - sum_indices[current_sum]) else: sum_indices[current_sum] = i return max_length"},{"question":"Given a list of integers and an integer `k`, return the k-th largest element in the list. Note that it is the k-th largest element in sorted order, not the k-th distinct element. Implement a function `findKthLargest` that takes an array of integers `nums` and an integer `k` as input and returns the k-th largest element. You must implement an algorithm with O(n) average time complexity.","solution":"import heapq def findKthLargest(nums, k): This function returns the k-th largest element in the input list `nums`. It uses a min-heap to maintain the k largest elements found so far. # Use a min-heap with k elements to store the k largest elements min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) return min_heap[0]"},{"question":"You are given a list of `n` non-negative integers representing the amount of money in each house in a row. To maximize the amount of money stolen, you cannot steal from any two adjacent houses. Write a function that returns the maximum amount of money you can steal given the list of house values. Return the result as an integer.","solution":"def rob(houses): Given a list of non-negative integers representing the amount of money in each house, returns the maximum amount of money you can steal without stealing from two adjacent houses. if not houses: return 0 if len(houses) <= 2: return max(houses) dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], houses[i] + dp[i-2]) return dp[-1]"},{"question":"Given a sorted array of distinct integers `arr` and an integer `k`, return the `k`-th missing positive integer. Note that a positive integer is considered missing if it does not appear in `arr` and is less than the maximum element of `arr` plus `k`.","solution":"def find_kth_missing(arr, k): Returns the k-th missing positive integer from the sorted array `arr`. missing_count = 0 last_num = 0 for num in arr: num_missings = num - last_num - 1 if missing_count + num_missings >= k: return last_num + (k - missing_count) missing_count += num_missings last_num = num # If k-th missing is beyond the last element in the array return last_num + (k - missing_count)"},{"question":"Given an integer `n`, return the list of all unique combinations of factors (excluding 1 and the number itself) that multiply to `n`. Each combination should be sorted in ascending order, and the result list should be sorted lexicographically. For example, for n = 12, the output should be: ``` [ [2, 2, 3], [2, 6], [3, 4] ] ```","solution":"def get_factors(n): Returns a list of all unique combinations of factors (excluding 1 and the number itself) that multiply to `n`. Each combination is sorted in ascending order, and the result list is sorted lexicographically. def backtrack(start, target, path): if target == 1: if len(path) > 1: result.append(path[:]) return for i in range(start, target + 1): if target % i == 0: path.append(i) backtrack(i, target // i, path) path.pop() result = [] backtrack(2, n, []) return result"},{"question":"You are given a string `s` consisting of lowercase alphabetic characters. You can perform at most one operation on the string: choose any two indices `i` and `j` (0-indexed) and swap the characters at those positions. Return `true` if you can make the string a palindrome with exactly one swap operation or without any swap operations, and `false` otherwise. A palindrome is a word that reads the same forward as backward.","solution":"def can_make_palindrome(s): Return `true` if you can make the string a palindrome with one swap or no swaps. def is_palindrome(st): return st == st[::-1] n = len(s) if is_palindrome(s): return True # Find pairs of mismatched characters mismatched_pairs = [] for i in range(n // 2): if s[i] != s[n - i - 1]: mismatched_pairs.append((i, n - i - 1)) # If there are more than 2 mismatched pairs, it is not possible to make a palindrome with one swap if len(mismatched_pairs) > 2: return False # Special case for when there are exactly 2 mismatched pairs if len(mismatched_pairs) == 2: (i1, j1), (i2, j2) = mismatched_pairs if (s[i1] == s[j2] and s[j1] == s[i2]): return True # If there are 0 or 1 mismatched pairs, it\'s already handled - can be made palindrome with one swap or is already a palindrome return len(mismatched_pairs) == 0 or len(mismatched_pairs) == 1"},{"question":"You are given an array `heights` representing the heights of buildings in a city skyline. The array consists of `n` integers, where `heights[i]` is the height of the `i`-th building. You are also given an integer `k`. You need to calculate the maximum possible height increase for any building such that there are no more than `k` increases from the original height. These increases can be distributed among all buildings in any manner. Return _an array_ `result`_, where_ `result[i]` _is the maximum possible height of the_ `i`-th building.","solution":"def max_height_increase(heights, k): Returns an array where each element represents the maximum possible height of each building after distributing at most k increases in height. max_possible_height = max(heights) + k return [max_possible_height for _ in heights]"},{"question":"You are given a \\"square\\" 2D character grid of size `n x n` that is filled with letters from the alphabet. Your task is to find the length of the longest word that can be constructed by following the letters in reverse diagonal order, starting from any cell in the grid. A word is constructed by moving from a cell to another cell that is one step diagonally down-left. You may not use the same cell more than once in constructing the word. Return the length of the longest word possible. **Example:** grid = [ [\'a\', \'b\', \'c\'], [\'d\', \'e\', \'f\'], [\'g\', \'h\', \'i\'] ] Starting from cell (0, 2) -> the word is \'c\', length = 1. Starting from cell (1, 1) -> then (2, 0) -> the word is \'eh\', length = 2.","solution":"def longest_reverse_diagonal_word_length(grid): Returns the length of the longest word that can be constructed by following the letters in reverse diagonal order in a given n x n grid. n = len(grid) max_length = 0 def dfs(x, y, length): nonlocal max_length max_length = max(max_length, length) if x + 1 < n and y - 1 >= 0: dfs(x + 1, y - 1, length + 1) # Process all cells in the first column and the first row for i in range(n): dfs(i, 0, 1) dfs(0, i, 1) return max_length"},{"question":"Given a 2D grid of integers `grid` representing a map where `1` represents land and `0` represents water, an island is defined as a group of `1`\'s (land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Write a function that returns the maximum number of connected land cells (an island) in the `grid`. Note that the island may contain land cells of any shape.","solution":"def max_area_of_island(grid): Returns the maximum number of connected land cells in the grid. if not grid or not grid[0]: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # mark as visited area = 1 # current land cell area += dfs(grid, i + 1, j) area += dfs(grid, i - 1, j) area += dfs(grid, i, j + 1) area += dfs(grid, i, j - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(grid, i, j)) return max_area"},{"question":"You are given a list of `n` integers representing the heights of buildings in a line. Each building\'s width is `1`. Implement a function that calculates the **maximum rectangular area** that can be formed using one or more consecutive buildings. The height of the rectangle is determined by the shortest building in the selected range of buildings. The function should be defined as: ```python def max_rectangle_area(heights: List[int]) -> int: ``` This function should return the maximum rectangular area that can be formed from a contiguous subarray of the heights array.","solution":"from typing import List def max_rectangle_area(heights: List[int]) -> int: Finds the maximum rectangular area that can be formed using one or more consecutive buildings given their heights. n = len(heights) if n == 0: return 0 max_area = 0 stack = [] for i in range(n): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] if stack: width = i - stack[-1] - 1 else: width = i max_area = max(max_area, h * width) stack.append(i) while stack: h = heights[stack.pop()] if stack: width = n - stack[-1] - 1 else: width = n max_area = max(max_area, h * width) return max_area"},{"question":"Given a `m x n` binary matrix `mat`, return _the **maximum area** of a rectangle that contains only `1`s_. A rectangle is defined as a contiguous block of cells that all have the value `1` and can span over multiple rows and columns. The area of the rectangle is given by the number of cells within it.","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 dp = [0] * len(matrix[0]) for row in matrix: for index, val in enumerate(row): dp[index] = dp[index] + 1 if val == \'1\' else 0 max_area = max(max_area, largestRectangleArea(dp)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"You are given a string `s` and an integer `k` representing the maximum number of characters you can delete from the string. You need to determine the **length of the longest substring** of `s` where at most `k` characters have been removed from it. Return _an integer_ representing the length of the longest substring you can obtain by removing at most `k` characters. Example: ``` Input: s = \\"abcde\\", k = 2 Output: 5 Explanation: You can remove 0 characters and have the entire string \\"abcde\\" as a valid substring. ```","solution":"def longest_substring_with_k_deletions(s, k): Returns the length of the longest substring where at most k characters have been removed from it. n = len(s) left = 0 max_length = 0 while left < n: for right in range(left, n + 1): if len(s[left:right]) + k >= n: max_length = max(max_length, right - left) left += 1 return max_length # Testing the function with the given example s = \\"abcde\\" k = 2 print(longest_substring_with_k_deletions(s, k)) # Output should be 5"},{"question":"Given an array of distinct integers `arr` sorted in strictly increasing order, and an integer `k`, return the `k`-th missing positive integer from the array. A missing positive integer is a positive integer that does not appear in the array. Note that `k` is a 1-based index. --- This question complements the existing set by introducing a different area within similar concepts, focusing on array manipulation and sequence analysis while maintaining consistent complexity and format.","solution":"def find_kth_missing(arr, k): Returns the k-th missing positive integer from the sorted array `arr`. :param arr: List[int] - A sorted list of distinct integers. :param k: int - The 1-based index of the missing positive integer to find. :return: int - The k-th missing positive integer. missing_count = 0 i, current = 0, 1 while True: if i < len(arr) and arr[i] == current: i += 1 else: missing_count += 1 if missing_count == k: return current current += 1"},{"question":"Given an integer array `arr` of **unique** integers sorted in **increasing order** and an integer `target`, return _the integer in the array that is **closest** to the target_. If there are two numbers in the array equally close to the target, return the smaller number.","solution":"def find_closest_number(arr, target): Returns the number in the array \'arr\' that is closest to \'target\'. If two numbers are equally close, the smaller number is returned. closest = arr[0] min_diff = abs(closest - target) for num in arr: current_diff = abs(num - target) if current_diff < min_diff or (current_diff == min_diff and num < closest): closest = num min_diff = current_diff return closest"},{"question":"You are given an array of integers `arr` and an integer `k`. Suppose we can make at most `k` changes to the numbers in `arr`, where each change involves incrementing or decrementing an element by `1`. Return the maximum possible frequency of any one value after performing at most `k` changes. For example, given `arr = [1, 2, 4, 4, 3]` and `k = 2`, the result would be `3` since we can change the two `4`s to `3`s or the two `3`s to `4`s, resulting in three `3`s or three `4`s, respectively.","solution":"def max_frequency(arr, k): Returns the maximum possible frequency of any one value in the array after performing at most k changes. :param arr: List[int] - the list of integers :param k: int - the maximum number of changes allowed :return: int - the maximum possible frequency of any one value arr.sort() left, total, result = 0, 0, 0 for right in range(len(arr)): total += arr[right] while (arr[right] * (right - left + 1) - total) > k: total -= arr[left] left += 1 result = max(result, right - left + 1) return result"},{"question":"You are given a 2D grid represented by a list of lists `grid` where each element can be 0 (representing an empty cell) or 1 (representing an obstacle). A robot can move from the top-left corner of the grid (starting at `grid[0][0]`) to the bottom-right corner (ending at `grid[m-1][n-1]`). The robot can only move right or down. Determine the number of unique paths that the robot can take to reach the destination. If there is no valid path from the top-left to the bottom-right corner, return `0`.","solution":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths in a 2D grid with obstacles. :param grid: List[List[int]] representing a 2D grid with 0s (empty) and 1s (obstacle) :return: int - Number of unique paths from top-left to bottom-right if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given a sorted integer array `arr` of size `n`, and an integer `target`. Your task is to find two distinct indices `i` and `j` in the array such that the sum `arr[i] + arr[j]` is equal to `target`. Return the indices `i` and `j` as a tuple `(i, j)`. If there are no such indices, return `(-1, -1)`. Ensure that the solution has a time complexity of O(n).","solution":"def find_two_sum_indices(arr, target): Returns the indices of two distinct elements in the sorted array `arr` that sum up to `target`. If no such elements are found, returns (-1, -1). :param arr: List[int] - a sorted list of integers. :param target: int - the target sum. :return: Tuple[int, int] - a tuple containing the indices of the two elements, or (-1, -1) if no such elements exist. left = 0 right = len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return (left, right) elif current_sum < target: left += 1 else: right -= 1 return (-1, -1)"},{"question":"In a warehouse, there are multiple shelves stacked with different boxes. Each shelf `i` has `height[i]` representing the height of the tallest box on that shelf. You must rearrange these shelves to make the warehouse more organized. The task is to sort the shelves in non-decreasing order of their heights using minimum effort. Your effort is defined as the number of swaps required. A swap involves moving one box from one shelf to another while maintaining the overall ordering of the shelves. Write a function that takes an array `height` of length `n` representing the height of the tallest box on each of `n` shelves. Your function should return the minimum number of swaps required to sort the shelves in non-decreasing order of height. Example: ``` Input: height = [4, 3, 2, 1] Output: 2 Explanation: Swap 4 and 1, then swap 4 and 2. The sorted array is [1, 2, 3, 4]. ```","solution":"def min_swaps_to_sort(height): Returns the minimum number of swaps required to sort the array height in non-decreasing order. # Create a list of tuples where each tuple contains a height and its index in the original array indexed_height = list(enumerate(height)) # Sort the list based on heights indexed_height.sort(key=lambda x: x[1]) # Initialize an array to check if a shelf has been visited during the cycle detection visited = [False] * len(height) swaps = 0 for i in range(len(height)): if visited[i] or indexed_height[i][0] == i: continue # Find the cycle length cycle_length = 0 x = i while not visited[x]: visited[x] = True x = indexed_height[x][0] cycle_length += 1 # If cycle length is n, we need (n-1) swaps to sort the cycle if cycle_length > 0: swaps += (cycle_length - 1) return swaps"},{"question":"Given an integer array `arr`, return the element that appears **more than** `n / 2` times, where `n` is the length of the array. You may assume that such an element always exists in the array. The algorithm should run in **O(n)** time and use **O(1)** extra space.","solution":"def majority_element(arr): Finds the element that appears more than n / 2 times in the array. Assumption: Such an element always exists. :param arr: List[int], the input array :return: int, the majority element candidate, count = None, 0 for num in arr: if count == 0: candidate, count = num, 1 elif num == candidate: count += 1 else: count -= 1 return candidate"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of a series of buildings and an integer `h` representing a height threshold. A building is considered **towering** if its height is more than `h`, and all buildings to its left are shorter than `h`. Return the index of the first towering building. If no such building exists, return `-1`.","solution":"def find_towering_building(heights, h): Returns the index of the first towering building in the heights array. Parameters: - heights: List[int], a list of building heights. - h: int, the height threshold. Returns: - int, the index of the first towering building or -1 if no such building exists. for i in range(len(heights)): if heights[i] > h and all(height <= h for height in heights[:i]): return i return -1"},{"question":"You are given a list of integers `arr` representing a time series of stock prices where `arr[i]` is the price of a stock on the `i-th` day. You are allowed to buy and sell the stock only once. Your task is to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum possible profit you can achieve from this transaction. If no profit can be made, return `0`.","solution":"def max_profit(arr): Returns the maximum profit that can be made by buying and selling stock once. If no profit can be made, returns 0. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: profit = price - min_price max_profit = max(max_profit, profit) min_price = min(min_price, price) return max_profit"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents a point on the 2D plane. You are also given an integer `k`. A move consists of choosing any point and moving it to a new location `(xi + dx, yi + dy)` such that the Euclidean distance `(dx^2 + dy^2)^0.5` between the original and new locations is at most `k`. Calculate the minimum number of moves required to make all points coincident (i.e., the same position). If it is not possible to make all points coincident, return `-1`.","solution":"# Given the problem constraints, the task is complex. To simplify, let\'s analyze. # Given a set of points, the goal is to minimize the moves required to make them coincide. # Being each move restricted by a maximum distance k, we need to check all possible pairs of points and # analyze whether we can make a point coincide at the same location within given constraints. from math import sqrt def min_moves_to_coincide(points, k): def can_move_within_distance(p1, p2): distance = sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) return distance <= k n = len(points) # If there\'s only one point, it is already coincident if n == 1: return 0 # Iterate through each point and check if we can move all other points to coincide with it for i in range(n): valid = True for j in range(n): if i != j and not can_move_within_distance(points[i], points[j]): valid = False break if valid: return 1 # If we can move all points to coincide with `points[i]`, return 1 move # If no point can be used to coincide all points within distance k, return -1 return -1"},{"question":"You are given an **undirected graph** represented as an integer `n` (indicating the number of nodes, labeled from `0` to `n-1`) and a 2D integer array `edges`, where each `edges[i] = [u, v]` represents an undirected edge between nodes `u` and `v`. You need to perform the following operations: * **addEdge(u, v)**: Adds an undirected edge between nodes `u` and `v` if it does not already exist. * **removeEdge(u, v)**: Removes the edge between nodes `u` and `v` if it exists. * **isConnected(u, v)**: Checks if there is a path between nodes `u` and `v` (excluding certain edges if specified during the check). Implement the `Graph` class, which includes the following methods: * `Graph(int n)`: Initializes the graph with `n` nodes and no edges. * `void addEdge(int u, int v)`: Adds an undirected edge between nodes `u` and `v`. * `void removeEdge(int u, int v)`: Removes the edge between nodes `u` and `v`. * `boolean isConnected(int u, int v)`: Returns `true` if there is a path between nodes `u` and `v`, and `false` otherwise.","solution":"class Graph: def __init__(self, n): Initializes the graph with n nodes and no edges. self.n = n self.adj_list = {i: set() for i in range(n)} def addEdge(self, u, v): Adds an undirected edge between nodes u and v. if v not in self.adj_list[u]: self.adj_list[u].add(v) self.adj_list[v].add(u) def removeEdge(self, u, v): Removes the edge between nodes u and v if it exists. if v in self.adj_list[u]: self.adj_list[u].remove(v) self.adj_list[v].remove(u) def isConnected(self, u, v): Checks if there is a path between nodes u and v. Uses Breadth-First Search (BFS). if u == v: return True visited = [False] * self.n queue = [u] while queue: current = queue.pop(0) if current == v: return True visited[current] = True for neighbor in self.adj_list[current]: if not visited[neighbor]: queue.append(neighbor) return False"},{"question":"Given a string `sentence` consisting of only lowercase English letters and spaces, return the number of words consisting of vowels only. Vowels are the letters `\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, and `\'u\'`. A **word** is defined as a contiguous string of non-space characters. Consider the following example to understand the requirement: * For example, `\\"aeiou is the only vowel\\"` should return 1 because there is only one word (\\"aeiou\\") that consists entirely of vowels.","solution":"def count_vowel_words(sentence): Returns the number of words in the sentence that consist only of vowels. Args: - sentence (str): A string containing lowercase English letters and spaces. Returns: - int: The count of words that are made up of only vowels. vowels = set(\'aeiou\') count = 0 # Split the sentence into words words = sentence.split() for word in words: if all(char in vowels for char in word): count += 1 return count"},{"question":"You are given a dictionary `mappings` where each key is a string representing a word and each value is a list of synonyms for that word. Also, you are given a list of strings `sentences`, each representing a sentence. Write a function to return a list of all possible sentences where each word in the original sentence is replaced with one of its synonyms, if any. Words without synonyms should remain unchanged. The order and capitalization of the initial sentence must be preserved. Each possible sentence should be a separate string in the returned list. For example, given `mappings = {\\"quick\\": [\\"fast\\", \\"speedy\\"], \\"brown\\": [\\"chocolate\\"]}` and `sentences = [\\"The quick brown fox\\"]`, the output should be `[\\"The fast chocolate fox\\", \\"The speedy chocolate fox\\", \\"The quick chocolate fox\\"]`. Function Signature: ```python def generate_synonym_sentences(mappings: Dict[str, List[str]], sentences: List[str]) -> List[str]: ```","solution":"from typing import List, Dict import itertools def generate_synonym_sentences(mappings: Dict[str, List[str]], sentences: List[str]) -> List[str]: Given a dictionary of mappings where each key is a word and its value is a list of synonyms, and a list of sentences, returns a list of all possible sentences where each word in the original sentences is replaced with one of its synonyms. :param mappings: Dict[str, List[str]] - word to synonyms mapping :param sentences: List[str] - original sentences :return: List[str] - all possible sentences with synonyms replacements result = [] def generate_variants(words: List[str], index: int) -> List[str]: if index == len(words): # Base case: return current completed variant as a single-item list return [\' \'.join(words)] word = words[index] # Generate sentences with current word and all its synonyms variants = [] # Use the original word itself next_words = words[:index] + [word] + words[index+1:] variants.extend(generate_variants(next_words, index + 1)) if word in mappings: for synonym in mappings[word]: next_words = words[:index] + [synonym] + words[index+1:] variants.extend(generate_variants(next_words, index + 1)) return variants for sentence in sentences: words = sentence.split() result.extend(generate_variants(words, 0)) return result"},{"question":"Design a data structure that supports the following operations on a collection of intervals: merging intervals and finding the maximum overlapping intervals. Implement the `IntervalCollection` class: - `IntervalCollection()` Initializes the interval collection. - `void addInterval(int start, int end)` Adds an interval `[start, end]` to the collection. Each interval `[start, end]` includes all the integers between `start` and `end`, including the endpoints. - `List<int[]> getMergedIntervals()` Returns a list of merged intervals where all overlapping intervals have been merged. - `int getMaxOverlapping()` Returns the maximum number of overlapping intervals at any point in the collection.","solution":"from typing import List, Tuple class IntervalCollection: def __init__(self): self.intervals = [] def addInterval(self, start: int, end: int) -> None: self.intervals.append((start, end)) def getMergedIntervals(self) -> List[Tuple[int, int]]: if not self.intervals: return [] # Sort intervals by their start time self.intervals.sort() merged_intervals = [self.intervals[0]] for current in self.intervals[1:]: last_merged = merged_intervals[-1] if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals def getMaxOverlapping(self) -> int: if not self.intervals: return 0 events = [] for start, end in self.intervals: events.append((start, 1)) events.append((end + 1, -1)) events.sort() max_overlap = 0 current_overlap = 0 for time, change in events: current_overlap += change max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"You have an array of integers `nums` and an integer `target`. Your task is to find out if there exists a contiguous subarray within `nums` whose sum is exactly `target`. If such a subarray exists, return _the starting and ending indices of one such subarray_. If there are multiple such subarrays, return any one of them. If no such subarray exists, return `[-1, -1]`.","solution":"def subarray_sum(nums, target): Returns the starting and ending indices of a contiguous subarray within `nums` whose sum is exactly `target`. If no such subarray exists, returns [-1, -1]. current_sum = 0 sum_index_map = {0: -1} # To handle the case when subarray starts from index 0 for index, num in enumerate(nums): current_sum += num if (current_sum - target) in sum_index_map: start_index = sum_index_map[current_sum - target] + 1 end_index = index return [start_index, end_index] sum_index_map[current_sum] = index return [-1, -1]"},{"question":"You are given a list of non-negative integers representing an elevation map where the width of each bar is 1. Write a function to find the maximum amount of water that can be trapped after raining. The elevation map is represented by an integer array `height` where `height[i]` is the height of the `i-th` bar.","solution":"def trap(height): Calculate the total amount of water trapped based on the input height array. :param height: List[int], the elevation map. :return: int, total water trapped. if not height: return 0 length = len(height) left_max = [0] * length right_max = [0] * length water_trapped = 0 left_max[0] = height[0] for i in range(1, length): left_max[i] = max(left_max[i - 1], height[i]) right_max[length - 1] = height[length - 1] for i in range(length - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(length): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a string `word` and a non-negative integer `k`. A subsequence of `word` is considered valid if it contains at most `k` distinct characters. Return the number of valid subsequences of `word`. Since the result might be large, return it modulo `10^9 + 7`. * For example, if `word = \\"abc\\"` and `k = 2`, the valid subsequences are `a`, `b`, `c`, `ab`, `ac`, `bc`, giving a result of `6`.","solution":"def num_valid_subsequences(word, k): Returns the number of valid subsequences of the given word that contain at most k distinct characters. MOD = 10**9 + 7 n = len(word) all_masks = 1 << n valid_count = 0 from collections import defaultdict from functools import lru_cache @lru_cache(None) def count_distinct_chars(mask): char_set = set() for i in range(n): if (mask & (1 << i)): char_set.add(word[i]) return len(char_set) for mask in range(1, all_masks): if count_distinct_chars(mask) <= k: valid_count = (valid_count + 1) % MOD return valid_count"},{"question":"Given a list of non-negative integers `nums`, you are to rearrange `nums` such that they form the **largest possible concatenated integer**. Return _the largest concatenated integer_ as a string. Note that the result may be very large, so you need to return a string instead of an integer.","solution":"from functools import cmp_to_key def largest_concatenated_integer(nums): Rearranges nums to form the largest possible concatenated integer. :param nums: List of non-negative integers :return: The largest concatenated integer as a string # Convert all numbers to strings since we need to compare concatenations nums = list(map(str, nums)) # Custom comparator to determine order based on concatenation results def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort the array using the custom comparator nums.sort(key=cmp_to_key(compare)) # Concatenate the result and handle the special case where input is all zeros result = \'\'.join(nums) return \'0\' if result[0] == \'0\' else result"},{"question":"Implement a `StreamChecker` class that performs a query to check if a string is present in a given list of strings, but the query should be done in reverse. The `StreamChecker` class should support two functions: 1. `StreamChecker(words)`: The constructor which initializes the `StreamChecker` with the list of given words. 2. `query(letter)`: A function that accepts a new character and returns `True` if any previously added word appears as a suffix of the formed string by appending the given letter, otherwise returns `False`. Note: - The query characters are appended one by one, and the words need to be checked in reverse order. - The maximum length of a word will be guaranteed to be 2000.","solution":"class StreamChecker: def __init__(self, words): Initializes the StreamChecker with the list of given words. self.queries = [] self.word_set = set() max_len = 0 for word in words: reversed_word = word[::-1] # Reverse the word and store in set self.word_set.add(reversed_word) max_len = max(max_len, len(reversed_word)) self.max_len = max_len def query(self, letter): Appends the letter to the query stream and checks if any word appears as a suffix. self.queries.append(letter) if len(self.queries) > self.max_len: self.queries.pop(0) current_string = \'\'.join(self.queries[::-1]) for word in self.word_set: if current_string.startswith(word): return True return False"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of buildings in a city. The array satisfies the following properties: 1. `heights.length` is odd. 2. There is a unique index `i` such that `heights[i]` is the maximum height in the array. A **peak arrangement** of buildings is an arrangement of the buildings such that: 1. Building at the maximum height is positioned at the center index. 2. The buildings on the left of the center index should have strictly increasing heights. 3. The buildings on the right of the center index should have strictly decreasing heights. Return `true` _if the given arrangement of buildings is already a peak arrangement_. Otherwise, return `false`.","solution":"def is_peak_arrangement(heights): Returns True if the given building heights are in a peak arrangement, otherwise False. n = len(heights) peak_index = heights.index(max(heights)) # Check if the max height is at the center index if peak_index != n // 2: return False # Check the left side (strictly increasing) for i in range(peak_index): if heights[i] >= heights[i + 1]: return False # Check the right side (strictly decreasing) for i in range(peak_index, n - 1): if heights[i] <= heights[i + 1]: return False return True"},{"question":"Given the `root` of a binary search tree, write a function to find the **k-th smallest element** in the tree. A binary search tree is a binary tree in which for each node, any descendant of the node\'s left child has a value less than the node\'s value, and any descendant of the node\'s right child has a value greater than the node\'s value. To achieve this, you may use an **in-order traversal** method. The function should take the root node of the binary search tree and an integer `k` as its parameters and return the k-th smallest element in the binary search tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Function to find the k-th smallest element in a BST. Args: root (TreeNode): The root of the binary search tree. k (int): The k-th position. Returns: int: The k-th smallest element in the BST. def inorder(node): return inorder(node.left) + [node.val] + inorder(node.right) if node else [] return inorder(root)[k-1]"},{"question":"A construction company wants to build a new road connecting two cities. There are `n` possible routes between the cities, each with a different construction cost. The routes are represented as an array of integers `cost`, where `cost[i]` is the construction cost of the `i-th` route. Additionally, each route has a specified maximum capacity, represented by an array `capacity`, where `capacity[i]` is the maximum number of vehicles that can travel the `i-th` route per day. Given a budget `B` for the total construction cost and a required capacity `R` for the new road, your task is to determine if it is possible to choose a subset of routes such that the total construction cost does not exceed `B` and the combined capacity meets or exceeds `R`. Return `true` if it is possible to select such a subset of routes, otherwise return `false`. _Example:_ **Input**: `cost = [5, 10, 3, 8], capacity = [4, 9, 2, 6], B = 15, R = 12` **Output**: `true`","solution":"def can_build_road(cost, capacity, B, R): Determines if it\'s possible to select a subset of routes such that the total construction cost does not exceed B and the combined capacity meets or exceeds R. :param cost: List[int], construction costs of the routes. :param capacity: List[int], capacities of the routes. :param B: int, budget for the total construction cost. :param R: int, required capacity for the new road. :return: bool, True if such a subset of routes can be selected, else False. n = len(cost) dp = [(0, 0)] # tuple of (total_cost, total_capacity) for i in range(n): current_cost, current_capacity = cost[i], capacity[i] new_dp = dp[:] for total_cost, total_capacity in dp: new_cost = total_cost + current_cost new_capacity = total_capacity + current_capacity if new_cost <= B: new_dp.append((new_cost, new_capacity)) dp = new_dp for total_cost, total_capacity in dp: if total_cost <= B and total_capacity >= R: return True return False"},{"question":"A programming company has a file system represented as a tree structure where each node denotes a directory or a file. You are given an array where each element is a string representing a path from the root directory to a particular file or directory. The directories and files are separated by `/`. For instance, the path `\\"dir1/dir2/file.txt\\"` indicates that `file.txt` is located inside `dir2` which is inside `dir1`. Your task is to write a program that transforms these paths into a nested dictionary structure such that each directory contains its subdirectories and files as sub-dictionaries and strings respectively. Return the nested dictionary structure representing the file system.","solution":"def build_file_structure(paths): Transforms an array of paths into a nested dictionary structure. Args: paths (list): List of path strings. Returns: dict: Nested dictionary representing the file structure. file_structure = {} for path in paths: components = path.split(\'/\') current_level = file_structure for component in components[:-1]: if component not in current_level: current_level[component] = {} current_level = current_level[component] current_level[components[-1]] = None return file_structure"},{"question":"You are given a string `s` consisting of lowercase English letters. A good string is a string in which all the characters are the same. Return the minimum number of characters to be changed to make the string a good string.","solution":"def min_changes_to_good_string(s): Returns the minimum number of characters to be changed to make the string a good string. :param s: A string consisting of lowercase English letters. :return: Minimum number of changes required. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 max_frequency = max(frequency.values()) return len(s) - max_frequency"},{"question":"You are given a string `s` and a string `t`. You can select any character from `s` and replace it with any other character. How many such single-character replacements are needed to make the string `s` an anagram of `t`? If it\'s not possible to transform `s` into an anagram of `t`, return `-1`. Note: An anagram of a string is another string that contains the same characters, only the order of characters can be different.","solution":"from collections import Counter def min_replacements_to_anagram(s, t): Given two strings s and t, returns the minimum number of single-character replacements needed to make s an anagram of t. Returns -1 if it\'s not possible to transform s into an anagram of t. if len(s) != len(t): return -1 count_s = Counter(s) count_t = Counter(t) # Calculate the number of replacements needed. replacements = 0 for char in count_t: if char in count_s: if count_t[char] > count_s[char]: replacements += count_t[char] - count_s[char] else: replacements += count_t[char] return replacements"},{"question":"A **word ladder** is a sequence of words where each word varies by just one letter from the previous word. Given two words, `start` and `end`, and a dictionary containing a list of valid words, return _the length of the shortest **word ladder** from_ `start` _to_ `end` where only one letter can be changed at a time and each intermediate word must exist in the dictionary. If no such sequence exists, return 0.","solution":"from collections import deque def word_ladder_length(start, end, dictionary): Returns the length of the shortest word ladder from start to end using the given dictionary. Parameters: start (str): The starting word. end (str): The ending word. dictionary (set): A set of valid words. Returns: int: Length of the shortest word ladder, or 0 if no such sequence exists. if end not in dictionary: return 0 dictionary.add(start) queue = deque([(start, 1)]) # (current_word, current_length) while queue: current_word, current_length = queue.popleft() if current_word == end: return current_length for i in range(len(current_word)): for char in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + char + current_word[i+1:] if next_word in dictionary: dictionary.remove(next_word) queue.append((next_word, current_length + 1)) return 0"},{"question":"You are provided with a **0-indexed** array `arr` where `arr[i]` represents the color of the ith stone in a row of stones. You are also given a 2D array `operations` where each `operations[j] = [leftj, rightj, colorj]` represents a range update. The update changes the color of all stones from index `leftj` to `rightj` inclusive, setting their color to `colorj`. After all operations are applied, your task is to determine the frequency of the most common color in the final configuration of stones. Return _the frequency of the most common color after performing all the operations._","solution":"def most_common_color_frequency(arr, operations): for left, right, color in operations: for i in range(left, right + 1): arr[i] = color color_frequency = {} for color in arr: if color in color_frequency: color_frequency[color] += 1 else: color_frequency[color] = 1 return max(color_frequency.values())"},{"question":"Given a **0-indexed** integer array `nums`, sort the numbers in non-decreasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order. _Return the sorted array._","solution":"from collections import Counter def frequencySort(nums): Sort the numbers in non-decreasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order. # Count the frequency of each value frequency = Counter(nums) # Sort based on frequency first and then value in decreasing order nums.sort(key=lambda x: (frequency[x], -x)) return nums"},{"question":"You are given a list of non-negative integers that represent the heights of pillars arranged in a line. You have to find the maximum area of water that can be trapped between two pillars. Write a function that receives a list `heights` of integers, where `heights[i]` represents the height of the `i-th` pillar. The function should return the maximum area of water that can be trapped between any two pillars. The area between two pillars is computed as the horizontal distance between the pillars multiplied by the height of the shorter pillar. You are required to solve this using a linear time complexity algorithm.","solution":"def max_area(heights): Returns the maximum area of water that can be trapped between two pillars. if len(heights) < 2: return 0 max_area = 0 left = 0 right = len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a list of strings `words` and a string `target`. You can perform the following operation on `words` any number of times: choose a word and reverse any one of its substrings. Return the _minimum number of operations required to make `words` a subset of permutations of `target`_ or `-1` if it\'s not possible. A **permutation of `target`** means any reorder of the characters in `target`.","solution":"def min_operations_to_permutations(words, target): Returns the minimum number of operations required to make `words` a subset of permutations of `target`. If it\'s not possible, returns -1. from collections import Counter def can_become_permutation(word, target_counter): Helper function to check if a word can be transformed to a permutation of target by reversing substrings. return Counter(word) == target_counter target_counter = Counter(target) operations = 0 for word in words: if not can_become_permutation(word, target_counter): return -1 operations += 1 return operations"},{"question":"You are given two strings `s` and `t` of length `n` and an integer `k`. You can choose up to `k` positions in the string `s` and change each of these positions to any character. Your task is to return the minimum number of positions you must change in `s` to make it equal to `t`.","solution":"def min_changes_to_equal(s, t, k): Returns the minimum number of changes required in string s to make it equal to string t, given that we can change up to k positions in string s. :param s: String s of length n :param t: String t of length n :param k: Maximum number of positions we are allowed to change :return: Minimum number of changes required to make s equal to t if len(s) != len(t): raise ValueError(\\"Strings s and t must be of the same length\\") change_count = sum(1 for i in range(len(s)) if s[i] != t[i]) return min(change_count, k)"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to partition the array into exactly `k` non-empty subarrays such that the sum of each subarray is _greater than or equal to_ a given integer `target`. If it is possible to partition the array in such a way, return `true`; otherwise, return `false`.","solution":"def can_partition(arr, k, target): Determines if it is possible to partition the array into exactly k non-empty subarrays such that the sum of each subarray is greater than or equal to a given integer target. :param arr: List of integers :param k: Number of partitions :param target: Target sum for each subarray :return: True if possible, otherwise False def can_form_partitions(arr, k, target): current_sum = 0 partitions = 0 for num in arr: current_sum += num if current_sum >= target: partitions += 1 current_sum = 0 return partitions >= k if sum(arr) < k * target: return False return can_form_partitions(arr, k, target)"},{"question":"You are given a string `s` containing only lowercase alphabetical characters. Your task is to determine the **length** of the longest substring that contains **no more than two distinct characters**. Write a function `longestSubstringWithTwoDistinct(s)` that takes the string `s` as input and returns the length of this longest substring. Keep in mind that the input string can be quite long, so make sure your solution is efficient.","solution":"def longestSubstringWithTwoDistinct(s): Returns the length of the longest substring that contains no more than two distinct characters. n = len(s) if n < 3: return n # Sliding window left and right pointers left, right = 0, 0 # Hashmap to keep track of characters and their rightmost positions hashmap = {} max_len = 2 while right < n: # Slide the window hashmap[s[right]] = right right += 1 # If the map contains more than 2 distinct characters if len(hashmap) > 2: # Get the leftmost character del_idx = min(hashmap.values()) # Remove it from the map del hashmap[s[del_idx]] # Slide the left pointer of the window left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given an `m x n` matrix of characters `grid` representing a word search puzzle, and a string `word`. Return _true_ if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Implement the function `bool exist(vector<vector<char>>& grid, string word)` which returns _true_ or _false_ based on whether the word can be formed in the grid or not.","solution":"def exist(grid, word): if not grid or not word: return False rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False # Save and mark the current cell as visited temp, grid[r][c] = grid[r][c], \'#\' # Explore the neighbors in DFS manner found = any(dfs(nr, nc, index + 1) for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]) # Restore the current cell grid[r][c] = temp return found for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"Given a non-negative integer `n`, your task is to generate a list of all unique valid combinations of well-formed parentheses of length `2n`. Each combination must use exactly `n` opening and `n` closing parentheses. For example: - Input: `n = 3` - Output: `[\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]` Return the list of valid combinations in any order.","solution":"def generate_parentheses(n): def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) result = [] backtrack() return result"},{"question":"Given a string `s` consisting of alphabets and digit characters, remove all consecutive duplicate characters and return the resulting string. Consecutive means the same character repeating one after another. For example, if the given string was \\"abbaccd\\", the output should be \\"abacd\\".","solution":"def remove_consecutive_duplicates(s): Removes all consecutive duplicate characters from the string s and returns the resulting string. if not s: return \\"\\" result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return \'\'.join(result)"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to determine whether there is a continuous subarray of size at least 2 that sums up to a multiple of `k`. In other words, should exist integers `i`, `j` with `j > i` such that `(sum(nums[i] ... nums[j])) % k == 0`. If `k` is 0, check if there is at least one subarray sum that equals 0. Return `true` if such subarray exists, otherwise return `false`.","solution":"def checkSubarraySum(nums, k): Return whether the array contains a subarray of at least size 2 that sums up to a multiple of k. If k is 0, check if there is at least one subarray sum that equals 0. if k == 0: # Check for any two consecutive zero elements for the subarray for i in range(1, len(nums)): if nums[i] == 0 and nums[i - 1] == 0: return True return False # Dictionary to store the modulus of the sum up to current index mod_dict = {0: -1} cumulative_sum = 0 for i in range(len(nums)): cumulative_sum += nums[i] current_mod = cumulative_sum % k if current_mod in mod_dict: if i - mod_dict[current_mod] > 1: return True else: mod_dict[current_mod] = i return False"},{"question":"You are given a string `s` representing a sequence of parentheses. A valid parentheses string is one that is correctly matched. Write a function to determine _the minimum number of parentheses to be added to make the parentheses string valid_. Strings consisting of only parentheses `(` and `)` will be given and the goal is to balance them by adding the least number of parentheses. Return _the minimum number of parentheses needed_.","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses to be added to make the string valid. :param s: str: A string consisting of \'(\' and \')\' :return: int: The minimum number of parentheses needed to make the string valid left_bracket_count = 0 right_bracket_count = 0 for char in s: if char == \'(\': left_bracket_count += 1 elif char == \')\': if left_bracket_count > 0: left_bracket_count -= 1 else: right_bracket_count += 1 return left_bracket_count + right_bracket_count"},{"question":"You are given a string `s` representing a sentence containing words separated by spaces. Each word consists of only lowercase English letters. Your task is to find and return the length of the longest word in the sentence. If there are multiple words with the same maximum length, return the length of the first one. Write code that efficiently performs this operation, ensuring minimal time complexity.","solution":"def length_of_longest_word(s): Returns the length of the longest word in the given sentence s. words = s.split() longest_word_length = 0 for word in words: if len(word) > longest_word_length: longest_word_length = len(word) return longest_word_length"},{"question":"You are given an integer array `tasks` where `tasks[i]` represents the duration of the `i-th` task. You need to distribute the tasks among two workers such that the difference between the total duration of tasks assigned to each worker is minimized. Write a function to determine the minimum possible difference achievable. Return _the minimum difference_ between the total durations assigned to the two workers.","solution":"def min_difference(tasks): Return the minimum possible difference between the total durations assigned to the two workers. :param tasks: List[int] - a list of task durations :return: int - the minimum difference between the two workers\' total task durations total_sum = sum(tasks) half_sum = total_sum // 2 # Initialize a DP set with a single element 0 (indicating zero sum) dp = {0} for task in tasks: # Update DP set with new possible sums new_dp = dp.copy() for s in dp: new_dp.add(s + task) dp = new_dp # Find the closest sum to half_sum closest_sum = max(s for s in dp if s <= half_sum) return abs(total_sum - 2 * closest_sum)"},{"question":"You are given two strings `s` and `t` of the same length. You want to transform string `s` into string `t` by performing the following operation any number of times: Choose any character in string `s` and change it to any other lowercase English letter. The operation costs 1 unit per change of a character. Return the minimum cost to transform string `s` into string `t`.","solution":"def min_cost_transform(s, t): Returns the minimum cost to transform string s into string t. The cost is 1 unit per character change. if len(s) != len(t): return -1 # Cost is determined by the number of differing characters. cost = 0 for sc, tc in zip(s, t): if sc != tc: cost += 1 return cost"},{"question":"You are given a matrix of lowercase characters where each cell contains a single letter. Write a function to determine the maximum number of distinct characters that can be collected by following a path that starts at any cell and moves to adjacent cells (up, down, left, or right) without revisiting any cell. Return the maximum number of distinct characters that can be collected from such a path.","solution":"def max_distinct_chars(matrix): Returns the maximum number of distinct characters that can be collected by following a path that starts at any cell and moves to adjacent cells (up, down, left, or right) without revisiting any cell in the given matrix. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_distinct = 0 def dfs(x, y, visited): nonlocal max_distinct if 0 <= x < rows and 0 <= y < cols and matrix[x][y] not in visited: visited.add(matrix[x][y]) max_distinct = max(max_distinct, len(visited)) dfs(x + 1, y, visited) dfs(x - 1, y, visited) dfs(x, y + 1, visited) dfs(x, y - 1, visited) visited.remove(matrix[x][y]) for i in range(rows): for j in range(cols): dfs(i, j, set()) return max_distinct"},{"question":"You are given a string `s` and an array of pairs of integers `queries` where each query `queries[i] = [l, r]` asks for the number of distinct characters in the substring `s[l:r+1]`. Return _an array of integers where the ith integer is the answer to the ith query_.","solution":"def distinct_characters_count(s, queries): Returns an array where each element is the number of distinct characters in the specified substring of s for each query in queries. :param s: A string :param queries: A list of pairs of integers denoting the start and end indices :return: A list of integers representing the number of distinct characters for each query result = [] for l, r in queries: substring = s[l:r+1] distinct_chars = set(substring) result.append(len(distinct_chars)) return result"},{"question":"You are given a list of flights represented as an array of `Flight` objects where each `Flight` has three attributes: `source`, `destination`, and `price`. You are also given three integers: `src`, `dst`, and `K`. Return _the **cheapest price** from `src` to `dst` with at most `K` stops_. If there is no such route, return `-1`. Note: - `Flight` is a class that is defined with three attributes: `source`, `destination`, and `price`. - The flight routes are bidirectional.","solution":"from typing import List import heapq class Flight: def __init__(self, source: int, destination: int, price: int): self.source = source self.destination = destination self.price = price def find_cheapest_price(flights: List[Flight], src: int, dst: int, K: int) -> int: graph = {} for flight in flights: if flight.source not in graph: graph[flight.source] = [] graph[flight.source].append((flight.destination, flight.price)) # Min-heap priority queue (cost, current_city, stops) pq = [(0, src, K + 1)] while pq: cost, node, stops = heapq.heappop(pq) if node == dst: return cost if stops > 0: if node in graph: for neighbor, price in graph[node]: heapq.heappush(pq, (cost + price, neighbor, stops - 1)) return -1"},{"question":"You are given a positive integer `num`. Write a function that returns a string representation of all the numbers from 1 to `num` in lexicographical order. For example, if `num = 13`, your function should return: [\\"1\\", \\"10\\", \\"11\\", \\"12\\", \\"13\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\", \\"6\\", \\"7\\", \\"8\\", \\"9\\"]. The solution must be efficient and handle large inputs up to `10^4`.","solution":"def lexical_order(num): Returns a list of numbers from 1 to num in lexicographical order. return [str(i) for i in range(1, num + 1)] def sort_lexicographically(nums): Sorts a list of numbers (in string format) lexicographically. return sorted(nums) def lexicographical_numbers(num): Combines generating and lexicographically sorting numbers for the given num. nums = lexical_order(num) return sort_lexicographically(nums)"},{"question":"You are given an array of integers `arr` and an integer `x`. You are allowed to pick integers from the array such that no two picked integers are adjacent in the original array. Return the maximum sum of the picked integers. For example, for the array [3, 2, 7, 10], the maximum sum is 13 (3 + 10) because picking `3` and `10` gives the highest possible sum without picking adjacent elements.","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of non-adjacent integers in the array. if not arr: return 0 elif len(arr) == 1: return arr[0] incl = arr[0] # Max sum including the previous element. excl = 0 # Max sum excluding the previous element. for i in arr[1:]: new_excl = max(incl, excl) # Current max excluding i incl = excl + i # Current max including i excl = new_excl # Update excl to new_excl return max(incl, excl)"},{"question":"You are given an integer array `heights` representing the height of buildings on a street, where `heights[i]` is the height of the building at position `i`, and `heights` is of length `n`. Define a **peak building** as a building that is both taller than the building to its left and taller than the building to its right. The buildings at the ends of the street cannot be peak buildings. Return the number of **peak buildings** in `heights`.","solution":"def count_peak_buildings(heights): Returns the number of peak buildings in the `heights` array. A peak building is one that is taller than the buildings to its left and right. n = len(heights) if n < 3: return 0 peak_count = 0 for i in range(1, n-1): if heights[i] > heights[i-1] and heights[i] > heights[i+1]: peak_count += 1 return peak_count"},{"question":"You are given a string `s` and an integer `k`. You can choose any substring of `s` and rearrange its characters in any order. You may perform this operation at most `k` times. Return _the lexicographically smallest string you can obtain after performing the operation at most_ `k` _times_.","solution":"def smallest_lexicographical_string(s, k): Returns the lexicographically smallest string after rearranging any substring of s at most k times. if k == 1: # Generate all cyclic rotations of the string min_s = s for i in range(1, len(s)): rotated = s[i:] + s[:i] if rotated < min_s: min_s = rotated return min_s else: # If k is more than 1, we can fully sort the string return \\"\\".join(sorted(s))"},{"question":"You are provided a **0-indexed** matrix `mat` of size `m x n` consisting of **positive** integers. You need to apply `k` operations to this matrix, where in the `ith` operation, you increment all the elements in the row `operations[i][0]` by `operations[i][1]`. Return _the matrix obtained after applying all the operations_.","solution":"def increment_rows(mat, operations): Applies operations to increment rows in the matrix. Args: mat: List[List[int]] - a 2D list of integers representing the matrix. operations: List[List[int]] - a list of operations where each operation is represented as a list [row_index, increment_value]. Returns: List[List[int]] - the modified matrix after applying the operations. for operation in operations: row_index, increment_value = operation mat[row_index] = [x + increment_value for x in mat[row_index]] return mat"},{"question":"You are given an array of integers `arr` and an integer `N`. Divide the array into exactly `N` contiguous subarrays such that the maximum sum of any subarray is minimized. Return the minimized maximum sum. Assume that `N` is between 1 and the length of `arr` inclusive.","solution":"def splitArray(arr, N): Divide the array into exactly N contiguous subarrays such that the maximum sum of any subarray is minimized. Parameters: arr (list): Array of integers. N (int): Number of subarrays. Returns: int: The minimized maximum sum of any subarray. def canSplit(maxSubarraySum): subarrayCount = 1 currentSum = 0 for num in arr: if currentSum + num > maxSubarraySum: subarrayCount += 1 currentSum = num if subarrayCount > N: return False else: currentSum += num return True left = max(arr) right = sum(arr) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"Given a linked list, remove the `n`th node from the end of the list and return its head. You must solve this problem in linear time and with constant space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Removes the n-th node from the end of the list and returns the head of the list. dummy = ListNode(0) dummy.next = head first = second = dummy # Advance first pointer by n+1 steps to maintain the gap of n between first and second for _ in range(n + 1): first = first.next # Move first to the end, maintaining the gap while first: first = first.next second = second.next # second will be pointing to the node before the target node second.next = second.next.next return dummy.next"},{"question":"You are given a list of non-negative integers `arr` representing the height of bars in a histogram. Each bar has a width of 1. Return the area of the largest rectangle in the histogram that can be formed by one or more consecutive bars.","solution":"def largest_rectangle_area(hist): Calculates the area of the largest rectangle that can be formed in a histogram. Parameters: hist (list): List of non-negative integers representing the height of histogram bars. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(hist): if not stack or hist[index] >= hist[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (hist[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (hist[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an integer array `heights` representing the heights of a group of students. A student is eligible for an award if they impressively stand out, which is determined by the fact that a student should be taller than both their immediate neighbors. Return _the number of students eligible for an award_.","solution":"def count_award_eligible_students(heights): Returns the number of students eligible for an award. A student is eligible if they are taller than both their immediate neighbors. :param heights: List[int] - list of student heights :return: int - number of students eligible for an award if len(heights) < 3: return 0 eligible_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: eligible_count += 1 return eligible_count"},{"question":"Given a **0-indexed** integer array `nums`, return _the maximum absolute value of the difference between two elements_ such that the larger element appears after the smaller element in the array. In other words, return the maximum value of `|nums[j] - nums[i]|` where `0 <= i < j < nums.length`.","solution":"def max_abs_difference(nums): Returns the maximum absolute value of the difference between two elements such that the larger element appears after the smaller element in the array. if not nums or len(nums) < 2: return 0 min_element = nums[0] max_diff = 0 for j in range(1, len(nums)): max_diff = max(max_diff, abs(nums[j] - min_element)) min_element = min(min_element, nums[j]) return max_diff"},{"question":"Given an integer array `nums`, return the number of **reverse pairs**. A **reverse pair** is defined as a pair of indices `(i, j)` where `i < j` and `nums[i] > 2 * nums[j]`.","solution":"def reverse_pairs(nums): Given an integer array nums, return the number of reverse pairs. A reverse pair is defined as a pair of indices (i, j) where i < j and nums[i] > 2 * nums[j]. def merge_sort_and_count(arr, left, right): if left >= right: return 0 mid = (left + right) // 2 count = merge_sort_and_count(arr, left, mid) + merge_sort_and_count(arr, mid + 1, right) j = mid + 1 for i in range(left, mid + 1): while j <= right and arr[i] > 2 * arr[j]: j += 1 count += j - (mid + 1) # Merge the sorted halves arr[left:right + 1] = sorted(arr[left:right + 1]) return count return merge_sort_and_count(nums, 0, len(nums) - 1)"},{"question":"You are given two strings `word1` and `word2`. Your task is to merge the two strings into a single string such that the characters from `word1` and `word2` are interleaved starting with `word1`. If one string runs out of characters before the other, append the remaining characters of the non-empty string to the merged string. Return the merged string.","solution":"def merge_strings(word1, word2): Merges two strings by interleaving their characters starting with word1. If one string runs out of characters before the other, appends the remaining characters. merged = [] len1, len2 = len(word1), len(word2) i = 0 # Traverse through both strings until the end of the shorter one while i < len1 and i < len2: merged.append(word1[i]) merged.append(word2[i]) i += 1 # Append remaining characters of the longer string if i < len1: merged.append(word1[i:]) elif i < len2: merged.append(word2[i:]) return \'\'.join(merged)"},{"question":"You are given a string `s` representing an expression containing digits and the characters `\'+\'`, `\'-\'`, `\'*\'`, and `\'/\'`. Your task is to evaluate this expression following the standard operator precedence rules (multiplication and division have higher precedence than addition and subtraction). For simplicity, assume the expression is always valid and doesn\'t contain any parentheses. Implement a function that returns the result of the calculation as an integer.","solution":"def evaluate_expression(s): Evaluates a mathematical expression containing +, -, *, / following the standard operator precedence. Returns the result as an integer. def compute(operators, numbers): right = numbers.pop() left = numbers.pop() op = operators.pop() if op == \'+\': numbers.append(left + right) elif op == \'-\': numbers.append(left - right) elif op == \'*\': numbers.append(left * right) elif op == \'/\': numbers.append(int(left / right)) # truncate towards zero operators, numbers = [], [] i = 0 while i < len(s): if s[i] == \' \': i += 1 continue if s[i] in \'0123456789\': num = 0 while i < len(s) and s[i] in \'0123456789\': num = num * 10 + int(s[i]) i += 1 numbers.append(num) continue if s[i] in \\"+-*/\\": while (operators and operators[-1] in \\"*/\\" and s[i] in \\"+-\\") or (operators and operators[-1] in \\"*/\\" and s[i] in \\"*/\\"): compute(operators, numbers) operators.append(s[i]) i += 1 while operators: compute(operators, numbers) return numbers[0]"},{"question":"You are given a list of unique player scores in a game, represented as an integer array `scores`, where `scores[i]` is the score of the `i-th` player. Each player can challenge another player to a one-on-one match. If player `i` challenges player `j` and wins, player `i` earns an additional score equal to `scores[j]`. Write a class `PlayerRankings` that manages the players and their scores. Implement the `PlayerRankings` class: * `PlayerRankings(int[] scores)` Initializes the rankings with the given list of scores. * `void challenge(int i, int j)` Updates the scores after player `i` challenges player `j` and wins. * `int[] getRankings()` Returns an array of player indices in descending order of their scores. If two players have the same score, they should be ranked in ascending order of their indices.","solution":"class PlayerRankings: def __init__(self, scores): Initializes the rankings with the given list of scores. self.scores = scores def challenge(self, i, j): Updates the scores after player `i` challenges player `j` and wins. self.scores[i] += self.scores[j] def getRankings(self): Returns an array of player indices in descending order of their scores. If two players have the same score, they should be ranked in ascending order of their indices. return sorted(range(len(self.scores)), key=lambda x: (-self.scores[x], x))"},{"question":"Write a function that takes an integer array `nums` as input and returns the starting and ending position of the subarray that contains the maximum sum. If there are multiple such subarrays, return the one with the smallest starting index. If the array is empty, return `[-1, -1]`.","solution":"def max_subarray_indices(nums): Returns the start and end indices of the subarray with the maximum sum. If there are multiple such subarrays, returns the one with the smallest starting index. If the array is empty, returns [-1, -1]. if not nums: return [-1, -1] max_sum = float(\'-inf\') current_sum = 0 start = 0 result_start = 0 result_end = 0 for i in range(len(nums)): if current_sum <= 0: current_sum = nums[i] start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum result_start = start result_end = i return [result_start, result_end]"},{"question":"Given a 2D integer matrix `grid` of size `m x n` representing a maze, return `true` if there is a path from the top-left corner to the bottom-right corner, otherwise return `false`. You can only move up, down, left, or right and can only traverse cells that contain the value `1` (representing a walkable path). Cells with `0` are considered obstacles and cannot be traversed.","solution":"def is_path_exists(grid): Returns true if there is a path from the top-left corner to the bottom-right corner of the grid. We can only move up, down, left, or right and only through cells that contain the value 1. m, n = len(grid), len(grid[0]) if grid[0][0] == 0 or grid[m-1][n-1] == 0: return False # Directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False]*n for _ in range(m)] def dfs(x, y): if x == m - 1 and y == n - 1: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 1: if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"You are given a list of non-negative integers, `nums`, arranged in ascending order. Your task is to find the index of a given `target` value in the list. If the target is not found, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. Implement the function `int searchInsert(int[] nums, int target)`. The function takes an array of integers and a target integer as inputs and returns the index as an integer.","solution":"def searchInsert(nums, target): Returns the index of the target if found in the list, otherwise returns the index where the target should be inserted in order. Args: nums (list of int): The list of non-negative integers in ascending order. target (int): The target value to find or insert. Returns: int: The index of the target or the insertion position. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"Given a string `s`, find the length of the **longest substring** without repeating characters. **Examples:** 1. Input: `s = \\"abcabcbb\\"` Output: `3` Explanation: The answer is `\\"abc\\"`, with the length of 3. 2. Input: `s = \\"bbbbb\\"` Output: `1` Explanation: The answer is `\\"b\\"`, with the length of 1. 3. Input: `s = \\"pwwkew\\"` Output: `3` Explanation: The answer is `\\"wke\\"`, with the length of 3. Note that the answer must be a substring, `\\"pwke\\"` is a subsequence and not a substring. **Hint:** - Use a sliding window approach with two pointers to keep track of the current substring and a set to store the characters in the current window. **Definition:** - `function lengthOfLongestSubstring(s: string): number`","solution":"def lengthOfLongestSubstring(s): Finds the length of the longest substring without repeating characters. Args: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of integers `nums` and an integer `target`. Each element in `nums` should be used at most once to form a subarray whose sum is closest to `target` without exceeding it. Return _the sum of the subarray that is closest to `target` without exceeding it_. If there are multiple such subarrays, return the sum of any one of them.","solution":"def closest_subarray_sum(nums, target): Returns the sum of the subarray that is closest to target without exceeding it. from itertools import combinations closest_sum = float(\'-inf\') # Generate all possible subarrays for r in range(1, len(nums) + 1): for combo in combinations(nums, r): current_sum = sum(combo) if current_sum <= target and current_sum > closest_sum: closest_sum = current_sum return closest_sum"},{"question":"Given an array of integers `arr` and an integer `limit`, transform the array so that each element falls within the range `[-limit, limit]`. You can replace any element `x` in the array with `y`, where `-limit <= y <= limit`. Return _the minimal possible sum of the array\'s elements after performing the replacements_.","solution":"def minimal_sum_within_limit(arr, limit): Transforms the array so that each element falls within the range [-limit, limit]. Returns the minimal possible sum of the array\'s elements after performing the replacements. transformed_array = [max(min(x, limit), -limit) for x in arr] return sum(transformed_array)"},{"question":"You are given an array `arr` of integers, where `arr[i]` is either `-1`, `0`, or `1`. You need to find the maximum length of any subarray where the product of all its elements is `1`. A subarray is a contiguous part of the array. Return the length of the longest subarray with a product of `1`.","solution":"def max_length_subarray_product_one(arr): Returns the maximum length of any subarray where the product of all its elements is 1. max_len = 0 count_1 = 0 count_neg_ones = 0 first_neg_one_index = -1 last_neg_one_index = -1 for i, num in enumerate(arr): if num == 0: count_1 = 0 count_neg_ones = 0 first_neg_one_index = -1 last_neg_one_index = -1 else: if num == 1: count_1 += 1 elif num == -1: count_neg_ones += 1 if first_neg_one_index == -1: first_neg_one_index = i last_neg_one_index = i if count_neg_ones % 2 == 0: current_len = count_1 + count_neg_ones max_len = max(max_len, current_len) else: if first_neg_one_index != -1: current_len = i - first_neg_one_index max_len = max(max_len, current_len) return max_len"},{"question":"Given a `board` representing a grid of cells where each cell contains a letter, and a `word` that you need to form by moving through adjacent cells (horizontally or vertically), write a function that determines if the `word` exists in the `board`. Each letter must be used exactly once, and the same letter cell cannot be reused. Return `true` if the word can be formed and `false` otherwise.","solution":"def exist(board, word): Checks if the word exists in the given board. :param board: List[List[str]] - a two-dimensional list representing the board :param word: str - the word to search for :return: bool - True if the word exists, False otherwise if not board: return False num_rows = len(board) num_cols = len(board[0]) def dfs(r, c, idx): if idx == len(word): return True if r < 0 or r >= num_rows or c < 0 or c >= num_cols or board[r][c] != word[idx]: return False # Temporarily mark the cell as visited temp, board[r][c] = board[r][c], \'\' found = (dfs(r+1, c, idx+1) or dfs(r-1, c, idx+1) or dfs(r, c+1, idx+1) or dfs(r, c-1, idx+1)) board[r][c] = temp return found for i in range(num_rows): for j in range(num_cols): if dfs(i, j, 0): return True return False"},{"question":"You are given a string `s` and an integer `x`. Imagine you need to create a new string by removing characters from `s` such that no two adjacent characters in the new string are the same and the total number of removed characters is a multiple of `x`. Return `true` if such a string can be created, otherwise return `false`.","solution":"def can_create_string(s, x): Returns True if it\'s possible to remove characters from s such that no two adjacent characters in the new string are the same and the total number of removed characters is a multiple of x. Otherwise, returns False. if not s or x <= 0: return False removed_count = 0 i = 1 # Iterate the string and count characters to be removed while i < len(s): if s[i] == s[i - 1]: removed_count += 1 i += 1 # Check if number of characters removed is a multiple of x return removed_count % x == 0"},{"question":"Implement a function `maxDepth` that calculates the maximum depth of a binary tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. The binary tree is represented by a class `TreeNode` that has attributes `val`, `left`, and `right`. Example: ``` Input: root = [3, 9, 20, null, null, 15, 7] Output: 3 ``` In this example, the binary tree has a maximum depth of 3 as there are 3 nodes from the root to the farthest leaf node path (3 -> 20 -> 15). The input `root` represents the binary tree using level order traversal where \'null\' signifies absence of a node at that position.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Returns the maximum depth of the binary tree rooted at \'root\'. if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"Given an array `arr` of positive integers, return an array `result` such that `result[i]` is the product of all elements in `arr` except `arr[i]`, without using division. For example, if `arr` is `[1, 2, 3, 4]`, return `[24, 12, 8, 6]`. Note: Ensure your solution has a linear time complexity and uses constant space complexity (excluding the output array).","solution":"def product_except_self(arr): Returns an array `result` where result[i] is the product of all elements in `arr` except arr[i]. length = len(arr) if length == 0: return [] result = [1] * length # Calculate left products, each result[i] contains the product of all elements to the left of arr[i] left_product = 1 for i in range(length): result[i] = left_product left_product *= arr[i] # Calculate right products and update the result array right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of `n` students standing in a line. You can perform the following operation as many times as you want: Swap the positions of any two students if the absolute difference in their heights is less than or equal to a given integer `k`. Return _true if it is possible to arrange the students in non-decreasing order of their heights using the above operation and false otherwise._","solution":"def canArrangeHeights(heights, k): Returns true if it is possible to arrange heights in non-decreasing order with swap operations where the absolute difference between heights is less than or equal to k. n = len(heights) sorted_heights = sorted(heights) for i in range(n): if abs(heights[i] - sorted_heights[i]) > k: return False return True"},{"question":"Given a matrix `grid` of size `m x n` where each cell contains a non-negative integer representing the cost of stepping into that cell, find a path from the top-left corner of the grid to the bottom-right corner which minimizes the total cost. You can only move either down or right at any point in time. Implement the function: * `int minPathSum(int[][] grid)` which takes an `m x n` grid of integers and returns the minimum cost to reach the bottom-right corner from the top-left corner.","solution":"def minPathSum(grid): Find the minimum path sum from the top-left corner to the bottom-right corner of a grid. Args: grid (List[List[int]]): 2D list containing non-negative integers Returns: int: minimum path sum if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the dp table with the same size as the grid dp = [[0] * n for _ in range(m)] # Fill the dp table for i in range(m): for j in range(n): if i == 0 and j == 0: dp[i][j] = grid[i][j] elif i == 0: dp[i][j] = dp[i][j-1] + grid[i][j] elif j == 0: dp[i][j] = dp[i-1][j] + grid[i][j] else: dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given two lists `list1` and `list2`, each containing `n` integers. A pair (i, j) is said to be a \\"good pair\\" if `list1[i]` equals `list2[j]` and `i` is less than `j`. Return the number of \\"good pairs\\" in these two lists. If there are no \\"good pairs\\", return `0`.","solution":"def count_good_pairs(list1, list2): Returns the number of \\"good pairs\\" (i, j) such that list1[i] == list2[j] and i < j. good_pairs = 0 for i in range(len(list1)): for j in range(i + 1, len(list2)): if list1[i] == list2[j]: good_pairs += 1 return good_pairs"},{"question":"A company has a list of tasks that need to be executed in a certain order due to dependencies between the tasks. The dependencies are represented as a directed graph, where each node represents a task, and an edge from node `u` to node `v` means that task `u` must be completed before task `v` can start. Given the total number of tasks `numTasks` and a list of dependency pairs `dependencies`, determine if it is possible to complete all tasks. If it is possible, return _a valid order of tasks_ so that all tasks can be completed. If it is not possible, return _an empty list_. Given: - `int numTasks`: the total number of tasks (numbered from `0` to `numTasks - 1`). - `int[][] dependencies`: a list of dependency pairs where `dependencies[i] = [ai, bi]` denotes an edge from `ai` to `bi`. Implement the function: - `List<Integer> findOrder(int numTasks, int[][] dependencies)` that returns the order of tasks or an empty list if it is not possible to complete all tasks.","solution":"from typing import List def findOrder(numTasks: int, dependencies: List[List[int]]) -> List[int]: from collections import defaultdict, deque # Create an adjacency list for the graph graph = defaultdict(list) indegree = [0] * numTasks # In-degree array to keep track of in-degrees # Build the graph and the in-degree array for dest, src in dependencies: graph[src].append(dest) indegree[dest] += 1 # Queue for nodes with 0 in-degree zero_indegree_queue = deque([i for i, degree in enumerate(indegree) if degree == 0]) task_order = [] while zero_indegree_queue: node = zero_indegree_queue.popleft() task_order.append(node) # Reduce the in-degree of neighbour nodes by 1 for neighbour in graph[node]: indegree[neighbour] -= 1 if indegree[neighbour] == 0: zero_indegree_queue.append(neighbour) # If all tasks are in task_order, it means we could finish all tasks if len(task_order) == numTasks: return task_order # Otherwise, return an empty list indicating that it\'s not possible to finish all tasks return []"},{"question":"A company wants to distribute candies to children standing in a line, where each child has a rating score. You are given an integer array `ratings` representing the rating scores of the children. You need to distribute candies according to the following requirements: 1. Each child must have at least one candy. 2. Children with a higher rating get more candies than their neighbors. Return _the minimum number of candies you need to have to distribute to the children_ according to the above rules.","solution":"def candy(ratings): Returns the minimum number of candies needed to distribute to the children according to the given ratings and rules. n = len(ratings) if n == 0: return 0 candies = [1] * n # First pass: ensure right higher rated kids get more candy than left neighbor for i in range(1, n): if ratings[i] > ratings[i - 1]: candies[i] = candies[i - 1] + 1 # Second pass: ensure left higher rated kids get more candy than right neighbor for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) return sum(candies)"},{"question":"A group of students is preparing for a coding competition and wants to select a leader. The leader should be chosen based on their performance in various subjects. Each student receives a score for several subjects, and the goal is to select a leader such that the selected student\'s lowest score across all subjects is as high as possible. Given an array `scores` where `scores[i][j]` represents the score of the `ith` student in the `jth` subject, return _the index of the student_ who has the highest minimum score across all subjects. If multiple students have the same highest minimum score, return the smallest index among them.","solution":"def select_leader(scores): Selects the leader based on the highest minimum score across subjects. Parameters: scores (list of list of int): The scores of students in various subjects. Returns: int: The index of the student who has the highest minimum score across all subjects. if not scores or not all(scores): return -1 # If the input is empty, return -1 as an invalid input indicator. max_min_score = None leader_index = None for i, student_scores in enumerate(scores): min_score = min(student_scores) if max_min_score is None or min_score > max_min_score: max_min_score = min_score leader_index = i return leader_index"},{"question":"Given an array of integers `nums` and an integer `k`, modify the array in such a way that each element at index `i` is equal to the product of the next `k` elements. If there are fewer than `k` elements remaining from index `i`, use all the remaining elements. Return the modified array.","solution":"def product_of_next_k_elements(nums, k): Modifies the array such that each element at index i is equal to the product of the next k elements. If there are fewer than k elements remaining from index i, use all the remaining elements. n = len(nums) result = [] for i in range(n): product = 1 for j in range(1, k+1): if i + j < n: product *= nums[i + j] else: break result.append(product) return result"},{"question":"You are given a string `recipe` which represents a sequence of ingredients in a recipe, where each character in `recipe` is a single ingredient identified by a unique letter. You also have a string `available` which denotes the ingredients you currently have where each character is an available ingredient. Write a function `minSteps(recipe, available)` that returns the **minimum number of ingredient additions** needed to be able to prepare the recipe. In other words, determine the smallest number of characters you would need to add to `available` to be able to create a string that contains all characters in `recipe`. For example, if `recipe = \\"abac\\"` and `available = \\"abc\\"`, you would need to add one more `a` to `available` to be able to prepare the recipe, so the function should return 1.","solution":"def minSteps(recipe, available): from collections import Counter recipe_count = Counter(recipe) available_count = Counter(available) steps = 0 for ingredient, count in recipe_count.items(): if available_count[ingredient] < count: steps += count - available_count[ingredient] return steps"},{"question":"You are given a string `s` containing only lowercase alphabetic characters. Determine the most frequent character in `s`. If there is a tie for the most frequent character, return the alphabetically first character among the highest frequency characters. Write a function that returns this character.","solution":"def most_frequent_character(s): Determine the most frequent character in the string `s`. In case of a tie, return the alphabetically first character. if not s: return \'\' char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 max_frequency = max(char_count.values()) most_frequent_chars = [char for char, count in char_count.items() if count == max_frequency] return min(most_frequent_chars)"},{"question":"You are given an array of non-negative integers `nums` and an integer `k`. You are allowed to choose any `i`-th element of the array and add `k` to it exactly once. Your task is to maximize the minimum value of the array after performing at most one such operation. Write a function that takes `nums` and `k` as input and returns the maximum possible minimum value of the array.","solution":"def maximize_minimum(nums, k): Returns the maximum possible minimum value of the array after adding k to one element. min_value = min(nums) return min_value + k"},{"question":"A **valid mountain array** is defined as an array where the elements strictly increase until they reach a certain peak element and then strictly decrease. The array must have at least 3 elements, and the peak cannot be the first or last element. Given an integer array `arr`, return `true` if it is a valid mountain array, or `false` otherwise.","solution":"def is_valid_mountain_array(arr): Determines if the array is a valid mountain array. A valid mountain array is an array where elements strictly increase until they reach a peak element and then strictly decrease. The peak cannot be the first or the last element of the array. Additionally, the array must have at least three elements. :param arr: List[int] - Input array :return: bool - True if the array is a valid mountain array, False otherwise n = len(arr) if n < 3: return False i = 1 # Walk up while i < n and arr[i] > arr[i - 1]: i += 1 # Peak can\'t be first or last if i == 1 or i == n: return False # Walk down while i < n and arr[i] < arr[i - 1]: i += 1 return i == n"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `m`. Your task is to split the array into exactly `m` non-empty, consecutive subarrays. The cost of a split is defined as the maximum sum of any subarray formed. Return _the minimum cost of splitting the array into_ `m` _subarrays._","solution":"def split_array(nums, m): Minimizes the maximum sum of any subarray when the given array is split into m subarrays. def can_split(largest_sum): current_sum = 0 count = 1 for num in nums: if current_sum + num > largest_sum: current_sum = num count += 1 if count > m: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of integers `tasks` where `tasks[i]` represents the time it takes to complete the `i-th` task. You need to assign the tasks to two workers such that the maximum amount of time taken by either worker to complete their assigned tasks is minimized. Return _the minimum possible time in which both workers can complete all tasks_ when both workers work simultaneously and without any interruption. Each task must be assigned to exactly one worker.","solution":"from typing import List def minimum_time_for_workers(tasks: List[int]) -> int: def can_split(tasks, limit): current_time = 0 workers_needed = 1 for task in tasks: if current_time + task <= limit: current_time += task else: workers_needed += 1 current_time = task if workers_needed > 2: return False return True left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_split(tasks, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and an integer `k`. Find the `k` pairs `(u, v)` which have the smallest sums, where `u` is an element from `nums1` and `v` is an element from `nums2`. Return the answer in any order. Example: ```python nums1 = [1, 7, 11] nums2 = [2, 4, 6] k = 3 ``` Expected output: ```python [(1, 2), (1, 4), (1, 6)] ```","solution":"import heapq from typing import List, Tuple def k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[Tuple[int, int]]: Find the k pairs (u, v) from nums1 and nums2 with the smallest sums. if not nums1 or not nums2: return [] min_heap = [] for i in range(min(len(nums1), k)): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) result = [] while k > 0 and min_heap: _, i, j = heapq.heappop(min_heap) result.append((nums1[i], nums2[j])) if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1)) k -= 1 return result"},{"question":"You are given an integer array `arr` representing an elevation map where the width of each bar is 1. The array has `n` non-negative integers where each integer represents the height of a bar. Find the largest rectangular area that can be formed within the bounds made by the bars. Return the area of the largest rectangle. Note that the rectangle must be contained within the height of the bars.","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle that can be formed within the bounds made by the bars. :param heights: List of non-negative integers representing the heights of bars. :return: Integer representing the area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() current_area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, current_area) while stack: top_of_stack = stack.pop() current_area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, current_area) return max_area"},{"question":"You are given a list of `n` integers where each integer represents the profit you can earn from a job in a day. However, due to the nature of the jobs, you cannot complete two jobs on consecutive days. Write a function that returns the maximum profit you can earn over some days, ensuring that you never take up jobs on two consecutive days.","solution":"def max_profit(profits): Returns the maximum profit that can be earned by not taking jobs on two consecutive days. Args: profits (List[int]): List of integers where each integer represents the profit of completing a job on that day. Returns: int: Maximum profit that can be earned. n = len(profits) if n == 0: return 0 if n == 1: return profits[0] max_prof = [0] * n max_prof[0] = profits[0] max_prof[1] = max(profits[0], profits[1]) for i in range(2, n): max_prof[i] = max(max_prof[i-1], max_prof[i-2] + profits[i]) return max_prof[-1]"},{"question":"You are given an array `arr` of integers. Your task is to find a pair of indices `(i, j)` such that `i < j` and the absolute difference between `arr[i]` and `arr[j]` is the maximum possible among all such pairs in the array. Return _the maximum absolute difference_. Note: - The absolute difference between two integers `a` and `b` is given by `|a - b|`, where `|x|` denotes the absolute value of `x`.","solution":"def max_absolute_difference(arr): Returns the maximum absolute difference between any pair (i, j) such that i < j. n = len(arr) if n < 2: return 0 # Not enough elements to form a pair # find max element and min element considering the constraint i < j max_diff = 0 for i in range(n - 1): for j in range(i + 1, n): max_diff = max(max_diff, abs(arr[i] - arr[j])) return max_diff"},{"question":"Given an array of integers `arr` and an integer `k`, find out if it is possible to split the array into `k` non-empty subarrays such that each subarray has the same sum. Return `true` if it is possible, otherwise return `false`.","solution":"def can_split_into_k_subarrays(arr, k): Determines if the array can be split into k non-empty subarrays with the same sum. Parameters: arr (list of int): The array of integers. k (int): The number of subarrays. Returns: bool: True if it is possible to split the array as described, else False. total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k current_sum, subarray_count = 0, 0 for num in arr: current_sum += num if current_sum == target_sum: subarray_count += 1 current_sum = 0 elif current_sum > target_sum: return False return subarray_count == k"},{"question":"You are given an array of integers `nums` and an integer `target`. Your goal is to determine if there are exactly two numbers in the array that add up to the `target`. You should return the indices of these two numbers as a list, `[index1, index2]`. If no such pair exists, return an empty list. Note that the indices returned should be in ascending order.","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. :param nums: List of integers :param target: Integer target sum :return: List containing the indices of the two numbers that add up to the target, or an empty list if no such pair exists num_to_index = {} # A dictionary to store number and its index for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], index]) num_to_index[num] = index return []"},{"question":"You are given a string `s` and an integer `k`. A substring is called a **k-palin** if it is k-palindromic, meaning the substring can be rearranged to form a palindrome. Return _the **number** of k-palin substrings in the string `s`._ A substring is a **contiguous** part of a string. For instance, in the string \\"aabb\\", the substring \\"aabb\\" is 2-palin as it can be rearranged to form \\"abba\\".","solution":"from collections import Counter def is_k_palin(substring, k): Helper function to check if the substring can be rearranged to form a k-palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count. For k-palindrome, it\'s allowed to have up to k characters with odd counts. count = Counter(substring) odd_counts = sum(1 for cnt in count.values() if cnt % 2 != 0) return odd_counts // 2 <= k def count_k_palin_substrings(s, k): Returns the number of k-palin substrings in the given string s. n = len(s) k_palin_count = 0 # Iterate through all possible substrings for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] if is_k_palin(substring, k): k_palin_count += 1 return k_palin_count"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. The array `nums` represents a circular queue where the `i-th` element is followed by the `(i+1)-th` element, and the `(n-1)-th` element is followed by the `0-th` element. Your task is to rotate the array to the right by `k` steps, where `k` is non-negative. After rotating, return _the resulting array_. For example, if the input consists of `nums = [1, 2, 3, 4, 5, 6, 7]` and `k = 3`, the output should be `[5, 6, 7, 1, 2, 3, 4]`.","solution":"def rotate_array(nums, k): Rotates the array nums to the right by k steps. :param nums: List[int], the array to be rotated :param k: int, the number of steps to rotate the array :return: List[int], the rotated array n = len(nums) k = k % n # In case k is greater than the length of nums return nums[-k:] + nums[:-k]"},{"question":"Given a list of `n` integers, find the maximum product that can be obtained by multiplying any three distinct numbers in the list. Return the maximum product possible. Ensure your solution has a time complexity of O(n log n) or better. You may assume that the list contains at least three numbers.","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three distinct numbers in the list. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"Given a list of `n` integers, return the number of contiguous subarrays that have a sum equal to a given target value `k`. The list of integers may contain both positive and negative numbers.","solution":"def subarray_sum(nums, k): Returns the number of contiguous subarrays that sum to a given target value k. :param nums: List of integers :param k: Target sum value :return: Number of contiguous subarrays that sum to k count = 0 current_sum = 0 prefix_sum_count = {0: 1} for num in nums: current_sum += num diff = current_sum - k count += prefix_sum_count.get(diff, 0) prefix_sum_count[current_sum] = prefix_sum_count.get(current_sum, 0) + 1 return count"},{"question":"You are given a `n x n` `matrix`. The matrix is filled with values from `1` to `n^2` in a spiral order starting from the top-left corner and moving towards the center. Your task is to write a function that takes this matrix and returns the values of the matrix’s elements in a clockwise spiral order starting from the `top-left` corner. For example, given the following `3 x 3` matrix: ``` 1 2 3 8 9 4 7 6 5 ``` Your function should return the list: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`. Return _a list of integers representing the spiral order traversal of elements_.","solution":"def spiralOrder(matrix): Returns the elements of the matrix in a clockwise spiral order. if not matrix: return [] m, n = len(matrix), len(matrix[0]) result = [] top, bottom, left, right = 0, m - 1, 0, n - 1 while top <= bottom and left <= right: for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"You are given a list of strings `paragraph` where each string represents a sentence. Implement a function that concatenates all sentences into a single paragraph, ensuring that there is exactly one space between each sentence, and that the entire paragraph ends with a period `\'.\'`. Return the concatenated paragraph as a single string.","solution":"def concatenate_sentences(paragraph): Concatenates a list of sentences into a single paragraph with exactly one space between each sentence and ending with a period. Parameters: paragraph (list of str): List of sentences to concatenate. Returns: str: The concatenated paragraph as a single string. # Strip leading and trailing whitespace from each sentence cleaned_sentences = [sentence.strip() for sentence in paragraph] # Concatenate all sentences with a space between each concatenated_paragraph = \' \'.join(cleaned_sentences) # Ensure the paragraph ends with a period if not concatenated_paragraph.endswith(\'.\'): concatenated_paragraph += \'.\' return concatenated_paragraph"},{"question":"You are given a linked list where each node contains an integer value. The linked list has two special properties: 1. It can contain cycles, with a known cycle starting node provided as input. 2. It may also contain multiple random pointers where each node can randomly point to any other node or `null`. You need to clone this linked list. The resultant cloned linked list should have the same structure and values, including the same cycles and random pointers. Return the head of the cloned linked list.","solution":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def clone_linked_list(head): if not head: return None # Create a dictionary to hold original nodes and their clones old_to_new = {} # First, create all the nodes current = head while current: clone = Node(current.val) old_to_new[current] = clone current = current.next # Now, set the next and random references current = head while current: if current.next: old_to_new[current].next = old_to_new[current.next] if current.random: old_to_new[current].random = old_to_new[current.random] current = current.next # Return the cloned head return old_to_new[head]"},{"question":"Given two integer arrays `arr1` and `arr2`, return the _length of the longest common subsequence_ (LCS) of `arr1` and `arr2`. A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Write an algorithm that has `O(n*m)` time complexity, where `n` and `m` are the lengths of `arr1` and `arr2` respectively.","solution":"def longest_common_subsequence(arr1, arr2): Returns the length of the longest common subsequence of arr1 and arr2. n = len(arr1) m = len(arr2) # Create a (n+1)x(m+1) DP table with all zeroes dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The value at dp[n][m] will be the length of the LCS return dp[n][m]"},{"question":"You are given a string `s` containing only digits. Find the largest number that can be formed from these digits and return it as a string. Note that you should not reorder the digits but can insert as many commas as you like to form the largest possible number.","solution":"def largest_number_with_commas(s): Returns the largest possible number string that can be formed by inserting commas into the digits string s. The digits order should not be changed. # Since we need to return the largest number and we can\'t change the order of digits, # the best we can do is to not insert any commas and return the original string return s"},{"question":"You are given a list of strings `transactionLog` where each string represents a transaction in the format `[\\"user_id:amount\\"]`. Each `user_id` is a unique identifier for a user in the system and `amount` represents the transaction amount they processed. Your task is to identify users who have processed transactions totaling more than `10,000`. Return a dictionary with the `user_id` as the key and their total transaction amount as the value for users who have exceeded the `10,000` threshold. You can assume that `amount` is always a positive integer and all transactions are in USD. Sort the dictionary by user_ids in ascending order.","solution":"def identify_high_spenders(transactionLog): Identifies users who have processed transactions totaling more than 10,000. Parameters: transactionLog (list of str): List of transactions where each transaction is in the format \\"user_id:amount\\". Returns: dict: Dictionary with user_id as key and their total transaction amount as the value for users who have exceeded the 10,000 threshold. user_totals = {} for transaction in transactionLog: user_id, amount = transaction.split(\':\') amount = int(amount) if user_id in user_totals: user_totals[user_id] += amount else: user_totals[user_id] = amount high_spenders = {user_id: total for user_id, total in user_totals.items() if total > 10000} return dict(sorted(high_spenders.items()))"},{"question":"Given a matrix of integers `grid` representing a 2D grid of integers, determine if there is a path from the top-left corner to the bottom-right corner (both inclusive) that only moves up, down, left, or right, and only travels through non-negative cells (cells with value >= 0). Return `true` if such a path exists, or `false` otherwise.","solution":"def is_path_possible(grid): rows = len(grid) cols = len(grid[0]) if grid[0][0] < 0 or grid[rows-1][cols-1] < 0: return False def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] >= 0 def dfs(x, y, visited): if (x, y) == (rows-1, cols-1): return True visited.add((x, y)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: if dfs(nx, ny, visited): return True visited.discard((x, y)) return False return dfs(0, 0, set())"},{"question":"You are given an array `arr` of size `n` which initially contains integers from `0` to `n-1` in some order. Your task is to transform this array into a sorted array of the same size using a series of operations. In one operation, you can choose two adjacent elements in the array and swap them. Your goal is to determine the minimum number of swaps required to sort the array. Return _the **minimum number of swaps** needed to make the array sorted in ascending order_.","solution":"def minSwapsToSort(arr): Returns the minimum number of adjacent swaps required to sort the array. n = len(arr) # Pair the element with its initial index in the array arrpos = [(val, idx) for idx, val in enumerate(arr)] # Sort the array by the array values arrpos.sort() # To keep track of visited elements visited = {i: False for i in range(n)} swaps = 0 for i in range(n): # If the element is already in the correct place or already visited if visited[i] or arrpos[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arrpos[x][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"You are given an array of `n` integers representing the height of walls where each unit of wall has a width of 1. The objective is to find _the maximum amount of water that can be trapped between these walls after it rains_. The width between the walls in the array is defined as the distance between their indices. Return the maximum amount of water that can be trapped.","solution":"def max_water_trapped(heights): Returns the maximum amount of water that can be trapped between walls represented by heights. if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] max_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) max_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) max_water += max(0, right_max - heights[right]) return max_water"},{"question":"Given an array of integers `nums` and an integer `target`, return _the **index** of the first occurrence of an element that equals the `target`_ in `nums`. If such an element does not exist, return `-1`. Note: You are expected to solve this using a linear search algorithm.","solution":"def find_first_occurrence(nums, target): Returns the index of the first occurrence of target in nums. If the target is not found, returns -1. for index, num in enumerate(nums): if num == target: return index return -1"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to process the string so that every letter appears exactly once. You can only remove letters from the string. Your task is to return the lexicographically smallest string you can obtain using this method.","solution":"def remove_duplicates_lexicographical_smallest(s): Remove duplicates from the string to get the lexicographically smallest result. last_occurrence = {char: i for i, char in enumerate(s)} result = [] added = set() for i, char in enumerate(s): if char in added: continue while result and char < result[-1] and i < last_occurrence[result[-1]]: added.remove(result.pop()) result.append(char) added.add(char) return \'\'.join(result)"},{"question":"You are given an integer array `arr` consisting of `n` elements, and an integer `d`. Write a function that determines if there exists a subsequence of `arr` such that the absolute difference between any two consecutive elements of the subsequence is at most `d`. Return `true` if such a subsequence exists, and `false` otherwise. **Note**: A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def can_find_subsequence_with_diff(arr, d): if not arr: return False arr.sort() for i in range(len(arr) - 1): if abs(arr[i+1] - arr[i]) <= d: return True return False"},{"question":"Given a string `s` and an array of strings `dict`, return _the longest string in_ `dict` _that can be formed by deleting some of the characters of_ `s`. If there are multiple strings with the same length, return the lexicographically smallest one. If there is no possible result, return an empty string. Here is how the resulting string should be formed: - You can delete some (or none) of the characters from `s` without reordering the remaining characters. - You need to find the longest string from `dict` that is a subsequence of `s`.","solution":"def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) def find_longest_word(s, dict): dict.sort(key=lambda x: (-len(x), x)) for word in dict: if is_subsequence(word, s): return word return \\"\\""},{"question":"You are managing a **movie theater** reservation system where customers can book, cancel, and query seats for shows. The theater has a fixed number of rows and seats per row, both numbered starting from 1. Each show has its own seating arrangement. Implement the `MovieReservationSystem` class: * `MovieReservationSystem(int numRows, int numSeatsPerRow)` Initializes the theater with `numRows` rows and `numSeatsPerRow` seats per row for every show. * `void addShow(String showId)` Adds a new show to the system with the given `showId`, initializing its seating arrangement. * `boolean bookSeat(String showId, int row, int seat)` Books the seat at `row` and `seat` for the show with `showId`. Returns `true` if the booking is successful, or `false` if the seat is already booked or the show does not exist. * `boolean cancelSeat(String showId, int row, int seat)` Cancels the booking of the seat at `row` and `seat` for the show with `showId`. Returns `true` if the cancellation is successful, or `false` if the seat is not booked or the show does not exist. * `String checkAvailability(String showId, int row, int seat)` Checks the availability of the seat at `row` and `seat` for the show with `showId`. Returns `\\"Available\\"` if the seat is not booked, `\\"Booked\\"` if the seat is already booked, or `\\"Show not found\\"` if the show does not exist. * `int[] getTotalSeatCount(String showId)` Returns the total number of seats available and the total number of seats booked for the show with `showId` as a 2-element array `[availableSeats, bookedSeats]`. Returns `[-1, -1]` if the show does not exist. Ensure to handle edge cases such as invalid row or seat numbers, and cases where `showId` does not exist.","solution":"class MovieReservationSystem: def __init__(self, numRows, numSeatsPerRow): self.numRows = numRows self.numSeatsPerRow = numSeatsPerRow self.shows = {} def addShow(self, showId): self.shows[showId] = [[False] * self.numSeatsPerRow for _ in range(self.numRows)] def bookSeat(self, showId, row, seat): if showId not in self.shows: return False if row < 1 or row > self.numRows or seat < 1 or seat > self.numSeatsPerRow: return False if self.shows[showId][row-1][seat-1]: return False self.shows[showId][row-1][seat-1] = True return True def cancelSeat(self, showId, row, seat): if showId not in self.shows: return False if row < 1 or row > self.numRows or seat < 1 or seat > self.numSeatsPerRow: return False if not self.shows[showId][row-1][seat-1]: return False self.shows[showId][row-1][seat-1] = False return True def checkAvailability(self, showId, row, seat): if showId not in self.shows: return \\"Show not found\\" if row < 1 or row > self.numRows or seat < 1 or seat > self.numSeatsPerRow: return \\"Invalid seat\\" if self.shows[showId][row-1][seat-1]: return \\"Booked\\" else: return \\"Available\\" def getTotalSeatCount(self, showId): if showId not in self.shows: return [-1, -1] totalSeats = self.numRows * self.numSeatsPerRow bookedSeats = sum(map(sum, self.shows[showId])) availableSeats = totalSeats - bookedSeats return [availableSeats, bookedSeats]"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n-1` and `m` directed edges represented as pairs `(u, v)`, where `u` and `v` are nodes in the graph. Lines can have different weights, represented by a separate array `weights` of length `m`. A positive weight indicates a one-way connection from `u` to `v`, and a negative weight represents a one-way connection from `v` to `u`. Your task is to determine the shortest path from a given starting node `start` to a given target node `target`. If there is no path from `start` to `target`, return -1. The graph may contain cycles. Given the nodes `n`, edges `edges` as an array of pairs, weights `weights`, `start`, and `target`, return the length of the shortest path from `start` to `target`. Test your implementation with the following signature: `def shortest_path(n, edges, weights, start, target):`","solution":"import heapq def shortest_path(n, edges, weights, start, target): Returns the length of the shortest path from start to target. If there is no path, return -1. adj = [[] for _ in range(n)] for (u, v), w in zip(edges, weights): if w > 0: adj[u].append((v, w)) else: adj[v].append((u, -w)) distances = [float(\'inf\')] * n distances[start] = 0 min_heap = [(0, start)] while min_heap: cur_dist, u = heapq.heappop(min_heap) if u == target: return cur_dist if cur_dist > distances[u]: continue for v, weight in adj[u]: distance = cur_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return -1 if distances[target] == float(\'inf\') else distances[target]"},{"question":": You are given an integer array `arr` and an integer `d`. An element in the array is considered **valid** if there are no elements within distance `d` from it that are greater than or equal to itself. More formally, an element `arr[i]` is **valid** if for every `j` with `0 <= j < arr.length` and `|i - j| <= d`, `arr[j] < arr[i]`. Return _the list of all **valid** elements in the array_. Return the valid elements in the **same order** they appear in `arr`.","solution":"def find_valid_elements(arr, d): Find all elements in the `arr` that are considered valid. An element arr[i] is valid if for every j with 0 <= j < len(arr) and |i - j| <= d, arr[j] < arr[i]. Args: arr (list of int): The input array of integers. d (int): The distance criteria. Returns: list of int: List of valid elements in the same order they appear in arr. n = len(arr) valid_elements = [] for i in range(n): is_valid = True for j in range(max(0, i - d), min(n, i + d + 1)): if j != i and arr[j] >= arr[i]: is_valid = False break if is_valid: valid_elements.append(arr[i]) return valid_elements"},{"question":"Given an integer array `days` where `days[i]` represents the number of tasks on the ith day, you are also given an integer `n`. You are required to find the minimum number of days required to complete all the tasks if you can work at most `n` days consecutively and must take at least one rest day after every consecutive `n` working days. Return the minimum number of days required to finish all tasks.","solution":"def min_days_to_complete_tasks(days, n): Calculate the minimum number of days required to complete all tasks. Args: days (List[int]): Array representing the number of tasks on each day. n (int): Maximum number of consecutive working days allowed. Returns: int: Minimum number of days required to complete all tasks. total_days = 0 index = 0 while index < len(days): total_days += min(n, len(days) - index) # work for n days or until the end of the array index += n # move the index n days forward if index < len(days): total_days += 1 # add a mandatory rest day return total_days"},{"question":"Given an array of integers `arr` where `arr[i]` represents the height of the `i-th` building in a row, return _the total amount of rainwater that can be trapped after it rains_. Water is trapped between buildings based on their height, with the assumption that the width of each building (gap between `arr[i-1]` and `arr[i]`) is `1` unit. ___","solution":"def trapRainwater(heights): Given an array of integers heights where heights[i] represents the height of the i-th building in a row, return the total amount of rainwater that can be trapped after it rains. Parameters: heights (list of int): List of building heights. Returns: int: Total amount of trapped rainwater. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Given a string `s` and a dictionary of words `wordDict`, return _the minimum number of breakable segments_ where _all the segments are found in_ `wordDict`. A segment is a contiguous non-empty substring of `s` that is present in `wordDict`. If `s` cannot be segmented in such a way, return `-1`. For example, given `s = \\"leetcode\\"` and `wordDict = [\\"leet\\", \\"code\\"]`, the result would be `2` because \\"leetcode\\" can be segmented into \\"leet\\" and \\"code\\".","solution":"def min_segments(s, wordDict): word_set = set(wordDict) dp = [float(\'inf\')] * (len(s) + 1) dp[0] = 0 for i in range(1, len(s) + 1): for j in range(i): if s[j:i] in word_set: dp[i] = min(dp[i], dp[j] + 1) return dp[-1] if dp[-1] != float(\'inf\') else -1"},{"question":"You are given an array `arr` of `n` integers, where `n` is always even. The task is to partition the array into two subsets such that the difference between the sum of the two subsets is minimized. Return the minimum possible difference.","solution":"def min_subset_sum_difference(arr): Given an array of n integers (where n is always even), partitions the array into two subsets such that the difference between the sum of the two subsets is minimized. Returns the minimum possible difference. total_sum = sum(arr) n = len(arr) # DP array to hold possible sums up to total_sum / 2 dp = [0] * (total_sum // 2 + 1) for num in arr: for j in range(total_sum // 2, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) subset1_sum = dp[total_sum // 2] subset2_sum = total_sum - subset1_sum return abs(subset1_sum - subset2_sum)"},{"question":"You are given an array of integers `arr` and an integer `target`. You need to find if there exist three elements in `arr` whose sum is equal to `target`. Return _all unique triplets_ in the array which gives the sum of `target`. The solution set must not contain duplicate triplets. Note: - The array elements can be positive, negative, or zero. - The order of triplets in the output does not matter. - Each triplet in the solution must be sorted in ascending order.","solution":"def three_sum(arr, target): Finds all unique triplets in the array which sum up to the target value. Args: arr: List[int] - List of integers target: int - Target sum for the triplets Returns: List[List[int]] - List of unique triplets that sum up to the target arr.sort() triplets = [] for i in range(len(arr) - 2): # Skip the same element to avoid duplicate triplets if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: triplets.append([arr[i], arr[left], arr[right]]) # Skip duplicates for `left` and `right` while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"You are given a string `s` consisting of only letters and digits. A substring of `s` is called a good substring if all the characters in the substring are unique. Return _the length of the longest_ good substring _of_ `s`. If there are multiple substrings with the same length, return the length of any one of them. For example, if `s = \\"abcabcbb\\"`, the longest good substring is `\\"abc\\"` which has a length of 3.","solution":"def length_of_longest_good_substring(s): Returns the length of the longest good substring of s. A good substring is defined as a substring where all characters are unique. n = len(s) if n == 0: return 0 start = 0 max_length = 0 char_index_map = {} for end in range(n): end_char = s[end] if end_char in char_index_map: # Update the start position to the next position after last occurrence of end_char start = max(start, char_index_map[end_char] + 1) char_index_map[end_char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a binary tree, each node has a value representing the amount of gold. Your task is to find the maximum amount of gold that can be collected by starting at any node and following a path (down or up). A path is a sequence of nodes where each pair of adjacent nodes in the sequence is connected by an edge. You may start the path at any node, and the path may end at any node. Return the maximum amount of gold collected.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_gold_collect(node): Function to find the maximum amount of gold that can be collected by starting at any node and following a path. def max_gain(node): if not node: return 0 # Recursively get the maximum gain from left and right subtrees left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) # Current maximum path sum including the current node\'s value current_max_path = node.value + left_gain + right_gain # Update the global maximum gold amount max_gold_collect.max_gold = max(max_gold_collect.max_gold, current_max_path) # For recursion: return the maximum gain from either left or right path return node.value + max(left_gain, right_gain) max_gold_collect.max_gold = float(\'-inf\') max_gain(node) return max_gold_collect.max_gold"},{"question":"Given an array `arr` of integers where some elements appear twice and others appear once, find all the elements that appear twice. Your algorithm should run in O(n) time and use only O(1) extra space. Return a list of integers that appear twice in the input array. You can assume that the elements in the array are in the range 1 to the length of the array.","solution":"def find_duplicates(arr): Returns a list of integers that appear twice in the input array. result = [] for num in arr: index = abs(num) - 1 if arr[index] < 0: result.append(index + 1) arr[index] = -arr[index] return result"},{"question":"You are given two strings `s1` and `s2` of equal lengths. Your task is to determine the smallest possible length of a substring in `s1` that can be rearranged to form `s2`. If no such substring exists, return `-1`.","solution":"def smallest_substring_length_to_form(s1, s2): from collections import Counter def is_valid(counter_s1, counter_s2): for char in counter_s2: if counter_s1[char] < counter_s2[char]: return False return True len_s2 = len(s2) counter_s2 = Counter(s2) left, right = 0, 0 current_counter = Counter() min_length = float(\'inf\') while right < len(s1): current_counter[s1[right]] += 1 right += 1 while is_valid(current_counter, counter_s2): min_length = min(min_length, right - left) current_counter[s1[left]] -= 1 left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a list of non-negative integers `nums` which represents a list of coins, where `nums[i]` is the number of coins in the `i-th` pile. You are allowed to merge any two adjacent piles of coins into one larger pile. The cost of merging two piles is equal to the sum of the coins in both piles. Find the minimum total cost to merge all the piles into one pile. Note that once a merge is made, the new pile can also be merged with adjacent piles, and the process continues until you are left with one single pile.","solution":"def min_cost_to_merge_piles(nums): Returns the minimum total cost to merge all the piles into one pile. Args: nums: List of non-negative integers representing the number of coins in each pile. Returns: int: Minimum total cost to merge all piles into one pile. n = len(nums) if n == 0: return 0 if n == 1: return 0 import heapq heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first_min = heapq.heappop(nums) second_min = heapq.heappop(nums) current_cost = first_min + second_min total_cost += current_cost heapq.heappush(nums, current_cost) return total_cost"},{"question":"You are given a binary tree with `n` nodes where each node represents a person\'s name and their corresponding birthday. Each node contains three attributes: `name`, `birthday`, and the list of children nodes. Write a function that takes in the root of the tree and prints the names of people who have birthdays in the current month. The current month is given as an integer from 1 to 12. Function Signature: ```python def get_birthdays_in_current_month(root: Node, current_month: int) -> List[str]: ``` Where `Node` is defined as: ```python class Node: def __init__(self, name: str, birthday: str, children: List[\'Node\']): self.name = name self.birthday = birthday # formatted as \'YYYY-MM-DD\' self.children = children ```","solution":"from typing import List class Node: def __init__(self, name: str, birthday: str, children: List[\'Node\'] = []): self.name = name self.birthday = birthday # formatted as \'YYYY-MM-DD\' self.children = children def get_birthdays_in_current_month(root: Node, current_month: int) -> List[str]: Returns a list of names of people who have birthdays in the current month. def traverse(node: Node, current_month: int, result: List[str]): Helper function to traverse the tree and collect names with birthdays in the current month. month = int(node.birthday.split(\'-\')[1]) # Extract the month from \'YYYY-MM-DD\' if month == current_month: result.append(node.name) for child in node.children: traverse(child, current_month, result) result = [] traverse(root, current_month, result) return result"},{"question":"Given an array of non-negative integers `nums`, you are allowed to modify the array by selecting any index `i` and setting `nums[i]` to `nums[i]` plus or minus one. Return the minimum number of moves required to make all elements of the array equal. A move consists of incrementing or decrementing an element of the array by one.","solution":"def min_moves(nums): Returns the minimum number of moves required to make all elements in nums equal. A move is defined as incrementing or decrementing an element of the array by 1. Args: nums (list): List of non-negative integers. Returns: int: Minimum number of moves. median = sorted(nums)[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"You are given an array of `n` strings `arr`, where each string consists of lowercase English letters only. Your task is to find the longest common prefix among all the strings in the array. If there is no common prefix, return an empty string `\\"\\"`. For example, given the array `[\\"flower\\", \\"flow\\", \\"flight\\"]`, the longest common prefix is `\\"fl\\"`, while for `[\\"dog\\", \\"racecar\\", \\"car\\"]`, there is no common prefix, so the answer is `\\"\\"`. Return _the longest common prefix shared among the strings in_ `arr`.","solution":"def longest_common_prefix(arr): Returns the longest common prefix among all strings in the array. if not arr: return \\"\\" # Start by assuming the first word is the common prefix prefix = arr[0] # Iterate through the array starting from the second element for string in arr[1:]: # Check the current prefix against the current string in the array while string[:len(prefix)] != prefix and prefix: # Reduce the prefix by one character from the end prefix = prefix[:-1] if not prefix: break return prefix"},{"question":"You are given a **0-indexed** integer array `prices` where `prices[i]` represents the price of a given item on the `i-th` day. You are also given an integer `d`. You want to buy an item on one of the days and sell it on another day such that the difference between the buying and selling days is greater than or equal to `d`. Your goal is to maximize your profit. Return _the **maximum profit** you can achieve from these transactions_. If no profit can be achieved, return `0`. For example, if the input array is `[7, 1, 5, 3, 6, 4]` and `d` is `2`, the maximum profit would be obtained by buying on day `1` (price `1`) and selling on day `4` (price `6`) resulting in a profit of `5`.","solution":"def max_profit(prices, d): Returns the maximum profit that can be achieved with a constraint on the difference between the buying and selling days. :param prices: List of integers represents the price of an item on the i-th day. :param d: Integer represents the minimum difference in days between buying and selling. :return: Maximum profit possible. n = len(prices) if n <= d: return 0 max_profit = 0 for buy_day in range(n - d): for sell_day in range(buy_day + d, n): profit = prices[sell_day] - prices[buy_day] max_profit = max(max_profit, profit) return max_profit"},{"question":"You are given a binary matrix `grid` of size `n x n` where each cell contains either `0` or `1`. A square submatrix within this grid is called a \\"maximal square\\" if all of its elements are `1` and it cannot be extended by including any adjacent cell of the grid. Your task is to find the area of the largest maximal square in the given binary matrix. Return the area of the largest maximal square found. If there is no such square, return `0`. Remember that the area of a square is the square of the length of its side.","solution":"def maximal_square(grid): Computes the area of the largest square containing all 1\'s in the given binary matrix. :param grid: List[List[int]] - Binary matrix of size n x n :return: int - Area of the largest maximal square if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"You are given an integer array `heights` representing the height of buildings along a row, where the `ith` building has a height of `heights[i]`. The array is sorted in non-decreasing order. You need to simulate a water container placed between two buildings such that it can hold the maximum possible amount of water. The width of the container is determined by the distance between the two buildings, and the height is determined by the shorter building. Return the maximum amount of water that can be contained between any two buildings in the given array. The amount of water contained between the buildings at indices `i` and `j` is given by `(j - i) * min(heights[i], heights[j])`.","solution":"def max_water_container(heights): Returns the maximum amount of water that can be contained between any two buildings. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The maximum amount of water that can be contained. left = 0 right = len(heights) - 1 max_water = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_water = max(max_water, height * width) # Move the pointer that points to the shorter building if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given an integer array `nums` and an integer `k`. Return _the **maximum sum of a non-empty subsequence** of_ `nums` _such that the maximum element of the subsequence appears at least_ `k` _times in the subsequence_. If no such subsequence exists, return `-1`. A **subsequence** is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.","solution":"def max_sum_of_subsequence(nums, k): from collections import Counter # Count the frequency of each element in nums frequency = Counter(nums) # Filter out elements that appear at least k times valid_elements = [num for num, count in frequency.items() if count >= k] if not valid_elements: return -1 # Find the maximum element among valid elements max_element = max(valid_elements) # The maximum sum is max_element appearing exactly k times max_sum = max_element * k return max_sum"},{"question":"Given a string of lowercase alphabets, find the length of the longest substring that contains no more than two distinct characters. For example, given \\"eceba\\", the longest substring is \\"ece\\" with a length of 3.","solution":"def length_of_longest_substring_two_distinct(s): Given a string `s`, return the length of the longest substring that contains no more than two distinct characters. if not s: return 0 left, right = 0, 0 max_len = 0 char_map = {} while right < len(s): char_map[s[right]] = right right += 1 if len(char_map) > 2: del_idx = min(char_map.values()) del char_map[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given an array of positive integers `nums` and an integer `threshold`. You can partition `nums` into one or more subarrays such that the maximum sum of any subarray is minimized. Return the minimized maximum sum achievable by splitting the array at most `m` times. For example, if `nums = [7,2,5,10,8]` and `m = 2`, you can split the array into `[7,2,5]` and `[10,8]` to obtain a maximum sum of `18`, which is the smallest possible maximum sum given the constraints. Write a function that receives an array `nums` and an integer `m`, and returns the minimized maximum sum of its subarray splits.","solution":"def split_array(nums, m): def can_split(max_sum): current_sum = 0 count = 1 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` representing a list of words separated by spaces. Each word is a sequence of non-space characters. A word is considered a **duplicate** if it appears more than once in the list. Return a list of all the **duplicate** words in the order they first appear in the string. If there are no duplicate words, return an empty list.","solution":"def find_duplicate_words(s): Returns a list of duplicate words in the order they first appear in the string. words = s.split() word_count = {} duplicates = [] for word in words: if word in word_count: word_count[word] += 1 if word_count[word] == 2: # Add to duplicates list on the second occurrence duplicates.append(word) else: word_count[word] = 1 return duplicates"},{"question":"Given a **0-indexed** integer array `nums` of size `n`, you are tasked with finding an element that appears **more than** `n // 2` times in the array. This element is known as the **majority element**. You may assume that the majority element **always** exists in the array. Return _the majority element_. (Note: You must solve this using a linear time algorithm and in constant space.)","solution":"def majority_element(nums): Finds the majority element in the array nums. The majority element is the element that appears more than n // 2 times. Uses the Boyer-Moore Voting Algorithm to achieve O(n) time complexity and O(1) space complexity. # Boyer-Moore Voting Algorithm count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Since the majority element is guaranteed to exist, we can return the candidate directly. return candidate"},{"question":"You are given a string `s` consisting of lowercase English letters and a list of operations. Each operation is characterized by swapping two characters at given indices `i` and `j`. After performing all given operations, a string is considered to be lexicographically smallest if no permutation of the string, by performing the same operations, results in a smaller string. Implement a function that returns the lexicographically smallest string that can be obtained after performing any number of the given operations in any order.","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def smallestStringWithSwaps(s, pairs): n = len(s) parent = list(range(n)) rank = [0] * n for i, j in pairs: union(parent, rank, i, j) from collections import defaultdict groups = defaultdict(list) for i in range(n): root = find(parent, i) groups[root].append(i) res = list(s) for key in groups: indices = groups[key] chars = [res[i] for i in indices] chars.sort() for i, char in zip(sorted(indices), chars): res[i] = char return \'\'.join(res)"},{"question":"You are given an integer array `nums`. Check if we can form a strictly increasing sequence by removing at most one element from the array. If it\'s possible, return `true`, otherwise, return `false`. Note that the elements of the array should be rearranged according to their original relative order after removing at most one element.","solution":"def can_be_increasing(nums): Check if we can form a strictly increasing sequence by removing at most one element. def is_increasing(arr): for i in range(len(arr) - 1): if arr[i] >= arr[i + 1]: return False return True # Edge case: if the array is already strictly increasing if is_increasing(nums): return True # Try removing each element and check if the resulting array is strictly increasing for i in range(len(nums)): if is_increasing(nums[:i] + nums[i + 1:]): return True return False"},{"question":"Write a function that takes a list of non-negative integers representing the amount of rainwater each block in a bar graph can trap, where each index represents a block with the height of the numeral at that index. The height of each bar can be any non-negative integer. Calculate and return the maximum amount of rainwater that can be trapped within the given set of blocks when it rains.","solution":"def trap_rainwater(height): Calculate the maximum amount of rainwater that can be trapped. Parameters: height (list of int): A list of non-negative integers representing the height of blocks. Returns: int: The maximum amount of rainwater that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a string `s` consisting only of characters \'a\', \'b\', and \'c\', you are allowed to delete any number of characters from the string. Design a function to determine the minimum number of deletions required so that no two adjacent characters are the same. - For example, for `s = \\"aab\\"`, the minimum number of deletions required is 1. - For example, for `s = \\"aaaa\\"`, the minimum number of deletions required is 3. Implement the function `int minDeletions(String s)` to solve the problem.","solution":"def minDeletions(s): Determine the minimum number of deletions required so that no two adjacent characters are the same. Parameters: s (str): The input string consisting only of characters \'a\', \'b\', and \'c\'. Returns: int: The minimum number of deletions required. if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions"},{"question":"Given an array of integers `arr`, write a function that returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to a given integer `limit`. For example, given `arr = [8, 2, 4, 7]` and `limit = 4`, the longest subarray is `[2, 4]` with length `2`. If `arr = [10, 1, 2, 4, 7, 2]` and `limit = 5`, the longest subarray is `[4, 7, 2]` with length `3`.","solution":"from collections import deque def longest_subarray(arr, limit): Returns the length of the longest contiguous subarray with absolute difference between any two elements within limit. if not arr: return 0 max_dq = deque() # Deque to keep track of max values min_dq = deque() # Deque to keep track of min values start = 0 max_length = 0 for end in range(len(arr)): while max_dq and arr[end] > arr[max_dq[-1]]: max_dq.pop() while min_dq and arr[end] < arr[min_dq[-1]]: min_dq.pop() max_dq.append(end) min_dq.append(end) while arr[max_dq[0]] - arr[min_dq[0]] > limit: start += 1 if max_dq[0] < start: max_dq.popleft() if min_dq[0] < start: min_dq.popleft() max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an integer array `arr`, return `true` if and only if you can split the array into two non-empty subarrays `left` and `right` such that the average of elements in `left` is equal to the average of elements in `right`. The average of `n` elements is the sum of the elements divided by `n`.","solution":"def split_array_same_average(arr): Returns true if and only if you can split the array into two non-empty subarrays left and right such that the average of elements in left is equal to the average of elements in right. from itertools import combinations n = len(arr) total_sum = sum(arr) for size in range(1, n): if (total_sum * size) % n == 0: left_sum = (total_sum * size) // n if any(sum(comb) == left_sum for comb in combinations(arr, size)): return True return False"},{"question":"You are provided with two arrays `weights` and `values`, both of length `n`, where `weights[i]` is the weight of the `i-th` item and `values[i]` is the value of the `i-th` item. You also have a maximum capacity `W` which represents the maximum total weight that you can carry. Each item can be picked at most once. Your task is to determine the maximum total value you can accumulate by selecting a subset of the items such that the total weight of the selected items does not exceed `W`. Return _the maximum total value_ that can be obtained within the given constraints.","solution":"def knapsack(weights, values, W): Returns the maximum total value that can be accumulated without exceeding capacity W. :param weights: List of item weights. :param values: List of item values. :param W: Maximum capacity. :return: Maximum total value. n = len(weights) dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(W + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"You are given a `matrix` that represents a 2D grid of integers. Each element in the matrix represents the cost of entering that cell. You can only move right or down from any cell. Starting from the top-left cell, find the path that minimizes the sum of the costs of the cells included in the path to reach the bottom-right cell. Return the minimum sum as the output.","solution":"def minPathSum(matrix): Returns the minimum sum of the path from top-left to bottom-right of the matrix, where you can only move right or down. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill in the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"You are given a list of strings `words` and an integer `n`. Your task is to find the `n` most frequent words in the list. If two words have the same frequency, then the word with the smaller lexicographical order comes first. Return the result as a list of strings sorted by their frequency and lexicographical order. Implement the `FrequentWords` class: * `FrequentWords()` Initializes the object. * `List<String> findFrequentWords(List<String> words, int n)` returns the list of the `n` most frequent words from the input list, sorted by their frequency and then by lexicographical order.","solution":"from collections import Counter class FrequentWords: def __init__(self): pass def findFrequentWords(self, words, n): count = Counter(words) sorted_words = sorted(count.keys(), key=lambda x: (-count[x], x)) return sorted_words[:n]"},{"question":"[Question]: You are given a list of positive integers representing the durations of tasks you need to complete. Additionally, you have a fixed number of workers, each of whom can work on one task at a time. Each worker can complete exactly one task in a given unit of time. Implement a function `minTime(tasks, workers)` that returns the minimum amount of time required to complete all tasks given that no worker can start a new task until they have finished their current one. The function should take in a list `tasks` of positive integers where `tasks[i]` represents the duration of the `i`-th task, and an integer `workers` representing the number of workers available.","solution":"import math def minTime(tasks, workers): Returns the minimum amount of time required to complete all tasks. Parameters: tasks (list of int): A list of task durations. workers (int): The number of workers available. Returns: int: The minimum time required to complete all tasks. if not tasks: return 0 # Sort tasks in descending order for better load balancing tasks.sort(reverse=True) # Create a list to keep track of the amount of time each worker has been assigned worker_loads = [0] * workers # Assign tasks to the worker with the least current load for task in tasks: # Assign the current task to the least loaded worker least_loaded_worker = worker_loads.index(min(worker_loads)) worker_loads[least_loaded_worker] += task # The minimum time required is the maximum load on any single worker return max(worker_loads)"},{"question":"You are given a **0-indexed** array of integers `heights` representing the heights of students in a line. The goal is to reorder the students in such a way that the absolute difference between the heights of any two adjacent students is minimized. Return the array after reordering. Note: Multiple valid outputs are possible. You only need to return one such result.","solution":"def reorder_heights(heights): Reorder the students in such a way that the absolute difference between the heights of any two adjacent students is minimized. Args: heights (list of int): A 0-indexed array of integers representing the heights of students in a line. Returns: list of int: The reordered array where the differences between adjacent heights are minimized. # Sort the heights to minimize the differences between adjacent elements heights_sorted = sorted(heights) return heights_sorted"},{"question":"Given an integer `n`, write a function to generate all combinations of well-formed parentheses of length `2n`. A set of well-formed parentheses satisfies the following conditions: 1. Every opening bracket has a corresponding closing bracket. 2. Opening brackets must be closed in the correct order. Return _a list containing all possible combinations of well-formed parentheses of length `2n`_.","solution":"def generate_parentheses(n): Generates all combinations of well-formed parentheses of length 2n. def backtrack(current, open_count, close_count): if len(current) == 2 * n: result.append(current) return if open_count < n: backtrack(current + \\"(\\", open_count + 1, close_count) if close_count < open_count: backtrack(current + \\")\\", open_count, close_count + 1) result = [] backtrack(\\"\\", 0, 0) return result"},{"question":"Given a string `s` consisting of lowercase alphabets and an integer `k`, return _the lexicographically smallest subsequence of length_ `k` _that can be obtained by removing zero or more characters from_ `s`.","solution":"def smallest_subsequence(s, k): Returns the lexicographically smallest subsequence of length k that can be obtained by removing zero or more characters from s. stack = [] # This will store the smallest subsequence to_remove = len(s) - k # Number of characters we can remove to get subsequence of length k for i, char in enumerate(s): # While stack is not empty, we need to ensure the characters in stack are in ascending order while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) return \'\'.join(stack[:k])"},{"question":"A manufacturing company needs to simulate the performance of a machine that processes items. Each item has a unique processing time and weight. Given an integer `maxWeight` representing the maximum weight that the machine can handle simultaneously, and an array of tuples `items` where each tuple `(processingTime_i, weight_i)` denotes the processing time and weight of an item, determine the minimum total processing time to process all items, adhering to the weight constraint. Write a function that returns the minimum total processing time required. ```python def min_processing_time(maxWeight: int, items: List[Tuple[int, int]]) -> int: # Your code here # Example usage: # maxWeight = 10 # items = [(3, 4), (2, 8), (4, 5), (1, 6)] # The function should return the minimum total processing time feasible. ```","solution":"from typing import List, Tuple def min_processing_time(maxWeight: int, items: List[Tuple[int, int]]) -> int: Calculate the minimum total processing time to handle all items within the weight constraint of the machine. # Sort items by their processing time (ascending) items.sort() total_processing_time = 0 current_weight = 0 for time, weight in items: current_weight += weight if current_weight > maxWeight: # If we exceed the maxWeight, we need to add the processing time of the current item total_processing_time += time current_weight = weight # Start a new batch with the current item weight else: total_processing_time += time return total_processing_time"},{"question":"You need to implement an `LRUCache` class that simulates the Least Recently Used (LRU) cache. The cache should be initialized with a positive integer `capacity` which indicates the maximum number of items it can hold. The class should support the following operations: - `get(key)` - returns the value of the key if it exists in the cache, otherwise returns `-1`. - `put(key, value)` - updates or inserts the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. Your implementation should use `O(1)` time complexity for both operations.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) # mark the item as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # remove the first added (least recently used) item"},{"question":"Given a list of `n` integers, `arr`, a consecutive subsequence is defined as a non-empty segment of the array that contains elements which can be rearranged into an array of consecutive integers (e.g., `[4, 2, 3, 5]` can be rearranged to `[2, 3, 4, 5]` which is a consecutive sequence). Write a function that returns the length of the longest such consecutive subsequence in the list. Note: Your algorithm should have time complexity of O(n).","solution":"def longest_consecutive_subsequence(arr): Finds the length of the longest consecutive subsequence in the array. Args: arr (list of int): array of integers Returns: int: length of the longest consecutive subsequence num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a string `s` consisting of lowercase English letters. A character is considered to be \'unique\' if it appears exactly once in the string. Your task is to find the first unique character in the string and return its index. If there is no such character, return -1. Try to achieve this in linear time complexity.","solution":"def first_unique_char(s): Returns the index of the first unique character in the string `s`. If there is no unique character, returns -1. # Dictionary to store the frequency of each character char_count = {} # First pass: count each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: find the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"Given a string `s` consisting of only the characters \'a\', \'b\', and \'c\', replace every \'a\' with \'b\', every \'b\' with \'c\', and every \'c\' with \'a\'. Return the modified string after all replacements have been made. Note that all character replacements must be done simultaneously.","solution":"def replace_characters(s): Replaces every \'a\' with \'b\', every \'b\' with \'c\', and every \'c\' with \'a\' in the given string. Args: s (str): Input string consisting of only characters \'a\', \'b\', and \'c\'. Returns: str: Modified string after replacements. translation_table = str.maketrans(\'abc\', \'bca\') return s.translate(translation_table)"},{"question":"You are given two strings `s` and `t` of the same length that consist of characters \'0\' or \'1\'. Your task is to transform string `s` into string `t` by applying the following operation any number of times: - Choose any two positions `i` and `j` (0 ≤ i, j < len(s)) where `i ≠ j`. - Swap the characters at positions `i` and `j`. Return _the minimum number of swaps required_ to transform string `s` into string `t`, or `-1` if it is impossible to do so.","solution":"def min_swaps_to_transform(s, t): Returns the minimum number of swaps required to transform string s into string t. If it is impossible, returns -1. if len(s) != len(t): return -1 # Count differences between `s` and `t` count_0_in_s = count_1_in_s = count_0_in_t = count_1_in_t = 0 for i in range(len(s)): if s[i] != t[i]: if s[i] == \'0\': count_0_in_s += 1 else: count_1_in_s += 1 if t[i] == \'0\': count_0_in_t += 1 else: count_1_in_t += 1 # Check if transformation is possible if count_0_in_s != count_0_in_t or count_1_in_s != count_1_in_t: return -1 # Number of swaps needed is the number of different \'0\'s (or \'1\'s) in s and t return count_0_in_s"},{"question":"You are given an array of integers `arr` which may contain duplicates. Your task is to modify the array such that every integer in the array appears exactly once while minimizing the sum of all the removed elements. Return _the minimized sum of the removed elements_.","solution":"def minimize_removed_elements_sum(arr): Modify the array to have all unique elements and return the minimized sum of removed elements. Args: arr (list): The input array which may contain duplicates. Returns: int: The sum of all removed elements to make all elements in the array unique. from collections import Counter element_count = Counter(arr) removed_sum = 0 for element, count in element_count.items(): if count > 1: removed_sum += (count - 1) * element return removed_sum"},{"question":"You are managing a supply chain and need to optimize the stock levels of various products. You are given an array `stock` of length `n`, where `stock[i]` represents the current stock level of the `i-th` product. You are also given an integer `threshold` which represents the minimum required stock level for each product. Each day, you can choose one product and restock it to any level above its current stock. You need to return the **minimum number of days** needed to make sure all products have stock levels greater than or equal to `threshold`.","solution":"def min_days_to_restock(stock, threshold): Returns the minimum number of days needed to restock all products such that their levels are greater than or equal to the threshold. Parameters: stock (list): List of integers representing the current stock levels of products. threshold (int): The minimum required stock level for each product. Returns: int: Minimum number of days needed to restock. days = 0 for level in stock: if level < threshold: days += 1 return days"},{"question":"There are `n` people standing in a circle, numbered from `1` to `n`. They are playing a game where they pass a ball around the circle. Starting from person `1`, the ball is passed to the next person in the circle (i.e., person `1` passes to person `2`, person `n` passes to person `1`, etc.). The game continues until a person receives the ball `k` times. You are given two integers `n` and `k`. Write a function that returns the number of the person who will receive the ball the `k-th` time.","solution":"def find_person_with_ball(n, k): Returns the number of the person who will receive the ball the k-th time in a circle of n people. # The ball is passed n times in a complete round. # The person who receives the k-th pass can be found using modulo arithmetic. return (k - 1) % n + 1"},{"question":"Given a list of words `words` and a string `pattern`, return _a list of all words in `words` that match the given `pattern`_. A word matches the pattern if there exists a permutation of letters such that transforming each letter of the pattern to the corresponding letter of the word results in the original pattern. _Ensure the returned list is sorted in lexicographical order._","solution":"def find_and_sort_matching_patterns(words, pattern): def normalize(word): mapping = {} normalized_word = [] next_char = \'a\' for char in word: if char not in mapping: mapping[char] = next_char next_char = chr(ord(next_char) + 1) normalized_word.append(mapping[char]) return \'\'.join(normalized_word) normalized_pattern = normalize(pattern) matched_words = [word for word in words if normalize(word) == normalized_pattern] return sorted(matched_words)"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to return the indices of the two numbers such that they add up to the `target`. Solution should not involve using the same element twice, and there is exactly one solution. Implement the function `List<int> twoSum(List<int> nums, int target)` that returns a list of the two integers\' indices which sum to `target`.","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"Given a string `s`, return _the shortest palindromic substring that can be obtained by inserting the fewest number of characters at any position of the string_. Note that a palindromic string reads the same forward and backward.","solution":"def shortest_palindrome(s): Returns the shortest palindromic substring that can be obtained by inserting the fewest number of characters at any position of the string. if s == s[::-1]: return s rev_s = s[::-1] for i in range(len(s)): if s.startswith(rev_s[i:]): return rev_s[:i] + s return \\"\\""},{"question":"You are given two strings, `s1` and `s2`. Determine if `s2` can be obtained by rearranging the characters of `s1` and inserting exactly one additional character at any position in the rearranged string. Return _true_ if it is possible, otherwise return _false_.","solution":"def can_form_by_inserting_one_char(s1, s2): Determine if s2 can be obtained by rearranging characters of s1 and inserting exactly one character. Args: s1 (str): The source string. s2 (str): The target string that should be checked. Returns: bool: True if s2 can be formed, otherwise False. if len(s2) != len(s1) + 1: return False # Count characters in both strings from collections import Counter count_s1 = Counter(s1) count_s2 = Counter(s2) # There should be exactly one character in s2 that is not in s1 before insertion extra_char_count = 0 for char in count_s2: if count_s2[char] > count_s1[char]: extra_char_count += count_s2[char] - count_s1[char] return extra_char_count == 1"},{"question":"You are given an integer array `arr` where each element represents the height of a building. A set of buildings form a **skyline** if the height of each building in the set is greater than the height of the building immediately to its left (if it exists). Return an integer representing the length of the longest possible skyline that can be formed from the elements of `arr`.","solution":"def longest_skyline(arr): Returns the length of the longest possible skyline that can be formed from the elements of arr where each building (height in arr) is greater than the height of the building immediately to its left. if not arr: return 0 # This will store the lengths of the longest increasing subsequence ending at each index lis = [1] * len(arr) for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"You are tasked with developing a `FileSystem` class that emulates a hierarchical storage system. Each directory can contain multiple files and subdirectories. Implement the following methods: - `FileSystem()`: Initializes the filesystem. - `mkdir(path: str) -> None`: Creates a new directory at the specified `path`. The string `path` represents a sequence of directory names separated by forward slashes (`/`), starting from the root (`\\"/\\"`). If a directory along the path does not exist, it should be created automatically. - `addContentToFile(path: str, content: str) -> None`: Appends `content` to the file located at `path`. If the file does not exist, it is created. - `readContentFromFile(path: str) -> str`: Returns the content of the file located at `path`.","solution":"class FileSystem: def __init__(self): self.fs = {} def mkdir(self, path: str) -> None: dirs = path.split(\'/\') current = self.fs for d in dirs: if d: # skip empty strings resulted from split if d not in current: current[d] = {} current = current[d] def addContentToFile(self, path: str, content: str) -> None: dirs = path.split(\'/\') current = self.fs for d in dirs[:-1]: if d: # skip empty strings resulted from split if d not in current: current[d] = {} current = current[d] if dirs[-1] not in current: current[dirs[-1]] = \\"\\" current[dirs[-1]] += content def readContentFromFile(self, path: str) -> str: dirs = path.split(\'/\') current = self.fs for d in dirs: if d: # skip empty strings resulted from split current = current[d] return current"},{"question":"You are given an integer array `nums` where each element represents the amount of time a task takes to complete. Two workers, Worker A and Worker B, can work on tasks simultaneously but each can only work on one task at a time. Your goal is to find the minimum possible time required to complete all tasks if you assign the tasks optimally to both workers. Return the minimum time required to finish all tasks.","solution":"def min_time_to_complete_tasks(nums): Finds the minimum time required to complete all tasks if optimally assigned to two workers. :param nums: List[int] - An array where each element represents the amount of time a task takes to complete. :return: int - The minimum possible time required to complete all tasks. nums.sort(reverse=True) worker_a_time = 0 worker_b_time = 0 for time in nums: if worker_a_time <= worker_b_time: worker_a_time += time else: worker_b_time += time return max(worker_a_time, worker_b_time)"},{"question":"You are given a **0-indexed** integer array `nums`. A **running sum** of `nums` is an array `runningSum` where `runningSum[i]` is the sum of the elements from `nums[0]` to `nums[i]`. Implement a function that calculates the **running sum** of the array. Return _the **running sum** of the given array_.","solution":"def running_sum(nums): Returns the running sum of the given array. running_sum_array = [] current_sum = 0 for num in nums: current_sum += num running_sum_array.append(current_sum) return running_sum_array"},{"question":"Given a string `s` and an array of strings `words`, determine if `s` can be formed by concatenating each string in `words` exactly once and without any intervening characters. The words in `words` can be used in any order. Return `true` if `s` can be formed in such a way, and `false` otherwise.","solution":"def can_form_string(s, words): Determines whether the string `s` can be formed by concatenating each string in `words` exactly once and in any order. :param s: The target string. :param words: An array of strings. :return: True if `s` can be formed; False otherwise. from collections import Counter # Concatenate all words and check if its sorted characters match those in s concatenated_words = \'\'.join(words) if Counter(concatenated_words) == Counter(s): return True return False"},{"question":"You are given a square grid of size `n x n` represented by a 2D array `grid` where `grid[i][j]` could be either `0` (an empty cell) or `1` (a filled cell). You need to determine if it is possible to place exactly `n` non-intersecting horizontal or vertical dominos (`2 x 1` or `1 x 2` blocks) such that each domino covers two `1`s. Return true if it is possible to place the dominos in the described manner and false otherwise.","solution":"def is_possible_to_place_dominos(grid): Determine if it is possible to place n non-intersecting horizontal or vertical dominos such that each domino covers two `1`s in the given n x n grid. Args: grid: List[List[int]] - The given square grid of size n x n. Returns: bool - True if it is possible to place the dominos as described, False otherwise. n = len(grid) def can_place_domino(r, c, dr, dc): Helper function to check and place a horizontal or vertical domino if 0 <= r + dr < n and 0 <= c + dc < n and grid[r][c] == 1 and grid[r+dr][c+dc] == 1: grid[r][c] = 0 grid[r+dr][c+dc] = 0 return True return False domino_count = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: if can_place_domino(i, j, 0, 1) or can_place_domino(i, j, 1, 0): domino_count += 1 # Checking if we could place exactly n dominos return domino_count == n"},{"question":"You are managing a dynamic list of integers. Your task is to design a class that supports the following operations and can handle them efficiently: * `DynamicList()` Initializes the `DynamicList` object with an empty list. * `void insert(int index, int value)` Inserts the integer `value` at the specified `index` in the list. * `int find(int value)` Returns the index of the first occurrence of `value` in the list. If the value is not found, returns -1. * `void delete(int value)` Deletes the first occurrence of the integer `value` from the list. If no such value exists in the list, do nothing.","solution":"class DynamicList: def __init__(self): self.lst = [] def insert(self, index, value): Inserts the integer `value` at the specified `index` in the list. if index >= len(self.lst): self.lst.append(value) else: self.lst.insert(index, value) def find(self, value): Returns the index of the first occurrence of `value` in the list. If the value is not found, returns -1. try: return self.lst.index(value) except ValueError: return -1 def delete(self, value): Deletes the first occurrence of the integer `value` from the list. If no such value exists in the list, do nothing. try: self.lst.remove(value) except ValueError: pass"},{"question":"Given an array of integers `distances` where each `distances[i]` represents the distance from city `i` to a destination city located at `0`. You are required to build a new array `positions` of length `n` such that: - `positions[i]` is the number of cities that are greater than or equal to `distances[i]` in the `distances` array. Write a function `greatestCities(distances)` that returns the `positions` array. For example, if `distances = [3, 2, 1, 4, 5, 2]`, the function should return `[2, 3, 6, 1, 0, 3]` because: - For distances[0] = 3, there are 2 other cities (`distances[3]` = 4 and `distances[4]` = 5) that have a greater distance, and 0 other cities with the same distance, so `positions[0]` = 2. - Continue this process for each index in the input array.","solution":"def greatestCities(distances): Returns an array where positions[i] is the number of cities that are greater than or equal to distances[i]. n = len(distances) positions = [0] * n for i in range(n): count = 0 for j in range(n): if distances[j] > distances[i]: count += 1 positions[i] = count return positions"},{"question":"You are given a m x n matrix filled with non-negative integers. Find the maximum sum of a **submatrix** of size k x l, where k and l are given positive integers and both are less than or equal to the dimensions of the matrix. The submatrix must be contiguous and completely contained within the original matrix. Return the maximum sum of any such submatrix.","solution":"def max_sum_submatrix(matrix, k, l): Returns the maximum sum of a contiguous submatrix of size k x l in the given matrix. m = len(matrix) n = len(matrix[0]) # Initialize max sum to a very low value max_sum = float(\'-inf\') # Iterate over all possible top-left corners of k x l submatrices in the matrix for i in range(m - k + 1): for j in range(n - l + 1): # Calculate the sum of the current k x l submatrix current_sum = 0 for row in range(k): for col in range(l): current_sum += matrix[i + row][j + col] # Update max_sum if we found a new max if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given a string `s` consisting of lowercase alphabets and an integer `k`, determine if it is possible to rearrange the characters in `s` such that the same characters are at least `k` distance apart. If possible, return one such rearranged string. If not, return an empty string. Aim to design an algorithm that runs in O(n log n) time, where `n` is the length of the string.","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s, k): if k == 0: return s # Count the frequencies of each character char_count = Counter(s) # Use a max-heap to store the characters based on their frequency max_heap = [] for char, freq in char_count.items(): heappush(max_heap, (-freq, char)) result = [] queue = [] while max_heap: freq, char = heappop(max_heap) result.append(char) # Decrement the frequency queue.append((freq + 1, char)) if len(queue) >= k: f, c = queue.pop(0) if f < 0: heappush(max_heap, (f, c)) return \'\'.join(result) if len(result) == len(s) else \'\'"},{"question":"You are given an `m x n` binary matrix `grid`, where `0` represents a sea cell and `1` represents a land cell. An island is a maximal 4-directionally connected group of `1`s. The grid is said to be fully surrounded by `0`s if it contains no connected `1`s that are connected to the boundary of the grid. Write a function `numFullySurroundedIslands(grid)` that returns the number of fully surrounded islands in the grid. **Example 1:** ``` Input: grid = [ [1, 0, 0, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 0] ] Output: 1 ``` **Example 2:** ``` Input: grid = [ [0, 0, 1, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] Output: 1 ``` **Example 3:** ``` Input: grid = [ [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] Output: 1 ```","solution":"def numFullySurroundedIslands(grid): if not grid or not grid[0]: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 for x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]: dfs(i + x, j + y) def is_on_boundary(i, j): return i == 0 or i == len(grid) - 1 or j == 0 or j == len(grid[0]) - 1 # Turn boundary-connected \'1\'s and their connected components into \'0\'s for i in range(len(grid)): for j in range(len(grid[0])): if is_on_boundary(i, j) and grid[i][j] == 1: dfs(i, j) # Count the fully surrounded islands count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: count += 1 dfs(i, j) return count"},{"question":"Given an array of integers `nums` where `nums[i]` is in the range `[1, n]` and `n` is the length of the array, some elements appear twice and others appear once. Implement a function that returns all the integers that appear twice in `nums`. You must write an algorithm that uses `O(n)` time and `O(1)` extra space.","solution":"def find_duplicates(nums): Finds all the integers that appear twice in the nums array. Args: nums (List[int]): A list of integers. Returns: List[int]: A list of integers that appear twice in nums. # Result list to store duplicates duplicates = [] # Go through each number in nums for num in nums: # Find the index that corresponds to the number\'s value (1-based index) index = abs(num) - 1 if nums[index] < 0: # If the value at this index is negative, the number is a duplicate duplicates.append(abs(num)) else: # Mark the value at this index as seen by making it negative nums[index] = -nums[index] return duplicates"},{"question":"You are given a list of `n` integers `arr` and an integer `target`. Implement a function that returns the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. The solution should return the indices in increasing order. If no such indices exist, return an empty list.","solution":"def two_sum(arr, target): Finds the two indices in the list `arr` such that the numbers at those indices add up to `target`. Parameters: arr (list of int): List of integers. target (int): The target sum. Returns: list of int: The indices of the two numbers that add up to the target, in increasing order. num_to_index = {} for index, num in enumerate(arr): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], index]) num_to_index[num] = index return []"},{"question":"Given a string `pattern` and a string `str`, find if `str` follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in `pattern` and a non-empty word in `str`. Constraints: - You may assume `pattern` contains only lowercase letters, and `str` contains only lowercase letters separated by a single space. - Length of `pattern` will not exceed 100. - Length of `str` will not exceed 10,000. For example: - Given `pattern = \\"abba\\"` and `str = \\"dog cat cat dog\\"`, return true. - Given `pattern = \\"abba\\"` and `str = \\"dog cat cat fish\\"`, return false. - Given `pattern = \\"aaaa\\"` and `str = \\"dog cat cat dog\\"`, return false. - Given `pattern = \\"abba\\"` and `str = \\"dog dog dog dog\\"`, return false.","solution":"def word_pattern(pattern, str): Determines if str follows the same pattern. :param pattern: a string representing the pattern :param str: a string where words are separated by single spaces :return: True if str follows pattern, False otherwise words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: if word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"You are given an integer `n` which represents the number of vertices in a graph, and an array `edges` where `edges[i] = [u, v]` represents an undirected edge between the vertices `u` and `v`. Given an integer `start`, you are required to find the **maximum depth** of the graph starting from the node `start`. The depth of the graph from a starting node is defined as the maximum number of edges in the shortest path from the start node to any other node in the graph. Return _the maximum depth of the graph from the starting node_. If the graph is not connected, consider only the connected component that includes the `start` node.","solution":"from collections import deque, defaultdict def max_graph_depth(n, edges, start): Returns the maximum depth of the graph starting from the node `start`. Parameters: n (int): Number of vertices in the graph. edges (list of list of int): List of edges in the graph where edges[i] = [u, v] represents an undirected edge between the vertices u and v. start (int): Starting node to calculate the maximum depth from. Returns: int: Maximum depth of the graph from the starting node. if n == 0 or not edges: return 0 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() queue = deque([(start, 0)]) visited.add(start) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, depth + 1)) return max_depth"},{"question":"You are given a 2D grid of size `m x n` filled with non-negative integers. The value at each cell represents the height of a terrain at that point. Water can flow from one cell to another if and only if the height of the destination cell is less than or equal to the height of the current cell (water can flow horizontally or vertically). The Pacific Ocean touches the left and top edges of the grid, and the Atlantic Ocean touches the right and bottom edges of the grid. Write a function to determine the list of grid coordinates where water can flow to both the Pacific and Atlantic oceans. Implement the `waterFlow` function: * `List<int[]> waterFlow(int[][] heights)` where `heights` is a 2D array representing the heights of the terrain. Your function should return a list of coordinates `[i, j]` for which water can flow from that cell to both the Pacific and Atlantic oceans. The list should be sorted primarily by increasing row index and secondarily by increasing column index.","solution":"from typing import List def waterFlow(heights: List[List[int]]) -> List[List[int]]: if not heights or not heights[0]: return [] m, n = len(heights), len(heights[0]) pacific_reachable = [[False] * n for _ in range(m)] atlantic_reachable = [[False] * n for _ in range(m)] def dfs(x, y, reachable): reachable[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not reachable[nx][ny] and heights[nx][ny] >= heights[x][y]: dfs(nx, ny, reachable) for i in range(m): dfs(i, 0, pacific_reachable) dfs(i, n - 1, atlantic_reachable) for j in range(n): dfs(0, j, pacific_reachable) dfs(m - 1, j, atlantic_reachable) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"You are given an array of integers `arr` representing a list of daily temperatures. For each day, you need to tell how many days you have to wait until a warmer temperature. If there is no future day for which this is possible, return `0` for that day. Implement a function that returns an array of integers where each element represents the number of days to wait for a warmer temperature or `0` if no such day exists.","solution":"def dailyTemperatures(T): Given a list of daily temperatures, returns a list where each element represents the number of days to wait for a warmer temperature. If there is no future day with a warmer temperature, returns 0 for that day. :param T: List[int] - List of daily temperatures. :return: List[int] - List of days to wait for a warmer temperature. n = len(T) answer = [0] * n stack = [] # Stack to store indices of the temperatures for i in range(n): # Check the stack and process until we find a lower temperature while stack and T[i] > T[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"Given a binary search tree (BST) with `n` nodes, write a function to convert the BST into a balanced binary search tree (BBST) while maintaining the original elements. A balanced binary search tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Implement the function `TreeNode* balanceBST(TreeNode* root)` that takes the root node of the BST and returns the root node of the balanced BST. Note: - The structure for a binary tree node is defined as: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; ``` - You may assume that nodes\' values in the BST are unique. - You may use any strategy to balance the tree (e.g., in-order traversal to get sorted elements and then reconstructing the tree).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balanceBST(root): Convert a binary search tree (BST) into a balanced binary search tree (BBST). def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) def sorted_list_to_bbst(nums): if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_list_to_bbst(nums[:mid]) root.right = sorted_list_to_bbst(nums[mid+1:]) return root elements = inorder_traversal(root) return sorted_list_to_bbst(elements)"},{"question":"Given a list of integers `nums` representing a set of coins and an integer `target`, return _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`. You may assume that you have an infinite number of each kind of coin. * For example, with `nums = [1, 2, 5]` and `target = 11`, the return value would be `3` (11 = 5 + 5 + 1).","solution":"def coin_change(nums, target): Returns the fewest number of coins needed to make the target amount. If the target amount cannot be made up by any combination of the coins, returns -1. # Initializing the dp array with a value greater than any possible number of coins dp = [float(\'inf\')] * (target + 1) # Base case: No coins needed to make 0 amount dp[0] = 0 for coin in nums: for i in range(coin, target + 1): dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[target] is still infinity, it means it\'s not possible to make that amount with the given coins return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the number of distinct pairs `(i, j)` in the array such that `arr[i] + arr[j]` is divisible by `k`. A pair `(i, j)` is considered valid if and only if `i < j`. Return the number of valid pairs. **Example:** ``` Input: arr = [1, 2, 3, 4, 5], k = 3 Output: 4 Explanation: The pairs (0, 2), (1, 3), (0, 5), and (2, 4) are the pairs for which the sum is divisible by 3. ```","solution":"def count_divisible_pairs(arr, k): Returns the number of distinct pairs (i, j) in the array such that arr[i] + arr[j] is divisible by k and i < j. Parameters: arr (list): The input list of integers. k (int): The integer divisor. Returns: int: The count of valid pairs. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"Given an array `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane, return _the minimum number of arrows that must be shot to burst all balloons_. An arrow can be shot up exactly vertically from different points along the X-axis. A balloon with `diameter d` centered at `[xi, yi]` can be burst by an arrow shot from any point between `xi - d/2` and `xi + d/2`.","solution":"def find_min_arrows(points): Returns the minimum number of arrows required to burst all balloons. Args: points (list of list of int): An array where points[i] = [xi, yi] represents a point on the X-Y plane. Returns: int: The minimum number of arrows required to burst all balloons. if not points: return 0 # Sort the points based on their y-coordinate (height) points.sort(key=lambda x: x[1]) arrows = 1 current_end = points[0][1] for x, y in points: if x > current_end: arrows += 1 current_end = y return arrows"},{"question":"Given an array of strings, return a list of all strings that are anagrams of each other grouped together. Each group of anagrams should be represented as a list of strings, and the groups should be sorted lexicographically within themselves. The resulting list of groups should also be sorted lexicographically by the first string in each group. An anagram is a word or phrase formed by rearranging the letters of another, using all the original letters exactly once.","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams together from a list of strings. Args: words (list of str): List of strings to be grouped as anagrams. Returns: list of list of str: List of groups of anagram strings, each sorted lexicographically within the group. anagram_dict = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) for key in anagram_dict: anagram_dict[key].sort() result = sorted(anagram_dict.values(), key=lambda x: x[0]) return result"},{"question":"Given an `n x n` matrix `matrix` containing only `1` (representing land) and `0` (representing water), find the largest square sub-matrix that consists entirely of `1`. The sub-matrix should be square-shaped. Return _the area of the largest square sub-matrix_.","solution":"def max_square_area(matrix): Returns the area of the largest square sub-matrix filled with 1s. if not matrix or not matrix[0]: return 0 n = len(matrix) # Create a dp array to store the size of the largest square sub-matrix ending at each cell dp = [[0] * n for _ in range(n)] max_side = 0 # Iterate through the matrix for i in range(n): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # The edge values will be the same as the matrix values else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) # The area of the largest square sub-matrix is the square of the side length return max_side * max_side"},{"question":"Given a matrix `mat` where each cell contains an integer, return the minimum cost to traverse from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. The cost is defined by the sum of the values of the cells you pass through, including the starting and ending cells.","solution":"def minPathSum(mat): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of the matrix mat. if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = mat[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + mat[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + mat[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + mat[i][j] return dp[-1][-1]"},{"question":"Given a string `s`, return the total number of distinct non-empty substrings of `s`. Since the answer can be very large, return the result **modulo** `109 + 7`. Note that different occurrences of the same substring should be counted only once.","solution":"def distinct_substrings(s): Returns the total number of distinct non-empty substrings of `s` modulo 10^9 + 7. MODULO = 10**9 + 7 n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings) % MODULO"},{"question":"You are given a 2D grid of size `m x n` where each cell is either a `0` (empty) or a `1` (occupied). You need to find the largest rectangle containing only `1`s and return its area. The rectangle can be of any size and orientation.","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 height = [0] * (len(matrix[0]) + 1) # Using one extra element for easier calculations for row in matrix: for i in range(len(row)): if row[i] == \'1\': height[i] += 1 else: height[i] = 0 stack = [] for i in range(len(height)): while stack and height[stack[-1]] > height[i]: h = height[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You can delete at most `k` characters from the string. A string is called beautiful if there are no adjacent characters in the string that are the same. Determine the **minimum** number of deletions required to make the string beautiful. If it is not possible to make the string beautiful by deleting `k` characters, return `-1`. Return the number of deletions needed or `-1` if it isn\'t possible.","solution":"def min_deletions_to_beautiful(s, k): Determines the minimum number of deletions required to make the string beautiful, ensuring no more than \'k\' deletions are performed. deletions = 0 n = len(s) if n == 0: return 0 i = 0 while i < n - 1: if s[i] == s[i + 1]: deletions += 1 i += 1 return deletions if deletions <= k else -1"},{"question":"Given a list of intervals where each interval is represented as a tuple `(start, end)` and a new interval represented as a tuple `(new_start, new_end)`, insert the new interval into the list of intervals and merge if necessary. The intervals in the list are initially sorted based on the starting times. Return the updated list of intervals after the new interval has been inserted and merged.","solution":"def insert_and_merge_intervals(intervals, new_interval): Insert a new interval into the list of intervals and merge if necessary. :param intervals: List of intervals represented as tuples (start, end) :param new_interval: A tuple (new_start, new_end) representing the new interval :return: Updated list of intervals after insertion and merging updated_intervals = [] merged_interval = new_interval inserted = False for interval in intervals: if interval[1] < new_interval[0]: updated_intervals.append(interval) elif new_interval[1] < interval[0]: if not inserted: updated_intervals.append(merged_interval) inserted = True updated_intervals.append(interval) else: merged_interval = (min(merged_interval[0], interval[0]), max(merged_interval[1], interval[1])) if not inserted: updated_intervals.append(merged_interval) return updated_intervals"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find the **number of unique pairs** in the array whose sum is equal to the given `target` value. Each pair should be counted only once, even if there are multiple instances of each element in the array. Note that the elements within each pair must come from different indices in the array. Write a function `countUniquePairs(int[] nums, int target)` that returns the count of such unique pairs. Examples: - Given `nums = [1, 2, 3, 4, 3, 2, 1]` and `target = 5`, the function should return `2` because the pairs (1, 4) and (2, 3) sum up to 5. - Given `nums = [1, 1, 1, 1]` and `target = 2`, the function should return `1` because there is only one pair (1, 1) that sums up to 2.","solution":"def countUniquePairs(nums, target): Returns the number of unique pairs in the array `nums` whose sum is equal to `target`. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of students standing in a line. A group of students is considered to be a **balanced group** if the absolute difference between the heights of any two students in the group is at most `k`. You are also provided with an integer `k`. Return _the maximum number of balanced groups you can form by dividing the students standing in line_. Each student must be part of exactly one group, and the order of students within the group should remain the same. If it is impossible to divide the students into balanced groups, return `0`.","solution":"def max_balanced_groups(heights, k): Returns the maximum number of balanced groups that can be formed from the given heights with the condition that the absolute difference between the heights in any group is at most k. if not heights: return 0 groups = 1 min_height = heights[0] max_height = heights[0] for height in heights[1:]: if height < min_height: min_height = height if height > max_height: max_height = height if max_height - min_height > k: groups += 1 min_height = height max_height = height return groups"},{"question":"Given a string `s` containing letters and digits, you need to return a string where all the digits have been grouped together following all the letters while maintaining their relative order. For example, if the given string is `\\"a3c2b1\\"`, the output should be `\\"acb321\\"`. Implement a function that efficiently processes the input string in a single pass. Note that the input string can also be empty or contain no digits or letters.","solution":"def rearrange_string(s): Rearranges the input string so that all digits are moved to the end while maintaining the order of both the letters and digits. Args: s (str): Input string containing letters and digits. Returns: str: String with all digits grouped together at the end. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return \'\'.join(letters) + \'\'.join(digits)"},{"question":"You are given a list of `n` strings. Your task is to find the longest string that can be constructed by concatenating any subset of the given strings (including the original strings themselves) such that each string in the resulting concatenated string appears exactly once. If multiple longest strings exist, return the lexicographically smallest one. Return an empty string if no valid string can be formed.","solution":"def longest_unique_concatenated_string(strings): Returns the longest string that can be constructed by concatenating any subset of the given strings such that each string in the resulting concatenated string appears exactly once. If multiple longest strings exist, return the lexicographically smallest one. Return an empty string if no valid string can be formed. from itertools import combinations def is_unique(s): return len(s) == len(set(s)) sorted_strings = sorted(strings) # Sort to ensure lexicographical order max_len = 0 result = \\"\\" # Check all subsets of different lengths for r in range(1, len(strings) + 1): for subset in combinations(sorted_strings, r): combined = \'\'.join(subset) if is_unique(combined): if len(combined) > max_len or (len(combined) == max_len and combined < result): max_len = len(combined) result = combined return result"},{"question":"You are given a list of `events` represented as tuples `(event_type, timestamp)`, where `event_type` is a string representing an event (either \\"start\\" or \\"end\\") and `timestamp` is an integer representing the time the event occurred. Your task is to implement a class `EventTracker` with the following methods: - `void addEvent(string event_type, int timestamp)`: - Records an event with the given `event_type` and `timestamp`. - Events may be added out of order. - `double getAverageStartToEndTime()`: - Returns the average time elapsed between each \\"start\\" and the corresponding \\"end\\" event. - If there are no complete start-end pairs, return `0.0`. - `int getIncompleteEventCount()`: - Returns the count of \\"start\\" events that do not have a corresponding \\"end\\" event. Assume that for every \\"start\\" event, there is a corresponding \\"end\\" event. However, the events might not be in chronological order initially, and there might be some \\"start\\" events without matching \\"end\\" events when queried. Implement the `EventTracker` class and its methods as specified.","solution":"class EventTracker: def __init__(self): self.events = [] self.start_times = [] def addEvent(self, event_type, timestamp): Records an event with the given event_type and timestamp. self.events.append((event_type, timestamp)) if event_type == \\"start\\": self.start_times.append(timestamp) elif event_type == \\"end\\": self.start_times.sort() self.events.sort(key=lambda x: x[1]) earliest_start = self.start_times.pop(0) def getAverageStartToEndTime(self): Returns the average time elapsed between each \'start\' and the corresponding \'end\' event. If there are no complete start-end pairs, return 0.0. start_times = [] start_end_pairs = [] self.events.sort(key=lambda x: x[1]) for event_type, timestamp in self.events: if event_type == \\"start\\": start_times.append(timestamp) elif event_type == \\"end\\": if start_times: start_time = start_times.pop(0) start_end_pairs.append(timestamp - start_time) if not start_end_pairs: return 0.0 return sum(start_end_pairs) / len(start_end_pairs) def getIncompleteEventCount(self): Returns the count of \'start\' events that do not have a corresponding \'end\' event. start_times = [] self.events.sort(key=lambda x: x[1]) for event_type, timestamp in self.events: if event_type == \\"start\\": start_times.append(timestamp) elif event_type == \\"end\\": if start_times: start_times.pop(0) return len(start_times)"},{"question":"Given a string `s` containing only characters \'a\' and \'b\', a **good substring** is defined as a substring that contains an equal number of \'a\'s and \'b\'s. Write a function to return _the length of the longest good substring in_ `s`. If no such substring exists, return `0`.","solution":"def longest_good_substring(s): Returns the length of the longest good substring in s. A good substring has an equal number of \'a\'s and \'b\'s. max_len = 0 n = len(s) for i in range(n): count_a = count_b = 0 for j in range(i, n): if s[j] == \'a\': count_a += 1 elif s[j] == \'b\': count_b += 1 if count_a == count_b: max_len = max(max_len, j - i + 1) return max_len"},{"question":"Given an array of integers, write a function to find and return the largest sum of any contiguous subarray. If the array contains only negative numbers, return the single largest number.","solution":"def max_subarray_sum(nums): Returns the largest sum of any contiguous subarray. If the array contains only negative numbers, returns the single largest number. if not nums: return 0 current_subarray_sum = max_subarray_sum = nums[0] for num in nums[1:]: current_subarray_sum = max(num, current_subarray_sum + num) max_subarray_sum = max(max_subarray_sum, current_subarray_sum) return max_subarray_sum"},{"question":"Given a binary tree where the value of each node represents a digit (0–9), return _the sum of all the numbers formed by the root-to-leaf paths_. Each path in the tree creates a number by consecutively appending the digits from the root to the leaf. All intermediate and final results will be within the range of a 32-bit signed integer. **Note:** A leaf is a node with no children.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_numbers(root): Returns the sum of all the numbers formed by the root-to-leaf paths in the binary tree. def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.value # If it\'s a leaf node, return the current number if not node.left and not node.right: return current_number # Otherwise, sum up the values from left and right subtrees left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"You are given a list of `n` items where each item has a value and a weight. You are also given a maximum weight capacity of a knapsack. Your goal is to determine the maximum total value of items that can be included in the knapsack without exceeding the weight capacity. Each item can be included completely or not at all, there are no fractional items allowed. Given two lists `values` and `weights` of length `n`, and an integer `capacity`, return the maximum total value that can be achieved.","solution":"def knapsack(values, weights, capacity): Determines the maximum total value of items that can be included in the knapsack without exceeding the weight capacity. :param values: List of values of the items. :param weights: List of weights of the items. :param capacity: Maximum weight capacity of the knapsack. :return: Integer, the maximum total value. n = len(values) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(1, capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"You are given an integer array `nums` and you need to determine if there exists a triple `(i, j, k)` such that `i < j < k` and `nums[i] < nums[j] < nums[k]`. Return `true` if such a triple exists and `false` otherwise.","solution":"def increasing_triplet(nums): Determines if there exists a triple (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. Args: nums (List[int]): The input list of integers. Returns: bool: True if such a triplet exists, else False. first = second = float(\'inf\') for num in nums: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"Given an array of `n` positive integers, where each integer represents the height of a bar, imagine `n` vertical bars on a histogram. A bar\'s width is given as `1`. You need to determine the area of the largest rectangle that can be formed, such that the rectangle is fully contained within the histogram, considering the bars as the potential heights of the rectangle. Unlike the actual histogram where the base of the rectangle is always the width of the bars, here the base of the rectangle can be of any width within the limits of the histogram. Return the area of the largest rectangle that can be formed within the histogram given the array. The height of the rectangle is determined by the shortest bar in the interval chosen and the width by the length of that interval.","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed within the histogram. :param heights: List of positive integers representing the heights of bars. :return: Integer representing the largest rectangle area. stack = [] max_area = 0 index = 0 while index < len(heights): # If stack is empty or current bar is taller than # the bar at stack\'s top index if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a binary tree where each node contains an integer value. Implement a function `maxLevelSum` that returns the level of the tree with the maximum sum of node values. In case of a tie, return the smallest level number. Consider the root level as 1. Class definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Function signature: ```python def maxLevelSum(root: TreeNode) -> int: # Your code here ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxLevelSum(root: TreeNode) -> int: if not root: return 0 max_sum = float(\'-inf\') max_level = 0 level = 1 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) if level_sum > max_sum: max_sum = level_sum max_level = level level += 1 return max_level"},{"question":"You are given two strings `s1` and `s2` of the same length, consisting of lowercase letters. Your task is to interleave the two strings to create a new string `result` where the characters from `s1` and `s2` alternate. Specifically, the `i-th` character of `result` should be the `i-th` character of `s1`, followed by the `i-th` character of `s2`. Write a function `interleaveStrings(s1, s2)` that returns the interleaved string `result`.","solution":"def interleaveStrings(s1, s2): Interleaves two strings of the same length by alternating their characters. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: str: The interleaved string. result = [] for i in range(len(s1)): result.append(s1[i]) result.append(s2[i]) return \'\'.join(result)"},{"question":"Given a list of integers `nums`, and an integer `K`, return a list of all unique subsets of `nums` such that the sum of elements in each subset is less than or equal to `K`. Each subset in the returned list should be sorted in non-decreasing order, and the entire output list should be sorted in lexicographical order. Note that the solution set must not contain duplicate subsets.","solution":"from itertools import combinations def subsets_with_sum_k(nums, K): Returns all unique subsets of `nums` such that the sum of elements in each subset is less than or equal to `K`. Each subset in the returned list is sorted in non-decreasing order, and the entire output list is sorted in lexicographical order. nums = sorted(nums) n = len(nums) result = set() for r in range(n + 1): for combo in combinations(nums, r): if sum(combo) <= K: result.add(combo) sorted_result = sorted(result, key=lambda x: (len(x), x)) return [list(subset) for subset in sorted_result]"},{"question":"Given an array of integers, find the maximum sum of any contiguous subarray of the array. Your task is to implement a function that computes this maximum sum.","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` is a jumbled version of a permutation where each character has been scrambled according to the `indices` array. The `indices` array indicates the correct position of each character in the original string. Return the original string after rearranging the characters of `s` according to the given `indices`.","solution":"def restore_string(s, indices): Restore the string according to the given indices array. Parameters: s (str): jumbled version of a permutation string. indices (List[int]): This array indicates the correct position of each character in the original string. Returns: str: The original string after rearranging the characters of \'s\'. restored = [\'\'] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return \'\'.join(restored)"},{"question":"You are given a string `s` consisting of words, and a string `pattern`. Every word consists of lowercase English letters and is separated by a single space. Write a function to determine if the words in the string `s` follow the same order as characters in the string `pattern`. Here, \\"follow\\" means that there is a bijection between a letter in `pattern` and a non-empty word in `s`. Return `true` if `s` follows the `pattern`, and `false` otherwise.","solution":"def word_pattern(s, pattern): Returns True if words in string s follow the same order as characters in string pattern. words = s.split() if len(words) != len(pattern): return False char_to_word = {} word_to_char = {} for c, word in zip(pattern, words): if c in char_to_word: if char_to_word[c] != word: return False else: if word in word_to_char: if word_to_char[word] != c: return False char_to_word[c] = word word_to_char[word] = c return True"},{"question":"Given an array of integers `arr`, return the number of contiguous subarrays that sum to a target value `target`. Each subarray must have a length of at least 1.","solution":"from collections import defaultdict def subarray_sum(arr, target): Return the number of contiguous subarrays that sum to a target value. :param arr: List of integers :param target: Integer target sum :return: Number of contiguous subarrays that sum to the target value count = 0 current_sum = 0 prefix_sums = defaultdict(int) prefix_sums[0] = 1 for num in arr: current_sum += num if (current_sum - target) in prefix_sums: count += prefix_sums[current_sum - target] prefix_sums[current_sum] += 1 return count"},{"question":"Given an array of integers `nums` and an integer `target`, return the number of pairs `(i, j)` where `0 <= i < j < nums.length` and `nums[i] + nums[j] == target`. The solution should have a linear time complexity.","solution":"def count_pairs(nums, target): Returns the number of pairs (i, j) where 0 <= i < j < nums.length and nums[i] + nums[j] == target. The solution has a linear time complexity. num_count = {} pair_count = 0 for num in nums: complement = target - num if complement in num_count: pair_count += num_count[complement] if num in num_count: num_count[num] += 1 else: num_count[num] = 1 return pair_count"},{"question":"You are given a list of non-overlapping intervals `intervals` where `intervals[i] = [start_i, end_i]` represent the start and the end of the i-th interval. You are also given another interval `newInterval = [start, end]` that you need to insert into `intervals`. Insert `newInterval` into `intervals` such that the `intervals` remain non-overlapping and sorted in ascending order by their start time. Return the resulting list of intervals after the insertion. For example, given `intervals = [[1,3],[6,9]]` and `newInterval = [2,5]`, your function should return `[[1,5],[6,9]]`.","solution":"def insert_intervals(intervals, newInterval): result = [] i, n = 0, len(intervals) # Add all intervals before newInterval while i < n and intervals[i][1] < newInterval[0]: result.append(intervals[i]) i += 1 # Merge intervals that overlap with newInterval while i < n and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 # Add the merged interval result.append(newInterval) # Add the remaining intervals while i < n: result.append(intervals[i]) i += 1 return result"},{"question":"Given a binary string `s`, you can delete any two adjacent characters `00` or `11` in `s`. Each deletion reduces the length of `s` by 2. Return the length of the smallest possible string that can be obtained by performing this operation any number of times. For example, given `s = \\"110100\\"`, after deleting `11` and `00` you\'re left with the string \\"10\\". The smallest possible string length is `2`.","solution":"def smallest_string_length(s): Return the length of the smallest possible string that can be obtained by deleting any two adjacent characters \'00\' or \'11\'. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"Write a function to determine if a given number `n` is a \\"happy number.\\" A happy number is defined by the following process: - Starting with any positive integer, replace the number by the sum of the squares of its digits. - Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle that does not include 1. - Those numbers for which this process ends in 1 are happy numbers. Return `true` if n is a happy number, otherwise return `false`. Example: - Input: `19` - Output: `true` Explanation: 1² + 9² = 82 8² + 2² = 68 6² + 8² = 100 1² + 0² + 0² = 1","solution":"def is_happy(n): Determines if a number n is a \\"happy number\\". Parameters: n (int): The number to check. Returns: bool: True if n is a happy number, False otherwise. def sum_of_squares(num): return sum(int(digit) ** 2 for digit in str(num)) seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares(n) return n == 1"},{"question":"You are given a string `formula` representing a chemical formula. The formula will always be valid and consists of chemical elements represented by uppercase English letters, followed by lowercase English letters (if any), and numbers representing the count of each element. For example, \\"H2O\\" represents 2 hydrogen atoms and 1 oxygen atom, and \\"Mg(OH)2\\" represents 1 magnesium atom, 2 oxygen atoms, and 2 hydrogen atoms. Construct and return the count of each chemical element in the given formula as a string representation with the element followed by its count (in sorted order of the elements). For example, given the chemical formula `formula = \\"K4(ON(SO3)2)2\\"`, the count of elements should be `K4N2O14S4`.","solution":"def count_of_atoms(formula): import re from collections import defaultdict def parse_formula(formula): \\"Recursive function to parse the formula inside brackets\\" stack = [[]] i = 0 while i < len(formula): if formula[i] == \'(\': stack.append([]) i += 1 elif formula[i] == \')\': number = \'\' i += 1 while i < len(formula) and formula[i].isdigit(): number += formula[i] i += 1 multiplier = int(number) if number else 1 elements = stack.pop() for el in elements: el[1] *= multiplier stack[-1].extend(elements) else: element = formula[i] i += 1 if i < len(formula) and formula[i].islower(): element += formula[i] i += 1 number = \'\' while i < len(formula) and formula[i].isdigit(): number += formula[i] i += 1 count = int(number) if number else 1 stack[-1].append([element, count]) return stack[0] def count_elements(elements): element_count = defaultdict(int) for element, count in elements: element_count[element] += count return element_count parsed_formula = parse_formula(formula) element_count = count_elements(parsed_formula) sorted_elements = sorted(element_count.items()) return \'\'.join(f\\"{el}{count}\\" for el, count in sorted_elements) # Example print(count_of_atoms(\\"K4(ON(SO3)2)2\\")) # K4N2O14S4"},{"question":"You are given an m x n binary matrix `grid`, where `0` represents an empty cell and `1` represents a blocked cell. You start at the top-left corner of the grid (0, 0) and need to reach the bottom-right corner (m-1, n-1). You can only move right or down. Your task is to determine the number of distinct paths from the start to the destination while avoiding blocked cells. If there is no valid path, return 0. Return _the number of distinct paths_ from the top-left corner to the bottom-right corner of the grid. Since the number of paths can be large, return the answer **modulo** `10^9 + 7`.","solution":"def num_of_paths(grid): MOD = 10**9 + 7 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[m-1][n-1]"},{"question":"You are given a binary tree in which each node contains a value that can be 0 or 1. Your task is to prune the tree such that every subtree (including the entire tree) that does not contain a 1 gets removed. For example, given the binary tree: ``` 1 / 0 0 / 1 1 ``` You should return: ``` 1 / 0 0 / 1 1 ``` **Note:** The pruned tree should only contain nodes whose subtree contains the value 1. Return the pruned binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root): Prunes the tree such that every subtree that does not contain a 1 gets removed. :param root: TreeNode, the root of the binary tree. :return: TreeNode, the root of the pruned binary tree. if not root: return None root.left = pruneTree(root.left) root.right = pruneTree(root.right) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"You are given an array of integers `plants` where `plants[i]` represents the water requirement of the `i-th` plant in a row. You have an infinite amount of water in a watering can of capacity `k`. You need to water the plants in the given order. However, you can fill your can from a river at any time with the constraint that you cannot carry more water than the specified `k` capacity. If you water a plant and the remaining water in the can is less than the plant’s requirement, you must refill the can before continuing to water the remaining plants. Determine the minimum number of refills required to water all the plants in the row. Return the number of refills needed.","solution":"def min_refills(plants, k): Returns the minimum number of refills required to water all the plants. Parameters: plants (list): List of integers where plants[i] represents the water requirement of the i-th plant. k (int): Watering can capacity. Returns: int: Minimum number of refills required. current_water = k # Start with a full can refills = 0 for requirement in plants: if requirement > current_water: # If the current requirement is more than the remaining water, refill the can refills += 1 current_water = k # Refill the can current_water -= requirement # Water the plant return refills"},{"question":"You are given an integer array `arr` representing a permutation of numbers from `1` to `arr.length`. You need to determine if you can rearrange the elements of `arr` such that the resulting array forms a consecutive sequence starting from `1` up to `arr.length`. In other words, return `true` if the array can be rearranged to be in the form `[1, 2, 3, ..., arr.length]`, otherwise return `false`.","solution":"def is_consecutive_sequence(arr): Determines if the array can be rearranged to form a consecutive sequence starting from 1 to len(arr). :param arr: List[int] - an integer array representing a permutation of numbers from 1 to len(arr) :return: bool - True if the array can be rearranged to form [1, 2, 3, ..., len(arr)], otherwise False return sorted(arr) == list(range(1, len(arr) + 1))"},{"question":"Given a **matrix** filled with non-negative integers, assume you are initially positioned at the top-left corner of the matrix. Your goal is to reach the bottom-right corner of the matrix. You can only move **either down or right** at any point in time. Return _the **maximum** sum of all numbers along your path_ from the top-left corner to the bottom-right corner.","solution":"def max_path_sum(matrix): Given a matrix filled with non-negative integers, find the maximum sum of all numbers along the path from the top-left to the bottom-right corner, moving only right or down. if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Create a dp array with the same dimensions as the matrix dp = [[0] * cols for _ in range(rows)] # Initialize the starting point dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[rows-1][cols-1]"},{"question":"Given two integers `n` and `k`, return _the number of compositions of the integer_ `n` _into exactly_ `k` _parts (each part being a positive integer)_. A composition of `n` into `k` parts is a way of writing `n` as the sum of `k` positive integers. The order of the parts matters in compositions. Since the answer may be very large, return it **modulo** `10^9 + 7`.","solution":"def count_compositions(n, k): Returns the number of compositions of the integer n into exactly k parts (each part being a positive integer), modulo 10^9 + 7. MOD = 10**9 + 7 # Initialize a dp array where dp[i][j] represents the number of ways to write i as the sum of j positive integers dp = [[0] * (k + 1) for _ in range(n + 1)] # There\'s only one way to write 0 using 0 parts: using no parts at all dp[0][0] = 1 # Fill the dp array for i in range(1, n + 1): for j in range(1, k + 1): dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD return dp[n][k]"},{"question":"Given a list of integers `heights` representing the heights of buildings, where `heights[i]` is the height of the `i`th building, you need to determine how many buildings have an ocean view. A building has an ocean view if all the buildings to its right are shorter in height. Return _the number of buildings that have an ocean view_.","solution":"def find_buildings_with_ocean_view(heights): Returns the number of buildings that have an ocean view. A building has an ocean view if all the buildings to its right are shorter. :param heights: List[int] - A list of integers representing the heights of buildings :return: int - The number of buildings that have an ocean view if not heights: return 0 count = 1 # The last building always has an ocean view max_height = heights[-1] for i in range(len(heights) - 2, -1, -1): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"You are given a 2D grid `grid` of size `m x n` representing a map of land (`1`) and water (`0`). The grid is surrounded by an imaginary border of water. An island is formed by connecting adjacent lands horizontally or vertically. The grid consists of exactly one island. Each cell is either a previously visited cell, represented by `\'#\'`, or an unvisited cell, indicated by its original value (`1` or `0`). When you encounter a land cell (`1`), you can start a depth-first search process to mark the entire island as visited. Your task is to return the number of initial land cells that form the perimeter of the island, where the perimeter is defined as the number of land cells that are adjacent to water.","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given 2D grid. def count_perimeter(i, j): perimeter = 0 if i == 0 or grid[i-1][j] == 0: perimeter += 1 if i == len(grid)-1 or grid[i+1][j] == 0: perimeter += 1 if j == 0 or grid[i][j-1] == 0: perimeter += 1 if j == len(grid[0])-1 or grid[i][j+1] == 0: perimeter += 1 return perimeter total_perimeter = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: total_perimeter += count_perimeter(i, j) return total_perimeter"},{"question":"Write a function that takes a list of integers and returns the longest increasing subsequence (LIS). The subsequence consists of elements from the list that are in increasing order and form a contiguous segment from the original list, not necessarily consecutive elements. The function should return the length of the LIS found.","solution":"def longest_increasing_subsequence(nums): if not nums: return 0 # Initialize lengths list with 1 as the smallest LIS has at least one element lis = [1] * len(nums) # Iterate over each number in the list for i in range(1, len(nums)): # Compare with all previous numbers for j in range(i): # If the current number is greater than the previous one and the LIS ending with the previous one +1 is # greater than current LIS ending at the current index if nums[i] > nums[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Find the maximum value in the lis array which represents the longest increasing subsequence return max(lis)"},{"question":"You are given a string `s` consisting of lowercase English letters. Return _a new string where each character in `s` that is a vowel (`\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, `\'u\'`) is replaced by the next vowel in the sequence (`\'a\'` -> `\'e\'`, `\'e\'` -> `\'i\'`, `\'i\'` -> `\'o\'`, `\'o\'` -> `\'u\'`, `\'u\'` -> `\'a\'`). Non-vowel characters should remain unchanged._","solution":"def replace_vowels(s): Replaces each vowel in the string s with the next vowel in the sequence. vowel_map = {\'a\': \'e\', \'e\': \'i\', \'i\': \'o\', \'o\': \'u\', \'u\': \'a\'} result = [] for char in s: if char in vowel_map: result.append(vowel_map[char]) else: result.append(char) return \'\'.join(result)"},{"question":"You are given a list of `n` integers `nums`, where each integer represents the number of available seats in a row. You need to group all the rows into the minimum number of rectangular sections such that each section contains rows with equal number of seats. Return the minimum number of sections required. You may assume that all rows with the same number of seats are contiguous in the list `nums`.","solution":"def min_sections(nums): Returns the minimum number of sections required to group rows with equal number of seats together. Parameters: nums (list): a list of integers representing the number of available seats in each row. Returns: int: the minimum number of sections required. if not nums: return 0 # Initialize the count of sections. sections = 1 for i in range(1, len(nums)): if nums[i] != nums[i - 1]: sections += 1 return sections"},{"question":"Given a list of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...]` (s_i < e_i), find the minimum number of conference rooms required. Implement the function `minMeetingRooms(intervals: List[List[int]]) -> int`, which takes a list of intervals and returns the minimum number of conference rooms needed to hold all the meetings.","solution":"def minMeetingRooms(intervals): if not intervals: return 0 start_times = sorted(interval[0] for interval in intervals) end_times = sorted(interval[1] for interval in intervals) start_pointer = end_pointer = 0 used_rooms = 0 while start_pointer < len(intervals): if start_times[start_pointer] >= end_times[end_pointer]: used_rooms -= 1 end_pointer += 1 used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"Given a list of non-negative integers representing the heights of buildings situated along a line, return the maximum amount of water that can be trapped between the buildings after raining. Each element in the list represents the height of a building, and the width of each building (and the gap between two buildings) is `1` unit.","solution":"def max_trapped_water(heights): Function to calculate the maximum amount of water that can be trapped between buildings. :param heights: List[int] -> List of non-negative integers representing heights of buildings. :return: int -> Maximum amount of water that can be trapped. if not heights or len(heights) < 3: # If the list is empty or has less than 3 buildings, no water can be trapped return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] max_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) max_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) max_water += max(0, right_max - heights[right]) return max_water"},{"question":"Given an integer `n`, return the sum of all its digits. If the resulting sum has more than one digit, repeat the process until the sum becomes a single digit. Output this single digit result.","solution":"def sum_of_digits_until_single(n): Returns the sum of all digits of `n` until the sum becomes a single digit. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"You are provided with a **0-indexed** array `heights` of size `n` where each element represents the height of a building. Your task is to determine if the buildings can form a line where the heights are either strictly increasing or strictly decreasing. Return `true` if such an arrangement is possible, otherwise return `false`.","solution":"def can_form_line(heights): Determines if the array of building heights can form a strictly increasing or strictly decreasing line. Parameters: - heights (list of int): 0-indexed array of building heights. Returns: - bool: True if the buildings can form a strictly increasing or decreasing line, False otherwise. if len(heights) <= 1: return True increasing = all(heights[i] < heights[i + 1] for i in range(len(heights) - 1)) decreasing = all(heights[i] > heights[i + 1] for i in range(len(heights) - 1)) return increasing or decreasing"},{"question":"Given a **digit string** `s`, return the number of ways the string can be **decoded** into an alphabet where \'A\' is represented by `1`, \'B\' by `2`, ..., and \'Z\' by `26`. Note that characters like \'0\' do not map to any letter and cannot be used alone. Ensure that the decoding follows the rules of **valid groups** of one to two characters. For example, \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12).","solution":"def num_decodings(s): Returns the number of ways the string can be decoded. if not s: return 0 n = len(s) dp = [0] * (n + 1) # Base cases dp[0] = 1 # empty string can be decoded in one way dp[1] = 1 if s[0] != \'0\' else 0 # single character string cannot start with \'0\' for i in range(2, n + 1): # Check single digit decode if s[i-1] != \'0\': dp[i] += dp[i-1] # Check two digit decode two_digit = int(s[i-2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"You are given an array of integers `transactions` representing a list of transactions where `transactions[i]` is the amount spent in the `i-th` transaction. Your goal is to determine the smallest subarray (contiguous segment of the array) whose sum is equal to or greater than a given integer `target`. Return _the length of the smallest such subarray if it exists, otherwise return `-1`_.","solution":"def min_subarray_len(transactions, target): Find the length of the smallest subarray with a sum of at least target. :param transactions: List of integer transactions. :param target: Target sum. :return: Length of the smallest subarray with sum >= target or -1 if no such subarray exists. n = len(transactions) min_len = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += transactions[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= transactions[start] start += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"Given a binary tree, you need to serialize and deserialize it. Serialization is the process of converting a binary tree into a string, and deserialization is the process of converting a string back into a binary tree. Implement both `serialize` and `deserialize` functions: - `serialize(root: TreeNode) -> str`: This function converts the binary tree starting at the given `root` into a string. - `deserialize(data: str) -> TreeNode`: This function converts the given string `data` back into a binary tree. The binary tree is represented using TreeNode class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your implementations should be efficient in both time and space and should reconstruct the exact tree structure from the given serialized string.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): def helper(node): if not node: return \\"None,\\" return str(node.val) + \\",\\" + helper(node.left) + helper(node.right) return helper(root) def deserialize(data): def helper(data_list): if data_list[0] == \\"None\\": data_list.pop(0) return None root = TreeNode(int(data_list.pop(0))) root.left = helper(data_list) root.right = helper(data_list) return root data_list = data.split(\\",\\") root = helper(data_list) return root"},{"question":"You are given an array `arr` of integers and an integer `k`. The array `arr` contains at least two distinct elements. Your task is to find the `k`-th smallest number in the array using the Quickselect algorithm, an optimization of the QuickSort algorithm. The Quickselect algorithm works by choosing a pivot and partitioning the array into elements less than the pivot, the pivot itself, and elements greater than the pivot. It then recursively narrows down which partition contains the `k`-th smallest element until it finds it. Implement the function `kthSmallest(arr, k)` that takes in the array `arr` and the integer `k`, and returns the `k`-th smallest element in the array.","solution":"import random def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot_index = partition(arr, low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) def kthSmallest(arr, k): Returns the k-th smallest element in the array. if k < 1 or k > len(arr): raise ValueError(\\"k is out of bounds of the array length.\\") return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"You are given a binary tree with `n` nodes labeled from `1` to `n`. Each node has a unique value and two pointers, `left` and `right`, that point to its left and right children, respectively. A node is considered a **good node** if, in the path from the root to the node, there are no nodes with a value greater than the node\'s value. Implement a function that returns the number of good nodes in the binary tree. For example, in the binary tree: ``` 3 / 1 4 / / 3 1 5 ``` The good nodes are `3, 3, 4, and 5`.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_nodes(root): def dfs(node, max_val): if not node: return 0 is_good = node.val >= max_val max_val = max(max_val, node.val) return is_good + dfs(node.left, max_val) + dfs(node.right, max_val) return dfs(root, root.val)"},{"question":"You are given an integer array `nums` of length `n`. A permutation of the array is defined as a rearrangement of its elements. The **modulus operation** of an integer array is defined as the sum of the difference between each element and its index. Formally, for a permutation `perm` of `nums`, its modulus operation is calculated as: [ text{modulus}(perm) = sum_{i=0}^{n-1} |perm[i] - i| ] Your task is to find the permutation of `nums` that **maximizes** the modulus operation and return the maximum value. If there are multiple permutations yielding the same maximum value, return the lexicographically smallest permutation.","solution":"def max_modulus_permutation(nums): Given an integer array nums, this function finds the permutation of nums that maximizes the modulus operation: modulus(perm) = sum(|perm[i] - i| for all i) If there are multiple permutations yielding the same maximum value, return the lexicographically smallest permutation. Args: nums (List[int]): The input integer array. Returns: List[int]: The permutation that maximizes the modulus operation. nums.sort(reverse=True) return nums"},{"question":"You are given a binary tree in which each node contains an integer value. Write a function that collects the node values into a list arranged by levels, starting from the bottom-level upwards. This is an example of a bottom-up level order traversal. The structure of the tree is given by the following class definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement the function `def levelOrderBottom(root: TreeNode) -> List[List[int]]`. The returned list should contain the node values arranged by levels, starting from the bottom-level upwards. For example, if you have the following tree: ``` 3 / 9 20 / 15 7 ``` The function should return `[[15, 7], [9, 20], [3]]`.","solution":"from collections import deque from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderBottom(root: TreeNode) -> List[List[int]]: if not root: return [] result = deque() queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.appendleft(level_nodes) return list(result)"},{"question":"Given an array of integers `arr`, write a function that returns the length of the longest subarray consisting of the same repeating element. If the array is empty, return 0. The subarray must consist of contiguous elements from the original array. For example, for the input array `[1, 2, 2, 2, 3, 4, 4, 4, 4, 5]`, the function should return 4, as the longest subarray of repeating elements is `[4, 4, 4, 4]`. [Question 4]:","solution":"def longest_subarray_length(arr): Returns the length of the longest subarray consisting of the same repeating element. If the array is empty, return 0. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(max_length, current_length)"},{"question":"You are given an array `arr` of integers and an integer `m`. Your task is to check if the array can be divided into `m` non-empty contiguous subarrays such that the sum of each subarray is equal. If it is possible, return `true`; otherwise, return `false`.","solution":"def can_divide_into_subarrays_with_equal_sum(arr, m): Check if the array can be divided into m non-empty contiguous subarrays with equal sum. Parameters: arr (list): List of integers m (int): Number of subarrays Returns: bool: True if possible, False otherwise if m <= 0: return False total_sum = sum(arr) if total_sum % m != 0: return False target_sum = total_sum // m current_sum = 0 count = 0 for num in arr: current_sum += num if current_sum == target_sum: count += 1 current_sum = 0 return count == m"},{"question":"Given a string `s` containing only lowercase letters, you need to partition the string into as many parts as possible so that each letter appears in at most one part, and return _the lengths of these parts in a list_. Note that a partitioning is valid if and only if for each letter in the string, all occurrences of that letter are completely within exactly one part.","solution":"def partition_labels(s): Partition the string s into as many parts as possible so that each letter appears in at most one part. Return the lengths of these parts in a list. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"You are given an array `projects` where each element represents the cost of a project. You have a budget of `B` and your goal is to fund as many projects as possible without exceeding your budget. Each project can either be fully funded or not funded at all (no partial funding is allowed). Return _the **maximum number** of projects that can be funded within the budget_. Note: The cost of each project and the total budget are positive integers.","solution":"def max_projects_funded(projects, B): Returns the maximum number of projects that can be funded within the given budget B. :param projects: List[int] - a list of integers representing the cost of each project :param B: int - the total budget available :return: int - the maximum number of projects that can be funded projects.sort() funded_projects = 0 current_budget = 0 for cost in projects: if current_budget + cost <= B: current_budget += cost funded_projects += 1 else: break return funded_projects"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n-1`. Each node has zero or more outgoing edges represented by an `n x n` adjacency matrix `graph`, where `graph[i][j] == 1` indicates a directed edge from node `i` to node `j`, and `graph[i][j] == 0` indicates no direct edge from `i` to `j`. Find the number of strongly connected components in the graph. A strongly connected component is a maximal subgraph in which any two vertices are reachable from each other. Return the number of strongly connected components.","solution":"from collections import defaultdict def find_scc_count(graph): Finds the number of strongly connected components (SCCs) in a graph. Parameters: graph (List[List[int]]): n x n adjacency matrix where graph[i][j] == 1 indicates a directed edge from node i to node j, and graph[i][j] == 0 indicates no direct edge from node i to node j. Returns: int: The number of strongly connected components in the graph. def dfs(v, visited, stack): visited[v] = True for i in range(len(graph)): if graph[v][i] == 1 and not visited[i]: dfs(i, visited, stack) stack.append(v) def transpose_graph(): return [[graph[j][i] for j in range(len(graph))] for i in range(len(graph))] def fill_order(): visited = [False] * len(graph) stack = [] for i in range(len(graph)): if not visited[i]: dfs(i, visited, stack) return stack def dfs_on_transpose(v, visited): visited[v] = True for i in range(len(transposed_graph)): if transposed_graph[v][i] == 1 and not visited[i]: dfs_on_transpose(i, visited) # Step 1: Fill vertices in stack according to their finishing times stack = fill_order() # Step 2: Create a transposed graph transposed_graph = transpose_graph() # Step 3: Do DFS on transposed graph in the order defined by the stack visited = [False] * len(graph) strongly_connected_components = 0 while stack: i = stack.pop() if not visited[i]: dfs_on_transpose(i, visited) strongly_connected_components += 1 return strongly_connected_components"},{"question":"Given a linked list `head`, determine if the linked list has a cycle in it. A linked list has a cycle if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, the `pos` is used to denote the index of the node that tail\'s `next` pointer is connected to. **Note that `pos` is not passed as a parameter.** Return `true` _if there is a cycle in the linked list_. Otherwise, return `false`. **Follow up**: Can you solve it using O(1) (i.e. constant) memory?","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determines if the linked list has a cycle. :param head: ListNode, the head of the linked list :return: Boolean, True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"Given a **0-indexed** binary array `nums`, find the maximum length of a contiguous subarray with an equal number of `0` and `1`. Return _an integer_ representing the length of such subarray. If there are multiple such subarrays, any of them can be considered. Your solution must have a time complexity of O(n).","solution":"def findMaxLength(nums): Given a 0-indexed binary array nums, find the maximum length of a contiguous subarray with an equal number of 0 and 1. Returns an integer representing the length of such subarray. count_map = {0: -1} count = 0 max_length = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"You are given a string `s` and a list of strings `patterns`. You need to determine if any of the strings in `patterns` can be found as a substring in `s`. If at least one pattern exists in `s`, return the length of the longest pattern found. If no patterns are found, return `-1`.","solution":"def longest_pattern_length(s, patterns): Returns the length of the longest pattern found in string s. If no patterns are found, returns -1. max_length = -1 for pattern in patterns: if pattern in s: max_length = max(max_length, len(pattern)) return max_length"},{"question":"You are given two integer arrays `nums1` and `nums2` both of size `n` representing two sequences. Write a function to find the **Longest Common Subsequence** (LCS) between these two sequences and return its length. A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively.","solution":"def lcs_length(nums1, nums2): Returns the length of the Longest Common Subsequence (LCS) between two sequences nums1 and nums2. n = len(nums1) m = len(nums2) dp = [[0 for _ in range(m+1)] for _ in range(n+1)] for i in range(1, n+1): for j in range(1, m+1): if nums1[i-1] == nums2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[n][m]"},{"question":"You are given a string `s`. A substring of `s` is called a **palindromic substring** if it reads the same backward as forward. Return the number of **palindromic substrings** in `s`. For example, given `s = \\"ababa\\"`, the palindromic substrings are `\\"a\\"`, `\\"b\\"`, `\\"a\\"`, `\\"b\\"`, `\\"a\\"`, `\\"aba\\"`, `\\"bab\\"`, `\\"aba\\"` and the function should return `9`.","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the string s. n = len(s) count = 0 # Helper function to expand around center def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd-length palindromes (single character center) expand_around_center(i, i) # Even-length palindromes (two character center) expand_around_center(i, i + 1) return count"},{"question":"You are given two arrays of integers `nums1` and `nums2` sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums2` into `nums1` as one sorted array. You must do this by modifying `nums1` in-place to hold the result.","solution":"def merge(nums1, m, nums2, n): Merges array nums2 into array nums1 in-place. nums1 has a size of m + n, where the first m elements are valid and the remaining elements are 0. # Start from the end of the arrays while m > 0 and n > 0: # Place the larger element at the end of nums1 if nums1[m-1] > nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 # If nums2 is not exhausted, copy remaining elements to nums1 while n > 0: nums1[n-1] = nums2[n-1] n -= 1"},{"question":"Given a string `s`, you are tasked with removing all duplicate letters from the string while preserving the order of the characters and ensuring that the resulting string is the smallest lexicographical order possible. Return the resulting string after removing the duplicates.","solution":"def remove_duplicate_letters(s): Given a string s, remove the duplicate letters such that every letter appears once and only once, and return the smallest in lexicographical order that can result from removing the duplicate letters. stack = [] seen = set() last_occurrence = {char: i for i, char in enumerate(s)} for i, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and i < last_occurrence[stack[-1]]: seen.discard(stack.pop()) seen.add(char) stack.append(char) return \'\'.join(stack)"},{"question":"Given a **0-indexed** integer array `nums`, return the maximum difference between any pair of indices `(i, j)` such that `i < j` and `nums[i] < nums[j]`. If no such pair exists, return `-1`.","solution":"def maximum_difference(nums): Given a 0-indexed integer array `nums`, return the maximum difference between any pair of indices (i, j) such that i < j and nums[i] < nums[j]. If no such pair exists, return -1. max_diff = -1 min_value = nums[0] for j in range(1, len(nums)): if nums[j] > min_value: max_diff = max(max_diff, nums[j] - min_value) min_value = min(min_value, nums[j]) return max_diff"},{"question":"You are given an integer array `heights` representing the heights of buildings in a city. Arrange the buildings such that the skyline formed shows the maximum possible number of buildings when viewed from the front in silhouette form. You can change the order of buildings but cannot change their heights. Return _the maximum number of buildings that can be seen in the skyline_.","solution":"def max_visible_buildings(heights): Arrange the buildings to form the maximum possible number of buildings visible in the skyline silhouette. # To maximize the number of visible buildings, we need to maintain strictly increasing heights. heights.sort() visible_count = 0 max_height = 0 for height in heights: # A building is only visible if it is taller than all previous buildings. if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given a list of integers `lst` where each integer appears either once or twice. Sort the list in ascending order such that the integers that appear once come before the integers that appear twice. If two integers appear the same number of times, they should be sorted based on their value. Return the sorted list. For example, given the input list `lst = [4, 1, 2, 1, 3, 2, 4]`, the output should be `[3, 1, 2, 4, 1, 2, 4]`.","solution":"def custom_sort(lst): from collections import Counter # Count the frequency of each element counts = Counter(lst) # Separate elements that appear once and twice once = [x for x in lst if counts[x] == 1] twice = [x for x in lst if counts[x] == 2] # Remove duplicates from the \'twice\' list and sort both lists once_sorted = sorted(set(once)) twice_sorted = sorted(set(twice)) # Return the combined list result = once_sorted + twice_sorted * 2 return result"},{"question":"Given a binary tree, return the values of its nodes in zigzag level order traversal. (that is, from left to right, then right to left for the next level and alternate between). You must write an algorithm with `O(n)` runtime complexity, where `n` is the number of nodes in the tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root): Returns the values of nodes in a binary tree in zigzag level order. if not root: return [] results = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) current_level = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: current_level.append(node.val) else: current_level.appendleft(node.val) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) results.append(list(current_level)) left_to_right = not left_to_right return results"},{"question":"You are given an integer array `points` of length `n` where `points[i]` represents the point value of the `i-th` game. You have been challenged to play these games sequentially while following specific rules to maximize your total score. The rules are: - If you choose to play a game at index `i` and win, you earn `points[i]` points. However, you must skip the next game (`i + 1` index) as a penalty for playing this game. - Alternatively, you can choose to skip the game at index `i` and proceed to the next game. Determine the maximum points you can earn by strategically deciding which games to play and which to skip. Return the maximum points that can be earned under the given constraints.","solution":"def max_points(points): n = len(points) if n == 0: return 0 if n == 1: return points[0] # dp[i] will store the maximum points we can get till index i dp = [0] * n dp[0] = points[0] if n > 1: dp[1] = max(points[0], points[1]) for i in range(2, n): dp[i] = max(dp[i-1], points[i] + dp[i-2]) return dp[-1]"},{"question":"You are given a binary tree in the form of an array `tree`, where each element represents a node\'s value in level order traversal of the tree (null nodes are represented by -1). Your task is to determine if the tree is a valid Binary Search Tree (BST). A Binary Search Tree is defined as follows: * The left subtree of a node contains only nodes with keys less than the node\'s key. * The right subtree of a node contains only nodes with keys greater than the node\'s key. * Both the left and right subtrees must also be binary search trees. Return _a boolean_ `isValidBST` _indicating whether the given binary tree is a valid BST or not_.","solution":"def isValidBST(tree): Returns whether the given binary tree is a valid Binary Search Tree (BST). def isValidBSTHelper(tree, index, left, right): if index >= len(tree) or tree[index] == -1: return True value = tree[index] if not (left < value < right): return False left_index = 2 * index + 1 right_index = 2 * index + 2 return (isValidBSTHelper(tree, left_index, left, value) and isValidBSTHelper(tree, right_index, value, right)) return isValidBSTHelper(tree, 0, float(\'-inf\'), float(\'inf\'))"},{"question":"You are given a string `s` consisting of lowercase English letters. Define the **weight** of a substring to be the number of **distinct** letters in the substring. Calculate the **maximum weight** of all substrings of `s` that have length `k`. Return _the maximum weight possible_.","solution":"def max_weight_substring(s, k): Calculates the maximum weight of all substrings of s with length k. :param s: Input string consisting of lowercase English letters :param k: Length of the substrings to consider :return: Maximum weight of all substrings of s with length k if not s or k <= 0 or k > len(s): return 0 max_weight = 0 for i in range(len(s) - k + 1): substring = s[i:i+k] distinct_chars = set(substring) max_weight = max(max_weight, len(distinct_chars)) return max_weight"},{"question":"Given a list of strings `words` and a string `s`, return `True` if `s` can be formed by concatenating some of the words in the list, without reusing any word from the list. Otherwise, return `False`.","solution":"def can_form_string(words, s): Returns True if string s can be formed by concatenating some of the words in the list, without reusing any word from the list. Otherwise, returns False. def backtrack(remaining, words): if not remaining: return True for i, word in enumerate(words): if remaining.startswith(word): if backtrack(remaining[len(word):], words[:i] + words[i+1:]): return True return False return backtrack(s, words)"},{"question":"You are given an array `schedule` representing the schedule of a group of employees, where `schedule[i]` is a list of intervals representing the working hours of the ith employee.Each interval is represented as a light `[start, end]` where `start` is the start time of the interval and `end` is the end time of the interval (both in the format `HH:MM`). Your task is to find and return the list of time intervals in which there is no employee working. In other words, return the list of free time intervals. Each free time interval should be represented as a list `[start, end]`, where `start` is the start time and `end` is the end time of the interval.","solution":"from typing import List import itertools def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: if not intervals: return [] # Sort intervals by starting time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] # If the current interval overlaps with the merged last interval if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged.append(current) return merged def find_free_time(schedule: List[List[List[str]]]) -> List[List[str]]: working_intervals = [] # Convert all intervals to minutes for employee_schedule in schedule: for interval in employee_schedule: start_hour, start_minute = map(int, interval[0].split(\\":\\")) end_hour, end_minute = map(int, interval[1].split(\\":\\")) start = start_hour * 60 + start_minute end = end_hour * 60 + end_minute working_intervals.append([start, end]) # Merge overlapping intervals merged_intervals = merge_intervals(working_intervals) # Find gaps between the merged intervals free_intervals = [] for i in range(1, len(merged_intervals)): start_free = merged_intervals[i-1][1] end_free = merged_intervals[i][0] if end_free > start_free: free_intervals.append([start_free, end_free]) # Convert minutes back to HH:MM def minutes_to_time(minutes): hour = minutes // 60 minute = minutes % 60 return f\\"{hour:02}:{minute:02}\\" free_intervals_str = [[minutes_to_time(start), minutes_to_time(end)] for start, end in free_intervals] return free_intervals_str"},{"question":"Given an array of integers `arr` and an integer `k`, modify the array in such a way that every element in the array becomes `arr[i] % k`. After modifying the array, sort it in non-decreasing order. Return the transformed and sorted array.","solution":"def transform_and_sort(arr, k): Modifies the array such that each element becomes arr[i] % k, and then sorts the array. Parameters: arr (list): List of integers. k (int): The integer by which we take the modulus of each element. Returns: list: Transformed and sorted array. transformed_arr = [x % k for x in arr] transformed_arr.sort() return transformed_arr"},{"question":"You are given a string `s` representing a sequence of characters, and a list of words `dict`. Your task is to determine if `s` can be segmented into a sequence of one or more dictionary words from `dict`. Return `true` if it is possible to segment the string as per the dictionary, otherwise return `false`. * For example, given the string `s = \\"leetcode\\"` and the dictionary `dict = [\\"leet\\", \\"code\\"]`, the function should return `true` because `s` can be segmented into \\"leet\\" and \\"code\\". * Another example, given the string `s = \\"applepenapple\\"` and the dictionary `dict = [\\"apple\\", \\"pen\\"]`, the function should return `true` as \\"applepenapple\\" can be segmented into \\"apple\\", \\"pen\\", and \\"apple\\". * For `s = \\"catsandog\\"` and `dict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]`, the function should return `false` because there is no way to segment \\"catsandog\\" using the given dictionary. The function signature is: ```python def can_segment_string(s: str, dict: List[str]) -> bool: ```","solution":"from typing import List def can_segment_string(s: str, dict: List[str]) -> bool: Returns `True` if the string `s` can be segmented into one or more words from `dict`, else returns `False`. word_set = set(dict) # Convert list to set for faster lookup dp = [False] * (len(s) + 1) dp[0] = True # Initial condition: empty string can be segmented # Traverse through all substrings of `s` for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break # No need to further check if we found a valid decomposition return dp[len(s)]"},{"question":"You are given two integers `a` and `b` which represent the dimensions of a grid (height and width respectively). Each cell in the grid contains a value representing whether it is part of an island (1) or water (0). Two cells are considered part of the same island if they are both 1 and are adjacent horizontally or vertically (not diagonally). Write a function to count the number of islands in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. **Function signature:** ```python def countIslands(grid: List[List[int]]) -> int: ``` **Example:** ``` Input: grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] Output: 3 ``` Explanation: - There are three islands in the grid. - The first island is formed by the 1s in the top-left corner. - The second island is the single 1 in the middle. - The third island is formed by the two 1s in the bottom-right corner.","solution":"from typing import List def countIslands(grid: List[List[int]]) -> int: Counts the number of islands in a given grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Parameters: grid (List[List[int]]): 2D list representing the grid where 1 represents land and 0 represents water. Returns: int: The number of islands. if not grid or not grid[0]: return 0 def dfs(i, j): Depth-first search to mark the visited land cells. if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark this cell as visited dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: num_islands += 1 dfs(i, j) return num_islands"},{"question":"Given a string `s` consisting of lowercase letters, you need to remove the minimum number of characters from `s` so that any two adjacent characters are different. Return the minimum number of characters you need to remove. For example, for `s = \\"aaabbb\\"`, the result would be `4` because you need to remove `2 \'a\'s` and `2 \'b\'s` to get \\"ab\\". For `s = \\"ababab\\"`, the result would be `0` because the string is already valid.","solution":"def min_removals_to_avoid_adjacent_duplicates(s): Returns the minimum number of characters that need to be removed from s so that no two adjacent characters are the same. if not s: return 0 count = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 return count"},{"question":"You are given a list of strings, where each string corresponds to a sequence of operations applied to an initially empty string. Each operation is one of the following: - \'A x\' (Appends character `x` to the end of the string) - \'D\' (Deletes the last character of the string) - \'R\' (Returns the current string) Your task is to implement a function that takes this list of operations and returns a list of the results of all \'R\' operations in the order in which they appear. If there are no \'R\' operations in the input, return an empty list.","solution":"def process_operations(operations): Processes a list of operations and returns the results of \'R\' operations. Args: operations (list of str): A list where each element is a string corresponding to an operation. Returns: list of str: A list of strings which are the results of \'R\' operations. result = [] current_string = \\"\\" for operation in operations: if operation.startswith(\'A \'): current_string += operation[2] elif operation == \'D\': current_string = current_string[:-1] elif operation == \'R\': result.append(current_string) return result"},{"question":"You are given a **0-indexed** integer array `prices` representing the prices of products in a store. You also have an integer `discount` representing a percentage discount. You want to apply this discount to the prices but only to the first `k` products in the array. However, the discount can be applied to a continuous substring (subarray) of products, and you must maximize the total savings. Return _the **maximum** savings possible by applying the discount to any continuous substring of length `k` in the array_ `prices`_. If there are no such subarrays of length `k`, return_ `0`.","solution":"def maximum_savings(prices, discount, k): if k > len(prices): return 0 max_saving = 0 discount = discount / 100 for i in range(len(prices) - k + 1): subarray = prices[i:i+k] savings = sum(subarray) * discount max_saving = max(max_saving, savings) return max_saving"},{"question":"You are given an array of integers `arr` and an integer `x`. Your task is to determine if there exists a subarray of `arr` with length `3` whose sum is greater than `x`. A subarray is a contiguous part of an array. Return _`True`_ if such a subarray exists, and _`False`_ otherwise.","solution":"def subarray_sum_greater_than_x(arr, x): Determines if there exists a subarray with length 3 whose sum is greater than x. :param arr: List of integers :param x: Integer value to compare the sum to :return: True if there exists a subarray of length 3 with sum greater than x, False otherwise n = len(arr) if n < 3: return False # Check the sum of each subarray of length 3 for i in range(n - 2): current_sum = arr[i] + arr[i + 1] + arr[i + 2] if current_sum > x: return True return False"},{"question":"Write a function that takes a binary tree and returns the level order traversal of its nodes\' values. (i.e., from left to right, level by level). Implement the `TreeNode` and `Solution` classes as follows: * `class TreeNode:` Defines a node in the binary tree. - `__init__(self, val=0, left=None, right=None):` Initializes the node with a value and optional left and right children. * `class Solution:` Contains the method `levelOrder`. - `def levelOrder(self, root: TreeNode) -> List[List[int]]:` Given the root of the binary tree, returns a list of lists, where each sub-list represents one level of the tree.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for i in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"Given an array of integers `nums` representing the number of stones in each pile, and an integer `m`, determine if you can partition the piles into `m` non-empty subsets such that each subset has the same sum. Return `true` if it is possible to achieve such a partition, otherwise return `false`.","solution":"def canPartitionKSubsets(nums, k): total_sum = sum(nums) if total_sum % k != 0: return False target_sum = total_sum // k nums.sort(reverse=True) used = [False] * len(nums) def backtrack(idx, k, current_sum): if k == 0: return True if current_sum == target_sum: return backtrack(0, k-1, 0) for i in range(idx, len(nums)): if not used[i] and current_sum + nums[i] <= target_sum: used[i] = True if backtrack(i+1, k, current_sum + nums[i]): return True used[i] = False return False return backtrack(0, k, 0)"},{"question":"You are given a string `s` and an integer `n`. You want to encode `s` using the Run-Length Encoding scheme, where consecutive repeating characters are replaced by the character followed by the number of times it appears consecutively in `s`. If any encoded segment\'s length (i.e., the character and the count) is greater than `n`, you need to split that segment into multiple segments each of length at most `n`. For example, for `s = \\"aaabbbbcc\\"` and `n = 3`, the result would be `\\"a3b3b1c2\\"`, and for `s = \\"aaabbbcc\\"` and `n = 2`, the result would be `\\"a2a1b2b1c2\\"`. Return _the encoded string_.","solution":"def run_length_encode(s, n): Encodes the string `s` using run-length encoding with segment length limited to `n`. Parameters: s (str): The input string to be encoded. n (int): The maximum length of any encoded segment. Returns: str: The encoded string. if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: while count > n: encoded_string.append(f\\"{current_char}{n}\\") count -= n encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 while count > n: encoded_string.append(f\\"{current_char}{n}\\") count -= n encoded_string.append(f\\"{current_char}{count}\\") return \\"\\".join(encoded_string)"},{"question":"You are given a string `s` which consists of lowercase letters and an integer array `indexes` of the same length, both of which are **0-indexed**. The string `s` represents a shuffled version of another string you need to find. The array `indexes` indicates the position to which each character of the string `s` should be moved to form the correct string. Return the unshuffled (original) version of the string.","solution":"def unshuffle_string(s, indexes): Returns the original string by rearranging the characters of \'s\' using the \'indexes\' array. n = len(s) result = [\'\'] * n for i, char in enumerate(s): result[indexes[i]] = char return \'\'.join(result)"},{"question":"Given a string `s` consisting of lowercase English letters, find the length of the longest substring where every character appears an even number of times. Implement the function `int longestEvenSubstring(String s)` that accepts a string `s` and returns the length of the longest substring that meets the condition. Note: The substring must be contiguous.","solution":"def longestEvenSubstring(s): Returns the length of the longest substring where every character appears an even number of times. n = len(s) if n == 0: return 0 prefixXOR = [0] * (n + 1) xorIndex = {0: -1} max_length = 0 for i in range(n): prefixXOR[i + 1] = prefixXOR[i] ^ (1 << (ord(s[i]) - ord(\'a\'))) if prefixXOR[i + 1] in xorIndex: max_length = max(max_length, i - xorIndex[prefixXOR[i + 1]]) else: xorIndex[prefixXOR[i + 1]] = i return max_length"},{"question":"Given an array of integers `nums` and an integer target, use a combination of the elements in `nums` to see if you can sum up to the `target`. You can use each number more than once. Return _true_ if you can meet the target using the elements of the array, otherwise return _false_.","solution":"def can_sum(nums, target): Returns True if the target can be summed using elements in nums, otherwise False. Each number in nums can be used multiple times. dp = [False] * (target + 1) dp[0] = True for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer array `indices` of the same length. The string `s` is randomly shuffled such that once it is sorted according to the `indices` array, the characters will align to form the original string. Implement the `Solution` class: * `Solution(String s, int[] indices)` Initializes the object with the shuffled string `s` and the array `indices`. * `String restore()` Returns the original string by sorting the characters of `s` according to the given `indices` array.","solution":"class Solution: def __init__(self, s, indices): Initializes the object with the shuffled string s and the array indices. self.s = s self.indices = indices def restore(self): Returns the original string by sorting the characters of s according to the given indices array. original = [\'\'] * len(self.s) for i, idx in enumerate(self.indices): original[idx] = self.s[i] return \'\'.join(original)"},{"question":"You are given a 0-indexed array `heights` representing the heights of buildings in a cityscape. A building is **visible** if there are no taller buildings to its right. Return _an array of booleans where each index `i` represents whether the building at index `i` is visible_.","solution":"def find_visible_buildings(heights): Returns a list of booleans indicating if corresponding buildings are visible. A building is visible if there are no taller buildings to its right. n = len(heights) if n == 0: return [] visible = [False] * n max_height_to_right = 0 for i in reversed(range(n)): if heights[i] > max_height_to_right: visible[i] = True max_height_to_right = heights[i] return visible"},{"question":"You are given a list of strings `strs`, all of which are of the same length. Find the number of pairs of strings `(str1, str2)` such that `str1` is a permutation of `str2` (i.e., `str1` and `str2` contain the same characters in potentially different orders) and the indices of `str1` and `str2` satisfy `i < j`. Return _the count of such pairs_ in the list.","solution":"def count_permutation_pairs(strs): Returns the count of pairs of strings (str1, str2) such that str1 is a permutation of str2 and the index of str1 is less than the index of str2. from collections import Counter def is_permutation(s1, s2): return Counter(s1) == Counter(s2) count = 0 n = len(strs) for i in range(n): for j in range(i + 1, n): if is_permutation(strs[i], strs[j]): count += 1 return count"},{"question":"Given an integer array `arr` and an integer `k`, return the minimum number of elements that need to be removed from `arr` to make the array such that the absolute difference between the maximum and minimum element in the modified array is less than or equal to `k`.","solution":"def min_elements_to_remove(arr, k): Returns the minimum number of elements that need to be removed to make the difference between the maximum and minimum elements in the array less than or equal to k. arr.sort() n = len(arr) left = 0 right = 0 max_elements_to_keep = 0 while right < n: if arr[right] - arr[left] <= k: max_elements_to_keep = max(max_elements_to_keep, right - left + 1) right += 1 else: left += 1 return n - max_elements_to_keep"},{"question":"You are given two arrays of integers `A` and `B`, both of length `n`. You can perform the following operations any number of times: * Select a pair of indices `(i, j)` such that `0 <= i, j < n`. * Swap the elements `A[i]` and `B[j]`. Your goal is to make the arrays `A` and `B` identical. Return _the minimum number of swaps needed to make the arrays identical, or `-1` if it is impossible_.","solution":"def min_swaps_to_identical_arrays(A, B): Returns the minimum number of swaps needed to make arrays A and B identical, or -1 if it is impossible. from collections import Counter # First check if it\'s possible by comparing the frequency counts of both arrays if Counter(A) != Counter(B): return -1 # Count the number of positions where A[i] != B[i] swaps_needed = 0 for a_val, b_val in zip(A, B): if a_val != b_val: swaps_needed += 1 # Each swap fixes two positions, so half of the swaps_needed is the answer return swaps_needed // 2"},{"question":"You are given a string `text` and an integer array `indices`. The array `indices` contains the indices of characters in `text` that need to be removed. After removing the characters at the specified indices, return the resulting string with the remaining characters in their original order. Given the constraints of the problem, ensure your solution optimally handles potentially large strings and indices.","solution":"def remove_characters(text, indices): Removes characters from `text` at the indices specified in `indices`. The resulting string retains the order of the remaining characters. Parameters: - text: str, the input string. - indices: list of int, the indices of characters to be removed from `text`. Returns: - str, the resulting string after removal. # Convert indices list to set for O(1) lookup indices_set = set(indices) # Build the new string skipping indices specified in indices_set return \'\'.join(char for i, char in enumerate(text) if i not in indices_set)"},{"question":"You are given a 2D integer array `items` where each `items[i] = [type_i, value_i]` represents an item with a type and its associated value. Your task is to determine the maximum sum of values among all possible types. Return the type that has the maximum sum of associated values. If there is a tie, return the smallest type among them. Note that the types are positive integers. For example, given: ```plaintext items = [[1, 10], [2, 5], [1, 7], [3, 8]] ``` The output should be `1`, since type `1` has the highest sum of values (10 + 7 = 17) compared to type `2` with a sum of 5 and type `3` with a sum of 8.","solution":"def type_with_max_sum(items): Returns the type that has the maximum sum of associated values. If there is a tie, returns the smallest type among them. from collections import defaultdict type_sum = defaultdict(int) # Calculate the sum for each type for type_i, value_i in items: type_sum[type_i] += value_i # Find the type with the maximum sum max_sum = max(type_sum.values()) max_sum_types = [type_i for type_i, total in type_sum.items() if total == max_sum] return min(max_sum_types)"},{"question":"Given an array of integers `arr` and an integer `k`, rotate the array to the right by `k` steps. The array should be rotated in-place with `O(1)` extra memory. Return the modified array after the rotation.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. :param arr: List[int] - The array of integers. :param k: int - The number of steps to rotate the array. :return: List[int] - The rotated array. # Edge case handling n = len(arr) if n == 0: return arr k = k % n # In case k is greater than the length of the array # Reverse helper function def reverse(sub_arr, start, end): while start < end: sub_arr[start], sub_arr[end] = sub_arr[end], sub_arr[start] start += 1 end -= 1 # Reverse the entire array reverse(arr, 0, n - 1) # Reverse the first k elements reverse(arr, 0, k - 1) # Reverse the remaining elements reverse(arr, k, n - 1) return arr"},{"question":"Given an integer array `nums` and an integer `target`, return _the indices of the two numbers such that they add up to `target`_. You may assume that each input would have **exactly one solution**, and you may not use the same element twice. Implement the function `twoSum` that finds the solution in linear time. Evaluate the performance of your solution and explain your approach.","solution":"def twoSum(nums, target): Returns the indices of the two numbers in the array nums that add up to the target. Arguments: nums -- List of integers. target -- Integer target sum. Returns: List of two integers representing the indices of the two numbers. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return [seen[complement], i] seen[num] = i"},{"question":"You are given an integer array `arr` and an integer `m`. Your task is to partition the array into `m` non-empty subarrays such that the sum of the maximum values of these subarrays is minimized. Return the minimized sum of the maximum values of the subarrays.","solution":"def splitArray(arr, m): Partition the array into m non-empty subarrays such that the sum of the maximum values of these subarrays is minimized. :param arr: List[int] - Array of integers. :param m: int - Number of subarrays. :return: int - The minimized sum of the maximum values of the subarrays. def valid(mid): count, sum_split = 1, 0 for num in arr: if sum_split + num > mid: count += 1 sum_split = num if count > m: return False else: sum_split += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if valid(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` consisting only of letters \'a\' and \'b\'. A move consists of selecting the first occurrence of \'ab\' and swapping them to get \'ba\'. Return the string after performing the move any number of times until no more moves can be done.","solution":"def swap_ab(s): Perform the \'ab\' to \'ba\' swapping move until no more moves can be done. while \'ab\' in s: s = s.replace(\'ab\', \'ba\', 1) return s"},{"question":"You are given a directed graph represented by an adjacency list, where each node has a unique integer value. The graph contains no cycles and may be disconnected. Write a function that accepts the adjacency list of the graph and returns a list of strongly connected components (SCCs) in the graph. Each SCC should be represented as a list of node values. The SCCs should be listed in a specific order such that for every pair of SCCs (SCC1, SCC2), if there is a directed edge from any node in SCC1 to any node in SCC2, SCC1 should appear before SCC2 in the output list. **For example:** If the input adjacency list is: ``` { 1: [2], 2: [3], 3: [1], 4: [5], 5: [] } ``` The output should be: ``` [ [1, 2, 3], [4], [5] ] ``` where `[1, 2, 3]` forms one SCC, `[4]` is a singleton SCC, and `[5]` is another singleton SCC. The order ensures that for every directed edge between SCCs, the source SCC comes before the destination SCC.","solution":"from collections import defaultdict def kosaraju_scc(graph): def dfs(v, visited, stack, graph): visited.add(v) for neighbor in graph[v]: if neighbor not in visited: dfs(neighbor, visited, stack, graph) stack.append(v) def transpose(graph): t_graph = defaultdict(list) for src in graph: for dst in graph[src]: t_graph[dst].append(src) return t_graph def fill_order(graph): visited = set() stack = [] for node in graph: if node not in visited: dfs(node, visited, stack, graph) return stack def dfs_collect(v, visited, component, graph): visited.add(v) component.append(v) for neighbor in graph[v]: if neighbor not in visited: dfs_collect(neighbor, visited, component, graph) stack = fill_order(graph) t_graph = transpose(graph) visited = set() sccs = [] while stack: v = stack.pop() if v not in visited: component = [] dfs_collect(v, visited, component, t_graph) sccs.append(sorted(component)) return sorted(sccs, key=lambda x: x[0]) # Example usage graph = { 1: [2], 2: [3], 3: [1], 4: [5], 5: [] } print(kosaraju_scc(graph)) # Output: [[1, 2, 3], [4], [5]]"},{"question":"You are given a string `s` representing a sentence that contains words separated by single spaces and starting and ending with a word. Your task is to reverse the order of the words in the sentence. Note that the final output should not contain any leading or trailing spaces and the words should be separated by a single space. Return _the string with the words in reversed order_.","solution":"def reverse_words(s): Returns the input string with the words in reversed order. Parameters: s (str): The input string representing a sentence. Returns: str: The sentence with words in reversed order. # Split the string into words based on spaces words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a single string with a single space separator reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"Given a string `s` and an integer `k`, reverse the order of the first `k` characters of `s`, the order of the second `k` characters of `s`, the order of the third `k` characters of `s`, and so on. If there are fewer than `k` characters left in a segment, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original. Return the altered string as the result.","solution":"def reverseStr(s, k): Reverse the first k characters for every 2k characters in the string. :param s: input string :param k: number of characters to reverse in each segment :return: string with specified segments reversed result = [] for i in range(0, len(s), 2 * k): part1 = s[i:i + k][::-1] # Reverse first k characters part2 = s[i + k:i + 2 * k] # Leave rest as original until next 2k segment result.append(part1 + part2) return \'\'.join(result)"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house, arranged in a circle. Suppose all the houses are arranged in a circular manner. To avoid alerting the police, a thief cannot steal from two adjacent houses, including the first and last house which are adjacent due to the circular layout. Determine the maximum amount of money the thief can steal without alerting the police. Return _the maximum amount of money that can be stolen without stealing from two adjacent houses_.","solution":"def rob(nums): Returns the maximum amount of money that can be stolen without stealing from two adjacent houses. Since the houses are arranged in a circular manner, we consider two cases: 1. Including the first house and not the last. 2. Including the last house and not the first. if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] def rob_linear(houses): prev = curr = 0 for house in houses: prev, curr = curr, max(curr, prev + house) return curr # Exclude last house, include first house max1 = rob_linear(nums[:-1]) # Exclude first house, include last house max2 = rob_linear(nums[1:]) return max(max1, max2)"},{"question":"You are given a list of flight tickets represented by pairs of departure and arrival airports `[from, to]`. Use these tickets to construct an itinerary in order such that you visit all given airports and return to the starting airport. Each ticket is represented as a one-way flight from `from` airport to `to` airport. To construct the itinerary: 1. **Start from the \\"JFK\\" airport**. 2. Visit each airport exactly once. 3. If multiple valid itineraries exist, return the itinerary which has the **smallest lexical order** when read as a single string. Return the itinerary starting from \\"JFK\\" in the form of a list of airport codes. Example: ``` Input: [[\\"MUC\\", \\"LHR\\"], [\\"JFK\\", \\"MUC\\"], [\\"SFO\\", \\"SJC\\"], [\\"LHR\\", \\"SFO\\"]] Output: [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] ```","solution":"def find_itinerary(tickets): from collections import defaultdict import heapq # Build the graph graph = defaultdict(list) for frm, to in tickets: heapq.heappush(graph[frm], to) # Use stack to perform Depth-First Search (DFS) stack = [\\"JFK\\"] path = [] while stack: # Loop to ensure that we use valid tickets from current node while graph[stack[-1]]: next_dest = heapq.heappop(graph[stack[-1]]) stack.append(next_dest) path.append(stack.pop()) # The path is constructed in reverse order, so reverse it at the end return path[::-1]"},{"question":"You are given an array of integers `arr` and an integer `k`. You need to determine if the array can be split into **k** non-empty groups such that the sum of the elements in each group is the same. Return `true` if such a division is possible, or `false` otherwise.","solution":"def can_partition_k_subsets(arr, k): Determine if the array can be split into k non-empty groups such that the sum of the elements in each group is the same. Returns True if such a division is possible, otherwise False. total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k subsets = [0] * k arr.sort(reverse=True) def backtrack(index): if index == len(arr): return all(s == target_sum for s in subsets) for i in range(k): if subsets[i] + arr[index] <= target_sum: subsets[i] += arr[index] if backtrack(index + 1): return True subsets[i] -= arr[index] if subsets[i] == 0: break return False return backtrack(0)"},{"question":"Write a function `reverseWords` that takes a string `s` as input, which consists of words and whitespaces. The function should reverse the order of the words in the string while preserving whitespace and initial word order within the sentence. Words are defined as sequences of non-whitespace characters. Multiple spaces between words should be reduced to a single space in the output. The function should return the modified string. **Example:** ``` Input: s = \\" the sky is blue \\" Output: \\"blue is sky the\\" ```","solution":"def reverseWords(s): Reverses the order of the words in the string while preserving whitespace and initial word order within the sentence. Multiple spaces between words should be reduced to a single space. words = s.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"You are given two integer arrays `groupSizes` and `groupValues`, both of length `n`, where `groupSizes[i]` indicates the size of a group and `groupValues[i]` indicates the value of that group. Your task is to partition these groups into two non-empty sub-collections such that the sum of group sizes in both sub-collections are as close as possible to each other. _Return the **minimum absolute difference** between the sums of group sizes in the two sub-collections._","solution":"def find_min_diff(groupSizes, groupValues): Returns the minimum absolute difference between the sums of group sizes in the two sub-collections. total_sum = sum(groupSizes) n = len(groupSizes) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum // 2 + 1): if j >= groupSizes[i - 1]: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - groupSizes[i - 1]] else: dp[i][j] = dp[i - 1][j] closest_sum = 0 for j in range(total_sum // 2 + 1): if dp[n][j]: closest_sum = j return abs(total_sum - 2 * closest_sum)"},{"question":"You are given an array of `n` integers `arr` where all elements are in the range `[1, n]`. Some elements appear twice and others appear once. Your task is to find all the elements that appear twice in the array and return them in an array. You should implement an algorithm that runs in `O(n)` time and uses only constant extra space.","solution":"def find_duplicates(arr): This function finds all elements that appear twice in the array. It runs in O(n) time with constant extra space. duplicates = [] for i in range(len(arr)): index = abs(arr[i]) - 1 if arr[index] < 0: duplicates.append(abs(arr[i])) else: arr[index] = -arr[index] return duplicates"},{"question":"You are given a list of strings `words`. A **word square** is a set of words that forms a square grid such that the words read the same horizontally and vertically. Write a function to determine if you can arrange some of the given words into a word square. Return `true` if you can form such a square using the words, and `false` otherwise. Note that an empty grid is not considered a valid word square.","solution":"from typing import List def is_word_square(words: List[str]) -> bool: Determines if the given list of words can form a word square. if not words: return False num_words = len(words) word_length = len(words[0]) if word_length != num_words: return False for i in range(num_words): for j in range(word_length): if words[i][j] != words[j][i]: return False return True"},{"question":"You are given a sorted array of unique integers `arr` and an integer `target`. Your task is to find a pair of indices `(i, j)` such that the sum of the elements at these indices equals `target` (i.e., `arr[i] + arr[j] == target`). If such a pair exists, return it as a list `[i, j]`. If there are multiple pairs, return any one of them. If no such pair exists, return an empty list. Your solution should have a time complexity of O(n). Note: The returned indices must be distinct.","solution":"def find_pair_with_sum(arr, target): Finds and returns a pair of indices (i, j) such that arr[i] + arr[j] == target. If no such pair exists, returns an empty list. The array is assumed to be sorted and contains unique integers. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"You are given an integer array `arr` and an integer `k`. Your task is to determine whether there exists a contiguous subarray of length `k` that has the highest possible sum of elements among all contiguous subarrays of the same length. Return the starting index of such a subarray. If there are multiple subarrays with the same maximum sum, return the starting index of the first one. If `k` is greater than the length of the array, return `-1`.","solution":"def max_sum_subarray(arr, k): Returns the starting index of the contiguous subarray of length k that has the highest possible sum. If k is greater than the length of the array, returns -1. n = len(arr) if k > n: return -1 max_sum = sum(arr[:k]) current_sum = max_sum start_index = 0 for i in range(1, n - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum > max_sum: max_sum = current_sum start_index = i return start_index"},{"question":"You are given two strings `s` and `t` of equal length consisting only of lowercase letters. Your task is to transform string `s` into string `t` using exactly three types of operations, any number of times: 1. **Swap any two characters in `s`.** 2. **Change any character in `s` to any other lowercase letter.** 3. **Reverse the whole string `s`.** Return `true` if it is possible to transform `s` into `t` using the above operations, otherwise return `false`.","solution":"def can_transform(s, t): Returns True if it is possible to transform string `s` into string `t` using the given operations. return sorted(s) == sorted(t)"},{"question":"You are given a list of words. Some words can be grouped together if they are anagrams of each other. An anagram is a word formed by rearranging the letters of another, such as \\"listen\\" is an anagram of \\"silent\\". Your task is to partition the given list of words such that each group contains only anagrams, and return the list of these groups. Each group should be a list of anagrams, and groups can be returned in any order.","solution":"from collections import defaultdict def group_anagrams(words): Groups words that are anagrams of each other. Args: words (list of str): The list of words to be grouped. Returns: list of list of str: A list of groups, where each group contains anagrams. anagrams = defaultdict(list) for word in words: # Sort each word and use it as the key sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"You are given a string `s` and an array of strings `words`. Each word in `words` is a subsequence of `s`. You need to determine if the given string `s` can be split into exactly `k` non-overlapping subsequences such that each subsequence is a word in `words`. Return `true` if it is possible to split `s` into exactly `k` subsequences from `words`, otherwise return `false`. *Note:* A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def can_split_into_k_subsequences(s, words, k): Determines if s can be split into exactly k non-overlapping subsequences such that each subsequence is a word in words. :param s: string, input string :param words: list of strings, each is a subsequence of s :param k: int, the number of subsequences to split s into :return: bool, True if s can be split into exactly k non-overlapping subsequences from words, otherwise False from collections import Counter # Count the frequency of each word in `words` word_count = Counter(words) # We\'ll use a list to keep track of which words we\'ve found as subsequences found_words = [] # Helper function to check if a word is a subsequence of `s` starting at position `start` def is_subsequence(word, start): idx = start for char in word: idx = s.find(char, idx) + 1 if idx == 0: return False return True # Iterate over the words in the order they appear in `s` for word in words: if is_subsequence(word, 0): found_words.append(word) # Check if after finding all possible words we can match the count requirement found_word_count = Counter(found_words) for word in word_count: if found_word_count[word] < word_count[word]: return False return sum(word_count.values()) == k"},{"question":"You are given a binary tree represented by a list of integer values in level order traversal, where `null` represents an absent (or null) node. Your task is to determine the **maximum depth** of the binary tree. The **maximum depth** is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. Return _the maximum depth of the binary tree_.","solution":"from typing import List, Optional from collections import deque def max_depth(level_order: List[Optional[int]]) -> int: Calculate the maximum depth of a binary tree represented by a level order traversal list. if not level_order or level_order[0] is None: return 0 index = 0 level = 0 queue = deque([index]) while queue: level += 1 for _ in range(len(queue)): idx = queue.popleft() left_child_idx = 2 * idx + 1 right_child_idx = 2 * idx + 2 if left_child_idx < len(level_order) and level_order[left_child_idx] is not None: queue.append(left_child_idx) if right_child_idx < len(level_order) and level_order[right_child_idx] is not None: queue.append(right_child_idx) return level"},{"question":"A string `s` is called **good** if there are no repeated characters. Given an integer `n`, return the number of good strings of length `n` that can be formed using only lowercase English letters. A good string must have all unique characters.","solution":"import math def count_good_strings(n): Returns the number of good strings of length n that can be formed using only lowercase English letters. Good strings have all unique characters. if n > 26: return 0 return math.perm(26, n)"},{"question":"Given an integer array `nums`, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and its indices. If the array is already sorted, return an empty list.","solution":"def find_unsorted_subarray(nums): Returns the shortest continuous subarray which if sorted will make the whole array sorted. Also returns the starting and ending indices of that subarray. If the array is already sorted, returns an empty list. # Edge case for an empty array if not nums: return [] n = len(nums) left, right = None, None # Find the left boundary for i in range(n - 1): if nums[i] > nums[i + 1]: left = i break # If the array is already sorted if left is None: return [] # Find the right boundary for j in range(n - 1, 0, -1): if nums[j] < nums[j - 1]: right = j break # Find the min and max of the unsorted subarray sub_min = min(nums[left:right + 1]) sub_max = max(nums[left:right + 1]) # Expand the left boundary if needed for i in range(left): if nums[i] > sub_min: left = i break # Expand the right boundary if needed for j in range(n - 1, right, -1): if nums[j] < sub_max: right = j break return nums[left:right + 1], (left, right)"},{"question":"Given a binary search tree (BST), write a function `findNearestSmallerValue(TreeNode* root, int key)` that returns the largest value in the BST that is smaller than or equal to the given key. If no such value exists, return `-1`. The function should have an average time complexity of `O(log n)` for balanced trees. Example: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; ``` Implement the function: ```cpp int findNearestSmallerValue(TreeNode* root, int key); ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findNearestSmallerValue(root, key): Find the largest value in the BST that is smaller than or equal to the given key. If no such value exists, return -1. result = -1 while root: if root.val <= key: result = root.val root = root.right else: root = root.left return result"},{"question":"Given a list of strings `words` and a list of characters `chars`, return _the length of all words that can be formed using characters from_ `chars` _without reusing characters from_ `chars`_. Each character in_ `chars` _can only be used once for each word._","solution":"def countCharacters(words, chars): from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[c] <= chars_count[c] for c in word_count): total_length += len(word) return total_length"},{"question":"Given a binary search tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree. A BST is defined as follows: - The left subtree of a node contains only nodes with keys less than the node\'s key. - The right subtree of a node contains only nodes with keys greater than the node\'s key. - Both the left and right subtrees must also be binary search trees. Write a function that takes the root of the BST as input and returns the minimum absolute difference.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def getMinimumDifference(root): Returns the minimum absolute difference between the values of any two different nodes in the BST. def in_order_traversal(node, values): Perform in-order traversal and collect node values. if node is None: return in_order_traversal(node.left, values) values.append(node.val) in_order_traversal(node.right, values) values = [] in_order_traversal(root, values) min_diff = float(\'inf\') for i in range(1, len(values)): min_diff = min(min_diff, values[i] - values[i-1]) return min_diff"},{"question":"Write a function that takes an array of integers and an integer `k`, where `1 <= k <= array.length`, and returns the length of the longest subarray in which there are at most `k` distinct integers. For example, given the array `[1, 2, 1, 2, 3, 4, 5, 2]` and `k = 3`, the function should return `5` because the longest subarray with at most 3 distinct integers is `[1, 2, 1, 2, 3]`.","solution":"def longest_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if n * k == 0: return 0 left = 0 right = 0 hashmap = defaultdict(int) max_len = 1 while right < n: hashmap[arr[right]] += 1 while len(hashmap) > k: hashmap[arr[left]] -= 1 if hashmap[arr[left]] == 0: del hashmap[arr[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given a string `s` consisting of letters and digits. Separate digits and letters from the string such that all letters come first, followed by digits, but maintain their original order. For example, given the string `a1b2c3`, the result should be `abc123`. Return the newly formatted string.","solution":"def separate_letters_and_digits(s): Separates letters and digits from the string such that all letters come first, followed by digits, and maintain their original order. Args: s (str): The input string containing letters and digits. Returns: str: The reformatted string with all letters first followed by all digits. letters = \'\'.join([char for char in s if char.isalpha()]) digits = \'\'.join([char for char in s if char.isdigit()]) return letters + digits"},{"question":"You are given a binary tree with `n` nodes, and an integer `k`. Each node has an integer value associated with it. You need to determine if there exists a **path** in the tree that starts at the root and ends at a leaf, such that the sum of the values along the path is exactly `k`. Return `true` if such a path exists, otherwise return `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, k): Determines if there exists a path from root to leaf such that the sum of the path equals to k. Args: root (TreeNode): The root of the binary tree. k (int): The target sum. Returns: bool: True if such a path exists, False otherwise. if not root: return False # If we are at a leaf node, check if the sum equals to k if not root.left and not root.right: return k == root.val # Recur for left and right subtrees k -= root.val return has_path_sum(root.left, k) or has_path_sum(root.right, k)"},{"question":"You are given a list of strings `words` representing an English dictionary and a string `s` representing a sentence. Each word in `s` is separated by a single space. You need to determine if the sentence can be typed using letters from the given dictionary, under the constraint that each letter can only be used once. Implement the function `canTypeSentence(words: List[str], s: str) -> bool` which returns `true` if the sentence can be typed using the dictionary, and `false` otherwise.","solution":"from typing import List def canTypeSentence(words: List[str], s: str) -> bool: Returns True if the sentence `s` can be typed using the provided list of words, False otherwise. Each letter can only be used once. # Create a dictionary to count the frequency of each character in words list letter_count = {} for word in words: for letter in word: if letter not in letter_count: letter_count[letter] = 0 letter_count[letter] += 1 # Check if we can form the sentence s with the given letters for letter in s: if letter != \' \': if letter not in letter_count or letter_count[letter] == 0: return False letter_count[letter] -= 1 return True"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to split the string into the **minimum** number of substrings such that each letter appears in only one substring. Return _the list of substrings_ in the order they appear in `s`. **Note**: * You cannot rearrange the order of the characters. * Each character must appear in exactly one substring.","solution":"def split_string(s): Split the string into the minimum number of substrings such that each letter appears in only one substring. last_occurrence = {ch: idx for idx, ch in enumerate(s)} start = 0 end = 0 result = [] for idx, ch in enumerate(s): end = max(end, last_occurrence[ch]) if idx == end: result.append(s[start:end + 1]) start = end + 1 return result"},{"question":"You are given an array of integers `nums` representing elements in a circular deque. The goal is to determine the maximum sum of a subarray with at least one element within the circular array. A circular array wraps around, meaning the subarray may begin from the end of the array and continue from the start. Return _the maximum sum of any subarray within the circular deque_.","solution":"def max_subarray_sum_circular(nums): Returns the maximum sum of any subarray within the circular array nums. def kadane(arr): curr_sum = max_sum = arr[0] for num in arr[1:]: curr_sum = max(num, curr_sum + num) max_sum = max(max_sum, curr_sum) return max_sum max_kadane = kadane(nums) total_sum = sum(nums) for i in range(len(nums)): nums[i] = -nums[i] inverted_kadane = kadane(nums) max_wraparound = total_sum + inverted_kadane if max_wraparound == 0: return max_kadane else: return max(max_kadane, max_wraparound)"},{"question":"You are given two strings `s1` and `s2`. You are allowed to perform two operations on the strings: 1. Choose a character from `s1` and move it to the start of `s2`. 2. Choose a character from `s2` and move it to the start of `s1`. Determine the minimum number of operations required to make `s1` and `s2` identical. Return _the minimum number of operations needed_ or `-1` if it is impossible to make the two strings identical.","solution":"def min_operations_to_make_strings_identical(s1, s2): Determine the minimum number of operations to make the two strings identical. Returns the minimum number of operations needed or -1 if it is impossible. if sorted(s1) != sorted(s2): return -1 # Use two pointers starting from the end of s1 and s2 i, j = len(s1) - 1, len(s2) - 1 ops = 0 while i >= 0 and j >= 0: if s1[i] == s2[j]: j -= 1 else: ops += 1 i -= 1 return ops"},{"question":"You are given a list of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent intervals on the real line. Write a function to insert a new interval `newInterval = [start, end]` into `intervals` such that `intervals` is still sorted in ascending order by starti, and `intervals` still do not have any overlapping intervals (merge overlapping intervals if necessary). Return _an array_ `answer` _of intervals after the insertion_.","solution":"def insert(intervals, newInterval): Inserts a new interval into a list of non-overlapping intervals, merging if necessary. Args: intervals (List[List[int]]): List of non-overlapping intervals sorted by start time. newInterval (List[int]): The new interval to be inserted. Returns: List[List[int]]: Updated list of non-overlapping intervals. merged = [] i = 0 while i < len(intervals) and intervals[i][1] < newInterval[0]: merged.append(intervals[i]) i += 1 while i < len(intervals) and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 merged.append(newInterval) while i < len(intervals): merged.append(intervals[i]) i += 1 return merged"},{"question":"You are provided with an array of positive integers `arr` and an integer `x`. Your task is to determine if there is a subset of `arr` such that the sum of the elements of the subset is equal to `x`. Return _true_ if such a subset exists, or _false_ otherwise.","solution":"def is_subset_sum(arr, x): Determine if there is a subset of arr that sums up to x. Parameters: arr (list): List of positive integers. x (int): Target sum. Returns: bool: True if there is a subset that sums up to x, False otherwise. n = len(arr) subset = [[False for j in range(x + 1)] for i in range(n + 1)] for i in range(n + 1): subset[i][0] = True for i in range(1, n + 1): for j in range(1, x + 1): if j < arr[i-1]: subset[i][j] = subset[i-1][j] if j >= arr[i-1]: subset[i][j] = (subset[i-1][j] or subset[i-1][j-arr[i-1]]) return subset[n][x]"},{"question":"You are given an integer array `arr` and a target integer `sum`. Your task is to find all unique pairs of elements in the array whose sum equals the target integer. Each pair should be represented as a tuple `(a, b)` where `a` and `b` are elements from the array, and `a <= b`. The order of the pairs in the output does not matter. If no such pairs exist, return an empty list. Write a function `find_pairs(arr: List[int], sum: int) -> List[Tuple[int, int]]`. The function should take the integer array `arr` and the target integer `sum`, and return a list of unique pairs that add up to the target sum.","solution":"from typing import List, Tuple def find_pairs(arr: List[int], sum: int) -> List[Tuple[int, int]]: Returns a list of unique pairs (a, b) from arr such that a + b equals sum and a <= b. pairs = set() seen = set() for num in arr: complement = sum - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return list(pairs)"},{"question":"You are given an `n x n` 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). To rotate the image, you have to turn each row of the matrix into the corresponding column of the rotated matrix. Specifically, the first row of the original matrix becomes the last column of the new matrix, the second row becomes the second last column, and so on until the last row becomes the first column of the new matrix. Write a function `rotate(matrix: List[List[int]]) -> None` to rotate the given `n x n` 2D matrix in-place. This means you have to modify the input 2D matrix directly, without using an additional matrix for rotation.","solution":"from typing import List def rotate(matrix: List[List[int]]) -> None: Rotates an n x n matrix 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): An n x n 2D matrix representing an image. Returns: None: The matrix is modified in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given a list of integers `nums` and an integer `target`. Return all unique quadruples `[nums[a], nums[b], nums[c], nums[d]]` such that `0 <= a, b, c, d < nums.length`, `a`, `b`, `c`, and `d` are distinct, and `nums[a] + nums[b] + nums[c] + nums[d] == target`. The quadruples can be returned in any order.","solution":"def four_sum(nums, target): Returns all unique quadruples [nums[a], nums[b], nums[c], nums[d]] that sum up to the target. nums.sort() results, n = [], len(nums) for i in range(n-3): if i > 0 and nums[i] == nums[i-1]: # skip duplicate \'i\' continue for j in range(i+1, n-2): if j > i+1 and nums[j] == nums[j-1]: # skip duplicate \'j\' continue left, right = j+1, n-1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: results.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left+1]: # skip duplicate \'left\' left += 1 while left < right and nums[right] == nums[right-1]: # skip duplicate \'right\' right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return results"},{"question":"You are given a string `s` which may contain letters, digits, and special characters. Your task is to determine if the letters of the string can be rearranged to form a palindrome. Return `true` if it is possible to rearrange the letters of `s` to form a palindrome, otherwise return `false`. For example: * If `s = \\"aabbcc\\"`, return `true` because it can be rearranged to form \\"abcabc\\", which is a palindrome. * If `s = \\"aabbccc\\"`, return `true` because it can be rearranged to form \\"abccba\\", which is a palindrome. * If `s = \\"abc\\"`, return `false` because there is no way to rearrange the letters to form a palindrome. Note: - Ignore all non-letter characters while checking the palindrome. - Consider the case sensitivity of the letters (i.e., \'A\' and \'a\' are different characters).","solution":"from collections import Counter def can_form_palindrome(s): Determines if the letters of the string `s` can be rearranged to form a palindrome. :param s: The input string containing letters, digits, and special characters. :type s: str :return: True if the letters can be rearranged to form a palindrome, False otherwise. :rtype: bool # Filter out non-letter characters letters = [char for char in s if char.isalpha()] # Count the frequency of each letter letter_count = Counter(letters) # Count how many letters have an odd frequency odd_count = sum(1 for count in letter_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one letter with an odd frequency return odd_count <= 1"},{"question":"You are given a string `expression` that contains a mathematical expression consisting of non-negative integers and operators `+`, `-`, `*`, and `()`. Implement a function to calculate the result of the expression. You can assume that the given expression is always valid, i.e., it follows the correct syntax for mathematical expressions. Write a function `int calculate(String expression)` that computes and returns the result of the input expression. Example: ``` Input: expression = \\"3+(2*2)-1\\" Output: 6 ``` Note: You may encounter large numbers in the expression, and Python handles large integers. However, ensure your implementation manages intermediate results correctly to avoid overflow in languages with fixed-precision integers.","solution":"def calculate(expression): def update_op(op, v): if op == \'+\': stack.append(v) if op == \'-\': stack.append(-v) if op == \'*\': stack.append(stack.pop() * v) if op == \'/\': stack.append(int(stack.pop() / v)) stack = [] num, op = 0, \'+\' i = 0 while i < len(expression): if expression[i].isdigit(): num = num * 10 + int(expression[i]) elif expression[i] in \'+-*/\': update_op(op, num) num, op = 0, expression[i] elif expression[i] == \'(\': j = i braces = 0 while True: if expression[j] == \'(\': braces += 1 if expression[j] == \')\': braces -= 1 if braces == 0: break j += 1 num = calculate(expression[i + 1:j]) i = j i += 1 update_op(op, num) return sum(stack)"},{"question":"You have been provided with a list of integers `nums` and a positive integer `k`. You need to divide the list into `k` contiguous non-empty subarrays such that the maximum sum of elements among all subarrays is minimized. Return _the minimized maximum sum of the subarrays_.","solution":"def can_partition(nums, k, max_sum): current_sum = 0 required_parts = 1 for num in nums: if current_sum + num > max_sum: required_parts += 1 current_sum = num if required_parts > k: return False else: current_sum += num return True def split_array(nums, k): left = max(nums) right = sum(nums) while left < right: mid = (left + right) // 2 if can_partition(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a **0-indexed** integer array `arr` which initially contains `n` integers. Each element in the array represents the height of a block in a histogram. A rectangle can be formed within the histogram by selecting any range of consecutive blocks and taking the minimum height within that range as the height of the rectangle. The width of the rectangle is the number of blocks in the selected range. Return _the **area** of the largest rectangle that can be formed within the histogram_. For example, given the array `arr = [2, 1, 5, 6, 2, 3]`, the largest rectangle possible has an area of 10 (formed by the third and fourth blocks with heights 5 and 6).","solution":"def largestRectangleArea(heights): Calculate the area of the largest rectangle in the histogram. Parameters: heights (list[int]): A list of integers representing the heights of the histogram\'s bars Returns: int: The area of the largest rectangle that can be formed within the histogram stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a binary tree, each node has an integer value. Determine if the tree has a root-to-leaf path such that the sum of the values along the path equals a given integer `targetSum`. Return `true` if such a path exists, or `false` otherwise. The binary tree is represented as follows: `TreeNode` is a struct that contains an integer (`val`), and two pointers to `TreeNode` (`left` and `right`).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target_sum): if root is None: return False if not root.left and not root.right: return root.val == target_sum target_sum -= root.val return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum)"},{"question":"You are given a binary tree where the value of each node is either `0` or `1`. Each node has up to two children, labeled as `left` and `right`. You need to perform a specific type of traversal on this tree: 1. Start from the root node. 2. Traverse the tree in a \\"zigzag\\" manner, which means: - On level `0`, visit nodes left to right. - On level `1`, visit nodes right to left. - Continue alternating the order of visiting nodes level by level. Return _the values of the nodes in the order they are visited during this zigzag traversal_ as a list.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_traversal(root): Return the nodes\' values in a zigzag traversal order. if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [] next_level = [] for node in current_level: level_values.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_values.reverse() result.extend(level_values) current_level = next_level left_to_right = not left_to_right return result"},{"question":"Given an array of integers `arr` and an integer `k`, return the _k-th smallest **missing** positive integer_ from the array. A **missing** positive integer is defined as a positive integer that does not exist in the array. For example, if `arr` is `[2, 3, 4, 7, 11]` and `k` is `5`, the 5-th smallest missing positive integer is `9` because the sequence of missing integers starts from `1, 5, 6, 8, 9,...`.","solution":"def find_kth_missing_positive(arr, k): Returns the k-th smallest missing positive integer from the array `arr`. missing_count, current = 0, 1 arr_set = set(arr) while missing_count < k: if current not in arr_set: missing_count += 1 if missing_count < k: current += 1 return current"},{"question":"You are given a string `s` containing only lowercase English letters. You can perform an operation where you choose one character and move it to the beginning of the string. Determine the minimum number of such operations needed such that no two adjacent characters are the same. If it is impossible to achieve this, return `-1`.","solution":"from collections import Counter def min_operations_to_no_adjacent(s: str) -> int: counter = Counter(s) max_count = max(counter.values()) n = len(s) if max_count > (n + 1) // 2: return -1 else: return 0 # Further implementation needed for actual moves calculations."},{"question":"Given a **doubly linked list** which can have additional `child` pointers that point to a separate doubly linked list (and so on), flatten the list so that all nodes appear in a single-level doubly linked list. For example, if one node has a `child` pointer that points to a separate list, the entire child list should be inserted after this node, and so on. Return the head of the flattened list.","solution":"class Node: def __init__(self, val, prev=None, next=None, child=None): self.val = val self.prev = prev self.next = next self.child = child def flatten(head): if not head: return None current = head stack = [] while current: if current.child: if current.next: stack.append(current.next) current.next = current.child current.child.prev = current current.child = None if not current.next and stack: current.next = stack.pop() current.next.prev = current current = current.next return head"},{"question":"You are managing a warehouse and need to keep track of inventory. Each item in the warehouse is represented by an item code, which includes a string of **uppercase English letters** (with possible repetitions). The warehouse manager needs to periodically check the inventory against duplicate items. Your task is to write a function that takes a list of item codes and returns a list of duplicate item codes in sorted order. If no duplicates are found, return an empty list. Write a function that efficiently determines the duplicates from a given list of item codes.","solution":"def find_duplicates(item_codes): Returns a list of duplicate item codes in sorted order. Args: item_codes (list): List of item codes as strings. Returns: list: Sorted list of duplicate item codes. from collections import Counter # Count the occurrences of each item code count = Counter(item_codes) # Find the item codes that have a count greater than 1 (duplicates) duplicates = [item for item, freq in count.items() if freq > 1] # Return the duplicates in sorted order return sorted(duplicates)"},{"question":"Given a linked list, remove the N-th node from the end of the list and return its head.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the N-th node from the end of the list and returns its head. dummy = ListNode(0, head) fast = slow = dummy # Move fast ahead by n+1 steps to maintain a gap of n between slow and fast for _ in range(n + 1): fast = fast.next # Move both fast and slow until fast reaches the end while fast: fast = fast.next slow = slow.next # Slow is now pointing to the node just before the node to be removed slow.next = slow.next.next return dummy.next"},{"question":"You are given a list of words `words` where each word consists of lowercase letters. A word is called a \\"happy string\\" if there are no two consecutive letters that are the same. Your task is to determine if a given word is a \\"happy string.\\" Return `true` if the word is a \\"happy string\\" and `false` otherwise.","solution":"def is_happy_string(word): Returns True if the word is a \\"happy string\\", False otherwise. A word is a \\"happy string\\" if there are no two consecutive letters that are the same. for i in range(len(word) - 1): if word[i] == word[i + 1]: return False return True"},{"question":"Given a string `s`, return the **length** of the longest substring of `s` that contains **only unique characters**.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring of s that contains only unique characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `arr` and an integer `d`. An element in the array can **jump** to a different index `i` (0-based) within the array if the following conditions are met: * You can jump to the index `i` from the current index `j` if `arr[i] < arr[j]`. * You can only jump to the indices within the range `[j - d, j + d]` (inclusive) and should stay inside the boundaries of the array. You need to find out the maximum length of a jump sequence you can generate starting from any index. Return the maximum length of any such jump sequence.","solution":"def maxJumps(arr, d): n = len(arr) # Helper function using memoization for recursion def dfs(i): if memo[i] != -1: return memo[i] max_len = 1 # Since minimum length including the element itself is 1 # Look to the left within the boundary for j in range(i-1, max(i-d-1, -1), -1): if arr[j] < arr[i]: max_len = max(max_len, 1 + dfs(j)) else: break # Look to the right within the boundary for j in range(i+1, min(i+d+1, n)): if arr[j] < arr[i]: max_len = max(max_len, 1 + dfs(j)) else: break memo[i] = max_len return memo[i] memo = [-1] * n # Initialize memoization array with -1 max_jump_length = 0 for i in range(n): max_jump_length = max(max_jump_length, dfs(i)) return max_jump_length"},{"question":"Given a square matrix `matrix`, your task is to rotate the matrix 90 degrees clockwise in-place. This means you need to modify the matrix directly without using any extra space for another matrix. The rotation should be applied such that every row of the initial matrix becomes a column in the output matrix. For example, given the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The matrix after rotating 90 degrees clockwise should be: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Return the matrix after performing the rotation in-place.","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second, reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"Given a binary matrix `grid` where `grid[i][j]` can be either `0` or `1`, return the largest rectangle containing only `1\'s` and return the area of that rectangle. You may assume that the input grid will always have at least one element. The rectangle can be constructed using adjacent 1\'s in the grid.","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 dp = [0] * len(matrix[0]) for row in matrix: for j in range(len(row)): dp[j] = dp[j] + 1 if row[j] == \'1\' else 0 max_area = max(max_area, largestRectangleArea(dp)) return max_area def largestRectangleArea(heights): stack = [-1] max_area = 0 for i, h in enumerate(heights): while stack[-1] != -1 and heights[stack[-1]] >= h: height = heights[stack.pop()] width = i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack[-1] != -1: height = heights[stack.pop()] width = len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"You are given a 2D grid `grid` of size `m x n` representing a map, where `1` represents land and `0` represents water. You can perform an unlimited number of moves, and in one move you can either move: * Up * Down * Left * Right Your goal is to determine the largest possible size of an island, where an island is a group of `1`s connected 4-directionally (vertical or horizontal). Return the size of the largest island possible. An island\'s size is defined as the number of `1`s it contains.","solution":"def maxAreaOfIsland(grid): Given a 2D grid of 0s and 1s, returns the size of the largest island. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0 or visited[r][c]: return 0 visited[r][c] = True return 1 + dfs(r+1, c) + dfs(r-1, c) + dfs(r, c+1) + dfs(r, c-1) max_area = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"You are given a list of non-negative integers `slopes` where each integer represents the steepness of a slope. Your goal is to find the maximum number of segments a continuous subarray can be split into, where the sum of slopes in each segment is no more than `k`. Each segment must contain at least one slope. Return _the maximum number of such segments in the array_.","solution":"def max_segments(slopes, k): Returns the maximum number of segments that the slopes array can be split into, given each segment\'s sum of steepness is no more than k. :param slopes: List[int] - List of non-negative integers representing steepness. :param k: int - The maximum allowable sum of slopes in each segment. :returns: int - The maximum number of segments. n = len(slopes) start = 0 current_sum = 0 segments = 0 for end in range(n): current_sum += slopes[end] while current_sum > k and start <= end: current_sum -= slopes[start] start += 1 if current_sum <= k: segments = max(segments, end - start + 1) return segments"},{"question":"# New Question: [Question 4]: You are given an integer `n` representing the number of stairs in a staircase. You can climb either 1 or 2 stairs at a time. Write a function to compute the number of distinct ways to reach the top of the staircase. Given an integer `n`, return _the total number of distinct ways to reach the top_. Consider the following examples: - Input: n = 2; Output: 2 - Input: n = 3; Output: 3","solution":"def climbStairs(n): Returns the number of distinct ways to reach the top of a staircase with n stairs, where you can take either 1 or 2 steps at a time. if n <= 1: return 1 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"You are given an `n x n` 2D matrix representing an image, rotate the image by `90` degrees (clockwise). Implement the function `void rotate(int[][] matrix)` which rotates the matrix in-place. *Do not* use any additional matrix for rotation. Assume the given matrix is non-empty and its dimensions are `n x n`, where `1 <= n <= 20`.","solution":"def rotate(matrix): Rotates the given n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to determine the smallest index `i` such that the substring `s[0:i+1]` can be repeated one or more times to form the entire string `s`. If no such index exists, return -1. For instance, given the string `\\"abcabcabc\\"`, the output should be `2` since the substring `\\"abc\\"` can be repeated to form the entire string. If no such formation is possible, return `-1`.","solution":"def find_repeating_substring(s): Determines the smallest index i such that the substring s[0:i+1] can be repeated one or more times to form the entire string s. Returns -1 if no such index exists. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: substring = s[:i] if substring * (n // i) == s: return i - 1 return -1"},{"question":"You are given a `matrix` of integers where each row is sorted in ascending order from left to right and each column is sorted in ascending order from top to bottom. Implement a function to determine if a given integer `target` exists in the matrix. You may assume the matrix does not contain duplicate entries.","solution":"def search_matrix(matrix, target): Determines if a given integer `target` exists in the matrix. The matrix has the property of rows and columns being sorted in ascending order. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"Given a string `text`, arrange the characters so that no two adjacent characters are the same. If it is not possible, return an empty string. If there are multiple valid arrangements, return any of them.","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(text): Rearrange characters in the string so that no two adjacent characters are the same. If not possible, return an empty string. count = Counter(text) max_heap = [] for char, freq in count.items(): heappush(max_heap, (-freq, char)) prev_char, prev_freq = None, 0 result = [] while max_heap or prev_freq: if prev_freq: if not max_heap: return \\"\\" freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_char, prev_freq = char, freq + 1 return \'\'.join(result)"},{"question":"Given an undirected graph represented as an adjacency list, implement a function `is_cyclic(graph)` that determines whether the graph contains a cycle. The graph is defined such that its adjacency list is a dictionary where keys are graph vertices and values are lists of neighboring vertices. Return `True` if there is a cycle in the graph; otherwise, return `False`. ```python def is_cyclic(graph): # your code here ``` For example, given the graph: ``` { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\'], \'C\': [\'A\', \'D\'], \'D\': [\'B\', \'C\', \'E\'], \'E\': [\'D\'] } ``` The function should return `True`. Analyze the graph thoroughly to determine if any cycle exists through depth-first search (DFS) or breadth-first search (BFS) traversal techniques.","solution":"def is_cyclic(graph): Determines whether the graph contains a cycle. Parameters: - graph: a dictionary representing the adjacency list of the graph Returns: - True if the graph contains a cycle, False otherwise def dfs(vertex, parent, visited): Helper function to perform DFS and detect cycle. Parameters: - vertex: the current vertex in DFS - parent: the vertex from which the current vertex was visited - visited: a set of visited vertices Returns: - True if a cycle is detected, False otherwise visited.add(vertex) for neighbor in graph[vertex]: if neighbor not in visited: if dfs(neighbor, vertex, visited): return True elif neighbor != parent: return True return False visited = set() for vertex in graph: if vertex not in visited: if dfs(vertex, None, visited): return True return False"},{"question":"Given an array of integers representing elevation heights, find the two indices i and j such that i < j and the water trapped between these two indices (assuming no elevation exists between them) is maximized. Your function should return the maximum amount of water that can be trapped. The elevation heights are represented by non-negative integers. You must solve this problem in (O(n)) time. Example: Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The vertical lines are drawn at indices 1 and 8, the height of each line is 7, and the width between these indices is 7, so the area of water trapped is 7 * 7 = 49.","solution":"def max_area(height): Returns the maximum amount of water that can be trapped between two indices. left = 0 right = len(height) - 1 max_area = 0 while left < right: h = min(height[left], height[right]) w = right - left max_area = max(max_area, h * w) if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"Given an `m x n` matrix `board` representing a grid, where each cell can have one of three values: - `0` representing an empty cell, - `1` representing a fresh orange, - `2` representing a rotten orange, Return _the minimum number of minutes that must elapse until no cell has a fresh orange._ If this is impossible, return `-1`. Rotting occurs simultaneously every minute and cannot happen diagonally. A rotten orange rots adjacent fresh oranges (left, right, top, bottom).","solution":"from collections import deque def orangesRotting(grid): rows, cols = len(grid), len(grid[0]) queue = deque() fresh = 0 # Initialize the queue with all rotten oranges and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh += 1 # Direction vectors for the 4 possible directions (left, right, top, bottom) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] minutes = 0 # BFS starting from initially rotten oranges while queue and fresh > 0: minutes += 1 for _ in range(len(queue)): r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if nr in range(rows) and nc in range(cols) and grid[nr][nc] == 1: grid[nr][nc] = 2 queue.append((nr, nc)) fresh -= 1 return minutes if fresh == 0 else -1"},{"question":"You are given a string `s` and an array of strings `words`. The string `s` can be formed by concatenating some or all of the strings from `words` exactly once and in any order. Return _the lexicographically smallest string that can be formed_. Note: `words` may contain duplicates, and each element from `words` can be used at most once.","solution":"def smallest_lexicographic_string(s, words): Returns the lexicographically smallest string that can be formed by concatenating some or all strings from the words list exactly once. words.sort() result = \'\'.join(words) return result"},{"question":"You are given an unsorted integer array `nums` and an integer `target`. Write a function that moves all occurrences of `target` to the end of the array while maintaining the relative order of the other elements. Return the modified array. You should do this in-place without making a copy of the array.","solution":"def move_target_to_end(nums, target): Moves all occurrences of target to the end of the array while maintaining the relative order of the other elements. Args: nums: List[int] - The input array target: int - The target integer to move to the end Returns: List[int] - The modified array with all occurrences of target moved to the end non_target_index = 0 for i in range(len(nums)): if nums[i] != target: nums[non_target_index] = nums[i] non_target_index += 1 # Fill the rest of the array with the target value for i in range(non_target_index, len(nums)): nums[i] = target return nums"},{"question":"You are given a list of integers `nums` and an integer `k`. Your goal is to rearrange the elements of `nums` such that the sum of every `k` consecutive elements in the rearranged list is as large as possible. Return the largest possible sum of any `k` consecutive elements after rearranging `nums`. For example, if the input list is `[1, 3, 2, 6, 4, 5]` and `k = 3`, the output should be `15`, as the optimal arrangement is `[4, 5, 6, 3, 2, 1]` where the sum of `4 + 5 + 6` is `15`. If no such arrangement exists, return `0`.","solution":"def max_k_consecutive_sum(nums, k): Return the largest possible sum of any k consecutive elements after rearranging nums. if len(nums) < k: return 0 sorted_nums = sorted(nums, reverse=True) return sum(sorted_nums[:k])"},{"question":"You are given a binary tree in which each node contains an integer value. Define the **depth** of a node as the number of edges in the path from the root to the node. The **depth sum** of a binary tree is defined as the sum of the product of the depth of each node and its value. For example, in a binary tree where node values are `[value1, value2, value3]` at depths `[depth1, depth2, depth3]`, the depth sum would be calculated as `value1*depth1 + value2*depth2 + value3*depth3`. Return _the depth sum of the binary tree_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def depth_sum(root): Computes the depth sum of a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: int: The depth sum of the tree. def helper(node, depth): if not node: return 0 return node.val * depth + helper(node.left, depth + 1) + helper(node.right, depth + 1) return helper(root, 1)"},{"question":"You are given a list of integers `nums` representing the values of various items and an integer `target` representing the sum you need to achieve using the items. You can use an element from `nums` any number of times. Return _the number of unique combinations_ where the sum of the combination is equal to `target`. Each combination should be a sorted list of numbers, and the combinations themselves should not be repeated. Order of elements in the combination does not matter but output should be the count of unique combinations. If no combinations can achieve the target, return `0`.","solution":"def combination_sum_count(nums, target): nums.sort() dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if num <= i: dp[i] += dp[i - num] else: break return dp[target]"},{"question":"You are given an integer array `candies` where `candies[i]` represents the number of candies in the `ith` box. Each kid has a favorite number of candies they want to receive. You are also given an integer array `favorite` which represents each desired number of candies. For each kid, compute if there exists a way to choose some boxes (possibly zero) such that the sum of the number of candies in the chosen boxes equals their favorite number. Return an array `result` where `result[i]` is `true` if the `ith` kid\'s favorite number of candies can be obtained, else `false`.","solution":"def canAchieveFavoriteCandies(candies, favorite): Returns a list of boolean values indicating for each favorite number whether it can be obtained by summing any subset of the given candies. n = len(candies) max_sum = sum(candies) possible_sums = [False] * (max_sum + 1) possible_sums[0] = True # Process each candy to update the possible sums for candy in candies: for i in range(max_sum, candy - 1, -1): if possible_sums[i - candy]: possible_sums[i] = True result = [] for fav in favorite: if fav <= max_sum: result.append(possible_sums[fav]) else: result.append(False) return result"},{"question":"You are given an `m x n` 2D grid `grid` where each cell in the grid can contain either **0** (empty) or **1** (occupied). Two cells are said to be **connected** if they are adjacent horizontally or vertically. Your task is to determine the number of **disconnected clusters** of occupied cells in the grid. Return _the number of disconnected clusters of \\"1\\"s_. **Note**: * A cluster is defined as a group of **connected** \\"1\\"s. * Connectivity is limited to horizontal and vertical directions; diagonal connections are not considered. * The length of `grid` (number of rows) and the length of each row are both within the range `[1, 50]`.","solution":"def num_clusters(grid): if not grid or not grid[0]: return 0 def dfs(grid, visited, x, y): nrows, ncols = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < nrows and 0 <= ny < ncols and not visited[nx][ny] and grid[nx][ny] == 1: visited[nx][ny] = True stack.append((nx, ny)) nrows, ncols = len(grid), len(grid[0]) visited = [[False for _ in range(ncols)] for _ in range(nrows)] clusters = 0 for i in range(nrows): for j in range(ncols): if grid[i][j] == 1 and not visited[i][j]: clusters += 1 visited[i][j] = True dfs(grid, visited, i, j) return clusters"},{"question":"Given a string `s` containing only digits, return _an array of all possible strings we could create by inserting at most one plus(+) or minus(-) operator between any two adjacent digits_. Each resulting string must not start or end with a plus or minus, and the order of elements in the output does not matter. The input string will have at least two digits and at most eight digits.","solution":"def generate_expressions(s): Generates all possible strings by inserting at most one plus(+) or minus(-) operator between any two adjacent digits. n = len(s) expressions = [] # Helper function to add operators in between digits def add_operators(pos, current): if pos == n - 1: expressions.append(current + s[pos]) return add_operators(pos + 1, current + s[pos]) add_operators(pos + 1, current + s[pos] + \'+\') add_operators(pos + 1, current + s[pos] + \'-\') add_operators(0, \\"\\") return expressions"},{"question":"Design a class `RateLimiter` that controls how frequently a particular method can be executed. Implement the class with the following methods: - `RateLimiter(int maxCalls, int timeWindow)`: Initializes the `RateLimiter` object with two parameters - `maxCalls` (maximum number of calls allowed within the `timeWindow`) and `timeWindow` (allowed time window in seconds). - `boolean shouldAllow()`: Returns `true` if the method call is within the rate limits, otherwise returns `false`. The `shouldAllow` method should be called when a method invocation is attempted, and it should keep track of the number of calls and the timestamps of the calls to determine if the call should be allowed. If the number of calls in the recent `timeWindow` exceeds `maxCalls`, it should return `false`. Otherwise, it should return `true` and allow the call.","solution":"from collections import deque from time import time class RateLimiter: def __init__(self, maxCalls, timeWindow): self.maxCalls = maxCalls self.timeWindow = timeWindow self.calls = deque() def shouldAllow(self): current_time = time() # Slide the window: Remove calls older than the time window from queue while self.calls and self.calls[0] < current_time - self.timeWindow: self.calls.popleft() if len(self.calls) < self.maxCalls: self.calls.append(current_time) return True else: return False"},{"question":"Given an integer array `heights` representing the heights of buildings in a row, and an integer `K`, return the maximum number of buildings you can include in a segment such that the difference in heights between the tallest and shortest building in the segment is less than or equal to `K`. A _segment_ is defined as a consecutive subarray of `heights`.","solution":"def max_buildings_in_segment(heights, K): Returns the maximum number of buildings in a segment such that the difference in heights between the tallest and shortest building in the segment is <= K. n = len(heights) max_length = 0 left = 0 current_min = heights[0] current_max = heights[0] for right in range(n): current_min = min(current_min, heights[right]) current_max = max(current_max, heights[right]) while current_max - current_min > K: left += 1 current_min = min(heights[left:right+1]) current_max = max(heights[left:right+1]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a **0-indexed** integer array `arr` of size `n` which contains **unique** integers sorted in **ascending order**. Additionally, you are given an integer `x`. You need to find two distinct indices `i` and `j` in `arr` such that the sum of `arr[i]` and `arr[j]` equals `x`. Return the indices `i` and `j` as a pair `[i, j]`. If no such pair exists, return an empty array `[]`. Note: - The array and target integer may vary in different test cases. - The indices returned can be in any order in the pair `[i, j]`. - Your solution should be efficient in terms of time and space complexity. **Function Signature:** ```python def findPair(arr: List[int], x: int) -> List[int]: ```","solution":"from typing import List def findPair(arr: List[int], x: int) -> List[int]: Given a 0-indexed integer array `arr` of unique integers sorted in ascending order and an integer `x`, finds two distinct indices i and j such that arr[i] + arr[j] == x. Parameters: arr (List[int]): The input array of unique integers. x (int): The target sum. Returns: List[int]: The indices of the two integers in the array whose sum is equal to x, or [] if no such pair exists. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == x: return [left, right] elif current_sum < x: left += 1 else: right -= 1 return []"},{"question":"Given a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom. For example: Given the following tree `[1, 2, 3, null, 5, null, 4]`, ``` 1 / 2 3 5 4 ``` You should return `[1, 3, 4]`. Note: A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): if not root: return [] queue = deque([(root, 0)]) rightmost_value_at_depth = dict() max_depth = -1 while queue: node, depth = queue.popleft() if node: max_depth = max(max_depth, depth) rightmost_value_at_depth[depth] = node.val queue.append((node.left, depth + 1)) queue.append((node.right, depth + 1)) return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]"},{"question":"Given a non-empty binary tree, find a path in the tree such that the sum of the node values is equal to a given sum. This path must go from the root node to any leaf node. Implement the `hasPathSum` function: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, sum: int) -> bool: # Your code here ``` **Example:** ``` Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], sum = 22 Output: True Explanation: The path is 5 → 4 → 11 → 2 which equals 22. ``` **Note:** - A leaf is a node with no children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, sum: int) -> bool: if not root: return False # If we reached a leaf node, check if the remaining sum equals to current node\'s value if not root.left and not root.right: return root.val == sum # Recursively check left and right subtrees with the updated sum sum -= root.val return hasPathSum(root.left, sum) or hasPathSum(root.right, sum)"},{"question":"Given an `n x n` matrix `mat`, rotate the matrix 90 degrees clockwise in-place and return the resulting matrix. The rotation should be performed by first transposing the matrix and then reversing each row. * For example, given the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The function should return: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"def rotate_matrix(mat): Rotates an n x n matrix 90 degrees clockwise in-place. Args: mat (list of list of int): The n x n matrix to rotate. Returns: list of list of int: The rotated matrix. n = len(mat) # Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse() return mat"},{"question":"You are given a **0-indexed** integer array `nums` representing the cost of various items in a store. You have a certain amount of money `budget`. Your goal is to maximize the total number of items you can buy without exceeding your `budget`. Return _the maximum number of items you can buy_. If it is not possible to buy any item without exceeding the `budget`, return `0`.","solution":"def max_items(nums, budget): Return the maximum number of items that can be purchased within the budget. Parameters: nums (list of int): The costs of the items. budget (int): The available budget. Returns: int: The maximum number of items that can be purchased. nums.sort() # Sort the array to try to buy cheaper items first total_cost = 0 count = 0 for cost in nums: if total_cost + cost <= budget: total_cost += cost count += 1 else: break return count"},{"question":"You are given an integer array `height` where `height[i]` represents the height of a tree at position `i`. A pair of trees `(i, j)` is considered valid if they satisfy the following conditions: - `i < j` - The height difference between the trees at `i` and `j` does not exceed `d` (that is, `|height[i] - height[j]| <= d`). Return _the number of valid pairs of trees in the array_.","solution":"def count_valid_pairs(height, d): Returns the number of valid pairs (i, j) in the height array where 0 <= i < j < len(height) and |height[i] - height[j]| <= d. Args: height (list of int): List of tree heights. d (int): Maximum allowed height difference. Returns: int: Count of valid pairs. n = len(height) count = 0 for i in range(n): for j in range(i + 1, n): if abs(height[i] - height[j]) <= d: count += 1 return count"},{"question":"You are given a string `s` representing a postfix expression, where each valid operator and operand are separated by a single space. The valid operators are `+`, `-`, `*`, and `/`. Operands and the results of operations are assumed to be integers. Your task is to evaluate the postfix expression and return the result as an integer. If the expression is invalid, return `None`. For example, given the string `s = \\"2 3 + 5 *\\"`, the function should return `25`, as the expression evaluates to `25` (`(2 + 3) * 5`). If `s = \\"2 3 5 + *\\"`, the function should return `16`, as the expression evaluates to `16` (`2 * (3 + 5)`). **Constraints**: * Each operand will be a non-negative integer less than 100. * All calculations are guaranteed to lie within the range of a 32-bit signed integer.","solution":"def evaluate_postfix(s): Evaluates a postfix expression and returns the result as an integer. Returns None if the expression is invalid. Parameters: s (str): A string representing the postfix expression. Returns: int: The result of the postfix expression, or None if invalid. if not s: return None stack = [] operators = set([\'+\', \'-\', \'*\', \'/\']) for token in s.split(): if token.isdigit(): stack.append(int(token)) elif token in operators: if len(stack) < 2: return None b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': # Python division of integers follows floor division for // operator, # but \\"/\\" will give float. Hence, we use \\"//\\" for integer division. if b == 0: return None # Division by zero is invalid. stack.append(a // b) else: return None return stack[0] if len(stack) == 1 else None"},{"question":"Given a list of non-negative integers, represent each integer as a string in such a way that the concatenation of the numbers forms the largest possible number. For example, given the list [3, 30, 34, 5, 9], the largest formed number would be \\"9534330\\". Return _the resulting largest number as a string_.","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of non-negative integers, arrange them such that they form the largest number. :param nums: List of non-negative integers :return: The largest formed number as a string # Custom comparator to decide the order of numbers def compare(a, b): if a + b > b + a: return -1 elif a + b < b + a: return 1 else: return 0 # Convert integers to strings for easy comparison nums_str = list(map(str, nums)) # Sort numbers based on custom comparator nums_str.sort(key=cmp_to_key(compare)) # Edge case: if the highest number is \\"0\\", the result should be \\"0\\" if nums_str[0] == \'0\': return \'0\' # Join sorted numbers into one single string return \'\'.join(nums_str)"},{"question":"You are given a string `s` consisting of only characters `\'0\'` and `\'1\'`. A move consists of flipping any character in the string: changing a `\'0\'` to a `\'1\'` or vice versa. You need to make the string alternate, which means no two adjacent characters are the same. For example, `\\"0101\\"` and `\\"1010\\"` are alternating strings. Return the minimum number of moves required to make the string alternating.","solution":"def min_moves_to_alternate(s): Returns the minimum number of moves required to make the input string `s` alternating. n = len(s) # Pattern for alternating string \\"010101...\\" pattern1 = \'\'.join(\'01\'[(i % 2)] for i in range(n)) # Pattern for alternating string \\"101010...\\" pattern2 = \'\'.join(\'10\'[(i % 2)] for i in range(n)) # Count the number of moves needed to change `s` to pattern1 or pattern2 moves_to_pattern1 = sum(1 for i in range(n) if s[i] != pattern1[i]) moves_to_pattern2 = sum(1 for i in range(n) if s[i] != pattern2[i]) return min(moves_to_pattern1, moves_to_pattern2)"},{"question":"Given a **0-indexed** integer array `arr` and an integer `target`, return the number of pairs `(i, j)` where `0 <= i < j < arr.length` such that `arr[i] + arr[j] == target`. You must ensure that each pair is unique and only counted once irrespective of the order. Make sure to return the count of such pairs.","solution":"def count_pairs(arr, target): Returns the number of unique pairs (i, j) where 0 <= i < j < arr.length and arr[i] + arr[j] == target. count = 0 seen = {} for i in range(len(arr)): complement = target - arr[i] if complement in seen: count += seen[complement] if arr[i] in seen: seen[arr[i]] += 1 else: seen[arr[i]] = 1 return count"},{"question":"You are given an unsorted integer array `nums`. Design and implement a class named `MedianFinder` that handles the following operations efficiently: * `MedianFinder()` Initializes the `MedianFinder` object. * `void addNum(int num)` Adds a number `num` from the data stream to the data structure. * `double findMedian()` Returns the median of all elements so far. The median is the middle element if the total number of elements is odd and the average of the two middle elements if the total number of elements is even.","solution":"import heapq class MedianFinder: def __init__(self): Initialize two heaps (lower half max heap and upper half min heap). self.low = [] # Max heap for the lower half self.high = [] # Min heap for the upper half def addNum(self, num: int) -> None: Add a number into the data structure. if len(self.low) == 0 or num <= -self.low[0]: heapq.heappush(self.low, -num) else: heapq.heappush(self.high, num) # Balance the heaps if len(self.low) > len(self.high) + 1: heapq.heappush(self.high, -heapq.heappop(self.low)) elif len(self.high) > len(self.low): heapq.heappush(self.low, -heapq.heappop(self.high)) def findMedian(self) -> float: Return the median of all elements so far. if len(self.low) > len(self.high): return -self.low[0] else: return (-self.low[0] + self.high[0]) / 2.0"},{"question":"You are given two integer arrays `nums1` and `nums2`, both of which are of length `n`. Both arrays contain the same set of unique integers, but in different orders. Determine the minimum number of adjacent swaps required to make `nums1` equal to `nums2`. Return _the minimum number of swaps necessary or_ `-1` _if it is not possible to align the two arrays_.","solution":"def min_swaps_to_equal(nums1, nums2): Returns the minimum number of adjacent swaps required to make nums1 equal to nums2. if sorted(nums1) != sorted(nums2): return -1 index_map = {value: i for i, value in enumerate(nums2)} swaps = 0 for i in range(len(nums1)): while nums1[i] != nums2[i]: swap_index = index_map[nums1[i]] nums2[i], nums2[swap_index] = nums2[swap_index], nums2[i] index_map[nums2[swap_index]] = swap_index swaps += 1 return swaps"},{"question":"You are given a 2D integer array `grid` of size `m x n` representing a grid of cells, where `grid[i][j]` can either be \'1\' (representing land) or \'0\' (representing water). An island is formed by connecting adjacent lands horizontally or vertically. You need to find the number of islands in the grid. Two cells are considered connected if they are adjacent in one of the four possible directions (up, down, left, right). Return the number of islands.","solution":"def num_islands(grid): Given a 2D grid of \'1\'s (land) and \'0\'s (water), returns the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. if not grid: return 0 m, n = len(grid), len(grid[0]) count = 0 def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == \'0\': return grid[x][y] = \'0\' # Mark as visited dfs(x-1, y) dfs(x+1, y) dfs(x, y-1) dfs(x, y+1) for i in range(m): for j in range(n): if grid[i][j] == \'1\': count += 1 dfs(i, j) return count"},{"question":"You are given a binary tree represented by the root node. A node in the binary tree has an additional pointer called `random` which could point to any node in the tree or be `null`. You need to clone the tree; that is, create a deep copy of the tree where each node\'s value, structure, and `random` pointers are identically replicated. Return the root node of the cloned tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, random=None): self.val = val self.left = left self.right = right self.random = random def clone_tree(root): if not root: return None def clone_nodes(node): if not node: return None new_node = TreeNode(node.val) clones[node] = new_node new_node.left = clone_nodes(node.left) new_node.right = clone_nodes(node.right) return new_node def clone_random_pointers(node): if not node: return if node.random: clones[node].random = clones[node.random] clone_random_pointers(node.left) clone_random_pointers(node.right) clones = {} cloned_root = clone_nodes(root) clone_random_pointers(root) return cloned_root"},{"question":"Given a string `s` consisting of lowercase alphabets, split it into as many parts as possible such that each letter appears in at most one part. Return _a list of integers representing the lengths of these parts_. You must ensure that the each part includes the first and last occurrences of each character from that part in the original string.","solution":"def partition_labels(s): Returns a list of integers representing the lengths of the parts created, such that each letter appears in at most one part. last_occurrences = {char: idx for idx, char in enumerate(s)} j = anchor = 0 results = [] for i, char in enumerate(s): j = max(j, last_occurrences[char]) if i == j: results.append(i - anchor + 1) anchor = i + 1 return results"},{"question":"Given a list of integers `nums`, split the list into two subsets such that the difference between the sums of the subsets is minimized. Return the minimum possible difference. For example, if `nums = [1, 6, 11, 5]`, you can partition the list into `[1, 6, 5]` and `[11]`, resulting in sums of `12` and `11` respectively, and a minimum difference of `1`.","solution":"def min_subset_difference(nums): Given a list of integers, split the list into two subsets such that the difference between the sums of the subsets is minimized. Return the minimum possible difference. total_sum = sum(nums) n = len(nums) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(target + 1): if j >= nums[i - 1]: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(target, -1, -1): if dp[n][j]: subset1_sum = j break subset2_sum = total_sum - subset1_sum return abs(subset2_sum - subset1_sum)"},{"question":"Given an array `nums` of integers, return a new array consisting of all the even numbers from `nums` followed by all the odd numbers. The relative order of the even and odd numbers should be preserved. If there are no even numbers, the array should consist only of odd numbers and vice versa. If the array is empty, return an empty array.","solution":"def segregate_even_odd(nums): Returns a new array consisting of all the even numbers from `nums` followed by all the odd numbers. The relative order of the even and odd numbers should be preserved. If the array is empty, returns an empty array. if not nums: return [] evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"You are given a list of integers representing the prices of items in a store and an integer `amount` representing the total money you have. Your task is to implement a function that calculates the maximum number of items you can buy without exceeding the given `amount`. You may assume that each item can be bought only once. Implement the function: ```python def maxItems(prices: List[int], amount: int) -> int: # your code here ``` Return the maximum number of items you can buy.","solution":"from typing import List def maxItems(prices: List[int], amount: int) -> int: Returns the maximum number of items that can be bought with the given amount of money. Parameters: prices (List[int]): A list of integers representing the prices of items. amount (int): An integer representing the total amount of money available. Returns: int: The maximum number of items that can be bought. prices.sort() # Sort prices in ascending order to buy cheaper items first total_items = 0 total_cost = 0 for price in prices: if total_cost + price <= amount: total_items += 1 total_cost += price else: break return total_items"},{"question":"You are given a 2D grid of size `n x m` representing a map of terrains. Each cell in the grid contains an integer representing the height of that cell. You are also given two points, `source` and `destination`, each defined by their row and column coordinates in the grid. You need to find a path from the `source` to the `destination` such that the absolute difference in heights between any two consecutive cells in the path is minimized. Return the minimum value of the maximum absolute difference of heights between consecutive cells in the path. If there is no valid path from the `source` to the `destination`, return -1. You may move in any of the four possible directions (left, right, up, down) from a cell.","solution":"import heapq def minimum_effort_path(grid: list[list[int]], source: tuple[int, int], destination: tuple[int, int]) -> int: Returns the minimum value of the maximum absolute difference of heights between consecutive cells in the path from source to destination. def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x + dx, y + dy if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]): yield new_x, new_y heap = [(0, source[0], source[1])] efforts = {(source[0], source[1]): 0} while heap: effort, x, y = heapq.heappop(heap) if (x, y) == destination: return effort for new_x, new_y in neighbors(x, y): new_effort = max(effort, abs(grid[new_x][new_y] - grid[x][y])) if new_effort < efforts.get((new_x, new_y), float(\'inf\')): efforts[(new_x, new_y)] = new_effort heapq.heappush(heap, (new_effort, new_x, new_y)) return -1"},{"question":"You are given an array `days` where `days[i]` represents the number of flowers that bloom on the `i-th` day. You are also given another integer `bouquets` which represents the number of bouquets you need to form, and an integer `flowersPerBouquet` which represents the number of flowers required to form a single bouquet. A bouquet can only be formed using consecutive flowers. Return _the minimum number of days required to form exactly_ `bouquets` _bouquets using exactly_ `flowersPerBouquet` _flowers for each bouquet. If it is impossible to form the required number of bouquets, return `-1`_.","solution":"def min_days_to_bloom(days, bouquets, flowersPerBouquet): def can_make_bouquets(day_limit): flowers = 0 count_bouquets = 0 for day in days: if day <= day_limit: flowers += 1 if flowers == flowersPerBouquet: count_bouquets += 1 flowers = 0 else: flowers = 0 return count_bouquets >= bouquets if bouquets * flowersPerBouquet > len(days): return -1 left, right = min(days), max(days) while left < right: mid = (left + right) // 2 if can_make_bouquets(mid): right = mid else: left = mid + 1 return left if can_make_bouquets(left) else -1"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` is a point in a 2D plane. You need to find the minimum time in seconds to visit all points in the order given by `points`. You can move vertically, horizontally, or diagonally in one second moving from some point `[xi, yi]` to `[xi+1, yi+1]`, `[xi-1, yi-1]`, `[xi+1, yi-1]`, `[xi-1, yi+1]`, `[xi+1, yi]`, `[xi-1, yi]`, `[xi, yi+1]`, `[xi, yi-1]`. Return _the minimum time it takes to visit all the points in the order_ given by `points`.","solution":"def min_time_to_visit_all_points(points): Returns the minimum time in seconds to visit all given points in order. def distance(p1, p2): return max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) total_time = 0 for i in range(len(points) - 1): total_time += distance(points[i], points[i + 1]) return total_time"},{"question":"You are given two integers `n` and `m`. Your task is to construct an `n x m` matrix such that each element in the matrix `matrix[i][j]` satisfies the following conditions: - All elements in each row are unique. - All elements in each column are unique. - All elements in the matrix are integers in the range `[1, n * m]`. Return the constructed matrix. If there are multiple possible valid matrices, you may return any of them. If it is not possible to construct such a matrix, return an empty list.","solution":"def construct_matrix(n, m): Constructs an `n x m` matrix such that each element in the matrix satisfies: - All elements in each row are unique. - All elements in each column are unique. - All elements in the matrix are integers in the range [1, n * m]. Parameters: n (int): Number of rows m (int): Number of columns Returns: list: The constructed matrix or an empty list if it is not possible. if n == 0 or m == 0: return [] matrix = [] num = 1 for i in range(n): row = [] for j in range(m): row.append(num) num += 1 matrix.append(row) return matrix"},{"question":"You are given a string `s` consisting of lowercase English letters and a list of strings `patterns`. Each string in `patterns` is also a lowercase English letter. You need to find the number of substrings of `s` that match any of the strings in `patterns`. Return the total count of these matching substrings. Note that: - A substring is a contiguous sequence of characters within a string. - Each substring in `s` should be matched separately, even if the substrings overlap.","solution":"def count_matching_substrings(s, patterns): Returns the number of substrings in string `s` that match any of the strings in `patterns`. count = 0 n = len(s) for pattern in patterns: pattern_len = len(pattern) for i in range(n - pattern_len + 1): if s[i:i+pattern_len] == pattern: count += 1 return count"},{"question":"Given an array of integers `nums`, return the **smallest subarray length** that contains at least one occurrence of the maximum element and at least one occurrence of the minimum element from the array. If the array contains only one element, the subarray length should be 1.","solution":"def smallest_subarray_with_min_max(nums): Returns the smallest subarray length that contains at least one occurrence of the maximum element and at least one occurrence of the minimum element from the array. if len(nums) <= 1: return len(nums) maximum = max(nums) minimum = min(nums) if maximum == minimum: return 1 min_pos = -1 max_pos = -1 min_distance = len(nums) for index, num in enumerate(nums): if num == minimum: min_pos = index if num == maximum: max_pos = index if min_pos != -1 and max_pos != -1: min_distance = min(min_distance, abs(max_pos - min_pos) + 1) return min_distance"},{"question":"Given an array of integers `arr`, return the length of the longest subarray where all its elements are distinct. To achieve this, you need to implement a function that makes use of an efficient algorithm, avoiding the use of nested loops to check every subarray. The expected time complexity is O(n). Example: * Input: arr = [1, 2, 1, 3, 4, 2, 3] * Output: 4 (The longest subarray with distinct elements is [1, 3, 4, 2])","solution":"def longest_subarray_with_distinct_elements(arr): Returns the length of the longest subarray with all distinct elements. if not arr: return 0 max_length = 0 start = 0 seen = {} for end in range(len(arr)): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an array of integers `arr`, we define a **mountain** in the array as a sequence of elements that first strictly increases to a peak and then strictly decreases. A mountain must have at least three elements. Write a function that returns _the length of the longest mountain_ in the array. If there is no mountain, return `0`.","solution":"def longest_mountain(arr): Returns the length of the longest mountain in the array. A mountain is defined as a sequence of elements that strictly increases to a peak and then strictly decreases. It must have at least three elements. If there is no mountain, return 0. n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 right = i + 1 while left > 0 and arr[left] > arr[left - 1]: left -= 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"You are given a **1-indexed** integer array `heights` representing the heights of students in a row. You need to shuffle the array such that the order of heights is in non-decreasing order. However, you can only make a limited number of swaps. Define a swap as swapping two elements in the array. Return the **minimum number of swaps** required to sort the array in non-decreasing order. If it is not possible to sort the array with the given number of swaps, return -1.","solution":"def minimumSwaps(heights, K): Return the minimum number of swaps required to sort the array in non-decreasing order. If it is not possible to sort the array with the given number of swaps, return -1. n = len(heights) sorted_heights = sorted(heights) index_map = {v: i for i, v in enumerate(heights)} swaps = 0 for i in range(n): # If heights[i] is not at the correct position if heights[i] != sorted_heights[i]: swaps += 1 # Swap heights[i] with the correct element correct_value = sorted_heights[i] to_swap_idx = index_map[correct_value] # Update index_map to reflect the swap index_map[heights[i]] = to_swap_idx index_map[correct_value] = i # Perform the swap heights[i], heights[to_swap_idx] = heights[to_swap_idx], heights[i] return swaps if swaps <= K else -1"},{"question":"You are given a list of `n` words and a positive integer `k`. The list contains repetitions, and each occurrence of a word represents one appearance in a document. You need to find the `k` most frequent words in the document. If two words have the same frequency, the word with the lexicographically smaller name should come first. Return the `k` most frequent words in the sorted order, first by frequency and then lexicographically. Use the following signature: ```python def topKFrequentWords(words: List[str], k: int) -> List[str]: ```","solution":"from typing import List from collections import Counter def topKFrequentWords(words: List[str], k: int) -> List[str]: Returns the `k` most frequent words from the list `words`. In case of ties, the lexicographical order is considered. # Count the frequency of each word word_count = Counter(words) # Sort by frequency first (in descending order), then lexicographically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k frequent words result = [word for word, _ in sorted_words[:k]] return result"},{"question":"Write a function that takes a list of intervals representing a person\'s availability and merges all overlapping intervals to return a list of disjoint intervals. Each interval is represented as a tuple (start, end). The intervals are inclusive of start and exclusive of end. The input list is not necessarily sorted. The output list should be sorted by the start of each interval. Example: - Input: [(1, 3), (2, 6), (8, 10), (15, 18)] - Output: [(1, 6), (8, 10), (15, 18)]","solution":"def merge_intervals(intervals): Merges a list of overlapping intervals and returns a list of disjoint intervals. The intervals are inclusive of start and exclusive of end. Args: intervals (list of tuples): List of tuples where each tuple is an interval (start, end). Returns: list of tuples: List of merged disjoint intervals sorted by start time. if not intervals: return [] # Sort intervals by starting times intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"Given an integer array `nums` sorted in non-decreasing order, and an integer `target`, remove all occurrences of `target` from the array in-place. Return _the length of the modified array and the modified array itself_, which does not include any occurrence of `target`. The order of elements can be changed, it doesn\'t matter what you leave beyond the new length.","solution":"def remove_element(nums, target): Removes all occurrences of target from the nums list in-place. Returns the new length of the list after removal and the modified list. i = 0 while i < len(nums): if nums[i] == target: nums.pop(i) else: i += 1 return len(nums), nums"},{"question":"You are given a 2D grid `grid` of size `m x n` where each cell represents a plot of land. The grid is initially filled with 0\'s, representing water, and 1\'s, representing land. You can perform an operation to add a land cell at any water cell (`0`). Find the minimum number of operations required to make the grid into one single island (a contiguous region of land). Return _the minimum number of operations needed_ to make the grid a single island. An island is considered contiguous if each cell is connected to another horizontally or vertically. If the entire grid is already a single island, return `0`. If it\'s impossible to connect all the land cells into a single island, return `-1`.","solution":"def min_operations_to_make_one_island(grid): from collections import deque def is_within_grid(x, y, m, n): return 0 <= x < m and 0 <= y < n def bfs(grid, m, n): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False for _ in range(n)] for _ in range(m)] queue = deque() found_land = False for i in range(m): for j in range(n): if grid[i][j] == 1: queue.append((i, j)) visited[i][j] = True found_land = True break if found_land: break if not found_land: return 0, visited steps = 0 while queue: size = len(queue) steps += 1 for _ in range(size): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_grid(nx, ny, m, n) and not visited[nx][ny]: visited[nx][ny] = True if grid[nx][ny] == 1: queue.append((nx, ny)) return steps - 1, visited def count_islands(grid, m, n, visited): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] island_count = 0 def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if is_within_grid(nx, ny, m, n) and not visited[nx][ny] and grid[nx][ny] == 1: visited[nx][ny] = True stack.append((nx, ny)) for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: island_count += 1 visited[i][j] = True dfs(i, j) return island_count m, n = len(grid), len(grid[0]) if all(cell == 0 for row in grid for cell in row): return -1 initial_steps, initial_visits = bfs(grid, m, n) if all(all(initial_visits[i][j] for j in range(n)) for i in range(m)): return 0 total = 0 for row in grid: total += sum(row) if total == 1: return -1 for i in range(m): for j in range(n): if grid[i][j] == 0: grid[i][j] = 1 visited_new = [[False for _ in range(n)] for _ in range(m)] num_islands = count_islands(grid, m, n, visited_new) grid[i][j] = 0 if num_islands == 1: return 1 return 2"},{"question":"Given a string `s` which represents a mathematical expression, evaluate the expression and return its value. The expression string contains only non-negative integers, \'+\', \'-\', \'*\', \'/\' operators, and empty spaces. The integer division should truncate toward zero. You may assume that the given expression is always valid.","solution":"def evaluate_expression(s): Evaluates the given mathematical expression string and returns its value. Arguments: s -- a string representing a mathematical expression containing integers, \'+\', \'-\', \'*\', \'/\' operators, and spaces. Returns: The result of evaluating the expression as an integer. s = s.replace(\' \', \'\') num, stack, sign = 0, [], \'+\' i = 0 while i < len(s): if s[i].isdigit(): num = num * 10 + int(s[i]) if s[i] in \'+-*/\' or i == len(s) - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(int(stack.pop() / num)) sign = s[i] num = 0 i += 1 return sum(stack)"},{"question":"Given an integer array `arr` of unique elements, return _one of the possible permutations of `arr`_ such that the sum of the absolute differences between consecutive elements is maximal. Note that the order of the elements in the returned array should be one of the valid permutations that maximizes the sum of absolute differences.","solution":"def max_absolute_difference_permutation(arr): Given an integer array `arr` of unique elements, returns one of the possible permutations of `arr` such that the sum of the absolute differences between consecutive elements is maximal. arr.sort() result = [] i, j = 0, len(arr) - 1 while i <= j: if i != j: result.append(arr[j]) result.append(arr[i]) else: result.append(arr[i]) i += 1 j -= 1 return result"},{"question":"Given an array `logs` where `logs[i]` contains three different elements `[id, status, timestamp]`, your task is to find the maximum time any employee has spent on a task. Each log entry represents the start or end of a task by a specific employee id at a given timestamp. The `status` can be either \\"start\\" or \\"end\\". Return the `id` of the employee who has the maximum time spent on a task. If there are multiple employees with the same maximum time, return the smallest `id`. Note: The `timestamp` format is in seconds, and all ids are unique.","solution":"def max_time_spent_on_task(logs): Returns the id of the employee who has the maximum time spent on a task. :param logs: List of logs. Each log is a list with three elements [id, status, timestamp] :return: id of the employee with maximum time spent on a task task_times = {} start_times = {} for log in logs: emp_id, status, timestamp = log if status == \\"start\\": start_times[emp_id] = timestamp elif status == \\"end\\": if emp_id in start_times: elapsed_time = timestamp - start_times[emp_id] if emp_id in task_times: task_times[emp_id] = max(task_times[emp_id], elapsed_time) else: task_times[emp_id] = elapsed_time max_time = -1 max_id = float(\'inf\') for emp_id, time in task_times.items(): if time > max_time or (time == max_time and emp_id < max_id): max_time = time max_id = emp_id return max_id"},{"question":"Write a class `LinkedList` to represent a singly linked list and implement two methods in the class: `reverse()` and `to_list()`. The `reverse()` method should reverse the linked list in-place, and the `to_list()` method should convert the linked list to a Python list containing the same elements in the same order, making it easier to view the state of the linked list at any point. Additionally, include a constructor that initializes the linked list with an optional `values` argument, which is a list of integers to populate the linked list. Example: ```python # Initialize linked list with [1, 2, 3] ll = LinkedList([1, 2, 3]) print(ll.to_list()) # Output: [1, 2, 3] # Reverse the linked list ll.reverse() print(ll.to_list()) # Output: [3, 2, 1] ```","solution":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next class LinkedList: def __init__(self, values=None): self.head = None if values: for value in values: self.append(value) def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def to_list(self): elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"You are given a list of `intervals` where each interval is represented as a tuple `(start, end)`, denoting the start and end times of an event. Your task is to determine if a person could attend all given events. Return `true` if a person can attend all events without any overlap, otherwise return `false`. For example, given the list `[(1, 3), (2, 4), (5, 7)]`, the function should return `false` since the intervals `(1, 3)` and `(2, 4)` overlap. However, for the list `[(1, 2), (3, 5), (6, 8)]`, the function should return `true` as there are no overlapping intervals.","solution":"def can_attend_all_events(intervals): Determines if a person can attend all events without overlapping. Arguments: intervals -- List of tuples representing events with start and end times. Returns: True if a person can attend all events without overlap, otherwise False. # Sort intervals based on the start time intervals.sort() for i in range(1, len(intervals)): # If the start time of the current interval is less than the end time of the previous interval if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"Given a list of `heights` representing the heights of buildings along a street, you need to find the longest increasing subsequence of buildings. An increasing subsequence is a sequence of buildings such that each subsequent building has a greater height than the previous one. Return the _length of the longest increasing subsequence_ of buildings\' heights.","solution":"def length_of_LIS(heights): Returns the length of the longest increasing subsequence in the list of heights. if not heights: return 0 dp = [1] * len(heights) for i in range(1, len(heights)): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a string `s` containing only lowercase letters and the digits from `1` to `9`, you are tasked with decoding it following these rules: - The digits `1` to `9` indicate how many times the preceding letter should be repeated. - For example, the string `\\"a3b2\\"` should be decoded to `\\"aaabb\\"`. - If a letter is not followed by a digit, it is assumed to appear once. - For example, the string `\\"ab3\\"` should be decoded to `\\"abb\\"`. Write a function that takes the input string `s` and returns the decoded string.","solution":"def decode_string(s): Decodes a string as per the given rules: digits 1-9 indicate the repetition of the preceding letter. Parameters: s (str): The input string containing lowercase letters and digits. Returns: str: The decoded string. decoded = [] i = 0 while i < len(s): if s[i].isdigit(): # The logic assumes there\'s always a letter before a digit # Append the last added letter multiplied by the digit value decoded[-1] *= int(s[i]) else: # Just add the character decoded.append(s[i]) i += 1 return \'\'.join(decoded)"},{"question":"You are given an array of integers `nums` and an integer `k`. You need to implement a data structure that efficiently supports the following operations: 1. `void insert(int num)`: Insert the integer `num` into the `nums` array. 2. `int findKthLargest()`: Return the `k`-th largest element in the `nums` array. The data structure should be optimized for multiple calls to the `findKthLargest()` method. For instance, for `nums = [3, 1, 5, 12, 2, 11]` and `k = 3`, after calling `insert(6)`, the `findKthLargest()` call should return `6` if it is the `3rd` largest element in the updated array.","solution":"import heapq class KthLargest: def __init__(self, k, nums): self.k = k self.nums = nums heapq.heapify(self.nums) while len(self.nums) > k: heapq.heappop(self.nums) def insert(self, num): if len(self.nums) < self.k: heapq.heappush(self.nums, num) elif num > self.nums[0]: heapq.heapreplace(self.nums, num) def findKthLargest(self): return self.nums[0]"},{"question":"You are given a list of strings `words` and a string `chars`. A string is called **\\"good\\"** if it can be formed by characters from `chars` (characters can be reused). Find the total length of all \\"good\\" strings in `words`. You must implement a function that returns the total length of all \\"good\\" strings that can be formed by `chars`.","solution":"def good_strings_length(words, chars): Returns the total length of all \\"good\\" strings in words that can be formed by characters from chars. Characters in chars can be reused. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word): total_length += len(word) return total_length"},{"question":"You are given `k` sorted linked lists, each with increasing order values. Merge all the linked lists into one sorted linked list and return it. The input is `lists`, an array of `k` linked lists, where each linked list is represented as an array of integers. For example, a linked list `[1, 4, 5]` would be given as `list[0] = [1, 4, 5]`. The output should be a singly linked list in sorted order containing all the elements from the `k` linked lists.","solution":"from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: import heapq ListNode.__lt__ = lambda self, other: self.val < other.val min_heap = [] for i in range(len(lists)): if lists[i]: heapq.heappush(min_heap, lists[i]) head = ListNode(0) curr = head while min_heap: node = heapq.heappop(min_heap) curr.next = node curr = curr.next if node.next: heapq.heappush(min_heap, node.next) return head.next def array_to_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_array(node): array = [] current = node while current: array.append(current.val) current = current.next return array"},{"question":"You are given a list of integers `arr` and an integer `target`. Write a function that determines if there are four elements in `arr` whose sum is equal to `target`. Return `true` if such a combination of elements exists, otherwise return `false`. Create a question with relevant constraints and a diverse set of sample inputs.","solution":"def four_sum_exists(arr, target): Determines if there are four elements in `arr` whose sum is equal to `target`. :param arr: list of integers :param target: integer target sum :return: True if four elements sum to `target`, otherwise False arr.sort() length = len(arr) for i in range(length - 3): for j in range(i + 1, length - 2): left, right = j + 1, length - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` that consists of lowercase letters and an asterisk `\'*\'`. Your task is to replace every asterisk in the string with a character such that no two adjacent characters are the same after replacement. You can choose any character from `a` to `z` for replacement. If there are multiple valid results, return any one of them. Return the resulting string after replacing all the asterisks.","solution":"def replace_asterisks(s): Replaces each asterisk in the string s with a character from \'a\' to \'z\' such that no two adjacent characters are the same after replacement. s = list(s) length = len(s) for i in range(length): if s[i] == \'*\': for char in \'abcdefghijklmnopqrstuvwxyz\': if (i > 0 and s[i - 1] == char) or (i < length - 1 and s[i + 1] == char): continue s[i] = char break return \'\'.join(s)"},{"question":"Given a string `s`, return _the number of indices `i` where the following conditions hold_: 1. `s[i] == \'(\'` 2. _For every character `s[j]` where_ `j < i` _and_ `s[j] == \'(\', _there is a corresponding_ `s[k] == \')\'` _where_ `j < k < i` _and every_ `s[m]` _where_ `j < m < k` _and_ `s[m] == \'(\' _also has a corresponding_ `s[n] == \')\'` _where_ `m < n < k`.","solution":"def valid_left_parentheses_indices(s): Returns the number of indices i where the conditions hold: 1. s[i] == \'(\' 2. For every character s[j] where j < i and s[j] == \'(\', there is a corresponding s[k] == \')\' where j < k < i and every s[m] where j < m < k and s[m] == \'(\' also has a corresponding s[n] == \')\' where m < n < k. open_count = 0 for i in range(len(s)): if s[i] == \'(\': open_count += 1 elif s[i] == \')\' and open_count > 0: open_count -= 1 return open_count"},{"question":"You are given a string `s` containing only digits. Return the total number of ways to decode it into alphabetic characters where `\'A\'` is represented by `\'1\'`, `\'B\'` by `\'2\'`, and so on up to `\'Z\'` which is represented by `\'26\'`. Since the answer could be large, return it modulo `10^9 + 7`.","solution":"MOD = 10**9 + 7 def num_decodings(s): Returns the total number of ways to decode the string `s` into alphabetic characters. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != \'0\': dp[i] = dp[i - 1] if i != 1 and \'10\' <= s[i-2:i] <= \'26\': dp[i] = (dp[i] + dp[i - 2]) % MOD return dp[n]"},{"question":"You are given a list of strings `products` and a string `searchWord`. Design an algorithm to find all **prefix matches** of `searchWord` among the `products`. A **prefix match** is defined if a product string begins with a certain prefix derived from incremental characters of `searchWord`. Specifically, for each character added in `searchWord`, find all products that match that prefix in lexicographical order (up to 3 matches if available). For example, given `products = [\\"mobile\\", \\"mouse\\", \\"moneypot\\", \\"monitor\\", \\"mousepad\\"]` and `searchWord = \\"mouse\\"`, the iterative prefix matches are: - \\"m\\" -> [\\"mobile\\", \\"moneypot\\", \\"monitor\\"] - \\"mo\\" -> [\\"mobile\\", \\"moneypot\\", \\"monitor\\"] - \\"mou\\" -> [\\"mouse\\", \\"mousepad\\"] - \\"mous\\" -> [\\"mouse\\", \\"mousepad\\"] - \\"mouse\\" -> [\\"mouse\\", \\"mousepad\\"] Return a list of lists of strings, where each list corresponds to the prefix matches for incremental characters of `searchWord`.","solution":"def suggestedProducts(products, searchWord): Returns a list of lists of prefix matches for each incremental character addition in searchWord. Each list contains up to 3 lexicographically ordered strings from products that match the prefix. products.sort() result = [] prefix = \\"\\" for char in searchWord: prefix += char matches = [product for product in products if product.startswith(prefix)] result.append(matches[:3]) return result"},{"question":"You are given a list of `n` integers `nums`, and an integer `threshold`. Your task is to find the minimum possible largest sum of the subarrays that the list can be divided into, such that the sum of each subarray does not exceed `threshold`. You need to perform the split in such a way that minimizes this largest sum. Implement the function `minimizeLargestSum(nums: List[int], threshold: int) -> int` that returns the minimized largest sum.","solution":"from typing import List def can_split(nums: List[int], max_sum: int, threshold: int) -> bool: current_sum = 0 count_splits = 1 for num in nums: if current_sum + num <= max_sum: current_sum += num else: count_splits += 1 current_sum = num if count_splits > threshold: return False return True def minimizeLargestSum(nums: List[int], threshold: int) -> int: left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_split(nums, mid, threshold): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"Given an array of `n` integers `nums`, determine if there exists a triplet `(i, j, k)` with `0 <= i < j < k < n` such that `nums[i] + nums[j] + nums[k] = 0`. If such a triplet exists, return all the unique triplets that sum up to zero, otherwise return an empty list. Note that the solution set must not contain duplicate triplets.","solution":"def three_sum(nums): Find all unique triplets in the list which gives the sum of zero. Parameters: nums (List[int]): List of integers Returns: List[List[int]]: List of lists containing triplets that sum to zero. nums.sort() # Sorting the array helps in avoiding duplicates result = [] for i in range(len(nums)-2): if i > 0 and nums[i] == nums[i-1]: continue # Avoid duplicates for the first element left, right = i+1, len(nums)-1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left+1]: left += 1 # Avoid duplicates for the second element while left < right and nums[right] == nums[right-1]: right -= 1 # Avoid duplicates for the third element left += 1 right -= 1 return result"},{"question":"Given a character array `tasks` representing the tasks a CPU needs to perform, where each letter represents a different task. Tasks could be done in any order, and each task can be done in one unit of time. However, there is a non-negative integer `n` that represents the cooldown period between performing two of the same tasks. Determine the least number of units of time the CPU will take to finish all the given tasks.","solution":"from collections import Counter import heapq def least_interval(tasks, n): Determines the least number of units of time the CPU will take to finish all the given tasks considering the cooldown period `n` between performing two of the same tasks. Args: tasks (List[str]): A list of tasks represented by characters. n (int): Cooldown period between two same tasks. Returns: int: The minimum number of units of time to finish all the given tasks. if n == 0: return len(tasks) task_counts = Counter(tasks) max_heap = [-cnt for cnt in task_counts.values()] heapq.heapify(max_heap) time = 0 cooldown = [] while max_heap or cooldown: time += 1 if max_heap: count = heapq.heappop(max_heap) + 1 if count: cooldown.append((count, time + n)) if cooldown and cooldown[0][1] == time: heapq.heappush(max_heap, cooldown.pop(0)[0]) return time"},{"question":"You are given a **0-indexed** integer array `nums` and two integers `k1` and `k2`. Return the sum of the elements between the `k1`-th smallest and the `k2`-th smallest elements (inclusive) in the sorted array. If `k1` is greater than or equal to `k2`, return 0. Note that the indices `k1` and `k2` are 1-based, which means that the smallest element is the 1st smallest, the second smallest is the 2nd smallest, and so on.","solution":"def sum_elements_between_k1_k2(nums, k1, k2): Returns the sum of the elements between the k1-th smallest and the k2-th smallest elements (inclusive) in the sorted array. if k1 >= k2: return 0 # Create a sorted version of nums sorted_nums = sorted(nums) # Retrieve the k1-th and k2-th smallest elements k1_smallest = sorted_nums[k1-1] k2_smallest = sorted_nums[k2-1] # Sum elements between k1-th and k2-th smallest elements (inclusive) sum_elements = sum([num for num in sorted_nums if k1_smallest <= num <= k2_smallest]) return sum_elements"},{"question":"Given a string `s` that consists of lowercase letters and a non-negative integer `k`, write a function that returns a new string where all the characters of `s` are shifted to the right by `k` positions in the alphabet. After \'z\', the alphabet wraps around to \'a\'. For example, with `s = \\"abc\\"` and `k = 2`, the output should be \\"cde\\". If `s = \\"xyz\\"` and `k = 3`, the output should be \\"abc\\". Note that `k` can be larger than 26.","solution":"def shift_string(s, k): Shifts each character in the string `s` to the right by `k` positions in the alphabet. :param s: The input string consisting of lowercase letters. :param k: The number of positions to shift each character. :return: A new string with each character shifted to the right by `k` positions. k = k % 26 # Since the alphabet wraps around every 26 characters, we use modulo 26 shifted_string = [] for char in s: new_char = chr((ord(char) - ord(\'a\') + k) % 26 + ord(\'a\')) shifted_string.append(new_char) return \'\'.join(shifted_string)"},{"question":"Given two strings `str1` and `str2`, return the length of the longest substring that appears in both `str1` and `str2`. If there are no common substrings, return 0. The input strings consist of only lowercase English letters.","solution":"def longest_common_substring_length(str1, str2): Returns the length of the longest common substring between str1 and str2. len1, len2 = len(str1), len(str2) if len1 == 0 or len2 == 0: return 0 # Initialize DP table dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_length = 0 # Build the table in bottom-up fashion for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"You are given a list of integers where each element represents a day’s profit or loss. Write a function named `max_profit` that takes this list as an argument and returns the maximum profit that can be made by buying and selling on two different days. If no profit can be made, return 0. Note that you must buy before you sell, and you cannot buy and sell on the same day.","solution":"def max_profit(prices): Returns the maximum profit that can be made by buying and selling on two different days. If no profit can be made, returns 0. :param prices: List of integers representing daily profits or losses. :return: The maximum profit or 0 if no profit can be made. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values from left to right, level by level. Each value at a given tree level should be added to a nested list representing that level, maintaining the order of appearance from left to right at every level. For example, if the binary tree is: ``` 3 / 9 20 / 15 7 ``` The function should return `[[3], [9, 20], [15, 7]]`.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root): Perform level order traversal of a binary tree. :param root: TreeNode, the root of the binary tree :return: List[List[int]], a nested list where inner lists represent levels of the tree if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"Given an array of integers `arr` and a non-negative integer `m`, return the length of the shortest subarray whose sum is greater than or equal to `m`. If there is no such subarray, return `0`.","solution":"def min_subarray_len(arr, m): Returns the length of the shortest subarray whose sum is greater than or equal to `m`. If there is no such subarray, returns 0. n = len(arr) if n == 0: return 0 min_length = float(\'inf\') current_sum = 0 start_index = 0 for end_index in range(n): current_sum += arr[end_index] while current_sum >= m: min_length = min(min_length, end_index - start_index + 1) current_sum -= arr[start_index] start_index += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given two integer arrays `startTime` and `endTime`, both of size `n`, where `startTime[i]` represents the start time of the `i`th course and `endTime[i]` represents the end time of the `i`th course. You are also given an integer array `queryTime` of size `m`, where `queryTime[j]` is the time at which the `j`th query is made. For each query, return the number of courses that are active at that `queryTime[j]`. A course is considered active at a particular time if the time lies inclusively between the course\'s start and end times. Write a function `activeCourses` that takes three parameters: * `startTime` - List[int]: the list of start times of the courses. * `endTime` - List[int]: the list of end times of the courses. * `queryTime` - List[int]: the list of query times. The function should return a list of integers representing the number of active courses at each query time.","solution":"def activeCourses(startTime, endTime, queryTime): Returns a list of integers representing the number of active courses at each query time. Parameters: startTime (List[int]): The list of start times of the courses. endTime (List[int]): The list of end times of the courses. queryTime (List[int]): The list of query times. Returns: List[int]: The list of active courses at each query time. result = [] for qt in queryTime: count = 0 for st, et in zip(startTime, endTime): if st <= qt <= et: count += 1 result.append(count) return result"},{"question":"Imagine you are given a `10x10` checkered board where each cell can be either empty or filled. The board is represented as a 2D list `board` where `board[i][j]` is `1` if the cell is filled and `0` if it\'s empty. Your task is to determine the largest square (composed only of `1`s) that can be formed in this checkered board. Return the size of the side of that square.","solution":"def largest_square_side(board): Determine the size of the side of the largest square composed only of \'1\'s in a 10x10 checkered board. Parameters: board (list of list of int): 2D list representation of the board (10x10) Returns: int: The size of the side of the largest square composed only of \'1\'s # Initialize variables max_side = 0 # Create a DP table to store the size of the largest square ending at each cell dp = [[0] * 10 for _ in range(10)] # Iterate through the board for i in range(10): for j in range(10): if board[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # On the edges, the size is 1 if cell is filled else: # Minimum of top, left, and top-left diagonal cell + 1 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 # Update the maximum size max_side = max(max_side, dp[i][j]) return max_side"},{"question":"Write a function that takes in a list of strings and returns the list sorted in such a way that strings containing digits come after strings that contain only alphabetic characters. Within each group, strings should be sorted in ascending order. For example, given the input list `[\\"apple\\", \\"1banana\\", \\"banana\\", \\"2apples\\", \\"grape\\"]`, the function should return `[\\"apple\\", \\"banana\\", \\"grape\\", \\"1banana\\", \\"2apples\\"]`.","solution":"def custom_sort(strings): Sorts a list of strings such that strings containing digits come after strings that only contain alphabetic characters. Within each group, strings are sorted in ascending order. Args: strings (list of str): The list of strings to be sorted. Returns: list of str: The sorted list of strings. # Split the input list into two lists: one with only alphabetic strings and one with strings containing digits alphabetic_strings = [s for s in strings if s.isalpha()] digit_strings = [s for s in strings if any(char.isdigit() for char in s)] # Sort both lists alphabetic_strings.sort() digit_strings.sort() # Concatenate the lists with alphabetic_strings first return alphabetic_strings + digit_strings"},{"question":"You are given an array `boxes` representing the sizes of `n` boxes in a warehouse and an array `target` representing `n` target capacity values. Write a function that determines if it is possible to move every box to a target with a capacity that is at least as large as the box size. Each box can only be moved to one target. If it is possible to move all boxes to their respective targets, return `true`. Otherwise, return `false`.","solution":"def can_move_boxes_to_targets(boxes, targets): Determines if every box can be moved to a target with at least the same capacity. Args: boxes (list of int): Sizes of the boxes. targets (list of int): Target capacities. Returns: bool: True if every box can be moved to a target with at least the same capacity, False otherwise. # Sort both boxes and targets to facilitate the process of matching boxes.sort() targets.sort() # Compare each box to the corresponding target for box_size, target_capacity in zip(boxes, targets): if box_size > target_capacity: return False return True"},{"question":"You are given a string `s` and an integer `k`. The string `s` consists of lower-case English letters and represents a genome sequence. You are tasked with finding the length of the longest substring of `s` that contains no more than `k` distinct characters. If there are multiple such substrings with the same length, return any of them. In essence, you need to determine the maximum length of a substring within `s` which can be formed with at most `k` distinct characters and return its length.","solution":"def longest_substring_with_k_distinct_chars(s, k): Returns the length of the longest substring containing no more than k distinct characters. Args: s (str): the input string k (int): the number of distinct characters Returns: int: the length of the longest substring with at most k distinct characters if k == 0 or not s: return 0 char_freq = {} max_length = 0 left = 0 for right in range(len(s)): char_freq[s[right]] = char_freq.get(s[right], 0) + 1 while len(char_freq) > k: char_freq[s[left]] -= 1 if char_freq[s[left]] == 0: del char_freq[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. An **operation** consists of selecting two indices `i` and `j` such that `0 <= i < j < arr.length`, and then swapping `arr[i]` with `arr[j]`. Return `true` _if it is possible to sort the array in non-decreasing order with **at most** `k` operations._ Return `false` _otherwise_.","solution":"def can_sort_with_k_operations(arr, k): Determines if it\'s possible to sort the array `arr` in non-decreasing order with at most `k` swap operations. Parameters: arr (list of int): A 0-indexed integer array. k (int): Maximum number of swap operations allowed. Returns: bool: True if the array can be sorted with at most `k` operations, False otherwise. # Track the number of misplaced elements misplaced_count = 0 # Create a sorted version of the array to compare against sorted_arr = sorted(arr) # Iterate through the array and count the number of misplaced elements for i, val in enumerate(arr): if val != sorted_arr[i]: misplaced_count += 1 # Calculate the minimum number of swaps needed min_swaps_needed = misplaced_count // 2 # Check if the minimum required swaps are within the allowed operations return min_swaps_needed <= k"},{"question":"A company has a work schedule for its employees represented by a matrix `schedule` of size `m x n`, where `schedule[i][j]` is 1 if the employee `i` is working on the day `j`, and 0 otherwise. A team meeting is to be scheduled, and it needs to be attended by at least `K` employees from the company. Given the `schedule` matrix and an integer `K`, return _the maximum number of consecutive days where at least_ `K` _employees are scheduled to work_. If no such days exist, return 0.","solution":"def max_consecutive_days(schedule, K): Returns the maximum number of consecutive days where at least K employees are scheduled to work. if not schedule: return 0 n_employees = len(schedule) n_days = len(schedule[0]) if n_employees > 0 else 0 if n_days == 0 or K > n_employees: return 0 # Count the number of employees working each day day_counts = [sum(day[i] for day in schedule) for i in range(n_days)] max_consecutive = 0 current_count = 0 for count in day_counts: if count >= K: current_count += 1 max_consecutive = max(max_consecutive, current_count) else: current_count = 0 return max_consecutive"},{"question":"Given an array of integers `arr` and an integer `target`, return all unique pairs of integers in the array that sum up to `target`. Each pair should be represented as an array of two integers `[a, b]`, where `a <= b`. The pairs should be returned in sorted order based on their first element, and if two pairs have the same first element, then sort them based on the second element. If no such pairs exist, return an empty list. Method signature: `List<int[]> findPairsWithTargetSum(int[] arr, int target)`","solution":"def find_pairs_with_target_sum(arr, target): Finds all unique pairs of integers in the array that sum up to the target. Each pair is represented as an array of two integers [a, b], where a <= b. The pairs are returned in sorted order. seen = set() result = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted([num, complement])) result.add(pair) seen.add(num) result = list(result) result.sort() return [list(pair) for pair in result]"},{"question":"You are given a **0-indexed** array `heights` consisting of `n` integers that represent the heights of a sequence of buildings. A building `i` is **blocked** if there is a building `j` that comes before it in the array (i.e., `0 <= j < i`) such that the height of building `j` is greater than or equal to the height of building `i`. Return _an array `result` of length `n` such that `result[i]` contains the number of buildings that are blocked by building `i`. For example, if `heights = [4,2,3,1]`, the `result` should be `[0,1,1,3]` since: - The first building `(heights[0] = 4)` is not blocked by any building. - The second building `(heights[1] = 2)` is blocked by one building `(heights[0] = 4)`. - The third building `(heights[2] = 3)` is blocked by one building `(heights[0] = 4)`. - The fourth building `(heights[3] = 1)` is blocked by three buildings `(heights[0] = 4, heights[1] = 2, heights[2] = 3)`.","solution":"def count_blocked_buildings(heights): Returns an array of length n such that result[i] contains the number of buildings that are blocked by building i. n = len(heights) result = [0] * n for i in range(1, n): count = 0 for j in range(i): if heights[j] >= heights[i]: count += 1 result[i] = count return result"},{"question":"You are given a binary tree in which each node contains an integer value. Return the zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). The traversal should start from the root of the tree, alternating between levels. For example, in the even indexed levels (0, 2, 4, ...), nodes should be visited from left to right, while in the odd indexed levels (1, 3, 5, ...), nodes should be visited from right to left.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"You are given an integer array `heights` representing the height of students in a line. Your task is to implement a function that returns the minimum number of students that must be moved in order to change the existing order into non-decreasing order. For example, given `heights = [5, 3, 8, 6, 7]`, you need to find the minimum number of moves required to change the array into a non-decreasing sequence, such as `[3, 5, 6, 7, 8]` or any other valid order. Note that a \\"move\\" means removing a student\'s height from the `heights` list and inserting it at a different position.","solution":"def min_moves_to_non_decreasing(heights): Returns the minimum number of students that must be moved to form a non-decreasing order. :param heights: List of integers representing the height of students. :return: Integer representing the minimum number of moves needed. n = len(heights) # Find longest increasing subsequence lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) longest_increasing_subsequence_length = max(lis) # Minimum number of moves is the length of the array minus the length of longest increasing subsequence return n - longest_increasing_subsequence_length"},{"question":"Given a linked list where each node has a unique value, return the length of the longest sequence of consecutive numbers that can be formed using the values from the linked list. The sequence does not need to be contiguous in the linked list. For example, if the linked list contains the values **[100, 4, 200, 1, 3, 2]**, then the longest sequence of consecutive numbers is **[1, 2, 3, 4]**, and the length is **4**.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def longest_consecutive(head): Returns the length of the longest sequence of consecutive numbers in the linked list. if not head: return 0 nums = set() current = head while current: nums.add(current.val) current = current.next longest_streak = 0 for num in nums: if num - 1 not in nums: current_num = num current_streak = 1 while current_num + 1 in nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a `log` of various operations performed on a data structure. The `log` is represented as an array of strings, where each string represents a specific operation. The possible operations are: 1. `\\"push X\\"`: Push integer `X` onto the data structure. 2. `\\"pop\\"`: Remove the most recently added integer. 3. `\\"max\\"`: Query the maximum integer currently in the data structure. Return an array of integers representing the results of each `\\"max\\"` operation in the order they appear in the `log`. Example: ``` Input: log = [\\"push 3\\", \\"push 1\\", \\"max\\", \\"push 5\\", \\"max\\", \\"pop\\", \\"max\\"] Output: [3, 5, 3] ```","solution":"def process_log(log): stack = [] max_stack = [] results = [] for operation in log: if operation.startswith(\\"push\\"): _, value = operation.split() value = int(value) stack.append(value) if not max_stack or value >= max_stack[-1]: max_stack.append(value) elif operation == \\"pop\\": popped_value = stack.pop() if popped_value == max_stack[-1]: max_stack.pop() elif operation == \\"max\\": results.append(max_stack[-1]) return results"},{"question":"You are given an array of integers `nums` which represents different coins and their denominations. Your task is to find the minimum number of coins that make up a given amount `target`. If that amount cannot be made up by any combination of the coins, return `-1`. You may assume that you have an infinite number of each kind of coin. Implement a function `minCoins(nums, target)` that returns the minimum number of coins needed to make up the `target` amount. # Example ``` Input: nums = [1, 2, 5], target = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Input: nums = [2], target = 3 Output: -1 Explanation: No combination can make up the target 3. ``` Note: - `1 <= nums.length <= 100` - `1 <= nums[i] <= 10^4` - `0 <= target <= 10^4`","solution":"def minCoins(coins, target): Function to find the minimum number of coins needed to make up a given amount. If that amount cannot be made up by any combination of the coins, return -1. :param coins: List[int] - a list of different denominations of coins. :param target: int - the total amount to make. :return: int - the minimum number of coins to make the target amount or -1 if not possible. # Initialize DP array with infinity for all values except 0 which needs 0 coins to make. dp = [float(\'inf\')] * (target + 1) dp[0] = 0 for coin in coins: for x in range(coin, target + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"You are given a list of integers `nums` representing a continuous increasing sequence broken into two subarrays such that the whole array consists of strictly increasing elements initially, followed by a strictly increasing sequence. Your task is to determine the index at which the first subarray ends and the second subarray begins. Return the _index_ of the first element of the second subarray. If the entire `nums` list is already a single increasing sequence, return `-1`.","solution":"def find_subarray_split_index(nums): Find the index at which the first subarray ends and the second subarray begins. Parameters: nums (list): A list of integers representing a continuous increasing sequence split into two subarrays Returns: int: The index of the first element of the second subarray. Returns -1 if the entire `nums` list is a single increasing sequence. n = len(nums) if n < 2: return -1 for i in range(1, n): if nums[i] <= nums[i-1]: return i return -1"},{"question":"Consider a 2D grid of size `n x m` with each cell containing either a 0 or a 1. A group of connected 1s forms an island. Two cells are connected if they share a common edge. You can flip at most one 0 to a 1 to form a larger island or connect two existing islands. Write a function that returns the size of the largest island achievable after flipping exactly one 0 to a 1. If flipping a 0 to a 1 does not increase the size of any island, return the size of the largest existing island.","solution":"def largestIsland(grid): def dfs(x, y, index): stack = [(x, y)] visited.add((x, y)) current_size = 0 while stack: i, j = stack.pop() current_size += 1 grid[i][j] = index for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1 and (ni, nj) not in visited: visited.add((ni, nj)) stack.append((ni, nj)) return current_size def get_neighbors(x, y): neighbors = set() for di, dj in directions: ni, nj = x + di, y + dj if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] > 1: neighbors.add(grid[ni][nj]) return neighbors if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited = set() index = 2 island_sizes = {} # Step 1: Use DFS to find all islands and their sizes for i in range(n): for j in range(m): if grid[i][j] == 1 and (i, j) not in visited: island_size = dfs(i, j, index) island_sizes[index] = island_size index += 1 # Step 2: Check each 0 cell to see biggest possible island by flipping it max_island = max(island_sizes.values()) if island_sizes else 0 for i in range(n): for j in range(m): if grid[i][j] == 0: potential_size = 1 neighbors = get_neighbors(i, j) for neighbor in neighbors: potential_size += island_sizes[neighbor] max_island = max(max_island, potential_size) return max_island"},{"question":"You are given a list of `n` words. Each word contains only lowercase English letters. Design a function `word_mapper` that returns a dictionary where each key is a word from the list and the value is a list of indices at which the word appears in the list. If a word appears multiple times, all indices should be included in the list. The words should be considered case-sensitive and the indices should be zero-based. Example: Input: `words = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]` Output: `{\\"apple\\": [0, 2, 5], \\"banana\\": [1, 4], \\"orange\\": [3]}`","solution":"def word_mapper(words): Returns a dictionary where each key is a word from the list and the value is a list of indices at which the word appears in the list. word_dict = {} for index, word in enumerate(words): if word in word_dict: word_dict[word].append(index) else: word_dict[word] = [index] return word_dict"},{"question":"You are given a list of strings, `words`, and a string `target`. Each string in `words` consists only of lowercase English letters. Your goal is to find and return the minimum number of strings from `words` that you need to concatenate in any order to form the `target` string exactly. If it is not possible to form the `target` string using the given `words`, return `-1`. For example, if `words = [\\"ab\\", \\"c\\", \\"bca\\", \\"a\\", \\"bc\\"]` and `target = \\"abc\\"`, you can form `target` by concatenating `\\"a\\"`, `\\"b\\"`, and `\\"c\\"`, or by concatenating `\\"ab\\"` and `\\"c\\"`, etc. Return the minimum number of strings required.","solution":"def min_concat(words, target): Finds the minimum number of strings from words that you need to concatenate in any order to form the target string. Returns -1 if it is not possible to form the target string. from collections import Counter, defaultdict import sys word_counts = Counter(\\"\\".join(words)) target_counts = Counter(target) # Check if it\'s even possible to create the target with given words for char in target_counts: if target_counts[char] > word_counts.get(char, 0): return -1 # Initialize a memoization table to store the minimum number of words needed to form each prefix of target n = len(target) dp = [sys.maxsize] * (n + 1) dp[0] = 0 # dp[i] means the minimum number of words needed to make target[0:i] for i in range(1, n + 1): for word in words: word_len = len(word) if i >= word_len and target[i - word_len:i] == word: dp[i] = min(dp[i], dp[i - word_len] + 1) return dp[n] if dp[n] != sys.maxsize else -1"},{"question":"You are given a string `s` containing only characters `\'a\'`, `\'b\'`, and `\'c\'`. You can perform the following operation on the string any number of times: Choose any two adjacent characters and replace them with a different character. For example, if `\'a\'` and `\'b\'` are adjacent, you can replace them with `\'c\'`. Return the length of the shortest string possible after performing any number of operations. If it is not possible to reduce the string, return the length of the original string.","solution":"def minimize_string_length(s): Given a string s containing only characters \'a\', \'b\', and \'c\', return the length of the shortest string possible after performing any number of operations. # If all characters are the same, we can\'t reduce the string if len(s) == 0 or all(char == s[0] for char in s): return len(s) # If there are exactly two different characters if len(set(s)) == 2: return 2 # For three different characters return 2 if len(set(s)) == 3 else 1"},{"question":"You are given an array of integers `arr` where each integer represents the height of a large building in a line of buildings from left to right. The goal is to determine how much total rainwater can be trapped between these buildings after a rain. The amount of water that can be trapped is determined by comparing the height of each building with the tallest buildings to its left and right. Write a function that calculates and returns the total amount of trapped rainwater.","solution":"def trap_rainwater(arr): Calculate the total amount of trapped rainwater. Args: arr (list of int): List of building heights. Returns: int: Total amount of trapped rainwater. if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - arr[i] return total_water"},{"question":"You are given a **0-indexed** array `nums` consisting of `n` positive integers. You are also given an integer `m` which represents a sliding window of size `m`. Your task is to calculate the **maximum** sum of any subarray of size `m` within `nums`. For example, given `nums = [1, 4, 2, 10, 23, 3, 1, 0, 20]` and `m = 4`, the maximum sum of any subarray of size `m` would be `39` (subarray `[4, 2, 10, 23]`). Return the integer representing the maximum sum of any subarray of size `m`.","solution":"def max_subarray_sum(nums, m): Returns the maximum sum of any subarray of size m within the list nums. n = len(nums) if n < m: raise ValueError(\\"Subarray size m cannot be larger than the array size.\\") max_sum = sum(nums[:m]) current_sum = max_sum for i in range(m, n): current_sum += nums[i] - nums[i-m] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given an integer array `weights` where `weights[i]` represents the weight of the `ith` item, and an integer `limit` representing the weight limit of a partition. Your task is to partition the array into two subsets `subset1` and `subset2` such that: - The weight of each partition does not exceed `limit`. - The sum of the weights in `subset1` is as close as possible to the sum of the weights in `subset2`. Return _a boolean_ `canPartition` _which is_ `true` _if such a partition exists, or_ `false` _otherwise_.","solution":"def canPartition(weights, limit): n = len(weights) total_weight = sum(weights) if total_weight % 2 != 0: return False target = total_weight // 2 if target > limit: return False dp = [False] * (target + 1) dp[0] = True for weight in weights: for j in range(target, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] return dp[target]"},{"question":"You are given an infinite number of boxes in 3 different sizes: small, medium, and large. A small box can hold `X` units, a medium box can hold `Y` units, and a large box can hold `Z` units. Write a function that determines the minimum number of boxes required to exactly fit a given number of units, `N`. If it is not possible to exactly fit the given number of units using the available boxes, return `-1`. The function should take in the values for `X`, `Y`, `Z`, and `N` as parameters.","solution":"def min_boxes(X, Y, Z, N): Determines the minimum number of boxes required to exactly fit N units. If it is not possible to exactly fit N units, returns -1. Parameters: X (int): units small box can hold. Y (int): units medium box can hold. Z (int): units large box can hold. N (int): total units to fit into boxes. Returns: int: minimum number of boxes or -1 if not possible. # Let\'s use a dynamic programming approach to solve this problem. # dp[i] will store the minimum number of boxes required to fit exactly i units. dp = [float(\'inf\')] * (N + 1) dp[0] = 0 # No box is needed to fit 0 units for i in range(1, N + 1): if i >= X and dp[i - X] != float(\'inf\'): dp[i] = min(dp[i], dp[i - X] + 1) if i >= Y and dp[i - Y] != float(\'inf\'): dp[i] = min(dp[i], dp[i - Y] + 1) if i >= Z and dp[i - Z] != float(\'inf\'): dp[i] = min(dp[i], dp[i - Z] + 1) return dp[N] if dp[N] != float(\'inf\') else -1"},{"question":"You are given an array of integers `nums` representing the amounts of money of `n` houses, arranged in a circle. A robber is planning to rob these houses and must abide by the rule that adjacent houses cannot be robbed on the same night, and since the houses are in a circle, the first and last house cannot both be robbed. Return the maximum amount of money the robber can rob without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money the robber can rob without alerting the police. def rob_linear(houses): prev, curr = 0, 0 for amount in houses: prev, curr = curr, max(curr, prev + amount) return curr if len(nums) == 1: return nums[0] return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"You are given a list of non-negative integers representing the strength of different warriors. You need to form a team of exactly three warriors such that the sum of their strengths is the maximum possible but **less than** a given integer `limit`. Write a function that takes the list of warriors\' strengths and the integer `limit`, and returns the maximum sum of strengths that meets the criteria. If no such combination exists, return -1.","solution":"from itertools import combinations def max_sum_less_than_limit(strengths, limit): Returns the maximum sum of strengths of three warriors that is less than the given limit. If no such combination exists, returns -1. max_sum = -1 # Generating all combinations of three warriors for combo in combinations(strengths, 3): current_sum = sum(combo) if current_sum < limit: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of `n` unique integers, write a function to find the maximum length of a subarray where the absolute difference between any two elements is at most `k`. In other words, for each subarray, the condition `abs(a[i] - a[j]) <= k` must hold for any pair of elements `a[i]` and `a[j]` in the subarray. Return _the length of the longest such subarray_.","solution":"def max_length_subarray(arr, k): Returns the maximum length of a subarray where the absolute difference between any two elements is at most k. n = len(arr) if n == 0: return 0 arr.sort() left = 0 max_len = 1 for right in range(1, n): while arr[right] - arr[left] > k: left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given an array of strings `words` and a 2D list of integers `queries`. Each query consists of two indices `[i, j]`, and your task is to count the number of strings in the subarray `words[i]` to `words[j]` (inclusive) that can be concatenated to form a palindrome. A palindrome is a string that reads the same backward as forward. Return an array of integers representing the answer for each query in `queries`. For example, if `words = [\\"radar\\", \\"apple\\", \\"level\\", \\"racecar\\"]` and `queries = [[0, 2], [1, 3]]`, the function should return `[2, 2]` because in the subarray from index 0 to 2, there are two palindromic strings (\\"radar\\" and \\"level\\"), and in the subarray from index 1 to 3, there are also two palindromic strings (\\"level\\" and \\"racecar\\").","solution":"def is_palindrome(s): Check if a given string s is a palindrome. return s == s[::-1] def palindromic_subarray(words, queries): Given a list of strings \'words\' and a list of \'queries\', return a list of integers where each integer represents the count of palindromic strings in the corresponding subarray defined by the query. result = [] for i, j in queries: count = sum(is_palindrome(word) for word in words[i:j+1]) result.append(count) return result"},{"question":"A **warehouse** consists of `m` rows and `n` columns forming a grid of cells, where each cell can either be empty (represented by `0`) or occupied by an obstacle (represented by `1`). Robots can only move to a cell directly adjacent (up, down, left, right) without passing through obstacles. Given the starting cell `(startRow, startCol)` and target cell `(endRow, endCol)`, determine the shortest path the robot must take to reach the target. If no path exists, return `-1`. Assume the robot always starts on an empty cell and the grid has at least one path. Return _the length of the shortest path from the start cell to the target cell_.","solution":"from collections import deque def shortest_path(grid, startRow, startCol, endRow, endCol): Determines the shortest path in the grid from the start cell to the target cell. Returns the length of the shortest path, or -1 if no path exists. def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set((startRow, startCol)) queue = deque([(startRow, startCol, 0)]) # (x, y, step count) while queue: x, y, steps = queue.popleft() if (x, y) == (endRow, endCol): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 # No path found"},{"question":"You are given a 2D grid `grid` of size `m x n` representing a map of land (`1`) and water (`0`). A connected island is a group of `1`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Find the number of distinct islands in `grid`. An island is considered distinct if and only if one island is not identical to another (not even rotated or reflected). Implement the function `numDistinctIslands` which accepts a 2D grid and returns the number of distinct islands. Example: ``` Input: grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0] ] Output: 2 ``` In the example grid, there are two distinct islands: 1. The first island is represented by the coordinates [(0,0),(0,1),(1,0),(1,1)]. 2. The second island is represented by the coordinates [(1,4),(2,3),(2,4)]. Note: * The number of distinct islands is determined by their shape and relative positions, not their exact coordinates.","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, path): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 path.append(direction) dfs(x + 1, y, \'D\', path) dfs(x - 1, y, \'U\', path) dfs(x, y + 1, \'R\', path) dfs(x, y - 1, \'L\', path) path.append(\'B\') unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path = [] dfs(i, j, \'O\', path) unique_islands.add(tuple(path)) return len(unique_islands)"},{"question":"Given a string `s`, you can perform the following operations: - Choose any character from `s` and remove it. - Choose any two adjacent characters from `s` and replace them with a single character that is the **sum** of their respective ASCII values. You need to determine the **lexicographically smallest string** that can be obtained by performing any number of the above operations on `s`. Write a function that returns this lexicographically smallest string possible. (Note: The resulting characters after the ASCII sum operation must remain within the range of lowercase English letters, i.e., `\'a\'` to `\'z\'`.)","solution":"def lexicographically_smallest_string(s): This function returns the lexicographically smallest string possible by performing the given operations on the string `s`. # The smallest possible lexicographically string would be keeping the minimum character min_char = min(s) return min_char"},{"question":"Given a list of processes, each with a unique process ID and a unique parent process ID, write a function to capture the hierarchy by returning the list of process IDs that are killed if a given process ID is killed. When a process is killed, all of its child processes (and their descendants) are also killed. The list of processes is represented as two arrays: one for process IDs and one for parent process IDs. Each process has exactly one parent, except for the root process which has no parent (indicated by a parent ID of `0`). Return the order in which the process IDs are killed.","solution":"def kill_process(pid_list, ppid_list, kill): Returns the list of process IDs that are killed if a given process ID is killed. :param pid_list: List of process IDs. :param ppid_list: List of parent process IDs corresponding to each process ID. :param kill: Process ID to be killed. :return: List of process IDs that are killed. from collections import defaultdict, deque # Building the process tree process_tree = defaultdict(list) for i in range(len(pid_list)): process_tree[ppid_list[i]].append(pid_list[i]) # Performing BFS to collect all processes to be killed killed_processes = [] queue = deque([kill]) while queue: current = queue.popleft() killed_processes.append(current) queue.extend(process_tree[current]) return killed_processes"},{"question":"You are given a `2D` grid of size `m x n` filled with **non-negative** integers. The goal is to find the most **valuable** path from the top-left corner (i.e., `grid[0][0]`) to the bottom-right corner (i.e., `grid[m-1][n-1]`) such that the value of a path is the **sum** of the values of the cells the path passes through. You can only move either **right** or **down** at any point in time. Given the grid, return _the maximum value_ that can be collected along such a path.","solution":"def maxValuePath(grid): Finds the maximum value path from the top-left corner to the bottom-right corner in a grid, where you can only move right or down. Parameters: - grid: list of lists of non-negative integers representing the grid. Returns: - int: Maximum value collectible following the path. # Get the dimensions of the grid m, n = len(grid), len(grid[0]) # Create a 2D DP table to store the maximum value obtainable at each cell dp = [[0] * n for _ in range(m)] # Initialize the DP table with the value at the starting cell dp[0][0] = grid[0][0] # Fill in the first row of the DP table for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column of the DP table for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum value path return dp[m-1][n-1]"},{"question":"A factory produces widgets in batches. Each widget is inspected for quality control and is assigned a score based on its condition - a higher score indicates a better quality widget. Given an array of positive integers `scores` where `scores[i]` represents the score of the `i-th` widget, you are tasked to determine the maximum score that can be obtained by selecting a contiguous subarray of widgets. However, the length of the selected subarray must be exactly `k`. Implement a function that returns this maximum score.","solution":"def max_subarray_score(scores, k): Returns the maximum score of a contiguous subarray with length exactly k. n = len(scores) if k > n: raise ValueError(\\"k shouldn\'t be greater than the length of the scores array\\") # Compute the sum of the first subarray of length k current_sum = sum(scores[:k]) max_sum = current_sum # Use sliding window to find max sum for i in range(k, n): current_sum += scores[i] - scores[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Write a function `alienOrder(words)` that receives a list of strings `words` from an alien language dictionary, where the strings are sorted lexicographically according to the alien language\'s dictionary order. You need to derive and return a unique character order that would satisfy this ordering. If there are multiple valid solutions, return any of them. If no valid ordering exists, return an empty string `\\"\\"`. **Note:** You may assume that all characters are lowercase English letters and that the input words are non-empty.","solution":"from collections import defaultdict, deque def alienOrder(words): Determine the order of characters in an alien language. :param List[str] words: List of words sorted lexicographically in the alien language :return str: A string representing the order of characters or \\"\\" if no valid ordering exists # Create data structures adj_list = defaultdict(set) in_degree = {char: 0 for word in words for char in word} # Build the graph for i in range(len(words) - 1): first_word, second_word = words[i], words[i + 1] min_length = min(len(first_word), len(second_word)) # Check if the first word is a prefix of the second word if len(first_word) > len(second_word) and first_word[:min_length] == second_word[:min_length]: return \\"\\" # Create edges for j in range(min_length): if first_word[j] != second_word[j]: if second_word[j] not in adj_list[first_word[j]]: adj_list[first_word[j]].add(second_word[j]) in_degree[second_word[j]] += 1 break # Topological Sort (Kahn\'s algorithm) zero_in_degree_queue = deque([char for char in in_degree if in_degree[char] == 0]) ordered_chars = [] while zero_in_degree_queue: char = zero_in_degree_queue.popleft() ordered_chars.append(char) # Reduce the in-degree of the neighbor nodes for neighbor in adj_list[char]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the topologically sorted order has all the characters, return as a string if len(ordered_chars) == len(in_degree): return \\"\\".join(ordered_chars) else: return \\"\\""},{"question":"**Question 4**: You are given a 2D grid of characters `board` representing a word search puzzle, and a string `word`. The word can be constructed from letters of sequentially adjacent cells, where \\"`adjacent`\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Return _true_ if `word` exists in the grid and _false_ otherwise. Examples: ``` Input: board = [ [\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\'] ], word = \\"ABCCED\\" Output: true Input: board = [ [\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\'] ], word = \\"SEE\\" Output: true Input: board = [ [\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\'] ], word = \\"ABCB\\" Output: false ```","solution":"def exist(board, word): rows, cols = len(board), len(board[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or c < 0 or r >= rows or c >= cols or board[r][c] != word[index]: return False temp = board[r][c] board[r][c] = \'#\' # mark as visited found = ( dfs(r + 1, c, index + 1) or dfs(r - 1, c, index + 1) or dfs(r, c + 1, index + 1) or dfs(r, c - 1, index + 1) ) board[r][c] = temp # unmark as visited return found for i in range(rows): for j in range(cols): if board[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"Write a function that given a string `path`, which represents an absolute Unix file path, simplifies the path. A Unix file path starts with `\'/\'` and follows these rules: 1. Any two consecutive slashes (`\'//\'`) are treated as a single slash (`\'/\'`). 2. Any single dot (`\\".\\"`) refers to the current directory and can be ignored. 3. Any double dots (`\\"..\\"`) move up to the parent directory. The directory before the `..` is removed for each `..`. 4. Any other name represents a directory name or a file, which is added to the path. Return the simplified canonical path. **Examples:** - Given path = `\\"/home/\\"`, the output should be `\\"/home\\"`. - Given path = `\\"/../\\"`, the output should be `\\"/\\"`. - Given path = `\\"/home//foo/\\"`, the output should be `\\"/home/foo\\"`. - Given path = `\\"/a/./b/../../c/\\"`, the output should be `\\"/c\\"`.","solution":"def simplify_path(path): Simplify a given absolute Unix file path. Args: path (str): A string representing the absolute Unix file path. Returns: str: The simplified canonical path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue if part == \'..\': if stack: stack.pop() else: stack.append(part) result = \'/\' + \'/\'.join(stack) return result"},{"question":"You are given an array of integers `height`, where `height[i]` represents the height of a building located at position `i`. A building offers a view if there are no taller buildings to its right. More formally, a building `i` has a view if for all `j > i`, `height[j] <= height[i]`. Return the list of indices of buildings that have a view, in ascending order.","solution":"def find_buildings_with_view(height): Returns the list of indices of buildings that have a view. n = len(height) if n == 0: return [] view_indices = [] max_height_so_far = float(\'-inf\') for i in range(n - 1, -1, -1): if height[i] > max_height_so_far: view_indices.append(i) max_height_so_far = height[i] view_indices.reverse() return view_indices"},{"question":"You are given a **binary tree** with `n` nodes, where each node has a distinct value from 1 to n. The root node is guaranteed to have the value 1. You should create a **new binary tree** where each node has the **sum of values** of all nodes in its subtree (including the node itself) from the original tree. Return the root of the new binary tree with the updated values. A binary tree is a structure in which each node has at most two children, referred to as the left child and the right child.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_sum_tree(root): Given a binary tree, returns a new binary tree where each node contains the sum of the values of all nodes in its subtree (including the node itself). if not root: return None def subtree_sum(node): if not node: return 0 left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) return node.val + left_sum + right_sum new_root = TreeNode(subtree_sum(root)) new_root.left = construct_sum_tree(root.left) new_root.right = construct_sum_tree(root.right) return new_root"},{"question":"A certain robotics company built a robot with the ability to navigate in a grid. The robot is initially located at the top-left corner of the grid (position `(0, 0)`). It can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (position `(m-1, n-1)`). The grid is represented by a `m x n` matrix filled with non-negative numbers, where each cell represents the cost required to enter that cell. Write a function that takes an `m x n` grid as input and returns the minimum cost required for the robot to reach the bottom-right corner of the grid from the top-left corner.","solution":"def min_path_sum(grid): Calculate the minimum cost to navigate from the top-left corner to the bottom-right corner of the grid. Args: grid (list of lists of int): The m x n grid with non-negative numbers. Returns: int: The minimum cost to reach the bottom-right corner. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the cost matrix with the same dimensions as the grid cost = [[0 for _ in range(cols)] for _ in range(rows)] # Start from the top-left corner cost[0][0] = grid[0][0] # Initialize the first row (can only come from the left) for j in range(1, cols): cost[0][j] = cost[0][j-1] + grid[0][j] # Initialize the first column (can only come from above) for i in range(1, rows): cost[i][0] = cost[i-1][0] + grid[i][0] # Fill the cost matrix for i in range(1, rows): for j in range(1, cols): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[rows-1][cols-1]"},{"question":"You are given a `k x n` 2D grid `grid` where each cell of the grid contains an integer. A **path** in the grid is a sequence of cells where each subsequent cell is either to the right or directly below the current cell. The **path sum** is the sum of the integers in the path. Determine the minimum path sum from the top-left cell to the bottom-right cell. Return _the minimum path sum._","solution":"def minPathSum(grid): Determine the minimum path sum from the top-left cell to the bottom-right cell in a k x n grid. :param grid: List[List[int]], 2D grid containing integers :return: int, minimum path sum if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp table with same dimensions as grid dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill out the first row. for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill out the first column. for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"Given a string `s` and a list of words `words`, return _the **number** of words from the list that are **substrings** of the given string_ `s`.","solution":"def count_substrings(s, words): Returns the number of words from the given list that are substrings of the given string s. :param s: The string to search within. :param words: A list of words to check as substrings. :return: The number of words that are substrings of s. return sum(1 for word in words if word in s)"},{"question":"You are given a **0-indexed** integer array `arr` of length `n` and an integer `k`. You need to create a new array `result` of length `n`, where `result[i]` is equal to the sum of elements in the subarray `arr[max(0, i - k) ... min(n - 1, i + k)]`. In other words, `result[i]` is the sum of elements within a window of size `2k + 1` centered at index `i`, but the window is clipped at the ends of the array if necessary. Return _the new array_ `result`.","solution":"def sum_of_subarrays(arr, k): Returns a new array where each element is the sum of a subarray of arr, centered at each index and having a window of size 2k + 1. n = len(arr) result = [0] * n # Initialize the result array with zeros for i in range(n): start = max(0, i - k) end = min(n - 1, i + k) result[i] = sum(arr[start:end+1]) return result"},{"question":"Design and implement a data structure that supports the following operations in constant time: `insert`, `delete`, and `getRandom`. The `insert` operation inserts an element to the collection, `delete` removes an element from the collection if it is present, and `getRandom` returns a random element from current elements in the collection. Note that `delete` operation does not return anything, and `getRandom` returns the element only if the collection is not empty. Your implementation should aim to handle each function in average O(1) time complexity. Implement the `RandomizedCollection` class: - `RandomizedCollection()` Initializes the RandomizedCollection object. - `boolean insert(int val)` Inserts an item `val` into the collection if it is not present. Returns `true` if the item was not present, `false` otherwise. - `boolean delete(int val)` Deletes an item `val` from the collection if it is present. Returns `true` if the item was present, `false` otherwise. - `int getRandom()` Returns a random element from the current set of elements (it’s guaranteed that at least one element exists when this method is called).","solution":"import random class RandomizedCollection: def __init__(self): self.dict = {} self.list = [] def insert(self, val): if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def delete(self, val): if val not in self.dict: return False index_to_remove = self.dict[val] last_element = self.list[-1] self.list[index_to_remove] = last_element self.dict[last_element] = index_to_remove self.list.pop() del self.dict[val] return True def getRandom(self): return random.choice(self.list)"},{"question":"Given `m` arrays of integers, where the `i-th` array `arr[i]` is sorted in non-decreasing order, return *the smallest number* that appears in *at least k* of the `m` arrays. If there is no such number, return `-1`. The input arrays may contain negative numbers.","solution":"from collections import defaultdict def smallest_common_number(arrays, k): Finds the smallest number that appears in at least k of the m sorted arrays. :param arrays: List of m sorted arrays. :param k: Minimum number of arrays a number should appear in. :return: The smallest number that appears in at least k of the m arrays, or -1 if no such number exists. number_count = defaultdict(int) for array in arrays: unique_elements = set(array) for num in unique_elements: number_count[num] += 1 result = float(\'inf\') for num, count in number_count.items(): if count >= k: result = min(result, num) return result if result != float(\'inf\') else -1"},{"question":"You are given two strings `s` and `goal`. Return _true if and only if `s` can become `goal` after exactly one swap in `s`_, or _if `s` is equal to `goal_`. A swap exchanges the positions of two characters in a string.","solution":"def can_single_swap_make_equal(s, goal): Returns true if and only if s can become goal after exactly one swap in s, or if s is equal to goal. if s == goal: return True if len(s) != len(goal): return False diff = [(a, b) for a, b in zip(s, goal) if a != b] if len(diff) == 2 and diff[0] == diff[1][::-1]: return True return False"},{"question":"Given an integer `n`, calculate the total number of ways to express `n` as the sum of one or more consecutive positive integers. Return the number of such ways.","solution":"def consecutive_sum_ways(n): Returns the total number of ways to express n as the sum of one or more consecutive positive integers. count = 0 for start in range(1, n + 1): sum_consecutive = 0 for i in range(start, n + 1): sum_consecutive += i if sum_consecutive == n: count += 1 break elif sum_consecutive > n: break return count"},{"question":"Given a string `s` consisting of lowercase alphabetical characters, return the character that appears most frequently in the string. If there is a tie, return the character that comes first alphabetically.","solution":"def most_frequent_char(s): Given a string `s` consisting of lowercase alphabetical characters, return the character that appears most frequently in the string. If there is a tie, return the character that comes first alphabetically. from collections import Counter # Count the frequency of each character in the string frequency = Counter(s) # Find the character with the highest frequency most_frequent = max(frequency.items(), key=lambda x: (x[1], -ord(x[0]))) # Return the character return most_frequent[0]"},{"question":"Given a string `str` and a string `target`, return the minimum window substring of `str` that contains all the characters in `target`. If there is no such substring, return an empty string. Note that if there is a match, it is guaranteed that there will always be only one unique answer.","solution":"from collections import Counter def min_window_substring(s, t): Returns the minimum window substring of `s` that contains all the characters in `t`. if not s or not t: return \\"\\" t_counter = Counter(t) s_counter = Counter() required = len(t_counter) formed = 0 l, r = 0, 0 min_len = float(\\"inf\\") min_window = \\"\\" while r < len(s): character = s[r] s_counter[character] += 1 if character in t_counter and s_counter[character] == t_counter[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < min_len: min_len = r - l + 1 min_window = s[l:r+1] s_counter[character] -= 1 if character in t_counter and s_counter[character] < t_counter[character]: formed -= 1 l += 1 r += 1 return min_window"},{"question":"You are given a list of words and a pattern. The pattern is a string where each character represents a different letter but all letters that occur the same number of times in the pattern must appear the same number of times in the words. For example, pattern \\"aabb\\" means that valid words must have two letters appearing twice each. Return a list of words from the provided list that match the pattern. Each word in the list contains only lowercase English letters, and the length of each word is the same as the length of the pattern. Each word contains distinct characters that map uniquely to the characters in the pattern. Your task is to find and return all the words that match the given pattern.","solution":"def match_pattern(words, pattern): from collections import Counter def encode(word): counter = Counter(word) return tuple(sorted(counter.values())) pattern_code = encode(pattern) return [word for word in words if encode(word) == pattern_code]"},{"question":"You are given an array of integers `nums` representing the number of items with each unique value, and an integer `k` representing the number of items you are allowed to remove. Return _the minimum number of unique integers left in the array after removing_ `k` _items._","solution":"from collections import Counter def find_least_num_of_unique_ints(nums, k): Returns the minimum number of unique integers left in the array after removing k items. count = Counter(nums) frequencies = sorted(count.values()) unique_ints = len(frequencies) for freq in frequencies: if k >= freq: k -= freq unique_ints -= 1 else: break return unique_ints"},{"question":"You are given an array of integers `arr` with a length of `n` and an integer `target`. Your task is to find all unique triplets `[arr[i], arr[j], arr[k]]` such that `i != j != k` and `arr[i] + arr[j] + arr[k] == target`. Return the triplets in a unique sorted order, and there should be no duplicate triplets in the output.","solution":"def three_sum(arr, target): Finds all unique triplets in the array which gives the sum of target. :param arr: List[int] - The input array of integers :param target: int - The target sum for the triplets :return: List[List[int]] - List of unique triplets that sum up to the target arr.sort() result = [] n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue # Skip duplicate elements left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: result.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 # Skip duplicates while left < right and arr[right] == arr[right - 1]: right -= 1 # Skip duplicates left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"You are given an array `nums` of integers and an integer `k`. Write a function to return the length of the smallest contiguous subarray the sum of whose elements is greater than or equal to `k`. If there is no such subarray, return `0`.","solution":"def min_subarray_len(nums, k): Returns the length of the smallest contiguous subarray sum that is greater than or equal to k. If there is no such subarray, return 0. n = len(nums) min_len = float(\'inf\') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= k: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float(\'inf\') else 0"},{"question":"You have a list of words and want to maximize the number of words that can be typed using a keyboard with broken letters. Given a string `text` representing the typed words (separated by spaces) and a string `brokenLetters` containing all the broken letters on the keyboard, return the maximum number of words that can be typed without using any broken letters. The function should take two parameters: `text` (string) and `brokenLetters` (string).","solution":"def canBeTypedWords(text, brokenLetters): Returns the maximum number of words that can be typed without using any broken letters. Parameters: - text: string representing the typed words (separated by spaces) - brokenLetters: string containing all the broken letters on the keyboard Returns: - int: the maximum number of words that can be typed words = text.split() broken_set = set(brokenLetters) def is_typable(word): Checks if a word can be typed without using any broken letters. for char in word: if char in broken_set: return False return True return sum(is_typable(word) for word in words)"},{"question":"You are given an array of integers `arr` representing a sequence of `n` integers. An operation is defined as selecting two different elements in the array and swapping their positions. Return the minimum number of operations required to sort the array in non-decreasing order. **Notes:** * The array may contain duplicate elements. * You are allowed to perform any number of swaps.","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in non-decreasing order. n = len(arr) # Create a list of tuples where each tuple is (value, index) arr_pos = [(value, idx) for idx, value in enumerate(arr)] # Sort the array by the values arr_pos.sort(key=lambda x: x[0]) # Create a visited array to mark already visited elements visited = [False] * n swaps = 0 for i in range(n): # If element is already visited or already in the correct place if visited[i] or arr_pos[i][1] == i: continue # Calculate the size of the cycle cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 # If there is a cycle of k nodes, the number of swaps required is (k-1) if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"You are given an `n x m` integer grid `grid` representing a field of values. A movement can be made from any cell to any adjacent cell (up, down, left, right) continuously in one step. A path is a sequence of cells, and the cost of a path is defined as the sum of the values of the cells in the path. Given this grid, find the minimum possible cost to reach from the top-left cell `(0, 0)` to the bottom-right cell `(n-1, m-1)`. Return the minimum cost as an integer. The input grid is guaranteed to have at least one possible path.","solution":"import heapq def min_cost(grid): Returns the minimum cost to reach from the top-left cell (0, 0) to the bottom-right cell (n-1, m-1) in the given grid. if not grid or not grid[0]: return float(\'inf\') n, m = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Min-heap to keep the paths with the minimum cost at the top heap = [(grid[0][0], 0, 0)] # (cost, row, col) visited = set() while heap: cost, x, y = heapq.heappop(heap) if (x, y) in visited: continue visited.add((x, y)) # If we\'ve reached the bottom-right cell if x == n-1 and y == m-1: return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: next_cost = cost + grid[nx][ny] heapq.heappush(heap, (next_cost, nx, ny)) return float(\'inf\')"},{"question":"Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. Return the length of `nums` after duplicates have been removed. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. Implement the function `removeDuplicates(nums: List[int]) -> int` that meets the requirements. Additionally, ensure that the elements beyond the returned length do not matter.","solution":"def removeDuplicates(nums): Remove duplicates in-place in the sorted list nums and return the length of the list after duplicates have been removed. Parameters: nums (List[int]): The sorted integer list with potential duplicates Returns: int: The length of the list after removing duplicates if not nums: return 0 write_index = 1 # Start writing from the second element for i in range(1, len(nums)): if nums[i] != nums[i - 1]: # If current element is not equal to the previous nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"You are given an array of integers `arr` and an integer `k`. A pair of integers `(i, j)` is called an **important reverse pair** if `0 <= i < j < arr.length` and `arr[i] > 2 * arr[j]`. Write a function to find the number of **important reverse pairs** in the array. For example, given the array `arr = [1, 3, 2, 3, 1]` and `k = 1`, the function should return 2, indicating that the important reverse pairs are (3,2) and (3,1).","solution":"def count_reverse_pairs(arr): def merge_and_count(nums, temp, left, mid, right): i, j, k = left, mid + 1, left count = 0 # Count important reverse pairs while i <= mid and j <= right: if nums[i] > 2 * nums[j]: count += (mid - i + 1) j += 1 else: i += 1 # Merge the two halves i, j = left, mid + 1 while i <= mid and j <= right: if nums[i] <= nums[j]: temp[k] = nums[i] i += 1 else: temp[k] = nums[j] j += 1 k += 1 while i <= mid: temp[k] = nums[i] k += 1 i += 1 while j <= right: temp[k] = nums[j] k += 1 j += 1 for i in range(left, right + 1): nums[i] = temp[i] return count def merge_sort_and_count(nums, temp, left, right): if left >= right: return 0 mid = (left + right) // 2 count = merge_sort_and_count(nums, temp, left, mid) count += merge_sort_and_count(nums, temp, mid + 1, right) count += merge_and_count(nums, temp, left, mid, right) return count return merge_sort_and_count(arr, [0] * len(arr), 0, len(arr) - 1)"},{"question":"You are given a string `s` that consists of lowercase letters and contains no spaces. Write a function to return the **length of the longest substring** of `s` that contains **no repeating characters**. If there is no such substring, return 0.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters in the given string s. if not s: return 0 char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given a string `s` consisting of lowercase letters, determine the minimum number of characters needed to be inserted to make the string a palindrome. A palindrome is a word that reads the same backward as forward. Implement the function `minInsertionsToPalindrome(s)` that returns this minimum number.","solution":"def minInsertionsToPalindrome(s): Returns the minimum number of characters needed to be inserted to make the string a palindrome. n = len(s) # Create a DP table of size n x n where dp[i][j] represents # the minimum number of insertions to make the substring s[i:j+1] a palindrome dp = [[0] * n for _ in range(n)] # Fill the table for length in range(2, n+1): # length of the current substring for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1 return dp[0][n-1]"},{"question":"You are given a **0-indexed** binary array `nums` where `nums[i]` is either `0` or `1`. A **subarray** is a contiguous non-empty sequence of elements within the array. Return the length of the **longest subarray** with an equal number of `0`\'s and `1`\'s.","solution":"def findMaxLength(nums): Finds the length of the longest subarray with an equal number of 0\'s and 1\'s. Parameters: nums (list of int): A binary array where each element is either 0 or 1. Returns: int: The length of the longest subarray with equal number of 0\'s and 1\'s. count = 0 max_length = 0 count_index_map = {0: -1} for index, num in enumerate(nums): count += -1 if num == 0 else 1 if count in count_index_map: max_length = max(max_length, index - count_index_map[count]) else: count_index_map[count] = index return max_length"},{"question":"You are given a list of positive integers `nums` and a positive integer `target`. Find the number of contiguous subarrays that sum to the given `target`. Write a function `countSubarrays`: * `countSubarrays(nums: List[int], target: int) -> int` - This function should take a list of integers `nums` and an integer `target` as input and return the number of contiguous subarrays whose sum equals `target`. You may assume that integers in the list are non-negative.","solution":"from typing import List def countSubarrays(nums: List[int], target: int) -> int: Returns the number of contiguous subarrays that sum to the given target. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if current_sum - target in prefix_sums: count += prefix_sums[current_sum - target] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"Given a string `s` and an array of integers representing the `frequency` of each character in the string, you need to construct the lexicographically smallest string possible by performing the following operation exactly `k` times: - Remove any one character from the string `s`. - Add it back to any position in the string. Return the final string after `k` operations. The input string will contain only lowercase English letters, and the length of the string will not exceed 50 characters.","solution":"def construct_lexicographically_smallest_string(s, k): Returns the lexicographically smallest string possible after performing exactly `k` operations of removing any one character from the string `s` and adding it back to any position in the string. Parameters: s (str): input string containing only lowercase English letters k (int): number of allowed operations Returns: str: lexicographically smallest string after `k` operations if k > 0: s = sorted(s) return \'\'.join(s) else: return s"},{"question":"You are given a 2D grid of integers representing a map where `land` is represented by `1` and `water` is represented by `0`. An island is a group of `1`s connected horizontally or vertically (but not diagonally). The grid is surrounded by water. Write a function `numDistinctIslands(int[][] grid)` that returns the number of distinct islands. Two islands are considered distinct if and only if one island is not the same as another by shape. Formally, two islands are distinct if and only if one island is not the translate, rotate, or reflect of another.","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, path): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 path.append(direction) direction_vectors = [(-1, 0, \'U\'), (1, 0, \'D\'), (0, -1, \'L\'), (0, 1, \'R\')] for dx, dy, dir in direction_vectors: dfs(x + dx, y + dy, dir, path) path.append(\'B\') # Backtrack unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path = [] dfs(i, j, \'O\', path) unique_islands.add(tuple(path)) return len(unique_islands)"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a row. The goal is to construct a new array `leftMax` where `leftMax[i]` is the maximum height of all buildings to the left of building `i` (excluding `i` itself) and a new array `rightMax` where `rightMax[i]` is the maximum height of all buildings to the right of building `i` (excluding `i` itself). Your task is to implement a function that takes the array `heights` and returns a tuple of the two arrays `leftMax` and `rightMax`.","solution":"def calculate_left_right_max(heights): Given a list of building heights, generate and return two lists: 1. leftMax - the maximum height of all buildings to the left of each building. 2. rightMax - the maximum height of all buildings to the right of each building. :param heights: List[int] - list of building heights :return: Tuple[List[int], List[int]] - tuple containing leftMax and rightMax lists n = len(heights) if n == 0: return [], [] leftMax = [0] * n rightMax = [0] * n # Fill leftMax array for i in range(1, n): leftMax[i] = max(leftMax[i-1], heights[i-1]) # Fill rightMax array for i in range(n-2, -1, -1): rightMax[i] = max(rightMax[i+1], heights[i+1]) return leftMax, rightMax"},{"question":"You are given an **undirected tree** with `n` nodes labeled from `0` to `n - 1`. The tree nodes are connected by an array of `edges` where `edges[i] = [u, v]` represents an edge between nodes `u` and `v`. Each node also has a pre-defined **color** given in the array `color` where `color[i]` represents the color of the `i`-th node. Two nodes are considered **color-adjacent** if they share the same color and there exists a path between them consisting of edges where all intermediate nodes have different colors. Return _the maximum number of nodes that can form a **color-adjacent** set in the tree_.","solution":"def max_color_adjacent_nodes(n, edges, colors): from collections import defaultdict def dfs(node, parent, graph, colors, color): count = 1 if colors[node] == color else 0 for neighbor in graph[node]: if neighbor != parent: count += dfs(neighbor, node, graph, colors, color) return count # Build graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) max_set_size = 0 visited_colors = set() for color in colors: if color not in visited_colors: visited_colors.add(color) count = 0 for i in range(n): if colors[i] == color: count = max(count, dfs(i, -1, graph, colors, color)) max_set_size = max(max_set_size, count) return max_set_size"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `threshold`. Your goal is to sum the elements in `nums` such that the sum of any contiguous subarray (of at least one element) does not exceed the given `threshold`. Create a function that identifies the longest such subarray and returns its length. For example, given `nums = [1, 2, 3, 4, 5]` and `threshold = 7`, the longest subarray is `[1, 2, 3]` with a length of `3` since the sum `1 + 2 + 3 = 6` which is less than `7` and includes the maximum number of elements that satisfy the condition. If multiple subarrays have the same length, return the length of any one of them. Return _the length of the longest subarray where the sum of its elements does not exceed_ `threshold`.","solution":"def max_subarray_length(nums, threshold): Returns the length of the longest subarray where the sum of its elements does not exceed `threshold`. n = len(nums) max_len = 0 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum > threshold and start <= end: current_sum -= nums[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given a string `s` consisting of lowercase English letters, remove all consecutive duplicates from the string. Return _the resulting string_ after all such duplicate removals have been completed.","solution":"def remove_consecutive_duplicates(s): Removes all consecutive duplicates from the string s. if not s: return \\"\\" result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return \'\'.join(result)"},{"question":"Design a data structure that supports adding integers and searching for the kth largest integer efficiently. Implement the `KthLargest` class: * `KthLargest(int k, int[] nums)` Initializes the object with the integer `k` and the stream of integers `nums`. * `int add(int val)` Appends the integer `val` to the stream and returns the element representing the kth largest. **Notes:** * It is guaranteed that you will call the `add` method at least once before calling the `kthLargest` method. * Assume that k is always a valid integer.","solution":"import heapq class KthLargest: def __init__(self, k, nums): Initializes the KthLargest object with the integer k and the stream of integers nums. self.k = k self.heap = nums heapq.heapify(self.heap) while len(self.heap) > k: heapq.heappop(self.heap) def add(self, val): Appends the integer val to the stream and returns the element representing the kth largest. heapq.heappush(self.heap, val) if len(self.heap) > self.k: heapq.heappop(self.heap) return self.heap[0] # Example usage: # kthLargest = KthLargest(3, [4,5,8,2]) # kthLargest.add(3) # returns 4 # kthLargest.add(5) # returns 5 # kthLargest.add(10) # returns 5 # kthLargest.add(9) # returns 8 # kthLargest.add(4) # returns 8"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, you are allowed to perform the following operation at most once: choose any substring of `nums` and reverse it. After performing the operation (or choosing not to), determine if the array can be sorted in non-decreasing order. Return _a boolean value indicating whether the array can be sorted with at most one reversal operation_.","solution":"def can_be_sorted_by_reversing(nums): Determines if the array can be sorted in non-decreasing order by at most one reversal operation. Parameters: nums: List[int] - The input array of integers. Returns: bool - True if the array can be sorted with at most one reversal operation, otherwise False. n = len(nums) # Identify the first and last positions where the array is out of order left, right = 0, n - 1 while left < n - 1 and nums[left] <= nums[left + 1]: left += 1 # If entire array is sorted if left == n - 1: return True while right > 0 and nums[right] >= nums[right - 1]: right -= 1 # Reverse the subarray and check if array becomes sorted nums[left:right + 1] = nums[left:right + 1][::-1] return nums == sorted(nums)"},{"question":"Given a string `s`, recursively remove all adjacent duplicates in the string. The final result should not have any adjacent duplicates. For example, for the input string `\\"abbaca\\"`, the output should be `\\"ca\\"` because first, the \\"bb\\" and \\"aa\\" are removed to form `\\"aaca\\"`, then \\"aa\\" is removed to form `\\"ca\\"`. Implement a function `String removeAdjacentDuplicates(String s)` that returns the reduced string without any adjacent duplicates.","solution":"def removeAdjacentDuplicates(s): Recursively remove all adjacent duplicates in the string s. Parameters: s (str): The input string. Returns: str: The string after removing all adjacent duplicates. # Using a stack to process the string and remove adjacent duplicates stack = [] # Traverse through the string for char in s: # If the stack is not empty and the top of the stack is equal to current character, # it means we found an adjacent duplicate, so we remove the top element from stack if stack and stack[-1] == char: stack.pop() else: # Otherwise, we push the current character to the stack stack.append(char) # The remaining elements in the stack form the result string return \'\'.join(stack)"},{"question":"You are given an array of integers representing the heights of buildings on a street. A building\'s \\"view\\" is considered to be clear if there are no taller buildings to its right. Count and return _the number of buildings that have a clear view of the sunset, i.e., there are no taller buildings to its right_.","solution":"def count_clear_views(buildings): Returns the number of buildings that have a clear view of the sunset. Parameters: buildings (list of int): List of building heights. Returns: int: The number of buildings with a clear view of the sunset. if not buildings: return 0 clear_view_count = 1 max_height = buildings[-1] for height in reversed(buildings[:-1]): if height > max_height: clear_view_count += 1 max_height = height return clear_view_count"},{"question":"You are given a list of `n` positive integers, `nums`, representing the amount of money in each house. Assume you are an expert robber planning to rob these houses. Each house is connected to its adjacent houses in a circular fashion (i.e., the first house is the neighbor of the last one). However, you cannot rob two adjacent houses. Determine the maximum amount of money you can rob tonight without alerting the police. Return the maximum amount of money you can rob. **Note:** The total number of houses is greater than or equal to 2.","solution":"def rob(nums): Determines the maximum amount of money that can be robbed from a list of houses in a circular manner without robbing two adjacent houses. :param nums: List of positive integers representing the amount of money in each house. :return: The maximum amount of money that can be robbed. def rob_line(houses): prev1, prev2 = 0, 0 for money in houses: temp = prev1 prev1 = max(prev1, prev2 + money) prev2 = temp return prev1 n = len(nums) if n == 1: return nums[0] return max(rob_line(nums[:-1]), rob_line(nums[1:]))"},{"question":"You are given an array of integers `arr` and an integer `k`. A **cyclic rotation** of the array means shifting all elements by one position to the right and the last element moves to the first position. Return _the array after `k` cyclic rotations_. Each rotation must be performed step by step to achieve the final rotated array.","solution":"def cyclic_rotate(arr, k): Returns the array after `k` cyclic rotations. Parameters: arr (list): List of integers to be rotated. k (int): Number of cyclic rotations to be performed. Returns: list: The rotated list. n = len(arr) # Normalize k to be within the length of the array k = k % n # Perform the rotations return arr[-k:] + arr[:-k]"},{"question":"You are given an integer `k` and a list of integers `nums` containing `n` elements. The elements in `nums` represent different coin denominations, and `k` represents the total amount of money you want to make. You can use each coin denomination in `nums` any number of times. Your task is to determine the minimum number of coins needed to make the amount `k`. If it is not possible to make the amount `k` with the given coin denominations, return `-1`. For example, given `k = 11` and `nums = [1, 2, 5]`, the minimum number of coins needed to make `11` is `3` (using two 5-coin denominations and one 1-coin denomination). However, given `k = 3` and `nums = [2]`, it is not possible to make the amount `3` with the given coin denominations, so the function should return `-1`.","solution":"def coin_change(k, nums): Determine the minimum number of coins needed to make amount `k` using given coin denominations in `nums`. Returns -1 if it\'s not possible. Args: k (int): The total amount of money to make. nums (list): List of integers representing coin denominations. Returns: int: Minimum number of coins needed to make amount `k` or -1 if not possible. # Initialize the dp array with a value greater than the maximum possible number of coins dp = [float(\'inf\')] * (k + 1) dp[0] = 0 # Base case: no coins are needed to make 0 amount for coin in nums: for i in range(coin, k + 1): if dp[i - coin] != float(\'inf\'): dp[i] = min(dp[i], dp[i - coin] + 1) return dp[k] if dp[k] != float(\'inf\') else -1"},{"question":"Given an integer array `nums` of length `n`, you are allowed to rotate the array to the right by `k` steps, where `k` is a non-negative integer. A rotation to the right means moving the elements in the array to their right by one position, and the last element is moved to the first position. If `k` is greater than `n`, the array is rotated by `k % n` steps. Return the array after `k` rotations.","solution":"def rotate_array(nums, k): Rotates the array to the right by k steps. :param nums: List[int] - The array to rotate. :param k: int - The number of steps to rotate the array. :return: List[int] - The array after rotation. n = len(nums) k = k % n # In case k is greater than n return nums[-k:] + nums[:-k]"},{"question":"Given a nested list of integers represented as a string, write a function to calculate the sum of all integers in the list considering their depths. Each integer is multiplied by its depth level. The depth level of the outermost list is `1`. For example, given the string representation of a nested list `\\"[[1,2],3,[[4,5],6],7]\\"`, the sum would be calculated as follows: - The values `1` and `2` have depth `2`, so their contribution to the sum is `2 * 1 + 2 * 2 = 6`. - The value `3` has depth `1`, so its contribution to the sum is `1 * 3 = 3`. - The values `4` and `5` have depth `3`, so their contribution to the sum is `3 * 4 + 3 * 5 = 27`. - The value `6` has depth `2`, so its contribution to the sum is `2 * 6 = 12`. - The value `7` has depth `1`, so its contribution to the sum is `1 * 7 = 7`. Thus, the total sum is `6 + 3 + 27 + 12 + 7 = 55`. Write a function that takes the nested list string, parses it, and returns the calculated depth sum.","solution":"import ast def depth_sum(nested_list_str): Returns the sum of all integers in the nested list considering their depths. Each integer is multiplied by its depth level. The depth level of the outermost list is 1. :param nested_list_str: A string representation of a nested list of integers :return: The calculated depth sum def calculate_depth_sum(nested_list, current_depth): total_sum = 0 for element in nested_list: if isinstance(element, list): total_sum += calculate_depth_sum(element, current_depth + 1) else: total_sum += element * current_depth return total_sum # Convert the string representation to an actual list (using ast.literal_eval for safety) nested_list = ast.literal_eval(nested_list_str) return calculate_depth_sum(nested_list, 1)"},{"question":"You are implementing a version-controlled system for a file. Each version of the file can be represented as a string. Implement the `VersionControl` class to support the following operations: * `VersionControl()` Initializes the version-controlled system with an empty string. * `void commit(String s)` Saves a new version of the file with the content of `s`. * `String rollback(int steps)` Reverts to the content of the file that was `steps` versions ago from the latest version. If `steps` is greater than the number of saved versions, revert to the initial state (empty string). * `String diff(int v1, int v2)` Compares two versions of the file with indices `v1` and `v2` (0-indexed) and returns a string that shows the differences between these versions. If either `v1` or `v2` is out of bounds, return \\"Invalid version numbers\\". Your task is to design the `VersionControl` class that simulates this version control system.","solution":"class VersionControl: def __init__(self): self.versions = [\\"\\"] def commit(self, s): self.versions.append(s) def rollback(self, steps): if steps >= len(self.versions): return self.versions[0] else: return self.versions[-1 - steps] def diff(self, v1, v2): if 0 <= v1 < len(self.versions) and 0 <= v2 < len(self.versions): version1 = self.versions[v1] version2 = self.versions[v2] return f\\"v{v1}: {version1} || v{v2}: {version2}\\" else: return \\"Invalid version numbers\\""},{"question":"You are given a **binary tree** where each node has an additional **random pointer** which could point to any node in the tree or be `null`. The random pointer is only allowed to point to a node that is in the subtree rooted at that node (including the node itself). Your task is to create a **deep copy** of the binary tree where each node has the same values for its children and random pointers as the original tree. Return the root of the newly copied tree. **Note:** The tree may have loops due to the random pointers, so ensure your solution handles cycles appropriately.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, random=None): self.val = val self.left = left self.right = right self.random = random def copy_tree(root): if not root: return None old_to_new = {} def clone(node): if not node: return None if node in old_to_new: return old_to_new[node] copy = TreeNode(node.val) old_to_new[node] = copy copy.left = clone(node.left) copy.right = clone(node.right) copy.random = clone(node.random) return copy return clone(root)"},{"question":"Implement a `LRUCache` class with the following methods: * `LRUCache(int capacity)` Initializes the LRU cache with a positive size capacity. * `int get(int key)` Return the value of the key if the key exists, otherwise return `-1`. * `void put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions `get` and `put` must each run in O(1) average time complexity. For example, given a cache capacity of 2: * `LRUCache(2)` * `put(1, 1)` // cache is `{1=1}` * `put(2, 2)` // cache is `{1=1, 2=2}` * `get(1)` // return 1, cache is `{2=2, 1=1}` * `put(3, 3)` // evicts key 2, cache is `{1=1, 3=3}` * `get(2)` // returns -1 * `put(4, 4)` // evicts key 1, cache is `{4=4, 3=3}` * `get(1)` // returns -1 * `get(3)` // returns 3 * `get(4)` // returns 4","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 # This is the item\'s usage, since it\'s been accessed, move to end. self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: # Update value and move to end to mark as most recently used self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: # popitem(last=False) pops the first item if it\'s beyond capacity self.cache.popitem(last=False)"},{"question":"You are given two **0-indexed** integer arrays `nums1` and `nums2` of the same length. Both arrays represent the number of widgets produced each day over a period. Each day, you can choose to either keep the widgets produced on that specific day as is, or swap the widgets produced that day in `nums1` with the widgets produced that day in `nums2`. Your goal is to maximize the sum of widgets produced in `nums1` after performing at most one swap operation each day. Return _the maximum possible sum of widgets in `nums1` after the optimal sequence of swap operations_.","solution":"def max_sum_after_swapping(nums1, nums2): Returns the maximum possible sum of widgets in nums1 after the optimal sequence of swap operations. Parameters: nums1 (list of int): The first array representing widgets produced each day. nums2 (list of int): The second array representing widgets produced each day. Returns: int: The maximum sum of nums1 after optimal swaps. max_sum = sum(nums1) current_sum = sum(nums1) for i in range(len(nums1)): # Try swapping swap_sum = current_sum - nums1[i] + nums2[i] # Update current_sum and max_sum if swap_sum is greater if swap_sum > current_sum: current_sum = swap_sum # Ensure max_sum always holds the highest possible sum max_sum = max(max_sum, swap_sum) return max_sum"},{"question":"You are given a list of `n` integers representing the heights of building blocks, and you need to arrange them to form a skyline. The height of a building block at position `i` is denoted by `heights[i]`. A skyline is defined such that no two adjacent buildings have the same height. You are allowed to rearrange the building blocks\' positions. Return _the minimum number of changes required to rearrange the heights list such that no two adjacent buildings have the same height_.","solution":"def min_replacements_for_skyline(heights): This function returns the minimum number of changes required to rearrange the heights array such that no two adjacent buildings have the same height. from collections import Counter # Getting the frequency of each height height_count = Counter(heights) # Find the height with the maximum frequency max_freq_height = max(height_count.values()) # The idea is to place the most frequent height first, # and then interleave other heights to ensure no two adjacent # buildings have the same height. # max_freq_height - 1 is the max number of times we need to make the changes return max(0, max_freq_height - 1)"},{"question":"You are given an array of integers `arr` where each integer represents the number of stones in a pile. In each turn, you need to choose any two piles and remove any number of stones from both piles (at least one stone from each pile). The goal is to minimize the total number of stones left. You can keep performing these steps until you cannot make any more valid moves. Return the minimum number of stones left after you have made all possible moves.","solution":"def minimize_stones(arr): Returns the minimum number of stones left after making all possible moves. import heapq # Convert the list into a max-heap (invert the values for max-heap simulation) neg_arr = [-a for a in arr if a > 0] heapq.heapify(neg_arr) while len(neg_arr) > 1: # Extract the two largest piles first = -heapq.heappop(neg_arr) second = -heapq.heappop(neg_arr) if first > 1 or second > 1: # Reduce both piles by the number of stones from the smaller pile first -= 1 second -= 1 # Add the remaining stones back to the heap if above zero if first > 0: heapq.heappush(neg_arr, -first) if second > 0: heapq.heappush(neg_arr, -second) return sum([-x for x in neg_arr])"},{"question":"You are given a `k x k` square matrix `matrix` containing integers, and an integer `target`. You need to determine whether there exists a **rectangle** within this matrix such that the sum of all the integers within that rectangle is equal to `target`. A **rectangle** within the matrix will be represented as a submatrix formed by selecting a contiguous group of rows and columns. Return a boolean value `_True_` if such a rectangle exists, otherwise return `_False_`.","solution":"def findTarget(matrix, target): Returns True if there exists a rectangle in the given k x k matrix whose sum is equal to the target. Otherwise, returns False. if not matrix: return False rows, cols = len(matrix), len(matrix[0]) # Calculate prefix sums for the matrix prefix_sums = [[0] * (cols + 1) for _ in range(rows + 1)] for r in range(1, rows + 1): for c in range(1, cols + 1): prefix_sums[r][c] = matrix[r-1][c-1] + prefix_sums[r-1][c] + prefix_sums[r][c-1] - prefix_sums[r-1][c-1] # Check all possible rectangles for r1 in range(1, rows + 1): for r2 in range(r1, rows + 1): for c1 in range(1, cols + 1): for c2 in range(c1, cols + 1): rect_sum = prefix_sums[r2][c2] - prefix_sums[r1-1][c2] - prefix_sums[r2][c1-1] + prefix_sums[r1-1][c1-1] if rect_sum == target: return True return False"},{"question":"Given a 2D grid `board` where each cell represents a letter in an alphabet, and a string `word`, return `true` if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Implement a function to search for the word in the grid where each cell has an entry of a single lowercase English letter and the word is composed of lowercase English letters. **Definition of the function:** ```python def exist(board: List[List[str]], word: str) -> bool: ``` **Parameters:** - `board`: `List[List[str]]` - 2D grid of characters - `word`: `str` - target word to be found in the grid **Returns:** - `bool` - `True` if word exists in the grid, `False` otherwise","solution":"from typing import List def exist(board: List[List[str]], word: str) -> bool: rows, cols = len(board), len(board[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[i]: return False temp, board[r][c] = board[r][c], \'#\' found = (dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1)) board[r][c] = temp return found for row in range(rows): for col in range(cols): if board[row][col] == word[0] and dfs(row, col, 0): return True return False"},{"question":"Given an array of integers `nums`, you need to form an ordered sequence where the difference between consecutive elements is either `1` or `-1`. For a given sequence, calculate the sum of the absolute differences between consecutive elements and the sum of the actual differences (without absolute value). Write a function that returns a tuple containing both sums for the best possible sequence that can be formed with the given array. If there are multiple sequences resulting in the same sums, any of them is acceptable. Use the provided function signature: ```python def find_best_sequence(nums: List[int]) -> Tuple[int, int]: ``` **Example:** ```python nums = [4, 3, 2, 3, 4] # Possible sequence: [4, 3, 2, 3, 4] # Absolute differences: [1, 1, 1, 1] # Actual differences: [-1, -1, 1, 1] # Sum of absolute differences: 4 # Sum of actual differences: 0 # Output: (4, 0) ```","solution":"from typing import List, Tuple def find_best_sequence(nums: List[int]) -> Tuple[int, int]: Returns a tuple containing the sum of the absolute differences and the sum of the actual differences for a sequence where the differences between consecutive elements is either 1 or -1. if not nums or len(nums) == 1: return (0, 0) actual_differences = [] abs_differences = [] prev = nums[0] for num in nums[1:]: actual_diff = num - prev abs_diff = abs(actual_diff) # To follow the constraint of difference -1 or 1 if abs_diff != 1: actual_diff = 1 if actual_diff > 0 else -1 abs_diff = 1 actual_differences.append(actual_diff) abs_differences.append(abs_diff) prev = prev + actual_diff # Adjust prev to follow the constraints sum_abs_diff = sum(abs_differences) sum_actual_diff = sum(actual_differences) return (sum_abs_diff, sum_actual_diff)"},{"question":"Given an array of integers `arr`, write a function `canPartitionKSubsets(arr, k)` to determine if it is possible to partition the array into `k` non-empty subsets whose sums are all equal. The function should return `true` if such a partition can be made, and `false` otherwise. *Constraints:* - Each element in the array is a non-negative integer. - It is guaranteed that the total sum of the elements in the array is divisible by `k`.","solution":"def canPartitionKSubsets(arr, k): Determines if the array can be partitioned into k non-empty subsets with equal sums. total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) used = [False] * len(arr) subsets = [0] * k def can_partition(index): if index == len(arr): return all(subset == target_sum for subset in subsets) for i in range(k): if subsets[i] + arr[index] <= target_sum: subsets[i] += arr[index] if can_partition(index + 1): return True subsets[i] -= arr[index] if subsets[i] == 0: break return False return can_partition(0)"},{"question":"You are given a string `s` representing a date in the format \\"YYYY-MM-DD\\". You need to calculate the day of the week for the given date. The input date is always a valid date between the years 1971 and 2100 (inclusive). Implement a function that returns the day of the week for the given date. The output should be one of the following strings: \\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", or \\"Saturday\\".","solution":"from datetime import datetime def day_of_week(date_str): Returns the day of the week for the given date string in format \\"YYYY-MM-DD\\". date = datetime.strptime(date_str, \\"%Y-%m-%d\\") days = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] return days[date.weekday()]"},{"question":"You are given a string `s` consisting of only lowercase English letters. A substring is called a **semi-palindrome** if it can be rearranged to form a palindrome. Your task is to find the **length** of the **longest semi-palindromic substring** of `s`. _Return an integer representing the length of this longest semi-palindromic substring._","solution":"def longest_semi_palindromic_substring(s): Finds the length of the longest semi-palindromic substring of s. A substring is called semi-palindromic if it can be rearranged to form a palindrome. from collections import defaultdict def can_form_palindrome(counter): odd_count = sum(v % 2 for v in counter.values()) return odd_count <= 1 n = len(s) max_length = 0 for start in range(n): counter = defaultdict(int) for end in range(start, n): counter[s[end]] += 1 if can_form_palindrome(counter): max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to determine the length of the smallest substring that, when sorted, would form a palindrome. If no such substring exists, return `-1`. A palindrome is a string that reads the same backward as forward. Only consider substrings with a non-zero length.","solution":"def is_palindrome_possible(s): Returns the length of the smallest substring of s that can be rearranged to form a palindrome, or -1 if no such substring exists. from collections import Counter if not s: return -1 char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If more than one character has an odd count, it\'s not possible to form a palindrome if odd_count > 1: return -1 # A palindrome can be formed by a substring containing all characters, rearranged correctly return len(s)"},{"question":"You are given a string `s`, and a list of queries `queries`. Each query is represented as a pair `[start, end]`, where `start` and `end` denote the starting and ending indices of a substring in `s`. For each query, return the length of the longest palindromic substring in the specified range `[start, end]`. If the substring does not contain any palindromic string, return `0`.","solution":"def longest_palindromic_substring(s, queries): Returns the length of the longest palindromic substring for each query. Args: s: str - Input string queries: List[List[int]] - List of queries where each query is a [start, end] pair Returns: List[int] - List of lengths of the longest palindromic substrings for each query def longest_palindrome(substr): n = len(substr) if n == 0: return 0 # Initialize a table to mark palindromic substrings dp = [[False] * n for _ in range(n)] max_len = 1 for i in range(n): dp[i][i] = True start = 0 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if cl == 2: dp[i][j] = (substr[i] == substr[j]) else: dp[i][j] = (substr[i] == substr[j]) and dp[i + 1][j - 1] if dp[i][j] and cl > max_len: start = i max_len = cl return max_len result = [] for start, end in queries: substr = s[start:end + 1] result.append(longest_palindrome(substr)) return result"},{"question":"You are given a list of integers `arr` representing the positions of stones along a river, sorted in non-decreasing order. Your goal is to determine whether it is possible to cross the river by making a series of jumps. Initially, you are on the first stone at position `arr[0]`, and the goal is to reach the last stone at position `arr[arr.length - 1]`. At each step, if you are on stone at position `arr[i]` and your last jump was `k` units, you can only move to stones at positions `arr[i] + k - 1`, `arr[i] + k`, or `arr[i] + k + 1`. Additionally, you can only start with a jump of 1 unit from the first stone. Return _true_ if you can reach the last stone, or _false_ otherwise.","solution":"def canCross(arr): Determine if a frog can cross the river by making a series of valid jumps. if arr[1] != arr[0] + 1: return False stone_positions = set(arr) n = len(arr) dp = {x: set() for x in arr} dp[arr[0]].add(0) for stone in arr: for jump in dp[stone]: for step in [-1, 0, 1]: next_jump = jump + step if next_jump > 0 and stone + next_jump in stone_positions: dp[stone + next_jump].add(next_jump) return bool(dp[arr[-1]])"},{"question":"You are given a list of tasks represented as integer values, where each task needs to run at a specific interval. Each task takes one unit of time to complete, but there must be at least `n` units of time interval between two instances of the same task. You need to determine the **minimum time** required to complete all the tasks in the list. Implement a function that takes a list `tasks` of characters representing the tasks and an integer `n`, and returns the minimum time required to complete all tasks considering the cooldown period.","solution":"from collections import Counter import heapq def least_interval(tasks, n): Returns the least interval required to finish all the tasks with a cooldown time of n units. :param tasks: List of characters representing tasks :param n: Integer, cooldown period between same tasks :return: Integer, minimum time required to complete all tasks task_counts = Counter(tasks) max_heap = [-count for count in task_counts.values()] heapq.heapify(max_heap) time = 0 while max_heap: i, temp = 0, [] while i <= n: if max_heap: count = heapq.heappop(max_heap) if count < -1: temp.append(count + 1) time += 1 if not max_heap and not temp: break i += 1 for item in temp: heapq.heappush(max_heap, item) return time"},{"question":"Given a binary tree with `n` nodes, each node has a unique value from `1` to `n`. Return the length of the longest path where each node in the path has a value incrementing by `1`. Such a path does not need to start at the root and ends when the incrementing sequence breaks.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_sequence(root): Returns the length of the longest path where each node in the path has a value incrementing by 1 in a binary tree. def dfs(node): if not node: return 0, 0 left_len, max_left_len = dfs(node.left) right_len, max_right_len = dfs(node.right) curr_len = 1 if node.left and node.val + 1 == node.left.val: curr_len = max(curr_len, left_len + 1) if node.right and node.val + 1 == node.right.val: curr_len = max(curr_len, right_len + 1) max_len = max(max_left_len, max_right_len, curr_len) return curr_len, max_len _, max_len = dfs(root) return max_len"},{"question":"You are given a list of non-negative integers `arr` which represents the amount of gas at each gas station. You are also given a list of non-negative integers `cost` which represents the cost of gas needed to travel from that gas station to the next one. Assume you have a car with an unlimited gas tank, but the car starts with an empty tank at one of the gas stations. Return the starting gas station index if you can travel around the circuit once in the clockwise direction, otherwise return `-1`. If there are multiple possible starting gas stations, return the smallest index.","solution":"def can_complete_circuit(gas, cost): Determines the starting gas station index from which you can travel around the circuit once. Parameters: gas (list): List of non-negative integers representing the amount of gas at each gas station. cost (list): List of non-negative integers representing the cost of gas needed to travel to the next gas station. Returns: int: The starting gas station index, or -1 if you cannot complete the circuit. if sum(gas) < sum(cost): return -1 start_station = 0 tank = 0 for i in range(len(gas)): tank += gas[i] - cost[i] if tank < 0: start_station = i + 1 tank = 0 return start_station"},{"question":"Given a binary tree, populate each next pointer to point to its next right node. If there\'s no next right node, the next pointer should be set to `null`. Initially, all next pointers are set to `null`. Example: ``` 1 / 2 3 / 4 5 7 ``` After you\'re done, the next pointers should be set as follows: ``` 1 -> null 2 -> 3 -> null 4 -> 5 -> 7 -> null ``` You must write an algorithm that runs in `O(n)` time complexity, where `n` is the number of nodes in the tree.","solution":"class TreeLinkNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): if not root: return None from collections import deque queue = deque([root]) while queue: prev = None level_size = len(queue) for _ in range(level_size): node = queue.popleft() if prev: prev.next = node prev = node if node.left: queue.append(node.left) if node.right: queue.append(node.right) prev.next = None return root"},{"question":"Given a positive integer `num`, write a function to determine if it is a **palindromic number**. A palindromic number is a number that remains the same when its digits are reversed. Return `true` if `num` is a palindromic number, and `false` otherwise.","solution":"def is_palindromic_number(num): Determine if a positive integer is a palindromic number. Parameters: num (int): The positive integer to check. Returns: bool: True if num is a palindromic number, False otherwise. # Convert the number to a string num_str = str(num) # Check if the string is the same when reversed return num_str == num_str[::-1]"},{"question":"Given two integer arrays `arr1` and `arr2`, both of which are sorted in non-decreasing order and can contain duplicates, merge the two arrays into a single sorted array in non-decreasing order without using any extra space for the merged array (i.e., modify `arr1` to hold the merged result). Assume `arr1` has enough space at the end to hold the elements of `arr2`. Return the modified `arr1` after merging.","solution":"def merge_arrays(arr1, m, arr2, n): Merges two sorted arrays arr1 and arr2 into a single sorted array in-place. The function modifies arr1 to hold the merged result. Args: arr1: List[int] with enough space at the end to hold elements of arr2. m: Number of valid elements initially in arr1. arr2: List[int] n: Number of elements in arr2. Returns: List[int]: The merged array in arr1. # Start from the end of arr1 and arr2 last1, last2 = m - 1, n - 1 last = m + n - 1 # Merge in reverse order while last1 >= 0 and last2 >= 0: if arr1[last1] > arr2[last2]: arr1[last] = arr1[last1] last1 -= 1 else: arr1[last] = arr2[last2] last2 -= 1 last -= 1 # Copy remaining elements of arr2, if any while last2 >= 0: arr1[last] = arr2[last2] last -= 1 last2 -= 1 return arr1"},{"question":"You are given an integer array `nums` containing `n` elements. Your task is to create a new array based on the following transformation rules: 1. The first element of the new array is equal to the first element of `nums`. 2. The last element of the new array is equal to the last element of `nums`. 3. Each remaining element in the new array at index `i` is the sum of the elements in the original array from index `0` to `i-1` (inclusive). Return the new array after applying the transformation rules.","solution":"def transform_array(nums): Transform the array according to the given rules. :param nums: List[int] - The input array of integers. :return: List[int] - The transformed array. if not nums: return [] n = len(nums) result = [0] * n result[0] = nums[0] result[-1] = nums[-1] for i in range(1, n - 1): result[i] = sum(nums[:i]) return result"},{"question":"You are given a **binary tree** where each node contains an integer value. Implement a function that **returns the smallest subtree** containing all the deepest nodes in the binary tree. A node is considered a deepest node if it has the maximum depth in the entire tree; a subtree is defined as a node and all its descendants. If there is a tie for the deepest nodes at the same depth, return the root of the smallest subtree that includes all these deepest nodes. The definition of the smallest subtree here implies the subtree should have the smallest possible height while still containing all the deepest nodes. The input to your function is a binary tree, represented by a TreeNode class with attributes `val`, `left`, and `right`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def subtreeWithAllDeepest(root): Returns the smallest subtree containing all the deepest nodes. def dfs(node): # Perform DFS, return the depth and the subtree if not node: return (0, None) left_depth, left_subtree = dfs(node.left) right_depth, right_subtree = dfs(node.right) if left_depth > right_depth: return (left_depth + 1, left_subtree) elif right_depth > left_depth: return (right_depth + 1, right_subtree) else: return (left_depth + 1, node) return dfs(root)[1]"},{"question":"Given a binary tree, each node has a value from `0` to `1`. You need to prune the tree such that every subtree not containing a `1` is removed. A subtree of a node `node` is `node` plus every node that is a descendant of `node`. Return the pruned binary tree. **Note:** - The binary tree is represented using nodes. - A `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The function should be named `pruneTree` and should have the following signature: ```python def pruneTree(root: TreeNode) -> TreeNode: ``` Use the following `TreeNode` class definition to construct your solution: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root: TreeNode) -> TreeNode: Prunes the binary tree such that every subtree not containing a 1 is removed. :param root: TreeNode :return: TreeNode if not root: return None # Recursively prune the left and right subtrees root.left = pruneTree(root.left) root.right = pruneTree(root.right) # If the current node is 0 and both of its subtrees are None, then it should be pruned (return None) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"A company is conducting interviews for new software developers. They want to schedule the interviews in such a way that no two interviews for the same panel are scheduled at overlapping times. The company has multiple rooms and each interview is assigned to a specific panel. You are given a list of `n` interviews where each interview is represented by a tuple `(start, end, panel)` indicating the start time, end time, and the panel responsible for the interview. The start and end times are given in a 24-hour format without any delimiters (e.g., 1300 for 1:00 PM). Determine the minimum number of rooms required to conduct all interviews without conflicts within the same panel. Return the minimum number of rooms required.","solution":"def min_rooms_required(interviews): Determine the minimum number of rooms required to conduct all interviews without conflicts within the same panel. :param interviews: List of tuples (start, end, panel) indicating the start time, end time, and panel of each interview. :return: Minimum number of rooms required. from collections import defaultdict import heapq # Separate the interviews by panel panels = defaultdict(list) for start, end, panel in interviews: panels[panel].append((start, end)) max_rooms = 0 # Process each panel separately for panel in panels: events = [] for start, end in panels[panel]: events.append((start, 1)) # start time indicates +1 room events.append((end, -1)) # end time indicates -1 room events.sort() # Sort events by time, with start times processed before end times at the same time current_rooms = 0 for _, event in events: current_rooms += event max_rooms = max(max_rooms, current_rooms) return max_rooms"},{"question":"You are given an input string `s`. Return _the length of the longest substring of `s` that is an anagram of a palindrome_. A substring is defined as a contiguous sequence of characters within a string. An anagram of a palindrome is a permutation of a string that forms a palindrome. For example, `\\"aabb\\"` can be rearranged to `\\"abba\\"` which is a palindrome, but `\\"abc\\"` cannot be rearranged to form a palindrome.","solution":"def longest_anagram_of_palindrome_substring(s): Returns the length of the longest substring of `s` that is an anagram of a palindrome. def is_anagram_of_palindrome(sub): count = {} for char in sub: count[char] = count.get(char, 0) + 1 odd_count = 0 for c in count.values(): if c % 2 != 0: odd_count += 1 if odd_count > 1: return False return True n = len(s) max_len = 0 for i in range(n): for j in range(i, n): if is_anagram_of_palindrome(s[i:j+1]): max_len = max(max_len, j - i + 1) return max_len"},{"question":"Implement a data structure called `MyBoundedStack` that supports the following operations on a stack with a fixed maximum capacity: * `MyBoundedStack(int capacity)` - Initializes the stack with a maximum capacity of `capacity`. * `void push(int x)` - Adds an item `x` to the top of the stack if it is not full. If the stack is full, do nothing. * `int pop()` - Removes the item on the top of the stack and returns it. If the stack is empty, return `-1`. * `int top()` - Returns the item on the top of the stack without removing it. If the stack is empty, return `-1`. * `boolean isEmpty()` - Returns `true` if the stack is empty, `false` otherwise. * `boolean isFull()` - Returns `true` if the stack is full, `false` otherwise.","solution":"class MyBoundedStack: def __init__(self, capacity: int): self.capacity = capacity self.stack = [] def push(self, x: int) -> None: if not self.isFull(): self.stack.append(x) def pop(self) -> int: if not self.isEmpty(): return self.stack.pop() return -1 def top(self) -> int: if not self.isEmpty(): return self.stack[-1] return -1 def isEmpty(self) -> bool: return len(self.stack) == 0 def isFull(self) -> bool: return len(self.stack) == self.capacity"},{"question":"Given a string `s` and an integer `k`, return _the string obtained by reversing every `k` characters in `s`_. If there are fewer than `k` characters left at the end, reverse all of them. If there are between `k` and `2k-1` characters left, reverse the first `k` characters and leave the rest as is.","solution":"def reverse_k_characters(s, k): Returns the string obtained by reversing every k characters in s. chars = list(s) for i in range(0, len(chars), 2 * k): # Reverse the first k characters chars[i:i+k] = reversed(chars[i:i+k]) return \'\'.join(chars)"},{"question":"You are given a **0-indexed** integer array `tasks` of length `m` where `tasks[i]` represents the number of minutes required to complete the `i`th task. Additionally, you are given a positive integer `x` which represents the maximum number of minutes you can work consecutively before taking a break. You can choose any task block starting at index `i` and ending at index `j` (`0 <= i <= j < m`) without exceeding `x` minutes in total working time. However, the total working time from `i` to `j` inclusive must include an entire task at each index. Return _the **maximum** number of tasks you can complete consecutively within `x` minutes._","solution":"def max_tasks_within_limit(tasks, x): Return the maximum number of tasks that can be completed consecutively within x minutes. max_tasks = 0 n = len(tasks) for i in range(n): total_time = 0 current_tasks = 0 for j in range(i, n): total_time += tasks[j] if total_time > x: break current_tasks += 1 max_tasks = max(max_tasks, current_tasks) return max_tasks"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Determine if an element occurs more than `n/4` times in the array, where `n` is the length of the array. An element is called a **dominant element** if it appears more than `n/4` times. If there is such an element, return it; otherwise, return -1. Implement the function as follows: * `int findDominantElement(int[] nums)` - This function takes in an integer array `nums` and returns the dominant element if it exists; otherwise, returns -1.","solution":"def find_dominant_element(nums): Returns the dominant element in the sorted array nums if it exists, otherwise returns -1. A dominant element is one that appears more than n/4 times where n is the length of the array. from collections import Counter n = len(nums) threshold = n // 4 count = Counter(nums) for num, freq in count.items(): if freq > threshold: return num return -1"},{"question":"You are given a string `s` consisting only of characters \'a\' and \'b\'. You can remove a subsequence from `s` such that the remaining string becomes a palindrome. A string is a palindrome if it reads the same forward as backward. Return the minimum number of removals needed to make the string a palindrome.","solution":"def min_removals_to_palindrome(s): Returns the minimum number of removals needed to make the string a palindrome. def is_palindrome(s): return s == s[::-1] # If the string is already a palindrome if is_palindrome(s): return 0 # If the string is not a palindrome # It will take at most 1 removal to make it a palindrome # because we can always remove the subsequences between the same characters return 1"},{"question":"You are given a 2D grid representing a map where each cell is either \'1\' (land) or \'0\' (water). An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Write a function that returns the number of islands. The function should explore all four directions around each piece of land and mark it as visited. Consider using Depth-First Search (DFS) for this purpose.","solution":"def num_islands(grid): if not grid: return 0 def dfs(grid, r, c): nr = len(grid) nc = len(grid[0]) if r < 0 or c < 0 or r >= nr or c >= nc or grid[r][c] == \'0\': return grid[r][c] = \'0\' # Mark as visited # Explore in all directions directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(grid, r + dr, c + dc) num_islands = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == \'1\': num_islands += 1 dfs(grid, r, c) return num_islands"},{"question":"Given a list of transactions where each transaction is represented by a string `transactions[i]` in the format `\\"name, time, amount, city\\"`, return a list of invalid transactions. A transaction is considered invalid if: 1. The amount exceeds `1000`. 2. There are two transactions with the same name and the absolute difference in the time of the two transactions is less than or equal to `60` minutes and they occur in different cities. Return the list of invalid transactions in the order they appear in the input list.","solution":"def invalid_transactions(transactions): Identify invalid transactions based on the given conditions. Args: transactions (list of str): List of transactions where each transaction is represented by a string in the format \\"name,time,amount,city\\". Returns: list of str: List of invalid transactions in the order they appear in the input list. n = len(transactions) invalid = [] trans_info = [] for i in range(n): name, time, amount, city = transactions[i].split(\',\') trans_info.append((name, int(time), int(amount), city, transactions[i])) # Check conditions for each transaction for i in range(n): name1, time1, amount1, city1, raw1 = trans_info[i] if amount1 > 1000: invalid.append(raw1) continue for j in range(n): if i != j: name2, time2, amount2, city2, raw2 = trans_info[j] if name1 == name2 and abs(time1 - time2) <= 60 and city1 != city2: invalid.append(raw1) break return invalid"},{"question":"Given a list of integers `nums`, you have to perform a sequence of operations. In each operation, choose any two elements `x` and `y` from the list and remove them, then append the result of their absolute difference `|x - y|` to the list. Repeat this process until only one element remains in the list. Return the value of this last remaining element. If the list initially has no elements, return `0`.","solution":"def last_remaining_element(nums): Given a list of integers `nums`, perform a sequence of operations on the list: 1. Choose any two elements `x` and `y` from the list. 2. Remove them and append the absolute difference `|x - y|` to the list. Repeat until only one element remains in the list. Return the value of this last remaining element. If the list initially has no elements, return `0`. :param nums: List of integers :return: The last remaining element. if not nums: return 0 import heapq nums = [-num for num in nums] heapq.heapify(nums) while len(nums) > 1: x = -heapq.heappop(nums) y = -heapq.heappop(nums) if x != y: heapq.heappush(nums, -(abs(x - y))) return -nums[0] if nums else 0"},{"question":"You are given a list of integers `nums` representing coordinates of stones in a river. The stones are placed in a straight line on a number line. A frog is positioned initially at the first stone (`nums[0]`). Each stone\'s position is a valid coordinate on the number line. The frog can jump forward to the next stone according to the following rules: 1. The frog can only jump to the next stone if the distance to it is one less, equal to, or one more than the distance it previously jumped. 2. The frog\'s first jump has to be exactly 1 unit. Return `true` if the frog can reach the last stone, otherwise, return `false`. Implement the function: ```python def canCross(nums: List[int]) -> bool ```","solution":"from typing import List def canCross(nums: List[int]) -> bool: # Using a dictionary to store positions and the successful jumps that led there stone_positions = {stone: set() for stone in nums} stone_positions[nums[0]].add(0) # initial position with a jump of \'0\' for stone in nums: for jump in stone_positions[stone]: for step in {jump-1, jump, jump+1}: if step > 0 and stone + step in stone_positions: stone_positions[stone + step].add(step) return bool(stone_positions[nums[-1]])"},{"question":"A company has `n` employees, each of whom completes a certain number of tasks each day. You are given an array `tasks`, where `tasks[i][j]` represents how many tasks employee `i` completed on day `j`. You need to find the employee who has completed the most tasks over the given days. Return _the 0-based index of the employee who completed the highest total number of tasks._ If there is a tie, return the index of the employee who reached the tied total first. (Note: You can assume that each employee completed at least one task over the period.)","solution":"def most_tasks_employee(tasks): Returns the index of the employee who completed the most tasks over a period. Args: tasks (list of list of int): A 2D list where tasks[i][j] is the number of tasks completed by employee i on day j. Returns: int: The index of the employee with the highest total number of tasks. max_tasks = -1 best_employee = -1 for i, employee_tasks in enumerate(tasks): total_tasks = sum(employee_tasks) if total_tasks > max_tasks: max_tasks = total_tasks best_employee = i return best_employee"},{"question":"Write a function `findWordSquares(words)` that returns all unique word squares you can build from the provided list of words. A sequence of words forms a valid word square if the k-th row and column read the exact same string, and there is exactly the same number of rows and columns. For example, if `input` words list is `[\\"area\\", \\"lead\\", \\"wall\\", \\"lady\\", \\"ball\\"]`, valid word squares can be: ``` [ [ \\"ball\\", \\"area\\", \\"lead\\", \\"lady\\" ], [ \\"wall\\", \\"area\\", \\"lead\\", \\"lady\\" ] ] ``` You may assume that there are no duplicate words in the given words list and all words are of the same length.","solution":"from collections import defaultdict from typing import List def build_prefix_dict(words: List[str]): prefix_dict = defaultdict(list) for word in words: for i in range(len(word)): prefix_dict[word[:i]].append(word) return prefix_dict def findWordSquares(words): def backtrack(step): if step == n: result.append(list(square)) return prefix = \'\'.join([word[step] for word in square]) for candidate in prefix_dict[prefix]: square.append(candidate) backtrack(step + 1) square.pop() n = len(words[0]) prefix_dict = build_prefix_dict(words) result = [] square = [] for word in words: square.append(word) backtrack(1) square.pop() return result"},{"question":"You are given a 2D grid of integers where each cell can either be `0` (representing water) or `1` (representing land). The grid is surrounded by water on all four sides. An island is a collection of `1`\'s connected 4-directionally (horizontally or vertically) on the grid. Given that there is exactly one island, return the perimeter of this island. The perimeter is the total length of the boundary of the island.","solution":"def island_perimeter(grid): Calculate the perimeter of the island in the given grid. :param grid: List[List[int]] - List of lists representing the 2D grid containing 0\'s and 1\'s :return: int - The perimeter of the island rows = len(grid) if rows == 0: return 0 cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 if r > 0 and grid[r - 1][c] == 1: # Up perimeter -= 2 if c > 0 and grid[r][c - 1] == 1: # Left perimeter -= 2 return perimeter"},{"question":"You are given two strings `s` and `t` both consisting of lowercase English letters. You need to transform string `s` into string `t` by performing a series of operations. In one operation, you can pick a character from `s` and move it to any position in the string (including the beginning and the end). Return the _minimum number of operations needed to transform_ `s` _into_ `t`, or return `-1` if it is impossible to transform `s` into `t`.","solution":"def min_operations_to_transform(s, t): Return the minimum number of operations needed to transform s into t. If it is impossible, return -1. # If the sorted strings are not equal, it\'s impossible to transform s into t if sorted(s) != sorted(t): return -1 # Initialize indices for s and t i = len(s) - 1 j = len(t) - 1 # Initialize the number of operations to 0 operations = 0 # Traverse both strings from the end to the beginning while i >= 0: if s[i] == t[j]: # If the characters are the same, move j to the left j -= 1 else: # If characters are not same, increment operations count operations += 1 # Move i to the left i -= 1 return operations"},{"question":"You are given a 2D integer matrix `matrix` of size `m x n`, and an integer `target`. Your goal is to move from the top-left cell to the bottom-right cell, following these rules: - You can only move down or right at any point in time. - The value of each cell represents the cost of stepping onto that cell. Return the minimum cost to reach the bottom-right cell starting from the top-left cell such that the sum of the path\'s costs is equal to the `target`. If it is not possible to reach the bottom-right cell with the exact `target` cost, return -1.","solution":"def min_cost_to_reach_target(matrix, target): m, n = len(matrix), len(matrix[0]) # DP table to store the minimum cost to reach each cell dp = [[float(\'inf\')] * n for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(m): for j in range(n): if i > 0: dp[i][j] = min(dp[i][j], dp[i - 1][j] + matrix[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j - 1] + matrix[i][j]) # If bottom-right cell cost is exactly target if dp[-1][-1] == target: return dp[-1][-1] return -1"},{"question":"You are given a **0-indexed** 2D integer array `flights` where `flights[i] = [ai, bi, costi]` represents a direct flight from city `ai` to city `bi` with a travel cost of `costi`. You are also given two integers `src` and `dst` representing the starting city and the destination city, respectively, and an integer `k` which is the maximum number of stops allowed. Return _the minimum cost to travel from `src` to `dst` with at most `k` stops_. If there is no such route, return `-1`.","solution":"import heapq from collections import defaultdict, deque def findCheapestPrice(n, flights, src, dst, k): Finds the cheapest price from src to dst with at most k stops. Parameters: n (int): Number of cities flights (List[List[int]]): List of flights where each flight is represented as [ai, bi, costi] src (int): Starting city dst (int): Destination city k (int): Maximum number of stops allowed Returns: int: Minimum cost to travel from src to dst with at most k stops. If no such route exists, returns -1. # Create an adjacency list graph = defaultdict(list) for start, end, cost in flights: graph[start].append((end, cost)) # Min-heap to store (cost, current_city, stops) heap = [(0, src, 0)] # costs dictionary that stores the minimum cost to reach a city with a certain number of stops costs = defaultdict(lambda: float(\'inf\')) costs[(src, 0)] = 0 while heap: current_cost, current_city, stops = heapq.heappop(heap) # If we reach the destination city if current_city == dst: return current_cost # If we have stops available if stops <= k: for next_city, next_cost in graph[current_city]: new_cost = current_cost + next_cost if new_cost < costs[(next_city, stops + 1)]: costs[(next_city, stops + 1)] = new_cost heapq.heappush(heap, (new_cost, next_city, stops + 1)) return -1"},{"question":"You are given a list of strings `words` where each string contains lowercase alphabetical characters. Design a class `WordEncoderDecoder` that provides methods to encode the list of strings into a single string and then decode the single string back into the original list of strings. Implement the `WordEncoderDecoder` class: * `WordEncoderDecoder()`: Initializes the `WordEncoderDecoder` object. * `String encode(List<String> words)`: Encodes the list of strings `words` into a single string. * `List<String> decode(String encodedString)`: Decodes the single string `encodedString` back into the original list of strings. # Example: ```plaintext WordEncoderDecoder encoderDecoder = new WordEncoderDecoder(); List<String> words = Arrays.asList(\\"hello\\", \\"world\\"); String encodedString = encoderDecoder.encode(words); // Encodes the list of strings List<String> decodedWords = encoderDecoder.decode(encodedString); // Decodes the string back to list of strings ``` # Note: * The encoded string must ensure that no ambiguity or loss of data occurs during the encoding and decoding process. * Consider any special characters that may need to be handled to ensure correct decoding.","solution":"class WordEncoderDecoder: def encode(self, words): Encodes the list of strings into a single string. encoded = \'\' for word in words: encoded += f\'{len(word)}#{word}\' return encoded def decode(self, encodedString): Decodes the single string back into the original list of strings. words = [] i = 0 while i < len(encodedString): j = encodedString.find(\'#\', i) length = int(encodedString[i:j]) word = encodedString[j + 1:j + 1 + length] words.append(word) i = j + 1 + length return words"},{"question":"You are given a word list `wordList` where each word consists of lowercase English letters. You are also given two words `beginWord` and `endWord`. Your task is to find the **length of the shortest transformation sequence** from `beginWord` to `endWord` such that: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in the word list. Note that `beginWord` is **not** a transformed word. Include `beginWord` and `endWord` in the transformation process. If there is no possible transformation, return `0`. The transformation sequence is defined as follows: - A sequence of words where each word in the sequence differs by exactly one letter from the previous word, starting from `beginWord` and ending with `endWord`. Return the length of the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such sequence exists.","solution":"from collections import deque def ladderLength(beginWord, endWord, wordList): Returns the length of the shortest transformation sequence from beginWord to endWord if endWord not in wordList or not endWord or not beginWord or not wordList: return 0 L = len(beginWord) all_combo_dict = {} for word in wordList: for i in range(L): new_word = word[:i] + \\"*\\" + word[i+1:] if new_word not in all_combo_dict: all_combo_dict[new_word] = [word] else: all_combo_dict[new_word].append(word) queue = deque([(beginWord, 1)]) visited = {beginWord: True} while queue: current_word, level = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \\"*\\" + current_word[i+1:] for word in all_combo_dict.get(intermediate_word, []): if word == endWord: return level + 1 if word not in visited: visited[word] = True queue.append((word, level + 1)) all_combo_dict[intermediate_word] = [] return 0"},{"question":"Given a list of integers `nums`, determine whether there is a **subsequence** of `nums` such that the sum of the subsequence is equal to half the total sum of `nums`. Return `true` if such a subsequence exists, otherwise return `false`.","solution":"def can_partition(nums): Determine whether there is a subsequence of nums such that the sum of the subsequence is equal to half the total sum of nums. :param nums: List of integers :return: Boolean indicating whether such a subsequence exists total_sum = sum(nums) # If the total sum is odd, we cannot partition it into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array to store subset sums dp = [False] * (target + 1) dp[0] = True # There\'s always a subset sum 0 (empty subset) # Process each number for num in nums: # Update the DP array from right to left for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"You are given a 0-indexed integer array `tasks`, where `tasks[i]` represents the number of hours needed to complete the i-th task. You have a group of `n` workers, and each worker can only work on one task at a time. Each worker can work for exactly `m` hours a day. Distribute the tasks among the workers such that the maximum number of hours any worker ends up working on is minimized. Return this minimized maximum number of hours.","solution":"def minimized_maximum_workload(tasks, n, m): Distribute tasks among workers such that the maximum number of hours any worker ends up working on is minimized. :param tasks: List[int] - List of tasks where tasks[i] is the number of hours needed :param n: int - Number of workers :param m: int - Max hours a worker can work per day :return: int - Minimized maximum number of hours any worker ends up working def can_distribute(max_hours): workers_used = 1 current_worker_hours = 0 for task in tasks: if current_worker_hours + task <= max_hours: current_worker_hours += task else: workers_used += 1 if workers_used > n or task > max_hours: return False current_worker_hours = task return True left = 0 right = sum(tasks) result = right while left <= right: mid = (left + right) // 2 if can_distribute(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a linked list where every node contains a unique integer value. Write a function to return the value of the second to last node in the linked list. If the linked list has fewer than two nodes, return -1.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def second_to_last(head): Returns the value of the second to last node in the linked list. If the linked list has fewer than two nodes, returns -1. if not head or not head.next: return -1 current = head while current.next.next: current = current.next return current.value"},{"question":"Write a function that takes a string containing digits from `\'0\'` to `\'9\'` and a target value. The function should return all possible ways to add the binary operators `\'+\'`, `\'-\'`, and/or `\'*\'` between the digits so they evaluate to the target value. ```python def add_operators(num: str, target: int) -> List[str]: pass ``` # Example: - Input: `num = \\"123\\", target = 6` - Output: `[\\"1+2+3\\", \\"1*2*3\\"]` - Input: `num = \\"232\\", target = 8` - Output: `[\\"2*3+2\\", \\"2+3*2\\"]` - Input: `num = \\"105\\", target = 5` - Output: `[\\"1*0+5\\", \\"10-5\\"]` - Input: `num = \\"00\\", target = 0` - Output: `[\\"0+0\\", \\"0-0\\", \\"0*0\\"]`","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def backtrack(index, path, value, last): if index == len(num): if value == target: result.append(path) return for i in range(index, len(num)): temp_str = num[index:i+1] temp_val = int(temp_str) if i != index and num[index] == \'0\': break if index == 0: backtrack(i + 1, temp_str, temp_val, temp_val) else: backtrack(i + 1, path + \'+\' + temp_str, value + temp_val, temp_val) backtrack(i + 1, path + \'-\' + temp_str, value - temp_val, -temp_val) backtrack(i + 1, path + \'*\' + temp_str, value - last + last * temp_val, last * temp_val) result = [] backtrack(0, \\"\\", 0, 0) return result"},{"question":"Given an array of integers `arr` consisting of `n` elements, where `n` is even, divide the array into two subsets of `equal size` such that the sum of the elements in both subsets is as close as possible. Return the absolute difference between the sums of the two subsets after the division.","solution":"from itertools import combinations def min_difference_partition(arr): n = len(arr) half_n = n // 2 total_sum = sum(arr) target = total_sum // 2 def get_combinations_closest_sum(): best_comb_sum = float(\'inf\') best_comb_diff = float(\'inf\') for comb in combinations(arr, half_n): comb_sum = sum(comb) comb_diff = abs((total_sum - comb_sum) - comb_sum) if comb_diff < best_comb_diff: best_comb_sum = comb_sum best_comb_diff = comb_diff return best_comb_sum half_sum = get_combinations_closest_sum() other_half_sum = total_sum - half_sum return abs(half_sum - other_half_sum)"},{"question":"You are given an **n-ary tree**. An n-ary tree is a rooted tree in which each node has at most `n` children. Each node is represented as a pair of `(val, list_of_children)` where `val` is an integer and `list_of_children` is the list of child nodes. Implement a function to perform a **preorder traversal** of the n-ary tree, which means visiting the root node first, then recursively doing a preorder traversal of each child. The function should return a list of integers representing the values of the nodes in the order they were visited. Implement the function `preorder_traversal(root)` where `root` is the root node of the n-ary tree. The function should return a list of integers representing the preorder traversal of the tree nodes. If the tree is empty, return an empty list. --- Given the n-ary tree, perform a preorder traversal and return the list of node values in the order they were visited.","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def preorder_traversal(root): Perform a preorder traversal of an n-ary tree. :param root: Root node of the n-ary tree :return: List of integers representing the values of the nodes in preorder traversal if root is None: return [] result = [] def traverse(node): if node: result.append(node.val) for child in node.children: traverse(child) traverse(root) return result"},{"question":"Given an array of integers `arr` representing the elevation map where the width of each bar is 1, return _the total amount of **water** that can be trapped after raining_.","solution":"def trap(height): Given an array of integers height representing the elevation map where the width of each bar is 1, return the total amount of water that can be trapped after raining. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"Given an integer array `nums`, return an array of the same length where each element is replaced by the **sum of its adjacent elements**. If an element has only one adjacent element (i.e., it\'s one of the array endpoints), simply return that adjacent element as the replacement. For example, if `nums = [2, 5, 8, 10]`, the result should be `[5, 10, 15, 8]`.","solution":"def sum_of_adjacent(nums): Given an integer array `nums`, return an array where each element is replaced by the sum of its adjacent elements. Parameters: nums (list): A list of integers. Returns: list: A list of integers where each element is the sum of its adjacent elements. if not nums: return [] n = len(nums) # Special case for single element array if n == 1: return nums result = [0] * n for i in range(n): if i == 0: result[i] = nums[i + 1] elif i == n - 1: result[i] = nums[i - 1] else: result[i] = nums[i - 1] + nums[i + 1] return result"},{"question":"Given a sorted array of distinct integers `arr`, write a function to find the smallest positive integer that is missing from the array. Assume that `arr` contains only integers within the range of `-10^6` to `10^6`. Your solution should have a time complexity of O(n) and a space complexity of O(1). Return the smallest missing positive integer.","solution":"def findSmallestMissingPositive(arr): Find the smallest missing positive integer from the sorted array of distinct integers. # Initialize the smallest missing positive integer to 1 missing = 1 for num in arr: if num == missing: missing += 1 elif num > missing: break return missing"},{"question":"You are given an integer array `nums` of length `n`, where all the elements are unique. Define the beauty of the array as the number of distinct prime factors of each element in the array multiplied together. Return the **maximum beauty** for any subarray of the given array `nums`. A subarray is a contiguous subsequence of the array.","solution":"def max_beauty_of_subarray(nums): from math import sqrt def prime_factors(n): Returns the prime factors of a given number n as a set. i = 2 factors = set() while i * i <= n: while (n % i) == 0: factors.add(i) n //= i i += 1 if n > 1: factors.add(n) return factors def beauty_of_subarray(subarray): Returns the beauty of a subarray, which is the product of distinct prime factors of its elements. unique_factors = set() for num in subarray: unique_factors |= prime_factors(num) beauty = 1 for prime in unique_factors: beauty *= prime return beauty n = len(nums) max_beauty = 0 # Evaluate beauty for all possible subarrays for start in range(n): for end in range(start, n): subarray = nums[start:end + 1] max_beauty = max(max_beauty, beauty_of_subarray(subarray)) return max_beauty"},{"question":"You are given an integer array `heights` representing the heights of students in a class, where `heights[i]` is the height of the `i-th` student. The students are standing in a straight line, and you want to create the largest possible group of students that form a \\"staircase\\" where each next student in the group is taller than the previous one. Return the maximum number of students that can form such a \\"staircase\\".","solution":"def max_staircase_students(heights): Returns the maximum number of students that can form a \\"staircase\\". A \\"staircase\\" means every next student is taller than the previous one. :param heights: List[int] - List of students\' heights. :return: int - Maximum number of students to form a \\"staircase\\". if not heights: return 0 n = len(heights) dp = [1] * n # dp[i] will be the length of staircase ending with heights[i] for i in range(1, n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a string `s` representing an arithmetic expression containing just integers and the operators `\'+\'`, `\'-\'`, `\'*\'`, and `\'/\'`, implement a basic calculator to evaluate it and return the result as an integer. The integer division should truncate towards zero. You may assume that the string contains valid arithmetic expressions and has no leading or trailing spaces. The expressions in the input string are always well-formed. Example: ``` Input: \\"3+2*2\\" Output: 7 Input: \\" 3/2 \\" Output: 1 Input: \\" 3+5 / 2 \\" Output: 5 ```","solution":"def calculate(s): def evaluate_expression(tokens): stack = [] current_number = 0 current_operator = \'+\' for token in tokens + [\'+\']: if token.isdigit(): current_number = current_number * 10 + int(token) elif token in \'+-*/\': if current_operator == \'+\': stack.append(current_number) elif current_operator == \'-\': stack.append(-current_number) elif current_operator == \'*\': stack[-1] = stack[-1] * current_number elif current_operator == \'/\': stack[-1] = int(stack[-1] / current_number) current_operator = token current_number = 0 return sum(stack) tokens = list(s.replace(\' \', \'\')) return evaluate_expression(tokens)"},{"question":"You are given an array `heights` representing the heights of buildings in a city, where `heights[i]` is the height of the `i-th` building. A building is considered **unobstructed** if its height is greater than or equal to the height of every building to its right. Return _an array of the indices of the **unobstructed** buildings in ascending order_. For example, given `heights = [4, 2, 3, 1]`, the unobstructed buildings are at indices `[0, 2, 3]` because: - Building 0 (height 4) is taller than buildings 1, 2, and 3. - Building 2 (height 3) is taller than building 3. - Building 3 (height 1) is taller than no buildings to its right. Hence, the result is `[0, 2, 3]`.","solution":"def unobstructed_buildings(heights): Returns the list of indices of unobstructed buildings in ascending order. n = len(heights) unobstructed = [] max_height = float(\'-inf\') for i in range(n - 1, -1, -1): if heights[i] >= max_height: unobstructed.append(i) max_height = heights[i] return unobstructed[::-1] # return in ascending order"},{"question":"Write a function that takes a string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and determines if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type. Your function should return `true` if the string is valid, and `false` otherwise. You must solve the problem using a stack data structure.","solution":"def is_valid_parentheses(s): Determines if the input string containing just the brackets \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is valid. :param s: The input string containing the brackets. :return: True if the string is valid, False otherwise. stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping: top_element = stack.pop() if stack else \'#\' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are given an m x n 2D grid initialized with a starting position marked as \'S\', a goal position marked as \'G\', empty cells marked as \'.\', and obstacle cells marked as \'#\'. You need to determine the minimum number of steps required to reach the goal from the starting position. You can move up, down, left, or right. If the goal cannot be reached, return -1. Write a function that takes the grid as input and returns the minimum number of steps to reach the goal or -1 if it is not possible.","solution":"from collections import deque def min_steps_to_goal(grid): Returns the minimum number of steps required to reach the goal \'G\' from the starting position \'S\' in a 2D grid. If the goal cannot be reached, return -1. rows = len(grid) columns = len(grid[0]) # Directions array for movement (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Find the starting position \'S\' start = None for i in range(rows): for j in range(columns): if grid[i][j] == \'S\': start = (i, j) break if start: break if not start: return -1 # No start position found # BFS to find the shortest path from \'S\' to \'G\' queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set() visited.add(start) while queue: x, y, steps = queue.popleft() if grid[x][y] == \'G\': return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < columns and (nx, ny) not in visited and grid[nx][ny] != \'#\': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1 # Goal not reachable"},{"question":"You are given a 2D grid of size `n x n` where each cell contains a positive integer representing the height of the terrain at that point. Water can flow from one cell to another if and only if the height of the destination cell is less than or equal to the height of the current cell. Water can flow in all four cardinal directions (left, right, up, down). The grid contains two lakes, Lake A located at the top-left cell `(0, 0)` and Lake B located at the bottom-right cell `(n-1, n-1)`. Determine if there exists a path that allows water to flow from Lake A to Lake B. Return _true if such a path exists, or false otherwise_.","solution":"def can_flow_to_both_lakes(grid): if not grid: return False n = len(grid) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(x, y, visited): stack = [(x, y)] visited.add((x, y)) while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] <= grid[cx][cy]: visited.add((nx, ny)) stack.append((nx, ny)) visited_from_a = set() visited_from_b = set() dfs(0, 0, visited_from_a) dfs(n - 1, n - 1, visited_from_b) # If there\'s any common cell in both visited sets, there is a path return len(visited_from_a & visited_from_b) > 0"},{"question":"You are given an integer array `arr` consisting of `n` integers and an integer `target`. Your task is to find tuples `(i, j, k, l)` such that `arr[i] + arr[j] + arr[k] + arr[l]` is equal to `target`, where `0 <= i < j < k < l < n`. Return _the number of such tuples_.","solution":"def four_sum_count(arr, target): Returns the number of unique tuples (i, j, k, l) such that arr[i] + arr[j] + arr[k] + arr[l] == target and 0 <= i < j < k < l < len(arr). from itertools import combinations n = len(arr) count = 0 # Generate all combinations of 4 indices for i, j, k, l in combinations(range(n), 4): if arr[i] + arr[j] + arr[k] + arr[l] == target: count += 1 return count"},{"question":"Given a list of integers `heights` representing the heights of buildings in a linear street, you need to determine how many buildings have an unobstructed view of the sunset. The buildings are standing in a line and the sunset is viewed from the right side (i.e., from the end of the list towards the start). A building has an unobstructed view if there are no taller buildings to its right. Return the number of buildings with an unobstructed view of the sunset.","solution":"def count_sunset_buildings(heights): Returns the count of buildings that have an unobstructed view of the sunset. A building has an unobstructed view if there are no taller buildings to its right. count = 0 max_height = 0 # Traverse the list from right to left for height in reversed(heights): if height > max_height: count += 1 max_height = height return count"},{"question":"Write a function that takes a string `s` as input and returns `true` if it is a valid palindrome after deleting at most one character from it. A string is considered a palindrome if it reads the same forward and backward. Your function should return `false` otherwise.","solution":"def validPalindrome(s: str) -> bool: Returns true if the string s can be a valid palindrome after deleting at most one character. def is_palindrome_range(i, j): Helper function to check if s[i:j+1] is a palindrome. return all(s[k] == s[j-k+i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1) left, right = left + 1, right - 1 return True"},{"question":"You are given a list of non-negative integers `nums` representing the amount of time for each task, and an integer `k`. Each task can be perormed by one machine. However, the machine can only perform a task if it is not overheating. After performing a task with `nums[i]` time, a cooling period of at least `k` time units is required before the machine can take up the next task. Your goal is to determine the minimum time required to complete all tasks. Return _the minimum completion time_ to execute all tasks while adhering to the cooldown rule.","solution":"def minimum_time(nums, k): Returns the minimum completion time to execute all tasks considering the cooling period. Parameters: nums (list of int): A list indicating the time required for each task. k (int): The cooling period required after each task. Returns: int: The minimum completion time. if not nums: return 0 total_time = 0 for i in range(len(nums)): total_time += nums[i] if i < len(nums) - 1: total_time += k return total_time"},{"question":"You are given a list of strings `words` and a list of integers `positions` of the same length. The `positions` list indicates the initial index of each word in the `words` list, i.e., `positions[i]` is the starting index of `words[i]` in the reconstructed sentence. Construct and return the original sentence by arranging the words based on their given positions. The sentence should be a single string with words separated by a single space.","solution":"def reconstruct_sentence(words, positions): Reconstructs the original sentence from the given words and their positions. Args: words: List of words to be arranged. positions: List of integers indicating the initial index of each word. Returns: A single string with words arranged in the correct order separated by a single space. # Create a list of the correct size filled with empty strings sentence = [\\"\\"] * len(words) # Place each word in its correct position for word, position in zip(words, positions): sentence[position] = word # Join the list into a single string with words separated by spaces return \\" \\".join(sentence)"},{"question":"Given an array of `n` integers where each element is either `1` or `-1`, find the length of the longest subarray with a sum of `0`. If no such subarray exists, return `0`. For example, if the input array is `[1, -1, 1, 1, -1, -1]`, the longest subarray with a sum of `0` is `[1, -1, 1, 1, -1, -1]`, and its length is `6`. Return an integer representing the length of the longest subarray with a sum of `0`.","solution":"def longest_zero_sum_subarray(arr): Find the length of the longest subarray with sum zero. Parameters: arr (list): List of integers where each element is either 1 or -1. Returns: int: Length of the longest subarray with sum zero. sum_index_map = {} max_length = 0 current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == 0: max_length = i + 1 elif current_sum in sum_index_map: max_length = max(max_length, i - sum_index_map[current_sum]) else: sum_index_map[current_sum] = i return max_length"},{"question":"You are given a list of `n` courses labeled from `0` to `n - 1` and an array of prerequisites where `prerequisites[i] = [a, b]` indicates that you must take course `b` before taking course `a`. Assume you can always complete all the courses. Create a function that returns the order in which you should take courses to satisfy all prerequisites. If there are multiple valid orders, return any of them.","solution":"from collections import deque, defaultdict def find_course_order(num_courses, prerequisites): Returns the order in which to take courses to satisfy all prerequisites. Parameters: num_courses (int): Total number of courses. prerequisites (list): List of prerequisite pairs Returns: list: Ordered list of courses # Create an adjacency list representation of the graph adj_list = defaultdict(list) in_degree = [0] * num_courses for course, prereq in prerequisites: adj_list[prereq].append(course) in_degree[course] += 1 # Initialize a queue with all courses having zero in-degrees queue = deque([course for course in range(num_courses) if in_degree[course] == 0]) order = [] while queue: current_course = queue.popleft() order.append(current_course) for next_course in adj_list[current_course]: in_degree[next_course] -= 1 if in_degree[next_course] == 0: queue.append(next_course) return order"},{"question":"Given a string `s` containing one or more words, transform it such that each word is reversed but the order of words remains the same. A word is defined as a sequence of non-space characters, separated by spaces. The function should return the transformed string with spacing preserved as in the original string. For example, given `\\"the sky is blue\\"`, your function should return `\\"eht yks si eulb\\"`.","solution":"def reverse_words_in_string(s): Returns a transformed string such that each word in the input string is reversed but the order of words remains the same. return \' \'.join(word[::-1] for word in s.split(\' \'))"},{"question":"You are given a 2D grid `grid` consisting of `\'1\'`s (land) and `\'0\'`s (water). An island is a maximal group of `\'1\'`s connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Given two island locations in the grid, return `true` if they are connected (i.e., there is a path of land from one to the other), and `false` otherwise.","solution":"def are_islands_connected(grid, loc1, loc2): Returns true if two islands are connected, false otherwise. :param grid: List[List[str]]: The 2D grid map of \'1\'s and \'0\'s. :param loc1: Tuple[int, int]: First location (row, col) of the first island. :param loc2: Tuple[int, int]: Second location (row, col) of the second island. if not grid or not grid[0]: return False n, m = len(grid), len(grid[0]) def dfs(x, y, visited): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == \'0\' or (x, y) in visited: return visited.add((x, y)) # explore all 4-connected neighbors for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, visited) visited = set() dfs(loc1[0], loc1[1], visited) return loc2 in visited"},{"question":"You are given a string `s` representing a sentence, where each word is separated by a single space. Each letter in the string is either an uppercase English letter or a lowercase English letter. We define the \\"word score\\" of a word as the sum of the position values of its characters (`\'a\'`=1, `\'b\'`=2, ..., `\'z\'`=26). The position value is case insensitive, so `\'A\'` and `\'a\'` both contribute 1. Write a function that computes the score of each word and returns a list of words sorted by their \\"word score\\" in descending order. If two words have the same score, maintain their original relative order in the sentence.","solution":"def word_score(word): Calculate the word score for a given word. Each letter (\'a\'-\'z\' or \'A\'-\'Z\') has a value which is its position in the alphabet case-insensitive (\'a\' = 1, \'b\' = 2, ..., \'z\' = 26). return sum((ord(char.lower()) - ord(\'a\') + 1) for char in word) def sort_sentence_by_word_scores(s): Returns the words in the sentence sorted by their word score in descending order. words = s.split() # Calculate word scores and store them with original words scored_words = [(word, word_score(word)) for word in words] # Sort the tuple list by score in descending order, keeping original order for equal scores scored_words.sort(key=lambda x: (-x[1], words.index(x[0]))) # Extract the sorted words from the tuple list sorted_words = [word for word, score in scored_words] return sorted_words # Example usage: # s = \\"hello world\\" # print(sort_sentence_by_word_scores(s)) # Output: [\'world\', \'hello\']"},{"question":"Given an integer array `nums` of length `n`, return _the **minimum number of moves** required to make all array elements equal_. In one move, you can increment or decrement an element of the array by 1. The array may contain both positive and negative integers. Minimize the total number of moves by choosing an optimal target value.","solution":"def min_moves_to_equal_elements(nums): Returns the minimum number of moves required to make all elements of the array equal. In one move, you can increment or decrement an element of the array by 1. The optimal choice is to make all elements equal to the median. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"Given a string `s` consisting of only the characters `\'a\'` and `\'b\'`, you can perform the following operation on `s` any number of times: * Choose any two adjacent characters and replace them with a single character that is different from both. For example, you can replace `\\"ab\\"` or `\\"ba\\"` with `\\"c\\"` or `\\"b\\"`, but you cannot replace `\\"aa\\"` or `\\"bb\\"`. Determine the minimum length of the final string that can be obtained after applying the above operation any number of times. Return this minimum length.","solution":"def min_length_final_string(s): Returns the minimum length of the final string after applying the given operation any number of times. # Since each \\"ab\\" or \\"ba\\" operation reduces the length of the string by 1, # the minimum length of the string will be determined by the number of \'a\'s and \'b\'s that can cancel each other out. # Therefore, the result is the absolute difference between the number of \'a\'s and \'b\'s. return abs(s.count(\'a\') - s.count(\'b\'))"},{"question":"You are given an integer array `arr` and a target integer `target`. Determine if there are two distinct indices `i` and `j` in the array such that `arr[i] + arr[j]` equals `target`. You must return `true` if such a pair exists, and `false` otherwise. Try to achieve a solution with a time complexity better than O(n^2).","solution":"def has_pair_with_sum(arr, target): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] equals the target. :param arr: List of integers :param target: Target integer :return: Boolean indicating if such a pair exists seen = set() for number in arr: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5` and `k = 2`, your function should return `4 -> 5 -> 1 -> 2 -> 3`. Return the head of the rotated linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or k == 0: return head # Compute the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Make the list circular tail.next = head # Find the new head which is (length - k % length) steps away from the current head k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"You are given a 2D **grid** of integers where each cell contains a positive integer representing the *height* at that grid position. Your task is to find the maximum **difference in height** between any two adjacent cells in the grid. Two cells are considered adjacent if they share a common side (up, down, left, or right). Return the maximum difference found. The grid will always have at least one row and one column.","solution":"def max_difference(grid): Returns the maximum difference in height between any two adjacent cells in the grid. Args: grid (list of list of int): 2D list representing the grid of heights. Returns: int: The maximum difference in height between any two adjacent cells. rows = len(grid) cols = len(grid[0]) max_diff = 0 for i in range(rows): for j in range(cols): # Check right neighbor if j + 1 < cols: max_diff = max(max_diff, abs(grid[i][j] - grid[i][j + 1])) # Check bottom neighbor if i + 1 < rows: max_diff = max(max_diff, abs(grid[i][j] - grid[i + 1][j])) return max_diff"},{"question":"You are given a string `s` consisting of lowercase English letters, and an array `queries` where `queries[i] = [lefti, righti]`. For each query, determine the number of distinct characters in the substring `s[lefti...righti]`. Return an array `result` where `result[i]` is the answer to the `ith` query. A substring is defined as any consecutive sequence of characters within the string. The goal is to efficiently compute the number of distinct characters for multiple queries on the same string.","solution":"def distinct_characters_in_substrings(s, queries): Given a string `s` and a list of queries, this function returns the number of distinct characters in the substring `s[lefti...righti]` for each query. Args: s (str): The input string consisting of lowercase English letters. queries (List[List[int]]): A list of queries, where each query is a list [lefti, righti]. Returns: List[int]: A list containing the number of distinct characters for each query. result = [] for left, right in queries: substring = s[left:right+1] distinct_chars = set(substring) result.append(len(distinct_chars)) return result"},{"question":"You are given two strings `text1` and `text2`. You want to create a new string by selecting some characters from `text1` and `text2` in a way that maintains the relative order of characters in text1 and text2. The newly created string should be the shortest common supersequence that contains both `text1` and `text2` as subsequences. Write a function that returns the shortest common supersequence. For example, given `text1 = \\"abac\\"` and `text2 = \\"cab\\"`, the shortest common supersequence would be `\\"cabac\\"` because this is the shortest string which has both `text1` and `text2` as subsequences. There might be multiple valid outputs; any of them would be correct.","solution":"def shortest_common_supersequence(text1, text2): Given two strings text1 and text2, returns the shortest common supersequence (SCS) that contains both text1 and text2 as subsequences. m, n = len(text1), len(text2) dp = [[0] * (n+1) for _ in range(m+1)] # Build the DP table for the lengths of the longest common subsequence (LCS) for i in range(1, m+1): for j in range(1, n+1): if text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # Reconstruct the shortest common supersequence from the DP table i, j = m, n scs = [] while i > 0 and j > 0: if text1[i-1] == text2[j-1]: scs.append(text1[i-1]) i -= 1 j -= 1 elif dp[i-1][j] > dp[i][j-1]: scs.append(text1[i-1]) i -= 1 else: scs.append(text2[j-1]) j -= 1 # If either string has remaining characters, add them while i > 0: scs.append(text1[i-1]) i -= 1 while j > 0: scs.append(text2[j-1]) j -= 1 # The constructed scs array is in reverse order; need to reverse it return \'\'.join(reversed(scs))"},{"question":"You are given a binary tree in which each node contains an integer value. Determine if the binary tree is a valid binary search tree (BST). This would mean that for every node: 1. The left subtree of a node contains only nodes with values less than the node\'s value. 2. The right subtree of a node contains only nodes with values greater than the node\'s value. 3. Both, the left and right subtrees must also be binary search trees. Write a function that takes the root node of the binary tree and returns `true` if it is a valid BST, otherwise, it returns `false`. The binary tree is represented in the input as a list of tuples where each tuple contains three elements: (node_value, left_child_value, right_child_value). If a node does not have a left or right child, the corresponding value will be `null`.","solution":"from typing import List, Optional, Tuple class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None def create_tree_node(data: List[Tuple[int, Optional[int], Optional[int]]]) -> Optional[TreeNode]: if not data: return None nodes = {val: TreeNode(val) for val, _, _ in data} for val, left, right in data: if left is not None: nodes[val].left = nodes[left] if right is not None: nodes[val].right = nodes[right] return nodes[data[0][0]] def is_valid_bst(root: Optional[TreeNode]) -> bool: def helper(node: Optional[TreeNode], low: float, high: float) -> bool: if not node: return True if not (low < node.val < high): return False return helper(node.left, low, node.val) and helper(node.right, node.val, high) return helper(root, float(\'-inf\'), float(\'inf\'))"},{"question":"Design a class that represents a Last In First Out (LIFO) stack with an additional operation `getMax()`. Implement the `MaxStack` class: * `MaxStack()` - Initializes the stack. * `void push(int val)` - Pushes the element `val` onto the stack. * `int pop()` - Removes and returns the element on the top of the stack. If the stack is empty, return `-1`. * `int top()` - Returns the element on the top of the stack without removing it. If the stack is empty, return `-1`. * `int getMax()` - Retrieves the maximum element in the stack. If the stack is empty, return `-1`. **Example**: * Pushing values `[5, 1, 5]` onto the stack and calling `getMax()` should return `5`. * Calling `pop()` should return `5` and the stack should be `[5, 1]`. * Calling `getMax()` again should now return `5`. * Calling `pop()` and then `getMax()` should return `1` after the stack becomes `[5]`.","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.max_stack or val >= self.max_stack[-1]: self.max_stack.append(val) def pop(self) -> int: if not self.stack: return -1 val = self.stack.pop() if val == self.max_stack[-1]: self.max_stack.pop() return val def top(self) -> int: if not self.stack: return -1 return self.stack[-1] def getMax(self) -> int: if not self.max_stack: return -1 return self.max_stack[-1]"},{"question":"You are given a string `s` representing a nested list of integers. Implement a function that returns the sum of all integers in the list, weighted by their depth. Each integer is multiplied by its depth in the list. Nested lists are represented as strings. For example, given the string `\\"[1,[4,[6]]]\\"`, the list contains two elements: the first element is an integer `1`, and the second element is a list containing two elements: the first element is `4`, and the second element is a list with one element: `6`. The result for this example would be `1*1 + 4*2 + 6*3 = 27`.","solution":"def depth_sum(s): def helper(nested_list, depth): total = 0 for item in nested_list: if isinstance(item, list): total += helper(item, depth + 1) else: total += item * depth return total import ast nested_list = ast.literal_eval(s) return helper(nested_list, 1)"},{"question":"You are given a **0-indexed** integer array `nums` where `nums[i]` represents the number of stones at the `ith` position in a linear path. A frog is initially located at the first position of the path (i.e., `nums[0]`). The frog can jump to any position ahead of its current position, but it can only make one jump at a time. The frog wants to reach the last position of the path with the **minimum** number of jumps. Additionally, the frog can pick up all the stones located at any position it jumps to. Return _the **minimum** number of jumps_ the frog needs to reach the last position of the path. Your implementation should provide a function: * `int minJumps(int[] nums)` which returns the minimum number of jumps needed by the frog to reach the last position of the path.","solution":"def minJumps(nums): Return the minimum number of jumps needed by the frog to reach the last position of the path. Args: nums (List[int]): a list of integers where nums[i] represents the number of stones at the ith position. Returns: int: the minimum number of jumps needed to reach the last position. n = len(nums) if n == 1: return 0 max_reach = nums[0] steps = nums[0] jumps = 1 for i in range(1, n): if i == n - 1: return jumps max_reach = max(max_reach, i + nums[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"You are given a string `time` that represents a time in the format `\\"HH:MM\\"`. You need to find the next closest time that can be formed by reusing the digits present in the `time` string. The returned time must still be in the format `\\"HH:MM\\"`. If there is no valid next time, return the original `time`.","solution":"def nextClosestTime(time): Given a string time in the format \'HH:MM\', returns the next closest time that can be formed by reusing the digits present in the time string. # Extract digits and sort them digits = sorted(time.replace(\\":\\", \\"\\")) # Extract HH and MM hh, mm = int(time[:2]), int(time[3:]) while True: # Increment the minute mm += 1 if mm == 60: mm = 0 hh += 1 if hh == 24: hh = 0 # Format HH and MM into \'HH:MM\' hh_str = f\\"{hh:02}\\" mm_str = f\\"{mm:02}\\" new_time = hh_str + mm_str # Check if the new time is made of the original digits if all(digit in digits for digit in new_time): return f\\"{hh_str}:{mm_str}\\" # Example usage: nextClosestTime(\\"19:34\\") -> \\"19:39\\""},{"question":"Given a string `s` consisting of lowercase letters and an integer `k`, we want to construct the lexicographically smallest string possible by removing exactly `k` characters from `s`. Design an algorithm that returns this resulting string. The input string `s` will always have at least `k` characters.","solution":"def remove_k_characters(s, k): Returns the lexicographically smallest string by removing exactly k characters from s. stack = [] for char in s: while stack and k > 0 and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still characters to remove while k > 0: stack.pop() k -= 1 return \\"\\".join(stack)"},{"question":"You are given an array of integers `nums` where each integer represents the number of fruits on a tree, arranged in a line. You want to collect the most fruits possible by choosing a range of trees such that you only collect from at most two different types of trees. Return _the maximum number of fruits you can collect in a single range where the range includes trees with at most two different types of fruits._","solution":"def total_fruit(tree): Returns the maximum number of fruits collected from at most two different types of trees. if len(tree) == 0: return 0 max_fruits = 0 fruit_count = {} left = 0 for right in range(len(tree)): if tree[right] in fruit_count: fruit_count[tree[right]] += 1 else: fruit_count[tree[right]] = 1 while len(fruit_count) > 2: fruit_count[tree[left]] -= 1 if fruit_count[tree[left]] == 0: del fruit_count[tree[left]] left += 1 current_fruits = right - left + 1 max_fruits = max(max_fruits, current_fruits) return max_fruits"},{"question":"A **min-heap** is a specialized binary tree data structure in which the root node contains the smallest element, and each parent node is smaller than or equal to its child nodes. Given an integer array `arr`, return _the **k largest** elements in the array_. The output should be in **ascending order**. Implement this using a **min-heap**.","solution":"import heapq def k_largest_elements(arr, k): Returns the k largest elements in the array in ascending order. if k <= 0: return [] if k >= len(arr): return sorted(arr) # Use a min-heap to keep track of the k largest elements min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) return sorted(min_heap)"},{"question":"You are given a list of strings `operations` where each string represents an operation to be performed on a stack. The operations consist of `<integer>` (a string representing a positive or negative integer) which means pushing that integer onto the stack, `POP` which means removing the top element from the stack, and `DUP` which means duplicating the top element of the stack. An initial stack is empty. Your task is to process the list of operations and return the final state of the stack. If an operation cannot be performed (e.g., popping from an empty stack), the stack should remain unchanged for that operation. Return the final stack as a list of integers.","solution":"def process_operations(operations): Processes a list of operations on a stack and returns the final stack. Parameters: operations (list): A list of strings representing operations. Returns: list: The final state of the stack after all operations have been performed. stack = [] for op in operations: if op.isdigit() or (op.startswith(\'-\') and op[1:].isdigit()): stack.append(int(op)) elif op == \\"POP\\" and stack: stack.pop() elif op == \\"DUP\\" and stack: stack.append(stack[-1]) return stack"},{"question":"You are given an array of integers `arr` and an integer `k`. You need to find the length of the longest subsequence of `arr` such that the difference between adjacent elements in the subsequence is less than or equal to `k`. Implement the function `int longestSubsequence(int[] arr, int k)` that returns the length of this subsequence.","solution":"def longest_subsequence(arr, k): Returns the length of the longest subsequence such that the difference between adjacent elements is less than or equal to k. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) <= k: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given an array of integers `heights` representing the height of trees in a forest. The positions of the trees are their indices in the array. Your task is to find a pair of two different trees such that they form the largest rectangle when viewed from the top. The rectangle\'s height is determined by the shorter tree in the pair, and the distance between the trees forms the width. Return _the area of the largest rectangle_ you can form with any two trees in the array.","solution":"def max_rectangle_area(heights): Returns the area of the largest rectangle that can be formed by any two trees in the array. Parameters: heights (list of int): List of integers representing the heights of trees. Returns: int: The area of the largest rectangle. max_area = 0 n = len(heights) for i in range(n): for j in range(i + 1, n): height = min(heights[i], heights[j]) width = j - i area = height * width max_area = max(max_area, area) return max_area"},{"question":"You are given an `m x n` 2D binary grid `grid` which represents a map of `1`s (land) and `0`s (water). An island is a group of continuous `1`s connected vertically or horizontally (not diagonally). You are tasked with finding the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Write a function that returns the number of islands in `grid`. * Implement the function `int numIslands(char[][] grid)` which returns the total number of islands in the given grid.","solution":"def numIslands(grid): Returns the number of islands in the given grid. :param grid: List[List[int]] - 2D binary grid representing the map of \'1\'s (land) and \'0\'s (water). :return: int - the number of islands. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == \'0\': return grid[x][y] = \'0\' # Mark as visited # Visit all adjacent cells dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) number_of_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': number_of_islands += 1 dfs(i, j) return number_of_islands"},{"question":"Given a binary tree, find the **maximum** difference between the value of any node and the value of any ancestor node. The difference is computed as the node value minus the ancestor value. Return this maximum difference. For example, for the binary tree: ``` 8 / 3 10 / 1 6 14 / / 4 7 13 ``` The output should be `7` because the maximum difference is `8 - 1` = `7`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_ancestor_diff(root: TreeNode) -> int: def helper(node, cur_min, cur_max): if not node: return cur_max - cur_min cur_min = min(cur_min, node.val) cur_max = max(cur_max, node.val) left_diff = helper(node.left, cur_min, cur_max) right_diff = helper(node.right, cur_min, cur_max) return max(left_diff, right_diff) return helper(root, root.val, root.val)"},{"question":"You are given an integer array `height` representing the height of each building, and you are tasked to perform a number of daily operations to increase the height of buildings. Each day, choose one building and increase its height by 1. Return the minimum number of days required to make all building heights the same. If it is not possible to make all buildings the same height, return `-1`.","solution":"def min_days_to_equal_heights(heights): Returns the minimum number of days required to make all building heights equal. If it is not possible to make all buildings the same height, returns -1. if not heights: return 0 max_height = max(heights) min_height = min(heights) # If all buildings already have the same height if max_height == min_height: return 0 total_increase_needed = 0 for height in heights: total_increase_needed += max_height - height unique_heights = set(heights) # Check if it\'s a valid configuration to make all heights equal # All buildings should be able to reach the max height if len(unique_heights) > 1 and min_height >= 0: return total_increase_needed else: return -1"},{"question":"A group of friends wants to attend a music festival. They have `n` tickets, each with a unique price. They also have a list of price ranges they are willing to pay for the tickets. Given an array `prices` of length `n`, where `prices[i]` is the price of the `i-th` ticket, and another array `ranges` of tuples, where each tuple `[minPrice, maxPrice]` represents the acceptable price range one friend is willing to pay for their ticket, determine the maximum number of friends that can get a ticket such that each friend gets exactly one ticket and the ticket price falls within their respective price range. Each ticket can only be assigned to one friend. Return the maximum number of friends that can attend the festival.","solution":"def max_friends_with_tickets(prices, ranges): Given a list of ticket prices and a list of acceptable price ranges for each friend, this function returns the maximum number of friends that can get a ticket, such that each friend gets exactly one ticket and the ticket price is within their respective range. # Sort the prices and ranges prices.sort() ranges.sort(key=lambda x: x[1]) tickets_given = 0 for min_price, max_price in ranges: for i in range(len(prices)): if min_price <= prices[i] <= max_price: tickets_given += 1 prices[i] = float(\'inf\') # Mark this price as used break return tickets_given"},{"question":"Suppose you have a function `mysteryFunction` that you want to test. This function takes an integer input `n` and returns a transformed version of the number by reversing the digits and adding it to the original number until the number becomes a palindrome or it reaches a maximum of 25 iterations. Write a function to test the `mysteryFunction` and determine if the final result is a palindrome. Return _True_ if the final result is a palindrome within 25 iterations, otherwise return _False_. You should also return the final number obtained after performing the transformations.","solution":"def is_palindrome(num): Checks if a given number is a palindrome. return str(num) == str(num)[::-1] def reverse_number(num): Reverses the digits of an integer. return int(str(num)[::-1]) def mysteryFunction(n): Transforms a number by reversing it and adding until it becomes a palindrome or reaches 25 iterations. Returns True if the final result is a palindrome within 25 iterations, otherwise returns False. Also returns the final number obtained after performing the transformations. for _ in range(25): reversed_n = reverse_number(n) n += reversed_n if is_palindrome(n): return True, n return False, n"},{"question":"You are given a string `s` containing characters from the set `{\'a\', \'b\', \'c\'}`. The string is valid if it can be constructed from the string `abc` by repeating it zero or more times and possibly deleting some characters. You need to determine if the given string conforms to this rule. Return `true` if the string is valid, and `false` otherwise.","solution":"def is_valid_abc_string(s): Returns True if the string s can be constructed from the string `abc` by repeating it zero or more times and possibly deleting some characters, False otherwise. for char in s: if char not in {\'a\', \'b\', \'c\'}: return False return True"},{"question":"Given a list of non-negative integers `nums` representing the amount of money of each house, you are a professional burglar planning to rob houses along a street. However, due to the neighborhood watch, adjacent houses have security systems connected, which means if two adjacent houses are broken into on the same night, the system will alert the police. Given this constraint, write an algorithm to determine the maximum amount of money you can rob without triggering the alarm. Return the maximum amount you can rob.","solution":"def rob(nums): Calculate the maximum amount of money that can be robbed without triggering the alarm. Args: nums (List[int]): List of non-negative integers representing the amount of money of each house. Returns: int: The maximum amount of money that can be robbed. if not nums: return 0 elif len(nums) == 1: return nums[0] n = len(nums) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given a string `s` consisting of lowercase English letters and a pattern string `p` which is also a string of lowercase English letters. A permutation of `p` is defined as any string formed by rearranging the letters of `p`. Write a function to determine if `s` contains a permutation of `p`. In other words, check if one of `p`\'s permutations is a substring of `s`. Return _true_ if `s` contains such a permutation, otherwise return _false_.","solution":"def contains_permutation(s, p): Returns True if s contains any permutation of p, otherwise False. from collections import Counter p_len = len(p) p_counter = Counter(p) window_counter = Counter(s[:p_len]) if p_counter == window_counter: return True for i in range(p_len, len(s)): window_counter[s[i]] += 1 window_counter[s[i - p_len]] -= 1 if window_counter[s[i - p_len]] == 0: del window_counter[s[i - p_len]] if window_counter == p_counter: return True return False"},{"question":"Given a list of flights where `flights[i] = [origin_i, destination_i, price_i]` represents a flight from the `origin_i` airport to the `destination_i` airport with a cost of `price_i`, and given the number of airports `n` and the number of allowed stops `k`, return _the minimum cost to travel from the source airport to the destination airport while making at most `k` stops._ If there is no such route, return `-1`.","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, src, dst, k): Takes the number of airports n, a list of flights where each flight is represented as [origin, destination, price], the source airport src, the destination airport dst, and the number of allowed stops k. Returns the minimum cost to travel from src to dst with at most k stops. If no such route exists, returns -1. # Build graph graph = defaultdict(list) for origin, destination, price in flights: graph[origin].append((destination, price)) # Use priority queue to store (price, node, stops) heap = [(0, src, 0)] # Dictionary to store the minimum distance to each node # considering the number of stops min_price = {} # Implement Dijkstra\'s-like algorithm with up to k stops while heap: price, node, stops = heapq.heappop(heap) if node == dst: return price if stops > k: continue for neighbor, w in graph[node]: total_price = price + w if (neighbor, stops + 1) not in min_price or total_price < min_price[(neighbor, stops + 1)]: min_price[(neighbor, stops + 1)] = total_price heapq.heappush(heap, (total_price, neighbor, stops + 1)) return -1"},{"question":"Given a list of integers `arr` and an integer `target`, find and return a list of all unique triplets in the array that sum up to the given target. Each triplet should be represented as a sorted list of three integers, and the output list should not contain duplicate triplets. Ensure your solution runs in O(n^2) time complexity where n is the length of the array.","solution":"def three_sum(arr, target): Given a list of integers arr and an integer target, returns a list of all unique triplets in the array that sum up to the given target. Each triplet is sorted and the output list does not contain duplicate triplets. arr.sort() triplets = [] length = len(arr) for i in range(length - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, length - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"John is working with a software system that logs user activities on a web platform. Each activity is represented as a tuple `(userId, timestamp)` where `userId` is a unique identifier for the user, and `timestamp` is the time the activity was logged. Given a list of these activities, John wants to determine the maximum number of unique users that have been active within any time window of size `k`. The time window can start at any of the given timestamps and extends for `k` units of time. Return the maximum number of unique users active in any such time window.","solution":"def max_unique_users(activities, k): Given a list of activities and a time window size k, returns the maximum number of unique users active within any time window of size k. Parameters: activities (list): A list of tuples where each tuple is (userId, timestamp). k (int): The size of the time window. Returns: int: The maximum number of unique users in any time window of size k. activities.sort(key=lambda x: x[1]) # Sort activities by timestamp max_unique = 0 start = 0 window_users = set() for end in range(len(activities)): userId, timestamp = activities[end] window_users.add(userId) # Move the start pointer to maintain the time window size while activities[start][1] <= timestamp - k: if activities[start][0] in window_users: window_users.remove(activities[start][0]) start += 1 max_unique = max(max_unique, len(window_users)) return max_unique"},{"question":"Given an array of integers `arr`, you need to find the minimum number of operations required to make all elements of the array equal. In one operation, you can select a subarray and add the same integer `k` to all the elements in the subarray. Write a function `minOperations(arr, k)` that returns the minimum number of operations. The function has the parameters: * an array of integers `arr` * an integer `k` which is the value that can be added to the elements in each operation.","solution":"def minOperations(arr, k): Returns the minimum number of operations required to make all elements of arr equal by adding the value k to all elements of any subarray in each operation. from collections import Counter def gcd(a, b): while b: a, b = b, a % b return a def gcd_multiple(nums): current_gcd = nums[0] for num in nums[1:]: current_gcd = gcd(current_gcd, num) return current_gcd # Calculate the frequencies of elements in the array frequency = Counter(arr) # If all elements are already the same, no operation is needed if len(frequency) == 1: return 0 # Find the difference between any pair of elements and calculate the gcd of all differences differences = [] unique_elements = list(frequency.keys()) for i in range(1, len(unique_elements)): differences.append(unique_elements[i] - unique_elements[i-1]) # The gcd of the differences must be divisible by k for it to be possible to make all elements equal gcd_diff = gcd_multiple(differences) if gcd_diff % k != 0: return -1 # It\'s impossible to make all elements equal # The minimum operations required is determined by the largest group of identical numbers max_freq = max(frequency.values()) return len(arr) - max_freq"},{"question":"**[Question 4]:** Given a string `text` consisting of lowercase English letters, you can perform the following operation as many times as desired: Pick any two adjacent characters in the string and swap them. Return _the lexicographically largest string_ that can be obtained by performing this operation. **Note:** - A string `a` is lexicographically larger than a string `b` if in the first position where they differ, `a` has a character that appears later in the alphabet than the corresponding character in `b`. - A string of letters is expected, and it should fit within typical constraints for coding competitions.","solution":"def get_lexicographically_largest_string(text): Returns the lexicographically largest string achievable by swapping adjacent characters as needed. return \'\'.join(sorted(text, reverse=True))"},{"question":"You are given a rectangular matrix `mat` of dimensions `m x n`, where each cell in the matrix contains a non-negative integer representing the number of coins placed in that cell. You can start from any cell in the first column and move to any cell in the last column by repeatedly moving to the right, up-right, or down-right. You cannot move outside the matrix. Return _the **maximum** number of coins you can collect starting from any cell in the first column and moving to any cell in the last column_.","solution":"def max_coins(mat): Given a matrix mat of dimensions m x n, determine the maximum number of coins that can be collected starting from any cell in the first column and moving to any cell in the last column by repeatedly moving right, up-right, or down-right. m, n = len(mat), len(mat[0]) # Create a DP table with the same dimensions as mat. dp = [[0] * n for _ in range(m)] # Initialize the first column of the DP table with the same values as the mat. for i in range(m): dp[i][0] = mat[i][0] # Fill the rest of the DP table. for j in range(1, n): for i in range(m): # Collect the coins from the right, upper-right, and lower-right cells. right = dp[i][j-1] up_right = dp[i-1][j-1] if i > 0 else 0 down_right = dp[i+1][j-1] if i < m-1 else 0 dp[i][j] = mat[i][j] + max(right, up_right, down_right) # The result is the maximum value in the last column of the DP table. return max(dp[i][n-1] for i in range(m))"},{"question":"You are given a **0-indexed** integer array `nums`. Calculate and return _the **maximum** sum of any non-empty **contiguous subarray** of_ `nums`_. A contiguous subarray is a subarray consisting of consecutive elements from the original array.","solution":"def max_subarray_sum(nums): Calculates the maximum sum of any non-empty contiguous subarray of nums. if not nums: # Empty input check return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a **0-indexed** integer array `blocks` representing a row of houses, where `blocks[i]` represents the height of the house at index `i`. A painter can paint any house in a single operation but to maximize efficiency, they can only paint continuously increasing subsequences of houses. More formally, a painter can paint houses at indices `i, i + 1, ..., j` such that `blocks[i] <= blocks[i + 1] <= ... <= blocks[j]`. Return _the **minimum** number of operations required to paint all the houses_ in the row if each operation paints one of these increasing subsequences.","solution":"def min_operations(blocks): Returns the minimum number of operations required to paint all the houses. Parameters: blocks (list of int): The heights of the houses. Returns: int: The minimum number of operations. if not blocks: return 0 operations = 1 for i in range(1, len(blocks)): if blocks[i] < blocks[i - 1]: operations += 1 return operations"},{"question":"You are given a **0-indexed** integer array `nums` where each integer represents the number of stones in a pile. On each turn, you may choose any pile of stones and remove any nonzero number of stones from that pile. However, if a player makes the number of stones in at least one pile equal for the second time or more, that player loses. Determine if the first player can guarantee a win if both players play optimally. Return `true` if the first player can always win, and `false` otherwise.","solution":"def can_first_player_win(nums): Determine if the first player can guarantee a win given the rules. Parameters: nums (list): A list of integers representing the number of stones in each pile. Returns: bool: True if the first player can guarantee a win, False otherwise. return any(pile % 2 == 1 for pile in nums)"},{"question":"Given a list of integers `nums` and an integer `k`, return the length of the shortest contiguous subarray whose sum is equal to or greater than `k`. If there is no such subarray, return `-1`. The subarray must contain at least one number. Your algorithm should aim for a time complexity better than `O(n^2)`.","solution":"def min_subarray_len(nums, k): Returns the length of the shortest contiguous subarray whose sum is equal to or greater than \'k\'. If no such subarray exists, returns -1. n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a list of integers and two integers, `x` and `y`, write a function to find the number of **subarrays** where the maximum element of that subarray is less than or equal to `x`, and the minimum element of that subarray is greater than or equal to `y`. Return _the number of such subarrays_ in the list.","solution":"def count_subarrays(arr, x, y): Returns the number of subarrays in which the maximum element is <= x and the minimum element is >= y. n = len(arr) count = 0 for start in range(n): for end in range(start, n): subarray = arr[start:end + 1] if max(subarray) <= x and min(subarray) >= y: count += 1 return count"},{"question":"Given an array of integers `arr` representing the heights of a landscape, where each integer represents a unit width column of the landscape, return the maximum amount of water that can be trapped after it rains. The water trapped is determined by the difference between the height of the landscape and the height of the columns within the trapped water area.","solution":"def trap_rain_water(arr): Returns the maximum amount of water that can be trapped after it rains. Parameters: arr (list): List of integers representing the heights of the landscape. Returns: int: Maximum amount of water that can be trapped. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"You are given a `linked list` where each node contains a unique integer value and potentially a random pointer, which may point to any node in the list or `null`. Your task is to create a **deep copy** of this list. The list is represented with a class `ListNode` with the following attributes: * `val`: an integer representing the value stored at the node. * `next`: a pointer to the next node in the list or `null` if it\'s the end of the list. * `random`: a pointer to any node in the list or `null`. Return the head of the cloned list.","solution":"class ListNode: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copy_random_list(head): if not head: return None # Create a copy of the list nodes while storing the original to copied node mapping old_to_new = {} current = head while current: old_to_new[current] = ListNode(current.val) current = current.next # Reset current back to the head of the list current = head while current: if current.next: old_to_new[current].next = old_to_new[current.next] if current.random: old_to_new[current].random = old_to_new[current.random] current = current.next return old_to_new[head]"},{"question":"A city has a network of `n` one-way roads represented as a directed graph with `n` nodes (intersections) and `m` edges (roads). Each road `i` has a travel time `time[i]`. You are given a list of `edges`, where `edges[i] = [u, v, time[i]]` represents a road from intersection `u` to intersection `v` with travel time `time[i]`. You are also given an integer `k` representing the maximum travel time allowed on any single road. A road can be traveled if and only if its time is less than or equal to `k`. Calculate the number of connected components in the graph where each road\'s travel time does not exceed `k`. A **connected component** is a subset of nodes in the graph such that there is a path between any two nodes in this subset within the constraints.","solution":"def count_connected_components(n, edges, k): Count the number of connected components in the graph where each road\'s travel time is less than or equal to k. Parameters: n (int): The number of intersections. edges (List[Tuple[int, int, int]]): The list of edges, where each edge is represented as a tuple (u, v, time) k (int): The maximum allowed travel time for any road to be considered. Returns: int: The number of connected components. from collections import defaultdict def dfs(node, visited, graph): stack = [node] while stack: current_node = stack.pop() for neighbor in graph[current_node]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # Build the graph with edges that have time <= k graph = defaultdict(list) for u, v, time in edges: if time <= k: graph[u].append(v) graph[v].append(u) visited = set() components = 0 for node in range(n): if node not in visited: components += 1 visited.add(node) dfs(node, visited, graph) return components"},{"question":"A university offers multiple courses, some of which may have prerequisites. You are given a list of courses and a list of prerequisite pairs, where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before you take course `ai`. Suppose you want to find a feasible order in which to complete all courses. Implement a function `findOrder(numCourses, prerequisites)`: - `numCourses` is an integer representing the total number of courses. - `prerequisites` is a list of pairs representing the prerequisite relationships. Return an order in which you can take all the courses. If there are multiple valid orders, return any of them. If it is impossible to finish all courses, return an empty list.","solution":"from collections import deque, defaultdict def findOrder(numCourses, prerequisites): Finds an order in which you can complete all courses. :param numCourses: int, number of courses :param prerequisites: List[List[int]], list of prerequisite pairs :return: List[int], a feasible order to complete all courses or an empty list if impossible indegree = {i: 0 for i in range(numCourses)} adjacency_list = defaultdict(list) # Build graph and compute in-degrees of nodes for course, pre in prerequisites: adjacency_list[pre].append(course) indegree[course] += 1 # Count of courses with no prerequisites zero_indegree_queue = deque([k for k in indegree if indegree[k] == 0]) topological_order = [] while zero_indegree_queue: course = zero_indegree_queue.popleft() topological_order.append(course) for neighbor in adjacency_list[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) if len(topological_order) == numCourses: return topological_order else: return []"},{"question":"You are given a **0-indexed** list of integers `nums`. You need to find the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to `1`. Implement a function `longestSubarray(nums: List[int]) -> int` that returns the length of such a subarray.","solution":"def longestSubarray(nums): Returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to 1. if not nums: return 0 max_length = 1 start = 0 for end in range(1, len(nums)): while abs(nums[end] - nums[start]) > 1: start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a `m * n` 2D grid `grid`, where each cell represents a different colored square. The colors are represented by integers. Two squares are considered connected if they are adjacent and have the same color. The task is to find the number of distinct connected components of color squares in the grid. Return _the number of distinct connected components_. Consider the grid as follows: ``` [ [1, 1, 2, 2], [1, 1, 2, 3], [3, 3, 3, 3], [3, 4, 4, 4] ] ``` For this example, there are `4` connected components: the component with color `1`, the component with color `2`, the component with color `3`, and the component with color `4`.","solution":"def num_connected_components(grid): def dfs(x, y, color, visited): Depth First Search to mark all connected components of the same color stack = [(x, y)] while stack: cx, cy = stack.pop() if (cx, cy) in visited: continue visited.add((cx, cy)) for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited and grid[nx][ny] == color: stack.append((nx, ny)) if not grid: return 0 visited = set() components = 0 for i in range(len(grid)): for j in range(len(grid[0])): if (i, j) not in visited: components += 1 dfs(i, j, grid[i][j], visited) return components"},{"question":"You are given a string `s` that consists of lowercase English letters and a list of pairs of indices in the string `pairs` where each pair `[a, b]` can be swapped. You can swap any number of times the pairs in the list. Return _the lexicographically smallest string_ that `s` can be transformed into after using the swaps. If no swaps are possible, return the original string. The lexicographical order of a string is defined as the dictionary order.","solution":"def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def smallestStringWithSwaps(s, pairs): n = len(s) parent = list(range(n)) rank = [0] * n for x, y in pairs: union(parent, rank, x, y) root_to_component = {} for i in range(n): root = find(parent, i) if root not in root_to_component: root_to_component[root] = [] root_to_component[root].append(i) result = list(s) for component in root_to_component.values(): chars = [s[i] for i in component] chars.sort() for idx, char in zip(sorted(component), chars): result[idx] = char return \'\'.join(result)"},{"question":"Implement a data structure to manage a dynamic set of non-negative integers and support the following operations efficiently: * `SparseArray(int size)` Initializes an array of given size with all elements set to 0. * `void set(int index, int value)` Updates the element at the specified index to `value`. * `int get(int index)` Returns the value of the element at the specified index. * `int find_first(int low, int high)` Finds the first index in the specified range `[low, high]` containing a non-zero value and returns that index. If no such index exists, return -1. Ensure that the implementation is memory-efficient and optimizes for scenarios where most of the elements in the array are zero.","solution":"class SparseArray: def __init__(self, size): Initialize an array of given size with all elements set to 0. self.size = size self.data = {} def set(self, index, value): Update the element at the specified index to value. if value != 0: self.data[index] = value elif index in self.data: del self.data[index] def get(self, index): Returns the value of the element at the specified index. return self.data.get(index, 0) def find_first(self, low, high): Finds the first index in the specified range [low, high] containing a non-zero value and returns that index. If no such index exists, return -1. for index in range(low, high + 1): if self.get(index) != 0: return index return -1"},{"question":"Given a string `s` representing a sequence of moves for a robot, where each character in the string is one of the following: \'L\' for left, \'R\' for right, \'U\' for up, and \'D\' for down. The robot starts at the origin (0, 0) on a 2D plane. After performing all the moves in the string, return `true` if the robot returns to the origin, and `false` otherwise. ___ The provided examples seem to focus on problem-solving in various contexts, such as manipulating elements in a list, maximizing values under constraints, and validating movement paths. The new question adheres to this by posing a problem related to string processing and movement validation while ensuring consistent length, difficulty level, and topic alignment.","solution":"def robot_return_to_origin(s): Returns True if the robot returns to the origin after performing all the moves in string `s`. Moves are \'L\', \'R\', \'U\', \'D\' representing left, right, up, and down respectively. x, y = 0, 0 for move in s: if move == \'L\': x -= 1 elif move == \'R\': x += 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"Given two integers `dividend` and `divisor`, perform an integer division (without using multiplication, division, and mod operator) and return the quotient. If the division result overflows the range of a 32-bit signed integer, return `2^31 - 1` (which is `2147483647`). Additionally, ensure that the division result truncates towards zero (i.e., the quotient is the integer part of the result). Write a function that implements this integer division process.","solution":"def divide(dividend, divisor): Perform integer division of dividend by divisor without using multiplication, division, and mod operator. Return the quotient truncated towards zero. If the result overflows a 32-bit signed integer, return 2147483647. if divisor == 0: raise ValueError(\\"Division by zero is not allowed.\\") # Handling overflow MAX_INT = 2147483647 MIN_INT = -2147483648 # Special case: Most negative number divided by -1 leads to overflow if dividend == MIN_INT and divisor == -1: return MAX_INT # Determine the sign of the result negative = (dividend < 0) != (divisor < 0) # Work with positive values dividend_abs = abs(dividend) divisor_abs = abs(divisor) quotient = 0 # Subtract divisor from dividend until dividend becomes smaller than divisor while dividend_abs >= divisor_abs: temp_divisor = divisor_abs multiple = 1 while dividend_abs >= (temp_divisor << 1): temp_divisor <<= 1 multiple <<= 1 dividend_abs -= temp_divisor quotient += multiple return -quotient if negative else quotient"},{"question":"You are given a grid of size `n x m` with 0-based indices. Each cell in the grid can either be a \'0\' (representing a free cell) or a \'1\' (representing an obstacle). You are currently standing at the top-left corner of the grid (cell (0, 0)), and you want to reach the bottom-right corner of the grid (cell (n-1, m-1)). However, you can only move right or down to adjacent cells that are free (contain a \'0\'). Write a function that determines the number of distinct paths you can take to get from the top-left corner to the bottom-right corner. Since the answer may be large, return it **modulo** `10^9 + 7`.","solution":"def num_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner of the grid, moving only right or down through free cells. MOD = 10**9 + 7 n = len(grid) m = len(grid[0]) # Early exit if starting or ending point is an obstacle if grid[0][0] == \'1\' or grid[n-1][m-1] == \'1\': return 0 # Initialize a dp array with all zeros dp = [[0] * m for _ in range(n)] # Set the starting point dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == \'1\': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"You are given a **binary tree** with `n` nodes. Each node has a unique value between `1` and `n`. Your task is to find the **maximum weighted** path in this tree. The weight of a path is defined as the sum of the values of the nodes included in the path. A path in a binary tree is a sequence of nodes starting from any node and ending at any node in the tree, moving only downwards (both children nodes and the root are considered downward movements). Return the **maximum weight** of any such path in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Given a binary tree, find the maximum weighted path sum. def dfs(node): nonlocal max_sum if not node: return 0 left_gain = max(dfs(node.left), 0) # only take positive gains right_gain = max(dfs(node.right), 0) # only take positive gains current_path_sum = node.val + left_gain + right_gain # Update the global maximum sum max_sum = max(max_sum, current_path_sum) # Return the maximum gain if starting from this node return node.val + max(left_gain, right_gain) max_sum = float(\'-inf\') dfs(root) return max_sum"},{"question":"You are given a list of strings `words` and a string `target`. The string `target` can be formed by concatenating strings from the list `words` in any order and using each string from the list exactly once. Implement the following function: * `bool canFormTarget(List<String> words, String target)` - This function should return `true` if the `target` can be formed using all strings in `words` exactly once, and `false` otherwise. Example: Input: `words = [\\"cat\\", \\"dog\\", \\"god\\", \\"tac\\"]`, `target = \\"catdoggodtac\\"` Output: `true` Input: `words = [\\"cat\\", \\"dog\\", \\"god\\"]`, `target = \\"catdoggodcat\\"` Output: `false` Note: - The input list `words` contains strings with lowercase letters only. - The string `target` contains lowercase letters only. - The length of `words` will be between 1 and 100. - The length of `target` will be between 1 and 1000.","solution":"def canFormTarget(words, target): Checks if the target can be formed by concatenating all strings from the list words exactly once. from collections import Counter # Join all words to form a single string and create a character count combined_words = \'\'.join(words) combined_counter = Counter(combined_words) target_counter = Counter(target) # Check if both Counters match return combined_counter == target_counter"},{"question":"Write a function that accepts an integer array `nums` and an integer `k`. Find the number of unique pairs `(i, j)` where `i != j` and `nums[i] + nums[j] == k`. Each pair should be counted only once, e.g., (1, 2) and (2, 1) are considered the same pair and should only be counted once. Return the count of such unique pairs.","solution":"def count_unique_pairs(nums, k): Finds the number of unique pairs (i, j) in the array nums where i != j and nums[i] + nums[j] == k. nums.sort() seen = set() pairs = set() for num in nums: complement = k - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"You are given a `k`-ary tree with `n` nodes, where each node can have up to `k` children. Each node has a value assigned to it. Write a function to find the **maximum path sum** in the tree, where the path must start at the root node and end at any leaf node. The path must traverse only downwards (i.e., from parent nodes to child nodes). Provide the value of this maximum path sum.","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def max_path_sum(root): Returns the maximum path sum from root to any leaf node. The path must traverse only downwards. if root is None: return 0 if not root.children: return root.value max_child_sum = max(max_path_sum(child) for child in root.children) return root.value + max_child_sum"},{"question":"You are given a list of integers representing the amount of food available each day, `foodAmounts`, over a period of `n` days. You can only eat a portion of the available food each day, and you cannot eat more than the available amount for that day. However, any uneaten food from a day is carried over to the next day (if you eat less than what is available, the remainder adds to the following day\'s total). You are also given an integer `dailyLimit` which indicates the maximum amount of food you can consume each day. Your task is to calculate the total amount of food you will have eaten by the end of the `n` days, given the constraints. Return the total amount of food you have eaten over the `n` days.","solution":"def total_food_consumed(foodAmounts, dailyLimit): Calculate the total amount of food consumed over n days given the daily limit. :param foodAmounts: List[int], list of integers representing food available each day :param dailyLimit: int, maximum amount of food that can be consumed each day :return: int, total amount of food consumed over the period of n days total_consumed = 0 carry_over = 0 for food in foodAmounts: available_food = food + carry_over consumed_today = min(available_food, dailyLimit) total_consumed += consumed_today carry_over = available_food - consumed_today return total_consumed"},{"question":"Given a directed graph represented as an adjacency list, write an algorithm to determine if the graph contains a cycle. If a cycle exists, return **true**; otherwise, return **false**. You are given a 2D integer array `edges` where each `edges[i] = [from, to]` represents a directed edge from node `from` to node `to`. The graph may contain multiple edges and self-loops. Consider an efficient approach to solve this problem, and describe it in detail.","solution":"def has_cycle(edges): from collections import defaultdict def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False graph = defaultdict(list) nodes = set() for u, v in edges: graph[u].append(v) nodes.add(u) nodes.add(v) visited = {node: False for node in nodes} rec_stack = {node: False for node in nodes} for node in nodes: if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"Implement the `MovingAverage` class which calculates the moving average of the last `size` values in a stream of integers: * `MovingAverage(int size)` Initializes the object with the size of the moving average window. * `double next(int val)` Returns the moving average of the last `size` values from the stream after including the current value `val`. Note: The moving average is the sum of the last `size` values in the stream divided by `size`. If the stream contains fewer than `size` values, use the sum of all values in the stream divided by the number of values.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the object with the size of the moving average window. :param size: The size of the moving average window self.size = size self.queue = deque() self.sum = 0 def next(self, val: int) -> float: Returns the moving average of the last size values from the stream after including the current value val. :param val: The next value in the stream :return: The moving average of the last size values self.queue.append(val) self.sum += val if len(self.queue) > self.size: self.sum -= self.queue.popleft() return self.sum / len(self.queue)"},{"question":"Given a list of words `words`, you need to find and return the word that has the maximum product of lengths of two words such that the two words do not share any common characters. If there are multiple pairs with the same product, return any one of them. If no such pair exists, return an empty string. For example, given the list `words = [\\"abcw\\", \\"baz\\", \\"foo\\", \\"bar\\", \\"xtfn\\", \\"abcdef\\"]`, the pair of words \\"abcw\\" and \\"xtfn\\" has the maximum product of lengths that do not share any common characters.","solution":"def max_product_word_pair(words): Returns the word pair that has the maximum product of lengths where the two words do not share any common characters. def no_common_chars(word1, word2): return not set(word1) & set(word2) max_product = 0 best_pair = \\"\\" n = len(words) for i in range(n): for j in range(i + 1, n): if no_common_chars(words[i], words[j]): product = len(words[i]) * len(words[j]) if product > max_product: max_product = product best_pair = (words[i], words[j]) return best_pair if max_product > 0 else \\"\\""},{"question":"Given a list of non-negative integers `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight without alerting the police_. You are not allowed to rob two adjacent houses. Write a function `int rob(vector<int>& nums)` that returns the maximum money that can be robbed. Note: Your solution should have a time complexity of O(n) and a space complexity of O(1).","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. You are not allowed to rob two adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"Given two arrays `nums1` and `nums2` of integers, return an array of their intersection. Each element in the result must be unique, and you may return the result in any order. The solution should have an expected time complexity better than O(n^2). **Note:** * Both arrays may contain duplicates. * The arrays\' lengths are not necessarily equal, but are both guaranteed to be greater than `0`.","solution":"def intersection(nums1, nums2): Returns an array of the intersection of nums1 and nums2 with unique elements. The result can be in any order. # Convert the lists to sets to remove duplicates and for efficient intersection set1 = set(nums1) set2 = set(nums2) # Find the intersection of two sets intersection_set = set1.intersection(set2) # Return the result as a list return list(intersection_set)"},{"question":"You are given an m x n grid `grid` consisting of characters \'W\', \'S\', and \'D\'. Each character represents: - \'W\' -> Wall (an impassable obstacle) - \'S\' -> Safe zone (you can walk through) - \'D\' -> Danger zone (you cannot walk through) You need to determine if there is a path from the top-left corner to the bottom-right corner of the grid, moving only through safe zones (\'S\'). You may only move up, down, left, or right. Return `true` if such a path exists, otherwise return `false`.","solution":"def is_path_exist(grid): Determines if there is a path from the top-left corner to the bottom-right corner, moving only through safe zones (\'S\'). if not grid or not grid[0] or grid[0][0] != \'S\' or grid[-1][-1] != \'S\': return False m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x == m - 1 and y == n - 1: return True visited[x][y] = True for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)): nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == \'S\': if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"You are given a **0-indexed** integer array `nums` of even length, where different elements in the array represent different types of candies with each type designated by a unique integer. You need to distribute these candies equally between two people such that each person gets exactly `n` candies where `n` is the half of the length of the array. Each individual can choose their `n` candies sequentially but you must ensure that the number of different types of candies each person receives is maximized. Return _the **maximum number** of different types of candies each person can have if they both choose optimally_.","solution":"def max_candies_types(nums): Returns the maximum number of different types of candies each person can have. Parameters: nums (list): List of integers representing different types of candies. Returns: int: Maximum number of different types of candies each person can have. unique_candies = len(set(nums)) half_length = len(nums) // 2 return min(unique_candies, half_length)"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). Each node in the binary tree is numbered uniquely. The tree is represented by a dictionary where keys are node values and values are pairs representing the left and right children. For instance, `{1: (2, 3), 2: (4, 5), 3: (6, 7)}` represents a binary tree where node `1` is the root, with `2` and `3` as its children, and so forth. If a node does not have a left or right child, it is represented by `None`. Return a list of lists where each sublist represents a level in the tree.","solution":"from collections import deque def level_order_traversal(tree): Returns the level order traversal of the binary tree. The tree is represented as a dictionary where keys are node values and the values are pairs representing left and right children. if not tree: return [] # Find the root of the tree all_nodes = set(tree.keys()) children_nodes = set(child for left, right in tree.values() for child in (left, right) if child is not None) root = (all_nodes - children_nodes).pop() result = [] queue = deque([root]) while queue: level = [] for _ in range(len(queue)): node = queue.popleft() level.append(node) left, right = tree.get(node, (None, None)) if left is not None: queue.append(left) if right is not None: queue.append(right) result.append(level) return result"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to find all the possible paths from the root node to any leaf node such that the sum of the values along the path is equal to a given target sum. Each path should be represented as a list of node values. Return all such paths in the format of a list of lists. If no such path exists, return an empty list. Note: A leaf node is a node with no children. For example, given the target sum of 22, and the following binary tree: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` One of the resulting paths would be `[5, 4, 11, 2]`. Complete the function: ```python def pathSum(root: TreeNode, targetSum: int) -> List[List[int]]: # Your code here ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root: TreeNode, targetSum: int) -> List[List[int]]: def dfs(node, current_path, total_sum): if not node: return current_path.append(node.val) total_sum += node.val if not node.left and not node.right: if total_sum == targetSum: result.append(list(current_path)) else: if node.left: dfs(node.left, current_path, total_sum) if node.right: dfs(node.right, current_path, total_sum) current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"You are given a **0-indexed** array `rain` of integers representing the amount of rain that falls on each day. Each integer in the array corresponds to a lake, with a unique identifier ranging from `1` to `n`. A value of `0` in the array represents a dry day, which you can use to drain any lake that has previously been filled. If it rains on a lake that is already full and has not been drained, it will flood. Return _an array of integers where each index corresponds to the decision made on that day. For rainy days, return `-1`. For dry days, return the lake number that you decide to drain on that day. If it\'s impossible to avoid flooding, return an empty array_.","solution":"def avoidFlood(rain): Returns an array where each index corresponds to the decision made on that day. For rainy days, return -1. For dry days, return the lake number that you decide to drain. If it\'s impossible to avoid flooding, return an empty array. n = len(rain) lake_to_day = {} dry_days = [] result = [-1] * n for i in range(n): if rain[i] > 0: lake = rain[i] if lake in lake_to_day: if not dry_days: return [] dry_day = None for j, day in enumerate(dry_days): if day > lake_to_day[lake]: dry_day = day break if dry_day is None: return [] result[dry_day] = lake dry_days.pop(j) lake_to_day[lake] = i else: dry_days.append(i) for day in dry_days: result[day] = 1 # Any arbitrary number can replace 1 if needed return result"},{"question":"You are given a 2D grid of integers `grid` which represents a map where each cell contains a certain number of apples. You are to implement an algorithm to calculate the maximum number of apples that can be collected when traveling from the top-left corner of the grid to the bottom-right corner. The travel is restricted to only moving right or down at any point in time. The cell at the top-left corner (0,0) and the cell at the bottom-right corner are always included in the path. Return _the maximum number of apples that can be collected_.","solution":"def max_apples(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"You are given a 2D grid `obstacles` of integers where `obstacles[i][j]` represents the presence of an obstacle in cell `(i, j)`. You are also given a starting point `(startRow, startCol)` and an ending point `(endRow, endCol)`. The grid cells with value 1 represent obstacles and cannot be moved onto, while cells with value 0 are free to move onto. You need to determine the minimum number of steps required for you to travel from the starting point to the ending point. You can move up, down, left, or right, but cannot move diagonally. If the path does not exist, return -1. Return _the minimum number of steps required to travel from_ `(startRow, startCol)` _to_ `(endRow, endCol)`_ or_ -1 _if no path exists_.","solution":"from collections import deque def min_steps(obstacles, startRow, startCol, endRow, endCol): Calculates the minimum number of steps to travel from start to end on a grid with obstacles. rows = len(obstacles) cols = len(obstacles[0]) if obstacles[startRow][startCol] == 1 or obstacles[endRow][endCol] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(startRow, startCol, 0)]) visited = set((startRow, startCol)) while queue: row, col, steps = queue.popleft() if (row, col) == (endRow, endCol): return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and obstacles[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `m`. You need to **rearrange** the elements within `arr` such that the sum of every **continuous** subarray of length `m` is **distinct**. Return _the lexicographically smallest rearrangement_ of `arr` that meets the condition. If it is not possible to obtain such a rearrangement, return `-1` instead. A rearrangement of the array is considered lexicographically smaller if, in the first position where the two arrays differ, the rearranged one has a smaller element.","solution":"def lexicographically_smallest_rearrangement(arr, m): Rearranges the elements within arr to ensure the sum of every continuous subarray of length m is distinct, and returns the lexicographically smallest rearrangement that meets the condition. If not possible to obtain such a rearrangement, return -1. n = len(arr) if m > n: return -1 arr.sort() sums = set() for i in range(n - m + 1): subarray_sum = sum(arr[i:i + m]) if subarray_sum in sums: return -1 sums.add(subarray_sum) return arr"},{"question":"You are given a binary tree where each node contains an integer value. Write a function to return the level order traversal of the tree, where each level is represented as a separate list. The level order traversal of a tree is a breadth-first traversal, where we visit all the nodes at the current depth level before moving on to nodes at the next depth level. The node structure is defined as follows: - `TreeNode`: - `val`: an integer value - `left`: a pointer/reference to the left child - `right`: a pointer/reference to the right child Return _a list of lists containing the values of the nodes at each level of the tree_. Example: For a tree with root node `1`, left child `2`, right child `3`, left child of the left child `4`, and right child of the right child `5`, the level order traversal would be `[[1], [2, 3], [4, 5]]`.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"You are given an array of `logins` where each element is a string of log records in the format `<id>:<timestamp>`. Each login record indicates when a user logged into a system. Your task is to find the user with the highest number of unique logins and return their `<id>`. If there is a tie, return the user with the smallest `<id>` (lexicographically). **Example:** ``` logins = [\\"user1:159431\\", \\"user2:159432\\", \\"user1:159433\\", \\"user3:159434\\", \\"user2:159433\\", \\"user3:159432\\", \\"user2:159435\\", \\"user3:159436\\", \\"user1:159437\\"] ``` **Output:** ``` \\"user1\\" ```","solution":"def most_unique_logins(logins): Finds the user with the highest number of unique logins and returns their <id>. If there\'s a tie, returns the user with the smallest <id>. from collections import defaultdict login_records = defaultdict(set) for login in logins: user_id, timestamp = login.split(\\":\\") login_records[user_id].add(timestamp) max_unique_logins = 0 result_user = None for user_id, timestamps in login_records.items(): if len(timestamps) > max_unique_logins or (len(timestamps) == max_unique_logins and (result_user is None or user_id < result_user)): max_unique_logins = len(timestamps) result_user = user_id return result_user"},{"question":"Given a 2D grid of size `m x n` representing a field of cherries, each cell is one of three possible integers. * `0` means the cell is empty, * `1` means the cell contains a cherry tree, * `-1` means the cell is an obstacle. You can collect cherries by moving from the top-left cell to the bottom-right cell, following only the directions right or down. After reaching the bottom-right cell, you must return to the top-left cell, by moving only up or left. Each time you pass through a cell containing a cherry tree, you pick the cherries, and the cell becomes empty (i.e., it turns to `0`). You cannot pass through a cell containing an obstacle or go outside the boundary of the grid. Develop a function: ```python def collectCherries(grid: List[List[int]]) -> int: ``` This function should receive the grid and return the maximum number of cherries you can collect by following the path described.","solution":"from typing import List def collectCherries(grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) # Using a memoization table to avoid recomputation memo = [[[-1] * n for _ in range(n)] for _ in range(m)] def dp(r1, c1, c2): r2 = r1 + c1 - c2 # Because r1 + c1 - r2 - c2 must always be 0 # If out of bounds or hitting an obstacle return 0 if r1 < 0 or r1 >= m or r2 < 0 or r2 >= m or c1 < 0 or c1 >= n or c2 < 0 or c2 >= n or grid[r1][c1] == -1 or grid[r2][c2] == -1: return float(\'-inf\') # Base case: reaching the bottom-right corner if r1 == m-1 and c1 == n-1: return grid[r1][c1] # Check if already computed if memo[r1][c1][c2] != -1: return memo[r1][c1][c2] # Initial cherries at start or current positions result = grid[r1][c1] if r1 != r2 or c1 != c2: result += grid[r2][c2] # Recursive traversal for all possibilities result += max( dp(r1, c1 + 1, c2 + 1), # right-right dp(r1 + 1, c1, c2 + 1), # down-right dp(r1, c1 + 1, c2), # right-down dp(r1 + 1, c1, c2) # down-down ) # Memoize the calculation result memo[r1][c1][c2] = result return result # Computing the maximum cherries collected starting both from top-left corner max_cherries = dp(0, 0, 0) return max(0, max_cherries)"},{"question":"Given the head of two singly linked lists, determine the node at which the two lists intersect. Assume that the linked lists retain their original structure after the intersection check. For example, if the two linked lists are defined as: ```plaintext ListA: a1 → a2 ↘ c1 → c2 → c3 ↗ ListB: b1 → b2 → b3 ``` The intersecting node is c1. If the two linked lists have no intersection, return `null`. Implement the `Solution` class: * `Solution()`: Initializes the object. * `ListNode getIntersectionNode(ListNode headA, ListNode headB)`: Returns the node at which the intersection of two singly linked lists begins, or `null` if there is no such intersection.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode: if headA is None or headB is None: return None # Use two pointers pA = headA pB = headB # Iterate through both lists while pA is not pB: # If pointer hits the end, move it to the head of the other list if pA is None: pA = headB else: pA = pA.next if pB is None: pB = headA else: pB = pB.next return pA"},{"question":"You are given a binary tree in which each node contains an integer value. Design a function that returns the sum of all values in the tree. The binary tree is defined using the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function that takes the root of the binary tree as input and returns the sum of all node values in the tree. For example: ``` Input: root = [1, 2, 3, 4, 5, 6, 7] Output: 28 ``` In this example, the input binary tree looks like this: ``` 1 / 2 3 / / 4 5 6 7 ``` The sum of all values (1+2+3+4+5+6+7) is 28.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_tree(root): if root is None: return 0 return root.val + sum_of_tree(root.left) + sum_of_tree(root.right)"},{"question":"You are given a list of words `words` and a `startWord`. Your task is to return the longest sequence of words in which each word can be formed by inserting exactly one letter at any given position into the previous word. The sequence must start with `startWord`. If there are multiple sequences of the same length, return the one that appears first lexicographically. If no such sequence can be formed, return an empty list. For example, given `words = [\\"a\\", \\"at\\", \\"bat\\", \\"tabs\\", \\"tab\\", \\"bats\\"]` and `startWord = \\"at\\"`, one possible sequence would be `[\\"at\\", \\"bat\\", \\"tabs\\"]`.","solution":"def find_longest_sequence(words, startWord): def can_form_by_inserting_one_letter(prev_word, new_word): if len(new_word) != len(prev_word) + 1: return False i, j = 0, 0 while i < len(prev_word) and j < len(new_word): if prev_word[i] == new_word[j]: i += 1 j += 1 return i == len(prev_word) words_set = set(words) result = [] def dfs(current_word, sequence): nonlocal result if len(sequence) > len(result): result = sequence candidates = [word for word in words_set if can_form_by_inserting_one_letter(current_word, word)] candidates.sort() # Ensures lexicographical order for word in candidates: words_set.remove(word) dfs(word, sequence + [word]) words_set.add(word) if startWord in words_set: words_set.remove(startWord) dfs(startWord, [startWord]) return result"},{"question":"You are given a binary tree with `n` nodes where each node is uniquely labeled from `0` to `n - 1`. The tree is represented as an integer array `parent`, where `parent[i]` denotes the parent of the `i-th` node. The root of the tree has `parent[root] == -1`. Each node also has a corresponding value in the integer array `value`, where `value[i]` is the value of the `i-th` node. You need to support multiple queries of the following type: for a given node `u` and an integer `x`, determine the number of nodes in the subtree rooted at `u` whose values are greater than `x`. Return an array `result` where `result[j]` is the answer to the j-th query.","solution":"from collections import defaultdict def build_tree(parent): tree = defaultdict(list) root = -1 n = len(parent) for i in range(n): if parent[i] == -1: root = i else: tree[parent[i]].append(i) return tree, root def count_nodes_greater_than_x(tree, values, u, x): def dfs(node): count = 0 if values[node] > x: count += 1 for child in tree[node]: count += dfs(child) return count return dfs(u) def query_subtree_greater_than_x(parent, value, queries): tree, root = build_tree(parent) result = [] for u, x in queries: result.append(count_nodes_greater_than_x(tree, value, u, x)) return result"},{"question":"You are given an **m x n** 2D integer matrix `heights` where `heights[r][c]` represents the height of cell `(r, c)`. A path from cell `(r1, c1)` to cell `(r2, c2)` is a sequence of cells such that one can travel from one cell to another adjacent cell (in the top, bottom, left, or right direction) with the height difference between any two adjacent cells in the path being at most a given value `k`. Your task is to determine if there exists a path from the top-left cell `(0, 0)` to the bottom-right cell `(m-1, n-1)` such that the height difference condition holds true. Return _`true` if such a path exists, or `false` if it does not_.","solution":"def can_reach_bottom_right(heights, k): Determine if a path exists from the top-left to the bottom-right of the heights matrix with the given maximum allowed height difference for adjacent cells. from collections import deque def valid(x, y): return 0 <= x < len(heights) and 0 <= y < len(heights[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] m, n = len(heights), len(heights[0]) visited = [[False for _ in range(n)] for _ in range(m)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if valid(nx, ny) and not visited[nx][ny] and abs(heights[nx][ny] - heights[x][y]) <= k: queue.append((nx, ny)) visited[nx][ny] = True return False"},{"question":"A parking lot keeps track of incoming and outgoing vehicles to maintain a real-time count of the number of available parking spots. Implement the `ParkingSystem` class: * `void addCar(int carType)`: - A car of type `carType` enters the parking lot. There are three types of cars, type 1 is a big car, type 2 is a medium car, and type 3 is a small car. - Each car type has a limited number of spots available, and a car can only park if a spot is available for its type. - The method returns `true` if the car was successfully parked, otherwise it returns `false`. * `void removeCar(int carType)`: - A car of type `carType` leaves the parking lot, freeing up a spot for its car type. - The method returns `true` if a car of this type was successfully removed, otherwise it returns `false`. * `int availableSpots()`: - Returns the total number of parking spots that are available across all car types. Instantiate the `ParkingSystem` class with the number of available spots for each car type upon creation.","solution":"class ParkingSystem: def __init__(self, big: int, medium: int, small: int): self.available_spots = {1: big, 2: medium, 3: small} self.capacity = {1: big, 2: medium, 3: small} def addCar(self, carType: int) -> bool: if self.available_spots[carType] > 0: self.available_spots[carType] -= 1 return True return False def removeCar(self, carType: int) -> bool: if self.available_spots[carType] < self.capacity[carType]: self.available_spots[carType] += 1 return True return False def availableSpots(self) -> int: return sum(self.available_spots.values())"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n-1` and an array of edges where `edges[i] = [a, b]` represents a directed edge from node `a` to node `b`. You are also given two additional arrays `restricted` and `queries`. The `restricted` array contains a list of nodes that are restricted, meaning you cannot visit or pass through these nodes. The `queries` array contains pairs of nodes, and for each pair `[u, v]` in `queries`, you need to determine if there is a valid path from node `u` to node `v` that does not pass through any of the restricted nodes. Return an array of boolean values indicating the result of each query.","solution":"def can_traverse(n, edges, restricted, queries): from collections import defaultdict, deque graph = defaultdict(list) for a, b in edges: graph[a].append(b) restricted_set = set(restricted) def bfs(start, end): if start in restricted_set or end in restricted_set: return False queue = deque([start]) visited = set([start]) while queue: node = queue.popleft() if node == end: return True for neighbor in graph[node]: if neighbor not in visited and neighbor not in restricted_set: visited.add(neighbor) queue.append(neighbor) return False result = [] for u, v in queries: result.append(bfs(u, v)) return result"},{"question":"Anna loves solving puzzles. She recently came across the concept of string compression and decided to apply it to her problem statements. Given a string `s`, Anna wants to perform a run-length encoding on it. The run-length encoding involves replacing each run of consecutive repeated characters with the repetition count followed by the character. Write a function to convert the given string `s` to its run-length encoded form. # Example: - Input: \\"aaabbbc\\" - Output: \\"3a3b1c\\" # Explanation: The given string \\"aaabbbc\\" has: - 3 consecutive \'a\'s, - Followed by 3 consecutive \'b\'s, - Then 1 \'c\'. Thus, its run-length encoded string is \\"3a3b1c\\".","solution":"def run_length_encode(s): Returns the run-length encoded form of the given string s. if not s: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str += str(count) + s[i - 1] count = 1 encoded_str += str(count) + s[-1] return encoded_str"},{"question":"You are given an array of integers `heights` representing the heights of buildings along a street, where `heights[i]` is the height of the building at the `i-th` position. You are standing on the roof of the first building and you want to move to the roof of the last building. You can jump from the roof of a building to another roof if and only if the height of the destination building is less than or equal to your jumping capability which is defined as a fixed positive integer `maxJumpHeight`. Your task is to determine if you can reach the last building from the first building, by making jumps from one building to another based on your jumping capability. Return `true` if you can reach the last building, or `false` otherwise.","solution":"def can_reach_last_building(heights, maxJumpHeight): Determines if you can reach the last building from the first building given the max jump height. Parameters: heights (list of int): The heights of the buildings. maxJumpHeight (int): The maximum height you can jump. Returns: bool: True if you can reach the last building, False otherwise. i = 0 while i < len(heights) - 1: if heights[i + 1] - heights[i] <= maxJumpHeight: i += 1 else: return False return True"},{"question":"You are given a grid representing a field containing `m x n` cells. Each cell can either be empty (represented by `\'0\'`) or contain an obstacle (represented by `\'1\'`). You start at the top-left corner of the field and your goal is to reach the bottom-right corner. You can only move right or down one cell at a time, and cannot move through cells with obstacles. Determine if there is a path from the top-left corner to the bottom-right corner. Implement the `FieldPath` class: * `FieldPath(char[][] grid)` Initializes the object with the grid. * `boolean hasPath()` Returns `true` if there is a path from the top-left to the bottom-right corner, otherwise returns `false`.","solution":"class FieldPath: def __init__(self, grid): self.grid = grid self.m = len(grid) self.n = len(grid[0]) self.visited = [[False] * self.n for _ in range(self.m)] def hasPath(self): if not self.grid or self.grid[0][0] == \'1\' or self.grid[self.m - 1][self.n - 1] == \'1\': return False return self.dfs(0, 0) def dfs(self, i, j): if i == self.m - 1 and j == self.n - 1: return True self.visited[i][j] = True for x, y in [(i + 1, j), (i, j + 1)]: if 0 <= x < self.m and 0 <= y < self.n and not self.visited[x][y] and self.grid[x][y] == \'0\': if self.dfs(x, y): return True self.visited[i][j] = False return False"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to find the length of the longest substring of `s` in which the letters occur in sorted order (from \'a\' to \'z\', not necessarily consecutive). If there are multiple substrings with the same length, return the length of any one of them. For instance, given `s = \\"abacdefg\\"`, the longest substring in which the letters appear in sorted order is `\\"acdefg\\"`, and its length is 6. Similarly, for `s = \\"aabbcc\\"`, the longest substring can be `\\"abc\\"`, and its length is 3.","solution":"def longest_sorted_substring_length(s): Returns the length of the longest substring of s where the letters occur in sorted order. if not s: return 0 max_len = 1 current_len = 1 for i in range(1, len(s)): if s[i] >= s[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"You are given a list of `n` integers `arr` where each integer represents the height of blocks arranged in a line. The blocks are initially stacked from left to right. Your task is to compute the maximum area of water that can be trapped between the blocks after it rains. The water should be contained between higher blocks and the ground level. Return _the maximum area of water_ that can be trapped between the blocks. **Example** - `Input`: arr = [0,1,0,2,1,0,1,3,2,1,2,1] - `Output`: 6 **Explanation**: The maximum water trapped between the blocks is between indices 1 and 9 which gives an area of 6. **Note:** You cannot change the order of the blocks and must consider them in the given sequence.","solution":"def max_water_trapped(arr): Returns the maximum water trapped between the blocks after it rains. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) # Fill right_max array right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"You are given a list of integers `arr` representing a sequence of continuous elements. Your task is to identify if there exists a subarray (contiguous elements) that sums up to `k`. If such a subarray exists, return `true`, otherwise return `false`. Implement the function `boolean hasSubarraySum(int[] arr, int k)` that takes in an array of integers `arr` and an integer `k`, and returns `true` if there is a contiguous subarray that sums up to `k`, otherwise returns `false`. Example: ``` Input: arr = [1, 2, 3, 4, 5], k = 9 Output: true Explanation: The subarray [2, 3, 4] sums up to 9. ```","solution":"def has_subarray_sum(arr, k): Function to determine if there exists a subarray that sums up to k. current_sum = 0 sum_dict = {} for i in range(len(arr)): current_sum += arr[i] # Check if current sum is equal to k if current_sum == k: return True # Check if current_sum - k is in sum_dict if (current_sum - k) in sum_dict: return True # Store the current sum in dictionary sum_dict[current_sum] = True return False"},{"question":"Write a function that takes a string s and returns a new string with the duplicate characters removed, while preserving the original order of characters. For example, if the input string is \\"programming\\", the output should be \\"progamin\\". The function should not use any additional data structures (such as sets or arrays) that dynamically grow with the size of the input. You may assume the input string contains only lowercase English letters and its length is at most 1000. **Example 1:** **Input:** s = \\"programming\\" **Output:** \\"progamin\\" **Example 2:** **Input:** s = \\"abcabc\\" **Output:** \\"abc\\" **Example 3:** **Input:** s = \\"aabbcc\\" **Output:** \\"abc\\" **Constraints:** - `1 <= s.length <= 1000` - `s` consists of only lowercase English letters.","solution":"def remove_duplicates(s): Returns a new string with the duplicate characters removed, while preserving the original order of characters. :param s: Input string :returns: New string with duplicates removed seen = [False] * 26 # There are 26 lowercase English letters result = [] for char in s: if not seen[ord(char) - ord(\'a\')]: seen[ord(char) - ord(\'a\')] = True result.append(char) return \'\'.join(result)"},{"question":"You are given an integer array `arr`. Your task is to find the **length** of the longest contiguous subarray that has a sum equal to a given integer `targetSum`. A contiguous subarray is defined as a sequence of elements within the array with no breaks between them. If there is no such subarray, return `0`. - For example, given `arr = [1, -1, 5, -2, 3]` and `targetSum = 3`, the longest subarray with sum `3` is `[1, -1, 5, -2]` with length `4`. - Given `arr = [-2, -1, 2, 1]` and `targetSum = 1`, the longest subarray with sum `1` is `[2, -1]` with length `2`. Return _the length of the longest contiguous subarray with sum equal to_ `targetSum`.","solution":"def longest_subarray_with_sum(arr, targetSum): Finds the length of the longest contiguous subarray with a sum equal to targetSum. prefix_sum = 0 prefix_sums_map = {0: -1} # To handle cases where subarray starts from index 0 max_length = 0 for i, num in enumerate(arr): prefix_sum += num if prefix_sum - targetSum in prefix_sums_map: max_length = max(max_length, i - prefix_sums_map[prefix_sum - targetSum]) if prefix_sum not in prefix_sums_map: prefix_sums_map[prefix_sum] = i return max_length"},{"question":"You are given two sorted linked lists of integers, `list1` and `list2`. Merge the two linked lists into a single sorted linked list, and return the head of the merged list. The merged list should be made by splicing together the nodes of the two lists, maintaining their relative order from the input. Implement the function `ListNode mergeTwoLists(ListNode list1, ListNode list2)`. Consider the following classes and functions provided: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(list1: ListNode, list2: ListNode) -> ListNode: # Your code here ``` **Example:** - Input: `list1 = [1,2,4], list2 = [1,3,4]` - Output: `[1,1,2,3,4,4]` Function signature: ```python def mergeTwoLists(list1: ListNode, list2: ListNode) -> ListNode: # Return the head of the merged linked list ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(list1: ListNode, list2: ListNode) -> ListNode: dummy = ListNode() current = dummy while list1 and list2: if list1.val <= list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1: current.next = list1 if list2: current.next = list2 return dummy.next"},{"question":"Task Design a **Matrix Multiplication Function**. Objective Write a function that multiplies two matrices of compatible dimensions and returns the result. Your implementation should include a check for dimension compatibility before attempting to multiply the matrices. Guidelines # Function Signature ```python def matrix_multiply(A, B): pass ``` # Input - `A`: A list of lists representing matrix A, where each inner list represents a row of the matrix. - `B`: A list of lists representing matrix B, where each inner list represents a row of the matrix. # Output - A new matrix representing the product of matrices A and B. # Constraints - The number of columns in matrix A should be equal to the number of rows in matrix B to be compatible for multiplication. - Both matrices can be empty, and the function should return an empty matrix in such cases. # Example ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] print(matrix_multiply(A, B)) # Output: [[58, 64], [139, 154]] ``` # Explanation The product of matrices A and B results in a new matrix where each element at position (i, j) is calculated as the sum of element-wise products of row i from matrix A and column j from matrix B. # Constraints 1. Matrices A and B are rectangular. 2. Elements of matrices A and B can be any real numbers. # Notes - If the dimensions of the two matrices are incompatible, raise a ValueError with a message \\"Incompatible dimensions for matrix multiplication\\". - The function should handle matrices with any number of rows and columns, but keep in mind the complexity of your solution, as matrix multiplication can be time-consuming for very large matrices.","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B if they are compatible for multiplication. Args: A: list of lists representing matrix A. B: list of lists representing matrix B. Returns: A resultant matrix which is a product of matrices A and B. # Check if the matrices are compatible for multiplication if len(A) == 0 or len(B) == 0: return [] rows_A = len(A) cols_A = len(A[0]) rows_B = len(B) cols_B = len(B[0]) if cols_A != rows_B: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Initialize the result matrix with zeroes result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"}]'),F={name:"App",components:{PoemCard:I},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},N={class:"card-container"},C={key:0,class:"empty-state"},z=["disabled"],S={key:0},E={key:1};function D(i,e,u,c,a,s){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[b,a.searchQuery]]),a.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")}," ✕ ")):l("",!0)]),t("div",N,[(n(!0),r(y,null,w(s.displayedPoems,(o,g)=>(n(),v(f,{key:g,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),r("div",C,' No results found for "'+h(a.searchQuery)+'". ',1)):l("",!0)]),s.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[a.isLoading?(n(),r("span",E,"Loading...")):(n(),r("span",S,"See more"))],8,z)):l("",!0)])}const G=m(F,[["render",D],["__scopeId","data-v-17785d41"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/12.md","filePath":"library/12.md"}'),P={name:"library/12.md"},W=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{M as __pageData,W as default};
