import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,m,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-a0602b24"]]),S=JSON.parse('[{"question":"# Hit Probability in a Circular Field You are developing a game where a player shoots arrows at a target represented by a circle on a 2D plane. For a simulation task, you need to determine the probability of hitting the target based on multiple shooting attempts. Task Write a function `hit_probability` that calculates the probability of hitting the circular target given the results of multiple shots. Function Signature ```python def hit_probability(radius: float, shots: list[tuple[float, float]]) -> float: pass ``` Input - `radius` (float): The radius of the circular target. It should be a positive value. - `shots` (list of tuples): A list of coordinates representing the positions where the shots landed. Each tuple contains two floats representing the x and y coordinates of a shot. Output - Returns the probability (float) of hitting the target, which is the ratio of the number of shots that landed inside or on the target to the total number of shots. Constraints - Radius should be a positive number. - The list of shots can be empty or contain any number of shot coordinates. Errors - The function should raise a `ValueError` if the radius is not positive. Examples ```python hit_probability(5.0, [(0,0), (3,4), (6,8), (5,0)]) # Should return 0.75 because 3 out of 4 shots are within the radius hit_probability(3.0, [(3,3), (0,0), (-3,-3)]) # Should return 0.333 because 1 out of 3 shots are within the radius hit_probability(2.0, [(1,1), (2,2)]) # Should return 0.5 because 1 out of 2 shots are within the radius hit_probability(1.0, [(1,0.5), (1,1), (0,1)]) # Should return 1.0 because 3 out of 3 shots are within the radius hit_probability(3.0, []) # Should return 0.0 because there are no shots ``` Hints - A shot is considered within the target if the distance from the origin to the shot coordinates `(x, y)` is less than or equal to the radius, i.e., ( sqrt{x^2 + y^2} leq text{radius} ).","solution":"import math def hit_probability(radius: float, shots: list[tuple[float, float]]) -> float: if radius <= 0: raise ValueError(\\"Radius must be a positive number\\") if not shots: return 0.0 hits = 0 for x, y in shots: distance = math.sqrt(x**2 + y**2) if distance <= radius: hits += 1 return hits / len(shots)"},{"question":"# Problem Statement: You are given a list of integers, and your task is to reorder the list such that the first element is the maximum value, the second element is the minimum value, the third element is the second maximum, the fourth element is the second minimum, and so on. # Function Signature: ```python def reorder_list(nums: List[int]) -> List[int] ``` # Input: - `nums` (List[int]): A list of integers (1 ≤ len(nums) ≤ 10^5, -10^9 ≤ nums[i] ≤ 10^9) # Output: - (List[int]): The reordered list according to the described rules. # Constraints: - The function should operate efficiently with a maximum time complexity of O(n log n). - Consider edge cases such as an empty list, a single-element list, and when all elements are the same. # Example: ```python # Example 1: reorder_list([1, 3, 2, 5, 4]) # Returns: [5, 1, 4, 2, 3] # Example 2: reorder_list([10, -1, 2, 11, -5]) # Returns: [11, -5, 10, -1, 2] # Example 3: reorder_list([3]) # Returns: [3] # Example 4: reorder_list([]) # Returns: [] ``` # Hints: - Use sorting to efficiently arrange the elements first. - Consider using two pointers to alternately select the maximum and minimum values from the sorted list. - Ensure to handle the list in-place if possible, to minimize additional space usage. # Additional Context: The task requires careful rearrangement of the elements to ensure the alternating pattern is maintained. Efficient use of sorting and two-pointer technique can greatly simplify the implementation.","solution":"from typing import List def reorder_list(nums: List[int]) -> List[int]: Reorders the list such that the first element is the maximum value, the second element is the minimum value, the third element is the second maximum, the fourth element is the second minimum, and so on. if not nums: return [] nums.sort() result = [] left, right = 0, len(nums) - 1 while left <= right: if left == right: result.append(nums[left]) else: result.append(nums[right]) result.append(nums[left]) left += 1 right -= 1 return result"},{"question":"# Problem Statement Design a function `find_common_elements(matrix)` that finds all the common elements present in each row of a given matrix. # Function Signature ```python def find_common_elements(matrix: list[list[int]]) -> list[int]: pass ``` # Input - `matrix`: A list of lists of integers where each inner list represents a row of the matrix. # Output - A list of integers that are common to all rows of the matrix. # Constraints - Each row in the `matrix` contains at least 1 element. - All elements in the matrix are integers, and their values range between `-1000` and `1000`. - The matrix has at least 1 row and at most 100 rows. - Each row has at least 1 element and at most 100 elements. # Example ```python matrix1 = [ [1, 2, 3, 4, 5], [2, 3, 5, 8, 10], [2, 3, 6, 7, 9] ] find_common_elements(matrix1) # Expected output: [2, 3] matrix2 = [ [10, 15, 20, 25], [15, 20, 35, 40, 50], [5, 15, 20, 30] ] find_common_elements(matrix2) # Expected output: [15, 20] ``` # Notes - The order of the output list does not matter. - If there are no common elements across all rows, the function should return an empty list. - Consider edge cases such as a matrix with only one row or a matrix with rows that have no common elements.","solution":"def find_common_elements(matrix: list[list[int]]) -> list[int]: if not matrix: return [] # Initialize the common elements set with the first row\'s elements common_elements = set(matrix[0]) # Iterate through the rest of the rows and perform intersection for row in matrix[1:]: common_elements.intersection_update(row) return list(common_elements)"},{"question":"# Scenario You are tasked with developing a system to measure and evaluate the performance of software applications. One of the key metrics is the average response time of a system over a specific period. You have access to predefined functions that fetch system response times. # Task Create a function that calculates the average response time of the system over a given period by utilizing the `get_response_times(start, end)` function. # Function Signature ```python def average_response_time(start: datetime, end: datetime) -> float: pass ``` # Input and Output * **Input**: * `start`: A `datetime` object representing the start of the time period. * `end`: A `datetime` object representing the end of the time period. * **Output**: * Returns a float representing the average response time over the specified period. # Constraints * Utilize the provided `get_response_times(start, end)` function to fetch data. * Assume that the API provides data consistently and without delays. * The `start` time should be before or equal to the `end` time. * Handle edge cases such as no response times within the specified period. # Example ```python from datetime import datetime start_time = datetime(2023, 1, 1, 0, 0, 0) end_time = datetime(2023, 1, 2, 0, 0, 0) result = average_response_time(start_time, end_time) print(result) # Expected to print the average response time for the period from 2023-01-01 00:00:00 to 2023-01-02 00:00:00 ``` # Performance Requirements Ensure the function handles large data sets efficiently and processes the response times within reasonable limits. Optimize for accuracy and performance in varying system loads and durations.","solution":"from datetime import datetime from typing import List def get_response_times(start: datetime, end: datetime) -> List[float]: Mock function to simulate fetching of response times. In an actual implementation, this function would fetch data from a database or monitoring system. # Sample data for demonstration: sample_data = { (datetime(2023, 1, 1, 0, 0, 0), datetime(2023, 1, 1, 23, 59, 59)): [200, 210, 190, 220], (datetime(2023, 1, 2, 0, 0, 0), datetime(2023, 1, 2, 23, 59, 59)): [230, 250, 240, 210], } return sample_data.get((start, end), []) def average_response_time(start: datetime, end: datetime) -> float: Calculate the average response time of the system over the given period. Parameters: start (datetime): The start of the time period. end (datetime): The end of the time period. Returns: float: The average response time over the specified period. response_times = get_response_times(start, end) if not response_times: # Handle the case with no data return 0.0 return sum(response_times) / len(response_times)"},{"question":"# Coding Assessment Question As a data analyst at a logistics company, you have been tasked with developing a program to optimize delivery routes for a fleet of delivery vehicles. The program should identify the shortest route that a delivery vehicle can take, from the starting point to the final destination, passing through all specified delivery locations exactly once. Your tasks are: 1. **Implement the Travelling Salesman Problem (TSP):** - Create a function that uses a nearest neighbor heuristic to solve the TSP. - The function should take a list of delivery locations represented as (x, y) coordinates and output the order in which to visit these locations to minimize the total travel distance. 2. **Optimize the algorithm:** - Enhance the solution to check for possible improvements by using pairwise exchange (2-opt algorithm) to reduce the total travel distance further. - Implement this additional optimization as a separate function called `two_opt`. 3. **Calculate the total distance:** - Write a function `calculate_distance` to compute the total travel distance for a given route. - Ensure this function handles floating-point arithmetic accurately, especially for distances with many decimals. 4. **Handle large datasets:** - Ensure that your algorithm performs efficiently with up to 100 delivery locations. - Implement appropriate data handling to avoid memory issues when dealing with large datasets. **Input:** - A list of tuples representing delivery locations\' coordinates (e.g., `[(x1, y1), (x2, y2), ..., (xn, yn)]`). **Output:** - A list of indices representing the optimized order of delivery locations. - The total travel distance for the route in a floating-point number format. **Constraints:** - Each location is represented as a tuple of two floating-point numbers. - The input list contains at least 2 and at most 100 locations. - Ensure that the functions are designed to handle precision issues due to the floating-point representation. **Scenario Context:** Imagine a logistics company aiming to minimize delivery times and fuel consumption by optimizing the routes of their delivery fleet. Efficient route planning will lower operational costs and enhance customer satisfaction by ensuring timely deliveries. The algorithm you develop will be pivotal in achieving these goals.","solution":"import math from itertools import permutations def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def calculate_distance(route, locations): Calculate the total travel distance for the given route. total_distance = 0 for i in range(len(route)): total_distance += euclidean_distance(locations[route[i - 1]], locations[route[i]]) return total_distance def nearest_neighbor(locations): Nearest neighbor heuristic for solving TSP. num_locations = len(locations) unvisited = set(range(num_locations)) current_location = 0 route = [current_location] unvisited.remove(current_location) while unvisited: nearest = min(unvisited, key=lambda location: euclidean_distance(locations[current_location], locations[location])) route.append(nearest) unvisited.remove(nearest) current_location = nearest return route def two_opt(route, locations): Improve the route using the 2-opt algorithm. best_route = route best_distance = calculate_distance(route, locations) improved = True while improved: improved = False for i in range(1, len(route) - 1): for j in range(i + 1, len(route)): if j - i == 1: continue # Cannot swap adjacent edges new_route = route[:i] + route[i:j][::-1] + route[j:] new_distance = calculate_distance(new_route, locations) if new_distance < best_distance: best_route = new_route best_distance = new_distance improved = True route = best_route return best_route def optimize_route(locations): init_route = nearest_neighbor(locations) final_route = two_opt(init_route, locations) total_distance = calculate_distance(final_route, locations) return final_route, total_distance"},{"question":"# Problem Context You are developing a simulation tool that models the motion of projectiles under the influence of gravity and other external forces. Users can define initial conditions and observe the trajectory of the projectiles through a graphical interface. # Task Implement the `Projectile` class to simulate and compute the projectile\'s path given initial velocity, angle, and other parameters. Include methods to compute the position at any time `t` and to plot the trajectory. # Function Signature ```python class Projectile: def __init__(self, initial_velocity: float, launch_angle: float, initial_position: tuple[float, float] = (0, 0)): ... def position_at_time(self, t: float) -> tuple[float, float]: ... def plot_trajectory(self, total_time: float, time_step: float = 0.1): ... ``` # Requirements 1. **Initialization (`__init__` method)**: - Accepts initial velocity (in meters per second), launch angle (in degrees), and initial position (as an XY coordinate tuple). - Converts the launch angle to radians and decomposes the initial velocity into horizontal and vertical components. - Stores the initial position. 2. **Position Calculation (`position_at_time` method)**: - Accept a time `t` in seconds. - Compute and return the XY coordinates of the projectile at time `t` using the equations of motion under uniform gravity (use gravitational constant ( g = 9.81 , text{m/s}^2 )). 3. **Plot Trajectory (`plot_trajectory` method)**: - Accept the total time of flight and optionally a time step parameter. - Compute the position of the projectile at each time step up until the total time. - Use `matplotlib` to plot the trajectory of the projectile with the initial position marked. # Input and Output Format * **Input**: Initial velocity, launch angle, and initial position ```plaintext Initial velocity: 50 Launch angle: 45 Initial position: (0, 0) ``` * **Output**: - Method signature implementations. - Use provided `plot_trajectory` to visualize the path. # Constraints 1. Launch angle: [0, 90] degrees. 2. Initial velocity: Positive value. 3. Initial position: Valid coordinates. # Example Usage ```python if __name__ == \\"__main__\\": projectile = Projectile(initial_velocity=50, launch_angle=45) projectile.plot_trajectory(total_time=10, time_step=0.1) ``` Visualize the trajectory of the projectile under the defined conditions. # Additional Guidelines 1. **Edge Cases**: - Handle situations where `initial_velocity` is zero or negative. - Ensure calculations accommodate the projectile hitting the ground (y = 0). 2. **Performance**: - Efficiently calculate trajectory points. - Optimize plotting for a large number of time steps.","solution":"import math import matplotlib.pyplot as plt class Projectile: def __init__(self, initial_velocity: float, launch_angle: float, initial_position: tuple[float, float] = (0, 0)): Initializes the Projectile with initial velocity, launch angle, and initial position. Angle is converted to radians and initial velocity is decomposed into horizontal and vertical components. self.initial_velocity = initial_velocity self.launch_angle = math.radians(launch_angle) self.initial_position = initial_position self.vx = initial_velocity * math.cos(self.launch_angle) self.vy = initial_velocity * math.sin(self.launch_angle) self.g = 9.81 # Acceleration due to gravity (m/s^2) def position_at_time(self, t: float) -> tuple[float, float]: Calculate the position of the projectile at time t. x = self.initial_position[0] + self.vx * t y = self.initial_position[1] + self.vy * t - 0.5 * self.g * t**2 return (x, y) def plot_trajectory(self, total_time: float, time_step: float = 0.1): Plot the trajectory of the projectile from the initial position to the position at total_time. times = [i * time_step for i in range(int(total_time / time_step) + 1)] positions = [self.position_at_time(t) for t in times] x_positions = [pos[0] for pos in positions] y_positions = [pos[1] for pos in positions] plt.figure(figsize=(10, 5)) plt.plot(x_positions, y_positions, label=\'Projectile Path\') plt.scatter([self.initial_position[0]], [self.initial_position[1]], color=\'red\', label=\'Initial Position\') plt.xlabel(\'Distance (m)\') plt.ylabel(\'Height (m)\') plt.title(\'Projectile Trajectory\') plt.legend() plt.grid(True) plt.show()"},{"question":"# Advanced Path Finder: Optimal Route in Weighted Graph In this challenge, you need to implement an algorithm to find the shortest path between two nodes in a weighted, directed graph using Dijkstra\'s algorithm. Your task is to ensure the solution is optimized to handle large graphs efficiently and manages edge cases properly. # Task Complete the function `dijkstra_shortest_path` provided below to determine the shortest path between two nodes in a graph. # Requirements - Implement the function using Dijkstra\'s algorithm with a priority queue for optimization. - Ensure your solution handles graphs with varying densities and edge weights (positive weights only). - The function should return both the shortest distance and the path taken. # Implementation Details *Function Signature*: ```python def dijkstra_shortest_path(graph: Dict[int, List[Tuple[int, float]]], start: int, end: int) -> Tuple[float, List[int]]: pass ``` **Arguments**: - `graph` (Dict[int, List[Tuple[int, float]]]): A dictionary representing the weighted directed graph, where the key is a node, and the value is a list of tuples representing the neighboring node and the edge weight. - `start` (int): The starting node. - `end` (int): The destination node. **Returns**: - `Tuple[float, List[int]]`: A tuple containing the shortest distance and the list of nodes representing the path from start to end. If there\'s no path, return `float(\'inf\')` and an empty list. # Example Usage Example 1: ```python graph = { 1: [(2, 1), (3, 4)], 2: [(3, 2), (4, 5)], 3: [(4, 1)], 4: [] } distance, path = dijkstra_shortest_path(graph, 1, 4) print(distance, path) # Output: 4.0 [1, 2, 3, 4] ``` Example 2: ```python graph = { 1: [(2, 10)], 2: [(3, 10)], 3: [(4, 10)], 4: [(1, 10)] } distance, path = dijkstra_shortest_path(graph, 1, 4) print(distance, path) # Output: 30.0 [1, 2, 3, 4] ``` Example 3: ```python graph = { 1: [(2, 1)], 2: [(3, 1)], 3: [(4, 1)], 4: [(5, 1)] } distance, path = dijkstra_shortest_path(graph, 1, 5) print(distance, path) # Output: 4.0 [1, 2, 3, 4, 5] ``` Make sure to validate your implementation against diverse test cases to verify correctness and efficiency.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra_shortest_path(graph: Dict[int, List[Tuple[int, float]]], start: int, end: int) -> Tuple[float, List[int]]: Uses Dijkstra\'s algorithm to find the shortest path in a weighted directed graph. Returns a tuple with the shortest distance and the path taken. # Priority queue to store (distance, node, path) priority_queue = [(0, start, [start])] # Dictionary to store the shortest known distance to each node shortest_distances = {start: 0} while priority_queue: current_distance, current_node, path = heapq.heappop(priority_queue) # If we reached the destination node if current_node == end: return (current_distance, path) # Explore neighbors for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight # if new calculated distance is shorter, update the shortest distances and push to the queue if distance < shortest_distances.get(neighbor, float(\'inf\')): shortest_distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path + [neighbor])) # If the destination node is not reachable return (float(\'inf\'), [])"},{"question":"# Longest Increasing Subsequence In this problem, you are given a sequence of integers. Your objective is to find the length of the longest increasing subsequence in the given sequence. An increasing subsequence is a sequence of numbers such that each number is less than the number that follows it. For example, given the sequence `[10, 22, 9, 33, 21, 50, 41, 60, 80]`, the longest increasing subsequence is `[10, 22, 33, 50, 60, 80]`, which has length 6. Complete the implementation of the `longest_increasing_subsequence` function according to the provided requirements. Function Signature ```python def longest_increasing_subsequence(seq: list[int]) -> int: ``` **Input:** * `seq`: A list of integers representing the sequence. **Output:** * Returns an integer representing the length of the longest increasing subsequence. **Constraints:** * `0 <= len(seq) <= 10^3` * `-10^4 <= seq[i] <= 10^4` **Example:** ```python >>> seq = [10, 22, 9, 33, 21, 50, 41, 60, 80] >>> longest_increasing_subsequence(seq) 6 >>> seq = [3, 10, 2, 1, 20] >>> longest_increasing_subsequence(seq) 3 >>> seq = [50, 3, 10, 7, 40, 80] >>> longest_increasing_subsequence(seq) 4 >>> seq = [] >>> longest_increasing_subsequence(seq) 0 ``` **Explanation:** * In the first example, the longest increasing subsequence is `[10, 22, 33, 50, 60, 80]` with a length of 6. * In the second example, the longest increasing subsequence is `[3, 10, 20]` with a length of 3. * In the third example, the longest increasing subsequence is `[3, 10, 40, 80]` with a length of 4. * In the fourth example, the sequence is empty, so the longest increasing subsequence has length 0. **Note:** There can be multiple longest increasing subsequences of the same length. For instance, in the third example, `[3, 10, 40, 80]` and `[3, 7, 40, 80]` are both valid subsequences with length 4.","solution":"def longest_increasing_subsequence(seq): Returns the length of the longest increasing subsequence in the given sequence. if not seq: return 0 # Initialize LIS array to store the length of the longest subsequence that ends with seq[i] lis = [1] * len(seq) for i in range(1, len(seq)): for j in range(i): if seq[i] > seq[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # The maximum value in the LIS array is the length of the longest increasing subsequence return max(lis)"},{"question":"# Weather Data Analysis Function Objective Your task is to implement a function that takes a dictionary of weather data for multiple days and calculates specific weather metrics. Utilize the `WeatherAnalysis` class to perform this task. Input The function will take: 1. **metric_name**: A string representing the weather metric to be calculated (e.g., \'average_temperature\'). 2. **weather_data**: A dictionary where each key is a string representing a date in the format \'YYYY-MM-DD\' and each value is another dictionary containing weather attributes such as \'temperature\', \'humidity\', and \'precipitation\'. Output The function should return the calculated metric. Constraints - Ensure that the weather attributes are available in the same format and units. - The metric_name must be one of the supported metrics in the `WeatherAnalysis` class. Example Usage ```python # Example weather data weather_data = { \'2023-01-01\': {\'temperature\': 25.3, \'humidity\': 80, \'precipitation\': 5}, \'2023-01-02\': {\'temperature\': 22.1, \'humidity\': 75, \'precipitation\': 10}, \'2023-01-03\': {\'temperature\': 23.4, \'humidity\': 78, \'precipitation\': 0}, } # Example function call result = calculate_weather_metric(\\"average_temperature\\", weather_data) print(result) # Expected output: 23.6 ``` Implementation Details 1. Instantiate the `WeatherAnalysis` class. 2. Use the `calculate` method of the `WeatherAnalysis` class to compute the desired metric. 3. Handle invalid `metric_name` inputs gracefully. Function Signature ```python from typing import Dict def calculate_weather_metric(metric_name: str, weather_data: Dict[str, Dict[str, float]]) -> float: # Your implementation here pass ```","solution":"from typing import Dict class WeatherAnalysis: @staticmethod def average_temperature(weather_data: Dict[str, Dict[str, float]]) -> float: total_temp = sum(data[\'temperature\'] for data in weather_data.values()) return total_temp / len(weather_data) @staticmethod def total_precipitation(weather_data: Dict[str, Dict[str, float]]) -> float: return sum(data[\'precipitation\'] for data in weather_data.values()) @staticmethod def average_humidity(weather_data: Dict[str, Dict[str, float]]) -> float: total_humidity = sum(data[\'humidity\'] for data in weather_data.values()) return total_humidity / len(weather_data) def calculate_weather_metric(metric_name: str, weather_data: Dict[str, Dict[str, float]]) -> float: weather_analysis = WeatherAnalysis() if not hasattr(weather_analysis, metric_name): raise ValueError(f\\"Invalid metric name: {metric_name}\\") metric_function = getattr(weather_analysis, metric_name) return metric_function(weather_data)"},{"question":"Binary Tree Flattening # Objective Implement a function to flatten a binary tree to a linked list in-place, following the pre-order traversal of the tree. Your solution should demonstrate your understanding of tree traversal and manipulation. # Function Signature ```python def flatten(root: Optional[TreeNode]) -> None: ``` # Input 1. `root` (Optional[TreeNode]): The root node of the binary tree to be flattened. # Output * None: The transformation should be done in-place. # Constraints * The number of nodes in the tree is in the range [0, 2000]. * -100 <= Node.val <= 100 # Example ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(3) root.left.right = TreeNode(4) root.right.right = TreeNode(6) flatten(root) # After flattening, tree should be transformed to: # 1 # # 2 # # 3 # # 4 # # 5 # # 6 ``` # Notes 1. The resulting flattened tree should use the right child pointers to form the linked list. 2. The left child pointers should all be set to `None`. 3. You may not use any additional space beyond the function stack. # Hints 1. Start by considering a recursive approach that processes each node. 2. Ensure that you handle both left and right subtrees appropriately. 3. Think about how to \\"reconnect\\" nodes to form the linked list in place.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root: TreeNode) -> None: Flatten the tree in-place to a linked list following pre-order traversal. if not root: return # Pointer to keep track of the previously visited node prev = None # Use a stack to go through nodes and flatten the tree in pre-order stack = [root] while stack: node = stack.pop() # If there is a previous node, set its right to the current node if prev: prev.right = node prev.left = None # Push right and then left child to stack (if they exist) if node.right: stack.append(node.right) if node.left: stack.append(node.left) # Update the previous node to the current node prev = node"},{"question":"Problem Statement You are given an integer array `nums` and an integer `k`. Implement a function `find_subarray_with_sum` that returns the length of the shortest contiguous subarray whose sum is equal to `k`. If no such subarray exists, the function should return `-1`. # Function Signature ```python def find_subarray_with_sum(nums: list[int], k: int) -> int: pass ``` # Input - `nums`: A list of integers, where the length of `nums` is between 1 and 100,000. - `k`: An integer representing the target sum, where `-10^5 <= k <= 10^5`. # Output - Returns an integer representing the length of the shortest contiguous subarray whose sum is `k`. If no such subarray exists, return `-1`. # Constraints - The function should handle invalid inputs by throwing appropriate exceptions. # Example ```python nums = [1, 2, 3, 4, 5] k = 9 print(find_subarray_with_sum(nums, k)) # Output: 2 (The subarray [4, 5] sums to 9) nums2 = [1, 2, 3, 4, 5] k2 = 15 print(find_subarray_with_sum(nums2, k2)) # Output: 5 (The entire array sums to 15) nums3 = [1, 2, 3, 4, 5] k3 = 20 print(find_subarray_with_sum(nums3, k3)) # Output: -1 (No such subarray exists) ``` # Requirements - The solution should efficiently handle large arrays. - Address invalid inputs by raising appropriate exceptions with clear error messages. - Optimize the solution to avoid a naive O(n^2) approach for finding the sum of the subarray. Aim for a more efficient algorithm.","solution":"def find_subarray_with_sum(nums: list[int], k: int) -> int: if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(\\"nums must be a list of integers\\") if not isinstance(k, int): raise ValueError(\\"k must be an integer\\") sum_dict = {} current_sum = 0 min_length = float(\'inf\') for i in range(len(nums)): current_sum += nums[i] if current_sum == k: min_length = min(min_length, i + 1) if (current_sum - k) in sum_dict: min_length = min(min_length, i - sum_dict[current_sum - k]) if current_sum not in sum_dict: sum_dict[current_sum] = i return min_length if min_length != float(\'inf\') else -1"},{"question":"# Coding Challenge: Array Rotation Checker Background: Array rotation is a common technique in various applications such as data processing, cryptography, and more. We need to check if an array is a rotated version of another array. Objective: Write a function to determine if one array is a rotation of another array. Two arrays are considered rotations of each other if they contain the same elements in the same order, but one array can be derived by rotating the other. Task: Implement the function `is_rotation(arr1: list, arr2: list) -> bool` that: - Takes two lists of integers `arr1` and `arr2`. - Returns `True` if `arr2` is a rotation of `arr1`, otherwise returns `False`. Input: - Two lists, `arr1` and `arr2`, each containing integers. Output: - Returns a boolean value `True` or `False`. Constraints: - Both arrays can be empty or contain up to (10^5) elements. - Each integer in both arrays can be in the range (-10^9) to (10^9). Examples: ```python >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) True >>> is_rotation([1, 2, 3, 4, 5], [4, 5, 1, 2, 3]) True >>> is_rotation([1, 2, 3, 4, 5], [2, 3, 4, 5, 1]) True >>> is_rotation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) True >>> is_rotation([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) False >>> is_rotation([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) False >>> is_rotation([], []) True >>> is_rotation([], [1]) False ``` Requirements: 1. The function should handle edge cases, including empty arrays. 2. Ensure the solution\'s efficiency given the constraints (arrays containing up to (10^5) elements). # Similarity Justification: This new question aligns with the original set by focusing on array manipulation and algorithmic thinking. It tests for logical reasoning (sequence and rotation) and efficient handling of input sizes. Additionally, the input constraints and types are similar, ensuring consistency in complexity and scope.","solution":"def is_rotation(arr1, arr2): Determine if arr2 is a rotation of arr1. if len(arr1) != len(arr2): return False doubled_arr1 = arr1 + arr1 return \'\'.join(map(str, arr2)) in \'\'.join(map(str, doubled_arr1))"},{"question":"**Matrix Transpose Verification** Understanding matrix operations is crucial for numerous applications in computer science, particularly in algorithms that rely on linear algebra. The transpose of a matrix is one of the basic operations where the rows and columns of the matrix are swapped. # Problem Statement Write a function `is_transpose(matrix: list, transposed: list) -> bool` that verifies if `transposed` is indeed the transpose of `matrix`. # Function Signature ```python def is_transpose(matrix: list, transposed: list) -> bool: ``` # Input * `matrix`: A list of lists representing the original matrix. Each sublist represents a matrix row (1 <= len(matrix) <= 10^4; 1 <= len(matrix[i]) <= 10^4). * `transposed`: A list of lists representing the supposed transpose of the matrix. # Output * `True` if `transposed` is the transpose of `matrix`, `False` otherwise. # Constraints 1. The dimensions of `matrix` and `transposed` must be compatible for transposition. 2. The matrix should contain only integers. 3. An empty matrix should return `True` if the transposed matrix is also empty. # Performance Considerations 1. Ensure that the verification is efficient even for large matrices. # Examples ```python >>> is_transpose([[1, 2, 3], [4, 5, 6]], [[1, 4], [2, 5], [3, 6]]) True >>> is_transpose([[1, 2], [3, 4], [5, 6]], [[1, 3, 5], [2, 4, 6]]) True >>> is_transpose([[7, 8, 9]], [[7], [8], [9]]) True >>> is_transpose([[1, 2], [3, 4]], [[1, 4], [2, 3]]) False >>> is_transpose([[]], [[]]) True >>> is_transpose([], []) True >>> is_transpose([[1, 2, 3]], [[1, 2, 3]]) False ``` # Requirements 1. Implement functionality to verify if `transposed` is the correct transpose of `matrix`. 2. Handle edge cases with matrices of different valid dimensions. 3. The solution should be efficient and adhere to the input and output format closely. Your task is to implement the `is_transpose` function to confirm if the provided `transposed` version of a matrix is accurate.","solution":"def is_transpose(matrix, transposed): Check if the provided transposed matrix is actually the transpose of the original matrix. # Handle the case of empty matrices if not matrix and not transposed: return True if len(matrix) == 0 or len(matrix[0]) == 0: return matrix == transposed if len(matrix) != len(transposed[0]) or len(matrix[0]) != len(transposed): return False for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] != transposed[j][i]: return False return True"},{"question":"# Prime Sum Pair Calculation **Background**: In number theory, a prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. A prime sum pair is a pair of odd prime numbers (p1, p2) such that p1 + p2 = n, where n is an even number greater than 2. **Task**: Write a function `find_prime_sum_pairs` that takes an integer `n` and returns a list of all unique prime pairs (as tuples) that satisfy the condition p1 + p2 = n. Each pair (p1, p2) should be listed in ascending order (p1 < p2). Function Signature: ```python def find_prime_sum_pairs(n: int) -> list: pass ``` Input: * An integer `n` (4 <= n <= 100) Output: * A list of tuples, where each tuple contains two integers representing the prime pairs whose sum is `n`. Examples: ```python find_prime_sum_pairs(10) -> [(3, 7), (5, 5)] find_prime_sum_pairs(20) -> [(3, 17), (7, 13)] find_prime_sum_pairs(30) -> [(7, 23), (11, 19), (13, 17)] find_prime_sum_pairs(8) -> [(3, 5)] ``` # Constraints: * The function should efficiently calculate all prime sum pairs for the given even number `n`. * Ensure the solution considers all prime numbers up to `n` and pairs them correctly. * Handle edge cases where no prime sum pairs exist (though for n within given range, there should always be at least one pair). # Scenario: Imagine you are developing a tool that helps in teaching basic number theory concepts. This function could be used to generate examples for classroom exercises or to verify student solutions. Performance and correctness are crucial to handle typical values within the input range efficiently.","solution":"def find_prime_sum_pairs(n: int) -> list: def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True primes = [i for i in range(2, n) if is_prime(i)] prime_pairs = [] for i in range(len(primes)): for j in range(i, len(primes)): if primes[i] + primes[j] == n: prime_pairs.append((primes[i], primes[j])) return prime_pairs"},{"question":"# Coding Assessment: Matrix Transpose Context You are given a 2D matrix (a list of lists in Python), and your task is to implement a function that transposes this matrix. The transpose of a matrix is obtained by swapping the rows and columns of the matrix. Problem Description Implement the function `transpose_matrix(matrix: list[list[int]]) -> list[list[int]]` that transposes the given matrix and returns the transposed matrix. Input - `matrix` is a list of lists of integers, where each inner list represents a row of the matrix. Output - A list of lists representing the transposed matrix. Constraints - Validate that the input `matrix` is not empty and each inner list has the same length. - Consider edge cases such as matrices with only one row or one column. Examples ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2, 3, 4]]) [[1], [2], [3], [4]] >>> transpose_matrix([[1], [2], [3], [4]]) [[1, 2, 3, 4]] ```","solution":"def transpose_matrix(matrix): Transposes the given matrix. Parameters: matrix (list[list[int]]): A 2D list representing a matrix Returns: list[list[int]]: The transposed matrix if not matrix or not matrix[0]: raise ValueError(\\"Matrix cannot be empty and must have rows with equal length\\") # Transpose operation using list comprehension transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] return transposed"},{"question":"# Problem: **Library Management System** You are given the task of implementing a basic Library Management System. The primary objective is to manage the collection of books in the library, allowing users to borrow and return books, and keeping track of the books’ availability. Required Operations: 1. **Add Book**: Implement a function that adds a new book to the library. 2. **Borrow Book**: Implement a function that allows a user to borrow a book, marking it as unavailable. 3. **Return Book**: Implement a function that allows a user to return a book, marking it as available again. 4. **Book Status**: Implement a function that returns the availability status of a specific book. Input and Output Formats: 1. **Add Book**: - Input: A string representing the book title - Output: None 2. **Borrow Book**: - Input: A string representing the book title - Output: A boolean indicating whether the borrowing operation was successful (True) or the book is unavailable (False) 3. **Return Book**: - Input: A string representing the book title - Output: A boolean indicating if the return operation was successful (True) or if the book was not borrowed (False) 4. **Book Status**: - Input: A string representing the book title - Output: A boolean indicating the availability of the book (True if available, False if unavailable) # Constraints: - Each book in the library is uniquely identified by its title. - Ensure that the `borrow_book` and `return_book` operations properly handle cases where the same book cannot be borrowed by multiple users at the same time. # Performance Requirements: - All operations should perform efficiently based on the size of the library collection. Example: ```python library = Library() library.add_book(\\"The Great Gatsby\\") library.add_book(\\"1984\\") library.add_book(\\"To Kill a Mockingbird\\") print(library.book_status(\\"The Great Gatsby\\")) # Output: True borrowed = library.borrow_book(\\"The Great Gatsby\\") print(borrowed) # Output: True print(library.book_status(\\"The Great Gatsby\\")) # Output: False returned = library.return_book(\\"The Great Gatsby\\") print(returned) # Output: True print(library.book_status(\\"The Great Gatsby\\")) # Output: True borrowed_again = library.borrow_book(\\"1984\\") print(borrowed_again) # Output: True borrowed_again = library.borrow_book(\\"1984\\") print(borrowed_again) # Output: False # Book is already borrowed ``` Implement these functions in the `Library` class and thoroughly test them to ensure correctness.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title): Adds a new book to the library. Initializes the book as available. if title not in self.books: self.books[title] = True def borrow_book(self, title): Borrows a book from the library if it is available. Parameters: title (str): The title of the book to borrow Returns: bool: True if the book is successfully borrowed, False if it is not available if title in self.books and self.books[title]: self.books[title] = False return True return False def return_book(self, title): Returns a book to the library if it was borrowed. Parameters: title (str): The title of the book to return Returns: bool: True if the book is successfully returned, False if it was not borrowed if title in self.books and not self.books[title]: self.books[title] = True return True return False def book_status(self, title): Checks the availability of a book in the library. Parameters: title (str): The title of the book Returns: bool: True if the book is available, False if it is borrowed or not present return self.books.get(title, False)"},{"question":"# Background You are tasked with developing a function to analyze word frequency in a list of documents. Each document is represented as a string of text. The goal is to find the top N most frequent words across all documents, considering that words are case insensitive. # Task Implement a function `top_n_frequent_words` that identifies the top N most frequent words across a list of documents. Your implementation should adhere to the following specifications: Function Signature ```python def top_n_frequent_words(documents: list[str], N: int) -> list[tuple[str, int]]: pass ``` Input * `documents`: A list of strings, where each string represents a document. * `N`: An integer representing the number of top frequent words to retrieve. Output * Returns a list of tuples where each tuple contains a word and its frequency, sorted by frequency in descending order, and then lexicographically in ascending order if frequencies are the same. * The list should contain at most N tuples. * Words should be case insensitive but returned in lowercase. Constraints * Number of documents: 1 ≤ len(documents) ≤ 10^3. * Document length: 1 ≤ length of each document ≤ 10^3. * N is guaranteed to be less than or equal to the number of unique words in the documents. Examples ```python documents1 = [ \\"The quick brown fox jumps over the lazy dog\\", \\"The dog is quick and the fox is jumped over by the dog\\" ] documents2 = [ \\"Lorem ipsum dolor sit amet, consectetur adipiscing elit\\", \\"Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua\\", \\"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat\\" ] print(top_n_frequent_words(documents1, 3)) # Output: [(\'the\', 5), (\'dog\', 3), (\'fox\', 2)] print(top_n_frequent_words(documents1, 1)) # Output: [(\'the\', 5)] print(top_n_frequent_words(documents2, 5)) # Output: [(\'ut\', 3), (\'ad\', 2), (\'dolor\', 2), (\'ipsum\', 2), (\'labore\', 2)] print(top_n_frequent_words(documents2, 10)) # Output: [(\'ut\', 3), (\'ad\', 2), (\'dolor\', 2), (\'ipsum\', 2), (\'labore\', 2), (\'dolore\', 2), # (\'aliqua\', 1), (\'amet\', 1), (\'consectetur\', 1), (\'consequat\', 1)] ``` These examples should help you test and validate your implementation.","solution":"from collections import Counter import re def top_n_frequent_words(documents: list[str], N: int) -> list[tuple[str, int]]: Returns the top N most frequent words across a list of documents. word_counts = Counter() for doc in documents: words = re.findall(r\'bw+b\', doc.lower()) word_counts.update(words) most_common_words = word_counts.most_common() most_common_words.sort(key=lambda x: (-x[1], x[0])) return most_common_words[:N]"},{"question":"# Problem Statement # Scenario You are tasked with optimizing inventory management for a small bookstore. The bookstore has a sales target for the number of books to be sold, and you need to select different types of books to meet or exceed this target with the minimum number of books. # Task Implement a function `optimize_inventory` to determine the minimum number of different types of books required to meet or exceed the sales target. # Requirements 1. Write a class `Book` that captures the following attributes: title, stock. 2. Implement the utility function `build_book_list(titles, stocks)` which constructs a list of `Book` objects. 3. Implement the function `optimize_inventory(books, sales_target)` which should return: - The minimum number of different book titles to meet or exceed the sales target. - A list of selected `Book` objects that contribute to meeting or exceeding the sales target. # Input * `books`: List of `Book` objects. * `sales_target`: An integer representing the sales target (i.e., total number of books to be sold). # Output * A tuple containing: - An integer representing the minimum number of different book titles. - List of selected `Book` objects. **Function Signatures** ```python class Book: def __init__(self, title, stock): self.title = title self.stock = stock def get_stock(self): return self.stock def __repr__(self): return f\\"{self.__class__.__name__}({self.title}, {self.stock})\\" def build_book_list(titles, stocks): pass def optimize_inventory(books, sales_target): pass ``` # Constraints * Each book type can only be selected once. * `1 <= len(books) <= 10^5` * `1 <= sales_target <= 10^6` * Stock values are positive integers. # Performance * The implementation should aim for a time complexity of O(n log n) due to sorting. # Example ```python def test_optimize_inventory(): titles = [\\"Book_A\\", \\"Book_B\\", \\"Book_C\\", \\"Book_D\\", \\"Book_E\\"] stocks = [10, 50, 20, 30, 70] book_list = build_book_list(titles, stocks) num_titles, selected_books = optimize_inventory(book_list, 100) assert num_titles == 2, f\\"Expected number of titles to be 2 but got {num_titles}\\" print(selected_books) # Calling the test function test_optimize_inventory() ``` # Solution Approach (Greedy Algorithm) 1. Sort the list of books in descending order of stock. 2. Select books sequentially, starting from the book with the highest stock, and accumulate their stocks until the sales target is met or exceeded. 3. Count the number of selected books and return the count along with the list of selected books.","solution":"class Book: def __init__(self, title, stock): self.title = title self.stock = stock def get_stock(self): return self.stock def __repr__(self): return f\\"{self.__class__.__name__}({self.title}, {self.stock})\\" def build_book_list(titles, stocks): Constructs a list of Book objects given titles and stocks. return [Book(title, stock) for title, stock in zip(titles, stocks)] def optimize_inventory(books, sales_target): Determines the minimum number of different book titles required to meet or exceed the sales target and returns the list of selected Book objects along with the count. # Sort books by stock in descending order books.sort(key=lambda book: book.get_stock(), reverse=True) total_stock = 0 selected_books = [] for book in books: if total_stock >= sales_target: break selected_books.append(book) total_stock += book.get_stock() return len(selected_books), selected_books"},{"question":"# Problem Statement You have been assigned to write a program for managing vehicle routes, where each route is represented by an array of city names in the order they need to be visited. To optimize the vehicle\'s journey, you need to identify the starting city from each route. Write a function named `find_starting_city` that takes a list of routes (each route itself being a list of unique city names) and a list of the first city names that must be the first stop of each journey (that is, the starting point for each respective route). The function should return a list of indices representing the starting point in the route list that matches the order of the cities given in the `starting_cities` list. # Input * `routes` (list of list of str): A list where each element is a list representing a route, and each route contains unique city names in the order they need to be visited. * `starting_cities` (list of str): A list of city names that must be the first stop of each respective route. # Output * A list of integers representing the indices of the `routes` list where each route starts with the corresponding city in the `starting_cities` list. # Examples ```python # Example 1 routes = [ [\\"Seattle\\", \\"Denver\\", \\"Chicago\\", \\"New York\\"], [\\"San Francisco\\", \\"Los Angeles\\", \\"Las Vegas\\", \\"Grand Canyon\\"], [\\"Austin\\", \\"Dallas\\", \\"Houston\\", \\"Miami\\"] ] starting_cities = [\\"San Francisco\\", \\"Austin\\", \\"Seattle\\"] assert find_starting_city(routes, starting_cities) == [1, 2, 0] # Example 2 routes = [ [\\"Paris\\", \\"Lyon\\", \\"Marseille\\"], [\\"Berlin\\", \\"Hamburg\\", \\"Munich\\"], [\\"Madrid\\", \\"Barcelona\\", \\"Valencia\\"] ] starting_cities = [\\"Berlin\\", \\"Paris\\", \\"Madrid\\"] assert find_starting_city(routes, starting_cities) == [1, 0, 2] # Example 3 routes = [ [\\"Boston\\", \\"Philadelphia\\", \\"Washington DC\\"], [\\"Chicago\\", \\"Detroit\\", \\"Milwaukee\\"], [\\"San Diego\\", \\"Phoenix\\"] ] starting_cities = [\\"Chicago\\", \\"San Diego\\"] assert find_starting_city(routes, starting_cities) == [1, 2] ``` # Constraints * Each route in the `routes` list will contain between 1 and 1000 city names. * The length of the `starting_cities` list will be between 1 and the length of `routes`. * Each city name in the routes is unique. * City names will be strings that only contain alphabetic characters and spaces, with a maximum length of 50 characters. * The given lists `routes` and `starting_cities` are non-empty. # Additional Notes * The function should efficiently find the starting city indices even if the `routes` list is large. * If a city from `starting_cities` is not found in any route, assume the input is always properly formed so there will always be a valid route for each starting city specified.","solution":"def find_starting_city(routes, starting_cities): Finds the indices of the routes that start with the specified starting cities. Parameters: routes (list of list of str): List of routes, each route is a list of city names. starting_cities (list of str): List of city names to be the first stop in each route. Returns: list of int: The indices of the routes where each route starts with the corresponding city in the starting cities list. starting_indices = [] route_dict = {route[0]: idx for idx, route in enumerate(routes)} for city in starting_cities: if city in route_dict: starting_indices.append(route_dict[city]) return starting_indices"},{"question":"# Question: Efficient Caching Mechanism In this task, you will implement an efficient caching mechanism using the Least Recently Used (LRU) cache eviction policy. Your implementation must include methods to retrieve and insert items from/into the cache, respecting the capacity constraints and ensuring optimal performance with respect to time complexity. Class Signature ```python class LRUCache: def __init__(self, capacity: int): Initialize the LRU Cache with a given capacity. :param capacity: The maximum number of items the Cache can hold at any time pass def get(self, key: int) -> int: Retrieve the value associated with the given key in the Cache. If the key is not present, return -1. :param key: The key of the item to retrieve :return: The value associated with the key, or -1 if the key is not present pass def put(self, key: int, value: int) -> None: Insert or update the value of a key in the Cache. If the Cache is at capacity, it should evict the least recently used item before inserting the new item. :param key: The key of the item to insert/update :param value: The value of the item to insert/update pass ``` Constraints * All keys and values will be non-negative integers. * The number of operations (get and put) will be at most 10^5. * The capacity of the cache will be at most 10^4. * The methods `get` and `put` must operate in O(1) time complexity. Example ```python # Create a cache of capacity 2 cache = LRUCache(2) cache.put(1, 1) # Cache is {1=1} cache.put(2, 2) # Cache is {1=1, 2=2} assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # Evicts key 2 and Cache is {1=1, 3=3} assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # Evicts key 1 and Cache is {4=4, 3=3} assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` Your task is to implement the LRUCache class to meet the specifications outlined above.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) # Mark as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) # Mark as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Remove least recently used item"},{"question":"# Problem Statement **First Repeated Character** You are to implement a function that identifies the first character in a given string that repeats. If no character repeats, return an empty string. **Function Signature**: ```python def first_repeated_char(s: str) -> str: pass ``` # Input * `s` (str): The input string that can contain lowercase and uppercase alphabets, digits, and common punctuation marks. # Output * `str`: The first character that repeats in the string. If no character repeats, return an empty string. # Constraints * The function should raise a TypeError if input is not a string. * String length will not exceed 10^5 characters. # Example ```python print(first_repeated_char(\\"abca\\")) # Output: \\"a\\" print(first_repeated_char(\\"abcdefgabc\\")) # Output: \\"a\\" print(first_repeated_char(\\"hello\\")) # Output: \\"l\\" print(first_repeated_char(\\"swiss\\")) # Output: \\"s\\" print(first_repeated_char(\\"unique\\")) # Output: \\"\\" ``` # Additional Requirements 1. Ensure your function handles typical edge cases: strings with no repeated characters, strings where the repeated character appears later. 2. Efficient handling of long strings should be considered in your approach. # Hints * Use data structures that allow checking for previously seen characters efficiently. * Consider using a set or a dictionary to track characters as you iterate through the string.","solution":"def first_repeated_char(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") seen = set() for char in s: if char in seen: return char seen.add(char) return \\"\\""},{"question":"**Context**: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. However, this can be generalized to any starting numbers. **Task**: Write a function `solve_fibonacci_seq(n, a, b)` that generates the first `n` numbers in a generalized Fibonacci sequence, where the sequence starts with the integers `a` and `b`. The function should: - Take three integers `n`, `a`, and `b` as input, where `1 <= n <= 100`, and `-10^3 <= a, b <= 10^3`. - Return a list of the first `n` numbers in the sequence. **Constraints**: - The starting numbers `a` and `b` can be any integers. - The function should handle up to `100` numbers efficiently. **Examples**: ```python >>> solve_fibonacci_seq(10, 0, 1) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> solve_fibonacci_seq(5, 2, 3) [2, 3, 5, 8, 13] >>> solve_fibonacci_seq(7, -1, 1) [-1, 1, 0, 1, 1, 2, 3] >>> solve_fibonacci_seq(10, 5, 5) [5, 5, 10, 15, 25, 40, 65, 105, 170, 275] ``` **Hint**: Consider iterative implementation to avoid recursion depth issues for larger sequences. You may assume the input to the function is always such that `1 <= n <= 100` and `-1000 <= a, b <= 1000`.","solution":"def solve_fibonacci_seq(n, a, b): Generate the first n numbers in a generalized Fibonacci sequence starting with a and b. Parameters: n (int): the number of elements in the sequence to generate. a (int): the first starting element. b (int): the second starting element. Returns: list: a list containing the first n numbers in the sequence. if n == 1: return [a] sequence = [a, b] for _ in range(2, n): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"# Question: Dynamic Weather Data Simulation You are asked to simulate dynamic weather data over a specific time period using custom data structures and methods. This will involve creating, storing, and querying weather data efficiently while ensuring that various kinds of statistics can be derived in real-time. # Task: 1. **Implement the WeatherData Simulation**: - Create a class `WeatherData` with the following methods: - Add weather data points based on time. - Retrieve weather data by time range. - Compute various statistics over the collected data. - De-duplicate data points added at the same timestamp. 2. **Analyze and Test**: - Analyze the efficiency of your simulation in terms of time and space complexity. - Write appropriate unittests to ensure that the implementation handles edge cases and performs correctly. # Specifications: - **`WeatherData` Class**: - `__init__(self)`: Initialize the data structure. - `add_data(self, timestamp: str, temperature: float, humidity: float, pressure: float) -> None`: Add or update the weather data for a specific timestamp. - `get_data_by_range(self, start_timestamp: str, end_timestamp: str) -> dict`: Retrieve all recorded weather data in the given time range. - `get_statistics(self, start_timestamp: str, end_timestamp: str) -> dict`: Compute and return statistics (average, min, max) for temperature, humidity, and pressure within the given time range. # Input and Output - **Input**: - Time-stamped weather data points (including temperature, humidity, and pressure). - Time range for querying the data and statistics. - **Output**: - A dictionary of weather data for the specified time range for `get_data_by_range`. - A dictionary of calculated statistics for the specified time range for `get_statistics`. # Constraints: - The timestamps will be in the format `YYYY-MM-DD HH:MM:SS`. - The weather data points will be provided in real-time and must be handled efficiently. - There will be no more than 10,000 data points added. # Example: ```python # Initialize WeatherData instance weather = WeatherData() # Add weather data points weather.add_data(\\"2023-10-01 12:00:00\\", 25.3, 45.0, 1013.25) weather.add_data(\\"2023-10-01 13:00:00\\", 26.1, 47.2, 1012.85) weather.add_data(\\"2023-10-01 14:00:00\\", 27.2, 50.1, 1012.65) weather.add_data(\\"2023-10-01 14:00:00\\", 27.0, 49.8, 1012.70) # Update existing data point # Retrieve data within the time range data_range = weather.get_data_by_range(\\"2023-10-01 12:00:00\\", \\"2023-10-01 13:59:59\\") print(data_range) # Output: {\'2023-10-01 12:00:00\': {\'temperature\': 25.3, \'humidity\': 45.0, \'pressure\': 1013.25}, \'2023-10-01 13:00:00\': {\'temperature\': 26.1, \'humidity\': 47.2, \'pressure\': 1012.85}} # Get statistics within the time range statistics = weather.get_statistics(\\"2023-10-01 12:00:00\\", \\"2023-10-01 14:00:00\\") print(statistics) # Output: {\'average_temperature\': 26.1333, \'min_temperature\': 25.3, \'max_temperature\': 27.0, # \'average_humidity\': 47.3333, \'min_humidity\': 45.0, \'max_humidity\': 49.8, # \'average_pressure\': 1012.9333, \'min_pressure\': 1012.65, \'max_pressure\': 1013.25} ``` # Deliverables: - The complete implementation of `WeatherData` class. - Analysis of the implemented code regarding its time and space complexity. - Unittests to validate correct operation of the `WeatherData` class for edge cases and general cases.","solution":"from datetime import datetime from collections import defaultdict class WeatherData: def __init__(self): self.data = {} def add_data(self, timestamp: str, temperature: float, humidity: float, pressure: float) -> None: Adds or updates weather data for a specific timestamp. self.data[timestamp] = { \'temperature\': temperature, \'humidity\': humidity, \'pressure\': pressure } def get_data_by_range(self, start_timestamp: str, end_timestamp: str) -> dict: Retrieves all weather data between the specified start and end timestamps. start_dt = datetime.strptime(start_timestamp, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_timestamp, \\"%Y-%m-%d %H:%M:%S\\") result = {} for timestamp, values in self.data.items(): current_dt = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= current_dt <= end_dt: result[timestamp] = values return result def get_statistics(self, start_timestamp: str, end_timestamp: str) -> dict: Computes and returns statistics (average, min, max) for temperature, humidity, and pressure within the specified time range. data_in_range = self.get_data_by_range(start_timestamp, end_timestamp) if not data_in_range: return {} stats = defaultdict(list) for values in data_in_range.values(): for key, value in values.items(): stats[key].append(value) statistics = {} for key, values in stats.items(): statistics[f\'average_{key}\'] = sum(values) / len(values) statistics[f\'min_{key}\'] = min(values) statistics[f\'max_{key}\'] = max(values) return statistics"},{"question":"# Question Problem Statement You are given a list of N integers representing the heights of buildings in a city skyline. A \\"building cluster\\" is defined as a contiguous subarray where the buildings are of the same height. Write a function that returns the total number of building clusters in the skyline. Function Signature ```python def count_building_clusters(heights: list) -> int: Counts the number of building clusters in the skyline. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The total number of building clusters. pass ``` Input * `heights`: A list of integers where each integer represents the height of a building. Notes: * The list will contain at least one building. * All heights are non-negative integers. Output * An integer representing the total number of building clusters. Constraints * 1 ≤ N ≤ 10^5 * 0 ≤ heights[i] ≤ 10^6 Example ```python heights = [3, 3, 4, 4, 4, 2, 2, 1, 1] assert count_building_clusters(heights) == 4 # Clusters: [3, 3], [4, 4, 4], [2, 2], [1, 1] heights = [5, 5, 5, 5, 5] assert count_building_clusters(heights) == 1 # Cluster: [5, 5, 5, 5, 5] heights = [1, 2, 3, 4] assert count_building_clusters(heights) == 4 # Clusters: [1], [2], [3], [4] ``` Additional Information * Ensure your solution efficiently handles the input size constraints. * Consider edge cases such as where all buildings have the same height or all buildings have unique heights. * Focus on implementing an optimal solution in terms of time complexity.","solution":"def count_building_clusters(heights: list) -> int: Counts the number of building clusters in the skyline. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The total number of building clusters. # Edge case: if the list is empty, return 0 clusters if not heights: return 0 count_clusters = 1 # Start with the first building cluster for i in range(1, len(heights)): if heights[i] != heights[i - 1]: count_clusters += 1 return count_clusters"},{"question":"# Question: You are to implement a system that encodes and decodes messages using a simple substitution cipher with a twist based on a given shift value and a coded message. **Objective:** Write two functions, `shift_encode` and `shift_decode`. 1. `shift_encode(plain_text: str, shift: int) -> str`: - Encodes the given string using a simple substitution cipher where each letter is shifted by a specified number of positions in the *alphabet*. - Ignore non-alphabetic characters during shifting but include them in the result string unchanged. - Spaces and other punctuation should remain as is. 2. `shift_decode(encoded_text: str, shift: int) -> str`: - Decodes the encoded string using the same shift value used for encoding and returns the original message. - Ignore non-alphabetic characters during shifting but include them in the result string unchanged. **Constraints:** - The input string for encoding and decoding will contain lowercase alphabetic characters and other characters including spaces and punctuation marks. - The `shift` value will be an integer between 1 and 25. **Input and Output:** - For shift_encode: - **Input**: A lowercase string with alphabetic and non-alphabetic characters, and an integer shift value. - **Output**: A string where each alphabetic character is shifted by the given value, preserving spaces and punctuation marks. - For shift_decode: - **Input**: A string where each alphabetic character has been shifted by a given value, and the same integer shift value. - **Output**: The original string before encoding. **Examples:** 1. **Encoding Example:** ```python >>> shift_encode(\\"hello, world!\\", 3) \'khoor, zruog!\' ``` 2. **Decoding Example:** ```python >>> shift_decode(\\"khoor, zruog!\\", 3) \'hello, world!\' ``` **Function Signatures:** ```python def shift_encode(plain_text: str, shift: int) -> str: pass def shift_decode(encoded_text: str, shift: int) -> str: pass ``` **Performance Requirements:** - The solution should handle strings up to 10^6 characters efficiently.","solution":"def shift_encode(plain_text: str, shift: int) -> str: def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) return c return \'\'.join(shift_char(c, shift) for c in plain_text) def shift_decode(encoded_text: str, shift: int) -> str: return shift_encode(encoded_text, -shift)"},{"question":"# Scenario You have been assigned to develop a function that calculates the operating cost of a car rental agency. The agency offers different car types, each with specific daily rental rates. Customers may rent cars for varying durations and must be billed accordingly. # Task Write a Python function `calculate_rental_cost(car_type: str, days: int) -> float` that computes the total rental cost based on the type of car and the number of rental days. The function should account for the following car types and their respective daily rates: - **economy**: 30 per day - **compact**: 40 per day - **standard**: 50 per day - **luxury**: 100 per day The function should also handle invalid or unknown car types by raising a `ValueError`. # Requirements - Use a dictionary to store the car types and their corresponding rates. - Ensure proper error handling for invalid or negative days input. - Optimize the function to deliver the result efficiently. # Input and Output - **Input**: - `car_type` (str): The type of car, which may be one of \\"economy\\", \\"compact\\", \\"standard\\", \\"luxury\\". - `days` (int): The number of days the car is rented. - **Output**: The function should return the total rental cost as a floating-point number. # Code Template ```python def calculate_rental_cost(car_type: str, days: int) -> float: # Dictionary mapping car types to their daily rates rates = { \\"economy\\": 30, \\"compact\\": 40, \\"standard\\": 50, \\"luxury\\": 100 } # Validate input if car_type not in rates: raise ValueError(\\"Unknown car type\\") if days < 0: raise ValueError(\\"Days cannot be negative\\") # Compute and return the total rental cost total_cost = rates[car_type] * days return total_cost # Example usage (do not include in submission): # print(calculate_rental_cost(\\"compact\\", 5)) # print(calculate_rental_cost(\\"luxury\\", 3)) ``` **Constraints**: - The function should raise a `ValueError` for invalid car types or negative rental days. - No need to handle fractional days; all rentals are for whole days only.","solution":"def calculate_rental_cost(car_type: str, days: int) -> float: Computes the total rental cost based on the type of car and the number of rental days. Parameters: car_type (str): The type of car, which may be one of \\"economy\\", \\"compact\\", \\"standard\\", \\"luxury\\". days (int): The number of days the car is rented. Returns: float: The total rental cost. Raises: ValueError: If car_type is unknown or days is negative. # Dictionary mapping car types to their daily rates rates = { \\"economy\\": 30, \\"compact\\": 40, \\"standard\\": 50, \\"luxury\\": 100 } # Validate input if car_type not in rates: raise ValueError(\\"Unknown car type\\") if days < 0: raise ValueError(\\"Days cannot be negative\\") # Compute and return the total rental cost total_cost = rates[car_type] * days return total_cost"},{"question":"# Prime Pair Partition **Context**: A prime pair partition of an integer `n` is a way of writing `n` as the sum of two prime numbers. For example, the number 10 can be expressed as the sum of the two primes 3 and 7 (and also 5 and 5). **Problem**: You are tasked with writing a function `prime_pair_partition` that determines all unique prime pairs that sum up to a given integer `n`. Your function should: - Raise a `TypeError` if the input is not an integer. - Return an empty list if the input is a negative integer or less than 2. - Return a list of tuples, each containing a pair of prime numbers that sum up to `n`. **Function Signature**: `def prime_pair_partition(n: int) -> list[tuple[int, int]]` **Input**: - An integer `n` ( ( 0 leq n leq 10^6 ) ). **Output**: - A list of tuples, each containing a pair of prime numbers that sum up to `n`. Each pair should be represented as `(p1, p2)` where `p1 <= p2`. **Examples**: - `prime_pair_partition(-5)` should return `[]` - `prime_pair_partition(1)` should return `[]` - `prime_pair_partition(4)` should return `[(2, 2)]` - `prime_pair_partition(10)` should return `[(3, 7), (5, 5)]` - `prime_pair_partition(16)` should return `[(3, 13), (5, 11)]` - `prime_pair_partition(100)` should return `[(3, 97), (11, 89), (17, 83), (29, 71), (41, 59), (47, 53)]` **Constraints**: 1. Your solution should handle edge cases such as zero and very small numbers correctly. 2. It should also handle the upper limits of the input constraints efficiently. **Performance Requirements**: The solution should be optimized with a time complexity of (O(n log log n)) for generating prime numbers and (O(n)) for determining the pairings. **Clarification**: You do not need to handle extremely large numbers beyond the typical 2^31-1 integer range. Focus on correctness and efficiency within the given constraints.","solution":"def prime_pair_partition(n: int) -> list[tuple[int, int]]: if not isinstance(n, int): raise TypeError(\\"Input must be an integer.\\") if n < 2: return [] def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, limit + 1) if is_prime[p]] primes = sieve_of_eratosthenes(n) prime_set = set(primes) result = [] for p1 in primes: p2 = n - p1 if p2 in prime_set and p1 <= p2: result.append((p1, p2)) return result"},{"question":"# Longest Common Prefix Array You are given a class `LongestCommonPrefixArray` which should compute the longest common prefix array for a given list of strings. Your task is to implement a method that constructs this array. Method to Implement ```python class LongestCommonPrefixArray: def __init__(self, strings: List[str]): self.strings = strings def build_lcp_array(self) -> List[str]: pass ``` # Input - The constructor of the `LongestCommonPrefixArray` takes a list of strings. - You must implement the `build_lcp_array` method which processes the strings and returns a list of strings representing the longest common prefixes. # Output - The method should return a list of strings where each element is the longest common prefix shared among the input strings up to that index. # Example ```python strings = [\\"flower\\", \\"flow\\", \\"flight\\"] lcp_array = LongestCommonPrefixArray(strings) print(lcp_array.build_lcp_array()) # should return [\\"f\\", \\"fl\\", \\"fl\\"] ``` # Constraints * The number of strings will be at most `10^3`. * The length of each string will be at most `10^4`. * Each string will only contain lowercase English letters. # Note 1. Consider edge cases where no common prefixes exist or where all strings are identical. 2. Focus on efficiency to ensure your solution can handle the upper constraint limits. # Additional Information - The task focuses on finding the longest common prefix up to each string in the list sequentially. - Ensure the function handles varying string lengths and provides accurate results for the constraints provided.","solution":"from typing import List class LongestCommonPrefixArray: def __init__(self, strings: List[str]): self.strings = strings def build_lcp_array(self) -> List[str]: if not self.strings: return [] def common_prefix(s1: str, s2: str) -> str: min_length = min(len(s1), len(s2)) for i in range(min_length): if s1[i] != s2[i]: return s1[:i] return s1[:min_length] lcp_array = [self.strings[0]] for i in range(1, len(self.strings)): lcp = common_prefix(lcp_array[i - 1], self.strings[i]) lcp_array.append(lcp) return lcp_array"},{"question":"# Implement a Basic Text Compression Algorithm **Context**: You are developing a basic software tool to compress text data to save storage space. One simple way to compress text is by using Run-Length Encoding (RLE). Run-Length Encoding is a form of lossless data compression in which consecutive data elements are stored as a single data value and count, rather than as the original run. **Task**: Implement the function `compress_text(text: str) -> str` that compresses the input text using Run-Length Encoding. **Function Signature**: ```python def compress_text(text: str) -> str: ``` **Input**: - `text` (str): A string representing the text to be compressed. The text will contain only lowercase letters (`a`-`z`). **Output**: - (str): The compressed text using Run-Length Encoding. **Constraints**: - The input string `text` will not be empty. - The compressed format will always be shorter than or equal to the original string. **Examples**: ```python assert compress_text(\\"aaabccdddd\\") == \\"a3b1c2d4\\" assert compress_text(\\"aabbcc\\") == \\"a2b2c2\\" assert compress_text(\\"aaaaa\\") == \\"a5\\" assert compress_text(\\"abc\\") == \\"a1b1c1\\" ``` **Additional Notes**: 1. Ensure your function handles strings with no consecutive duplicate characters appropriately. 2. The function should handle edge cases, such as a long string with many different consecutive characters or the same character repeated many times. 3. Run-length encoding does not necessarily reduce the size of the text, but it simplifies repetitive text patterns into a concise format.","solution":"def compress_text(text: str) -> str: Compresses the input text using Run-Length Encoding (RLE). Parameters: text (str): A string representing the text to be compressed. Returns: str: The compressed text using Run-Length Encoding. if not text: return \\"\\" compressed = [] count = 1 prev_char = text[0] for char in text[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 compressed.append(f\\"{prev_char}{count}\\") return \\"\\".join(compressed)"},{"question":"# Problem Statement: Longest Word with Given Letters Given a list of words and a set of letters, write a function `longest_word_with_letters(words, letters)` that returns the longest word from the list that can be formed using the given set of letters. Each letter in the set can only be used as many times as it appears in the set. Function Signature ```python def longest_word_with_letters(words: List[str], letters: str) -> str: ``` Input - A list of words `words` such that ( 1 leq text{len(words)} leq 10^5 ) and each word has a length ranging from ( 1 ) to ( 100 ). - A string `letters` comprising only lowercase English letters, such that ( 1 leq text{len(letters)} leq 10^5 ). Output - A string representing the longest word that can be formed using the given set of letters. If there are multiple words of the same length, return the lexicographically smallest one. Examples ```python >>> longest_word_with_letters([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"aabnnnaa\\") \\"banana\\" >>> longest_word_with_letters([\\"hello\\", \\"world\\"], \\"ehllloh\\") \\"hello\\" >>> longest_word_with_letters([\\"abc\\", \\"bca\\", \\"cab\\", \\"abbc\\"], \\"abc\\") \\"abc\\" >>> longest_word_with_letters([\\"cat\\", \\"bat\\", \\"rat\\"], \\"tca\\") \\"cat\\" >>> longest_word_with_letters([\\"longest\\", \\"longish\\", \\"short\\"], \\"slighntgo\\") \\"longish\\" ``` Constraints - You should ensure the function runs efficiently given the upper constraints. - Handle edge cases such as the smallest and largest possible values for the lengths of `words` and `letters`. Context You are given a list of words and a set of letters. The task is to determine the longest word that can be formed from the available letters, considering each letter can only be used as many times as it appears in the set. This problem tests your understanding of string manipulation, counting occurrences, and comparison logic.","solution":"from typing import List from collections import Counter def longest_word_with_letters(words: List[str], letters: str) -> str: letter_count = Counter(letters) # Helper function to determine if a word can be formed with given letters def can_form_word(word): word_count = Counter(word) for char, count in word_count.items(): if letter_count[char] < count: return False return True # Finding the longest valid word (lexicographically smaller if lengths are equal) valid_words = [word for word in words if can_form_word(word)] if not valid_words: return \\"\\" valid_words.sort(key=lambda x: (-len(x), x)) return valid_words[0]"},{"question":"# Context In advanced data processing scenarios, transforming data from one form to another is a common necessity. One such transformation is finding the transpose of a matrix. Transposing a matrix involves flipping the matrix over its diagonal, converting its rows to columns and vice versa. The task is to write a function to perform this transformation for a given matrix. # Task Write a Python function `transpose_matrix()` that takes a 2D list (matrix) and returns its transpose. # Function Signature ```python def transpose_matrix(matrix: list) -> list: pass ``` # Input - `matrix`: A 2D list where each list represents a row of the matrix. The matrix can have variable row lengths but must be 1 ≤ number of rows, number of columns ≤ 100. # Output - A 2D list (matrix) representing the transposed matrix. # Requirements - Ensure the function handles non-rectangular matrices (i.e., rows of different lengths) correctly. - Raise a `TypeError` if the input matrix is not a list of lists. - Raise a `ValueError` if the input matrix contains non-integer elements or if dimensions are out of specified bounds. - The transpose of an empty matrix should be an empty matrix. # Constraints 1. The function should raise a `TypeError` if the matrix is not a list or if any row is not a list. 2. The function should raise a `ValueError` if any element of the matrix is not an integer or if any row\'s length exceeds 100. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6] ] result = transpose_matrix(matrix) print(result) # Expected output: [[1, 4], [2, 5], [3, 6]] ``` # Notes - The function should handle matrices of different dimensions gracefully. - Python\'s built-in capabilities such as list comprehensions can be utilized for efficient transformation. - Ensure prompt and meaningful error messages for invalid inputs to aid debugging. # Reference: - [Matrix Transposition](https://en.wikipedia.org/wiki/Transpose)","solution":"def transpose_matrix(matrix): if not isinstance(matrix, list): raise TypeError(\\"The input should be a list of lists\\") if any(not isinstance(row, list) for row in matrix): raise TypeError(\\"Each row of the matrix should be a list\\") if any(any(not isinstance(item, int) for item in row) for row in matrix): raise ValueError(\\"Matrix elements should be integers\\") if len(matrix) > 100 or any(len(row) > 100 for row in matrix): raise ValueError(\\"Matrix dimensions must be within 1 ≤ number of rows, number of columns ≤ 100\\") if not matrix: return [] max_length = max(len(row) for row in matrix) transposed = [[None] * len(matrix) for _ in range(max_length)] for i in range(len(matrix)): for j in range(len(matrix[i])): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Problem Statement: # Context: You are tasked with providing a function that computes the next lexicographical permutation of a list of numbers. This is useful in generating successive permutations of a set or understanding the sequence in sorting or arranging. **Purpose**: Implement a function that finds the next permutation of a given list of numbers in lexicographical order. # Task: Write a function `next_permutation(nums: List[int]) -> None` that takes in a list of integers `nums` and modifies it in-place to produce the next lexicographical permutation. If such a permutation is not possible (i.e., the list is sorted in descending order), the function should rearrange the list in ascending order. # Input: - A list `nums` consisting of integers, where `1 <= len(nums) <= 1000` and `-10^6 <= nums[i] <= 10^6`. # Output: - The function does not return a value. It modifies the list `nums` in-place to its next permutation. # Constraints: - The function must operate in-place with O(1) extra space complexity. - The time complexity of the solution should be O(n), where n is the length of the list. # Example: ```python >>> nums = [1, 2, 3] >>> next_permutation(nums) >>> nums [1, 3, 2] >>> nums = [3, 2, 1] >>> next_permutation(nums) >>> nums [1, 2, 3] >>> nums = [1, 1, 5] >>> next_permutation(nums) >>> nums [1, 5, 1] ``` **Note**: To generate the next permutation in lexicographical order, follow these steps: 1. Find the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is the last permutation. 2. Find the largest index `l` greater than `k` such that `nums[k] < nums[l]`. 3. Swap the value of `nums[k]` with that of `nums[l]`. 4. Reverse the sequence from `nums[k + 1]` up to and including the final element `nums[len(nums) - 1]`. Adopt these steps to ensure efficient and correct adjustments to the list to reflect the next permutation sequence.","solution":"def next_permutation(nums): Modifies the list \'nums\' in place to the next lexicographical permutation. If such a permutation is not possible, it rearranges the list to the lowest possible order (sorted in ascending order). # Step 1: Find the largest index k such that nums[k] < nums[k + 1]. k = len(nums) - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k == -1: # No such index found, list is in descending order, reverse it to ascending nums.reverse() return # Step 2: Find the largest index l greater than k such that nums[k] < nums[l] l = len(nums) - 1 while nums[l] <= nums[k]: l -= 1 # Step 3: Swap the value of nums[k] with that of nums[l] nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] to the end of the list nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"# Question: Improved String Manipulation with Memory Efficiency Context You have been provided with a `StringManipulator` class that currently supports basic operations like `reverse`, `to_upper`, and `to_lower`. Your task is to enhance the functionality of this class by adding new features and optimizing memory usage for string manipulation. Task 1. **Implement New Features**: Extend the `StringManipulator` class to support additional string operations such as `replace`, `concatenate`, and `strip`. 2. **Memory Efficiency**: Optimize the `StringManipulator` class to handle large strings efficiently. Focus on minimizing unnecessary copies and utilizing in-place modifications where appropriate. 3. **Edge Case Handling**: Improve the class to handle edge cases gracefully, such as empty strings and strings containing special characters. Requirements 1. **New Features**: * Addition of `replace(old, new)` to replace all occurrences of `old` substring with `new`. * Addition of `concatenate(other)` to concatenate the current string with `other`. * Addition of `strip(chars)` to remove leading and trailing characters specified in `chars`. 2. **Memory Efficiency**: * Optimize concatenation to avoid multiple unnecessary copies. * Utilize in-place modification techniques for memory efficiency. 3. **Edge Case Handling**: * Ensure operations handle empty strings without errors. * Properly manage special characters in strings. Implementation Here is the expected structure for the `StringManipulator` class: ```python class StringManipulator: def __init__(self, text): self.text = text def reverse(self): self.text = self.text[::-1] return self.text def to_upper(self): self.text = self.text.upper() return self.text def to_lower(self): self.text = self.text.lower() return self.text def replace(self, old, new): self.text = self.text.replace(old, new) return self.text def concatenate(self, other): self.text += other return self.text def strip(self, chars=None): self.text = self.text.strip(chars) return self.text # Sample Usage manipulator = StringManipulator(\\" Hello World \\") print(manipulator.strip()) # Output: \\"Hello World\\" print(manipulator.replace(\\"World\\", \\"Universe\\")) # Output: \\"Hello Universe\\" print(manipulator.concatenate(\\"!!!\\")) # Output: \\"Hello Universe!!!\\" ``` Constraints * Input to all methods is valid non-null strings. * Ensure memory usage is optimized and methods handle modifications in-place where possible. * Edge cases such as empty strings and strings containing special characters must be handled gracefully.","solution":"class StringManipulator: def __init__(self, text): self.text = text def reverse(self): self.text = self.text[::-1] return self.text def to_upper(self): self.text = self.text.upper() return self.text def to_lower(self): self.text = self.text.lower() return self.text def replace(self, old, new): self.text = self.text.replace(old, new) return self.text def concatenate(self, other): # Use join for memory efficiency instead of multiple concatenations self.text = \'\'.join([self.text, other]) return self.text def strip(self, chars=None): self.text = self.text.strip(chars) return self.text # Sample Usage # manipulator = StringManipulator(\\" Hello World \\") # print(manipulator.strip()) # Output: \\"Hello World\\" # print(manipulator.replace(\\"World\\", \\"Universe\\")) # Output: \\"Hello Universe\\" # print(manipulator.concatenate(\\"!!!\\")) # Output: \\"Hello Universe!!!\\""},{"question":"Scenario You are tasked with developing a utility for managing a collection of items in a warehouse. Each item has a unique identifier, a name, and a quantity. The utility should be able to add new items, remove items, update item quantities, and display a summary of all items currently in the warehouse. This task will test your understanding of basic class structures, methods, and data management in Python. Task Write a class implementation named `Warehouse` that includes the following methods: 1. `add_item(item_id: int, item_name: str, quantity: int) -> None` 2. `remove_item(item_id: int) -> None` 3. `update_quantity(item_id: int, quantity: int) -> None` 4. `get_summary() -> str` # Method Descriptions 1. **add_item(item_id: int, item_name: str, quantity: int) -> None** - Adds a new item with the specified ID, name, and quantity to the warehouse. If an item with the same ID already exists, raise an exception. 2. **remove_item(item_id: int) -> None** - Removes the item with the specified ID from the warehouse. If no such item exists, raise an exception. 3. **update_quantity(item_id: int, quantity: int) -> None** - Updates the quantity of the item with the specified ID. If the item does not exist, raise an exception. The quantity can be positive (adding stock) or negative (removing stock), but the final quantity should not be negative. 4. **get_summary() -> str** - Returns a string summary of all items in the warehouse, formatted as: ``` ItemID: 1, Name: Widget, Quantity: 10 ItemID: 2, Name: Gadget, Quantity: 5 ``` # Constraints 1. The item ID will be a positive integer. 2. The item name will be a non-empty string. 3. The quantity will be an integer (can be positive or negative, depending on the operation). 4. Initial warehouse can hold up to 1000 distinct items. # Example Inputs and Outputs ```python # Initialize the Warehouse warehouse = Warehouse() # Add items warehouse.add_item(1, \\"Widget\\", 10) warehouse.add_item(2, \\"Gadget\\", 5) # Update quantity warehouse.update_quantity(1, 5) # Adds 5 to the quantity of item with ID 1 # Remove item warehouse.remove_item(2) # Get summary summary = warehouse.get_summary() print(summary) # Expected output: # ItemID: 1, Name: Widget, Quantity: 15 ``` # Performance 1. The solution should efficiently handle operations on a warehouse with up to 1000 distinct items.","solution":"class Warehouse: def __init__(self): self.items = {} def add_item(self, item_id: int, item_name: str, quantity: int) -> None: if item_id in self.items: raise Exception(f\\"Item with ID {item_id} already exists.\\") self.items[item_id] = {\'name\': item_name, \'quantity\': quantity} def remove_item(self, item_id: int) -> None: if item_id not in self.items: raise Exception(f\\"Item with ID {item_id} does not exist.\\") del self.items[item_id] def update_quantity(self, item_id: int, quantity: int) -> None: if item_id not in self.items: raise Exception(f\\"Item with ID {item_id} does not exist.\\") new_quantity = self.items[item_id][\'quantity\'] + quantity if new_quantity < 0: raise Exception(f\\"Item quantity cannot be negative.\\") self.items[item_id][\'quantity\'] = new_quantity def get_summary(self) -> str: summary = [] for item_id, item_info in self.items.items(): summary.append(f\\"ItemID: {item_id}, Name: {item_info[\'name\']}, Quantity: {item_info[\'quantity\']}\\") return \\"n\\".join(summary)"},{"question":"# Coding Assessment Question Context: As a data analyst, you need to develop a system to help clean and organize data logs. One common task is to remove duplicate entries from a list while preserving the order of the first occurrence. This will help ensure that only unique records are maintained in the order they were first encountered. Task: Write a function `remove_duplicates` that takes a list of integers `data_log` and returns a new list that contains only the unique elements from `data_log` in the order of their first occurrence. Function Signature: ```python def remove_duplicates(data_log: list[int]) -> list[int]: ``` Input: * `data_log`: A list of integers representing a sequence of data entries. Output: * A list of integers containing only the unique elements from the input list, in the order of their first appearance. Constraints: * The length of `data_log` will be between 1 and 10^6. * Each element in `data_log` will be an integer between -10^6 and 10^6. Examples: ```python remove_duplicates([1, 2, 2, 3, 4, 4, 5]) => [1, 2, 3, 4, 5] remove_duplicates([7, 7, 6, 5, 5, 5, 4]) => [7, 6, 5, 4] remove_duplicates([3, 3, 3, 2, 1, 1]) => [3, 2, 1] remove_duplicates([1, 2, 3, 4, 5, 6]) => [1, 2, 3, 4, 5, 6] remove_duplicates([5, 5, 5, 5, 5]) => [5] ``` Scenario: You have access to a data log of user activity for the day. Use your function to create a clean list of unique user activity entries, preserving the order of their first appearance.","solution":"def remove_duplicates(data_log): Removes duplicate elements from the data_log while preserving the order of their first occurrence. Parameters: data_log (list of int): A list of integers representing a sequence of data entries Returns: list of int: A list with unique elements from the input list, in the order of their first appearance seen = set() unique_data_log = [] for item in data_log: if item not in seen: seen.add(item) unique_data_log.append(item) return unique_data_log"},{"question":"# Context You are helping develop a recommendation system for an online book store. The system needs to suggest books based on user ratings. You\'ve decided to implement a simple k-nearest neighbors (k-NN) algorithm to recommend books similar to those a user has rated highly. # Problem Statement Write a Python function to implement a k-nearest neighbors algorithm with the following requirements: 1. **Distance Calculation**: Must compute the Euclidean distance between book feature vectors. 2. **Finding k-Nearest Neighbors**: Must find the k nearest neighbors of a given book based on the computed distances. 3. **Recommendation**: Return the IDs of these k nearest neighbor books as recommendations. # Function Signature ```python def knn_recommendations(book_features: np.ndarray, book_id: int, k: int) -> List[int]: Parameters: book_features: np.ndarray -> Feature matrix representing all books (m x n) book_id: int -> ID of the book for which recommendations are being made (0 <= book_id < m) k: int -> Number of nearest neighbors to consider Returns: List[int] -> List of book IDs of the k nearest neighbors ``` # Input and Output - **Input**: - `book_features`: A `numpy` array of shape `(m, n)`, where `m` is the number of books and `n` is the number of features. - `book_id`: An integer representing the ID of the book for which recommendations are sought. - `k`: An integer specifying the number of nearest neighbors to consider for recommendations. - **Output**: - A list of integers representing the IDs of the k nearest neighbor books. # Constraints - You must use the Euclidean distance for similarity measurement. - Ensure `book_id` is a valid index for the input feature matrix. - Handle edge cases where `k` exceeds the number of available books, or `k` is zero or negative. # Example ```python import numpy as np book_features = np.array([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [1.0, 1.0, 1.0], [5.0, 5.0, 5.0], [1.5, 2.5, 3.5]]) book_id = 0 k = 2 recommendations = knn_recommendations(book_features, book_id, k) print(recommendations) # Example output: [4, 1] ``` # Test Case Validate your solution by: 1. Testing with a sample feature matrix and multiple `book_id` values. 2. Verifying the correctness of the distance calculations. 3. Ensuring the recommendations are accurate for various `k` values, including edge cases such as `k` equal to or greater than the number of books, or `k` being zero. # Notes - You may assume no two books have exactly the same feature vector. - Focus on the efficiency of your distance calculation and neighbor finding approach, especially for large datasets.","solution":"import numpy as np from typing import List import heapq def knn_recommendations(book_features: np.ndarray, book_id: int, k: int) -> List[int]: Parameters: book_features: np.ndarray -> Feature matrix representing all books (m x n) book_id: int -> ID of the book for which recommendations are being made (0 <= book_id < m) k: int -> Number of nearest neighbors to consider Returns: List[int] -> List of book IDs of the k nearest neighbors if k <= 0: return [] if not (0 <= book_id < book_features.shape[0]): raise ValueError(\\"book_id is out of the range of book_features\\") distances = [] # Calculate the Euclidean distance from the book with book_id to all other books for idx in range(book_features.shape[0]): if idx != book_id: dist = np.linalg.norm(book_features[book_id] - book_features[idx]) distances.append((dist, idx)) # Find the k smallest distances k_nearest_neighbors = heapq.nsmallest(k, distances, key=lambda x: x[0]) return [neighbor[1] for neighbor in k_nearest_neighbors]"},{"question":"# Implementation Question: Handling Permutations with Specific Constraints **Problem Statement**: You need to write a function `find_permutations` that generates all permutations of a given string and filters out those that do not meet specific constraints. The constraints are: 1. No permutation should have the same character appearing consecutively. 2. Only unique permutations should be returned. **Function Signature**: ```python def find_permutations(input_str: str) -> List[str]: Generates all unique permutations of the input string where no character appears consecutively. Parameters: input_str (str): The string for which permutations need to be generated. Returns: List[str]: A list of unique permutations where no characters are consecutive. Raises: ValueError: When the input is not a string. pass ``` **Input/Output Examples**: ```python >>> find_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> find_permutations(\\"aa\\") [] >>> find_permutations(\\"aab\\") [\'aba\'] >>> find_permutations(\\"123\\") [\'123\', \'132\', \'213\', \'231\', \'312\', \'321\'] >>> find_permutations(\\"\\") Traceback (most recent call last): ... ValueError: Expected non-empty string as input >>> find_permutations(123) Traceback (most recent call last): ... ValueError: Expected string as input, found <class \'int\'> ``` **Constraints**: * The input must be a non-empty string of length up to 10^3 characters. * Non-alphabetic characters should be treated as valid and considered in permutations. * The input string may contain duplicate characters. # Hints: 1. Use backtracking to generate permutations. 2. Utilize a set to keep track of unique permutations. 3. Skip permutations where the same character appears consecutively.","solution":"from typing import List from itertools import permutations def find_permutations(input_str: str) -> List[str]: if not isinstance(input_str, str): raise ValueError(f\\"Expected string as input, found {type(input_str)}\\") if not input_str: raise ValueError(\\"Expected non-empty string as input\\") unique_permutations = set(permutations(input_str)) filtered_permutations = [] for perm in unique_permutations: perm_str = \'\'.join(perm) valid = True for i in range(len(perm_str) - 1): if perm_str[i] == perm_str[i + 1]: valid = False break if valid: filtered_permutations.append(perm_str) return sorted(filtered_permutations)"},{"question":"# Max Stack with Constant Time Operations You are required to design a special stack data structure capable of the following operations in constant time: 1. **Push(x)**: Pushes an integer x onto the stack. 2. **Pop()**: Removes the element on the top of the stack. 3. **Top()**: Retrieves the top element of the stack without removing it. 4. **GetMax()**: Retrieves the maximum element in the stack. Each operation must be implemented to run in O(1) time complexity. You need to ensure that the stack supports these operations efficiently. **Function Signature:** ```python class MaxStack: def __init__(self) -> None: Initializes the stack object. pass def push(self, x: int) -> None: Pushes the integer x on the stack. Args: - x (int): The integer to be pushed on the stack. pass def pop(self) -> None: Removes the top element from the stack. pass def top(self) -> int: Retrieves the top element from the stack. Returns: - int: The top element from the stack. pass def getMax(self) -> int: Retrieves the maximum element in the stack. Returns: - int: The maximum element in the stack. pass ``` # Requirements 1. **`__init__` Method**: Initialize the stack structure. 2. **`push` Method**: Adds an integer x on the top of the stack. It must also update the maximum element if necessary. 3. **`pop` Method**: Removes the top element of the stack and also ensures the maximum element is updated accurately. 4. **`top` Method**: Returns the top-most element of the stack. 5. **`getMax` Method**: Returns the current maximum element in the stack. # Constraints - All integers pushed and retrieved will be valid signed 32-bit integer values. - The stack will be able to handle up to approximately 10^5 operations. # Example ```python stack = MaxStack() stack.push(5) stack.push(1) stack.push(5) assert stack.getMax() == 5 stack.top() # Returns 5 stack.pop() assert stack.getMax() == 5 stack.top() # Returns 1 stack.pop() assert stack.getMax() == 5 stack.top() # Returns 5 stack.pop() assert stack.getMax() == \'Invalid operation\' # If stack is empty, handle appropriately ``` Implement these methods ensuring that all operations run in constant time and the structure is robust enough to handle any edge cases appropriately.","solution":"class MaxStack: def __init__(self) -> None: self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> None: if self.stack: top = self.stack.pop() if top == self.max_stack[-1]: self.max_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] else: return \'Invalid operation\' def getMax(self) -> int: if self.max_stack: return self.max_stack[-1] else: return \'Invalid operation\'"},{"question":"# Question You are tasked with writing a function `remove_duplicates_preserve_order(elements: List[int]) -> List[int]` that takes a list of integers and returns a new list with duplicate elements removed while preserving the order of their first occurrence. Input - A list `elements` of integers that may contain duplicates. Output - A list of integers with all duplicates removed, and the order of elements preserved as their first appearance in the input list. Constraints - The input list `elements` can contain up to 10^5 elements. - Each element in the input list is between -10^6 and 10^6. Expected Time Complexity - O(n), where n is the number of elements in the input list. Example ```python >>> remove_duplicates_preserve_order([4, 5, 5, 4, 6, 4]) [4, 5, 6] >>> remove_duplicates_preserve_order([1, 2, 3, 1, 2, 3]) [1, 2, 3] >>> remove_duplicates_preserve_order([]) [] >>> remove_duplicates_preserve_order([7, 8, 8, 8, 9]) [7, 8, 9] ``` Notes - The function should handle an empty list and return an empty list in such a case. - Ensure the order of the first occurrence of each element is preserved in the output list. Write the function `remove_duplicates_preserve_order` following the specified requirements.","solution":"from typing import List def remove_duplicates_preserve_order(elements: List[int]) -> List[int]: Removes duplicates from the list while preserving the order of the first occurrence. seen = set() result = [] for element in elements: if element not in seen: seen.add(element) result.append(element) return result"},{"question":"**Problem Statement:** Given an unsorted list of integers `num_list` and an integer `k`, your task is to implement a function `find_kth_largest` that returns the k-th largest element in the list. Requirements: 1. The function should be efficient and have an expected time complexity of (O(n log k)). 2. You may use a min-heap to achieve the desired time complexity. 3. If `k` is greater than the number of elements in the list, return `None`. Function Signature: ```python def find_kth_largest(num_list: list[int], k: int) -> int: Finds the k-th largest element in an unsorted list of integers. :param num_list: A list of integers. :param k: An integer representing which largest element to find. :return: The k-th largest element if found, otherwise None. ``` Example: ```python num_list = [3, 2, 1, 5, 6, 4] k = 2 print(find_kth_largest(num_list, k)) # Output: 5 num_list = [1, 9, 8, 7, 5, 6] k = 4 print(find_kth_largest(num_list, k)) # Output: 6 k = 7 print(find_kth_largest(num_list, k)) # Output: None ``` Constraints: - The list `num_list` can contain both positive and negative integers and can be empty. - 1 ≤ k ≤ len(num_list). Notes: - You may assume that `k` is always a positive integer. - You can leverage Python\'s `heapq` module to handle the heap operations efficiently.","solution":"import heapq def find_kth_largest(num_list: list[int], k: int) -> int: Finds the k-th largest element in an unsorted list of integers. :param num_list: A list of integers. :param k: An integer representing which largest element to find. :return: The k-th largest element if found, otherwise None. if k > len(num_list): return None # Using a min-heap of size k min_heap = num_list[:k] heapq.heapify(min_heap) for num in num_list[k:]: if num > min_heap[0]: # Compare with the smallest element in the min-heap heapq.heapreplace(min_heap, num) return min_heap[0]"},{"question":"# Question Scenario: As a part of a team developing software for a small logistics company, you are tasked with implementing a feature to facilitate package tracking. Each package has a unique identifier, and your system needs to keep track of these identifiers by storing them in a sorted collection. Your team decides to use the Insertion Sort algorithm due to its simplicity and efficiency for small datasets. Task: Write a Python function `stable_insertion_sort` that sorts a given list of package identifiers in ascending order using a stable version of the Insertion Sort algorithm. Function Signature: ```python def stable_insertion_sort(identifiers: list[int]) -> list[int]: ``` Input: - A list of integer package identifiers, `identifiers` (0 <= len(identifiers) <= 10^3). Output: - A list of integer package identifiers sorted in ascending order. Constraints: - Do not use any built-in sort functions. - Ensure that the sort is stable. - Aim for a solution within the time complexity of (O(n^2)) and space complexity of (O(1)). Performance Requirements: - The implemented solution should handle edge cases efficiently (e.g., empty list, single element list, already sorted list, list with duplicate elements). Example Usage: ```python >>> stable_insertion_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> stable_insertion_sort([10, 9, 8]) [8, 9, 10] >>> stable_insertion_sort([3, 1, 2, 1, 3, 2]) [1, 1, 2, 2, 3, 3] >>> stable_insertion_sort([4, 5, -1, 3, 0]) [-1, 0, 3, 4, 5] >>> stable_insertion_sort([]) [] ```","solution":"def stable_insertion_sort(identifiers: list[int]) -> list[int]: for i in range(1, len(identifiers)): key = identifiers[i] j = i - 1 while j >= 0 and key < identifiers[j]: identifiers[j + 1] = identifiers[j] j -= 1 identifiers[j + 1] = key return identifiers"},{"question":"# Cartesian Product of String Tuples You are tasked with implementing a function that calculates the Cartesian product of two input tuples of strings. The Cartesian product of two tuples is the set of all possible pairs where the first element of the pair is from the first tuple and the second element is from the second tuple. # Function Signature ```python def cartesian_product_of_tuples(tuple1: tuple, tuple2: tuple) -> list: ``` # Input 1. `tuple1`: A tuple containing strings. Example: `(\'a\', \'b\')` 2. `tuple2`: A tuple containing strings. Example: `(\'c\', \'d\')` # Output - Return a list of tuples, where each tuple is a pair from the Cartesian product of `tuple1` and `tuple2`. # Constraints - The input tuples will each contain at most (10^5) elements. - Each string in the tuples will have a length of at most 100 characters. - The input strings will contain only alphabetical characters a-zA-Z. # Example ```python tuple1 = (\'a\', \'b\') tuple2 = (\'c\', \'d\') result = cartesian_product_of_tuples(tuple1, tuple2) print(result) # Output: [(\'a\', \'c\'), (\'a\', \'d\'), (\'b\', \'c\'), (\'b\', \'d\')] ``` # Notes * You are allowed to use Python standard libraries to implement your solution. * Focus on clarity and efficiency in your implementation.","solution":"from itertools import product def cartesian_product_of_tuples(tuple1: tuple, tuple2: tuple) -> list: Returns the Cartesian product of two input tuples of strings. Args: tuple1 (tuple): First input tuple containing strings. tuple2 (tuple): Second input tuple containing strings. Returns: list: List of tuples, where each tuple is a pair from the Cartesian product of tuple1 and tuple2. return list(product(tuple1, tuple2))"},{"question":"# Scenario You are developing a text processing tool that requires finding and highlighting specific patterns within a given document. The tool should be able to recognize email addresses and highlight them by surrounding each email with square brackets. # Task Implement a function `highlight_emails(text: str) -> str` that identifies all email addresses in a given text and highlights them by surrounding them with square brackets. An email address is defined as follows: it contains alphanumeric characters, and can include periods, underscores, and dashes before the @ symbol, followed by a domain name with at least one period separating the domain and top-level domain. # Function Signature ```python def highlight_emails(text: str) -> str: Identifies all email addresses in the input text and surrounds them with square brackets. ``` # Input - A single string `text` which contains the text to be processed. # Output - A single string with all email addresses highlighted with square brackets. # Constraints - Input string length will be at most 2000 characters. - The text may include multiple email addresses and other alphanumeric characters. # Example ```python assert highlight_emails(\\"Contact us at support@example.com for more details.\\") == \\"Contact us at [support@example.com] for more details.\\" assert highlight_emails(\\"Send an email to admin@example.com or sales@example.co.uk.\\") == \\"Send an email to [admin@example.com] or [sales@example.co.uk].\\" assert highlight_emails(\\"Invalid emails: test@com, user@com.\\") == \\"Invalid emails: test@com, user@com.\\" assert highlight_emails(\\"Emails: user123@example.com, another.user@sub.domain.com, final_user@final-domain.org.\\") == \\"Emails: [user123@example.com], [another.user@sub.domain.com], [final_user@final-domain.org].\\" ``` # Notes - Your solution should efficiently match email addresses within the text. - Consider edge cases such as emails at the beginning or end of the text and different formats of email addresses. - Do not use any external libraries or modules for regular expressions.","solution":"import re def highlight_emails(text: str) -> str: Identifies all email addresses in the input text and surrounds them with square brackets. email_pattern = r\'b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}b\' return re.sub(email_pattern, r\'[g<0>]\', text)"},{"question":"# Question You are implementing an application that manages rooms booking in a hotel. Your task is to create a function that checks if all the booked intervals in a list can be accommodated using a given number of rooms without any overlaps beyond the room capacity. Function Specification ```python def can_accommodate_bookings(bookings: list[tuple[int, int]], rooms: int) -> bool: Determines if all bookings can be accommodated without overlapping beyond the specified number of rooms. Each booking is represented as a tuple (start, end). The function returns True if the bookings can be accommodated, else False. ``` # Input * `bookings`: A list of tuples where each tuple (a, b) represents a booking with the start time `a` (inclusive) and end time `b` (exclusive). * `rooms`: An integer representing the total number of rooms available. # Output * Returns `True` if it is possible to accommodate all bookings with the given number of rooms, `False` otherwise. # Constraints * `1 ≤ len(bookings) ≤ 10^4` - The number of bookings can be up to 10,000. * `0 ≤ start time < end time ≤ 10^6` - Booking times are constrained between 0 and 1,000,000. * `1 ≤ rooms ≤ 500` - The number of rooms available is constrained between 1 and 500. # Example ```python bookings = [(1, 4), (2, 5), (7, 9), (3, 6)] rooms = 2 print(can_accommodate_bookings(bookings, rooms)) # Output: False bookings = [(1, 2), (3, 4), (5, 6), (7, 8)] rooms = 1 print(can_accommodate_bookings(bookings, rooms)) # Output: True ``` # Performance Requirements Your implementation should aim for an efficient approach to handle the worst-case time complexity given the upper limits of the input. Typically, O(n log n) due to sorting can be effective for this problem. Explanation: In the first example, we have: - Booking from 1 to 4 - Booking from 2 to 5 (overlapping with the first) - Booking from 7 to 9 (no overlap) - Booking from 3 to 6 (overlapping with the first and the fourth) With only 2 rooms available, it\'s impossible to accommodate all bookings because, at one point (3 to 4), three bookings overlap which would require 3 rooms. Thus, the result is `False`. In the second example, all bookings are non-overlapping and can be accommodated with just 1 room, so the result is `True`.","solution":"def can_accommodate_bookings(bookings, rooms): if not bookings: return True events = [] for start, end in bookings: events.append((start, 1)) # 1 indicates a booking starts events.append((end, -1)) # -1 indicates a booking ends events.sort() current_rooms = 0 for time, event in events: current_rooms += event if current_rooms > rooms: return False return True"},{"question":"# Scenario An online bookstore needs a recommendation system that suggests books to users based on the genres they have previously bought. Each user has a purchase history stored in a dictionary, and each book belongs to one specific genre. The recommendation system should identify the user who has bought the most books in the given genre and recommend them a new book from that genre that they haven\'t already purchased. # Task Implement a Python function `recommend_book(purchase_history: Dict[str, List[str]], genre_books: Dict[str, List[str]], genre: str) -> str` that performs the following: 1. Identifies the user who has bought the most books in the specified genre. 2. Recommends a book from the specified genre that the identified user hasn\'t already purchased. # Constraints * `purchase_history` is a dictionary where keys are user names (strings) and values are lists of purchased books (each book represented as a string). * `genre_books` is a dictionary where keys are genre names (strings) and values are lists of books belonging to that genre. * `genre` is a string representing the genre for which a recommendation is needed. * If no user has purchased any book in the given genre, return an empty string. * If the identified user has already purchased all the books in the genre, return an empty string. * Assume all books have unique titles. # Function Signature ```python from typing import Dict, List def recommend_book(purchase_history: Dict[str, List[str]], genre_books: Dict[str, List[str]], genre: str) -> str: pass ``` # Example ```python purchase_history = { \\"user1\\": [\\"book1\\", \\"book2\\", \\"book3\\"], \\"user2\\": [\\"book4\\", \\"book5\\", \\"book6\\", \\"book7\\"], \\"user3\\": [\\"book8\\", \\"book9\\"] } genre_books = { \\"fiction\\": [\\"book1\\", \\"book3\\", \\"book5\\", \\"book8\\"], \\"non-fiction\\": [\\"book2\\", \\"book4\\", \\"book6\\"], \\"fantasy\\": [\\"book7\\", \\"book9\\", \\"book10\\"] } result = recommend_book(purchase_history, genre_books, \\"fiction\\") print(result) # Output: \\"book5\\" (or \\"book8\\" depending on the implementation) ``` # Requirements * Ensure the solution handles cases where multiple users have the same maximum number of purchases in the specified genre by choosing one of them arbitrarily. * Optimize for scenarios where the purchase history is large. * Validate input data to handle edge cases gracefully.","solution":"from typing import Dict, List def recommend_book(purchase_history: Dict[str, List[str]], genre_books: Dict[str, List[str]], genre: str) -> str: max_purchased_books = 0 user_most_purchased = None for user, books in purchase_history.items(): purchased_books_in_genre = [book for book in books if book in genre_books.get(genre, [])] if len(purchased_books_in_genre) > max_purchased_books: max_purchased_books = len(purchased_books_in_genre) user_most_purchased = user if user_most_purchased is None: return \\"\\" purchased_books = set(purchase_history[user_most_purchased]) for book in genre_books.get(genre, []): if book not in purchased_books: return book return \\"\\""},{"question":"# Palindrome Partitions with Constraints Context: Partitioning a string such that each substring is a palindrome is a common problem. In this variation, you must consider additional constraints on which characters can be used in forming palindrome substrings. This added restriction will test your understanding of dynamic programming and backtracking algorithms. Problem Statement: Write a function `partition_with_constraints(s: str, allowed_chars: List[str]) -> List[List[str]]` which returns all possible palindrome partitioning of the string `s` such that only allowed characters can be used in forming palindrome substrings. Each partition must be a list of palindromic substrings. * The allowed characters are given as a list of single characters. * Your solution must ensure that all substrings in the partition can only contain characters from `allowed_chars`. Input: * `s` - a string consisting of lowercase English letters. * `allowed_chars` - a list of single characters representing the allowed characters that can form palindromes (1 ≤ len(allowed_chars) ≤ 26). Output: * A list of lists, where each inner list represents a possible palindrome partition of the string `s` adhering to the constraints. Example: ```python s = \\"aab\\" allowed_chars = [\\"a\\", \\"b\\"] partition_with_constraints(s, allowed_chars) ``` Expected Output: ```python [ [\\"a\\", \\"a\\", \\"b\\"], [\\"aa\\", \\"b\\"] ] ``` Constraints: 1. If no valid partitions exist, return an empty list. 2. Assume the input string and allowed characters are valid and contain only lowercase English letters. Function Signature: ```python from typing import List def partition_with_constraints(s: str, allowed_chars: List[str]) -> List[List[str]]: pass ``` Notes: * Consider edge cases where the input string or allowed characters may be empty. * Optimize your solution to handle the worst-case scenario within a reasonable time for given constraints. Create your function ensuring it identifies all possible sets of palindromic partitions while respecting the character constraints, leveraging dynamic programming or backtracking as necessary.","solution":"from typing import List def is_palindrome(s: str) -> bool: Helper function to check if a given string is a palindrome. return s == s[::-1] def partition_with_constraints(s: str, allowed_chars: List[str]) -> List[List[str]]: Returns all possible palindrome partitioning of the string `s` such that only allowed characters can be used in forming palindrome substrings. allowed_set = set(allowed_chars) result = [] def backtrack(start: int, path: List[str]): if start == len(s): result.append(path.copy()) return for end in range(start + 1, len(s) + 1): substring = s[start:end] if is_palindrome(substring) and all(c in allowed_set for c in substring): path.append(substring) backtrack(end, path) path.pop() backtrack(0, []) return result"},{"question":"# Context: As a data analyst for an e-commerce platform, you are required to analyze customer purchase patterns. You need to cluster customers based on their purchase history to identify distinct customer segments. # Task: Implement a Python function `cluster_customers(data_path, n_clusters)` that: 1. Loads the purchase history data from a CSV file specified by `data_path`. 2. Processes the data to extract relevant features for clustering. 3. Applies the K-means clustering algorithm to segment the customers into the specified number of clusters. # Input: * `data_path` (str): File path to the dataset in CSV format, where each row represents a customer\'s purchase behavior. * `n_clusters` (int): Number of clusters to form. # Output: * Returns a list where each index represents a customer and the value at that index represents the cluster the customer belongs to. # Constraints: * The dataset must contain at least 50 rows of data. * Assume the CSV file is correctly formatted. * Use the elbow method to determine an optimal number of features before applying the clustering algorithm. # Requirements: * Ensure your clustering algorithm scales with larger datasets. * Optimize feature selection to improve clustering performance. # Example: ```python clusters = cluster_customers(\\"purchase_history.csv\\", 5) print(clusters) # Output: Example: [0, 1, 2, 0, 4, 3, 2,…] ``` This problem tests the ability to process data for clustering, select optimal features, and implement a K-means clustering algorithm, thereby matching the style, complexity, and scope of the initial question.","solution":"import pandas as pd from sklearn.cluster import KMeans from sklearn.preprocessing import StandardScaler from sklearn.decomposition import PCA def cluster_customers(data_path, n_clusters): Clusters customers based on their purchase history. Parameters: data_path (str): Path to CSV file containing purchase history data. n_clusters (int): Number of clusters to form. Returns: List[int]: A list where each index represents a customer and the value at that index represents the cluster the customer belongs to. # Load data data = pd.read_csv(data_path) # Drop non-numeric and identifier columns if present data = data.select_dtypes(include=[float, int]) # Standardize the data scaler = StandardScaler() scaled_data = scaler.fit_transform(data) # Using PCA to reduce dimensionality (elbow method can be used for selecting optimal number of features) pca = PCA(n_components=0.95) # Retain 95% of variance pca_data = pca.fit_transform(scaled_data) # Apply K-means clustering kmeans = KMeans(n_clusters=n_clusters, random_state=42) clusters = kmeans.fit_predict(pca_data) return clusters.tolist()"},{"question":"# Maximum Subarray Sum: Dynamic Programming **Context:** In the field of finance, finding optimal sections of an investment period that yield the highest returns is a common problem. This can be modeled using arrays where each element represents the return for a specific day. You need to find the continuous subarray within an array (containing at least one number) that has the largest sum, which helps in identifying the best investment period. **Problem Statement:** Implement a function `max_subarray_sum(nums)` that receives: 1. A list `nums` containing integers which represent the daily returns. Your function should return the sum of the contiguous subarray with the largest sum. **Function Signature:** ```python def max_subarray_sum(nums: List[int]) -> int: pass ``` **Input:** - `nums`: A list of integers where each integer represents the return for the day. **Output:** - An integer which is the sum of the contiguous subarray with the largest sum. **Constraints:** - The length of `nums` will be between `1` and `10^4`. - Each element in `nums` will be between `-10^4` and `10^4`. **Example:** ```python # Example input nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # Example output 6 ``` **Explanation:** The subarray `[4, -1, 2, 1]` has the largest sum `6`. **Notes:** - You are encouraged to implement this with an efficient algorithm such as Kadane’s Algorithm which runs in O(n) time complexity. - Handle the cases where all numbers might be negative carefully, ensuring the single largest number is selected.","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Function to find the sum of the contiguous subarray with the largest sum. if not nums: return 0 # Initialize our variables current_max = global_max = nums[0] for number in nums[1:]: current_max = max(number, current_max + number) if current_max > global_max: global_max = current_max return global_max"},{"question":"# Coding Assessment Question You are developing a software package for a library management system. As part of the system\'s functionality, you need to implement a feature that categorizes books based on their genres and availability status. Task Write a function `categorize_books(books: List[Dict[str, Any]]) -> Dict[str, Dict[str, List[str]]]` that categorizes books into genres and further sub-categorizes them based on their availability status (\'available\' or \'checked_out\'). Input: - `books` (List[Dict[str, Any]]): A list of dictionaries, where each dictionary represents a book with the following keys: - `title` (str): The title of the book. - `genre` (str): The genre of the book. - `is_available` (bool): The availability status of the book. Output: - (Dict[str, Dict[str, List[str]]]): A nested dictionary where the keys are genres (str), and each key maps to another dictionary where keys are availability statuses (\'available\', \'checked_out\'), mapping to lists of book titles corresponding to each status. Constraints: - If a genre has no books in a particular availability status, the status should still be included with an empty list as its value. - All titles and genres will be non-empty strings. - The list of books may be empty. Examples: ```python # Example 1: Categorizing a small set of books books = [ {\\"title\\": \\"Book A\\", \\"genre\\": \\"Fiction\\", \\"is_available\\": True}, {\\"title\\": \\"Book B\\", \\"genre\\": \\"Fiction\\", \\"is_available\\": False}, {\\"title\\": \\"Book C\\", \\"genre\\": \\"Science\\", \\"is_available\\": True}, ] expected_output = { \\"Fiction\\": { \\"available\\": [\\"Book A\\"], \\"checked_out\\": [\\"Book B\\"] }, \\"Science\\": { \\"available\\": [\\"Book C\\"], \\"checked_out\\": [] } } assert categorize_books(books) == expected_output # Example 2: All books in one genre, mixed availability books = [ {\\"title\\": \\"Book D\\", \\"genre\\": \\"History\\", \\"is_available\\": False}, {\\"title\\": \\"Book E\\", \\"genre\\": \\"History\\", \\"is_available\\": True}, {\\"title\\": \\"Book F\\", \\"genre\\": \\"History\\", \\"is_available\\": True} ] expected_output = { \\"History\\": { \\"available\\": [\\"Book E\\", \\"Book F\\"], \\"checked_out\\": [\\"Book D\\"] } } assert categorize_books(books) == expected_output # Example 3: No books available books = [] expected_output = {} assert categorize_books(books) == expected_output ``` Provide comprehensive test cases for your function, including edge cases where the list of books is empty, all books belong to the same genre with different availability statuses, and typical cases reflecting realistic library inventory scenarios.","solution":"from typing import List, Dict, Any def categorize_books(books: List[Dict[str, Any]]) -> Dict[str, Dict[str, List[str]]]: categorized = {} for book in books: genre = book[\'genre\'] title = book[\'title\'] status = \'available\' if book[\'is_available\'] else \'checked_out\' if genre not in categorized: categorized[genre] = {\'available\': [], \'checked_out\': []} categorized[genre][status].append(title) return categorized"},{"question":"# Coding Question **Objective**: Write a function to calculate the matrix product of two 2D lists (matrices). # Problem Statement You are given two matrices represented as 2D lists. You need to write a function `matrix_product(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]` that takes these matrices as input and returns their matrix product. # Input Format - Two 2D lists (matrices) `matrix1` and `matrix2` where each list contains sublists representing rows. - Each sublist will contain integers. - Example: ```python matrix1 = [[1, 2, 3], [4, 5, 6]] matrix2 = [[7, 8], [9, 10], [11, 12]] ``` # Output Format - A new 2D list representing the product of the two input matrices. - Example: ```python [[58, 64], [139, 154]] ``` # Constraints - Matrix multiplication is only defined when the number of columns in `matrix1` is equal to the number of rows in `matrix2`. - You may assume that the matrices passed to the function are always valid for multiplication. # Example ```python # Example 1 matrix1 = [[1, 2, 3], [4, 5, 6]] matrix2 = [[7, 8], [9, 10], [11, 12]] assert matrix_product(matrix1, matrix2) == [[58, 64], [139, 154]] # Example 2 matrix1 = [[1, 0], [0, 1]] matrix2 = [[4, 1], [2, 2]] assert matrix_product(matrix1, matrix2) == [[4, 1], [2, 2]] # Example 3 matrix1 = [[2, 3], [4, 5]] matrix2 = [[1, 2], [3, 4]] assert matrix_product(matrix1, matrix2) == [[11, 16], [19, 28]] ``` # Requirements - You must write the core logic to perform matrix multiplication. - Ensure that your implementation is efficient and handles the given constraints properly.","solution":"def matrix_product(matrix1, matrix2): Compute the matrix product of two 2D lists (matrices). Args: matrix1 (List[List[int]]): The first matrix. matrix2 (List[List[int]]): The second matrix. Returns: List[List[int]]: The product matrix. result = [[0 for _ in range(len(matrix2[0]))] for _ in range(len(matrix1))] for i in range(len(matrix1)): for j in range(len(matrix2[0])): for k in range(len(matrix2)): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"# **Question 2**: Implementing a Stack with Minimum Retrieval You are required to implement a custom stack in Python that, in addition to the usual stack operations like push and pop, allows retrieval of the minimum element in constant time. **Requirements**: * Implement a class `MinStack` that supports the following methods: * `push(val: int)` pushes the element `val` onto the stack. * `pop()` removes the element on the top of the stack. * `top()` gets the top element of the stack. * `get_min()` retrieves the minimum element in the stack. **Function Specifications**: ```python class MinStack: def __init__(self): Initialize your data structure here. pass def push(self, val: int) -> None: Push element val onto stack. pass def pop(self) -> None: Remove the element on the top of the stack. pass def top(self) -> int: Get the top element. pass def get_min(self) -> int: Retrieve the minimum element in the stack. pass ``` **Constraints**: * The number of `push`, `pop`, `top`, and `get_min` operations will be at most (10^4). * These methods should operate in constant O(1) time complexity. **Example**: ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Expected output: -3 min_stack.pop() print(min_stack.top()) # Expected output: 0 print(min_stack.get_min()) # Expected output: -2 ``` **Edge Cases** to Consider: * What happens when `pop()` is called on an empty stack? * How should `get_min()` behave when the stack is empty? * Ensure merging of the logic for stack operations and the minimum element tracking remains efficient even with frequent inserts and deletes.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Push element val onto the stack. self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Remove the element on the top of the stack. if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element. return self.stack[-1] if self.stack else None def get_min(self) -> int: Retrieve the minimum element in the stack. return self.min_stack[-1] if self.min_stack else None"},{"question":"# Weather Data Parsing Objective Design a function that parses weather data from a JSON format and calculates the average temperature for each city over a specified period. Input The function will take: 1. **weather_data**: A JSON string containing weather data for multiple cities. Each city has a dictionary with dates as keys and temperature readings as values. 2. **start_date**: A string representing the start date in \\"YYYY-MM-DD\\" format. 3. **end_date**: A string representing the end date in \\"YYYY-MM-DD\\" format. Output The function should return a dictionary where keys are city names and values are the average temperatures over the specified date range. Constraints - Ensure the dates in the weather data are in \\"YYYY-MM-DD\\" format. - The start_date and end_date will always be in the range of dates available in the weather_data. - The weather_data JSON string contains valid JSON. Example Usage ```python weather_data = \'\'\' { \\"New York\\": { \\"2023-01-01\\": 5, \\"2023-01-02\\": 7, \\"2023-01-03\\": 6 }, \\"Los Angeles\\": { \\"2023-01-01\\": 10, \\"2023-01-02\\": 12, \\"2023-01-03\\": 11 } } \'\'\' # Example function call result = calculate_average_temperature(weather_data, \\"2023-01-01\\", \\"2023-01-02\\") print(result) # Expected output: {\\"New York\\": 6.0, \\"Los Angeles\\": 11.0} ``` Implementation Details 1. Parse the JSON string to a dictionary. 2. Extract temperature values for each city within the specified date range. 3. Calculate and return the average temperature for each city. Function Signature ```python import json from datetime import datetime from typing import Dict def calculate_average_temperature(weather_data: str, start_date: str, end_date: str) -> Dict[str, float]: # Your implementation here pass ```","solution":"import json from datetime import datetime from typing import Dict def calculate_average_temperature(weather_data: str, start_date: str, end_date: str) -> Dict[str, float]: data = json.loads(weather_data) start = datetime.strptime(start_date, \\"%Y-%m-%d\\") end = datetime.strptime(end_date, \\"%Y-%m-%d\\") average_temps = {} for city, temps in data.items(): total_temp = 0 count = 0 for date, temp in temps.items(): current_date = datetime.strptime(date, \\"%Y-%m-%d\\") if start <= current_date <= end: total_temp += temp count += 1 if count > 0: average_temps[city] = total_temp / count return average_temps"},{"question":"# Sum of Nested Arrays You need to implement a function that calculates the weighted sum of all integer elements in a nested list, where the weight is the depth of the integer within the nested structure. The depth of the shallowest integers is 1, the depth of integers inside one level of nested lists is 2, and so on. Function Signature ```python def nested_list_weight_sum(nested_list: list) -> int: ``` Input * `nested_list` (list): A list which contains integers and/or other nested lists of integers, with depth ranging from 1 to 10. Each integer within the list can be in the range of ([-10^6, 10^6]). The length of the list does not exceed 100 elements. Output * Returns an integer which is the weighted sum of all integers in the nested list. Requirements * Your solution should handle the nested structure efficiently. * Ensure that the solution processes lists with varying depths correctly. Example ```python # Example 1: nested_list = [1, [4, [6]]] print(nested_list_weight_sum(nested_list)) #=> 27 # Example 2: nested_list = [1, [2, [3, 4]], [5]] print(nested_list_weight_sum(nested_list)) #=> 27 # Example 3: nested_list = [1, 2, [3, 4, [5, 6, [7]]]] print(nested_list_weight_sum(nested_list)) #=> 50 ``` Explanation 1. In the first example, 1 has depth 1, 4 has depth 2, and 6 has depth 3. The weighted sum is (1*1 + 4*2 + 6*3 = 1 + 8 + 18 = 27). 2. In the second example, the weighted sum is calculated as (1*1 + 2*2 + 3*3 + 4*3 + 5*2 = 1 + 4 + 9 + 12 + 10 = 36). 3. In the third example, the weighted sum is calculated by considering the varying depths, resulting in (1*1 + 2*1 + 3*2 + 4*2 + 5*3 + 6*3 + 7*4 = 1 + 2 + 6 + 8 + 15 + 18 + 28 = 78). Implement the function `nested_list_weight_sum` to solve the problem efficiently. Make sure to handle all edge cases and optimize your solution to avoid redundant computations.","solution":"def nested_list_weight_sum(nested_list: list, depth=1) -> int: Returns the weighted sum of all integer elements in a nested list, where the weight is the depth of the integer within the nested structure. total_sum = 0 for element in nested_list: if isinstance(element, list): total_sum += nested_list_weight_sum(element, depth + 1) else: total_sum += element * depth return total_sum"},{"question":"# Fibonacci Sequence Generator with Memoization Objective Develop a `FibonacciGenerator` that efficiently computes Fibonacci numbers using memoization technique to enhance performance. The generator should be capable of generating the first `n` Fibonacci numbers and retrieving previously cached results to avoid redundant computations. Instructions 1. **Class Definition**: Define a class `FibonacciGenerator` that: - Maintains a dictionary to store previously computed Fibonacci numbers. - Provides a method to generate the first `n` Fibonacci numbers. - Allows retrieval of any Fibonacci number by its position. 2. **Class Methods**: - `generate(n: int) -> list`: Generates and returns a list of the first `n` Fibonacci numbers. - `get_fibonacci(position: int) -> int`: Returns the Fibonacci number at the specified position. - `clear_cache() -> None`: Clears the internal cache of previously computed Fibonacci numbers. 3. **Implementation Details**: - Use memoization to store results of previously computed Fibonacci numbers to optimize the performance. - Use Python\'s default dictionary or similar data structure to implement the cache. # Example Here\'s an example of how your `FibonacciGenerator` can be used: ```python fib_gen = FibonacciGenerator() print(fib_gen.generate(10)) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] print(fib_gen.get_fibonacci(5)) # Output: 5 print(fib_gen.generate(15)) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377] fib_gen.clear_cache() ``` Constraints - Assume that `n` (number of terms to generate) will be between 1 and 1000. - The position for retrieving a Fibonacci number will always be a positive integer. - Optimize for time complexity using memoization techniques.","solution":"class FibonacciGenerator: def __init__(self): self.cache = {0: 0, 1: 1} def generate(self, n: int) -> list: # Ensure we have memoized all Fibonacci numbers up to n-1 for i in range(2, n): if i not in self.cache: self.cache[i] = self.cache[i - 1] + self.cache[i - 2] return [self.cache[i] for i in range(n)] def get_fibonacci(self, position: int) -> int: if position not in self.cache: self.cache[position] = self.get_fibonacci(position - 1) + self.get_fibonacci(position - 2) return self.cache[position] def clear_cache(self) -> None: self.cache = {0: 0, 1: 1}"},{"question":"# Binomial Coefficient Calculation In this coding task, you are required to implement a function that computes the binomial coefficient, commonly known as \\"n choose k,\\" which represents the number of ways to choose `k` elements from a set of `n` elements without regard to order. # Function to Implement You need to implement the following function: ```python def binomial_coefficient(n: int, k: int) -> int: Calculates the binomial coefficient \\"n choose k\\". Parameters: n (int): The total number of items. k (int): The number of items to choose from the total. Returns: int: The binomial coefficient C(n, k). pass ``` # Input - An integer `n`, representing the total number of items. - An integer `k`, representing the number of items to choose from the total. # Output - An integer representing the binomial coefficient (C(n, k)). # Constraints - (0 leq k leq n leq 1000) - Consider using an efficient algorithm to handle large calculations. # Example ```python binomial_coefficient(5, 2) # Output: 10 binomial_coefficient(10, 5) # Output: 252 ``` # Explanation Given `n=5` and `k=2`: 1. The binomial coefficient formula (C(n, k) = frac{n!}{k!(n-k)!}) should be used. 2. Calculate the factorial of `n`, `k`, and `n-k`, then compute the binomial coefficient using the formula. 3. Return the computed value. Edge cases: - When `k` is 0, the result should be 1 (since there\'s exactly one way to choose 0 items from `n`). - When `k` is equal to `n`, the result should also be 1 (since there\'s exactly one way to choose all `n` items from `n`). Implement the function ensuring efficient handling of large numbers, possibly using memoization or iterative methodologies to optimize factorial computations.","solution":"import math def binomial_coefficient(n: int, k: int) -> int: Calculates the binomial coefficient \\"n choose k\\". Parameters: n (int): The total number of items. k (int): The number of items to choose from the total. Returns: int: The binomial coefficient C(n, k). if k < 0 or k > n: return 0 if k == 0 or k == n: return 1 # Use the symmetry property to minimize calculations k = min(k, n - k) c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"# Question: Implement an Efficient Roman to Integer Converter You are given a string representing a Roman numeral. Your task is to convert this Roman numeral string into its equivalent integer value in an efficient manner. # Requirements: 1. Write a function `roman_to_int(s: str) -> int` that takes a string representing a Roman numeral and returns its integer equivalent. 2. The function should correctly handle all valid Roman numerals from 1 to 3999. 3. Optimize the conversion process by considering the subtractive notation used in Roman numerals. # Constraints: * The input string length will be between 1 and 15 characters. * The input string will always represent a valid Roman numeral. # Roman Numeral Basics: - The symbols are `I V X L C D M`, which stand for `1 5 10 50 100 500 1000`. - Some numbers use subtractive combinations (e.g., `IV` for 4, `IX` for 9, `XL` for 40, `XC` for 90, `CD` for 400, `CM` for 900). # Expected Input and Output: **Input**: A string `s` representing a valid Roman numeral **Output**: An integer representing the equivalent of the Roman numeral ```python def roman_to_int(s: str) -> int: >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 pass ``` # Performance Requirement: * Ensure that the solution runs efficiently within the provided constraints. # Explanation: - You need to demonstrate a clear understanding of string traversal and conditional checks. - Pay special attention to efficiently handling subtractive combinations. - Avoid unnecessary operations to keep the overall complexity low. This question tests the candidate\'s ability to implement efficient string manipulation and conversion logic, similar to the provided sample question on Atbash cipher optimization.","solution":"def roman_to_int(s: str) -> int: roman_numerals = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_numerals[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Question Scenario: As a junior software developer at a tech company, you are given a task to analyze and manipulate a given dataset that is represented as a list of integers. Your specific task is to implement a function that finds the maximum difference between any two elements in the list such that the larger element comes after the smaller element in the input list. This problem is common in many financial and data analysis applications where the aim is to maximize profit by buying and selling at the right times. Task: Write a Python function `max_difference` that accepts a list of integers and returns the maximum difference found according to the specified conditions. If no such elements exist, return -1. Function Signature: ```python def max_difference(numbers: list[int]) -> int: ``` Input: - A list of integers, `numbers` (0 <= len(numbers) <= 10^5). Output: - An integer representing the maximum difference where the larger element appears after the smaller element. If no such pair exists, return -1. Constraints: - You may assume all list elements are integers within the range of [-10^6, 10^6]. - Aim for an efficient solution with a linear time complexity of (O(n)) and space complexity of (O(1)). Performance Requirements: - The implementation should handle edge cases effectively (e.g., empty list, single element list, non-decreasing or non-increasing lists). Example Usage: ```python >>> max_difference([2, 3, 10, 2, 4, 8, 1]) 8 # The maximum difference is 10 - 2 = 8 >>> max_difference([7, 9, 5, 6, 3, 2]) 2 # The maximum difference is 9 - 7 = 2 >>> max_difference([1, 2, 90, 10, 110]) 109 # The maximum difference is 110 - 1 = 109 >>> max_difference([4, 3, 2, 1]) -1 # No valid difference, since the list is decreasing >>> max_difference([]) -1 # Empty list case ```","solution":"def max_difference(numbers: list[int]) -> int: Returns the maximum difference between any two elements in the list such that the larger element comes after the smaller element in the input list. If no such elements exist, return -1. if len(numbers) < 2: return -1 min_value = numbers[0] max_diff = -1 for i in range(1, len(numbers)): if numbers[i] > min_value: max_diff = max(max_diff, numbers[i] - min_value) min_value = min(min_value, numbers[i]) return max_diff"},{"question":"# Coding Assessment Question Context You are given a class `Matrix` that represents a 2D matrix with integer elements. The class supports various operations such as matrix addition, multiplication, and transposition. Problem Statement Implement the following function: ```python def rotate_matrix_90_degrees(matrix: Matrix) -> Matrix: Rotates the given matrix by 90 degrees clockwise. Args: matrix (Matrix): The input matrix. Returns: Matrix: The matrix rotated by 90 degrees clockwise. pass ``` Definition The function `rotate_matrix_90_degrees` takes a `Matrix` instance and returns a new `Matrix` instance which is the result of rotating the input matrix by 90 degrees clockwise. Input - `matrix`: An instance of the `Matrix` class representing a 2D matrix of integers. Output - A new instance of the `Matrix` class representing the rotated matrix. Constraints - The matrix is not empty and has dimensions (m times n) where (1 leq m, n leq 100). Examples ```python # Example 1 matrix_1 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) rotated_matrix_1 = Matrix([[7, 4, 1], [8, 5, 2], [9, 6, 3]]) assert rotate_matrix_90_degrees(matrix_1).data == rotated_matrix_1.data # Example 2 matrix_2 = Matrix([[1, 2], [3, 4], [5, 6]]) rotated_matrix_2 = Matrix([[5, 3, 1], [6, 4, 2]]) assert rotate_matrix_90_degrees(matrix_2).data == rotated_matrix_2.data ``` Notes 1. You may utilize the existing methods and properties of the `Matrix` class to aid in the rotation process. 2. Ensure that the dimensions of the resulting matrix are correctly adjusted after the rotation. 3. Consider edge cases where the matrix has only one row or column.","solution":"class Matrix: def __init__(self, data): self.data = data def __eq__(self, other): return self.data == other.data def rotate_matrix_90_degrees(matrix: Matrix) -> Matrix: Rotates the given matrix by 90 degrees clockwise. Args: matrix (Matrix): The input matrix. Returns: Matrix: The matrix rotated by 90 degrees clockwise. data = matrix.data rows, cols = len(data), len(data[0]) rotated_data = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated_data[c][rows - 1 - r] = data[r][c] return Matrix(rotated_data)"},{"question":"# Tree Diameter Calculator Context In graph theory, the diameter of a tree is the length of the longest path between any two nodes. A tree is an undirected graph in which any two vertices are connected by exactly one path. You are tasked with implementing a function to find the diameter of a tree represented as a set of edges. Task Implement a function `tree_diameter(edges: List[Tuple[int, int]]) -> int` which takes a list of tuples representing the edges of the tree and returns an integer representing the diameter of the tree. Input and Output Formats * **Input**: A list of tuples `edges` where each tuple `(a, b)` represents an edge connecting nodes `a` and `b`. * **Output**: An integer representing the diameter of the tree. Constraints * The length of `edges` will be at most 5000. * The nodes in the tree are labeled with non-negative integers starting from 0. * Each node in the tree is connected by a unique path. Example ```python def tree_diameter(edges: List[Tuple[int, int]]) -> int: >>> tree_diameter([(0, 1), (1, 2), (1, 3), (2, 4), (3, 5)]) 4 >>> tree_diameter([(0, 1), (1, 2), (2, 3)]) 3 >>> tree_diameter([(0, 1)]) 1 >>> tree_diameter([]) 0 pass ``` Requirements * Implement the function using an efficient algorithm, such as two BFS/DFS from the farthest nodes, to ensure the correctness within the provided constraints. * The algorithm should run with a time complexity of O(n), where n is the number of nodes in the tree.","solution":"from typing import List, Tuple from collections import deque, defaultdict def tree_diameter(edges: List[Tuple[int, int]]) -> int: Function to calculate the diameter of a tree given its edges. if not edges: return 0 def bfs(node): visited = set() queue = deque([(node, 0)]) farthest_node, max_dist = node, 0 while queue: current, dist = queue.popleft() visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, dist + 1)) if dist + 1 > max_dist: farthest_node, max_dist = neighbor, dist + 1 return farthest_node, max_dist # Build the graph graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) # Step 1: Start BFS/DFS from any arbitrary node to find the farthest node from it arbitrary_node = edges[0][0] farthest_node, _ = bfs(arbitrary_node) # Step 2: Start BFS/DFS from the farthest node found in step 1 to get the diameter _, diameter = bfs(farthest_node) return diameter"},{"question":"# Question: Custom String Sorting You are tasked with implementing a custom sorting function for strings based on a given order of precedence for characters. The function should take a list of strings and a string that defines the desired character order and return the list of strings sorted accordingly. Function Specification ```python def custom_string_sort(string_list: list[str], order: str) -> list[str]: Sorts a list of strings based on the given character precedence order. Parameters: string_list (list of str): A list of strings to be sorted. order (str): A string representing the desired character order. Returns: list of str: Sorted list of strings according to the given character precedence. Examples: >>> custom_string_sort([\\"cabbage\\", \\"apple\\", \\"banana\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") [\'cabbage\', \'banana\', \'apple\'] >>> custom_string_sort([\\"dog\\", \\"cat\\", \\"bird\\"], \\"abcdefghijklmnopqrstuvwxyz\\") [\'bird\', \'cat\', \'dog\'] >>> custom_string_sort([\\"xyz\\", \\"abc\\", \\"def\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") [\'xyz\', \'def\', \'abc\'] >>> custom_string_sort([\\"a\\", \\"aaa\\", \\"aa\\"], \\"abcdefgh\\") [\'a\', \'aa\', \'aaa\'] ``` Requirements 1. **Input Constraints**: - `string_list` will be a list of strings containing only lowercase alphabetical characters. - `order` will be a string containing a permutation of the 26 lowercase English letters. 2. **Output**: - The function should return `string_list` sorted according to the precedence defined in `order`. 3. **Edge Cases**: - Handle empty lists gracefully by returning an empty list. - Ensure strings with the same characters in different orders are correctly sorted. 4. **Performance Considerations**: - The function should efficiently handle lists of strings, leveraging the characteristics of Python\'s built-in sorting functionalities while applying the custom order.","solution":"def custom_string_sort(string_list: list[str], order: str) -> list[str]: Sorts a list of strings based on the given character precedence order. Parameters: string_list (list of str): A list of strings to be sorted. order (str): A string representing the desired character order. Returns: list of str: Sorted list of strings according to the given character precedence. Examples: >>> custom_string_sort([\\"cabbage\\", \\"apple\\", \\"banana\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") [\'cabbage\', \'banana\', \'apple\'] >>> custom_string_sort([\\"dog\\", \\"cat\\", \\"bird\\"], \\"abcdefghijklmnopqrstuvwxyz\\") [\'bird\', \'cat\', \'dog\'] >>> custom_string_sort([\\"xyz\\", \\"abc\\", \\"def\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") [\'xyz\', \'def\', \'abc\'] >>> custom_string_sort([\\"a\\", \\"aaa\\", \\"aa\\"], \\"abcdefgh\\") [\'a\', \'aa\', \'aaa\'] # Create a dictionary to map each character in `order` to its index order_index = {char: idx for idx, char in enumerate(order)} # Define a custom key function that transforms each string into a tuple of indices def custom_key(string): return [order_index[char] for char in string] # Sort the list with the custom key return sorted(string_list, key=custom_key)"},{"question":"# Coding Assessment Question You are tasked with writing a function that processes customer orders, simulates a database query, and uses mock testing to ensure its correctness without interacting with a real database. The goal is to verify the function\'s behavior with predefined responses. Scenario Your task is to write a function `get_order_details` which fetches order details from a fictional order database. Additionally, you need to write test cases using mock testing to ensure the function behaves correctly under predefined conditions. Implementation Details **Function: get_order_details(db_conn: Any, order_id: int) -> dict** * **Inputs**: - `db_conn` (Any): A database connection object. - `order_id` (int): The ID of the order to fetch details for. * **Outputs**: - A dictionary containing order details with keys `order_id`, `customer_name`, `items`, and `total_price`. **Mock Testing Function** * Write a function `test_get_order_details` that uses mock responses to test `get_order_details`. * Ensure to mock the database query within `get_order_details`. Example: ```python from typing import Any import pytest def get_order_details(db_conn: Any, order_id: int) -> dict: cursor = db_conn.cursor() cursor.execute(\\"SELECT * FROM orders WHERE order_id = ?\\", (order_id,)) row = cursor.fetchone() if row is None: return {} return { \\"order_id\\": row[\\"order_id\\"], \\"customer_name\\": row[\\"customer_name\\"], \\"items\\": row[\\"items\\"], \\"total_price\\": row[\\"total_price\\"] } def test_get_order_details(monkeypatch): class FakeCursor: def execute(self, query, params): assert query == \\"SELECT * FROM orders WHERE order_id = ?\\" assert params == (1234,) def fetchone(self): return {\\"order_id\\": 1234, \\"customer_name\\": \\"John Doe\\", \\"items\\": [\\"item1\\", \\"item2\\"], \\"total_price\\": 99.99} class FakeDBConnection: def cursor(self): return FakeCursor() def mock_db_conn(*args, **kwargs): return FakeDBConnection() monkeypatch.setattr(\\"__main__.db_conn\\", mock_db_conn) result = get_order_details(mock_db_conn(), 1234) assert result[\\"order_id\\"] == 1234 assert result[\\"customer_name\\"] == \\"John Doe\\" assert result[\\"items\\"] == [\\"item1\\", \\"item2\\"] assert result[\\"total_price\\"] == 99.99 def test_get_order_details_no_order(monkeypatch): class FakeCursor: def execute(self, query, params): assert query == \\"SELECT * FROM orders WHERE order_id = ?\\" assert params == (9999,) def fetchone(self): return None class FakeDBConnection: def cursor(self): return FakeCursor() def mock_db_conn(*args, **kwargs): return FakeDBConnection() monkeypatch.setattr(\\"__main__.db_conn\\", mock_db_conn) result = get_order_details(mock_db_conn(), 9999) assert result == {} ``` In the above example, you need to ensure the correctness of `get_order_details` by developing appropriate mock setups and assertions. **Constraints**: * Do not interact with an actual database. * Use Python\'s `sqlite3` or equivalent for the database connection and `monkeypatch` for mocking. * Handle edge cases for order IDs and missing data.","solution":"from typing import Any def get_order_details(db_conn: Any, order_id: int) -> dict: Fetches order details from the database for the given order_id. Parameters: db_conn (Any): A database connection object. order_id (int): The ID of the order to fetch details for. Returns: dict: A dictionary containing order details. cursor = db_conn.cursor() cursor.execute(\\"SELECT * FROM orders WHERE order_id = ?\\", (order_id,)) row = cursor.fetchone() if row is None: return {} return { \\"order_id\\": row[\\"order_id\\"], \\"customer_name\\": row[\\"customer_name\\"], \\"items\\": row[\\"items\\"], \\"total_price\\": row[\\"total_price\\"] }"},{"question":"# Problem Statement You are tasked with implementing a function to transform a list of integers according to specific rules. The transformation involves reversing segments of the list based on a given step size. Specifically, for an input list and step size, reverse every segment of the list of length equal to the step size. # Function Signature ```python def transform_list(lst: list[int], step: int) -> list[int]: ``` # Input * `lst` (list of ints): A list of integers to be transformed. * `step` (int): The step size used to divide and reverse segments of the list. Must be a positive integer. # Output * list of ints: The transformed list where every segment of length `step` is reversed. # Constraints * `lst` can be an empty list. * `step` must be a positive integer (≥ 1). * If `step` is greater than the length of `lst`, reverse the entire list. # Examples ```python >>> transform_list([1, 2, 3, 4, 5, 6, 7, 8], 3) [3, 2, 1, 6, 5, 4, 8, 7] >>> transform_list([10, 20, 30, 40, 50], 2) [20, 10, 40, 30, 50] >>> transform_list([1, 2, 3, 4, 5], 5) [5, 4, 3, 2, 1] >>> transform_list([1, 2, 3], 4) [3, 2, 1] >>> transform_list([], 3) [] >>> transform_list([1, 2, 3], -1) Traceback (most recent call last): ... ValueError: Step size must be a positive integer. ``` # Notes * Ensure your function raises a `ValueError` with the message \\"Step size must be a positive integer.\\" if the input does not meet the required constraints. * Do not use any external libraries for segmenting or reversing the list. Write your own logic to achieve the transformation. * Consider edge cases such as empty lists, step size larger than the list length, and non-positive integers for step size.","solution":"def transform_list(lst: list[int], step: int) -> list[int]: This function takes a list of integers and a step size, and returns a new list where every segment of length equal to the step size is reversed. if step < 1: raise ValueError(\\"Step size must be a positive integer.\\") n = len(lst) result = [] for i in range(0, n, step): segment = lst[i:i + step] result.extend(segment[::-1]) return result"},{"question":"# Scenario You are a software engineer working on an online personal finance application. Your task is to implement a function that calculates the total balance of a user\'s account after processing a series of financial transactions. # Task Write a function `calculate_balance(transactions: List[Tuple[str, int]]) -> int` that computes the total balance given a list of transactions. Each transaction is represented as a tuple where the first element is a string \\"deposit\\" or \\"withdrawal\\" indicating the type of transaction, and the second element is the amount (an integer). # Input Format * `transactions`: A list of tuples. Each tuple consists of a transaction type (\\"deposit\\" or \\"withdrawal\\") and an amount (integer). # Output Format * Return the total balance (integer) after processing all transactions. # Constraints * The transaction list contains at most (10^5) entries. * Each amount will be a non-negative integer and does not exceed (10^6). * The balance will never go below zero. # Example ```python transactions = [ (\\"deposit\\", 100), (\\"withdrawal\\", 50), (\\"deposit\\", 200), (\\"withdrawal\\", 80), ] print(calculate_balance(transactions)) # Output: 170 ```","solution":"from typing import List, Tuple def calculate_balance(transactions: List[Tuple[str, int]]) -> int: Calculates the total account balance after processing a series of financial transactions. :param transactions: A list of tuples where each tuple contains a transaction type (\\"deposit\\" or \\"withdrawal\\") and an amount (integer). :return: The total account balance (integer) after processing all transactions. balance = 0 for transaction in transactions: if transaction[0] == \\"deposit\\": balance += transaction[1] elif transaction[0] == \\"withdrawal\\": balance -= transaction[1] return balance"},{"question":"# Problem: Sum of Unique Odd Elements You are tasked with writing a function that takes a list of integers and returns the sum of all unique odd numbers. This function is essential for processing numerical datasets where only specific elements need to be considered based on given properties. Function Signature ```python def sum_unique_odds(numbers: list) -> int: Computes the sum of unique odd numbers in the given list. Parameters: numbers (list): A list of integers which may include duplicates. Returns: int: The sum of all unique odd integers. Example: >>> sum_unique_odds([1, 2, 3, 4, 5, 3, 1, 5, 7, 8]) 16 >>> sum_unique_odds([2, 2, 2, 4, 4, 6]) 0 ``` Input * A list `numbers` (0 <= len(numbers) <= 1000) composed of integers (-10^6 <= numbers[i] <= 10^6). Output * An integer which is the sum of all unique odd numbers in the input list. Constraints * The function should ignore even numbers. * If there are no odd numbers, return 0. * Elements in the input list may appear multiple times but should only be considered once if they are odd. Examples ```python sum_unique_odds([1, 2, 3, 4, 5, 3, 1, 5, 7, 8]) # Should output: 16 (1 + 3 + 5 + 7) sum_unique_odds([2, 2, 2, 4, 4, 6]) # Should output: 0 (no odd numbers) sum_unique_odds([11, 15, -23, 42, -23, 17]) # Should output: 20 (11 + 15 + 17 - 23) sum_unique_odds([]) # Should output: 0 (empty list) ```","solution":"def sum_unique_odds(numbers): Computes the sum of unique odd numbers in the given list. Parameters: numbers (list): A list of integers which may include duplicates. Returns: int: The sum of all unique odd integers. # Use a set to store unique odd numbers unique_odds = set() for number in numbers: if number % 2 != 0: # Check if the number is odd unique_odds.add(number) # Return the sum of unique odd numbers return sum(unique_odds)"},{"question":"# Load Balancer Program **Problem Statement:** You have been tasked with designing a basic round-robin load balancer for distributing requests evenly across a pool of servers. All the servers in the pool are distinct and represented by their unique IDs. The load balancer maintains a list of these server IDs and assigns incoming requests to them in a round-robin fashion. Your task is to implement a class `LoadBalancer` with the following methods: 1. `__init__(self, servers: List[str]) -> None`: Initializes the load balancer with a list of server IDs. 2. `next_server(self) -> str`: Returns the ID of the next server in the round-robin sequence. 3. `print_servers(self) -> None`: Prints the current order of servers. The `next_server` method should return the next server in the sequence and then move that server to the end of the list, effectively rotating the list. **Function Signatures:** ```python class LoadBalancer: def __init__(self, servers: List[str]) -> None: pass def next_server(self) -> str: pass def print_servers(self) -> None: pass ``` **Input:** - A list of strings representing server IDs when initializing the `LoadBalancer`. - Calls to the `next_server` and `print_servers` methods. **Output:** - The `next_server` method returns a string (server ID). - The `print_servers` method prints the list of servers. **Constraints:** - The server IDs are guaranteed to be non-empty strings. - The list of server IDs passed to the `LoadBalancer` will contain at least one server ID. - You may assume that the `next_server` and `print_servers` methods will be called in a valid context (i.e., they won\'t be called with an uninitialized list). **Examples:** ```python # Example calls: lb = LoadBalancer([\\"server1\\", \\"server2\\", \\"server3\\"]) print(lb.next_server()) # \\"server1\\" print(lb.next_server()) # \\"server2\\" print(lb.next_server()) # \\"server3\\" print(lb.next_server()) # \\"server1\\" lb.print_servers() # [\\"server2\\", \\"server3\\", \\"server1\\"] # Another example: lb = LoadBalancer([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) print(lb.next_server()) # \\"a\\" print(lb.next_server()) # \\"b\\" print(lb.next_server()) # \\"c\\" lb.print_servers() # [\\"d\\", \\"a\\", \\"b\\", \\"c\\"] ``` **Technical Notes:** 1. Implement the rotation within `next_server` method to ensure servers are accessed in a round-robin manner. 2. The `print_servers` method should display the current state of the server list, aiding in debugging and verification of the round-robin behavior. 3. Ensure your implementation handles list rotation efficiently to maintain consistent performance.","solution":"from typing import List class LoadBalancer: def __init__(self, servers: List[str]) -> None: self.servers = servers def next_server(self) -> str: next_server = self.servers.pop(0) self.servers.append(next_server) return next_server def print_servers(self) -> None: print(self.servers)"},{"question":"# Question: Matrix Diagonal Sum with Exclusions You are tasked with implementing a function that computes the sum of both the primary and secondary diagonals of a given square matrix, excluding any elements that are common to both diagonals. The function should handle edge cases and input validation appropriately. A square matrix is a matrix with the same number of rows and columns. The primary diagonal of a square matrix consists of elements from the top left to the bottom right. The secondary diagonal consists of elements from the top right to the bottom left. For a 3x3 matrix: - The primary diagonal elements are those at positions (0,0), (1,1), and (2,2). - The secondary diagonal elements are those at positions (0,2), (1,1), and (2,0). If an element is part of both diagonals (it lies at the center of an odd dimension matrix), it should only be added once. **Function Signature**: ```python def diagonal_sum(matrix: List[List[int]]) -> int: pass ``` # Input - `matrix` (List[List[int]]): A two-dimensional list representing a square matrix of integers. The matrix dimensions will be between 1x1 and 100x100 inclusive. # Output - Returns the sum of the elements in both diagonals, with no duplication of elements. # Constraints - The function should only accept a square matrix. - Should handle edge cases, such as non-square matrices by raising `ValueError`. - Use appropriate error messages mentioned in the given snippets. # Examples ```python assert diagonal_sum([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 25 # 1 + 5 + 9 + 3 + 7 (excluding the middle element 5 twice) assert diagonal_sum([ [5, 2], [9, 4] ]) == 20 # 5 + 4 + 2 + 9 assert diagonal_sum([ [1] ]) == 1 # Single element matrix try: diagonal_sum([ [1, 2], [3, 4], [5, 6] ]) except ValueError as e: assert str(e) == \\"Invalid input: matrix must be square\\" try: diagonal_sum(\\"not a matrix\\") except ValueError as e: assert str(e) == \\"Invalid input: matrix must be a list of lists containing integers\\" ```","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Invalid input: matrix must be a list of lists containing integers\\") n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"Invalid input: matrix must be square\\") primary_diag_sum = 0 secondary_diag_sum = 0 for i in range(n): primary_diag_sum += matrix[i][i] secondary_diag_sum += matrix[i][n - 1 - i] if n % 2 == 1: mid = n // 2 overlap_element = matrix[mid][mid] return primary_diag_sum + secondary_diag_sum - overlap_element return primary_diag_sum + secondary_diag_sum"},{"question":"# Task: Design a Cache System Using a Least Recently Used (LRU) Cache Algorithm # Problem Statement You are required to implement a cache system utilizing the Least Recently Used (LRU) cache algorithm. The system should be able to efficiently store, retrieve, and evict cache entries based on their usage patterns. Requirements 1. **Cache Entry**: - Each cache entry consists of a key and a value. 2. **LRU Cache Operations**: - **Insert**: - Add a new entry to the cache. - If the cache is full, evict the least recently used entry before inserting the new one. - **Retrieve**: - Retrieve the value associated with a given key. - Update the usage of the key to mark it as recently used. - **Delete**: - Remove a given entry from the cache using its key. 3. **Edge Cases**: - Handle the insertion of new entries when the cache is full. - Handle retrievals of keys that do not exist in the cache. - Maintain performance during frequent insertions and retrievals. Implementation Details - Implement the `LRUCacheEntry` class for initializing cache entries. - Implement the `LRUCache` class with the following methods: - `insert(key: str, value: str) -> None`: Inserts a key-value pair into the cache. - `retrieve(key: str) -> str | None`: Retrieves the value associated with the key if it exists in the cache, otherwise returns `None`. - `delete(key: str) -> bool`: Deletes the entry associated with the key from the cache. Returns `True` if the entry was deleted, otherwise `False`. - Ensure that the cache maintains the LRU property using appropriate data structures (e.g., a combination of a dictionary and a doubly linked list). Constraints - The cache size is limited by a fixed capacity. - Keys and values are non-empty strings consisting of lowercase alphabets (\'a\' to \'z\'). - Ensure O(1) average time complexity for insertion, retrieval, and deletion. # Example Usage ```python cache = LRUCache(capacity=3) # Insert entries cache.insert(\\"apple\\", \\"A fruit\\") cache.insert(\\"banana\\", \\"Another fruit\\") cache.insert(\\"cherry\\", \\"A red fruit\\") # Retrieve entries assert cache.retrieve(\\"banana\\") == \\"Another fruit\\" assert cache.retrieve(\\"grape\\") is None # \\"grape\\" is not in the cache # Insert another entry, should evict \\"apple\\" (least recently used) cache.insert(\\"date\\", \\"A sweet fruit\\") assert cache.retrieve(\\"apple\\") is None # \\"apple\\" has been evicted # Delete an entry assert cache.delete(\\"banana\\") is True assert cache.retrieve(\\"banana\\") is None # \\"banana\\" has been deleted # Insert and verify eviction cache.insert(\\"fig\\", \\"A unique fruit\\") cache.insert(\\"grape\\", \\"Yet another fruit\\") assert cache.retrieve(\\"cherry\\") is None # \\"cherry\\" has been evicted due to LRU policy ``` Ensure that your implementation adheres to the given requirements and efficiently handles the cache operations maintaining the LRU property throughout. # Explanation This problem requires the understanding and implementation of the LRU Cache algorithm, designed for optimizing the retrieval of frequently accessed data while maintaining a fixed size. The task tests the ability to manage a cache system that supports constant-time operations for insertion, deletion, and retrieval, which is crucial for performance in large-scale applications.","solution":"class LRUCacheEntry: Cache Entry for LRU Cache containing a key and a value. def __init__(self, key: str, value: str): self.key = key self.value = value self.prev = None self.next = None class LRUCache: LRU Cache implementing the Least Recently Used (LRU) Cache Algorithm. def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = LRUCacheEntry(None, None) # Initialize dummy head self.tail = LRUCacheEntry(None, None) # Initialize dummy tail self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: LRUCacheEntry): Remove the node from the doubly linked list. prev = node.prev next = node.next prev.next = next next.prev = prev def _add(self, node: LRUCacheEntry): Add the node to the front (right after the head). node.next = self.head.next node.prev = self.head self.head.next.prev = node self.head.next = node def _move_to_head(self, node: LRUCacheEntry): Move the given node to the front (right after the head). self._remove(node) self._add(node) def _pop_tail(self): Pop the current tail (real element before the dummy tail). res = self.tail.prev self._remove(res) return res def insert(self, key: str, value: str) -> None: Insert a (key, value) pair into the cache. An existing key\'s value will be overwritten. If the cache is full, evict the LRU item. if key in self.cache: node = self.cache[key] node.value = value self._move_to_head(node) else: new_node = LRUCacheEntry(key, value) self.cache[key] = new_node self._add(new_node) if len(self.cache) > self.capacity: tail = self._pop_tail() del self.cache[tail.key] def retrieve(self, key: str) -> str | None: Retrieve the value associated with the key if it exists in the cache, otherwise return None. node = self.cache.get(key) if not node: return None self._move_to_head(node) return node.value def delete(self, key: str) -> bool: Delete the entry associated with the key from the cache. Returns True if the entry was deleted, otherwise False. node = self.cache.get(key) if not node: return False self._remove(node) del self.cache[key] return True"},{"question":"# Problem Statement Extend the functionality of the `Matrix` class by implementing a method that finds the trace (the sum of the diagonal elements) of the matrix. # Requirements 1. **Function to Implement**: `trace()` method inside the `Matrix` class. 2. **Input**: The `Matrix` object itself of size (n times n) where (n geq 2). 3. **Output**: Integer or Float representing the trace of the matrix. 4. **Performance**: Aim for (O(n)) time complexity. 5. **Constraints**: Ensure that the matrix is square; otherwise, raise an appropriate exception. # Example ```python a = Matrix(3, 3) a[0, 0], a[0, 1], a[0, 2] = 3, 1, 1 a[1, 0], a[1, 1], a[1, 2] = 4, 3, 2 a[2, 0], a[2, 1], a[2, 2] = 2, 7, 3 print(a.trace()) # Output: 9 ``` # Notes - The trace of a square matrix is the sum of its diagonal elements. - Ensure to handle cases where the matrix is not square by raising an appropriate exception. - This method should be efficient with a complexity of (O(n)), where (n) is the size of the matrix.","solution":"class Matrix: def __init__(self, rows, cols): if rows != cols: raise ValueError(\\"Matrix must be square\\") self.rows = rows self.cols = cols self.data = [[0] * cols for _ in range(rows)] def __getitem__(self, indices): row, col = indices return self.data[row][col] def __setitem__(self, indices, value): row, col = indices self.data[row][col] = value def trace(self): return sum(self.data[i][i] for i in range(self.rows)) # Example usage (not part of the solution, just for reference) a = Matrix(3, 3) a[0, 0], a[0, 1], a[0, 2] = 3, 1, 1 a[1, 0], a[1, 1], a[1, 2] = 4, 3, 2 a[2, 0], a[2, 1], a[2, 2] = 2, 7, 3 print(a.trace()) # Output: 9"},{"question":"# Scenario You are developing a file system management tool where users can perform various operations on files and directories. One function that users often request is the ability to find the largest file within a directory and its subdirectories. # Task Write a function `find_largest_file` that takes the root directory path as input and returns the path to the largest file within the directory and its subdirectories. # Function Signature ```python def find_largest_file(root_directory: str) -> str: ``` # Input - `root_directory` (str): The path to the root directory from where the search for the largest file will begin. # Output - Returns the path to the largest file as a string. If there are multiple files with the same maximum size, return any one of them. # Constraints - Assume you have read permissions for all the directories and files within the `root_directory`. - The function should handle directories that may contain any number of files and subdirectories. - Ignore files that you do not have permission to read or cannot be accessed for any reason, but make sure to note any error handling if necessary. # Examples ```python # Example 1 print(find_largest_file(\'/home/user/documents\')) # Output: \'/home/user/documents/reports/annual_report.pdf\' # Example 2 print(find_largest_file(\'/var/log\')) # Output: \'/var/log/syslog.1\' # Example 3 print(find_largest_file(\'/usr/bin\')) # Output: \'/usr/bin/gcc\' ``` # Notes - Focus on handling large directories efficiently to avoid memory issues. - Utilize appropriate libraries to walk through directories and get file sizes. - Ensure the solution is robust and handles various edge cases, such as empty directories, directories with unreadable files, and symbolic links.","solution":"import os def find_largest_file(root_directory: str) -> str: Function to find the largest file within a directory and its subdirectories. :param root_directory: The path to the root directory where the search will start. :return: The path to the largest file. largest_file = \'\' largest_size = -1 for dirpath, dirnames, filenames in os.walk(root_directory): for filename in filenames: file_path = os.path.join(dirpath, filename) try: current_size = os.path.getsize(file_path) if current_size > largest_size: largest_size = current_size largest_file = file_path except (OSError, FileNotFoundError): # Ignore unreadable files continue return largest_file"},{"question":"# Scenario You are developing a tool to compress large text files for efficient storage and transmission. Implementing an algorithm to encode text using Huffman coding is crucial for achieving high compression ratios. # Problem Statement **Task**: Implement the Huffman Coding algorithm to generate the Huffman codes for each character in a given text string. # Input & Output **Function Name**: `huffman_coding` **Input**: - `text`: A string, representing the input text for which we need to generate Huffman codes. **Output**: - `codes`: A dictionary where keys are characters from the input text and values are the corresponding Huffman codes as strings. # Example ```python text = \\"this is an example for huffman encoding\\" codes = huffman_coding(text) print(codes) # Output could be: {\' \': \'00\', \'a\': \'010\', \'c\': \'0110\', \'d\': \'0111\', \'e\': \'100\', \'f\': \'101\', \'g\': \'1100\', \'h\': \'1101\', \'i\': \'1110\', \'l\': \'11110\', \'m\': \'11111\', \'n\': \'1000\', \'o\': \'1001\', \'p\': \'1100\', \'r\': \'1011\', \'s\': \'1110\', \'t\': \'0000\', \'u\': \'01110\', \'x\': \'01000\'} ``` # Constraints - The function should handle both uppercase and lowercase letters as different characters. - Non-alphabet characters (spaces, punctuation) should also be included in the Huffman coding. # Performance Requirements - The solution should have a time complexity of O(n log n) where n is the number of unique characters in the input text. - The space complexity should be O(n). # Implementation Guidance 1. Count the frequency of each character in the text. 2. Build a priority queue (min-heap) of nodes where each node represents a character and its frequency. 3. While the priority queue has more than one node: - Extract the two nodes with the lowest frequency. - Create a new internal node with these two nodes as children and the sum of their frequencies as the new frequency. - Insert the new node back into the priority queue. 4. The remaining node is the root of the Huffman tree. Traverse the tree to generate the codes. ```python from heapq import heappush, heappop, heapify from collections import defaultdict, Counter class Node: def __init__(self, char=None, freq=0): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def huffman_coding(text: str) -> dict: if not text: return {} frequency = Counter(text) heap = [Node(char, freq) for char, freq in frequency.items()] heapify(heap) while len(heap) > 1: node1 = heappop(heap) node2 = heappop(heap) merged = Node(freq=node1.freq + node2.freq) merged.left = node1 merged.right = node2 heappush(heap, merged) root = heap[0] huffman_codes = {} def generate_codes(node, code=\\"\\"): if node is not None: if node.char is not None: huffman_codes[node.char] = code generate_codes(node.left, code + \\"0\\") generate_codes(node.right, code + \\"1\\") generate_codes(root) return huffman_codes # Example usage text = \\"this is an example for huffman encoding\\" codes = huffman_coding(text) print(codes) ``` This question aligns with the structure and complexity of the given sample question by requiring implementation of a fundamental algorithm and providing a clear and concise problem statement. The task involves understanding and applying the Huffman coding algorithm, ensuring it is suitable for a coding assessment scenario.","solution":"from heapq import heappush, heappop, heapify from collections import Counter class Node: def __init__(self, char=None, freq=0): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def huffman_coding(text: str) -> dict: if not text: return {} # Count the frequency of each character in the text frequency = Counter(text) # Create a heap (priority queue) of nodes heap = [Node(char, freq) for char, freq in frequency.items()] heapify(heap) # Combine nodes until there\'s only one node left (the root of the Huffman tree) while len(heap) > 1: node1 = heappop(heap) node2 = heappop(heap) merged = Node(freq=node1.freq + node2.freq) merged.left = node1 merged.right = node2 heappush(heap, merged) # The remaining node is the root of the Huffman tree root = heap[0] huffman_codes = {} def generate_codes(node, code=\\"\\"): if node is not None: if node.char is not None: huffman_codes[node.char] = code generate_codes(node.left, code + \\"0\\") generate_codes(node.right, code + \\"1\\") generate_codes(root) return huffman_codes"},{"question":"# Problem Statement You are developing a social network analysis tool and need to implement a function to identify key influencers within a network. The network is represented as a graph where nodes are individuals and edges denote connections between them. You want to find the k most connected individuals, or nodes with the highest degree. # Requirements Your task is to implement a function `top_influencers` that takes an adjacency list representation of a graph and an integer k, and returns a list of the k most connected individuals in descending order of their connections. # Function Signature ```python def top_influencers(graph: dict, k: int) -> list: pass ``` # Input * `graph` (dict): A dictionary where each key is a node (individual) and the value is a list of nodes (individuals) connected to that node. * `k` (int): An integer representing the number of top influencers to return. The value of k is non-negative. # Output * A list of k nodes (individuals) sorted in descending order of their degree (number of connections). If two nodes have the same degree, they should be returned in alphabetical order. # Constraints * If k is zero, the function should return an empty list. * If k is greater than the number of nodes in the graph, return all nodes sorted by their degree. * The function should handle edge cases, including an empty graph. # Examples ```python graph = { \\"Alice\\": [\\"Bob\\", \\"Charlie\\", \\"David\\"], \\"Bob\\": [\\"Alice\\", \\"Charlie\\"], \\"Charlie\\": [\\"Alice\\", \\"Bob\\"], \\"David\\": [\\"Alice\\"], \\"Eve\\": [], } k = 2 print(top_influencers(graph, k)) # Output: [\'Alice\', \'Bob\'] graph = { \\"Alice\\": [\\"Bob\\"], \\"Bob\\": [\\"Alice\\"], } k = 3 print(top_influencers(graph, k)) # Output: [\'Alice\', \'Bob\'] graph = {} k = 1 print(top_influencers(graph, k)) # Output: [] ``` # Explanation In the first example, the function returns \'Alice\' and \'Bob\' as they have the highest degrees (3 and 2 connections respectively). \'Charlie\' has the same number of connections as \'Bob\', but \'Bob\' appears first alphabetically. In the second example, the graph only has two nodes, so both are returned even though k is 3. In the third example, the graph is empty, so the function returns an empty list regardless of the value of k. Good luck with your implementation!","solution":"def top_influencers(graph: dict, k: int) -> list: Returns a list of the k most connected individuals in descending order of their connections. Parameters: graph (dict): Adjacency list representation of the graph. k (int): Number of top influencers to return. Returns: list: List of k most connected individuals. # Handle edge case where the graph is empty or k is zero if not graph or k == 0: return [] # Calculate the degree of each node degrees = {node: len(neighbors) for node, neighbors in graph.items()} # Sort nodes by degree (descending) and then alphabetically sorted_nodes = sorted(degrees.keys(), key=lambda node: (-degrees[node], node)) # Return the top k nodes return sorted_nodes[:k]"},{"question":"# Problem: Implementing an Efficient Matrix Transpose Context You are developing a utility for processing large matrices in a data analysis application. One common operation is transposing a matrix, which involves flipping it over its diagonal so that the row and column indices of each element are swapped. This operation must be optimized for performance due to the large size of the matrices handled. Task 1. **Implement the matrix transpose function** as specified. 2. **Optimize the function** to handle large matrices efficiently. Details 1. **Functionality**: - Implement a function `transpose_matrix` that will transpose a given matrix. 2. **Input and Output Formats**: - `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]`: Returns the transpose of the input matrix `matrix`. 3. **Constraints and Requirements**: - The input `matrix` will be a list of lists where each sublist represents a row in the matrix. - The function should handle non-square matrices as well. - Ensure that the transposition operation is optimized for performance, especially for large matrices. - Handle edge cases such as an empty matrix. 4. **Example Usage**: - Given the matrix `[[1, 2, 3], [4, 5, 6]]`, the function should return `[[1, 4], [2, 5], [3, 6]]`. - Given the matrix `[[1, 2], [3, 4], [5, 6]]`, the function should return `[[1, 3, 5], [2, 4, 6]]`. Implementation ```python def transpose_matrix(matrix): Transposes the given matrix. if not matrix: return [] rows, cols = len(matrix), len(matrix[0]) transposed = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): transposed[c][r] = matrix[r][c] return transposed # Example to test print(transpose_matrix([[1, 2, 3], [4, 5, 6]])) # Expected: [[1, 4], [2, 5], [3, 6]] print(transpose_matrix([[1, 2], [3, 4], [5, 6]])) # Expected: [[1, 3, 5], [2, 4, 6]] print(transpose_matrix([[]])) # Expected: [[]] ``` Write your implementation and ensure it passes all test cases provided. Ensure performance measures are considered for large-scale matrix transpositions. --- The new question focuses on matrix manipulation, which complements the hash function question by dealing with a different domain while maintaining a similar complexity level. This ensures a well-rounded assessment of the candidate\'s programming skills across different types of problems.","solution":"def transpose_matrix(matrix): Transposes the given matrix. if not matrix: return [] rows, cols = len(matrix), len(matrix[0]) transposed = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): transposed[c][r] = matrix[r][c] return transposed"},{"question":"# Coding Question: Implement a Circular Queue with Dynamic Resizing Context A circular queue (also known as a ring buffer) is an advanced queue data structure that uses a fixed-size buffer. When the buffer is full, new data wraps around to the beginning if there is space, providing efficient memory usage and queue operations. Dynamic resizing allows the queue to grow or shrink based on usage, combining flexibility with efficiency. Task **Implement a Circular Queue class with dynamic resizing. Your implementation should efficiently handle enqueue and dequeue operations while resizing the buffer as needed.** Requirements 1. Implement a `CircularQueue` class with the following methods: * `__init__(self, initial_capacity: int)`: Initializes the circular queue with the given initial capacity. * `enqueue(self, value: int) -> None`: Adds an element to the end of the queue, resizing if necessary. * `dequeue(self) -> int`: Removes and returns an element from the front of the queue. Raises an exception if the queue is empty. * `is_empty(self) -> bool`: Returns `True` if the queue is empty, `False` otherwise. * `is_full(self) -> bool`: Returns `True` if the queue is full, `False` otherwise. * `size(self) -> int`: Returns the current number of elements in the queue. Constraints * The initial capacity of the queue will be a positive integer. * The elements in the queue are integers. # Example ```python >>> cq = CircularQueue(3) >>> cq.enqueue(1) >>> cq.enqueue(2) >>> cq.enqueue(3) >>> cq.is_full() True >>> cq.dequeue() 1 >>> cq.enqueue(4) >>> cq.is_full() True >>> cq.dequeue() 2 >>> cq.dequeue() 3 >>> cq.size() 1 >>> cq.dequeue() 4 >>> cq.is_empty() True ``` # Implementation Notes 1. Implement circular indexing to efficiently use the buffer space. 2. Resize the queue when it becomes full or when a significant portion of it is empty after dequeuing. 3. Handle edge cases like trying to dequeue from an empty queue. ```python class CircularQueue: def __init__(self, initial_capacity: int): self.queue = [None] * initial_capacity self.capacity = initial_capacity self.front = 0 self.rear = 0 self.current_size = 0 def enqueue(self, value: int) -> None: if self.is_full(): self._resize(2 * self.capacity) self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.current_size += 1 def dequeue(self) -> int: if self.is_empty(): raise ValueError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.current_size -= 1 if 0 < self.capacity // 4 > self.current_size: self._resize(self.capacity // 2) return value def is_empty(self) -> bool: return self.current_size == 0 def is_full(self) -> bool: return self.current_size == self.capacity def size(self) -> int: return self.current_size def _resize(self, new_capacity: int) -> None: new_queue = [None] * new_capacity for i in range(self.current_size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.capacity = new_capacity self.front = 0 self.rear = self.current_size # Test cases if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"class CircularQueue: def __init__(self, initial_capacity: int): self.queue = [None] * initial_capacity self.capacity = initial_capacity self.front = 0 self.rear = 0 self.current_size = 0 def enqueue(self, value: int) -> None: if self.is_full(): self._resize(2 * self.capacity) self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.current_size += 1 def dequeue(self) -> int: if self.is_empty(): raise ValueError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.current_size -= 1 if 0 < self.capacity // 4 > self.current_size: self._resize(self.capacity // 2) return value def is_empty(self) -> bool: return self.current_size == 0 def is_full(self) -> bool: return self.current_size == self.capacity def size(self) -> int: return self.current_size def _resize(self, new_capacity: int) -> None: new_queue = [None] * new_capacity for i in range(self.current_size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.capacity = new_capacity self.front = 0 self.rear = self.current_size"},{"question":"# Scenario As part of a project to manage user access control in a system, you need to implement a feature that checks if a user has the necessary permissions to perform a certain operation. The permissions are represented as a set of strings and you need to ensure efficient checking of these strings within the set. # Task Write a function that determines whether all required permissions are present for a given user. The function should take two sets: one containing the user\'s permissions and the other containing the required permissions for the operation. It should return `True` if the user has all the required permissions, and `False` otherwise. # Function Signature ```python def has_permissions(user_permissions: set, required_permissions: set) -> bool: Check if the user has all required permissions. :param user_permissions: A set of permissions that the user has. :param required_permissions: A set of permissions required for the operation. :return: True if the user has all required permissions, False otherwise. :raises TypeError: If user_permissions or required_permissions are not sets. ``` # Input * `user_permissions`: a set of strings representing permissions the user has. * `required_permissions`: a set of strings representing permissions required for the operation. # Output Returns `True` if the user has all required permissions, `False` otherwise. # Constraints * `user_permissions` and `required_permissions` should both be sets of strings. * If the inputs are not sets, the function should raise a `TypeError`. # Example ```python >>> has_permissions({\\"read\\", \\"write\\", \\"delete\\"}, {\\"read\\", \\"write\\"}) True >>> has_permissions({\\"read\\", \\"write\\"}, {\\"read\\", \\"write\\", \\"delete\\"}) False >>> has_permissions({\\"read\\", \\"write\\"}, set()) True >>> has_permissions(set(), {\\"read\\"}) False >>> has_permissions(123, {\\"read\\"}) Traceback (most recent call last): ... TypeError: user_permissions and required_permissions must be sets of strings >>> has_permissions({\\"read\\"}, {\\"read\\", 1}) Traceback (most recent call last): ... TypeError: user_permissions and required_permissions must be sets of strings ``` # Notes * The time complexity should be O(n), where n is the size of the `required_permissions` set. * Proper validation should be performed to ensure the input constraints are met.","solution":"def has_permissions(user_permissions: set, required_permissions: set) -> bool: Check if the user has all required permissions. :param user_permissions: A set of permissions that the user has. :param required_permissions: A set of permissions required for the operation. :return: True if the user has all required permissions, False otherwise. :raises TypeError: If user_permissions or required_permissions are not sets of strings. if not isinstance(user_permissions, set) or not isinstance(required_permissions, set): raise TypeError(\\"user_permissions and required_permissions must be sets\\") if not all(isinstance(perm, str) for perm in user_permissions): raise TypeError(\\"user_permissions must be a set of strings\\") if not all(isinstance(perm, str) for perm in required_permissions): raise TypeError(\\"required_permissions must be a set of strings\\") return required_permissions.issubset(user_permissions)"},{"question":"**Context**: You are developing a simple inventory management system for a small retail store. The system maintains a list of items, each with a unique identifier, a name, and a quantity in stock. To ensure efficient management, the system must support adding new items, updating existing item quantities, and checking if an item is out of stock. **Task**: Implement an `InventoryManager` class to manage the inventory. Your implementation should include methods to `add_item`, `update_quantity`, and `is_out_of_stock`. # Function Signature ```python class InventoryManager: def __init__(self): pass def add_item(self, item_id: int, name: str, quantity: int) -> bool: pass def update_quantity(self, item_id: int, quantity: int) -> bool: pass def is_out_of_stock(self, item_id: int) -> bool: pass ``` # Requirements 1. **Constructor**: Initialize the inventory manager. 2. **Add Item Function**: Add a new item with the given `item_id`, `name`, and `quantity`. Return `True` if the item is successfully added, `False` if an item with the same `item_id` already exists. 3. **Update Quantity Function**: Update the quantity of the specified item by adding the given `quantity`. Return `True` if the update is successful, `False` if the item does not exist. 4. **Is Out Of Stock Function**: Return `True` if the specified item is out of stock (quantity is 0), `False` otherwise. # Constraints - Items will have unique `item_id` values. - `item_id` is a positive integer within the range `1 to 10^6`. - `name` is a non-empty string. - `quantity` is a non-negative integer. # Example ```python # Create an instance of InventoryManager inventory = InventoryManager() # Add new items assert inventory.add_item(1, \\"Apple\\", 50) is True assert inventory.add_item(2, \\"Banana\\", 100) is True assert inventory.add_item(1, \\"Orange\\", 30) is False # Duplicate item_id # Update item quantities assert inventory.update_quantity(1, 20) is True # Apple quantity now 70 assert inventory.update_quantity(3, 10) is False # Non-existent item_id # Check if items are out of stock assert inventory.is_out_of_stock(1) is False # Apple is in stock assert inventory.is_out_of_stock(2) is False # Banana is in stock assert inventory.update_quantity(2, -100) is True # Decrease Banana quantity to 0 assert inventory.is_out_of_stock(2) is True # Banana is out of stock ``` **Note**: Ensure your implementation correctly handles edge cases such as adding duplicate items and correctly updates quantities, including decreasing to zero.","solution":"class InventoryManager: def __init__(self): self.inventory = {} def add_item(self, item_id: int, name: str, quantity: int) -> bool: if item_id in self.inventory: return False self.inventory[item_id] = {\'name\': name, \'quantity\': quantity} return True def update_quantity(self, item_id: int, quantity: int) -> bool: if item_id not in self.inventory: return False self.inventory[item_id][\'quantity\'] += quantity return True def is_out_of_stock(self, item_id: int) -> bool: if item_id not in self.inventory: return False return self.inventory[item_id][\'quantity\'] == 0"},{"question":"# Coding Assessment Question Network Packet Routing Simulation with Dijkstra\'s Algorithm As a network engineer, you are tasked with designing a tool to simulate packet routing in a network. The goal is to find the shortest path for a packet to travel from a given source node to a destination node using Dijkstra\'s algorithm. # Problem Statement Implement a function `dijkstra_shortest_path` in Python to determine the shortest path between two nodes in a network represented by a graph. The graph will be defined by an adjacency list in the form specified below. # Input Your function will read from a file with the following format: ``` source_node destination_node weight source_node another_node weight ... ``` For example: ``` A B 5 A C 10 B C 2 B D 4 C D 1 D E 7 E A 9 ``` # Function Signature ```python def dijkstra_shortest_path(file_path: str, start: str, end: str) -> Tuple[List[str], int]: pass ``` # Parameters - `file_path`: Path to the file containing the adjacency list of the graph. - `start`: The starting node for the packet. - `end`: The destination node for the packet. # Output * Returns a tuple: 1. A list representing the nodes in the shortest path from the starting node to the destination node. 2. An integer representing the total weight of the shortest path. # Constraints * All nodes are uniquely identifiable strings (i.e., no duplicates). * Weights are positive integers. * The maximum number of nodes is 100. # Performance Requirements * The solution should handle input files with up to 100 nodes efficiently. * Optimize the algorithm to run within a reasonable time frame for the full input size. # Example For the input file with the following adjacency list: ``` A B 5 A C 10 B C 2 B D 4 C D 1 D E 7 E A 9 ``` And the function call `dijkstra_shortest_path(\'network.txt\', \'A\', \'D\')`, a possible output could be: ```python ([\'A\', \'B\', \'C\', \'D\'], 8) ``` This indicates the shortest path found and the corresponding total weight. # Additional Instructions * Ensure your implementation handles file reading errors gracefully. * Document your code with comments explaining the key parts. * You are encouraged to write helper functions to break down different parts of the algorithm (e.g., updating distances, extracting the minimum distance node). *Note:* If there is no path between the start node and the end node, your function should return an empty list and a weight of -1.","solution":"import heapq from typing import List, Tuple, Dict import sys def dijkstra_shortest_path(file_path: str, start: str, end: str) -> Tuple[List[str], int]: graph = build_graph(file_path) # If start or end node does not exist in the graph if start not in graph or end not in graph: return ([], -1) # Distance to the node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # To store the best path taken to reach the node previous_nodes = {node: None for node in graph} # Priority queue to choose the node with the smallest distance priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reach the target node, no need to process further if current_node == end: break # For adjacent nodes of the current node for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider the better path if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) path, total_weight = reconstruct_path(previous_nodes, start, end, distances[end]) return path, total_weight def build_graph(file_path: str) -> Dict[str, Dict[str, int]]: graph = {} with open(file_path) as file: for line in file: if line.strip(): source, dest, weight = line.strip().split() weight = int(weight) if source not in graph: graph[source] = {} if dest not in graph: graph[dest] = {} graph[source][dest] = weight return graph def reconstruct_path(previous_nodes: Dict[str, str], start: str, end: str, total_weight: int) -> Tuple[List[str], int]: if total_weight == float(\'inf\'): return ([], -1) path = [] current_node = end while current_node is not None: path.append(current_node) current_node = previous_nodes[current_node] path.reverse() return path, total_weight"},{"question":"Implement a Simple Data Queue with Circular Buffer You are required to implement a data queue using a circular buffer. A circular buffer is a data structure that uses a fixed-size buffer considered as if it were connected end-to-end. This structure is efficient and useful for buffering data streams. Your task is to create a `CircularQueue` class that supports the following operations: - `enqueue`: Adds an element to the end of the queue. - `dequeue`: Removes an element from the front of the queue. - `is_full`: Checks if the queue is full. - `is_empty`: Checks if the queue is empty. - `size`: Returns the number of elements currently in the queue. Function Signature ```python class CircularQueue: def __init__(self, capacity: int) -> None: pass def enqueue(self, value: int) -> bool: pass def dequeue(self) -> int: pass def is_full(self) -> bool: pass def is_empty(self) -> bool: pass def size(self) -> int: pass ``` Requirements 1. **Initialization**: - The constructor should initialize the queue with a given `capacity` and appropriate pointers for the front and rear of the queue. 2. **Enqueue Operation**: - Add an element to the queue if it is not full. Return `True` if the operation is successful, and `False` if the queue is full. 3. **Dequeue Operation**: - Remove and return the front element of the queue if it is not empty. Return `-1` if the queue is empty. 4. **Full and Empty Checks**: - `is_full`: Return `True` if the queue is full, `False` otherwise. - `is_empty`: Return `True` if the queue is empty, `False` otherwise. 5. **Size Calculation**: - `size`: Return the number of elements currently in the queue. Example ```python # Sample operations on the CircularQueue queue = CircularQueue(5) print(queue.enqueue(10)) # Output: True print(queue.enqueue(20)) # Output: True print(queue.enqueue(30)) # Output: True print(queue.enqueue(40)) # Output: True print(queue.enqueue(50)) # Output: False (Queue is full) print(queue.size()) # Output: 4 print(queue.is_full()) # Output: True print(queue.is_empty()) # Output: False print(queue.dequeue()) # Output: 10 print(queue.size()) # Output: 3 print(queue.enqueue(60)) # Output: True print(queue.is_full()) # Output: True print(queue.dequeue()) # Output: 20 print(queue.dequeue()) # Output: 30 print(queue.dequeue()) # Output: 40 print(queue.dequeue()) # Output: -1 (Queue is empty) print(queue.is_empty()) # Output: True ``` Your implementation should handle edge cases, such as attempting to enqueue when the queue is full or dequeue when the queue is empty. Test the functionality thoroughly using an appropriate set of operations as demonstrated in the example.","solution":"class CircularQueue: def __init__(self, capacity: int) -> None: self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, value: int) -> bool: if self.is_full(): return False self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.count += 1 return True def dequeue(self) -> int: if self.is_empty(): return -1 value = self.queue[self.front] self.queue[self.front] = None # Optional: Clear the slot for clarity self.front = (self.front + 1) % self.capacity self.count -= 1 return value def is_full(self) -> bool: return self.count == self.capacity def is_empty(self) -> bool: return self.count == 0 def size(self) -> int: return self.count"},{"question":"**[Question 2]: String Parsing and Analysis** You are tasked with developing a system to parse and analyze customer reviews from an e-commerce platform. This system should extract and normalize critical information, detect sentiment, and summarize review contents. **Objective:** Implement the functions required to perform the parsing, normalization, sentiment detection, and summarization of the reviews. **Requirements:** 1. **Parse and Normalize**: - Implement a function `parse_reviews` to extract the review text, rating, and reviewer\'s username from a given list of raw review strings. - Normalize the extracted text by converting it to lowercase and removing punctuation. 2. **Sentiment Detection**: - Implement a function `detect_sentiment` to classify the sentiment of a review as \'positive\', \'negative\', or \'neutral\' based on the review text and rating. - Use a simple heuristic: reviews with ratings ≥ 4 are \'positive\', ratings ≤ 2 are \'negative\', and ratings 3 are \'neutral\'. 3. **Review Summarization**: - Implement a function `summarize_reviews` that aggregates reviews by creating a summary of the positive, negative, and neutral reviews. **Function Signatures**: ```python import re from typing import List, Dict, Tuple def parse_reviews(raw_reviews: List[str]) -> List[Dict[str, str]]: # Extract and normalize review data pass def detect_sentiment(review_text: str, rating: int) -> str: # Detect sentiment based on review text and rating pass def summarize_reviews(reviews: List[Dict[str, str]]) -> Dict[str, List[str]]: # Summarize the reviews into positive, negative, and neutral categories pass ``` **Input and Output**: Input: 1. A list of raw review strings, where each string contains the review text, rating, and reviewer\'s username. 2. Example raw review: `\\"Great product! Totally worth the money. 5 - JohnDoe\\"` Output: 1. A list of dictionaries containing normalized review text, rating, and username. 2. Sentiment classification for each review. 3. Aggregated summaries of positive, negative, and neutral reviews. **Example**: ```python raw_reviews = [ \\"Great product! Totally worth the money. 5 - JohnDoe\\", \\"Not what I expected, quite disappointing. 2 - JaneSmith\\", \\"It\'s okay, does the job. 3 - AlexBrown\\" ] parsed_reviews = parse_reviews(raw_reviews) for review in parsed_reviews: review[\'sentiment\'] = detect_sentiment(review[\'text\'], int(review[\'rating\'])) summary = summarize_reviews(parsed_reviews) ``` Output: ```python parsed_reviews = [ {\\"text\\": \\"great product totally worth the money\\", \\"rating\\": \\"5\\", \\"username\\": \\"johndoe\\"}, {\\"text\\": \\"not what i expected quite disappointing\\", \\"rating\\": \\"2\\", \\"username\\": \\"janesmith\\"}, {\\"text\\": \\"its okay does the job\\", \\"rating\\": \\"3\\", \\"username\\": \\"alexbrown\\"} ] summary = { \\"positive\\": [\\"Great product! Totally worth the money. 5 - JohnDoe\\"], \\"negative\\": [\\"Not what I expected, quite disappointing. 2 - JaneSmith\\"], \\"neutral\\": [\\"It\'s okay, does the job. 3 - AlexBrown\\"] } ```","solution":"import re from typing import List, Dict, Tuple def parse_reviews(raw_reviews: List[str]) -> List[Dict[str, str]]: parsed_reviews = [] for raw_review in raw_reviews: # Split the review by \'-\' to separate the main body from the username review_parts = raw_review.rsplit(\\" - \\", 1) body_and_rating, username = review_parts username = username.strip().lower() # Extract rating and review text match = re.match(r\\"(.+)s(d+)\\", body_and_rating) if match: review_text = match.group(1).strip().lower() rating = match.group(2) # Normalize the review text by removing punctuation review_text = re.sub(r\'[^ws]\', \'\', review_text) parsed_reviews.append({ \\"text\\": review_text, \\"rating\\": rating, \\"username\\": username }) return parsed_reviews def detect_sentiment(review_text: str, rating: int) -> str: if rating >= 4: return \'positive\' elif rating <= 2: return \'negative\' else: return \'neutral\' def summarize_reviews(reviews: List[Dict[str, str]]) -> Dict[str, List[str]]: summary = {\\"positive\\": [], \\"negative\\": [], \\"neutral\\": []} for review in reviews: sentiment = detect_sentiment(review[\'text\'], int(review[\'rating\'])) summary[sentiment].append(review[\'text\']) return summary"},{"question":"# Coding Assessment Question In database management systems, Join operations are fundamental for querying and combining data across multiple tables. You are to create a function that performs an inner join on two tables represented as lists of dictionaries based on a common key. Write a function `inner_join` that performs an inner join on two tables based on a specified key. **Function Signature**: ```python def inner_join(table1, table2, key): pass ``` # Input and Output - **Input**: - `table1` - A list of dictionaries, where each dictionary represents a row in the first table. - `table2` - A list of dictionaries, where each dictionary represents a row in the second table. - `key` - A string representing the common key to join on. - **Output**: - Returns a list of dictionaries representing the joined table. # Constraints - Both tables are guaranteed to have the key present in every dictionary. - If there are no matching keys, the result should be an empty list. # Example ```python table1 = [ {\\"id\\": 1, \\"name\\": \\"Alice\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\"}, {\\"id\\": 3, \\"name\\": \\"Charlie\\"} ] table2 = [ {\\"id\\": 1, \\"age\\": 25}, {\\"id\\": 2, \\"age\\": 30}, {\\"id\\": 4, \\"age\\": 35} ] out = inner_join(table1, table2, key=\\"id\\") print(out) # Expected Output : # [ # {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 25}, # {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 30} # ] ``` # Requirements - Ensure that the function handles large tables efficiently. - The resulting list should not contain duplicate rows. - Rows from `table1` and `table2` should retain all their original fields in the joined table. # Hints - Consider using hash maps for efficient key lookups. - Think about how to handle edge cases like empty tables or no common keys. Formulate the `inner_join` function such that it reliably produces combined records based on the specified key, reflecting an understanding of relational database joins and hashing for performance.","solution":"def inner_join(table1, table2, key): Performs an inner join on two tables based on the specified key. # Create a hashmap for table2 with key as the join key and value as the row hashMap = {row[key]: row for row in table2} # Iterate through table1 and join with table2 using the hashmap joined_table = [] for row in table1: if row[key] in hashMap: # Merge the dictionaries merged_row = {**row, **hashMap[row[key]]} joined_table.append(merged_row) return joined_table"},{"question":"# Circular Array Rotation You are given an array of integers and a number of rotations, `k`. Each rotation shifts every element of the array one place to the right, and the last element is moved to the first position. Implement a function `rotate_array(arr: List[int], k: int) -> List[int]` that returns the array after `k` rotations. # Input: - `arr` (List[int]): The input array of integers. (1 <= len(arr) <= 10^5) - `k` (int): The number of rotations to be performed. (0 <= k <= 10^5) # Output: - (List[int]): The array after `k` rotations. # Example: ```python # Example Case # Input: arr = [1, 2, 3, 4, 5], k = 2 # Output: [4, 5, 1, 2, 3] # Example Case # Input: arr = [0, 1, 2, 3], k = 4 # Output: [0, 1, 2, 3] ``` # Explanation: In the first example, after 1 rotation, the array becomes [5, 1, 2, 3, 4]. After the second rotation, the array becomes [4, 5, 1, 2, 3]. In the second example, four rotations lead the array back to its original state. # Constraints: - The array\'s length is at least 1 and at most 100,000. - The number of rotations `k` is non-negative and can be very large (up to 100,000). # Performance Requirement: Ensure your algorithm runs efficiently for the maximum input sizes. # Hints: 1. Note that rotating the array by its length results in the same array. 2. Use modulo operation to avoid unnecessary rotations. Write your function implementation below: ```python from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: n = len(arr) k = k % n # Avoid unnecessary full rotations if k == 0: return arr return arr[-k:] + arr[:-k] # Testing the function print(rotate_array([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(rotate_array([0, 1, 2, 3], 4)) # Output: [0, 1, 2, 3] ```","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array \'arr\' to the right by \'k\' steps. n = len(arr) k = k % n # Avoid unnecessary full rotations if k == 0: return arr return arr[-k:] + arr[:-k]"},{"question":"**Problem Statement**: You are required to create a function that takes an integer array and returns the first non-repeating element in it. Additionally, you should implement a function that finds all non-repeating elements and returns them as a list. **Function Specifications**: 1. **first_non_repeating**: - **Input**: `arr: List[int]` - An array of integers. - **Output**: `int` - The first non-repeating element in the array. 2. **all_non_repeating**: - **Input**: `arr: List[int]` - An array of integers. - **Output**: `List[int]` - A list of all non-repeating elements in the array. When calling `first_non_repeating`, the function should return the first element that does not have duplicates in the array. If all elements are repeated, it should return `None`. When calling `all_non_repeating`, the function should return a list of all elements that do not have duplicates. The order of elements in the list should be the same as their first appearance in the array. **Details**: Use an efficient algorithm to handle large arrays. Avoid nested loops where possible to maintain performance. **Constraints**: - The length of the array will be up to `10^5`. - The elements in the array will be integers in the range `-10^6` to `10^6`. # Implementation You need to implement the following functions: ```python def first_non_repeating(arr: List[int]) -> int: # Implement to find the first non-repeating element pass def all_non_repeating(arr: List[int]) -> List[int]: # Implement to find all non-repeating elements pass ``` **Example**: ```python # Example usage: print(first_non_repeating([4, 5, 1, 2, 0, 4])) # Expected Output: 5 print(all_non_repeating([4, 5, 1, 2, 0, 4])) # Expected Output: [5, 1, 2, 0] ``` **Explanation**: ``` In the array [4, 5, 1, 2, 0, 4]: - 5 is the first non-repeating element. - All non-repeating elements are [5, 1, 2, 0]. ```","solution":"from typing import List, Optional from collections import Counter def first_non_repeating(arr: List[int]) -> Optional[int]: Returns the first non-repeating element in the array. If all elements are repeating, return None. count = Counter(arr) for num in arr: if count[num] == 1: return num return None def all_non_repeating(arr: List[int]) -> List[int]: Returns a list of all non-repeating elements in the array. count = Counter(arr) return [num for num in arr if count[num] == 1]"},{"question":"# Coding Challenge: Detect Cycles in a Directed Graph In many applications, it\'s crucial to determine whether a directed graph contains a cycle. You are tasked with implementing a function to detect the presence of cycles in a directed graph. **Your Task**: - Write a function `has_cycle(graph: Dict[int, List[int]]) -> bool` that checks if the given directed graph contains any cycles. - The graph will be provided as an adjacency list, where each key is a node and the corresponding value is a list of nodes that it points to. **Input**: - `graph` (Dict[int, List[int]]): A dictionary representing the directed graph. Each key is a node, and its value is a list of nodes it connects to directly. **Output**: - A boolean value `True` if the graph contains a cycle, and `False` otherwise. **Constraints**: - The graph does not contain duplicate edges. - The graph may have disconnected components. - The graph may contain nodes with no outgoing edges (these nodes will simply have an empty list as their value). ```python def has_cycle(graph: dict) -> bool: Detect if the given directed graph contains a cycle. Parameters: - graph (dict): A dictionary representing the directed graph, where each key is a node and the value is a list of nodes it points to. Returns: - bool: True if the graph contains a cycle, False otherwise. def dfs(node, visited, rec_stack): # Mark the current node as visited and add it to the recursion stack visited.add(node) rec_stack.add(node) # Recur for all the vertices adjacent to this vertex for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True # Remove the vertex from the recursion stack rec_stack.remove(node) return False visited = set() rec_stack = set() # Call the recursive helper function to detect cycle in different DFS trees for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False ``` **Example Scenarios**: 1. Given the graph: ```python graph = { 0: [1], 1: [2], 2: [0], 3: [4], 4: [] } ``` - Calling `has_cycle(graph)` should output `True` because there is a cycle involving nodes 0, 1, and 2. 2. Given the graph: ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } ``` - Calling `has_cycle(graph)` should output `False` because there are no cycles in this graph. **Edge cases**: - The graph is empty, e.g., `graph = {}`. - The graph consists of a single node with no edges, e.g., `graph = {0: []}`. - The graph has multiple disconnected components, some with cycles, and some without.","solution":"def has_cycle(graph: dict) -> bool: Detect if the given directed graph contains a cycle. Parameters: - graph (dict): A dictionary representing the directed graph, where each key is a node and the value is a list of nodes it points to. Returns: - bool: True if the graph contains a cycle, False otherwise. def dfs(node, visited, rec_stack): # Mark the current node as visited and add it to the recursion stack visited.add(node) rec_stack.add(node) # Recur for all the vertices adjacent to this vertex for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True # Remove the vertex from the recursion stack rec_stack.remove(node) return False visited = set() rec_stack = set() # Call the recursive helper function to detect cycle in different DFS trees for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Question **Background**: You are optimizing a point-of-sale system where transactions are recorded in real-time. One functionality required is to efficiently manage and retrieve the list of unique product names sold throughout the day. You need to implement a function that maintains uniqueness of product names, ignoring their case. **Task**: Write a function `unique_products` that accepts a list of product names sold during the day, processes them to be case-insensitive, and returns a list of unique product names preserving their original case from the first occurrence. **Function Signature**: ```python def unique_products(products: list[str]) -> list[str]: pass ``` **Input**: * `products` (list of str): A list of product names represented as strings. Product names can contain letters and spaces. **Output**: * (list of str): A list of unique product names in the order of their first occurrence, with their case preserved as in the first occurrence. **Constraints**: * The length of the input list, ( n ), will be ( 1 leq n leq 10^5 ). * The length of each product name will be ( 1 leq text{len(product)} leq 50 ). **Requirements**: * Ensure the function is efficiently implemented to handle large input sizes up to ( 10^5 ). **Examples**: ```python # Example 1 input_products = [\\"Apple\\", \\"Banana\\", \\"apple\\", \\"Orange\\", \\"banana\\", \\"Grape\\"] output_products = unique_products(input_products) print(output_products) # Expected: [\\"Apple\\", \\"Banana\\", \\"Orange\\", \\"Grape\\"] # Example 2 input_products = [\\"Laptop\\", \\"Monitor\\", \\"Mouse\\", \\"laptop\\", \\"Keyboard\\", \\"mouse\\", \\"monitor\\"] output_products = unique_products(input_products) print(output_products) # Expected: [\\"Laptop\\", \\"Monitor\\", \\"Mouse\\", \\"Keyboard\\"] ``` **Notes**: * The case of the first occurrence of each product name should be preserved, and subsequent duplicate products (case-insensitive) should be ignored.","solution":"def unique_products(products: list[str]) -> list[str]: Returns a list of unique product names in the order of their first occurrence, ignoring case differences. seen = set() unique_list = [] for product in products: lower_product = product.lower() if lower_product not in seen: seen.add(lower_product) unique_list.append(product) return unique_list"},{"question":"# Description: You are tasked with transforming a given string such that each letter is replaced with the next letter in the alphabet, with \'z\' being replaced by \'a\'. Moreover, any letters that were initially uppercase should remain uppercase in the transformed string, and those that were lowercase should remain lowercase. # Task: You need to implement a function, `shift_string(s: str) -> str`, which returns the transformed string after shifting each letter by one position in the alphabet while preserving the case. # Input: - A string `s` consisting of alphabetic letters only (a-z, A-Z). # Output: - The transformed string after each letter in the input string has been replaced by the next letter in the alphabet, preserving the case. # Constraints: - The input string `s` will have at least 1 character and at most 100 characters. # Example: ```python def shift_string(s: str) -> str: # (Your logic here) pass print(shift_string(\\"abcXYZ\\")) # Output: \\"bcdYZA\\" print(shift_string(\\"helloWorld\\")) # Output: \\"ifmmpXpsme\\" ``` # Instructions: 1. Iterate through each character in the string. 2. For each character, identify if it\'s uppercase or lowercase. 3. Shift the character by one position in the alphabet, ensuring that \'z\' wraps around to \'a\' and \'Z\' wraps around to \'A\'. 4. Preserve the case of the original character in the transformed string. 5. Return the transformed string.","solution":"def shift_string(s: str) -> str: Shifts each letter in the string by one position in the alphabet, preserving case. result = [] for char in s: if char.islower(): if char == \'z\': result.append(\'a\') else: result.append(chr(ord(char) + 1)) elif char.isupper(): if char == \'Z\': result.append(\'A\') else: result.append(chr(ord(char) + 1)) return \'\'.join(result)"},{"question":"# Question Scenario: You are tasked with developing a utility function that processes a list of product transactions and identifies the product with the highest sales based on quantity sold. However, the transactions data may vary in terms of the availability of products and their quantities. To simulate this, you will be asked to create a function that takes in a list of transactions and returns the product with the highest sales. Task: Implement a function `find_top_selling_product(transactions: List[Dict[str, Any]]) -> str` that processes the provided transactions and identifies the top-selling product based on the total quantity sold. Input: - `transactions`: A list of dictionaries where each dictionary contains: - `product`: A string representing the name of the product. - `quantity`: An integer representing the quantity sold in that transaction. Output: - A string representing the name of the product with the highest total quantity sold. Constraints: - Each transaction dictionary will have exactly two keys: \\"product\\" and \\"quantity\\". - The `product` key will always have a non-empty string value. - The `quantity` key will always have a non-negative integer value. - If there are no transactions, return `None`. - If multiple products have the same highest quantity sold, return any one of them. Performance Requirements: - Ensure the solution processes the list of transactions efficiently. Example: ```python from typing import List, Dict, Any def find_top_selling_product(transactions: List[Dict[str, Any]]) -> str: Example usage: >>> find_top_selling_product([ ... {\\"product\\": \\"apple\\", \\"quantity\\": 5}, ... {\\"product\\": \\"banana\\", \\"quantity\\": 10}, ... {\\"product\\": \\"apple\\", \\"quantity\\": 15} ... ]) \'apple\' >>> find_top_selling_product([ ... {\\"product\\": \\"apple\\", \\"quantity\\": 5}, ... {\\"product\\": \\"banana\\", \\"quantity\\": 10}, ... {\\"product\\": \\"banana\\", \\"quantity\\": 10} ... ]) \'banana\' >>> find_top_selling_product([{\\"product\\": \\"orange\\", \\"quantity\\": 0}]) \'orange\' >>> find_top_selling_product([]) None >>> find_top_selling_product([ ... {\\"product\\": \\"apple\\", \\"quantity\\": 5}, ... {\\"product\\": \\"banana\\", \\"quantity\\": 5} ... ]) in [\'apple\', \'banana\'] True # Your implementation here # Driver Code (Optional) if __name__ == \\"__main__\\": transactions = [ {\\"product\\": \\"apple\\", \\"quantity\\": 5}, {\\"product\\": \\"banana\\", \\"quantity\\": 10}, {\\"product\\": \\"apple\\", \\"quantity\\": 15} ] print(find_top_selling_product(transactions)) ``` Make sure you handle edge cases effectively and test your code thoroughly before submission.","solution":"from typing import List, Dict, Any def find_top_selling_product(transactions: List[Dict[str, Any]]) -> str: Given a list of product transactions, returns the name of the product with the highest sales. If no transactions are given, returns None. if not transactions: return None product_sales = {} for transaction in transactions: product = transaction[\\"product\\"] quantity = transaction[\\"quantity\\"] if product in product_sales: product_sales[product] += quantity else: product_sales[product] = quantity # Find the product with the highest sales top_selling_product = max(product_sales, key=product_sales.get) return top_selling_product"},{"question":"# Coding Challenge Context You are employed at a logistics company, and your task is to develop an algorithm that aids in route optimization for delivery trucks. Due to traffic conditions, some routes might cause delays and extra fuel consumption. Your algorithm should determine if a circular route is possible starting and ending at the same point, such that the truck can complete its journey without running out of fuel. Task Implement a function: ```python def can_complete_circuit(gas: List[int], cost: List[int]) -> int: pass ``` Function Signature ```python def can_complete_circuit(gas: List[int], cost: List[int]) -> int: ``` Input * A list of integers `gas`, where ( gas[i] ) is the amount of fuel available at the ( i )-th station. * A list of integers `cost`, where ( cost[i] ) is the fuel required to travel from the ( i )-th station to the ( (i+1) )-th station. Output * Return the starting gas station\'s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Examples ```python >>> can_complete_circuit([1,2,3,4,5], [3,4,5,1,2]) 3 >>> can_complete_circuit([2,3,4], [3,4,3]) -1 ``` Constraints * The length of `gas` and `cost` are the same and range from 1 to ( 10^5 ). * The elements in `gas` and `cost` are integers in the range ( 0 ) to ( 10^4 ). * Ensure your solution runs efficiently under the provided constraints.","solution":"from typing import List def can_complete_circuit(gas: List[int], cost: List[int]) -> int: Determines if a circular route is possible starting and ending at the same point. Returns the starting gas station\'s index if possible, otherwise -1. total_tank, curr_tank = 0, 0 starting_station = 0 for i in range(len(gas)): total_tank += gas[i] - cost[i] curr_tank += gas[i] - cost[i] if curr_tank < 0: # If we cannot reach the next station from station `i` starting_station = i + 1 curr_tank = 0 if total_tank >= 0: return starting_station else: return -1"},{"question":"# Question: Implementing a Custom Linked List with Enhanced Operations You are tasked with creating a custom linked list class called `EnhancedLinkedList` that supports some advanced features. In addition to standard operations such as insertion and deletion, this class should also provide methods to reverse the list, detect cycles, and merge with another sorted linked list. # Task: 1. **Implement the Enhanced Linked List**: - Create a class `EnhancedLinkedList` with methods to: - Insert a new node at the end of the list. - Delete a node with a given value. - Reverse the linked list. - Detect if the linked list contains a cycle. - Merge this linked list with another sorted linked list. 2. **Analyze and Test**: - Analyze the efficiency of your algorithm in terms of time and space complexity. - Write appropriate unittests to ensure that the implementation handles edge cases and performs correctly. # Specifications: - **`EnhancedLinkedList` Class**: - `__init__(self)`: Initialize an empty linked list. - `insert(self, value: int) -> None`: Insert a new node with the given value at the end of the list. - `delete(self, value: int) -> bool`: Delete the first node with the given value. Return `True` if deletion was successful, `False` otherwise. - `reverse(self) -> None`: Reverse the linked list in place. - `detect_cycle(self) -> bool`: Return `True` if the linked list contains a cycle, `False` otherwise. - `merge(self, other: \'EnhancedLinkedList\') -> \'EnhancedLinkedList\'`: Merge this linked list with another sorted linked list and return the merged list. # Input and Output - **Input**: - For insertion and deletion, a value to add or remove from the list. - For merge, another instance of `EnhancedLinkedList`. - **Output**: - After insertion or deletion, the updated linked list (internally). - A boolean for cycle detection. - The merged linked list for the merge operation. # Constraints: - All values in the linked list nodes are integers. - The linked lists to merge will be sorted in non-decreasing order. - Node values are unique within the list. # Example: ```python # Initialize two linked lists ell1 = EnhancedLinkedList() ell2 = EnhancedLinkedList() # Insert elements ell1.insert(1) ell1.insert(2) ell1.insert(4) ell2.insert(1) ell2.insert(3) ell2.insert(4) # Merge both lists merged = ell1.merge(ell2) # Reverse the merged list merged.reverse() # Check and print if there is a cycle print(merged.detect_cycle()) # Output: False # Print the elements of merged and reversed list node = merged.head while node: print(node.value, end=\\" \\") node = node.next # Output: 4 4 3 2 1 1 ``` # Deliverables: - The complete implementation of `EnhancedLinkedList`. - Analysis of the implemented code regarding its time and space complexity. - Unittests to validate correct operation of the linked list for edge cases and general cases.","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class EnhancedLinkedList: def __init__(self): self.head = None def insert(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def delete(self, value: int) -> bool: current = self.head prev = None while current and current.value != value: prev = current current = current.next if not current: return False if prev: prev.next = current.next else: self.head = current.next return True def reverse(self) -> None: prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def detect_cycle(self) -> bool: slow = fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def merge(self, other: \'EnhancedLinkedList\') -> \'EnhancedLinkedList\': dummy = Node(0) tail = dummy l1 = self.head l2 = other.head while l1 and l2: if l1.value <= l2.value: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 or l2 merged_list = EnhancedLinkedList() merged_list.head = dummy.next return merged_list # This will help in the unit tests def to_list(head): result = [] while head: result.append(head.value) head = head.next return result"},{"question":"# Coding Question Context You are managing a social media platform where user activities need to be monitored and displayed in reverse chronological order. Each activity has a timestamp represented as a string in the \\"YYYY-MM-DD HH:MM:SS\\" format. Implement a function to sort these activities by their timestamp in descending order. Objective Write a function `sort_activities` that takes an array of strings, each representing an activity timestamp, and returns the array sorted in descending (latest first) order. Function Signature ```python def sort_activities(timestamps: list[str]) -> list[str]: ``` Input * `timestamps`: a list of strings representing the timestamps of activities. Constraints: 1 <= len(timestamps) <= 1000 and each timestamp is a valid \\"YYYY-MM-DD HH:MM:SS\\" string. Output * A list of strings containing the timestamps sorted in descending order. Examples ```python >>> sort_activities([\\"2023-09-01 12:30:45\\", \\"2023-08-30 14:20:10\\", \\"2023-09-01 10:15:30\\", \\"2022-12-01 09:00:00\\"]) [\'2023-09-01 12:30:45\', \'2023-09-01 10:15:30\', \'2023-08-30 14:20:10\', \'2022-12-01 09:00:00\'] >>> sort_activities([\\"2021-01-01 00:00:00\\", \\"2021-12-31 23:59:59\\"]) [\'2021-12-31 23:59:59\', \'2021-01-01 00:00:00\'] >>> sort_activities([\\"2020-11-15 06:45:00\\"]) [\'2020-11-15 06:45:00\'] >>> sort_activities([\\"2022-05-20 10:00:00\\", \\"2021-04-15 09:00:00\\", \\"2023-01-25 13:30:00\\"]) [\'2023-01-25 13:30:00\', \'2022-05-20 10:00:00\', \'2021-04-15 09:00:00\'] ``` Constraints * Your function should have an overall time complexity of O(n log n), where n is the number of timestamps. * Ensure your function handles valid timestamp format inputs only. Notes 1. Consider edge cases such as a single timestamp in the list or timestamps that are already in descending order. 2. Make sure the function deals with all possible date and time ranges correctly.","solution":"def sort_activities(timestamps): Sorts the list of activity timestamps in descending order. Parameters: timestamps (list of str): A list of timestamps in the \\"YYYY-MM-DD HH:MM:SS\\" format. Returns: list of str: The sorted list of timestamps in descending order. return sorted(timestamps, reverse=True)"},{"question":"# Digital Circuit Simulation: AND Gate Implementation Background In digital circuits, an AND gate is a fundamental logic gate that outputs true (1) only when all its inputs are true (1). If any of the inputs are false (0), the output is false (0). Let us simulate the operation of an AND gate using a function. Task Write a function `and_gate(input_1: int, input_2: int) -> int` that takes two integer inputs representing Boolean values (0 or 1) and returns an integer representing the result of the AND operation according to the properties of an AND gate. Input - `input_1`: An integer (0 or 1) specifying the first input to the AND gate. - `input_2`: An integer (0 or 1) specifying the second input to the AND gate. Output - Returns an integer (0 or 1) which is the result of the AND operation. Constraints - Both inputs will always be either 0 or 1. Example ```python >>> and_gate(0, 0) 0 >>> and_gate(0, 1) 0 >>> and_gate(1, 0) 0 >>> and_gate(1, 1) 1 ``` Additional Notes - Handle any non-0 or non-1 inputs (if any exist outside the provided constraints, for example in extended tests) by considering them as invalid and returning a suitable message or error. Your task is to implement this `and_gate` function correctly and efficiently.","solution":"def and_gate(input_1: int, input_2: int) -> int: Simulates the AND gate operation. Parameters: input_1 (int): The first boolean input (0 or 1). input_2 (int): The second boolean input (0 or 1). Returns: int: The result of the AND operation (0 or 1). return input_1 & input_2"},{"question":"# Problem Statement You are tasked with developing a function that calculates the maximum sum of a contiguous subarray within a one-dimensional array of integers. This problem extends the well-known \\"maximum subarray\\" problem by allowing an additional condition: You can exclude up to one element in the subarray to potentially increase the maximum sum. # Task Implement the function `max_subarray_with_one_exclusion(arr: List[int]) -> int` where: * `arr`: A list of integers representing the array. Input * `arr` (1 ≤ len(arr) ≤ 10^5): the input array. Output * Return an integer representing the maximum sum of a contiguous subarray with at most one element excluded. # Example ```python max_subarray_with_one_exclusion([1, -2, 0, 3]) # Output: 4 max_subarray_with_one_exclusion([1, -2, 0, -3, 5]) # Output: 5 ``` Explanation For the first example: 1. If no exclusion, the maximum subarray is [1, -2, 0, 3] with sum 2. 2. Excluding -2 yields the subarray [1, 0, 3] with sum 4. For the second example: 1. If no exclusion, the maximum subarray is [5] with sum 5. 2. Excluding any element would not yield a sum greater than 5. # Constraints * Ensure the solution handles the input size efficiently in terms of both time and space. * Validate the presence of integers in the array. * Handle edge cases where the array size is minimal or all elements are negative.","solution":"from typing import List def max_subarray_with_one_exclusion(arr: List[int]) -> int: n = len(arr) if n == 1: return arr[0] # Initialize arrays to store the maximum sum subarray ending at each index max_end_here = [0] * n max_start_here = [0] * n # Compute the maximum subarray sum ending at each index max_end_here[0] = arr[0] for i in range(1, n): max_end_here[i] = max(arr[i], max_end_here[i-1] + arr[i]) # Compute the maximum subarray sum starting from each index max_start_here[-1] = arr[-1] for i in range(n-2, -1, -1): max_start_here[i] = max(arr[i], max_start_here[i+1] + arr[i]) # Find the maximum subarray sum with at most one exclusion max_sum = max(max_end_here) for i in range(1, n-1): max_sum = max(max_sum, max_end_here[i-1] + max_start_here[i+1]) return max(max_sum, max(max_start_here[-1], max_end_here[-1]))"},{"question":"# Coding Assessment Question Context You are working on a text processing tool designed for large-scale document analysis. One of the specific tasks is to identify the top `k` most frequent words in any given document. However, traditional methods like sorting all words by frequency are not efficient for this purpose due to time and space complexity constraints. Task Write a function `top_k_frequent_words` that finds the top `k` most frequent words in a given string. The function should return a list of words in order of their frequency, with the most frequent word first. If two words have the same frequency, their relative order should be based on their first appearance in the text. Your function should: 1. Handle cases where the input string is empty. 2. Treat words in a case-insensitive manner. 3. Only consider alphabetic characters and ignore punctuation and numbers. 4. Be efficient in terms of both time and space complexity. Constraints - The input string `text` can have up to (10^6) characters. - The value of `k` will be between 1 and 100. - Words will consist of alphabetic characters only. Function Signature ```python def top_k_frequent_words(text: str, k: int) -> list[str]: pass ``` Expected Input and Output ```python >>> top_k_frequent_words(\\"The quick brown fox jumps over the lazy dog\\", 3) [\\"the\\", \\"quick\\", \\"brown\\"] >>> top_k_frequent_words(\\"Hello world! Say hello to the world of Python.\\", 2) [\\"hello\\", \\"world\\"] >>> top_k_frequent_words(\\"\\", 3) [] >>> top_k_frequent_words(\\"Python is great and Python is fun\\", 2) [\\"python\\", \\"is\\"] ``` Performance Requirements - Your implementation should be optimized to handle large texts efficiently. - Aim for a time complexity of O(n log k) where n is the number of words in the text. - Ensure to handle edge cases mentioned above effectively.","solution":"def top_k_frequent_words(text: str, k: int) -> list[str]: import re from collections import Counter from heapq import nlargest # Normalize the text to lowercase and extract words words = re.findall(r\'b[a-zA-Z]+b\', text.lower()) # If there is no words, return an empty list if not words: return [] # Count the frequency of each word word_count = Counter(words) # Find the k most common words most_common_words = nlargest(k, word_count.items(), key=lambda x: (x[1], -words.index(x[0]))) # Extract only the words from the most common words return [word for word, _ in most_common_words]"},{"question":"# Binary Tree Level Order Traversal You are working for an e-commerce company that needs to optimize the display of product recommendations. To achieve this, products are categorized in a binary tree structure where each node represents a product category, and the nodes at each level represent product categories at a similar hierarchy level. # Task: Implement a function `level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]` that: * Takes the root of a binary tree. * Returns a list of lists containing the values of nodes at each level from top to bottom. Each inner list corresponds to a tree level. # Input: * `root`: The root node of a binary tree. The value of each node is an integer. The tree may be empty (`root` can be `None`). # Output: * A list of lists where each inner list contains the values of the nodes at that level of the tree in left-to-right order. # Example: ```python # Example usage: # Given binary tree: # 3 # / # 9 20 # / # 15 7 >>> level_order_traversal(root) [ [3], [9, 20], [15, 7] ] ``` # Constraints: * The number of nodes in the tree is in the range `[0, 10^4]`. * `-1000 <= Node.val <= 1000`. # Performance Requirement: * Your solution should perform efficiently within the given constraints, focusing on minimizing the time complexity. # Class Definition: The TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level = [] for _ in range(level_length): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Question: Efficient Matrix Exponentiation You are given a square matrix represented as a list of lists, with each inner list containing the matrix rows. The matrix size is (N times N). **Objective:** Write a function `matrix_exponentiation(mat: List[List[int]], exp: int) -> List[List[int]]` that computes the exponentiation of the matrix to the power of `exp` using an optimized approach. Requirements: 1. Use an iterative or recursive approach to achieve matrix exponentiation with a time complexity better than the naive (O(exp cdot N^3)). 2. Ensure matrix multiplication is carried out in the most efficient way possible. 3. Assume all elements and the exponent will be integers. Input: 1. `mat`: List of lists of integers representing the input square matrix. 2. `exp`: Integer representing the exponent to raise the matrix to. Output: - A list of lists of integers representing the matrix after raising it to the power of `exp`. Constraints: - (1 leq N leq 30) - (-100 leq text{matrix elements} leq 100) - (0 leq text{exp} leq 10^9) Example: ```python >>> matrix_exponentiation([[1, 1], [1, 0]], 5) [[8, 5], [5, 3]] >>> matrix_exponentiation([[2, 0], [0, 2]], 3) [[8, 0], [0, 8]] >>> matrix_exponentiation([[1, 2], [3, 4]], 2) [[7, 10], [15, 22]] ``` # Notes: - Your implementation should efficiently handle large exponents using techniques such as exponentiation by squaring. - Consider edge cases like the zero exponent (which should return the identity matrix) and different matrix values. - Ensure the solution handles matrices with both positive and negative elements correctly.","solution":"from typing import List def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two square matrices A and B. N = len(A) C = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): C[i][j] = sum(A[i][k] * B[k][j] for k in range(N)) return C def identity_matrix(N: int) -> List[List[int]]: Returns an N x N identity matrix. I = [[0] * N for _ in range(N)] for i in range(N): I[i][i] = 1 return I def matrix_exponentiation(mat: List[List[int]], exp: int) -> List[List[int]]: Computes matrix exponentiation using binary exponentiation. N = len(mat) result = identity_matrix(N) base = mat while exp > 0: if exp % 2 == 1: result = matrix_multiplication(result, base) base = matrix_multiplication(base, base) exp //= 2 return result"},{"question":"Longest Consecutive Subsequence Given an unsorted array of integers, write a function `longest_consecutive_subsequence(nums: List[int]) -> int` to find the length of the longest subsequence of consecutive integers. # Function Signature ```python def longest_consecutive_subsequence(nums: List[int]) -> int: pass ``` # Input - `nums`: A list of integers. # Output - An integer representing the length of the longest consecutive subsequence. # Constraints - The number of elements in the array will be between 0 and 10000. - Each integer in the array will be in the range from -10^6 to 10^6. - The array may contain duplicates. # Example ```python nums = [100, 4, 200, 1, 3, 2] print(longest_consecutive_subsequence(nums)) # Output: 4 ``` # Explanation - The longest consecutive subsequence in the given array is [1, 2, 3, 4]. Hence, the length is 4. # Implementation Details - Use a hash set to efficiently check for the presence of consecutive elements. - Iterate through each element in the array, and for each element, find the start of a possible consecutive sequence. - Check how long the sequence extends and update the maximum length accordingly. _Private class or additional helper functions can be defined to maintain modularity and readability._","solution":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Check if it is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Employee Hierarchy Given the structure of a company hierarchy using a tree where each node represents an employee, your task is to implement a function that finds the lowest common manager (LCM) for any two employees. The LCM is defined as the lowest node in the tree that has both employees as descendants (a node can be a descendant of itself). Your function should: 1. Find the lowest common manager for the given two employees. 2. Return the LCM node\'s name. # Function Signature ```python def find_lowest_common_manager(employee_tree: Node, employee1: str, employee2: str) -> str: ``` # Input * `employee_tree` (Node): The root node of the company hierarchy tree (each node has a `name` attribute representing the employee\'s name). * `employee1` (str): The name of the first employee. * `employee2` (str): The name of the second employee. # Output * The name of the lowest common manager (str). # Constraints * The tree nodes contain names of employees. * Employees\' names are unique. * Both employees always exist in the company hierarchy. # Example ```python # Example: Company Hierarchy Tree # \\"CEO\\" # / # \\"CTO\\" \\"CFO\\" # / # \\"Eng1\\" \\"Eng2\\" \\"Fin1\\" # / # \\"Intern\\" tree = Node(\\"CEO\\", [ Node(\\"CTO\\", [ Node(\\"Eng1\\", [ Node(\\"Intern\\") ]), Node(\\"Eng2\\") ]), Node(\\"CFO\\", [ Node(\\"Fin1\\") ]) ]) # Example 1: Employees \\"Eng1\\" and \\"Fin1\\" result1 = find_lowest_common_manager(tree, \\"Eng1\\", \\"Fin1\\") # Expected output: \\"CEO\\" # Example 2: Employees \\"Intern\\" and \\"Eng2\\" result2 = find_lowest_common_manager(tree, \\"Intern\\", \\"Eng2\\") # Expected output: \\"CTO\\" ``` # Explanation of Output Example - In the first example, \\"Eng1\\" and \\"Fin1\\" have \\"CEO\\" as their lowest common manager because \\"CEO\\" is the lowest node in the hierarchy that has both \\"Eng1\\" and \\"Fin1\\" as descendants. - In the second example, \\"Intern\\" and \\"Eng2\\" have \\"CTO\\" as their lowest common manager because \\"CTO\\" is the lowest node in the hierarchy that has both \\"Intern\\" (having \\"Eng1\\" as an ancestor) and \\"Eng2\\" as descendants.","solution":"class Node: def __init__(self, name, children=None): self.name = name self.children = children if children is not None else [] def find_lowest_common_manager(employee_tree, employee1, employee2): def lca_helper(node): if not node: return None if node.name == employee1 or node.name == employee2: return node matched_nodes = [] for child in node.children: result = lca_helper(child) if result: matched_nodes.append(result) if len(matched_nodes) == 2: return node elif len(matched_nodes) == 1: return matched_nodes[0] else: return None lca_node = lca_helper(employee_tree) return lca_node.name if lca_node else None"},{"question":"# Reordered List with Double Values You are tasked with writing a function that takes a list of integers, doubles the value of each integer, and then returns the new doubled values reordered in descending order. Function Signature: ```python def double_and_sort(numbers: List[int]) -> List[int]: # your code here ``` Parameters: - `numbers` (List[int]): A list of integers. Returns: - `List[int]`: A list of integers, where each integer from the input list has been doubled and the resulting list is sorted in descending order. Constraints: - The function should handle lists containing up to ( 10^6 ) integers. - Each integer in the list is within the range (-10^4) to (10^4). Example: ```python # Example Input numbers = [1, 3, 2, -5, 4, -3, 0] # Expected Output [8, 6, 4, 2, 0, -6, -10] # Explanation: # After doubling the values, the list becomes: [2, 6, 4, -10, 8, -6, 0]. # Sorting in descending order gives: [8, 6, 4, 2, 0, -6, -10]. ``` Notes: - Efficient sorting is key, especially with large lists. - Pay attention to handling negative numbers correctly when doubling and sorting. - Thoroughly test your function to ensure correctness with various list combinations, including edge cases like empty lists or lists containing repetitive values.","solution":"from typing import List def double_and_sort(numbers: List[int]) -> List[int]: Takes a list of integers, doubles the value of each integer, and then returns the new doubled values reordered in descending order. :param numbers: List of integers :return: A list of integers, where each integer from the input list has been doubled and the resulting list is sorted in descending order. # Double each number in the list doubled_numbers = [2 * num for num in numbers] # Sort the numbers in descending order doubled_numbers.sort(reverse=True) return doubled_numbers"},{"question":"# Quicksort with Dual Pivot Partitioning You are required to implement the Quicksort algorithm using a dual pivot partitioning method. This variation of Quicksort uses two pivots and can offer improved performance over the classic single pivot Quicksort. # Function Signature ```python def dual_pivot_quicksort(arr: List[int], low: int, high: int) -> List[int]: pass ``` # Input 1. `arr`: A list of integers that needs to be sorted. 2. `low`: Starting index of the segment of the list to be sorted. 3. `high`: Ending index of the segment of the list to be sorted. # Output * Returns the sorted list of integers. # Constraints * `0 <= low < high < len(arr)` * The list can contain both positive and negative integers, as well as duplicates. # Example ```python arr = [24, -34, 5, 0, 17, -5, 10, 23] sorted_arr = dual_pivot_quicksort(arr, 0, len(arr) - 1) print(sorted_arr) # Output should be: [-34, -5, 0, 5, 10, 17, 23, 24] ``` # Note 1. Your solution should implement the dual pivot Quicksort algorithm, where you choose two pivots and partition the array into three parts. 2. Ensure that your function sorts the entire array from index `low` to `high`. 3. Evaluate the performance and correctness of your function with varying list sizes and content. 4. Use recursion to divide the problem into smaller sub-problems as per Quicksort conventions.","solution":"def dual_pivot_quicksort(arr, low, high): if low < high: # partition the array and get the indices of the pivots lp, rp = dual_pivot_partition(arr, low, high) # recursively sort the subarrays dual_pivot_quicksort(arr, low, lp - 1) dual_pivot_quicksort(arr, lp + 1, rp - 1) dual_pivot_quicksort(arr, rp + 1, high) return arr def dual_pivot_partition(arr, low, high): if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] lp = low + 1 rp = high - 1 k = low + 1 p = arr[low] q = arr[high] while k <= rp: if arr[k] < p: arr[k], arr[lp] = arr[lp], arr[k] lp += 1 elif arr[k] >= q: while arr[rp] > q and k < rp: rp -= 1 arr[k], arr[rp] = arr[rp], arr[k] rp -= 1 if arr[k] < p: arr[k], arr[lp] = arr[lp], arr[k] lp += 1 k += 1 lp -= 1 rp += 1 arr[low], arr[lp] = arr[lp], arr[low] arr[high], arr[rp] = arr[rp], arr[high] return lp, rp"},{"question":"# K-nearest Neighbors (KNN) Classifier Implementation **Problem Statement**: Implement a K-nearest Neighbors (KNN) classifier from scratch in Python. Your task is to understand and implement the key functions necessary for the KNN algorithm. Demonstrate your coding proficiency by writing correct, optimized, and tested code. Components to Implement: 1. **Distance Metric**: Calculate the Euclidean distance between data points. 2. **K-nearest Neighbors Selection**: Identify the K-nearest neighbors of a given data point. 3. **Prediction Function**: Predict the class label of a test instance based on the majority class of its K-nearest neighbors. Requirements: 1. Implement the functions `euclidean_distance()`, `get_neighbors()`, and `predict_class()` as described. 2. Ensure your implementation can handle various K values and tie situations in a meaningful way. Input and Output: 1. **Input**: * `k` (int): Number of nearest neighbors to consider. * `X_train` (np.ndarray): Feature matrix for training data. * `y_train` (np.ndarray): Target labels for training data. * `X_test` (np.ndarray): Feature matrix for test data. 2. **Output**: * `predictions` (np.ndarray): Predicted class labels for test data. Examples: ```python # Sample Inputs k = 3 X_train = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [6.0, 7.0]]) y_train = np.array([0, 0, 1, 1]) X_test = np.array([[3.0, 3.5]]) # Call the KNN prediction function predictions = predict_class(k, X_train, y_train, X_test) # Expected Output (format the output to match the example) print(f\\"Predictions: {predictions}\\") ``` Ensure your solution works for the sample input and appropriately handles a variety of real-world datasets, considering different values of K, edge cases, and handling ties in the prediction. Constraints: 1. You must adhere to the essential properties of each function. 2. Optimize for computational efficiency where possible. 3. Test your implementation thoroughly using multiple test cases and edge scenarios. # Solution Outline: ```python import numpy as np def euclidean_distance(point1, point2): return np.sqrt(np.sum((point1 - point2) ** 2)) def get_neighbors(X_train, y_train, test_point, k): distances = [] for i in range(len(X_train)): dist = euclidean_distance(X_train[i], test_point) distances.append((y_train[i], dist)) distances.sort(key=lambda x: x[1]) neighbors = [distances[i][0] for i in range(k)] return neighbors def predict_class(k, X_train, y_train, X_test): predictions = [] for test_point in X_test: neighbors = get_neighbors(X_train, y_train, test_point, k) prediction = max(set(neighbors), key=neighbors.count) predictions.append(prediction) return np.array(predictions) ```","solution":"import numpy as np def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points. return np.sqrt(np.sum((np.array(point1) - np.array(point2)) ** 2)) def get_neighbors(X_train, y_train, test_point, k): Identify the K-nearest neighbors of a given test data point. distances = [] for i in range(len(X_train)): dist = euclidean_distance(X_train[i], test_point) distances.append((y_train[i], dist)) distances.sort(key=lambda x: x[1]) neighbors = [distances[i][0] for i in range(k)] return neighbors def predict_class(k, X_train, y_train, X_test): Predict the class label of each test data instance based on majority voting among its K-nearest neighbors. predictions = [] for test_point in X_test: neighbors = get_neighbors(X_train, y_train, test_point, k) prediction = max(set(neighbors), key=neighbors.count) predictions.append(prediction) return np.array(predictions)"},{"question":"# Binary Search Tree Enhancements You are given a base implementation of a Binary Search Tree (BST). The BST ensures that all left child nodes have smaller values and all right child nodes have larger values compared to their parent node. You must extend the functionality of the provided BST by implementing the following additional features: 1. **Count Nodes**: Implement a function to count and return the total number of nodes in the BST. 2. **Sum of All Nodes**: Implement a function to calculate and return the sum of all node values in the BST. 3. **In-Order Traversal**: Implement a function to perform in-order traversal (left, root, right) and return the values as a list. 4. **Check if BST**: Implement a function to verify if a given binary tree is a valid BST. Each function should take the root of the BST as an argument. # Function Signatures ```python def count_nodes(root: Node | None) -> int: pass def sum_of_nodes(root: Node | None) -> int: pass def in_order_traversal(root: Node | None) -> list[int]: pass def is_bst(root: Node, min_value: int, max_value: int) -> bool: pass ``` # Input/Output * `count_nodes(root: Node | None) -> int`: Returns the total number of nodes in the BST. If the BST is empty, return `0`. * `sum_of_nodes(root: Node | None) -> int`: Returns the sum of all node values in the BST. If the BST is empty, return `0`. * `in_order_traversal(root: Node | None) -> list[int]`: Returns a list of node values in-order. If the BST is empty, return an empty list. * `is_bst(root: Node, min_value: int, max_value: int) -> bool`: Returns `True` if the binary tree is a valid BST respecting the given min and max values, otherwise `False`. # Constraints * Assume the given tree nodes contain integer values only. * For the `is_bst` function, assume the helper function will initially be called with the full integer range (e.g., `float(\'-inf\')` to `float(\'inf\')`). # Examples ```python # Example BST creation root = None root = insert(root, 10) root = insert(root, 20) root = insert(root, 5) root = insert(root, 7) root = insert(root, 3) # Function outputs assert count_nodes(root) == 5 assert sum_of_nodes(root) == 45 assert in_order_traversal(root) == [3, 5, 7, 10, 20] assert is_bst(root, float(\'-inf\'), float(\'inf\')) == True # Example to check non-BST tree root = Node(10) root.left = Node(15) # Incorrect BST since left node is greater than root assert is_bst(root, float(\'-inf\'), float(\'inf\')) == False ``` # Implementation Notes 1. **count_nodes**: Recursively count nodes by summing counts of left and right subtrees and adding one. 2. **sum_of_nodes**: Recursively sum node values by summing values of left and right subtrees and root node value. 3. **in_order_traversal**: Recursively traverse left subtree, root, and right subtree, aggregating node values in a list. 4. **is_bst**: Verify node values respect the BST property; use helper values min_value and max_value to ensure node values remain within valid range.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return Node(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def count_nodes(root: Node | None) -> int: if root is None: return 0 return 1 + count_nodes(root.left) + count_nodes(root.right) def sum_of_nodes(root: Node | None) -> int: if root is None: return 0 return root.val + sum_of_nodes(root.left) + sum_of_nodes(root.right) def in_order_traversal(root: Node | None) -> list[int]: if root is None: return [] return in_order_traversal(root.left) + [root.val] + in_order_traversal(root.right) def is_bst(root: Node, min_value: int, max_value: int) -> bool: if root is None: return True if root.val <= min_value or root.val >= max_value: return False return is_bst(root.left, min_value, root.val) and is_bst(root.right, root.val, max_value)"},{"question":"# Question: Find the Closest Point to the Origin You need to write a function `closest_point_to_origin(points)` that receives a list of tuples, where each tuple contains two integers representing the coordinates (x, y) of different points in a 2D plane. The function should return a string identifying the point that is closest to the origin (0, 0) based on the Euclidean distance. Function Signature ```python def closest_point_to_origin(points: List[Tuple[int, int]]) -> str: ``` Input * `points` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the x and y coordinate of a point in the 2D plane. Output * A string in the format: `\\"Closest point is (x, y)\\"` where `x` and `y` are the coordinates of the point closest to the origin. Constraints * The points provided will be integers and can be positive or negative. * There will be at least one point in the list. Example ```python closest_point_to_origin([(1, 2), (3, 4), (0, 5)]) # Should return \\"Closest point is (1, 2)\\" since the distance of (1, 2) from the origin is sqrt(1^2 + 2^2) = sqrt(5) which is smaller than other distances. closest_point_to_origin([(0, 2), (-2, 0), (1, 1)]) # Should return \\"Closest point is (1, 1)\\" since the distance of (1, 1) from the origin is sqrt(1^2 + 1^2) = sqrt(2) which is the smallest. ``` Notes 1. Implement the function to handle potentially large values of x and y. 2. Ensure to correctly calculate Euclidean distance using `sqrt(x^2 + y^2)` but avoid floating point inaccuracies by comparing the squares of distances. 3. **Performance requirements**: Time complexity should be O(n), where n is the number of points provided.","solution":"from typing import List, Tuple def closest_point_to_origin(points: List[Tuple[int, int]]) -> str: Returns the closest point to the origin (0, 0) from a list of points. def distance_squared(point): return point[0]**2 + point[1]**2 closest_point = min(points, key=distance_squared) return f\\"Closest point is ({closest_point[0]}, {closest_point[1]})\\" # Example usage # print(closest_point_to_origin([(1, 2), (3, 4), (0, 5)])) # Expected \\"Closest point is (1, 2)\\" # print(closest_point_to_origin([(0, 2), (-2, 0), (1, 1)])) # Expected \\"Closest point is (1, 1)\\""},{"question":"# Matrix Rotation Assessment Matrix rotation is a common operation in computer graphics and image processing where a matrix is rotated 90 degrees clockwise or counterclockwise. Your task is to implement functions to perform these rotations on a given 2D matrix. Part 1: Rotate 90 Degrees Clockwise Implement the function `rotate_matrix_clockwise(matrix: list) -> list` that takes a 2D list `matrix` representing a square matrix and returns a new matrix that is rotated 90 degrees clockwise. # Input * `matrix` (list): A 2D list of integers representing a square matrix. # Output * A new 2D list representing the rotated matrix. # Example ```python >>> rotate_matrix_clockwise([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [ [7, 4, 1], [8, 5, 2], [9, 3, 0] ] ``` Part 2: Rotate 90 Degrees Counterclockwise Implement the function `rotate_matrix_counterclockwise(matrix: list) -> list` that takes a 2D list `matrix` representing a square matrix and returns a new matrix that is rotated 90 degrees counterclockwise. # Input * `matrix` (list): A 2D list of integers representing a square matrix. # Output * A new 2D list representing the rotated matrix. # Example ```python >>> rotate_matrix_counterclockwise([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` Constraints * Assume the input matrix is always square (N x N) where 1 ≤ N ≤ 100. * The elements of the matrix are integers. Performance Requirements * Aim for linear time complexity relative to the number of elements in the matrix. ```python def rotate_matrix_clockwise(matrix: list) -> list: # Your code here def rotate_matrix_counterclockwise(matrix: list) -> list: # Your code here ```","solution":"def rotate_matrix_clockwise(matrix: list) -> list: Rotates a given square matrix 90 degrees clockwise. n = len(matrix) # The new matrix to hold the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated def rotate_matrix_counterclockwise(matrix: list) -> list: Rotates a given square matrix 90 degrees counterclockwise. n = len(matrix) # The new matrix to hold the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[n - 1 - j][i] = matrix[i][j] return rotated"},{"question":"# Question: **Dynamic Programming: Ladder Problem** Implement a function that calculates the number of ways to climb to the top of a ladder with `n` rungs, where you can take either one, two, or three steps at a time. This problem should be solved using dynamic programming to ensure efficient computation for large `n`. # Function Signature ```python def num_ways_to_climb(n: int) -> int: pass ``` # Input 1. `n`: An integer representing the number of rungs in the ladder. # Output * Return the number of distinct ways to reach the top of the ladder. # Constraints * `1 <= n <= 1000` # Performance Requirements * The function should have a time complexity of O(n). * The space complexity should be optimized to O(1) if possible, but O(n) is acceptable. # Example ```python # Example 1 n = 4 print(num_ways_to_climb(n)) # Output: 7 # Example 2 n = 5 print(num_ways_to_climb(n)) # Output: 13 ``` # Explanation * For `n = 4`, the ways to reach the top are: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (2, 1, 1), (2, 2), (1, 3), (3, 1) – totaling 7 ways. * For `n = 5`, the ways to reach the top are: (1, 1, 1, 1, 1), (1, 1, 1, 2), (1, 1, 2, 1), (1, 2, 1, 1), (2, 1, 1, 1), (2, 2, 1), (2, 1, 2), (1, 2, 2), (1, 1, 3), (1, 3, 1), (3, 1, 1), (3, 2), (2, 3) – totaling 13 ways. # Notes * Ensure that the function handles the lower edge case where `n = 1` correctly, which should return `1`. * Make sure to use memoization or an iterative approach to ensure that the function operates efficiently for the upper limits of `n`.","solution":"def num_ways_to_climb(n: int) -> int: Returns the number of ways to climb a ladder with `n` rungs, where you can take either one, two, or three steps at a time. if n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 # Initialize ways to climb 0, 1, 2, and 3 rungs ways = [0] * (n + 1) ways[1], ways[2], ways[3] = 1, 2, 4 # Fill the ways array for all rungs from 4 to n for i in range(4, n + 1): ways[i] = ways[i - 1] + ways[i - 2] + ways[i - 3] return ways[n]"},{"question":"Matrix Multiplication **Scenario**: You are a software engineer working on a scientific computing project. Often, you\'ll need to perform matrix operations efficiently. One such common operation is the multiplication of two matrices. Write a function to perform matrix multiplication. **Task**: Implement the function `matrix_multiplication(matrix_a, matrix_b)` that multiplies two matrices and returns the resulting matrix. Ensure that the input matrices are compatible for multiplication. **Function Signature**: ```python def matrix_multiplication(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: ``` **Input**: * `matrix_a`: A list of lists of integers representing matrix A (dimensions m x n). * `matrix_b`: A list of lists of integers representing matrix B (dimensions n x p). **Output**: * A list of lists of integers representing the resulting matrix (dimensions m x p) after multiplication. **Constraints**: * The number of columns in `matrix_a` equals the number of rows in `matrix_b`. * 1 <= m, n, p <= 100 * The elements of the matrices are integers in the range [-100, 100]. **Example**: ```python matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] print(matrix_multiplication(matrix_a, matrix_b)) # Expected output: [[58, 64], [139, 154]] matrix_a = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] matrix_b = [ [4, 5, 6], [7, 8, 9], [10, 11, 12] ] print(matrix_multiplication(matrix_a, matrix_b)) # Expected output: [[4, 5, 6], [7, 8, 9], [10, 11, 12]] ``` **Note**: Your implementation should be efficient and handle the given constraints.","solution":"from typing import List def matrix_multiplication(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Multiplies two matrices matrix_a and matrix_b and returns the resulting matrix. m = len(matrix_a) n = len(matrix_a[0]) p = len(matrix_b[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Find the Maximum Path Sum in a Binary Tree Scenario You are developing a feature for a system that needs to analyze binary trees. A key requirement is to find the maximum path sum in a binary tree, where each node contains an integer value. The path connects nodes through parent-child links and must contain at least one node in the tree. Task Write a function `max_path_sum(root: Node) -> int` that takes the root of a binary tree and returns the maximum sum that can be achieved from any path in the binary tree. Input The function will receive a root node of the binary tree: - `root`: a `Node` instance where `Node` is defined as follows: ```python @dataclass class Node: data: int left: Node | None = None right: Node | None = None ``` Output The function should return an integer representing the maximum sum obtained from any path in the binary tree. Constraints - Nodes contain integer values (both positive and negative). - The tree can be empty, in which case the function should return 0. Example ```python # Example of maximum path sum calculation root = Node(data=-10) root.left = Node(data=9) root.right = Node(data=20) root.right.left = Node(data=15) root.right.right = Node(data=7) max_path_sum(root) # Output: 42 (20 + 15 + 7) # Another example root = Node(data=1) root.left = Node(data=2) root.right = Node(data=3) max_path_sum(root) # Output: 6 (2 + 1 + 3) ``` # Additional Notes - Ensure your code handles various edge cases, such as trees with only one node or left/right skewed trees. - Optimize the function to handle large trees efficiently, considering depth and complexity of the recursive calls.","solution":"from dataclasses import dataclass from typing import Optional @dataclass class Node: data: int left: Optional[\'Node\'] = None right: Optional[\'Node\'] = None def max_path_sum(root: Optional[Node]) -> int: if not root: return 0 def max_gain(node): nonlocal max_sum if not node: return 0 # Max sum on the left and right subtrees, only considering positive gains left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) # Price of new path which passes through this node current_path_sum = node.data + left_gain + right_gain # Update max_sum if the current path is better max_sum = max(max_sum, current_path_sum) # For the recursion, return the max gain if continue the same path return node.data + max(left_gain, right_gain) max_sum = float(\'-inf\') max_gain(root) return max_sum"},{"question":"# Coding Assessment Question Context You are building a tool that analyzes text files and summarizes their contents. Your utility will provide a concise representation of frequent words in the text files, which is useful for quick content previews. Task Create a function `summarize_text_file(filepath: str, top_n: int = 5) -> List[Tuple[str, int]]` which: 1. Reads the content of the file specified by the `filepath`. 2. Processes the text to count the frequency of each word. 3. Returns a list of tuples, each containing a word from the text and its respective frequency count, ordered by frequency in descending order. Requirements 1. Implement the function `summarize_text_file(filepath: str, top_n: int = 5) -> List[Tuple[str, int]]`. 2. Return only the top `top_n` most frequent words in descending order. 3. Ignore case and punctuation when counting word frequencies. 4. Handle files with any text encoding (e.g., UTF-8). 5. Implement error handling for file access issues or unsupported file formats. Input and Output * **Input**: A string `filepath` indicating the path to the text file, and an integer `top_n` specifying the number of top frequent words to return. * **Output**: A list of tuples, each tuple containing a word and its frequency count. Constraints * The function should process files of up to 10 MB in size. * Assume the environment has necessary permissions to read the file. * Handle common file reading errors gracefully (e.g., file not found, unsupported format). Example: ```python >>> summary = summarize_text_file(\\"sample.txt\\", 3) >>> print(summary) [(\'the\', 15), (\'and\', 10), (\'of\', 9)] ``` Note: Assume \\"sample.txt\\" contains: ``` The quick brown fox jumps over the lazy dog. The dog barked and ran over the hill. And the fox, quick as a wink, disappeared into the forest, leaving the dog bewildered. ```","solution":"import re from collections import Counter from typing import List, Tuple def summarize_text_file(filepath: str, top_n: int = 5) -> List[Tuple[str, int]]: Summarizes the text file by returning a list of tuples with the most frequent words and their counts. :param filepath: Path to the text file. :param top_n: Number of top frequent words to return. :return: List of tuples containing words and their frequency counts. try: with open(filepath, \'r\', encoding=\'utf-8\') as file: text = file.read() except FileNotFoundError: print(f\\"The file at the path \'{filepath}\' was not found.\\") return [] except Exception as e: print(f\\"An error occurred while reading the file: {e}\\") return [] # Normalize the text text = text.lower() text = re.sub(r\'[^ws]\', \'\', text) # Remove punctuation # Split text into words and count frequencies words = text.split() word_counts = Counter(words) # Get top_n most common words most_common_words = word_counts.most_common(top_n) return most_common_words"},{"question":"Coin Change Combination Count You are given an integer amount and an array of distinct integers representing different coin denominations. Your task is to calculate the number of different combinations of these coins that sum up to the given amount. Assume that you have an infinite supply of each type of coin. Function Signature ```python def coin_combinations(amount: int, coins: list[int]) -> int: Parameters: amount (int): The target amount to reach using the coins. coins (list[int]): A list of distinct integers representing different coin denominations. Returns: int: The number of different combinations of coins that sum up to the target amount. Returns 0 if no combination is possible. ``` Input - `amount`: An integer representing the target sum (0 <= amount <= 1000). - `coins`: A list of distinct integers representing coin denominations (1 <= len(coins) <= 50 and 1 <= coins[i] <= 100). Output - An integer representing the number of different combinations of coins that sum up to the given amount. Example ```python >>> coin_combinations(5, [1, 2, 5]) 4 >>> coin_combinations(3, [2]) 0 >>> coin_combinations(10, [2, 5, 3, 6]) 5 >>> coin_combinations(0, [1, 2, 5]) 1 ``` Note - The order of coins does not matter in a combination. - Since the amount can be zero, one combination is to use no coins at all, in which case the answer should be 1. Explanation - In the first example, there are four ways to make 5 using [1, 2, 5]: [1,1,1,1,1], [1,1,1,2], [1,2,2], and [5]. - In the second example, there is no way to make 3 with just the coin of 2. Hence, it returns 0. - In the fourth example, using no coins to make an amount of 0 is one valid combination, resulting in 1.","solution":"def coin_combinations(amount: int, coins: list[int]) -> int: Parameters: amount (int): The target amount to reach using the coins. coins (list[int]): A list of distinct integers representing different coin denominations. Returns: int: The number of different combinations of coins that sum up to the target amount. Returns 0 if no combination is possible. # Initialize a list to keep track of the number of ways to make each amount dp = [0] * (amount + 1) # Base case: there is one way to make amount 0 (using no coins) dp[0] = 1 # Iterate through each coin for coin in coins: # Update the dp list for all amounts that can be reached by adding the current coin for current_amount in range(coin, amount + 1): dp[current_amount] += dp[current_amount - coin] # The final answer will be the number of ways to make the given amount return dp[amount]"},{"question":"# Problem Statement Write a function `is_bst_symmetric()` that determines if a given Binary Search Tree (BST) is symmetric. A symmetric tree is a mirror image of itself around its center. # Function Signature ```python def is_bst_symmetric(root: TreeNode) -> bool: ``` # Input 1. `root` (TreeNode): The root node of the binary search tree. The structure of a tree node is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - `is_symmetric` (bool): Returns `True` if the binary tree is symmetric; otherwise, return `False`. # Constraints - The number of nodes in the tree is in the range [1, 1000]. - -1000 <= Node.val <= 1000. # Example ```python # Example 1: # Input: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.left.right = TreeNode(4) root.right.left = TreeNode(4) root.right.right = TreeNode(3) # Output: True assert is_bst_symmetric(root) == True # Example 2: # Input: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.right = TreeNode(3) root.right.right = TreeNode(3) # Output: False assert is_bst_symmetric(root) == False ``` # Implementation Note 1. A recursive function can be used to compare the left subtree with the right subtree. 2. Another approach involves using an iterative method with a queue to compare nodes iteratively. 3. Take care of the base cases where the tree is empty or has only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val and is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)) def is_bst_symmetric(root: TreeNode) -> bool: if not root: return True return is_symmetric(root.left, root.right)"},{"question":"# Problem: Implementing a Priority Queue using Binary Heap A priority queue is a data structure that allows for efficient retrieval of the highest (or lowest) priority element. One of the most common implementations of a priority queue is using a binary heap, which ensures that the element with the highest priority (in a max-heap) or lowest priority (in a min-heap) is stored at the root of the heap. Your task is to implement a class `PriorityQueue` using a binary heap. This class should support the following operations: - `insert(element: int) -> None`: Inserts a new element into the priority queue. - `extract_max() -> int`: Removes and returns the element with the highest priority from the priority queue. If the priority queue is empty, this method should raise an `IndexError`. - `peek_max() -> int`: Returns the element with the highest priority without removing it. If the priority queue is empty, this method should raise an `IndexError`. - `is_empty() -> bool`: Returns `True` if the priority queue is empty, and `False` otherwise. # Constraints: - The elements inserted in the priority queue are guaranteed to be integers. - All operations should have an average-case time complexity of (O(log n)) where (n) is the number of elements in the priority queue. # Expected Class Definition: ```python class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element: int) -> None: pass def extract_max(self) -> int: pass def peek_max(self) -> int: pass def is_empty(self) -> bool: pass ``` # Example: ```python pq = PriorityQueue() pq.insert(10) pq.insert(4) pq.insert(15) pq.insert(7) print(pq.peek_max()) # Should output: 15 print(pq.extract_max()) # Should output: 15 print(pq.extract_max()) # Should output: 10 print(pq.is_empty()) # Should output: False pq.extract_max() pq.extract_max() print(pq.is_empty()) # Should output: True ``` # Notes: 1. Make use of a list to represent the binary heap, where the first element represents the root of the heap. 2. Ensure that you maintain the heap property after each insert and extract operation. 3. Raise an `IndexError` with an appropriate message if `peek_max` or `extract_max` is called when the priority queue is empty. Your implementation will be tested on various sequences of insertions and extractions to ensure correctness and performance.","solution":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element: int) -> None: self.heap.append(element) self._bubble_up(len(self.heap) - 1) def extract_max(self) -> int: if self.is_empty(): raise IndexError(\'extract_max from empty priority queue\') max_element = self.heap[0] last_element = self.heap.pop() if not self.is_empty(): self.heap[0] = last_element self._bubble_down(0) return max_element def peek_max(self) -> int: if self.is_empty(): raise IndexError(\'peek_max from empty priority queue\') return self.heap[0] def is_empty(self) -> bool: return len(self.heap) == 0 def _bubble_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._bubble_up(parent_index) def _bubble_down(self, index): max_index = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] > self.heap[max_index]: max_index = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] > self.heap[max_index]: max_index = right_child_index if max_index != index: self.heap[index], self.heap[max_index] = self.heap[max_index], self.heap[index] self._bubble_down(max_index)"},{"question":"# Image Compression using Run-Length Encoding **Objective**: You need to implement a simple image compression and decompression algorithm using Run-Length Encoding (RLE) for binary images. # Function 1: `rle_compress(image: list[list[int]]) -> list[list[tuple]]` **Input**: - `image`: A 2D list representing a binary image, where each element is either 0 (white) or 1 (black). **Output**: - A 2D list where each list contains tuples representing the RLE compression of that row. - Each tuple is in the form `(value, count)` where `value` is either 0 or 1, and `count` represents the number of consecutive occurrences of that value. # Function 2: `rle_decompress(compressed_image: list[list[tuple]]) -> list[list[int]]` **Input**: - `compressed_image`: A 2D list where each list contains tuples representing the RLE compressed data of image rows. **Output**: - A 2D list representing the decompressed binary image. # Constraints: - Assume the input image is always a rectangular binary image. - Only support binary images where each pixel is either 0 or 1. - The decompressed output should be exactly the same as the original input image provided to the `rle_compress` function. # Requirements: 1. Implement the RLE compression using the described algorithm in `rle_compress`. 2. Implement the RLE decompression using the described algorithm in `rle_decompress`. 3. Ensure the compression and decompression processes handle edge cases gracefully (e.g., very small or very large images, continuous blocks of the same pixel). # Example: ```python >>> image = [ ... [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], ... [1, 1, 1, 1, 0, 0, 1, 0, 0, 0], ... [0, 1, 1, 0, 0, 0, 1, 1, 0, 0], ... ] >>> compressed_image = rle_compress(image) >>> compressed_image [ [(0, 3), (1, 2), (0, 2), (1, 3)], [(1, 4), (0, 2), (1, 1), (0, 3)], [(0, 1), (1, 2), (0, 3), (1, 2), (0, 2)] ] >>> decompressed_image = rle_decompress(compressed_image) >>> decompressed_image [ [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0], ] ``` **Note**: 1. Focus on the correctness and efficiency of the RLE algorithm. 2. Your implementation should be capable of being tested using standard unit tests.","solution":"def rle_compress(image): Performs run-length encoding on a binary image. Args: image (list[list[int]]): A 2D list representing a binary image. Returns: list[list[tuple]]: A 2D list where each inner list contains tuples of (value, count). compressed_image = [] for row in image: compressed_row = [] current_value = row[0] count = 0 for pixel in row: if pixel == current_value: count += 1 else: compressed_row.append((current_value, count)) current_value = pixel count = 1 compressed_row.append((current_value, count)) compressed_image.append(compressed_row) return compressed_image def rle_decompress(compressed_image): Decompresses a binary image from its run-length encoded form. Args: compressed_image (list[list[tuple]]): A 2D list where each inner list contains tuples of (value, count). Returns: list[list[int]]: A 2D list representing a decompressed binary image. decompressed_image = [] for compressed_row in compressed_image: row = [] for value, count in compressed_row: row.extend([value] * count) decompressed_image.append(row) return decompressed_image"},{"question":"# Weather Data Analysis **Scenario**: You have been given a dataset containing daily weather observations for a particular location over the span of one year. The dataset includes measurements such as temperature, humidity, and precipitation. Your task is to analyze this data to compute various statistics that can be useful for understanding weather patterns. **Task**: Implement a WeatherAnalyzer class in Python which reads the dataset from a CSV file and computes statistics including: 1. The average temperature for each month. 2. The wettest month (the month with the highest total precipitation). 3. The driest month (the month with the lowest total precipitation). 4. The day with the highest temperature in the entire dataset. 5. The average daily temperature for a specified range of days. **Function Signature**: ```python class WeatherAnalyzer: def __init__(self, data_file: str) -> None: pass def _read_data(self) -> None: pass def average_monthly_temperature(self) -> Dict[str, float]: pass def wettest_month(self) -> str: pass def driest_month(self) -> str: pass def highest_temperature_day(self) -> str: pass def average_temperature_range(self, start_day: str, end_day: str) -> float: pass ``` # Constraints: 1. **Inputs**: - `data_file`: A filepath to the CSV file containing weather data. The file has columns: `date`, `temperature`, `humidity`, and `precipitation`. - `start_day` and `end_day`: Dates in the format `YYYY-MM-DD` denoting the range for average temperature calculation. 2. **Outputs**: - Average monthly temperature as a dictionary with month names as keys and floating point temperatures as values. - Wettest and driest month as a string (month name). - The day with the highest temperature as a string (`YYYY-MM-DD`). - Average daily temperature for the specified date range as a floating point number. **Example**: ```python # Example of reading data and computing weather statistics: weather_data_file = \\"weather_data.csv\\" analyzer = WeatherAnalyzer(data_file=weather_data_file) # Example CSV contents (weather_data.csv): date,temperature,humidity,precipitation 2022-01-01,15.2,0.5,0.0 2022-01-02,17.3,0.6,0.0 ... 2022-12-31,14.7,0.5,2.4 # Compute monthly average temperatures average_temps = analyzer.average_monthly_temperature() print(average_temps) # Output might be {\'January\': 16.5, \'February\': 15.8, ..., \'December\': 14.2} # Find wettest and driest months print(analyzer.wettest_month()) # Expected output: \'May\' print(analyzer.driest_month()) # Expected output: \'August\' # Day with the highest temperature print(analyzer.highest_temperature_day()) # Expected output: \'2022-07-21\' # Average temperature for a specific date range start_day = \'2022-07-01\' end_day = \'2022-07-10\' print(analyzer.average_temperature_range(start_day, end_day)) # Output might be 29.5 ``` # Performance Requirements: 1. Efficiently read and process the dataset to handle the calculations. 2. Handle edge cases such as missing data, incorrect date formats, and large datasets adeptly without sacrificing performance.","solution":"import csv from datetime import datetime from collections import defaultdict from typing import Dict class WeatherAnalyzer: def __init__(self, data_file: str) -> None: self.data_file = data_file self.data = [] self._read_data() def _read_data(self) -> None: with open(self.data_file, \'r\') as file: reader = csv.DictReader(file) for row in reader: row[\'date\'] = datetime.strptime(row[\'date\'], \'%Y-%m-%d\') row[\'temperature\'] = float(row[\'temperature\']) row[\'humidity\'] = float(row[\'humidity\']) row[\'precipitation\'] = float(row[\'precipitation\']) self.data.append(row) def average_monthly_temperature(self) -> Dict[str, float]: monthly_temps = defaultdict(list) for entry in self.data: month = entry[\'date\'].strftime(\'%B\') monthly_temps[month].append(entry[\'temperature\']) average_temps = {month: sum(temps) / len(temps) for month, temps in monthly_temps.items()} return average_temps def wettest_month(self) -> str: monthly_precipitation = defaultdict(float) for entry in self.data: month = entry[\'date\'].strftime(\'%B\') monthly_precipitation[month] += entry[\'precipitation\'] wettest_month = max(monthly_precipitation, key=monthly_precipitation.get) return wettest_month def driest_month(self) -> str: monthly_precipitation = defaultdict(float) for entry in self.data: month = entry[\'date\'].strftime(\'%B\') monthly_precipitation[month] += entry[\'precipitation\'] driest_month = min(monthly_precipitation, key=monthly_precipitation.get) return driest_month def highest_temperature_day(self) -> str: highest_temp_entry = max(self.data, key=lambda entry: entry[\'temperature\']) highest_temp_day = highest_temp_entry[\'date\'].strftime(\'%Y-%m-%d\') return highest_temp_day def average_temperature_range(self, start_day: str, end_day: str) -> float: start_date = datetime.strptime(start_day, \'%Y-%m-%d\') end_date = datetime.strptime(end_day, \'%Y-%m-%d\') filtered_temps = [ entry[\'temperature\'] for entry in self.data if start_date <= entry[\'date\'] <= end_date ] if not filtered_temps: raise ValueError(\\"No data available for the provided date range\\") average_temp = sum(filtered_temps) / len(filtered_temps) return average_temp"},{"question":"# Problem Statement Consider a two-dimensional grid of size `m x n` represented by a list of lists, where each cell contains a non-negative integer. Your task is to find the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). You can only move right or down at any point in time and can only step on cells with a value of 0. # Function Signature ```python def shortest_path(grid: List[List[int]]) -> int: ``` # Input - `grid` (List[List[int]]): A 2D list representing the grid, where each element is a non-negative integer (either 0 or 1). # Output - Return an integer representing the length of the shortest path from the top-left corner to the bottom-right corner. If no such path exists, return -1. # Constraints - The dimensions of the grid (1 leq m, n leq 100). - The values in the grid are either 0 or 1. - The top-left corner (0, 0) and the bottom-right corner (m-1, n-1) will always be 0. # Example ```python grid = [ [0, 0, 1], [0, 0, 0], [1, 0, 0] ] print(shortest_path(grid)) # Expected output: 4 ``` # Requirements 1. Implement the function `shortest_path(grid: List[List[int]]) -> int` that computes the length of the shortest path from (0, 0) to (m-1, n-1). 2. Ensure your implementation is efficient and can handle the maximum constraints. # Tips - Use Breadth-First Search (BFS) for finding the shortest path in an unweighted graph. - Keep track of visited cells to prevent reprocessing and avoid infinite loops.","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0)] # only right and down directions queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Coding Challenge Context/Scenario You are tasked with engineering a new functionality in the existing Python script that calculates the price of stocks from various companies. Given a list of stock prices and the number of days each stock price has been recorded, determine the maximum profit that can be achieved from a single buy and sell transaction of these stocks. Function Signature Create a function `max_profit`: ```python def max_profit(prices: List[float]) -> float: Given a list of stock prices where each element represents the price of the stock on that particular day, return the maximum profit that can be made from one buy and one sell transaction. ``` Expected Input and Output Formats * **Input**: - `prices (List[float])`: A list of stock prices [(0 < len(prices) <= 10^5)], each price being a positive float representing the stock price on that day. * **Output**: - `float`: The maximum profit achievable from a single buy and sell transaction. If no profit is possible, return 0. Constraints and Limitations - Return 0 if the input list is empty or has only one element. - Prices in the list are guaranteed to be positive floats. Performance Requirements - The function should execute in linear time O(n) relative to the length of the prices list. Example ```python >>> max_profit([7, 1, 5, 3, 6, 4]) 5.0 # Buy at 1, sell at 6 >>> max_profit([7, 6, 4, 3, 1]) 0.0 # No profit can be made >>> max_profit([1.0, 2.0, 4.0, 2.0, 5.0, 7.0]) 6.0 # Buy at 1.0, sell at 7.0 >>> max_profit([3.0]) 0.0 # Only one price, no transactions can be made ```","solution":"from typing import List def max_profit(prices: List[float]) -> float: if len(prices) < 2: return 0.0 min_price = prices[0] max_profit = 0.0 for price in prices[1:]: if price < min_price: min_price = price profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"# Question: Implement and Test a String Transformation Function Context String manipulation is a fundamental aspect of programming, often required to preprocess data or modify content dynamically. Given code snippets demonstrate various string operations targeting different real-world contexts. Your task is to implement a custom string transformation function that capitalizes the first letter of each word and changes any occurrence of a specific character to a given replacement. Task Implement a function `transform_string(s: str, old_char: str, new_char: str) -> str` that performs the following transformations: - Capitalizes the first letter of each word in the string. - Replaces all occurrences of `old_char` with `new_char`. Requirements 1. **Function Signature**: ```python def transform_string(s: str, old_char: str, new_char: str) -> str: ``` 2. **Inputs**: - `s`: A string that you want to transform. - `old_char`: A character in the string to be replaced. - `new_char`: A character that will replace the `old_char`. 3. **Output**: - A string that has capitalized words and replaced characters. 4. **Constraints**: - `s` can contain letters, digits, spaces, and punctuation. - `old_char` and `new_char` are single character strings. - If `old_char` is not found in `s`, the function should simply capitalize the words and return the result. 5. **Error Handling**: - Ensure that `old_char` and `new_char` are single characters. Raise a `ValueError` with the message \\"old_char and new_char must be single character strings\\" if not. Examples ```python >>> s = \\"hello world! python programming is fun.\\" >>> transform_string(s, \' \', \'_\') \\"Hello_World!_Python_Programming_Is_Fun.\\" >>> s = \\"this is an example string.\\" >>> transform_string(s, \'x\', \'y\') \\"This Is An Example String.\\" >>> s = \\"special characters: #, @, &.\\" >>> transform_string(s, \'#\', \'\') \\"Special Characters: , @, &.\\" >>> s = \\"test\\" >>> transform_string(s, \'es\', \'xz\') Traceback (most recent call last): ... ValueError: old_char and new_char must be single character strings ```","solution":"def transform_string(s: str, old_char: str, new_char: str) -> str: Capitalizes the first letter of each word in the string and replaces old_char with new_char. Args: - s (str): The input string. - old_char (str): The character to be replaced. - new_char (str): The replacement character. Returns: - str: The transformed string. Raises: - ValueError: If old_char or new_char are not single character strings. if len(old_char) != 1 or len(new_char) != 1: raise ValueError(\\"old_char and new_char must be single character strings\\") # Replace old character with new character transformed_string = s.replace(old_char, new_char) # Capitalize the first letter of each word transformed_string = transformed_string.title() return transformed_string"},{"question":"# Decision Tree Regression As a data scientist, you are tasked with predicting the value of a numerical target variable based on a set of input features using a Decision Tree Regressor. You will be provided with training data to train your model and test data to validate its performance. Your task involves the following steps: 1. **Implement Decision Tree Regressor**: Write a function `train_and_predict(X, y, test_data)` that: * Takes as input: * `X`, a list of training input samples (each sample itself a list of feature values). * `y`, a list of numerical training labels. * `test_data`, a list of input samples to be used for testing the trained model. * Returns: * A list of predicted numerical labels for the input `test_data`. 2. **Use appropriate Decision Tree settings**: The Decision Tree should use the following settings: * Criterion: \'mse\' (mean squared error) * Splitter: \'best\' * Max depth: None (no maximum depth restriction) * Random state: 42 (to ensure reproducibility) 3. **Performance Requirements**: Your model should efficiently handle reasonably small datasets and produce accurate results. Ensure that training and prediction with the given settings are optimal. **Input and Output Format:** Input: ```python X = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [4.0, 5.0]] y = [2.0, 3.0, 4.0, 5.0] test_data = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]] ``` Output: ```python [2.0, 3.0, 4.0] ``` Your implementation must account for the following constraints and ensure it performs these operations correctly and efficiently. ```python from sklearn.tree import DecisionTreeRegressor def train_and_predict(X, y, test_data): Train a Decision Tree Regressor with given data and return predictions on test data. Args: X (list of list of float): Training input samples. y (list of float): Training labels. test_data (list of list of float): Test input samples. Returns: list of float: Predicted labels for the test data. # Initialize the Decision Tree Regressor regressor = DecisionTreeRegressor(criterion=\'mse\', splitter=\'best\', max_depth=None, random_state=42) # Train the regressor on the provided data regressor.fit(X, y) # Make predictions on the test data predictions = regressor.predict(test_data) return predictions.tolist() # Example usage (you can use this for testing your function): X = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [4.0, 5.0]] y = [2.0, 3.0, 4.0, 5.0] test_data = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]] predictions = train_and_predict(X, y, test_data) print(predictions) # Expected output: [2.0, 3.0, 4.0] ``` Ensure your implementation meets the requirements and provides the correct predictions.","solution":"from sklearn.tree import DecisionTreeRegressor def train_and_predict(X, y, test_data): Train a Decision Tree Regressor with given data and return predictions on test data. Args: X (list of list of float): Training input samples. y (list of float): Training labels. test_data (list of list of float): Test input samples. Returns: list of float: Predicted labels for the test data. # Initialize the Decision Tree Regressor regressor = DecisionTreeRegressor(criterion=\'squared_error\', splitter=\'best\', max_depth=None, random_state=42) # Train the regressor on the provided data regressor.fit(X, y) # Make predictions on the test data predictions = regressor.predict(test_data) return predictions.tolist() # Example usage (you can use this for testing your function): X = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [4.0, 5.0]] y = [2.0, 3.0, 4.0, 5.0] test_data = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]] predictions = train_and_predict(X, y, test_data) print(predictions) # Expected output: [2.0, 3.0, 4.0]"},{"question":"# City Temperature Analysis Objective Write a function that analyzes the temperature data from different cities and provides insights based on the following rules: 1. The input will be a dictionary, where keys are city names, and values are lists of integer temperatures. 2. You need to compute the average temperature for each city. 3. Additionally, determine which city has the highest average temperature. Function Signature ```python def city_temperature_analysis(temperature_data: dict) -> tuple: ``` Input * `temperature_data` (dict): A dictionary where keys are city names (str) and values are lists of integer temperatures (List[int]) for each respective city. Output * Returns a tuple of two elements: * A dictionary with the average temperature for each city. * A string representing the city with the highest average temperature. Constraints * Each list of temperatures will contain at least one temperature. * Temperatures are given as integers in degrees Celsius. * There will be at least one city in the input dictionary. # Examples ```python >>> city_temperature_analysis({ ... \\"New York\\": [23, 19, 25, 27], ... \\"Los Angeles\\": [22, 21, 20, 24, 25], ... \\"Chicago\\": [18, 17, 19, 20], ... \\"Houston\\": [28, 29, 31, 30] ... }) ({\'New York\': 23.5, \'Los Angeles\': 22.4, \'Chicago\': 18.5, \'Houston\': 29.5}, \'Houston\') >>> city_temperature_analysis({ ... \\"Miami\\": [30, 29, 28], ... \\"Dallas\\": [25, 26, 27] ... }) ({\'Miami\': 29.0, \'Dallas\': 26.0}, \'Miami\') >>> city_temperature_analysis({ ... \\"San Francisco\\": [15, 16, 15, 17], ... \\"Seattle\\": [18, 16, 17, 19] ... }) ({\'San Francisco\': 15.75, \'Seattle\': 17.5}, \'Seattle\') ``` # Requirements 1. You must not use any built-in statistical functions or libraries (e.g., to calculate the average). 2. Consider edge cases, such as all cities having temperatures in different ranges. 3. The function should handle typical dictionary sizes and data efficiently. # Hints - Use basic arithmetic to calculate averages. - Iterate over the dictionary efficiently to ensure performance within reasonable limits.","solution":"def city_temperature_analysis(temperature_data): Analyze temperature data of different cities. :param temperature_data: Dictionary where keys are city names and values are lists of temperatures :return: Tuple consisting of a dictionary with the average temperature for each city, and the city with the highest average temperature average_temperatures = {} for city, temperatures in temperature_data.items(): average_temperature = sum(temperatures) / len(temperatures) average_temperatures[city] = average_temperature # Find the city with the highest average temperature highest_avg_temp_city = max(average_temperatures, key=average_temperatures.get) return average_temperatures, highest_avg_temp_city"},{"question":"# Coding Assessment Question Problem Statement You are given a linked list class which supports basic operations like insertion and traversal. Your task is to extend this class to include a function that performs an in-place reversal of the linked list. Objective 1. Write a function `reverse_linked_list` that reverses the entire linked list such that the last node becomes the first node, the second last node becomes the second node, and so on. 2. Ensure you handle edge cases effectively, such as an empty linked list or a linked list with a single node. Implementation Details Extend the provided class with the following function: ```python def reverse_linked_list(self) -> None: ``` - **Input**: This function does not take any arguments, it operates on the linked list object directly. - **Output**: The linked list itself should be modified in-place, hence no return value is required. Constraints - The solution should run in O(n) time complexity, where n is the number of nodes in the linked list. - Be careful with memory usage and ensure no new nodes are created or destroyed in the process. Example ```python # Example usage: ll = LinkedList() ll.insert(1) ll.insert(2) ll.insert(3) ll.insert(4) # The linked list is now: 1 -> 2 -> 3 -> 4 ll.reverse_linked_list() # The linked list should now be: 4 -> 3 -> 2 -> 1 node = ll.head while node: print(node.value, end=\' -> \' if node.next else \'\') node = node.next # Output: 4 -> 3 -> 2 -> 1 ``` Notes - Use a single pass algorithm to reverse the linked list. - Ensure that your solution doesn\'t allocate additional memory proportional to the linked list size (i.e., no recursion or copying the list). The provided linked list implementation is already given and includes: - A `Node` class to represent each node of the list. - A `LinkedList` class to manage the list with insertion and traversal methods.","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value: int): new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def reverse_linked_list(self) -> None: prev = None current = self.head while current: next_node = current.next # Store the next node current.next = prev # Reverse the current node\'s pointer prev = current # Move prev and current one step forward current = next_node self.head = prev def to_list(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"# Problem Statement You are tasked with implementing a text editor that can maintain the editing history. Design a class `TextEditor` that supports the following operations: 1. `insert(char: str)` - Appends the character `char` at the end of the current text. 2. `delete()` - Deletes the last character from the current text. If the text is empty, do nothing. 3. `undo()` - Undoes the last operation performed (either an insert or a delete). 4. `redo()` - Redoes the last undone operation. Function Signatures ```python class TextEditor: def __init__(self): pass def insert(self, char: str) -> None: pass def delete(self) -> None: pass def undo(self) -> None: pass def redo(self) -> None: pass def getText(self) -> str: pass ``` Input Parameters * `insert(char: str)` - A string character (case-insensitive) to be added to the text. * `delete()` - No parameters. * `undo()` - No parameters. * `redo()` - No parameters. Output * No return value for `insert`, `delete`, `undo`, and `redo` operations. * `getText()` returns the current text as a string after all operations. # Constraints * Characters in the text are case-sensitive. * You can assume the input character for `insert` is always a single alphabetic character. * The maximum length of the text will not exceed 10,000 characters. * There will not be more than 10,000 operations in total. * The operations `undo` and `redo` only apply to the last put/erase actions, and their respective order. # Examples ```python editor = TextEditor() editor.insert(\'a\') editor.insert(\'b\') editor.insert(\'c\') assert editor.getText() == \'abc\' editor.delete() assert editor.getText() == \'ab\' editor.undo() assert editor.getText() == \'abc\' editor.redo() assert editor.getText() == \'ab\' editor.delete() editor.delete() assert editor.getText() == \'\' editor.undo() editor.undo() assert editor.getText() == \'ab\' ``` # Notes * You should use appropriate data structures to efficiently manage the history of operations and the ability to undo and redo. * The implementation should ensure that adding and deleting characters, as well as undoing and redoing operations, are performed as efficiently as possible.","solution":"class TextEditor: def __init__(self): self.text = [] self.history = [] self.redo_stack = [] def insert(self, char: str) -> None: self.text.append(char) self.history.append((\'insert\', char)) self.redo_stack.clear() # Clear redo stack on new operation def delete(self) -> None: if self.text: deleted_char = self.text.pop() self.history.append((\'delete\', deleted_char)) self.redo_stack.clear() # Clear redo stack on new operation def undo(self) -> None: if self.history: last_action, char = self.history.pop() if last_action == \'insert\': self.text.pop() elif last_action == \'delete\': self.text.append(char) self.redo_stack.append((last_action, char)) def redo(self) -> None: if self.redo_stack: last_action, char = self.redo_stack.pop() if last_action == \'insert\': self.text.append(char) self.history.append((\'insert\', char)) elif last_action == \'delete\': self.text.pop() self.history.append((\'delete\', char)) def getText(self) -> str: return \'\'.join(self.text)"},{"question":"**[Question 2]: You have been asked to implement a function that finds all the unique paths in a grid for a robot to travel from the top-left corner to the bottom-right corner, given that the robot can only move either down or right at any point in time. Your goal is to write a Python function that counts the number of unique paths in a grid of specified dimensions. Additionally, implement an optimized iterative approach using dynamic programming.** # Function 1: Brute Force Recursive Approach Implement the function `unique_paths_recursive(m: int, n: int) -> int`. This function should: * Take two integers `m` and `n` representing the number of rows and columns in the grid, respectively. * Return the number of unique paths from the top-left corner to the bottom-right corner using a brute force recursive approach. # Function 2: Dynamic Programming Approach Implement the function `unique_paths_dp(m: int, n: int) -> int`. This function should: * Take two integers `m` and `n` representing the number of rows and columns in the grid, respectively. * Return the number of unique paths from the top-left corner to the bottom-right corner using a dynamic programming approach. # Input and Output Format * The input will be two integers `m` and `n` where 1 <= m, n <= 100. * The function should return an integer representing the number of unique paths from the top-left corner to the bottom-right corner. # Example ```python assert unique_paths_recursive(3, 3) == 6 assert unique_paths_dp(3, 3) == 6 assert unique_paths_recursive(4, 4) == 20 assert unique_paths_dp(4, 4) == 20 ``` # Constraints * 1 <= m, n <= 100 * The integers `m` and `n` will be positive and represent the dimensions of the grid. # Notes * In the brute force recursive approach, you may encounter a challenge with large values of `m` and `n` due to its exponential time complexity, but it will serve as a good base to understand the problem. * The dynamic programming approach should efficiently handle larger values of `m` and `n` due to its polynomial time complexity.","solution":"def unique_paths_recursive(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner using a brute force recursive approach. # Base cases if m == 1 or n == 1: return 1 else: return unique_paths_recursive(m - 1, n) + unique_paths_recursive(m, n - 1) def unique_paths_dp(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner using a dynamic programming approach. dp = [[0] * n for _ in range(m)] # Initialize the first column and first row to 1 for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"# Coding Assessment Question **Scenario**: You are developing a feature for a booking system that tracks the availability of conference rooms. One of the functionalities includes finding available time slots for a given duration. Your team asks you to implement a solution to handle this requirement efficiently. # Problem Statement: Implement a function `find_available_slots(booked_slots: List[Tuple[str, str]], duration: int, start: str, end: str) -> List[Tuple[str, str]]` that identifies all available time slots of at least the given duration within a specified time frame. # Requirements: 1. **Input**: - A list of tuples `booked_slots`, where each tuple consists of two strings representing the start time and end time of a booked slot in the format `HH:MM`. - An integer `duration` representing the minimum length of the slots to be found, in minutes. - Two strings `start` and `end` representing the overall time frame within which to find available slots, in the format `HH:MM`. 2. **Output**: - A list of tuples, where each tuple consists of two strings representing the start time and end time of an available slot with at least the given duration. 3. **Constraints**: - The time values for `booked_slots`, `start`, and `end` will be valid times in `HH:MM` format. - All booked slots are within the `start` and `end` time frame and do not overlap with each other. - The `duration` is a positive integer representing minutes and will be less than or equal to the difference between `start` and `end`. # Examples: ```python >>> find_available_slots([(\\"09:00\\", \\"09:30\\"), (\\"10:00\\", \\"10:45\\"), (\\"12:00\\", \\"12:30\\")], 30, \\"08:00\\", \\"13:00\\") [(\\"08:00\\", \\"09:00\\"), (\\"09:30\\", \\"10:00\\"), (\\"10:45\\", \\"12:00\\"), (\\"12:30\\", \\"13:00\\")] >>> find_available_slots([(\\"09:00\\", \\"09:30\\"), (\\"10:00\\", \\"10:30\\")], 60, \\"08:00\\", \\"11:00\\") [(\\"08:00\\", \\"09:00\\")] >>> find_available_slots([(\\"09:00\\", \\"09:15\\"), (\\"09:30\\", \\"10:00\\")], 15, \\"09:00\\", \\"10:00\\") [(\\"09:15\\", \\"09:30\\")] >>> find_available_slots([(\\"09:00\\", \\"09:10\\"), (\\"09:20\\", \\"09:30\\")], 5, \\"09:00\\", \\"09:30\\") [(\\"09:10\\", \\"09:20\\")] >>> find_available_slots([], 15, \\"08:00\\", \\"09:00\\") # No booked slots [(\\"08:00\\", \\"09:00\\")] ``` # Guidelines: * Ensure that the function handles edge cases such as no booked slots and tight time frames efficiently. * Consider using helper functions to simplify the conversion between time strings and minutes for easier calculations. * The implementation should be efficient and clearly structured to handle up to 1000 booked slots quickly. *Note*: To compare and calculate time differences easily, consider converting the time from \\"HH:MM\\" format to an integer representing the minutes since midnight.","solution":"from typing import List, Tuple def time_to_minutes(time: str) -> int: Convert HH:MM time format to minutes since midnight. hh, mm = map(int, time.split(\\":\\")) return hh * 60 + mm def minutes_to_time(minutes: int) -> str: Convert minutes since midnight to HH:MM time format. hh = minutes // 60 mm = minutes % 60 return f\\"{hh:02}:{mm:02}\\" def find_available_slots(booked_slots: List[Tuple[str, str]], duration: int, start: str, end: str) -> List[Tuple[str, str]]: Find available time slots of at least the given duration within a specified time frame. start_minutes = time_to_minutes(start) end_minutes = time_to_minutes(end) duration_minutes = duration # Convert booked slots to minutes booked_slots_minutes = [(time_to_minutes(s), time_to_minutes(e)) for s, e in booked_slots] booked_slots_minutes.sort() available_slots = [] current_start = start_minutes for slot_start, slot_end in booked_slots_minutes: if slot_start - current_start >= duration_minutes: available_slots.append((minutes_to_time(current_start), minutes_to_time(slot_start))) current_start = slot_end if end_minutes - current_start >= duration_minutes: available_slots.append((minutes_to_time(current_start), minutes_to_time(end_minutes))) return available_slots"},{"question":"# Programming Question: Synchronization of Bells In a village, there are several churches, each having a bell that rings at a fixed interval in minutes. The intervals can vary from church to church. The bell in the first church rings every `a` minutes, the bell in the second church rings every `b` minutes, and so on. There are `n` churches in total, with the bell intervals given as an array of integers. The bells all start ringing at the same time initially (minute 0). Your task is to identify the first minute after the initial ringing when all the bells ring simultaneously again. Write a Python function: ```python def find_sync_time(intervals: List[int]) -> int: pass ``` # Input * An integer `n` (1 <= n <= 1000), representing the number of churches. * A list of integers `intervals` of length `n`, where each integer (1 <= intervals[i] <= 10^6) represents the ringing interval of a church bell. # Output * Return the first minute after the initial ringing when all bells ring simultaneously again. # Constraints * Ensure that your solution efficiently handles large intervals and multiple churches. * Consider using mathematical properties and optimizations related to intervals to derive the solution. # Example ```python >>> find_sync_time([5, 7, 11]) 385 >>> find_sync_time([2, 3, 4]) 12 ``` # Notes: * The solution should take advantage of the least common multiple (LCM) to synchronize the bells. * Avoid unnecessary repetition of calculations. * Accuracy and performance are critical, especially for handling the larger intervals efficiently.","solution":"from math import gcd from functools import reduce from typing import List def lcm(a: int, b: int) -> int: Helper function to calculate least common multiple (LCM) of two numbers. return abs(a * b) // gcd(a, b) def lcm_of_list(nums: List[int]) -> int: Helper function to calculate the LCM of a list of numbers. return reduce(lcm, nums) def find_sync_time(intervals: List[int]) -> int: Function to find the first minute after the initial ringing when all the bells ring simultaneously again. if len(intervals) == 1: return intervals[0] # If there is only one interval, that itself is the answer return lcm_of_list(intervals)"},{"question":"# Coding Assessment Question Scenario & Context You are developing a software for managing a virtual library system. The system tracks the availability of books and allows users to reserve books under certain conditions. Your task is to write a set of functions to handle book reservations, checking book availability, and managing book reservations for multiple users. Problem Statement Implement three functions `check_availability`, `reserve_book`, and `cancel_reservation` that handle the library\'s book reservation system, given a dictionary of books and their current reservations. 1. **check_availability**: This function should check if a book is available for reservation. 2. **reserve_book**: This function should reserve a book for a user if it is available. 3. **cancel_reservation**: This function should cancel an existing reservation for a user. Function Specifications 1. **check_availability** function: - **Input**: - `book_collection` (dict): A dictionary where keys are book titles (strings), and values are the number of available copies (integers). - `book_title` (string): The title of the book to check availability for. - **Output**: - (bool): True if the book is available, False otherwise. - **Constraints**: - `book_title` must be a string. - The number of available copies must be a non-negative integer. - **Error Handling**: - Raise an error if the book title is not found in the collection. 2. **reserve_book** function: - **Input**: - `book_collection` (dict): A dictionary where keys are book titles (strings), and values are the number of available copies (integers). - `reserves` (dict): A dictionary where keys are user names (strings), and values are lists of book titles (strings) the user has reserved. - `user_name` (string): The name of the user reserving the book. - `book_title` (string): The title of the book to reserve. - **Output**: - (bool): True if the reservation was successful, False otherwise. - **Constraints**: - `user_name` and `book_title` must be strings. - The number of available copies must be a non-negative integer. - **Error Handling**: - Raise an error if the book title is not found in the collection. 3. **cancel_reservation** function: - **Input**: - `book_collection` (dict): A dictionary where keys are book titles (strings), and values are the number of available copies (integers). - `reserves` (dict): A dictionary where keys are user names (strings), and values are lists of book titles (strings) the user has reserved. - `user_name` (string): The name of the user canceling the reservation. - `book_title` (string): The title of the book to cancel the reservation for. - **Output**: - (bool): True if the cancellation was successful, False otherwise. - **Constraints**: - `user_name` and `book_title` must be strings. - The number of available copies must be a non-negative integer. - **Error Handling**: - Raise an error if the book title is not found in the collection or the user does not have the book reserved. # Example ```python # Sample book collection and reservations book_collection = { \\"The Great Gatsby\\": 3, \\"1984\\": 2, \\"To Kill a Mockingbird\\": 0 } reserves = { \\"Alice\\": [\\"The Great Gatsby\\"], \\"Bob\\": [\\"1984\\"] } # Example 1: Check availability assert check_availability(book_collection, \\"1984\\") == True assert check_availability(book_collection, \\"To Kill a Mockingbird\\") == False # Example 2: Reserve a book assert reserve_book(book_collection, reserves, \\"Charlie\\", \\"1984\\") == True assert reserve_book(book_collection, reserves, \\"Alice\\", \\"1984\\") == True # Example 3: Cancel a reservation assert cancel_reservation(book_collection, reserves, \\"Bob\\", \\"1984\\") == True assert cancel_reservation(book_collection, reserves, \\"Alice\\", \\"To Kill a Mockingbird\\") == False ``` Note * Ensure to handle dictionaries properly and update values as needed. * Ensure to raise appropriate errors where necessary.","solution":"def check_availability(book_collection, book_title): Check if a book is available for reservation. if book_title not in book_collection: raise ValueError(\\"Book title not found in collection\\") return book_collection[book_title] > 0 def reserve_book(book_collection, reserves, user_name, book_title): Reserve a book for a user if it is available. if book_title not in book_collection: raise ValueError(\\"Book title not found in collection\\") if check_availability(book_collection, book_title): # Decrease the availability count book_collection[book_title] -= 1 # Add the book to the user\'s reservations if user_name not in reserves: reserves[user_name] = [] reserves[user_name].append(book_title) return True return False def cancel_reservation(book_collection, reserves, user_name, book_title): Cancel an existing reservation for a user. if book_title not in book_collection: raise ValueError(\\"Book title not found in collection\\") if user_name not in reserves or book_title not in reserves[user_name]: return False # Add the book back to the collection book_collection[book_title] += 1 # Remove the book from the user\'s reservations reserves[user_name].remove(book_title) return True"},{"question":"# Problem Description: You are required to implement a MaxStack class that supports the following operations efficiently: 1. **Push**: Push an integer onto the stack. 2. **Pop**: Remove the integer on the top of the stack and return it. 3. **Top**: Get the integer on the top of the stack. 4. **GetMax**: Retrieve the maximum integer from the stack. # Requirements: - **Input Format**: - For push, the method signature should be: ```python def push(self, value: int) -> None ``` - For pop, the method signature should be: ```python def pop(self) -> int ``` - For top, the method signature should be: ```python def top(self) -> int ``` - For getMax, the method signature should be: ```python def getMax(self) -> int ``` - **Performance Constraints**: Each operation should have an average time complexity of O(1). - **Assumptions**: The stack will be non-empty when pop, top, or getMax is called. # Example Usage: ```python maxStack = MaxStack() maxStack.push(5) maxStack.push(1) maxStack.push(5) print(maxStack.top()) # Output: 5 print(maxStack.pop()) # Output: 5 print(maxStack.getMax()) # Output: 5 print(maxStack.pop()) # Output: 1 print(maxStack.getMax()) # Output: 5 ``` # Notes: - Ensure that your implementation handles edge cases such as popping from or retrieving the top or maximum value from an empty stack gracefully. - You may use additional data structures or techniques to help achieve the required performance constraints. - Follow proper coding conventions and structure your solution to be clear and maintainable.","solution":"class MaxStack: def __init__(self): self.stack = [] self.maxStack = [] def push(self, value: int) -> None: self.stack.append(value) if not self.maxStack or value >= self.maxStack[-1]: self.maxStack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if value == self.maxStack[-1]: self.maxStack.pop() return value def top(self) -> int: if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def getMax(self) -> int: if not self.maxStack: raise IndexError(\\"getMax from empty stack\\") return self.maxStack[-1]"},{"question":"# Zigzag Conversion The classic problem of converting a string into a zigzag pattern on a given number of rows has various applications, particularly in text manipulation and display. # Task Write a function `zigzag_convert(s: str, num_rows: int) -> str` that converts a given string `s` into a zigzag pattern on `num_rows` rows and then reads the pattern line by line. # Details - **Input**: - A string `s` consisting of lowercase and uppercase English letters and digits, where ( 0 leq |s| leq 10^4 ). - An integer `num_rows` where ( 1 leq num_rows leq 1000 ). - **Output**: A single string that represents the zigzag pattern read line by line. - **Constraints**: The function should handle erroneous inputs gracefully (e.g., non-string input for `s`, non-integer input for `num_rows`, invalid range). # Performance Requirements - The function should have a time complexity of (O(n)) where (n) is the length of the input string `s`. # Example ```python def zigzag_convert(s: str, num_rows: int) -> str: if not isinstance(s, str) or not isinstance(num_rows, int) or num_rows <= 0: raise ValueError(\\"Invalid input parameters\\") if num_rows == 1 or len(s) <= num_rows: return s rows = [\'\' for _ in range(min(num_rows, len(s)))] current_row, step = 0, 1 for char in s: rows[current_row] += char if current_row == 0: step = 1 elif current_row == num_rows - 1: step = -1 current_row += step return \'\'.join(rows) # Example usages and expected outputs print(zigzag_convert(\\"PAYPALISHIRING\\", 3)) # Expected output: \\"PAHNAPLSIIGYIR\\" print(zigzag_convert(\\"PAYPALISHIRING\\", 4)) # Expected output: \\"PINALSIGYAHRPI\\" print(zigzag_convert(\\"A\\", 1)) # Expected output: \\"A\\" # Edge case with single character input ``` # Explanation 1. **Zigzag Pattern**: The string is written in a zigzag pattern across the given number of rows and then read sequentially by row. 2. **Handling Corner Cases**: If `num_rows` is 1 or if the length of `s` is less than or equal to `num_rows`, the function should return `s` itself. 3. **Iterating over the String**: Distribute characters into rows following the zigzag fashion. 4. **Combining Rows**: Concatenate all rows to get the final converted string. 5. **Validation**: Include input validation to ensure proper handling of erroneous inputs.","solution":"def zigzag_convert(s: str, num_rows: int) -> str: if not isinstance(s, str) or not isinstance(num_rows, int) or num_rows <= 0: raise ValueError(\\"Invalid input parameters\\") if num_rows == 1 or len(s) <= num_rows: return s rows = [\'\' for _ in range(min(num_rows, len(s)))] current_row, step = 0, 1 for char in s: rows[current_row] += char if current_row == 0: step = 1 elif current_row == num_rows - 1: step = -1 current_row += step return \'\'.join(rows)"},{"question":"# Coding Assessment: Optimize Sorting Function with Constraints Context You are familiar with sorting algorithms and their applications. You have a basic implementation of the bubble sort algorithm, and your task is to optimize it while ensuring it adheres to specific constraints. Problem Statement Improve the function `bubble_sort_with_constraints` to handle edge cases, optimize its performance, and provide input validation. Function to Be Enhanced ```python def bubble_sort_with_constraints(arr: list) -> list: Sort an array using bubble sort. Ensure sorting correctness while optimizing for early stopping. Skip sorting for certain values as defined by constraints. >>> bubble_sort_with_constraints([3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> bubble_sort_with_constraints([10, -1, 2, 8, -3]) [-3, -1, 2, 8, 10] n = len(arr) for i in range(n): for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr ``` Requirements 1. **Input Validation**: - Ensure `arr` is a list of integers. - Raise a `ValueError` with an appropriate message for invalid inputs. 2. **Optimization**: - Implement early stopping if the array is already sorted during iterations. 3. **Enhanced Functionality**: - Skip sorting for certain values, such as `None`, which should remain in their original positions. Input/Output Format * **Input**: - `arr`: A list of integers (and potentially `None` values). * **Output**: - A sorted list, with `None` values remaining in their original positions. Constraints 1. The input list `arr` should have a maximum length of 1000. 2. The values in the list should be integers or `None`. Example ```python try: print(bubble_sort_with_constraints([3, 1, 4, 1, 5])) # Outputs: [1, 1, 3, 4, 5] print(bubble_sort_with_constraints([10, -1, 2, 8, -3])) # Outputs: [-3, -1, 2, 8, 10] print(bubble_sort_with_constraints([2, 1, None, 4, 3])) # Outputs: [1, 2, None, 3, 4] except ValueError as ve: print(f\\"ValueError: {ve}\\") ``` Implementation Notes - Use a flag to check for early stopping if no swaps are made during an iteration. - Ensure that `None` values are not compared or swapped during the sort.","solution":"def bubble_sort_with_constraints(arr: list) -> list: Sort an array using bubble sort with the following enhancements: - Ensure input validation. - Implement early stopping for optimization. - Maintain the position of `None` values. Parameters: arr (list): List of integers and `None` values to be sorted. Returns: list: Sorted list with `None` values in their original positions. Raises: ValueError: If the input is not a list or contains non-integer, non-None elements. Examples: >>> bubble_sort_with_constraints([3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> bubble_sort_with_constraints([10, -1, 2, 8, -3]) [-3, -1, 2, 8, 10] >>> bubble_sort_with_constraints([2, 1, None, 4, 3]) [1, 2, None, 3, 4] if not isinstance(arr, list): raise ValueError(\\"Input must be a list.\\") for element in arr: if not (isinstance(element, int) or element is None): raise ValueError(\\"All elements of the list must be integers or None.\\") n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): # Skip None elements during comparison if arr[j] is not None and arr[j + 1] is not None: if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break # Sort only the non-None elements and maintain the position of None elements non_none_values = [x for x in arr if x is not None] non_none_values.sort() result = [] non_none_index = 0 for value in arr: if value is None: result.append(None) else: result.append(non_none_values[non_none_index]) non_none_index += 1 return result"},{"question":"# Greatest Common Divisor (GCD) Calculator You are tasked with developing a function to calculate the Greatest Common Divisor (GCD) of two non-negative integers. The function should make use of the Euclidean algorithm for computing the GCD. Function Signature ```python def gcd(a: int, b: int) -> int: ``` Input * `a` (int): The first non-negative integer. * `b` (int): The second non-negative integer. Output * A single integer representing the Greatest Common Divisor of `a` and `b`. Errors The function should raise a `ValueError` if: * Either `a` or `b` is a negative integer (i.e., less than zero). Algorithm Description The Euclidean algorithm for finding GCD is based on the principle that the GCD of two numbers also divides their difference. The steps are: 1. If `b` is zero, return `a`. 2. Otherwise, set `a` to `b` and `b` to `a % b`. 3. Repeat the process until `b` becomes zero. The remaining non-zero value at this point will be the GCD of the original numbers. Example Usage ```python >>> gcd(48, 18) 6 >>> gcd(56, 98) 14 >>> gcd(101, 10) 1 >>> gcd(0, 25) 25 >>> gcd(37, 600) 1 ``` # Notes * The function should handle cases where either of the inputs is zero. * If both inputs are zero, the function should return 0, as the GCD of zero and zero is not well-defined but typically considered zero for practical purposes.","solution":"def gcd(a: int, b: int) -> int: Computes the Greatest Common Divisor (GCD) of two non-negative integers using the Euclidean algorithm. Parameters: a (int): The first non-negative integer. b (int): The second non-negative integer. Returns: int: The GCD of a and b. Raises: ValueError: If either a or b is a negative integer. if a < 0 or b < 0: raise ValueError(\\"Both numbers must be non-negative.\\") while b != 0: a, b = b, a % b return a"},{"question":"# Scenario You are developing a function that processes a list of strings representing binary numbers. The goal is to determine if the decimal equivalent of each binary number is a prime number and to return a list of these binary numbers which are prime when converted to their decimal form. # Task Write a Python function `filter_prime_binaries(binary_list)` that: 1. Converts each binary number in the list to its decimal equivalent. 2. Checks if the decimal equivalent is a prime number. 3. Returns a list of binary numbers that are prime in their decimal form. # Input Format * `binary_list` (list of strings): The list of binary numbers as strings. # Output Format * A list of strings representing binary numbers that are prime when converted to decimal. # Constraints 1. Each binary number in `binary_list` contains only the characters \'0\' and \'1\'. 2. The length of `binary_list` is at most 100. 3. The maximum length of a binary number (string) in `binary_list` is 20 characters. # Example ```python binary_list = [\\"101\\", \\"111\\", \\"1001\\", \\"1011\\"] # Decimal equivalents are 5, 7, 9, 11 # Primes are 5, 7, 11 # Corresponding binary numbers are \\"101\\", \\"111\\", \\"1011\\" assert filter_prime_binaries(binary_list) == [\\"101\\", \\"111\\", \\"1011\\"] ``` # Requirements 1. Use the `sympy.isprime` function to check for prime numbers. 2. Ensure the implementation is efficient and follows good coding practices.","solution":"from sympy import isprime def filter_prime_binaries(binary_list): Processes a list of binary strings, converts them to decimal, checks if they are prime, and returns a list of binaries that are prime in decimal form. Parameters: binary_list (list of str): The list of binary numbers as strings. Returns: list of str: The list of binary numbers that are prime in their decimal form. prime_binaries = [] for binary_str in binary_list: decimal_num = int(binary_str, 2) if isprime(decimal_num): prime_binaries.append(binary_str) return prime_binaries"},{"question":"# Problem Statement Design and implement the `rotate_array` function which rotates the elements of an array to the right by `k` steps. The rotation means that each element of the array is shifted to the right by `k` positions, and the elements that overflow are wrapped around to the beginning of the array. You should aim to achieve this with optimal time complexity, aiming for (O(n)) time where (n) is the length of the array. # Function Signature ```python def rotate_array(arr: List[int], k: int) -> List[int]: ``` # Input * **arr**: A list of integers, where the length of the list is between 0 and 10^5. * **k**: A non-negative integer. (0 ≤ k ≤ 10^5) # Output * Returns a new list of integers where the original list is rotated to the right by `k` steps. # Constraints * You must handle a variety of edge cases, including but not limited to: - Rotating an empty list. - Rotation count `k` that is larger than the length of the list. - The input list can contain duplicate values. - The function should return a new list and not modify the original input list. # Examples 1. `rotate_array([1, 2, 3, 4, 5], 2)` returns `[4, 5, 1, 2, 3]` 2. `rotate_array([1, 2, 3, 4, 5], 7)` returns `[4, 5, 1, 2, 3]` 3. `rotate_array([1, 2, 3, 4, 5], 0)` returns `[1, 2, 3, 4, 5]` 4. `rotate_array([], 3)` returns `[]` 5. `rotate_array([1, 1, 1, 1], 2)` returns `[1, 1, 1, 1]` # Notes * Consider the rotation count `k` might be greater than the length of the array, and you should handle this efficiently by reducing `k` using modulo operation. For instance, `k %= len(arr)` can reduce unnecessary rotations. * Always keep an eye on edge cases for an accurate and optimized solution. Implement the `rotate_array` function.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Args: arr (List[int]): The input list of integers. k (int): The number of steps to rotate the array. Returns: List[int]: A new list of integers where the original list is rotated to the right by k steps. # If the array is empty or no rotation is needed, return the array as is if not arr or k == 0: return arr n = len(arr) # Reduce k if it is greater than the length of the array k %= n # Perform the rotation return arr[-k:] + arr[:-k]"},{"question":"# Image Compression Algorithm Context Image compression is crucial for reducing the size of image data without significantly compromising quality. One basic method of image compression is Run-Length Encoding (RLE), which is particularly effective for images with large areas of uniform color. # Task Write a function `compress_image(image: List[List[int]]) -> List[Tuple[int, int]]` that applies Run-Length Encoding (RLE) to a grayscale image represented as a 2D list of integers. # Input & Output * **Input**: `image` - a 2D list of integers where each integer represents a pixel\'s grayscale value (0 to 255). * **Output**: A list of tuples, where each tuple contains a grayscale value and the count of consecutive pixels with that value. # Constraints * The input `image` will have dimensions between 1x1 and 1000x1000. * Each integer in the input list will be in the range 0 to 255. * The output should minimize space by effectively using RLE. # Example ```python >>> image = [ ... [255, 255, 255, 0, 0, 0, 255, 255], ... [255, 255, 0, 0, 0, 0, 0, 255], ... [255, 0, 0, 0, 0, 255, 255, 255] ... ] >>> compress_image(image) [ (255, 3), (0, 3), (255, 2), (255, 2), (0, 5), (255, 1), (255, 1), (0, 4), (255, 3) ] ``` # Requirements * Efficiently implement the Run-Length Encoding algorithm. * Your solution should handle edge cases such as all pixels being the same value and alternating patterns effectively. # Notes 1. The function should process the image row by row, compressing each row\'s pixel values using RLE. 2. Ensure that the output list provides the correct sequence of grayscale value and its consecutive count for each row consecutively. # Additional Consideration An image with uniform areas should result in significant compression, whereas more complex patterns may result in a longer output list due to frequent value changes. Make sure your algorithm accounts for both scenarios equally.","solution":"from typing import List, Tuple def compress_image(image: List[List[int]]) -> List[Tuple[int, int]]: Apply Run-Length Encoding (RLE) to a 2D grayscale image. Parameters ---------- image : List[List[int]] A 2D list of integers representing the grayscale image. Returns ------- List[Tuple[int, int]] A list of tuples where each tuple contains a grayscale value and the count of consecutive pixels with that value. compressed = [] for row in image: if not row: continue current_value = row[0] count = 1 for i in range(1, len(row)): if row[i] == current_value: count += 1 else: compressed.append((current_value, count)) current_value = row[i] count = 1 # Append the last run for the current row compressed.append((current_value, count)) return compressed"},{"question":"# Problem Statement You have been provided a list of integers where each integer represents a seat number in a theater. The seat numbers are listed in a non-sequential order, and some seats may be missing. Write a function to find the missing seat numbers that are not in the list and return them in ascending order. # Input - A list of integers `seats` representing the seat numbers present in the theater. # Output - A list of integers representing the missing seat numbers in ascending order. # Constraints - 1 <= length of `seats` <= 1000 - All elements in `seats` are unique. - 1 <= minimum element in `seats` <= 100 - maximum element in `seats` <= 1000 # Example ```python find_missing_seats([1, 2, 4, 5, 7, 10]) ``` Expected Output: ```python [3, 6, 8, 9] ``` # Implementation ```python from typing import List def find_missing_seats(seats: List[int]) -> List[int]: if not seats: return [] seats.sort() complete_set = set(range(seats[0], seats[-1] + 1)) seats_set = set(seats) missing_seats = sorted(complete_set - seats_set) return missing_seats ``` # Note Make sure your function efficiently handles the sorting and set operations to ensure optimal performance even for the upper limit of the input constraints.","solution":"from typing import List def find_missing_seats(seats: List[int]) -> List[int]: if not seats: return [] seats = sorted(seats) complete_set = set(range(seats[0], seats[-1] + 1)) seats_set = set(seats) missing_seats = sorted(complete_set - seats_set) return missing_seats"},{"question":"# Reservoir Sampling for Stream Data Context: You are developing a data-processing application that needs to handle streaming data efficiently. A common use case in big data analytics is selecting a random sample from a massive dataset that is too large to fit into memory. Reservoir Sampling is a family of randomized algorithms particularly suitable for this purpose. Task: You are required to implement a function that takes a stream of data and selects a random sample of size `k` from the stream using the Reservoir Sampling algorithm. Input: - `stream`: An iterable representing the data stream, which can contain a mixture of integers, strings, or any other data type. - `k`: An integer specifying the size of the sample to be selected from the stream. Output: - A list containing `k` elements sampled randomly from the stream. Constraints: - The stream is potentially very large, and the algorithm should be efficient in both time and space. - The value of `k` is always less than or equal to the number of elements in the stream. - The function must produce a random sample each time it is run, ensuring an equal probability for all possible selections. Function Signature: ```python def reservoir_sampling(stream: Iterable, k: int) -> List: ``` Requirements: - Implement the function using the Reservoir Sampling algorithm. - Ensure the randomness of the sample by making proper use of random number generation. - The function should be optimized to handle large data streams efficiently. Example: ```python >>> import random >>> random.seed(42) # Setting the seed for reproducibility in the example >>> reservoir_sampling(range(100), 5) [81, 14, 3, 94, 35] >>> reservoir_sampling([\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'], 3) [\'c\', \'b\', \'f\'] >>> reservoir_sampling(iter([10, 20, 30, 40, 50]), 2) [30, 10] >>> reservoir_sampling(\'abcdefghij\', 4) [\'a\', \'e\', \'b\', \'j\'] ``` Note: - In the first example, a random sample of 5 integers is selected from the range 0 to 99. - In the second example, a random sample of 3 characters is selected from the list `[\'a\', \'b\', \'c\', \'d\', \'e\', \'f\']`. - In the third example, a random sample of 2 integers is selected from the iterable `[10, 20, 30, 40, 50]`. - In the fourth example, a random sample of 4 characters is selected from the string `\'abcdefghij\'`. Ensure each run of the function (without setting a random seed) produces a different random sample.","solution":"import random from typing import List, Iterable def reservoir_sampling(stream: Iterable, k: int) -> List: reservoir = [] for i, item in enumerate(stream): if i < k: reservoir.append(item) else: j = random.randint(0, i) if j < k: reservoir[j] = item return reservoir"},{"question":"# Problem Statement You are given a nested dictionary that represents a file system. Your task is to implement a function `find_largest_file(filesystem)` that iterates through the file system and returns the name of the largest file. The file system dictionary structure can have nested directories and files. Files are represented as dictionary keys with the file size as their values, and directories are also dictionary keys with another dictionary as their value. # Function Signature ```python def find_largest_file(filesystem: dict) -> str: ... ``` # Input * `filesystem`: A dictionary representing the file system, where files are keys with integer values representing their sizes, and directories are keys with another dictionary as their value. # Output * A string representing the name of the largest file in the filesystem. # Constraints * The file system will have at least one file. * File names and directory names are unique. * File sizes are positive integers. * The depth of nested directories will not exceed 100. * The number of files and directories combined will not exceed 1000. # Example ```python filesystem = { \'Documents\': { \'file1.txt\': 100, \'file2.txt\': 200, \'Photos\': { \'photo1.jpg\': 500, \'photo2.jpg\': 150 }, \'Music\': { \'song1.mp3\': 300, \'song2.mp3\': 250 } } } print(find_largest_file(filesystem)) # Output: \\"photo1.jpg\\" ``` # Guidelines * Your function should be able to recursively or iteratively traverse the entire filesystem. * Consider edge cases where files might have the same size. * Ensure the function is optimized to handle up to 1000 files and directories efficiently. * Handle cases where the largest file might be deep within nested directories.","solution":"def find_largest_file(filesystem: dict) -> str: Recursively traverses a filesystem to find the name of the largest file. def helper(fs: dict) -> tuple: largest_file = None largest_size = -1 for name, value in fs.items(): if isinstance(value, dict): # It\'s a directory, recursive call. sub_file, sub_size = helper(value) if sub_size > largest_size: largest_file, largest_size = sub_file, sub_size else: # It\'s a file. if value > largest_size: largest_file, largest_size = name, value return largest_file, largest_size largest_file, _ = helper(filesystem) return largest_file"},{"question":"# Coding Assessment Question Context: You are required to implement a function to solve the \\"word ladder\\" problem. The word ladder problem is a famous problem from algorithms and graph theory where you have to transform one word into another by changing only one letter at a time, with the restriction that each transformed word must also be a valid word in a given dictionary. Task: Implement the function `word_ladder_length(begin_word: str, end_word: str, word_list: List[str]) -> int` which: 1. Accepts a start word (`begin_word`), an end word (`end_word`), and a list of valid intermediate words (`word_list`). 2. Returns the length of the shortest transformation sequence from `begin_word` to `end_word`. If no such transformation is possible, return 0. Input: - `begin_word`: A string representing the start word. - `end_word`: A string representing the end word. - `word_list`: A list of strings representing the dictionary of intermediate words. Output: - An integer representing the length of the shortest transformation sequence. Return 0 if transformation is not possible. Constraints: 1. All words consist of lowercase English letters. 2. 1 <= len(begin_word) <= 10. 3. 1 <= len(end_word) <= 10. 4. 1 <= len(word_list) <= 500. 5. All words in `word_list` are of the same length as `begin_word`. Example: ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] assert word_ladder_length(begin_word, end_word, word_list) == 5 ``` Note: - You need to find the shortest transformation sequence. - Each transformation must be a valid word in the `word_list`. - If multiple sequences have the same length, any one of them is acceptable as the answer. - If `end_word` is not in the `word_list`, then no valid transformation sequence exists. You may use the following function skeleton: ```python def word_ladder_length(begin_word: str, end_word: str, word_list: List[str]) -> int: pass ```","solution":"from collections import deque from typing import List def word_ladder_length(begin_word: str, end_word: str, word_list: List[str]) -> int: if end_word not in word_list: return 0 word_set = set(word_list) queue = deque([(begin_word, 1)]) while queue: current_word, length = queue.popleft() if current_word == end_word: return length for i in range(len(current_word)): for char in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + char + current_word[i+1:] if next_word in word_set: queue.append((next_word, length + 1)) word_set.remove(next_word) return 0"},{"question":"# Problem Statement A village is represented as a 2D grid where each cell either has a house (\'H\') or an empty plot (\'.\'). You need to build the minimum number of libraries such that every house has access to at least one library. A house has access to a library if they are in the same row, column, or diagonal. # Function to Implement Implement the function `min_libraries(grid: List[List[str]]) -> int`: * The function should return the minimum number of libraries required to ensure every house has access to at least one library. # Expected Input/Output Formats * **Input**: * `grid`: A list of lists of strings where each string is either \\"H\\" representing a house or \\".\\" representing an empty plot. * **Output**: * Returns an integer representing the minimum number of libraries needed. # Constraints 1. The grid is rectangular and contains at least one house. 2. The dimensions of the grid are such that 1 ≤ number of rows, columns ≤ 50. # Performance Requirement * The function should be optimized to handle the largest possible grid efficiently given the constraints. # Example ```python def test_min_libraries(): grid_1 = [ [\'H\', \'.\', \'H\'], [\'.\', \'H\', \'.\'], [\'H\', \'.\', \'H\'] ] grid_2 = [ [\'H\', \'.\', \'.\'], [\'.\', \'.\', \'H\'], [\'.\', \'H\', \'.\'] ] assert min_libraries(grid_1) == 1 assert min_libraries(grid_2) == 2 test_min_libraries() ``` # Explanation For `grid_1`, placing a single library in the center (1,1) will provide access to all houses. For `grid_2`, at least two libraries are needed, one for each group of disconnected houses.","solution":"from typing import List def min_libraries(grid: List[List[str]]) -> int: Returns the minimum number of libraries needed to ensure every house has access to at least one library. A house has access to a library if they are in the same row, column, or diagonal. def dfs(x, y): if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] != \'H\': return grid[x][y] = \'.\' for dx, dy in directions: dfs(x + dx, y + dy) rows, cols = len(grid), len(grid[0]) directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] libraries_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == \'H\': libraries_count += 1 dfs(i, j) return libraries_count"},{"question":"Question: Find Node at Given Depth in N-ary Tree You are given an N-ary Tree where each node contains an integer value and has an arbitrary number of child nodes. Implement a function `find_nodes_at_depth(root: TreeNode, depth: int) -> List[int]:` that finds all the nodes at a given depth in the N-ary Tree. # Function Signature: ```python def find_nodes_at_depth(root: TreeNode | None, depth: int) -> List[int]: ``` # Input: - `root` (TreeNode | None): The root of the N-ary tree, or `None` if the tree is empty. - `depth` (int): The depth at which to find nodes (where the root is at depth 0). # Output: - A list of integers representing the values of all nodes at the given depth. - If no nodes exist at the given depth, return an empty list. # Constraints: - You may assume that the node values are unique. - The depth value will be a non-negative integer. - The N-ary tree is well-formed and may have zero or more children for each node. # Example: ```python class TreeNode: def __init__(self, val: int): self.val = val self.children = [] root = TreeNode(1) root.children = [TreeNode(2), TreeNode(3), TreeNode(4)] root.children[0].children = [TreeNode(5), TreeNode(6)] root.children[2].children = [TreeNode(7), TreeNode(8), TreeNode(9)] assert find_nodes_at_depth(root, 1) == [2, 3, 4] assert find_nodes_at_depth(root, 2) == [5, 6, 7, 8, 9] assert find_nodes_at_depth(root, 3) == [] assert find_nodes_at_depth(root, 0) == [1] ``` # Description: 1. Your function should traverse the N-ary tree starting from the `root`. 2. Use breadth-first search (BFS) to explore each level of the tree and collect node values at the specified depth. 3. Return the list of node values found at the given depth. Good luck!","solution":"from typing import List, Union class TreeNode: def __init__(self, val: int): self.val = val self.children = [] def find_nodes_at_depth(root: Union[TreeNode, None], depth: int) -> List[int]: if not root: return [] if depth == 0: return [root.val] current_level = [root] current_depth = 0 while current_level and current_depth < depth: next_level = [] for node in current_level: next_level.extend(node.children) current_level = next_level current_depth += 1 return [node.val for node in current_level] if current_depth == depth else []"},{"question":"# Coding Challenge: Implement an LFU (Least Frequently Used) Cache Context You have been provided with a skeleton for an LFU (Least Frequently Used) Cache that supports efficient operations for caching frequently accessed data. The LFU cache evicts the least frequently used items to make space for new items. Task You need to implement the LFU Cache class with the following functionalities: 1. **Set Key-Value Pair**: This operation adds a key-value pair to the cache. If the key already exists, it updates the value and increases the frequency count of the key. 2. **Get Value By Key**: This operation retrieves the value for a given key and increments its frequency count. If the key does not exist, it returns -1. Specifications **Operation 1: Set Key-Value Pair** - **Function Signature**: `def set(self, key, value):` - **Input**: `key` - The key to be added or updated, `value` - The value corresponding to the key. - **Output**: It does not return anything but adds/updates the key-value pair in the cache. **Operation 2: Get Value By Key** - **Function Signature**: `def get(self, key):` - **Input**: `key` - The key whose value needs to be retrieved. - **Output**: It returns the value corresponding to the key if found; otherwise, it returns -1. Additional Requirements - Implement appropriate data structures to efficiently track the frequency of accesses. - Ensure that the cache evicts the least frequently used items when it\'s full. - The cache should support a fixed capacity provided during initialization. # Example Usage ```python # Initialize an LFU cache with a capacity of 3 lfu = LFUCache(3) # Set key-value pairs lfu.set(1, 10) lfu.set(2, 20) lfu.set(3, 30) # Access some keys to change their frequencies print(lfu.get(1)) # Should print 10 print(lfu.get(2)) # Should print 20 print(lfu.get(2)) # Should print 20 # Add a new key to the cache, triggering eviction of the least frequently used item lfu.set(4, 40) # Get the values of keys to verify the eviction logic print(lfu.get(3)) # Should print -1, as key 3 is evicted print(lfu.get(4)) # Should print 40 print(lfu.get(2)) # Should print 20 # Add another key, triggering another eviction lfu.set(5, 50) # Check the values after the eviction print(lfu.get(1)) # Should print -1, as key 1 is evicted print(lfu.get(5)) # Should print 50 print(lfu.get(2)) # Should print 20 ``` # Constraints - The cache should have a fixed size determined at initialization. - The cache should have O(1) time complexity for both `set` and `get` operations. - If there are multiple least frequently used items, evict the one that was least recently used. **Nota Bene**: Implement the LFU Cache and necessary supporting structures to achieve the required functionalities.","solution":"from collections import defaultdict, OrderedDict class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.size = 0 self.min_freq = 0 self.key_to_val = {} self.key_to_freq = defaultdict(int) self.freq_to_keys = defaultdict(OrderedDict) def _update_frequency(self, key): # Remove key from old frequency list freq = self.key_to_freq[key] del self.freq_to_keys[freq][key] if not self.freq_to_keys[freq]: if freq == self.min_freq: self.min_freq += 1 del self.freq_to_keys[freq] # Add key to new frequency list self.key_to_freq[key] += 1 freq = self.key_to_freq[key] self.freq_to_keys[freq][key] = None def set(self, key: int, value: int): if self.capacity == 0: return if key in self.key_to_val: self.key_to_val[key] = value self._update_frequency(key) else: if self.size == self.capacity: # Evict the least frequently used key k, _ = self.freq_to_keys[self.min_freq].popitem(last=False) del self.key_to_val[k] del self.key_to_freq[k] self.size -= 1 self.key_to_val[key] = value self.key_to_freq[key] = 1 self.freq_to_keys[1][key] = None self.min_freq = 1 self.size += 1 def get(self, key: int) -> int: if key not in self.key_to_val: return -1 self._update_frequency(key) return self.key_to_val[key]"},{"question":"**[Question 2]:** Your task is to implement a function that compresses a string by using the counts of repeated characters. This is a common technique used in data compression algorithms. # Function Definition Implement the function `compress_string(s)` that takes in a single string `s` and returns a new compressed version of that string. # Compression Rules - The compression of the string should be achieved by replacing sequences of the same character with that character followed by the number of its occurrences consecutively. - The compressed string should only be created if it\'s shorter than the original string. If not, return the original string. - The string will contain only uppercase and lowercase alphabetical characters. # Example ```python # Example 1 s = \\"aabcccccaaa\\" result = compress_string(s) # Expected Output: \\"a2b1c5a3\\" # Example 2 s = \\"abcd\\" result = compress_string(s) # Expected Output: \\"abcd\\" # Example 3 s = \\"aaAAaa\\" result = compress_string(s) # Expected Output: \\"aaAAaa\\" (since the compressed version \\"a2A2a2\\" is longer) ``` # Constraints - The length of the string `s` will be between 1 and 10^6 characters. - The characters in string `s` are all alphabetical (uppercase and lowercase). # Additional Information - The implementation should be efficient to handle the upper limit of the constraints. - Consider edge cases like strings with a single character, all unique characters, or very long strings with high repetition. Implement the `compress_string` function accordingly, ensuring to test for both performance and correctness.","solution":"def compress_string(s): Compresses a string by using the counts of repeated characters. Returns the original string if the compressed version is not shorter. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Problem Statement You need to write a function that finds the longest contiguous subarray with at most one unique integer in it. A contiguous subarray is a subset of an array that is contiguous; this means the elements appear together, and they appear in the same order as they do in the array. # Function Signature ```python def longest_subarray_with_one_unique_integer(nums: List[int]) -> int: # Your code implementation here ``` # Input 1. **nums** (List[int]): An array of integers. * 1 <= len(nums) <= 100,000 * -10^9 <= nums[i] <= 10^9 # Output * **int**: Length of the longest contiguous subarray with at most one unique integer. # Constraints * The length of input array will be positive and within the range specified. * Elements in the array can be large but are handled in standard integer range. # Examples ```python assert longest_subarray_with_one_unique_integer([1, 2, 2, 3, 1, 1, 1, 0, 0, 0, 0]) == 4 assert longest_subarray_with_one_unique_integer([4, 4, 4, 4]) == 4 assert longest_subarray_with_one_unique_integer([1]) == 1 assert longest_subarray_with_one_unique_integer([1, 2, 3, 4, 5]) == 1 ``` # Explanation * For the first example, the subarray `[0, 0, 0, 0]` is continuous and contains the same number, with length 4. * For the second example, the entire array `[4, 4, 4, 4]` has only one unique integer, thus its length is 4. * For the third example, the single element array `[1]` has only one unique integer, thus its length is 1. * For the fourth example, any subarray will have only one element since all of them are unique, so the length is 1. # Requirements 1. Implement the function to find the length of the longest contiguous subarray with at most one unique integer. 2. Ensure the implementation efficiently handles large arrays within the provided constraints.","solution":"from typing import List def longest_subarray_with_one_unique_integer(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with at most one unique integer. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_length += 1 else: current_length = 1 # Reset the current length counter max_length = max(max_length, current_length) return max_length"},{"question":"# Question: Reverse Words in a String Context: You are given a string of words separated by single spaces. Your task is to write a Python function that reverses the order of the words in the string while maintaining the original spacing. Problem Statement: Write a function `reverse_words(sentence: str) -> str` that takes a string containing words separated by single spaces and returns a string with the words in reverse order. Input: * `sentence` (str): A string containing words separated by single spaces. Output: * `str`: A string with the words in reverse order. Constraints: * The length of the `sentence` will not exceed 10,000 characters. * Each word will contain only alphabetical characters, and there will be at least one word in the `sentence`. Example: ```python assert reverse_words(\\"hello world\\") == \\"world hello\\" assert reverse_words(\\"python is fun\\") == \\"fun is python\\" assert reverse_words(\\"a b c d\\") == \\"d c b a\\" ``` Requirements: * Your solution should have a time complexity of O(N) and a space complexity of O(N), where N is the length of the sentence. * Avoid using built-in functions that directly reverse the order of words (e.g., slicing). * Ensure correctness for edge cases such as single-word sentences and very long strings.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in the given sentence. Parameters: sentence (str): A string containing words separated by single spaces. Returns: (str): A string with the words in reverse order. words = sentence.split() reversed_sentence = \' \'.join(reversed(words)) return reversed_sentence"},{"question":"# Depth-First Search Algorithm Problem Given an undirected graph represented as an adjacency list, implement a function `connected_components` that finds all the connected components in the graph using the Depth-First Search (DFS) algorithm. A connected component is a subset of the graph where there is a path between any two vertices. # Function Signature ```python def connected_components(graph: dict) -> list: pass ``` # Input * `graph`: A dictionary where the keys are nodes and the values are lists of nodes representing the adjacency list of the graph. The graph has no more than 10^5 nodes and 5*10^5 edges. # Output * A list of connected components, where each connected component is represented as a list of nodes. Each list of nodes should be sorted in ascending order. # Example ```python >>> connected_components({0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3]}) [[0, 1, 2], [3, 4]] >>> connected_components({0: [], 1: []}) [[0], [1]] >>> connected_components({}) [] ``` # Constraints * The function must correctly identify and return all connected components. * Handle edge cases such as an empty graph and graphs with isolated nodes. * Each connected component should be listed only once and the nodes within each component should be in ascending order.","solution":"def connected_components(graph): Find all connected components in an undirected graph using DFS. :param graph: Dictionary where the keys are nodes and the values are lists of nodes representing the adjacency list of the graph. :return: List of connected components, where each connected component is represented as a list of nodes sorted in ascending order. def dfs(node, visited, component): visited.add(node) component.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, component) visited = set() components = [] for node in graph: if node not in visited: component = [] dfs(node, visited, component) components.append(sorted(component)) return components"},{"question":"# Introduction You are working on a text processing tool that frequently handles strings with special characters, punctuation, and whitespace. One of your tasks is to implement a function that removes all non-alphanumeric characters from a given string while preserving spaces, effectively cleaning it for further processing. # Problem Write a function `clean_string(input_string: str) -> str` that removes all non-alphanumeric characters from the input string, except for spaces, and returns the cleaned string. # Function Signature ```python def clean_string(input_string: str) -> str: ``` # Input The input is a single string, `input_string`, which may: - Be empty or consist of whitespace only. - Include various alphabets (uppercase and lowercase), digits, special characters, punctuation, and whitespace. # Output The function should return a new string with all non-alphanumeric characters removed, except for spaces. # Constraints 1. An empty input string should return an empty string. 2. The function must preserve all spaces in their original positions. # Examples ```python assert clean_string(\\"Hello, World!\\") == \\"Hello World\\" assert clean_string(\\"This is a test.\\") == \\"This is a test\\" assert clean_string(\\"Python@3.8\\") == \\"Python38\\" assert clean_string(\\"123 456 7890\\") == \\"123 456 7890\\" assert clean_string(\\" Remove!!! these special@ characters! \\") == \\" Remove these special characters \\" assert clean_string(\\"\\") == \\"\\" assert clean_string(\\" \\") == \\" \\" ``` Make sure your solution passes the above examples and adheres to the constraints provided.","solution":"def clean_string(input_string: str) -> str: Removes all non-alphanumeric characters from the input string except for spaces. return \'\'.join(char for char in input_string if char.isalnum() or char.isspace())"},{"question":"# Problem Statement: Write a function `calculate_discounted_price(original_prices: List[float], discounts: List[float]) -> List[float]` that calculates the discounted prices of a list of items given their original prices and discount percentages. Each item in the `original_prices` list corresponds to a discount percentage in the `discounts` list. The discounted price is calculated by applying the discount percentage to the original price. Input Format: * A list of floats `original_prices` representing the original prices of the items. * A list of floats `discounts` representing the discount percentages for each item. Each discount is a value between 0 and 100 inclusive. Output Format: * A list of floats where each element is the discounted price for the corresponding item in the `original_prices` list. Constraints: * The `original_prices` list and the `discounts` list will each have at most 10^3 elements. * Each value in `original_prices` will be between 0 and 10^5 inclusive. * Each value in `discounts` will be between 0 and 100 inclusive. Examples: ```python calculate_discounted_price([100.0, 200.0, 300.0], [10.0, 20.0, 30.0]) # Returns: [90.0, 160.0, 210.0] calculate_discounted_price([50.0, 75.0], [25.0, 50.0]) # Returns: [37.5, 37.5] calculate_discounted_price([120.0, 80.0], [0.0, 100.0]) # Returns: [120.0, 0.0] calculate_discounted_price([500.0], [15.0]) # Returns: [425.0] ``` Additional notes: Ensure accurate calculations involving floating-point arithmetic. Handle edge cases such as zero discounts and zero original prices correctly.","solution":"from typing import List def calculate_discounted_price(original_prices: List[float], discounts: List[float]) -> List[float]: Calculate the discounted prices of a list of items given their original prices and discount percentages. discounted_prices = [] for original_price, discount in zip(original_prices, discounts): discounted_price = original_price * (1 - discount / 100) discounted_prices.append(discounted_price) return discounted_prices"},{"question":"# Coding Assessment Question **Objective**: Assess students\' ability to work with data structures and understand time complexity optimization. **Background**: Understanding and manipulating data structures efficiently is a core aspect of software development. One common structure is the binary search tree (BST), which provides efficient lookup, insertion, and deletion operations when balanced. Your task is to implement a function to find the `k`th smallest element in a Binary Search Tree (BST). This is a fundamental problem that tests your ability to perform in-order traversal and utilize properties of BSTs. **Task**: 1. **Function Implementation**: Implement a function called `find_kth_smallest` that: - Accepts the root of a BST and an integer `k`. - Returns the `k`th smallest element in the BST. 2. **Constraints**: - The BST node values are unique. - k is valid for the given BST (1 ≤ k ≤ number of nodes in the tree). 3. **Performance**: - Your implementation should be efficient, with a time complexity of O(h + k), where `h` is the height of the tree, considering both balanced and unbalanced scenarios. **Input/Output**: - Input: `find_kth_smallest(root: Optional[TreeNode], k: int) -> int` - `root`: The root node of the BST. - `k`: An integer representing the position (1-based) of the smallest element to return. - Output: Returns the `k`th smallest element in the BST. **Example**: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_kth_smallest(root: Optional[TreeNode], k: int) -> int: pass # Example Usage # Construct the BST # 5 # / # 3 7 # /| | # 2 4 6 8 root = TreeNode(5) root.left = TreeNode(3, TreeNode(2), TreeNode(4)) root.right = TreeNode(7, TreeNode(6), TreeNode(8)) assert find_kth_smallest(root, 1) == 2 assert find_kth_smallest(root, 3) == 4 assert find_kth_smallest(root, 5) == 6 assert find_kth_smallest(root, 7) == 8 ``` Provide a clear, efficient, and well-commented solution to find the `k`th smallest element in a Binary Search Tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_kth_smallest(root: TreeNode, k: int) -> int: Returns the k-th smallest element in the BST. stack = [] curr = root count = 0 while curr is not None or stack: while curr is not None: stack.append(curr) curr = curr.left curr = stack.pop() count += 1 if count == k: return curr.value curr = curr.right"},{"question":"# Problem: You are working with a collection of words. You need to check if a word is a concatenation of other words from the collection. # Objective: Implement the function `is_concatenated(word: str, collection: List[str]) -> bool` that takes a word and a collection of words as input, and returns a boolean indicating whether the word can be formed by concatenating one or more words from the collection. # Function Signature: ```python def is_concatenated(word: str, collection: List[str]) -> bool: ``` # Input: - `word`: A string representing the target word. (1 <= len(word) <= 100) - `collection`: A list of strings representing the collection of words. (1 <= len(collection) <= 50, 1 <= len(collection[i]) <= 20) # Output: - A boolean value: `True` if the word can be formed by concatenating words from the collection, and `False` otherwise. # Example: ```python word = \\"applepenapple\\" collection = [\\"apple\\", \\"pen\\"] output = is_concatenated(word, collection) # Expected output: True word = \\"catsandog\\" collection = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] output = is_concatenated(word, collection) # Expected output: False ``` # Constraints: - A word from the collection can be used multiple times in the concatenation process. - The words in the collection and the target word consist only of lowercase English letters. # Guidance: In your function: 1. You can use dynamic programming to solve the problem. 2. Create a boolean array that keeps track of whether a substring can be formed by concatenation of words in the collection. 3. Iterate through the target word and update the boolean array based on the words found in the collection. 4. Return the value indicating whether the entire target word can be formed. # Example Description: - For the first example, \\"applepenapple\\" can be segmented as (\\"apple\\" + \\"pen\\" + \\"apple\\"), which are all in the collection. - For the second example, \\"catsandog\\" cannot be segmented to form valid consecutive words from the given collection.","solution":"def is_concatenated(word: str, collection: [str]) -> bool: Returns True if the word can be formed by concatenating one or more words from the collection, else False. if not word: return False word_len = len(word) dp = [False] * (word_len + 1) dp[0] = True for i in range(1, word_len + 1): for w in collection: word_w_len = len(w) if dp[i - word_w_len] and word[i - word_w_len:i] == w: dp[i] = True break return dp[word_len]"},{"question":"# Question: Implement Efficient Letter Combinations of a Phone Number You are asked to write a program that generates all possible letter combinations a phone number could represent. The mapping of digits to letters is based on the traditional telephone keypad layout, but you should optimize the function for efficiency as the input number can be lengthy. Requirements: 1. **Function Signature**: Implement a function `letter_combinations(digits: str) -> List[str]`. 2. **Input**: A string `digits` representing a phone number. 3. **Output**: A list of strings containing all possible letter combinations the input number could represent. 4. **Time Complexity**: Ensure the function is optimized for large inputs, targeting O(3^n) when n is the length of the digits string. 5. **Constraints**: * The input string consists of digits from \'2\' to \'9\' only. * The length of the input string can be up to 50 characters. 6. **Performance**: * The solution must be efficient in generating combinations for strings up to the maximum length. Edge Cases to Handle: * The input string is empty. * The input string contains the same digit repeated. * The input string contains a mix of digits with differing mappings (e.g., \'23\', \'78\'). Example: ```python >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"7\\") [\\"p\\", \\"q\\", \\"r\\", \\"s\\"] >>> letter_combinations(\\"222\\") [\\"aaa\\", \\"aab\\", \\"aac\\", \\"aba\\", \\"abb\\", \\"abc\\", \\"aca\\", \\"acb\\", \\"acc\\", \\"baa\\", \\"bab\\", \\"bac\\", \\"bba\\", \\"bbb\\", \\"bbc\\", \\"bca\\", \\"bcb\\", \\"bcc\\", \\"caa\\", \\"cab\\", \\"cac\\", \\"cba\\", \\"cbb\\", \\"cbc\\", \\"cca\\", \\"ccb\\", \\"ccc\\"] ``` **Note**: Ensure to utilize efficient algorithms and data structures to handle the generation of combinations, particularly for longer digit strings. Use iterative approaches, caching, or any suitable method to keep the solution performant.","solution":"def letter_combinations(digits: str): if not digits: return [] # Mapping of digits to corresponding letters phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if len(path) == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_map[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# String Compression Implement a compressor function that reduces the size of a given string by compressing consecutive identical characters. The compression should be done by replacing consecutive identical characters with the character followed by the count of their occurrences. # Problem Statement You are tasked with writing a function `compress_string(s: str) -> str` that compresses a given string `s` by replacing consecutive identical characters with that character and the number of repetitions. # Task 1. **Function Implementation**: Implement the function `compress_string(s: str) -> str` where: - **Input**: - `s`: A string consisting of alphabetic characters (both uppercase and lowercase). - **Output**: - A compressed string according to the described rules. 2. **Compression Rules**: - Replace consecutive identical characters with the character followed by the number of its consecutive occurrences. - If a character appears exactly once, it should not be followed by a number. 3. **Edge Cases**: - If the string is empty, return an empty string. - Handle both uppercase and lowercase characters separately. # Example ```python print(compress_string(\\"aaabbccccdaa\\")) # Output: \\"a3b2c4d1a2\\" print(compress_string(\\"abc\\")) # Output: \\"abc\\" print(compress_string(\\"a\\")) # Output: \\"a\\" print(compress_string(\\"\\")) # Output: \\"\\" print(compress_string(\\"KKKKLLaaaBB\\")) # Output: \\"K4L2a3B2\\" ``` # Constraints - The length of the input string will not exceed 100,000 characters. - The function should run efficiently within acceptable limits given the input size.","solution":"def compress_string(s: str) -> str: Compresses the string by replacing consecutive identical characters with the character followed by the count of their occurrences. If a character appears exactly once, it should not be followed by a number. if not s: return \\"\\" result = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: result.append(s[i-1]) if count > 1: result.append(str(count)) count = 1 # Append the last character(s) result.append(s[-1]) if count > 1: result.append(str(count)) return \'\'.join(result)"},{"question":"# Scenario You are working on a data analysis project involving a list of strings representing various entries. You need to identify palindromes within this list. Understanding the implementation of palindrome detection will help students deepen their knowledge of string manipulation techniques. # Task Write a function `find_palindromes(words: list[str]) -> list[str]` that finds all the palindromes in a given list of strings. # Function Signature ```python def find_palindromes(words: list[str]) -> list[str] ``` # Input * A list of strings `words` where each element represents a word or phrase. All strings contain only lowercase letters and no spaces. # Output * A list of strings containing all elements from the input `words` that are palindromes. # Constraints * The input list `words` will have a length between 0 and 1000. * Each string in the list will have a length between 1 and 100 characters. # Example 1. For an input `words = [\'racecar\', \'level\', \'hello\', \'world\']` - The function should return `[\'racecar\', \'level\']` 2. For an input `words = [\'madam\', \'deified\', \'test\', \'rotor\']` - The function should return `[\'madam\', \'deified\', \'rotor\']` 3. For an input `words = []` - The function should return `[]` # Additional Requirements * The function should be able to identify palindromes efficiently within the given constraints. * The solution should handle edge cases such as an empty input list gracefully. ```python def find_palindromes(words: list[str]) -> list[str]: return [word for word in words if word == word[::-1]] ```","solution":"def find_palindromes(words: list[str]) -> list[str]: Finds all the palindromes in a given list of strings. Args: words (list[str]): A list of strings where each string is a word or phrase. Returns: list[str]: A list containing all palindromic strings from the input list. return [word for word in words if word == word[::-1]]"},{"question":"# Balanced Binary Search Tree (BST) Insertion and Search **Scenario**: You are developing a data storage system that requires fast insertion and retrieval of records. To ensure these operations are as efficient as possible, you decide to use a balanced Binary Search Tree (BST). Your task is to implement a balanced BST class in Python, supporting insertion of nodes and searching for values. **Task**: Implement a BalancedBST class in Python which supports inserting new values and searching for existing values. The tree should automatically balance itself after each insertion to maintain optimal search performance. **Function Signature**: ```python class BalancedBST: def __init__(self) -> None: pass def insert(self, value: int) -> None: pass def search(self, value: int) -> bool: pass ``` # Constraints: 1. **Inputs**: - `value`: Integer value to be inserted or searched in the BST. - BST operations are required for dynamic insertion and searching. 2. **Outputs**: - `insert`: Insert the given value into the BST. - `search`: Return `True` if the integer value is found in the BST, otherwise return `False`. **Example**: ```python # Examples of inserting and searching: bst = BalancedBST() # Insert values bst.insert(10) bst.insert(20) bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(30) # Search values print(bst.search(20)) # Expected output: True print(bst.search(15)) # Expected output: False # Check BST structure and balance # The exact structure check may not be trivial, but in a balanced tree, # the heights of left and right subtrees should not differ by more than one for every node. ``` # Performance Requirements: 1. Ensure the tree is balanced after each insertion to guarantee O(log n) time complexity for search operations. 2. Optimize the insertion process to maintain the tree\'s balance efficiently. 3. Handle edge cases such as inserting duplicate values by discarding them and ensuring the tree remains valid. # Note: 1. You can use AVL tree or Red-Black tree balancing methods to ensure the BST remains balanced after each insertion. 2. Implement any necessary helper methods within the BalancedBST class to keep the main methods concise and readable.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class BalancedBST: def __init__(self) -> None: self.root = None def insert(self, value: int) -> None: if not self.root: self.root = Node(value) else: self.root = self._insert(self.root, value) def search(self, value: int) -> bool: return self._search(self.root, value) is not None def _insert(self, root, key): if not root: return Node(key) if key < root.key: root.left = self._insert(root.left, key) elif key > root.key: root.right = self._insert(root.right, key) else: # Duplicate keys are not allowed return root root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) # Get balance factor balance = self._get_balance(root) # Left Left if balance > 1 and key < root.left.key: return self._right_rotate(root) # Right Right if balance < -1 and key > root.right.key: return self._left_rotate(root) # Left Right if balance > 1 and key > root.left.key: root.left = self._left_rotate(root.left) return self._right_rotate(root) # Right Left if balance < -1 and key < root.right.key: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def _search(self, root, key): if root is None or root.key == key: return root if key < root.key: return self._search(root.left, key) return self._search(root.right, key) def _left_rotate(self, z): y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) # Return the new root return y def _right_rotate(self, z): y = z.left T3 = y.right # Perform rotation y.right = z z.left = T3 # Update heights z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) # Return the new root return y def _get_height(self, root): if not root: return 0 return root.height def _get_balance(self, root): if not root: return 0 return self._get_height(root.left) - self._get_height(root.right)"},{"question":"# Coding Assessment Question You are given an integer array `arr` and an integer `k`. Your task is to write a function that rotates the array to the right by `k` positions. The rotation should be performed in-place, meaning you should not create a new array to perform this operation. # Function Signature ```python def rotate_array(arr: List[int], k: int) -> None: Rotate the array to the right by k steps in-place. :param arr: A list of integers. :param k: An integer representing the number of steps by which to rotate the array. :return: None ``` # Example ```python >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotate_array(arr, 3) >>> arr [5, 6, 7, 1, 2, 3, 4] >>> arr = [-1, -100, 3, 99] >>> rotate_array(arr, 2) >>> arr [3, 99, -1, -100] ``` # Input Constraints * The input list `arr` can have between 1 and ( 10^5 ) elements. * The integer `k` is non-negative and can be up to ( 10^5 ). # Requirements * Your solution must modify the array in-place with a time complexity of O(n) and a space complexity of O(1). # Edge Cases * Test with the smallest possible array (1 element). * Validate the behavior when `k` is larger than the length of the array (use modulus operation to handle such cases).","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> None: Rotate the array to the right by k steps in-place. :param arr: A list of integers. :param k: An integer representing the number of steps by which to rotate the array. :return: None n = len(arr) k = k % n # Handle the case when k is larger than the array length if k == 0: return # Reverse the entire array arr.reverse() # Reverse the first k elements arr[:k] = reversed(arr[:k]) # Reverse the remaining elements arr[k:] = reversed(arr[k:])"},{"question":"# Coding Question: Find the Index and Value of the Most Frequent Element Given an array of integers, your task is to implement two functions that return the index and value of the most frequent element and the element that appears the first time in the list if there are multiple elements with the same frequency. 1. **Function 1: `index_most_frequent(lst: list[int]) -> tuple[int, int]`**: * **Input**: A list of integers `lst`. * **Output**: A tuple `(index, value)` where `index` is the index of the most frequently occurring element, and `value` is the element itself. If there are multiple elements with the same frequency, return the one that appears first. * **Constraints**: The list has at least one element. 2. **Function 2: `first_occurrence(lst: list[int]) -> int`**: * **Input**: A list of integers `lst`. * **Output**: An integer representing the index of the first occurrence of `index_most_frequent(lst)`. It should call `index_most_frequent` and return the index. * **Constraints**: The list has at least one element. # Example ```python # Test case 1 lst = [3, 1, 4, 4, 5, 2, 2, 4] assert index_most_frequent(lst) == (2, 4) assert first_occurrence(lst) == 2 # Test case 2 lst = [2, 3, 2, 3, 3, 2, 2] assert index_most_frequent(lst) == (0, 2) assert first_occurrence(lst) == 0 # Test case 3 lst = [7] assert index_most_frequent(lst) == (0, 7) assert first_occurrence(lst) == 0 ``` # Your implementation should handle all edge cases, including: * Lists with a single element. * Lists where two or more elements have the same highest frequency but different values. * Lists where the elements appear more than once but not consecutively. * Handling elements with the same frequency correctly as per constraints.","solution":"from collections import Counter def index_most_frequent(lst): Returns the index and value of the most frequent element in the list. If there are multiple elements with the same frequency, returns the one that appears first. counter = Counter(lst) most_common_value, _ = counter.most_common(1)[0] index = lst.index(most_common_value) return index, most_common_value def first_occurrence(lst): Returns the index of the first occurrence of the most frequent element in the list. index, _ = index_most_frequent(lst) return index"},{"question":"# Coding Assessment Question **Objective**: Assess students\' ability to manipulate data structures and solve real-world computational problems. **Background**: An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For instance, \\"listen\\" and \\"silent\\" are anagrams of each other. An important problem in text analysis is finding all groups of words in a list that are anagrams of each other. **Task**: 1. **Function Implementation**: Implement a function called `group_anagrams` that: - Accepts a list of strings. - Returns a list of lists, where each inner list contains words that are anagrams of each other. 2. **Requirements**: - Ensure that the function handles cases with multiple groups of anagrams. - The output lists (groups of anagrams) and the words within those lists should be sorted in lexicographical order. 3. **Edge Cases**: Handle possible edge cases such as: - An empty input list. - Words that do not have any anagrams in the list. **Input/Output**: - Input: `group_anagrams(words: List[str]) -> List[List[str]]` - `words`: A list of strings containing only lowercase alphabets. - Output: Returns a list of lists where each sublist contains anagrams sorted in lexicographical order. **Constraints**: - 0 ≤ len(words) ≤ 10^4 - 1 ≤ len(words[i]) ≤ 100 **Performance Requirements**: - Your solution should efficiently handle the upper constraint on input size. # Example ```python def group_anagrams(words: List[str]) -> List[List[str]]: pass # Example Usage assert group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [ [\\"ate\\", \\"eat\\", \\"tea\\"], [\\"bat\\"], [\\"nat\\", \\"tan\\"] ] assert group_anagrams([]) == [] assert group_anagrams([\\"\\"]) == [[\\"\\"]] assert group_anagrams([\\"a\\"]) == [[\\"a\\"]] ``` Provide a well-commented and efficient solution to this problem.","solution":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams together from the input list. Args: words (List[str]): A list of strings to be grouped by anagram. Returns: List[List[str]]: A list of lists where each sublist contains anagrams sorted in lexicographical order. anagram_map = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_map[sorted_word].append(word) # Sort each group of anagrams and the overall list of groups return [sorted(group) for group in anagram_map.values()]"},{"question":"# Coding Assessment Question Context A logistics company wants to optimize the sorting of its delivery routes based on distance. Their current system sorts routes using a basic bubble sort algorithm, which is not efficient for large data sets. They require a more efficient sorting method to improve overall performance. Task Write a function `merge_sort_routes(routes: list[tuple[str, float]]) -> list[tuple[str, float]]` which sorts a list of routes based on distance using the merge sort algorithm. Each route is represented as a tuple containing a route name (a string) and a distance (a float). Your implementation must correctly handle an empty list and ensure optimal sorting performance for large lists. Input/Output Format * **Input**: A list of routes, where each route is a tuple consisting of a route name (string) and a distance (float). * **Output**: A list of tuples sorted by the distance in ascending order. Constraints 1. Handle edge cases such as an empty list or a list with a single route. 2. Ensure the implementation uses the merge sort algorithm for efficiency. 3. The route name can contain alphabets and spaces, and the distance is a non-negative float. Example ```python >>> merge_sort_routes([(\\"Route A\\", 120.5), (\\"Route B\\", 85.2), (\\"Route C\\", 67.9), (\\"Route D\\", 101.0)]) [(\\"Route C\\", 67.9), (\\"Route B\\", 85.2), (\\"Route D\\", 101.0), (\\"Route A\\", 120.5)] >>> merge_sort_routes([(\\"Route X\\", 45.0)]) [(\\"Route X\\", 45.0)] >>> merge_sort_routes([]) [] >>> merge_sort_routes([(\\"Route 1\\", 250.3), (\\"Route 2\\", 250.3), (\\"Route 3\\", 150.0)]) [(\\"Route 3\\", 150.0), (\\"Route 1\\", 250.3), (\\"Route 2\\", 250.3)] ```","solution":"def merge_sort_routes(routes): Sort a list of routes based on distance using the merge sort algorithm. :param routes: List of tuples, where each tuple contains a route name and a distance. :return: List of tuples sorted by the distance in ascending order. if len(routes) <= 1: return routes mid = len(routes) // 2 left_half = merge_sort_routes(routes[:mid]) right_half = merge_sort_routes(routes[mid:]) return merge(left_half, right_half) def merge(left, right): Merge two halves of the list, sorting by distance. :param left: Left half of the list. :param right: Right half of the list. :return: Merged and sorted list. sorted_list = [] i = 0 j = 0 while i < len(left) and j < len(right): if left[i][1] <= right[j][1]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 while i < len(left): sorted_list.append(left[i]) i += 1 while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"# Substring Permutations In this task, you are required to determine whether any permutation of a given string `s1` is a substring of another string `s2`. Write a function `check_permutation_substring` **Function Signature**: ```python def check_permutation_substring(s1: str, s2: str) -> bool: ``` **Input**: - A string `s1`: The string of which permutations are to be checked as substrings. - A string `s2`: The string in which to look for permutations of `s1`. **Output**: - A boolean `True` if any permutation of `s1` is a substring of `s2`, otherwise `False`. Constraints: - The length of `s1` is at most `10`, and contains only lowercase letters. - The length of `s2` is at most `10,000`, and contains only lowercase letters. Example ```python print(check_permutation_substring(\\"ab\\", \\"eidbaooo\\")) # expected output: True, (\\"ba\\" is a substring of \\"eidbaooo\\") print(check_permutation_substring(\\"ab\\", \\"eidboaoo\\")) # expected output: False print(check_permutation_substring(\\"adc\\", \\"dcda\\")) # expected output: True, (\\"dca\\" is a substring of \\"dcda\\") ``` Hints: - Use the sliding window technique to compare character counts for efficiency. - Keep track of character counts using dictionaries or arrays.","solution":"def check_permutation_substring(s1: str, s2: str) -> bool: from collections import Counter len1, len2 = len(s1), len(s2) if len1 > len2: return False s1_count = Counter(s1) window_count = Counter(s2[:len1]) if s1_count == window_count: return True for i in range(len1, len2): window_count[s2[i]] += 1 window_count[s2[i - len1]] -= 1 if window_count[s2[i - len1]] == 0: del window_count[s2[i - len1]] if s1_count == window_count: return True return False"},{"question":"# Question: Rotating Elements in an Array You are provided with an array of integers, where each element represents a unique identifier. Your task is to write a function that performs a right rotation on the array by a specified number of steps. A right rotation by one step shifts each element of the array to its right, and the last element moves to the first position. # Requirements: 1. **Function Signature:** ```python def rotate_array(arr: list[int], steps: int) -> list[int]: ``` 2. **Input:** * `arr`: A list of integers. * `steps`: An integer indicating the number of steps to rotate the array to the right. 3. **Output:** * Returns a list of integers representing the array after the specified number of right rotations. 4. **Constraints:** * The length of `arr` will be between 0 and (10^5). * `steps` will be a non-negative integer. 5. **Performance Requirements:** * Your approach should efficiently handle large input sizes up to the upper limit. * Aim for an (O(n)) time complexity solution with (O(n)) space complexity. # Examples: 1. **Example 1:** ```python arr = [1, 2, 3, 4, 5] steps = 2 output = [4, 5, 1, 2, 3] ``` The function should return `[4, 5, 1, 2, 3]`. 2. **Example 2:** ```python arr = [0, 0, 0] steps = 3 output = [0, 0, 0] ``` The function should return `[0, 0, 0]`. 3. **Example 3:** ```python arr = [1, 2, 3] steps = 5 output = [2, 3, 1] ``` The function should return `[2, 3, 1]`. 4. **Example 4:** ```python arr = [] steps = 1 output = [] ``` The function should return an empty list. # Starter Code: ```python def rotate_array(arr: list[int], steps: int) -> list[int]: n = len(arr) if n == 0: return arr steps = steps % n # Handles cases where steps are greater than the array length return arr[-steps:] + arr[:-steps] # You can add some basic testing here if __name__ == \\"__main__\\": test_arr = [1, 2, 3, 4, 5] test_steps = 2 print(rotate_array(test_arr, test_steps)) ```","solution":"def rotate_array(arr: list[int], steps: int) -> list[int]: n = len(arr) if n == 0: return arr steps = steps % n # This reduces unnecessary full rotations return arr[-steps:] + arr[:-steps]"},{"question":"# Understanding and Manipulating Binary Trees Objective Enhance your skills in tree data structures by implementing several key operations on a binary tree. Task Extend the given `BinaryTree` class by implementing the following functionalities: 1. **Node Insertion**: Implement a method to insert a node into the binary tree. The tree should remain a complete binary tree after each insertion. 2. **Tree Traversal Methods**: Implement Inorder, Preorder, and Postorder traversal methods. Each method should return a list of node values in the order they were visited. 3. **Height Calculation**: Implement a method to calculate the height of the binary tree. 4. **Level Order Traversal**: Implement a method to perform level order traversal of the binary tree. Requirements - Ensure proper error handling and raise appropriate exceptions for invalid operations. - Your methods should follow these signatures: ```python def insert(self, value: int) -> None: pass def inorder_traversal(self) -> list[int]: pass def preorder_traversal(self) -> list[int]: pass def postorder_traversal(self) -> list[int]: pass def height(self) -> int: pass def level_order_traversal(self) -> list[int]: pass ``` Input and Output Formats - **Node Insertion** (`insert`): - **Input**: Value of the node to be inserted (`int`). - **Output**: None. - **Tree Traversal Methods** (`inorder_traversal`, `preorder_traversal`, `postorder_traversal`): - **Input**: None. - **Output**: A list of node values in the order they were visited. - **Height Calculation** (`height`): - **Input**: None. - **Output**: Height of the tree (`int`). - **Level Order Traversal** (`level_order_traversal`): - **Input**: None. - **Output**: A list of node values in level order. Constraints - The number of nodes in the tree can be up to 1000. - Ensure your solutions handle edge cases and are optimized for performance on large inputs. Example ```python # Sample Binary Tree Definition class BinaryTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None # Implement the methods here # Creating a binary tree and testing methods binary_tree = BinaryTree() # Insert nodes to form the tree binary_tree.insert(1) binary_tree.insert(2) binary_tree.insert(3) binary_tree.insert(4) binary_tree.insert(5) # Perform traversals print(binary_tree.inorder_traversal()) # Example Output: [4, 2, 5, 1, 3] print(binary_tree.preorder_traversal()) # Example Output: [1, 2, 4, 5, 3] print(binary_tree.postorder_traversal()) # Example Output: [4, 5, 2, 3, 1] print(binary_tree.level_order_traversal()) # Example Output: [1, 2, 3, 4, 5] # Calculate height print(binary_tree.height()) # Output: 3 ``` Implement and test the functionalities with various binary tree structures to ensure correctness and efficiency.","solution":"class BinaryTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None def insert(self, value: int) -> None: new_node = self.Node(value) if not self.root: self.root = new_node return queue = [self.root] while queue: current = queue.pop(0) if not current.left: current.left = new_node return else: queue.append(current.left) if not current.right: current.right = new_node return else: queue.append(current.right) def inorder_traversal(self) -> list[int]: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result) def preorder_traversal(self) -> list[int]: result = [] self._preorder_traversal(self.root, result) return result def _preorder_traversal(self, node, result): if node: result.append(node.value) self._preorder_traversal(node.left, result) self._preorder_traversal(node.right, result) def postorder_traversal(self) -> list[int]: result = [] self._postorder_traversal(self.root, result) return result def _postorder_traversal(self, node, result): if node: self._postorder_traversal(node.left, result) self._postorder_traversal(node.right, result) result.append(node.value) def height(self) -> int: return self._height(self.root) def _height(self, node): if not node: return 0 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def level_order_traversal(self) -> list[int]: result = [] if not self.root: return result queue = [self.root] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result"},{"question":"# Array Rotation Coding Assessment Background You are tasked with implementing an efficient algorithm for rotating the elements of an array to the right by a given number of positions. This operation can be useful in various applications such as data manipulation, cyclic buffering, and array-based algorithms. Task Write a function `rotate_array` that rotates the elements of a given array to the right by `k` positions. Implementation Details * **Function Signature**: `def rotate_array(arr: list, k: int) -> list` * **Input**: * `arr`: A list of integers (0 ≤ len(arr) ≤ 10^5) * `k`: An integer (0 ≤ k ≤ 10^5) * **Output**: The list with elements rotated to the right by `k` positions. Function Specifics 1. Handle edge cases such as empty lists and cases where `k` is greater than the length of the list. 2. Use slicing to achieve the rotation efficiently. 3. Ensure the final rotated list has the same order of elements preserved but starting from the rotated position. Edge Cases * If the list is empty, return an empty list. * If `k` is 0, return the original list unchanged. * If `k` is greater than the length of the list, handle it by using `k % len(arr)` to determine the effective rotation. Example ```python def rotate_array(arr: list, k: int) -> list: n = len(arr) if n == 0 or k == 0: return arr k = k % n return arr[-k:] + arr[:-k] # Example Usage print(rotate_array([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(rotate_array([1, 2, 3, 4, 5], 7)) # Output: [4, 5, 1, 2, 3] print(rotate_array([], 3)) # Output: [] print(rotate_array([1, 2, 3], 0)) # Output: [1, 2, 3] ``` **Constraints**: * Time Complexity: O(n), where n is the length of the input array. * Space Complexity: O(n). Note This function should efficiently rotate large arrays and handle cases where the rotation count `k` is substantially larger than the array length gracefully by using modulo arithmetic.","solution":"def rotate_array(arr: list, k: int) -> list: Rotates the elements of an array to the right by k positions. Parameters: arr (list): The list of integers to be rotated. k (int): The number of positions to rotate the array. Returns: list: The rotated list. n = len(arr) if n == 0 or k == 0: return arr k = k % n return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement You are given a positive integer, and your task is to determine if it is a Harshad Number (a number that is divisible by the sum of its digits). # Detailed Instructions Implement the function `is_harshad(number: int) -> bool` which takes an integer `number` as input and returns a boolean indicating if the number is a Harshad Number. # Input * An integer `number` where 1 <= number <= 10^5. # Output * Return `True` if the given number is a Harshad Number, otherwise return `False`. # Example ```python assert is_harshad(18) == True # 18 is divisible by (1 + 8) == 9 assert is_harshad(20) == True # 20 is divisible by (2 + 0) == 2 assert is_harshad(19) == False # 19 is not divisible by (1 + 9) == 10 assert is_harshad(1) == True # 1 is divisible by 1 ``` # Constraints * `1 <= number <= 100000` * Aim to achieve a solution that is easy to understand and optimized for performance. # Notes 1. Consider edge cases such as numbers with digits summing to zero. 2. Ensure your solution works efficiently for the upper limit of the input range. Design your implementation to meet the given constraints efficiently. Employ best practices for readability and performance, ensuring correctness for all potential inputs.","solution":"def is_harshad(number: int) -> bool: Determine if the given number is a Harshad number. # Calculate the sum of the digits of the given number digit_sum = sum(int(digit) for digit in str(number)) # Check if the number is divisible by the sum of its digits return number % digit_sum == 0"},{"question":"# Coding Assessment Question You are a developer at a company that specializes in inventory management systems. One of your tasks is to implement a function that calculates the reorder level for a product. Create a function `reorder_level(daily_usage: float, lead_time_days: int, safety_stock: float) -> float` to compute the reorder level required to prevent stockouts, given the daily usage rate, the lead time in days (time taken to replenish stock), and a safety stock level. * **Input/Output Formats**: * **Input**: * `daily_usage` (float): The average daily usage of the product, must be greater than 0. * `lead_time_days` (int): The number of days it takes to restock, must be a positive integer. * `safety_stock` (float): The additional stock kept as a buffer, must be non-negative. * **Output**: * (float): The calculated reorder level. * **Constraints and Limitations**: * The function should raise exceptions with meaningful messages if the inputs are invalid: * If `daily_usage` is less than or equal to 0, raise Exception with the message \\"Daily usage must be > 0\\". * If `lead_time_days` is less than or equal to 0 or not an integer, raise Exception with the message \\"Lead time days must be an integer > 0\\". * If `safety_stock` is negative, raise Exception with the message \\"Safety stock must be >= 0\\". * **Performance Requirements**: * Ensure that the function runs efficiently with a time complexity of O(1) and a space complexity of O(1). * **Example**: ```python def reorder_level(daily_usage: float, lead_time_days: int, safety_stock: float) -> float: # your implementation here # Test Cases print(reorder_level(50, 10, 100)) # Expected output: 600.0 print(reorder_level(20, 7, 50)) # Expected output: 190.0 try: reorder_level(0, 10, 100) # Expected output: Exception(\\"Daily usage must be > 0\\") except Exception as e: print(e) try: reorder_level(50, 0, 100) # Expected output: Exception(\\"Lead time days must be an integer > 0\\") except Exception as e: print(e) try: reorder_level(50, 10, -5) # Expected output: Exception(\\"Safety stock must be >= 0\\") except Exception as e: print(e) ``` **Note**: The reorder level can be calculated using the following formula: `Reorder Level = (Daily Usage * Lead Time Days) + Safety Stock`.","solution":"def reorder_level(daily_usage: float, lead_time_days: int, safety_stock: float) -> float: Calculate the reorder level required to prevent stockouts. Parameters: - daily_usage (float): The average daily usage of the product. Must be > 0. - lead_time_days (int): The number of days it takes to restock. Must be an integer > 0. - safety_stock (float): The additional stock kept as a buffer. Must be >= 0. Returns: - float: The calculated reorder level. Raises: - Exception: If any input parameters are outside the allowed ranges. if daily_usage <= 0: raise Exception(\\"Daily usage must be > 0\\") if not isinstance(lead_time_days, int) or lead_time_days <= 0: raise Exception(\\"Lead time days must be an integer > 0\\") if safety_stock < 0: raise Exception(\\"Safety stock must be >= 0\\") reorder_level_value = (daily_usage * lead_time_days) + safety_stock return reorder_level_value"},{"question":"# Problem Statement You are tasked with implementing a function to calculate the frequency of characters in a given string, considering only alphabetical characters and ignoring case. # Functional Requirements Implement a function `char_frequency(text: str) -> dict` that: - Computes the frequency of each alphabetical character in the given string. - The function should be case-insensitive, meaning \'A\' and \'a\' are considered the same character. - The function should return a dictionary where the keys are the characters and the values are their corresponding counts. # Constraints - The `text` parameter can contain any ASCII characters. - Ignore non-alphabetical characters. - Process the string in a case-insensitive manner. # Example ```python def char_frequency(text: str) -> dict: frequency = {} for char in text.lower(): if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency # Test cases assert char_frequency(\\"Hello World!\\") == {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} assert char_frequency(\\"Python 3.8\\") == {\'p\': 1, \'y\': 1, \'t\': 1, \'h\': 1, \'o\': 1, \'n\': 1} assert char_frequency(\\"aAaA\\") == {\'a\': 4} ``` # Your Task Implement the `char_frequency` function according to the specifications above. Make sure your implementation correctly handles the case insensitivity and ignores non-alphabetical characters. Use the provided test cases to verify your implementation. **Note**: Be mindful of the constraints and ensure your solution is efficient.","solution":"def char_frequency(text: str) -> dict: Computes the frequency of each alphabetical character in the given string. The function is case-insensitive and ignores non-alphabetical characters. Parameters: text (str): The input string. Returns: dict: A dictionary with characters as keys and their frequency counts as values. frequency = {} for char in text.lower(): if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Scenario: You are developing a tool for data analysis that includes a feature to find the most common word in a given text. This feature is crucial for summarizing important keywords from large documents efficiently. # Task: Implement a Python function `find_most_common_word(text)` that identifies the most frequently occurring word in the provided text string. The function should exclude common stop words and should be case-insensitive. # Function Specification: Input: - `text` (string): A string containing the text to be analyzed. Output: - A dictionary with the following keys: * `\'word\'`: The most common word as a string. * `\'frequency\'`: The frequency of the most common word as an integer. Constraints: - Ignore punctuation marks. - Convert all words to lowercase for comparison. - Exclude common English stop words (e.g., \'the\', \'and\', \'is\', \'in\', \'to\', etc.). - Handle edge cases such as empty strings or ties (if multiple words have the same maximum frequency, you can return any one of them). # Example: ```python # Example usage result = find_most_common_word(\\"The quick brown fox jumps over the lazy dog. The dog barks loudly.\\") print(result) ``` Expected Output: ```python { \'word\': \\"dog\\", \'frequency\': 2 } ```","solution":"from collections import Counter import string def find_most_common_word(text): Identifies the most frequently occurring word in the provided text string. Ignores punctuation, case-insensitive, and excludes common English stop words. :param text: str :return: dict with keys \'word\' and \'frequency\' # Define common English stop words stop_words = {\\"i\\", \\"me\\", \\"my\\", \\"myself\\", \\"we\\", \\"our\\", \\"ours\\", \\"ourselves\\", \\"you\\", \\"your\\", \\"yours\\", \\"yourself\\", \\"yourselves\\", \\"he\\", \\"him\\", \\"his\\", \\"himself\\", \\"she\\", \\"her\\", \\"hers\\", \\"herself\\", \\"it\\", \\"its\\", \\"itself\\", \\"they\\", \\"them\\", \\"their\\", \\"theirs\\", \\"themselves\\", \\"what\\", \\"which\\", \\"who\\", \\"whom\\", \\"this\\", \\"that\\", \\"these\\", \\"those\\", \\"am\\", \\"is\\", \\"are\\", \\"was\\", \\"were\\", \\"be\\", \\"been\\", \\"being\\", \\"have\\", \\"has\\", \\"had\\", \\"having\\", \\"do\\", \\"does\\", \\"did\\", \\"doing\\", \\"a\\", \\"an\\", \\"the\\", \\"and\\", \\"but\\", \\"if\\", \\"or\\", \\"because\\", \\"as\\", \\"until\\", \\"while\\", \\"of\\", \\"at\\", \\"by\\", \\"for\\", \\"with\\", \\"about\\", \\"against\\", \\"between\\", \\"into\\", \\"through\\", \\"during\\", \\"before\\", \\"after\\", \\"above\\", \\"below\\", \\"to\\", \\"from\\", \\"up\\", \\"down\\", \\"in\\", \\"out\\", \\"on\\", \\"off\\", \\"over\\", \\"under\\", \\"again\\", \\"further\\", \\"then\\", \\"once\\", \\"here\\", \\"there\\", \\"when\\", \\"where\\", \\"why\\", \\"how\\", \\"all\\", \\"any\\", \\"both\\", \\"each\\", \\"few\\", \\"more\\", \\"most\\", \\"other\\", \\"some\\", \\"such\\", \\"no\\", \\"nor\\", \\"not\\", \\"only\\", \\"own\\", \\"same\\", \\"so\\", \\"than\\", \\"too\\", \\"very\\", \\"s\\", \\"t\\", \\"can\\", \\"will\\", \\"just\\", \\"don\\", \\"should\\", \\"now\\"} # Remove punctuation and convert to lowercase translator = str.maketrans(\'\', \'\', string.punctuation) cleaned_text = text.translate(translator).lower() # Split the text into words words = cleaned_text.split() # Filter out stop words filtered_words = [word for word in words if word not in stop_words] # Count word frequencies word_counts = Counter(filtered_words) # Find the most common word if word_counts: most_common_word, frequency = word_counts.most_common(1)[0] return {\'word\': most_common_word, \'frequency\': frequency} else: return {\'word\': None, \'frequency\': 0}"},{"question":"# Problem Statement You are working on a matrix manipulation project. For a part of it, you need to implement a function to rotate a given n x n matrix 90 degrees clockwise. # Function Specification **Function Name**: `rotate_matrix` **Input**: - `matrix`: A list of lists, where each list represents a row of a square matrix of integers. **Output**: - A list of lists representing the matrix rotated 90 degrees clockwise. # Constraints: - The size of the matrix, n, can be up to 1000. - Each element in the matrix is between -1000 and 1000 inclusive. # Requirements: - Your solution should have a time complexity of O(n^2). - Do not use any external libraries except `numpy`. # Examples 1. Example 1: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) ``` Output: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. Example 2: ```python matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix) ``` Output: ```python [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` 3. Example 3: ```python matrix = [ [-1, 0, 1], [2, -2, 2], [1, -1, 0] ] rotate_matrix(matrix) ``` Output: ```python [ [1, 2, -1], [-1, -2, 0], [0, 2, 1] ] ``` *Note*: The rotation should be performed in place if possible to optimize for space, but a new matrix may be created if needed for simplicity.","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise. Args: matrix: List of lists where each sublist is a row in the matrix. Returns: Rotated list of lists representing the matrix after rotating 90 degrees clockwise. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i] = matrix[i][::-1] return matrix"},{"question":"# Objective Implement a data structure that maintains a set of integers and allows querying the k-th smallest element efficiently. # Scenario In this problem, you need to implement a class `KthSmallestSet` that supports adding integers and retrieving the k-th smallest integer from the set. This task evaluates your knowledge of data structures, sorting algorithms, and efficient retrieval mechanisms. # Task - Implement the `KthSmallestSet` class with the following methods: 1. `add(self, value: int) -> None`: Adds an integer to the set. 2. `kth_smallest(self, k: int) -> int`: Returns the k-th smallest integer in the set. # Implementation Details 1. **Characteristics**: - The set must not contain duplicate integers. - Support efficient addition of integers and retrieval of the k-th smallest integer. 2. **Input/Output**: - `add`: Adds an integer to the set. - Input: value: int - Output: None - `kth_smallest`: Returns the k-th smallest integer from the set. - Input: k: int - Output: k-th smallest integer: int - If `k` is out of range (i.e., `k` less than 1 or greater than the size of the set), raise an appropriate exception. 3. **Constraints**: - All integer values are within the range of typical 32-bit integers. - The size of the set will not exceed 10^5 elements. - The operations should be optimized for both time and space complexity. # Example ```python kth_set = KthSmallestSet() kth_set.add(5) kth_set.add(3) kth_set.add(10) print(kth_set.kth_smallest(1)) # Output: 3 print(kth_set.kth_smallest(2)) # Output: 5 print(kth_set.kth_smallest(3)) # Output: 10 ``` 4. **Performance Requirements**: - Ensure the `add` operation remains efficient even as the size of the set increases. - The `kth_smallest` operation must be optimized to retrieve the k-th smallest element quickly.","solution":"import bisect class KthSmallestSet: def __init__(self): self.arr = [] def add(self, value: int) -> None: # Use binary search to maintain a sorted array if value not in self.arr: bisect.insort(self.arr, value) def kth_smallest(self, k: int) -> int: if k < 1 or k > len(self.arr): raise ValueError(\\"k is out of range\\") return self.arr[k - 1]"},{"question":"# Spiral Matrix - Extraction and Transformation You are provided with a function to extract elements of a 2D matrix in spiral order. The goal is to traverse the matrix and collect its elements into a single list following a spiral pattern, starting from the top-left corner and proceeding in a clockwise direction. **Task**: Implement the function to perform the spiral extraction from the 2D matrix and ensure it handles edge cases effectively. **Function Signature**: ```python def spiral_matrix(matrix: list) -> list: Extracts elements of a 2D matrix in spiral order. Args: matrix (list): A 2D list representing the matrix Returns: list: A list containing the elements in spiral order ``` **Input/Output**: - **Input**: A 2D list of integers. - **Output**: A list of integers representing the matrix elements in spiral order. **Constraints**: - The matrix can be empty. - Matrix dimensions are up to 100 x 100. - The matrix may contain negative numbers. - The matrix may be non-square (rows ≠ columns). **Performance**: - Aim to traverse the matrix in a single pass, minimizing the operational complexity. - The solution should be efficient enough to handle matrices at the upper constraint limits. **Examples**: ```python >>> spiral_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_matrix([ [1, 2], [3, 4], [5, 6] ]) [1, 2, 4, 6, 5, 3] >>> spiral_matrix([ [] ]) [] >>> spiral_matrix([ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ]) [-1, -2, -3, -6, -9, -8, -7, -4, -5] >>> spiral_matrix([ [1, 3, 5, 7], [2, 4, 6, 8] ]) [1, 3, 5, 7, 8, 6, 4, 2] ``` **Additional Challenge**: Optimize the algorithm to efficiently handle matrices at or near the upper constraint (100 x 100). Discuss potential optimization techniques and their impact on performance in the comments.","solution":"def spiral_matrix(matrix): Extracts elements of a 2D matrix in spiral order. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) left, right, top, bottom = 0, cols - 1, 0, rows - 1 spiral_order = [] while left <= right and top <= bottom: # Traverse from left to right along the top row for col in range(left, right + 1): spiral_order.append(matrix[top][col]) top += 1 # Traverse from top to bottom along the right column for row in range(top, bottom + 1): spiral_order.append(matrix[row][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for col in range(right, left - 1, -1): spiral_order.append(matrix[bottom][col]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for row in range(bottom, top - 1, -1): spiral_order.append(matrix[row][left]) left += 1 return spiral_order"},{"question":"# Problem Statement Create a function `ordered_insert` that inserts an element into a sorted list, while maintaining the sorted order. The function should handle both ascending and descending order lists. # Requirements 1. **Function Signature**: ```python def ordered_insert(lst: List[int], element: int, ascending: bool = True) -> List[int]: ``` 2. **Inputs**: * `lst` (List[int]): A list of integers that is already sorted in either ascending or descending order. * `element` (int): The integer value to insert into the list. * `ascending` (bool): A boolean flag indicating whether the list is sorted in ascending order (`True` by default) or descending order (`False`). 3. **Outputs**: * Returns a new list which includes the `element` inserted in the correct position while maintaining the sorted order. 4. **Constraints**: * The input list will always be sorted in either ascending or descending order as specified by the `ascending` parameter. * The list can contain negative numbers and duplicates. # Example Usage ```python >>> ordered_insert([1, 3, 4, 7], 5) [1, 3, 4, 5, 7] >>> ordered_insert([10, 8, 5, 3], 6, ascending=False) [10, 8, 6, 5, 3] >>> ordered_insert([-7, -3, 2, 8], -5) [-7, -5, -3, 2, 8] ``` # Additional Notes - Consider using a binary search approach to find the insert position efficiently. - Handle edge cases, such as inserting into an empty list or inserting elements that are already present in the list. - The function should not modify the original list but return a new list with the element inserted.","solution":"from typing import List def ordered_insert(lst: List[int], element: int, ascending: bool = True) -> List[int]: Inserts an element into a sorted list while maintaining the sorted order. Parameters: lst (List[int]): A list of integers that is already sorted. element (int): The integer value to insert into the list. ascending (bool): A boolean flag indicating whether the list is sorted in ascending order (True by default) or descending order (False). Returns: List[int]: A new list with the element inserted in the correct position. if not lst: return [element] left, right = 0, len(lst) if ascending: while left < right: mid = (left + right) // 2 if lst[mid] < element: left = mid + 1 else: right = mid else: while left < right: mid = (left + right) // 2 if lst[mid] > element: left = mid + 1 else: right = mid return lst[:left] + [element] + lst[left:]"},{"question":"# List Reordering Coding Assessment Background You have been provided a function that needs to reorder elements in a list based on their frequency. The goal of this exercise is to assess your understanding of data manipulation and sorting algorithms in Python. Task Your task is to implement a function: 1. `reorder_list_based_on_frequency(nums: List[int]) -> List[int]`: Reorders the given list so that elements that appear more frequently come before elements that appear less frequently. In case of ties, the elements should be ordered according to their first appearance in the list. Details: - The input list `nums` contains integers, which may include both positive and negative numbers and is non-empty. - The return list should retain the relative order of elements that have the same frequency. Input - `nums`: A list of integers. Output - A list of integers reordered according to their frequency. Examples ```python assert reorder_list_based_on_frequency([4, 1, -1, 2, -1, 2, 3]) == [-1, -1, 2, 2, 4, 1, 3] assert reorder_list_based_on_frequency([1, 2, 3, 4, 1, 2, 2, 3, 3]) == [2, 2, 2, 3, 3, 3, 1, 1, 4] ``` Requirements - Implement the reordering based on the frequency of elements. - Maintain the relative order of elements that have the same frequency. Constraints - The input list will be non-empty. - List length: 1 ≤ length of the list ≤ 10^5 - Elements in the list: -10^5 ≤ element value ≤ 10^5","solution":"from typing import List from collections import Counter def reorder_list_based_on_frequency(nums: List[int]) -> List[int]: Reorders elements in nums so that elements that appear more frequently come before elements that appear less frequently. In case of ties, elements are ordered based on their first appearance in the list. # Calculate the frequency of each element frequency = Counter(nums) # Sort elements first by frequency (in descending order), and then by their # original index in the list to maintain relative order for ties sorted_nums = sorted(nums, key=lambda x: (-frequency[x], nums.index(x))) return sorted_nums"},{"question":"# Coding Question Scenario You are working on a project that requires you to simulate a sequence of operations on a stack. A stack is a data structure that follows last-in, first-out (LIFO) principles, and only allows operations at one end — the top of the stack. Your task is to implement a function that processes a series of push and pop operations and then returns the state of the stack after each operation. Requirements Implement the function `simulate_stack_operations` which takes an initial list for the stack and a list of operations to be performed in sequence. The function should process each operation and return the state of the stack after each operation is applied. Function Signature ```python def simulate_stack_operations(initial_stack: list[int], operations: list[str]) -> list[list[int]]: ``` Input * `initial_stack`: A list of integers representing the initial state of the stack. * `operations`: A list of strings where each string is either `\'push X\'` (where `X` is an integer) or `\'pop\'`. Output * A list of lists, where each inner list represents the state of the stack after applying each operation in sequence. Constraints 1. Assume that pop operations will not be called on an empty stack. 2. You may not use any library functions for managing the stack (such as `collections.deque` or external stack libraries). 3. Assume that the length of `operations` will not exceed 100 and the `initial_stack` length will also not exceed 100. Example ```python >>> simulate_stack_operations([1, 2], [\'push 3\', \'pop\', \'push 4\', \'push 5\']) [[1, 2, 3], [1, 2], [1, 2, 4], [1, 2, 4, 5]] >>> simulate_stack_operations([], [\'push 1\', \'push 2\', \'pop\']) [[1], [1, 2], [1]] ``` Edge Cases 1. `initial_stack` is empty. 2. All operations are \'push\'. 3. All operations are \'pop\'. In this problem, you are required to simulate basic stack operations and track their states step-by-step, ensuring that the stack behaves as expected according to LIFO principles.","solution":"def simulate_stack_operations(initial_stack: list[int], operations: list[str]) -> list[list[int]]: stack = initial_stack[:] result = [] for operation in operations: if operation.startswith(\'push\'): _, value = operation.split() stack.append(int(value)) elif operation == \'pop\': stack.pop() result.append(stack[:]) # Append a copy of the current stack return result"},{"question":"# Question Context: As a developer, you are working on a web service that stores user activity logs. To optimize querying, you want to build a system capable of efficiently merging multiple log files and retrieving logs within a specific time range. # Coding Task: Implement a function `merge_logs` which takes as input a list of lists, where each inner list contains tuples representing log entries. Each tuple consists of a timestamp (an integer) and a log message (a string). The logs within each list are sorted by timestamps in non-decreasing order. The function should merge all logs into a single list, preserving the sorted order. # Input: * A list of lists, where each inner list contains tuples with each tuple having: - An integer (timestamp). - A string (log message). # Output: * A single list containing all log entries from the input lists, merged into non-decreasing order based on timestamps. # Constraints: * Each inner list of logs is sorted by timestamp. * The number of lists and the number of logs within each list can be large (at least 1), but you can assume the total number of logs across all lists fits into memory. * The timestamps are unique. # Performance Requirements: * Aim for an efficient solution in terms of both time and space complexity, leveraging appropriate algorithms for merging sorted lists. # Scenario: Consider the following example scenario to understand the task requirements: ```python def merge_logs(logs: List[List[Tuple[int, str]]]) -> List[Tuple[int, str]]: # Your implementation here pass # Example: logs = [ [(1, \\"Login\\"), (3, \\"Logout\\")], [(2, \\"PageView\\"), (4, \\"Click\\")], [(5, \\"Download\\")] ] # Calling the function should return the following list: # [(1, \\"Login\\"), (2, \\"PageView\\"), (3, \\"Logout\\"), (4, \\"Click\\"), (5, \\"Download\\")] print(merge_logs(logs)) # Output: [(1, \\"Login\\"), (2, \\"PageView\\"), (3, \\"Logout\\"), (4, \\"Click\\"), (5, \\"Download\\")] ``` Your function should efficiently merge the lists while maintaining the order of log entries based on their timestamps.","solution":"from heapq import heappop, heappush from typing import List, Tuple def merge_logs(logs: List[List[Tuple[int, str]]]) -> List[Tuple[int, str]]: Merges multiple lists of log entries, each sorted by timestamp, into a single sorted list. Args: logs (List[List[Tuple[int, str]]]): A list of lists, where each inner list contains tuples with each tuple having an integer (timestamp) and a string (log message). Returns: List[Tuple[int, str]]: A single list of logs, sorted by timestamp. min_heap = [] # Push the first element of each log into the min_heap along with their index positions for i, log in enumerate(logs): if log: heappush(min_heap, (log[0][0], i, 0, log[0][1])) # (timestamp, log_index, element_index, log_message) merged_logs = [] while min_heap: timestamp, log_index, element_index, log_message = heappop(min_heap) merged_logs.append((timestamp, log_message)) # If there is another log in the same list, push the next element onto the heap if element_index + 1 < len(logs[log_index]): next_log = logs[log_index][element_index + 1] heappush(min_heap, (next_log[0], log_index, element_index + 1, next_log[1])) return merged_logs"},{"question":"# Array Element Search Scenario You are working as a software developer and you need to solve a common problem in data structures: searching within a sorted array. Given a sorted array of unique integers and a target value, determine if the target value exists in the array. Implement a binary search algorithm to efficiently find the target value. Task Implement a function `binary_search` that determines if the target value is present in the sorted array. Use binary search technique, as it reduces the time complexity to O(log n). Function Signature ```python def binary_search(sorted_array: list[int], target: int) -> bool: pass ``` Parameters - `sorted_array (list[int])`: A sorted list of unique integers. - `target (int)`: The integer value to be searched within the sorted array. Returns - A boolean value: `True` if the target exists in the array, `False` otherwise. Constraints - The input list will contain at least one element and will not exceed 10^4 elements. - All integers in the list are unique and between -10^5 and 10^5. - The target integer will also be within the range -10^5 to 10^5. Examples - `binary_search(sorted_array=[-10, -5, 0, 3, 7, 9, 12, 15], target=3)` should return `True` - `binary_search(sorted_array=[-10, -5, 0, 3, 7, 9, 12, 15], target=8)` should return `False` - `binary_search(sorted_array=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=1)` should return `True` - `binary_search(sorted_array=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=10)` should return `True` - `binary_search(sorted_array=[-100000, -50000, 0, 49999, 99999], target=50000)` should return `False`","solution":"def binary_search(sorted_array: list[int], target: int) -> bool: Implements binary search to determine if the target exists in the sorted array. left, right = 0, len(sorted_array) - 1 while left <= right: mid = left + (right - left) // 2 # Check if target is present at mid if sorted_array[mid] == target: return True # If target is greater, ignore left half elif sorted_array[mid] < target: left = mid + 1 # If target is smaller, ignore right half else: right = mid - 1 # Target was not found in the array return False"},{"question":"# Problem Statement You are required to write a Python function that finds the highest prime factor of a given number `n`. The function should efficiently handle large values of `n` while following specific constraints described below. # Input - An integer `n` where 2 <= `n` <= 10^12 # Output - An integer representing the highest prime factor of `n`. # Constraints - The function should have a time complexity of O(sqrt(n)) for the primary factorization process. - The function should use optimized algorithms to check for primality and efficiently factorize the number. - Handle edge cases where `n` is already a prime number. # Example ```python >>> highest_prime_factor(10) 5 >>> highest_prime_factor(17) 17 >>> highest_prime_factor(60) 5 >>> highest_prime_factor(13195) 29 ``` # Hints 1. Consider using trial division up to the square root of `n` to identify factors efficiently. 2. Remember to handle both small and large prime numbers properly. 3. Optimize the primality test using known algorithms like the 6k ± 1 optimization. ```python def highest_prime_factor(n: int) -> int: Returns the highest prime factor of the given number n. Args: n (int): The number for which to find the highest prime factor. Returns: int: The highest prime factor of n. pass if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"import math def highest_prime_factor(n: int) -> int: Returns the highest prime factor of the given number n. Args: n (int): The number for which to find the highest prime factor. Returns: int: The highest prime factor of n. # Handle the smallest possible prime factor max_prime = -1 # Check if 2 is a factor while n % 2 == 0: max_prime = 2 n //= 2 # Check for odd factors from 3 upwards for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: max_prime = i n //= i # If n becomes a prime number greater than 2 if n > 2: max_prime = n return max_prime"},{"question":"# **Unique Character Extraction** Scenario: You have been asked to write a utility that processes a string to extract unique characters in the same order they appear in the string. This can be useful for text processing tools where unique character sequences are required. Task: Implement two methods, `extract_unique` and `count_unique`, in a class `UniqueCharProcessor`. The `extract_unique` method should return a string containing only the first occurrence of each character, preserving the original order. The `count_unique` method should return the number of unique characters in the string. Method Specifications: 1. **extract_unique(text: str) -> str** - **Input**: A string `text` that needs to be processed. - **Output**: A string containing only the unique characters from the input text in their first occurrence order. 2. **count_unique(text: str) -> int** - **Input**: A string `text` that needs to be analyzed. - **Output**: An integer representing the count of unique characters in the text. Constraints: - The methods should handle empty inputs gracefully. - Characters are case-sensitive and should be treated as unique based on their case. - Special characters and spaces should be included in the processing. Example: ```python from unique_char_processor import UniqueCharProcessor # assume the code is in a file named \'unique_char_processor.py\' # Extracting unique characters unique_sequence = UniqueCharProcessor.extract_unique(\\"Hello World\\") # unique_sequence should be \\"Helo Wrd\\" # Counting unique characters unique_count = UniqueCharProcessor.count_unique(\\"Hello World\\") # unique_count should be 8 # Check that extraction and counting are coherent assert unique_sequence == \\"Helo Wrd\\" assert unique_count == len(unique_sequence) ``` Your task is to implement these methods with the given specifications.","solution":"class UniqueCharProcessor: @staticmethod def extract_unique(text: str) -> str: seen = set() unique_chars = [] for char in text: if char not in seen: seen.add(char) unique_chars.append(char) return \'\'.join(unique_chars) @staticmethod def count_unique(text: str) -> int: return len(set(text))"},{"question":"# Scenario You are designing a security feature that involves generating a unique token for each user session. The token must be unique and should contain both timestamp information and a random component to ensure its uniqueness. # Problem Statement Implement a function `generate_token(user_id: int, timestamp: int) -> str` that takes in a user ID and a Unix timestamp (the number of seconds since January 1, 1970), and generates a unique token. The token should be a base64 encoded string which is a concatenation of the user ID, a hyphen, timestamp, another hyphen, and a random 8-digit hexadecimal number. # Input and Output Formats * The function will receive two integers, `user_id` and `timestamp`, as input parameters. * The function will return a string which is the base64 encoded version of the combined ID, timestamp, and random number. # Constraints * Both `user_id` and `timestamp` will be positive integers. * The generated token must be unique for each call. # Example Cases ```python import base64 >>> token = generate_token(12345, 1609459200) >>> decoded_token = base64.b64decode(token).decode(\'utf-8\') >>> \\"12345-1609459200-\\" in decoded_token True >>> token1 = generate_token(12345, 1609459200) >>> token2 = generate_token(12345, 1609459200) >>> token1 != token2 True >>> token = generate_token(54321, 1614556800) >>> decoded_token = base64.b64decode(token).decode(\'utf-8\') >>> \\"54321-1614556800-\\" in decoded_token True ``` # Additional Notes * Utilize Python\'s `random` module to generate the random hexadecimal number. * Ensure the function is deterministic with respect to `user_id` and `timestamp` but still produces different tokens on successive calls even with the same inputs. * Base64 encode the final string to ensure it is suitable for use as a token in a URL or other text-based format. ```python import base64 import random def generate_token(user_id: int, timestamp: int) -> str: random_hex = format(random.randint(0, 0xFFFFFFFF), \'08x\') token = f\\"{user_id}-{timestamp}-{random_hex}\\" encoded_token = base64.b64encode(token.encode(\'utf-8\')).decode(\'utf-8\') return encoded_token ```","solution":"import base64 import random def generate_token(user_id: int, timestamp: int) -> str: random_hex = format(random.randint(0, 0xFFFFFFFF), \'08x\') token = f\\"{user_id}-{timestamp}-{random_hex}\\" encoded_token = base64.b64encode(token.encode(\'utf-8\')).decode(\'utf-8\') return encoded_token"},{"question":"**Serialize and Deserialize Binary Tree** You are given the root node of a binary tree. Implement two functions to serialize and deserialize the binary tree. Serialization is the process of converting a binary tree into a string representation, and deserialization is the process of converting the string representation back into the original binary tree structure. Function Definitions: 1. **`serialize(root: TreeNode) -> str`** - **Input**: root: TreeNode - **Output**: A string representation of the binary tree. 2. **`deserialize(data: str) -> TreeNode`** - **Input**: data: str - **Output**: The root node of the binary tree reconstructed from the string representation. Constraints: - The number of nodes in the binary tree is in the range [0, 1000]. - Each node has a unique integer value. - Empty nodes are represented by the string \\"null\\" in the serialized string. Example: Given the binary tree: ``` 1 / 2 3 / 4 5 ``` 1. **Serialization**: \\"1,2,null,null,3,4,null,null,5,null,null\\" 2. **Deserialization**: The reconstructed binary tree matches the original tree structure. Use the provided `TreeNode` class for tree construction: ```python from __future__ import annotations from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right ``` Implement the given functions considering edge cases and optimizing for the constraints provided.","solution":"from __future__ import annotations from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right def serialize(root: TreeNode) -> str: Serializes a binary tree to a string. def helper(node): if node is None: result.append(\\"null\\") else: result.append(str(node.val)) helper(node.left) helper(node.right) result = [] helper(root) return \\",\\".join(result) def deserialize(data: str) -> TreeNode: Deserializes a string to a binary tree. def helper(): val = next(vals) if val == \\"null\\": return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node vals = iter(data.split(\\",\\")) return helper()"},{"question":"Context You are tasked with developing a function to handle data compression, specifically implementing the Run-Length Encoding (RLE) algorithm. RLE is a basic form of lossless data compression where sequences of the same data value (runs) are stored as a single data value and count. Task Your goal is to implement a function named `compress_rle` that compresses a given string using the RLE algorithm. Additionally, for practical usage, you also need to implement a function named `decompress_rle` to revert the compressed string back to its original form. Function Signatures ```python def compress_rle(input_string: str) -> str: ``` ```python def decompress_rle(encoded_string: str) -> str: ``` Input - `input_string`: A string consisting of alphanumeric characters. Length will range from 1 to 10^6 characters. Output - For `compress_rle`, return the RLE compressed version of the input string as a new string. - For `decompress_rle`, return the original string after decoding the RLE encoded input. Constraints - The `input_string` may contain upper and lower case characters, digits, and special characters. - The length of `input_string` should be between 1 and 1,000,000 characters. Example ```python input_string = \\"aaabbccc\\" compress_rle(input_string) # Output: \\"a3b2c3\\" encoded_string = \\"a3b2c3\\" decompress_rle(encoded_string) # Output: \\"aaabbccc\\" ``` Notes - Ensure to handle edge cases where the characters change frequently. - Consider the performance implications of string operations on large inputs. - The implementation of `decompress_rle` should be able to handle encoded strings with single digits (e.g., \\"a2b1c5\\" -> \\"aabccccc\\").","solution":"def compress_rle(input_string: str) -> str: Compresses the input string using Run-Length Encoding (RLE) algorithm. if not input_string: return \\"\\" compressed = [] count = 1 prev_char = input_string[0] for char in input_string[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) return \'\'.join(compressed) def decompress_rle(encoded_string: str) -> str: Decompresses the RLE encoded string back to its original form. if not encoded_string: return \\"\\" decompressed = [] count = \'\' for char in encoded_string: if char.isdigit(): count += char else: if count: decompressed.append(prev_char * int(count)) count = \'\' prev_char = char decompressed.append(prev_char * int(count)) return \'\'.join(decompressed)"},{"question":"# Problem Statement Write a function that takes a list of integers and returns the longest contiguous sublist where the absolute difference between any two consecutive integers is at most 1. If there are multiple sublists with the same maximum length, return the first one. # Function Signature ```python def longest_contiguous_sublist(nums: list[int]) -> list[int]: Finds the longest contiguous sublist where the absolute difference between any two consecutive integers is at most 1. Parameters: nums (list[int]): List of integers. Returns: list[int]: Longest contiguous sublist meeting the criteria. Example: >>> longest_contiguous_sublist([1, 2, 3, 2, 3, 4, 1, 0]) [1, 2, 3, 2, 3, 4] pass ``` # Constraints - The length of the `nums` list will be between 1 and 10^5. - Each element in the `nums` list is an integer between -10^5 and 10^5. # Performance Requirements - The solution should run in linear time relative to the length of the `nums` list. # Example Usage ```python assert longest_contiguous_sublist([1, 2, 3, 2, 3, 4, 1, 0]) == [1, 2, 3, 2, 3, 4] assert longest_contiguous_sublist([4, 6, 5, 7, 5, 6, 7, 8, 9]) == [5, 6, 7, 8, 9] assert longest_contiguous_sublist([7, 8, 9, 1, 2, 3, 4, 10, 2]) == [1, 2, 3, 4] ``` # Implementation Notes - Use a sliding window or two-pointer technique to maintain and expand the current valid sublist while iterating through the array. - Keep track of the maximum length sublist found and its starting position to return the correct result.","solution":"def longest_contiguous_sublist(nums): Finds the longest contiguous sublist where the absolute difference between any two consecutive integers is at most 1. Parameters: nums (list[int]): List of integers. Returns: list[int]: Longest contiguous sublist meeting the criteria. if not nums: return [] max_len = 1 current_len = 1 start_index = 0 best_start_index = 0 for i in range(1, len(nums)): if abs(nums[i] - nums[i - 1]) <= 1: current_len += 1 else: if current_len > max_len: max_len = current_len best_start_index = start_index start_index = i current_len = 1 if current_len > max_len: max_len = current_len best_start_index = start_index return nums[best_start_index:best_start_index + max_len]"},{"question":"# Problem Statement You are given a string representing an arithmetic expression that may contain nested parentheses. Your task is to evaluate this expression. The expression will follow these rules: 1. The expression contains non-negative single-digit integers, \'+\', \'-\', \'*\', \'/\', and parentheses \'(\' and \')\'. 2. The precedence of the operators follows the standard mathematical rules (multiplication and division have higher precedence over addition and subtraction). 3. All operations are integer-based, so you should use integer division for \'/\'. # Function Signature ```python def evaluate_expression(expression: str) -> int: @param: expression (string representation of an arithmetic expression) @return: the integer result of the evaluated expression Example: >>> evaluate_expression(\\"3+(2*2)\\") 7 >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"(3+(4*5))/2\\") 11 >>> evaluate_expression(\\"10+(2*3)-(5/5)\\") 15 pass ``` # Input/Output * **Input**: - A string `expression` that represents an arithmetic expression. * **Output**: - The integer result of evaluating the expression. # Constraints * The length of the expression will not exceed 10^4 characters. * The expression is guaranteed to be valid and parentheses will be balanced. # Performance Requirements * Aim for time complexity O(N) where N is the length of the expression, using a stack-based approach or shunting-yard algorithm to ensure that the evaluation is efficient given the constraints. # Scenario Consider using the function to evaluate dynamically generated arithmetic expressions in a programming environment, such as a language interpreter or a calculator application. The ability to handle nested expressions and respect operator precedence ensures robust and accurate computation of results.","solution":"def evaluate_expression(expression: str) -> int: Evaluates an arithmetic expression containing single-digit integers, \'+\', \'-\', \'*\', \'/\', and parentheses \'(\' and \')\'. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Integer division def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 values = [] operators = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() # pop \'(\' else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"# Problem Statement You are tasked with writing a function that checks whether a given string is a valid anagram of another string, but with the restriction that both strings must be of the same length. An anagram is formed by rearranging the letters of one string to make the other string, meaning both strings contain exactly the same letters with the same frequencies. # Requirements * Implement a function `is_anagram` that takes two strings as inputs and returns a boolean indicating whether they are anagrams of each other. * Handle both upper and lower case letters. * Ensure the algorithm\'s time complexity is O(n). # Input and Output * **Input**: Two strings `s1` and `s2`, both having the same length. For example: - \\"listen\\", \\"silent\\" - \\"triangle\\", \\"integral\\" - \\"apple\\", \\"papel\\" - \\"rat\\", \\"car\\" * **Output**: A boolean value indicating whether the two strings are anagrams. # Constraints 1. You may assume both input strings contain only alphabetic characters (a-z, A-Z). 2. Both strings will be of the same length but can be of any length within typical string limits. # Example Scenarios Example 1: * **Input**: `s1 = \\"listen\\"`, `s2 = \\"silent\\"` * **Output**: `True` Example 2: * **Input**: `s1 = \\"triangle\\"`, `s2 = \\"integral\\"` * **Output**: `True` Example 3: * **Input**: `s1 = \\"apple\\"`, `s2 = \\"papel\\"` * **Output**: `True` Example 4: * **Input**: `s1 = \\"rat\\"`, `s2 = \\"car\\"` * **Output**: `False` Write the function `is_anagram(s1: str, s2: str) -> bool` to determine if the two strings are anagrams of each other as described.","solution":"def is_anagram(s1, s2): Checks if two strings are anagrams of each other. :param s1: First string :param s2: Second string :return: True if the strings are anagrams, False otherwise if len(s1) != len(s2): return False # Create a dictionary to count the frequency of characters in s1 count = {} for char in s1: char = char.lower() if char in count: count[char] += 1 else: count[char] = 1 # Subtract the frequency of characters in s2 for char in s2: char = char.lower() if char in count: count[char] -= 1 if count[char] == 0: del count[char] else: return False # If the count dictionary is empty, strings are anagrams return len(count) == 0"},{"question":"**Context:** You are working on efficient text processing in a text editor. To achieve this, you need to efficiently track and manipulate the cursor position within a string, while keeping the runtime complexity of each operation low. # Task: Implement a class to manage a string with functionalities to simulate text editor operations. Your editor should support the following operations: - `move_cursor(position)`: Moves the cursor to the specified `position` (0-based index). - `insert(character)`: Inserts the given `character` at the current cursor position and moves the cursor right. - `delete()`: Deletes the character at the current cursor position and the cursor stays at the same position. - `get_content()`: Returns the current contents of the string. - `get_cursor()`: Returns the current position of the cursor. # Specifications: 1. Implement the text editor such that: - `move_cursor` operation has O(1) time complexity. - `insert` and `delete` operations have O(n) amortized time complexity, where n is the length of the string. 2. Handle all edge cases mentioned. # Input and Output: Your methods must match the following signatures: - `move_cursor(position: int) -> None` - `insert(character: str) -> None` - `delete() -> None` - `get_content() -> str` - `get_cursor() -> int` # Constraints: - Assume all characters are single lowercase letters (\'a\' to \'z\'). - Maximum length of the string: 10^5. - `position` is guaranteed to be a valid index within the current length of the string, including 0 for an empty string. - Each `delete` operation should not throw errors if the cursor is at the end of the string. **Example:** ```python editor = TextEditor() editor.insert(\'a\') editor.insert(\'b\') editor.insert(\'c\') assert editor.get_content() == \'abc\' assert editor.get_cursor() == 3 editor.move_cursor(1) editor.delete() assert editor.get_content() == \'ac\' assert editor.get_cursor() == 1 editor.insert(\'d\') editor.move_cursor(2) editor.insert(\'e\') assert editor.get_content() == \'adec\' assert editor.get_cursor() == 3 ```","solution":"class TextEditor: def __init__(self): self.content = [] self.cursor = 0 def move_cursor(self, position: int) -> None: self.cursor = position def insert(self, character: str) -> None: self.content = self.content[:self.cursor] + [character] + self.content[self.cursor:] self.cursor += 1 def delete(self) -> None: if self.cursor < len(self.content): del self.content[self.cursor] def get_content(self) -> str: return \'\'.join(self.content) def get_cursor(self) -> int: return self.cursor"},{"question":"**Scenario**: You are tasked with writing a function that computes the nth number in a specific sequence known as the \\"Tribonacci sequence\\". The exercise will test your understanding of dynamic programming concepts and efficient computation for sequences. **Problem Statement**: Write a function `tribonacci(n: int) -> int` that calculates the nth number in the Tribonacci sequence, where each term is the sum of the three preceding ones, starting from 0, 1, 1. For example, the sequence starts as 0, 1, 1, 2, 4, 7, 13, 24,... # Function Signature ```python def tribonacci(n: int) -> int: ``` # Input * `n` (0 <= n <= 37): An integer representing the position in the Tribonacci sequence. # Output * An integer representing the nth number in the Tribonacci sequence. # Constraints * Ensure your solution is efficient in terms of both time and space. * Consider edge cases when `n` is very small. # Example ```python >>> tribonacci(0) 0 # The 0th element in the Tribonacci sequence is 0. >>> tribonacci(1) 1 # The 1st element in the Tribonacci sequence is 1. >>> tribonacci(2) 1 # The 2nd element in the Tribonacci sequence is 1. >>> tribonacci(3) 2 # The 3rd element in the Tribonacci sequence is 2. >>> tribonacci(4) 4 # The 4th element in the Tribonacci sequence is 4. >>> tribonacci(25) 1389537 # The 25th element in the Tribonacci sequence is 1389537. ``` # Note - Pay attention to how you handle the initial values of the sequence. - Validate the function with different values of `n` to ensure correctness and efficiency.","solution":"def tribonacci(n: int) -> int: Returns the nth number in the Tribonacci sequence. if n == 0: return 0 if n == 1 or n == 2: return 1 # Initialize the first three numbers of the Tribonacci sequence trib = [0, 1, 1] # Calculate the nth number by adding the last three numbers of the current list for i in range(3, n + 1): next_val = trib[-1] + trib[-2] + trib[-3] trib.append(next_val) return trib[n]"},{"question":"# Coding Assessment Question Scenario You are developing a library for date and time manipulation and need a function to determine if a given year is a leap year. A leap year is exactly divisible by 4 except for end-of-century years, which must be divisible by 400. This means that the years 2000 and 2400 are leap years, but 1900, 2100, 2200, and 2300 are not. Task Implement a function `is_leap_year` that determines if a given year is a leap year. Input - An integer `year` representing the year (1 ≤ year ≤ 9999). Output - A boolean value `True` if the year is a leap year, `False` otherwise. Constraints - The input year is a positive integer between 1 and 9999 inclusive. Examples ```python >>> is_leap_year(2000) True >>> is_leap_year(1900) False >>> is_leap_year(2024) True >>> is_leap_year(2100) False >>> is_leap_year(2400) True >>> is_leap_year(2021) False ``` Implementation ```python def is_leap_year(year: int) -> bool: Determine if a given year is a leap year. :param year: An integer representing the year :return: True if the year is a leap year, False otherwise if (year % 4 == 0): if (year % 100 == 0): if (year % 400 == 0): return True else: return False else: return True else: return False # Sample test cases to validate your function assert is_leap_year(2000) == True assert is_leap_year(1900) == False assert is_leap_year(2024) == True assert is_leap_year(2100) == False assert is_leap_year(2400) == True assert is_leap_year(2021) == False print(\\"All tests passed!\\") ```","solution":"def is_leap_year(year: int) -> bool: Determine if a given year is a leap year. :param year: An integer representing the year :return: True if the year is a leap year, False otherwise if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False"},{"question":"# Scientific Computation and Data Analysis Task You are working on a project that involves analyzing Earthquake data and determining statistical insights from it. You need to create a function that processes a dataset of earthquake events and provides various statistics. Your goal is to write a function called `analyze_earthquake_data` that performs the following tasks: 1. **Calculate Average Magnitude**: Computes the average magnitude of all earthquake events. 2. **Count Significant Earthquakes**: Determines how many earthquakes had a magnitude above a given threshold. 3. **Find Largest Earthquake**: Identifies the earthquake event with the largest magnitude. # Function Signature ```python def analyze_earthquake_data(data: List[Dict], threshold: float) -> Tuple[float, int, Dict]: Analyzes earthquake data to compute various statistics. Parameters: - data (List[Dict]): A list of dictionaries, each representing an earthquake event with at least a \\"magnitude\\" key. - threshold (float): The magnitude threshold to count significant earthquakes. Returns: - Tuple[float, int, Dict]: A tuple containing the average magnitude, the count of significant earthquakes, and the largest earthquake event. ``` # Requirements 1. Calculate the average magnitude of all earthquake events in the data list. 2. Count how many earthquake events had a magnitude above the given threshold. 3. Determine the event with the highest magnitude. # Constraints - Assume all dictionaries in the data list have a key `\\"magnitude\\"` with a float value. - If the data list is empty, return `(0.0, 0, {})`. - Handle cases where the magnitude values are not valid numbers gracefully. # Example ```python earthquake_data = [ {\\"id\\": \\"event1\\", \\"magnitude\\": 4.5, \\"location\\": \\"California\\"}, {\\"id\\": \\"event2\\", \\"magnitude\\": 2.8, \\"location\\": \\"Nevada\\"}, {\\"id\\": \\"event3\\", \\"magnitude\\": 5.9, \\"location\\": \\"Alaska\\"}, {\\"id\\": \\"event4\\", \\"magnitude\\": 3.2, \\"location\\": \\"Mexico\\"}, {\\"id\\": \\"event5\\", \\"magnitude\\": 6.1, \\"location\\": \\"Japan\\"} ] average_magnitude, significant_count, largest_earthquake = analyze_earthquake_data(earthquake_data, 5.0) print(average_magnitude) # Expected output: 4.5 print(significant_count) # Expected output: 2 print(largest_earthquake) # Expected output: {\\"id\\": \\"event5\\", \\"magnitude\\": 6.1, \\"location\\": \\"Japan\\"} ```","solution":"from typing import List, Dict, Tuple def analyze_earthquake_data(data: List[Dict], threshold: float) -> Tuple[float, int, Dict]: Analyzes earthquake data to compute various statistics. Parameters: - data (List[Dict]): A list of dictionaries, each representing an earthquake event with at least a \\"magnitude\\" key. - threshold (float): The magnitude threshold to count significant earthquakes. Returns: - Tuple[float, int, Dict]: A tuple containing the average magnitude, the count of significant earthquakes, and the largest earthquake event. if not data: return (0.0, 0, {}) total_magnitude = 0.0 significant_count = 0 largest_earthquake = None for event in data: try: magnitude = float(event[\\"magnitude\\"]) except (KeyError, ValueError, TypeError): continue total_magnitude += magnitude if magnitude > threshold: significant_count += 1 if largest_earthquake is None or magnitude > largest_earthquake[\\"magnitude\\"]: largest_earthquake = event average_magnitude = total_magnitude / len(data) return (average_magnitude, significant_count, largest_earthquake)"},{"question":"Scenario You are working on a project that involves processing text documents. The objective is to find the unique longest word (case-insensitive) in a provided text. If there are multiple words with the same maximum length, your task is to return the first one encountered. Function Specification # Function Name `find_longest_word` # Inputs - `text` (str): A string of characters, possibly including punctuation and whitespace. # Output - The longest unique word (case-insensitive). # Constraints - The input string will have at most 10,000 characters. - Words are defined as contiguous sequences of alphabetic characters (`a-zA-Z`). - Ignore punctuation marks and treat them as delimiters between words. - Digits and other non-alphabetical symbols are to be excluded from consideration as part of words. # Example Cases Example 1 ```python assert find_longest_word(\\"The quick brown fox jumped over the lazy dogs.\\") == \\"jumped\\" ``` Example 2 ```python assert find_longest_word(\\"Hello! Is anyone there? This— is a text... with various delimiters.\\") == \\"delimiters\\" ``` Example 3 ```python assert find_longest_word(\\"He said, \'It’s an emergency!\' and left.\\") == \\"emergency\\" ``` Example 4 ```python assert find_longest_word(\\"Life, liberty and the pursuit of happiness.\\") == \\"happiness\\" ``` Notes - The function should handle text in a case-insensitive manner. - The result should return the word in its original casing as it appears in the text. - It is important to efficiently handle the constraints of the input size.","solution":"import re def find_longest_word(text): Finds the longest unique word in the input text. If multiple words have the same maximum length, return the first one encountered. The search is case-insensitive but retains the original casing for the result. Parameters: text (str): A string of characters, possibly including punctuation and whitespace. Returns: str: The longest unique word. # Use regex to find all words (sequences of alphabetic characters) words = re.findall(r\'[a-zA-Z]+\', text) # Create a set for uniqueness and transform words to lower case for comparison seen = set() longest_word = \\"\\" for word in words: lower_word = word.lower() if lower_word not in seen: seen.add(lower_word) if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"# Coding Question: Rotational Cipher **Scenario**: You are working on adding a new feature to a communication application that involves encrypting messages. One common encryption technique is the Caesar cipher, which shifts each letter of the plaintext by a fixed number of positions down the alphabet. Your task is to extend this concept to create a rotational cipher for an alphanumeric string. In this cipher, each letter is shifted forward by a certain number of positions, wrapping around if necessary, and each digit is similarly shifted. # Problem: Implement a function `rotational_cipher` that encrypts a given alphanumeric string using a rotational cipher with a specified rotation factor. The function should leave non-alphanumeric characters unchanged. # Requirements: 1. Shift each letter in the input string by the rotation factor, maintaining the case (i.e., shift for `a-z` and `A-Z` separately). 2. Shift each digit by the rotation factor, wrapping around if necessary. 3. Non-alphanumeric characters should remain unchanged in the output. # Function Signature: ```python def rotational_cipher(input_str: str, rotation_factor: int) -> str: Encrypt the input string using a rotational cipher. Args: input_str (str): The string to be encrypted. rotation_factor (int): The rotation factor for the cipher. Returns: str: The encrypted string. Examples: >>> rotational_cipher(\\"Zebra-493?\\", 3) \'Cheud-726?\' >>> rotational_cipher(\\"abcXYZ123\\", 2) \'cdeZAB345\' ``` # Constraints: - The input string contains only printable ASCII characters. - The length of the input string does not exceed (10^4) characters. - The rotation factor is a non-negative integer. # Examples 1. **Input**: `\\"Zebra-493?\\"`, 3 **Output**: `\'Cheud-726?\'` *Explanation*: Z->C, e->h, b->e, r->u, a->d, 4->7, 9->2, 3->6. 2. **Input**: `\\"abcXYZ123\\"`, 2 **Output**: `\'cdeZAB345\'` *Explanation*: a->c, b->d, c->e, X->Z, Y->A, Z->B, 1->3, 2->4, 3->5. ```python def rotational_cipher(input_str: str, rotation_factor: int) -> str: def rotate_char(c, rotation_factor): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + rotation_factor) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + rotation_factor) % 26 + ord(\'A\')) elif \'0\' <= c <= \'9\': return chr((ord(c) - ord(\'0\') + rotation_factor) % 10 + ord(\'0\')) return c return \'\'.join(rotate_char(c, rotation_factor) for c in input_str) ```","solution":"def rotational_cipher(input_str: str, rotation_factor: int) -> str: Encrypt the input string using a rotational cipher. Args: input_str (str): The string to be encrypted. rotation_factor (int): The rotation factor for the cipher. Returns: str: The encrypted string. def rotate_char(c, rotation_factor): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + rotation_factor) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + rotation_factor) % 26 + ord(\'A\')) elif \'0\' <= c <= \'9\': return chr((ord(c) - ord(\'0\') + rotation_factor) % 10 + ord(\'0\')) return c return \'\'.join(rotate_char(c, rotation_factor) for c in input_str)"},{"question":"# Average Temperature Calculation Meteorologists often need to calculate the average temperature over different periods to identify trends and anomalies. Your task is to implement a function `average_temperature(temperatures: List[float]) -> float` that computes the average of a list of temperature readings. # Input * `temperatures` (List[float]): A list of temperature readings in degrees Celsius. The list can contain zero or more readings and values can be negative or positive. # Output * Returns the average of the temperature readings as a float. If the list is empty, return `0.0`. # Constraints 1. The function should handle an empty list by returning `0.0`. 2. The function should be able to process lists with one or more temperature readings. 3. Ensure the average is calculated accurately and efficiently. # Examples ```python >>> average_temperature([30.0, 32.0, 31.0, 28.0, 35.0]) 31.2 >>> average_temperature([-10.0, 0.0, 10.0]) 0.0 >>> average_temperature([25.5]) 25.5 >>> average_temperature([]) 0.0 >>> average_temperature([-5.0, -15.0, -10.0, -20.0]) -12.5 >>> average_temperature([15.1, 16.1, 15.9, 16.4]) 15.875 ``` # Additional Information - The function should handle both Celsius and Fahrenheit readings, but for simplicity, assume all input values are in Celsius. - The average should be calculated as the sum of all temperatures divided by the number of readings. - Make sure to handle any potential edge cases, such as very high or very low temperature values.","solution":"from typing import List def average_temperature(temperatures: List[float]) -> float: Returns the average of the temperature readings. If the list is empty, return 0.0. if not temperatures: return 0.0 return sum(temperatures) / len(temperatures)"},{"question":"Question You are tasked with implementing a function that takes a list of lists representing a 2D grid of land and water, and counts the number of distinct islands. An island is defined as a group of adjacent land cells (`1`) connected vertically or horizontally. Water is represented by `0`. # Function Signature ```python def count_islands(grid: List[List[int]]) -> int: pass ``` # Input - **grid**: A list of lists, where each inner list represents a row in a grid consisting of integers `0` and `1`. # Output - Returns the number of distinct islands in the grid as an integer. # Constraints - The input `grid` will have at least 1 row and at least 1 column. - The number of rows and columns will not exceed 1000. - Each cell in the grid will contain either a `0` or a `1`. # Example ```python count_islands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1]]) # Output: 5 count_islands([[1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]]) # Output: 1 ``` # Note - Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) to explore and mark visited land cells, ensuring each cell is visited only once. - Handle edge cases such as grids with no land (`1`) at all or grids completely filled with land.","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: if not grid: return 0 rows = len(grid) cols = len(grid[0]) # Directions for exploring adjacent cells (up, down, left, right). directions = [(-1,0), (1,0), (0,-1), (0,1)] def dfs(r, c): stack = [(r, c)] while stack: row, col = stack.pop() if 0 <= row < rows and 0 <= col < cols and grid[row][col] == 1: grid[row][col] = 0 # Mark as visited for dr, dc in directions: stack.append((row + dr, col + dc)) islands = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Found an island islands += 1 dfs(r, c) # Mark the whole island as visited return islands"},{"question":"# Question: Find the Diameter of a Binary Tree Scenario In computational biology, modeling evolutionary trees (phylogenetic trees) is an essential task. One aspect is to measure the \\"diameter\\" of these trees, which is defined as the longest path between any two nodes in the tree. You are tasked with implementing an algorithm to find the diameter of such a tree. The tree to be analyzed will be represented as a binary tree data structure. Task Implement a function `find_diameter(root: TreeNode) -> int` that computes the diameter of a binary tree. The diameter of a binary tree is the length of the longest path between any two nodes in the tree. This path might or might not pass through the root node. Constraints * The number of nodes in the tree will be between `1` and `10^4`. * The value of each node will be an integer between `-10^5` and `10^5`. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(find_diameter(root)) # Output: 3 (The longest path is 4 -> 2 -> 1 -> 3 or 5 -> 2 -> 1 -> 3) # Example 2 root = TreeNode(1) root.left = TreeNode(2) print(find_diameter(root)) # Output: 1 (The longest path is 2 -> 1) ``` Note * Assume you have a class `TreeNode` for representing binary tree nodes as shown in the example above. * The function `find_diameter` should return an integer representing the diameter of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_diameter(root: TreeNode) -> int: Computes the diameter of a binary tree. The diameter is the length of the longest path between any two nodes in the tree. :param root: TreeNode - The root of the binary tree. :return: int - The diameter of the binary tree. def depth(node): nonlocal max_diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) max_diameter = max(max_diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 max_diameter = 0 depth(root) return max_diameter"},{"question":"# Combinations of Phone Digits Problem Statement You are given a string containing digits from 2 to 9 inclusive. Your task is to return all possible letter combinations that the number could represent on a phone\'s keypad. The mapping of digits to letters is as follows: - 2: \'abc\' - 3: \'def\' - 4: \'ghi\' - 5: \'jkl\' - 6: \'mno\' - 7: \'pqrs\' - 8: \'tuv\' - 9: \'wxyz\' Note that 1 does not map to any letters. Function Signature ```python def letter_combinations(digits: str) -> List[str]: ``` Input - `digits`: A string containing digits (2-9). Output - A list of strings, where each string represents a possible letter combination. Example ```python print(letter_combinations(\\"23\\")) # Output: [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] print(letter_combinations(\\"\\")) # Output: [] print(letter_combinations(\\"2\\")) # Output: [\\"a\\", \\"b\\", \\"c\\"] ``` Constraints - The length of the input string is in the range [0, 4]. - The input string only contains digits from 2 to 9. Additional Information - The order of the combinations in the output list does not matter. - If the input string is empty, return an empty list. Hints - Consider using a recursive approach to build the combinations. - You may also use an iterative method with a queue to generate the combinations.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string of digits from 2 to 9, return all possible letter combinations that the number could represent on a phone\'s keypad. if not digits: return [] digit_to_letters = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return possible_letters = digit_to_letters[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"# Coding Question: Longest Consecutive Sequence in a 2D Grid **Context**: Handling and processing two-dimensional arrays (grids) are common in various domains like image processing, game development, and scientific computations. This problem focuses on navigating a grid to identify patterns. **Problem Statement**: Write a function `longest_consecutive_sequence(grid: List[List[int]]) -> int` that takes a 2D grid of integers where each cell contains a unique integer. Your function should find the longest consecutive sequence of numbers that can be formed by moving up, down, left, or right to neighboring cells. **Function Signature**: ```python def longest_consecutive_sequence(grid: List[List[int]]) -> int: # your code here ``` **Input**: * `grid` (List[List[int]]): A 2D list of integers with unique elements. **Output**: * (int): The length of the longest consecutive sequence. **Constraints**: * The grid will have a non-negative number of rows and columns (can be a zero-sized grid). * Integers in the grid are unique. **Example**: Given the grid: ``` [ [1, 2, 9], [5, 3, 8], [4, 6, 7] ] ``` Calling `longest_consecutive_sequence([[1, 2, 9], [5, 3, 8], [4, 6, 7]])` would return `4`, corresponding to the sequence `1-2-3-4`. **Edge Cases**: * Handle when the grid has no rows and no columns (return 0). * Handle when the grid is very large efficiently. **Notes**: - You need to explore the grid in all four possible directions: up, down, left, right. - The function should handle grids of different shapes and sizes. - Consider optimizing your approach to avoid repeated calculations.","solution":"def longest_consecutive_sequence(grid): if not grid or not grid[0]: return 0 def dfs(x, y): if (x, y) in memo: return memo[(x, y)] max_len = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == grid[x][y] + 1: max_len = max(max_len, 1 + dfs(nx, ny)) memo[(x, y)] = max_len return max_len memo = {} return max(dfs(x, y) for x in range(len(grid)) for y in range(len(grid[0])))"},{"question":"# Question: Maximum Length of Consecutive Increasing Subarray You are given an integer array, representing a sequence of numbers. Write a Python function to compute the length of the longest subarray that consists of consecutively increasing numbers within the given array. Function Signature ```python def longest_consecutive_increasing_subarray(arr: List[int]) -> int: ``` # Input * `arr` - a list of integers representing the sequence of numbers. # Output * Return an integer representing the length of the longest consecutively increasing subarray. # Constraints * The length of the array will be at least 1 and no more than 10,000. * The numbers in the array can range between -10,000 to 10,000. * The elements of the array are not necessarily distinct. # Example Given the following array: ```python arr = [1, 2, 2, 3, 4, 5, 1, 2, 3, 2, 4, 5, 6, 7] ``` Your function, when called as `longest_consecutive_increasing_subarray(arr)`, should return `5`, as the longest consecutively increasing subarray is `[2, 3, 4, 5, 6, 7]` which has a length of 5. # Additional Information: * The function should properly handle cases where the array contains descending sequences or same-valued elements. * Ensure efficient traversal of the array to handle the computations quickly. # Implementation Guidelines: - Utilize simple looping constructs to iterate through the array. - Keep track of the current length of consecutive increasing subarray and update the maximum length as needed. - Ensure checking of boundary conditions to avoid index errors. - Aim for a time complexity of O(n) where n is the length of the array.","solution":"def longest_consecutive_increasing_subarray(arr): Returns the length of the longest consecutively increasing subarray. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Question: Develop a Generic Framework for Custom Operations in Reverse Mode Automatic Differentiation Context The current implementation of the `Variable`, `Operation`, and `GradientTracker` classes supports a set of predefined operations and their gradients. To enhance flexibility and extensibility, you are required to develop a mechanism that allows users to define their own custom operations and gradients within this framework. Task 1. **Define Custom Operations**: Extend the framework to allow the definition and integration of custom operations by the user. 2. **Attach Custom Gradients**: Ensure that users can specify how the gradients should be computed for their custom operations. 3. **Framework Integration**: Seamlessly integrate these custom operations into the existing gradient tracking system without altering the existing functionality. Requirements 1. **Custom Operations**: * Implement a mechanism for users to define custom operations, specifying the forward computation. * Allow users to register these operations within the `Variable` class. 2. **Custom Gradients**: * Enable users to specify the gradient computation logic for the custom operations. * Ensure the system correctly invokes this custom gradient logic during backpropagation. 3. **Integration**: * Ensure the new custom operations operate within the same framework as predefined operations, maintaining the integrity of the computation graph. * Provide examples demonstrating the usage of custom operations and gradients. Constraints * The implementation should avoid significant performance overhead. * Custom operations should be as efficient as the predefined ones. * Ensure error handling for invalid custom operation definitions. Example Usage Here is how custom operations and gradients should be used in the extended framework: ```python # Define a custom operation and gradient def custom_tanh(x): return np.tanh(x) def custom_tanh_grad(x, grad_output): return grad_output * (1 - np.tanh(x) ** 2) # Register the custom operation within the Variable class Variable.register_custom_operation(\'custom_tanh\', custom_tanh, custom_tanh_grad) # Use the custom operation and compute gradients with GradientTracker() as tracker: a = Variable([1.0, 2.0, 3.0]) b = a.custom_tanh() grad = tracker.gradient(b, a) print(grad) # Expected output: array([0.41997434, 0.07065082, 0.00986604]) ``` Notes: * Users should be able to define any number of custom operations. * Ensure compatibility with other existing operations and gradients in the system. * Thoroughly test the framework with different custom operations and gradients.","solution":"import numpy as np class Variable: _custom_ops = {} def __init__(self, value): self.value = np.array(value) self.grad = None self.op = None self.prev = [] def set_gradient(self, grad): self.grad = grad @staticmethod def register_custom_operation(name, func, grad_func): Variable._custom_ops[name] = (func, grad_func) def __getattr__(self, name): if name in Variable._custom_ops: def method(*args): return self._apply_custom_op(name, args) return method else: raise AttributeError(f\\"\'{type(self).__name__}\' object has no attribute \'{name}\'\\") def _apply_custom_op(self, name, args): func, grad_func = Variable._custom_ops[name] result_value = func(self.value, *args) result_var = Variable(result_value) result_var.op = (name, self, args, grad_func) return result_var class GradientTracker: def __enter__(self): self.tracked_operations = [] return self def __exit__(self, exc_type, exc_value, traceback): self.tracked_operations = [] def track_operation(self, result, op_name, inputs, grad_func): self.tracked_operations.append((result, op_name, inputs, grad_func)) def gradient(self, output_var, input_var): self.gradients = {output_var: np.ones_like(output_var.value)} stack = [output_var] while stack: var = stack.pop() if var.op: op_name, inp, args, grad_func = var.op if inp not in self.gradients: self.gradients[inp] = np.zeros_like(inp.value) grad_wrt_input = grad_func(inp.value, self.gradients[var], *args) self.gradients[inp] += grad_wrt_input stack.append(inp) return self.gradients[input_var] # Example usage: # Define a custom tanh operation and its gradient def custom_tanh(x): return np.tanh(x) def custom_tanh_grad(x, grad_output): return grad_output * (1 - np.tanh(x) ** 2) # Register the custom operation and its gradient in the Variable class Variable.register_custom_operation(\'custom_tanh\', custom_tanh, custom_tanh_grad) # Use the custom operation and compute gradients with GradientTracker() as tracker: a = Variable([1.0, 2.0, 3.0]) b = a.custom_tanh() grad = tracker.gradient(b, a) print(grad) # Expected output: array([0.41997434, 0.07065082, 0.00986604])"},{"question":"# Integer to Roman Numeral Conversion Context: You are developing a historical data converter that frequently deals with Roman numerals. Roman numerals are represented by combinations of the letters I, V, X, L, C, D, and M. Each of these letters has a fixed numerical value, and they are combined to represent numbers. Task: Write a function `int_to_roman(n: int) -> str` that converts a given integer to its Roman numeral representation. The input is an integer, and the function should return a string representing the Roman numeral. Input: * An integer `n` (1 <= n <= 3999). Output: * A string representing the Roman numeral equivalent of the input integer. Example: ```python def int_to_roman(n: int) -> str: Example usage: >>> int_to_roman(58) \\"LVIII\\" >>> int_to_roman(1994) \\"MCMXCIV\\" >>> int_to_roman(4) \\"IV\\" >>> int_to_roman(1) \\"I\\" ``` Constraints: * The input integer will always be in the range 1 to 3999 inclusive. * Roman numerals are written by combining the following symbols and values: * I: 1 * V: 5 * X: 10 * L: 50 * C: 100 * D: 500 * M: 1000 * Specific rules apply to the combinations, such as IV being 4 and IX being 9. Requirements: * Make sure your function correctly handles all valid inputs and includes edge cases. * Ensure the output format follows standard Roman numeral rules and conventions.","solution":"def int_to_roman(n: int) -> str: Converts an integer to a Roman numeral string. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman = \'\' i = 0 while n > 0: for _ in range(n // val[i]): roman += syms[i] n -= val[i] i += 1 return roman"},{"question":"# Maximum Subarray Sum Context: In finance and stock market analysis, understanding trends of maximum profit over a period can help in making informed decisions. Given a list of daily stock price changes, identify the maximum possible profit (or minimum loss) that could be achieved over a contiguous subarray of days. Problem Statement: Given a list of integers representing daily changes in stock prices, compute the maximum possible sum of any contiguous subarray. Function Signature: ```python def max_subarray_sum(changes: list) -> int: This function returns the maximum possible sum of any contiguous subarray >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 ``` Input: - A list of integers `changes` (1 <= len(changes) <= 10^5). Output: - An integer, the maximum sum of any contiguous subarray. Constraints: - The list consists of at least one integer and can have both positive and negative integers. Example: ```python assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert max_subarray_sum([1]) == 1 ``` Explanation: - For the input `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`, the contiguous subarray `[4, -1, 2, 1]` has the maximum sum, which is `6`. - For the input `[1]`, the single element itself forms the maximum sum, which is `1`. Implement the function to find and return the maximum sum of any contiguous subarray in the provided list. Consider optimizing both time and space complexity where possible.","solution":"def max_subarray_sum(changes): Returns the maximum possible sum of any contiguous subarray. max_ending_here = max_so_far = changes[0] for x in changes[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Matrix Transpose Coding Challenge You are asked to write a function that transposes a given matrix. The transpose of a matrix is achieved by swapping its rows and columns. Write a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes: - `matrix`: a list of lists of integers representing a matrix of size n x m. The function should return the transposed matrix, which is of size m x n. Constraints: 1. The matrix will always be non-empty. 2. The number of rows and columns will be at most 1000. Expected Input/Output: - Input: ``` python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` - Output: ``` python [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` Example: ``` python matrix = [ [1, 2], [3, 4], [5, 6] ] print(transpose_matrix(matrix)) # Output: [ # [1, 3, 5], # [2, 4, 6] # ] ``` Notes: 1. Ensure your function handles matrices of different sizes, such as 1xN and Nx1 matrices. 2. Validate the input to ensure it is a list of lists and that each sublist (row) is of the same length. 3. Optimize for readability and performance within the given constraints.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given n x m matrix to an m x n matrix. if not matrix or not matrix[0]: return [] # Initialize the transposed matrix with the appropriate size rows, cols = len(matrix), len(matrix[0]) transposed = [[0] * rows for _ in range(cols)] # Perform the transpose operation for i in range(rows): for j in range(cols): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Matrix Rotation Scenario You are working on an image processing library where users can rotate images. An image can be represented as a 2D matrix of pixels, where each pixel has a specific color value. Users often require rotating the image by 90 degrees clockwise. Your task is to implement such a function. Task Your task is to implement a function to rotate a given NxN matrix (image) by 90 degrees clockwise in-place. This means you should not use any additional memory for another matrix, and you should change the given matrix directly. Function **Function `rotate_matrix`:** - **Input**: - `matrix` (List of List of integers): An NxN matrix where each element is an integer representing pixel color values. - **Output**: - The function modifies the input matrix in-place and does not return anything. ```python def rotate_matrix(matrix: list[list[int]]) -> None: Rotate the NxN matrix by 90 degrees clockwise in-place. Parameters: - matrix (list of list of int): NxN matrix to rotate in-place. Returns: - None # Your code here ``` Examples ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) print(matrix1) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [1, 2], [3, 4] ] rotate_matrix(matrix2) print(matrix2) # Output: # [ # [3, 1], # [4, 2] # ] ``` Constraints - The matrix provided will always be NxN, where N >= 1 and N <= 100. - You must rotate the matrix in place without using any extra space for another matrix. - You can only use space for a few temporary variables. **Note:** The matrix can contain any integer values including negative numbers. Your solution should handle all possible integers and ensure the matrix is rotated correctly even if it contains the minimum or maximum integer values.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotate the NxN matrix by 90 degrees clockwise in-place. Parameters: - matrix (list of list of int): NxN matrix to rotate in-place. Returns: - None N = len(matrix) for i in range(N // 2): for j in range(i, N - i - 1): # Save the top temp = matrix[i][j] # Move left to top matrix[i][j] = matrix[N - j - 1][i] # Move bottom to left matrix[N - j - 1][i] = matrix[N - i - 1][N - j - 1] # Move right to bottom matrix[N - i - 1][N - j - 1] = matrix[j][N - i - 1] # Move top to right matrix[j][N - i - 1] = temp"},{"question":"# Problem Statement You are given data about employees in a company. Each employee has a name, age, department, and salary. Your task is to implement functions that perform certain operations on this data set. # Requirements Implement the following functions: 1. `get_average_salary_by_department(employee_data: list, department: str) -> float`: - This function calculates and returns the average salary of employees in the specified department. 2. `get_oldest_employee(employee_data: list) -> dict`: - This function returns a dictionary containing details of the oldest employee. 3. `get_employees_by_age_range(employee_data: list, min_age: int, max_age: int) -> list`: - This function returns a list of dictionaries containing details of employees whose age falls within the specified range (inclusive). # Input Parameters Each function will work with the input list `employee_data`, where each element is a dictionary with the following keys: - `name`: The name of the employee (string). - `age`: The age of the employee (integer). - `department`: The department in which the employee works (string). - `salary`: The salary of the employee (float). # Function Signatures ```python def get_average_salary_by_department(employee_data: list, department: str) -> float: pass def get_oldest_employee(employee_data: list) -> dict: pass def get_employees_by_age_range(employee_data: list, min_age: int, max_age: int) -> list: pass ``` # Output 1. `get_average_salary_by_department`: - Returns a float representing the average salary in the specified department. - If no employees are in the specified department, return `0.0`. 2. `get_oldest_employee`: - Returns a dictionary representing the oldest employee. - In case of a tie (multiple employees with the highest age), return any one of them. 3. `get_employees_by_age_range`: - Returns a list of dictionaries representing employees whose ages fall within the specified range. # Example ```python employee_data = [ {\'name\': \'John\', \'age\': 30, \'department\': \'Engineering\', \'salary\': 70000}, {\'name\': \'Jane\', \'age\': 25, \'department\': \'Marketing\', \'salary\': 60000}, {\'name\': \'Doe\', \'age\': 50, \'department\': \'Engineering\', \'salary\': 80000}, {\'name\': \'Mary\', \'age\': 45, \'department\': \'HR\', \'salary\': 75000} ] >>> get_average_salary_by_department(employee_data, \'Engineering\') 75000.0 >>> get_average_salary_by_department(employee_data, \'Finance\') 0.0 >>> get_oldest_employee(employee_data) {\'name\': \'Doe\', \'age\': 50, \'department\': \'Engineering\', \'salary\': 80000} >>> get_employees_by_age_range(employee_data, 30, 50) [ {\'name\': \'John\', \'age\': 30, \'department\': \'Engineering\', \'salary\': 70000}, {\'name\': \'Doe\', \'age\': 50, \'department\': \'Engineering\', \'salary\': 80000}, {\'name\': \'Mary\', \'age\': 45, \'department\': \'HR\', \'salary\': 75000} ] ``` # Constraints - The function should handle edge cases where the employee data is empty. - Handle cases where no employees fall in the specified age range appropriately by returning an empty list.","solution":"def get_average_salary_by_department(employee_data: list, department: str) -> float: Returns the average salary of employees in the specified department. salaries = [employee[\'salary\'] for employee in employee_data if employee[\'department\'] == department] if not salaries: return 0.0 return sum(salaries) / len(salaries) def get_oldest_employee(employee_data: list) -> dict: Returns a dictionary containing details of the oldest employee. if not employee_data: return {} oldest_employee = max(employee_data, key=lambda employee: employee[\'age\']) return oldest_employee def get_employees_by_age_range(employee_data: list, min_age: int, max_age: int) -> list: Returns a list of employees whose age falls within the specified range. return [employee for employee in employee_data if min_age <= employee[\'age\'] <= max_age]"},{"question":"# Coding Assessment Question Scenario You are developing a software system for a ride-sharing company. Your task is to create a dispatch algorithm that matches riders to drivers based on the shortest distance. Riders and drivers are located on a grid, and the system should ensure each rider is paired with a driver such that the total travel distance is minimized. Function to Implement Implement the function `match_riders_drivers(riders: list, drivers: list) -> list` that returns a list of tuples representing the optimal pairs of riders and drivers along with the total travel distance. Input 1. `riders`: A list of tuples, where each tuple contains the coordinates (x, y) of a rider on a grid. 2. `drivers`: A list of tuples, where each tuple contains the coordinates (x, y) of a driver on a grid. Output The function should return: - A list of tuples, where each tuple represents a rider-driver pair by their indices in the input lists. - An integer representing the total minimum travel distance. Constraints 1. The number of riders (R) and drivers (D) can be between 1 and 100. 2. There are exactly as many drivers as there are riders (R = D). 3. The coordinates of riders and drivers are non-negative integers within the range of 0 to 1000. Performance Requirements - Your algorithm should efficiently handle the pairing in polynomial time, aiming for O(R^3) time complexity or better. Example ```python riders = [(0, 0), (1, 1), (2, 2)] drivers = [(2, 0), (1, 0), (0, 2)] assert match_riders_drivers(riders, drivers) == ([(0, 1), (1, 0), (2, 2)], 5) ``` Notes - Ensure that your algorithm effectively minimizes the total travel distance by considering every possible rider-driver pairing. - Use a data structure and algorithm that appropriately solve the assignment problem, such as the Hungarian algorithm. # Explanation: In the given example, the optimal pairs of riders and drivers are: - Rider 0 to Driver 1 with distance 1 - Rider 1 to Driver 0 with distance 1 - Rider 2 to Driver 2 with distance 3 Thus, the total travel distance is 5.","solution":"from scipy.optimize import linear_sum_assignment import numpy as np def match_riders_drivers(riders, drivers): Matches riders to drivers minimizing the total travel distance. Args: riders (list): A list of tuples representing the coordinates of riders. drivers (list): A list of tuples representing the coordinates of drivers. Returns: list: A list of tuples representing the optimal pairs (index of rider, index of driver). int : The total minimum travel distance. # Calculate the cost matrix cost_matrix = np.zeros((len(riders), len(drivers)), dtype=int) for i, (rx, ry) in enumerate(riders): for j, (dx, dy) in enumerate(drivers): cost_matrix[i, j] = abs(rx - dx) + abs(ry - dy) # Apply the Hungarian algorithm to find the minimum cost matching row_ind, col_ind = linear_sum_assignment(cost_matrix) # Create the list of optimal pairs and calculate the total minimum distance total_distance = 0 optimal_pairs = [] for ri, di in zip(row_ind, col_ind): optimal_pairs.append((ri, di)) total_distance += cost_matrix[ri, di] return (optimal_pairs, total_distance)"},{"question":"# **Question: Seating Arrangement Simulator** You are tasked with developing a simulator for seating arrangements in a theater. The theater has a predefined seating layout represented by a 2D array where each element indicates whether the seat is available (`0`) or already booked (`1`). You must provide functionalities to check seat availability and to book a seat. 1. **Check Seat Availability**: Implement a function `is_seat_available(layout, row, col)` that returns `True` if the seat at the specified row and column is available, otherwise returns `False`. 2. **Book a Seat**: Implement a function `book_seat(layout, row, col)` that books the seat at the specified row and column if it is available and returns `True`. If the seat is already booked, return `False`. Constraints 1. The input 2D array (`layout`) will be non-empty with `m` rows and `n` columns. 2. Valid values for `row` and `col` are from `0` to `m-1` and `0` to `n-1`, respectively. 3. The value of each element in the array is either `0` (available) or `1` (booked). Input 1. For `is_seat_available` function: - `layout`: A 2D array representing the seating layout. - `row`: An integer representing the row of the seat. - `col`: An integer representing the column of the seat. 2. For `book_seat` function: - `layout`: A 2D array representing the seating layout. - `row`: An integer representing the row of the seat. - `col`: An integer representing the column of the seat. Output 1. For `is_seat_available` function: - Returns a boolean value indicating the availability of the specified seat. 2. For `book_seat` function: - Returns a boolean value indicating whether the seat was successfully booked. # Example 1. **Check seat availability:** ```python layout = [[0, 1, 0], [1, 0, 0], [0, 0, 1]] row = 0 col = 2 print(is_seat_available(layout, row, col)) # Output: True row = 1 col = 0 print(is_seat_available(layout, row, col)) # Output: False ``` 2. **Book a seat:** ```python layout = [[0, 1, 0], [1, 0, 0], [0, 0, 1]] row = 2 col = 0 print(book_seat(layout, row, col)) # Output: True row = 1 col = 0 print(book_seat(layout, row, col)) # Output: False ``` # Requirements * Implement the `is_seat_available` function. * Implement the `book_seat` function. * Ensure error handling for invalid seat indices. * Maintain efficient time and space complexity.","solution":"def is_seat_available(layout, row, col): Check if the seat at the specified row and column is available. :param layout: 2D list representing the seating layout :param row: Row index of the seat :param col: Column index of the seat :return: True if the seat is available, False otherwise if layout[row][col] == 0: return True return False def book_seat(layout, row, col): Book the seat at the specified row and column if it is available. :param layout: 2D list representing the seating layout :param row: Row index of the seat :param col: Column index of the seat :return: True if the seat was successfully booked, False otherwise if layout[row][col] == 0: layout[row][col] = 1 return True return False"},{"question":"# Binary Search Tree Insertion and Lookup Problem Statement: You are required to implement a basic binary search tree (BST) with functionalities to add new elements and retrieve elements. Each node in the BST should store an integer value. The BST should maintain the property that for any given node, its left descendants are less than the node and its right descendants are greater than the node. Requirements: 1. **Function Signature**: ```python class TreeNode: def __init__(self, key: int) -> None: self.left = None self.right = None self.key = key class BinarySearchTree: def __init__(self) -> None: self.root = None def insert(self, key: int) -> None: def search(self, key: int) -> bool: def __repr__(self) -> str: ``` 2. **Input and Output Format**: - `insert(self, key: int)`: Inserts a node with the provided key into the BST. If the key already exists, it should not insert the duplicate. - `search(self, key: int)`: Returns `True` if a node with the provided key exists in the BST, otherwise returns `False`. - `__repr__(self)`: Returns a string representation of the BST showing an inorder traversal of nodes. 3. **Constraints**: - The keys are integers. - The tree should be dynamically adjusted on insertion to maintain the binary search tree properties. 4. **Performance Requirements**: - The average case operations for insertion and lookup should have a time complexity of O(log n). - The worst-case operations would be O(n) for skewed trees, but these are outside the scope of balancing. Example Usage: ```python # Initializing binary search tree bst = BinarySearchTree() # Inserting elements bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(3) bst.insert(7) bst.insert(15) bst.insert(30) # Searching for elements print(bst.search(7)) # Output: True print(bst.search(100)) # Output: False # String representation of binary search tree (inorder traversal) print(bst) # Output: 3, 5, 7, 10, 15, 20, 30 ``` Implement the `TreeNode` and `BinarySearchTree` classes to fulfill the above specifications.","solution":"class TreeNode: def __init__(self, key: int) -> None: self.left = None self.right = None self.key = key class BinarySearchTree: def __init__(self) -> None: self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node: TreeNode, key: int) -> None: if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) elif key > node.key: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) # If key == node.key, do not insert duplicate def search(self, key: int) -> bool: return self._search_recursive(self.root, key) def _search_recursive(self, node: TreeNode, key: int) -> bool: if node is None: return False if key == node.key: return True elif key < node.key: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key) def __repr__(self) -> str: nodes = [] self._inorder_traversal(self.root, nodes) return \\", \\".join(map(str, nodes)) def _inorder_traversal(self, node: TreeNode, nodes: list) -> None: if node is not None: self._inorder_traversal(node.left, nodes) nodes.append(node.key) self._inorder_traversal(node.right, nodes)"},{"question":"# Context You are developing a software that helps analyze stock price performance over a certain period. This software allows users to input a list of daily closing prices for a stock, and then it calculates various performance metrics. # Task Implement a function `stock_performance(prices: list) -> dict` that determines the maximum profit that could be obtained by buying and selling once, the day to buy to achieve this profit, and the day to sell. # Input Requirements 1. `prices`: A list of non-negative floating-point numbers representing daily closing prices of a stock. The list will have at least two prices. # Output Format A dictionary with the following key-value pairs: - `\\"max_profit\\"`: The maximum profit that could be obtained (a float, rounded to 2 decimal places). - `\\"buy_day\\"`: The day (0-indexed) to buy the stock to achieve the maximum profit (an integer). - `\\"sell_day\\"`: The day (0-indexed) to sell the stock to achieve the maximum profit (an integer). # Constraints & Considerations - **Constraints**: - Raise appropriate errors for invalid input values. A **ValueError** should be raised if the list has less than two prices or contains negative prices. - Raise a **TypeError** if the input is not a list or the elements of the list are not numbers. - **Performance requirements**: The solution should efficiently calculate the required metrics. # Function Signature In the implementation, ensure to define the function signature as follows: ```python def stock_performance(prices: list) -> dict: pass ``` # Example ```python >>> stock_performance([7.5, 1.5, 5.0, 3.0, 6.4, 4.7]) { \\"max_profit\\": 4.9, \\"buy_day\\": 1, \\"sell_day\\": 4 } >>> stock_performance([100, 90, 80, 70, 60]) { \\"max_profit\\": 0.0, \\"buy_day\\": 0, \\"sell_day\\": 0 } >>> stock_performance([1.5]) Traceback (most recent call last): ... ValueError: Invalid prices list. At least two prices are required. >>> stock_performance([7.5, -1, 5.0]) Traceback (most recent call last): ... ValueError: Invalid prices list. Prices should be non-negative. ```","solution":"def stock_performance(prices: list) -> dict: Determines the maximum profit that could be obtained by buying and selling once, the day to buy to achieve this profit, and the day to sell. Args: prices (list): A list of non-negative floating-point numbers representing daily closing prices of a stock. Returns: dict: A dictionary with \\"max_profit\\", \\"buy_day\\", and \\"sell_day\\". if not isinstance(prices, list): raise TypeError(\\"Prices should be provided as a list.\\") if len(prices) < 2: raise ValueError(\\"Invalid prices list. At least two prices are required.\\") if any(p < 0 for p in prices): raise ValueError(\\"Invalid prices list. Prices should be non-negative.\\") # Initialize variables min_price = prices[0] min_day = 0 max_profit = 0.0 buy_day = 0 sell_day = 0 # Iterate through the list for i in range(1, len(prices)): if prices[i] - min_price > max_profit: max_profit = prices[i] - min_price buy_day = min_day sell_day = i if prices[i] < min_price: min_price = prices[i] min_day = i return { \\"max_profit\\": round(max_profit, 2), \\"buy_day\\": buy_day, \\"sell_day\\": sell_day }"},{"question":"# Detect Palindrome in a String Context You are given a string consisting of alphanumeric characters and spaces. Your task is to determine if the string can be rearranged to form a palindrome. Note: A string is a palindrome if it reads the same forwards and backwards (ignoring spaces). Function Signature ```python def can_form_palindrome(s: str) -> bool: ``` Inputs - `s`: A string containing alphanumeric characters and spaces. Outputs - A boolean value `True` if the input string can be rearranged to form a palindrome, and `False` otherwise. Constraints - The input string length will not exceed 1000 characters. - The input string will contain only alphanumeric characters and spaces. Example ```python >>> can_form_palindrome(\\"Tact Coa\\") True >>> can_form_palindrome(\\"a man a plan a canal panama\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"hello world\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"A Santa at NASA\\") True ``` Instructions 1. Normalize the string by removing spaces and converting all characters to the same case. 2. Use a frequency count to check the number of times each character appears in the string. 3. Implement the logic to check if the string can be rearranged to form a palindrome: - For a string to be rearranged into a palindrome, all characters except at most one must have even counts. 4. Return `True` if the string can be rearranged to form a palindrome, `False` otherwise. Edge Cases to Consider - The string contains only spaces. - All characters in the string are the same. - The string contains both upper and lower case variations of the same letter. Note Use the provided function signature and ensure that the function returns the correct result for all the provided test cases.","solution":"def can_form_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. # Normalize the string: remove spaces and convert to lower case s = \'\'.join(c.lower() for c in s if c.isalnum()) # Count the frequency of each character freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 # Check the counts: At most one character can have an odd count odd_count = 0 for count in freq.values(): if count % 2 != 0: odd_count += 1 # If more than one character has an odd count, it can\'t form a palindrome return odd_count <= 1"},{"question":"# File Organizer **Objective**: Implement a function to organize files in a given directory based on their file extensions, creating subdirectories for each type and moving the files accordingly. **Scenario**: In a scenario where you need to manage a cluttered directory with different types of files, you need to write a script that categorizes these files by their extensions. Your solution should be robust and handle potential edge cases effectively. **Requirements**: - Define a function `organize_files_by_extension(directory_path: str) -> dict` that: - Takes the path of the directory to organize (string). - Returns a dictionary with two keys: `\\"success\\"` (boolean) and `\\"data\\"` (details of the operation or error message on failure). - The function should: - Create subdirectories named after the extensions found (e.g., `txt`, `jpg`). - Move the files into the corresponding subdirectory based on their extension. - Handle the case where files have no extension by moving them into a subdirectory named `no_extension`. - Handle edge cases such as read/write permission issues gracefully. - Assume no hidden files or directories need to be organized. **Function Signature**: ```python def organize_files_by_extension(directory_path: str) -> dict: pass ``` **Constraints**: - The directory path provided exists and is valid. - The function has permission to read and write to the specified directory. **Examples**: 1. Given the directory structure before running the function: ``` /my_directory/ ├── file1.txt ├── file2.jpg ├── notes.docx ├── data.csv ├── another_note.TXT └── Music ``` Running `organize_files_by_extension(\\"/my_directory\\")` might return: ```python { \\"success\\": True, \\"data\\": \\"Files organized successfully.\\" } ``` Resulting directory structure: ``` /my_directory/ ├── txt/ │ ├── file1.txt │ └── another_note.TXT ├── jpg/ │ └── file2.jpg ├── docx/ │ └── notes.docx ├── csv/ │ └── data.csv └── Music ``` 2. On permission issues: ```python { \\"success\\": False, \\"data\\": \\"Permission denied while accessing the directory.\\" } ``` 3. With no files to organize: ```python { \\"success\\": True, \\"data\\": \\"No files to organize.\\" } ```","solution":"import os import shutil def organize_files_by_extension(directory_path: str) -> dict: try: if not os.path.exists(directory_path): return { \\"success\\": False, \\"data\\": \\"Directory does not exist.\\" } files_moved = False for item in os.listdir(directory_path): item_path = os.path.join(directory_path, item) if os.path.isfile(item_path): files_moved = True _, extension = os.path.splitext(item) if extension: extension = extension[1:].lower() else: extension = \\"no_extension\\" target_dir = os.path.join(directory_path, extension) if not os.path.exists(target_dir): os.makedirs(target_dir) shutil.move(item_path, os.path.join(target_dir, item)) if files_moved: return { \\"success\\": True, \\"data\\": \\"Files organized successfully.\\" } else: return { \\"success\\": True, \\"data\\": \\"No files to organize.\\" } except PermissionError: return { \\"success\\": False, \\"data\\": \\"Permission denied while accessing the directory.\\" } except Exception as e: return { \\"success\\": False, \\"data\\": f\\"An error occurred: {str(e)}\\" }"},{"question":"# Maximum Points on a Line You are given a series of points in a 2D plane, each represented as a pair of integers `(x, y)`. Your task is to determine the maximum number of points that lie on the same straight line. Task Write a function `max_points_on_line(points: List[Tuple[int, int]]) -> int` which: - Accepts a list of points, where each point is a tuple of two integers `(x, y)`. - Returns an integer representing the maximum number of points that are collinear (lie on the same straight line). Input & Output - **Input**: A list of tuples `points` where each tuple `(x, y)` represents a point\'s coordinates. The number of points may range from 1 up to 300. - **Output**: A single integer representing the maximum number of collinear points. Example ```python max_points_on_line([(1, 1), (2, 2), (3, 3), (1, 4), (3, 2)]) ``` Output: ```plaintext 3 ``` Explanation: - The points `(1, 1)`, `(2, 2)`, and `(3, 3)` are collinear. Constraints - Points can have negative or positive integer coordinates. - Two or more distinct points can have the same coordinates, but each occurrence should be considered separately. Notes - Use of efficient geometric algorithms or hash maps will be necessary to handle the upper limit of 300 points. - Consider edge cases where all points might be the same. - Aim for a solution that scales well in terms of time complexity, considering pairwise slope calculations. Hints - Calculate slope between every pair of points and use a hash map to count points with identical slopes. - Be mindful of edge cases involving vertical lines and overlapping points.","solution":"from collections import defaultdict from math import gcd from typing import List, Tuple def max_points_on_line(points: List[Tuple[int, int]]) -> int: if len(points) <= 1: return len(points) def get_slope(p1, p2): Helper function to calculate the slope between two points. dx = p2[0] - p1[0] dy = p2[1] - p1[1] if dx == 0: return float(\'inf\') elif dy == 0: return 0 else: g = gcd(dy, dx) return (dy // g, dx // g) max_points = 1 for i in range(len(points)): slopes = defaultdict(int) duplicates = 1 for j in range(i + 1, len(points)): if points[i] == points[j]: duplicates += 1 else: slope = get_slope(points[i], points[j]) slopes[slope] += 1 current_max = duplicates for count in slopes.values(): current_max = max(current_max, count + duplicates) max_points = max(max_points, current_max) return max_points"},{"question":"You are required to implement a function that finds the maximum sum of any increasing subsequence of a given list of integers. An increasing subsequence is a sequence of numbers such that each number in the sequence is strictly greater than the previous number. # Function Signature ```python def max_sum_increasing_subsequence(arr: List[int]) -> int: pass ``` # Input * A list of integers `arr`. # Output * Return an integer representing the maximum sum of any increasing subsequence of the input list. # Constraints * 1 <= len(arr) <= 1000 * -10^4 <= arr[i] <= 10^4 # Examples ```python >>> max_sum_increasing_subsequence([1, 101, 2, 3, 100, 4, 5]) 106 >>> max_sum_increasing_subsequence([3, 4, 5, 10]) 22 >>> max_sum_increasing_subsequence([10, 5, 4, 3]) 10 ``` # Explanation To solve this problem: 1. Use dynamic programming to keep track of the maximum sum of increasing subsequences ending at each position in the array. 2. For each element in the array, check all previous elements to see if they can form an increasing subsequence and update the maximum sum accordingly. The core idea is to iterate through the list and for each element `arr[i]`, update its maximum sum using all previous elements `arr[j]` that are less than `arr[i]`. The final result is the maximum value found for any subsequence ending in any element in the list.","solution":"from typing import List def max_sum_increasing_subsequence(arr: List[int]) -> int: if not arr: return 0 # Initialize the maximum sum for each position with the value at that position n = len(arr) max_sum = arr[:] # Fill the max_sum array for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: max_sum[i] = max(max_sum[i], max_sum[j] + arr[i]) return max(max_sum)"},{"question":"# Question: Dynamic Array Manipulation and Querying You are given a class `DynamicArray` that initially contains an empty array. The class should enable dynamic updates to the array and support efficient querying. # Task 1. Extend the `DynamicArray` class to handle the following scenarios: - Support appending new elements to the array. - Support querying the sum of elements within a specified range of indices. - Support updating an element at a specific index. 2. Ensure that the methods manage the array efficiently, even with a large number of operations. # Requirements 1. **Implement** the following methods in the `DynamicArray` class: - `append`: to add a new element to the end of the array. - `sum_range`: to find the sum of elements between two given indices (inclusive). - `update`: to update the value of an element at a specific index. # Input: - Series of operations to either append elements, update elements, or query the sum of elements in a specified range. # Output: - The result of each sum query. # Constraints: - The number of operations (append, update, and sum queries) will be at most 10^5. - The array will contain integer values. # Example: ```python dynamic_array = DynamicArray() dynamic_array.append(1) dynamic_array.append(2) dynamic_array.append(3) # Array now: [1, 2, 3] print(dynamic_array.sum_range(0, 2)) # Output: 6 dynamic_array.update(1, 5) # Array now: [1, 5, 3] print(dynamic_array.sum_range(1, 2)) # Output: 8 ``` # Function Signatures: 1. `def append(self, value: int) -> None:` 2. `def update(self, index: int, value: int) -> None:` 3. `def sum_range(self, left: int, right: int) -> int:`","solution":"class DynamicArray: def __init__(self): self.array = [] def append(self, value: int) -> None: self.array.append(value) def update(self, index: int, value: int) -> None: if 0 <= index < len(self.array): self.array[index] = value else: raise IndexError(\\"Index out of bounds\\") def sum_range(self, left: int, right: int) -> int: if 0 <= left <= right < len(self.array): return sum(self.array[left:right+1]) else: raise IndexError(\\"Index out of bounds\\")"},{"question":"# Coding Question Problem Statement You are required to implement a function `flatten_dict` that takes a nested dictionary and returns a new dictionary with all the keys flattened. Key names in the flattened dictionary are the concatenation of the keys from the original dictionary in a breadth-first traversal, separated by dots. Function Signature ```python def flatten_dict(d: dict) -> dict: pass ``` Input and Output Requirements * **Input**: - `d` (dict): A dictionary that may be nested. * **Output**: - Returns a new dictionary with flattened keys and their corresponding values. Constraints * Nested dictionaries can contain other dictionaries as values. * The original dictionary may not contain nested dictionaries infinitely, i.e., it won\'t be an overly deep or infinitely recursive structure. Examples 1. `flatten_dict({\\"a\\": {\\"b\\": 1}})` should return `{\'a.b\': 1}` 2. `flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": 2}}, \\"d\\": 3})` should return `{\'a.b.c\': 2, \'d\': 3}` 3. `flatten_dict({})` should return `{}` (empty dictionary) Notes * Your function should handle cases of mixed nested and non-nested structures within the dictionary. * Consider edge cases where the values aren\'t dicts but other data types, and make sure they are properly assigned in the resulting flattened dictionary.","solution":"def flatten_dict(d, parent_key=\'\', sep=\'.\'): Flattens a nested dictionary. Args: d (dict): The dictionary to flatten. parent_key (str): The base key for the current nested level. sep (str): The separator to use between key levels. Returns: dict: A new dictionary with flattened keys. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"# Evenly Partition Array for Optimal Sum **Context**: In optimization problems, particularly in resource management and load balancing, it is often necessary to split data into subsets such that certain criteria are met. A common problem requires partitioning an array into subsets with minimal difference in their sums. **Task**: Implement a function `evenly_partition(arr: List[int]) -> Tuple[List[int], List[int]]` that splits an array of integers into two subsets such that the absolute difference between their sums is minimized. If there are multiple ways to achieve the minimal difference, you may return any valid pair of subsets. # Input Format: - A list of integers, `arr`, where all elements are non-negative and the length of the list is at least 1. # Output Format: - A tuple containing two lists of integers, representing the partitions. # Constraints: - The input list can have up to `100` elements, with each element being in the range `[0, 1000]`. # Examples: ```python >>> evenly_partition([3, 1, 4, 2, 2]) ([3, 2], [4, 2, 1]) # One possible valid output >>> evenly_partition([1, 2, 3, 4, 5]) ([1, 4, 5], [2, 3]) # One possible valid output >>> evenly_partition([10, 20, 30, 50]) ([20, 30], [10, 50]) # One possible valid output ``` **Performance Requirements:** - Your solution should consider an efficient approach to dynamically partitioning the array, bearing in mind the constraints. # Implementation: Your solution should employ dynamic programming, greedy algorithms, or other combinatorial techniques to efficiently minimize the absolute difference between the subset sums, considering the constraints provided.","solution":"from typing import List, Tuple def evenly_partition(arr: List[int]) -> Tuple[List[int], List[int]]: total_sum = sum(arr) n = len(arr) # Create a dp array where dp[i][j] will be True if a subset of the first i items has sum j dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum // 2 + 1): dp[i][j] = dp[i - 1][j] if j >= arr[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]] # Find the largest j such that dp[n][j] is True for j in range(total_sum // 2, -1, -1): if dp[n][j]: sum1 = j break # Reconstruct the subsets subset1, subset2 = [], [] w = sum1 for i in range(n, 0, -1): if w >= arr[i - 1] and dp[i - 1][w - arr[i - 1]]: subset1.append(arr[i - 1]) w -= arr[i - 1] else: subset2.append(arr[i - 1]) return subset1, subset2"},{"question":"Question: Matrix Diagonal Sum and Product Calculation # Scenario You\'re developing a functionality for a linear algebra library that involves operations on square matrices. Your task is to create functions to calculate the sum and the product of the diagonal elements of a given square matrix. # Implementation Requirements - Implement a function `diagonal_sum(matrix: list) -> int` that returns the sum of the diagonal elements of the input square matrix. - Implement a function `diagonal_product(matrix: list) -> int` that returns the product of the diagonal elements of the input square matrix. # Input - A square matrix (list of lists) where each sub-list represents a row in the matrix, e.g., `[[2, 5, 1], [4, 3, 6], [7, 8, 9]]`. # Output - `diagonal_sum` should return an integer representing the sum of the elements on the main diagonal. - `diagonal_product` should return an integer representing the product of the elements on the main diagonal. # Constraints - The input matrix must be non-empty and must be square (number of rows equals number of columns). - The elements of the matrix must be numeric. # Example ```python matrix = [[2, 5, 1], [4, 3, 6], [7, 8, 9]] print(diagonal_sum(matrix)) # Output: 14 (2 + 3 + 9) print(diagonal_product(matrix)) # Output: 54 (2 * 3 * 9) matrix = [[1, 2], [3, 4]] print(diagonal_sum(matrix)) # Output: 5 (1 + 4) print(diagonal_product(matrix)) # Output: 4 (1 * 4) ``` # Edge Cases - The functions should raise a `ValueError` if the input is not a square matrix (e.g., non-list, non-square matrix). - Ensure that the functions handle matrices with negative numbers or zeros gracefully.","solution":"def diagonal_sum(matrix: list) -> int: Returns the sum of the diagonal elements of a square matrix. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be a non-empty square matrix.\\") return sum(matrix[i][i] for i in range(len(matrix))) def diagonal_product(matrix: list) -> int: Returns the product of the diagonal elements of a square matrix. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be a non-empty square matrix.\\") product = 1 for i in range(len(matrix)): product *= matrix[i][i] return product"},{"question":"# Optimize Matrix Multiplication Background Matrix multiplication is a fundamental operation in many applications in scientific computing, engineering, and computer graphics. The standard approach for multiplying two matrices involves iterating through rows and columns, which can be inefficient for large matrices. To improve performance, several optimization techniques can be applied. Task Implement an optimized matrix multiplication function that minimizes the computational time by leveraging matrix properties and efficient looping constructs. Specifically, optimize the matrix multiplication by: 1. Using list comprehensions and/or other Pythonic constructs to improve efficiency. 2. Reducing redundant calculations and memory references during the multiplication process. 3. Optionally, utilize NumPy for further speed improvements (this is not mandatory but encouraged for additional practice). Your function should have the following signature: ```python def optimized_matrix_multiplication(matrix_a: list[list[float]], matrix_b: list[list[float]]) -> list[list[float]]: ``` Constraints * Assume the provided matrices are valid 2D lists and can be multiplied (i.e., the number of columns in the first matrix equals the number of rows in the second). * Optimize for large matrices, ensuring your implementation handles performance improvement noticeably. * Consider edge cases where matrices can be empty, containing zeroes, or having non-integer values. Example Usage ```python # Test case example matrix_a = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix_b = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] # Expected Product: # [ # [30, 24, 18], # [84, 69, 54], # [138, 114, 90] # ] result = optimized_matrix_multiplication(matrix_a, matrix_b) expected_result = [ [30, 24, 18], [84, 69, 54], [138, 114, 90] ] assert result == expected_result, \\"Test Case 1 Failed\\" print(\\"Test Case 1 Passed\\") # Additional test cases can be added for thorough validation ``` Notes * Ensure your implementation includes appropriate unit tests to verify correctness and performance. * Handle edge cases and potential exceptions properly. * If using NumPy, ensure you provide the necessary import statements and manage dependencies appropriately.","solution":"def optimized_matrix_multiplication(matrix_a: list[list[float]], matrix_b: list[list[float]]) -> list[list[float]]: Performs optimized matrix multiplication of matrix_a and matrix_b. if not matrix_a or not matrix_b: return [] num_rows_a = len(matrix_a) num_cols_a = len(matrix_a[0]) num_cols_b = len(matrix_b[0]) # Initialize result matrix with zeros result = [[0] * num_cols_b for _ in range(num_rows_a)] # Transpose matrix_b for efficient column access matrix_b_transposed = [list(row) for row in zip(*matrix_b)] for i in range(num_rows_a): for j in range(num_cols_b): result[i][j] = sum(matrix_a[i][k] * matrix_b_transposed[j][k] for k in range(num_cols_a)) return result"},{"question":"# Fibonacci Sequence and Memoization **Problem Statement:** You are tasked with implementing two functions based on the algorithm of generating Fibonacci numbers and optimizing it using memoization: 1. `fibonacci(n: int) -> int`: - Compute the n-th Fibonacci number using a recursive approach. - **Input**: An integer `n` representing the position in the Fibonacci sequence. - **Output**: The n-th Fibonacci number. 2. `memoized_fibonacci(n: int) -> int`: - Compute the n-th Fibonacci number using a memoized recursive approach (top-down dynamic programming). - **Input**: An integer `n` representing the position in the Fibonacci sequence. - **Output**: The n-th Fibonacci number. # Function Signature ```python def fibonacci(n: int) -> int: pass def memoized_fibonacci(n: int) -> int: pass ``` # Constraints - The input integer `n` is guaranteed to be within the range of [0, 50]. # Example Input/Output ```python # Example for fibonacci assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 # Example for memoized_fibonacci assert memoized_fibonacci(0) == 0 assert memoized_fibonacci(1) == 1 assert memoized_fibonacci(10) == 55 assert memoized_fibonacci(50) == 12586269025 ``` **Notes:** 1. Ensure efficient handling of the Fibonacci sequence where the function `fibonacci` may exhibit exponential time complexity. 2. Use memoization in `memoized_fibonacci` to improve the time complexity to linear. 3. Consider the implications of recursion depth and performance. **Optional:** Discuss the advantages of memoization compared to the plain recursive approach and any potential pitfalls in terms of stack overflow and memory usage.","solution":"def fibonacci(n: int) -> int: if n <= 0: return 0 elif n == 1: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2) def memoized_fibonacci(n: int, memo=None) -> int: if memo is None: memo = {} if n in memo: return memo[n] if n <= 0: return 0 elif n == 1: return 1 else: memo[n] = memoized_fibonacci(n - 1, memo) + memoized_fibonacci(n - 2, memo) return memo[n]"},{"question":"# Find the Longest Common Subsequence Write a function `longest_common_subsequence(str1: str, str2: str) -> str` to find the longest common subsequence (LCS) between two given strings. The function should return the LCS as a string. The longest common subsequence is defined as the longest sequence that can be derived from both strings by deleting some characters (without reordering the remaining characters). Function Specifications: - **Input**: - `str1` (str): The first string (1 <= len(str1) <= 1000). - `str2` (str): The second string (1 <= len(str2) <= 1000). - **Output**: - A string representing the longest common subsequence of `str1` and `str2`. If there are multiple LCS of the same length, return any one of them. Example: ```python # Example 1 str1 = \\"ABCDGH\\" str2 = \\"AEDFHR\\" # Expected output: \\"ADH\\" # Example 2 str1 = \\"AGGTAB\\" str2 = \\"GXTXAYB\\" # Expected output: \\"GTAB\\" ``` Constraints: - The strings will only contain uppercase letters. Notes: - Your solution should handle edge cases where one or both strings are empty. - Consider using dynamic programming to achieve an efficient solution.","solution":"def longest_common_subsequence(str1: str, str2: str) -> str: Finds the longest common subsequence (LCS) between two given strings. m, n = len(str1), len(str2) # Create a DP table with (m+1) x (n+1) dimensions dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Backtrack to find the LCS lcs = [] i, j = m, n while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: lcs.append(str1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 # The LCS is built backwards, reverse it at the end return \'\'.join(reversed(lcs))"},{"question":"# File Compression Tool As a software developer, you\'re required to create a command-line tool that compresses a list of files into a single ZIP archive. The tool should provide feedback about the compression progress and any encountered errors. Your task is to implement the command-line interface (CLI) and the main functionality of the compression tool by following these requirements: 1. **File Compression**: - Accept a list of file paths as input and compress them into a single ZIP file. - The name of the resulting ZIP file should be specified by the user. 2. **Progress Feedback**: - Display progress messages indicating which file is being processed and when the compression is complete. 3. **Error Handling**: - Implement error handling for the following scenarios: - File not found. - Insufficient permissions to read a file or write the ZIP archive. - Any other I/O related errors. # Function to Implement ```python def compress_files(file_paths: List[str], output_zip: str): ``` # Input - `file_paths`: A list of strings representing the file paths to be compressed. - `output_zip`: A string representing the name of the output ZIP file. # Output - Print progress messages for the stages of file compression (e.g., compressing `file1.txt`, `complete`). - Print error messages for any issues encountered during the process. # Constraints - Use standard Python libraries (e.g., `zipfile`, `os`). - The total size of files to be compressed will not exceed 500MB. - The provided file paths will be valid strings. # Example Scenario Your function will compress files `file1.txt`, `file2.log`, and `file3.csv` into a ZIP archive named `archive.zip`. ```python compress_files([\'file1.txt\', \'file2.log\', \'file3.csv\'], \'archive.zip\') ``` You are expected to handle file read/write errors gracefully and provide user-friendly messages to the standard output.","solution":"import os from zipfile import ZipFile, ZIP_DEFLATED from typing import List def compress_files(file_paths: List[str], output_zip: str): try: with ZipFile(output_zip, \'w\', ZIP_DEFLATED) as zipf: for file_path in file_paths: if not os.path.isfile(file_path): print(f\\"Error: File not found - {file_path}\\") continue try: zipf.write(file_path, os.path.basename(file_path)) print(f\\"Compressing: {file_path}\\") except PermissionError: print(f\\"Error: Permission denied - {file_path}\\") except Exception as e: print(f\\"Error: {str(e)} - {file_path}\\") print(\\"Compression complete\\") except PermissionError: print(f\\"Error: Permission denied - Unable to write {output_zip}\\") except Exception as e: print(f\\"Error: {str(e)} - Unable to create {output_zip}\\")"},{"question":"# Data Duplicate Elimination with O(1) Space Context In many applications, data integrity and uniqueness are crucial, especially for systems involving user data, logs, or sensor inputs. Efficiently identifying and removing duplicates in-place helps save memory and processing time. Task Implement an algorithm that removes duplicate elements from an integer array in-place, without using additional space apart from a few variables. Specific Objectives 1. **Modify in-place**: Ensure that the array is modified in-place without using extra space. 2. **Maintain Order**: The relative order of elements in the original array should be maintained. Function Signature ```python def remove_duplicates(nums: List[int]) -> int: pass ``` Input - `nums`: A List of integers where each element might contain duplicates. Output - Returns an integer representing the new length of the array. - The first part of the array up to this length should contain the unique elements. Constraints - (1 leq text{len(nums)} leq 10^5) - (-10^4 leq text{nums[i]} leq 10^4) Requirements - Your solution should have a time complexity of (O(n)). - Space complexity should be (O(1)). Note * Do not use any extra space other than a few integer variables. * The result should be reflected in the input array itself. Example ```python def remove_duplicates(nums: List[int]) -> int: if not nums: return 0 unique_pos = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_pos]: unique_pos += 1 nums[unique_pos] = nums[i] return unique_pos + 1 if __name__ == \\"__main__\\": nums = [1, 1, 2, 3, 3, 4, 4, 4, 5, 6, 6, 7] new_length = remove_duplicates(nums) print(f\\"Array after removing duplicates: {nums[:new_length]}\\") print(f\\"New length of array: {new_length}\\") ``` Explanation For the input `nums = [1, 1, 2, 3, 3, 4, 4, 4, 5, 6, 6, 7]`, the function should modify the array to `[1, 2, 3, 4, 5, 6, 7, _, _, _, _, _]`, filling the trailing positions with ignored values, and return `7` as the new length of the array. The output up to the returned length should contain no duplicates and maintain the order of first occurrences from the input.","solution":"from typing import List def remove_duplicates(nums: List[int]) -> int: if not nums: return 0 # Using a single variable to track the unique position unique_pos = 0 # Start from the second element and iterate through the list for i in range(1, len(nums)): # If the current element is different from the element at unique_pos if nums[i] != nums[unique_pos]: unique_pos += 1 nums[unique_pos] = nums[i] # The new length of array with unique elements return unique_pos + 1"},{"question":"# Problem Statement: You are given a task to determine a unique way to rearrange the words in a sentence such that the rearranged sentence forms a valid question. The original sentence will never end with a question mark and may contain punctuation marks. Words should be in randomly shuffled order. Build a function `rearrange_to_question(sentence: str) -> str` that receives a string `sentence`, and returns it with each word\'s capitalization intact but rearranged to end with a question mark. The function should ensure that the result forms a logical question in English. # Input Format: - `sentence` (string): The input sentence containing words and punctuation marks, but not ending with a question mark. Each word in the sentence is separated by one space. # Output Format: - Return a string representing the rearranged sentence that follows the rules of question formation and ends with a question mark. # Example: ```python >>> rearrange_to_question(\\"can you solve this puzzle effectively\\") \\"Can you solve this puzzle effectively?\\" >>> rearrange_to_question(\\"what time does the train leave station\\") \\"What time does the train leave station?\\" >>> rearrange_to_question(\\"is this the best solution you have come up with for the problem\\") \\"Is this the best solution you have come up with for the problem?\\" ``` # Constraints: - Ensure the function handles sentences that include punctuation marks within the sentence but never at the end. - The function should preserve the original capitalization of each word. - Consider edge cases such as one-word inputs where no rearrangement is needed except to add a question mark. - Optimize the function to be efficient with respect to time complexity and correct sentence formation. # Implementation Details: 1. Identify and handle potential punctuation in the input string. 2. Split the input string into words while maintaining the punctuation. 3. Reconstruct the sentence such that it forms a grammatically correct question, ensuring proper word order. 4. End the sentence with a question mark. 5. Return the rearranged sentence while preserving original capitalization.","solution":"def rearrange_to_question(sentence): Rearranges the words in a sentence such that the resulting string forms a valid question while the capitalization of each word remains intact. Args: - sentence (str): The input sentence with words and punctuation marks. Returns: - str: The rearranged sentence ending with a question mark. # Split the sentence into words words = sentence.split() # Capitalize the first word and add the question mark at the end words[0] = words[0].capitalize() question_sentence = \\" \\".join(words) + \\"?\\" return question_sentence"},{"question":"# Coding Challenge **String Segmentation Problem** Given a string and a dictionary of words, write a function to determine if the string can be segmented into a space-separated sequence of one or more dictionary words. # Function Signature ```python def can_segment_string(s: str, word_dict: List[str]) -> bool: pass ``` # Input - `s`: A non-empty string consisting of lowercase letters. (e.g., \\"applepie\\") - `word_dict`: A list of words (strings) representing the dictionary. The dictionary words are non-empty and consist of lowercase letters. (e.g., [\\"apple\\", \\"pie\\", \\"pear\\", \\"applepie\\"]) # Output - A boolean value `True` if the string can be segmented into one or more words from the dictionary, otherwise `False`. # Example ```python assert can_segment_string(\\"applepie\\", [\\"apple\\", \\"pie\\"]) == True # The string can be segmented as \\"apple pie\\" assert can_segment_string(\\"applepie\\", [\\"pear\\", \\"pie\\"]) == False # The string cannot be segmented using given dictionary assert can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True # The string can be segmented as \\"leet code\\" assert can_segment_string(\\"catsanddog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == True # The string can be segmented as \\"cats and dog\\" assert can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False ``` # Constraints - 1 <= len(s) <= 300 - 1 <= len(word_dict) <= 10,000 - 1 <= len(word_dict[i]) <= 20 # Requirements 1. Your function must be efficient enough to handle large inputs within acceptable time limits. 2. Handle edge cases gracefully as per the analysis provided. # Optimization Challenge Design the algorithm to utilize dynamic programming to ensure it remains efficient for large input strings and dictionary sizes. Avoid rechecking the same substrings multiple times within your solution.","solution":"from typing import List def can_segment_string(s: str, word_dict: List[str]) -> bool: Determines if the string can be segmented into a sequence of one or more dictionary words. word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True # base case: empty string for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"# Question: File Operation and String Manipulation Objective: You are tasked to develop a script that reads data from a file, performs specific string manipulations, and then writes the modified data to a new file. This is to help in processing and transforming data for further analysis. Part 1: Reading and Writing Files 1. **Function: `read_file`** * Read the contents of a file specified by the file path. * Ensure that the function returns the content as a string. ```python def read_file(file_path: str) -> str: Read the contents of a file. Parameters: file_path (str): Path to the file to be read. Returns: str: Content of the file as a string. pass # Your implementation ``` 2. **Function: `write_file`** * Write a given string to a file at the specified file path. * Ensure that the function handles file operations correctly and overwrites any existing content. ```python def write_file(file_path: str, content: str) -> None: Write content to a file. Parameters: file_path (str): Path to the file where the content will be written. content (str): The content to be written to the file. pass # Your implementation ``` Part 2: String Manipulation 3. **Function: `process_text`** * Perform multiple string manipulations on the input text. * Convert all characters to uppercase. * Replace all occurrences of the word \\"foo\\" with \\"bar\\". * Ensure that function operations are case-insensitive when replacing words. ```python def process_text(text: str) -> str: Perform string manipulations on the text. Parameters: text (str): The input text to be processed. Returns: str: The manipulated text. pass # Your implementation ``` Constraints & Requirements: * Ensure file operations safely handle potential I/O errors (e.g., file not found, read/write permissions). * String manipulations should be case-insensitive for word replacement. * Functions should be modular and adhere to single-responsibility principles. Example: ```python # Assume \'input.txt\' contains the text: \\"Hello world! foo\\" input_text = read_file(\'input.txt\') # Example Input: \\"Hello world! foo\\" processed_text = process_text(input_text) # Example Output: \\"HELLO WORLD! BAR\\" write_file(\'output.txt\', processed_text) ``` Ensure your implementation handles edge cases efficiently, performs file operations robustly, and appropriately processes the text as specified.","solution":"def read_file(file_path: str) -> str: Read the contents of a file. Parameters: file_path (str): Path to the file to be read. Returns: str: Content of the file as a string. try: with open(file_path, \'r\', encoding=\'utf-8\') as file: return file.read() except Exception as e: raise e def write_file(file_path: str, content: str) -> None: Write content to a file. Parameters: file_path (str): Path to the file where the content will be written. content (str): The content to be written to the file. try: with open(file_path, \'w\', encoding=\'utf-8\') as file: file.write(content) except Exception as e: raise e def process_text(text: str) -> str: Perform string manipulations on the text. Parameters: text (str): The input text to be processed. Returns: str: The manipulated text. text = text.upper() text = text.replace(\'FOO\', \'BAR\') return text"},{"question":"# Find Longest Substring with K Unique Characters Objective Write a function `longest_substring_with_k_unique_characters` that takes as input a string and an integer `k` and returns the length of the longest substring that contains exactly `k` unique characters. Input and Output Formats * **Input**: * `s` - a string consisting of lowercase alphabets. * `k` - an integer representing the number of unique characters required. * **Output**: * An integer representing the length of the longest substring with exactly `k` unique characters. Constraints * The input string `s` will have at most 10^5 characters. * The integer `k` will be in the range [1, 26]. Performance Requirements * Aim for a time complexity of O(n). * Ensure space complexity is O(1), considering constant space usage for character frequency storage as we are dealing with a fixed alphabet size. Example ```python print(longest_substring_with_k_unique_characters(\\"aabacbebebe\\", 3)) # Output: 7 (\\"cbebebe\\") print(longest_substring_with_k_unique_characters(\\"aaaa\\", 1)) # Output: 4 (\\"aaaa\\") print(longest_substring_with_k_unique_characters(\\"aabbcc\\", 2)) # Output: 4 (\\"aabb\\" or \\"bbcc\\") ``` Scenario and Context You are developing a feature to analyze text data where it is useful to find the longest segment of text that exhibits diversity in character usage. This is valuable in fields such as linguistics, where understanding character distribution in substrings can reveal interesting patterns. Implementation Notes Consider edge cases such as: * An empty input string. * Strings with fewer unique characters than `k`. * Strings where `k` is higher than the number of unique characters in the string. Implement the function in a way that optimizes performance and adheres to the constraints.","solution":"def longest_substring_with_k_unique_characters(s, k): Given a string s, find the length of the longest substring that contains exactly k unique characters. :param s: A string consisting of lowercase alphabets. :param k: An integer representing the number of unique characters required. :return: An integer representing the length of the longest substring with exactly k unique characters. if k == 0 or len(s) == 0: return 0 left = 0 right = 0 char_frequency = {} max_length = 0 while right < len(s): char_frequency[s[right]] = char_frequency.get(s[right], 0) + 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 if len(char_frequency) == k: max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"# Coding Challenge: Implement a Custom Recursive QuickSort **Context**: You have been given an array that needs to be sorted in ascending order using the QuickSort algorithm. QuickSort is a widely used sorting algorithm that works by selecting a \'pivot\' element from the array and partitioning the other elements into two subarrays according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively. **Your Task**: Write a Python function `quick_sort(arr)` that performs the QuickSort algorithm recursively and returns a sorted version of the input array. Additionally, your implementation should handle edge cases effectively and ensure optimal performance. **Input**: - `arr`: A list of integers that needs to be sorted. **Output**: - `sorted_arr`: A list of integers sorted in ascending order. **Example input/output**: - Example 1: - Input: `[3, 6, 8, 10, 1, 2, 1]` - Output: `[1, 1, 2, 3, 6, 8, 10]` - Example 2: - Input: `[1, 2, 3, 0, -1, 7]` - Output: `[-1, 0, 1, 2, 3, 7]` **Constraints**: - `1 <= len(arr) <= 10^5` - `-10^9 <= arr[i] <= 10^9` for every element `arr[i]` **Optimization to Implement**: 1. **Pivot Selection**: Use a median-of-three method for selecting the pivot to ensure better performance on average. 2. **Tail Recursion**: Optimize the recursive calls to prevent stack overflow for very large arrays. 3. **In-Place Sorting**: Ensure the sorting algorithm works in place to conserve memory. ```python # Custom Recursive QuickSort Function def quick_sort(arr): QuickSort implementation using recursive approach. Args: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. if len(arr) <= 1: return arr def partition(array, low, high): pivot = array[low] left = low + 1 right = high done = False while not done: while left <= right and array[left] <= pivot: left = left + 1 while array[right] >= pivot and right >=left: right = right - 1 if right < left: done = True else: array[left], array[right] = array[right], array[left] array[low], array[right] = array[right], array[low] return right def quick_sort_helper(array, low, high): if low < high: pivot_index = partition(array, low, high) quick_sort_helper(array, low, pivot_index - 1) quick_sort_helper(array, pivot_index + 1, high) quick_sort_helper(arr, 0, len(arr) - 1) return arr # Example usage: arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr = quick_sort(arr) print(\\"Sorted array:\\", sorted_arr) ``` **Note**: Ensure that your approach follows the outlined optimization practices, especially focusing on proper pivot selection and tail recursion where possible to improve performance and handle large datasets efficiently.","solution":"def quick_sort(arr): QuickSort implementation using recursive approach. Args: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. if len(arr) <= 1: return arr def partition(array, low, high): pivot = array[high] i = low - 1 for j in range(low, high): if array[j] < pivot: i = i + 1 array[i], array[j] = array[j], array[i] array[i + 1], array[high] = array[high], array[i + 1] return i + 1 def quick_sort_helper(array, low, high): while low < high: pivot_index = partition(array, low, high) if pivot_index - low < high - pivot_index: quick_sort_helper(array, low, pivot_index - 1) low = pivot_index + 1 else: quick_sort_helper(array, pivot_index + 1, high) high = pivot_index - 1 quick_sort_helper(arr, 0, len(arr) - 1) return arr # Example usage: arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr = quick_sort(arr) print(\\"Sorted array:\\", sorted_arr)"},{"question":"Challenge: Unique Character Identifier You are required to implement a function, `unique_char_identifier`, that identifies the first character in a string that does not repeat. If all characters repeat or if the input string is empty, the function should return an empty string `\\"\\"`. # Function Signature ```python def unique_char_identifier(string: str) -> str: ``` # Input - `string` (str): A non-empty string containing only lowercase alphabetical characters. # Output - (str): A single character string representing the first non-repeating character, or an empty string if all characters repeat. # Constraints - The input string will only consist of lowercase alphabetical characters and can be arbitrarily long. - The function must have a time complexity of O(n), where n is the length of the string. # Error Handling - Raise a `ValueError` if `string` is not a string or if it is empty. # Examples ```python assert unique_char_identifier(\\"swiss\\") == \\"w\\" assert unique_char_identifier(\\"programming\\") == \\"p\\" assert unique_char_identifier(\\"aabbcc\\") == \\"\\" assert unique_char_identifier(\\"abcd\\") == \\"a\\" # Edge cases assert unique_char_identifier(\\"\\") == \\"\\" assert unique_char_identifier(\\"aabbccdef\\") == \\"d\\" assert unique_char_identifier(\\"a\\" * 100000 + \\"b\\" * 100000 + \\"c\\") == \\"c\\" ``` # Explanation - `unique_char_identifier(\\"swiss\\")` returns `\\"w\\"` because: - Characters and their counts: `s` (3), `w` (1), `i` (1) - The first non-repeating character is `w`. - `unique_char_identifier(\\"programming\\")` returns `\\"p\\"` because: - Characters and their counts: `p` (1), `r` (2), `o` (1), `g` (2), `a` (1), `m` (2), `i` (1), `n` (1) - The first non-repeating character is `p`. # Additional Notes - Ensure to handle edge cases such as empty strings or strings where all characters repeat. - Optimize the solution to run efficiently for longer strings.","solution":"def unique_char_identifier(string: str) -> str: if not isinstance(string, str): raise ValueError(\\"Input must be a string.\\") if not string: return \\"\\" # Dictionary to store the frequency of the characters char_count = {} # First pass: Count occurrences of each character for char in string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: Find the first character with a count of 1 for char in string: if char_count[char] == 1: return char # If no unique character found, return empty string return \\"\\""},{"question":"# Task: Implement a function to calculate the similarity score between two strings using the Levenshtein distance. # Function Signature: ```python def calculate_similarity_score(str1: str, str2: str) -> float: pass ``` # Description: The Levenshtein distance between two strings is the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into the other. Your task is to write a function `calculate_similarity_score` that calculates the similarity score between two strings based on the Levenshtein distance. # Requirements: 1. **Input**: Two strings `str1` and `str2`. 2. **Output**: A float representing the similarity score between `str1` and `str2`. The similarity score is defined as: [ text{Similarity Score} = 1 - frac{text{Levenshtein Distance}}{max(text{len(str1)}, text{len(str2)})} ] - If both strings are empty, return 1.0 as they are identical. - If only one of the strings is empty, return 0.0 as there are no common characters. 3. **Constraints**: - The function should handle strings of varying lengths efficiently. 4. **Performance**: - Ensure the solution is optimized for performance and handles edge cases gracefully. # Example: ```python str1 = \\"kitten\\" str2 = \\"sitting\\" similarity_score = calculate_similarity_score(str1, str2) print(f\\"The similarity score between \'{str1}\' and \'{str2}\' is {similarity_score:.2f}\\") str1 = \\"flaw\\" str2 = \\"lawn\\" similarity_score = calculate_similarity_score(str1, str2) print(f\\"The similarity score between \'{str1}\' and \'{str2}\' is {similarity_score:.2f}\\") ``` # Hints: - Use dynamic programming to compute the Levenshtein distance efficiently. - Create a two-dimensional array to store distances between prefixes of the two strings. - Consider edge cases such as empty strings and strings of different lengths.","solution":"def calculate_similarity_score(str1: str, str2: str) -> float: def levenshtein_distance(s1, s2): if len(s1) < len(s2): return levenshtein_distance(s2, s1) if len(s2) == 0: return len(s1) previous_row = range(len(s2) + 1) for i, c1 in enumerate(s1): current_row = [i + 1] for j, c2 in enumerate(s2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] max_len = max(len(str1), len(str2)) if max_len == 0: return 1.0 lev_distance = levenshtein_distance(str1, str2) similarity_score = 1 - (lev_distance / max_len) return similarity_score"},{"question":"# String Permutation Checker Context Permutation checking is a common problem in computer science, where you need to determine if one string is a rearrangement of another string. This problem has applications in areas such as anagram detection, cryptography, and data processing. You are required to implement functions that: 1. Check if two strings are permutations of each other. 2. Handle case sensitivity and whitespace in the strings. Tasks 1. **Implement the `are_permutations` function**: - **Input**: Two strings. - **Output**: A boolean indicating if the strings are permutations of each other, ignoring case and whitespace. 2. **Implement the `normalize_string` function**: - **Input**: A string. - **Output**: A lowercase string with all whitespace removed. Example ```python # are_permutations examples print(are_permutations(\\"Listen\\", \\"Silent\\")) # should return True print(are_permutations(\\"Triangle\\", \\"Integral\\")) # should return True print(are_permutations(\\"Apple\\", \\"Pabble\\")) # should return False # normalize_string examples print(normalize_string(\\" LisTen \\")) # should return \\"listen\\" print(normalize_string(\\"Tri Angle \\")) # should return \\"triangle\\" print(normalize_string(\\"Wh!te Sp@ce\\")) # should return \\"wh!tesp@ce\\" ``` **Constraints**: 1. Strings can contain letters, digits, and special characters. 2. The comparison should be case-insensitive. 3. Whitespace should be removed before comparison. **Performance Requirement**: Your solution should handle typical usage efficiently. Optimal performance is necessary for strings up to 1,000 characters in length.","solution":"def normalize_string(s): Converts the input string to lowercase and removes all whitespace. Args: s (str): The input string to be normalized. Returns: str: The normalized string. return \'\'.join(s.split()).lower() def are_permutations(s1, s2): Checks if two strings are permutations of each other, ignoring case and whitespace. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: bool: True if the strings are permutations of each other, False otherwise. return sorted(normalize_string(s1)) == sorted(normalize_string(s2))"},{"question":"# Remove Duplicates from Sorted Array You are given a function `remove_duplicates` that removes duplicates from a sorted integer array and returns the length of the new array without duplicates. The function works correctly for typical cases but needs improvement in efficiency and handling of edge cases, such as empty arrays. Your task is to provide a new implementation of the `remove_duplicates` function considering the core principles and addressing the challenges derived from the analysis of the provided implementation. Your function should improve performance and error-handling aspects. # Requirements: 1. **Input**: A list of integers where the integers are sorted in non-decreasing order. 2. **Output**: An integer representing the length of the new array after duplicates have been removed. 3. **Constraints**: - The input list must be sorted in non-decreasing order. - The input list may have a length of up to `10^6`. - If the input list is empty, return `0`. # Performance: - Optimize the function to handle up to `10^6` length lists efficiently. - Ensure the algorithm runs in O(n) time complexity, where n is the length of the list. Additional Requirements: - Raise a `ValueError` for: - Input that is not a list. - Input that contains elements out of order (not in non-decreasing order). Example usage: ```python >>> remove_duplicates([1, 1, 2]) 2 >>> remove_duplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]) 5 >>> remove_duplicates([]) 0 >>> remove_duplicates({1, 1, 2}) Traceback (most recent call last): ... ValueError: Input is not a list >>> remove_duplicates([1, 3, 2]) Traceback (most recent call last): ... ValueError: Input list is not sorted in non-decreasing order ```","solution":"def remove_duplicates(nums): Removes duplicates from a sorted list of integers and returns the new length. Args: nums (list of int): A list of integers sorted in non-decreasing order. Returns: int: The length of the list after removing duplicates. Raises: ValueError: If the input is not a list or the list is not sorted in non-decreasing order. if not isinstance(nums, list): raise ValueError(\\"Input is not a list\\") for i in range(len(nums) - 1): if nums[i] > nums[i + 1]: raise ValueError(\\"Input list is not sorted in non-decreasing order\\") if not nums: return 0 unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] return unique_index + 1"},{"question":"# String Permutation Checker Problem Statement: Given two strings, `s1` and `s2`, both containing only lowercase alphabets, your task is to write a function that determines if `s1` is a permutation (an anagram) of `s2`. Two strings are permutations of each other if one string\'s characters can be rearranged to form the other string. For example, \\"abc\\" is a permutation of \\"bca\\", and \\"aaa\\" is not a permutation of \\"aab\\". Function Signature ```python def are_permutations(s1: str, s2: str) -> bool: pass ``` # Input - `s1` (1 ≤ len(s1) ≤ 10^5): a string containing only lowercase alphabets. - `s2` (1 ≤ len(s2) ≤ 10^5): a string containing only lowercase alphabets. # Output - Returns `True` if `s1` is a permutation of `s2`. - Returns `False` otherwise. # Constraints - Consider the most efficient way to compare permutation, possibly leveraging frequency counts. - Optimize the function to handle the maximum input size effectively. # Examples: ```python assert are_permutations(\\"listen\\", \\"silent\\") == True assert are_permutations(\\"triangle\\", \\"integral\\") == True assert are_permutations(\\"abc\\", \\"def\\") == False assert are_permutations(\\"a\\", \\"aa\\") == False assert are_permutations(\\"ab\\", \\"ba\\") == True assert are_permutations(\\"aaaaaa\\", \\"aaaaaab\\") == False assert are_permutations(\\"abcabc\\", \\"cbacba\\") == True ```","solution":"def are_permutations(s1: str, s2: str) -> bool: Determine if s1 is a permutation of s2. # If lengths are not the same, they cannot be permutations if len(s1) != len(s2): return False # Use frequency count (hashmap) to check character counts from collections import Counter # Compare the frequency counters of both strings return Counter(s1) == Counter(s2)"},{"question":"# Coding Challenge: Find the Longest Common Substring # Objective Write a function that finds the longest common substring among an array of strings. The function should be efficient and handle edge cases effectively. # Task Function Specification * **Function Name**: `longest_common_substring` * **Input**: * A single parameter: `strings` - a list of strings (1 ≤ `len(strings[i])` ≤ (10^4)) * **Output**: * A string representing the longest common substring shared among all input strings. * **Constraints**: * The list is guaranteed to contain at least 1 string. * All elements in the list are non-empty strings consisting of printable ASCII characters. * If no common substring exists, return an empty string. Examples ```python # Example 1: # Input: strings = [\\"babcde\\", \\"abc\\", \\"bc\\"] # Output: \\"b\\" # Example 2: # Input: strings = [\\"interspecies\\", \\"interstellar\\", \\"interstate\\"] # Output: \\"inters\\" # Example 3: # Input: strings = [\\"throne\\", \\"throne\\"] # Output: \\"throne\\" # Example 4: # Input: strings = [\\"dog\\", \\"racecar\\", \\"car\\"] # Output: \\"\\" ``` # Additional Instructions 1. **Edge Case Considerations**: * Handle cases with only one string in the list. * Handle cases with completely distinct strings. 2. **Validation**: Raise appropriate errors for invalid input conditions (e.g., empty list). # Implementation Notes * You can use helper functions as needed. * Ensure the function does not use any built-in functions or libraries specifically meant for computing longest common substrings. * Focus on optimizing performance, especially considering the potential length of the strings and size of the list.","solution":"def longest_common_substring(strings): def common_substring_between_two(s1, s2): len1, len2 = len(s1), len(s2) max_len = 0 end_index = 0 dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_len: max_len = dp[i][j] end_index = i return s1[end_index - max_len:end_index] if not strings: raise ValueError(\\"Input list cannot be empty.\\") if len(strings) == 1: return strings[0] common_substr = strings[0] for i in range(1, len(strings)): common_substr = common_substring_between_two(common_substr, strings[i]) if not common_substr: break return common_substr"},{"question":"# Pathfinding in a Weighted Graph **Context:** You are given a weighted graph represented by an adjacency matrix. Your task is to determine the shortest path from a start node to all other nodes using Dijkstra\'s Algorithm. # Requirements: 1. Implement a graph class that supports: * **Initialization**: Create a graph from a given adjacency matrix. * **Shortest Path Calculation**: Use Dijkstra\'s algorithm to compute the shortest paths from a start node to all other nodes. * **Path Retrieval**: Retrieve the shortest path and the distance to any specific node from the start node based on the precomputed shortest paths. # Specifications: * **Function Definitions**: * `__init__(self, matrix: List[List[int]])`: Initialize the graph with the given adjacency matrix. * `calculate_shortest_paths(self, start: int) -> Dict[int, int]`: Compute the shortest paths from the start node to all other nodes and return a dictionary where the keys are nodes and the values are the shortest path distances. * `get_shortest_path(self, start: int, end: int) -> Tuple[List[int], int]`: Return the shortest path as a list of nodes and the total distance from the start node to the end node. If no path exists, return an empty list and a distance of -1. * **Input Constraints**: * The adjacency matrix is a square matrix with non-negative integers, where a value of 0 indicates no direct path (unless it\'s the diagonal with zero weights). * The matrix size is n x n, with 1 ≤ n ≤ 1000. * 0 ≤ matrix[i][j] ≤ 10^6. * Start and end nodes are valid indices within the graph. * **Example**: ```python adj_matrix = [ [0, 1, 4, 0, 0, 0], [1, 0, 4, 2, 7, 0], [4, 4, 0, 3, 5, 0], [0, 2, 3, 0, 4, 6], [0, 7, 5, 4, 0, 7], [0, 0, 0, 6, 7, 0] ] graph = Graph(adj_matrix) shortest_paths = graph.calculate_shortest_paths(0) assert shortest_paths == {0: 0, 1: 1, 2: 4, 3: 3, 4: 7, 5: 9} path, distance = graph.get_shortest_path(0, 5) assert path == [0, 1, 3, 5] assert distance == 9 ``` * **Edge Cases to Consider**: * Graph with only one node. * Disconnected graph (some nodes unreachable). * Multiple shortest paths of the same length. # Objective: Provide a clean and efficient implementation of Dijkstra\'s algorithm tailored to handle large graphs robustly. Ensure your solution can handle sparse and dense graphs efficiently.","solution":"import heapq from typing import List, Dict, Tuple class Graph: def __init__(self, matrix: List[List[int]]): self.matrix = matrix self.n = len(matrix) def calculate_shortest_paths(self, start: int) -> Dict[int, int]: dist = {i: float(\'inf\') for i in range(self.n)} dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v in range(self.n): if self.matrix[u][v] != 0 and (self.matrix[u][v] + current_dist < dist[v]): dist[v] = self.matrix[u][v] + current_dist heapq.heappush(priority_queue, (dist[v], v)) return dist def get_shortest_path(self, start: int, end: int) -> Tuple[List[int], int]: dist = self.calculate_shortest_paths(start) if dist[end] == float(\'inf\'): return ([], -1) path = [] current = end while current != start: path.append(current) for i in range(self.n): if self.matrix[i][current] != 0 and (dist[current] - self.matrix[i][current] == dist[i]): current = i break path.append(start) path.reverse() return (path, dist[end])"},{"question":"# Coding Question: Minimum Window Substring with Character Frequencies **Objective**: Write a function that finds the smallest window in a given string that contains all characters (including their exact frequencies) of another string. # Context Given two strings, `s` and `t`, the task is to find the minimum window in `s` which will contain all the characters in `t` including their frequencies. If no such window exists, return an empty string. # Input and Output Format - **Input**: - `s`: A `String` representing the source string. - `t`: A `String` representing the target string whose characters need to be contained in the window. - **Output**: - A `String` representing the smallest window in `s` that contains all characters (including their frequencies) of `t`. If no such window exists, return an empty string. # Constraints - `1 ≤ len(s) ≤ 10^5` - `1 ≤ len(t) ≤ 10^5` - Both `s` and `t` are composed of ASCII characters. # Performance Requirements - Optimize for time and space efficiency given the constraints. - Handle cases where the target string `t` may have characters not present in `s`. # Examples ```python def min_window_substring(s: str, t: str) -> str: pass # Example 1: # Input: # s = \\"ADOBECODEBANC\\", t = \\"ABC\\" # Output: \\"BANC\\" # Example 2: # Input: # s = \\"a\\", t = \\"a\\" # Output: \\"a\\" # Example 3: # Input: # s = \\"a\\", t = \\"aa\\" # Output: \\"\\" # Example 4: # Input: # s = \\"abcabdebac\\", t = \\"cda\\" # Output: \\"cabd\\" ``` # Additional Notes 1. The order of characters in the window does not matter. 2. The solution should take into account the frequency of each character in `t`. 3. Consider utilizing sliding window techniques for efficient processing.","solution":"from collections import Counter, defaultdict def min_window_substring(s: str, t: str) -> str: if not s or not t: return \\"\\" count_t = Counter(t) count_s = defaultdict(int) required = len(count_t) formed = 0 l, r = 0, 0 min_len = float(\\"inf\\") min_window = (0, 0) while r < len(s): char = s[r] count_s[char] += 1 if char in count_t and count_s[char] == count_t[char]: formed += 1 while l <= r and formed == required: current_window_length = r - l + 1 if current_window_length < min_len: min_len = current_window_length min_window = (l, r) count_s[s[l]] -= 1 if s[l] in count_t and count_s[s[l]] < count_t[s[l]]: formed -= 1 l += 1 r += 1 l, r = min_window return s[l:r+1] if min_len != float(\\"inf\\") else \\"\\""},{"question":"# Problem Statement You are given a string containing only lowercase alphabetic characters and numbers. You need to determine the sum of all numeric digits in the string. If there are no numeric digits in the string, return 0. Write a function to compute the sum of numeric digits in the string, adhering to the following function signature: Function Signature: ```python def sum_of_digits(s: str) -> int: # Your code here ``` # Input * `s`: A string containing lowercase alphabetic characters and numeric digits. * Constraints: * 1 <= len(s) <= 100000 # Output * Returns an integer: * The sum of all numeric digits in the string. * 0 if there are no numeric digits in the string. # Example Scenarios Example 1 * **Input**: `\\"abc123\\"` * **Output**: `6` * Explanation: The numeric digits in the string are `1`, `2`, and `3`. Their sum is `6`. Example 2 * **Input**: `\\"a1b2c3\\"` * **Output**: `6` * Explanation: The numeric digits in the string are `1`, `2`, and `3`. Their sum is `6`. Example 3 * **Input**: `\\"abcdef\\"` * **Output**: `0` * Explanation: There are no numeric digits in the string, so the sum is `0`. # Evaluation Criteria * Correctness: Solutions must correctly sum all numeric digits in the given string. * Efficiency: Solutions should work within the constraints efficiently. * Edge Case Handling: Solutions should correctly manage inputs with no digits and very large strings. * Code Quality: Clear, readable, and well-documented code. Write your function below: ```python def sum_of_digits(s: str) -> int: total_sum = 0 for char in s: if char.isdigit(): total_sum += int(char) return total_sum ```","solution":"def sum_of_digits(s: str) -> int: total_sum = 0 for char in s: if char.isdigit(): total_sum += int(char) return total_sum"},{"question":"# Movie Rating Histogram Calculation You are tasked with implementing a function that calculates the distribution of user ratings for a movie. The function should compute how many users gave each possible rating to the movie, and return these counts. Function Signature ```python def calculate_rating_histogram(ratings: List[int]) -> Dict[int, int]: pass ``` Objective Write a function `calculate_rating_histogram` that takes a list of integers representing user ratings and returns a dictionary where the keys are the ratings (from 1 to 5) and the values are the counts of how many users gave each rating. Input * `ratings` (List[int]): A list of integers where each integer is a rating (1 <= rating <= 5). The length of the list will be between 1 and 10^6. Output * Dictionary: A dictionary with keys ranging from 1 to 5, inclusive, and values representing the count of each rating. Constraints * If a rating from 1 to 5 is not in the `ratings` list, its count should be 0. Examples ```python assert calculate_rating_histogram([1, 2, 2, 3, 4, 4, 4, 5]) == {1: 1, 2: 2, 3: 1, 4: 3, 5: 1} assert calculate_rating_histogram([5, 5, 5, 5, 5]) == {1: 0, 2: 0, 3: 0, 4: 0, 5: 5} assert calculate_rating_histogram([1, 1, 1, 2, 3, 3, 4, 5, 5, 5, 5]) == {1: 3, 2: 1, 3: 2, 4: 1, 5: 4} ``` Notes: * Ensure the function handles large input sizes efficiently. * The dictionary keys should always include all ratings from 1 to 5, even if some of them have a count of zero. Good luck!","solution":"from typing import List, Dict def calculate_rating_histogram(ratings: List[int]) -> Dict[int, int]: histogram = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0} for rating in ratings: if rating in histogram: histogram[rating] += 1 return histogram"},{"question":"# Question: Implement a Simple Text Justification Given a list of words and a line width `max_width`, write a function `full_justify(words: List[str], max_width: int) -> List[str]` to format the text such that each line has exactly `max_width` characters, and is fully (left and right) justified. You should distribute extra spaces as evenly as possible between words, with the first slots getting more spaces when spaces are not evenly divisible. For the last line of text, it should be left-justified and no extra space is inserted between words. Constraints: - Every word contains only lowercase English letters. - `1 <= words.length <= 300`. - `1 <= words[i].length <= 20`. - `1 <= max_width <= 100`. - The words array will at least contain one word. Input: - `words` (List[str]): A list of words to be justified. - `max_width` (int): The number of characters for each line. Output: - A list of strings where each string represents a fully justified line of text. Example: - `full_justify([\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], 16)` should return: ``` [\\"This is an\\", \\"example of text\\", \\"justification. \\"] ``` - `full_justify([\\"What\\", \\"must\\", \\"be\\", \\"acknowledgment\\", \\"shall\\", \\"be\\"], 16)` should return: ``` [\\"What must be\\", \\"acknowledgment \\", \\"shall be \\"] ``` - `full_justify([\\"Science\\",\\"is\\",\\"what\\",\\"we\\",\\"understand\\",\\"well\\",\\"enough\\",\\"to\\",\\"explain\\",\\"to\\",\\"a\\",\\"computer.\\",\\"Art\\",\\"is\\",\\"everything\\",\\"else\\",\\"we\\",\\"do\\"], 20)` should return: ``` [\\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\"] ``` Edge Cases: - If only one word is in the list, and it is shorter than `max_width`, the result should be that word followed by spaces to make up the `max_width`. **Function Signature:** ```python def full_justify(words: List[str], max_width: int) -> List[str]: pass ``` Your implementation should handle edge cases gracefully, and it should be optimized for lists of varying lengths and widths.","solution":"from typing import List def full_justify(words: List[str], max_width: int) -> List[str]: def justify_line(line_words, line_length, max_width): if len(line_words) == 1: return line_words[0].ljust(max_width) total_spaces = max_width - line_length total_gaps = len(line_words) - 1 even_spaces = total_spaces // total_gaps extra_spaces = total_spaces % total_gaps justified_line = \\"\\" for i in range(total_gaps): justified_line += line_words[i] + \\" \\" * even_spaces if i < extra_spaces: justified_line += \\" \\" justified_line += line_words[-1] return justified_line res, current_line, line_length = [], [], 0 for word in words: if line_length + len(word) + len(current_line) > max_width: res.append(justify_line(current_line, line_length, max_width)) current_line, line_length = [], 0 current_line.append(word) line_length += len(word) last_line = \\" \\".join(current_line).ljust(max_width) res.append(last_line) return res"},{"question":"**Task**: Implement a function `generate_morse_code(text: str) -> str` that converts a given text string into its equivalent Morse code representation. Each character in the text string will be converted to Morse code, with individual Morse code symbols separated by a single space and words separated by a single forward slash (\'/\'). **Requirements**: - The function must handle both uppercase and lowercase English alphabet characters, numerals (0-9), and standard punctuation (period, comma, question mark, exclamation mark, and space). - Use the standard Morse code dictionary to perform the conversion. - Maintain the original spacing and punctuation precisely. **Input/Output Specification**: - **Input**: `text` - A string consisting of letters, numbers, punctuation, and spaces. - **Output**: A string representing the input text converted to Morse code. **Constraints**: - The input string is non-empty and contains only valid characters as specified above. - Preserve the input text\'s structure and spacing in the output Morse code. **Performance**: Your function should run efficiently with a time complexity of O(n), where n is the length of the input text. **Scenario**: Given an input text string, you need to: - Encode each character into Morse code using a predefined dictionary. - Separate Morse code symbols for characters with a single space. - Use a forward slash (\'/\') to separate words initially separated by a single space in the input text. **Edge Cases**: - Text containing multiple spaces between words. - Text with various punctuation marks. - Text with a mix of uppercase and lowercase letters. **Example**: - Input: `\\"Hello, World!\\"` - Output: `\\".... . .-.. .-.. --- --..-- / .-- --- .-. .-.. -.. -.-.--\\"` ```python def generate_morse_code(text: str) -> str: morse_code_dict = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'.\': \'.-.-.-\', \',\': \'--..--\', \'?\': \'..--..\', \'!\': \'-.-.--\', \' \': \'/\' } result = [] for char in text.upper(): if char in morse_code_dict: result.append(morse_code_dict[char]) return \' \'.join(result) ```","solution":"def generate_morse_code(text: str) -> str: morse_code_dict = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'.\': \'.-.-.-\', \',\': \'--..--\', \'?\': \'..--..\', \'!\': \'-.-.--\', \' \': \'/\' } result = [] for char in text.upper(): if char in morse_code_dict: result.append(morse_code_dict[char]) return \' \'.join(result)"},{"question":"# Coding Assessment Question Context You are developing a scaling system for a large distributed logging application. Each log entry is associated with a server\'s timestamp and its unique ID. An important functionality is to efficiently merge and sort logs coming from different servers. Problem Statement You are given multiple lists of log entries. Each log entry is represented as a tuple `(timestamp: int, server_id: int)`. Your task is to merge these lists into a single sorted list based on the timestamps. Function Signature ```python from typing import List, Tuple def merge_sorted_logs(logs: List[List[Tuple[int, int]]]) -> List[Tuple[int, int]]: Merges multiple sorted lists of log entries based on their timestamps into a single sorted list. pass ``` Example ```python logs = [ [(1, 1), (4, 1), (5, 1)], [(1, 2), (3, 2), (6, 2)], [(2, 3), (4, 3)] ] print(merge_sorted_logs(logs)) # Output: [(1, 1), (1, 2), (2, 3), (3, 2), (4, 1), (4, 3), (5, 1), (6, 2)] ``` Explanation The function `merge_sorted_logs` takes a list of lists where each sublist contains log entries sorted by the timestamp. The output is a single list containing all log entries sorted by the timestamp. Constraints * Number of log lists (`k`): 1 ≤ k ≤ 10^5 * Number of log entries per list: 0 ≤ number of entries ≤ 10^5 * The timestamp for each log entry is a non-negative integer. * The server ID is a positive integer. * Total number of log entries across all lists will not exceed 10^6. Requirements * Your solution must be efficient in terms of time and space complexity. * Use appropriate data structures to handle merging efficiently. Your implementation will be assessed based on correctness, efficiency (both time and space complexities), and proper handling of edge cases.","solution":"from typing import List, Tuple import heapq def merge_sorted_logs(logs: List[List[Tuple[int, int]]]) -> List[Tuple[int, int]]: Merges multiple sorted lists of log entries based on their timestamps into a single sorted list. # Create a min heap to maintain the order of log entries min_heap = [] # Populate the heap with the first entry from each log list for log_index, log in enumerate(logs): if log: heapq.heappush(min_heap, (log[0][0], log[0][1], log_index, 0)) # (timestamp, server_id, log_list_index, entry_index) merged_logs = [] while min_heap: timestamp, server_id, log_index, entry_index = heapq.heappop(min_heap) merged_logs.append((timestamp, server_id)) # If there is a next entry in the same log list, push it to the heap if entry_index + 1 < len(logs[log_index]): next_entry = logs[log_index][entry_index + 1] heapq.heappush(min_heap, (next_entry[0], next_entry[1], log_index, entry_index + 1)) return merged_logs"},{"question":"# Problem Statement You are developing a payment processing system where transactions need to be grouped into batches based on the identical customer ID and the sum of amounts should be calculated for each batch. Write a function to group transactions and calculate the total amount for each customer. # Requirements: Implement a function `batch_transactions` that takes in: 1. A list of transactions, where each transaction is represented by a dictionary with keys `customer_id` and `amount`. Your function should return a dictionary where the keys are customer IDs and the values are the total amounts they have transacted. Constraints: * Each transaction is represented by a dictionary with keys `customer_id` (a string) and `amount` (a float). * The list of transactions may be empty. # Function Signature: ```python from typing import List, Dict def batch_transactions(transactions: List[Dict[str, any]]) -> Dict[str, float]: pass ``` # Example: ```python def batch_transactions(transactions: List[Dict[str, any]]) -> Dict[str, float]: # Your implementation here # Example Usage transactions = [ {\\"customer_id\\": \\"A123\\", \\"amount\\": 100.0}, {\\"customer_id\\": \\"B456\\", \\"amount\\": 200.0}, {\\"customer_id\\": \\"A123\\", \\"amount\\": 50.0}, {\\"customer_id\\": \\"C789\\", \\"amount\\": 300.0}, ] print(batch_transactions(transactions)) # Output: {\'A123\': 150.0, \'B456\': 200.0, \'C789\': 300.0} transactions = [] print(batch_transactions(transactions)) # Output: {} ``` # Additional Examples: ```python transactions = [{\\"customer_id\\": \\"D012\\", \\"amount\\": 500.0}] print(batch_transactions(transactions)) # Output: {\'D012\': 500.0} transactions = [ {\\"customer_id\\": \\"E345\\", \\"amount\\": 200.5}, {\\"customer_id\\": \\"E345\\", \\"amount\\": 100.25}, {\\"customer_id\\": \\"E345\\", \\"amount\\": -50.75} ] print(batch_transactions(transactions)) # Output: {\'E345\': 250.0} transactions = [ {\\"customer_id\\": \\"F678\\", \\"amount\\": 0.0}, {\\"customer_id\\": \\"F678\\", \\"amount\\": 0.0} ] print(batch_transactions(transactions)) # Output: {\'F678\': 0.0} ``` # Notes: * The returned dictionary should have customer IDs as keys and the total transaction amounts as values. * If the list of transactions is empty, the function should return an empty dictionary.","solution":"from typing import List, Dict def batch_transactions(transactions: List[Dict[str, any]]) -> Dict[str, float]: Groups transactions by customer_id and calculates the total amount for each customer. :param transactions: List of transactions, each represented by a dictionary with keys \'customer_id\' and \'amount\'. :return: A dictionary with customer IDs as keys and total transaction amounts as values. result = {} for transaction in transactions: customer_id = transaction[\'customer_id\'] amount = transaction[\'amount\'] if customer_id in result: result[customer_id] += amount else: result[customer_id] = amount return result"},{"question":"# Question You are assigned to implement a function that calculates the determinant of a given square matrix using Gaussian Elimination. The result should be a numerical value representing the determinant. Requirements 1. The function should ensure the input matrix is square. If it is not, raise a ValueError. 2. Perform Gaussian Elimination to transform the matrix into an upper triangular form. - If a row swap is necessary during elimination, count the number of swaps as they affect the determinant\'s sign. 3. Calculate the determinant as the product of the diagonal elements of the upper triangular matrix, adjusted for row swaps. 4. Add sufficient documentation and type hints to your function. Function Signature ```python def calculate_determinant(matrix: list[list[float]]) -> float: Calculate the determinant of a given square matrix using Gaussian Elimination. :param matrix: List of lists representing a square matrix. :return: A float value representing the determinant of the matrix. :raises ValueError: If the input matrix is not square. pass ``` Input - `matrix`: A square list of lists of floats, representing a matrix of dimension n x n (1 <= n <= 100). Output - Returns a float value representing the determinant of the matrix. Constraints - The solution should effectively manage matrices up to a size of 100x100. - Incorrect dimensions should lead to a raised ValueError. Example ```python matrix = [ [4, 3], [6, 3] ] determinant = calculate_determinant(matrix) # Output: # determinant = -6.0 # In case of non-square matrix matrix = [ [1, 2, 3], [4, 5, 6] ] # Raises ValueError # Another example matrix matrix = [ [2, -3, 1], [2, 0, -1], [1, 4, 5] ] determinant = calculate_determinant(matrix) # Output: # determinant = 49.0 ``` Hints - Gaussian Elimination involves iterating over matrix rows and performing row operations to achieve an upper triangular matrix. - Be mindful of floating-point operations; subtle errors can affect the outcome, especially in large matrices. - Consider the number of row swaps as they impact the sign of the determinant.","solution":"def calculate_determinant(matrix: list[list[float]]) -> float: Calculate the determinant of a given square matrix using Gaussian Elimination. :param matrix: List of lists representing a square matrix. :return: A float value representing the determinant of the matrix. :raises ValueError: If the input matrix is not square. # Check if the matrix is square n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The input matrix must be square.\\") # Function to perform row swaps and count them def swap_rows(mat, row1, row2): mat[row1], mat[row2] = mat[row2], mat[row1] # Copy the matrix to avoid modifying the original mat = [row[:] for row in matrix] swap_count = 0 # Gaussian Elimination to transform the matrix to upper triangular form for i in range(n): # Find the pivot row pivot_row = i for j in range(i + 1, n): if abs(mat[j][i]) > abs(mat[pivot_row][i]): pivot_row = j if pivot_row != i: swap_rows(mat, i, pivot_row) swap_count += 1 # Perform row reduction for j in range(i + 1, n): factor = mat[j][i] / mat[i][i] for k in range(i, n): mat[j][k] -= factor * mat[i][k] # Calculate the determinant as the product of the diagonal elements determinant = 1 for i in range(n): determinant *= mat[i][i] # Adjust determinant for the number of row swaps if swap_count % 2 != 0: determinant *= -1 return determinant"},{"question":"# Problem Statement: Permutation Check Your task is to write an algorithm that checks whether one string is a permutation of another string. A string is a permutation of another string if it contains the same characters in the same frequencies. # Function Signature ```python def is_permutation(str1: str, str2: str) -> bool: pass ``` # Input * `str1` (1 ≤ `len(str1)` ≤ ( 10^5 )): The first input string. * `str2` (1 ≤ `len(str2)` ≤ ( 10^5 )): The second input string. # Output * Returns `True` if `str1` is a permutation of `str2`, otherwise returns `False`. # Example ```python >>> is_permutation(\\"abc\\", \\"cba\\") True >>> is_permutation(\\"aabbcc\\", \\"abcabc\\") True >>> is_permutation(\\"abc\\", \\"abcc\\") False >>> is_permutation(\\"hello\\", \\"ohlle\\") True >>> is_permutation(\\"abc\\", \\"abcd\\") False ``` # Constraints * The solution should run efficiently under the given constraints.","solution":"def is_permutation(str1: str, str2: str) -> bool: This function checks if one string is a permutation of another string. if len(str1) != len(str2): return False from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"# Find the Longest Ordered Subsequence **Scenario**: You are tasked with developing a feature for an analytics platform that processes and analyzes sequences of numbers. One of the key operations involves identifying the longest ordered subsequence within a given list of numbers. Ordered subsequences can either be strictly increasing or strictly decreasing. **Task**: Write a function `longest_ordered_subsequence(arr: list[int]) -> list[int]` that accepts a list of integers and returns the longest ordered subsequence (either increasing or decreasing). In the case of ties (multiple subsequences of the same maximum length), return any one of them. **Input**: * `arr` - A list of integers. **Output**: * A list of integers representing the longest ordered subsequence. **Constraints**: * 1 <= len(arr) <= 1000 * -10^4 <= arr[i] <= 10^4 Your function should handle the task efficiently and ensure that it correctly identifies the longest subsequence in either order. **Example**: ```python >>> longest_ordered_subsequence([10, 20, 10, 30, 40, 10]) [10, 20, 30, 40] # (longest increasing subsequence) >>> longest_ordered_subsequence([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] # (longest decreasing subsequence) >>> longest_ordered_subsequence([1, 2, 3, 1, 2, 3]) [1, 2, 3] # (one possible longest increasing subsequence, another being [1, 2, 3] starting from the second 1) ``` **Note**: - Ensure your solution is capable of detecting and returning subsequences in both potential orders. - Consider dynamic programming or other efficient approaches to maximize performance with the given constraints.","solution":"def longest_ordered_subsequence(arr): if not arr: return [] def lis(nums): # Longest Increasing Subsequence n = len(nums) lengths = [1] * n sequences = [None] * n maxLength = 1 maxIndex = 0 for i in range(1, n): for j in range(i): if nums[i] > nums[j] and lengths[i] < lengths[j] + 1: lengths[i] = lengths[j] + 1 sequences[i] = j if lengths[i] > maxLength: maxLength = lengths[i] maxIndex = i seq = [] k = maxIndex while k is not None: seq.append(nums[k]) k = sequences[k] return seq[::-1] def lds(nums): # Longest Decreasing Subsequence n = len(nums) lengths = [1] * n sequences = [None] * n maxLength = 1 maxIndex = 0 for i in range(1, n): for j in range(i): if nums[i] < nums[j] and lengths[i] < lengths[j] + 1: lengths[i] = lengths[j] + 1 sequences[i] = j if lengths[i] > maxLength: maxLength = lengths[i] maxIndex = i seq = [] k = maxIndex while k is not None: seq.append(nums[k]) k = sequences[k] return seq[::-1] increasing_seq = lis(arr) decreasing_seq = lds(arr) if len(increasing_seq) >= len(decreasing_seq): return increasing_seq else: return decreasing_seq"},{"question":"# Problem Statement You are developing software for a robot that navigates through a grid, represented as a 2D matrix. The robot starts at the top-left corner of the grid and can only move right or down. Each cell in the grid contains a non-negative integer representing the cost of entering that cell. The robot\'s objective is to reach the bottom-right corner of the grid with the minimal travel cost. Write a function `min_cost_path(matrix)` that computes the minimal cost required for the robot to reach the bottom-right corner of the grid from the top-left corner. # Function Signature ```python def min_cost_path(matrix: List[List[int]]) -> int: ``` # Input * `matrix` (a list of lists of integers `matrix` with dimensions `n x m` where `1 <= n, m <= 1000`): - Each element of `matrix` is a non-negative integer (0 <= `matrix[i][j]` <= 10000). # Output * Return the minimal cost to travel from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1). # Constraints * The grid size will not exceed 1000 x 1000. * All costs are non-negative integers. # Performance Requirements * The solution should be efficient enough to handle the maximum input size within reasonable time limits. # Example ```python matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_cost_path(matrix)) # Output: 7 # Explanation: Path 1→3→1→1→1 minimizes the cost matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(min_cost_path(matrix)) # Output: 21 # Explanation: Path 1→2→3→6→9 minimizes the cost ``` # Additional Notes Considerations: 1. Use dynamic programming to build a solution that efficiently computes the minimal cost for larger grids. 2. Handle edge cases where the grid dimensions are 1xN or Nx1. 3. Ensure that your solution does not use more space than necessary to avoid memory issues with large grids.","solution":"from typing import List def min_cost_path(matrix: List[List[int]]) -> int: n, m = len(matrix), len(matrix[0]) dp = [[0] * m for _ in range(n)] # Initialize the dp array with the cost of the starting point dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner will have the minimal cost return dp[n-1][m-1]"},{"question":"# **Coding Challenge: Balance String Checker** You are given a problem where you need to analyze a string with regards to balance. A string is considered balanced if every character in the string appears the same number of times. **Problem Statement**: Write a function `is_balanced(s: str) -> bool` that checks whether the given string `s` is balanced. The function should return `True` if the string is balanced, and `False` otherwise. # **Input Format** * A string `s` containing only lowercase alphabetic characters. # **Output Format** * Returns `True` if the string is balanced, otherwise returns `False`. # **Constraints** * (1 leq text{len}(s) leq 10^5) # **Example** * For `s = \\"aabbcc\\"`: ```python print(is_balanced(\\"aabbcc\\")) # Output: True ``` * For `s = \\"aabbccc\\"`: ```python print(is_balanced(\\"aabbccc\\")) # Output: False ``` # **Explanation** - For `s = \\"aabbcc\\"`, each character `a`, `b`, and `c` appears exactly 2 times, so the string is balanced. - For `s = \\"aabbccc\\"`, the character `c` appears 3 times while `a` and `b` each appear 2 times, so the string is not balanced. Make sure to account for varying character counts efficiently given the possible length of the string.","solution":"def is_balanced(s: str) -> bool: Returns True if the string s is balanced, else returns False. A string is considered balanced if every character in the string appears the same number of times. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Get the unique frequencies of the character counts unique_counts = set(char_count.values()) # If there is more than one unique frequency, the string is not balanced return len(unique_counts) == 1"},{"question":"# Scenario You are participating in a game development bootcamp where the focus is on algorithmic problem-solving required for game mechanics. One of the modules involves creating functions that determine potential moves within a grid-based game world, such as a chessboard. # Task Write a function `knight_moves(position: str) -> list[str]` that calculates all valid moves for a knight in a standard 8x8 chessboard given the knight\'s current position. # Function Signature ```python def knight_moves(position: str) -> list[str] ``` # Input * A string `position` representing the current position of the knight on the chessboard. It will be in the format of a letter followed by a number (e.g., \'a1\', \'d4\', \'h8\'). # Output * A list of strings representing all valid positions that the knight can move to from the given `position`. The positions should also be in the format of a letter followed by a number (e.g., \'b2\', \'f5\'). # Constraints * The input string `position` will be a valid position on a standard 8x8 chessboard. * Ensure that the function does not return moves outside the bounds of the chessboard. # Examples 1. For an input `position = \'g8\'` - The function could return `[\'e7\', \'f6\', \'h6\']` 2. For an input `position = \'b1\'` - The function could return `[\'a3\', \'c3\', \'d2\']` 3. For an input `position = \'d4\'` - The function could return `[\'c2\', \'e2\', \'b3\', \'f3\', \'b5\', \'f5\', \'c6\', \'e6\']` # Additional Requirements * Make sure to handle edge cases such as the knight being on the edges or corners of the board. * The solution should efficiently compute all possible valid moves without including invalid ones.","solution":"def knight_moves(position: str) -> list[str]: Returns a list of all valid positions that a knight can move to from the given position on a chessboard. # Define the move offsets for a knight move_offsets = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] # Translate the position to board indices column, row = ord(position[0]) - ord(\'a\'), int(position[1]) - 1 # Generate all possible moves valid_moves = [] for dc, dr in move_offsets: new_col, new_row = column + dc, row + dr if 0 <= new_col < 8 and 0 <= new_row < 8: valid_moves.append(chr(new_col + ord(\'a\')) + str(new_row + 1)) return valid_moves"},{"question":"# Coding Assessment Question Context Imagine a scenario where you need to analyze and manipulate sequences of text strings to ascertain specific patterns of substrings within larger strings. This is a common task in various applications like data parsing, validation, or text processing. Task Write a function `count_substring_occurrences` that takes two string parameters `main_str` and `sub_str`, and returns the number of non-overlapping occurrences of `sub_str` within `main_str`. * **Input**: * `main_str` (str): The main string in which to search for the `sub_str`. * `sub_str` (str): The substring whose occurrences in `main_str` are to be counted. * **Output**: * An integer representing the count of non-overlapping occurrences of `sub_str` in `main_str`. For example: ```python >>> count_substring_occurrences(\\"ababcabc\\", \\"abc\\") 2 >>> count_substring_occurrences(\\"aaaaaa\\", \\"aa\\") 3 ``` Constraints * The input `main_str` and `sub_str` will only contain lowercase English letters and have lengths between 1 and 100,000. * The input strings will be non-empty. Requirements * Your solution must handle large inputs efficiently. * Ensure that overlapping occurrences are not counted. * Aim for linear time complexity, utilizing string searching mechanisms where appropriate. Performance Your solution should aim to minimize unnecessary computations and ideally process in `O(n)` time complexity due to the string search operations. Edge Cases: * Handle cases where `sub_str` length is greater than `main_str` length such that the count should be 0. * Consider cases where `sub_str` appears multiple times consecutively in `main_str`. # Example The following illustrates the expected result: ```python >>> count_substring_occurrences(\\"abcdabcdabcd\\", \\"abcd\\") 3 >>> count_substring_occurrences(\\"nananana\\", \\"na\\") 4 ``` # Implement the function below: ```python def count_substring_occurrences(main_str, sub_str): # Your code here pass ```","solution":"def count_substring_occurrences(main_str, sub_str): Returns the number of non-overlapping occurrences of sub_str in main_str. count = 0 start = 0 while True: start = main_str.find(sub_str, start) if start == -1: break count += 1 start += len(sub_str) return count"},{"question":"```markdown You are given the root node of a binary tree. Write a function to perform a zigzag level order traversal of the binary tree. Implement the function as described below: Function Definition: - **`binary_tree_zigzag_level_order(root: TreeNode) -> list[list[int]]`** - **Input**: root: TreeNode - **Output**: list of lists of integers, where each list represents a level of the tree in zigzag order (alternating left to right and right to left). Constraints: - The number of nodes in the binary tree is in the range [0, 1000]. - Each node has a unique integer value. Example: Given the binary tree: ``` 3 / 9 20 / 15 7 ``` - **Zigzag Level Order**: [[3], [20, 9], [15, 7]] Use the provided `TreeNode` class for tree construction: ```python from __future__ import annotations from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right ``` Implement the given function considering edge cases and optimizing for the constraints provided. ```","solution":"from __future__ import annotations from typing import Optional, List from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right def binary_tree_zigzag_level_order(root: TreeNode) -> List[List[int]]: if not root: return [] result = [] nodes_queue = deque([root]) left_to_right = True while nodes_queue: level_size = len(nodes_queue) level_nodes = deque() for _ in range(level_size): current_node = nodes_queue.popleft() if left_to_right: level_nodes.append(current_node.val) else: level_nodes.appendleft(current_node.val) if current_node.left: nodes_queue.append(current_node.left) if current_node.right: nodes_queue.append(current_node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"# Problem Statement A software company has hired you to implement a queue system with additional constraints. The system must simulate a line of people waiting to access a service, where each person has a priority that determines their position in line. The queue should support adding new people, removing the person with the highest priority, and querying the person with the current highest priority. # Function Specification Your task is to implement a class `PriorityQueue` with the following methods: - `insert(self, person: str, priority: int) -> None`: Adds a new person with the given priority to the queue. - `extract_max(self) -> str`: Removes and returns the name of the person with the highest priority. If the queue is empty, return an empty string. - `get_max(self) -> str`: Returns the name of the person with the highest priority without removing them from the queue. If the queue is empty, return an empty string. # Input - The `insert` method takes a string `person` and an integer `priority` where: - `person` is a non-empty string with at most 100 characters. - `priority` is an integer from -10^6 to 10^6. - The `extract_max` and `get_max` methods take no inputs. # Output - The `insert` method has no return value. - The `extract_max` method returns a string. - The `get_max` method returns a string. # Example ```python # Initialize the queue pq = PriorityQueue() # Insert people with various priorities pq.insert(\\"Alice\\", 5) pq.insert(\\"Bob\\", 10) pq.insert(\\"Charlie\\", 7) # Query the person with the highest priority assert pq.get_max() == \\"Bob\\" # Remove the person with the highest priority assert pq.extract_max() == \\"Bob\\" # Query the new person with the highest priority assert pq.get_max() == \\"Charlie\\" # Remove the person with the highest priority assert pq.extract_max() == \\"Charlie\\" # Remove the next person with the highest priority assert pq.extract_max() == \\"Alice\\" # Attempt to remove from an empty queue assert pq.extract_max() == \\"\\" # Query from an empty queue assert pq.get_max() == \\"\\" ``` # Notes - Use a heap data structure to efficiently manage the priority queue. - The priority queue should handle multiple people with the same priority by ordering them based on their insertion order.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def insert(self, person: str, priority: int) -> None: heapq.heappush(self._queue, (-priority, self._index, person)) self._index += 1 def extract_max(self) -> str: if self._queue: return heapq.heappop(self._queue)[2] return \\"\\" def get_max(self) -> str: if self._queue: return self._queue[0][2] return \\"\\""},{"question":"# Problem Statement You are working on a social media platform where users can post messages. To keep the platform user-friendly, you need to implement a feature to detect the most frequently occurring word in a given message, ignoring any special characters and case-sensitivity. Your task is to write a function that finds the most frequent word in the given message string. The words are sequences of letters (a-z, A-Z) separated by non-letter characters. If there\'s a tie in frequency, return the word that appears first lexicographically. # Function Details **Function Name**: `most_frequent_word` **Input**: - `message`: A string representing the message, which may contain any printable ASCII characters. **Output**: - A string representing the most frequently occurring word in the message. **Constraints**: - The length of the message will not exceed 10^6 characters. - The message will have at least one word. # Example: ```python def most_frequent_word(message: str) -> str: # Your implementation here pass # Example Test Cases print(most_frequent_word(\'Hello, world! Hello... HELLO.\')) # Expected: \'hello\' print(most_frequent_word(\'The quick brown fox jumps over the lazy dog.\')) # Expected: \'the\' print(most_frequent_word(\'Programming is fun. Programming, coding, and debugging.\')) # Expected: \'programming\' print(most_frequent_word(\'A good day and a GREAT day! A day.\')) # Expected: \'a\' print(most_frequent_word(\'Data: 123, analysis. 456. Data-collection.\')) # Expected: \'data\' ``` # Notes: - The function should ignore the case when counting word frequencies. - The special characters should not be considered as parts of words. - If there\'s a tie in frequency, return the word that comes first lexicographically. - Consider edge cases such as messages with multiple special characters and mixed cases.","solution":"import re from collections import Counter def most_frequent_word(message: str) -> str: # Convert the message to lowercase and extract words using regex words = re.findall(r\'[a-zA-Z]+\', message) words = [word.lower() for word in words] # Count the frequency of each word word_counts = Counter(words) # Find the word with the highest frequency most_frequent = max(word_counts, key=lambda word: (word_counts[word], -ord(word[0]))) return most_frequent"},{"question":"# Problem Statement You need to write a function that compresses a given string using the Run-Length Encoding (RLE) algorithm. The function should read the input string and return a new encoded string where consecutive repetitions of characters are replaced by the character followed by its count. # Function Signature ```python def run_length_encode(s: str) -> str: Encodes a string using Run-Length Encoding (RLE). :param s: Input string to be encoded. :return: Run-Length Encoded string. ``` # Input * **s**: a string `s` where (0 leq text{len(s)} leq 10^3). # Output * The function should return a new string which is the Run-Length Encoded version of the input string. # Constraints 1. The input string can include both uppercase and lowercase letters, digits, and special characters. 2. The function should handle an empty string. 3. The function must maintain the order of characters and their count in sequence. # Example ```python >>> run_length_encode(\\"aaabbcccc\\") \\"a3b2c4\\" >>> run_length_encode(\\"xyz\\") \\"x1y1z1\\" >>> run_length_encode(\\"\\") \\"\\" >>> run_length_encode(\\"AaaAaa\\") \\"A1a2A1a2\\" ``` # Instructions 1. Implement the `run_length_encode` function according to the specifications above. 2. Ensure your function passes the provided example cases as well as any additional edge cases you can think of. 3. Optimize for readability and efficiency within the given constraints.","solution":"def run_length_encode(s: str) -> str: Encodes a string using Run-Length Encoding (RLE). :param s: Input string to be encoded. :return: Run-Length Encoded string. if not s: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str += s[i - 1] + str(count) count = 1 # Add the last character and its count encoded_str += s[-1] + str(count) return encoded_str"},{"question":"# Prime Factorization: Summing Unique Prime Factors Problem Statement You are given a positive integer `n` and your task is to compute the sum of distinct prime factors of `n`. A prime factor of a number is a factor that is a prime number. Objective Implement a function `sum_prime_factors` that: - Takes an integer input `n`. - Returns the sum of all distinct prime factors of `n`. Functional Requirements - The function should validate and handle incorrect inputs: - Raise a `TypeError` if `n` is not an integer or cannot be cast to an integer. - Raise a `ValueError` if `n` is less than 2. - Use an efficient algorithm to find the prime factors and calculate their sum. Constraints * 2 ≤ `n` ≤ 10^12. Input Format - An integer `n` representing the number for which the distinct prime factors are to be summed. Output Format - An integer representing the sum of all distinct prime factors of `n`. Example ```python >>> sum_prime_factors(28) 10 # Prime factors are 2 and 7, 2 + 7 = 9 >>> sum_prime_factors(50) 7 # Prime factors are 2 and 5, 2 + 5 = 7 >>> sum_prime_factors(13) 13 # Prime factor is 13 itself >>> sum_prime_factors(1) ValueError: n must be greater than or equal to 2 ``` Function Signature ```python def sum_prime_factors(n: int) -> int: # Your code here ``` Scenario You are developing a utility for an analytical tool that needs to extract and use unique prime factors of numbers. The user will provide a positive integer, and your function will compute and return the sum of its distinct prime factors, efficiently and correctly handling possible errors and edge cases.","solution":"def sum_prime_factors(n: int) -> int: Returns the sum of all distinct prime factors of n. if not isinstance(n, int): raise TypeError(\\"n must be an integer\\") if n < 2: raise ValueError(\\"n must be greater than or equal to 2\\") def get_prime_factors(num): prime_factors = set() while num % 2 == 0: prime_factors.add(2) num //= 2 factor = 3 while factor * factor <= num: while (num % factor == 0): prime_factors.add(factor) num //= factor factor += 2 if num > 2: prime_factors.add(num) return prime_factors prime_factors = get_prime_factors(n) return sum(prime_factors)"},{"question":"# Scenario A retail company wants to track the movement of their delivery trucks to monitor their operations. Each truck logs its location periodically with a timestamp, and the company needs to determine the total distance traveled by each truck on a given day. Assume the trucks only move in a 2D plane. # Task Description Implement a function `total_distance` that receives a list of tuples `locations` which contains coordinates (x, y) of the truck at different timestamps. The function should compute the total distance traveled based on these coordinates. # Function Signature ```python def total_distance(locations: List[Tuple[int, int]]) -> float: pass ``` # Input * A list of tuples `locations` where each tuple `(x, y)` represents the coordinates of the truck at a specific timestamp. * `1 <= len(locations) <= 10^4` * Each coordinate `x` and `y` is an integer within the range `-10^4` to `10^4`. # Output * A float value representing the total distance traveled by the truck. # Constraints * The coordinates are given in increasing order of timestamps. # Example Example 1 ```python locations = [(0, 0), (3, 4)] print(total_distance(locations)) # Output: 5.0 ``` Example 2 ```python locations = [(1, 1), (4, 5), (7, 1)] print(total_distance(locations)) # Output: 10.0 ``` Example 3 ```python locations = [(0, 0), (0, 0), (0, 4), (5, 4)] print(total_distance(locations)) # Output: 9.0 # Notes * The distance between two points `(x1, y1)` and `(x2, y2)` can be calculated using the Euclidean distance formula: `sqrt((x2 - x1)^2 + (y2 - y1)^2)`. * Ensure that the returned distance is a float rounded to one decimal place using the Python built-in function `round()`. * Use only the Python standard library.","solution":"import math from typing import List, Tuple def total_distance(locations: List[Tuple[int, int]]) -> float: Calculate the total distance traveled based on a list of coordinates. Args: locations (List[Tuple[int, int]]): List of (x, y) coordinates. Returns: float: Total distance traveled rounded to one decimal place. total_dist = 0.0 for i in range(1, len(locations)): x1, y1 = locations[i - 1] x2, y2 = locations[i] dist = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) total_dist += dist return round(total_dist, 1)"},{"question":"# Context As a software engineer, you are optimizing the playback of a media player. One of the key tasks is to manage the buffering of media data to ensure smooth playback without interruptions. To achieve this, you decide to structure the media data into fixed-size chunks and calculate the optimal playback order while accounting for varying download speeds of each chunk. You need to determine the order in which the chunks should be played to minimize playback interruptions assuming you can start playing as soon as the first chunk is fully received. # Task Implement a function that computes the optimal playback order for media chunks based on their download times. The function should take a list of download times for each chunk and return a list representing the order of chunks to be played. # Function Signature ```python def optimal_playback_order(download_times: List[int]) -> List[int]: ``` # Input - `download_times` (List of ints): A list of integers where each integer represents the time (in milliseconds) it takes to download a corresponding media chunk. # Output - Returns a list of integers representing the indices of the chunks in the order they should be played to minimize playback interruptions. # Examples ```python assert optimal_playback_order([300, 200, 100]) == [2, 1, 0] assert optimal_playback_order([400, 500, 100, 200]) == [2, 3, 0, 1] assert optimal_playback_order([1000, 2000, 3000]) == [0, 1, 2] ``` # Constraints 1. The input list `download_times` will have at least one element and at most 10^5 elements. 2. Each element in `download_times` represents a positive integer time. # Edge Cases 1. The function should correctly handle the case where there is only one chunk to download, returning `[0]` as the order. 2. The implementation should ensure that download times are non-negative integers and properly index the chunks even when there are extreme variations in download times. Your goal is to implement the `optimal_playback_order` function to ensure that the playback is as smooth as possible given the varying download times of the chunks.","solution":"from typing import List def optimal_playback_order(download_times: List[int]) -> List[int]: Computes the optimal playback order for media chunks based on their download times. Parameters: download_times (List[int]): A list of integers where each integer represents the time (in milliseconds) it takes to download a corresponding media chunk. Returns: List[int]: A list representing the indices of the chunks in the order they should be played to minimize playback interruptions. # Pair each download time with its original index then sort by download time indexed_download_times = [(index, time) for index, time in enumerate(download_times)] sorted_indexed_times = sorted(indexed_download_times, key=lambda x: x[1]) # Return the indices sorted by their corresponding download times return [index for index, _ in sorted_indexed_times]"},{"question":"# Substring Permutation Check **Scenario**: Suppose you are developing a security feature for a password manager. One requirement is to ensure that a given password does not contain any permutation of a specific banned substring to prevent predictable patterns. **Task**: Write a function that, given a password and a banned substring, checks if any permutation of the banned substring exists as a contiguous part of the password. **Function Signature**: ```python def is_permutation_in_string(password: str, banned: str) -> bool: ``` # Requirements: 1. **Input**: * A string, `password`, representing the password to be checked. * A string, `banned`, representing the banned substring. * The length of `password` and `banned` can be between 1 and 10^4. 2. **Output**: * Return `True` if any permutation of `banned` exists in `password` as a contiguous substring. * Return `False` otherwise. # Example: ```python >>> is_permutation_in_string(\\"aabbcc\\", \\"abc\\") True >>> is_permutation_in_string(\\"password123\\", \\"pass\\") True >>> is_permutation_in_string(\\"hello\\", \\"world\\") False >>> is_permutation_in_string(\\"abcdefg\\", \\"gfedcba\\") True >>> is_permutation_in_string(\\"security\\", \\"key\\") False ``` # Notes: * **Edge Cases**: Consider passwords and banned substrings of all valid lengths. Ensure the function correctly handles strings with repeated characters. * **Performance**: Optimize your solution to handle the largest possible inputs efficiently. Implement your function below: ```python def is_permutation_in_string(password: str, banned: str) -> bool: from collections import Counter banned_len = len(banned) banned_counter = Counter(banned) for i in range(len(password) - banned_len + 1): if Counter(password[i:i+banned_len]) == banned_counter: return True return False ```","solution":"def is_permutation_in_string(password: str, banned: str) -> bool: from collections import Counter banned_len = len(banned) banned_counter = Counter(banned) for i in range(len(password) - banned_len + 1): if Counter(password[i:i+banned_len]) == banned_counter: return True return False"},{"question":"Sorting Mechanism Optimization # Objective: You are to enhance an existing sorting algorithm by optimizing it for a specific type of dataset. The dataset consists of numerous \'sorted in chunks\' sequences within a larger, overall unsorted list. # Requirements: 1. **Algorithm Identification**: Identify whether you\'re using insertion sort, merge sort, or quicksort. 2. **Optimization Implementation**: Modify the chosen sorting algorithm to efficiently handle lists where elements are already sorted in large chunks. 3. **Performance Verification**: Demonstrate the enhanced performance compared to the standard implementation of the chosen algorithm on the specified dataset. # Input & Output Format: - **Input**: - A list `L` containing integers, with several segments already sorted internally. - **Output**: - The fully sorted list. - Print statements indicating the time taken to sort the list before and after optimization. # Example: ```python # Sample list with sorted chunks L = [1, 2, 5, 10, 12, 3, 4, 8, 9, 11, 20, 30, 25, 22, 24] # Standard implementation sorting standard_sorted_L = standard_sort(L) print(f\\"Time before optimization: {standard_sort_time}\\") # Optimized implementation sorting optimized_sorted_L = optimized_sort(L) print(f\\"Time after optimization: {optimized_sort_time}\\") ``` # Sample Output: ```python # Before optimization Time before optimization: 0.5 seconds # After optimization Time after optimization: 0.2 seconds ``` # Constraints: - The optimized sort should handle lists of up to 100,000 elements efficiently. - Ensure the optimized method still sorts any general list correctly, regardless of pre-sorted chunks. - Properly handle edge cases where the list might be entirely sorted or completely random. # Performance: - Your optimization should demonstrate a clear improvement for large, chunk-sorted datasets while maintaining a worse-case time complexity comparable to the standard algorithm. Enhance and verify your sorting algorithm to fulfill the outlined requirements, ensuring you provide test cases and performance metrics for validation.","solution":"def merge_sorted_chunks(L): This function merges a list of integers containing sorted chunks. if not L: return [] def merge(left, right): merged, i, j = [], 0, 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged def find_chunks(L): chunks = [] start = 0 for i in range(1, len(L)): if L[i] < L[i - 1]: chunks.append(L[start:i]) start = i chunks.append(L[start:]) return chunks chunks = find_chunks(L) while len(chunks) > 1: new_chunks = [] for i in range(0, len(chunks), 2): if i + 1 < len(chunks): new_chunks.append(merge(chunks[i], chunks[i + 1])) else: new_chunks.append(chunks[i]) chunks = new_chunks return chunks[0]"},{"question":"# Problem Statement: You have been tasked with writing a function that simulates the logistics of a small warehouse. The warehouse contains different products, and your task is to manage the inventory operations such as adding new products, removing products, and updating quantities of existing products. The operations to be performed are given as a list of commands. Implement a Python function `manage_warehouse(commands: List[str]) -> List[Tuple[str, int]]` which: 1. Takes a list of string commands where each command represents an operation on the warehouse inventory. 2. Each command can be one of the following: - `\\"ADD <product_name> <quantity>\\"` to add a new product or increase the quantity of an existing product. - `\\"REMOVE <product_name>\\"` to completely remove a product from the warehouse. - `\\"UPDATE <product_name> <quantity>\\"` to set the quantity of an existing product to a new value. 3. Processes the commands in the given order. 4. Returns a sorted list of tuples where each tuple contains a product name and its current quantity. Constraints * The `commands` list will contain between 1 and 1000 commands. * Each `product_name` will be a non-empty string of up to 20 characters. * The `quantity` will be a positive integer not exceeding 1000. * The same product will not have multiple `\\"ADD\\"` or `\\"UPDATE\\"` commands in a row without an intervening `\\"REMOVE\\"` command. Inputs and Outputs * **Input**: `commands` (List[str]) - a list of command strings. Each command is space-separated and can be of three types: ADD, REMOVE, or UPDATE. * **Output**: List[Tuple[str, int]] - a sorted list of (product name, quantity) tuples. Example: ```python commands = [ \\"ADD apple 10\\", \\"ADD banana 5\\", \\"UPDATE apple 20\\", \\"REMOVE banana\\", \\"ADD orange 15\\" ] print(manage_warehouse(commands)) ``` This should output: ``` [(\'apple\', 20), (\'orange\', 15)] ``` In this example: - \\"ADD apple 10\\" adds 10 apples to the warehouse. - \\"ADD banana 5\\" adds 5 bananas to the warehouse. - \\"UPDATE apple 20\\" sets the quantity of apples to 20. - \\"REMOVE banana\\" removes bananas from the warehouse. - \\"ADD orange 15\\" adds 15 oranges to the warehouse. The final sorted inventory would be `[(\'apple\', 20), (\'orange\', 15)]`.","solution":"from typing import List, Tuple def manage_warehouse(commands: List[str]) -> List[Tuple[str, int]]: # Initialize an empty dictionary to store the product inventory inventory = {} # Process each command in order for command in commands: parts = command.split() action = parts[0] product_name = parts[1] if action == \\"ADD\\": quantity = int(parts[2]) if product_name in inventory: inventory[product_name] += quantity else: inventory[product_name] = quantity elif action == \\"REMOVE\\": if product_name in inventory: del inventory[product_name] elif action == \\"UPDATE\\": quantity = int(parts[2]) if product_name in inventory: inventory[product_name] = quantity # Convert the inventory dictionary to a sorted list of tuples sorted_inventory = sorted(inventory.items()) return sorted_inventory"},{"question":"# Secure Storage System: Efficient Data Retrieval In this challenge, you are tasked with designing a secure and efficient data retrieval system for a highly sensitive storage module. The system uses a hash-based mechanism to ensure quick and secure access to the stored data. You are provided with a pre-defined hash map (dictionary) where keys are unique identifiers and values are the associated data. # Task Complete the function `secure_data_retrieval` provided below. Your implementation should efficiently retrieve the value associated with a given key and handle potential errors gracefully, such as non-existent keys. # Requirements - Implement the function to retrieve data based on a unique identifier. - Ensure that the function handles missing keys by returning an appropriate default message. - Optimize the retrieval process to operate in constant time. # Implementation Details *Function Signature*: ```python def secure_data_retrieval(storage: dict, key: str) -> str: pass ``` **Arguments**: - `storage` (dict): A dictionary where keys are unique identifiers (strings) and values are the corresponding data (strings). - `key` (str): The unique identifier for which data needs to be retrieved. **Returns**: - `str`: The data associated with the given key if it exists, otherwise \\"Data not found\\". # Constraints - The storage dictionary will have at most 10,000 entries. - Identifiers (keys) are unique alphanumeric strings with lengths between 1 to 30 characters. - Data values are strings with lengths between 1 to 100 characters. # Example Usage Example 1: ```python storage = {\'a1b2c3\': \'file1.txt\', \'d4e5f6\': \'image.jpg\', \'g7h8i9\': \'document.pdf\'} print(secure_data_retrieval(storage, \'a1b2c3\')) # Output: \'file1.txt\' ``` Example 2: ```python storage = {\'a1b2c3\': \'file1.txt\', \'d4e5f6\': \'image.jpg\', \'g7h8i9\': \'document.pdf\'} print(secure_data_retrieval(storage, \'z1x2y3\')) # Output: \'Data not found\' ``` Example 3: ```python storage = {\'user01\': \'profile_pic.png\', \'user02\': \'resume.pdf\', \'user03\': \'report.docx\'} print(secure_data_retrieval(storage, \'user03\')) # Output: \'report.docx\' ``` Make sure your function handles large dictionaries efficiently and accurately retrieves data or returns the \\"Data not found\\" message for invalid keys. Validate your implementation against various test cases to ensure robustness and performance.","solution":"def secure_data_retrieval(storage: dict, key: str) -> str: Efficiently retrieves the value associated with a given key in the storage dictionary. Returns \\"Data not found\\" if the key does not exist in the dictionary. :param storage: Dictionary with unique identifiers as keys and associated data as values. :param key: Unique identifier for which data needs to be retrieved. :return: The data associated with the given key, or \\"Data not found\\" if the key does not exist. return storage.get(key, \\"Data not found\\")"},{"question":"# Minimum Spanning Tree with Kruskal\'s Algorithm Implement Kruskal\'s algorithm in Python to find the Minimum Spanning Tree (MST) of a given graph. You will be provided with the `Graph` class and a list of `Edge` instances. Your task is to write a function `kruskal_mst` that returns the edges forming the MST. Function Signature ```python def kruskal_mst(graph: Graph) -> List[Edge]: ``` Input * `graph`: An instance of `Graph` representing the vertices and edges of the graph. Output * A list of `Edge` instances representing the edges in the Minimum Spanning Tree. Constraints * The graph may have up to 10,000 vertices and 30,000 edges. * The weight of each edge is a positive integer. * Ensure the implementation handles edge cases such as disconnected graphs or graphs with cycles. Example ```python class Edge: def __init__(self, u: int, v: int, weight: int): self.u = u self.v = v self.weight = weight class Graph: def __init__(self, vertices: int, edges: List[Edge]): self.vertices = vertices self.edges = edges >>> edges = [ ... Edge(0, 1, 10), ... Edge(0, 2, 6), ... Edge(0, 3, 5), ... Edge(1, 3, 15), ... Edge(2, 3, 4) ... ] >>> graph = Graph(4, edges) >>> mst_edges = kruskal_mst(graph) >>> [(edge.u, edge.v, edge.weight) for edge in mst_edges] [(2, 3, 4), (0, 3, 5), (0, 1, 10)] ``` Performance Requirements * The function should efficiently handle graphs up to the provided constraints. * Ensure the solution uses optimal data structures to manage union-find operations. Use the given `Graph` and `Edge` classes as the basis for your function. Consider edge cases such as disconnected components and verify the correct construction of the MST.","solution":"class Edge: def __init__(self, u: int, v: int, weight: int): self.u = u self.v = v self.weight = weight class Graph: def __init__(self, vertices: int, edges: list): self.vertices = vertices self.edges = edges class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if u != self.parent[u]: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_mst(graph: Graph): result_mst = [] # Step 1: Sort edges in non-decreasing order of their weight sorted_edges = sorted(graph.edges, key=lambda edge: edge.weight) # Step 2: Create disjoint sets for each vertex disjoint_set = DisjointSet(graph.vertices) # Step 3: Iterate through the sorted edges for edge in sorted_edges: u, v = edge.u, edge.v if disjoint_set.find(u) != disjoint_set.find(v): result_mst.append(edge) disjoint_set.union(u, v) return result_mst"},{"question":"# Scenario You are a software engineer working on a project that requires implementing various sorting algorithms for performance comparison. One of the sorting methods you\'ve been asked to implement is QuickSort, and you need to ensure it handles edge cases like arrays with duplicate values efficiently. # Problem Statement Write a function called `quick_sort` that implements the QuickSort algorithm. Your function should take an input list of integers and return a new list that is sorted in ascending order. # Function Signature ```python def quick_sort(arr: list[int]) -> list[int]: pass ``` # Input - `arr` (list[int]): A list of integers that needs to be sorted. # Output - Returns a new list of integers that is sorted in ascending order. # Constraints - The input list `arr` may contain up to `10^5` elements. - Elements of the list can range from `-10^9` to `10^9`. - The implementation should handle lists with duplicate values effectively. - The function should aim for an average time complexity of O(n log n). # Examples ```python >>> quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quick_sort([5, 3, 8, 4, 2]) [2, 3, 4, 5, 8] >>> quick_sort([10, 7, 8, 9, 1, 5]) [1, 5, 7, 8, 9, 10] ``` # Notes - Ensure that your implementation avoids excessive recursion and handles the partitioning efficiently. - You can use either the Lomuto or Hoare partition scheme as long as it keeps the implementation efficient and clean. - Be mindful of stack overflow issues on very large lists and consider tail-call optimization techniques if necessary.","solution":"def quick_sort(arr: list[int]) -> list[int]: Implements the QuickSort algorithm to sort a list in ascending order. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Context: You have been asked to implement a filesystem simulation that supports the creation, deletion, and navigation of directories and files. Additionally, the simulation should be able to list the contents of directories recursively. # Problem: 1. Write a method `create(self, path, is_directory)` that creates a file or directory at the given path. The path will be a string representing the hierarchy from the root, with directories separated by slashes (`/`). The method should handle cases where a directory or file already exists at the given location. 2. Write a method `delete(self, path)` that removes a file or directory at the given path. If the path represents a directory, it should also delete all its contents recursively. The function should handle cases where the specified path does not exist. 3. Write a method `list_contents(self, path)` that lists the contents of the directory at the given path. It should return a list of paths representing the files and directories within the specified directory, including nested contents. # Implementation Details: - Class definition: `class FileSystem:` - Methods to implement: * `def create(self, path, is_directory):` * `def delete(self, path):` * `def list_contents(self, path):` # Input: - `create(self, path, is_directory)` takes two parameters: * `path` (string): The path where the file or directory should be created. * `is_directory` (boolean): A flag indicating whether to create a directory (`True`) or a file (`False`). - `delete(self, path)` takes one parameter: * `path` (string): The path of the file or directory to be deleted. - `list_contents(self, path)` takes one parameter: * `path` (string): The path of the directory whose contents need to be listed. # Output: - `create(self, path, is_directory)` will modify the filesystem to include the new file or directory and return `None`. - `delete(self, path)` will modify the filesystem to remove the specified file or directory and return `None`. - `list_contents(self, path)` will return a list of paths (strings) representing the contents of the specified directory and its subdirectories, sorted in lexicographic order. # Constraints: - The filesystem starts with a single root directory (`/`). - Use appropriate data structures to manage files and directories. - Ensure efficient management of nested directories and files. # Example Usage: ```python fs = FileSystem() # Creating directories and files fs.create(\'/home\', True) fs.create(\'/home/user\', True) fs.create(\'/home/user/document.txt\', False) # Deleting a file fs.delete(\'/home/user/document.txt\') # Listing contents print(fs.list_contents(\'/home\')) # should list [\'/home/user\'] ``` # Note: - Do not use any built-in filesystem libraries or functions for this implementation. - Consider edge cases, such as attempting to create a file where a directory already exists or deleting a non-existent path.","solution":"class FileSystem: def __init__(self): self.fs = {\\"\\": {}} def create(self, path, is_directory): components = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"\\"] for i, component in enumerate(components): if i == len(components) - 1: # Last component if component in current: raise FileExistsError(f\\"{path} already exists\\") else: current[component] = {} if is_directory else None else: if component not in current or current[component] is None: raise FileNotFoundError(f\\"Path {path} does not exist\\") current = current[component] def delete(self, path): components = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"\\"] stack = [] for component in components: if component not in current: raise FileNotFoundError(f\\"{path} does not exist\\") stack.append((current, component)) current = current[component] parent, component_to_delete = stack[-1] del parent[component_to_delete] def list_contents(self, path): components = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"\\"] for component in components: if component: if component not in current: raise FileNotFoundError(f\\"{path} does not exist\\") current = current[component] results = [] self._recursive_list(path, current, results) return sorted(results) def _recursive_list(self, path, current, results): for name, node in current.items(): item_path = f\\"{path}/{name}\\".replace(\\"//\\", \\"/\\") results.append(item_path) if isinstance(node, dict): self._recursive_list(item_path, node, results)"},{"question":"# Build the Largest Number: You are given a list of non-negative integers. Your task is to arrange these integers such that they form the largest possible number and return this number as a string. **Function Definition:** ```python def largest_number(nums: List[int]) -> str: # Your code here ``` **Input:** - `nums` (List[int]): A list of non-negative integers. **Output:** - Returns a string representing the largest possible number that can be formed by arranging the integers. **Constraints:** - All numbers in the input list are non-negative. - The total number of integers does not exceed 100. - The length of each integer does not exceed 100. **Example:** ```python nums = [10, 2] print(largest_number(nums)) # Output: \\"210\\" ``` ```python nums = [3, 30, 34, 5, 9] print(largest_number(nums)) # Output: \\"9534330\\" ``` **Explanation:** - In the first example, arranging 10 and 2 in any order would give two potential numbers: 102 and 210. Among these, 210 is the largest. - In the second example, arranging the numbers in the specific order to get the largest possible concatenated number results in \\"9534330\\". **Note:** - The numbers should be compared based on their concatenated values. For example, to decide the order between 3 and 30, the program should compare \\"330\\" and \\"303\\". Write a function that achieves the desired result by appropriately sorting the numbers based on the custom comparison criteria, ensuring that the largest possible number is formed. Ensure your solution handles edge cases and provides the result in string format correctly.","solution":"from typing import List from functools import cmp_to_key def largest_number(nums: List[int]) -> str: def compare(x, y): # Custom comparator to decide order based on concatenated result if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert numbers to strings for comparison nums_str = list(map(str, nums)) # Sort the numbers using the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join sorted strings into a single string and convert it to int and back to string to remove leading \'0\'s largest_num = \'\'.join(nums_str) return str(int(largest_num))"},{"question":"# Question: Implement a Rolling Median Computation You are provided with a list of numerical data points. Your task is to compute the **Rolling Median** over this data with a specified window size. The median of a set of numbers is the middle value when they are sorted in ascending order, or the average of the two middle values when the set has an even number of elements. # Requirements 1. **Function**: Implement the function `rolling_median(data: Sequence[float], window_size: int) -> list[float | None]`. 2. **Median Calculation**: The function should compute the median for each window of the given size as it slides over the data. 3. **Edge Cases**: - Return `None` for data points that don’t have enough previous points to form a full window. - Raise a `ValueError` if window size is not a positive integer greater than 0. 4. **Performance Requirement**: Ensure that the implementation efficiently computes rolling medians with a time complexity that leverages the properties of data structures like heaps or balanced search trees. # Input - `data`: A list of numerical data points. - `window_size`: An integer representing the size of the rolling window. # Output - A list of median values with the same length as the input data. # Example Input: ```python data = [10, 12, 15, 13, 14, 16, 18, 17, 19, 21] window_size = 3 ``` Output: ```python [None, None, 12.0, 13.0, 14.0, 14.0, 16.0, 17.0, 18.0, 19.0] ``` # Additional Notes: - The resulting median values should handle floating-point precision appropriately. - Consider using efficient algorithms for large datasets to maintain acceptable performance. # Testing: Include tests to validate the function against typical and edge cases using a `unittest` or similar framework.","solution":"from collections.abc import Sequence import heapq def rolling_median(data: Sequence[float], window_size: int) -> list[float | None]: if not isinstance(window_size, int) or window_size <= 0: raise ValueError(\\"window_size must be a positive integer greater than 0\\") n = len(data) if window_size > n: return [None] * n medians = [None] * (window_size - 1) min_heap = [] max_heap = [] def add_number(num): if not max_heap or num <= -max_heap[0]: heapq.heappush(max_heap, -num) else: heapq.heappush(min_heap, num) balance_heaps() def remove_number(num): if num <= -max_heap[0]: max_heap.remove(-num) heapq.heapify(max_heap) else: min_heap.remove(num) heapq.heapify(min_heap) balance_heaps() def balance_heaps(): if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) def get_median(): if len(max_heap) == len(min_heap): return (-max_heap[0] + min_heap[0]) / 2.0 return -max_heap[0] for i in range(n): add_number(data[i]) if i >= window_size - 1: medians.append(get_median()) remove_number(data[i - window_size + 1]) return medians"},{"question":"# Find Unique Triplets Sum to Zero You are tasked with writing a Python program that finds all unique triplets in an array that sum up to zero. The triplets should be returned in a specific order, with each triplet sorted in non-decreasing order. **Function 1: find_triplets** - **Input**: A list of integers. - **Output**: A list of lists, where each inner list represents a unique triplet that sums to zero. # Constraints: 1. The input list can contain positive, negative, and zero integers. 2. The solution must not include duplicate triplets. 3. Each triplet should be sorted in non-decreasing order. 4. If no such triplet exists, return an empty list. # Example Cases: Input/Output: **Example 1:** ```python find_triplets([-1, 0, 1, 2, -1, -4]) -> [[-1, -1, 2], [-1, 0, 1]] ``` **Example 2:** ```python find_triplets([0, -1, 2, -3, 1]) -> [[-3, 1, 2], [-1, 0, 1]] ``` **Example 3:** ```python find_triplets([1, 2, -2, -1]) -> [] ``` Your task is to implement the function `find_triplets` that adheres to the given constraints and provides the correct output as per the examples. Ensure to handle edge cases and optimize for performance where possible.","solution":"def find_triplets(nums): nums.sort() result = [] length = len(nums) for i in range(length-2): # Avoid duplicates for the first element if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, length-1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) # Avoid duplicates for the second and third elements while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"# Coding Question **Problem Statement**: You are provided with a string consisting of lowercase alphabets and spaces. Your task is to reverse the order of the words in the string without reversing the individual words and without altering the case of letters. **Objective**: Write a function `reverse_words_in_string(s: str) -> str` that returns the string with the order of the words reversed. # Function Signature ```python def reverse_words_in_string(s: str) -> str: ``` # Input * A string `s` (1 <= len(s) <= 10^4) consisting of lowercase alphabets and spaces. Words are separated by single spaces, and there are no leading or trailing spaces. # Output * Return a string where the order of words is reversed. # Example ```python >>> reverse_words_in_string(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words_in_string(\\"hello world\\") \\"world hello\\" >>> reverse_words_in_string(\\"coding is fun\\") \\"fun is coding\\" >>> reverse_words_in_string(\\"keep it simple\\") \\"simple it keep\\" ``` # Constraints * Ensure the function handles strings up to the maximum length of 10^4 efficiently. * You may not use built-in functions that directly reverse the string or words. # Scenario In a language processing task, you receive sentences that need their word order reversed for analysis purposes. The input text can sometimes be long and should be handled efficiently. Your function\'s goal is to reverse the order of the words while maintaining their original case and integrity within each word.","solution":"def reverse_words_in_string(s: str) -> str: Reverses the order of words in a given string without reversing the individual words. Parameters: s (str): Input string of lowercase alphabets and spaces. Returns: str: String with the order of the words reversed. return \' \'.join(s.split()[::-1])"},{"question":"# Robot Path Finder You are coding an autonomous robot that must navigate a grid to capture and avoid obstacles. The robot starts at the top-left cell (0, 0) of an `m x n` grid and aims to reach the bottom-right cell (m-1, n-1). Some cells contain obstacles (denoted as 1), and the robot cannot pass through them. You need to determine the number of unique paths that the robot can take to reach the destination cell. The robot can only move either down or right at any point in time. **Function Signature**: ```python def unique_paths_obstacles(grid: list) -> int: pass ``` **Expected Input and Output**: * **Input**: * `grid` - A 2D list of integers where `grid[i][j]` is either 0 (empty cell) or 1 (obstacle). * **Output**: * Return a single integer representing the number of unique paths from the top-left to the bottom-right cell. **Constraints**: * `grid` is a list of lists with size `m x n` where `1 <= m, n <= 100`. * The value of each cell in `grid` is either 0 or 1. * The starting and ending cells (grid[0][0] and grid[m-1][n-1]) will always be 0. **Example**: ```python >>> unique_paths_obstacles([[0,0,0],[0,1,0],[0,0,0]]) 2 >>> unique_paths_obstacles([[0,1],[0,0]]) 1 ``` **Instructions**: 1. Validate the input data to ensure `grid` is a properly formatted 2D list with dimensions within the specified constraints. 2. Calculate the number of unique paths considering obstacles using dynamic programming. 3. Handle edge cases such as grids with no possible path due to obstacles blocking the way completely. 4. The solution should account for the robot\'s ability to only move either down or right at any point in time. **Note**: Pay special attention to the efficiency of the solution as the size of the grid can be large.","solution":"def unique_paths_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right of the grid, avoiding obstacles denoted by 1. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Initialize first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Initialize first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the DP table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[-1][-1]"},{"question":"# Question on Generating Palindromic Substrings Context In string manipulation, extracting substrings with certain properties is a common task. One such property of interest is whether a substring is palindromic. Task Given a string, implement a function to return all unique palindromic substrings. Function Requirements 1. **Function Signature**: ```python def generate_palindromic_substrings(s: str) -> list: ``` 2. **Parameters**: * `s` (str): A string containing lowercase alphabets. 3. **Return Values**: * `palindromes` (list): A list of unique palindromic substrings sorted lexicographically. Constraints * The input string will have a length between 1 and 1000. * A substring is defined as a contiguous sequence of characters within the string. * A string is palindromic if it reads the same backward as forward. Performance Requirements Your solution should efficiently generate all unique palindromic substrings, even for the maximum input size. Example Consider the string `\\"abccba\\"`. The palindromic substrings are `\\"a\\"`, `\\"b\\"`, `\\"c\\"`, `\\"cc\\"`, `\\"bccb\\"`, `\\"abccba\\"`. ```python s = \\"abccba\\" palindromes = generate_palindromic_substrings(s) # palindromes should be [\'a\', \'abccba\', \'b\', \'bccb\', \'c\', \'cc\'] ``` Submit your implementation of the `generate_palindromic_substrings` function below:","solution":"def generate_palindromic_substrings(s: str) -> list: Function to return all unique palindromic substrings. def is_palindrome(sub): return sub == sub[::-1] palindromes = set() n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j + 1] if is_palindrome(substring): palindromes.add(substring) return sorted(palindromes)"},{"question":"# Problem Scenario You have been tasked with developing a network packet analyzer to monitor and analyze packet flows in a network. To track and manage packets from different sources, you need to store and retrieve packet information efficiently. # Task: Implement a class `PacketAnalyzer` that allows adding packet information, querying packets by source, and calculating the average packet size from a specific source. # Key Requirements: 1. Add packet information with a source identifier and packet size. 2. Retrieve all packets from a given source. 3. Calculate the average size of packets from a given source. # Specifications: 1. **Class**: `PacketAnalyzer` 2. **Methods**: * `__init__(self)`: Initializes the packet analyzer without any packets. * `add_packet(self, source: str, size: int)`: Adds a packet with given source identifier and size. * `get_packets(self, source: str) -> list[int]`: Retrieves a list of packet sizes from a specific source. * `average_packet_size(self, source: str) -> float`: Returns the average size of packets from a specific source. If no packets from the source, return `0`. 3. **Input/Output**: * The method `add_packet` takes a source identifier as a string and a packet size as an integer. * The method `get_packets` takes a source identifier as a string and returns a list of integers representing packet sizes. * The method `average_packet_size` takes a source identifier as a string and returns a float which is the average of packet sizes for this source. # Constraints: * Packet sizes are non-negative integers. * Source identifier is a non-empty string. * Average packet size should be a float rounded to two decimal places. # Example: ```python # Example Usage analyzer = PacketAnalyzer() analyzer.add_packet(\\"192.168.1.1\\", 1500) analyzer.add_packet(\\"192.168.1.1\\", 500) analyzer.add_packet(\\"10.0.0.1\\", 1000) packets1 = analyzer.get_packets(\\"192.168.1.1\\") # returns [1500, 500] average1 = analyzer.average_packet_size(\\"192.168.1.1\\") # returns 1000.00 packets2 = analyzer.get_packets(\\"10.0.0.1\\") # returns [1000] average2 = analyzer.average_packet_size(\\"10.0.0.1\\") # returns 1000.00 average3 = analyzer.average_packet_size(\\"192.168.2.1\\") # returns 0.00 ``` # Notes: * Make sure to handle cases where there might be no packets from a specific source when calculating the average. * Ensure the average calculation is accurate up to two decimal places.","solution":"class PacketAnalyzer: def __init__(self): self.packets = {} def add_packet(self, source: str, size: int): if source not in self.packets: self.packets[source] = [] self.packets[source].append(size) def get_packets(self, source: str) -> list[int]: return self.packets.get(source, []) def average_packet_size(self, source: str) -> float: packet_list = self.packets.get(source, []) if not packet_list: return 0.0 average = sum(packet_list) / len(packet_list) return round(average, 2)"},{"question":"# Graph Search Algorithm You are provided with a class, `Graph`, that represents an undirected graph using an adjacency list. Your task is to implement the `bfs` method for this class, which performs a breadth-first search starting from a given node and returns the list of nodes in the order they are visited. Function Signature ```python def bfs(self, start_node: int) -> List[int]: ``` Input - `start_node` (int): The starting node for the breadth-first search. Output - A list of nodes (int) in the order they are visited by the BFS algorithm. Constraints - You can assume that the graph is connected. - The nodes are labeled with integer values from `0` to `n-1`, where `n` is the number of nodes in the graph. - The method must use the Breadth-First Search algorithm. Example ```python g = Graph(4) g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(2, 3) g.add_edge(3, 3) assert g.bfs(2) == [2, 0, 3, 1] # The BFS traversal starting from node 2 ```","solution":"from typing import List from collections import deque class Graph: def __init__(self, n: int): self.n = n self.adj_list = [[] for _ in range(n)] def add_edge(self, u: int, v: int): self.adj_list[u].append(v) self.adj_list[v].append(u) def bfs(self, start_node: int) -> List[int]: visited = [False] * self.n queue = deque([start_node]) visited[start_node] = True bfs_order = [] while queue: node = queue.popleft() bfs_order.append(node) for neighbor in self.adj_list[node]: if not visited[neighbor]: queue.append(neighbor) visited[neighbor] = True return bfs_order"},{"question":"# Scenario You are working on integrating a payment gateway into your e-commerce application. The function `process_payment` takes a payment token, amount, and user information and interacts with the payment gateway\'s API to complete the transaction. For testing purposes, you need to simulate the behavior of this external service. Using the concepts of mocking, write a comprehensive test for `process_payment` to verify it handles responses correctly, both for successful and failed transactions. # Task Write a function `test_process_payment(monkeypatch)` which performs the following: * Mocks the network request to the payment gateway\'s API. * Ensures the mock response contains a predefined transaction result for both success (`status`: \\"success\\", `transaction_id`: \\"abc123\\") and failure (`status`: \\"failure\\", `error_message`: \\"Invalid card details\\"). * Validates that `process_payment` processes these responses correctly, returning the expected results or raising appropriate exceptions. # Expected Input and Output * **Input**: `payment_token` (a string representing a valid payment token), `amount` (a float representing the payment amount), and `user_info` (a dictionary containing user details). * **Output**: The function should contain assertions that pass if `process_payment` works as expected for both successful and failed transactions, and fail otherwise. # Constraints * Assume `process_payment` and the API endpoint are correctly defined elsewhere in your codebase. * You must use the `monkeypatch` fixture from the `pytest` library to mock the `requests.post` method. Example ```python def process_payment(payment_token, amount, user_info): url = PAYMENT_GATEWAY_ENDPOINT payload = { \\"token\\": payment_token, \\"amount\\": amount, \\"user\\": user_info } response = requests.post(url, json=payload) response_data = response.json() if response_data[\\"status\\"] == \\"success\\": return response_data[\\"transaction_id\\"] else: raise Exception(response_data[\\"error_message\\"]) # Your task is to complete the test function `test_process_payment`. ``` Your solution should ensure that all assertions hold true for the provided scenarios.","solution":"import requests # Define the process_payment function as described in the scenario def process_payment(payment_token, amount, user_info): url = PAYMENT_GATEWAY_ENDPOINT payload = { \\"token\\": payment_token, \\"amount\\": amount, \\"user\\": user_info } response = requests.post(url, json=payload) response_data = response.json() if response_data[\\"status\\"] == \\"success\\": return response_data[\\"transaction_id\\"] else: raise Exception(response_data[\\"error_message\\"]) # Placeholder for the actual endpoint PAYMENT_GATEWAY_ENDPOINT = \\"https://api.paymentgateway.com/process\\""},{"question":"# Coding Challenge: Substring Palindrome Count Problem Statement Given a text file containing a list of strings, your task is to compute the total number of palindromic substrings present in each string. A palindromic substring is one that reads the same forward and backward. You need to write a function `count_palindromic_substrings(s: str) -> int` that returns the number of palindromic substrings in a given string. Use this function within a main function `compute_palindromic_substrings(filename: str) -> int` that reads the strings from a file and returns the total number of palindromic substrings found in all the strings combined. Specifications - **Input**: A string `filename`, which is the path to the file containing strings (one per line). - **Output**: An integer representing the total number of palindromic substrings found in all the strings. Example Consider a file named `strings.txt` with the following contents: ``` abba racecar abc aaa ``` Calling `compute_palindromic_substrings(\'strings.txt\')` should return `12`, since: - \\"abba\\" has 4 palindromic substrings: \\"a\\", \\"b\\", \\"bb\\", \\"abba\\" - \\"racecar\\" has 10 palindromic substrings: \\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"c\\", \\"racecar\\", \\"cec\\", \\"r\\", \\"a\\", \\"c\\" - \\"abc\\" has 3 palindromic substrings: \\"a\\", \\"b\\", \\"c\\" - \\"aaa\\" has 6 palindromic substrings: \\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aaa\\" Total palindromic substrings = 4 + 10 + 3 + 6 = 23. Constraints - Strings are non-empty and contain only lowercase English letters. Function Signatures ```python def count_palindromic_substrings(s: str) -> int: pass def compute_palindromic_substrings(filename: str) -> int: pass ``` **Note**: Ensure your solution optimizes for performance, especially when dealing with longer strings.","solution":"def count_palindromic_substrings(s: str) -> int: n = len(s) count = 0 # A 2D array to store the palindromic status of substrings dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True count += 1 for length in range(2, n+1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: if length == 2 or dp[i+1][j-1]: dp[i][j] = True count += 1 return count def compute_palindromic_substrings(filename: str) -> int: total_count = 0 with open(filename, \'r\') as file: for line in file: line = line.strip() if line: total_count += count_palindromic_substrings(line) return total_count"},{"question":"# Problem Statement You are building a system to manage a collection of books in a library. Each book has a title, an author, and a publication year. You need to implement a class `Library` that maintains a collection of books and supports various operations. # Class and Methods Implement the following methods within the `Library` class: Add a Book * **Method**: `add_book(title: str, author: str, year: int) -> None` * **Input**: * `title` (str): The title of the book. * `author` (str): The author of the book. * `year` (int): The publication year of the book. * **Output**: None. The book should be added to the library\'s collection. Remove a Book * **Method**: `remove_book(title: str) -> None` * **Input**: * `title` (str): The title of the book to remove. * **Output**: None. The book with the given title should be removed from the library\'s collection. If the book does not exist, raise a `ValueError` with a meaningful message. Get Books by Author * **Method**: `get_books_by_author(author: str) -> List[Dict[str, Union[str, int]]]` * **Input**: * `author` (str): The author of the books to retrieve. * **Output**: A list of dictionaries, where each dictionary represents a book authored by the given author. Each dictionary should have keys: `title`, `author`, and `year`. Get Books by Year * **Method**: `get_books_by_year(year: int) -> List[Dict[str, Union[str, int]]]` * **Input**: * `year` (int): The publication year of the books to retrieve. * **Output**: A list of dictionaries, where each dictionary represents a book published in the given year. Each dictionary should have keys: `title`, `author`, and `year`. # Example ```python # Example usage of the Library class library = Library() library.add_book(\\"Title1\\", \\"Author1\\", 2001) library.add_book(\\"Title2\\", \\"Author1\\", 2005) library.add_book(\\"Title3\\", \\"Author2\\", 2001) # Retrieve books by Author1 books_by_author1 = library.get_books_by_author(\\"Author1\\") assert books_by_author1 == [ {\\"title\\": \\"Title1\\", \\"author\\": \\"Author1\\", \\"year\\": 2001}, {\\"title\\": \\"Title2\\", \\"author\\": \\"Author1\\", \\"year\\": 2005} ] # Retrieve books published in 2001 books_published_2001 = library.get_books_by_year(2001) assert books_published_2001 == [ {\\"title\\": \\"Title1\\", \\"author\\": \\"Author1\\", \\"year\\": 2001}, {\\"title\\": \\"Title3\\", \\"author\\": \\"Author2\\", \\"year\\": 2001} ] # Remove a book and verify its removal library.remove_book(\\"Title1\\") books_by_author1 = library.get_books_by_author(\\"Author1\\") assert books_by_author1 == [ {\\"title\\": \\"Title2\\", \\"author\\": \\"Author1\\", \\"year\\": 2005} ] # Try to remove a non-existent book, expect a ValueError try: library.remove_book(\\"NonExistentTitle\\") except ValueError as e: assert str(e) == \\"Book with title \'NonExistentTitle\' does not exist.\\" ``` # Requirements 1. Each method should perform the described functionality correctly. 2. Ensure the `Library` class maintains a collection of books that does not allow duplicates based on the title. 3. Implement error checking such that the `remove_book` method raises a `ValueError` with a meaningful message if a book to be removed does not exist. 4. Return books sorted by title in ascending order for both `get_books_by_author` and `get_books_by_year` methods. # Constraints * Title and author are non-empty strings with a maximum length of 255 characters. * Publication year is an integer within the range [1000, 3000].","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, year: int) -> None: for book in self.books: if book[\\"title\\"] == title: return self.books.append({\\"title\\": title, \\"author\\": author, \\"year\\": year}) self.books.sort(key=lambda x: x[\\"title\\"]) def remove_book(self, title: str) -> None: for book in self.books: if book[\\"title\\"] == title: self.books.remove(book) return raise ValueError(f\\"Book with title \'{title}\' does not exist.\\") def get_books_by_author(self, author: str): filtered_books = [book for book in self.books if book[\\"author\\"] == author] filtered_books.sort(key=lambda x: x[\\"title\\"]) return filtered_books def get_books_by_year(self, year: int): filtered_books = [book for book in self.books if book[\\"year\\"] == year] filtered_books.sort(key=lambda x: x[\\"title\\"]) return filtered_books"},{"question":"# Question Statement Context: You have been tasked with creating a specialized function to perform matrix rotation. Specifically, you need to implement an algorithm that rotates a given NxN matrix by 90 degrees in a counterclockwise direction. This function will be part of a larger system involving image processing and transformations. Objective: Write a function `rotate_matrix_counterclockwise(matrix: List[List[int]]) -> List[List[int]]`, which takes a square matrix (NxN) as input and returns a new matrix that is rotated 90 degrees counterclockwise. Input: - `matrix`: A list of lists of integers representing an NxN matrix (1 ≤ N ≤ 1000) Output: - A new list of lists of integers representing the matrix rotated 90 degrees counterclockwise. Constraints and Requirements: - The function should efficiently handle matrices of varying sizes, ensuring performance constraints are met. - The function should not modify the original matrix, but rather create and return a new matrix. - Ensure a clear and comprehensive approach that correctly handles edge cases, such as the smallest possible matrix size. Examples: ```python print(rotate_matrix_counterclockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Output: [[3, 6, 9], [2, 5, 8], [1, 4, 7]] print(rotate_matrix_counterclockwise([[1, 2], [3, 4]])) # Output: [[2, 4], [1, 3]] print(rotate_matrix_counterclockwise([[1]])) # Output: [[1]] ``` Implementation Hint: Consider indexing the elements of the matrix appropriately to achieve the counterclockwise rotation, making use of a temporary new matrix to store the rotated values before returning it.","solution":"def rotate_matrix_counterclockwise(matrix): Rotates a given NxN matrix by 90 degrees in a counterclockwise direction. Parameters: matrix (list of list of int): A square matrix (NxN) Returns: list of list of int: The rotated matrix N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[N - j - 1][i] = matrix[i][j] return rotated_matrix"},{"question":"# Question: Rotated Array Search Context You are working on a problem involving rotated sorted arrays. In a rotated array, the sort order is disrupted at a single point and resumed. This makes a normal binary search infeasible without modifications. Problem Given a rotated sorted array `arr` of unique integers and an integer `target`, return the index of `target` if it exists in the array; otherwise, return `-1`. Tasks Write a Python function `search_rotated_array(arr: list[int], target: int) -> int` that efficiently searches for the `target` in the array and returns its index or `-1` if the target is not found. Input Format - `arr`: A list of unique integers which has been sorted and then rotated. - `target`: An integer which is the number to search for in the list. Output Format Return an integer which is the index of the target if present, otherwise `-1`. Constraints * ( 1 leq len(arr) leq 10^4 ) * ( -10^4 leq arr[i] leq 10^4 ) * ( arr[i] neq arr[i+1] ) for all valid `i` * `target` can take any integer value within the range `-10^4` to `10^4`. Examples ```python >>> search_rotated_array([4,5,6,7,0,1,2], 0) 4 >>> search_rotated_array([4,5,6,7,0,1,2], 3) -1 >>> search_rotated_array([1], 0) -1 >>> search_rotated_array([1], 1) 0 ``` Explanation 1. In the first example, the array `[4,5,6,7,0,1,2]` is a rotated version of `[0,1,2,4,5,6,7]`. The target `0` is at index `4`. 2. In the second example, the target `3` is not present in the array, so the output is `-1`. Note Implement an efficient search method that operates in (O(log n)) time. Good luck!","solution":"def search_rotated_array(arr, target): Searches for the target in a rotated sorted array and returns its index or -1 if not found. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid if arr[left] <= arr[mid]: # Left half is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement: Memory-Efficient String Permutations Given a string `s`, write a function to determine all unique permutations of the string that can be formed. The function should handle strings with possible duplicate characters and ensure the output is memory-efficient and only contains unique permutations. Requirements 1. **Function Signature**: ```python def find_unique_permutations(s: str) -> list[str]: ``` 2. **Parameters**: - `s` (str): The input string for which unique permutations need to be generated. 3. **Output**: - The function should return a list of strings, where each string is a unique permutation of the input string `s`. 4. **Constraints**: - The length of `s` will be between 1 and 8 (inclusive). - The function should avoid generating duplicate permutations in memory to optimize performance. 5. **Performance Requirements**: - The function should minimize memory usage by not storing duplicate permutations. - Utilize an efficient algorithm to generate unique permutations. # Example ```python # Example of usage print(find_unique_permutations(\\"aab\\")) # Expected Output: [\'aab\', \'aba\', \'baa\'] ``` Note: The order of permutations in the output list does not matter as long as all permutations are unique.","solution":"from itertools import permutations def find_unique_permutations(s: str) -> list[str]: Returns a list of all unique permutations of the input string s. # Generate all permutations using itertools.permutations all_permutations = permutations(s) # Convert them to a set to remove duplicates and then back to a list unique_permutations = set([\'\'.join(p) for p in all_permutations]) # Return the sorted list of unique permutations return sorted(unique_permutations)"},{"question":"# Query Tree Depth Calculation Context You are given a binary tree implementation in Python, and you need to determine the maximum depth (or height) of this tree. The depth of a binary tree is the length of the longest path from the root node down to the furthest leaf node. Task Write a function `max_depth` that takes a `TreeNode` as its input and returns an integer representing the maximum depth of the tree. Function Signature: ```python def max_depth(root: TreeNode) -> int: pass ``` Constraints * The tree nodes vary from 1 to 10^4 in number. * The value of each node is a unique integer. * The depth of the tree does not exceed 10^4. Input * `root`: The root node of the binary tree. Output * An integer representing the maximum depth of the binary tree. (e.g., 3 for a tree with three levels) Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree Construction # 3 # / # 9 20 # / # 15 7 root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) assert max_depth(root) == 3 ``` Edges Cases to Consider * A tree with only one node. * A tree with multiple levels with only left or only right children. * Extremely unbalanced trees. Performance Requirements Ensure the solution traverses the tree efficiently, preferably using Depth-First Search (DFS) to compute the maximum depth.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Graph Traversal You need to implement a program that performs both Depth-First Search (DFS) and Breadth-First Search (BFS) on a graph represented as an adjacency list. Your implementation should be able to handle both directed and undirected graphs. Description: Graph traversal is fundamental in many algorithms, such as searching, pathfinding, and connectivity checking. Your task is to implement two classic traversal techniques—DFS and BFS. Additionally, determine if all nodes in the graph are reachable from the starting node, indicating if the graph is connected. Functions to Implement: 1. **`bfs(graph: Dict[int, List[int]], start_node: int) -> List[int]`**: - Given a graph represented as an adjacency list and a starting node, perform Breadth-First Search and return the nodes in the order they are visited. 2. **`dfs(graph: Dict[int, List[int]], start_node: int) -> List[int]`**: - Given a graph represented as an adjacency list and a starting node, perform Depth-First Search and return the nodes in the order they are visited. 3. **`is_connected(graph: Dict[int, List[int]], start_node: int) -> bool`**: - Determine if all nodes in the graph are reachable from the starting node using either BFS or DFS. Additional requirements: * Write these functions in Python with proper error handling and consider edge cases such as empty graph or start_node not in graph. * Optimize for performance to handle large graphs efficiently. Example: Given the following graph represented as an adjacency list: ```python graph = { 1: [2, 4], 2: [3], 3: [1, 4], 4: [] } ``` Starting from node `1`, your BFS might visit nodes in [1, 2, 4, 3] order, and DFS might visit nodes in [1, 2, 3, 4] order. The graph is connected since all nodes are reachable from node 1. Input: - A dictionary `graph` representing the graph and an integer `start_node` representing the starting node. Output: - `bfs` returns a list of nodes visited in BFS order. - `dfs` returns a list of nodes visited in DFS order. - `is_connected` returns a boolean indicating if all nodes are reachable from `start_node`. Performance Constraints: - Efficiently handle graphs with up to 10^4 nodes and edges. - Ensure both space and time complexities are optimized for traversal operations.","solution":"from collections import deque from typing import List, Dict def bfs(graph: Dict[int, List[int]], start_node: int) -> List[int]: if start_node not in graph: return [] visited = set() queue = deque([start_node]) bfs_order = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) bfs_order.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return bfs_order def dfs(graph: Dict[int, List[int]], start_node: int) -> List[int]: if start_node not in graph: return [] visited = set() stack = [start_node] dfs_order = [] while stack: node = stack.pop() if node not in visited: visited.add(node) dfs_order.append(node) for neighbor in reversed(graph[node]): if neighbor not in visited: stack.append(neighbor) return dfs_order def is_connected(graph: Dict[int, List[int]], start_node: int) -> bool: if start_node not in graph: return False visited = set() stack = [start_node] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return len(visited) == len(graph)"},{"question":"Question: Implement a Simple Cache System Create a class `SimpleCache` that simulates a basic caching mechanism. The cache should store key-value pairs and support retrieval, insertion, updating, and deletion of cache items. Additionally, the cache must adhere to a fixed maximum size, and it should employ the Least Recently Used (LRU) eviction policy when the cache exceeds this size. # Details: 1. **Cache Operations**: * **Get**: Retrieve the value associated with a key. * **Put**: Insert or update a key-value pair in the cache. * **Delete**: Remove a key-value pair from the cache. * **Size**: Return the current number of key-value pairs in the cache. 2. **Eviction Policy**: * When the cache exceeds its maximum size, the least recently used item should be removed to make space for the new item. # Class Definition: Implement a class `SimpleCache` with the following methods: * **`__init__(self, capacity: int) -> None`**: Initializes the cache with a given capacity. * **`get(self, key: str) -> Optional[str]`**: Retrieves the value for a given key. If the key does not exist, return `None`. * **`put(self, key: str, value: str) -> None`**: Inserts or updates the key-value pair in the cache. * **`delete(self, key: str) -> None`**: Deletes the key-value pair from the cache if it exists. * **`size(self) -> int`**: Returns the current number of key-value pairs in the cache. # Example: ```python cache = SimpleCache(2) cache.put(\\"a\\", \\"1\\") cache.put(\\"b\\", \\"2\\") assert cache.size() == 2 assert cache.get(\\"a\\") == \\"1\\" cache.put(\\"c\\", \\"3\\") # This should evict key \\"b\\" assert cache.get(\\"b\\") == None assert cache.get(\\"c\\") == \\"3\\" cache.put(\\"d\\", \\"4\\") # This should evict key \\"a\\" assert cache.get(\\"a\\") == None assert cache.get(\\"d\\") == \\"4\\" assert cache.size() == 2 cache.delete(\\"c\\") assert cache.get(\\"c\\") == None assert cache.size() == 1 ``` # Additional Notes: - You may use any suitable data structure(s) to help implement the LRU eviction policy. - Ensure that all operations adhere to the specified maximum cache size. - Pay attention to the efficiency of the get and put operations. # Task: Implement the `SimpleCache` class as described. Ensure your solution passes the above example check scenarios.","solution":"from collections import OrderedDict from typing import Optional class SimpleCache: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = OrderedDict() def get(self, key: str) -> Optional[str]: if key not in self.cache: return None value = self.cache.pop(key) self.cache[key] = value # Re-inserts the key to mark it as recently used return value def put(self, key: str, value: str) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # Removes the first (least recently used) item self.cache[key] = value def delete(self, key: str) -> None: if key in self.cache: self.cache.pop(key) def size(self) -> int: return len(self.cache)"},{"question":"# Log Parsing Enhancement As a proficient developer familiar with text parsing and log analysis, you need to enhance the provided log parsing system to support various log formats and provide detailed error handling. Task Implement the following enhancements to the log parsing function (`parse_log`): 1. **Error Handling**: - Modify the `parse_log` function to handle lines that do not match the expected log format gracefully. - Log an error message for each unrecognized log line, indicating the line number and the issue. 2. **Format Flexibility**: - Extend the `parse_log` function to support additional log formats, such as those with different timestamp formats or varied delimiters. - Allow for configuration of expected formats via a `formats` parameter. 3. **Input Validation**: - Ensure the `parse_log` function correctly identifies malformed log entries. - Verify that the function handles extra whitespace gracefully, logging a warning when detected. 4. **Unit Tests**: - Write comprehensive unit tests to validate the enhanced function, ensuring it handles various log formats, error scenarios, and typical log entries correctly. Function Specifications **Parse Log Function**: ```python def parse_log(log: str, formats: list) -> list: Parses a given log file string according to specified formats. Parameters: - log: str : The input log string to be parsed. - formats: list : A list of expected log formats. Each format is a dictionary specifying the expected delimiter and the timestamp format. Returns: - list: A list of parsed log entries. Notes: - Handle lines that do not match any of the specified formats by logging an error. - Handle extra whitespace in the logs by logging a warning. Example: >>> log = \\"2023-03-15 12:34:56,INFO,User loginn2023-03-15 12:35:00,ERROR,Access denied\\" >>> formats = [{\'delimiter\': \',\', \'timestamp_format\': \'%Y-%m-%d %H:%M:%S\'}] >>> parse_log(log, formats) [{\'timestamp\': \'2023-03-15 12:34:56\', \'level\': \'INFO\', \'message\': \'User login\'}, {\'timestamp\': \'2023-03-15 12:35:00\', \'level\': \'ERROR\', \'message\': \'Access denied\'}] pass ``` **Additional Requirements:** - Write unittests for the enhanced function. - Handle each enhancement independently. - Use appropriate logging for errors and warnings. Input and Output Formats - Input: `str` (log string containing log entries); `list` (list of expected formats) - Output: `list` (list of parsed log entries)","solution":"import re from datetime import datetime import logging logging.basicConfig(level=logging.DEBUG) def parse_log(log: str, formats: list) -> list: Parses a given log file string according to specified formats. Parameters: - log: str : The input log string to be parsed. - formats: list : A list of expected log formats. Each format is a dictionary specifying the expected delimiter and the timestamp format. Returns: - list: A list of parsed log entries. Notes: - Handle lines that do not match any of the specified formats by logging an error. - Handle extra whitespace in the logs by logging a warning. # Function to parse a line based on given format def parse_line(line, fmt): parts = line.strip().split(fmt[\'delimiter\']) if len(parts) != 3: return None try: timestamp = datetime.strptime(parts[0].strip(), fmt[\'timestamp_format\']) level = parts[1].strip() message = parts[2].strip() return { \'timestamp\': parts[0].strip(), \'level\': level, \'message\': message } except ValueError: return None parsed_lines = [] lines = log.split(\'n\') for line_num, line in enumerate(lines): if not line.strip(): continue line_parsed = False for fmt in formats: parsed = parse_line(line, fmt) if parsed: if line != line.strip(): logging.warning(f\\"Line {line_num + 1}: Extra whitespace detected.\\") parsed_lines.append(parsed) line_parsed = True break if not line_parsed: logging.error(f\\"Line {line_num + 1}: Unrecognized format -> {line}\\") return parsed_lines"},{"question":"# Question: Rectangle Overlap Detection You are given the coordinates of two rectangles in a 2D space. Each rectangle is defined by the coordinates of its lower-left and upper-right corners. **Objective:** Write a function `detect_overlap(rect1: Tuple[int, int, int, int], rect2: Tuple[int, int, int, int]) -> bool` to determine if the two rectangles overlap or not. The function should return `True` if the rectangles overlap and `False` otherwise. Requirements: 1. Aim to achieve an efficient solution with an appropriate time complexity. 2. Make sure to handle edge cases such as rectangles that touch at the borders or corners. Input: 1. `rect1`: A tuple of four integers representing the coordinates (x1, y1, x2, y2) of the lower-left and upper-right corners of the first rectangle. 2. `rect2`: A tuple of four integers representing the coordinates (x3, y3, x4, y4) of the lower-left and upper-right corners of the second rectangle. Output: - A boolean value indicating whether the two rectangles overlap. Constraints: - All provided coordinates are integers. - The rectangles will be axis-aligned. Example: ```python >>> detect_overlap((0, 0, 2, 2), (1, 1, 3, 3)) True >>> detect_overlap((0, 0, 1, 1), (1, 1, 2, 2)) False >>> detect_overlap((0, 0, 2, 2), (2, 2, 3, 3)) False >>> detect_overlap((0, 0, 4, 4), (1, 1, 3, 3)) True ``` # Notes: - Two rectangles are considered to overlap if they share any portion of their areas. However, touching at the borders or corners without sharing any area does not count as overlapping. - Ensure to handle both positive and negative coordinates, as well as the case where the rectangles share edges but do not overlap. - The solution should be optimized to avoid unnecessary computations.","solution":"from typing import Tuple def detect_overlap(rect1: Tuple[int, int, int, int], rect2: Tuple[int, int, int, int]) -> bool: Returns True if the two rectangles overlap, else returns False. Each rectangle is defined by a tuple (x1, y1, x2, y2) representing the coordinates of the lower-left and upper-right corners respectively. x1, y1, x2, y2 = rect1 x3, y3, x4, y4 = rect2 # Check if one rectangle is on the left side of the other if x1 >= x4 or x3 >= x2: return False # Check if one rectangle is above the other if y1 >= y4 or y3 >= y2: return False return True"},{"question":"# Context You have been provided with a basic implementation of a singly linked list that supports standard operations like insertion, deletion, and traversal. Your task is to extend the functionality of this linked list by adding a method to reverse the list in place (i.e., without using extra space for an additional list). # Task 1. Implement the `reverse` method for the `LinkedList` class. 2. Ensure that the method reverses the linked list in place, updating the existing node connections without creating new nodes. 3. Maintain the existing class structure and ensure other operations (like `insert`, `delete`, `traverse`) remain functional post-reversal. # Linked List Class Skeleton ```python class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete(self, value): current = self.head if not current: return if current.value == value: self.head = current.next return while current.next: if current.next.value == value: current.next = current.next.next return current = current.next def traverse(self): current = self.head while current: print(current.value, end=\\" -> \\") current = current.next print(\\"None\\") # Implement the reverse method below def reverse(self): # Your code here ``` # Expected Input and Output * **insert(value: Any) -> None**: Inserts a new node with the given value at the end of the list. * **delete(value: Any) -> None**: Removes the first node with the given value from the list. * **traverse() -> None**: Prints the elements in the list from head to end. * **reverse() -> None**: Reverses the linked list in place. # Constraints * The `reverse` method should have O(n) time complexity and O(1) space complexity, where n is the number of elements in the list. * Other methods within the class should remain operational after reversing the list. # Example ```python ll = LinkedList() ll.insert(1) ll.insert(2) ll.insert(3) ll.traverse() # Output: 1 -> 2 -> 3 -> None ll.reverse() ll.traverse() # Output: 3 -> 2 -> 1 -> None ``` # Performance Requirements * The `reverse` method should complete in linear time relative to the number of nodes. * The method should utilize constant space, modifying the list in place.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete(self, value): current = self.head if not current: return if current.value == value: self.head = current.next return while current.next: if current.next.value == value: current.next = current.next.next return current = current.next def traverse(self): current = self.head while current: print(current.value, end=\\" -> \\") current = current.next print(\\"None\\") def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev"},{"question":"# Problem Statement Design a function to detect cycles in an undirected graph. Write a function `detect_cycle(graph: dict) -> bool` that determines if there is a cycle in the given graph. The graph is represented as an adjacency list. # Input 1. `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. # Output * A boolean value `True` if there is a cycle in the graph and `False` otherwise. # Constraints 1. The graph can have between 1 and 10,000 nodes. 2. Nodes are represented by integers. 3. The graph may be disconnected (contain more than one component). 4. The graph is undirected. # Performance Requirements * The solution should be efficient, ideally using depth-first search (DFS) or a union-find data structure. # Example ```python graph1 = { 1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3] } print(detect_cycle(graph1)) # Output: True graph2 = { 1: [2], 2: [1, 3], 3: [2, 4], 4: [3] } print(detect_cycle(graph2)) # Output: False graph3 = { 1: [2], 2: [1, 3], 3: [2] } print(detect_cycle(graph3)) # Output: False graph4 = { 1: [2, 4], 2: [1, 3], 3: [2, 4], 4: [1, 3] } print(detect_cycle(graph4)) # Output: True ``` # Function Signature ```python def detect_cycle(graph: dict) -> bool: # Your implementation here ```","solution":"def detect_cycle(graph): def dfs(v, parent): visited.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if dfs(neighbor, v): return True elif neighbor != parent: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, -1): return True return False"},{"question":"# Image Processing with Convolution Filters You are required to implement an image convolution filter and apply it to a sample image. This task will help you understand how convolution filters can be used to manipulate and enhance images. Instructions 1. Implement a function `apply_convolution` that takes an image and a convolution kernel (filter) as inputs. This function should: * Apply the given kernel to the image using 2D convolution. * Return the filtered image. 2. Test your implementation with different kernels on a sample image. Suggested kernels include: * **Identity kernel** (should return the original image) * **Edge detection kernel**: ``` [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]] ``` * **Blur kernel**: ``` [[1/9, 1/9, 1/9], [1/9, 1/9, 1/9], [1/9, 1/9, 1/9]] ``` 3. Display the original and filtered images using matplotlib to visually analyze the effect of each kernel. Expected Input and Output * **Input**: * `image`: 2D numpy array representing a grayscale image. * `kernel`: 2D numpy array representing the convolution kernel. * **Output**: * The function returns a 2D numpy array representing the filtered image. Performance Requirements * Ensure your function performs efficiently on images up to 1024x1024 pixels. Example ```python # Example usage of apply_convolution function import numpy as np import matplotlib.pyplot as plt from scipy.ndimage import convolve def apply_convolution(image, kernel): return convolve(image, kernel, mode=\'constant\', cval=0.0) # Sample image (for simplicity, you can use any 2D numpy array representing an image) image = np.random.rand(100, 100) # Define different kernels identity_kernel = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) edge_detection_kernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]]) blur_kernel = np.array([[1/9, 1/9, 1/9], [1/9, 1/9, 1/9], [1/9, 1/9, 1/9]]) # Apply convolutions filtered_image_identity = apply_convolution(image, identity_kernel) filtered_image_edge = apply_convolution(image, edge_detection_kernel) filtered_image_blur = apply_convolution(image, blur_kernel) # Plot images fig, axs = plt.subplots(1, 4, figsize=(15, 5)) axs[0].imshow(image, cmap=\'gray\') axs[0].set_title(\'Original Image\') axs[1].imshow(filtered_image_identity, cmap=\'gray\') axs[1].set_title(\'Identity Filter\') axs[2].imshow(filtered_image_edge, cmap=\'gray\') axs[2].set_title(\'Edge Detection\') axs[3].imshow(filtered_image_blur, cmap=\'gray\') axs[3].set_title(\'Blur Effect\') plt.show() ``` You are expected to write your own `apply_convolution` function and demonstrate its use with a sample image and the specified kernels.","solution":"import numpy as np from scipy.ndimage import convolve def apply_convolution(image, kernel): Applies a convolution filter to an image using the given kernel. Parameters: image (numpy.ndarray): 2D array representing a grayscale image. kernel (numpy.ndarray): 2D array representing the convolution kernel. Returns: numpy.ndarray: The filtered image. return convolve(image, kernel, mode=\'constant\', cval=0.0)"},{"question":"# Coding Assessment Question Problem Description Write a function `find_missing_number` that takes in a list containing `n` unique integers where the integers are in the range `[0, n]`. Since the list has `n` numbers, one integer from this range is missing. Your task is to identify that missing number. Function Signature ```python def find_missing_number(nums: list[int]) -> int: pass ``` Input - `nums (list[int])`: A list of `n` unique integers in the range `[0, n]`. Output - Returns the missing integer from the range `[0, n]`. Constraints 1. The length of the list `nums` is `n`. 2. All the integers in the list `nums` are unique and range from `0` to `n`. 3. Only one number is missing from the sequence. Example ```python >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9,6,4,2,3,5,7,0,1]) 8 >>> find_missing_number([0]) 1 ``` Performance Requirements - The solution should run in linear time complexity O(n). - The solution should use constant extra space O(1). Edge Cases to Consider 1. List with a single element: `[0]` or `[1]` 2. Missing number at the start: `[1, 2, 3, 4]` (missing 0) 3. Missing number at the end: `[0, 1, 2, 3]` (missing 4) 4. Random order of numbers: `[2, 0, 3]` (missing 1) Good luck!","solution":"def find_missing_number(nums: list[int]) -> int: Find the missing number in the list of unique integers ranging from 0 to n. Args: nums (list[int]): List of integers. Returns: int: The missing integer in the range 0 to len(nums). # Sum of first n natural numbers is (n * (n + 1)) // 2 n = len(nums) expected_sum = n * (n + 1) // 2 # Sum of all numbers in the list actual_sum = sum(nums) # The missing number is the difference between the expected sum and the actual sum return expected_sum - actual_sum"},{"question":"# [New Question]: Array Permutation Challenge Write a function that checks whether one array is a permutation of another array. A permutation, in this context, means that the arrays contain the same elements, only the order of elements can differ. The function should return `True` if one array is a permutation of the other and `False` otherwise. Function Signature ```python def are_permutations(arr1: list[int], arr2: list[int]) -> bool: Parameters: arr1 (list[int]): The first array to check. arr2 (list[int]): The second array to check. Returns: bool: True if arr1 is a permutation of arr2, otherwise False. ``` Input - `arr1`: A list of integers representing the first array (0 <= len(arr1) <= 10^5). - `arr2`: A list of integers representing the second array (0 <= len(arr2) <= 10^5). Constraints - The elements in the arrays are integers and can include negative numbers. - The elements can repeat within an array. Output - A boolean value `True` if `arr1` is a permutation of `arr2`, otherwise `False`. Example ```python >>> are_permutations([1, 2, 3], [3, 2, 1]) True >>> are_permutations([1, 2, 3], [3, 2, 2]) False >>> are_permutations([1, 2, 2, 3], [2, 3, 1, 2]) True >>> are_permutations([1, 2, 3, 4], [1, 2, 3]) False ``` Note - Consider edge cases such as when one or both of the arrays are empty. - Optimize your approach to handle large input sizes efficiently. - You may make use of additional data structures if needed to ensure that your implementation is both correct and performs well.","solution":"from collections import Counter def are_permutations(arr1: list[int], arr2: list[int]) -> bool: Checks whether one array is a permutation of another array. Parameters: arr1 (list[int]): The first array to check. arr2 (list[int]): The second array to check. Returns: bool: True if arr1 is a permutation of arr2, otherwise False. # If the lengths of the arrays are not equal, they cannot be permutations of each other if len(arr1) != len(arr2): return False # Use Counter to count the occurrences of each element in both arrays return Counter(arr1) == Counter(arr2)"},{"question":"# Question: Implement a Custom Sort Function to Handle Negative and Positive Integers You are tasked with implementing a custom sort function to handle a list of integers that contains both negative and positive values. The custom sort will place all negative numbers before positive numbers, while preserving the relative order of negative numbers among themselves and positive numbers among themselves. Your task is to: 1. Implement the `custom_sort` method that performs the described sorting operation. 2. Ensure that the sorting algorithm maintains stability, meaning that the relative order of equal elements remains the same. Requirements: - Your `custom_sort` method should accept one parameter: - `nums`: A list of integers. Input: - `nums`: List of integers containing both negative and positive values. Output: - `sorted_nums`: List of integers where all negative numbers appear before positive numbers, with the original relative order preserved within the negative and positive groups. Constraints: - The input list can contain duplicate values. - The input list can be empty, in which case the output should also be an empty list. # Example: ```python # Example input: nums = [3, -1, -4, 2, -6, 5, 0] # Expected output: # sorted_nums = [-1, -4, -6, 3, 2, 5, 0] ``` Function signature: ```python def custom_sort(nums: List[int]) -> List[int]: pass ``` You should implement the `custom_sort` method to fulfill the requirements while ensuring that both negative and positive numbers retain their original relative ordering within their respective groups.","solution":"from typing import List def custom_sort(nums: List[int]) -> List[int]: Custom sort function that places all negative numbers before positive numbers, while preserving the original relative order within negative and positive groups. :param nums: List of integers to be sorted. :return: A list of integers sorted as described. negative_numbers = [number for number in nums if number < 0] non_negative_numbers = [number for number in nums if number >= 0] return negative_numbers + non_negative_numbers"},{"question":"# Coding Assessment Question Scenario You are developing a new feature for a social media analytics tool. One of the features is to analyze the engagement level of posts based on specific keywords. To achieve this, you need to count the frequency of keywords in a given list of posts, considering various aspects such as case sensitivity and partial words matching. Task Implement a function that counts the occurrence of each keyword in the list of posts. The function should ignore case and count partial words. For example, if the keyword is \'engage\', posts with the word \'engagement\' should be included in the count for \'engage\'. Additionally, from the counted frequencies, determine the keyword with the highest occurrence rate. Function Signature ```python def analyze_keyword_frequency(posts: List[str], keywords: List[str]) -> Tuple[str, int, Dict[str, int]]: Analyze and return the most frequent keyword and its count along with a keyword frequency dictionary. :param posts: List of post strings where keywords need to be counted. :param keywords: List of keywords to be counted in the posts. :return: A tuple containing: - The keyword with the highest frequency. - The count of the keyword with the highest frequency. - A dictionary with keywords as keys and their respective frequencies as values. ``` Inputs and Outputs * **Input Format**: * `posts`: List of strings - Each string represents a social media post. * `keywords`: List of strings - Each string is a keyword to be counted in the posts. * **Output Format**: * A tuple containing the keyword with the highest frequency, its count, and a dictionary of all keywords with their frequency counts. Constraints * The list of posts will have at least one post and at most 10,000 posts. * The list of keywords will have at least one keyword and at most 100 keywords. * Each post will contain a maximum of 280 characters. * The function should ignore case when counting keywords. Performance Requirements * Handle up to 10,000 posts efficiently. * Ensure that the keyword matching is case-insensitive and handles partial matches correctly. Example ```python # Example usage of the function from typing import List, Tuple, Dict def analyze_keyword_frequency(posts: List[str], keywords: List[str]) -> Tuple[str, int, Dict[str, int]]: Analyze and return the most frequent keyword and its count along with a keyword frequency dictionary. keyword_count = {keyword.lower(): 0 for keyword in keywords} for post in posts: post_lower = post.lower() for keyword in keywords: keyword_lower = keyword.lower() keyword_count[keyword_lower] += post_lower.count(keyword_lower) most_frequent_keyword = max(keyword_count, key=keyword_count.get) most_frequent_count = keyword_count[most_frequent_keyword] return most_frequent_keyword, most_frequent_count, keyword_count def main(): posts = [ \\"Engagement is key to success. We should engage with our audience frequently.\\", \\"The level of engagement on our posts is quite impressive.\\", \\"Try to engage your followers with engaging content to increase engagement rates.\\" ] keywords = [\\"engage\\", \\"success\\", \\"impressive\\"] result = analyze_keyword_frequency(posts, keywords) print(result) # Output: (\'engage\', 5, {\'engage\': 5, \'success\': 1, \'impressive\': 1}) if __name__ == \\"__main__\\": main() ``` Evaluation Criteria: 1. Correctness: The function should accurately count the frequency of each keyword, considering case insensitivity and partial words. 2. Efficiency: The function should handle the maximum input constraints efficiently. 3. Code Quality: Code should be clean, well-commented, and follow good practices. 4. Usability: The function should return the keyword with the highest frequency along with the count and the frequency dictionary.","solution":"from typing import List, Tuple, Dict def analyze_keyword_frequency(posts: List[str], keywords: List[str]) -> Tuple[str, int, Dict[str, int]]: Analyze and return the most frequent keyword and its count along with a keyword frequency dictionary. :param posts: List of post strings where keywords need to be counted. :param keywords: List of keywords to be counted in the posts. :return: A tuple containing: - The keyword with the highest frequency. - The count of the keyword with the highest frequency. - A dictionary with keywords as keys and their respective frequencies as values. keyword_count = {keyword.lower(): 0 for keyword in keywords} for post in posts: post_lower = post.lower() for keyword in keywords: keyword_lower = keyword.lower() keyword_count[keyword_lower] += post_lower.count(keyword_lower) most_frequent_keyword = max(keyword_count, key=keyword_count.get) most_frequent_count = keyword_count[most_frequent_keyword] return most_frequent_keyword, most_frequent_count, keyword_count"},{"question":"# Task You are given an implementation of a segment tree that supports point updates and range queries. Your task is to implement a method that allows you to perform multiple point updates in a single operation. After performing the point updates, you should be able to query the sum of elements in any given range [left, right). # Function Signature ```python class SegmentTree: # ... (existing methods) def batch_update(self, updates: List[Tuple[int, int]]) -> None: Perform multiple point updates in a single operation Parameters: updates (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, (index, value), representing the index to be updated and the value to add at that index. Returns: None Example Usage: >>> s = SegmentTree([0] * 10) >>> s.batch_update([(2, 5), (3, 10), (5, 15)]) >>> s.query(0, 6) 30 >>> s.query(2, 4) 15 >>> s.query(4, 7) 15 pass ``` # Specifications 1. Implement the `batch_update` method that performs multiple point updates in a single operation. 2. Ensure that the method adheres to the efficiency constraints of segment tree operations, i.e., the updates should collectively have O(m * log N) complexity, where m is the number of updates. # Input - **updates**: A list of tuples, where each tuple contains two integers: the index at which to perform the update and the value to add at that index. # Output - The method should not return anything. It should update the internal state of the segment tree to reflect the batch updates. # Example 1. Create a Segment Tree with 10 zeroed elements: ```python s = SegmentTree([0] * 10) ``` 2. Perform batch updates: ```python s.batch_update([(2, 5), (3, 10), (5, 15)]) ``` 3. Perform queries to verify the updates: ```python assert s.query(0, 6) == 30 assert s.query(2, 4) == 15 assert s.query(4, 7) == 15 ``` # Constraints - You can assume that the indexes provided in the updates are within the bounds of the array. - Values can be positive, negative, or zero.","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): index += self.n self.tree[index] += value while index > 1: index //= 2 self.tree[index] = self.tree[2 * index] + self.tree[2 * index + 1] def query(self, left, right): left += self.n right += self.n total = 0 while left < right: if left % 2: total += self.tree[left] left += 1 if right % 2: right -= 1 total += self.tree[right] left //= 2 right //= 2 return total def batch_update(self, updates): for index, value in updates: self.update(index, value)"},{"question":"# Coding Assessment Question Problem Description You have been provided with a list of integers where every element appears twice except for one. Write a function `find_unique_number(nums: list) -> int` that finds the element that appears only once. Function Signature ```python def find_unique_number(nums: list) -> int: ``` Input - `nums`: A list of integers where every integer appears exactly twice except for one integer that appears exactly once. Output - An integer representing the single unique number. Constraints - The list will contain at least 1 up to a maximum of 10,000 integers. - The list will always contain an odd number of elements. - All integers in the list are in the range of -10^6 to 10^6. Examples ```python # Example 1 nums = [2, 2, 1] assert find_unique_number(nums) == 1 # Example 2 nums = [4, 1, 2, 1, 2] assert find_unique_number(nums) == 4 # Example 3 nums = [1] assert find_unique_number(nums) == 1 # Example 4 try: find_unique_number(None) except TypeError as e: print(e) try: find_unique_number([]) except ValueError as e: print(e) # Example 5 nums = [0, 0, -10^6, 10^6, 10^6] assert find_unique_number(nums) == -10^6 ``` Requirements - Handle input validation, raising a `TypeError` with the message \\"The list does not contain the appropriate information\\" if the input list is None. - Raise a `ValueError` with the message \\"The list is empty\\" if the input list is empty. - Ensure your implementation is efficient and runs within the given constraints. Good luck!","solution":"def find_unique_number(nums: list) -> int: Find the element that appears only once in a list where every other element appears twice. Parameters: nums (list): A list of integers containing all but one element appearing twice. Returns: int: The single element that appears only once. if nums is None: raise TypeError(\\"The list does not contain the appropriate information\\") if not nums: raise ValueError(\\"The list is empty\\") unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Anagram Finder - Efficient Grouping by Anagrams You have been provided with a list of strings. Your task is to create a function that efficiently groups these strings into sets of anagrams. Anagrams are words or phrases that contain the same characters arranged in different orders. For example, \\"listen\\" and \\"silent\\" are anagrams of each other. # Requirements 1. Implement a function `group_anagrams` that groups the input strings into lists of anagrams. 2. Optimize the function to handle large lists of strings efficiently. # Input and Output Formats - **Input**: - `words`: A list of strings. - **Output**: - A list of lists, where each sub-list contains all anagrams from the input list. # Constraints - All input strings will contain only lowercase alphabetical characters. - The length of each string will not exceed 100 characters. - The number of strings in the list can be up to 10^5. # Example ```python # Example usage of `group_anagrams` words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"rat\\", \\"tar\\", \\"art\\"] result = group_anagrams(words) # Expected Output: [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"google\\", \\"gogole\\"], [\\"rat\\", \\"tar\\", \\"art\\"]] ``` # Your Task: 1. Implement the `group_anagrams` function to group the anagrams from the given list. 2. Ensure the implementation is optimized for performance. ```python def group_anagrams(words): from collections import defaultdict # Using a dictionary to map sorted word to list of anagrams anagram_map = defaultdict(list) for word in words: # Sort the word and use it as a key sorted_word = \'\'.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values()) ``` # Tips: - Utilize data structures that offer efficient insertion and lookup for optimization. - Sorting each word and using it as a key can dramatically simplify the grouping operation.","solution":"def group_anagrams(words): from collections import defaultdict # Using a dictionary to map sorted word to list of anagrams anagram_map = defaultdict(list) for word in words: # Sort the word and use it as a key sorted_word = \'\'.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"# Question: Calendar Event Scheduler Objective: Building a collaborative calendar application, you are tasked to implement the calendar event scheduler. The scheduler should allow users to add events, check for conflicts, and retrieve the list of events for a given day. Part 1: Implementing the Scheduler 1. **Class: `Event`** * Represents a calendar event with a title, start time, end time, and description. ```python class Event: def __init__(self, title: str, start_time: str, end_time: str, description: str): Initialize a new event. Parameters: title (str): Title of the event. start_time (str): Start time of the event in \'HH:MM\' format. end_time (str): End time of the event in \'HH:MM\' format. description (str): Description of the event. self.title = title self.start_time = start_time self.end_time = end_time self.description = description ``` 2. **Class: `Calendar`** * Manage a collection of events, with functionality to add events, check for conflicts, and retrieve events for a specific day. ```python class Calendar: def __init__(self): Initialize a new calendar with an empty list of events. self.events = [] def add_event(self, event: Event) -> bool: Add a new event to the calendar if it does not conflict with existing events. Parameters: event (Event): The event to be added. Returns: bool: True if the event was added successfully, False if it conflicts with an existing event. for e in self.events: if self.is_conflicting(event, e): return False self.events.append(event) return True def is_conflicting(self, event1: Event, event2: Event) -> bool: Check if two events conflict with each other. Parameters: event1 (Event): The first event. event2 (Event): The second event. Returns: bool: True if the events conflict, False otherwise. return not (event1.end_time <= event2.start_time or event1.start_time >= event2.end_time) def get_events(self, date: str) -> list: Retrieve a list of events for the specified date. Parameters: date (str): The date in \'YYYY-MM-DD\' format. Returns: list: A list of events scheduled for the given date. return [event for event in self.events if event.start_time.startswith(date)] ``` Constraints & Requirements: * Ensure that event start and end times are valid 24-hour format `HH:MM` strings. * Events are not allowed to overlap in time. * The `Calendar.get_events` method should return events in the order they were added. Example: ```python event1 = Event(\\"Meeting\\", \\"2023-10-23 09:00\\", \\"2023-10-23 10:00\\", \\"Project discussion\\") event2 = Event(\\"Workshop\\", \\"2023-10-23 10:00\\", \\"2023-10-23 12:00\\", \\"Python workshop\\") event3 = Event(\\"Lunch\\", \\"2023-10-23 13:00\\", \\"2023-10-23 14:00\\", \\"Team lunch\\") calendar = Calendar() print(calendar.add_event(event1)) # Output: True print(calendar.add_event(event2)) # Output: True print(calendar.add_event(event3)) # Output: True print(calendar.add_event(Event(\\"Conflict Event\\", \\"2023-10-23 09:30\\", \\"2023-10-23 10:30\\", \\"Overlapping event\\"))) # Output: False events_on_23rd = calendar.get_events(\\"2023-10-23\\") for event in events_on_23rd: print(event.title) # Output: # Meeting # Workshop # Lunch ``` Ensure your implementation covers edge cases, handles time conflicts correctly, and operates efficiently with the ability to handle multiple events.","solution":"class Event: def __init__(self, title: str, start_time: str, end_time: str, description: str): Initialize a new event. Parameters: title (str): Title of the event. start_time (str): Start time of the event in \'YYYY-MM-DD HH:MM\' format. end_time (str): End time of the event in \'YYYY-MM-DD HH:MM\' format. description (str): Description of the event. self.title = title self.start_time = start_time self.end_time = end_time self.description = description class Calendar: def __init__(self): Initialize a new calendar with an empty list of events. self.events = [] def add_event(self, event: Event) -> bool: Add a new event to the calendar if it does not conflict with existing events. Parameters: event (Event): The event to be added. Returns: bool: True if the event was added successfully, False if it conflicts with an existing event. for e in self.events: if self.is_conflicting(event, e): return False self.events.append(event) return True def is_conflicting(self, event1: Event, event2: Event) -> bool: Check if two events conflict with each other. Parameters: event1 (Event): The first event. event2 (Event): The second event. Returns: bool: True if the events conflict, False otherwise. return not (event1.end_time <= event2.start_time or event1.start_time >= event2.end_time) def get_events(self, date: str) -> list: Retrieve a list of events for the specified date. Parameters: date (str): The date in \'YYYY-MM-DD\' format. Returns: list: A list of events scheduled for the given date. return [event for event in self.events if event.start_time.startswith(date)]"},{"question":"# Coding Assessment Question You\'re given a class `Point` that represents a point in a 2D Cartesian coordinate system. Enhance the class by adding two new methods: 1. `distance_to_origin()` - Computes the Euclidean distance of the point from the origin (0, 0). 2. `move(delta_x: float, delta_y: float)` - Moves the point by the given delta values along the x and y axes. Implement the following methods with the exact signatures as shown. Expected Input and Output Formats: ```python class Point: def __init__(self, x: float = 0.0, y: float = 0.0) -> None: self.x = x self.y = y def distance_to_origin(self) -> float: Computes the Euclidean distance from the point to the origin (0, 0). >>> p = Point(3, 4) >>> p.distance_to_origin() 5.0 >>> def move(self, delta_x: float, delta_y: float) -> None: Moves the point by delta_x along the x-axis and delta_y along the y-axis. >>> p = Point(3, 4) >>> p.move(1, -2) >>> p.x, p.y (4.0, 2.0) >>> ``` Constraints: - The `distance_to_origin` method should compute the distance using the formula sqrt(x^2 + y^2). - The `move` method should update the point coordinates correctly based on the provided delta values. - Ensure the methods handle edge cases gracefully (e.g., negative coordinates, zero coordinates). **Scenario/Context**: You are working on a graphics application that involves manipulating points on a 2D plane. Efficiently calculate the distance from a point to the origin and allow for smooth translations of points as needed for geometric transformations.","solution":"import math class Point: def __init__(self, x: float = 0.0, y: float = 0.0) -> None: self.x = x self.y = y def distance_to_origin(self) -> float: Computes the Euclidean distance from the point to the origin (0, 0). >>> p = Point(3, 4) >>> p.distance_to_origin() 5.0 >>> return math.sqrt(self.x ** 2 + self.y ** 2) def move(self, delta_x: float, delta_y: float) -> None: Moves the point by delta_x along the x-axis and delta_y along the y-axis. >>> p = Point(3, 4) >>> p.move(1, -2) >>> p.x, p.y (4.0, 2.0) >>> self.x += delta_x self.y += delta_y"},{"question":"# Coding Assessment Question Design and implement a class to manage a dynamic array that can perform the following operations: 1. `append(value)` - Adds an element at the end of the array. 2. `average(k)` - Returns the average of the last `k` elements in the array. 3. `rotate_right(k)` - Rotates the array to the right by `k` positions. Each method should be implemented to adhere to the provided constraints. Expected Input and Output Formats: ```python class DynamicArray: def __init__(self): Initialize your data structure here. def append(self, value: int) -> None: Adds an element at the end of the array. >>> arr = DynamicArray() >>> arr.append(1) >>> arr.append(2) >>> arr.append(3) >>> arr.append(4) >>> arr.append(5) def average(self, k: int) -> float: Returns the average of the last k elements in the array. If k is greater than the length of the array, return the average of the entire array. >>> arr = DynamicArray() >>> arr.append(1) >>> arr.append(2) >>> arr.append(3) >>> arr.append(4) >>> arr.append(5) >>> arr.average(3) 4.0 >>> arr.average(10) 3.0 def rotate_right(self, k: int) -> None: Rotates the array to the right by k positions. >>> arr = DynamicArray() >>> arr.append(1) >>> arr.append(2) >>> arr.append(3) >>> arr.append(4) >>> arr.append(5) >>> arr.rotate_right(2) >>> arr.display() [4, 5, 1, 2, 3] def display(self) -> None: Displays the array in its current state. >>> arr = DynamicArray() >>> arr.append(1) >>> arr.append(2) >>> arr.display() [1, 2] ``` Constraints: - Assume that after initialization, the append method will be called multiple times. - The average method should handle the calculation efficiently even for large values of `k`. - Rotating the array should be accomplished in O(N) time complexity where N is the size of the array. - Memory usage should be kept minimal and methods should perform operations in place as much as possible. - The methods should handle edge cases gracefully (e.g., k greater than the length of the array, empty array). **Scenario/Context**: You are tasked with designing a dynamic array to handle real-time data analytics. This array must efficiently manage frequent data append operations and provide quick computations such as calculating a rolling average or rotating the elements for various analytical needs. Implement these functionalities with an emphasis on performance and robustness.","solution":"class DynamicArray: def __init__(self): Initialize your data structure here. self.array = [] def append(self, value: int) -> None: Adds an element at the end of the array. self.array.append(value) def average(self, k: int) -> float: Returns the average of the last k elements in the array. If k is greater than the length of the array, return the average of the entire array. if k > len(self.array): k = len(self.array) if k == 0: return 0 return sum(self.array[-k:]) / k def rotate_right(self, k: int) -> None: Rotates the array to the right by k positions. n = len(self.array) if n == 0: return k = k % n self.array = self.array[-k:] + self.array[:-k] def display(self) -> list: Displays the array in its current state. return self.array"},{"question":"# Coding Assessment Question Context: You are tasked with developing a feature for a software application that involves processing user log data. Each log entry consists of a timestamp, user ID, and an action. A common requirement is to identify and extract blocks of consecutive time periods where a user is active based on the logs. Consecutive activity is defined as subsequent log entries without more than a specific gap in minutes between them. Task: Write a function `find_activity_blocks(logs: list[dict], gap: int) -> dict` that takes a list of log entries and a maximum allowed gap (in minutes) between consecutive logs to be considered as part of the same activity block, and returns a dictionary where keys are user IDs and values are lists of activity blocks. Each activity block is represented as a list of timestamps. Function Signature: ```python def find_activity_blocks(logs: list[dict], gap: int) -> dict: ``` Input: * A list of logs where each log is represented by a dictionary with keys `\\"timestamp\\"` (a string in the format \\"YYYY-MM-DD HH:MM:SS\\"), `\\"user_id\\"` (an integer), and `\\"action\\"` (a string). * An integer `gap` that specifies the maximum gap (in minutes) between consecutive logs to consider them as part of the same activity block. * Example Logs: ``` [ {\\"timestamp\\": \\"2023-01-01 10:00:00\\", \\"user_id\\": 1, \\"action\\": \\"login\\"}, {\\"timestamp\\": \\"2023-01-01 10:05:00\\", \\"user_id\\": 1, \\"action\\": \\"view\\"}, {\\"timestamp\\": \\"2023-01-01 10:20:00\\", \\"user_id\\": 2, \\"action\\": \\"login\\"}, {\\"timestamp\\": \\"2023-01-01 10:25:00\\", \\"user_id\\": 1, \\"action\\": \\"logout\\"}, {\\"timestamp\\": \\"2023-01-01 10:30:00\\", \\"user_id\\": 2, \\"action\\": \\"view\\"}, {\\"timestamp\\": \\"2023-01-01 10:40:00\\", \\"user_id\\": 1, \\"action\\": \\"login\\"}, {\\"timestamp\\": \\"2023-01-01 10:45:00\\", \\"user_id\\": 1, \\"action\\": \\"view\\"} ] ``` Output: * A dictionary where keys are user IDs, and values are lists of lists of timestamps representing the user\'s consecutive activity blocks. * Example Output: ``` { 1: [[\\"2023-01-01 10:00:00\\", \\"2023-01-01 10:05:00\\"], [\\"2023-01-01 10:25:00\\"], [\\"2023-01-01 10:40:00\\", \\"2023-01-01 10:45:00\\"]], 2: [[\\"2023-01-01 10:20:00\\", \\"2023-01-01 10:30:00\\"]] } ``` Constraints: * The length of the input logs list is between 1 and 10^5. * Timestamps in the input logs are formatted as \\"YYYY-MM-DD HH:MM:SS\\" and are within the same year. * The gap is a non-negative integer less than or equal to 60. * The log entries are sorted by timestamp. Example: ```python logs = [ {\\"timestamp\\": \\"2023-01-01 10:00:00\\", \\"user_id\\": 1, \\"action\\": \\"login\\"}, {\\"timestamp\\": \\"2023-01-01 10:05:00\\", \\"user_id\\": 1, \\"action\\": \\"view\\"}, {\\"timestamp\\": \\"2023-01-01 10:20:00\\", \\"user_id\\": 2, \\"action\\": \\"login\\"}, {\\"timestamp\\": \\"2023-01-01 10:30:00\\", \\"user_id\\": 2, \\"action\\": \\"view\\"} ] gap = 10 assert find_activity_blocks(logs, gap) == { 1: [[\\"2023-01-01 10:00:00\\", \\"2023-01-01 10:05:00\\"]], 2: [[\\"2023-01-01 10:20:00\\", \\"2023-01-01 10:30:00\\"]] } ``` Performance Requirements: * The solution should efficiently process the logs and adhere to the gap constraint. Summary: Implement the `find_activity_blocks` function to identify periods of consecutive user activity from log data, ensuring you consider the maximum allowed gap between logs to group them into activity blocks. Make sure to handle edge cases such as users with single log entries or multiple close ones.","solution":"from datetime import datetime def find_activity_blocks(logs: list[dict], gap: int) -> dict: def parse_timestamp(timestamp): return datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") user_activities = {} for log in logs: user_id = log[\\"user_id\\"] timestamp = parse_timestamp(log[\\"timestamp\\"]) if user_id not in user_activities: user_activities[user_id] = [] if not user_activities[user_id] or (timestamp - parse_timestamp(user_activities[user_id][-1][-1])).total_seconds() / 60 > gap: user_activities[user_id].append([log[\\"timestamp\\"]]) else: user_activities[user_id][-1].append(log[\\"timestamp\\"]) return user_activities"},{"question":"# Question You are tasked with creating a general framework for interval arithmetic operations, specifically for managing a set of closed intervals and providing efficient querying for overlaps. Objectives - Implement an `IntervalSet` class supporting insertion of intervals and querying for overlap with a given interval. - Ensure the data structure is space-efficient and operations perform efficiently. Input - A list of intervals to be inserted: `List[Tuple[int, int]]` each representing a closed interval `[start, end]`. - A single interval `Tuple[int, int]` to query for overlaps. Output - A list of intervals from the `IntervalSet` that overlap with the query interval, returned as a list of tuples `List[Tuple[int, int]]`. Constraints - The list of intervals to be inserted can contain up to 10^5 intervals. - The start and end of each interval are integers and valid intervals such that `start <= end`. - The query interval is a valid interval where `query_start <= query_end`. Example ```python # Sample usage intervals = [(1, 5), (10, 15), (20, 25), (12, 18)] query_interval = (14, 22) interval_set = IntervalSet() for interval in intervals: interval_set.insert(interval) result = interval_set.query(query_interval) print(result) # Expected: [(10, 15), (12, 18), (20, 25)] ``` Requirements 1. Complete the implementation of the `IntervalSet` class. 2. Focus on ensuring that both insertion and querying operations are efficient. 3. Aim to handle edge cases such as adjacent and exactly matching intervals correctly. You are not required to modify the given initialization interface or method signatures, but you can modify internal data structures and algorithms as needed to achieve the goals.","solution":"class IntervalSet: def __init__(self): self.intervals = [] def insert(self, interval): Insert a new interval into the set. Args: interval (Tuple[int, int]): The interval to insert as (start, end). self.intervals.append(interval) # Ensure the intervals list is sorted for efficient querying self.intervals.sort() def query(self, query_interval): Query the interval set for all intervals that overlap with the query interval. Args: query_interval (Tuple[int, int]): The interval to query as (start, end). Returns: List[Tuple[int, int]]: A list of intervals that overlap with the given interval. query_start, query_end = query_interval result = [] for interval in self.intervals: interval_start, interval_end = interval # Check if there is an overlap if interval_start <= query_end and interval_end >= query_start: result.append(interval) return result"},{"question":"# Question You have been tasked with developing a Python function to manage a dynamic inventory system, where products can be added, removed, and queried. The inventory system should keep track of the quantity of each product and the total value of the inventory based on product prices. Given the following requirements: - Implement a Python class `Inventory` that supports adding products, removing products, and querying the inventory. - Each product is identified by a unique string ID and has associated attributes: quantity (integer) and price (integer per unit). # Class Definition ```python class Inventory: def __init__(self): pass def add_product(self, product_id: str, quantity: int, price: int) -> None: pass def remove_product(self, product_id: str, quantity: int) -> bool: pass def get_total_value(self) -> int: pass def get_product_info(self, product_id: str) -> Tuple[int, int]: pass ``` # Method Signatures ```python def add_product(self, product_id: str, quantity: int, price: int) -> None: pass def remove_product(self, product_id: str, quantity: int) -> bool: pass def get_total_value(self) -> int: pass def get_product_info(self, product_id: str) -> Tuple[int, int]: pass ``` # Parameters and Returns - `add_product(self, product_id: str, quantity: int, price: int) -> None`: Adds the specified quantity of a product with the given price to the inventory. If the product already exists, update its quantity and price. - `remove_product(self, product_id: str, quantity: int) -> bool`: Removes the specified quantity of the product from the inventory. If the product does not exist or there is insufficient quantity, return `False`. Otherwise, return `True`. - `get_total_value(self) -> int`: Returns the total value of all products in the inventory (total quantity * price for each product). - `get_product_info(self, product_id: str) -> Tuple[int, int]`: Returns a tuple of the quantity and price of the specified product. If the product does not exist, return `(0, 0)`. # Example ```python inventory = Inventory() # Adding products inventory.add_product(\'apple\', 50, 2) inventory.add_product(\'banana\', 30, 1) inventory.add_product(\'apple\', 20, 3) # Querying product information print(inventory.get_product_info(\'apple\')) # Output: (70, 3) print(inventory.get_product_info(\'banana\')) # Output: (30, 1) print(inventory.get_product_info(\'cherry\')) # Output: (0, 0) # Removing products print(inventory.remove_product(\'banana\', 10)) # Output: True print(inventory.remove_product(\'banana\', 50)) # Output: False # Getting total value print(inventory.get_total_value()) # Output: (70 * 3 + 20) ``` # Constraints - The inventory should handle up to 1000 unique products. - The quantity and price for each product will be non-negative integers. - The remove operation should gracefully handle attempts to remove more quantity than available. # Additional Note Ensure your implementation efficiently manages the operations, especially considering large inventories. Handle edge cases effectively, such as adding products with zero quantity or attempting to remove more products than exist in the inventory.","solution":"from typing import Tuple class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: str, quantity: int, price: int) -> None: if product_id in self.products: self.products[product_id][\'quantity\'] += quantity self.products[product_id][\'price\'] = price else: self.products[product_id] = {\'quantity\': quantity, \'price\': price} def remove_product(self, product_id: str, quantity: int) -> bool: if product_id not in self.products or self.products[product_id][\'quantity\'] < quantity: return False self.products[product_id][\'quantity\'] -= quantity if self.products[product_id][\'quantity\'] == 0: del self.products[product_id] return True def get_total_value(self) -> int: total_value = 0 for product in self.products.values(): total_value += product[\'quantity\'] * product[\'price\'] return total_value def get_product_info(self, product_id: str) -> Tuple[int, int]: if product_id in self.products: product = self.products[product_id] return product[\'quantity\'], product[\'price\'] return 0, 0"},{"question":"# Question You have been provided with a partially implemented Binary Search Tree (BST). Your task is to implement a function that returns the height of the BST. Implement the function `calculate_bst_height(root: TreeNode) -> int` that calculates the height of the BST. # Function Signature ```python def calculate_bst_height(root: TreeNode) -> int: ``` # Input * `root`: The root node of the Binary Search Tree. # Output * Returns the height of the BST as an integer. # Constraints 1. The Binary Search Tree is constructed correctly and is not malformed. 2. Each node in the tree contains an integer value. # Example ```python # Define TreeNode class for the Binary Search Tree class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key # Initialize BST nodes root = TreeNode(3) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.right.left = TreeNode(4) root.right.right = TreeNode(6) # Calculate height of BST print(calculate_bst_height(root)) # Expected Output: 3 ``` # Notes * The height of a single-node tree is 1. * You may assume that the tree does not contain cycles or duplicate values. * Ensure that your implementation is efficient and handles various edge cases. * Write additional helper functions if necessary to modularize your solution.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def calculate_bst_height(root: TreeNode) -> int: Returns the height of the binary search tree. :param root: TreeNode, the root of the BST :return: int, height of the BST if root is None: return 0 left_height = calculate_bst_height(root.left) right_height = calculate_bst_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Problem Description You are given an array of `n` integers and an integer `k`. Your task is to write a function `find_k_largest` that finds the k-th largest element in the array. Your solution should have an optimal time complexity ideally around O(n). **Function Signature**: ```python def find_k_largest(arr: List[int], k: int) -> int: pass ``` # Input * A list of integers `arr` where ( 1 ≤ len(arr) ≤ 10^5 ) * An integer `k` where ( 1 ≤ k ≤ len(arr) ) # Output * Return an integer representing the k-th largest element in the array. # Constraints * The array can contain duplicate elements. * Ensure the solution is efficient and handles edge cases appropriately. # Example **Example 1**: ```python assert find_k_largest([3, 2, 1, 5, 6, 4], 2) == 5 ``` Explanation: The 2nd largest element in the array [3, 2, 1, 5, 6, 4] is 5. **Example 2**: ```python assert find_k_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 ``` Explanation: The 4th largest element in the array [3, 2, 3, 1, 2, 4, 5, 5, 6] is 4. **Example 3**: ```python assert find_k_largest([1], 1) == 1 ``` Explanation: The 1st largest element in the array [1] is 1. # Notes * Consider using algorithms such as Quickselect or a min-heap to achieve the desired time complexity. * Handle edge cases where the array has only one element or all elements are the same. * Make sure your function is robust to large arrays within the provided constraints.","solution":"from typing import List import heapq def find_k_largest(arr: List[int], k: int) -> int: Finds the k-th largest element in the array. if len(arr) == 0 or k < 1 or k > len(arr): return None # Use a min-heap of size k min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappushpop(min_heap, num) return min_heap[0]"},{"question":"# List Reversal Checker # Background In computer science, reversing elements in a list is a fundamental operation. It is sometimes necessary to check if a list has been properly reversed or not. # Problem You are required to write a function `is_reversed(original_list: list, reversed_list: list) -> bool` that checks if the `reversed_list` is indeed the reversed version of the `original_list`. # Inputs - `original_list`: A list of integers. - `reversed_list`: A list of integers that is supposed to be the reversed version of `original_list`. # Outputs - A boolean value `True` if `reversed_list` is the exact reverse of `original_list`, otherwise `False`. # Constraints - Both `original_list` and `reversed_list` will have the same length. - The length of the lists will be between 1 and 1000 inclusive. - The elements of the lists will be integers ranging from -10000 to 10000 inclusive. # Examples ```python assert is_reversed([1, 2, 3, 4], [4, 3, 2, 1]) == True assert is_reversed([1, 2, 3], [3, 2, 1]) == True assert is_reversed([-1, -2, -3], [-3, -2, -1]) == True assert is_reversed([1, 2], [2, 1, 0]) == False assert is_reversed([1], [1]) == True ``` **Your task** is to implement the `is_reversed` function that checks if the input `reversed_list` is indeed the reversed version of the `original_list`. Ensure that you: - Validate the inputs correctly. - Compare the lists accurately. - Return the appropriate boolean value based on whether the lists are reverses of each other.","solution":"def is_reversed(original_list: list, reversed_list: list) -> bool: Check if reversed_list is the reversed version of original_list. return original_list == reversed_list[::-1]"},{"question":"# Conveyor Belt Simulation Using Queues Context In a manufacturing process, objects are placed on a conveyor belt and processed in a first-come-first-served manner. Each object has a specific weight and processing time. The goal is to simulate this conveyor belt mechanism using a queue, ensuring accurate handling of the objects and efficient processing. Task Implement a simulation of the conveyor belt using a queue data structure. Your simulation should be able to add objects to the belt, process them, and track the total processing time. Specific Objectives 1. **Queue Operations**: Implement enqueue and dequeue operations to manage objects on the conveyor belt. 2. **Processing Simulation**: Simulate the processing of objects while tracking and updating their processing status. 3. **Tracking Time**: Track and report the total processing time of all objects. Function Signature ```python class ConveyorBelt: def __init__(self): pass def add_object(self, weight: int, process_time: int) -> None: pass def process_objects(self) -> int: pass ``` Input - `add_object(weight: int, process_time: int)`: Adds an object with the given weight and processing time to the conveyor belt. - `weight`: An integer representing the weight of the object. - `process_time`: An integer representing the time required to process the object in seconds. - `process_objects() -> int`: Processes all objects in the queue and returns the total processing time in seconds. Output - `process_objects() -> int`: Returns the total processing time in seconds of all objects processed. Constraints - The conveyor belt can hold any number of objects. - Each object has a positive integer weight (`1 <= weight <= 1000`). - Each object\'s processing time is a positive integer (`1 <= process_time <= 3600`). Requirements - Use a suitable queue data structure to manage the conveyor belt. - Ensure efficient handling and processing of objects. - Implement accurate tracking of the total processing time. Example ```python class ConveyorBelt: def __init__(self): self.queue = [] def add_object(self, weight: int, process_time: int) -> None: self.queue.append((weight, process_time)) def process_objects(self) -> int: total_time = 0 while self.queue: weight, process_time = self.queue.pop(0) # Simulate processing the object total_time += process_time return total_time # Example usage: belt = ConveyorBelt() belt.add_object(200, 120) belt.add_object(150, 300) belt.add_object(500, 180) total_time = belt.process_objects() print(total_time) # Output: 600 (120 + 300 + 180) ``` Good luck!","solution":"from collections import deque class ConveyorBelt: def __init__(self): self.queue = deque() def add_object(self, weight: int, process_time: int) -> None: Adds an object with the given weight and processing time to the conveyor belt. self.queue.append((weight, process_time)) def process_objects(self) -> int: Processes all objects in the queue and returns the total processing time in seconds. total_time = 0 while self.queue: weight, process_time = self.queue.popleft() total_time += process_time return total_time"},{"question":"# Coding Question You are required to create a library management system feature focusing on book inventory maintenance and transaction logging. The provided functionalities will include adding a new book, borrowing a book, returning a book, and viewing the transaction history of borrowed and returned books. Ensure the system treats case-sensitive book titles accurately. Objective Design and implement the necessary functions and enhancements to manage the library\'s book inventory effectively and keep a log of all transactions. 1. **Enhance Existing Functions**: - Modify the `borrow_book` function to ensure the book title is treated in a case-sensitive manner and update the inventory count accordingly. - Update the `return_book` function to handle the book title case-sensitively while updating the inventory count. 2. **Add New Functionalities**: - Implement a `view_transactions` function that returns a list of all borrow and return transactions logged in the order they were made. - Implement data validation in the `main` function to prompt user input until a valid book title and transaction type (borrow/return) are provided. Function Implementations - **add_book(title: str) -> None**: - Input: A string (title). - Output: Adds the book title to the inventory with an initial count of `1` or increments the count if the book already exists. - **borrow_book(title: str) -> str**: - Input: A string (title). - Output: If the book is available, decrement its count and log the transaction. Return a success message or an error message if the book is not available. - **return_book(title: str) -> str**: - Input: A string (title). - Output: Increment the count of the returned book and log the transaction. Return a success message. - **view_transactions() -> list[dict[str, str]]**: - Input: None - Output: Returns a list of dictionaries, each containing the transaction type (\'borrow\' or \'return\') and the book title. Example ```python >>> add_book(\\"The Great Gatsby\\") >>> add_book(\\"The Great Gatsby\\") >>> borrow_book(\\"The Great Gatsby\\") \'You have successfully borrowed \\"The Great Gatsby\\".\' >>> borrow_book(\\"The Great Gatsby\\") \'You have successfully borrowed \\"The Great Gatsby\\".\' >>> borrow_book(\\"The great gatsby\\") \'The book \\"The great gatsby\\" is not available for borrowing.\' >>> return_book(\\"The Great Gatsby\\") \'You have successfully returned \\"The Great Gatsby\\".\' >>> view_transactions() [{\'type\': \'borrow\', \'title\': \'The Great Gatsby\'}, {\'type\': \'borrow\', \'title\': \'The Great Gatsby\'}, {\'type\': \'return\', \'title\': \'The Great Gatsby\'}] ``` Ensure your program handles book titles case-sensitively and logs all transactions in the correct sequence.","solution":"class LibraryManagementSystem: def __init__(self): self.inventory = {} self.transactions = [] def add_book(self, title): if title in self.inventory: self.inventory[title] += 1 else: self.inventory[title] = 1 def borrow_book(self, title): if title in self.inventory and self.inventory[title] > 0: self.inventory[title] -= 1 self.transactions.append({\'type\': \'borrow\', \'title\': title}) return f\'You have successfully borrowed \\"{title}\\".\' else: return f\'The book \\"{title}\\" is not available for borrowing.\' def return_book(self, title): self.inventory[title] = self.inventory.get(title, 0) + 1 self.transactions.append({\'type\': \'return\', \'title\': title}) return f\'You have successfully returned \\"{title}\\".\' def view_transactions(self): return self.transactions"},{"question":"You are required to implement a `MinStack` class, which supports the following operations: 1. **`push(value)`**: Push a new value onto the stack. 2. **`pop()`**: Removes the value on the top of the stack. 3. **`top()`**: Retrieves the value on the top of the stack without removing it. 4. **`get_min()`**: Retrieves the minimum value in the stack. 5. **`is_empty()`**: Checks if the stack is empty. # Input and Output Formats: - **`push(value)`**: - Input: `value` is any integer. - Output: None - **`pop()`**: - Output: Integer value removed from the top of the stack. - **`top()`**: - Output: Integer value currently on the top of the stack. - **`get_min()`**: - Output: Integer value which is the minimum in the stack. - **`is_empty()`**: - Output: Boolean value. # Constraints: 1. The values inserted into the stack are within the range of a 32-bit signed integer. 2. The typical sequence of operations will not exceed 10000 operations. # Performance Requirements: All operations, including `get_min()`, must be performed in constant time, O(1). # Example Usage: ```python # Initialize stack stack = MinStack() stack.push(5) stack.push(3) stack.push(7) stack.push(1) assert stack.get_min() == 1 stack.pop() assert stack.get_min() == 3 stack.pop() assert stack.get_min() == 3 assert stack.top() == 3 stack.pop() assert stack.get_min() == 5 assert stack.is_empty() == False stack.pop() assert stack.is_empty() == True ``` Your task is to complete the `MinStack` class and implement the methods as per the description.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def top(self): if self.is_empty(): raise IndexError(\\"top from empty stack\\") return self.stack[-1] def get_min(self): if self.is_empty(): raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1] def is_empty(self): return len(self.stack) == 0"},{"question":"Matrix Rotation You are tasked with implementing an algorithm to rotate a given n x n matrix by 90 degrees clockwise. To achieve this, you are only allowed to modify the matrix in place, meaning you should not use any additional matrices or large amounts of extra memory. Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: pass ``` Input * A 2D list `matrix` where the number of rows and columns are equal (n x n matrix) and each element is an integer. Output * The function modifies the input `matrix` in place to represent a 90-degree clockwise rotation. Constraints * The function should handle edge cases such as small (1x1) or large matrices. * Typical values for n range between 1 and 1000. Performance Requirements * The algorithm should run efficiently within the given constraints. * The time complexity should be O(n^2). * The space complexity should be O(1), i.e., in-place rotations without using extra memory. Example For instance, rotating the following 3x3 matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` should modify it to: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Notes * Directly modifying the input matrix implies that the changes should reflect when accessing the input matrix post function call. * Ensure the function handles even and odd sizes of n correctly and efficiently.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement You are required to create a class `MatrixOperations` that provides various matrix-related functionalities. The class should implement methods to perform fundamental matrix operations as described below. Consider all possible edge cases and handle errors wherever necessary. # Method Specifications: 1. **transpose(matrix: List[List[int]]) -> List[List[int]]**: - Returns the transpose of the given matrix. - **Input**: A 2D square matrix of integers (1 <= len(matrix) <= 100, 1 <= len(matrix[i]) <= 100). - **Output**: A 2D square matrix which is the transpose of the input matrix. - **Constraints**: Raise a ValueError if the input is not a square matrix. 2. **trace(matrix: List[List[int]]) -> int**: - Calculates and returns the trace of the given matrix. - **Input**: A 2D square matrix of integers (1 <= len(matrix) <= 100, 1 <= len(matrix[i]) <= 100). - **Output**: An integer representing the trace of the matrix. - **Constraints**: Raise a ValueError if the input is not a square matrix. 3. **matrix_multiplication(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]**: - Multiplies two matrices and returns the resultant matrix. - **Input**: Two 2D matrices of integers where the number of columns in `matrix1` matches the number of rows in `matrix2`. - **Output**: A 2D matrix which is the product of `matrix1` and `matrix2`. - **Constraints**: Raise a ValueError if the matrices cannot be multiplied due to incompatible dimensions. 4. **determinant(matrix: List[List[int]]) -> int**: - Calculates the determinant of the given matrix. - **Input**: A 2D square matrix of integers (1 <= len(matrix) <= 100, 1 <= len(matrix[i]) <= 100). - **Output**: An integer representing the determinant of the matrix. - **Constraints**: Raise a ValueError if the input is not a square matrix. # Implementation Details - The class should be efficient, especially for larger matrices, handling worst-case scenarios within reasonable time limits. - You may use any helper functions if needed, but they should be encapsulated within the class. - Ensure proper error handling for all edge cases. Here is an initial structure of the class for reference: ```python class MatrixOperations: def transpose(self, matrix: List[List[int]]) -> List[List[int]]: # Your code here pass def trace(self, matrix: List[List[int]]) -> int: # Your code here pass def matrix_multiplication(self, matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: # Your code here pass def determinant(self, matrix: List[List[int]]) -> int: # Your code here pass ``` **Note** - Ensure to adhere to the method signatures. - Python’s built-in libraries can be used for auxiliary computations. - Raise a `ValueError` for invalid inputs according to the constraints mentioned for each method. # Example Usage ```python mo = MatrixOperations() matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [2, 0], [1, 2] ] print(mo.transpose(matrix1)) # Output: [[1, 3], [2, 4]] print(mo.trace(matrix1)) # Output: 5 print(mo.matrix_multiplication(matrix1, matrix2)) # Output: [[4, 4], [10, 8]] print(mo.determinant(matrix1)) # Output: -2 ```","solution":"from typing import List class MatrixOperations: def transpose(self, matrix: List[List[int]]) -> List[List[int]]: if not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Matrix is not square\\") return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix))] def trace(self, matrix: List[List[int]]) -> int: if not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Matrix is not square\\") return sum(matrix[i][i] for i in range(len(matrix))) def matrix_multiplication(self, matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: if len(matrix1[0]) != len(matrix2): raise ValueError(\\"Matrices cannot be multiplied due to incompatible dimensions\\") result = [[0 for _ in range(len(matrix2[0]))] for _ in range(len(matrix1))] for i in range(len(matrix1)): for j in range(len(matrix2[0])): for k in range(len(matrix2)): result[i][j] += matrix1[i][k] * matrix2[k][j] return result def determinant(self, matrix: List[List[int]]) -> int: if not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Matrix is not square\\") if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): det += ((-1) ** c) * matrix[0][c] * self.determinant(self._get_submatrix(matrix, 0, c)) return det def _get_submatrix(self, matrix: List[List[int]], row: int, col: int) -> List[List[int]]: return [r[:col] + r[col + 1:] for r in (matrix[:row] + matrix[row + 1:])]"},{"question":"# Scenario: You are working as a software developer and have been given a task to analyze a list of employee work records. Each record contains the employee\'s name, the project they have worked on, and the hours they\'ve logged for that project. Your goal is to create a system that can determine which employee has logged the most hours on a single project. # Problem Statement: Your task is to implement a function called `max_hours` which takes a list of work records and returns the name of the employee who has logged the most hours on a single project. If multiple employees have logged the same maximum number of hours on different projects, return all of their names in a list. Implementation Requirements: - Implement a function `max_hours(records: List[Tuple[str, str, int]]) -> Union[str, List[str]]` where: - `records` is a list of tuples, each tuple contains three elements: the employee\'s name (string), the project name (string), and the hours logged (integer). # Constraints: 1. The list of records can be empty, but if it is, the function should return an empty list. 2. All employee names and project names in the tuples are non-empty strings. 3. All hours logged are non-negative integers. Input: - A list of tuples, where each tuple is formatted as (employee_name, project_name, hours_logged). Output: - A single string or a list of strings with the name(s) of the employee(s) who logged the most hours on a single project. If the input list is empty, return an empty list. # Example: Assuming you have the following records: ```python records = [ (\\"Alice\\", \\"ProjectX\\", 35), (\\"Bob\\", \\"ProjectX\\", 42), (\\"Alice\\", \\"ProjectY\\", 20), (\\"Charlie\\", \\"ProjectX\\", 42) ] ``` After implementing `max_hours`, calling `max_hours(records)` will return `[\\"Bob\\", \\"Charlie\\"]` because both Bob and Charlie have logged the maximum hours (42) independently on \\"ProjectX\\". # Instructions: 1. Implement the function `max_hours` that takes in the list of records. 2. Ensure it runs correctly for both the examples and edge cases. 3. Consider edge cases such as empty lists, single record in the list, and multiple employees with the same maximum hours. Good luck!","solution":"from typing import List, Tuple, Union def max_hours(records: List[Tuple[str, str, int]]) -> Union[str, List[str]]: Takes a list of employee work records and returns the name(s) of the employee(s) who have logged the most hours on a single project. :param records: A list of tuples (employee_name, project_name, hours_logged) :return: The name(s) of employee(s) with the most hours logged on a single project. if not records: return [] max_hours_logged = 0 employees_with_max_hours = [] for employee, project, hours in records: if hours > max_hours_logged: max_hours_logged = hours employees_with_max_hours = [employee] elif hours == max_hours_logged: employees_with_max_hours.append(employee) if len(employees_with_max_hours) == 1: return employees_with_max_hours[0] return employees_with_max_hours"},{"question":"# Finding Number of 1 Bits # Problem Statement You are required to implement a function `count_ones` that determines the number of `1` bits (also known as \'set bits\') in the binary representation of a given non-negative integer. # Function Signature ```python def count_ones(number: int) -> int: pass ``` # Input * A single integer `number`, where `0 <= number <= 10^6`. # Output * Return the number of \'1\' bits in the binary representation of the input number. # Constraints * The function should handle non-negative integers only. * Input should be validated and appropriate exceptions should be raised for invalid inputs (`ValueError` for non-integers or negative integers). # Examples ```python >>> count_ones(0) 0 >>> count_ones(5) 2 >>> count_ones(36) 2 >>> count_ones(8) 1 >>> count_ones(50) 3 >>> count_ones(\'Hello\') Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> count_ones(-55) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> count_ones(3.5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer ``` # Explanation Consider the binary representation of the numbers: * `5` is `101` -> 2 bits are set * `36` is `100100` -> 2 bits are set * `8` is `1000` -> 1 bit is set * `0` has no 1s -> returns `0` You can use efficient bit manipulation techniques or built-in functions to implement this function. # Implementation Notes * Validate input and raise `ValueError` if input is not an integer or is negative. * Use bitwise techniques or built-in functions to count the set bits efficiently.","solution":"def count_ones(number: int) -> int: Returns the number of 1 bits in the binary representation of the given non-negative integer. if not isinstance(number, int) or number < 0: raise ValueError(\\"Input must be a non-negative integer\\") return bin(number).count(\'1\')"},{"question":"# Problem Statement You are tasked with creating a basic text-based inventory management system for a small store. The system should allow the user to add, remove, update, and display items in the inventory. # Requirements 1. **Add Item**: Add a new item to the inventory with its name, quantity, and price. 2. **Remove Item**: Remove an existing item from the inventory by name. 3. **Update Item**: Update the quantity and price of an existing item. 4. **Display Inventory**: Display a list of all items in the inventory along with their details. # Input/Output - **Input**: Commands from the user to add, remove, update, and display items. - **Output**: List of items in the inventory when the display command is issued. # Constraints 1. Item names should be unique. 2. Items should be stored in a case-insensitive manner. 3. Ensure consistent formatting when displaying the inventory. # Function Signature ```python def inventory_management(commands: list[str]) -> None: pass ``` # Example ```python if __name__ == \\"__main__\\": commands = [ \\"add apple 10 0.5\\", \\"add banana 20 0.2\\", \\"display\\", \\"update apple 15 0.6\\", \\"remove banana\\", \\"display\\", ] inventory_management(commands) ``` In this example, the inventory management system processes a series of commands to add items, update them, remove them, and finally display the list of items in the inventory. # Implementation Details 1. Parse the input commands to determine the operation (add, remove, update, display). 2. Implement each operation, ensuring that item names are handled in a case-insensitive manner. 3. Format the output of the display operation consistently to include the name, quantity, and price of each item.","solution":"def inventory_management(commands: list[str]) -> None: inventory = {} def add_item(name, quantity, price): name = name.lower() if name not in inventory: inventory[name] = {\\"quantity\\": int(quantity), \\"price\\": float(price)} def remove_item(name): name = name.lower() if name in inventory: del inventory[name] def update_item(name, quantity, price): name = name.lower() if name in inventory: inventory[name] = {\\"quantity\\": int(quantity), \\"price\\": float(price)} def display_inventory(): for item, details in inventory.items(): print(f\\"{item.capitalize()}: {details[\'quantity\']} at {details[\'price\']:.2f}\\") for command in commands: parts = command.split() if parts[0].lower() == \\"add\\": _, name, quantity, price = parts add_item(name, quantity, price) elif parts[0].lower() == \\"remove\\": _, name = parts remove_item(name) elif parts[0].lower() == \\"update\\": _, name, quantity, price = parts update_item(name, quantity, price) elif parts[0].lower() == \\"display\\": display_inventory()"},{"question":"# Coding Assessment Question: Movie Recommendation System As a skilled developer, you\'re assigned to develop a movie recommendation system using Python to assist users in finding similar movies based on a given list of movie titles and their genres. **Context:** Your company\'s recommendation engine needs an efficient solution to suggest movies that are similar based on their genres. Users often search for movies of similar genres using an extensive dataset consisting of movie titles with one or more associated genres. To enhance user experience, you need to implement a system to process this data and provide relevant movie recommendations. # Task: Implement a function `generate_genre_index(movie_file_path: str) -> dict[str, set[str]]` that reads a file of movie titles and their genres, creates a dictionary where the keys are the genres, and the values are sets of movie titles associated with each genre. Additionally, provide another function for fetching movies of the same genres as a given movie title. # Specifications: 1. **Function 1: Reading and Indexing Movies by Genre** ```python def generate_genre_index(movie_file_path: str) -> dict[str, set[str]]: ``` - **Input**: `movie_file_path` (str) - Path to the text file containing movie titles and their genres, each line formatted as \\"Title: Genre1, Genre2, ...\\". - **Output**: Dictionary where keys are genres (str), and values are sets of movie titles (str) associated with each genre. - **Constraints**: - Movie titles and genres are case-insensitive (process in lowercase). - Ignore leading/trailing spaces around movie titles and genres. - Handle large datasets efficiently. 2. **Function 2: Fetching Movies of Same Genres** ```python def recommend_movies(movie_title: str, genre_index: dict[str, set[str]]) -> set[str]: ``` - **Input**: `movie_title` (str) - The title of the movie for which to fetch recommendations; `genre_index` from `generate_genre_index`. - **Output**: Set of recommended movie titles from the same genres (excluding the given movie title itself if present). # Sample Input: ``` # Contents of movies.txt Inception: Sci-Fi, Thriller The Matrix: Sci-Fi, Action Titanic: Romance, Drama Avatar: Sci-Fi, Fantasy The Notebook: Romance, Drama Mad Max: Action, Adventure ``` # Sample Output: ```python { \'sci-fi\': {\'inception\', \'the matrix\', \'avatar\'}, \'thriller\': {\'inception\'}, \'action\': {\'the matrix\', \'mad max\'}, \'romance\': {\'titanic\', \'the notebook\'}, \'drama\': {\'titanic\', \'the notebook\'}, \'fantasy\': {\'avatar\'}, \'adventure\': {\'mad max\'} } ``` # Example Usage: ```python genre_index = generate_genre_index(\\"path/to/movies.txt\\") print(recommend_movies(\\"inception\\", genre_index)) # Output: {\'the matrix\', \'avatar\'} ``` # Performance Requirements: - Solutions should aim for optimized time and space complexity. - Edge cases such as empty files or querying for a movie not in the index should be gracefully handled. # Testing: - Write unit tests to validate your implementation against edge cases, performance bottlenecks, and typical scenarios. Good luck!","solution":"def generate_genre_index(movie_file_path: str) -> dict[str, set[str]]: genre_index = {} with open(movie_file_path, \'r\') as file: for line in file: title, genres = line.split(\':\') title = title.strip().lower() genres = genres.split(\',\') for genre in genres: genre = genre.strip().lower() if genre not in genre_index: genre_index[genre] = set() genre_index[genre].add(title) return genre_index def recommend_movies(movie_title: str, genre_index: dict[str, set[str]]) -> set[str]: movie_title = movie_title.strip().lower() recommended_movies = set() for genre, movies in genre_index.items(): if movie_title in movies: recommended_movies.update(movies) recommended_movies.discard(movie_title) return recommended_movies"},{"question":"# Subset Sum Problem using Dynamic Programming **Context**: You are asked to solve an instance of the Subset Sum Problem using Dynamic Programming. The Subset Sum Problem is a classic problem in computer science where the objective is to determine whether there is a subset of the given set with a sum equal to a given target value. # Your Task: Implement the core components of the Dynamic Programming approach to solve the Subset Sum Problem: 1. **Initialize DP Table**: Write a function to initialize the Dynamic Programming table. 2. **Fill DP Table**: Write a function to populate the DP table based on the given set and the target sum. 3. **Subset Reconstruction**: Write a function to reconstruct the subset from the populated DP table, if one exists. 4. **Subset Sum Algorithm**: Integrate the above components into the main algorithm to determine if a valid subset exists and, if so, return the subset. # Function Signatures: ```python def initialize_dp_table(n: int, target: int) -> list[list[bool]]: pass def fill_dp_table(dp: list[list[bool]], nums: list[int], target: int) -> list[list[bool]]: pass def subset_reconstruction(dp: list[list[bool]], nums: list[int], target: int) -> list[int]: pass def subset_sum(nums: list[int], target: int) -> tuple[bool, list[int]]: pass ``` # Constraints: 1. The maximum length of the set will not exceed 20. 2. Each element in the set will be a positive integer within the range [1, 100]. 3. The target sum will be a positive integer within the range [1, 1000]. # Input/Output Format: - **Input**: - `nums`: A list of integers representing the given set. - `target`: The target sum. - **Output**: - A tuple containing: - A boolean value (`True` if a subset with the target sum exists, `False` otherwise). - A list of integers representing the subset that adds up to the target sum if it exists, otherwise an empty list. # Example: ```python nums = [3, 34, 4, 12, 5, 2] target = 9 exists, subset = subset_sum(nums, target) print(f\\"Subset Exists: {exists}\\") print(f\\"Subset: {subset}\\") ``` ```python nums = [3, 34, 4, 12, 5, 2] target = 30 exists, subset = subset_sum(nums, target) print(f\\"Subset Exists: {exists}\\") print(f\\"Subset: {subset}\\") ``` # Example Output: ```python Subset Exists: True Subset: [4, 5] Subset Exists: False Subset: [] ``` # Choose appropriate libraries if necessary, but the core logic should remain self-contained within the provided function signatures.","solution":"def initialize_dp_table(n, target): Initializes the DP table for subset sum problem. Parameters: - n: Number of items in the nums array - target: The target sum Returns: - DP table as a list of lists (2D table), where dp[i][j] is True if a subset with sum j can be achieved using the first i items. dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True # Base case: subset sum of 0 is always possible (empty subset) return dp def fill_dp_table(dp, nums, target): Fills the DP table based on the given nums array and target sum. Parameters: - dp: Initialized DP table - nums: List of integers - target: The target sum Returns: - Filled DP table. n = len(nums) for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp def subset_reconstruction(dp, nums, target): Reconstructs the subset from the filled DP table if it exists. Parameters: - dp: Filled DP table - nums: List of integers - target: The target sum Returns: - List of integers representing the subset that adds up to the target sum if it exists, otherwise an empty list. subset = [] n = len(nums) if not dp[n][target]: return subset # No valid subset i, j = n, target while i > 0 and j > 0: if dp[i][j] and not dp[i - 1][j]: # This element is included subset.append(nums[i - 1]) j -= nums[i - 1] i -= 1 return subset def subset_sum(nums, target): Determines if there is a subset of the given nums list with a sum equal to the given target and returns the subset if it exists. Parameters: - nums: List of integers - target: The target sum Returns: - Tuple containing: - Boolean value (True if a subset with the target sum exists, False otherwise) - List of integers representing the subset that adds up to the target sum if it exists, otherwise an empty list. n = len(nums) dp = initialize_dp_table(n, target) dp = fill_dp_table(dp, nums, target) subset = subset_reconstruction(dp, nums, target) exists = dp[n][target] return exists, subset"},{"question":"# Prime Number Finder Scenario You are contributing to a math library where one of the required features is to check if a given number is a prime number. Primes have exceptional importance in many fields like cryptography and number theory, making this function crucial for various applications. Problem Statement Write a function `is_prime` that determines whether a given integer is a prime number or not. Your function should return a boolean value indicating the primality of the number. Input and Output * **Input**: An integer `n` where (-10^6 leq n leq 10^6). * **Output**: A boolean value - `True` if the number is prime and `False` otherwise. Constraints: * Ensure your solution is efficient enough to handle the entire input range within a reasonable timeframe. Example: ```python >>> is_prime(11) True >>> is_prime(10) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-7) False >>> is_prime(997) True >>> is_prime(1000003) True ``` Requirements: * Optimize the function to handle large values efficiently. * Account for both positive and negative integers, including zero. Notes: * A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. * Negative numbers, zero, and one are not considered prime.","solution":"def is_prime(n): Determines if a given integer is a prime number. Args: n (int): An integer value. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n == 2 or n == 3 else False if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Coding Assessment Question Context You are tasked with developing a ticketing system for a train station. The system should be able to efficiently process ticket bookings, ensuring that no two bookings overlap in assigned seats. Each train has a fixed number of seats, and every booking specifies a range of consecutive seats that the customer wants to reserve. Problem Statement Given a list of booking attempts for a train with a fixed number of seats, write a Python function `can_book_tickets(seat_count: int, bookings: list) -> list` that determines for each booking attempt whether it can be successfully reserved without overlapping with any previous reservations. Return a list of boolean values indicating the success or failure of each booking attempt. Input Format * An integer representing the total number of seats in the train. * A list of tuples, where each tuple contains two integers `[start, end]`, representing the range of seats requested for a booking (both inclusive). Seat numbers are 1-based. Output Format * Return a list of boolean values, where each value corresponds to whether the respective booking attempt can be successfully reserved. Constraints * `1 <= seat_count <= 10^5` * `1 <= len(bookings) <= 10^5` * `1 <= start <= end <= seat_count` Examples ```python >>> can_book_tickets(10, [(1, 3), (5, 7), (2, 4)]) [True, True, False] >>> can_book_tickets(5, [(1, 3), (2, 5)]) [True, False] >>> can_book_tickets(15, [(1, 5), (6, 10), (11, 15), (5, 6)]) [True, True, True, False] ``` Implementation Notes * You should handle the base case where no booking attempts are made. * Consider using an efficient data structure to track reserved seats and quickly check for overlaps. * Edge cases such as maximum seat numbers and minimal numbers of bookings should be carefully tested.","solution":"def can_book_tickets(seat_count: int, bookings: list) -> list: Determines for each booking attempt if it can be reserved without overlapping with any previous reservations. :param seat_count: Total number of seats in the train. :param bookings: List of tuples, each representing a booking attempt with a start and end seat. :return: List of boolean values where each value corresponds to whether the respective booking can be successfully reserved. reserved = [False] * (seat_count + 1) # Track reserved seats results = [] for start, end in bookings: # Check if the booking range is free if all(not reserved[i] for i in range(start, end + 1)): # Mark range as reserved for i in range(start, end + 1): reserved[i] = True results.append(True) else: results.append(False) return results"},{"question":"# Coding Assessment Question: Efficient Array Rotation You are given an array of integers and an integer (k). Your task is to implement a function that rotates the array to the right by (k) positions. Ensure your implementation is efficient and optimized for performance. # Function Signature ```python def rotate_array(arr: list[int], k: int) -> list[int]: pass ``` # Detailed Requirements 1. **Input**: * A list of integers. * An integer (k) where (0 leq k < 10^9). * You can assume the array can contain up to (10^6) elements. 2. **Output**: * A list of integers which is the result of rotating the input array to the right by (k) positions. 3. **Constraints and Assumptions**: * Your implementation must efficiently handle edge cases such as empty lists and (k) values that are larger than the array length. * Ensure that the rotation operation is performed in (O(n)) time complexity where (n) is the length of the array. * Aim to keep the space complexity to (O(1)), in-place rotations are preferred. 4. **Examples**: ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_array([1, 2, 3, 4, 5], 8) == [3, 4, 5, 1, 2] assert rotate_array([], 3) == [] ``` # Hints: * Consider using the modulus operator to handle cases where (k) is greater than the length of the array. * An optimal approach might involve reversing segments of the array to achieve the rotation without requiring additional space.","solution":"def rotate_array(arr: list[int], k: int) -> list[int]: Rotates the array to the right by k positions. Args: arr: List of integers. k: Integer specifying the number of positions to rotate. Returns: A list of integers rotated to the right by k positions. if not arr: return arr n = len(arr) k = k % n # Normalize k to ensure it\'s less than n # If k is 0, no need to rotate if k == 0: return arr # Reverse the entire array arr.reverse() # Reverse the first k elements arr[:k] = reversed(arr[:k]) # Reverse the remaining n-k elements arr[k:] = reversed(arr[k:]) return arr"},{"question":"# Question You are tasked with implementing a function that simulates a very basic file system with a directory structure. Your function should support the following commands: 1. `mkdir <path>` - Create a directory at the specified path. 2. `addContentToFile <filePath> <content>` - Append content to a file at the specified path. If the file does not exist, create it. 3. `ls <path>` - Return a list of all directories and files at that path. Results should be in lexicographical order. 4. `readContentFromFile <filePath>` - Return the content of the file at the specified path. Each command will be given as a string in the format shown above. Input - A list of command strings, where each command string follows one of the specified formats. Output - For each `ls` and `readContentFromFile` command, output the corresponding result. Constraints - The length of command strings list will be between 1 and 1000. - Each directory or file path will contain only lower case letters and `/` characters. - The total number of directories and files will not exceed 10,000. - The length of any content string for files will not exceed 100 characters. - The combined length of all content strings across all files will not exceed 5,000 characters. # Example ```python class FileSystem: def __init__(self): pass def mkdir(self, path): pass def addContentToFile(self, filePath, content): pass def ls(self, path): pass def readContentFromFile(self, filePath): pass # Example usage fs = FileSystem() fs.mkdir(\\"/a/b/c\\") print(fs.ls(\\"/a/b\\")) # Output: [\'c\'] fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") print(fs.ls(\\"/a/b/c\\")) # Output: [\'d\'] print(fs.readContentFromFile(\\"/a/b/c/d\\")) # Output: \\"hello\\" fs.addContentToFile(\\"/a/b/c/d\\", \\" world\\") print(fs.readContentFromFile(\\"/a/b/c/d\\")) # Output: \\"hello world\\" ``` Explanation - Initially, we create the directory `/a/b/c`. - Listing the contents of `/a/b` returns `[\'c\']` since `c` is the only directory in `/a/b`. - We then add content `\\"hello\\"` to the file `/a/b/c/d`. Listing `/a/b/c` returns `[\'d\']` as `d` is the only file in directory `/a/b/c`. - Reading content from `/a/b/c/d` returns `\\"hello\\"`. - Appending `\\" world\\"` to the file `/a/b/c/d`, reading it again returns `\\"hello world\\"`. Your task is to implement the `FileSystem` class with the methods described to handle the commands effectively.","solution":"class FileSystem: def __init__(self): self.fs = {\'/\': {}} def mkdir(self, path): current = self.fs[\'/\'] parts = path.split(\'/\') for part in parts: if not part: continue if part not in current: current[part] = {} current = current[part] def addContentToFile(self, filePath, content): current = self.fs[\'/\'] parts = filePath.split(\'/\') for part in parts[:-1]: if not part: continue if part not in current: current[part] = {} current = current[part] file_name = parts[-1] if file_name not in current: current[file_name] = \\"\\" current[file_name] += content def ls(self, path): if path == \'/\': return sorted(self.fs[\'/\'].keys()) current = self.fs[\'/\'] parts = path.split(\'/\') for part in parts: if not part: continue if isinstance(current[part], str): return [part] current = current.get(part, {}) return sorted(current.keys()) def readContentFromFile(self, filePath): current = self.fs[\'/\'] parts = filePath.split(\'/\') for part in parts[:-1]: if not part: continue current = current.get(part, {}) return current[parts[-1]]"},{"question":"# Graph Validation: Check if a Graph is a Tree A tree is an undirected graph in which any two vertices are connected by exactly one path. Moreover, a tree has `n` nodes and `n-1` edges. You are provided a graph in the form of an adjacency list, and you need to determine if the given graph is a tree. **Your Task**: - Implement a function `is_tree(graph: Dict[int, List[int]]) -> bool` that checks if the provided graph is a tree. **Input**: - `graph` (Dict[int, List[int]]): A dictionary representing the graph where the key is a node, and the value is a list of nodes that the key node is connected to. **Output**: - Return `True` if the graph is a tree; otherwise, return `False`. **Constraints**: - The number of nodes, `n`, will be between 1 and 1000. - The graph will not contain any self-loops or multiple edges between the same pair of nodes. ```python def is_tree(graph: dict) -> bool: Check if the graph is a tree. Parameters: - graph (dict): The adjacency list of the graph. Returns: - bool: True if the graph is a tree, False otherwise. # Initialize variables n = len(graph) visited = [False] * n parent = [-1] * n # Helper function to perform DFS def dfs(v): stack = [(v, -1)] while stack: node, par = stack.pop() if visited[node]: return False visited[node] = True parent[node] = par for neighbor in graph[node]: if neighbor != par: stack.append((neighbor, node)) return True # Start DFS from the first node if not dfs(0): return False # Check if all nodes were visited if not all(visited): return False # Ensure there are exactly n-1 edges edge_count = sum(len(neighbors) for neighbors in graph.values()) // 2 return edge_count == n - 1 ``` **Example Scenarios**: 1. Given the graph: ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1] } ``` - Calling `is_tree(graph)` should return `True`. 2. Given the graph: ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2] } ``` - Calling `is_tree(graph)` should return `False` because the graph contains a cycle. **Edge cases**: - The graph has only one node and no edges. - The graph has disconnected components. Ensure your solution handles these appropriately.","solution":"def is_tree(graph): Checks if the graph is a tree. Parameters: - graph (dict): The adjacency list of the graph. Returns: - bool: True if the graph is a tree, False otherwise. n = len(graph) if n == 0: return False # Helper function to perform DFS def dfs(node, parent, visited): visited.add(node) for neighbor in graph[node]: if neighbor == parent: continue if neighbor in visited or not dfs(neighbor, node, visited): return False return True # Start DFS from the first node visited = set() start_node = next(iter(graph)) if not dfs(start_node, -1, visited): return False # Check if all nodes are visited if len(visited) != n: return False # Ensure there are exactly n - 1 edges edge_count = sum(len(neighbors) for neighbors in graph.values()) // 2 return edge_count == n - 1"},{"question":"# Question: Employee Salary Hike Calculation You are required to write a set of functions to calculate salary hike based on specific criteria: performance-based hike, tenure-based hike, and bonus adjustment. Each function needs to handle input validations and return the appropriate updated salary. Function 1: `performance_based_hike(current_salary: float, performance_rating: int) -> float` **Calculate salary hike based on performance rating.** - **Input**: - `current_salary` (float): The current salary of the employee. - `performance_rating` (int): The performance rating of the employee ranging from 1 to 5. - **Output**: - `float`: Updated salary after applying the performance-based hike. - **Constraints**: - `current_salary` must be greater than 0. - `performance_rating` must be an integer between 1 and 5, inclusive. - **Hike Percentage Based on Performance Rating**: - Rating 1: No hike - Rating 2: 2% hike - Rating 3: 5% hike - Rating 4: 7% hike - Rating 5: 10% hike Function 2: `tenure_based_hike(current_salary: float, number_of_years: int) -> float` **Calculate salary hike based on the tenure of the employee.** - **Input**: - `current_salary` (float): The current salary of the employee. - `number_of_years` (int): The number of years the employee has worked. - **Output**: - `float`: Updated salary after applying the tenure-based hike. - **Constraints**: - `current_salary` must be greater than 0. - `number_of_years` must be a non-negative integer. - **Hike Percentage Based on Number of Years**: - Less than 1 year: No hike - 1 to 3 years: 3% hike - 4 to 6 years: 5% hike - More than 6 years: 8% hike Function 3: `bonus_adjustment(current_salary: float, bonus_percentage: float) -> float` **Calculate updated salary by applying a bonus percentage.** - **Input**: - `current_salary` (float): The current salary of the employee. - `bonus_percentage` (float): The bonus percentage to be applied. - **Output**: - `float`: Updated salary after adding the bonus. - **Constraints**: - `current_salary` must be greater than 0. - `bonus_percentage` must be non-negative. # Testing & Validation - Include checks for invalid inputs like negative values for salary, ratings, and years worked. - Use various test cases to validate the correctness of your implementation. Example test cases: 1. `performance_based_hike(50000, 4)` should return `53500.0` 2. `tenure_based_hike(50000, 5)` should return `52500.0` 3. `bonus_adjustment(50000, 10)` should return `55000.0` **Note:** You may assume that the hikes and bonuses are cumulative and can be applied sequentially.","solution":"def performance_based_hike(current_salary: float, performance_rating: int) -> float: Calculate salary hike based on performance rating. if current_salary <= 0: raise ValueError(\\"Current salary must be greater than 0\\") if not (1 <= performance_rating <= 5): raise ValueError(\\"Performance rating must be between 1 and 5, inclusive\\") hike_percentage = { 1: 0, 2: 2, 3: 5, 4: 7, 5: 10 } hike = current_salary * (hike_percentage[performance_rating] / 100) return current_salary + hike def tenure_based_hike(current_salary: float, number_of_years: int) -> float: Calculate salary hike based on tenure of the employee. if current_salary <= 0: raise ValueError(\\"Current salary must be greater than 0\\") if number_of_years < 0: raise ValueError(\\"Number of years must be a non-negative integer\\") if number_of_years < 1: hike_percentage = 0 elif 1 <= number_of_years <= 3: hike_percentage = 3 elif 4 <= number_of_years <= 6: hike_percentage = 5 else: # number_of_years > 6 hike_percentage = 8 hike = current_salary * (hike_percentage / 100) return current_salary + hike def bonus_adjustment(current_salary: float, bonus_percentage: float) -> float: Calculate updated salary by applying a bonus percentage. if current_salary <= 0: raise ValueError(\\"Current salary must be greater than 0\\") if bonus_percentage < 0: raise ValueError(\\"Bonus percentage must be non-negative\\") bonus = current_salary * (bonus_percentage / 100) return current_salary + bonus"},{"question":"# Problem Statement You are required to develop a `Queue` data structure using two stacks. Specifically, you need to implement the standard operations of a queue (enqueue, dequeue, front, and is_empty) utilizing the stack operations (push, pop, top). # Task 1. Develop a `Queue` class that internally uses two stacks to manage its elements. 2. Implement the enqueue operation to add elements to the end of the queue. 3. Implement the dequeue operation to remove and return the front element of the queue. 4. Implement the front operation to return the front element of the queue without removing it. 5. Implement the is_empty operation to check if the queue is empty. 6. Ensure all queue operations handle edge cases effectively and perform efficiently. # Constraints - Only use the standard operations of a stack (push, pop, top) within your `Queue` implementation. - Handle integer elements in the queue. # Requirements - Update the `Queue` class to internally manage its elements using two stacks. - Ensure that the dequeue and front operations throw exceptions when called on an empty queue. - Validate functionality with provided sample inputs. # Example Cases Here are some cases demonstrating the expected behavior of your queue: ```python queue = Queue() assert queue.is_empty() == True try: queue.dequeue() except IndexError: print(\\"Exception caught: Dequeue from an empty queue\\") queue.enqueue(1) assert queue.is_empty() == False queue.enqueue(2) queue.enqueue(3) assert queue.front() == 1 assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.dequeue() == 3 try: queue.front() except IndexError: print(\\"Exception caught: Front from an empty queue\\") ``` You need to implement the `Queue` class in the provided code to meet the above requirements. # Expected Function Signatures ```python class Queue(Generic[T]): def __init__(self) -> None: ... def enqueue(self, data: T) -> None: ... def dequeue(self) -> T: ... def front(self) -> T: ... def is_empty(self) -> bool: ... ```","solution":"class Queue: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, data): self.stack1.append(data) def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from an empty queue\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def front(self): if self.is_empty(): raise IndexError(\\"Front from an empty queue\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self): return not (self.stack1 or self.stack2)"},{"question":"# Problem Statement Consider a two-dimensional grid of size `nxn`, where initially, each cell of the grid contains either a \'B\' (for Bomb) or an \'E\' (for Empty). Implement a function that calculates the number of \'B\'s in the path from the upper-left corner of the grid to the bottom-right corner. The path can only move one step at a time to the right or down, i.e., from cell `(i, j)` you can move to either `(i, j+1)` or `(i+1, j)`, and you should explore all possible paths to find the one with the highest number of \'B\'s. # Function Signature ```python def most_bombs(grid: List[List[str]]) -> int: pass ``` # Input - `grid` (List[List[str]]): A 2D grid containing \'B\' and \'E\'. The grid size is `n x n` where (1 leq n leq 10). # Output - `int`: The maximum number of \'B\'s encountered in any valid path from `(0, 0)` to `(n-1, n-1)`. # Constraints - The grid will always be a square with dimensions `nxn`. - The grid will contain only the characters \'B\' and \'E\'. - The grid size (1 leq n leq 10). # Example ```python >>> most_bombs([ ... [\'E\', \'B\', \'E\'], ... [\'E\', \'B\', \'B\'], ... [\'E\', \'E\', \'B\'] ... ]) 4 >>> most_bombs([ ... [\'B\', \'E\'], ... [\'E\', \'B\'] ... ]) 2 ``` # Notes - There may be multiple paths with the maximum number of \'B\'s. The function should return this maximum number. - Considering the constraints on the grid size, a recursive solution is feasible without performance issues. # Implementation Complete the function `most_bombs` with the above constraints and requirements.","solution":"def most_bombs(grid): n = len(grid) # Helper function to calculate maximum bombs on a path using memoization def dfs(x, y, memo): if x == n - 1 and y == n - 1: return 1 if grid[x][y] == \'B\' else 0 if (x, y) in memo: return memo[(x, y)] bombs = 1 if grid[x][y] == \'B\' else 0 max_bombs = 0 if x + 1 < n: max_bombs = max(max_bombs, dfs(x + 1, y, memo)) if y + 1 < n: max_bombs = max(max_bombs, dfs(x, y + 1, memo)) memo[(x, y)] = bombs + max_bombs return memo[(x, y)] memo = {} return dfs(0, 0, memo)"},{"question":"# Coding Assessment Question **Scenario**: As a game developer, you need to generate a leaderboard for a multiplayer online game. Each player has a score, and bonus points may be awarded based on certain milestones achieved during the game. **Task**: Implement a Python function `generate_leaderboard` that computes the final scores for players, sorts them in descending order of their scores, and returns the sorted list of players. Each player may have a bonus score, which should be added to their initial score. **Function Signature**: ```python def generate_leaderboard( players: dict, bonuses: dict ) -> list: Generate a sorted leaderboard based on initial and bonus scores. Parameters: - players (dict): Dictionary with player names as keys and their initial scores as values. - bonuses (dict): Dictionary with player names as keys and their bonus scores as values. Returns: - list: List of tuples, where each tuple contains player name and final score, sorted in descending order of scores. Exceptions: - If any score in `players` or `bonuses` is negative, raise ValueError. - Ensure all player names in `bonuses` are present in `players`. pass ``` **Constraints**: - Both dictionaries (`players` and `bonuses`) should have valid player names as keys and non-negative integers as values. - Each player name in `bonuses` must exist in `players`. **Performance Requirements**: - The function should be efficient with a time complexity of O(N log N), where N is the number of players. **Examples**: ```python >>> players = {\'Alice\': 100, \'Bob\': 150, \'Charlie\': 120} >>> bonuses = {\'Alice\': 20, \'Bob\': 30} >>> generate_leaderboard(players, bonuses) [(\'Bob\', 180), (\'Alice\', 120), (\'Charlie\', 120)] >>> players = {\'Alice\': 200, \'Bob\': 150} >>> bonuses = {\'Alice\': -20, \'Bob\': 30} Traceback (most recent call last): ... ValueError: Scores must be non-negative >>> players = {\'Alice\': 200, \'Bob\': 150} >>> bonuses = {\'Charlie\': 20} Traceback (most recent call last): ... ValueError: All player names in bonuses must be in players ```","solution":"def generate_leaderboard(players: dict, bonuses: dict) -> list: Generate a sorted leaderboard based on initial and bonus scores. Parameters: - players (dict): Dictionary with player names as keys and their initial scores as values. - bonuses (dict): Dictionary with player names as keys and their bonus scores as values. Returns: - list: List of tuples, where each tuple contains player name and final score, sorted in descending order of scores. Exceptions: - If any score in `players` or `bonuses` is negative, raise ValueError. - Ensure all player names in `bonuses` are present in `players`. # Check for negative scores for name, score in players.items(): if score < 0: raise ValueError(\\"Scores must be non-negative\\") for name, score in bonuses.items(): if score < 0: raise ValueError(\\"Scores must be non-negative\\") # Ensure all player names in bonuses are present in players for bonus_player in bonuses.keys(): if bonus_player not in players: raise ValueError(\\"All player names in bonuses must be in players\\") # Create a new dictionary to store final scores final_scores = dict(players) # Add the bonuses to the final scores for name, bonus in bonuses.items(): final_scores[name] += bonus # Sort the players by descending scores and return as a list of tuples sorted_leaderboard = sorted(final_scores.items(), key=lambda x: x[1], reverse=True) return sorted_leaderboard"},{"question":"# Scenario You are developing a system that involves managing the frequency of events. You need to implement an efficient way to find the most frequent element in a list. Given your knowledge of data structures and hashmaps, write a function to achieve this. # Problem Statement Implement a function `most_frequent_element(elements: List[int]) -> int` that takes in a list of integers `elements`. The function should return the element that appears most frequently in the list. If there are multiple elements with the same highest frequency, any one of them can be returned. # Input and Output Formats * The function will receive a list of integers as the input parameter. * The function will return a single integer which is the most frequent element. # Constraints * The length of the list (L) can range from (1) to (10^5). * Each integer in the list can range from (-10^9) to (10^9). # Performance Requirements * The implementation should efficiently handle the input sizes, with an average time complexity of (O(L)). # Example Cases ```python >>> most_frequent_element([1, 3, 1, 3, 2, 1]) 1 >>> most_frequent_element([3, 3, 2, 1, 2, 3]) 3 >>> most_frequent_element([1]) 1 >>> most_frequent_element([-1, -1, -1, 2, 2, 2, 2]) 2 >>> most_frequent_element([1000000000, 999999999, 1000000000]) 1000000000 ``` # Additional Notes * Ensure the function handles large lists within a reasonable time frame. * The solution should use a hashmap (dictionary) to track the frequency of each element efficiently. * Consider edge cases such as a list with only one element or multiple elements with the same frequency.","solution":"from typing import List def most_frequent_element(elements: List[int]) -> int: frequency = {} for element in elements: if element in frequency: frequency[element] += 1 else: frequency[element] = 1 most_frequent = None max_count = 0 for element, count in frequency.items(): if count > max_count: most_frequent = element max_count = count return most_frequent"},{"question":"# Longest Increasing Subsequence with Dynamic Programming You are given a list of integers. Your task is to implement a function that computes the length of the longest strictly increasing subsequence using dynamic programming. Function Signature ```python def longest_increasing_subsequence(nums: list) -> int: pass ``` Input * `nums` (list of int): A list of integers. Output * `int`: The length of the longest strictly increasing subsequence in the list. Constraints * The length of the list nums will be between 1 and 2500. * Each integer in nums will be between -10^4 and 10^4. Example ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 ``` Instructions 1. Implement a dynamic programming approach to solve the problem efficiently. 2. You may use a 1D array to store the lengths of the longest increasing subsequences ending at each index. 3. Ensure the solution runs within a reasonable time complexity, approximately O(n^2). This new question leverages dynamic programming to solve a classic algorithmic problem, ensuring the difficulty, style, length, and topic alignment with the provided sample question on memoized knapsack problem.","solution":"def longest_increasing_subsequence(nums: list) -> int: Computes the length of the longest increasing subsequence in the list nums using dynamic programming. :param nums: List of integers :return: Length of the longest increasing subsequence if not nums: return 0 # Length of the array n = len(nums) # dp[i] will store the length of the longest increasing subsequence that ends with nums[i] dp = [1] * n # Fill the dp array for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence will be the maximum value in dp array return max(dp)"},{"question":"# Scenario You are working on a financial software system that requires accurate and real-time computation of compound interest for various financial products. Your task is to build functions that will calculate compound interest for different scenarios. The system should handle both annual and continuous compounding. # Task 1. **Implement `calculate_annual_compound_interest` function** - Input: - `principal`: The initial amount of money invested or loaned. - `rate`: The annual interest rate (as a decimal, e.g., 0.05 for 5%). - `times`: Number of times the interest is compounded per year. - `years`: The number of years the money is invested or borrowed for. - Output: A float representing the amount of money accumulated after n years, including interest. 2. **Implement `calculate_continuous_compound_interest` function** - Input: - `principal`: The initial amount of money invested or loaned. - `rate`: The annual interest rate (as a decimal, e.g., 0.05 for 5%). - `years`: The number of years the money is invested or borrowed for. - Output: A float representing the amount of money accumulated after n years, including interest. # Requirements - Ensure your implementation matches the given doctest examples. - Use appropriate mathematical formulas for both annual and continuous compounding. - The functions should handle edge cases and invalid inputs robustly. # Function Specifications # `calculate_annual_compound_interest(principal: float, rate: float, times: int, years: int) -> float` - **Input**: A float `principal`, float `rate`, int `times`, and int `years`. - **Output**: A float. # `calculate_continuous_compound_interest(principal: float, rate: float, years: int) -> float` - **Input**: A float `principal`, float `rate`, and int `years`. - **Output**: A float. # Example Usage ```python # Annual Compounding Example principal = 1000.00 rate = 0.05 times = 4 years = 10 amount = calculate_annual_compound_interest(principal, rate, times, years) print(amount) # Approximately 1647.009 # Continuous Compounding Example principal = 1000.00 rate = 0.05 years = 10 amount = calculate_continuous_compound_interest(principal, rate, years) print(amount) # Approximately 1648.721 ``` # Additional Considerations - Adhere to financial rounding rules where applicable. - Aim for optimized calculations. - Ensure that the interest rate and principal values are non-negative, raising appropriate errors for invalid inputs.","solution":"import math def calculate_annual_compound_interest(principal, rate, times, years): Calculate the amount of money accumulated after n years, including interest, with annual compounding. Args: principal (float): The initial amount of money invested or loaned. rate (float): The annual interest rate (as a decimal, e.g., 0.05 for 5%). times (int): Number of times the interest is compounded per year. years (int): The number of years the money is invested or borrowed for. Returns: float: The amount of money accumulated after n years, including interest. if principal < 0 or rate < 0 or times <= 0 or years < 0: raise ValueError(\\"All inputs must be non-negative and \'times\' must be greater than 0.\\") return principal * (1 + rate / times) ** (times * years) def calculate_continuous_compound_interest(principal, rate, years): Calculate the amount of money accumulated after n years, including interest, with continuous compounding. Args: principal (float): The initial amount of money invested or loaned. rate (float): The annual interest rate (as a decimal, e.g., 0.05 for 5%). years (int): The number of years the money is invested or borrowed for. Returns: float: The amount of money accumulated after n years, including interest. if principal < 0 or rate < 0 or years < 0: raise ValueError(\\"All inputs must be non-negative.\\") return principal * math.exp(rate * years)"},{"question":"# Question You are required to implement a function that calculates the sum of all elements in a rotating 2D grid after `k` rotations. # Objective Write a function `rotate_and_sum(matrix: [[int]], k: int) -> int` that accepts a 2D grid of integers and an integer `k`, and returns the sum of all elements in the grid after rotating the grid `k` times. Each rotation performs the following steps: 1. Remove the outermost layer of the grid. 2. Shift all remaining elements inward up, left, down, right in that order. 3. Put the removed layer back starting from the next position after the shift. For example, if the outermost layer in a grid is `[a, b, c, d]`, it becomes `[b, c, d, a]` after one rotation. # Specifications - **Input**: - `matrix` ([[int]]): A 2D list where each sublist represents a row in the grid. The number of rows and columns will be between 1 and 100 inclusive. - `k` (int): A non-negative integer where 1 ≤ k ≤ 10^6. - **Output**: - The sum of all elements in the grid after performing `k` rotations. # Constraints - Your solution should be efficient given the constraints, particularly the high value of `k`. - Handle edge cases properly. # Example ```python >>> rotate_and_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) 45 >>> rotate_and_sum([[1, 2], [3, 4]], 2) 10 >>> rotate_and_sum([[1]], 5) 1 ``` # Notes - Implement the function following the above description. - The input grid will always be rectangular, i.e., all rows have the same length.","solution":"def rotate_and_sum(matrix, k): Rotates the 2D grid k times and returns the sum of all elements. Parameters: matrix ([[int]]): 2D list where each sublist represents a row in the grid. k (int): Non-negative integer representing the number of rotations. Returns: int: Sum of all elements in the grid after k rotations. # Calculate the number of rotations needed in effective terms k = k % 4 # Since rotating the outer layer 4 times brings it back to original def rotate(): Rotates the outermost layer of the 2D grid once in place. rows, cols = len(matrix), len(matrix[0]) if rows <= 1 or cols <= 1: return # No effective rotation possible for single-row or single-column grids # Temporary storage for the top row temp = matrix[0][:] # Move left column up for i in range(rows - 1): matrix[i][0] = matrix[i+1][0] # Move bottom row left for j in range(cols - 1): matrix[rows-1][j] = matrix[rows-1][j+1] # Move right column down for i in range(rows - 1, 0, -1): matrix[i][cols-1] = matrix[i-1][cols-1] # Move top row right for j in range(cols - 1, 0, -1): matrix[0][j] = matrix[0][j-1] # Complete the cycle matrix[0][0] = temp[0] for _ in range(k): rotate() return sum(sum(row) for row in matrix)"},{"question":"# Problem Statement Write a function that takes a list of integers and returns the count of unique integers present in the list. The output should provide the count of distinct numbers ignoring their frequency of appearance. # Function Signature ```python def count_unique_numbers(numbers: List[int]) -> int: pass ``` # Input/Output Requirements * **Input**: A single argument: - `numbers` (List[int]): A list of integers, where each integer can be positive, negative, or zero. * **Output**: - Returns an integer representing the count of unique values in the list. # Constraints - The length of the list will be at most 10^5. - Each integer in the list will be within the range ([-10^9, 10^9]). # Performance Requirements - The function should have a time complexity of O(n), where n is the length of the list. - The space complexity should be O(n) to accommodate the storage of unique integers. # Scenario Imagine you are writing a software module for processing transaction data from an online store. As part of the analytics, you need to determine the number of unique customer IDs from a large list representing all transactions made in a given period. # Example ```python >>> count_unique_numbers([1, 2, 2, 3, 4, 4, 5]) 5 >>> count_unique_numbers([10, 10, 10, -1, -1, 0]) 3 >>> count_unique_numbers([]) 0 ``` # Solution Requirements - Implement the `count_unique_numbers` function following the above specifications. - Ensure the solution handles large inputs efficiently by leveraging appropriate data structures. - Focus on simplicity and clarity in your implementation.","solution":"from typing import List def count_unique_numbers(numbers: List[int]) -> int: Returns the count of unique integers in the given list. Parameters: numbers (List[int]): A list of integers where each integer can be positive, negative, or zero. Returns: int: The count of unique values in the list. unique_numbers = set(numbers) return len(unique_numbers)"},{"question":"# Interval Overlap Check You have been tasked with implementing a class that can store a set of numeric intervals and provide functionality to check if a given interval overlaps with any of the stored intervals. # Problem Description Implement the `IntervalSet` class with methods to add intervals to the set and to check for overlap with a given interval. # Class Signature ```python class IntervalSet: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: Adds an interval [start, end) to the set. pass def has_overlap(self, start: int, end: int) -> bool: Checks if the interval [start, end) overlaps with any interval in the set. pass ``` # Requirements: 1. Intervals are represented as half-open ranges [start, end). 2. Ensure no duplicate intervals are stored. 3. The `add_interval` method should add the interval to the set. 4. The `has_overlap` method should return `True` if any stored interval overlaps with the given interval. 5. Two intervals [a, b) and [c, d) are considered overlapping if a < d and c < b. # Constraints: 1. You can assume the start will always be less than the end for any interval. 2. The methods should handle intervals with large ranges efficiently. 3. There can be up to 10,000 intervals stored at any time. # Example Usage: ```python interval_set = IntervalSet() interval_set.add_interval(1, 5) interval_set.add_interval(10, 15) interval_set.add_interval(20, 25) print(interval_set.has_overlap(3, 7)) # Output: True print(interval_set.has_overlap(15, 20)) # Output: False print(interval_set.has_overlap(20, 22)) # Output: True print(interval_set.has_overlap(5, 10)) # Output: False ``` # Additional Information: - The intervals provided to the `add_interval` and `has_overlap` methods are guaranteed to have non-negative integer boundaries. - Focus on optimizing both the add and check operations for large sets of intervals.","solution":"class IntervalSet: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: Adds an interval [start, end) to the set. # Check for duplicates if any(s == start and e == end for s, e in self.intervals): return self.intervals.append((start, end)) def has_overlap(self, start: int, end: int) -> bool: Checks if the interval [start, end) overlaps with any interval in the set. for s, e in self.intervals: if start < e and s < end: return True return False"},{"question":"# Question: Implement Advanced Binary Tree Operations Context: Binary Trees are fundamental data structures in computer science. They are used in various applications such as expression parsing, searching, and as part of more complex data structures like binary search trees. In this question, you will enhance the functionality of a given `BinaryTree` class with advanced operations. Task: Extend the `BinaryTree` class to include additional operations and optimizations outlined below. Requirements: 1. **Find Level of Node**: Implement a method `find_level(key: int) -> int` that returns the level of a node with a given key in the binary tree. - The root of the tree is at level 0, its children are at level 1, and so on. - If the node is not found, return -1. 2. **Diameter of Tree**: Implement a method `diameter() -> int` that calculates the diameter of the binary tree. - The diameter of a binary tree is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. 3. **Zigzag Traversal**: Implement a method `zigzag_traversal() -> List[int]` that performs a zigzag level order traversal of the binary tree. - In a zigzag traversal, the nodes at each level are alternately traversed from left to right and right to left. Implementations: - Extend the `BinaryTree` class to include your new methods. - Add comprehensive unit tests to validate the functionality of the new methods. - Ensure the existing functionality and new functionality do not interfere. Constraints: - Assume the binary tree does not contain duplicate keys. - Each method should handle edge cases gracefully including empty trees. Below is the starter skeleton for your updated class: ```python # Extend your BinaryTree class with the following methods. class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self, root=None): self.root = root def find_level(self, key: int) -> int: Find the level of a node with the given key. Args: key: The key of the node to find the level. Returns: The level of the node if found, else -1. Example: >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> tree = BinaryTree(root) >>> tree.find_level(3) 1 pass def diameter(self) -> int: Calculate the diameter of the binary tree. Returns: The diameter of the binary tree. Example: >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.left.left = Node(4) >>> root.left.right = Node(5) >>> tree = BinaryTree(root) >>> tree.diameter() 3 pass def zigzag_traversal(self) -> List[int]: Perform a zigzag level order traversal of the binary tree. Returns: A list containing the keys in zigzag order. Example: >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.left.left = Node(4) >>> root.left.right = Node(5) >>> root.right.left = Node(6) >>> root.right.right = Node(7) >>> tree = BinaryTree(root) >>> tree.zigzag_traversal() [1, 3, 2, 4, 5, 6, 7] pass ``` Input and Output Format: - The input format for the `find_level` method is an integer key. - The `diameter` method does not require any inputs and returns an integer. - The `zigzag_traversal` method does not require any inputs and returns a list of integers. Constraints: - Your solution should maintain the computational efficiency of the tree operations. - The extended functionalities should be demonstrable with appropriate unit tests or doctests. Good luck!","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self, root=None): self.root = root def find_level(self, key: int) -> int: Find the level of a node with the given key. Args: key: The key of the node to find the level. Returns: The level of the node if found, else -1. def get_level(node, key, level): if node is None: return -1 if node.val == key: return level left_level = get_level(node.left, key, level + 1) if left_level != -1: return left_level return get_level(node.right, key, level + 1) return get_level(self.root, key, 0) def diameter(self) -> int: Calculate the diameter of the binary tree. Returns: The diameter of the binary tree. def diameter_util(node): if not node: return 0, 0 left_height, left_diameter = diameter_util(node.left) right_height, right_diameter = diameter_util(node.right) current_height = max(left_height, right_height) + 1 current_diameter = max(left_height + right_height, max(left_diameter, right_diameter)) return current_height, current_diameter return diameter_util(self.root)[1] def zigzag_traversal(self) -> list: Perform a zigzag level order traversal of the binary tree. Returns: A list containing the keys in zigzag order. if not self.root: return [] result = [] current_level = [self.root] left_to_right = True while current_level: level_values = [] next_level = [] for node in current_level: if left_to_right: level_values.append(node.val) else: level_values.insert(0, node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) result.extend(level_values) current_level = next_level left_to_right = not left_to_right return result"},{"question":"Problem Statement As a software engineer at a company that deals with large-scale data, you are asked to implement a function that will perform matrix multiplication on very large matrices using a divide-and-conquer approach. The goal is to split the matrices into smaller sub-matrices, multiply them, and then combine the results. # Function to Implement ```python def divide_and_conquer_matrix_mult(A, B): Perform matrix multiplication using the divide and conquer method. @param A: A two-dimensional numpy array representing matrix A. @param B: A two-dimensional numpy array representing matrix B. @return: A two-dimensional numpy array representing the product of matrices A and B. If the matrices A and B are not square or their dimensions do not match, return None. # Your code here pass ``` # Input and Output Formats Input - `A`: A two-dimensional numpy array representing matrix A. - `B`: A two-dimensional numpy array representing matrix B. Output - A two-dimensional numpy array representing the product of matrices A and B. - If matrices A and B are not square or their dimensions do not match such that they cannot be multiplied, return `None`. # Constraints - Matrices `A` and `B` should be square matrices of dimensions (2^k times 2^k) where (k) is a non-negative integer. - The size of the matrices will not exceed (1024 times 1024). # Example ```python # Example Input: import numpy as np A = np.array([[1, 2], [3, 4]]) B = np.array([[5, 6], [7, 8]]) # Example Output: # result = divide_and_conquer_matrix_mult(A, B) # The resultant matrix should be: # array([[19, 22], # [43, 50]]) ``` # Notes - The implementation should split the matrices into smaller sub-matrices, multiply them recursively, and then combine the results. - Ensure to handle the base case where the matrices are of size (1 times 1). - You can assume that the input matrices will always be square matrices of size (2^k times 2^k). - The function should handle edge cases, such as when matrices A and B are not of the same dimensions or when they are not square matrices. In such cases, the function should return `None`.","solution":"import numpy as np def divide_and_conquer_matrix_mult(A, B): Perform matrix multiplication using the divide and conquer method. @param A: A two-dimensional numpy array representing matrix A. @param B: A two-dimensional numpy array representing matrix B. @return: A two-dimensional numpy array representing the product of matrices A and B. If the matrices A and B are not square or their dimensions do not match, return None. if A.shape != B.shape or len(A.shape) != 2 or A.shape[0] != A.shape[1]: return None n = A.shape[0] if n == 1: return A * B # Base case: multiply 1x1 matrices directly mid = n // 2 A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:] B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:] C11 = divide_and_conquer_matrix_mult(A11, B11) + divide_and_conquer_matrix_mult(A12, B21) C12 = divide_and_conquer_matrix_mult(A11, B12) + divide_and_conquer_matrix_mult(A12, B22) C21 = divide_and_conquer_matrix_mult(A21, B11) + divide_and_conquer_matrix_mult(A22, B21) C22 = divide_and_conquer_matrix_mult(A21, B12) + divide_and_conquer_matrix_mult(A22, B22) C = np.zeros((n, n), dtype=A.dtype) C[:mid, :mid] = C11 C[:mid, mid:] = C12 C[mid:, :mid] = C21 C[mid:, mid:] = C22 return C"},{"question":"Write a function that takes a string representing a mathematical expression involving addition and multiplication of integers (positive or negative) and evaluates the expression following the standard order of operations (PEMDAS/BODMAS rules). # Function Signature ```python def evaluate_expression(expression: str) -> int: ``` # Input * A string `expression` containing a mathematical expression involving integers and the operators `+`, `-`, and `*`. # Output * An integer representing the result of evaluating the expression. # Constraints * The input string will only contain digits (0-9), spaces, and the operators `+`, `-`, `*`. * The expression will be valid and will not contain any division or parentheses. * Ensure your function handles all possible valid inputs efficiently. # Examples 1. **Input**: `evaluate_expression(\\"3 + 2 * 2\\")` **Output**: `7` 2. **Input**: `evaluate_expression(\\"-2 * -3 + 4\\")` **Output**: `10` 3. **Input**: `evaluate_expression(\\"2 + 3 * -2\\")` **Output**: `-4` 4. **Input**: `evaluate_expression(\\"1 + 1 + 1 * 1\\")` **Output**: `3` # Notes * Your function should handle spaces gracefully and ignore them. * The expression can include both positive and negative integers. * Pay attention to operator precedence where multiplication should be performed before addition and subtraction. * You do not need to handle division or parentheses as they are not part of the allowed operations.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression involving addition, subtraction, and multiplication following the standard order of operations (PEMDAS/BODMAS rule). tokens = expression.split() # We first handle the multiplication result_list = [] skip = False for i in range(len(tokens)): if skip: skip = False continue if tokens[i] == \'*\': prev = result_list.pop() next_value = int(tokens[i + 1]) result_list.append(prev * next_value) skip = True elif tokens[i] in \'+-\': result_list.append(tokens[i]) else: # It\'s a number result_list.append(int(tokens[i])) # Now we handle addition and subtraction result = result_list[0] i = 1 while i < len(result_list): operator = result_list[i] if operator == \'+\': result += result_list[i + 1] elif operator == \'-\': result -= result_list[i + 1] i += 2 return result"},{"question":"# Reverse Words in a Sentence Problem Statement: Your task is to implement a function that reverses the words in a given sentence. The words in the sentence are separated by spaces, and the sentence may contain leading or trailing whitespace. Input: - A single string `sentence` (length 0 <= len(sentence) <= 10^6). Output: - Return a new string with the words in reversed order while maintaining the original spacing. Example: ```python reverse_words(\\" Hello World \\") # Output: \\"World Hello\\" reverse_words(\\"The quick brown fox\\") # Output: \\"fox brown quick The\\" reverse_words(\\" a b \\") # Output: \\"b a\\" ``` Constraints: - Ignore multiple spaces between words (reduce them to a single space in the final output). - Consider edge cases where the sentence might be empty or consist of only spaces. Implementation Requirements: - Avoid using any built-in functions that directly perform the task (like `split` and `join`) to showcase your algorithmic approach. Starter Code: ```python def reverse_words(sentence: str) -> str: Reverses the words in a given sentence maintaining the original spacing. :param sentence: str: the input sentence :return: str: new sentence with reversed words words = [] length = len(sentence) i = 0 # Traverse the sentence from the start, extracting words while i < length: while i < length and sentence[i] == \' \': i += 1 if i >= length: break word_start = i while i < length and sentence[i] != \' \': i += 1 words.append(sentence[word_start:i]) # Reverse the list of words reversed_sentence = words[::-1] # Join words with single space reversed_sentence = \' \'.join(reversed_sentence) return reversed_sentence # Example usage: if __name__ == \\"__main__\\": sentence = input(\\"Enter sentence: \\").strip() result = reverse_words(sentence) print(f\\"Reversed sentence: \'{result}\'\\") ```","solution":"def reverse_words(sentence: str) -> str: Reverses the words in a given sentence maintaining the original spacing. :param sentence: str: the input sentence :return: str: new sentence with reversed words words = [] length = len(sentence) i = 0 # Traverse the sentence from the start, extracting words while i < length: # Skip spaces while i < length and sentence[i] == \' \': i += 1 if i >= length: break # Find the start of the word word_start = i while i < length and sentence[i] != \' \': i += 1 # Append word to the list words.append(sentence[word_start:i]) # Reverse the list of words reversed_sentence = words[::-1] # Join words with single space reversed_sentence = \' \'.join(reversed_sentence) return reversed_sentence"},{"question":"# Problem Statement Write a function `next_permutation` that takes a list of integers and rearranges them into the lexicographically next greater permutation of numbers. If no such permutation is possible, it rearranges it in the lowest possible order (i.e., sorted in ascending order). The function should perform this operation in-place and use only constant extra memory. # Input * A list of integers, e.g., `[1, 2, 3]`. # Output * The list rearranged to its next permutation, e.g., `[1, 3, 2]`. # Constraints 1. The input list will have at most `10^4` elements. 2. The algorithm should have a time complexity of O(n) and a space complexity of O(1). # Examples ```python >>> lst = [1, 2, 3] >>> next_permutation(lst) >>> lst [1, 3, 2] >>> lst = [3, 2, 1] >>> next_permutation(lst) >>> lst [1, 2, 3] >>> lst = [1, 1, 5] >>> next_permutation(lst) >>> lst [1, 5, 1] ``` # Notes - The function should modify the input list in place and not return a new list. - Consider edge cases where the list might be in complete descending order, where you should rearrange it to ascending order. # Instructions Implement the function `next_permutation` to solve the specified problem: ```python def next_permutation(lst: list) -> None: Modify the given list to its next permutation in lexicographical order. If no such permutation is possible, rearrange it to the lowest possible order. # Your code here ```","solution":"def next_permutation(lst: list) -> None: Modify the given list to its next permutation in lexicographical order. If no such permutation is possible, rearrange it to the lowest possible order. n = len(lst) if n <= 1: return # Step 1: Find the largest index k such that lst[k] < lst[k + 1] k = n - 2 while k >= 0 and lst[k] >= lst[k + 1]: k -= 1 if k == -1: # The list is in descending order. Reverse it to get the smallest arrangement. lst.reverse() else: # Step 2: Find the largest index l greater than k such that lst[k] < lst[l] l = n - 1 while l > k and lst[l] <= lst[k]: l -= 1 # Step 3: Swap lst[k] and lst[l] lst[k], lst[l] = lst[l], lst[k] # Step 4: Reverse the sequence from lst[k + 1] to the end lst[k + 1:] = reversed(lst[k + 1:])"},{"question":"# Sorting Custom Objects You are tasked with implementing a function that sorts a list of custom objects based on multiple attributes. Each object in the list is an instance of the `Person` class, which has the attributes `name` (a string), `age` (an integer), and `height` (a float representing height in meters). # Requirements 1. Provide a method `sort_people(people: list[Person], primary_key: str, secondary_key: str, reverse: bool) -> list[Person]` that sorts the list of `Person` objects. 2. `people`: A list of `Person` objects to be sorted. 3. `primary_key`: The primary attribute for sorting, either \'name\', \'age\', or \'height\'. 4. `secondary_key`: The secondary attribute for sorting, used to break ties when values of the primary key are equal. 5. `reverse`: A boolean that specifies whether to sort in ascending (False) or descending (True) order. # Constraints 1. The `Person` class is defined as follows: ```python class Person: def __init__(self, name: str, age: int, height: float): self.name = name self.age = age self.height = height ``` 2. All attributes for sorting will contain valid and non-null values. 3. The length of the `people` list can be between 1 and 1000. # Example ```python people = [ Person(\\"Alice\\", 30, 1.65), Person(\\"Bob\\", 25, 1.72), Person(\\"Charlie\\", 30, 1.75), Person(\\"Diana\\", 25, 1.68) ] sorted_people = sort_people(people, \\"age\\", \\"height\\", False) # This should sort by age (primary) and then by height (secondary) in ascending order for person in sorted_people: print(person.name, person.age, person.height) # Example Output: # Bob 25 1.72 # Diana 25 1.68 # Alice 30 1.65 # Charlie 30 1.75 ``` **Hint**: Leverage Python\'s sorting capabilities, such as the `sorted` function with a custom key. Consider using tuples for the sorting key to handle multiple attributes.","solution":"class Person: def __init__(self, name: str, age: int, height: float): self.name = name self.age = age self.height = height def sort_people(people, primary_key, secondary_key, reverse): Sorts a list of Person objects based on primary and secondary attributes. :param people: List[Person] - The list of Person objects to be sorted. :param primary_key: str - The primary attribute for sorting (name, age, or height). :param secondary_key: str - The secondary attribute for sorting to break ties. :param reverse: bool - Whether to sort in descending order. :return: List[Person] - The sorted list of Person objects. return sorted(people, key=lambda person: ( getattr(person, primary_key), getattr(person, secondary_key) ), reverse=reverse)"},{"question":"# Context: In your new role as a software engineer at a logistics company, you are tasked with creating a function that assists in packaging items that are grouped by weight classes. The function will ensure that items are evenly distributed across predefined weight classes. # Problem Statement: Write a Python function `distribute_packages(weights: List[int], capacity: int) -> Dict[int, List[int]]` that distributes a list of item weights into weight classes without exceeding each class\'s capacity. Each weight class is a bucket with a specific capacity, and no bucket should exceed that capacity. # Inputs: - `weights (List[int])`: A list of integers representing the weights of various items. - `capacity (int)`: The maximum capacity for each weight class (bucket). # Outputs: - A dictionary where: * Keys are integers representing the weight class index (starting from 0). * Values are lists of integers representing the item weights assigned to each weight class. # Constraints: - `1 <= len(weights) <= 1000` - `1 <= weights[i] <= capacity` - `1 <= capacity <= 10^6` # Example: ```python def distribute_packages(weights: List[int], capacity: int) -> Dict[int, List[int]]: pass # An example of the function in use: weights = [5, 8, 3, 12, 7, 9, 4] capacity = 15 print(distribute_packages(weights, capacity)) # Possible Output: {0: [5, 8], 1: [3, 12], 2: [7, 9], 3: [4]} weights = [1, 1, 1, 1, 1, 1, 1, 1] capacity = 3 print(distribute_packages(weights, capacity)) # Possible Output: {0: [1, 1, 1], 1: [1, 1, 1], 2: [1, 1] } ``` # Notes: - Ensure that each weight class\'s total weight does not exceed the given capacity. - There can be multiple valid distributions; any valid output that meets the constraints is acceptable. - Consider edge cases such as a single item exceeding the weight class capacity or the exact fitting of classes.","solution":"from typing import List, Dict def distribute_packages(weights: List[int], capacity: int) -> Dict[int, List[int]]: Distribute item weights into buckets without exceeding bucket capacity. buckets = {} # Dictionary to store items in each bucket current_bucket = 0 current_weight = 0 for weight in weights: if current_weight + weight <= capacity: if current_bucket in buckets: buckets[current_bucket].append(weight) else: buckets[current_bucket] = [weight] current_weight += weight else: current_bucket += 1 buckets[current_bucket] = [weight] current_weight = weight return buckets"},{"question":"# Problem: Implementing Large Fibonacci Sequence Efficiently Given a positive integer `n`, write a function `fibonacci(n: int) -> int` that efficiently computes the `n`-th Fibonacci number. The function should use an optimal approach to handle large values of `n`, especially for `n` up to 10^6. **Input**: * A single integer `n` where `0 <= n <= 10^6`. **Output**: * The function should return the `n`-th Fibonacci number. **Function Signature**: ```python def fibonacci(n: int) -> int: pass ``` # Constraints: 1. If `n` is not a non-negative integer, the function should raise a `ValueError` with the message \\"Input must be a non-negative integer\\". 2. If `n` is not an integer type, the function should raise a `TypeError` with the message \\"Input value of [number=n] must be an integer\\". # Example: ```python >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040 ``` # Notes: * The Fibonacci sequence is defined as F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n >= 2. * Optimize the implementation using matrix exponentiation or dynamic programming to handle large `n` efficiently. * Make sure to handle edge cases such as `n` being 0 or very large.","solution":"def fibonacci(n: int) -> int: if not isinstance(n, int): raise TypeError(f\\"Input value of [number={n}] must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 MOD = 10**9 + 7 # Often used to prevent overflow for large Fibonacci numbers def matrix_mult(A, B): return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % MOD, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % MOD], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % MOD, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % MOD] ] def matrix_pow(M, power): result = [[1, 0], [0, 1]] base = M while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n-1) return result_matrix[0][0] # Example usage: # print(fibonacci(10)) # Output: 55 # print(fibonacci(20)) # Output: 6765"},{"question":"# Sorting Employee Records by Salary Context: You are creating a human resources application that handles employee records. A common requirement is to sort employee data based on their salaries to generate payroll reports. Problem Statement: Write a function `sort_employees_by_salary(employee_records: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]` that accepts a list of employee records, where each record is a dictionary containing `name` (a string), `age` (an integer), and `salary` (an integer). The function should return a new list of employee records sorted in descending order by their salaries. If two employees have the same salary, they should be sorted alphabetically by their names. Function Signature: ```python def sort_employees_by_salary(employee_records: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: # Your code here ``` Expected Input and Output: * **Input**: A list of dictionaries, where each dictionary contains the keys `name`, `age`, and `salary`. For example: ```python [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 60000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 70000} ] ``` * **Output**: A list of dictionaries sorted by salary in descending order. For example: ```python [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 60000} ] ``` Constraints: * Each employee record will have valid `name`, `age`, and `salary` fields. * There will be no more than 10,000 employee records. * Employee names are unique strings consisting of alphabetic characters only. * Salaries are non-negative integers. * Age is a positive integer. Performance Requirements: The function should efficiently handle sorting up to 10,000 employee records. Example: ```python # Example usage employee_records = [ {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"salary\\": 80000}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 60000} ] sorted_records = sort_employees_by_salary(employee_records) print(sorted_records) # Expected Output [ {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"salary\\": 80000}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 60000} ] ``` Test Cases: Test your code with the following scenarios: * A list with varied salaries. * A list where multiple employees have the same salary. * An empty list. * A list with a single employee record.","solution":"from typing import List, Dict, Union def sort_employees_by_salary(employee_records: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: Returns a list of employee records sorted by salary in descending order. If two salaries are the same, records are sorted alphabetically by name. return sorted(employee_records, key=lambda x: (-x[\'salary\'], x[\'name\']))"},{"question":"# Problem Statement Given a binary tree, implement a function `is_symmetric` to determine if it is a mirror of itself (i.e., symmetric around its center). # Function Signature ```python def is_symmetric(root: TreeNode) -> bool: pass ``` # Input - `root`: The root node of a binary tree. A `TreeNode` is represented as a class with the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - Returns `True` if the tree is symmetric, otherwise `False`. # Constraints - The number of nodes in the tree is in the range `[0, 1000]`. - Node values are integers in the range `[-100, 100]`. # Example ```python # Example 1 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.left.right = TreeNode(4) root.right.left = TreeNode(4) root.right.right = TreeNode(3) print(is_symmetric(root)) # Output: True # Example 2 root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(2) root2.left.right = TreeNode(3) root2.right.right = TreeNode(3) print(is_symmetric(root2)) # Output: False # Example 3 root3 = None print(is_symmetric(root3)) # Output: True ``` # Requirements - Implement an efficient solution that handles the symmetry check recursively. - Ensure that the solution handles edge cases, such as empty trees or single-node trees. - Address invalid inputs by raising appropriate exceptions with clear error messages.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root: TreeNode) -> bool: if not root: return True def is_mirror(t1: TreeNode, t2: TreeNode) -> bool: if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) return is_mirror(root.left, root.right)"},{"question":"# Coding Assessment Question Context You are tasked with implementing a function that effectively manipulates and queries data from a collection of numerical values. The focus is on finding specific properties of subarrays within the collection. Problem Statement Given an array of integers, write a function `max_subarray_sum` that calculates the maximum sum of any contiguous subarray within the array. This problem is a fundamental example of dynamic programming. Function Signature ```python def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray in the provided array of integers. Args: nums : List[int] : a list of integers, where at least one integer is present. Returns: int: The maximum sum of any contiguous subarray. pass ``` Constraints - The input list `nums` will have at least one element and no more than ( 10^5 ) elements. - Each element in `nums` will be an integer where ( -10^5 le text{nums[i]} le 10^5 ). - The function should operate efficiently with linear ( O(n) ) time complexity. Examples ```python # Example 1 print(max_subarray_sum([1, -3, 2, 1, -1])) # Output: 3 # Example 2 print(max_subarray_sum([5, 4, -1, 7, 8])) # Output: 23 # Example 3 print(max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3])) # Output: 7 ``` **Hint**: Consider using Kadane\'s algorithm to efficiently find the maximum sum of a contiguous subarray.","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray in the provided array of integers. Args: nums : List[int] : a list of integers, where at least one integer is present. Returns: int: The maximum sum of any contiguous subarray. current_max = global_max = nums[0] for num in nums[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"# Question: Calculating the Length of the Longest Binary Gap **Context**: In binary representation, a binary gap is defined as the maximal sequence of consecutive zeros that is surrounded by ones at both ends. For example, binary representation of the number 529 is 1000010001, which contains a binary gap of length 4 and another of length 3. **Task**: Write a Python function `longest_binary_gap(N: int) -> int` that returns the length of the longest binary gap of the given integer `N`. If there are no binary gaps, the function should return 0. # Input * An integer `N` representing the input number (1 ≤ N ≤ 2,147,483,647). # Output * An integer representing the length of the longest binary gap. # Constraints * The input number will always be a positive integer. * The result should be computed efficiently in terms of both time and space complexity. # Example ```python # Given N = 1041 # Binary representation of 1041 is 10000010001 # The longest binary gap is of length 5 print(longest_binary_gap(1041)) # Output: 5 ``` # Implementation Details 1. Convert the input number `N` to its binary representation. 2. Traverse the binary string to find sequences of zeros that are bounded by \'1\' on both sides. 3. Track the length of the longest sequence of zeros and return the length of this sequence.","solution":"def longest_binary_gap(N: int) -> int: Returns the length of the longest binary gap of the given integer N. # Convert the number to binary and strip the \'0b\' prefix binary_representation = bin(N)[2:] # Split the binary representation by \'1\' to find gaps gaps = binary_representation.strip(\'0\').split(\'1\') # Length of each gap will be the count of zeros in the split parts gap_lengths = [len(gap) for gap in gaps] # Return the length of the longest gap, or 0 if no gaps were found return max(gap_lengths, default=0)"},{"question":"# Graph Algorithm Optimization You are tasked with optimizing the delivery routes in a logistics network. The network of cities is represented as a weighted directed graph, where nodes represent cities and edges represent direct routes with associated travel times. The goal is to find the shortest path from the main warehouse in City 0 to all other cities and return the total travel times. Write a function named `shortest_delivery_routes` that implements Dijkstra\'s algorithm to solve this problem. # Function Signature ```python def shortest_delivery_routes(num_cities: int, routes: List[Tuple[int, int, int]]) -> List[int]: Calculates the shortest delivery route times from the main warehouse (City 0) to all other cities using Dijkstra\'s algorithm. Parameters: - num_cities (int): The number of cities in the logistics network. - routes (List[Tuple[int, int, int]]): A list of tuples representing the routes in the network, where each tuple (u, v, w) indicates a direct route from city u to city v with travel time w. Returns: - List[int]: A list where the ith element represents the shortest travel time from City 0 to City i. If a city is not reachable, the travel time should be float(\'inf\'). ``` # Requirements 1. Implement Dijkstra\'s algorithm to find the shortest paths from City 0 to all other cities. 2. The function should handle up to 1000 cities and 10000 routes efficiently. 3. If a city is not reachable from City 0, the travel time should be `float(\'inf\')`. 4. Use a priority queue to manage the cities to process in Dijkstra\'s algorithm. 5. Ensure the function handles edge cases such as invalid routes and isolated cities. # Constraints - The number of cities (`num_cities`) will be between 1 and 1000. - The number of routes (`routes`) will be between 0 and 10000. - The travel time (`w`) for each route will be a non-negative integer. # Example ```python routes = [ (0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 1), (2, 3, 5) ] result = shortest_delivery_routes(4, routes) print(result) # Expected output: [0, 3, 1, 4] ```","solution":"from typing import List, Tuple import heapq def shortest_delivery_routes(num_cities: int, routes: List[Tuple[int, int, int]]) -> List[int]: Calculates the shortest delivery route times from the main warehouse (City 0) to all other cities using Dijkstra\'s algorithm. Parameters: - num_cities (int): The number of cities in the logistics network. - routes (List[Tuple[int, int, int]]): A list of tuples representing the routes in the network, where each tuple (u, v, w) indicates a direct route from city u to city v with travel time w. Returns: - List[int]: A list where the ith element represents the shortest travel time from City 0 to City i. If a city is not reachable, the travel time should be float(\'inf\'). graph = {i: [] for i in range(num_cities)} for u, v, w in routes: graph[u].append((v, w)) distances = {i: float(\'inf\') for i in range(num_cities)} distances[0] = 0 priority_queue = [(0, 0)] # (distance, city) while priority_queue: current_distance, current_city = heapq.heappop(priority_queue) if current_distance > distances[current_city]: continue for neighbor, weight in graph[current_city]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [distances[i] for i in range(num_cities)] return result"},{"question":"# Problem Description Write a function `find_missing_number` that identifies the missing number from a given sequence of integers from 1 to ( n ), where ( n ) is the length of the sequence plus one. # Function Signature ```python def find_missing_number(sequence: List[int]) -> int: ``` # Input * `sequence` (List[int]): A list of integers representing a sequence from 1 to ( n ) with exactly one number missing. ( 1 leq len(sequence) leq 10^6 ). # Output * (int): The missing number in the sequence. # Constraints * Each number in the sequence is unique and within the range from 1 to ( n ). # Examples ```python >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 3, 5]) 4 >>> find_missing_number([1]) 2 ``` # Notes * Your solution should efficiently handle the maximum input size. * Consider using mathematical properties or data structures to achieve optimal time and space complexity.","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Identifies the missing number from a given sequence of integers from 1 to n, where n is the length of the sequence plus one. n = len(sequence) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(sequence) return expected_sum - actual_sum"},{"question":"# In-Place Array Reversal Problem Statement You are required to implement a function named `reverse_array_in_place` that takes a list of integers and reverses the elements within the list without using any additional space for another list. The function should modify the original list and return it. Input * A list of integers `arr` where `1 <= len(arr) <= 10^4`. Output * The function should return the same list `arr` but with the elements reversed in place. Function Signature ```python def reverse_array_in_place(arr: list) -> list: pass ``` Constraints * The list should be reversed using constant space, meaning you cannot allocate another list for temporary storage. * The function should handle lists of any given length that is within the constraints. # Example ```python >>> reverse_array_in_place([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> reverse_array_in_place([1]) [1] >>> reverse_array_in_place([10, 20, 30]) [30, 20, 10] >>> reverse_array_in_place([-1, 0, 1]) [1, 0, -1] ``` Notes * You should not use any built-in functions that directly reverse the list (`reversed` or `arr[::-1]` are not allowed). * Aim to write a clear and efficient in-place reversal function that adheres to the constraints and handles all edge cases gracefully.","solution":"def reverse_array_in_place(arr: list) -> list: Reverses the elements within the list \'arr\' in place and returns it. Parameters: arr (list): The list of integers to be reversed. Returns: list: The same list with elements reversed in place. left, right = 0, len(arr) - 1 while left < right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 return arr"},{"question":"# Coding Question Introduction: Matrix multiplication is a fundamental operation in many areas of computer science, such as computer graphics, cryptography, and scientific computing. In this exercise, you will implement a function to multiply two matrices and return the resulting matrix. Task: Write a function `matrix_multiplication` that takes two 2-dimensional lists of integers `matrix_a` and `matrix_b` as input and returns a 2-dimensional list representing the product of the two matrices. If the matrices cannot be multiplied due to incompatible dimensions, an appropriate exception should be raised. Function Signature: ```python def matrix_multiplication(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: ``` Input: - `matrix_a`: A 2-dimensional list of integers representing the first matrix. - `matrix_b`: A 2-dimensional list of integers representing the second matrix. Output: - A 2-dimensional list of integers representing the product of the two matrices. Constraints: - If `matrix_a` or `matrix_b` are not 2-dimensional lists, raise an appropriate error. - Ensure that the number of columns in `matrix_a` is equal to the number of rows in `matrix_b`. If not, raise an appropriate error. - Handle cases where either `matrix_a` or `matrix_b` is empty by raising an appropriate error. Example: ```python # Example call result = matrix_multiplication([[1, 2], [3, 4]], [[5, 6], [7, 8]]) # Example output # [[19, 22], [43, 50]] ``` Notes: 1. Ensure your function validates inputs correctly. 2. Implement the standard matrix multiplication algorithm. 3. Handle edge cases and ensure the function raises appropriate exceptions for invalid inputs. 4. Return the result as a 2-dimensional list. --- This question evaluates the understanding of basic matrix operations, input validation, and handling edge cases in Python, promoting good programming practices and problem-solving abilities.","solution":"def matrix_multiplication(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: # Check if both matrices are not empty if not matrix_a or not matrix_b: raise ValueError(\\"Both matrices must be non-empty.\\") # Check if both matrices are 2-dimensional lists if not all(isinstance(row, list) for row in matrix_a) or not all(isinstance(row, list) for row in matrix_b): raise ValueError(\\"Both matrix_a and matrix_b should be 2-dimensional lists.\\") # Get the dimensions of the matrices rows_a, cols_a = len(matrix_a), len(matrix_a[0]) rows_b, cols_b = len(matrix_b), len(matrix_b[0]) # Check if matrix dimensions match for multiplication if cols_a != rows_b: raise ValueError(\\"Number of columns in matrix_a must be equal to number of rows in matrix_b.\\") # Initialize the resulting matrix with zeros result = [[0] * cols_b for _ in range(rows_a)] # Perform matrix multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"**String Manipulation and Pattern Matching** You are required to implement a set of string manipulation and pattern matching functions, including functions for reversing a string, finding the longest palindromic substring, checking if a string matches a given pattern, and counting occurrences of a character in a string. You should adhere to the following function signatures and specifications: ```python def reverse_string(s: str) -> str: Reverses the given string. :param s: Input string. :return: Reversed string. def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string. :param s: Input string. :return: The longest palindromic substring. def match_pattern(s: str, pattern: str) -> bool: Checks if the given string matches the given pattern. The pattern only includes characters and \'*\' which can match any sequence of characters (including the empty sequence). :param s: Input string. :param pattern: Pattern string including possible \'*\' characters. :return: True if the string matches the pattern, False otherwise. def count_char_occurrences(s: str, char: str) -> int: Counts the number of occurrences of the given character in the string. :param s: Input string. :param char: Character to count. :return: Number of occurrences of the character in the string. ``` # Constraints: 1. The input strings will have a maximum length of 1000 characters. 2. The input pattern for `match_pattern` may include \'*\' characters that can match any sequence of characters in the string. 3. The input character for `count_char_occurrences` will always be a single character. # Testing: You should ensure your implementations pass the following test cases: - Reverse String: Test with strings of various lengths, including empty strings and single-character strings. - Longest Palindromic Substring: Test with strings containing palindromic sequences of various lengths and positions. - Match Pattern: Test with patterns of different configurations, including patterns without \'*\', with multiple \'*\' characters, and edge cases like starting and ending with \'*\' or having \'*\' in the middle. - Count Character Occurrences: Test with strings containing the character multiple times, not containing the character, and edge cases with empty strings.","solution":"def reverse_string(s: str) -> str: Reverses the given string. :param s: Input string. :return: Reversed string. return s[::-1] def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string. :param s: Input string. :return: The longest palindromic substring. if not s: return \\"\\" n = len(s) start, max_length = 0, 1 # Table to store results of sub-problems table = [[False for _ in range(n)] for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): table[i][i] = True # Check for substring of length 2. for i in range(n - 1): if s[i] == s[i + 1]: table[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2. for k in range(3, n + 1): for i in range(n - k + 1): j = i + k - 1 if table[i + 1][j - 1] and s[i] == s[j]: table[i][j] = True if k > max_length: start = i max_length = k return s[start:start + max_length] def match_pattern(s: str, pattern: str) -> bool: Checks if the given string matches the given pattern. The pattern only includes characters and \'*\' which can match any sequence of characters (including the empty sequence). :param s: Input string. :param pattern: Pattern string including possible \'*\' characters. :return: True if the string matches the pattern, False otherwise. n, m = len(s), len(pattern) dp = [[False] * (m + 1) for _ in range(n + 1)] dp[0][0] = True for j in range(1, m + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] for i in range(1, n + 1): for j in range(1, m + 1): if pattern[j - 1] == \'*\': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] else: dp[i][j] = dp[i - 1][j - 1] and s[i - 1] == pattern[j - 1] return dp[n][m] def count_char_occurrences(s: str, char: str) -> int: Counts the number of occurrences of the given character in the string. :param s: Input string. :param char: Character to count. :return: Number of occurrences of the character in the string. return s.count(char)"},{"question":"Problem Statement You are tasked with implementing a function that merges two sorted lists into one sorted list without using any built-in sort function. The two input lists are guaranteed to be individually sorted in ascending order. # Function Signature ```python def merge_sorted_lists(list1: list, list2: list) -> list: ``` # Input - `list1`: A list of integers sorted in ascending order, with `n` elements. - `list2`: A list of integers sorted in ascending order, with `m` elements. # Output - Returns a new list containing all elements from `list1` and `list2`, sorted in ascending order. # Constraints - `0 <= n, m <= 1000` - Each list will only contain integers. - The combined length of the lists will not exceed 2000. # Example ```python list1 = [1, 3, 5, 7] list2 = [2, 4, 6, 8] print(merge_sorted_lists(list1, list2)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] list1 = [-5, 0, 3, 6] list2 = [-2, 1, 4, 7] print(merge_sorted_lists(list1, list2)) # Output: [-5, -2, 0, 1, 3, 4, 6, 7] ``` # Note - The solution should efficiently merge the two lists by comparing the elements from both lists sequentially. - If one list is exhausted before the other, append the remaining elements from the other list to the result.","solution":"def merge_sorted_lists(list1: list, list2: list) -> list: merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Question Style - Carefully examine the format and presentation of the given questions. - Maintain a consistent tone and language used in the original set. # Question Length - Ensure your new question is of comparable length to the existing ones. - If the original questions vary in length, aim for the average length among them. # Difficulty Level - Assess the cognitive and technical challenges presented in the sample questions. - Match the complexity of concepts, algorithms, or programming techniques required. # Topic Alignment - Identify the core programming concepts or domains covered in the existing questions. - Create a question that explores a related or complementary area within the same general topic. # Question Uniqueness - While maintaining similarity, ensure your new question is not a mere rephrasing of an existing one. - Introduce a novel problem or scenario that tests the same skills in a different context. Output Compose one additional question that seamlessly integrates with the existing set, adhering to all the above guidelines. Your new question should appear as if it were part of the original examination and indistinguishable in quality. Output one new question only. You are tasked with creating a function to generate an image of a fractal tree using recursive algorithms. Implement a function `generate_fractal_tree` that generates an image of a fractal tree. The function should support recursive calculations to create the tree branches. ```python def generate_fractal_tree( image_width: int, image_height: int, initial_height: float, branch_angle: float, depth: int ) -> Image.Image: Generate the image of a fractal tree. :param image_width: width of the image in pixels :param image_height: height of the image in pixels :param initial_height: height of the initial trunk in pixels :param branch_angle: angle between branches in degrees :param depth: depth of recursion for branch generation :return: an Image object representing the fractal tree pass ``` Requirements: * The function should use recursive calculations to generate the tree branches. * Keep floating-point precision issues in mind, especially for small branches. * Implement and use a custom color coding scheme to highlight the various branching levels. * Write additional helper functions as needed. Additional Considerations: Consider potential performance optimizations for generating the tree. A strong solution will address the balance between visual complexity and computational efficiency. Generate and display an image of size 800x600 pixels, with an initial trunk height of 100 pixels, a branch angle of 30 degrees, and a recursion depth of 10. Write a brief report explaining your design choices, performance challenges, and how your implementation handles edge cases and potential performance bottlenecks.","solution":"from PIL import Image, ImageDraw import math def draw_branch(draw, x1, y1, angle, length, depth, branch_angle): Recursive function to draw branches of the fractal tree. if depth == 0: return # Calculate the end point of the branch x2 = x1 + int(math.cos(math.radians(angle)) * length) y2 = y1 + int(math.sin(math.radians(angle)) * length) # Draw the branch draw.line((x1, y1, x2, y2), fill=(0, int(255 / depth), 0), width=depth) # Recursively draw two new branches draw_branch(draw, x2, y2, angle - branch_angle, length * 0.7, depth - 1, branch_angle) draw_branch(draw, x2, y2, angle + branch_angle, length * 0.7, depth - 1, branch_angle) def generate_fractal_tree(image_width, image_height, initial_height, branch_angle, depth): Generate the image of a fractal tree. image = Image.new(\'RGB\', (image_width, image_height), (255, 255, 255)) draw = ImageDraw.Draw(image) # Start drawing from the middle bottom of the image start_x = image_width // 2 start_y = image_height draw_branch(draw, start_x, start_y, -90, initial_height, depth, branch_angle) return image # Example usage: # tree_image = generate_fractal_tree(800, 600, 100, 30, 10) # tree_image.show()"},{"question":"# Problem Statement You need to design a function that generates a list of prime numbers up to a given positive integer `n` using the **Sieve of Eratosthenes** algorithm. The function should return the list of prime numbers in ascending order. # Function Signature ```python def sieve_of_eratosthenes(n: int) -> list: pass ``` # Input - **n** (int): The upper limit (inclusive) up to which to generate prime numbers. # Output - **result** (list): A list of prime numbers in ascending order up to the given integer `n`. # Constraints 1. `n` is a positive integer, ranging from 2 to 100,000. 2. The function should raise a `TypeError` if `n` is not an integer. 3. The function should raise a `ValueError` if `n` is less than 2. # Examples ```python >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(\'100\') Traceback (most recent call last): ... TypeError: Undefined for non-integers >>> sieve_of_eratosthenes(1) Traceback (most recent call last): ... ValueError: Undefined for numbers less than 2 ``` # Implementation Notes To generate the list of prime numbers using the Sieve of Eratosthenes algorithm: 1. Create a list of boolean values (`True` means the index is prime, initialized to `True`) from 2 to `n`. 2. Iterate from 2 to the square root of `n`. For each prime number found, mark its multiples as `False` indicating non-prime. 3. Collect all indices that are still `True` at the end of the iteration, which are the prime numbers up to `n`. Ensure your implementation is optimized for performance and can handle the upper limit efficiently.","solution":"def sieve_of_eratosthenes(n: int) -> list: Returns a list of prime numbers up to the given integer n using the Sieve of Eratosthenes algorithm. if not isinstance(n, int): raise TypeError(\\"Undefined for non-integers\\") if n < 2: raise ValueError(\\"Undefined for numbers less than 2\\") # Initialize sieve with True (means prime) sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [prime for prime, is_prime in enumerate(sieve) if is_prime]"},{"question":"# Predicting Movie Ratings using Collaborative Filtering You are tasked with predicting movie ratings in a collaborative filtering recommendation system. The goal is to implement the Alternating Least Squares (ALS) algorithm to predict the ratings matrix. **Function Signature**: ```python def predict_ratings( user_item_matrix: np.ndarray, num_latent_factors: int, num_iterations: int ) -> np.ndarray: ``` **Input**: - `user_item_matrix`: A 2D numpy array of shape `(num_users, num_items)` where `num_users` is the number of users and `num_items` is the number of items. Each element represents the rating a user has given to an item, with unknown ratings represented by `0`. - `num_latent_factors`: An integer representing the number of latent factors to use in the matrix factorization. - `num_iterations`: An integer representing the number of iterations to perform in the ALS algorithm. **Output**: - A 2D numpy array of shape `(num_users, num_items)` containing the predicted ratings matrix. **Constraints**: - Assume `num_users` and `num_items` are both greater than `0`. - `num_latent_factors` and `num_iterations` will be positive integers. - The function should handle typical values for `num_users` and `num_items` up to thousands, so efficiency is crucial. # Example ```python import numpy as np user_item_matrix = np.array([ [5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4] ]) num_latent_factors = 2 num_iterations = 10 predicted_matrix = predict_ratings(user_item_matrix, num_latent_factors, num_iterations) print(predicted_matrix) ``` Your implementation should use the basic principles of the ALS algorithm, which involves iteratively alternating between holding the user matrix fixed and solving for the item matrix, and then holding the item matrix fixed and solving for the user matrix. Ensure to implement both steps to update the latent factor matrices correctly.","solution":"import numpy as np def predict_ratings(user_item_matrix: np.ndarray, num_latent_factors: int, num_iterations: int) -> np.ndarray: Predict movie ratings using the Alternating Least Squares (ALS) algorithm. Parameters: - user_item_matrix: np.ndarray -- The user-item rating matrix. - num_latent_factors: int -- The number of latent factors. - num_iterations: int -- The number of iterations to perform. Returns: - np.ndarray -- The predicted ratings matrix. num_users, num_items = user_item_matrix.shape # Initialize user and item latent factor matrices with random values user_factors = np.random.rand(num_users, num_latent_factors) item_factors = np.random.rand(num_items, num_latent_factors) # Iterate to alternately update user_factors and item_factors for _ in range(num_iterations): # Update user_factors for u in range(num_users): # Only consider items rated by the user `u` rated_items = user_item_matrix[u, :] > 0 if np.sum(rated_items) > 0: item_factors_rated = item_factors[rated_items, :] ratings_rated = user_item_matrix[u, rated_items] user_factors[u, :] = np.linalg.solve(np.dot(item_factors_rated.T, item_factors_rated) + 0.1 * np.eye(num_latent_factors), np.dot(item_factors_rated.T, ratings_rated)) # Update item_factors for i in range(num_items): # Only consider users who rated the item `i` rated_users = user_item_matrix[:, i] > 0 if np.sum(rated_users) > 0: user_factors_rated = user_factors[rated_users, :] ratings_rated = user_item_matrix[rated_users, i] item_factors[i, :] = np.linalg.solve(np.dot(user_factors_rated.T, user_factors_rated) + 0.1 * np.eye(num_latent_factors), np.dot(user_factors_rated.T, ratings_rated)) # Compute the full ratings matrix predicted_ratings = np.dot(user_factors, item_factors.T) return predicted_ratings"},{"question":"# Coding Assessment Question Problem Statement You are given a linked list implemented with the following class structure: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next ``` The linked list has methods for adding nodes and displaying the list. Your task is to extend this class to support additional functionality. Objective 1. Write a function `reverse_k_group` that reverses the nodes of the list k at a time and returns its modified list. The function should handle cases where the number of nodes is not a multiple of k by leaving the last remaining nodes as they are. 2. Handle edge cases effectively (e.g., k is greater than the length of the list or k is 1). Implementation Details Extend the provided class with the following function: ```python def reverse_k_group(self, head: ListNode, k: int) -> ListNode: ``` - **Input**: - `head`: The head of the linked list (type `ListNode`). - `k`: The number of nodes in each group that should be reversed. - **Output**: - Returns the head of the modified linked list (type `ListNode`). Constraints - The function should run in O(n) time complexity, where n is the number of nodes in the linked list. - Space complexity should be optimized to O(1) additional space. Example ```python # Construct the linked list: 1 -> 2 -> 3 -> 4 -> 5 ln5 = ListNode(5) ln4 = ListNode(4, ln5) ln3 = ListNode(3, ln4) ln2 = ListNode(2, ln3) ln1 = ListNode(1, ln2) # Example usage: # This should reverse the linked list in groups of 2 # resulting in: 2 -> 1 -> 4 -> 3 -> 5 head = reverse_k_group(ln1, 2) # This should reverse the linked list in groups of 3 # resulting in: 3 -> 2 -> 1 -> 4 -> 5 head = reverse_k_group(ln1, 3) ``` Notes - The function should handle an empty list correctly (return `None`). - If `k` is 1, the list should remain unchanged since reversing a single node is redundant. - You may use helper functions if needed to maintain clear and efficient code. - Ensure to check if there are enough nodes left in the list to form a complete group of `k` for reversal. Hint Consider using a dummy node to simplify the reversal process and make handling the head pointer easier.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head cur, nex, pre = head, None, dummy count = 0 while cur: count += 1 cur = cur.next while count >= k: cur = pre.next nex = cur.next for _ in range(1, k): cur.next = nex.next nex.next = pre.next pre.next = nex nex = cur.next pre = cur count -= k return dummy.next"},{"question":"# Question: Circular Array Rotation A circular array rotation shifts each element of an array to the right by a given number of steps. For example, with a 3-step rotation on the array `[1, 2, 3, 4, 5]`, the resulting array is `[3, 4, 5, 1, 2]`. **Task**: Implement the function `circular_array_rotation` that rotates an array `k` times to the right. The function should return the modified array. **Function Signature**: ```python def circular_array_rotation(array: list[int], k: int) -> list[int]: ``` **Input**: * `array`: A list of integers representing the array to be rotated. * `k`: An integer denoting the number of rotations. **Output**: * A list of integers representing the rotated array. **Constraints**: * The array can be empty. * The rotation count `k` can be any non-negative integer. **Examples**: ```python >>> circular_array_rotation([1, 2, 3, 4, 5], 3) [3, 4, 5, 1, 2] >>> circular_array_rotation([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> circular_array_rotation([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> circular_array_rotation([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> circular_array_rotation([], 3) [] >>> circular_array_rotation([10, 20, 30], 2) [20, 30, 10] ``` **Notes**: * Handle edge cases such as empty input arrays and rotation counts larger than the array length. * Ensure the algorithm performs efficiently even for large arrays. * Consider cases where the number of rotations is a multiple of the array length.","solution":"def circular_array_rotation(array: list[int], k: int) -> list[int]: Rotates the elements of the array k times to the right and returns the resulting array. :param array: List of integers to be rotated :param k: Number of rotations to the right :return: Rotated list of integers if not array: return [] n = len(array) k = k % n # Handle cases where k is greater than the array length return array[-k:] + array[:-k]"},{"question":"# Array Right Rotation Implementation and Analysis Objective Given an array of integers and a non-negative integer `k`, implement an algorithm that performs a right rotation on the array `k` times. Additionally, analyze the expected performance and possible limitations of your approach. Task 1. **Function Implementation**: Implement the `right_rotate` function that rotates the input array to the right by `k` positions. 2. **Performance Analysis**: Write a brief analysis (approximately 200 words) discussing the expected time and space complexity of your implementation. Highlight any edge cases and explain how your approach handles them. Compare the rotational algorithm to other array manipulation techniques in terms of performance and use cases. Function Signature ```python def right_rotate(input_array: list, k: int) -> list: Rotates input_array to the right by k positions. :param input_array: A list of integers. :param k: A non-negative integer specifying the number of rotations. :return: The rotated list. pass ``` Input Format * A list of integers `input_array` where 0 ≤ len(input_array) ≤ 1000. * A non-negative integer `k` where 0 ≤ k ≤ 1000. Output Format * A list of integers rotated to the right by `k` positions. Constraints * Elements in the list may include both positive and negative integers. * The input list may include duplicate elements. Example ```python assert right_rotate([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert right_rotate([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] assert right_rotate([], 3) == [] assert right_rotate([7, -3, 10], 1) == [10, 7, -3] assert right_rotate([5, 6, 7], 6) == [6, 7, 5] ``` Analysis Evaluate the implementation in terms of: * **Worst-case Time Complexity**: Explain why the time complexity is O(n) where n is the length of the array. * **Space Complexity**: Justify the O(1) space complexity assuming that the rotation is done in-place. * **Edge Cases Handling**: Discuss edge cases, such as an empty list, `k` being zero, or `k` being larger than the length of the array, and how your implementation deals with them. Notes * Ensure the implementation takes into account all possible input conditions, ensuring stability and correctness. * Provide adequate comments and docstrings to explain the logic and flow of your implementation.","solution":"def right_rotate(input_array: list, k: int) -> list: Rotates input_array to the right by k positions. :param input_array: A list of integers. :param k: A non-negative integer specifying the number of rotations. :return: The rotated list. if not input_array: return input_array n = len(input_array) k = k % n # Handle cases where k > n return input_array[-k:] + input_array[:-k] # Performance Analysis # The right_rotate function operates in O(n) time complexity, where n is the length of the array. This is because slicing # operations on lists have O(n) complexity. The rotation is achieved by slicing the array into two parts and then # concatenating them, which is efficient. The space complexity of this implementation is O(n) since we create a new list # as a result of slicing and concatenating. However, it is possible to achieve an in-place rotation with O(1) extra space, # but it requires a more complex algorithm. The function handles edge cases such as an empty array, k being zero, and k # being larger than the length of the array effectively. For instance, if the input list is empty, it returns immediately, # ensuring no further operations are performed. Similarly, when k is zero, the original array is returned without # modifications. By using k % n, the implementation correctly handles cases where k exceeds the length of the array, # computing the effective number of rotations."},{"question":"# Image Processing and Enhancement Task Context: You are developing a utility for a photo editing application. Users frequently request the ability to enhance the quality of their images by adjusting brightness and contrast. Your task is to write a function that adjusts the brightness and contrast of an image using the Pillow library in Python. Task: Write a Python function, `enhance_image(image_path: str, brightness_factor: float, contrast_factor: float) -> None`, that takes the path of an image file and adjusts its brightness and contrast. The function should save the enhanced image as a new file, appending \\"_enhanced\\" to the original file name. Input: 1. `image_path` (str): The file path of the image to be enhanced (e.g., \\"photos/sample.jpg\\"). 2. `brightness_factor` (float): The factor by which to adjust the brightness. A factor of 1.0 means no change, less than 1.0 means dimmer, and greater than 1.0 means brighter. 3. `contrast_factor` (float): The factor by which to adjust the contrast. A factor of 1.0 means no change, less than 1.0 means lower contrast, and greater than 1.0 means higher contrast. Output: - The function should save the enhanced image to the same directory as the original, with \\"_enhanced\\" appended to the filename before the extension. Constraints: 1. Ensure the adjustments maintain the integrity of the image without introducing artifacts. 2. Handle cases where the specified image path does not exist gracefully. Requirements: 1. Use the Pillow library to read, process, and save images. 2. Provide clear and meaningful error messages for invalid inputs. # Example Usage: ```python enhance_image(\\"photos/sample.jpg\\", 1.2, 1.5) ``` Additional Information: - The Pillow library\'s `ImageEnhance` module provides convenient methods for adjusting brightness and contrast. - If the input is \\"photos/sample.jpg\\", the output should be saved as \\"photos/sample_enhanced.jpg\\". # Example Implementation: ```python from PIL import Image, ImageEnhance import os def enhance_image(image_path: str, brightness_factor: float, contrast_factor: float) -> None: try: # Open an image file with Image.open(image_path) as img: # Enhance brightness enhancer = ImageEnhance.Brightness(img) img_enhanced = enhancer.enhance(brightness_factor) # Enhance contrast enhancer = ImageEnhance.Contrast(img_enhanced) img_enhanced = enhancer.enhance(contrast_factor) # Generate new file path base, ext = os.path.splitext(image_path) new_image_path = f\\"{base}_enhanced{ext}\\" # Save the enhanced image img_enhanced.save(new_image_path) print(f\\"Enhanced image saved as {new_image_path}\\") except FileNotFoundError: print(f\\"File not found: {image_path}\\") except Exception as e: print(f\\"An error occurred: {e}\\") ```","solution":"from PIL import Image, ImageEnhance import os def enhance_image(image_path: str, brightness_factor: float, contrast_factor: float) -> None: try: # Open an image file with Image.open(image_path) as img: # Enhance brightness enhancer = ImageEnhance.Brightness(img) img_enhanced = enhancer.enhance(brightness_factor) # Enhance contrast enhancer = ImageEnhance.Contrast(img_enhanced) img_enhanced = enhancer.enhance(contrast_factor) # Generate new file path base, ext = os.path.splitext(image_path) new_image_path = f\\"{base}_enhanced{ext}\\" # Save the enhanced image img_enhanced.save(new_image_path) print(f\\"Enhanced image saved as {new_image_path}\\") except FileNotFoundError: print(f\\"File not found: {image_path}\\") except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"You need to implement a function that simulates an 8-to-3 priority encoder. An 8-to-3 priority encoder takes up to 8 input signals and outputs a 3-bit binary representation of the highest-priority input that is set to 1. The priority is defined such that input0 has the highest priority and input7 has the lowest priority. If no inputs are 1, the function should return `None`. # Function Signature ```python def priority_encoder(inputs: list) -> str: Implement an 8-to-3 priority encoder. :param inputs: A list of 8 integers (0 or 1). :return: The 3-bit binary representation of the highest-priority input set to 1, or None if all inputs are 0. Examples: >>> priority_encoder([0, 0, 0, 0, 0, 0, 0, 0]) None >>> priority_encoder([0, 1, 1, 1, 0, 0, 0, 0]) \'001\' >>> priority_encoder([0, 0, 0, 1, 0, 0, 0, 0]) \'011\' >>> priority_encoder([1, 0, 0, 0, 1, 1, 0, 1]) \'000\' >>> priority_encoder([0, 0, 0, 0, 0, 0, 0, 1]) \'111\' >>> priority_encoder([0, 0, 0, -1, 0, 0, 0, 0]) Traceback (most recent call last): ... ValueError: Each input must be 0 or 1 ``` # Constraints 1. The `inputs` list should contain exactly 8 elements. 2. Each element in the `inputs` list must be either 0 or 1. 3. If any element is not 0 or 1, raise a `ValueError`. # Task Implement the `priority_encoder` function so that it correctly determines the 3-bit binary value of the highest-priority input that is set to 1 based on the priority, with proper error handling for invalid inputs.","solution":"def priority_encoder(inputs: list) -> str: Implement an 8-to-3 priority encoder. :param inputs: A list of 8 integers (0 or 1). :return: The 3-bit binary representation of the highest-priority input set to 1, or None if all inputs are 0. if len(inputs) != 8: raise ValueError(\\"List must contain exactly 8 elements\\") for i in range(8): if inputs[i] not in {0, 1}: raise ValueError(\\"Each input must be 0 or 1\\") for i in range(8): if inputs[i] == 1: return f\'{i:03b}\' return None"},{"question":"# Question Context In computer science, searching algorithms play a crucial role in solving various problems. One classical search algorithm is the Binary Search. Binary Search works on sorted arrays and utilizes a divide-and-conquer approach to find a target value efficiently. Imagine you are implementing a search feature for a large dataset, and you want to use the Binary Search algorithm to locate items quickly. Problem Statement Implement two functions, `binary_search_iterative` and `binary_search_recursive`, to perform binary search on a sorted list, and return the index of the target value if found, otherwise return `-1`. 1. **binary_search_iterative(arr: list[int], target: int) -> int** - **Input**: - `arr`: A sorted list of integers. - `target`: An integer value to search for in the array. - **Output**: - The index of the target value if found, otherwise `-1`. - **Example**: ```python >>> binary_search_iterative([1, 2, 3, 4, 5, 6, 7], 5) 4 >>> binary_search_iterative([1, 2, 3, 4, 5, 6, 7], 9) -1 ``` 2. **binary_search_recursive(arr: list[int], target: int, low: int, high: int) -> int** - **Input**: - `arr`: A sorted list of integers. - `target`: An integer value to search for in the array. - `low`: The lower bound index of the current search interval. - `high`: The upper bound index of the current search interval. - **Output**: - The index of the target value if found, otherwise `-1`. - **Example**: ```python >>> binary_search_recursive([1, 2, 3, 4, 5, 6, 7], 5, 0, 6) 4 >>> binary_search_recursive([1, 2, 3, 4, 5, 6, 7], 9, 0, 6) -1 ``` 3. **Constraints**: - `1 <= len(arr) <= 10^5` - `-10^6 <= arr[i], target <= 10^6` - `low` and `high` will always be valid indices within the array bounds. Additional Requirements - Your implementation should handle edge cases such as: - An array with a single element. - A target value not present in the array. - Arrays with all elements being the same. - Ensure both implementations (iterative and recursive) are efficient and leverage the properties of the sorted array for early termination if the target is not found.","solution":"def binary_search_iterative(arr, target): Perform binary search in an iterative manner. Args: arr: A sorted list of integers. target: The integer value to search for in the array. Returns: The index of the target value if found, otherwise -1. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(arr, target, low, high): Perform binary search in a recursive manner. Args: arr: A sorted list of integers. target: The integer value to search for in the array. low: The lower bound index of the current search interval. high: The upper bound index of the current search interval. Returns: The index of the target value if found, otherwise -1. if low > high: return -1 mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] < target: return binary_search_recursive(arr, target, mid + 1, high) else: return binary_search_recursive(arr, target, low, mid - 1)"},{"question":"# Scenario You are developing an image processing library. As part of the functionality, you need to implement a special class that allows easy manipulation of image pixels. This class should also support several essential image transformations, such as rotation and scaling. # Task Implement the `ImageManipulator` class which supports basic manipulation of an image represented as a 2D array of pixels and provides a method to apply geometric transformations. # Details 1. **Class `ImageManipulator` Implementation**: * Attributes and methods to store and manipulate a 2D image. * Essential operations: - `rotate(angle: float)`: Rotates the image by a specified angle (in degrees). - `scale(factor: float)`: Scales the image by a specified factor. - `translate(dx: int, dy: int)`: Translates (shifts) the image by `dx` pixels horizontally and `dy` pixels vertically. 2. **Constructor and Helper Methods**: * The constructor initializes the image from a 2D list of pixel values. * Additional helper methods for handling internal operations and validations. # Input * Initial image: 2D list of integers representing pixel values. * Operations: rotate, scale, translate with respective arguments. # Output * Returns a 2D list of integers representing the transformed image. # Constraints * Pixel values are integers within the range [0, 255]. * Image dimensions do not exceed 1000x1000 pixels. * Rotation should handle angles that are multiples of 90 degrees. * Scaling factors are positive float values greater than 0. * Translations are integers. # Example ```python initial_image = [ [0, 0, 0], [255, 255, 255], [0, 0, 0] ] # Usage image_manipulator = ImageManipulator(initial_image) # Rotate 90 degrees rotated_image = image_manipulator.rotate(90) print(rotated_image) # Expected output: [ # [0, 255, 0], # [0, 255, 0], # [0, 255, 0] # ] # Scale by factor of 2 scaled_image = image_manipulator.scale(2) print(scaled_image) # Expected output: [ # [0, 0, 0, 0, 0, 0], # [0, 0, 0, 0, 0, 0], # [255, 255, 255, 255, 255, 255], # [255, 255, 255, 255, 255, 255], # [0, 0, 0, 0, 0, 0], # [0, 0, 0, 0, 0, 0] # ] # Translate by (1, 1) translated_image = image_manipulator.translate(1, 1) print(translated_image) # Expected output: [ # [0, 0, 0, 0], # [0, 0, 0, 0], # [255, 255, 255, 0], # [0, 0, 0, 0] # ] ``` # Notes 1. Ensure the class properly handles invalid transformations, such as rotation by non-multiples of 90 degrees. 2. The class should be designed to handle edge cases such as empty or null images. 3. Provide comprehensive error checking/messages for invalid input values.","solution":"class ImageManipulator: def __init__(self, image): self.image = image def rotate(self, angle): if angle % 90 != 0: raise ValueError(\\"Rotation angle must be a multiple of 90 degrees\\") if angle % 360 == 0: return self.image angle = angle % 360 if angle == 90: return self._rotate_90_clockwise(self.image) elif angle == 180: return self._rotate_180(self.image) elif angle == 270: return self._rotate_90_counterclockwise(self.image) def scale(self, factor): if factor <= 0: raise ValueError(\\"Scale factor must be greater than 0\\") return self._scale_image(self.image, factor) def translate(self, dx, dy): return self._translate_image(self.image, dx, dy) def _rotate_90_clockwise(self, image): return [list(row) for row in zip(*image[::-1])] def _rotate_180(self, image): return [row[::-1] for row in image[::-1]] def _rotate_90_counterclockwise(self, image): return [list(row) for row in zip(*image)][::-1] def _scale_image(self, image, factor): def enlarge_row(row, factor): return [pixel for pixel in row for _ in range(int(factor))] enlarged_image = [enlarge_row(row, factor) for row in image for _ in range(int(factor))] return enlarged_image def _translate_image(self, image, dx, dy): height = len(image) width = len(image[0]) if height > 0 else 0 translated_image = [[0] * (width + abs(dx)) for _ in range(height + abs(dy))] for y in range(height): for x in range(width): new_y = y + dy new_x = x + dx if 0 <= new_y < len(translated_image) and 0 <= new_x < len(translated_image[0]): translated_image[new_y][new_x] = image[y][x] return translated_image"},{"question":"# Problem Statement Implement a function in Python that uses the Depth-First Search (DFS) algorithm to determine if there exists a path between two nodes in a directed graph. If a path exists, return True, otherwise return False. # Function Signature ```python def has_path(n, edges, start, end): Determine if there exists a path between two nodes using Depth-First Search (DFS) algorithm. :param n: An integer representing the number of nodes. :param edges: A list of tuples (u, v), where \'u\' is the starting node, and \'v\' is the ending node of a directed edge. :param start: The starting node from which to search (integer). :param end: The ending node that we want to reach (integer). :return: A boolean value, True if there is a path from `start` to `end`, False otherwise. Example: >>> has_path(3, [(0, 1), (1, 2)], 0, 2) True >>> has_path(3, [(0, 1), (1, 2)], 1, 0) False pass ``` # Constraints * (1 leq n leq 100) — the number of nodes in the graph. * Each node is represented by an integer in the range `[0, n-1]`. # Input * `n` (integer): Number of nodes in the graph. * `edges` (list of tuples): Each tuple `(u, v)` represents a directed edge from node `u` to node `v`. * `start` (integer): The starting node. * `end` (integer): The target node to check for reachability. # Output * Return `True` if there is a path from `start` to `end`. * Return `False` if there is no path from `start` to `end`. # Example ```python >>> has_path(5, [(0, 1), (1, 2), (2, 3), (3, 4)], 0, 4) True >>> has_path(5, [(0, 1), (1, 2), (2, 3), (3, 4)], 0, 5) False >>> has_path(5, [(0, 1), (2, 3), (3, 4)], 0, 4) False ``` # Requirements 1. Create an adjacency list from the given edges. 2. Use a stack to implement the Depth-First Search algorithm. 3. Track visited nodes to prevent infinite loops. 4. Return `True` if the target node is found, otherwise return `False`.","solution":"def has_path(n, edges, start, end): Determine if there exists a path between two nodes using Depth-First Search (DFS) algorithm. :param n: An integer representing the number of nodes. :param edges: A list of tuples (u, v), where \'u\' is the starting node, and \'v\' is the ending node of a directed edge. :param start: The starting node from which to search (integer). :param end: The ending node that we want to reach (integer). :return: A boolean value, True if there is a path from `start` to `end`, False otherwise. graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) stack = [start] visited = set() while stack: node = stack.pop() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return False"},{"question":"# Problem Statement **Background**: In the context of graph theory, Depth-First Search (DFS) is a fundamental algorithm used for traversing or searching tree or graph data structures. The algorithm starts at the root node and explores as far as possible along each branch before backtracking. # Description Implement a function `count_connected_components` that takes an undirected graph represented as an adjacency list and returns the number of connected components within that graph. The graph is defined by a dictionary where the keys are nodes and the values are lists of neighboring nodes. Function Signature ```python def count_connected_components(graph: Dict[int, List[int]]) -> int: pass ``` # Input - `graph`: A dictionary representing an undirected graph, where: - Each key is an integer node. - Each value is a list of integers representing the neighboring nodes. - Assume the nodes are numbered uniquely and sequentially from 0 up to len(graph) - 1. # Output - Returns an integer representing the number of connected components in the graph. # Constraints - The graph may have up to 10^4 nodes. - The list of neighbors for each node may be empty, indicating an isolated node. # Performance Requirements - Aim for O(V + E) time complexity, where V is the number of vertices and E is the number of edges. - Use O(V) auxiliary space for tracking visited nodes. # Example ```python graph1 = { 0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3], 5: [] } assert count_connected_components(graph1) == 3 # There are three connected components: {0,1,2}, {3,4}, {5} graph2 = { 0: [], 1: [], 2: [], 3: [] } assert count_connected_components(graph2) == 4 # There are four connected components, each consisting of one node graph3 = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1] } assert count_connected_components(graph3) == 1 # There is one connected component: {0,1,2,3} ``` # Constraints and Notes - Ensure that your implementation can handle large graphs. - Utilize a depth-first search (DFS) approach to explore the graph and count connected components effectively. - Consider corner cases like completely isolated nodes or entirely connected graphs. # Additional Considerations - Implement helper functions if necessary for recursive DFS traversal. - Pay attention to the algorithm\'s efficiency and ensure it operates within the expected time and space constraints.","solution":"from typing import Dict, List def count_connected_components(graph: Dict[int, List[int]]) -> int: def dfs(node: int, visited: set): stack = [node] while stack: current = stack.pop() for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() connected_components = 0 for node in graph: if node not in visited: visited.add(node) dfs(node, visited) connected_components += 1 return connected_components"},{"question":"Problem Statement You are given a list of integers. Your task is to determine whether there exists a pair of distinct indices `i` and `j` such that the absolute difference between the elements at those positions is equal to a given target difference `k`. Write a function `find_pair_with_difference` that takes in a list of integers and an integer `k`, and returns a boolean value indicating whether such a pair exists. # Function Signature ```python def find_pair_with_difference(nums: list[int], k: int) -> bool: pass ``` # Input * `nums` (list of integers): A list of integers with length `1 <= len(nums) <= 10^4`. The integers can be positive, negative, or zero. * `k` (integer): A non-negative integer representing the target difference with `0 <= k <= 10^9`. # Output * A boolean value: `True` if there exists a pair of indices `i` and `j` (i ≠ j) such that `|nums[i] - nums[j]| == k`, otherwise `False`. # Example ```python assert find_pair_with_difference([1, 5, 3, 4, 2], 2) == True assert find_pair_with_difference([1, 5, 3, 4, 2], 10) == False assert find_pair_with_difference([1, 2, 3, 4, 5], 1) == True assert find_pair_with_difference([1, 2, 3, 4, 5], 0) == False ``` # Constraints * You can assume the list contains only integers. * The goal is to determine if such a pair exists, not to identify the indices themselves. * Try to achieve an efficient solution, with a time complexity better than O(n^2) if possible.","solution":"def find_pair_with_difference(nums: list[int], k: int) -> bool: Returns True if there exists a pair of distinct indices i and j such that the absolute difference between nums[i] and nums[j] is equal to k. Otherwise, returns False. nums_set = set(nums) for num in nums: if (num + k) in nums_set or (num - k) in nums_set: # We need to check for the existence of a distinct index if k == 0: if nums.count(num) > 1: return True else: return True return False"},{"question":"# Problem Statement You are tasked to create a function that merges two lists of integers in ascending order into a single list also in ascending order. This function is particularly useful for sorting and processing tasks in data analysis or machine learning preprocessing steps. **Function Signature:** ```python def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: pass ``` # Input * Two lists `list1` and `list2` of `m` and `n` integers, respectively, both sorted in ascending order. * ( 0 leq m, n leq 10^6 ) * Each integer in the lists can be between `-10^9` to `10^9`. # Output * A single list of `m + n` integers, which is a merged version of the input lists, sorted in ascending order. # Constraints * Ensure that your solution handles large lists efficiently, focusing on time and space complexity. * Avoid using built-in sort functions directly on the concatenated result; aim for a more algorithmic approach. # Example ```python def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. Parameters: list1 (List[int]): First sorted list of integers. list2 (List[int]): Second sorted list of integers. Returns: List[int]: Merged sorted list of integers. result = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: result.append(list1[i]) i += 1 else: result.append(list2[j]) j += 1 result.extend(list1[i:]) result.extend(list2[j:]) return result if __name__ == \\"__main__\\": # Example 1 list1 = [1, 3, 5, 7] list2 = [2, 4, 6, 8] print(merge_sorted_lists(list1, list2)) # Expected Output : [1, 2, 3, 4, 5, 6, 7, 8] # Example 2 list1 = [-10, -5, 0, 3] list2 = [-8, 1, 7, 12] print(merge_sorted_lists(list1, list2)) # Expected Output : [-10, -8, -5, 0, 1, 3, 7, 12] ``` # Notes * Make sure to follow the provided function signature. * Validate your approach with different input sizes for performance evaluation. * It is essential to ensure that the merging logic maintains the overall sorted order efficiently.","solution":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. Parameters: list1 (List[int]): First sorted list of integers. list2 (List[int]): Second sorted list of integers. Returns: List[int]: Merged sorted list of integers. result = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: result.append(list1[i]) i += 1 else: result.append(list2[j]) j += 1 result.extend(list1[i:]) result.extend(list2[j:]) return result"},{"question":"# Data Processing and Summarization You are tasked with writing a function that processes a large dataset of transactions and summarizes the data into meaningful insights. Each transaction consists of a customer ID, transaction amount, and the transaction category (e.g., groceries, electronics, clothing, etc.). **Task**: Implement a function `summarize_transactions` that receives a list of transactions and returns a summary of total spending per customer and the breakdown of spending by category for each customer. # Function Signature ```python def summarize_transactions(transactions: list) -> dict: Summarize the transactions to compute the total and categorized spending for each customer. Args: transactions (list): A list of dictionaries, each containing: - \\"customer_id\\" (str): ID of the customer. - \\"amount\\" (float): Transaction amount. - \\"category\\" (str): Category of the transaction. Returns: dict: A dictionary where each key is a customer ID and each value is a dictionary containing: - \\"total_spending\\" (float): Total amount spent by the customer. - \\"categories\\" (dict): A dictionary where each key is a category and each value is the total amount spent in that category. ``` # Requirements 1. **Input**: - `transactions` (list of dicts): A list of dictionaries, where each dictionary contains: * `customer_id` (str): ID of the customer. * `amount` (float): Amount of the transaction. * `category` (str): Category of the transaction. 2. **Output**: - A dictionary summarizing spending for each customer: * `total_spending` (float): Total amount spent by the customer. * `categories` (dict): A nested dictionary summarizing spending by each category for the customer. # Instructions 1. Calculate the total amount spent by each customer. 2. Provide a breakdown of spending by category for each customer. 3. Return the summary in a structured format as outlined in the function signature. 4. Handle any erroneous transaction entries gracefully, such as missing keys or incorrect data types, by ignoring them and logging an appropriate message. 5. Ensure the function performs efficiently even with a large number of transactions. # Example ```python >>> transactions = [ {\\"customer_id\\": \\"C001\\", \\"amount\\": 150.0, \\"category\\": \\"electronics\\"}, {\\"customer_id\\": \\"C002\\", \\"amount\\": 100.0, \\"category\\": \\"groceries\\"}, {\\"customer_id\\": \\"C001\\", \\"amount\\": 200.0, \\"category\\": \\"clothing\\"}, {\\"customer_id\\": \\"C002\\", \\"amount\\": 50.0, \\"category\\": \\"electronics\\"}, ] >>> summarize_transactions(transactions) { \\"C001\\": { \\"total_spending\\": 350.0, \\"categories\\": { \\"electronics\\": 150.0, \\"clothing\\": 200.0, } }, \\"C002\\": { \\"total_spending\\": 150.0, \\"categories\\": { \\"groceries\\": 100.0, \\"electronics\\": 50.0, } } } ``` # Constraints - Ensure the function handles up to 1,000,000 transactions efficiently. - Transaction amounts will be positive and can have up to two decimal places. - Transaction categories and customer IDs are non-empty strings. # Performance - Time complexity should be linear with respect to the number of transactions. - Optimize for both speed and memory, considering the large potential dataset size. Ensure your solution correctly handles typical edge cases and is optimized for performance.","solution":"def summarize_transactions(transactions): Summarize the transactions to compute the total and categorized spending for each customer. Args: transactions (list): A list of dictionaries, each containing: - \\"customer_id\\" (str): ID of the customer. - \\"amount\\" (float): Transaction amount. - \\"category\\" (str): Category of the transaction. Returns: dict: A dictionary where each key is a customer ID and each value is a dictionary containing: - \\"total_spending\\" (float): Total amount spent by the customer. - \\"categories\\" (dict): A dictionary where each key is a category and each value is the total amount spent in that category. summary = {} for transaction in transactions: try: customer_id = transaction[\\"customer_id\\"] amount = transaction[\\"amount\\"] category = transaction[\\"category\\"] if not isinstance(customer_id, str) or not isinstance(amount, (int, float)) or not isinstance(category, str): continue if customer_id not in summary: summary[customer_id] = {\\"total_spending\\": 0, \\"categories\\": {}} summary[customer_id][\\"total_spending\\"] += amount if category not in summary[customer_id][\\"categories\\"]: summary[customer_id][\\"categories\\"][category] = 0 summary[customer_id][\\"categories\\"][category] += amount except KeyError: continue return summary"},{"question":"# Implementing a Custom Data Loader for Large Datasets Given the outline of a `DataLoader` class above, extend its functionality to enable efficient loading and batching of large datasets that cannot be entirely loaded into memory. You are to complete the `__iter__` and `__next__` methods to ensure the data loader can be used in a loop to retrieve batches of data. You will need to: 1. **Implement the `__iter__` method** to initialize the iteration, like shuffling the dataset if required. 2. **Implement the `__next__` method** to load the next batch of data until the entire dataset is exhausted. # Implementation Details: 1. **`__iter__` method** should: - Initialize or shuffle the dataset if the `shuffle` attribute is set to `True`. - Define the logic for starting a new iteration over the dataset. 2. **`__next__` method** should: - Load the next batch of data from the dataset. - Ensure efficient memory usage and handle the end of the dataset gracefully. # Input/Output: - **Input**: - Initialization of `DataLoader`: ```python def __init__(self, dataset, batch_size, shuffle=False): # dataset: The input dataset # batch_size: Size of each batch # shuffle: Whether to shuffle the data at the start of each iteration ``` - For `__iter__` method: ```python def __iter__(self): # Initialize iteration ``` - For `__next__` method: ```python def __next__(self): # Load the next batch of data ``` - **Output**: - For `__next__` method: Return the next batch of data. - If the dataset is completely iterated, raise `StopIteration`. # Constraints: 1. The dataset is assumed to be a list or array that can be indexed. 2. The class should manage the state of iteration internally. 3. Each batch should be a subset of the dataset with a maximum length of `batch_size`. # Example Scenario: ```python # Creating a dataset of numbers dataset = list(range(100)) batch_size = 10 # Initializing DataLoader data_loader = DataLoader(dataset, batch_size, shuffle=True) # Iterating over batches for batch in data_loader: print(batch) ``` # Notes: - Ensure that the data loader is efficient and minimizes memory usage. - Think about handling edge cases, such as the dataset size not being perfectly divisible by the batch size. - Incorporate any necessary numpy operations to facilitate large scale data handling if needed. # Example Usage: ```python class DataLoader: def __init__(self, dataset, batch_size, shuffle=False): self.dataset = dataset self.batch_size = batch_size self.shuffle = shuffle self.current_index = 0 def __iter__(self): self.current_index = 0 if self.shuffle: np.random.shuffle(self.dataset) return self def __next__(self): if self.current_index >= len(self.dataset): raise StopIteration batch_start = self.current_index batch_end = min(self.current_index + self.batch_size, len(self.dataset)) batch = self.dataset[batch_start: batch_end] self.current_index = batch_end return batch # Example dataset and DataLoader usage import numpy as np dataset = np.arange(100) data_loader = DataLoader(dataset, batch_size=10, shuffle=True) for batch in data_loader: print(batch) ```","solution":"import numpy as np class DataLoader: def __init__(self, dataset, batch_size, shuffle=False): self.dataset = dataset self.batch_size = batch_size self.shuffle = shuffle self.current_index = 0 def __iter__(self): self.current_index = 0 if self.shuffle: np.random.shuffle(self.dataset) return self def __next__(self): if self.current_index >= len(self.dataset): raise StopIteration batch_start = self.current_index batch_end = min(self.current_index + self.batch_size, len(self.dataset)) batch = self.dataset[batch_start:batch_end] self.current_index = batch_end return batch"},{"question":"# Temperature Conversion Application In this task, you will implement a temperature conversion system that can transform temperatures between different units of measurement. Background: Temperature scales include Celsius, Fahrenheit, and Kelvin, and converting between them involves specific formulas: - Fahrenheit to Celsius: (C = frac{5}{9} times (F - 32)) - Celsius to Fahrenheit: (F = frac{9}{5} times C + 32) - Celsius to Kelvin: (K = C + 273.15) - Kelvin to Celsius: (C = K - 273.15) Your objective is to create functions that convert temperatures from one scale to another. Implement the following functions: - `fahrenheit_to_celsius(fahrenheit: float) -> float` - `celsius_to_fahrenheit(celsius: float) -> float` - `celsius_to_kelvin(celsius: float) -> float` - `kelvin_to_celsius(kelvin: float) -> float` # Function Signatures ```python def fahrenheit_to_celsius(fahrenheit: float) -> float: Convert a temperature from Fahrenheit to Celsius. Parameters: fahrenheit (float): The temperature in Fahrenheit. Returns: float: The temperature in Celsius. ``` ```python def celsius_to_fahrenheit(celsius: float) -> float: Convert a temperature from Celsius to Fahrenheit. Parameters: celsius (float): The temperature in Celsius. Returns: float: The temperature in Fahrenheit. ``` ```python def celsius_to_kelvin(celsius: float) -> float: Convert a temperature from Celsius to Kelvin. Parameters: celsius (float): The temperature in Celsius. Returns: float: The temperature in Kelvin. ``` ```python def kelvin_to_celsius(kelvin: float) -> float: Convert a temperature from Kelvin to Celsius. Parameters: kelvin (float): The temperature in Kelvin. Returns: float: The temperature in Celsius. ``` # Constraints 1. The temperature input can be any valid floating-point number. 2. Ensure that negative Kelvin values raise a `ValueError`, as they are not physically plausible. # Input & Output Formats * Input: A single floating-point number representing the temperature. * Output: A single floating-point number representing the converted temperature. # Example ```python # Example main function to demonstrate if __name__ == \\"__main__\\": fahrenheit_temp = 98.6 celsius_temp = 37.0 kelvin_temp = 310.15 print(fahrenheit_to_celsius(fahrenheit_temp)) # Expected output: 37.0 print(celsius_to_fahrenheit(celsius_temp)) # Expected output: 98.6 print(celsius_to_kelvin(celsius_temp)) # Expected output: 310.15 print(kelvin_to_celsius(kelvin_temp)) # Expected output: 37.0 ``` # Additional Notes Ensure proper handling for edge cases, including but not limited to extremely high or low temperatures. Each function should include thorough documentation and error checks where necessary.","solution":"def fahrenheit_to_celsius(fahrenheit: float) -> float: Convert a temperature from Fahrenheit to Celsius. Parameters: fahrenheit (float): The temperature in Fahrenheit. Returns: float: The temperature in Celsius. return (fahrenheit - 32) * 5.0 / 9.0 def celsius_to_fahrenheit(celsius: float) -> float: Convert a temperature from Celsius to Fahrenheit. Parameters: celsius (float): The temperature in Celsius. Returns: float: The temperature in Fahrenheit. return celsius * 9.0 / 5.0 + 32 def celsius_to_kelvin(celsius: float) -> float: Convert a temperature from Celsius to Kelvin. Parameters: celsius (float): The temperature in Celsius. Returns: float: The temperature in Kelvin. return celsius + 273.15 def kelvin_to_celsius(kelvin: float) -> float: Convert a temperature from Kelvin to Celsius. Parameters: kelvin (float): The temperature in Kelvin. Returns: float: The temperature in Celsius. if kelvin < 0: raise ValueError(\\"Kelvin temperature cannot be negative.\\") return kelvin - 273.15"},{"question":"# Binary Search Tree (BST) Operations Scenario You are tasked with implementing a basic Binary Search Tree (BST) class to support some fundamental operations as part of a data structures assignment. The BST should support insertion, search, and in-order traversal. Input and Output Requirements You need to implement the following methods for the BST class: 1. **`insert(value: int) -> None`**: * **Input**: Value (integer) to be inserted into the BST. * **Output**: None. The value must be inserted in the correct position according to BST properties. 2. **`search(value: int) -> bool`**: * **Input**: Value (integer) to search for in the BST. * **Output**: Boolean indicating whether the value is found in the tree or not. 3. **`in_order_traversal() -> list`**: * **Input**: None. * **Output**: A list of integers representing the BST\'s in-order traversal. The BST class should ensure that the tree properties are preserved after each operation. Example Usage and Expected Results ```python bst = BST() bst.insert(50) bst.insert(30) bst.insert(70) bst.insert(20) bst.insert(40) bst.insert(60) bst.insert(80) assert bst.search(50) == True assert bst.search(25) == False assert bst.in_order_traversal() == [20, 30, 40, 50, 60, 70, 80] ``` Constraints * Values to be inserted will be unique integers. * The BST must allow repeated search operations efficiently. * Ensure the methods are optimized for readability and performance. This assessment will test your understanding of binary search tree properties and your ability to implement key operations efficiently. Ensure your code is well-structured and properly handles edge cases.","solution":"class Node: A Node in the BST, containing a value, and pointers to left and right children. def __init__(self, key): self.key = key self.left = None self.right = None class BST: A simple Binary Search Tree (BST) implementation. def __init__(self): self.root = None def insert(self, value: int) -> None: Insert a value into the BST. if self.root is None: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.key: if node.left is None: node.left = Node(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert_recursive(node.right, value) def search(self, value: int) -> bool: Search for a value in the BST. return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None: return False if node.key == value: return True elif value < node.key: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def in_order_traversal(self) -> list: Perform in-order traversal of the BST and return the sorted values as a list. result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node, result): if node: self._in_order_recursive(node.left, result) result.append(node.key) self._in_order_recursive(node.right, result)"},{"question":"# Coding Assessment Question Context You are designing a text processing module for an application that requires extracting unique words from a given list of sentences. Your task is to implement a function that not only extracts these unique words but also handles different edge cases gracefully. Task Implement a function `extract_unique_words`, which takes a list of sentences (strings) and returns a sorted list of unique words. Each word should be stripped of punctuation and converted to lowercase to ensure uniqueness is determined accurately. Function Signature ```python def extract_unique_words(sentences: list) -> list: pass ``` Input * `sentences` is a list of strings, where each string is a sentence containing words separated by spaces. Output * Returns a sorted list of unique words (all in lowercase). Constraints * The input must be a list of strings. * Raise `TypeError` if the input is not a list of strings. * Raise `ValueError` if an element in the list is not a string. * Punctuation should be stripped from words (e.g., \\"hello,\\" and \\"hello\\" should be considered the same word). Example ```python assert extract_unique_words([\\"Hello, world!\\", \\"Hello world\\", \\"The quick brown fox.\\"]) == [\'brown\', \'fox\', \'hello\', \'quick\', \'the\', \'world\'] assert extract_unique_words([\\"Python is great.\\", \\"Is Python great?\\"]) == [\'great\', \'is\', \'python\'] assert extract_unique_words([\\"An example,\\", \\"with multiple sentences!\\"]) == [\'an\', \'example\', \'multiple\', \'sentences\', \'with\'] ``` Edge Cases * Non-list input: `extract_unique_words(\\"not_a_list\\")` should raise `TypeError`. * Non-string elements: `extract_unique_words([\\"Hello\\", 123])` should raise `ValueError`. * Empty list: `extract_unique_words([])` should return an empty list `[]`.","solution":"import re def extract_unique_words(sentences): Extract a sorted list of unique words from a list of sentences. :param sentences: list of strings where each string is a sentence. :return: sorted list of unique words in lowercase. if not isinstance(sentences, list): raise TypeError(\\"Input must be a list of strings.\\") words_set = set() # using a set to store unique words for sentence in sentences: if not isinstance(sentence, str): raise ValueError(\\"Each element in the list must be a string.\\") # Remove punctuation and convert to lowercase cleaned_sentence = re.sub(r\'[^ws]\', \'\', sentence).lower() words = cleaned_sentence.split() words_set.update(words) return sorted(words_set)"},{"question":"# Coding Assessment Question You need to implement a function `determine_datasets_split` that splits a given dataset into training, validation, and test sets based on specified proportions. # Function Signature ```python def determine_datasets_split(data: np.ndarray, proportions: dict) -> tuple: pass ``` # Input * `data` (np.ndarray): A NxD numpy array where N is the number of data samples and D is the number of features. * `proportions` (dict): A dictionary with three keys \'train\', \'validation\', and \'test\', representing the proportion of the data to be allocated to each corresponding set. The values should sum up to 1.0. # Output * Returns a tuple of three numpy arrays: (train_data, validation_data, test_data). # Constraints * The sum of the proportions in the `proportions` dictionary must be 1. * Each subset\'s data should be randomly sampled from the original data. * Ensure that the size of each set is correctly calculated based on the input proportions. # Performance Requirements * The splitting should be done in a way that randomly shuffles the data. * Handle large datasets efficiently to avoid excessive memory usage and ensure even distribution according to the given proportions. # Example ```python import numpy as np data = np.array([ [1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12] ]) proportions = { \'train\': 0.5, \'validation\': 0.25, \'test\': 0.25 } train_data, validation_data, test_data = determine_datasets_split(data, proportions) print(f\\"Train data:n{train_data}\\") print(f\\"Validation data:n{validation_data}\\") print(f\\"Test data:n{test_data}\\") ``` Expected output (order may vary due to randomness): ```python Train data: [[ 9 10] [11 12]] Validation data: [[5 6] [7 8]] Test data: [[1 2] [3 4]] ``` # Note * Ensure to shuffle the data before splitting. * Implement error handling for situations such as invalid proportions or empty input data. * Utilize numpy functions to efficiently handle data manipulations.","solution":"import numpy as np def determine_datasets_split(data: np.ndarray, proportions: dict) -> tuple: Splits the dataset into training, validation, and test sets based on the given proportions. Parameters: data (np.ndarray): A NxD numpy array where N is the number of data samples and D is the number of features. proportions (dict): A dictionary with keys \'train\', \'validation\', and \'test\', representing the proportions of the data to be allocated to each set. Returns: tuple: A tuple of three numpy arrays: (train_data, validation_data, test_data). # Check if proportions sum to 1 if not np.isclose(sum(proportions.values()), 1): raise ValueError(\\"Proportions must sum up to 1.\\") # Shuffle the data np.random.shuffle(data) # Calculate sizes for each set total_size = len(data) train_size = int(proportions[\'train\'] * total_size) validation_size = int(proportions[\'validation\'] * total_size) test_size = total_size - train_size - validation_size # Split the data train_data = data[:train_size] validation_data = data[train_size:train_size + validation_size] test_data = data[train_size + validation_size:] return train_data, validation_data, test_data"},{"question":"# Problem Statement You are given a list of integers `nums` and a target integer `target`. Your task is to find all unique combinations of numbers in `nums` where the chosen numbers sum to `target`. Each number in `nums` can be used an unlimited number of times. The combinations should be returned in lexicographical order. # Function Signature ```python def combination_sum(nums: list[int], target: int) -> list[list[int]]: pass ``` # Input - `nums`: A list of integers where each integer is greater than 0. - `target`: An integer representing the target sum. # Output - Return a list of lists containing all unique combinations where the numbers sum to `target`. Each combination should be in ascending order. # Constraints - All input integers in `nums` are positive and distinct. - The length of `nums` will be at most 30. - The target will be at most 500. # Example ```python nums = [2, 3, 6, 7] target = 7 output = combination_sum(nums, target) # Expected output: [[2, 2, 3], [7]] nums = [2, 3, 5] target = 8 output = combination_sum(nums, target) # Expected output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] ``` # Implementation Details - Implement the `combination_sum` function using backtracking to generate the unique combinations. - Ensure to handle edge cases such as an empty list or when no combination is possible. - Ensure the combinations are returned in lexicographical order.","solution":"def combination_sum(nums: list[int], target: int) -> list[list[int]]: def backtrack(start, current_combination, current_sum): if current_sum == target: result.append(list(current_combination)) return if current_sum > target: return for i in range(start, len(nums)): current_combination.append(nums[i]) backtrack(i, current_combination, current_sum + nums[i]) current_combination.pop() nums.sort() result = [] backtrack(0, [], 0) return result"},{"question":"# Question: Implement Depth-First Search to Find All Paths in a Directed Graph You are provided with the implementation of a `DirectedGraph` data structure representing a directed graph. Your task is to implement a function that finds all possible paths from a given start node to a given end node using Depth-First Search (DFS). # Objective Implement the method `find_all_paths` of the `DirectedGraph` class. This method should take two nodes, `start` and `end`, and return a list of lists where each inner list represents a unique path from the `start` node to the `end` node. # Input - An instance of `DirectedGraph`. - A start node `start`. - An end node `end`. # Output - A list of lists, where each list represents a path from `start` to `end`. # Constraints - The graph will have at least one node and can have up to 5,000 nodes and 10,000 edges. - The graph may not necessarily have a path from `start` to `end`. # Performance Requirements - The implementation must handle graphs with the upper constraint limits efficiently. - Aim for an algorithm with a time complexity of O(V + E) for searching paths from `start` to `end`. # Function Signature ```python class DirectedGraph: # ... (other methods in class definition) def find_all_paths(self, start, end): # Your implementation here pass ``` # Example ```python # Example usage of the method after implementation graph = DirectedGraph() graph.add_pair(0, 1) graph.add_pair(0, 2) graph.add_pair(1, 2) graph.add_pair(1, 3) graph.add_pair(2, 3) graph.add_pair(3, 4) paths = graph.find_all_paths(0, 3) print(paths) # Output should be [[0, 1, 3], [0, 1, 2, 3], [0, 2, 3]] ``` # Notes - Input validation is not required. - The graph may contain cycles, handle them appropriately to avoid infinite loops. - The order of the paths in the output list does not matter.","solution":"class DirectedGraph: def __init__(self): self.graph = {} def add_pair(self, start, end): if start not in self.graph: self.graph[start] = [] self.graph[start].append(end) def find_all_paths(self, start, end): paths = [] self._dfs_find_all_paths(start, end, [], paths) return paths def _dfs_find_all_paths(self, current, end, path, paths): path = path + [current] if current == end: paths.append(path) return if current not in self.graph: return for neighbor in self.graph[current]: if neighbor not in path: # avoid cycles self._dfs_find_all_paths(neighbor, end, path, paths)"},{"question":"# Finding Unique Elements and Their Counts You are tasked with creating a function that identifies unique elements in a given list of integers and returns their counts in the order they first appear. # Task 1. **unique_elements_count**: Write a function `unique_elements_count(numbers: List[int]) -> List[Tuple[int, int]]` that takes a list of integers and returns a list of tuples. Each tuple contains a unique element from the input list and the count of its occurrences, in the order they first appear. # Expected Input and Output Format Input: * For `unique_elements_count(numbers: List[int]) -> List[Tuple[int, int]]`: - `numbers` is a list of integers. Output: * For `unique_elements_count(numbers: List[int]) -> List[Tuple[int, int]]`: - Returns a list of tuples where each tuple consists of two elements: * The unique integer from the input list. * The count of its occurrences in the list. # Constraints and Limitations - The list can be empty, in which case the function should return an empty list. - The list may contain negative numbers and zeros. - The function should maintain the order of first appearances of the unique elements. # Example Example 1: ```python assert unique_elements_count([4, 5, 6, 4, 5, 6, 7]) == [(4, 2), (5, 2), (6, 2), (7, 1)] ``` Example 2: ```python assert unique_elements_count([1, 1, 2, 2, 3, 3, 4, 4, 5]) == [(1, 2), (2, 2), (3, 2), (4, 2), (5, 1)] ``` Example 3: ```python assert unique_elements_count([]) == [] ``` # Notes: 1. The input list may be long, so consider the efficiency of your solution. 2. The order of the output should respect the order of the first occurrences from the input list. 3. The returned list should contain only tuples with unique elements and their corresponding counts. # Python Function Signature: ```python from typing import List, Tuple def unique_elements_count(numbers: List[int]) -> List[Tuple[int, int]]: # Your code here ```","solution":"from typing import List, Tuple def unique_elements_count(numbers: List[int]) -> List[Tuple[int, int]]: element_count = {} order_of_first_appearance = [] for num in numbers: if num not in element_count: order_of_first_appearance.append(num) element_count[num] = element_count.get(num, 0) + 1 return [(num, element_count[num]) for num in order_of_first_appearance]"},{"question":"Problem Statement **Circular Array Rotation** You are given an array of integers and a number of rotations to perform on the array. Each rotation moves the elements in the array one position to the right. Your task is to return a new array representing the original array after the specified number of rotations. # Input Your function should take two arguments: 1. **array** (`List[int]`): List of integers. 2. **rotations** (`int`): Number of times to rotate the array. # Output A list of integers representing the rotated array. # Constraints * ( 1 leq text{len(array)} leq 10^5 ) * ( 0 leq text{rotations} leq 10^5 ) * If the rotations are greater than the length of the array, rotations should effectively be ((text{rotations} mod text{len(array)})). # Examples ```python # Example 1: print(circular_array_rotation([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] # Example 2: print(circular_array_rotation([7, 8, 9], 4)) # Output: [9, 7, 8] # Example 3: print(circular_array_rotation([10, 20, 30, 40], 0)) # Output: [10, 20, 30, 40] # Example 4: print(circular_array_rotation([1, 2, 3, 4, 5], 5)) # Output: [1, 2, 3, 4, 5] ``` # Submission Implement your solution in the function `circular_array_rotation`. Ensure it handles the given constraints and edge cases effectively.","solution":"def circular_array_rotation(array, rotations): Perform circular rotation on the array. Parameters: array (List[int]): List of integers. rotations (int): Number of rotations to perform. Returns: List[int]: Rotated array. n = len(array) rotations = rotations % n # Effective rotations needed if rotations == 0: return array return array[-rotations:] + array[:-rotations] # Examples: print(circular_array_rotation([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(circular_array_rotation([7, 8, 9], 4)) # Output: [9, 7, 8] print(circular_array_rotation([10, 20, 30, 40], 0)) # Output: [10, 20, 30, 40] print(circular_array_rotation([1, 2, 3, 4, 5], 5)) # Output: [1, 2, 3, 4, 5]"},{"question":"# Coding Assessment Question Scenario You are part of a team developing a logistics and delivery platform that tracks the inventory and sales of various items across multiple warehouses. To simplify the management of this system, you need to create a utility that processes the stock data and generates a report of the items that are running low on stock. Objective Write a function `low_stock_items(file_path, threshold)` that: - Takes a `file_path` (string) pointing to a CSV file containing inventory data for various items. Each row in the file represents an item and its stock quantity. - Takes an integer `threshold` to specify the stock quantity below which items are considered low stock. Function Signature ```python def low_stock_items(file_path: str, threshold: int) -> list: pass ``` Input - The CSV file (referred to by `file_path`) has the following format: ``` item_name,stock_quantity Example Item 1,10 Example Item 2,25 ``` where `item_name` is a string, and `stock_quantity` is an integer. - `threshold` (0 ≤ threshold ≤ 10000): The quantity below which an item is deemed low on stock. Output - A list of strings representing the names of the items with stock quantities less than the given `threshold`. If no items are below the threshold, return an empty list. Constraints - Handle edge cases such as an empty file or invalid data gracefully. - Assume the file contains a header row that should be skipped. Example Suppose the file `inventory.csv` contains the following: ``` item_name,stock_quantity Apples,30 Bananas,15 Cherries,7 Dates,50 ``` Calling `low_stock_items(\'inventory.csv\', 20)` should return `[\'Bananas\', \'Cherries\']`. Additional Notes - Ensure the function is robust and handles possible errors in the file format or contents gracefully.","solution":"import csv def low_stock_items(file_path, threshold): low_stock = [] try: with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: item_name = row[\'item_name\'] stock_quantity = int(row[\'stock_quantity\']) if stock_quantity < threshold: low_stock.append(item_name) except Exception as e: print(f\\"An error occurred: {e}\\") return low_stock"},{"question":"# Matrix Diagonal Sum **Scenario**: You work with a large dataset represented in a two-dimensional matrix. One of your tasks is to calculate the sum of elements along the main diagonal of the matrix. The main diagonal consists of elements that run from the top-left to the bottom-right of the matrix. **Task**: Implement a function that calculates the sum of elements along the main diagonal of a square matrix. **Function Signature**: ```python def diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the main diagonal elements of a square matrix. Args: matrix (list[list[int]]): a square matrix of integers. Returns: int: the sum of the main diagonal elements. ``` **Input**: - `matrix`: a 2D list of integers where `1 <= len(matrix) <= 1000` and each sublist within `matrix` has the same length as `matrix`. **Output**: - The function should return the sum of the elements along the main diagonal of the matrix. **Constraints**: - The matrix will be a square matrix (number of rows equals number of columns). - Elements of the matrix are integers. **Examples**: ```python # Sample Input/Output 1 >>> diagonal_sum([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 15 # Sample Input/Output 2 >>> diagonal_sum([ [10, 0, 0, 1], [0, 20, 0, 2], [0, 0, 30, 3], [4, 5, 6, 40] ]) 100 # Sample Input/Output 3 >>> diagonal_sum([ [1] ]) 1 # Sample Input/Output 4 >>> diagonal_sum([ [2, 2], [2, 2] ]) 4 # Sample Input/Output 5 >>> diagonal_sum([ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]) 3 ``` **Requirements**: - The solution should handle edge cases efficiently. - Include test cases for validation.","solution":"def diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the main diagonal elements of a square matrix. Args: matrix (list[list[int]]): a square matrix of integers. Returns: int: the sum of the main diagonal elements. return sum(matrix[i][i] for i in range(len(matrix)))"},{"question":"# Coding Challenge: Implementing a Sorting Algorithm You have been provided a partially implemented function to sort a list of integers using the Merge Sort algorithm. Your task is to complete the implementation to ensure the function sorts the list correctly. # Task **Function to Implement:** ```python def merge_sort(arr): Given a list of integers `arr`, returns a new list that contains all the elements, sorted in non-decreasing order. Parameters: arr (list): The list of integers to be sorted. Returns: list: A new list containing all the elements from `arr` in sorted order. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists `left` and `right` into one sorted list. Parameters: left (list): A sorted list of integers. right (list): A sorted list of integers. Returns: list: A merged list containing all the elements from `left` and `right` in sorted order. merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged ``` **Expected Input and Output:** - **Input**: - `arr`: A list of integers to sort. - **Output**: - A new list containing all the elements from `arr` in non-decreasing order. # Constraints - The function must have an average time complexity of O(n log n). - You must not use any built-in sorting functions. # Example ```python print(merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output should be [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] print(merge_sort([12, 11, 13, 5, 6, 7])) # Output should be [5, 6, 7, 11, 12, 13] print(merge_sort([])) # Output should be [] print(merge_sort([-1, -3, 4, 0, 2])) # Output should be [-3, -1, 0, 2, 4] ``` # Implementation Notes - Ensure that the `merge_sort` function makes use of recursion to divide the array and merge the sorted halves. - Ensure that the `merge` helper function correctly combines two sorted lists into one sorted list.","solution":"def merge_sort(arr): Given a list of integers `arr`, returns a new list that contains all the elements, sorted in non-decreasing order. Parameters: arr (list): The list of integers to be sorted. Returns: list: A new list containing all the elements from `arr` in sorted order. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists `left` and `right` into one sorted list. Parameters: left (list): A sorted list of integers. right (list): A sorted list of integers. Returns: list: A merged list containing all the elements from `left` and `right` in sorted order. merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged"},{"question":"# Binary Search Tree: Find K-th Smallest Element Context: You are tasked with working on a web application\'s backend to support an analytical dashboard that displays statistics on a large dataset. One of the features requires finding the K-th smallest element from a dynamically changing dataset. To efficiently manage this, you decide to use a Binary Search Tree (BST) structure due to its efficient in-order traversal properties. Problem: Given a Binary Search Tree (BST), implement a method `find_kth_smallest` that finds the K-th smallest element in the tree. Specifications: 1. **Function Signature:** ```python def find_kth_smallest(self, k: int) -> Any: Find and return the K-th smallest element in the BST. :param k: An integer representing the position (1-indexed) of the smallest element to find. :return: The K-th smallest element. ``` 2. **Input:** - `k`: An integer where 1 ≤ k ≤ N (N is the number of elements in the BST). 3. **Output:** - The K-th smallest element in the BST. 4. **Constraints:** - The BST will contain unique values. - Assume the method will always be called with a valid `k` (1 ≤ k ≤ N). Example Usage: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): # Method to insert value into the BST pass def find_kth_smallest(self, k): # Your implementation here pass # Example Tree: # 5 # / # 3 7 # / / # 2 4 6 8 bst = BinarySearchTree() # Insert elements to create the BST bst.insert(5) bst.insert(3) bst.insert(2) bst.insert(4) bst.insert(7) bst.insert(6) bst.insert(8) # Find the 3rd smallest element result = bst.find_kth_smallest(3) print(result) # Output: 4 ``` **Important:** - Ensure the implementation efficiently handles the retrieval of the K-th smallest element. - Consider the edge cases like finding the first and the last elements. - Raise appropriate exceptions or return suitable messages if the BST is empty (though input constraints ensure it\'s not the case here).","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def find_kth_smallest(self, k): def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right) in_order = inorder_traversal(self.root) return in_order[k - 1] # k - 1 to account for zero-based indexing"},{"question":"# Coding Assessment Question You are tasked with creating a function to evaluate the total resistance of resistors connected in different configurations: series and parallel. The function should compute the total resistance based on the given list of resistances and the specified configuration. Function Specification Function Name: `total_resistance` Parameters: - `resistances` (List[float]): A list of resistance values (in ohms). - `configuration` (str): The configuration type, which can either be `\'series\'` or `\'parallel\'`. Returns: - A float representing the total resistance in the specified configuration. Constraints - The `resistances` list will contain at least one resistance value. - All resistance values will be positive floats. - The `configuration` string will be either `\'series\'` or `\'parallel\'`. Exception Handling - Raise a `ValueError` if `configuration` is neither `\'series\'` nor `\'parallel\'`. Examples ```python >>> total_resistance([100, 200, 300], \'series\') 600.0 >>> total_resistance([100, 200, 300], \'parallel\') 54.54545454545455 >>> total_resistance([50, 50], \'series\') 100.0 >>> total_resistance([50, 50], \'parallel\') 25.0 ``` Write the function `total_resistance` to solve the problem using the constraints and requirements provided.","solution":"def total_resistance(resistances, configuration): Calculate the total resistance of resistors in series or parallel configuration. Args: resistances (list of float): The list of individual resistances. configuration (str): The type of configuration (\'series\' or \'parallel\') Returns: float: The total resistance in the specified configuration. if configuration == \'series\': return sum(resistances) elif configuration == \'parallel\': reciprocal_sum = sum(1.0/r for r in resistances) return 1.0 / reciprocal_sum else: raise ValueError(\\"Configuration must be either \'series\' or \'parallel\'\\")"},{"question":"# Coding Assessment Question Unique Paths in a Grid You are required to implement a function that calculates the number of unique paths to traverse a `m x n` grid. The traveler starts at the top-left corner of the grid (cell `(1, 1)`) and aims to reach the bottom-right corner of the grid (cell `(m, n)`). The traveler can only move either down or right at any point in time. Function Signature ```python def unique_paths(m: int, n: int) -> int: pass ``` Input - Two integers, `m` and `n` (1 <= m, n <= 100) Output - An integer representing the number of unique paths from the start (top-left corner) to the destination (bottom-right corner). Constraints - Ensure that both `m` and `n` are positive integers. - Consider edge cases such as `m = 1` or `n = 1` where there is only one row or one column. Example ```python assert unique_paths(3, 7) == 28, \\"Test case 1 failed\\" assert unique_paths(3, 2) == 3, \\"Test case 2 failed\\" assert unique_paths(7, 3) == 28, \\"Test case 3 failed\\" ``` Notes - The solution should focus on efficiency and handle large values of `m` and `n` gracefully. - You may use dynamic programming to solve this problem. - Consider implementing the solution in a way that minimizes time and space complexity. - You can include additional helper functions if necessary. Good luck, and may your path to success be unique and straightforward!","solution":"def unique_paths(m: int, n: int) -> int: Calculates the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: Number of unique paths to reach the bottom-right corner from the top-left corner. # Create a 2D list initialized to 1 because there\'s only one way to reach any cell in the first row/column dp = [[1]*n for _ in range(m)] # Fill in the dp table row by row for i in range(1, m): for j in range(1, n): # The number of ways to reach dp[i][j] is the sum of the ways to reach the cell directly above it and the cell directly to the left of it dp[i][j] = dp[i-1][j] + dp[i][j-1] # The answer is in the bottom-right corner of the dp array return dp[m-1][n-1]"},{"question":"# Problem: Count Unique Substrings Given a string ( s ), implement a function to calculate the number of unique substrings of ( s ). Use a suffix array and a longest common prefix (LCP) array for an efficient solution. **Input Format** - A single input line containing the string ( s ) (1 ≤ |s| ≤ 10^5), consisting of lowercase English letters only. **Output Format** - Return the number of unique substrings in the given string. **Constraints** - The time complexity of your solution should be O(n log n), where ( n ) is the length of the string ( s ). - Memory usage should be efficient and within reasonable bounds. **Example** *Input:* ``` abcab ``` *Output:* ``` 12 ``` # Detailed Requirements 1. Implement a function `suffix_array_construction` which constructs the suffix array of the given string. 2. Implement a function `lcp_array` which constructs the longest common prefix array using the suffix array. 3. Implement the `count_unique_substrings` function which uses the suffix and LCP arrays to calculate the number of unique substrings.","solution":"def suffix_array_construction(s): n = len(s) suffixes = sorted((s[i:], i) for i in range(n)) suffix_arr = [suffix[1] for suffix in suffixes] return suffix_arr def lcp_array(s, suffix_arr): n = len(s) rank = [0] * n lcp = [0] * n for i, suffix in enumerate(suffix_arr): rank[suffix] = i h = 0 for i in range(n): if rank[i] > 0: j = suffix_arr[rank[i] - 1] while (i + h < n and j + h < n and s[i + h] == s[j + h]): h += 1 lcp[rank[i]] = h if h > 0: h -= 1 return lcp def count_unique_substrings(s): n = len(s) suffix_arr = suffix_array_construction(s) lcp = lcp_array(s, suffix_arr) total_substrings = n * (n + 1) // 2 lcp_sum = sum(lcp) return total_substrings - lcp_sum"},{"question":"# Question: Calculate Shortest Paths with Dijkstra\'s Algorithm You need to implement a function that computes the shortest path from a given source node to all other nodes in a weighted, directed graph using Dijkstra\'s algorithm. The graph will be represented as an adjacency list. Function Signature ```python def dijkstra_shortest_paths(graph: dict, source: int) -> dict: ``` Input * `graph`: A dictionary representing a weighted, directed graph where keys are vertex identifiers and values are lists of tuples. Each tuple contains a neighboring vertex identifier and the weight of the edge to that neighbor. * `source`: An integer representing the starting vertex for the shortest paths calculation. Output * A dictionary where keys are vertex identifiers and values are the shortest distance from the source to that vertex. Constraints * The graph will have at most 10^3 vertices and 10^4 edges. * The vertex identifiers are non-negative integers. * Edge weights are positive integers. Requirements 1. Implement Dijkstra\'s algorithm using a priority queue to ensure efficiency. 2. Handle cases where some nodes are unreachable from the source by assigning a distance of `float(\'inf\')` to them. # Example ```python test_graph_1 = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [], 4: [(5, 1)], 5: [(4, 2)] } test_graph_2 = { 0: [(1, 1)], 1: [(2, 2)], 2: [(3, 1)], 3: [(4, 3)], 4: [] } assert dijkstra_shortest_paths(test_graph_1, 0) == {0: 0, 1: 3, 2: 1, 3: 4, 4: float(\'inf\'), 5: float(\'inf\')} assert dijkstra_shortest_paths(test_graph_2, 0) == {0: 0, 1: 1, 2: 3, 3: 4, 4: 7} assert dijkstra_shortest_paths(test_graph_2, 3) == {0: float(\'inf\'), 1: float(\'inf\'), 2: float(\'inf\'), 3: 0, 4: 3} ```","solution":"import heapq def dijkstra_shortest_paths(graph: dict, source: int) -> dict: Compute the shortest path from a given source node to all other nodes in a weighted, directed graph using Dijkstra\'s algorithm. :param graph: A dictionary representing a weighted, directed graph where keys are vertex identifiers and values are lists of tuples. Each tuple contains a neighboring vertex identifier and the weight of the edge to that neighbor. :param source: An integer representing the starting vertex for the shortest paths calculation. :return: A dictionary where keys are vertex identifiers and values are the shortest distance from the source to that vertex. # Initialize distances to all vertices as infinity and to source as 0 distances = {vertex: float(\'inf\') for vertex in graph} distances[source] = 0 # Priority queue to explore the closest node first priority_queue = [(0, source)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the popped vertex has already a greater distance, continue if current_distance > distances[current_vertex]: continue # Explore neighbors and update their shortest paths for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Problem Statement Write a function that takes a string as input and returns a new string where each character in the original string is doubled. For instance, if the input string is \\"hello\\", the output should be \\"hheelllloo\\". # Constraints 1. The input string will contain at least one character. 2. You need to handle strings containing up to 1000 characters efficiently. # Function Signature ```python def double_characters(input_string): pass ``` # Input * A string `input_string` containing alphabetical characters (both uppercase and lowercase). # Output * A new string where each character from the input string is doubled. # Example ```python input_string = \\"hello\\" # Example usage of the provided function doubled_string = double_characters(input_string) print(doubled_string) ``` # Expected Output ```plaintext hheelllloo ``` # Explanation 1. Implement the `double_characters` function to generate a new string where each character from the input string is duplicated. 2. Ensure that your solution handles edge cases, such as an empty string or strings with special characters. 3. Optimize for both time and space complexity while keeping the code clean and readable.","solution":"def double_characters(input_string): Returns a new string where each character in the original string is doubled. return \'\'.join([char * 2 for char in input_string])"},{"question":"# Problem Description: You need to implement a function `sum_of_squares_of_primes` which takes a list of integers as an input. The function should filter out prime numbers from the list, compute the square of each prime, and then return the sum of these squares. # Input/Output: - **Input**: - A list of integers where each integer is greater than 0. - **Output**: - An integer representing the sum of the squares of the prime numbers in the input list. # Example: ```python sum_of_squares_of_primes([10, 11, 13, 12]) # Expected Output: 290 ``` # Constraints: - The input list can contain up to 10,000 integers. - Each integer in the list is between 1 and 1,000,000. # Requirements: 1. Validate that the input is a list of positive integers. 2. Raise appropriate exceptions for invalid inputs. 3. Ensure the function works efficiently even for larger inputs within constraints. # Implementation Guidance: You already have the `is_prime` function implemented. Use it to check if numbers are prime before proceeding with the calculation. ```python def is_prime(number): # Function to check if `number` is a prime number # Assume this function is already implemented pass def sum_of_squares_of_primes(numbers): Takes a list of integers and returns the sum of squares of prime numbers in the list. :param numbers: List[int] - list of positive integers :return: int - sum of the squares of the prime numbers # Write your implementation here pass if __name__ == \\"__main__\\": assert sum_of_squares_of_primes([10, 11, 13, 12]) == 290 assert sum_of_squares_of_primes([2, 3, 5, 7, 8]) == 87 # Additional tests ```","solution":"from math import isqrt def is_prime(number): Checks if a number is prime. :param number: int :return: bool if number <= 1: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, isqrt(number) + 1, 2): if number % i == 0: return False return True def sum_of_squares_of_primes(numbers): Takes a list of integers and returns the sum of squares of prime numbers in the list. :param numbers: List[int] - list of positive integers :return: int - sum of the squares of the prime numbers if not all(isinstance(num, int) and num > 0 for num in numbers): raise ValueError(\\"Input must be a list of positive integers.\\") return sum(num ** 2 for num in numbers if is_prime(num))"},{"question":"# Majority Element Finder Objective Implement a function to find the majority element in an array using a linear time and constant space algorithm. Task Write a function `find_majority_element(arr: list[int]) -> int`: * **Input**: - A list of integers `arr` (1 ≤ len(arr) ≤ 10^5). * **Output**: - An integer representing the majority element of the array (an element that appears more than `len(arr)//2` times). Function Details # Parameters: `arr`: A list of integers representing the input array. # Returns: An integer representing the majority element in the array. # Description: - Use the Boyer-Moore Voting Algorithm to find the majority element. - Ensure the solution can handle the upper constraint of 10^5 efficiently. Example ```python >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([2, 2, 1, 1, 1, 2, 2]) 2 ``` # Constraints - There must be a majority element in the array. # Notes: - Ensure the implementation handles large datasets efficiently within O(n) time complexity. - The algorithm must use constant space (O(1)).","solution":"def find_majority_element(arr): Returns the majority element in the array using the Boyer-Moore Voting Algorithm. # Boyer-Moore Voting Algorithm initialization candidate = None count = 0 # First pass to find the candidate for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) # The candidate is the majority element, as per the problem\'s constraint return candidate"},{"question":"# Problem Description: Enhance the stack data structure implementation provided by adding a new method to determine the minimum element in the stack without using any auxiliary storage. **Task**: Implement a method min_element which returns the minimum value present in the stack. ```python def min_element(self) -> int: Returns the minimum element in the stack. Time complexity: O(1) @returns: The minimum element in the stack. Example: >>> our_stack = Stack() >>> our_stack.push(3) >>> our_stack.push(5) >>> our_stack.min_element() 3 >>> our_stack.push(2) >>> our_stack.push(1) >>> our_stack.min_element() 1 >>> our_stack.pop() >>> our_stack.min_element() 2 ``` **Input**: - No additional input beyond the state of the stack. **Output**: - An integer representing the minimum element currently in the stack. # Constraints: - The min_element method must operate in constant time (O(1)). - You may modify the existing stack implementation or extend it with additional attributes/methods to maintain the min_element functionality. - Handle edge cases, such as the stack being empty. # Example Consider a sample usage below: ```python # Stack initialization s = Stack() # Performing operations s.push(3) print(s.min_element()) # Output: 3 s.push(5) print(s.min_element()) # Output: 3 s.push(2) print(s.min_element()) # Output: 2 s.push(1) print(s.min_element()) # Output: 1 s.pop() print(s.min_element()) # Output: 2 ``` **Notes**: - Ensure that your stack supports typical operations (push, pop, etc.) properly. - Ensure that the min_element method operates efficiently, without needing to traverse the stack.","solution":"class Stack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value: int): # Push value to the main stack self.stack.append(value) # If the min_stack is empty or the current value is smaller or equal to the last min, push it to min_stack if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() # If the popped value is the minimum, also pop it from min_stack if value == self.min_stack[-1]: self.min_stack.pop() return value def top(self): if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def min_element(self) -> int: if not self.min_stack: raise IndexError(\\"min_element from empty stack\\") return self.min_stack[-1]"},{"question":"# Sum of Squares Difference Background The sum of the squares of the first n natural numbers is given by: [ S1 = sum_{i=1}^n i^2 ] The square of the sum of the first n natural numbers is given by: [ S2 = left( sum_{i=1}^n i right)^2 ] The difference between the square of the sum and the sum of the squares is given by ( D ): [ D = S2 - S1 ] You are given a task to implement a function that computes this difference for a given integer n. Requirements - Write a function `sum_of_squares_difference(n: int) -> int` that takes an integer `n` and returns the difference ( D ) for the first `n` natural numbers. - The function should raise a `ValueError` if `n` is not a positive integer. - The function should raise a `TypeError` if `n` is not an integer. Function Signature ```python def sum_of_squares_difference(n: int) -> int: pass ``` Input - An integer `n` (1 ≤ n ≤ 10^4) Output - Returns an integer which is the difference ( D ). Constraints - The solution must handle the function according to the performance constraints described. It\'s expected to operate efficiently for values of `n` up to 10,000. Example ```python print(sum_of_squares_difference(10)) # Output: 2640 print(sum_of_squares_difference(5)) # Output: 170 print(sum_of_squares_difference(1)) # Output: 0 ``` Notes - Carefully handle the types and edge cases as per the requirements. - Provide suitable test cases when submitting your solution.","solution":"def sum_of_squares_difference(n: int) -> int: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n <= 0: raise ValueError(\\"n must be a positive integer\\") sum_of_squares = sum(i**2 for i in range(1, n + 1)) square_of_sum = sum(range(1, n + 1)) ** 2 difference = square_of_sum - sum_of_squares return difference"},{"question":"# Question Context You are part of a team developing a real-time collaboration platform. One critical feature of this platform is managing user sessions and ensuring that no two users are in conflicting sessions concurrently. To implement this, you need a system that can detect whether any circular dependencies exist among the active user sessions. Task Implement a function `detect_cycle` that takes a directed graph represented as a dictionary and returns a boolean indicating whether the graph contains a cycle. Function Signature ```python def detect_cycle(graph: dict[int, list[int]]) -> bool: ``` - **Input**: * Graph: A dictionary where keys are user session IDs (integers) and values are lists of integers representing dependencies between sessions. - **Output**: * A boolean value `True` if there exists a cycle in the graph, `False` otherwise. - **Constraints**: * The graph will have at most (10^4) vertices and (10^5) edges. * The session IDs (vertices) are integers and are 0-indexed. - **Performance Requirements**: * The solution should run in linear time, (O(V + E)). Example ```python graph = { 0: [1], 1: [2], 2: [0], 3: [4], 4: [5], 5: [] } assert detect_cycle(graph) == True graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } assert detect_cycle(graph) == False ``` Explanation In the first example, there is a cycle involving the vertices {0, 1, 2}, creating a situation where user sessions are dependent on each other in a circular manner. Therefore, the function should return `True`. In the second example, there are no cycles in the graph, so the function should return `False`. Implement the function correctly to detect cycles in the directed graph, ensuring that the platform can manage user sessions effectively without conflicts.","solution":"def detect_cycle(graph: dict[int, list[int]]) -> bool: def dfs(v): if visited[v] == 1: return True if visited[v] == 2: return False visited[v] = 1 for neighbor in graph.get(v, []): if dfs(neighbor): return True visited[v] = 2 return False visited = {v: 0 for v in graph} # 0: not visited, 1: visiting, 2: visited for vertex in graph: if visited[vertex] == 0: if dfs(vertex): return True return False"},{"question":"**Objective**: Write a function to find the length of the longest substring without repeating characters from a given string. **Function Signature**: `def longest_unique_substring(s: str) -> int` **Input**: - `s`: A string containing only English letters (both uppercase and lowercase) and digits. **Output**: - An integer representing the length of the longest substring without repeating characters. **Constraints**: - The length of the input string `s` will be between 1 and 1000. **Performance Requirements**: - The algorithm should run in O(n) time complexity, where n is the length of the string. - The space complexity should be O(min(n, m)), where m is the size of the character set (in this case, 62 since we have 26 uppercase + 26 lowercase + 10 digits). **Example**: ```python s = \\"abcabcbb\\" print(longest_unique_substring(s)) # Expected Output: 3 (The longest substring without repeating characters is \\"abc\\") s = \\"bbbbb\\" print(longest_unique_substring(s)) # Expected Output: 1 (The longest substring without repeating characters is \\"b\\") s = \\"pwwkew\\" print(longest_unique_substring(s)) # Expected Output: 3 (The longest substring without repeating characters is \\"wke\\") ``` **Scenario**: You are building a text editor and need to implement a feature that highlights the longest segment of text where no characters are repeated. This feature will help users identify sections of their text that are diverse in character usage. **Clarifications**: - If the input string consists of a single character or all characters are unique, return the length of the string. - Do not worry about case sensitivity – treat uppercase and lowercase letters as distinct characters.","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string containing English letters (both uppercase and lowercase) and digits. Returns: int: The length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 # Dictionary to store the last positions of each character char_index = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are developing a feature for an e-commerce application that allows users to search for products by submitting queries to an internal search engine API. The API returns a JSON response containing product details that match the search criteria. Your task is to ensure the search function operates correctly through unit testing by mocking these API responses. # Task Using the format shown in the previous example snippet, write a Python function, `test_search_products`, to mock the API response for a GET request using the `requests.get` method. The test should simulate sending query parameters to the endpoint and receiving a JSON response. Requirements: - Create a class `FakeResponse` that mimics the real responses. - Mock the `requests.get` method to return a controlled response (`{\\"products\\":[{\\"id\\":1,\\"name\\":\\"laptop\\",\\"price\\":999.99},{\\"id\\":2,\\"name\\":\\"mouse\\",\\"price\\":25.99}]}`). - Ensure the mock function checks the parameters sent in the get request such as URL and query. - Use the `monkeypatch` fixture to apply the mock. - Verify that the returned response contains the expected keys and value structures. - Handle erroneous scenarios such as invalid query parameters with appropriate assertions. Input and Output: - You don’t need to worry about the input and output format as it\'s a unit test configuration. - If the setup is correct, the unit test should pass without making actual GET requests. Constraints: - Assume the API endpoint URL is `SEARCH_API_ENDPOINT`. - The function to test can be named `search_products` which sends a GET request. - Network operations should be fully mocked. # Example: ```python def search_products(query): params = {\\"q\\": query, \\"sort\\": \\"relevance\\"} response = requests.get(SEARCH_API_ENDPOINT, params=params) return response.json() ``` Create the mock unit test function `test_search_products` for the above example.","solution":"import requests SEARCH_API_ENDPOINT = \\"https://api.example.com/search\\" def search_products(query): Function to search for products using a query string and return the matched products. :param query: The search query string. :return: JSON response from the search API. params = {\\"q\\": query, \\"sort\\": \\"relevance\\"} response = requests.get(SEARCH_API_ENDPOINT, params=params) return response.json()"},{"question":"# K-Means Clustering on Customer Spending Data **Context**: Given a dataset containing customer spending data in a mall, your task is to implement the K-Means clustering algorithm to identify patterns in customer spending behavior. The dataset contains several features such as Customer ID, Age, Annual Income, and Spending Score. # Task: 1. **Data Normalization**: Implement a function to normalize the feature values. 2. **K-Means Algorithm**: Implement the K-Means clustering algorithm to categorize the customers into `k` clusters. 3. **Cluster Visualization**: Visualize the clusters in a 2D space using a suitable pair of features. # Inputs: - **dataset_url**: URL link to the dataset. - **k**: Number of clusters. - **max_iterations**: Maximum number of iterations for K-Means algorithm. - **init_centroids**: Initial centroids selected randomly from the dataset. # Expected Output: - Display the final centroid positions after convergence. - Display the customer distribution among different clusters. - Scatter plot showing the clusters with distinct colors. # Code Constraints: - Use numpy for efficient matrix operations. - Use matplotlib for data visualization. - Ensure your code handles the dataset loading and preprocessing efficiently. - Include meaningful comments and print statements for analysis and debug purposes. Here is the skeleton of the program you need to implement: ```python import numpy as np import matplotlib.pyplot as plt import requests def collect_dataset(url): response = requests.get(url, timeout=10) lines = response.text.splitlines() data = [] for item in lines: item = item.split(\\",\\") data.append(item) data.pop(0) # This is for removing the labels from the list dataset = np.array(data, dtype=float) return dataset def normalize_features(dataset): Normalize features of the dataset. mean = np.mean(dataset[:, 2:], axis=0) std = np.std(dataset[:, 2:], axis=0) normalized_data = (dataset[:, 2:] - mean) / std return np.c_[dataset[:, :2], normalized_data] def initialize_centroids(dataset, k): Randomly select k centroids from the dataset. indices = np.random.choice(dataset.shape[0], k, replace=False) centroids = dataset[indices, :] return centroids def compute_distances(dataset, centroids): Compute the distance between each point and each centroid. distances = np.zeros((dataset.shape[0], centroids.shape[0])) for i in range(centroids.shape[0]): distances[:, i] = np.linalg.norm(dataset[:, 2:] - centroids[i, 2:], axis=1) return distances def assign_clusters(distances): Assign each data point to the nearest centroid. return np.argmin(distances, axis=1) def update_centroids(dataset, clusters, k): Update the centroids as the mean of all points assigned to each cluster. new_centroids = np.zeros((k, dataset.shape[1])) for i in range(k): new_centroids[i, :] = np.mean(dataset[clusters==i, :], axis=0) return new_centroids def kmeans_clustering(dataset, k, max_iterations): centroids = initialize_centroids(dataset, k) for i in range(max_iterations): distances = compute_distances(dataset, centroids) clusters = assign_clusters(distances) new_centroids = update_centroids(dataset, clusters, k) if np.all(centroids == new_centroids): break centroids = new_centroids return clusters, centroids def visualize_clusters(dataset, clusters, centroids): plt.scatter(dataset[:, 2], dataset[:, 3], c=clusters, cmap=\'viridis\', marker=\'o\') plt.scatter(centroids[:, 2], centroids[:, 3], c=\'red\', marker=\'x\', s=200) plt.xlabel(\'Normalized Annual Income\') plt.ylabel(\'Normalized Spending Score\') plt.title(\'K-Means Clustering\') plt.show() def main(): url = \\"https://raw.githubusercontent.com/path/to/your/customer_spending_data.csv\\" data = collect_dataset(url) normalized_data = normalize_features(data) k = 5 # number of clusters max_iterations = 300 clusters, centroids = kmeans_clustering(normalized_data, k, max_iterations) print(\\"Final Centroid Positions: \\") print(centroids) customer_distribution = np.bincount(clusters) print(\\"Customer distribution among clusters: \\", customer_distribution) visualize_clusters(normalized_data, clusters, centroids) if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on correctly implementing data normalization and the K-Means clustering algorithm. - Properly handling convergence criteria for K-Means and ensuring meaningful clustering results. - Clear and concise code with appropriate function naming, comments, and effective data visualization.","solution":"import numpy as np import matplotlib.pyplot as plt import requests import pandas as pd from io import StringIO def collect_dataset(url): response = requests.get(url, timeout=10) df = pd.read_csv(StringIO(response.text)) dataset = df.values return dataset def normalize_features(dataset): Normalize features of the dataset. mean = np.mean(dataset[:, 2:], axis=0) std = np.std(dataset[:, 2:], axis=0) normalized_data = (dataset[:, 2:] - mean) / std return np.c_[dataset[:, :2], normalized_data] def initialize_centroids(dataset, k): Randomly select k centroids from the dataset. indices = np.random.choice(dataset.shape[0], k, replace=False) centroids = dataset[indices, :] return centroids def compute_distances(dataset, centroids): Compute the distance between each point and each centroid. distances = np.zeros((dataset.shape[0], centroids.shape[0])) for i in range(centroids.shape[0]): distances[:, i] = np.linalg.norm(dataset[:, 2:] - centroids[i, 2:], axis=1) return distances def assign_clusters(distances): Assign each data point to the nearest centroid. return np.argmin(distances, axis=1) def update_centroids(dataset, clusters, k): Update the centroids as the mean of all points assigned to each cluster. new_centroids = np.zeros((k, dataset.shape[1])) for i in range(k): new_centroids[i, :] = np.mean(dataset[clusters==i, :], axis=0) return new_centroids def kmeans_clustering(dataset, k, max_iterations): centroids = initialize_centroids(dataset, k) for i in range(max_iterations): distances = compute_distances(dataset, centroids) clusters = assign_clusters(distances) new_centroids = update_centroids(dataset, clusters, k) if np.all(centroids == new_centroids): break centroids = new_centroids return clusters, centroids def visualize_clusters(dataset, clusters, centroids): plt.scatter(dataset[:, 2], dataset[:, 3], c=clusters, cmap=\'viridis\', marker=\'o\') plt.scatter(centroids[:, 2], centroids[:, 3], c=\'red\', marker=\'x\', s=200) plt.xlabel(\'Normalized Annual Income\') plt.ylabel(\'Normalized Spending Score\') plt.title(\'K-Means Clustering\') plt.show() def main(): url = \\"https://raw.githubusercontent.com/path/to/your/customer_spending_data.csv\\" data = collect_dataset(url) normalized_data = normalize_features(data) k = 5 # number of clusters max_iterations = 300 clusters, centroids = kmeans_clustering(normalized_data, k, max_iterations) print(\\"Final Centroid Positions: \\") print(centroids) customer_distribution = np.bincount(clusters) print(\\"Customer distribution among clusters: \\", customer_distribution) visualize_clusters(normalized_data, clusters, centroids) if __name__ == \\"__main__\\": main()"},{"question":"# Task Given a string, write a Python function `find_all_substrings(s: str) -> List[str]` that returns all possible non-empty substrings of the given string sorted in lexicographical order. # Function Signature ```python def find_all_substrings(s: str) -> List[str]: pass ``` # Input * **s**: A string ( s ) of length (1 ≤ ( |s| ) ≤ 200). # Output * Returns a list of all possible non-empty substrings of the given string sorted in lexicographical order. # Constraints * The function should efficiently handle the upper limit of ( s ). * Do not use any built-in Python functions that directly solve the problem. # Example Considering ( s = \\"abc\\" ), the possible non-empty substrings are \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\". So the function should return: ```python >>> find_all_substrings(\\"abc\\") [\'a\', \'ab\', \'abc\', \'b\', \'bc\', \'c\'] ``` # Note Ensure that the output list of substrings is sorted in lexicographical order as shown in the example.","solution":"from typing import List def find_all_substrings(s: str) -> List[str]: Returns all possible non-empty substrings of the given string sorted in lexicographical order. substrings = [] for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.append(s[i:j]) substrings.sort() return substrings"},{"question":"# Maximum Subarray Length with Non-Repeating Characters Develop a function `max_unique_subarray_length` that takes a single string and determines the length of the longest contiguous subarray (substring) comprised of unique characters. This problem requires efficient processing of the string to find the maximum such length without repeating characters. You are expected to implement an algorithm with optimal time complexity, making use of sliding window or similar techniques. # Function Signature ```python def max_unique_subarray_length(s: str) -> int: pass ``` # Input * `s`: A string composed of lowercase English alphabetic characters. # Output * Returns an integer representing the length of the longest contiguous subarray with all unique characters. # Constraints * The input string will have a length up to 10,000 characters. # Examples ```python >>> max_unique_subarray_length(\\"abcabcbb\\") 3 >>> max_unique_subarray_length(\\"bbbb\\") 1 >>> max_unique_subarray_length(\\"pwwkew\\") 3 >>> max_unique_subarray_length(\\"abcdef\\") 6 >>> max_unique_subarray_length(\\"tmttmtctct\\") 3 ``` Ensure that your solution handles strings of varying lengths and contents, and optimally finds the maximum length of contiguous subarrays with unique characters.","solution":"def max_unique_subarray_length(s: str) -> int: Returns the length of the longest contiguous subarray with all unique characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: # Move start to the right of the last occurrence of s[end] start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Trie Data Structure Implementation for Contact List You are given the task of implementing a Trie (prefix tree) data structure that can be used to manage a contact list efficiently. The Trie should support operations for adding contacts and searching for all contacts that share a common prefix. Problem Statement 1. Implement a Trie class `ContactTrie` with the following methods: - `add_contact(name: str) -> None`: This method will add a new contact name to the Trie. - `search_contacts(prefix: str) -> List[str]`: This method will return a list of all contact names that share the given prefix, sorted in lexicographical order. 2. Handle invalid inputs gracefully as per the constraints. Class and Method Signatures ```python class ContactTrie: def __init__(self): pass def add_contact(self, name: str) -> None: pass def search_contacts(self, prefix: str) -> List[str]: pass ``` Input and Output Formats 1. **Class `ContactTrie`**: - No specific input for the constructor. 2. **Method `add_contact(name: str) -> None`**: - **Input**: - `name` (str): A non-empty string representing the contact name to be added. - **Output**: - None 3. **Method `search_contacts(prefix: str) -> List[str]`**: - **Input**: - `prefix` (str): A non-empty string representing the prefix to search for in the contact list. - **Output**: - A list of strings representing contact names that match the given prefix, sorted in lexicographical order. Constraints - On `add_contact`: - `name` must be a non-empty string. - Raise `TypeError` with a suitable message if `name` is not a string. - Raise `ValueError` with a suitable message if `name` is an empty string. - On `search_contacts`: - `prefix` must be a non-empty string. - Raise `TypeError` with a suitable message if `prefix` is not a string. - Raise `ValueError` with a suitable message if `prefix` is an empty string. Scenario and Context You are developing a contact management feature for a messaging application to enable efficient lookup of contacts by their names. This requires implementing an underlying data structure that allows quick insertion and prefix-based search operations. Your solution must handle edge cases, ensure optimal performance, and strictly adhere to the constraints outlined. ---","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class ContactTrie: def __init__(self): self.root = TrieNode() def add_contact(self, name: str) -> None: if not isinstance(name, str): raise TypeError(\\"Contact name must be a string\\") if not name: raise ValueError(\\"Contact name must not be empty\\") node = self.root for char in name: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_contacts(self, prefix: str) -> List[str]: if not isinstance(prefix, str): raise TypeError(\\"Prefix must be a string\\") if not prefix: raise ValueError(\\"Prefix must not be empty\\") node = self._find_node(prefix) if not node: return [] return self._collect_all_words(node, prefix) def _find_node(self, prefix): node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node def _collect_all_words(self, node, prefix): contacts = [] if node.is_end_of_word: contacts.append(prefix) for char, child_node in node.children.items(): contacts.extend(self._collect_all_words(child_node, prefix + char)) return sorted(contacts)"},{"question":"# Fibonacci Number at Position You are required to implement a function that returns the ( n )-th number in the Fibonacci sequence. The Fibonacci sequence is a series of numbers where a number is found by adding up the two numbers before it. Starting from 0 and 1, the sequence goes 0, 1, 1, 2, 3, 5, 8, 13, etc. The sequence is defined as: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n geq 2 ) # Function Signature ```python def fibonacci_number(n: int) -> int: ``` # Input - `n`: An integer representing the position in the Fibonacci sequence. # Output - An integer which is the ( n )-th number in the Fibonacci sequence. # Constraints - ( 0 leq n leq 50 ) # Examples ```python fibonacci_number(0) # Output: 0 fibonacci_number(1) # Output: 1 fibonacci_number(5) # Output: 5 fibonacci_number(10) # Output: 55 fibonacci_number(20) # Output: 6765 ``` **Note**: Ensure that your function handles edge cases such as ( n = 0 ) and large values of ( n ) within the given constraints to provide the correct ( n )-th Fibonacci number efficiently.","solution":"def fibonacci_number(n: int) -> int: Returns the n-th number in the Fibonacci sequence. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Task Create a function that calculates the minimum number of steps required to transform a given string `s` into another string `t` using a specific set of allowed operations. The allowed operations are: 1. Insert a character. 2. Delete a character. 3. Replace a character. This is a classic \\"Edit Distance\\" problem, also known as Levenshtein distance. # Objective Write a function `min_edit_distance` that computes the minimum number of operations required to convert string `s` into string `t`. # Input - `s` (str): The original string. - `t` (str): The target string. # Output - `int`: The minimum number of operations required to convert `s` into `t`. # Constraints 1. The length of strings `s` and `t` will be in the range `0 <= len(s), len(t) <= 500`. 2. The strings will only contain lowercase English letters (\'a\'-\'z\'). # Examples ```python min_edit_distance(\\"kitten\\", \\"sitting\\") # Output: 3 min_edit_distance(\\"flaw\\", \\"lawn\\") # Output: 2 min_edit_distance(\\"intention\\", \\"execution\\") # Output: 5 min_edit_distance(\\"\\", \\"\\") # Output: 0 min_edit_distance(\\"abc\\", \\"\\") # Output: 3 min_edit_distance(\\"\\", \\"xyz\\") # Output: 3 ``` # Guidelines - Use dynamic programming to efficiently solve the problem. - Create a 2D matrix where `dp[i][j]` represents the minimum edit distance between the first `i` characters of `s` and the first `j` characters of `t`. - Use the recurrence relation to fill the matrix: - If `s[i-1] == t[j-1]`, then `dp[i][j] = dp[i-1][j-1]` - Otherwise, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])` (insert, delete, replace respectively) - Optimize space complexity if possible, considering the constraints.","solution":"def min_edit_distance(s, t): Computes the minimum number of operations required to convert string s into string t. Operations allowed: 1. Insert a character. 2. Delete a character. 3. Replace a character. Parameters: s (str): The original string. t (str): The target string. Returns: int: The minimum number of operations required to convert s into t. m, n = len(s), len(t) # Create a 2D array to store the distance values dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the first row and column of the dp array for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the dp values for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1] # Replace ) # The value at dp[m][n] is the minimum edit distance return dp[m][n]"},{"question":"# Problem Statement Create a function `generate_pascals_triangle_row(n)` that generates the nth row of Pascal\'s Triangle. Pascal\'s Triangle is a triangular array of the binomial coefficients. The rows of Pascal\'s Triangle are enumerated starting with row 0 at the top. # Input - An integer `n` (0 ≤ n ≤ 10^3) # Output - A list of integers representing the nth row of Pascal\'s Triangle. # Constraints - The solution should be optimized to handle the input efficiently. # Performance Requirements - Aim for a time complexity of O(n). - Avoid redundant calculations by leveraging properties of binomial coefficients and symmetry within Pascal’s Triangle. # Example ```python print(generate_pascals_triangle_row(3)) # Expected output: [1, 3, 3, 1] print(generate_pascals_triangle_row(5)) # Expected output: [1, 5, 10, 10, 5, 1] ``` # Additional Context Pascal\'s Triangle can be constructed in a row-wise manner where each entry in a row is the sum of the above two entries from the previous row. The nth row can also be computed using the binomial coefficient formula where each element is calculated as: [ C(n, k) = frac{n!}{k!(n-k)!} ] for `k` ranging from 0 to `n`.","solution":"def generate_pascals_triangle_row(n): Returns the nth row of Pascal\'s Triangle. The nth row is represented by the series of binomial coefficients C(n, k) where 0 <= k <= n. if n == 0: return [1] row = [1] current_value = 1 for k in range(1, n + 1): current_value = current_value * (n - k + 1) // k row.append(current_value) return row"},{"question":"# Problem Statement As a data scientist, you are often required to process and analyze large textual datasets. You have been given a dataset containing a large number of documents, where each document is represented as a string. Your task is to implement a word frequency counter that computes the frequency of each word across all documents in a case-insensitive manner. The counter should exclude any punctuation and only consider alphabetic characters. # Function Signature ```python def compute_word_frequencies(documents): Computes the frequency of each word across all documents in a case-insensitive manner. Arguments: documents -- a list of strings, each representing a document. Returns: A dictionary where the keys are words (in lowercase) and the values are their respective frequencies. pass ``` # Input * `documents` (list of strings): The list of document strings. Each document can contain spaces, punctuation, and alphabetic characters. # Output * Dictionary (dict): A dictionary with words (in lowercase) as keys, and their corresponding word frequencies across all documents as values. # Constraints * The number of documents, ( 1 leq text{{len(documents)}} leq 1,000 ) * The length of each document, ( 1 leq text{{len(document)}} leq 10,000 ) # Performance Requirements * Your solution should efficiently process the input within the given constraints. # Example ```python # Define the input documents documents = [ \\"Hello world! This is a test document.\\", \\"This document is a simple test.\\", \\"Is this the real world? Just a fantasy.\\" ] # Call the function word_frequencies = compute_word_frequencies(documents) # Example output # { # \'hello\': 1, # \'world\': 2, # \'this\': 3, # \'is\': 3, # \'a\': 3, # \'test\': 2, # \'document\': 2, # \'simple\': 1, # \'the\': 1, # \'real\': 1, # \'just\': 1, # \'fantasy\': 1 # } ``` # Explanation The function processes each document to strip out punctuation and convert all characters to lowercase, then it counts the occurrences of each word across all documents. The returned dictionary shows the frequency of each word. For example, the word \\"this\\" appears three times across all documents, and \\"fantasy\\" appears once.","solution":"import re from collections import defaultdict def compute_word_frequencies(documents): Computes the frequency of each word across all documents in a case-insensitive manner. Arguments: documents -- a list of strings, each representing a document. Returns: A dictionary where the keys are words (in lowercase) and the values are their respective frequencies. freq_dict = defaultdict(int) for doc in documents: words = re.findall(r\'b[a-zA-Z]+b\', doc) for word in words: freq_dict[word.lower()] += 1 return dict(freq_dict)"},{"question":"# Problem: Implement a Merge Sort Algorithm You need to implement the Merge Sort algorithm, a widely used algorithm with `O(n log n)` time complexity for sorting an array. Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Description Given: - `arr`: A list of integers that needs to be sorted in non-decreasing order. Your implementation should: 1. Return a new list containing all elements from `arr`, sorted in non-decreasing order. # Constraints - `arr` is a list of integers, where `1 <= len(arr) <= 10^5`. - Individual integers in `arr` are in the range `-10^9 <= arr[i] <= 10^9`. # Input/Output Example ```python # Example 1 arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] print(merge_sort(arr)) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2 arr = [10, -1, 2, 5, 0] print(merge_sort(arr)) # Output: [-1, 0, 2, 5, 10] # Example 3 arr = [] print(merge_sort(arr)) # Output: [] ``` # Edge Cases to Consider - Sorting an empty list should return an empty list. - Sorting a list with one element should return the same list. - Handling lists with duplicate elements. # Important Notes - The function should utilize the merge sort algorithm, which recursively divides the list into halves, sorts each half, and then merges the sorted halves back together. - Ensure the implementation efficiently handles the largest constraints given the input size limits.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index = right_index = 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # Append any remaining elements from left or right sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Problem Statement You are required to write a function `get_top_trending_topics(api_endpoint: str, category: str) -> list | None` that fetches and returns a list of top trending topics from a given category using a public API endpoint. # Function Signature ```python def get_top_trending_topics(api_endpoint: str, category: str) -> list | None: pass ``` # Input - **api_endpoint**: A string representing the endpoint of the public API. - **category**: A string representing the category of trends (e.g., \\"technology\\", \\"sports\\"). # Output - Returns a list of dictionaries, where each dictionary contains: ```python { \\"topic\\": \\"Topic Name\\", \\"score\\": 95 } ``` If the input is invalid or an error occurs during fetching or parsing, the function should return `None`. # Constraints - The function should handle network timeouts, HTTP errors, and JSON parsing errors gracefully. - The input strings `api_endpoint` and `category` should not be empty. # Requirements - Validate that both inputs are provided and are not empty strings. - Make an HTTP GET request to the specified API endpoint appending the category as a query parameter. - Parse the JSON response to extract the list of trending topics and their scores. - Handle potential errors gracefully by returning `None`. # Example ```python >>> get_top_trending_topics(\\"https://api.example.com/trending\\", \\"technology\\") [{\'topic\': \'Artificial Intelligence\', \'score\': 98}, {\'topic\': \'Quantum Computing\', \'score\': 85}, ...] ``` # Notes - Consider edge cases such as empty strings for the api_endpoint or category. - Optimize error handling to ensure the function survives typical network or JSON parsing errors.","solution":"import requests def get_top_trending_topics(api_endpoint: str, category: str) -> list | None: if not api_endpoint or not category: return None try: response = requests.get(f\\"{api_endpoint}?category={category}\\", timeout=10) response.raise_for_status() # This will raise an HTTPError if the HTTP request returned an unsuccessful status code data = response.json() if \'topics\' in data: return [{\'topic\': topic[\'name\'], \'score\': topic[\'score\']} for topic in data[\'topics\']] else: return None except (requests.RequestException, ValueError, KeyError): return None"},{"question":"# Problem: Find the Kth Largest Element in an Array Given an array of integers and an integer ( k ), write a function to find the ( k )th largest element in the array. This problem should be solved using the Quickselect algorithm to ensure an average time complexity of ( O(n) ), where ( n ) is the number of elements in the array. **Input Format** - The first input line contains an integer ( n ) (1 ≤ n ≤ 5 cdot 10^4), the size of the array. - The second input line contains ( n ) integers representing the elements of the array with values in the range ([-10^6, 10^6]). - The third input line contains an integer ( k ) (1 ≤ k ≤ n), the position of the largest element to find. **Output Format** - Return the ( k )th largest element in the array. **Constraints** - Ensure the solution employs the Quickselect algorithm specifically. - The function should handle edge cases, such as duplicates and negative numbers, correctly. **Example** *Input:* ``` 6 3 2 1 5 6 4 2 ``` *Output:* ``` 5 ``` **Detailed Requirements** 1. Implement the Quickselect algorithm, leveraging the Lomuto partition scheme for simplicity. 2. Optimize the pivot selection to improve performance on average. 3. Ensure the solution works efficiently within the given constraints, especially for edge cases with large numbers or multiple duplicates. **Solution Strategy** Implement the Quickselect algorithm which combines partitioning logic of QuickSort and makes only one recursive call. Define a helper function for partitioning the array. Ensure correct handling of all corner cases to match the specified complexity requirements.","solution":"import random def kth_largest_element(arr, k): Returns the k-th largest element in the array using the Quickselect algorithm def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all larger elements to the left for i in range(left, right): if arr[i] > pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(left, right, k_smallest): # Base case: the list contains only one element if left == right: return arr[left] # Select a random pivot_index between pivot_index = random.randint(left, right) pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"# Question: Task Scheduling Optimization **Scenario**: Imagine you are tasked with optimizing a task scheduling system where multiple tasks need to be scheduled without an overlap. Each task has a start time and an end time, and you need to allocate these tasks in such a way that maximizes the number of tasks that can be executed. Problem Statement Write a function `maximize_tasks` that takes a list of tasks, where each task is represented by a tuple containing a start time and an end time. The function should return the maximum number of tasks that can be scheduled without overlapping. Function Signature ```python def maximize_tasks(tasks: list[tuple[int, int]]) -> int: pass ``` Input - `tasks`: A list of tuples, where each tuple contains two integers representing the start time and end time of a task. Output - Returns an integer representing the maximum number of tasks that can be scheduled without any overlap. Constraints - Each task\'s `start time` and `end time` will be non-negative integers. - The `start time` of a task is always less than its `end time`. - The number of tasks will not exceed 10^4. Example ```python tasks = [(1, 4), (2, 5), (3, 6), (7, 8), (5, 9), (8, 10)] print(maximize_tasks(tasks)) # Output should be 3, the best schedule would be [(1, 4), (5, 9), (7, 8)] ``` Requirements - Implement an efficient scheduling algorithm to select and count the maximum number of tasks that can be executed without overlapping. - Sort the tasks based on their end times to optimize the task selection process.","solution":"def maximize_tasks(tasks): Maximizes the number of non-overlapping tasks. Args: tasks (list of tuples): List where each tuple is a (start_time, end_time). Returns: int: The maximum number of non-overlapping tasks. # Sort tasks based on their end times tasks.sort(key=lambda x: x[1]) max_tasks = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: max_tasks += 1 last_end_time = end return max_tasks"},{"question":"# Prime Factorization Prime factorization is the process of determining the prime numbers that multiply together to give a given integer. Task Implement two functions `prime_factors` and `is_prime` in Python: 1. `prime_factors(n: int) -> List[int]`: This function should take an integer `n` as input and return its prime factors as a list of integers. 2. `is_prime(n: int) -> bool`: This function should take an integer `n` as input and return `True` if `n` is a prime number, and `False` otherwise. Input/Output * Input: * `n`: An integer, the number to factorize or check for primality. * Output: * For `prime_factors`, return a list of the prime factors of `n`. * For `is_prime`, return a boolean indicating whether `n` is a prime number. Constraints 1. `n` should be a positive integer greater than 1. 2. The function `prime_factors` should handle large numbers efficiently. 3. Use efficient algorithms to check for prime numbers and perform factorization. Examples ```python assert prime_factors(28) == [2, 2, 7] assert prime_factors(13195) == [5, 7, 13, 29] assert prime_factors(17) == [17] assert is_prime(29) == True assert is_prime(30) == False assert is_prime(31) == True ``` Ensure edge cases and invalid inputs are handled appropriately, and provide comprehensive unit tests for various scenarios.","solution":"def is_prime(n): Returns True if the number is prime, otherwise False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_factors(n): Returns a list of prime factors of the number. factors = [] # Check for number of 2s while n % 2 == 0: factors.append(2) n //= 2 # Check for number of 3s while n % 3 == 0: factors.append(3) n //= 3 # Check for other primes i = 5 while i * i <= n: while n % i == 0: factors.append(i) n //= i while n % (i + 2) == 0: factors.append(i + 2) n //= (i + 2) i += 6 if n > 1: factors.append(n) return factors"},{"question":"# Coding Question: Circular String Matching You need to implement a function that determines whether one string is a circularly shifted version of another string. A circular shift moves characters from the end of the string to the beginning in such a way that no character is lost. Circular String Matching Two strings `str1` and `str2` are considered circularly matched if you can obtain one from the other by performing a series of circular shifts. For example: * The circular shifts of the string \\"abc\\" are: \\"abc\\", \\"bca\\", \\"cab\\". * Therefore, \\"cab\\" is a circularly matched version of \\"abc\\". Input and Output Format * **Input**: Two strings `str1` and `str2`. * **Output**: A boolean value: `True` if `str1` and `str2` are circularly matched, `False` otherwise. Example ```python >>> circular_string_matching(\\"abc\\", \\"cab\\") True >>> circular_string_matching(\\"abcde\\", \\"deabc\\") True >>> circular_string_matching(\\"apple\\", \\"pleap\\") True >>> circular_string_matching(\\"hello\\", \\"olelh\\") False ``` Constraints - The strings will only contain printable ASCII characters. - The maximum length of the strings will not exceed 10^5. - Both strings will be of equal length. Function Signature ```python def circular_string_matching(str1: str, str2: str) -> bool: pass ``` Implement the function `circular_string_matching(str1: str, str2: str) -> bool` to solve the problem as described.","solution":"def circular_string_matching(str1: str, str2: str) -> bool: Determines if two strings are circularly matched versions of each other. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str2 is a circular shift of str1, False otherwise. # A string cannot be a circular shift of another string if their lengths differ if len(str1) != len(str2): return False # Concatenate str1 to itself and see if str2 is a substring of the result doubled_str1 = str1 + str1 return str2 in doubled_str1"},{"question":"# Problem Statement You are tasked with implementing a function `strip_comments` that removes comments from a given source code string. The comments can be either single-line (starting with `//`) or multi-line comments (enclosed with `/* ... */`). The function should ignore comments that appear within string literals. # Function Signature ```python def strip_comments(source_code: str) -> str: ``` # Input 1. `source_code` (str): A string representing the source code that includes comments and string literals. # Output - Returns a string where all the comments have been removed but preserves the code and string literals. # Constraints - The input source code string can be of any length but will consist of standard printable ASCII characters. - The input may include escaped quotes within string literals which should be preserved. - Multiple comments can be present, and they should all be removed appropriately. # Example ```python # Example 1 source_code = \'\'\' int main() { // This is a single-line comment printf(\\"Hello, World!\\"); /* This is a multi-line comment */ return 0; } \'\'\' print(strip_comments(source_code)) # Output: \'\'\' int main() { printf(\\"Hello, World!\\"); return 0; } \'\'\' # Example 2 source_code = \'\'\' const char* str = \\"/* Not a comment */\\"; // Another comment printf(\\"String with // inside\\"); \'\'\' print(strip_comments(source_code)) # Output: \'\'\' const char* str = \\"/* Not a comment */\\"; printf(\\"String with // inside\\"); \'\'\' ``` # Notes - Ensure your implementation correctly handles multiple types of comments within string literals. - Preserve the integrity of the code structure (indentation, line breaks) after removing comments. - Consider edge cases such as comments appearing right at the end of the source code string or nested comments, which are generally not allowed in most programming languages. # Edge Cases to Consider - Empty input string. - Comments within string literals. - Nested comments or comments appearing at the edge of the input. # Testing - Include tests to cover typical use cases and edge cases. - Utilize the `doctest` library to verify your solution. # Sample Tests Example ```python def test_strip_comments(): source_code = \'\'\' int main() { // Single-line comment printf(\\"Hello, World!\\"); /* Multi-line comment */ return 0; } \'\'\' assert strip_comments(source_code) == \'\'\' int main() { printf(\\"Hello, World!\\"); return 0; } \'\'\' source_code = \'\'\' const char* str = \\"/* Not a comment */\\"; // End line comment \'\'\' assert strip_comments(source_code) == \'\'\' const char* str = \\"/* Not a comment */\\"; \'\'\' source_code = \'printf(\\"String with // inside\\");\' assert strip_comments(source_code) == \'printf(\\"String with // inside\\");\' print(\\"All tests passed.\\") test_strip_comments() ```","solution":"def strip_comments(source_code: str) -> str: Removes both single-line (//) and multi-line (/*...*/) comments from the given source code string, while preserving string literals. import re # Regular expression to match comments, while ignoring string literals # This regex uses negative lookbehind to avoid removal inside string literals pattern = r\'((?<!)\\".*?(?<!)\\"|/*.*?*/|//.*?)\' def replacer(match): # If the match is a comment, return an empty string to remove it # Otherwise, return the match itself (string literal) return match.group(1) if match.group(1).startswith(\'\\"\') else \\"\\" # Use regex sub with the defined pattern and replacer function cleaned_code = re.sub(pattern, replacer, source_code, flags=re.DOTALL | re.MULTILINE) return cleaned_code"},{"question":"# Sorting Array of Structures Objective You are required to implement a function that sorts an array of structures based on multiple attributes. The sorting should be stable and consistent following the specified order of attributes. Function Signature ```python def sort_structures(data: list[dict], sort_by: list[str]) -> list[dict]: ``` Input - `data`: A list of dictionaries, where each dictionary represents a structure with multiple attributes and their corresponding values. - Each dictionary will have keys as attribute names (strings). - `sort_by`: A list of strings representing the attribute names to sort by, in the order of sorting priority. Output - The function should return a new list of dictionaries sorted based on the attributes specified in `sort_by`. Constraints - Dictionary attribute values can be integers, strings, or floats. - Sorting should be done in ascending order by default. - Each dictionary in the list contains the same set of keys. - The length of the `data` list will be between 1 and 1000. Example ```python structures = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85.5}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90.0}, {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"score\\": 88.0}, {\\"name\\": \\"David\\", \\"age\\": 35, \\"score\\": 80.0} ] sort_by = [\\"age\\", \\"score\\"] sorted_data = sort_structures(structures, sort_by) # Returns: [ # {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 88.0}, # {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"score\\": 90.0}, # {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85.5}, # {\\"name\\": \\"David\\", \\"age\\": 35, \\"score\\": 80.0} # ] sort_by = [\\"score\\"] sorted_data = sort_structures(structures, sort_by) # Returns: [ # {\\"name\\": \\"David\\", \\"age\\": 35, \\"score\\": 80.0}, # {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85.5}, # {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"score\\": 88.0}, # {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90.0} # ] ``` Additional Context The function should make use of stable sorting algorithms to ensure the order of items with equal sort key remains unchanged. This may include using techniques such as tuple comparison or chained comparisons to handle multiple sort keys effectively. Available Python libraries and functions like `sorted` with custom `key` functions can be utilized to achieve the desired outcome.","solution":"def sort_structures(data: list[dict], sort_by: list[str]) -> list[dict]: Sorts a list of dictionaries based on multiple attributes provided in sort_by. Args: data: List[Dict], a list of dictionaries to sort. sort_by: List[str], a list of attribute names to sort by, in order of priority. Returns: List[Dict], sorted list of dictionaries. def sort_key(item): return tuple(item[attr] for attr in sort_by) return sorted(data, key=sort_key)"},{"question":"# Coding Assessment Question Task You are required to write a Python function to simulate a simplified text-based game where multiple players take turns to roll a virtual die. The player with the highest cumulative score after a given number of rounds wins. Function Specifications Write a function `dice_game(players: List[str], rounds: int) -> dict` that: * Takes two inputs: * `players` (list of strings): A list containing the names of the players. * `rounds` (integer): The number of rounds to be played. * Returns a dictionary with the following keys: * \\"winner\\" (string): The name of the player with the highest score. * \\"scores\\" (dictionary): A dictionary where each key is a player\'s name and the value is their corresponding score. Constraints * Each player rolls a standard six-sided die once per round. * Use the `random` library to simulate die rolls. * Ensure that the function is fair and handles ties appropriately (if there\'s a tie, the function should return one of the winners arbitrarily). * The function should validate inputs and handle edge cases such as an empty player list or zero/negative rounds gracefully. * Each player\'s score is the sum of their die rolls across all rounds. Example **Input:** ```python players = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] rounds = 5 result = dice_game(players, rounds) print(result) ``` **Expected Output:** ```python { \\"winner\\": \\"Bob\\", \\"scores\\": { \\"Alice\\": 17, \\"Bob\\": 21, \\"Charlie\\": 19 } } ``` Note: The actual scores and winner may vary because of the random nature of die rolls. Guidelines * Use the `random.randint(1, 6)` function to simulate a die roll. * Ensure code readability and robustness, including appropriate handling of exceptions. * Avoid using any external dependencies outside of Python\'s standard library. Additional Context This simple game simulation can help assess a candidate\'s ability to manage collections (lists and dictionaries), implement basic game logic, and handle randomness in simulations.","solution":"import random from typing import List, Dict def dice_game(players: List[str], rounds: int) -> Dict[str, Dict[str, int]]: if not players or rounds <= 0: return {\\"winner\\": None, \\"scores\\": {player: 0 for player in players}} scores = {player: 0 for player in players} for _ in range(rounds): for player in players: roll = random.randint(1, 6) scores[player] += roll winner = max(scores, key=scores.get) return {\\"winner\\": winner, \\"scores\\": scores}"},{"question":"# Scenario You are tasked with enhancing a matrix manipulation library that supports various mathematical operations on matrices. One of the requirements is to implement a method for finding the transpose of a matrix. Matrix transposition is an important operation in linear algebra, often used in various algorithms and data transformations. # Task Implement a method `transpose()` that transposes a given matrix. Transposing a matrix means converting its rows into columns and vice versa. # Function Signature Implement the method below in a class `Matrix`: ```python def transpose(self) -> List[List[int]]: Calculate the transpose of the matrix. Returns: List[List[int]]: The transposed matrix. ``` # Input * This method relies on the class attribute `self.data`, which is a two-dimensional list representing the matrix. * The matrix (self.data) is a list of N lists, each containing M integers. # Output * A two-dimensional list representing the transposed matrix. # Constraints * 1 <= N, M <= 100 * The matrix can contain any integer values. # Expected Complexity * Expected time complexity is O(N*M), where N is the number of rows and M is the number of columns in the matrix. * Expected space complexity is O(N*M), where N is the number of rows and M is the number of columns in the matrix. # Example Usage ```python # Example matrix matrix_data = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix = Matrix(matrix_data) print(matrix.transpose()) # Expected output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] # Another example matrix_data = [ [1, 2], [3, 4], [5, 6] ] matrix = Matrix(matrix_data) print(matrix.transpose()) # Expected output: [[1, 3, 5], [2, 4, 6]] ``` # Note Ensure that the transposed matrix maintains the correct orientation by swapping rows and columns.","solution":"from typing import List class Matrix: def __init__(self, data: List[List[int]]): self.data = data def transpose(self) -> List[List[int]]: Calculate the transpose of the matrix. Returns: List[List[int]]: The transposed matrix. # Number of rows and columns rows = len(self.data) cols = len(self.data[0]) # Initialize the transposed matrix with switched dimensions transposed = [[0] * rows for _ in range(cols)] # Fill the transposed matrix with transposed values for r in range(rows): for c in range(cols): transposed[c][r] = self.data[r][c] return transposed"},{"question":"# Problem Statement **Scenario**: Alice and Bob are playing a game on a 2D grid of size `n x m`, where some cells contain obstacles, and others are empty. Alice starts at the top-left corner of the grid and needs to reach the bottom-right corner by moving only right or down. However, Bob has placed some obstacles in the grid, and Alice cannot move through these cells. Your task is to help Alice determine the number of distinct paths from the top-left cell to the bottom-right cell, avoiding obstacles. # Task Implement function `count_paths(grid: List[List[int]]) -> int` which takes a 2D list `grid` where `grid[i][j]` is 0 if the cell is empty, and 1 if the cell is an obstacle, and returns the count of distinct paths from the top-left cell to the bottom-right cell. # Requirements * The function must handle invalid inputs, specifically grids with no cells or non-rectangular grids. * The solution must use dynamic programming to efficiently count the paths. # Function Signature ```python def count_paths(grid: List[List[int]]) -> int: Args: grid (List[List[int]]): A 2D list representing the grid with 0 as empty cells and 1 as obstacles. Returns: int: The number of distinct paths from the top-left cell to the bottom-right cell avoiding obstacles. Raises: ValueError: If the grid is empty or non-rectangular. ``` # Constraints * `1 <= len(grid), len(grid[0]) <= 100` * `grid[0][0] == 0` (Alice starts at the top-left corner, which is empty) * `grid[-1][-1] == 0` (Alice needs to reach the bottom-right corner, which is empty) # Example ```python # Example 1 assert count_paths([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) == 2 # Example 2 assert count_paths([ [0, 1], [0, 0] ]) == 1 # Example 3 assert count_paths([ [0, 0], [1, 0] ]) == 1 ``` # Explanation In each example: - **Example 1**: There are two distinct paths Alice can take: - Path 1: Right -> Right -> Down -> Down - Path 2: Down -> Down -> Right -> Right - **Example 2**: The only path Alice can take is: Down -> Right. - **Example 3**: The only path Alice can take is: Right -> Down. **Note**: Ensure your implementation is optimized for the given constraints, using dynamic programming to count the paths efficiently.","solution":"def count_paths(grid): Returns the number of distinct paths from the top-left to the bottom-right corner of the grid, avoiding obstacles. Args: grid (List[List[int]]): A 2D list representing the grid. Returns: int: The number of distinct paths. Raises: ValueError: If the grid is empty or non-rectangular. if not grid or not grid[0]: raise ValueError(\\"Grid is empty or non-rectangular\\") n = len(grid) m = len(grid[0]) # DP table to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left cell to 1 if it\'s not an obstacle if grid[0][0] == 0: dp[0][0] = 1 # Fill the first row for j in range(1, m): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Fill the first column for i in range(1, n): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][m-1]"},{"question":"# Question: Sum of Digits in Base-5 You are given a non-negative integer and tasked with implementing a function that returns the sum of all its digits when it is expressed in base-5. Function Signature ```python def sum_of_digits_base5(number: int) -> int: Calculate the sum of the digits of a non-negative integer when expressed in base-5. Parameters: number (int): A non-negative integer to be converted. Returns: int: The sum of the digits of the provided number in base-5. ``` # Input: * `number`: A non-negative integer (0 ≤ number ≤ 10^6) # Output: * Return an integer representing the sum of the digits of the given number when expressed in base-5. # Examples: ```python sum_of_digits_base5(100) -> 4 # 100 in base-5 is 400, 4 + 0 + 0 = 4 sum_of_digits_base5(43) -> 6 # 43 in base-5 is 133, 1 + 3 + 3 = 7 sum_of_digits_base5(25) -> 2 # 25 in base-5 is 100, 1 + 0 + 0 = 1 sum_of_digits_base5(0) -> 0 # 0 in base-5 is 0, sum of digits is 0 sum_of_digits_base5(981) -> 19 # 981 in base-5 is 12411, 1 + 2 + 4 + 1 + 1 = 9 ``` # Constraints: * The input number will always be a non-negative integer within the given range. # Performance Requirements: * The function should convert the number to base-5 efficiently and sum the digits within acceptable time constraints. # Context: This function can be useful in scenarios that involve alternate base systems and where digital representations must be analyzed or manipulated. The summation of digits in a non-decimal base is a common operation in various counting and encoding tasks. **Note**: * Knowledge of base conversion is essential to solve this problem. * Consider edge cases such as the smallest and largest possible values within the given constraints.","solution":"def sum_of_digits_base5(number: int) -> int: Calculate the sum of the digits of a non-negative integer when expressed in base-5. Parameters: number (int): A non-negative integer to be converted. Returns: int: The sum of the digits of the provided number in base-5. if number == 0: return 0 total = 0 while number > 0: total += number % 5 number //= 5 return total"},{"question":"# Coding Assessment Question **Context**: Sorting algorithms are fundamental to computer science, frequently used in various applications ranging from database query optimization to arranging data in user interfaces. One classic problem is sorting an array of integers in ascending order. Implementing efficient sorting algorithms is a crucial skill for any software developer. **Problem Statement**: Implement a function `merge_sort` that performs the Merge Sort algorithm to sort an array of integers in ascending order. Ensure that the implementation follows the divide-and-conquer strategy for optimal performance. # Function Signature: ```python def merge_sort(arr: list[int]) -> list[int]: pass ``` # Input: * `arr` (list[int]): A list of integers to be sorted. # Output: * Returns a list of integers sorted in ascending order. # Constraints: * The input array will have length within the range `[1, 10^5]`. * The integers in the array will be within the range `[-10^9, 10^9]`. # Performance Requirements: * Time Complexity should be O(n log n), where n is the number of elements in the array. * Space Complexity should be O(n). # Examples: ```python >>> merge_sort([5, 3, 8, 6, 2]) [2, 3, 5, 6, 8] >>> merge_sort([14, -5, 0, 7, 3]) [-5, 0, 3, 7, 14] >>> merge_sort([1]) [1] >>> merge_sort([3, 3, 3, 3]) [3, 3, 3, 3] ``` # Additional Requirements: * Ensure that the function correctly handles arrays with repeated elements. * Implement the Merge Sort algorithm without using any built-in sorting methods. * The function should handle edge cases such as an already sorted array or an array containing negative integers effectively. # Hints: * Think about how you can split the array into smaller subarrays and how to merge them back together in a sorted manner. * Remember to handle base cases, such as an array with a single element, which is inherently sorted.","solution":"def merge_sort(arr: list[int]) -> list[int]: Performs Merge Sort to sort an array of integers in ascending order. if len(arr) <= 1: return arr def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"**Question 2: Traffic Light Simulation** Design and implement a traffic light simulation for a four-way intersection. The traffic lights at each approach (North, East, South, West) should cycle through the states: GREEN, YELLOW, and RED. Implement the simulation such that only one direction can have the GREEN light at any moment, and write functions to determine the state of each light at any given time and to advance the simulation by one unit of time. **Task**: 1. Implement the `TrafficLight` class with methods to initialize the lights, advance the state, and retrieve the current state. 2. Implement the `TrafficIntersection` class to manage four `TrafficLight` instances and ensure only one direction has the GREEN light. 3. Implement a function to simulate the traffic light changes over a given number of time units. **Function Signatures**: 1. `class TrafficLight:` 2. `def __init__(self): -> None` 3. `def advance(self): -> None` 4. `def get_state(self): -> str` 5. `class TrafficIntersection:` 6. `def __init__(self): -> None` 7. `def update(self): -> None` 8. `def get_states(self): -> dict` 9. `def simulate_traffic_lights(time_units: int): -> list[dict]` **Input Format**: - `time_units`: An integer representing the number of time units to simulate. **Output Format**: - A list of dictionaries where each dictionary represents the state of the traffic lights at each time unit. Each dictionary has keys for \\"North\\", \\"East\\", \\"South\\", \\"West\\" with the corresponding light states as values. **Constraints**: - Each `TrafficLight` should cycle through states: GREEN (duration 5 units), YELLOW (duration 2 units), RED (until the cycle comes back to GREEN). - Initially, the North light will be GREEN, East light will be RED, South light will be RED, and West light will be RED. **Example**: ```python # Simulating for 10 time units result = simulate_traffic_lights(10) # Expected Output: [ {\'North\': \'GREEN\', \'East\': \'RED\', \'South\': \'RED\', \'West\': \'RED\'}, {\'North\': \'GREEN\', \'East\': \'RED\', \'South\': \'RED\', \'West\': \'RED\'}, {\'North\': \'GREEN\', \'East\': \'RED\', \'South\': \'RED\', \'West\': \'RED\'}, {\'North\': \'GREEN\', \'East\': \'RED\', \'South\': \'RED\', \'West\': \'RED\'}, {\'North\': \'GREEN\', \'East\': \'RED\', \'South\': \'RED\', \'West\': \'RED\'}, {\'North\': \'YELLOW\', \'East\': \'RED\', \'South\': \'RED\', \'West\': \'RED\'}, {\'North\': \'YELLOW\', \'East\': \'RED\', \'South\': \'RED\', \'West\': \'RED\'}, {\'North\': \'RED\', \'East\': \'GREEN\', \'South\': \'RED\', \'West\': \'RED\'}, {\'North\': \'RED\', \'East\': \'GREEN\', \'South\': \'RED\', \'West\': \'RED\'}, {\'North\': \'RED\', \'East\': \'GREEN\', \'South\': \'RED\', \'West\': \'RED\'} ] ```","solution":"class TrafficLight: def __init__(self): self.states = [\'GREEN\', \'YELLOW\', \'RED\'] self.state_durations = {\'GREEN\': 5, \'YELLOW\': 2, \'RED\': 7} # RED duration will auto-adjust self.current_index = 0 self.time_in_state = 0 def advance(self): self.time_in_state += 1 if self.time_in_state >= self.state_durations[self.states[self.current_index]]: self.time_in_state = 0 self.current_index = (self.current_index + 1) % len(self.states) def get_state(self): return self.states[self.current_index] class TrafficIntersection: def __init__(self): self.directions = [\'North\', \'East\', \'South\', \'West\'] self.lights = {direction: TrafficLight() for direction in self.directions} self.active_light = 0 # 0 for North, 1 for East, 2 for South, 3 for West for i in range(1, len(self.directions)): self.lights[self.directions[i]].current_index = 2 # Set others to RED def update(self): # Advance the active light and check if it needs to change current_direction = self.directions[self.active_light] self.lights[current_direction].advance() # Check if current light is transitioning from YELLOW to RED if self.lights[current_direction].get_state() == \'RED\': self.active_light = (self.active_light + 1) % len(self.directions) self.lights[self.directions[self.active_light]].current_index = 0 # Set to GREEN self.lights[self.directions[self.active_light]].time_in_state = 0 def get_states(self): return {direction: self.lights[direction].get_state() for direction in self.directions} def simulate_traffic_lights(time_units: int) -> list[dict]: intersection = TrafficIntersection() states_over_time = [] for _ in range(time_units): states_over_time.append(intersection.get_states()) intersection.update() return states_over_time"},{"question":"# Question Context You are developing a software that involves organizing data in an optimal way. One task that you have encountered is scheduling. You need to find the maximum number of activities that can be performed by a single person, assuming that the person can only work on one activity at a time. Task Implement a function `max_activities` that selects the maximum number of activities that can be performed by a single person. Each activity has a start and end time, and activities are represented as a list of tuples. Function Signature ```python def max_activities(activities: list[tuple[int, int]]) -> int: ``` - **Input**: * A list of activities, where each activity is represented by a tuple of two integers (start time, end time). - **Output**: * An integer representing the maximum number of non-overlapping activities that can be performed. - **Constraints**: * The list of activities will have at most (10^5) activities. * The start and end times are positive integers and satisfy (1 leq text{start time} < text{end time} leq 10^9). - **Performance Requirements**: * The solution should run in (O(n log n)) time complexity. Example ```python activities = [(1, 2), (3, 4), (0, 6), (5, 7), (8, 9), (5, 9)] assert max_activities(activities) == 4 ``` Explanation In the given list of activities, the maximum number of non-overlapping activities is 4. One possible set of non-overlapping activities is: - (1, 2) - (3, 4) - (5, 7) - (8, 9) Implement the function correctly to find the maximum number of non-overlapping activities.","solution":"def max_activities(activities): if not activities: return 0 # Sort activities based on their end times activities.sort(key=lambda x: x[1]) # The first activity always gets selected count = 1 end_time = activities[0][1] for i in range(1, len(activities)): if activities[i][0] >= end_time: count += 1 end_time = activities[i][1] return count"},{"question":"**Scenario:** You are tasked with developing an automated system for an online bookstore. This system needs to manage and convert monetary values between different currencies to accommodate international transactions. The bookstore operates in multiple currencies, including US dollars (USD), Euros (EUR), British Pounds (GBP), Japanese Yen (JPY), and Canadian Dollars (CAD). The system must support conversion rates that are updated periodically. **Task:** Implement a function `currency_converter` that can convert a given monetary value from one currency to another based on provided conversion rates. **Function Signature:** ```python def currency_converter(value: float, from_currency: str, to_currency: str, rates: dict) -> float: pass ``` **Input and Output:** - **Input**: - `value` (float): The value to be converted. - `from_currency` (str): The currency of the given value (ISO 4217 currency code). - `to_currency` (str): The currency to which conversion is required (ISO 4217 currency code). - `rates` (dict): A dictionary containing conversion rates from one currency to others. The keys are currency codes, and the values are dictionaries where the keys are currency codes and the values are the conversion rates (e.g., `{\\"USD\\": {\\"EUR\\": 0.85, \\"GBP\\": 0.75}, \\"EUR\\": {\\"USD\\": 1.18, \\"GBP\\": 0.88}}`). - **Output**: - Returns the converted value as a float. **Constraints/Requirements**: - The function should handle case-insensitive currency codes: e.g., \\"usd\\", \\"USD\\", \\"Usd\\" should be treated the same. - The function should raise an appropriate error if the conversion rate between the specified currencies is not available. **Example**: ```python conversion_rates = { \\"USD\\": {\\"EUR\\": 0.85, \\"GBP\\": 0.75, \\"JPY\\": 110.0, \\"CAD\\": 1.25}, \\"EUR\\": {\\"USD\\": 1.18, \\"GBP\\": 0.88, \\"JPY\\": 129.0, \\"CAD\\": 1.47}, \\"GBP\\": {\\"USD\\": 1.33, \\"EUR\\": 1.14, \\"JPY\\": 147.0, \\"CAD\\": 1.67}, \\"JPY\\": {\\"USD\\": 0.0091, \\"EUR\\": 0.0078, \\"GBP\\": 0.0068, \\"CAD\\": 0.0113}, \\"CAD\\": {\\"USD\\": 0.80, \\"EUR\\": 0.68, \\"GBP\\": 0.60, \\"JPY\\": 88.5} } print(currency_converter(100, \\"USD\\", \\"EUR\\", conversion_rates)) # Expected output: 85.0 print(currency_converter(100, \\"GBP\\", \\"JPY\\", conversion_rates)) # Expected output: 14700.0 print(currency_converter(5000, \\"JPY\\", \\"CAD\\", conversion_rates)) # Expected output: 56.5 print(currency_converter(250, \\"CAD\\", \\"USD\\", conversion_rates)) # Expected output: 200.0 print(currency_converter(50, \\"EUR\\", \\"GBP\\", conversion_rates)) # Expected output: 44.0 ``` Ensure your implementation includes proper error handling for invalid currency codes or unavailable conversion rates.","solution":"def currency_converter(value: float, from_currency: str, to_currency: str, rates: dict) -> float: Converts a given monetary value from one currency to another based on provided conversion rates. Parameters: value (float): The value to be converted. from_currency (str): The currency of the given value (ISO 4217 currency code). to_currency (str): The currency to which conversion is required (ISO 4217 currency code). rates (dict): A dictionary containing conversion rates from one currency to others. Returns: float: The converted value. Raises: ValueError: If the conversion rate between the specified currencies is not available. from_currency = from_currency.upper() to_currency = to_currency.upper() if from_currency not in rates: raise ValueError(f\\"Conversion rates for {from_currency} are not available.\\") if to_currency not in rates[from_currency]: raise ValueError(f\\"Conversion rate from {from_currency} to {to_currency} is not available.\\") conversion_rate = rates[from_currency][to_currency] converted_value = value * conversion_rate return round(converted_value, 2)"},{"question":"# Problem Statement You have been tasked with creating a string compression algorithm that performs basic run-length encoding. The goal is to compress a given string and also decompress it back to its original form using the same encoding scheme. # Function to Implement 1. `compress_string(input_string: str) -> str` 2. `decompress_string(compressed_string: str) -> str` Requirements * **compress_string**: - **Input**: * `input_string` (str): The string to be compressed. (Constraints: lowercase letters only, with no spaces) - **Output**: * Compressed string (str): The compressed version of `input_string` using run-length encoding. * **decompress_string**: - **Input**: * `compressed_string` (str): The compressed string that needs to be decompressed. - **Output**: * Decompressed string (str): The original uncompressed version of the `compressed_string`. Example ```python def test_string_compression(): original = \\"aaabbcdddde\\" compressed = compress_string(original) # The expected compressed string would be \'3a2b1c4d1e\' decompressed = decompress_string(compressed) assert decompressed == original, f\\"Expected \'{original}\' but got \'{decompressed}\'\\" test_string_compression() ``` Explanation 1. **compress_string**: * The function should convert the input string into a compressed format where consecutive characters are replaced by the character followed by the count of its consecutive occurrences. * For example, \\"aaabbcdddde\\" should be compressed to \\"3a2b1c4d1e\\". 2. **decompress_string**: * The function should convert the compressed string back to its original format by expanding characters based on their subsequent counts. * For example, \\"3a2b1c4d1e\\" should be decompressed to \\"aaabbcdddde\\". **Constraints**: - The input string for compression will only contain lowercase English letters. - Ensure that the functions handle edge cases such as an empty string or strings with no repeating characters effectively. **Note**: Detailed handling of specific edge cases like a single character or empty string is crucial for passing the unit tests.","solution":"def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i-1]: count += 1 else: compressed.append(f\\"{count}{input_string[i-1]}\\") count = 1 compressed.append(f\\"{count}{input_string[-1]}\\") return \\"\\".join(compressed) def decompress_string(compressed_string: str) -> str: if not compressed_string: return \\"\\" decompressed = [] count = 0 for char in compressed_string: if char.isdigit(): count = count * 10 + int(char) else: decompressed.append(char * count) count = 0 return \\"\\".join(decompressed)"},{"question":"# Scenario: You have been recruited by a logistics company that manages an extensive fleet of delivery trucks. The company wants to optimize its delivery routes using a graph-based approach. They want you to implement a weighted, directed graph to represent their transportation network and provide functionality for: 1. Adding routes (edges) with specific weights (distances). 2. Removing existing routes. 3. Finding the shortest path between two delivery points (nodes) using Dijkstra\'s algorithm. 4. Determining if the graph has any negative weight cycles using the Bellman-Ford algorithm. # Task Implement the following methods in a class `TransportationNetwork`: 1. `add_route(self, node1: str, node2: str, weight: int) -> None`: * Adds a weighted, directed edge from `node1` to `node2` with the given `weight`. 2. `remove_route(self, node1: str, node2: str) -> None`: * Removes the edge from `node1` to `node2`. 3. `shortest_path(self, start: str, end: str) -> List[str] | None`: * Finds the shortest path from `start` to `end` using Dijkstra\'s algorithm. * Returns the list of nodes in the path if it exists; otherwise, returns `None`. 4. `detect_negative_cycle(self) -> bool`: * Determines if the graph contains any negative weight cycles using the Bellman-Ford algorithm. * Returns `True` if there is a negative weight cycle; otherwise, returns `False`. # Constraints: 1. Each node is represented by a unique string identifier. 2. Edge weights are integers and can be negative. 3. The graph can have up to `10^5` nodes and `10^6` edges. 4. Ensure Dijkstra\'s algorithm maintains an average time complexity of O((E + V) log V). # Example: ```python # Initialize Transportation Network network = TransportationNetwork() # Add routes network.add_route(\\"A\\", \\"B\\", 5) network.add_route(\\"B\\", \\"C\\", 2) network.add_route(\\"A\\", \\"C\\", 9) # Find the shortest path path = network.shortest_path(\\"A\\", \\"C\\") print(path) # Output: [\\"A\\", \\"B\\", \\"C\\"] # Detect negative cycles has_negative_cycle = network.detect_negative_cycle() print(has_negative_cycle) # Output: False # Remove a route network.remove_route(\\"A\\", \\"B\\") # Shortest path after removal path = network.shortest_path(\\"A\\", \\"C\\") print(path) # Output: [\\"A\\", \\"C\\"] ``` **Note**: Avoid using any built-in libraries for graph algorithms.","solution":"import heapq from collections import defaultdict from typing import List, Dict, Tuple import sys class TransportationNetwork: def __init__(self) -> None: self.graph: Dict[str, List[Tuple[str, int]]] = defaultdict(list) def add_route(self, node1: str, node2: str, weight: int) -> None: self.graph[node1].append((node2, weight)) def remove_route(self, node1: str, node2: str) -> None: self.graph[node1] = [(n, w) for n, w in self.graph[node1] if n != node2] def shortest_path(self, start: str, end: str) -> List[str] | None: queue = [(0, start, [])] visited = set() min_dist = {start: 0} while queue: (cost, node, path) = heapq.heappop(queue) if node in visited: continue visited.add(node) path = path + [node] if node == end: return path for next_node, weight in self.graph[node]: if next_node in visited: continue prev_cost = min_dist.get(next_node, float(\'inf\')) next_cost = cost + weight if next_cost < prev_cost: min_dist[next_node] = next_cost heapq.heappush(queue, (next_cost, next_node, path)) return None def detect_negative_cycle(self) -> bool: distances = {node: float(\'inf\') for node in self.graph} for node in self.graph: distances[node] = 0 break # Start with first node available for _ in range(len(self.graph) - 1): for node in self.graph: for neighbor, weight in self.graph[node]: if distances[node] + weight < distances[neighbor]: distances[neighbor] = distances[node] + weight for node in self.graph: for neighbor, weight in self.graph[node]: if distances[node] + weight < distances[neighbor]: return True return False"},{"question":"# Coding Task: Implementing a Min-Heap for Optimized Kth Smallest Element Retrieval __Context:__ In many scenarios, finding the k-th smallest element in a collection of numbers is a common problem that can be tackled efficiently with the appropriate data structure. One such structure is the Min-Heap, which allows for efficient element extraction and insertion. __Question:__ Implement a function to find the k-th smallest element in an unsorted list of integers using a Min-Heap. Ensure that your implementation efficiently manages the heap operations. __Expected Input and Output:__ - **Input**: A list of integers and an integer `k` (1 ≤ k ≤ length of list). - **Output**: An integer representing the k-th smallest element in the list. __Constraints:__ - The input list can contain any integer values, both positive and negative. - The length of the input list will be within the range of 1 to 10^4. __Performance Requirements:__ - Your solution should make use of a Min-Heap to achieve O(n log k) time complexity. __Function Signature:__ ```python def kth_smallest_element(arr: list[int], k: int) -> int: pass ``` __Example:__ ```python >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10 >>> kth_smallest_element([1], 1) 1 >>> kth_smallest_element([12, 3, 5, 7, 19], 2) 5 ``` __Additional Notes:__ 1. Focus on implementing the Min-Heap efficiently to ensure optimal performance. 2. Validate your solution with edge cases such as single-element lists and lists with very large elements.","solution":"import heapq def kth_smallest_element(arr: list[int], k: int) -> int: Returns the k-th smallest element in the unsorted list `arr`. Args: arr (list[int]): The list of integers. k (int): The k-th position to find the smallest element. Returns: int: The k-th smallest element in the list. # Convert the input list to a min-heap heapq.heapify(arr) # Extract the smallest element from the heap k-1 times for _ in range(k-1): heapq.heappop(arr) # The next element in the heap is the k-th smallest return heapq.heappop(arr)"},{"question":"# Tic-Tac-Toe Winner Checker **Context**: You\'re building an AI to play the game Tic-Tac-Toe. A crucial part of the game logic is to determine whether the game is over and if there is a winner. The game is played on a 3x3 grid. **Problem Statement**: Write a function `check_winner(board: list[list[str]]) -> str` that takes a 3x3 board and determines if there\'s a winner. The board is represented as a list of lists containing `\'X\'`, `\'O\'`, or `\'\'` (an empty string for unoccupied cells). The function should return: - `\'X\'` if player \'X\' has won, - `\'O\'` if player \'O\' has won, - `\'draw\'` if there are no more moves left and no winner, - `\'ongoing\'` if the game is still ongoing and no winner has been determined yet. # Instructions: 1. **Input**: - `board`: A 2D list of size 3x3 containing the characters `\'X\'`, `\'O\'`, or `\'\'`. ```python board: list[list[str]] = [[\'\', \'X\', \'O\'], [\'X\', \'O\', \'\'], [\'O\', \'\', \'X\']] ``` 2. **Output**: - A string representing the state of the game. - It must be one of the following: `\'X\'`, `\'O\'`, `\'draw\'`, or `\'ongoing\'`. 3. **Constraints**: - The board will always be a 3x3 grid. - The input will always be in the correct format. # Examples: Input: ```python check_winner([[\'\', \'X\', \'O\'], [\'X\', \'O\', \'\'], [\'O\', \'\', \'X\']]) ``` Output: ```python \'ongoing\' ``` Input: ```python check_winner([[\'X\', \'X\', \'X\'], [\'\', \'O\', \'O\'], [\'O\', \'\', \'\']]) ``` Output: ```python \'X\' ``` Input: ```python check_winner([[\'O\', \'X\', \'O\'], [\'X\', \'X\', \'O\'], [\'X\', \'O\', \'X\']]) ``` Output: ```python \'draw\' ``` Input: ```python check_winner([[\'X\', \'O\', \'X\'], [\'O\', \'X\', \'O\'], [\'\', \'O\', \'X\']]) ``` Output: ```python \'X\' ``` # Notes: 1. Check all possible win conditions: 3 in a row, 3 in a column, or 3 in a diagonal. 2. Ensure to check if there are any empty cells left for an ongoing game. 3. If no winner and no cells left, return \'draw\'.","solution":"def check_winner(board): Determines the current state of a Tic-Tac-Toe game. Parameters: board (list of list of str): 3x3 matrix representing the board Returns: str: \'X\' if player X has won, \'O\' if player O has won, \'draw\' if game is a draw, \'ongoing\' if game is still ongoing # Function to check if all elements in a list are the same and not empty. def all_same(lst): return lst[0] == lst[1] == lst[2] and lst[0] != \'\' # Check rows for row in board: if all_same(row): return row[0] # Check columns for col in range(3): if all_same([board[0][col], board[1][col], board[2][col]]): return board[0][col] # Check diagonals if all_same([board[0][0], board[1][1], board[2][2]]): return board[0][0] if all_same([board[0][2], board[1][1], board[2][0]]): return board[0][2] # Check if there are any empty cells left for row in board: for cell in row: if cell == \'\': return \'ongoing\' # If no winner and no empty cells, it\'s a draw return \'draw\'"},{"question":"# Task Description You are tasked with writing a function that flattens a nested list of integers. The list can contain other lists, which in turn can also contain other lists, and so on. The goal is to return a single, flat list containing all the integers in the nested lists. # Function Signature ```python def flatten_list(nested_list: list) -> list: ``` # Input * A single list `nested_list` that can contain integers and other lists (which can further contain integers or other lists). # Output * A single list containing all integers from the nested lists in a flat structure. # Constraints * The depth of nested lists will not exceed 10. * The list and its nested lists will only contain integers and other lists. * There will be at least one integer in the input list. # Example ```python assert flatten_list([1, [2, [3, 4]], 5]) == [1, 2, 3, 4, 5] assert flatten_list([[1, 2, [3]], 4]) == [1, 2, 3, 4] assert flatten_list([[[1], 2], [3, [4]]]) == [1, 2, 3, 4] assert flatten_list([1, [2], [[3]], [[[4]]], 5]) == [1, 2, 3, 4, 5] assert flatten_list([[1, 2, [3, [4, [5, 6]]]], 7]) == [1, 2, 3, 4, 5, 6, 7] ``` # Explanation 1. The function `flatten_list` should traverse the nested list structure recursively to collect all integers into a single flat list. 2. The function should handle any degree of nesting up to a depth of 10. 3. The integers should appear in the same relative order as they do in the original nested structure. 4. The function should not modify the input list and should return a new list. Implement the function ensuring it efficiently handles the recursive traversal and flattening process, considering edge cases such as deeply nested lists or lists containing only a single integer at each level.","solution":"def flatten_list(nested_list): Flattens a nested list of integers. Args: nested_list (list): A list that can contain integers and other lists. Returns: list: A single, flat list containing all integers from the nested lists. flat_list = [] def flatten(sub_list): for item in sub_list: if isinstance(item, list): flatten(item) else: flat_list.append(item) flatten(nested_list) return flat_list # Example usage # print(flatten_list([1, [2, [3, 4]], 5])) # Output: [1, 2, 3, 4, 5]"},{"question":"# Fibonacci Sequence Generator You need to implement a function that generates the Fibonacci sequence up to a specified count of terms. The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it, starting with 0 and 1. Detailed Instructions: 1. Write a function `fibonacci_sequence` with the following parameter: - `count`: A positive integer representing the number of Fibonacci terms to generate. 2. The function should perform the following tasks: - Validate that the parameter is a positive integer. - Generate and return a list containing the Fibonacci sequence up to the specified count. Constraints: - Do not use any additional libraries or modules. - Handle possible input errors gracefully by raising an appropriate ValueError. - Assume the input count is a positive integer greater than zero. Function Signature: ```python def fibonacci_sequence(count: int) -> list[int]: ``` Example: ```python # Example 1: count = 5 print(fibonacci_sequence(count)) # Output: [0, 1, 1, 2, 3] # Example 2: count = 10 print(fibonacci_sequence(count)) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # Example 3: count = 1 print(fibonacci_sequence(count)) # Output: [0] ```","solution":"def fibonacci_sequence(count: int) -> list[int]: Generates the Fibonacci sequence up to a specified count of terms. Parameters: count (int): The count of Fibonacci terms to generate. Returns: list[int]: The list containing the Fibonacci sequence up to the specified count. if not isinstance(count, int) or count <= 0: raise ValueError(\\"The count must be a positive integer greater than zero.\\") if count == 1: return [0] sequence = [0, 1] for _ in range(2, count): next_term = sequence[-1] + sequence[-2] sequence.append(next_term) return sequence"},{"question":"# Directed Graph Operations You will implement a DirectedGraph class that represents a directed graph and supports a variety of operations. Design your class to handle the graph efficiently. Problem Statement Implement the `DirectedGraph` class with the following functionality: 1. **Initialization**: - A constructor that initializes the graph with an optional adjacency list. - If provided, the adjacency list should be a dictionary where keys are node identifiers and values are lists of adjacent nodes. 2. **Add Edge**: - Implement a method to add a directed edge between two nodes. - If either node does not exist, add the node(s) to the graph. 3. **Remove Edge**: - Implement a method to remove a directed edge between two nodes. - If the edge does not exist, handle gracefully. 4. **Get All Nodes**: - Implement a method to return all nodes in the graph. 5. **Get Adjacent Nodes**: - Implement a method to get all nodes adjacent to a given node. 6. **Path Existence**: - Implement a method to check if there is a path between two nodes. 7. **Topological Sort**: - Implement a method to perform a topological sort on the graph. - Raise a ValueError if the graph contains a cycle. 8. **Graph Representation**: - Return a human-readable string representation of the graph. Example ```python g = DirectedGraph() g.add_edge(1, 2) g.add_edge(2, 3) g.add_edge(1, 3) print(g.get_all_nodes()) # [1, 2, 3] print(g.get_adjacent_nodes(1)) # [2, 3] print(g.has_path(1, 3)) # True print(g) # {1: [2, 3], 2: [3], 3: []} print(g.topological_sort()) # [1, 2, 3] g.remove_edge(2, 3) print(g.has_path(1, 3)) # True print(g.has_path(2, 3)) # False ``` Constraints - Nodes are identified by unique integers. - Adding an edge between a node and itself should be handled. - Removing a non-existent edge should not alter the graph. - The graph can initially be empty or come with an adjacency list.","solution":"class DirectedGraph: def __init__(self, adjacency_list=None): Initializes the graph. :param adjacency_list: Optional dictionary representing the adjacency list. self.adjacency_list = adjacency_list if adjacency_list is not None else {} def add_edge(self, start, end): Adds a directed edge from start to end node. :param start: The starting node. :param end: The ending node. if start not in self.adjacency_list: self.adjacency_list[start] = [] self.adjacency_list[start].append(end) if end not in self.adjacency_list: self.adjacency_list[end] = [] def remove_edge(self, start, end): Removes a directed edge from start to end node. :param start: The starting node. :param end: The ending node. if start in self.adjacency_list and end in self.adjacency_list[start]: self.adjacency_list[start].remove(end) def get_all_nodes(self): Returns all nodes in the graph. :return: List of all nodes. return list(self.adjacency_list.keys()) def get_adjacent_nodes(self, node): Gets all nodes adjacent to the given node. :param node: The node. :return: List of adjacent nodes. return self.adjacency_list.get(node, []) def has_path(self, start, end): Checks if there is a path from start to end node. :param start: The starting node. :param end: The ending node. :return: True if path exists, otherwise False. visited = set() return self._dfs(start, end, visited) def _dfs(self, current, target, visited): Depth First Search to find if a path exists. :param current: The current node. :param target: The target node. :param visited: Set of visited nodes. :return: True if path exists, otherwise False. if current == target: return True visited.add(current) for neighbor in self.adjacency_list.get(current, []): if neighbor not in visited and self._dfs(neighbor, target, visited): return True return False def topological_sort(self): Returns a topological sort of the graph. :return: List of nodes in topologically sorted order. :raises ValueError: If the graph contains a cycle. visited = set() stack = [] on_stack = set() for node in self.adjacency_list: if node not in visited: self._topological_sort_dfs(node, visited, stack, on_stack) return stack[::-1] def _topological_sort_dfs(self, node, visited, stack, on_stack): Helper function for topological sort DFS. :param node: The current node. :param visited: Set of visited nodes. :param stack: The topological sort stack. :param on_stack: Set of nodes currently in recursion stack. :raises ValueError: If a cycle is detected. visited.add(node) on_stack.add(node) for neighbor in self.adjacency_list.get(node, []): if neighbor not in visited: self._topological_sort_dfs(neighbor, visited, stack, on_stack) elif neighbor in on_stack: raise ValueError(\\"Graph contains a cycle\\") on_stack.remove(node) stack.append(node) def __str__(self): Returns a human-readable string representation of the graph. :return: String representation of the graph. return str(self.adjacency_list)"},{"question":"# Question Problem Statement Design a function that finds the second largest number in a list of integers. Your function should handle lists with unique values and should be efficient in terms of both time and space complexity. Function Signature ```python def second_largest(nums: list[int]) -> int: Finds the second largest number in a list of integers. :param nums: List of integers with unique values. :return: The second largest integer in the list. ``` Input * A list of integers with unique values. * Eg: `second_largest([4, 2, 7, 1, 9, 3])`. Output * Return the second largest integer from the list. Constraints * The list will have at least two integers. * All integers are unique. Examples ```python second_largest([4, 2, 7, 1, 9, 3]) # Returns 7 second_largest([10, 20, 30, 40, 50]) # Returns 40 second_largest([-10, -20, 0, -5]) # Returns -5 second_largest([9, 5]) # Returns 5 second_largest([101, 1010, 10101, 101010]) # Returns 10101 ``` Performance Requirements * The solution should run in O(n), where `n` is the number of elements in the list. Implementation Notes * Consider efficient methods to find the two largest elements in a single pass through the list. * Handle edge cases such as the minimum required list length of two elements. * Do not sort the list as it would increase the time complexity to O(n log n). Example Implementation ```python def second_largest(nums: list[int]) -> int: if len(nums) < 2: raise ValueError(\\"The list must contain at least two unique numbers.\\") first = float(\'-inf\') second = float(\'-inf\') for num in nums: if num > first: second = first first = num elif num > second and num != first: second = num return second ```","solution":"def second_largest(nums: list[int]) -> int: if len(nums) < 2: raise ValueError(\\"The list must contain at least two unique numbers.\\") first = second = float(\'-inf\') for num in nums: if num > first: second = first first = num elif num > second and num != first: second = num return second"},{"question":"# Find Missing Number in Arithmetic Sequence You are given an arithmetic sequence of `n` elements where one element is missing. Your task is to find the missing element in this sequence. # Function Signature: ```python def find_missing_number(sequence: List[int]) -> int: ``` # Input: * `sequence` (List[int]): A list of integers representing an arithmetic sequence with exactly one missing element. The list has at least 3 elements. # Output: * Returns an integer representing the missing element in the arithmetic sequence. # Constraints: * The input list will always contain at least 3 elements and no more than 10^5 elements. * The difference between consecutive elements in the arithmetic sequence is constant. * The values of the elements will be between -10^6 and 10^6. # Example: ```python >>> find_missing_number([1, 3, 5, 9, 11]) 7 >>> find_missing_number([2, 4, 6, 10, 12]) 8 >>> find_missing_number([10, 20, 40, 50]) 30 >>> find_missing_number([100, 200, 300, 500]) 400 >>> find_missing_number([-5, 0, 5, 15]) 10 ``` # Note: 1. The difference between consecutive elements in the arithmetic sequence is always non-zero. 2. The sequence will have exactly one missing number, which you need to identify and return. If there are no missing numbers, raise a `ValueError` with the message \\"No missing number\\". 3. Ensure your solution is efficient to handle large input sizes.","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Finds the missing number in the arithmetic sequence. n = len(sequence) total_sum = (n + 1) * (sequence[0] + sequence[-1]) // 2 actual_sum = sum(sequence) return total_sum - actual_sum"},{"question":"# Problem Statement Write a function `analyze_github_contributors` that evaluates and summarizes the contributions of users to a specific GitHub repository. The function will accept the repository name, the owner of the repository, and other optional parameters to customize the analysis. The function should: 1. Fetch the list of contributors and their contributions from the GitHub API. 2. Handle pagination to ensure all contributors are retrieved even if the number exceeds the API\'s single call limits. 3. Efficiently manage error handling for potential HTTP errors (e.g., 404, 403). 4. Allow filtering of contributors based on contribution counts or specific user attributes. 5. Provide an option to cache the results for a specified duration to avoid redundant API calls in a session. # Function Signature ```python def analyze_github_contributors( repo_owner: str, repo_name: str, min_contributions: int = 0, attributes: list | None = None, cache_duration: int = 600 ) -> dict: Fetch and analyze GitHub contributors data with pagination and caching. Parameters: - repo_owner (str): The owner of the repository. - repo_name (str): The name of the repository. - min_contributions (int): Minimum number of contributions to consider. - attributes (list): Specific user attributes to retrieve. - cache_duration (int): Cache duration in seconds. Default is 600 seconds. Returns: - dict: Dictionary containing the requested attributes for each contributor. ``` # Input/Output Examples Input ```python analyze_github_contributors(\\"octocat\\", \\"Hello-World\\", 10, [\\"login\\", \\"contributions\\"]) ``` Output ```python { 0: {\'login\': \'user1\', \'contributions\': 20}, 1: {\'login\': \'user2\', \'contributions\': 15} ... } ``` # Constraints and Requirements 1. The repo_owner and repo_name parameters are mandatory. 2. The min_contributions parameter defaults to 0 to include all contributors. 3. The attributes list and cache_duration are optional. Default cache_duration is 600 seconds. 4. Handle HTTP errors gracefully, specifically checking for status codes 404 (Not Found), 403 (Forbidden), and 429 (Rate Limited). 5. Use caching to avoid redundant requests within the specified duration. 6. Validate the attributes against the predefined valid GitHub user attributes. # Performance Requirements 1. The function should optimize network requests and manage rate limits. 2. Handle a maximum feasible number of contributors (keeping in mind GitHub API rate limits and pagination). # Context This function can be used to gather insights into the contributions of users to a given repository, which is useful for project management, evaluating open-source community engagement, or contributing to user profiles for community incentives.","solution":"import requests from cachetools import TTLCache, cached from typing import List, Dict, Any # Cache to store results to avoid redundant API calls cache = TTLCache(maxsize=100, ttl=600) @cached(cache) def fetch_contributors(repo_owner: str, repo_name: str, page: int = 1) -> List[Dict[str, Any]]: Fetch contributors from GitHub API for a given page. Parameters: - repo_owner (str): The owner of the repository. - repo_name (str): The name of the repository. - page (int): Pagination page number. Returns: - List of contributor dictionaries. url = f\\"https://api.github.com/repos/{repo_owner}/{repo_name}/contributors\\" params = {\'page\': page, \'per_page\': 100} response = requests.get(url, params=params) if response.status_code == 200: return response.json() elif response.status_code == 404: raise ValueError(\\"Repository not found.\\") elif response.status_code == 403: raise PermissionError(\\"Forbidden. Perhaps hit rate limit.\\") elif response.status_code == 429: raise Exception(\\"Rate limited. Please try again later.\\") else: response.raise_for_status() def analyze_github_contributors( repo_owner: str, repo_name: str, min_contributions: int = 0, attributes: List[str] = None, cache_duration: int = 600 ) -> Dict[int, Dict[str, Any]]: Fetch and analyze GitHub contributors data with pagination and caching. Parameters: - repo_owner (str): The owner of the repository. - repo_name (str): The name of the repository. - min_contributions (int): Minimum number of contributions to consider. - attributes (List[str]): Specific user attributes to retrieve. - cache_duration (int): Cache duration in seconds. Default is 600 seconds. Returns: - dict: Dictionary containing the requested attributes for each contributor. # Check valid attributes valid_attributes = {\\"login\\", \\"id\\", \\"node_id\\", \\"avatar_url\\", \\"gravatar_id\\", \\"url\\", \\"html_url\\", \\"followers_url\\", \\"subscriptions_url\\", \\"organizations_url\\", \\"repos_url\\", \\"events_url\\", \\"received_events_url\\", \\"type\\", \\"site_admin\\", \\"contributions\\"} if attributes: for attr in attributes: if attr not in valid_attributes: raise ValueError(f\\"Invalid attribute: {attr}\\") page = 1 all_contributors = [] while True: contributors = fetch_contributors(repo_owner, repo_name, page) if not contributors: break all_contributors.extend(contributors) page += 1 # Apply contribution count filter if min_contributions > 0: all_contributors = [contributor for contributor in all_contributors if contributor[\'contributions\'] >= min_contributions] # Prepare the final results result = {} for i, contributor in enumerate(all_contributors): if attributes: result[i] = {attr: contributor[attr] for attr in attributes} else: result[i] = contributor return result"},{"question":"# **Finding Duplicates in a List Using Hashing** Background In your latest project, you need to identify and handle duplicates within a dataset. The dataset is represented as a list of integers. You want to quickly determine if there are any duplicates in the list using an efficient approach. Task Write a Python function `has_duplicates(data: list) -> bool` that takes a list of integers as input and returns `True` if there are any duplicates, and `False` otherwise. Your implementation should utilize a hashing technique for optimal performance. Details: 1. **Input Format**: A single list `data` containing integers. 2. **Output Format**: A boolean indicating whether there are duplicates in the list. Constraints: - The function should raise a `TypeError` if the input is not a list of integers. - The list may contain both positive and negative integers, including zero. - An empty list should return `False`, as there are no duplicates. Examples: ``` has_duplicates([1, 2, 3, 4, 5]) # False, no duplicates in the list has_duplicates([1, 2, 3, 2, 4, 5]) # True, 2 is repeated has_duplicates([-1, -2, -3, -2]) # True, -2 is repeated has_duplicates([1]) # False, only one element has_duplicates([]) # False, empty list has no duplicates has_duplicates([0, 0, 1, 2]) # True, 0 is repeated has_duplicates([1, \\"2\\", 3]) # Raises TypeError ``` Notes: 1. Validate that the input is a list and all elements in the list are integers. 2. Use a set to keep track of unique elements encountered while iterating through the list. 3. Write appropriate test cases to handle possible edge cases, including verifying for correct exceptions.","solution":"def has_duplicates(data): Returns True if there are duplicates in the list, False otherwise. Raises TypeError if data is not a list of integers. if not isinstance(data, list): raise TypeError(\\"Input must be a list.\\") if not all(isinstance(i, int) for i in data): raise TypeError(\\"All elements in the list must be integers.\\") seen = set() for number in data: if number in seen: return True seen.add(number) return False"},{"question":"# Word Frequency Analysis Scenario You are tasked with developing a utility script to perform word frequency analysis on a given text. This script will help determine the frequency of each word and identify the top N most frequent words. Input and Output Requirements You need to implement the following functions: 1. **`word_frequency(text: str) -> dict`**: * **Input**: A string containing multiple words (alphabetic only; case insensitive). * **Output**: A dictionary where keys are words and values are their frequency in the given text. 2. **`top_n_words(freq_dict: dict, n: int) -> list`**: * **Input**: A dictionary of word frequencies and an integer n. * **Output**: A list of tuples where each tuple contains a word and its frequency, sorted by frequency in descending order. If two words have the same frequency, they should be sorted alphabetically. The list should contain exactly n items, or fewer if there are fewer than n unique words. Each function must validate its inputs. The `word_frequency` function should only count words (ignore case differences) and ignore any non-alphabetic characters. The `top_n_words` function should handle cases where n is larger than the number of unique words gracefully. Ensure the functions are optimized for readability and performance. Provide necessary test cases to validate your functions. Example Usage and Expected Results ```python text = \\"The cat and the hat and the bat\\" freq_dict = word_frequency(text) assert freq_dict == {\'the\': 3, \'cat\': 1, \'and\': 2, \'hat\': 1, \'bat\': 1} top_words = top_n_words(freq_dict, 2) assert top_words == [(\'the\', 3), (\'and\', 2)] top_words = top_n_words(freq_dict, 10) assert top_words == [(\'the\', 3), (\'and\', 2), (\'bat\', 1), (\'cat\', 1), (\'hat\', 1)] ``` Constraints * The input strings for text are non-empty and only contain alphabetic characters and spaces. * `n` is a non-negative integer. * Ensure your validation correctly handles edge cases. This assessment will test your ability to process and analyze textual data, with a focus on validation, sorting, and frequency analysis.","solution":"import re from collections import Counter def word_frequency(text: str) -> dict: Returns a dictionary containing the frequency of each word in the given text. Parameters: text (str): A string containing multiple words. Returns: dict: A dictionary with words as keys and their frequency as values. # Normalize the text to lowercase and use regex to find words words = re.findall(r\'b[a-z]+b\', text.lower()) # Count frequency of each word frequency_dict = Counter(words) return dict(frequency_dict) def top_n_words(freq_dict: dict, n: int) -> list: Returns the top N most frequent words from the frequency dictionary. Parameters: freq_dict (dict): A dictionary of word frequencies. n (int): The number of top frequent words to return. Returns: list: A list of tuples representing the top N most frequent words and their frequencies. if n <= 0: return [] # Sort the items first by frequency (in descending order) and then alphabetically by word sorted_words = sorted(freq_dict.items(), key=lambda item: (-item[1], item[0])) # Return the top n words return sorted_words[:n]"},{"question":"# Problem Statement Implement a function named `matrix_multiply` that takes two matrices represented as two-dimensional lists and returns their product. # Function Signature ```python def matrix_multiply(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: pass ``` # Input - **matrix1 (list[list[int]])**: The first matrix, a list of lists of integers. - **matrix2 (list[list[int]])**: The second matrix, a list of lists of integers. # Output - **list[list[int]]**: The resulting matrix from multiplying `matrix1` by `matrix2`. # Constraints - The number of columns in `matrix1` will always be equal to the number of rows in `matrix2` (i.e., matrix multiplication is possible). - Each matrix element is an integer. - Matrix dimensions: 1 ≤ m, n, p ≤ 100 where - `m` is the number of rows in `matrix1`, - `n` is the number of columns in `matrix1` (and the number of rows in `matrix2`), - `p` is the number of columns in `matrix2`. # Requirements 1. Ensure correct matrix multiplication as per the linear algebra definition. 2. Handle edge cases where the matrices might be of minimal size (1x1). 3. Optimize for performance and maintain readability. # Examples ```python assert matrix_multiply([[1, 2], [3, 4]], [[2, 0], [1, 3]]) == [[4, 6], [10, 12]] assert matrix_multiply([[1, 0], [0, 1]], [[5, 5], [5, 5]]) == [[5, 5], [5, 5]] assert matrix_multiply([[2]], [[3]]) == [[6]] assert matrix_multiply([[1, 2, 3]], [[4], [5], [6]]) == [[32]] ``` # Additional Context This function will test your ability to handle multidimensional arrays effectively and apply fundamental concepts of matrix theory. It requires understanding of nested loops and efficient computation techniques to ensure correct results within given constraints.","solution":"def matrix_multiply(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: # Get the dimensions of the input matrices m = len(matrix1) n = len(matrix2) p = len(matrix2[0]) # Initialize the resulting matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform the matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"Rabin-Miller Primality Test Write a function that uses the Rabin-Miller primality test to determine if a given number is likely a prime number. The Rabin-Miller test is a probabilistic algorithm for determining the primality of a number, which is particularly efficient for large numbers. # Function Definitions and Signature ```python def rabin_miller(number: int, iterations: int) -> bool: Check whether the input number is prime or not using the Rabin-Miller Primality test. Parameters: number: The number that is tested for primality. iterations: The number of times the test is run to enhance the accuracy. Returns: result: True if number is probably prime, False otherwise. Constraints: - The number of iterations will be up to 20. - You can assume the number will be a positive integer less than (10^{12}). # implementation provided above ``` # Task Implement the `rabin_miller` function so that it accurately determines whether a given number is probably prime following the Rabin-Miller algorithm. The function should return `True` if the number is probably prime, and `False` otherwise. # Input - `number`: A positive integer. - `iterations`: An integer representing the number of iterations to run the test. # Output - `True` if the number is probably prime. - `False` otherwise. # Examples ```python >>> random.seed(10) >>> rabin_miller(13, 5) True >>> rabin_miller(9, 10) False >>> rabin_miller(17, 15) True ``` # Additional Note This function should involve repeated squaring and modular arithmetic. The function should handle any special cases such as small primes or specific properties of numbers that facilitate early termination of the test.","solution":"import random def rabin_miller(number: int, iterations: int) -> bool: if number < 2: return False if number in (2, 3): return True if number % 2 == 0: return False # Write (number - 1) as d * 2^r d = number - 1 r = 0 while d % 2 == 0: d //= 2 r += 1 def check_composite(a, d, n, r): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(iterations): a = random.randint(2, number - 2) if check_composite(a, d, number, r): return False return True"},{"question":"# Task: Implement a function that, given two sorted lists, finds the intersection of the two lists. The intersection must be a list that contains only the elements that are present in both input lists, without any duplicates and sorted in ascending order. # Function Signature: ```python def find_intersection(list1: list[int], list2: list[int]) -> list[int]: pass ``` # Input: - `list1` (list of int): A sorted list of integers. - `list2` (list of int): Another sorted list of integers. # Output: - A sorted list of integers representing the intersection of `list1` and `list2`. # Sample Usage: ```python print(find_intersection([1, 3, 4, 6, 7, 9], [1, 2, 4, 5, 9, 10])) # Returns: # [1, 4, 9] print(find_intersection([1, 2, 3], [4, 5, 6])) # Returns: # [] print(find_intersection([2, 4, 4, 6, 8], [4, 4, 5, 7, 8, 8])) # Returns: # [4, 8] ``` # Constraints: - Both input lists, `list1` and `list2`, will contain between 1 and 100,000 integers. - Elements in each list are sorted in ascending order and fall within the range of -10^6 to 10^6. - The input lists can have duplicates, but the intersected result should not have duplicates. # Implementation Tips: - Utilize two pointers to efficiently traverse both lists. - Move the pointers accordingly to find common elements while maintaining minimal time complexity. - Handle edge cases like empty intersections or single element lists.","solution":"def find_intersection(list1, list2): Returns the intersection of two sorted lists without duplicates. intersection = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] == list2[j]: if not intersection or intersection[-1] != list1[i]: intersection.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return intersection"},{"question":"# Coding Assessment Question A company operates a warehouse where products are stored and shipped. The warehouse management system keeps track of product quantities using a dictionary. Your task is to implement a function that can handle multiple operations to modify and query the product quantities. The operations are provided in the form of a list of strings. Requirements: 1. **Adding Products**: * Operation format: `add <product_name> <quantity>`. Adds the specified quantity of the product to the warehouse. * If the product does not already exist, initialize its quantity with the given amount. 2. **Removing Products**: * Operation format: `remove <product_name> <quantity>`. Removes the specified quantity of the product from the warehouse. * If the quantity to be removed exceeds the current quantity, set the product quantity to 0. 3. **Querying Products**: * Operation format: `quantity <product_name>`. Returns the current quantity of the specified product in the warehouse. 4. **Multiple Operations**: * Your function should be able to handle a list of these operations and return the results of all `quantity` queries sequentially. # Expected Input and Output: * **Input**: `operations` (List[str]) - A list of operations to be performed on the warehouse. * **Output**: A list of integers representing the quantities from the `quantity` queries, in the order they appear in the input list. # Constraints: * Product names are alphanumeric strings without spaces. * Quantity values are non-negative integers. * The length of the operations list will not exceed 1000. * Each product name will appear at most 100 times across all operations. * Operations are well-formed according to their descriptions. # Function Signature: ```python def manage_warehouse_operations(operations: List[str]) -> List[int]: # Your implementation here ``` # Example Usage: ```python operations = [ \\"add apples 10\\", \\"add oranges 5\\", \\"remove apples 3\\", \\"quantity apples\\", \\"quantity oranges\\", \\"remove oranges 10\\", \\"quantity oranges\\" ] result = manage_warehouse_operations(operations) print(result) # Output: [7, 5, 0] ``` Your task is to implement the `manage_warehouse_operations` function according to the requirements and constraints specified above. Include appropriate comments and documentation for clarity.","solution":"from typing import List, Union def manage_warehouse_operations(operations: List[str]) -> List[int]: # Dictionary to keep track of product quantities warehouse = {} # List to store results of quantity queries query_results = [] # Process each operation for operation in operations: parts = operation.split() command = parts[0] product_name = parts[1] if command == \\"add\\": quantity = int(parts[2]) if product_name in warehouse: warehouse[product_name] += quantity else: warehouse[product_name] = quantity elif command == \\"remove\\": quantity = int(parts[2]) if product_name in warehouse: if warehouse[product_name] <= quantity: warehouse[product_name] = 0 else: warehouse[product_name] -= quantity elif command == \\"quantity\\": if product_name in warehouse: query_results.append(warehouse[product_name]) else: query_results.append(0) return query_results"},{"question":"# K-Means Clustering Implementation Context You are working as a data analyst for a retail company. Your task is to segment customers into distinct groups based on their purchasing behavior. You decide to use K-Means Clustering to identify clusters of customers with similar behavior. Objective Implement a K-Means Clustering algorithm from scratch and cluster the given data points into k clusters. Also, introduce a functionality to visualize the clusters and the cluster centroids. Input Format 1. A matrix `X` of shape (m, n) representing m customers and n features. 2. An integer `k` representing the number of clusters. 3. An integer `max_iterations` representing the maximum number of iterations to run the algorithm. 4. A boolean `plot` indicating whether to visualize the clusters and centroids (2D plots). Output Format 1. A vector `labels` of shape (m,) representing the cluster assignments for each data point. 2. If `plot` is True, display a scatter plot for the data points with different colors for different clusters and mark the centroids. Constraints 1. Number of clusters `k` should be ≥ 1 and ≤ 10. 2. Number of features `n` should be ≥ 2 and ≤ 50. 3. Number of samples `m` should be ≥ 10 and ≤ 5000. 4. If `plot` is True, the dimensions of X should be 2 (n=2). # Function Signature ```python def k_means_clustering(X: np.ndarray, k: int, max_iterations: int, plot: bool) -> np.ndarray: pass ``` # Example ```python X = np.array([[1, 2], [3, 4], [1, 0], [5, 2], [6, 4], [4, 1], [7, 3], [8, 0]]) k = 2 max_iterations = 100 plot = True labels = k_means_clustering(X, k, max_iterations, plot) print(\\"Cluster assignments:\\", labels) ``` In this example, the function `k_means_clustering` should output cluster assignments and optionally display a scatter plot with data points colored based on their cluster and centroids marked. # Requirements Implement the core operational steps for K-Means Clustering: 1. Initialize cluster centroids randomly from the data points. 2. Assign each data point to the nearest centroid. 3. Recompute the centroids as the mean of the data points assigned to each cluster. 4. Repeat the assignment and update steps until centroids do not change significantly or max iterations are reached. 5. If `plot` is True, visualize the clusters and centroids on a scatter plot. Good luck!","solution":"import numpy as np import matplotlib.pyplot as plt def initialize_centroids(X, k): Randomly initialize the centroids by selecting k unique points from X. m = X.shape[0] indices = np.random.choice(m, k, replace=False) centroids = X[indices] return centroids def compute_distances(X, centroids): Compute the distance of each point in X to each centroid. distances = np.linalg.norm(X[:, np.newaxis] - centroids, axis=2) return distances def assign_clusters(distances): Assign each point to the nearest centroid. return np.argmin(distances, axis=1) def compute_centroids(X, labels, k): Compute the centroids as the mean of all points assigned to each centroid. centroids = np.array([X[labels == i].mean(axis=0) for i in range(k)]) return centroids def k_means_clustering(X: np.ndarray, k: int, max_iterations: int, plot: bool) -> np.ndarray: np.random.seed(42) # For reproducible results centroids = initialize_centroids(X, k) for _ in range(max_iterations): distances = compute_distances(X, centroids) labels = assign_clusters(distances) new_centroids = compute_centroids(X, labels, k) if np.all(centroids == new_centroids): break centroids = new_centroids if plot and X.shape[1] == 2: plt.scatter(X[:, 0], X[:, 1], c=labels, s=50, cmap=\'viridis\') plt.scatter(centroids[:, 0], centroids[:, 1], s=200, c=\'red\', marker=\'X\') plt.title(f\'K-Means Clustering with k={k}\') plt.show() return labels"},{"question":"# Coding Challenge: Implement a Red-Black Tree Deletion Context You are provided with a Red-Black Tree implementation, which includes insertion and search operations. However, the delete operation is critical for maintaining the dynamic set\'s balance and ensuring that subsequent operations remain efficient, which is currently not implemented. Task Extend the `RedBlackTree` class with the deletion operation to remove a node with a given key from the tree while maintaining the red-black properties. Specifications **Operation: Delete Node** - **Function Signature**: `def delete_node(self, key):` - **Input**: `key` - The key of the node to be deleted. - **Output**: It returns the deleted node or None if the node is not found. Ensure the tree remains a valid red-black tree after deletion. Additional Requirements - Ensure all properties of the red-black tree are preserved: 1. Every node is either red or black. 2. The root is black. 3. All leaves (NIL nodes) are black. 4. If a node is red, then both its children are black. 5. Every path from a node to its descendant NIL nodes has the same number of black nodes. - Implement helper functions to manage the intricate balancing, recoloring, and rotations required. - Handle cases where the queried key does not exist gracefully. # Example Usage ```python # Initialize a red-black tree rbt = RedBlackTree() # Insert elements rbt.insert(20) rbt.insert(15) rbt.insert(25) rbt.insert(10) rbt.insert(5) # Delete key 15 deleted_node = rbt.delete_node(15) print(deleted_node.key if deleted_node else \\"Not Found\\") # Should print 15 # Delete a key that does not exist deleted_node = rbt.delete_node(30) print(deleted_node.key if deleted_node else \\"Not Found\\") # Should print \\"Not Found\\" # Test in-order traversal to check tree structure print(rbt.in_order_traversal()) # Should print the keys in sorted order without 15 and maintaining tree properties ``` # Constraints - Do not use additional data structures beyond what is required for red-black tree operations. - Performance requirements must adhere to standard red-black tree operations\' complexities. - Ensure handling of edge cases where the tree is empty or contains only one node. **Nota Bene:** Modify the `RedBlackTree` and `Node` classes as necessary to implement the delete operation and preserve tree properties.","solution":"class Node: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color # \'red\' or \'black\' self.left = left self.right = right self.parent = parent class RedBlackTree: def __init__(self): self.TNULL = Node(0, \'black\') # Sentinel node for NIL leaves self.root = self.TNULL def insert(self, key): node = Node(key, \'red\', self.TNULL, self.TNULL) parent = None current = self.root while current != self.TNULL: parent = current if node.key < current.key: current = current.left else: current = current.right node.parent = parent if parent is None: self.root = node elif node.key < parent.key: parent.left = node else: parent.right = node if node.parent is None: node.color = \'black\' return if node.parent.parent is None: return self.fix_insert(node) def fix_insert(self, k): while k.parent.color == \'red\': if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == \'red\': u.color = \'black\' k.parent.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == \'red\': u.color = \'black\' k.parent.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = \'black\' def delete_node(self, key): def transplant(u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def minimum(node): while node.left != self.TNULL: node = node.left return node def delete_fix(x): while x != self.root and x.color == \'black\': if x == x.parent.left: s = x.parent.right if s.color == \'red\': s.color = \'black\' x.parent.color = \'red\' self.left_rotate(x.parent) s = x.parent.right if s.left.color == \'black\' and s.right.color == \'black\': s.color = \'red\' x = x.parent else: if s.right.color == \'black\': s.left.color = \'black\' s.color = \'red\' self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = \'black\' s.right.color = \'black\' self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == \'red\': s.color = \'black\' x.parent.color = \'red\' self.right_rotate(x.parent) s = x.parent.left if s.right.color == \'black\' and s.right.color == \'black\': s.color = \'red\' x = x.parent else: if s.left.color == \'black\': s.right.color = \'black\' s.color = \'red\' self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = \'black\' s.left.color = \'black\' self.right_rotate(x.parent) x = self.root x.color = \'black\' z = self.root while z != self.TNULL: if z.key == key: node_to_delete = z break elif z.key < key: z = z.right else: z = z.left if z == self.TNULL: return None node_to_delete = z y = node_to_delete y_original_color = y.color if node_to_delete.left == self.TNULL: x = node_to_delete.right transplant(node_to_delete, node_to_delete.right) elif node_to_delete.right == self.TNULL: x = node_to_delete.left transplant(node_to_delete, node_to_delete.left) else: y = minimum(node_to_delete.right) y_original_color = y.color x = y.right if y.parent == node_to_delete: x.parent = y else: transplant(y, y.right) y.right = node_to_delete.right y.right.parent = y transplant(node_to_delete, y) y.left = node_to_delete.left y.left.parent = y y.color = node_to_delete.color if y_original_color == \'black\': delete_fix(x) return node_to_delete def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def in_order_traversal(self): def _in_order_traversal_helper(node): if node != self.TNULL: return _in_order_traversal_helper(node.left) + [node.key] + _in_order_traversal_helper(node.right) else: return [] return _in_order_traversal_helper(self.root)"},{"question":"# New Question: # Objectives: 1. Write a function `initialize_booking_system(trips: List[Dict[str, Any]]) -> None` to initialize the booking system with specified trips and their seating capacities. 2. Implement the `book_trip(trip_id: str, passenger_name: str) -> bool` function to handle booking requests. 3. Implement the `cancel_booking(trip_id: str, passenger_name: str) -> bool` function to handle booking cancellations. 4. Create a `query_availability(trip_id: str) -> int` function to check the number of available seats on a specific trip. # Function Definitions: - `initialize_booking_system(trips: List[Dict[str, Any]]) -> None` - **Input**: - trips: List of dictionaries where each dictionary contains: - \'trip_id\': A unique string identifier for the trip. - \'seats\': An integer representing the total number of seats available on that trip. - **Output**: None - `book_trip(trip_id: str, passenger_name: str) -> bool` - **Input**: - trip_id: A string representing the trip identifier. - passenger_name: A string representing the name of the passenger. - **Output**: Returns `True` if the booking is successful, `False` if the trip is full or the trip ID doesn\'t exist. - `cancel_booking(trip_id: str, passenger_name: str) -> bool` - **Input**: - trip_id: A string representing the trip identifier. - passenger_name: A string representing the name of the passenger. - **Output**: Returns `True` if the cancellation is successful, `False` if the trip ID or passenger name doesn\'t exist. - `query_availability(trip_id: str) -> int` - **Input**: - trip_id: A string representing the trip identifier. - **Output**: Returns an integer representing the number of available seats for the given trip ID. # Constraints: - Each `trip_id` in `trips` must be unique. - Each `passenger_name` in any given trip must be unique. - Each `trip_id` and `passenger_name` will be a non-empty string. # Example Usage: ```python # Example initialization parameters trips = [ {\'trip_id\': \'NY123\', \'seats\': 10}, {\'trip_id\': \'LA456\', \'seats\': 15} ] # Initializing Booking System initialize_booking_system(trips) # Making a booking result = book_trip(\'NY123\', \'Alice\') print(result) # Expected Output: True # Querying availability available_seats = query_availability(\'NY123\') print(available_seats) # Expected Output: 9 # Cancelling a booking result = cancel_booking(\'NY123\', \'Alice\') print(result) # Expected Output: True # Querying availability after cancellation available_seats = query_availability(\'NY123\') print(available_seats) # Expected Output: 10 ``` Implement these functions in Python following provided specifications and constraints. Ensure your implementation accurately handles booking requests, cancellations, and availability queries.","solution":"from typing import List, Dict, Any # Global variable to store trip information trips_data = {} def initialize_booking_system(trips: List[Dict[str, Any]]) -> None: global trips_data trips_data = {} for trip in trips: trip_id = trip[\'trip_id\'] seats = trip[\'seats\'] trips_data[trip_id] = {\'total_seats\': seats, \'booked_seats\': set()} def book_trip(trip_id: str, passenger_name: str) -> bool: if trip_id not in trips_data: return False trip_info = trips_data[trip_id] if len(trip_info[\'booked_seats\']) < trip_info[\'total_seats\']: trip_info[\'booked_seats\'].add(passenger_name) return True return False def cancel_booking(trip_id: str, passenger_name: str) -> bool: if trip_id not in trips_data: return False trip_info = trips_data[trip_id] if passenger_name in trip_info[\'booked_seats\']: trip_info[\'booked_seats\'].remove(passenger_name) return True return False def query_availability(trip_id: str) -> int: if trip_id not in trips_data: return -1 # Indicating trip not found trip_info = trips_data[trip_id] return trip_info[\'total_seats\'] - len(trip_info[\'booked_seats\'])"},{"question":"Coding Assessment Question **Context**: Working with numerical sequences and finding specific terms in such sequences is a common task in programming and mathematical problem solving. **Question**: Implement a function `nth_fibonacci(n: int) -> int` that returns the `n`-th term in the Fibonacci sequence. The Fibonacci sequence is defined as: * `F(0) = 0` * `F(1) = 1` * `F(n) = F(n-1) + F(n-2)` for `n >= 2`. **Function Signature**: ```python def nth_fibonacci(n: int) -> int: ``` **Input**: * `n` (int): A non-negative integer representing the position in the Fibonacci sequence. **Output**: * An integer representing the `n`-th term in the Fibonacci sequence. **Constraints**: * `0 <= n <= 50` **Performance Requirements**: * The solution should run with time complexity O(n). * The solution should use O(1) additional space. **Examples**: 1. `nth_fibonacci(0) -> 0` 2. `nth_fibonacci(1) -> 1` 3. `nth_fibonacci(5) -> 5` 4. `nth_fibonacci(10) -> 55` 5. `nth_fibonacci(50) -> 12586269025` **Notes**: * The function should be designed to be efficient and handle large values of `n` within the given constraints. * Make sure to consider edge cases such as the smallest and largest values of `n` provided in the constraint.","solution":"def nth_fibonacci(n: int) -> int: Returns the n-th term in the Fibonacci sequence. if n == 0: return 0 if n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"Context: In city planning, a distance matrix is a way to represent the distances between various points in a city, such as intersections or landmarks. This matrix can be useful for calculating the shortest paths, optimizing delivery routes, or planning public transportation. The diagonal of the distance matrix represents the distance from a point to itself and should always be zero. Non-diagonal entries represent the actual distances between different points. # Task: Implement a function `are_distances_symmetric` that checks if a given distance matrix is symmetric. A symmetric distance matrix means that the distance from point A to point B is the same as the distance from point B to point A. # Input: 1. `distance_matrix` (List[List[float]]): A square matrix (list of lists) representing distances between points. The element at row (i) and column (j) indicates the distance from point (i) to point (j). # Output: - A boolean value that indicates whether the input distance matrix is symmetric. # Constraints: - The length of the distance matrix will not exceed 1000. - Each element in the distance matrix will be a non-negative float. - The diagonal elements of the distance matrix will always be zero. # Examples: ```python def are_distances_symmetric(distance_matrix: List[List[float]]) -> bool: Checks if the given distance matrix is symmetric. Parameters: - distance_matrix : List[List[float]] : A square matrix representing distances between points Returns: - bool : True if the distance matrix is symmetric, False otherwise n = len(distance_matrix) for i in range(n): for j in range(n): if distance_matrix[i][j] != distance_matrix[j][i]: return False return True # Example 1: matrix1 = [ [0, 2, 3], [2, 0, 4], [3, 4, 0], ] print(are_distances_symmetric(matrix1)) # Output: True # Example 2: matrix2 = [ [0, 2, 3], [2, 0, 5], [4, 4, 0], ] print(are_distances_symmetric(matrix2)) # Output: False ``` # Requirements: Implement the function as described and ensure it handles all edge conditions. Use the provided examples to test your implementation.","solution":"from typing import List def are_distances_symmetric(distance_matrix: List[List[float]]) -> bool: Checks if the given distance matrix is symmetric. Parameters: - distance_matrix : List[List[float]] : A square matrix representing distances between points Returns: - bool : True if the distance matrix is symmetric, False otherwise n = len(distance_matrix) for i in range(n): for j in range(n): if distance_matrix[i][j] != distance_matrix[j][i]: return False return True"},{"question":"# Question: Recursive Directory Size Calculation Context You are a software developer working on a file management tool that helps users understand disk space usage. One of the tasks is to calculate the total size of a directory, including all its subdirectories and files. In this problem, you need to write a function that recursively calculates the size of a given directory. Task Implement a Python function `calculate_directory_size(directory: str) -> int` that recursively calculates the total size of a given directory. Input - `directory`: A string representing the path to the directory. Output - Returns an integer representing the total size of the directory in bytes. Constraints 1. You may assume all paths provided are valid and accessible. 2. The directory may contain both files and subdirectories. 3. The size of each file should be added to the total size. 4. Use the `os` and `os.path` modules for file and directory operations. Example ```python import os def calculate_directory_size(directory: str) -> int: # Function to be implemented pass # Example usage # Assuming the following directory structure: # /example # ├── file1.txt (200 bytes) # ├── file2.txt (300 bytes) # └── subdir # ├── file3.txt (150 bytes) # └── file4.txt (250 bytes) print(calculate_directory_size(\'/example\')) # Output: 900 ``` Notes - Ensure your solution comprehensively handles directories with multiple levels of nested subdirectories. - Use appropriate error handling to manage potential issues with file reading and permission. - Consider edge cases, such as empty directories and directories with only files or only subdirectories.","solution":"import os def calculate_directory_size(directory: str) -> int: total_size = 0 for dirpath, dirnames, filenames in os.walk(directory): for filename in filenames: filepath = os.path.join(dirpath, filename) if os.path.exists(filepath): total_size += os.path.getsize(filepath) return total_size"},{"question":"# Scenario You are tasked with implementing a search algorithm to locate the first recurring character in a given string. This problem involves creating a function that efficiently identifies and returns the first character that appears more than once in the string. If no recurring characters are found, the function should return `None`. # Requirements 1. **Implementation of First Recurring Character Finder** - Write a function `first_recurring_character` that identifies the first recurring character in a string. - Optimize the function to minimize the number of passes and checks required. # Input - `s` (str): An input string. # Output - `char` (str): The first recurring character, or `None` if no such character exists. # Constraints - The input string contains only lowercase letters. - 1 ≤ len(s) ≤ 1000. # Function Signature ```python def first_recurring_character(s: str) -> str: pass ``` # Sample Input and Output ```python >>> first_recurring_character(\\"acbbac\\") \'b\' >>> first_recurring_character(\\"abcdef\\") None >>> first_recurring_character(\\"abccba\\") \'c\' >>> first_recurring_character(\\"thedogranfast\\") None ``` # Instructions 1. **Efficiency**: Implement the function with an efficient search algorithm to handle the maximum string length within acceptable time limits. 2. **Edge Cases**: Ensure the function correctly handles strings with no recurring characters as well as those with immediate recurrences.","solution":"def first_recurring_character(s: str) -> str: Finds the first recurring character in the string s. Returns the first recurring character or None if there are no recurrences. seen = set() for char in s: if char in seen: return char seen.add(char) return None"},{"question":"# Problem Statement You have been given the task of managing orders in an online e-commerce platform. Each order can consist of multiple items, each with a specified quantity and price. You are required to implement a Python class to handle these orders efficiently. Additionally, you will need to add functionality to calculate the total value of an order, identify the most expensive item in an order, and merge two orders. # Requirements 1. Implement a function `calculate_total` that computes the total value of all items in the order. 2. Implement a function `most_expensive_item` that returns the name of the most expensive item in the order. 3. Implement a method `merge_order` that takes another order and merges it with the current order, combining quantities for items that appear in both orders. # Provided Code You have the starting implementation for an `Item` class and an `Order` class. Expand the `Order` class with the specified functionalities. # Function Signatures ```python def calculate_total(self) -> float: pass def most_expensive_item(self) -> str: pass def merge_order(self, other: \'Order\') -> \'Order\': pass ``` # Input and Output Formats * **calculate_total**: - **Input**: No additional input. - **Output**: The total value (float) of all items in the order. * **most_expensive_item**: - **Input**: No additional input. - **Output**: The name of the most expensive item (string). * **merge_order**: - **Input**: Another `Order` instance. - **Output**: A new `Order` instance representing the merged order. # Constraints 1. The item quantities and prices are non-negative. 2. The total value should be computed to two decimal places if necessary. 3. In case of merging orders with the same item, sum their quantities. # Provided Classes ```python class Item: def __init__(self, name: str, quantity: int, price: float): self.name = name self.quantity = quantity self.price = price class Order: def __init__(self): self.items = {} def add_item(self, item: Item): if item.name in self.items: self.items[item.name].quantity += item.quantity else: self.items[item.name] = item ``` # Scenario Alice is managing orders for her online store. After adding several items to an order, she wants to quickly calculate the total order value, identify the most expensive item, and merge new incoming orders with existing orders. Implement the functions to assist Alice in her tasks. # Usage Example ```python order = Order() order.add_item(Item(\\"Laptop\\", 1, 1500.00)) order.add_item(Item(\\"Mouse\\", 2, 25.00)) order.add_item(Item(\\"Keyboard\\", 1, 100.00)) print(order.calculate_total()) # Output: 1650.00 print(order.most_expensive_item()) # Output: \\"Laptop\\" order2 = Order() order2.add_item(Item(\\"Mouse\\", 1, 25.00)) order2.add_item(Item(\\"Headphones\\", 1, 200.00)) merged_order = order.merge_order(order2) print(merged_order.calculate_total()) # Output: 1875.00 print(merged_order.most_expensive_item()) # Output: \\"Laptop\\" ``` To implement the `calculate_total`, `most_expensive_item`, and `merge_order` methods, add them to your `Order` class accordingly and test them with the provided scenarios.","solution":"class Item: def __init__(self, name: str, quantity: int, price: float): self.name = name self.quantity = quantity self.price = price class Order: def __init__(self): self.items = {} def add_item(self, item: Item): if item.name in self.items: self.items[item.name].quantity += item.quantity else: self.items[item.name] = item def calculate_total(self) -> float: total = 0.0 for item in self.items.values(): total += item.quantity * item.price return round(total, 2) def most_expensive_item(self) -> str: if not self.items: return None most_expensive = max(self.items.values(), key=lambda item: item.price) return most_expensive.name def merge_order(self, other: \'Order\') -> \'Order\': new_order = Order() for name, item in self.items.items(): new_order.add_item(Item(name, item.quantity, item.price)) for name, item in other.items.items(): new_order.add_item(Item(name, item.quantity, item.price)) return new_order"},{"question":"# Problem Statement You are required to implement a simple version of a HashSet class. The HashSet should provide functionalities to add, remove, and check for the existence of elements, as well as methods to retrieve all elements and check the size of the set. The goal is to practice implementing hash-based data structures and handling collisions. Implement methods in the HashSet class as follows: 1. **Adding Elements to the Set** 2. **Removing Elements from the Set** 3. **Checking for the Existence of Elements** 4. **Retrieving All Elements** 5. **Getting the Size of the Set** # Function Specifications 1. **Add Function** ```python def add(self, value: int) -> None: ``` - **Input**: An integer value. - **Output**: None. - **Constraints**: Does nothing if the value already exists in the set. 2. **Remove Function** ```python def remove(self, value: int) -> None: ``` - **Input**: An integer value. - **Output**: None. - **Constraints**: Raises ValueError if the value doesn\'t exist in the set. 3. **Contains Function** ```python def contains(self, value: int) -> bool: ``` - **Input**: An integer value. - **Output**: Returns True if the value exists in the set, otherwise False. 4. **All Elements Function** ```python def all_elements(self) -> List[int]: ``` - **Input**: None. - **Output**: A list of all integers in the set. 5. **Size Function** ```python def size(self) -> int: ``` - **Input**: None. - **Output**: An integer representing the number of elements in the set. # Examples ```python s = HashSet() assert s.size() == 0 s.add(1) s.add(2) s.add(1) # Duplicate, should not be added assert s.size() == 2 assert s.contains(1) is True assert s.contains(3) is False s.remove(1) assert s.contains(1) is False assert s.size() == 1 try: s.remove(1) # Should raise ValueError except ValueError: pass elements = s.all_elements() assert elements == [2] ```","solution":"class HashSet: def __init__(self): self.set = set() def add(self, value: int) -> None: self.set.add(value) def remove(self, value: int) -> None: if value in self.set: self.set.remove(value) else: raise ValueError(\\"Value does not exist in the set\\") def contains(self, value: int) -> bool: return value in self.set def all_elements(self): return list(self.set) def size(self) -> int: return len(self.set)"},{"question":"# Problem Statement: Create a function to analyze a given sentence and determine the frequency of each word appearing in that sentence. Additionally, your program should identify and return the most frequently occurring word. If there is a tie, return the word that appears first in the sentence. # Requirements: 1. Implement the following function: - `word_frequency_analysis(sentence: str) -> dict` 2. The function should: - Take a single string parameter `sentence`, which represents a sentence of words separated by spaces. - Return a dictionary where the keys are the words and the values are their corresponding frequencies in the sentence. - Include the key `\'most_frequent_word\'` in the result dictionary, corresponding to the word that occurs most frequently in the sentence. If there\'s a tie, return the word that appears first. # Input: - A single string representing the sentence. # Output: - A dictionary where: - Each key is a unique word in the sentence. - Each value is the frequency count of that word. - The key `\'most_frequent_word\'` corresponds to the most frequently occurring word in the sentence. # Constraints: - The sentence passed as input should be a non-empty string. - The sentence will only contain alphabetic characters and spaces, with words separated by single spaces. # Example: ```plaintext word_frequency_analysis(\\"the quick brown fox jumps over the lazy dog\\") Expected Output: {\'the\': 2, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 1, \'most_frequent_word\': \'the\'} word_frequency_analysis(\\"hello world hello\\") Expected Output: {\'hello\': 2, \'world\': 1, \'most_frequent_word\': \'hello\'} word_frequency_analysis(\\"apple apple apple banana banana\\") Expected Output: {\'apple\': 3, \'banana\': 2, \'most_frequent_word\': \'apple\'} ``` # Notes: - Consider using Python\'s `collections.Counter` to help with the word frequency counting. - Iterate through the sentence to ensure the correct identification of the most frequently occurring word in case of a tie. - Ensure that your function is efficient and handles edge cases, such as very short or long sentences, appropriately.","solution":"from collections import Counter def word_frequency_analysis(sentence: str) -> dict: words = sentence.split() word_counts = Counter(words) # Identify the most frequently occurring word most_frequent_word = \'\' highest_frequency = 0 for word in words: if word_counts[word] > highest_frequency: most_frequent_word = word highest_frequency = word_counts[word] # Convert the Counter object to a dictionary and add most_frequent_word key result = dict(word_counts) result[\'most_frequent_word\'] = most_frequent_word return result"},{"question":"# Question: Implement a Tic-Tac-Toe Checker Design a class to represent a Tic-Tac-Toe game board and provide functionality to check the current status of the game. The class should support the following operations: - `__init__(self, board: List[List[str]]) -> None`: Initializes the Tic-Tac-Toe board with the given 3x3 grid. - `move(self, row: int, col: int, player: str) -> None`: Records the move `player` (\'X\' or \'O\') at the specified row and column. - `check_winner(self) -> str`: Checks the current state of the board and returns \'X\' if player X has won, \'O\' if player O has won, \'Draw\' if the game is a draw, or \'Pending\' if the game is still in progress. - `__repr__(self) -> str`: Returns a string representation of the board. Function Signature: ```python class TicTacToe: def __init__(self, board: List[List[str]]): pass def move(self, row: int, col: int, player: str) -> None: pass def check_winner(self) -> str: pass def __repr__(self) -> str: pass ``` # Constraints: - The board will always be a 3x3 grid. - Players are represented by \'X\' and \'O\' characters. - An empty cell is represented by an empty string \\"\\". - The `move` method should update the position if the cell is empty and no winner has been declared yet. # Example: ```python board = [ [\\"\\", \\"\\", \\"\\"], [\\"\\", \\"\\", \\"\\"], [\\"\\", \\"\\", \\"\\"] ] game = TicTacToe(board) game.move(0, 0, \'X\') print(game) # Output: # X | | # | | # | | game.move(1, 1, \'O\') print(game) # Output: # X | | # | O | # | | print(game.check_winner()) # Output: Pending game.move(0, 1, \'X\') game.move(0, 2, \'X\') print(game.check_winner()) # Output: X ```","solution":"from typing import List class TicTacToe: def __init__(self, board: List[List[str]]): self.board = board def move(self, row: int, col: int, player: str) -> None: if self.board[row][col] == \\"\\" and self.check_winner() == \\"Pending\\": self.board[row][col] = player def check_winner(self) -> str: # Check rows for row in self.board: if row[0] == row[1] == row[2] != \\"\\": return row[0] # Check columns for col in range(3): if self.board[0][col] == self.board[1][col] == self.board[2][col] != \\"\\": return self.board[0][col] # Check diagonals if self.board[0][0] == self.board[1][1] == self.board[2][2] != \\"\\": return self.board[0][0] if self.board[0][2] == self.board[1][1] == self.board[2][0] != \\"\\": return self.board[0][2] # Check if there are empty cells left for row in self.board: if \\"\\" in row: return \\"Pending\\" return \\"Draw\\" def __repr__(self) -> str: rows = [\\" | \\".join(cell if cell != \\"\\" else \\" \\" for cell in row) for row in self.board] return \\"n\\".join(rows)"},{"question":"# Problem Statement You are tasked with developing a utility function to analyze the performance of an e-commerce website. The website records detailed logs of user interactions, and you need to generate an aggregated report of user sessions. Each session begins when a user logs in and ends when the user logs out. Your goal is to calculate the total duration of active sessions for each user. # Task Requirements 1. Implement a function `user_session_durations(logs: list[tuple[str, str, int]]) -> dict[str, int]` that takes a list of tuples as input and returns a dictionary. 2. Each tuple in the list represents a log record with three elements: * `user_id` (str): The ID of the user. * `action` (str): Either \'login\' or \'logout\'. * `timestamp` (int): An integer representing the time when the action occurred, guaranteed to be unique for each log entry. 3. The function should calculate the total duration that each user spent logged in during their sessions and return a dictionary where the keys are user IDs and the values are the total durations (in seconds) of their active sessions. # Input - The logs are in chronological order. - Each user will have matching \'login\' and \'logout\' actions for every session. - The timestamps are unique and sorted in ascending order. # Output - A dictionary where each key is a user ID and each value is the total duration that user spent logged in. # Constraints 1. The number of log records can be up to `10^6`. 2. There are no overlapping sessions for any user; every \'login\' will be followed by a corresponding \'logout\' before any new \'login\' for that user. # Example ```python logs = [ (\'user1\', \'login\', 1610000000), (\'user1\', \'logout\', 1610003600), (\'user2\', \'login\', 1610007200), (\'user2\', \'logout\', 1610010800), (\'user1\', \'login\', 1610014400), (\'user1\', \'logout\', 1610018000), ] print(user_session_durations(logs)) # Output: {\'user1\': 7200, \'user2\': 3600} ``` Implement the function in such a way that it is efficient and handles the constraints mentioned.","solution":"def user_session_durations(logs): user_sessions = {} active_sessions = {} for user_id, action, timestamp in logs: if action == \'login\': active_sessions[user_id] = timestamp elif action == \'logout\': if user_id in active_sessions: session_start = active_sessions.pop(user_id) session_duration = timestamp - session_start if user_id in user_sessions: user_sessions[user_id] += session_duration else: user_sessions[user_id] = session_duration return user_sessions"},{"question":"# Heap Sort Implementation Challenge **Scenario**: You have been recruited as a software engineer by a tech company that requires efficient data organization solutions. One of your first tasks is to develop a reliable sorting algorithm for their system. Given the need for efficiency and scalability, you decide to implement the Heap Sort algorithm. This algorithm is known for its robust performance and is particularly suited for handling large datasets. Your task is to implement a function that sorts a given list of integers in ascending order using Heap Sort. Your solution should be capable of handling large lists efficiently and manage edge cases such as empty lists or lists with duplicate values. **Task**: Write a function `heap_sort` that sorts a given list of integers in ascending order using the Heap Sort algorithm. # Function Signature ```python def heap_sort(collection: list[int]) -> list[int]: pass ``` # Input - A list of integer values, `collection` (0 <= len(collection) <= 10^6, -10^9 <= collection[i] <= 10^9). # Output - A list of integers sorted in ascending order. # Constraints 1. The list can be as large as 1,000,000 elements. 2. The code should handle negative numbers and duplicate values. 3. The function should modify `collection` in-place to optimize space usage. # Example ```python print(heap_sort([0, 5, 3, 2, 2])) # Output: [0, 2, 2, 3, 5] print(heap_sort([])) # Output: [] print(heap_sort([-2, -5, -45])) # Output: [-45, -5, -2] ``` # Evaluation Criteria 1. **Accuracy**: Correctly sorts the list of integers. 2. **Efficiency**: Effectively implements the Heap Sort algorithm with optimal performance on large datasets. 3. **Robustness**: Handles various edge cases, including empty and duplicate-laden lists. 4. **Clarity**: Code is well-organized, clearly commented, and easy to follow. **Note**: Including internal comments to explain the heap construction and sorting process will be appreciated and helpful for the evaluation of your approach.","solution":"def heapify(arr, n, i): Helper function to maintain the heap property of a subtree rooted at index i. n is the size of the heap. largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[left] > arr[largest]: largest = left # See if right child of root exists and is greater than root if right < n and arr[right] > arr[largest]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) def heap_sort(collection): Sorts a collection of integers in ascending order using the Heap Sort algorithm. n = len(collection) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(collection, n, i) # One by one extract elements for i in range(n - 1, 0, -1): collection[i], collection[0] = collection[0], collection[i] # swap heapify(collection, i, 0) return collection"},{"question":"# Question: Implement and Visualize a Low-Pass Filter in Python Scenario You are tasked with designing an audio processing application where reducing high-frequency noise from audio signals is crucial. To achieve this, you need to implement a low-pass filter and visualize its effect on the signal\'s frequency and impulse responses. Task 1. Implement a class `LowPassFilter` that simulates a simple low-pass filter. This class should conform to the `FilterType` protocol by implementing the `process` method, which takes a sample and returns the filtered sample. 2. Write a function `configure_low_pass_filter(cutoff_freq: float, samplerate: int) -> LowPassFilter` that initializes and returns a `LowPassFilter` instance. The function should use the provided `cutoff_freq` and `samplerate` to configure the filter correctly. 3. Visualize the frequency and impulse responses of your low-pass filter using the provided `show_frequency_response` and `show_impulse_response` functions. Input and Output Formats - **Input**: - A cutoff frequency `cutoff_freq` (float) in Hertz. - A sampling rate `samplerate` (int) in samples per second. - **Output**: - The `configure_low_pass_filter` function should return an instance of `LowPassFilter`. - Visualization functions should display plots via `matplotlib`. Constraints: - The `cutoff_freq` must be between 1 Hz and half of the `samplerate`. - The `samplerate` should be a positive integer, typically between 8,000 Hz to 192,000 Hz. Performance Requirements: - The `process` method should handle sample-by-sample processing efficiently. Implementation Hints: - Utilize digital filter design principles like the difference equation of an IIR filter. - Use numpy and scipy libraries for necessary mathematical operations. Requirements: - Ensure your code includes sufficient error-checking and handles edge cases appropriately. - Add brief documentation and comments explaining your key decisions and logic. ```python from scipy.signal import butter, lfilter_zi, lfilter class LowPassFilter(FilterType): def __init__(self, cutoff_freq, samplerate): self.cutoff_freq = cutoff_freq self.samplerate = samplerate self.b, self.a = butter(1, cutoff_freq / (0.5 * samplerate), btype=\'low\', analog=False) self.zi = lfilter_zi(self.b, self.a) * 0 # initialize filter state def process(self, sample: float) -> float: filtered_sample, self.zi = lfilter(self.b, self.a, [sample], zi=self.zi) return filtered_sample[0] def configure_low_pass_filter(cutoff_freq: float, samplerate: int) -> LowPassFilter: if not (1 <= cutoff_freq <= samplerate / 2): raise ValueError(\\"cutoff_freq must be between 1 Hz and half of the samplerate\\") if samplerate <= 0: raise ValueError(\\"samplerate must be a positive integer\\") return LowPassFilter(cutoff_freq, samplerate) # Sample usage: # filt = configure_low_pass_filter(500.0, 44100) # show_frequency_response(filt, 44100) # show_impulse_response(filt, 44100) ``` # Testing the Implementation To ensure that the `LowPassFilter` works correctly: 1. Create instances with varying cutoff frequencies and sample rates. 2. Generate test signals and apply the filter to observe the output. 3. Use visualization functions to verify the frequency and impulse responses match expectations. Note: The `show_frequency_response` and `show_impulse_response` functions should generate plots that allow you to evaluate the filter performance visually.","solution":"import numpy as np from scipy.signal import butter, lfilter_zi, lfilter class LowPassFilter: def __init__(self, cutoff_freq, samplerate): self.cutoff_freq = cutoff_freq self.samplerate = samplerate self.b, self.a = butter(1, cutoff_freq / (0.5 * samplerate), btype=\'low\', analog=False) self.zi = lfilter_zi(self.b, self.a) * 0 # initialize filter state def process(self, sample: float) -> float: filtered_sample, self.zi = lfilter(self.b, self.a, [sample], zi=self.zi) return filtered_sample[0] def configure_low_pass_filter(cutoff_freq: float, samplerate: int) -> LowPassFilter: if not (1 <= cutoff_freq <= samplerate / 2): raise ValueError(\\"cutoff_freq must be between 1 Hz and half of the samplerate\\") if samplerate <= 0: raise ValueError(\\"samplerate must be a positive integer\\") return LowPassFilter(cutoff_freq, samplerate) def show_frequency_response(filter_instance, samplerate): import matplotlib.pyplot as plt from scipy.signal import freqz w, h = freqz(filter_instance.b, filter_instance.a, worN=8000) plt.plot(0.5 * samplerate * w / np.pi, np.abs(h), \'b\') plt.plot(filter_instance.cutoff_freq, 0.5 * np.sqrt(2), \'ko\') plt.axvline(filter_instance.cutoff_freq, color=\'k\') plt.xlim(0, 0.5 * samplerate) plt.title(\\"Frequency Response\\") plt.xlabel(\'Frequency [Hz]\') plt.ylabel(\'Gain\') plt.grid() plt.show() def show_impulse_response(filter_instance, samplerate): import matplotlib.pyplot as plt impulse = np.zeros(100) impulse[0] = 1.0 response = np.zeros(100) for i in range(100): response[i] = filter_instance.process(impulse[i]) plt.plot(response, \'b\') plt.title(\'Impulse Response\') plt.xlabel(\'Samples\') plt.ylabel(\'Amplitude\') plt.grid() plt.show()"},{"question":"# Problem Statement: Text Clustering with K-Means You are provided with a collection of text documents and your task is to implement a K-Means clustering algorithm to categorize these documents into a given number of clusters based on their TF-IDF features. # Function Signature ```python def text_kmeans_clustering(docs: list[str], k: int) -> list[int]: pass ``` # Parameters * `docs` (list[str]): A list of text documents. * `k` (int): The number of clusters for the K-Means algorithm. # Output * A list of integers where each index represents the cluster assignment of the corresponding document in `docs`. # Constraints * Each document in `docs` is a non-empty string. * `k` must be a positive integer and must not exceed the number of documents. * The function should raise appropriate errors for invalid inputs. # Examples ```python # Example 1 docs = [ \\"This is a document about machine learning.\\", \\"Machine learning involves models and data.\\", \\"This document is about natural language processing.\\", \\"Natural language processing and machine learning are closely related.\\" ] k = 2 print(text_kmeans_clustering(docs, k)) # Expected Output: [0, 0, 1, 1] (or any other valid clustering) # Example 2 docs = [ \\"Apple is a fruit.\\", \\"Banana is also a fruit.\\", \\"Apple and Banana are fruits.\\", \\"Computers are electronic devices.\\", \\"Laptops are a type of computer.\\" ] k = 3 print(text_kmeans_clustering(docs, k)) # Expected Output: [0, 0, 0, 1, 1] (or any other valid clustering) ``` # Additional Information 1. Perform appropriate preprocessing on text documents such as removing punctuation, stop words, and applying lowercasing. 2. Utilize the TF-IDF (Term Frequency-Inverse Document Frequency) technique to convert text documents into numerical features. 3. Implement and apply the K-Means clustering algorithm using these features. 4. Handle edge cases such as documents with significantly different lengths or highly similar documents. 5. Ensure the function is efficient and can process a moderate number of documents within a reasonable time.","solution":"from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.cluster import KMeans import numpy as np def text_kmeans_clustering(docs: list[str], k: int) -> list[int]: if not isinstance(docs, list) or not all(isinstance(doc, str) for doc in docs): raise ValueError(\\"docs must be a list of strings.\\") if not isinstance(k, int) or k <= 0 or k > len(docs): raise ValueError(\\"k must be a positive integer and less than or equal to the number of documents.\\") # Initialize TfidfVectorizer vectorizer = TfidfVectorizer(stop_words=\'english\', lowercase=True) tfidf_matrix = vectorizer.fit_transform(docs) # Perform K-Means clustering kmeans = KMeans(n_clusters=k, random_state=42) kmeans.fit(tfidf_matrix) # Return the cluster assignments return kmeans.labels_.tolist()"},{"question":"# **Meeting Scheduler** # Problem Statement: You are required to build a meeting scheduler that checks if a proposed meeting time conflicts with any existing meetings. Your application will receive a list of existing meetings and a proposed new meeting time. Each meeting is defined by a start and end time, and no two meetings should overlap. # Function Definitions: Function 1: `check_meeting_conflict(existing_meetings: List[Tuple[int, int]], new_meeting: Tuple[int, int]) -> bool` - **Input**: * A list of tuples where each tuple represents an existing meeting’s start and end time in the form `(start, end)`. * A tuple representing the new meeting’s start and end time `(start, end)`. - **Output**: * A boolean value indicating whether the new meeting time conflicts with any existing meetings. - **Constraints**: * Each meeting starts and ends on the same day and follows a 24-hour format (e.g., 900 for 9:00 AM and 1545 for 3:45 PM). * Sleep time is not considered, and meetings start from 0000 to 2359. Function 2: `add_meeting(existing_meetings: List[Tuple[int, int]], new_meeting: Tuple[int, int]) -> List[Tuple[int, int]]` - **Input**: * A list of tuples where each tuple represents existing meetings\' start and end times. * A tuple representing the new meeting’s start and end time. - **Output**: * A list of tuples representing all meetings, including the newly added meeting. - **Constraints**: * Only add the new meeting if `check_meeting_conflict` returns `False`. * If `check_meeting_conflict` returns `True`, do not add the new meeting and return the original list unchanged. # Task Instructions: 1. Implement the `check_meeting_conflict` function. 2. Implement the `add_meeting` function. 3. Write a main block to test your functions and ensure they work correctly with different input scenarios. # Example: Given the following input: ```python existing_meetings = [(900, 1030), (1300, 1430), (1600, 1730)] new_meeting = (1000, 1100) ``` 1. `check_meeting_conflict(existing_meetings, new_meeting)` would return `True` (since the new meeting overlaps with the first meeting from 900 to 1030). 2. `add_meeting(existing_meetings, new_meeting)` would return `[(900, 1030), (1300, 1430), (1600, 1730)]` since there’s a conflict, and the new meeting will not be added. Given a different new meeting: ```python new_meeting = (1100, 1200) ``` 1. `check_meeting_conflict(existing_meetings, new_meeting)` would return `False` (since the new meeting does not overlap with any existing meetings). 2. `add_meeting(existing_meetings, new_meeting)` would return `[(900, 1030), (1300, 1430), (1600, 1730), (1100, 1200)]` since there’s no conflict, and the new meeting will be added. # Constraints: * Meetings are bounded within a single day. * Ensure that the meeting times are valid, where start time is less than end time, and times are non-negative integers. * Handle edge cases where meetings could start or end at the same time or exactly with the opening and closing times (0000 to 2359).","solution":"from typing import List, Tuple def check_meeting_conflict(existing_meetings: List[Tuple[int, int]], new_meeting: Tuple[int, int]) -> bool: Checks if a new meeting conflicts with any existing meetings. :param existing_meetings: List of tuples where each tuple represents an existing meeting\'s start and end time. :param new_meeting: A tuple representing the new meeting\'s start and end time. :return: Boolean value indicating whether the new meeting time conflicts with any existing meetings. new_start, new_end = new_meeting for start, end in existing_meetings: if not (new_end <= start or new_start >= end): return True return False def add_meeting(existing_meetings: List[Tuple[int, int]], new_meeting: Tuple[int, int]) -> List[Tuple[int, int]]: Adds a new meeting to the list of existing meetings if there is no conflict. :param existing_meetings: List of tuples where each tuple represents existing meetings\' start and end times. :param new_meeting: A tuple representing the new meeting\'s start and end time. :return: List of tuples representing all meetings including the newly added meeting. if check_meeting_conflict(existing_meetings, new_meeting): return existing_meetings return existing_meetings + [new_meeting]"},{"question":"# Description: You are provided with a function `filter_even_numbers` and `filter_odd_numbers` which filter out even and odd numbers from a list, respectively, returning a new list containing only the filtered numbers. Your task is to implement a combined method that utilizes both filters based on a specified filter type. # Task: Implement a function `filter_numbers(nums: list[int], filter_type: str) -> list[int]` that: 1. Uses the `filter_even_numbers` function if the `filter_type` provided is \\"even\\". 2. Uses the `filter_odd_numbers` function if the `filter_type` provided is \\"odd\\". 3. Raises a `ValueError` with an appropriate error message if the `filter_type` is neither \\"even\\" nor \\"odd\\". 4. Handles an empty list by returning an empty list. # Constraints: - The list `nums` contains only integers. - The `filter_type` must be either \\"even\\" or \\"odd\\". - The function must handle invalid filter types by raising a `ValueError`. # Inputs: - `nums` (List of integers): The list of numbers to be filtered. - `filter_type` (String): A string indicating the type of numbers to filter, either \\"even\\" or \\"odd\\". # Output: - Returns a new list of integers containing only the filtered numbers based on the `filter_type`. # Example Usage: ```python >>> filter_numbers([1, 2, 3, 4, 5, 6], \\"even\\") [2, 4, 6] >>> filter_numbers([1, 2, 3, 4, 5, 6], \\"odd\\") [1, 3, 5] >>> filter_numbers([], \\"even\\") [] >>> filter_numbers([10, 15, 20, 25], \\"even\\") [10, 20] >>> filter_numbers([10, 15, 20, 25], \\"odd\\") [15, 25] >>> filter_numbers([1, 3, 5, 7, 9], \\"odd\\") [1, 3, 5, 7, 9] >>> filter_numbers([1, 3, 5, 7, 9], \\"even\\") [] >>> filter_numbers([1, 2, 3, 4], \\"prime\\") Traceback (most recent call last): ... ValueError: filter_numbers() unknown filter type \\"prime\\" ``` # Note: - Ensure your implementation leverages the pre-existing functions `filter_even_numbers` and `filter_odd_numbers`. - Validate the `filter_type` parameter correctly and provide informative error messages. ```python def filter_even_numbers(nums: list[int]) -> list[int]: return [num for num in nums if num % 2 == 0] def filter_odd_numbers(nums: list[int]) -> list[int]: return [num for num in nums if num % 2 != 0] def filter_numbers(nums: list[int], filter_type: str) -> list[int]: if filter_type == \\"even\\": return filter_even_numbers(nums) elif filter_type == \\"odd\\": return filter_odd_numbers(nums) else: raise ValueError(f\'filter_numbers() unknown filter type \\"{filter_type}\\"\') ```","solution":"def filter_even_numbers(nums: list[int]) -> list[int]: return [num for num in nums if num % 2 == 0] def filter_odd_numbers(nums: list[int]) -> list[int]: return [num for num in nums if num % 2 != 0] def filter_numbers(nums: list[int], filter_type: str) -> list[int]: if filter_type == \\"even\\": return filter_even_numbers(nums) elif filter_type == \\"odd\\": return filter_odd_numbers(nums) else: raise ValueError(f\'filter_numbers() unknown filter type \\"{filter_type}\\"\')"},{"question":"# Question: Implement a Custom String Compression Algorithm Context You work for a company that specializes in data storage solutions. To maximize storage efficiency, the team is working on compressing strings where repeated letters are replaced by their frequency count. Task Implement a string compression function that collapses groups of the same character into a single instance of that character followed by its count. If the compressed string is not shorter than the original string, return the original string. # Requirements 1. **Function Signature**: `def compress_string(s: str) -> str:` 2. **Input**: - A single string, `s`, which consists of uppercase ASCII letters (A-Z). - Example: `\\"AAABBBCCDAA\\"`, `\\"AABBCC\\"`, `\\"A\\"` 3. **Output**: - A compressed version of the input string `s` if it results in a shorter length string, otherwise the original string. 4. **Constraints**: - You must preserve the order of characters. - Only compress sequences that are 2 or longer (e.g., `\\"AAB\\"` would compress to `\\"A2B\\"`, but `\\"AB\\"` would not). - Keep the compressed format simple for readability. # Performance Expectations - The solution should target **O(n)** time complexity, where `n` is the length of the string. - Space complexity should be **O(n)** due to the need to store new strings. Example ```python >>> compress_string(\\"AAABBBCCDAA\\") \\"A3B3C2DA2\\" >>> compress_string(\\"AABBCC\\") \\"AABBCC\\" # not shorter after compression >>> compress_string(\\"A\\") \\"A\\" >>> compress_string(\\"ABBBBBCCC\\") \\"AB5C3\\" ```","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 # Append the last group compressed.append(s[-1]) if count > 1: compressed.append(str(count)) compressed_string = \'\'.join(compressed) # Return the original string if it\'s shorter or equal to the compressed version return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Problem: Warehouse Inventory Management System You are tasked with developing a warehouse inventory management system where each product is tracked by a unique product code. The inventory keeps records of product availability and supports operations to add new products, update quantities, and remove products from stock. The system should also provide functionality to query the current inventory level for a specific product. Instructions: 1. **Class Name**: `InventoryManager` 2. **Methods**: - `add_product(product_code: str, quantity: int) -> None`: Adds a new product with the given quantity to the inventory. If the product already exists, increase its quantity. - `update_quantity(product_code: str, quantity: int) -> None`: Updates the quantity of the specified product. If the product does not exist, add it to the inventory with the given quantity. - `remove_product(product_code: str) -> None`: Removes the product with the specified product code from the inventory. - `get_quantity(product_code: str) -> int`: Returns the current quantity of the specified product. If the product does not exist, return `0`. 3. **Constraints**: - All product codes are unique strings. - Quantities are non-negative integers. 4. **Performance Requirement**: - All methods should operate efficiently, particularly for large inventories. You are required to implement the `InventoryManager` class according to the following framework: ```python class InventoryManager: def __init__(self): # Initialize the inventory dictionary self.inventory = {} def add_product(self, product_code: str, quantity: int) -> None: # Add your implementation here pass def update_quantity(self, product_code: str, quantity: int) -> None: # Update the quantity of the given product pass def remove_product(self, product_code: str) -> None: # Remove the product from inventory pass def get_quantity(self, product_code: str) -> int: # Return the quantity of the given product pass # Example usage: # inv_manager = InventoryManager() # inv_manager.add_product(\\"A1001\\", 50) # inv_manager.update_quantity(\\"A1001\\", 75) # inv_manager.remove_product(\\"A1001\\") # print(inv_manager.get_quantity(\\"A1001\\")) # Expected output: 0 if __name__ == \\"__main__\\": inv_manager = InventoryManager() inv_manager.add_product(\\"A1001\\", 50) inv_manager.update_quantity(\\"A1001\\", 75) inv_manager.remove_product(\\"A1001\\") print(\\"Quantity of A1001:\\", inv_manager.get_quantity(\\"A1001\\")) ``` Scenario: You are building this inventory system for a large warehouse that needs to efficiently manage a diverse range of products. Robust inventory management is critical to ensure that stock levels are accurately maintained for all operations, including reordering, shipping, and auditing. **Deliverable**: Provide your complete implementation of the `InventoryManager` class with all specified methods. Ensure your code efficiently handles additions, updates, removals, and queries for product quantities.","solution":"class InventoryManager: def __init__(self): # Initialize the inventory dictionary self.inventory = {} def add_product(self, product_code: str, quantity: int) -> None: if product_code in self.inventory: self.inventory[product_code] += quantity else: self.inventory[product_code] = quantity def update_quantity(self, product_code: str, quantity: int) -> None: self.inventory[product_code] = quantity def remove_product(self, product_code: str) -> None: if product_code in self.inventory: del self.inventory[product_code] def get_quantity(self, product_code: str) -> int: return self.inventory.get(product_code, 0)"},{"question":"# Scenario Imagine you are given a list of integers where each integer represents the energy required to complete a task. You can distribute the energy units to different tasks such that the sum of energy distributed is minimized, given that you have a limited amount of energy units to distribute each day. Each completed task adds up to the overall efficiency score, and tasks should ideally be completed in the order they appear in the list. # Problem Statement Implement a function `min_energy(tasks: List[int], max_daily_energy: int) -> int` that takes a list of integers where each integer represents the energy required for a task, and an integer representing the maximum amount of energy units that can be distributed each day. The function should return the minimum number of days required to distribute the energy units and complete all tasks. # Input - `tasks`: A list of `n` integers where each integer `t` represents the energy required for a task. - `1 <= t <= 10^4` - `1 <= len(tasks) <= 10^5` - `max_daily_energy`: An integer representing the maximum amount of energy units that can be distributed each day. - `1 <= max_daily_energy <= 10^5` # Output - An integer representing the minimum number of days required to distribute energy units and complete all tasks. # Constraints - Each task must receive exactly the required amount of energy either partially over multiple days or entirely in one day. - The tasks must be completed in the same order they appear in the list. # Example - `min_energy([10, 20, 30], 15)` should return `4`. - Explanation: Distribute energy as Day 1: 10 (Task 1), Day 2: 15 (Task 2), Day 3: 5 (Task 2) + 10 (Task 3), Day 4: 20 (Task 3). - `min_energy([5, 5, 5], 10)` should return `2`. - Explanation: Distribute energy as Day 1: 5 (Task 1) + 5 (Task 2), Day 2: 5 (Task 3). **Note**: Ensure your function is optimized to handle up to the maximum constraints efficiently, aiming for a time complexity of O(n). # Requirements - Your implementation should handle edge cases where: - All tasks require minimal energy. - Tasks require varying and maximum energy close to the daily limit.","solution":"from typing import List def min_energy(tasks: List[int], max_daily_energy: int) -> int: days = 0 current_day_energy = 0 for task in tasks: while task > 0: if current_day_energy == 0: days += 1 current_day_energy = max_daily_energy if task <= current_day_energy: current_day_energy -= task task = 0 else: task -= current_day_energy current_day_energy = 0 return days"},{"question":"# Question **Context**: Efficient data structures are crucial for optimizing the performance of many algorithms. One such data structure is the linked list, which allows for efficient insertion and deletion operations. In this task, you will create a linked list and implement a function that detects if there is a cycle in the linked list. Task Write a function `has_cycle(head: ListNode) -> bool` that checks whether a given linked list has a cycle. Input - `head` (ListNode): The head node of the linked list. Output - Return `True` if there is a cycle in the linked list. - Return `False` if there is no cycle in the linked list. Constraints - The linked list contains between 0 and 10000 nodes. Examples ```python # Example 1 # Input: 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle) head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) head.next.next.next.next.next = head.next assert has_cycle(head) == True # Example 2 # Input: 1 -> 2 -> 3 -> 4 -> 5 (no cycle) head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) assert has_cycle(head) == False # Example 3 # Input: (empty list) head = None assert has_cycle(head) == False ``` Additional Notes - For this task, you can define the `ListNode` class as follows: ```python class ListNode: def __init__(self, x): self.val = x self.next = None ``` - Implement an efficient solution that does not use extra memory, such as storing the visited nodes in a set. - Consider using Floyd’s Cycle-Finding Algorithm (the \\"Tortoise and Hare\\" algorithm) for a more efficient solution.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: Detects if there is a cycle in a linked list. Uses Floyd\'s Cycle-Finding Algorithm, also known as the Tortoise and Hare algorithm. :param head: ListNode - the head of the linked list :return: bool - True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"Problem Statement # Largest Common Substring You are given two strings, `str1` and `str2`. Your task is to implement a function `largest_common_substring(str1: str, str2: str) -> str` that returns the largest common substring of the two given strings. If there are multiple substrings with the same maximum length, return the one which appears first in `str1`. # Input - **str1**: A string consisting of lowercase English letters, with length (1 leq |str1| leq 1000). - **str2**: A string consisting of lowercase English letters, with length (1 leq |str2| leq 1000). # Output Return the largest common substring of `str1` and `str2`. If no common substring exists, return an empty string. # Example ```python >>> largest_common_substring(\\"abcdef\\", \\"zcdghef\\") \\"cd\\" >>> largest_common_substring(\\"axbyc\\", \\"lmnobyq\\") \\"by\\" >>> largest_common_substring(\\"abc\\", \\"def\\") \\"\\" ``` # Constraints - The input strings will only contain lowercase English letters. - The input strings will have lengths within the specified range. # Requirements - Handle edge cases such as completely disjoint strings. - Optimize your solution for efficiency, ensuring it can handle the upper limits of the input size efficiently. # Implementation Notes Consider developing an efficient algorithm such as dynamic programming or suffix trees to determine the largest common substring. Ensure your solution handles the constraints effectively.","solution":"def largest_common_substring(str1, str2): Returns the largest common substring of str1 and str2. # Initialize the table for dynamic programming dp = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)] max_len = 0 max_substr_end_idx = 0 # Fill dp table for i in range(1, len(str1) + 1): for j in range(1, len(str2) + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_len: max_len = dp[i][j] max_substr_end_idx = i return str1[max_substr_end_idx - max_len:max_substr_end_idx]"},{"question":"# Find First and Last Position of Element in Sorted Array Context You\'re developing a search feature for a large-scale application where data is stored in sorted arrays for quick retrieval. To improve user experience, you need to implement a function that finds the first and last positions of a given target in a sorted array. Function Signature ```python def search_range(nums: List[int], target: int) -> List[int]: pass ``` Input - `nums` (List[int]): A list of integers sorted in ascending order. - Constraints: - The list will contain between 0 and 1,000,000 integers. - Integers will be between -1,000,000 and 1,000,000 (inclusive). - `target` (int): The target value to search for in the list. - Constraints: - The target will be an integer between -1,000,000 and 1,000,000 (inclusive). Output - Returns a list of two integers representing the starting and ending positions of the target in the array. - If the target is not found in the array, the function should return `[-1, -1]`. Requirements - The function should run in O(log n) time complexity where n is the length of the list. - The binary search algorithm must be utilized to ensure efficient searching. - The function should use O(1) extra space. # Additional Clarifications - If the array is empty, the function should return `[-1, -1]`. - If the target value does not exist in the array, return `[-1, -1]`. - Duplicates of the target value are allowed; the function should return the first and last indices of the target. Example Usage ```python # Example inputs and expected outputs print(search_range([5, 7, 7, 8, 8, 10], 8)) # Expected output: [3, 4] print(search_range([5, 7, 7, 8, 8, 10], 6)) # Expected output: [-1, -1] print(search_range([], 0)) # Expected output: [-1, -1] print(search_range([1], 1)) # Expected output: [0, 0] print(search_range([2, 2, 2, 2, 2], 2)) # Expected output: [0, 4] ``` Now, implement the `search_range` function based on the specified requirements and constraints.","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: def find_leftmost(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_rightmost(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right leftmost = find_leftmost(nums, target) rightmost = find_rightmost(nums, target) if leftmost <= rightmost and rightmost < len(nums) and nums[leftmost] == target and nums[rightmost] == target: return [leftmost, rightmost] else: return [-1, -1]"},{"question":"# Product of Array Except Self You are given an array of integers and need to implement a function that returns an array `result` such that `result[i]` is equal to the product of all the elements of the input array except `arr[i]`. The function you need to implement is `product_except_self(arr)` where `arr` is a list of integers. # Function Signature ```python def product_except_self(arr: List[int]) -> List[int]: ``` # Input Format - `arr`: A list of integers with length `n` (1 ≤ n ≤ 10^5). # Output Format - A list of integers `result` of length `n` where `result[i]` is the product of all elements in the array except `arr[i]`. # Constraints - No division operation can be used. - Elements of the input list can be negative, positive, or zero. - Ensure that your solution runs in O(n) time complexity. # Performance Requirements - The solution should be efficient and handle input sizes up to 10^5 within a reasonable time frame. # Example ```python # Sample input arr = [1, 2, 3, 4] # Convert result = product_except_self(arr) print(result) # Output: [24, 12, 8, 6] # Sample input arr = [0, 1, 2, 3] # Convert result = product_except_self(arr) print(result) # Output: [6, 0, 0, 0] ``` **Note**: Do not use the division operator in your solution. Consider using additional arrays to keep track of the products of elements on the left and right of each element.","solution":"from typing import List def product_except_self(arr: List[int]) -> List[int]: n = len(arr) if n == 1: return [0] # As per problem statement, though there isn\'t a clear definition of single element case, we treat as special. left_products = [1] * n right_products = [1] * n result = [1] * n # Fill left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Fill right_products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Fill result array by multiplying left and right products for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"Scenario: Your team is developing a scheduling system for a hospital. Part of the task involves generating potential shift schedules while ensuring that the differences in working hours between any two consecutive days are minimized. This helps to avoid fatigue among medical staff. Your job is to write an algorithm that determines the best possible schedule for the week. Question: Write a function `minimize_working_hours(durations)` that takes an array `durations` representing the working hours available for each day in a week and returns the optimal schedule that minimizes the difference in working hours between any two consecutive days. Implement the function based on the following specifications: * **Input Format**: * A list `durations` of 7 positive integers representing the possible working hours available for each day in a week. * **Output Format**: * A list of 7 integers representing the optimal working hours for each day of the week. * An integer representing the total minimal difference in working hours between all consecutive days of the week. **Constraints**: * The length of the input list is always 7. * Each element in durations is a positive integer not greater than 24 (hour). **Examples**: ```python def minimize_working_hours(durations): # Implementation goes here # Example Usage durations = [8, 5, 6, 7, 8, 5, 6] print(minimize_working_hours(durations)) # Output: # [6, 5, 6, 7, 8, 8, 6] # 1 + 1 + 1 + 1 + 0 + 2 = 6 ``` **Explanation**: In the given example, the input `durations` represents possible working hours each day: * Day 1: 8 hours * Day 2: 5 hours * Day 3: 6 hours * Day 4: 7 hours * Day 5: 8 hours * Day 6: 5 hours * Day 7: 6 hours The function should calculate the optimal working hours for the week that minimizes the total difference in working hours between consecutive days.","solution":"def minimize_working_hours(durations): This function takes an array \'durations\' representing the active hours available for each day in a week and returns an optimal schedule that minimizes the differences in working hours between any two consecutive days. # Sort the durations durations.sort() # To minimize the difference, we will rearrange the sorted list # by picking from both ends alternatively optimal_schedule = [] left = 0 right = len(durations) - 1 while left <= right: if left == right: optimal_schedule.append(durations[left]) else: optimal_schedule.append(durations[left]) optimal_schedule.append(durations[right]) left += 1 right -= 1 # Arrange back to minimize consecutive differences possible_schedule = [optimal_schedule[0]] for i in range(1, len(optimal_schedule)): best_pos = None min_diff = float(\'inf\') for j in range(1, len(possible_schedule) + 1): schedule_copy = possible_schedule[:j] + [optimal_schedule[i]] + possible_schedule[j:] diff = sum(abs(schedule_copy[k] - schedule_copy[k-1]) for k in range(1, len(schedule_copy))) if diff < min_diff: min_diff = diff best_pos = j possible_schedule.insert(best_pos, optimal_schedule[i]) # Calculate the total minimal difference total_difference = sum(abs(possible_schedule[i] - possible_schedule[i-1]) for i in range(1, len(possible_schedule))) return possible_schedule, total_difference"},{"question":"Coding Assessment Question You are developing a file synchronizer tool that copies files from a source directory to a destination directory, ensuring that only the updated or new files are copied. Your task is to create a function that checks for updates in the source directory and copies files accordingly. # Function Signature ```python def synchronize_files(source_dir: str, dest_dir: str) -> None: ``` # Objective Implement the `synchronize_files` function to: 1. Traverse through all files in the `source_dir`. 2. Compare each file’s last modified time with the corresponding file in the `dest_dir`. 3. Copy the file from `source_dir` to `dest_dir` if it is new or has been modified. # Input/Output Format * **Input**: * `source_dir` (str): Path to the source directory. * `dest_dir` (str): Path to the destination directory. * **Output**: None (the function performs the synchronization process and logs its actions). # Constraints * Use OS-independent methods for file and directory handling. * Maintain a log file `sync_log.txt` in the `dest_dir` that records: * The names of the files copied. * The date and time of each copy operation. * Ensure that non-existent directories in the destination path are created as needed. * Preserve the relative directory structure from `source_dir` in `dest_dir`. # Context This function will be part of a broader backup tool used to keep files synchronized between two locations. Efficient and reliable file copying, along with accurate logging, is essential for this tool to be effective. # Performance Requirements * Minimize unnecessary file copying by checking last modified times. * Ensure that directory traversals and file operations are handled efficiently. # Implementation Notes * Use the `os` and `shutil` modules for file system operations. * Ensure to handle exceptions for file operations, such as permission errors. Design and implement the `synchronize_files` function to achieve the above requirements.","solution":"import os import shutil from datetime import datetime def synchronize_files(source_dir: str, dest_dir: str) -> None: if not os.path.exists(dest_dir): os.makedirs(dest_dir) log_file = os.path.join(dest_dir, \'sync_log.txt\') for subdir, _, files in os.walk(source_dir): for file in files: source_file = os.path.join(subdir, file) relative_path = os.path.relpath(source_file, source_dir) dest_file = os.path.join(dest_dir, relative_path) dest_file_dir = os.path.dirname(dest_file) if not os.path.exists(dest_file_dir): os.makedirs(dest_file_dir) copy_file = True if os.path.exists(dest_file): source_mtime = os.path.getmtime(source_file) dest_mtime = os.path.getmtime(dest_file) if source_mtime <= dest_mtime: copy_file = False if copy_file: shutil.copy2(source_file, dest_file) with open(log_file, \'a\') as log: log.write(f\\"Copied: {relative_path} at {datetime.now()}n\\")"},{"question":"# Odd Integer Sum You are given a list of integers `numbers`. Your task is to implement a function `odd_integer_sum` that calculates the sum of all odd integers in the list. Implement the function `odd_integer_sum` with the following signature: ```python def odd_integer_sum(numbers: list) -> int: pass ``` # Input * `numbers`: A list of integers. # Output * An integer, which represents the sum of all odd integers in the list. # Constraints * The length of `numbers` will be at most (10^6). * Each integer in the list `numbers` will be between (-10^9) and (10^9). # Example ```python >>> odd_integer_sum([1, 2, 3, 4, 5]) 9 >>> odd_integer_sum([-1, -2, -3, -4, -5]) -9 >>> odd_integer_sum([10, 20, 30]) 0 >>> odd_integer_sum([]) 0 >>> odd_integer_sum([1, 1, 1, 1, 1]) 5 >>> odd_integer_sum([123456789, -123456789]) 0 ``` # Explanation 1. For the first example, the odd integers are [1, 3, 5], and their sum is 9. 2. For the second example, the odd integers are [-1, -3, -5], and their sum is -9. 3. For the third example, there are no odd integers, so the sum is 0. 4. For the fourth example, the list is empty, so the sum is 0. 5. For the fifth example, the list contains five 1s, so their sum is 5. 6. For the sixth example, the odd integers [123456789, -123456789] cancel each other out, resulting in a sum of 0. Consider edge cases such as an empty list or very large input values.","solution":"def odd_integer_sum(numbers: list) -> int: Returns the sum of all odd integers in the given list. return sum(num for num in numbers if num % 2 != 0)"},{"question":"# Coding Assessment Problem # Problem Statement You are tasked with creating a function that simulates a simplified order processing system. The function takes in a list of order objects, where each order object contains a unique order ID, a product name, the quantity ordered, and the price per unit of the product. The function should return the total revenue generated from all orders. # Input and Output Specifications - **Input**: A list of dictionaries, with each dictionary representing an order. Each dictionary contains: - `order_id` (int): A unique identification number for the order - `product` (str): The name of the product ordered - `quantity` (int): The number of units ordered - `price_per_unit` (float): The price of a single unit of the product - **Output**: A single float value representing the total revenue generated from all the orders. **Example**: If the list of orders is as follows: ```python [ {\\"order_id\\": 1, \\"product\\": \\"Laptop\\", \\"quantity\\": 2, \\"price_per_unit\\": 1500.0}, {\\"order_id\\": 2, \\"product\\": \\"Mouse\\", \\"quantity\\": 5, \\"price_per_unit\\": 25.0}, {\\"order_id\\": 3, \\"product\\": \\"Monitor\\", \\"quantity\\": 3, \\"price_per_unit\\": 300.0} ] ``` Total Revenue Calculation: - Order 1: 2 * 1500.0 = 3000.0 - Order 2: 5 * 25.0 = 125.0 - Order 3: 3 * 300.0 = 900.0 The total revenue would be `3000.0 + 125.0 + 900.0 = 4025.0`. # Constraints - All `order_id` values will be unique. - `quantity` will be a positive integer. - `price_per_unit` will be a positive float. - The number of orders will not exceed 1,000. # Function Signature ```python def calculate_total_revenue(orders: List[Dict[str, Union[int, str, int, float]]]) -> float: # Implementation here ``` # Example Given the list of orders: ```python [ {\\"order_id\\": 1, \\"product\\": \\"Laptop\\", \\"quantity\\": 2, \\"price_per_unit\\": 1500.0}, {\\"order_id\\": 2, \\"product\\": \\"Mouse\\", \\"quantity\\": 5, \\"price_per_unit\\": 25.0}, {\\"order_id\\": 3, \\"product\\": \\"Monitor\\", \\"quantity\\": 3, \\"price_per_unit\\": 300.0} ] ``` The function call `calculate_total_revenue(orders)` should return `4025.0`. # Context You are part of an order management team in an e-commerce setup. Your role is to implement a function that calculates the total revenue generated from various orders placed through the system, ensuring accurate financial reporting.","solution":"from typing import List, Dict, Union def calculate_total_revenue(orders: List[Dict[str, Union[int, str, int, float]]]) -> float: Calculates the total revenue from a list of order objects. :param orders: List of orders, each order represented as a dictionary with order_id, product, quantity, and price_per_unit. :return: The total revenue as a float. total_revenue = 0.0 for order in orders: total_revenue += order[\'quantity\'] * order[\'price_per_unit\'] return total_revenue"},{"question":"# Context You\'re developing a logistics application that helps track inventory in various stores. Each store has a limited capacity for storing specific products, and each product shipment needs to be distributed among stores efficiently. Your task is to create a system that facilitates the tracking and distribution of shipments to the stores based on their capacities and current inventory levels. # Task Implement the `InventorySystem` class. Method Details 1. **`__init__(self, stores_info: dict[int, int])`**: * Initializes the inventory system with the provided information about stores and their capacities. * `stores_info` is a dictionary where the key is the store ID and the value is the capacity of the store. 2. **`receive_shipment(self, shipment: list[tuple[int, int]]) -> None`**: * Receives a shipment, where `shipment` is a list of tuples containing the store ID and the quantity of product to be added. * If adding a shipment exceeds the current capacity of a store, raise a `ValueError`. 3. **`dispatch_products(self, orders: list[tuple[int, int]]) -> None`**: * Dispatches products from the stores based on the given orders, where `orders` is a list of tuples containing the store ID and the quantity of product to be dispatched. * If an order exceeds the current inventory of a store, raise a `ValueError`. 4. **`get_inventory_levels(self) -> dict[int, int]`**: * Returns the current inventory levels for all stores. The result should be a dictionary where the key is the store ID and the value is the current inventory level of that store. # Requirement Ensure your implementation of the `InventorySystem` class: * **Handles edge cases**: such as empty lists of shipments or orders and attempting to exceed store capacities or dispatch more products than available. * **Is efficient**: both in terms of time and space complexity. * **Produces accurate results**: reflects the current state of the inventory across all stores. # Input and Output * Input: * `stores_info` - A dictionary with store IDs and their capacities. * `shipment` - A list of tuples for the received shipment. * `orders` - A list of tuples for the dispatched orders. * Output: * A dictionary mapping store IDs to their current inventory levels. # Example ```python I = InventorySystem({1: 100, 2: 150, 3: 200}) I.receive_shipment([(1, 50), (2, 100), (3, 150)]) try: I.receive_shipment([(1, 60)]) # Should raise ValueError because the capacity is exceeded except ValueError as e: print(e) # Output: \\"Shipment exceeds capacity for store 1\\" I.dispatch_products([(1, 20), (2, 50)]) print(I.get_inventory_levels()) # Output: {1: 30, 2: 50, 3: 150} try: I.dispatch_products([(3, 160)]) # Should raise ValueError because more products are dispatched than available except ValueError as e: print(e) # Output: \\"Order exceeds current inventory for store 3\\" print(I.get_inventory_levels()) # Output: {1: 30, 2: 50, 3: 150} ``` # Constraints * Number of stores: (1 leq |stores| leq 10^3) * Capacity of each store: (1 leq text{capacity} leq 10^4) * Number of shipments/orders in a single operation: (0 leq |text{shipment/orders}| leq 10^3) * Quantity of each shipment/order: (0 leq text{quantity} leq 10^4) **Note**: Make sure to handle edge cases and optimize for both time and space complexity.","solution":"class InventorySystem: def __init__(self, stores_info: dict[int, int]): Initialize the inventory system with the provided store capacities. :param stores_info: Dictionary where key is the store ID and value is the capacity of the store. self.stores_capacity = stores_info self.stores_inventory = {store_id: 0 for store_id in stores_info} def receive_shipment(self, shipment: list[tuple[int, int]]) -> None: Receive a shipment and update the inventory for each store. :param shipment: List of tuples where each tuple contains store ID and the quantity of product to be added. :raises ValueError: If adding a shipment exceeds the capacity of a store. for store_id, quantity in shipment: if store_id not in self.stores_capacity: raise ValueError(f\\"Store ID {store_id} does not exist.\\") if self.stores_inventory[store_id] + quantity > self.stores_capacity[store_id]: raise ValueError(f\\"Shipment exceeds capacity for store {store_id}\\") self.stores_inventory[store_id] += quantity def dispatch_products(self, orders: list[tuple[int, int]]) -> None: Dispatch products from the stores based on given orders. :param orders: List of tuples where each tuple contains store ID and the quantity of product to be dispatched. :raises ValueError: If an order exceeds the current inventory of a store. for store_id, quantity in orders: if store_id not in self.stores_capacity: raise ValueError(f\\"Store ID {store_id} does not exist.\\") if self.stores_inventory[store_id] < quantity: raise ValueError(f\\"Order exceeds current inventory for store {store_id}\\") self.stores_inventory[store_id] -= quantity def get_inventory_levels(self) -> dict[int, int]: Get the current inventory levels for all stores. :return: Dictionary where key is the store ID and value is the current inventory level. return self.stores_inventory"},{"question":"Coding Assessment Question: Scenario: You are a software engineer responsible for working with a custom compression algorithm which identifies pairs of characters and simplifies them according to specific rules. As part of the testing process, you need to develop a utility function that determines if two given characters form a valid pair as per the compression rules. Task: Write a function `is_valid_compression_pair(char1: str, char2: str) -> bool` that takes in two single-character strings and returns `True` if the characters form a valid compression pair, and `False` otherwise. A valid compression pair consists of one alphabetic character and one numeric character (0-9). Input: - Two single-character strings, `char1` and `char2`. Output: - A boolean `True` if the characters form a valid compression pair, `False` otherwise. Constraints: - The inputs will always be single-character strings. - The function should handle both lowercase and uppercase alphabetic characters. - Your implementation should be efficient, focusing on minimizing the number of operations. Examples: ```python is_valid_compression_pair(\'a\', \'1\') # Returns: True is_valid_compression_pair(\'B\', \'4\') # Returns: True is_valid_compression_pair(\'z\', \'#\') # Returns: False is_valid_compression_pair(\'3\', \'y\') # Returns: True is_valid_compression_pair(\'!\', \'8\') # Returns: False ``` By following the given scenario and requirements, ensure your solution checks for the validity of compression pairs effectively and efficiently.","solution":"def is_valid_compression_pair(char1, char2): Determines if two characters form a valid compression pair. A valid compression pair consists of one alphabetic character and one numeric character (0-9). if (char1.isalpha() and char2.isdigit()) or (char1.isdigit() and char2.isalpha()): return True return False"},{"question":"# Problem Statement Create a function `unique_elements_sum(arr: list[int]) -> int` that returns the sum of elements that only appear once in the given list. Your implementation should account for edge cases and ensure optimal performance. # Input and Output Formats - **Input** - `arr`: a list of integers which can include both negative and positive values. - **Output** - An integer representing the sum of elements that appear exactly once in the input list. # Constraints - The length of `arr` can be in the range `[0, 10^5]`. - Each element in `arr` is in the range `[-10^6, 10^6]`. # Example - **Example 1:** ```python unique_elements_sum([4, 5, 7, 5, 4, 8]) ``` Expected Output: ```python 15 ``` Explanation: The unique elements are 7 and 8. Their sum is 15. - **Example 2:** ```python unique_elements_sum([10, 20, 10, 30, 20, 50]) ``` Expected Output: ```python 80 ``` Explanation: The unique elements are 30 and 50. Their sum is 80. - **Example 3:** ```python unique_elements_sum([]) ``` Expected Output: ```python 0 ``` Explanation: There are no elements in the list. - **Example 4:** ```python unique_elements_sum([3, 3, 3]) ``` Expected Output: ```python 0 ``` Explanation: There are no unique elements in the list. # Note Ensure that your function handles large lists efficiently and accurately identifies and sums only those elements appearing exactly once.","solution":"def unique_elements_sum(arr): Returns the sum of elements that appear exactly once in the list `arr`. from collections import Counter element_count = Counter(arr) unique_sum = sum(key for key, count in element_count.items() if count == 1) return unique_sum"},{"question":"# Maximum Ordered Subsequence **Objective**: Implement two functions to find the longest ordered (increasing) subsequence in a given list of integers. **Function Signatures**: 1. `def longest_ordered_subsequence_recursive(nums: List[int]) -> List[int]:` 2. `def longest_ordered_subsequence_iterative(nums: List[int]) -> List[int]:` **Requirements**: - **Inputs**: - A single list of integers `nums`. - `nums` must be a list of integers, which can be negative, zero, or positive. - **Outputs**: - A list representing the longest ordered subsequence. **Constraints**: - Raise a `ValueError` if `nums` is not a list of integers. - Both solutions should handle edge cases (an empty list) appropriately. **Performance Requirements**: - Ensure that the recursive implementation can handle lists up to length 1000. - The iterative implementation should be both time and space efficient. **Example**: ```python >>> longest_ordered_subsequence_recursive([3, 10, 2, 1, 20]) [3, 10, 20] >>> longest_ordered_subsequence_iterative([3, 2]) [3] ``` **Detailed Steps**: 1. Define `longest_ordered_subsequence_recursive` using a recursive approach: - Use a helper function to find the subsequences, comparing each element to the previously included element. - Merge and keep track of the longest subsequence found. 2. Define `longest_ordered_subsequence_iterative` using an iterative approach: - Implement the dynamic programming technique to build the solution. - Use an auxiliary array to capture the longest subsequence lengths at each position. **Scenario**: You are given this task to showcase not only your ability to handle complex algorithmic challenges but also your comprehension of dynamic programming principles and efficient list manipulation techniques. This problem tests your skill in breaking down a problem recursively as well as implementing an optimal iterative solution.","solution":"from typing import List def longest_ordered_subsequence_recursive(nums: List[int]) -> List[int]: if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(\\"Input must be a list of integers.\\") if not nums: return [] def subsequence_ending_at(index): if index == 0: return [nums[0]] max_subseq = [] for i in range(index): if nums[i] < nums[index]: current_subseq = subsequence_ending_at(i) if len(current_subseq) > len(max_subseq): max_subseq = current_subseq return max_subseq + [nums[index]] max_subsequence = [] for i in range(len(nums)): subseq = subsequence_ending_at(i) if len(subseq) > len(max_subsequence): max_subsequence = subseq return max_subsequence def longest_ordered_subsequence_iterative(nums: List[int]) -> List[int]: if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(\\"Input must be a list of integers.\\") if not nums: return [] n = len(nums) dp = [[] for _ in range(n)] dp[0] = [nums[0]] for i in range(1, n): max_subseq = [] for j in range(i): if nums[j] < nums[i] and len(dp[j]) > len(max_subseq): max_subseq = dp[j] dp[i] = max_subseq + [nums[i]] longest = [] for subseq in dp: if len(subseq) > len(longest): longest = subseq return longest"},{"question":"# Problem Statement You have been asked to create a function that will generate and validate email addresses based on certain criteria. The function should check if the email addresses conform to specific rules and provide a summary of any violations. Your task is to implement the function `validate_emails(emails: List[str]) -> Dict[str, List[str]]` that takes a list of email addresses and returns a dictionary categorizing them based on rule violations. # Expected Behavior The function should: 1. Return a dictionary with the following keys: - \'invalid_format\': List of emails not in a valid email format. - \'missing_domain\': List of emails missing the domain part. - \'missing_username\': List of emails missing the username part. - \'invalid_characters\': List of emails containing invalid characters (anything other than alphanumeric characters, dots, hyphens, or underscores in the username). 2. Upon completion, the function should print: - The number of emails in each category (if any). - The list of email addresses for each category (if any). # Valid Email Format - A valid email address should have exactly one \'@\' symbol. - It should have non-empty local parts (username) and domain. - The domain part should include at least one dot (\'.\'). # Input and Output **Input**: - `emails`: A list of non-empty strings indicating email addresses. **Output**: - A dictionary with keys being the categories (`\'invalid_format\'`, `\'missing_domain\'`, `\'missing_username\'`, `\'invalid_characters\'`) and values being lists of email addresses that fall into those categories. # Constraints - All email addresses are given as non-empty strings. - The username part can include alphanumeric characters, dots (\'.\'), hyphens (\'-\'), and underscores (\'_\'). # Performance Requirements - The solution should process the input in linear time, O(n), where n is the number of email addresses. # Example ```python from typing import List, Dict def validate_emails(emails: List[str]) -> Dict[str, List[str]]: # Write your implementation here # Example Usage emails = [ \\"user@example.com\\", \\"user.example.com\\", \\"user@.com\\", \\"@example.com\\", \\"user!@example.com\\" ] result = validate_emails(emails) # Expected Output: # { # \'invalid_format\': [\'user.example.com\'], # \'missing_domain\': [\'user@.com\'], # \'missing_username\': [\'@example.com\'], # \'invalid_characters\': [\'user!@example.com\'] # } ``` Implement the function according to the specified behavior and constraints.","solution":"from typing import List, Dict def validate_emails(emails: List[str]) -> Dict[str, List[str]]: invalid_format = [] missing_domain = [] missing_username = [] invalid_characters = [] for email in emails: if \'@\' not in email or email.count(\'@\') != 1: invalid_format.append(email) else: username, domain = email.split(\'@\') if not username: missing_username.append(email) if not domain or \'.\' not in domain: missing_domain.append(email) invalid_chars_found = any(c for c in username if not (c.isalnum() or c in {\'-\', \'_\', \'.\'})) if invalid_chars_found: invalid_characters.append(email) result = { \'invalid_format\': invalid_format, \'missing_domain\': missing_domain, \'missing_username\': missing_username, \'invalid_characters\': invalid_characters } return result"},{"question":"# Coding Assessment Question Context You are required to implement a function that takes an array of integers and an integer `k`, and returns the `k` largest elements from the array in descending order. The function should be optimized for performance and capable of handling large arrays efficiently. Task Implement a function `k_largest_elements(arr: List[int], k: int) -> List[int]` that finds the `k` largest elements in the input array and returns them in descending order. Your solution should ensure: 1. Efficient handling of large arrays and values of `k`. 2. Correct ordering of the output elements in descending order. 3. Proper handling of edge cases such as `k` being zero or larger than the length of the array. Input - `arr` (List[int]): A list of integers which could include both positive and negative numbers. - `k` (int): The number of largest elements to retrieve from the array. Output - (List[int]): A list of the `k` largest elements from the input array, sorted in descending order. Constraints - The length of `arr` will be in range `[0, 10^6]`. - The elements in `arr` will be in the range `[-10^9, 10^9]`. - `0 ≤ k ≤ len(arr)`. Example ```python >>> k_largest_elements([3, 1, 5, 12, 2, 11], 3) [12, 11, 5] >>> k_largest_elements([5, 7, 2, 9, 4], 2) [9, 7] >>> k_largest_elements([10], 1) [10] >>> k_largest_elements([], 0) [] >>> k_largest_elements([4, 5, 5, 5, 1], 1) [5] ``` # Notes: - You may not use the built-in `sorted` function in a way that directly handles the task. - Consider using efficient data structures or algorithms (e.g., heaps) to optimize performance.","solution":"import heapq from typing import List def k_largest_elements(arr: List[int], k: int) -> List[int]: Returns the k largest elements from the array in descending order. if k == 0: return [] if k >= len(arr): return sorted(arr, reverse=True) # Use a min-heap to keep track of the k largest elements min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) # Convert the min-heap to a list and sort in descending order return sorted(min_heap, reverse=True)"},{"question":"# Scenario A logistics company is developing a system to help its customers track the location of delivery trucks in real-time. Each truck reports its location using GPS coordinates (latitude and longitude), and customers can query the system to find the nearest truck to a specific location. The goal is to implement a function that handles these queries efficiently. # Task Implement a Python function `find_nearest_truck(trucks: List[Tuple[float, float]], location: Tuple[float, float]) -> Optional[Tuple[float, float]]` which calculates the nearest truck to a given customer\'s location based on Euclidean distance. Input * A list of tuples `trucks` where each tuple contains two float values representing the latitude and longitude of a truck. * A tuple `location` containing two float values representing the latitude and longitude of the customer\'s location. Output * Return a tuple containing the latitude and longitude of the nearest truck. * If the list of trucks is empty, return `None`. Constraints * The input lists can have up to 10,000 trucks. * Latitude and longitude values are floating-point numbers within the ranges: -90 ≤ latitude ≤ 90 and -180 ≤ longitude ≤ 180. Example Inputs and their corresponding outputs: ```python find_nearest_truck([(34.052235, -118.243683), (36.778259, -119.417931), (37.774929, -122.419416)], (34.052235, -118.243683)) # Returns: (34.052235, -118.243683) find_nearest_truck([(34.052235, -118.243683), (36.778259, -119.417931), (37.774929, -122.419416)], (35.052235, -119.243683)) # Returns: (34.052235, -118.243683) find_nearest_truck([], (34.052235, -118.243683)) # Returns: None ``` **Note**: Ensure the correctness of distance calculations and handle possible edge cases where input data may be empty or malformed.","solution":"from typing import List, Tuple, Optional import math def euclidean_distance(coord1: Tuple[float, float], coord2: Tuple[float, float]) -> float: Calculate the Euclidean distance between two GPS coordinates. return math.sqrt((coord1[0] - coord2[0]) ** 2 + (coord1[1] - coord2[1]) ** 2) def find_nearest_truck(trucks: List[Tuple[float, float]], location: Tuple[float, float]) -> Optional[Tuple[float, float]]: Find the nearest truck to the given location. if not trucks: return None closest_truck = min(trucks, key=lambda truck: euclidean_distance(truck, location)) return closest_truck"},{"question":"# Problem Statement Write a function to merge two sorted singly linked lists into one sorted singly linked list. The merged list should be created by splicing together the nodes of the original lists. # Requirements 1. **Implementation Details**: - The linked lists should be implemented using `ListNode` class. - Each `ListNode` should have attributes `val` and `next`. 2. **Functional Requirements**: Implement the following function: - `mergeTwoLists(l1: ListNode | None, l2: ListNode | None) -> ListNode | None`: Takes two sorted linked lists `l1` and `l2` and returns a merged sorted linked list. # Input/Output Formats - The `mergeTwoLists` function should accept two arguments `l1` and `l2`, representing the head nodes of two sorted linked lists. - The function should return the head node of the merged sorted linked list or `None` if both input lists are empty. # Constraints - The function should efficiently merge the lists such that the overall time complexity is O(n), where n is the total number of elements in both lists. - You are not allowed to create any additional nodes; use the existing nodes of the input lists. # Example Usage ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode | None, l2: ListNode | None) -> ListNode | None: # Function implementation goes here # Example: # List 1: 1 -> 3 -> 5 # List 2: 2 -> 4 -> 6 l1 = ListNode(1, ListNode(3, ListNode(5))) l2 = ListNode(2, ListNode(4, ListNode(6))) merged_list = mergeTwoLists(l1, l2) # The merged_list should be: 1 -> 2 -> 3 -> 4 -> 5 -> 6 # Printing the merged list values current = merged_list while current: print(current.val, end=\\" -> \\" if current.next else \\"\\") current = current.next # Output: 1 -> 2 -> 3 -> 4 -> 5 -> 6 ``` # Additional Notes - Make sure to handle cases where one or both input linked lists are empty. - Consider edge cases, such as lists with only one element or lists that are completely non-overlapping in value. - Implement a helper function (if needed) to keep the main function concise and focused.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode | None, l2: ListNode | None) -> ListNode | None: # Create a dummy node to simplify merging process dummy = ListNode() current = dummy # While both lists have nodes, choose the smaller one and attach it to the merged list while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Attach the remaining nodes of the non-empty list if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"**Context**: You are developing a Python application that processes text files. One of the requirements is to identify and extract email addresses from a given text file. The email addresses can be in various formats and you need to ensure that your solution can handle and match common email patterns. Your task is to implement functions to read the file content, extract email addresses, and write them into a new text file. **Task**: You should implement the following functions: 1. Write a function `read_file` to load the contents of a text file into a string. 2. Implement an `extract_emails` function to extract all email addresses from a given string. 3. Write a function called `write_emails_to_file` to write the extracted email addresses into a new text file, one email address per line. **Function Specifications**: 1. `read_file(file_path: str) -> str` - Reads the content of the file located at `file_path`. - Returns the content of the file as a string. 2. `extract_emails(text: str) -> list` - Extracts all email addresses from the given text using regular expressions. - Returns a list of unique email addresses. 3. `write_emails_to_file(emails: list, output_file_path: str) -> None` - Writes each email address in the `emails` list to the file specified by `output_file_path`. - Each email should be written on a new line. **Constraints**: - Use Python\'s `re` module to handle regular expressions. - The email addresses should match common formats like `user@example.com`, `user.name+tag+sorting@example.com`, or `user_name@sub.example.com`. **Example**: ```python import re def read_file(file_path): with open(file_path, \\"r\\") as file: return file.read() def extract_emails(text): email_pattern = r\'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\' emails = re.findall(email_pattern, text) return list(set(emails)) def write_emails_to_file(emails, output_file_path): with open(output_file_path, \\"w\\") as file: for email in emails: file.write(email + \'n\') def main(): text = read_file(\\"input.txt\\") emails = extract_emails(text) write_emails_to_file(emails, \\"output_emails.txt\\") if __name__ == \\"__main__\\": main() ``` Ensure that you test your solution with various input files that contain email addresses in different valid formats to verify the correctness of the extraction and writing process.","solution":"import re def read_file(file_path: str) -> str: Reads the content of the file located at `file_path`. Args: file_path (str): The path to the input file. Returns: str: The content of the file. with open(file_path, \\"r\\") as file: return file.read() def extract_emails(text: str) -> list: Extracts all email addresses from the given text using regular expressions. Args: text (str): The input text from which to extract email addresses. Returns: list: A list of unique email addresses. email_pattern = r\'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\' emails = re.findall(email_pattern, text) return list(set(emails)) def write_emails_to_file(emails: list, output_file_path: str) -> None: Writes each email address in the `emails` list to the file specified by `output_file_path`. Each email is written on a new line. Args: emails (list): A list of email addresses. output_file_path (str): The path to the output file. Returns: None with open(output_file_path, \\"w\\") as file: for email in emails: file.write(email + \'n\')"},{"question":"# Problem Statement Write a function `find_sublist_with_max_sum(arr: List[int]) -> Tuple[List[int], int]` that takes a list of integers and returns the sublist with the maximum sum along with the sum itself. Use dynamic programming to ensure the solution is efficient. # Input * `arr` (List[int]): A list of integers. Constraints: (1 leq text{len(arr)} leq 10^5), and ( -10^4 leq text{arr[i]} leq 10^4). # Output * (Tuple[List[int], int]): A tuple where the first element is the sublist with the maximum sum, and the second element is the sum of that sublist. # Constraints - The solution should be efficient and performant for large input sizes. - Handle both positive and negative integers in the array. - Return the first sublist found in case of multiple sublists with the same maximum sum. # Example ```python assert find_sublist_with_max_sum([-2,1,-3,4,-1,2,1,-5,4]) == ([4,-1,2,1], 6) assert find_sublist_with_max_sum([1,2,3,-2,5]) == ([1,2,3,-2,5], 9) ``` # Performance Expectations - The solution should run in linear time (O(n)). # Implementation Guidelines - Use Kadane’s algorithm to find the maximum sum subarray efficiently. - Track the start and end indices of the maximum sum subarray to return the appropriate sublist. - Optimize for large lists to ensure the approach is scalable.","solution":"from typing import List, Tuple def find_sublist_with_max_sum(arr: List[int]) -> Tuple[List[int], int]: Finds the sublist with the maximum sum in the given list of integers and returns the sublist along with the sum. if not arr: return ([], 0) max_sum = current_sum = arr[0] start = end = temp_start = 0 for i in range(1, len(arr)): if arr[i] > current_sum + arr[i]: current_sum = arr[i] temp_start = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return (arr[start:end+1], max_sum)"},{"question":"# Problem: Geometric Shape Area Calculation System Your task is to design an area calculation system that integrates various geometric area calculation functions into a unified module. The goal is to develop functions for each of these shapes, ensuring proper input validation, and efficient computation while adhering to geometric formulas. Task Requirements: 1. **Function Signature**: - Implement functions corresponding to each of the following shapes: * Square * Rectangle * Triangle * Circle * Ellipse * Parallelogram * Trapezoid * Regular Pentagon * Regular Hexagon * Regular Heptagon - The function names should be prefixed with `area_` followed by the shape name (e.g., `area_square`). 2. **Input and Output**: - The shape functions should accept `float` values and return the area as a `float`. - If invalid values are provided (e.g., negative dimensions), the function should raise a `ValueError` with an appropriate message. 3. **Constraints**: - All inputs must be non-negative floats or integers. 4. **Performance Requirements**: - Ensure that the functions run in constant time O(1) and use constant space O(1). Example Functions: 1. **Square Area** ```python def area_square(side_length: float) -> float: if side_length < 0: raise ValueError(\\"area_square() only accepts non-negative values\\") return pow(side_length, 2) ``` 2. **Circle Area** ```python def area_circle(radius: float) -> float: if radius < 0: raise ValueError(\\"area_circle() only accepts non-negative values\\") from math import pi, pow return pi * pow(radius, 2) ``` 3. **Rectangle Area** ```python def area_rectangle(length: float, width: float) -> float: if length < 0 or width < 0: raise ValueError(\\"area_rectangle() only accepts non-negative values\\") return length * width ``` Test Your Functions: Ensure to cover the following cases in your tests: - Typical valid inputs showing correct area calculations. - Boundary inputs like zero dimensions. - Invalid inputs like negative dimensions raising appropriate errors. Provide at least one test example for each area calculation function in the form of `assert` statements to validate their behavior. # Example Test Cases: ```python # Test area_square function assert area_square(4) == 16 assert area_square(0) == 0 # Test area_circle function assert area_circle(3) == 28.274333882308138 assert area_circle(0) == 0 # Test area_rectangle function assert area_rectangle(4, 5) == 20 assert area_rectangle(0, 5) == 0 assert area_rectangle(4, 0) == 0 ``` Use similar assertions to test other functions as needed.","solution":"from math import pi, pow, sqrt, tan def area_square(side_length: float) -> float: if side_length < 0: raise ValueError(\\"area_square() only accepts non-negative values\\") return pow(side_length, 2) def area_rectangle(length: float, width: float) -> float: if length < 0 or width < 0: raise ValueError(\\"area_rectangle() only accepts non-negative values\\") return length * width def area_triangle(base: float, height: float) -> float: if base < 0 or height < 0: raise ValueError(\\"area_triangle() only accepts non-negative values\\") return 0.5 * base * height def area_circle(radius: float) -> float: if radius < 0: raise ValueError(\\"area_circle() only accepts non-negative values\\") return pi * pow(radius, 2) def area_ellipse(semi_major_axis: float, semi_minor_axis: float) -> float: if semi_major_axis < 0 or semi_minor_axis < 0: raise ValueError(\\"area_ellipse() only accepts non-negative values\\") return pi * semi_major_axis * semi_minor_axis def area_parallelogram(base: float, height: float) -> float: if base < 0 or height < 0: raise ValueError(\\"area_parallelogram() only accepts non-negative values\\") return base * height def area_trapezoid(base1: float, base2: float, height: float) -> float: if base1 < 0 or base2 < 0 or height < 0: raise ValueError(\\"area_trapezoid() only accepts non-negative values\\") return 0.5 * (base1 + base2) * height def area_regular_pentagon(side_length: float) -> float: if side_length < 0: raise ValueError(\\"area_regular_pentagon() only accepts non-negative values\\") return (sqrt(5 * (5 + 2 * sqrt(5))) * pow(side_length, 2)) / 4 def area_regular_hexagon(side_length: float) -> float: if side_length < 0: raise ValueError(\\"area_regular_hexagon() only accepts non-negative values\\") return (3 * sqrt(3) * pow(side_length, 2)) / 2 def area_regular_heptagon(side_length: float) -> float: if side_length < 0: raise ValueError(\\"area_regular_heptagon() only accepts non-negative values\\") return (7 / 4) * pow(side_length, 2) * (1 / tan(pi / 7))"},{"question":"# Problem Statement You are developing a library management system that includes a feature for tracking book loans. Each book has a loan period, and your system should be able to identify overdue books. # Task Write a function `get_overdue_books` that takes in a list of dictionaries representing loans and the current date. Each loan contains the book title, due date, and patron name. Your function should return a list of dictionaries containing the title of the book and the patron name for all overdue books. # Input * `loans` (list): List of dictionaries, where each dictionary contains: * `title` (str): The title of the book. * `due_date` (str): The due date of the loan in the format \\"YYYY-MM-DD\\". * `patron` (str): The name of the patron who borrowed the book. * `current_date` (str): The current date in the format \\"YYYY-MM-DD\\". # Output * List of dictionaries, where each dictionary contains: * `title` (str): The title of the overdue book. * `patron` (str): The name of the patron. # Constraints * Assume `loans` list will always contain valid dictionaries. * Date strings will always be in the format \\"YYYY-MM-DD\\". * The `current_date` will be a valid date string in the format \\"YYYY-MM-DD\\". * There are no guarantees on the number of loan entries in the list. # Performance Requirements * The solution should efficiently handle lists with up to 1000 loans. * Handle cases where there are no overdue books gracefully. # Example Function Signature ```python from typing import List, Dict from datetime import datetime def get_overdue_books(loans: List[Dict[str, str]], current_date: str) -> List[Dict[str, str]]: overdue_books = [] current = datetime.strptime(current_date, \\"%Y-%m-%d\\") for loan in loans: due_date = datetime.strptime(loan[\\"due_date\\"], \\"%Y-%m-%d\\") if current > due_date: overdue_books.append({ \\"title\\": loan[\\"title\\"], \\"patron\\": loan[\\"patron\\"] }) return overdue_books ``` # Example Usage ```python loans = [ {\\"title\\": \\"The Great Gatsby\\", \\"due_date\\": \\"2023-09-21\\", \\"patron\\": \\"Alice\\"}, {\\"title\\": \\"1984\\", \\"due_date\\": \\"2023-10-05\\", \\"patron\\": \\"Bob\\"}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"due_date\\": \\"2023-09-28\\", \\"patron\\": \\"Charlie\\"} ] current_date = \\"2023-10-01\\" overdue_books = get_overdue_books(loans, current_date) for book in overdue_books: print(book) ``` **Remember**: Your solution should be able to handle different cases of overdue and non-overdue books efficiently.","solution":"from typing import List, Dict from datetime import datetime def get_overdue_books(loans: List[Dict[str, str]], current_date: str) -> List[Dict[str, str]]: overdue_books = [] current = datetime.strptime(current_date, \\"%Y-%m-%d\\") for loan in loans: due_date = datetime.strptime(loan[\\"due_date\\"], \\"%Y-%m-%d\\") if current > due_date: overdue_books.append({ \\"title\\": loan[\\"title\\"], \\"patron\\": loan[\\"patron\\"] }) return overdue_books"},{"question":"# Question: Implement an Efficient Version of QuickSelect The QuickSelect algorithm is used to find the k-th smallest element in an unordered list. Although effective, its performance can be improved by optimizing the partitioning step and mitigating poor pivot choices. Requirements: 1. **Input**: - A list of integers `arr` - An integer `k` representing the k-th smallest element to find (1-based index) 2. **Output**: - The k-th smallest element in the list 3. **Constraints**: * You should not use any built-in sort functions. * Handle cases where the input list might be empty or contain duplicate elements. * If `k` is out of bounds, return `None`. 4. **Performance**: * Aim to achieve average-case time complexity of O(n). * Implement heuristics for better pivot selection to avoid worst-case scenarios. ```python def efficient_quickselect(arr: list, k: int) -> int: Efficient QuickSelect implementation. :param arr: Unordered input list :param k: 1-based index of the k-th smallest element to find :return: The k-th smallest element in the list, or None if out of bounds Examples: >>> efficient_quickselect([3, 1, 5, 2, 4], 3) 3 >>> efficient_quickselect([10, 4, 5, 8, 6, 11, 26], 5) 10 >>> efficient_quickselect([2, 6, 10, 15], 1) 2 >>> efficient_quickselect([2, 6, 10, 15], 5) None # Your code here if __name__ == \\"__main__\\": assert efficient_quickselect([7, 10, 4, 3, 20, 15], 3) == 7 assert efficient_quickselect([7, 10, 4, 3, 20, 15], 4) == 10 assert efficient_quickselect([3, 2, 1, 5, 6, 4], 2) == 2 assert efficient_quickselect([3, 2, 1, 5, 6, 4], 7) == None ```","solution":"import random def partition(arr, low, high): pivot_index = random.randint(low, high) pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = partition(arr, low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) def efficient_quickselect(arr, k): if not arr or k < 1 or k > len(arr): return None return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"# Permutation Pairing Problem **Context**: In combinatorics, a permutation of a set is an arrangement of its members into a sequence or order. The total number of permutations of `n` distinct items is `n!`. Among permutations, some interesting problems involve counting specific types of pairings or arrangements, such as how many permutations have specific properties. Given `n`, the number of distinct items, compute the number of permutations where a given condition holds. For this problem, consider the condition that no item is in its original position. Such permutations are known as derangements. **Task**: Write a function `count_derangements(n: int) -> int` that computes the number of derangements (permutations where no element appears in its original position) for a given integer `n` (1 ≤ n ≤ 20). **Function Signature**: ```python def count_derangements(n: int) -> int: pass ``` **Expected Output**: The function should return an integer representing the number of derangements. **Constraints**: - The input `n` is an integer such that 1 ≤ n ≤ 20. - Factorials for small numbers are manageable, and you should be able to compute small factorial values directly. - Implement the function to compute derangements using a mathematical approach rather than importing built-in functions that solve the problem directly. **Example**: ```python print(count_derangements(4)) # Expected Output: 9 ``` **Additional Requirements**: - Ensure the function works efficiently for the given input range. - Consider using recursion or dynamic programming to avoid redundant calculations. **Mathematical Insight**: The number of derangements `D(n)` can be computed using the following recursive relation: [ D(n) = (n-1) times (D(n-1) + D(n-2)) ] where: [ D(0) = 1 ] [ D(1) = 0 ] This relation can be derived from the principle of inclusion and exclusion in combinatorics.","solution":"def count_derangements(n: int) -> int: Compute the number of derangements for n items using a dynamic programming approach. if n == 0: return 1 if n == 1: return 0 derangements = [0] * (n + 1) derangements[0] = 1 derangements[1] = 0 for i in range(2, n + 1): derangements[i] = (i - 1) * (derangements[i - 1] + derangements[i - 2]) return derangements[n]"},{"question":"# Implementing a Running Median Algorithm **Context**: A running median is a median calculated sequentially for a series of numbers. As each new number is added, the median is updated to reflect the current list of observed values. This algorithm is particularly useful in real-time systems where data arrives continuously and computing the overall median each time a new number arrives would be inefficient. **Task**: Write a class `RunningMedian` that maintains a running median of a stream of numbers. The class should have the following methods: - `add_number(num: int) -> None`: Adds a new number to the stream. - `get_median() -> float`: Returns the current median of the stream. **Input**: * A series of integers that are added one by one using the method `add_number`. **Output**: * The median after each insertion when `get_median` is called. **Constraints**: * You must use an efficient algorithm such as maintaining two heaps. * The time complexity for adding a number and retrieving the median should be O(log n). ```python from heapq import heappush, heappop class RunningMedian: def __init__(self): self.min_heap = [] self.max_heap = [] def add_number(self, num: int) -> None: Add a new number to the stream. heappush(self.max_heap, -num) heappush(self.min_heap, -heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heappush(self.max_heap, -heappop(self.min_heap)) def get_median(self) -> float: Return the current median of the stream. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2 # Example Usage rm = RunningMedian() rm.add_number(1) print(rm.get_median()) # Output: 1.0 rm.add_number(2) print(rm.get_median()) # Output: 1.5 rm.add_number(3) print(rm.get_median()) # Output: 2.0 rm.add_number(4) print(rm.get_median()) # Output: 2.5 ``` **Explanation**: 1. The `RunningMedian` class uses two heaps; a max-heap for the lower half and a min-heap for the upper half of the stream. 2. The `add_number` method balances these two heaps to efficiently keep track of the median. 3. The `get_median` method returns the current median based on the size and top values of the heaps. **Edge Cases to Consider**: 1. No numbers have been added yet (handling an empty state would require a check in real use). 2. Adding numbers that significantly differ in value. 3. Even and odd number of total elements in the stream.","solution":"from heapq import heappush, heappop class RunningMedian: def __init__(self): self.min_heap = [] # Min-heap for the larger half of the numbers self.max_heap = [] # Max-heap (inverted min-heap) for the smaller half of the numbers def add_number(self, num: int) -> None: Add a new number to the stream. if len(self.max_heap) == 0 or num <= -self.max_heap[0]: heappush(self.max_heap, -num) else: heappush(self.min_heap, num) # Balance the heaps to ensure their sizes differ by at most 1 if len(self.max_heap) > len(self.min_heap) + 1: heappush(self.min_heap, -heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heappush(self.max_heap, -heappop(self.min_heap)) def get_median(self) -> float: Return the current median of the stream. if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Objective: Write a function that finds the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \\"\\". # Requirements: 1. **Function Implementation**: * Write a function `longest_common_prefix(strs: list[str]) -> str`. 2. **Input**: * `strs` (list of strings): An array of strings. 3. **Output**: * A string representing the longest common prefix. # Constraints: * All strings in the input list will consist only of lowercase English letters. * 1 <= len(strs) <= 200 * 0 <= len(str) <= 200 for each string `str` in the array # Example: ```plaintext Input: strs = [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" Input: strs = [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" ``` # Performance Requirements: - Implement an efficient solution that minimizes the number of character comparisons, ideally targeting O(m*n) time complexity, where m is the length of the shortest string and n is the number of strings. # Context: Your task is to help with auto-suggestion for a search bar, where finding the common prefix in the list of suggestions can aid in displaying relevant auto-complete suggestions quickly. Develop your solution by implementing the function below, ensuring it returns correct and efficient results. ```python def longest_common_prefix(strs: list[str]) -> str: # Your implementation here if not strs: return \\"\\" # Find the shortest string in the list min_str = min(strs, key=len) for i, ch in enumerate(min_str): for other in strs: if other[i] != ch: return min_str[:i] return min_str # Example usage: if __name__ == \\"__main__\\": print(longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"])) # Output: \\"fl\\" print(longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"])) # Output: \\"\\" ``` This additional question aligns with the original set in terms of style, complexity, and scope. It involves a common problem in programming assessments, requires a clear understanding of string manipulation, and can be solved with efficient algorithms.","solution":"def longest_common_prefix(strs: list[str]) -> str: Finds the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Find the shortest string in the list min_str = min(strs, key=len) for i, ch in enumerate(min_str): for other in strs: if other[i] != ch: return min_str[:i] return min_str"},{"question":"# Task Scheduler Using Priority Queue Design a function to simulate a basic task scheduler that executes tasks based on their priority and order of arrival. The scheduler should ensure that the highest priority task is always executed first. If multiple tasks with the same highest priority exist, execute the one that arrived first. Input: * A list of tuples `tasks`, where each tuple consists of: - A string representing the task name. - An integer representing the task priority (higher value means higher priority). - An integer representing the arrival time of the task. * An integer `n` representing the number of tasks. Output: * Return a list of strings representing the order in which tasks are executed. Constraints: * The number of tasks ( n ) will be between 1 and 100. * Task priorities will be between 1 and 10. * Arrival times will be unique and between 1 and 1000. # Function Signature: ```python from typing import List, Tuple def task_scheduler(tasks: List[Tuple[str, int, int]], n: int) -> List[str]: pass ``` # Example: ```python tasks = [ (\\"task1\\", 3, 2), (\\"task2\\", 1, 5), (\\"task3\\", 2, 1), (\\"task4\\", 3, 3) ] assert task_scheduler(tasks, len(tasks)) == [\\"task1\\", \\"task4\\", \\"task3\\", \\"task2\\"] ``` # Additional Information: * You should use a heap or priority queue to manage the tasks efficiently. * The task order should strictly follow the highest priority criteria first and then arrival time in case of ties. # Explanation: ```python tasks = [ (\\"task1\\", 3, 2), # High priority (3), arrives 2nd (\\"task2\\", 1, 5), # Low priority (1), arrives last (\\"task3\\", 2, 1), # Medium priority (2), arrives 1st (\\"task4\\", 3, 3) # High priority (3), arrives 3rd ] ``` - `task1` and `task4` both have the highest priority (3), but `task1` arrives before `task4`. - Thus, execution order is `task1` -> `task4` -> `task3` -> `task2`.","solution":"from typing import List, Tuple import heapq def task_scheduler(tasks: List[Tuple[str, int, int]], n: int) -> List[str]: Simulates a task scheduler that executes tasks based on their priority and order of arrival. # Python\'s heapq is a min-heap by default, so we will store negative priority for max-heap behavior task_heap = [] for task in tasks: name, priority, arrival = task # Store tuple with negative priority for max-heap and the other values to handle tie-breaking heapq.heappush(task_heap, (-priority, arrival, name)) # Extract tasks in the required order execution_order = [] while task_heap: _, _, name = heapq.heappop(task_heap) execution_order.append(name) return execution_order"},{"question":"# Context: You are required to implement a system that logs and retrieves historical weather data for a given city. The system should store the weather data in memory and provide functionalities to add new records and retrieve the temperature for a specific date. # Task: **Implement** the weather logging and retrieval system described below. # Function Definitions: 1. **add_weather_record**(`city: str, date: str, temperature: float`) -> `None`: - **Input**: - `city`: The name of the city for which the weather record is being added. - `date`: The date of the weather record in `YYYY-MM-DD` format. - `temperature`: The temperature recorded on the specified date. - **Output**: None. The city-weather data should be stored in a data structure. 2. **get_weather_for_date**(`city: str, date: str`) -> `float`: - **Input**: - `city`: The name of the city for which the weather record is being retrieved. - `date`: The date of the weather record in `YYYY-MM-DD` format. - **Output**: The temperature recorded on the specified date for the specified city. If no record is found, return `None`. # Constraints: - Cities and dates are unique; there won\'t be multiple records for the same city on the same date. - Input dates will always be in `YYYY-MM-DD` format. - Temperatures are represented as floating-point numbers. - Handle the case where requested data might not be available. # Example: ```python class WeatherLog: def __init__(self): self.weather_data = {} def add_weather_record(self, city: str, date: str, temperature: float) -> None: # Your implementation here pass def get_weather_for_date(self, city: str, date: str) -> float: # Your implementation here pass if __name__ == \\"__main__\\": log = WeatherLog() log.add_weather_record(\\"New York\\", \\"2023-01-01\\", -1.0) log.add_weather_record(\\"Los Angeles\\", \\"2023-01-01\\", 15.5) log.add_weather_record(\\"New York\\", \\"2023-01-02\\", 0.5) temp = log.get_weather_for_date(\\"New York\\", \\"2023-01-01\\") print(temp) # -1.0 temp = log.get_weather_for_date(\\"Los Angeles\\", \\"2023-01-01\\") print(temp) # 15.5 temp = log.get_weather_for_date(\\"New York\\", \\"2023-01-03\\") print(temp) # None ```","solution":"class WeatherLog: def __init__(self): # Initialize the weather data dictionary self.weather_data = {} def add_weather_record(self, city: str, date: str, temperature: float) -> None: # Ensure the city exists in the dictionary if city not in self.weather_data: self.weather_data[city] = {} # Add the date and temperature record for the city self.weather_data[city][date] = temperature def get_weather_for_date(self, city: str, date: str) -> float: # Retrieve the temperature for the given city and date if it exists if city in self.weather_data and date in self.weather_data[city]: return self.weather_data[city][date] else: return None"},{"question":"# Question You are given a function that generates random numbers within a specified range. Extend this implementation by creating a class that uses this function to provide statistical analysis on the generated numbers. Implement the following class: ```python import random class RandomNumberStats: def __init__(self, lower_bound: int, upper_bound: int): Initialize with a range [lower_bound, upper_bound] for random number generation. :param lower_bound: lower bound of the range (inclusive) :param upper_bound: upper bound of the range (inclusive) self.lower_bound = lower_bound self.upper_bound = upper_bound self.numbers = [] def generate_numbers(self, count: int) -> list[int]: Generate a specified count of random numbers within the initialized range. :param count: number of random numbers to generate :return: list of generated random numbers self.numbers = [random.randint(self.lower_bound, self.upper_bound) for _ in range(count)] return self.numbers def mean(self) -> float: Calculate the mean of the generated random numbers. :return: mean of the generated numbers return sum(self.numbers) / len(self.numbers) if self.numbers else 0 def median(self) -> float: Calculate the median of the generated random numbers. :return: median of the generated numbers if not self.numbers: return 0 sorted_numbers = sorted(self.numbers) n = len(sorted_numbers) mid = n // 2 return (sorted_numbers[mid] if n % 2 != 0 else (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2) def mode(self) -> list[int]: Calculate the mode(s) of the generated random numbers. If multiple numbers have the highest frequency, return all of them. :return: list of the mode(s) of the generated numbers if not self.numbers: return [] frequency = {} for number in self.numbers: if number in frequency: frequency[number] += 1 else: frequency[number] = 1 max_freq = max(frequency.values()) return [number for number, freq in frequency.items() if freq == max_freq] ``` Constraints: * The `generate_numbers` method should efficiently handle generating up to 100,000 random numbers. * The class should be able to handle lower and upper bounds within reasonable limits of integer values. * Assume the range `(lower_bound, upper_bound)` will always be valid with `lower_bound <= upper_bound`. Input: * Lower and upper bounds for the random number generation. * Count of random numbers to generate for statistical analysis. Output: * List of generated numbers. * Mean, median, and mode(s) of the generated numbers. Example: Given the following scenario: ```python stats = RandomNumberStats(1, 10) generated_numbers = stats.generate_numbers(5) print(generated_numbers) # Possible Output: [3, 7, 2, 4, 7] print(stats.mean()) # Possible Output: 4.6 print(stats.median()) # Possible Output: 4 print(stats.mode()) # Possible Output: [7] ```","solution":"import random class RandomNumberStats: def __init__(self, lower_bound: int, upper_bound: int): Initialize with a range [lower_bound, upper_bound] for random number generation. :param lower_bound: lower bound of the range (inclusive) :param upper_bound: upper bound of the range (inclusive) self.lower_bound = lower_bound self.upper_bound = upper_bound self.numbers = [] def generate_numbers(self, count: int) -> list[int]: Generate a specified count of random numbers within the initialized range. :param count: number of random numbers to generate :return: list of generated random numbers self.numbers = [random.randint(self.lower_bound, self.upper_bound) for _ in range(count)] return self.numbers def mean(self) -> float: Calculate the mean of the generated random numbers. :return: mean of the generated numbers return sum(self.numbers) / len(self.numbers) if self.numbers else 0 def median(self) -> float: Calculate the median of the generated random numbers. :return: median of the generated numbers if not self.numbers: return 0 sorted_numbers = sorted(self.numbers) n = len(sorted_numbers) mid = n // 2 return (sorted_numbers[mid] if n % 2 != 0 else (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2) def mode(self) -> list[int]: Calculate the mode(s) of the generated random numbers. If multiple numbers have the highest frequency, return all of them. :return: list of the mode(s) of the generated numbers if not self.numbers: return [] frequency = {} for number in self.numbers: if number in frequency: frequency[number] += 1 else: frequency[number] = 1 max_freq = max(frequency.values()) return [number for number, freq in frequency.items() if freq == max_freq]"},{"question":"Scenario You are developing a feature for a movie streaming platform that helps users find the most popular movies based on user ratings. The system maintains a record of each movie\'s title, year of release, and a list of user ratings. The goal is to create functionality that identifies the top N highest-rated movies each year. Problem Statement Write a function `top_n_movies_per_year` that, given a list of movies with their titles, years, and user ratings, along with a number N, returns a dictionary where the keys are years and the values are lists of the top N highest-rated movie titles for that year. If there are fewer than N movies in a year, return all movies for that year sorted by rating in descending order. Movies with the same rating should be sorted alphabetically by title. # Function Signature ```python def top_n_movies_per_year(movies: List[Tuple[str, int, List[int]]], N: int) -> Dict[int, List[str]]: ``` # Input * A list of tuples `movies` where each tuple represents a movie: * The first element is the title of the movie (a string). * The second element is the year of the movie (an integer). * The third element is a list of user ratings for the movie (a list of integers). * An integer `N`, which represents the number of top movies to return for each year. # Output * A dictionary where the keys are years (integers), and the values are lists of movie titles (strings) that are the top N highest-rated movies for that year. # Constraints * 1 <= number of movies <= 1000 * 0 <= year <= 2023 * 1 <= number of ratings per movie <= 1000 * 1 <= each rating <= 10 # Example ```python movies = [ (\\"Movie A\\", 2022, [8, 9, 9, 8, 9]), (\\"Movie B\\", 2022, [9, 9, 8, 8]), (\\"Movie C\\", 2021, [7, 6, 8, 7, 7]), (\\"Movie D\\", 2021, [8, 6, 9, 7]), (\\"Movie E\\", 2021, [7]), (\\"Movie F\\", 2023, [10]), ] N = 2 result = top_n_movies_per_year(movies, N) # This should return the dictionary: # { # 2021: [\'Movie D\', \'Movie C\'], # 2022: [\'Movie A\', \'Movie B\'], # 2023: [\'Movie F\'] # } ``` # Additional Information * The average rating for a movie is calculated as the sum of all ratings divided by the number of ratings. * Ensure all movies are properly considered, and in case of ties in rating, movies should be sorted alphabetically by their title.","solution":"from typing import List, Tuple, Dict def top_n_movies_per_year(movies: List[Tuple[str, int, List[int]]], N: int) -> Dict[int, List[str]]: from collections import defaultdict import heapq def average_rating(ratings: List[int]) -> float: return sum(ratings) / len(ratings) movie_dict = defaultdict(list) for title, year, ratings in movies: avg_rating = average_rating(ratings) movie_dict[year].append((avg_rating, title)) result = {} for year in movie_dict: # Sort primarily by average rating (descending) and secondarily by title (ascending) sorted_movies = sorted(movie_dict[year], key=lambda x: (-x[0], x[1])) top_n_titles = [title for avg_rating, title in sorted_movies[:N]] result[year] = top_n_titles return result"},{"question":"# Fibonacci Sequence Iterative Calculation **Objective**: Implement an iterative algorithm to generate the first `n` Fibonacci numbers. Problem Statement Write a Python function `fibonacci_sequence(n: int) -> List[int]` that returns a list containing the first `n` numbers in the Fibonacci sequence using an iterative approach. Input - An integer `n` representing the number of Fibonacci numbers to generate. Output - A list of integers containing the first `n` numbers in the Fibonacci sequence. Constraints - `n` will be an integer where `0 <= n <= 10^6`. Performance Requirements - The time complexity should be O(n). - The space complexity should be O(n). Example ```python >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` Implementation Notes 1. If `n` is 0, return an empty list. 2. If `n` is 1, return a list containing only `0`. 3. For other values of `n`, iteratively calculate each Fibonacci number starting from 0 and 1, and append each number to the list. 4. Ensure the function handles large values of `n` efficiently. Here\'s a possible implementation skeleton to start with: ```python def fibonacci_sequence(n: int) -> List[int]: if n == 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence ```","solution":"from typing import List def fibonacci_sequence(n: int) -> List[int]: if n == 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"# Inventory System Query Implementation **Context**: Inventory management systems are essential tools for businesses to track their stock levels, orders, sales, and deliveries. A key feature of such systems is the ability to perform efficient queries on the inventory. **Problem Statement**: Your task is to complete the `Inventory` class which manages a list of `Item` objects. Each `Item` has a `name` (string), `quantity` (integer), and `price` (float). You need to implement the `query_items` method to return a list of item names that satisfy given criteria. Requirements: * Implement the `query_items` method in the `Inventory` class. * The method should accept three optional parameters (`min_quantity`, `max_quantity`, `max_price`), each defaulting to `None`. - `min_quantity`: filter items with at least this quantity. - `max_quantity`: filter items with at most this quantity. - `max_price`: filter items with a price not exceeding this value. * The method should return a list of item names that match all the given criteria. If a criterion is `None`, it should be ignored. # Function Signature ```python class Item: def __init__(self, name, quantity, price): self.name = name self.quantity = quantity self.price = price class Inventory: def __init__(self): self.items = [] def add_item(self, item): self.items.append(item) def query_items(self, min_quantity=None, max_quantity=None, max_price=None): pass ``` # Input & Output * `query_items` takes up to three optional parameters (`min_quantity`, `max_quantity`, `max_price`). * Returns a list of names (strings) of items that satisfy all provided criteria. # Example ```python >>> inv = Inventory() >>> inv.add_item(Item(\'apple\', 10, 0.5)) >>> inv.add_item(Item(\'banana\', 5, 0.75)) >>> inv.add_item(Item(\'cherry\', 20, 1.5)) >>> inv.query_items(min_quantity=6, max_price=1.0) [\'apple\'] >>> inv.query_items(max_quantity=15) [\'apple\', \'banana\'] >>> inv.query_items(min_quantity=5, max_quantity=10, max_price=1.0) [\'apple\', \'banana\'] ``` # Constraints * Ensure the method handles cases where no items match the criteria. * Ensure efficiency, keeping in mind that in real systems, the number of items could be large.","solution":"class Item: def __init__(self, name, quantity, price): self.name = name self.quantity = quantity self.price = price class Inventory: def __init__(self): self.items = [] def add_item(self, item): self.items.append(item) def query_items(self, min_quantity=None, max_quantity=None, max_price=None): result = [] for item in self.items: if (min_quantity is not None and item.quantity < min_quantity): continue if (max_quantity is not None and item.quantity > max_quantity): continue if (max_price is not None and item.price > max_price): continue result.append(item.name) return result"},{"question":"# Coding Challenge: Design and Implement a K-D Tree for Nearest Neighbor Search **Scenario**: You are working on a project that involves geographical mapping and need to efficiently perform nearest neighbor searches on a set of 2D coordinates. Your task is to design and implement a K-D Tree (K-dimensional tree) to handle this specific requirement. **Objective**: Implement a `KDTree` class that supports efficient insertion of points and nearest neighbor search operations. **Requirements**: 1. Implement the `KDTree` class. 2. Implement the `insert` method to add a point to the K-D Tree. 3. Implement the `nearest` method to find the point in the tree that is closest to a given target point. **Function Signature**: ```python class KDTree: def __init__(self): ... def insert(self, point: tuple) -> None: ... def nearest(self, target: tuple) -> tuple: ... ``` **Expected Input and Output**: - `__init__(self)`: Initializes the K-D Tree. - `insert(self, point: tuple) -> None`: Inserts a point (x, y) into the K-D Tree. - `nearest(self, target: tuple) -> tuple`: Returns the nearest point (x, y) in the tree to the target point. **Constraints**: - The points and target are tuples of two floats representing x and y coordinates. - The number of points to be inserted will be in the range [1, 1000]. - The coordinates will be in the range [-10000.0, 10000.0]. **Performance Requirements**: - The insertion of a point should be efficient and proceed recursively. - The nearest neighbor search should have an average-case time complexity of (O(log n)) where (n) is the number of inserted points. **Testing**: Your implementation should be verified by the following tests: 1. Inserting a set of points and performing nearest neighbor searches. 2. Ensuring that search returns the exact nearest point considering floating-point precision. 3. Performing multiple search operations to verify performance. 4. Handling edge cases such as searching closest to a point identical to an inserted one. Implement the `KDTree` class and its methods based on the provided function signature and ensure your solution passes the described tests.","solution":"class KDTree: class Node: def __init__(self, point, axis, left=None, right=None): self.point = point self.axis = axis self.left = left self.right = right def __init__(self): self.root = None def insert(self, point): def _insert(node, point, depth): if node is None: return self.Node(point, depth % 2) axis = node.axis if point[axis] < node.point[axis]: node.left = _insert(node.left, point, depth + 1) else: node.right = _insert(node.right, point, depth + 1) return node self.root = _insert(self.root, point, 0) def nearest(self, target): def _dist_squared(p1, p2): return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 def _nearest(node, target, depth, best): if node is None: return best point_dist = _dist_squared(target, node.point) if point_dist < best[1]: best = (node.point, point_dist) axis = depth % 2 diff = target[axis] - node.point[axis] close_side = node.left if diff < 0 else node.right far_side = node.right if diff < 0 else node.left best = _nearest(close_side, target, depth + 1, best) if diff ** 2 < best[1]: # Only check far side if necessary best = _nearest(far_side, target, depth + 1, best) return best best = _nearest(self.root, target, 0, (None, float(\'inf\'))) return best[0]"},{"question":"# Problem Statement In the magical world of wizardry, students are practicing their spellcasting skills using a finite set of magic spells. Each spell is represented by a number, and casting a spell reduces the power of that spell by one until it reaches zero, at which point the spell cannot be cast anymore. Given a list of initial spell powers and a sequence of spell casts, determine the sequence of spell powers after all the spells in the sequence have been cast. If a spell is cast and it has already reached zero power, it should be ignored. # Task Write a function `cast_spells` that takes a list of integers representing the initial spell powers and a list of integers representing the sequence of spell casts. The function should return the final spell powers after all the spell casts have been processed. # Function Signature ```python def cast_spells(spell_powers: List[int], spell_casts: List[int]) -> List[int]: ``` # Input - `spell_powers` (1 ≤ len(spell_powers) ≤ 1000): A list of integers where each integer (1 ≤ spell_powers[i] ≤ 100) represents the initial power of a corresponding spell. - `spell_casts` (0 ≤ len(spell_casts) ≤ 1000): A list of integers where each integer (0 ≤ spell_casts[i] < len(spell_powers)) represents the index of the spell being cast. # Output - Returns a list of integers representing the final spell powers after all the spell casts have been processed. # Example ```python spell_powers = [3, 1, 2, 5] spell_casts = [0, 1, 0, 3, 3, 3, 1, 2, 2] cast_spells(spell_powers, spell_casts) # Output: [1, 0, 0, 2] ``` # Constraints & Considerations - Ensure the function efficiently handles sequences with the upper limit of spell casts. - Consider edge cases, such as no spell casts or spells with initial power zero. - Optimize the function to handle large sequences of casts effectively. # Scenario Imagine you are developing a game where players cast spells against each other. The game engine needs to keep track of each spell\'s power and update them after each cast. Your solution should be efficient to handle a list of up to 1000 spells and 1000 spell casts, ensuring the final spell powers are accurately represented.","solution":"from typing import List def cast_spells(spell_powers: List[int], spell_casts: List[int]) -> List[int]: for cast in spell_casts: if spell_powers[cast] > 0: spell_powers[cast] -= 1 return spell_powers"},{"question":"# Question: Longest Consecutive Sequence in a Binary Search Tree Given a binary search tree (BST), write a Python function to find the longest consecutive sequence of integers in the tree. A consecutive sequence in the BST is defined as a sequence of parent-child nodes where the child\'s value is exactly one greater than the parent\'s value. Function Signature: ```python def longest_consecutive_sequence(root: Node) -> int: pass ``` Input: - `root`: The root node of the binary search tree, which can be `None` for an empty tree. Output: - An integer representing the length of the longest consecutive sequence in the tree. Constraints: - Tree can be empty, in which case the longest consecutive sequence is 0. - The function should aim for (O(n)) time complexity where (n) is the number of nodes in the tree. # Example: ```python # Example 1: # Construct the following BST # 2 # / # 1 3 # # 4 root = Node(2) root.left = Node(1) root.right = Node(3) root.right.right = Node(4) assert longest_consecutive_sequence(root) == 3 # Sequence: 2 -> 3 -> 4 # Example 2: # Construct the following BST # 5 # / # 1 7 # / # 0 8 # # 9 root = Node(5) root.left = Node(1) root.left.left = Node(0) root.right = Node(7) root.right.right = Node(8) root.right.right.right = Node(9) assert longest_consecutive_sequence(root) == 3 # Sequence: 7 -> 8 -> 9 ``` # Notes: - You may define additional helper functions if necessary. - Ensure that your solution handles edge cases like an empty tree or a tree with only one node.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def longest_consecutive_sequence(root: Node) -> int: if not root: return 0 def helper(node, parent_value, length): if not node: return length current_length = length + 1 if node.value == parent_value + 1 else 1 left_length = helper(node.left, node.value, current_length) right_length = helper(node.right, node.value, current_length) return max(current_length, left_length, right_length) return helper(root, root.value - 1, 0)"},{"question":"# Sorting Colors Problem Background: You are working with an array containing integers that represent colors. Each integer corresponds to a specific color. There are exactly three different colors represented by the integers 0, 1, and 2. Your task is to sort the array so that all instances of the same color are adjacent, with the colors in the order of 0, 1, and 2. This problem is a classic example of the Dutch National Flag problem proposed by Edsger W. Dijkstra. Task: Implement the `sort_colors` function that sorts the input array in-place according to the color order. Function Signature: ```python def sort_colors(nums: list[int]) -> None: pass ``` Input: - `nums`: A list of integers where each integer is either 0, 1, or 2. Output: - The function returns `None`, but it modifies the input list in-place to have the colors sorted in the order of 0, 1, and 2. Constraints: - The length of the input array `nums` is in the range [1, 300]. - The elements of `nums` are limited to the integers 0, 1, and 2. Example: ```python # Example 1 input_array = [2, 0, 2, 1, 1, 0] sort_colors(input_array) # After sorting, input_array becomes [0, 0, 1, 1, 2, 2] # Example 2 input_array = [2, 0, 1] sort_colors(input_array) # After sorting, input_array becomes [0, 1, 2] ``` Additional Information: - The solution should strive for a single-pass algorithm with constant space complexity. - It is acceptable to perform swaps within the array to achieve the desired order. - The sort operation should be efficient and handle all given constraints adequately. Good Luck!","solution":"def sort_colors(nums: list[int]) -> None: Sorts the list nums in-place such that all instances of 0 come first, followed by all instances of 1, followed by all instances of 2. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Implementation of a Trie You are tasked with implementing a basic Trie (prefix tree) data structure to efficiently store and retrieve keys in a dataset of strings. This question involves developing methods for inserting, searching, and deleting words, as well as finding all words with a given prefix. # Function Requirements 1. `insert(self, word)`: Insert a single word into the Trie. 2. `search(self, word)`: Check if the word is in the Trie; return `True` if found, otherwise return `False`. 3. `starts_with(self, prefix)`: Check if there is any word in the Trie that starts with the given prefix; return `True` if such a word exists, otherwise return `False`. 4. `delete(self, word)`: Delete a single word from the Trie. # Input and Output - `insert(self, word)` - **Input**: A string `word`. - **Output**: None. - `search(self, word)` - **Input**: A string `word`. - **Output**: Boolean value `True` if the word is in the Trie, otherwise `False`. - `starts_with(self, prefix)` - **Input**: A string `prefix`. - **Output**: Boolean value `True` if there is any word in the Trie that starts with the given prefix, otherwise `False`. - `delete(self, word)` - **Input**: A string `word`. - **Output**: None. # Constraints - All strings only contain lowercase English letters, from \'a\' to \'z\'. - The Trie must support insertion, search, deletion, and prefix search operations efficiently. - Handle duplicate entries gracefully, ensuring no duplicates exist in the Trie. # Example ```python trie = Trie() # Insert words trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apply\\") # Search words print(trie.search(\\"apple\\")) # => True print(trie.search(\\"appl\\")) # => False # Search prefixes print(trie.starts_with(\\"app\\")) # => True print(trie.starts_with(\\"apl\\")) # => False # Delete a word trie.delete(\\"apply\\") print(trie.search(\\"apply\\")) # => False print(trie.starts_with(\\"app\\")) # => True ``` # Implementation Implement the necessary methods to complete the `Trie` class, focusing on the characteristics and principles of a Trie data structure.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def delete(self, word): def _delete(node, word, depth): if len(word) == depth: if not node.is_end_of_word: return False node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char not in node.children: return False should_delete_child = _delete(node.children[char], word, depth + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 return False _delete(self.root, word, 0)"},{"question":"# Coding Question: Implement a Custom String Reversal Function Context: String manipulation is a fundamental skill in programming. Reversing a string is a common task that can serve as a building block for more complex operations. This exercise will test your understanding of string manipulation and edge cases. Task: 1. Implement the `reverse_string` function as defined below. 2. Ensure the function correctly handles edge cases such as empty strings and strings with varying character sets. Function Signature: ```python def reverse_string(s: str) -> str: Reverses the input string. Parameters: s (str): A string to be reversed. Returns: str: The reversed string. ``` Example: ```python # Example input input_data = \\"hello\\" # Expected output \\"olleh\\" ``` Constraints: * The input string can contain letters, numbers, symbols, and spaces. * The maximum length of the string is 10^5 characters. Objective: Ensure your implementation accurately reverses the string and handles edge cases efficiently.","solution":"def reverse_string(s: str) -> str: Reverses the input string. Parameters: s (str): A string to be reversed. Returns: str: The reversed string. return s[::-1]"},{"question":"# Coding Assessment Task: Context: Imagine you are a software developer working for a company that provides data analysis services. One of the common operations performed in data analysis is the computation of statistical measures on datasets. A particularly frequent request involves calculating the moving average of a time series. Problem Statement: Implement a function `moving_average` that calculates the moving average of a given list of numbers over a specified window size. A moving average is computed by taking the average of each subset of numbers that \\"slides\\" through the dataset, with the length of the subset defined by the window size. Function Signature: ```python def moving_average(data: list, window_size: int) -> list: pass ``` Input/Output: * **Input**: - `data`: A list of numerical values representing the dataset. - `window_size`: An integer specifying the size of the window over which to compute the moving average. * **Output**: A list of floats representing the moving averages calculated over the specified window size. Constraints: - The `data` list should not be empty. - The `window_size` should be a positive integer and not greater than the length of `data`. - If the `window_size` is greater than the length of `data`, raise a `ValueError` with an appropriate message. - Ensure the result list has length `len(data) - window_size + 1`. Examples: ```python >>> moving_average([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> moving_average([10, 20, 30, 40, 50, 60], 4) [25.0, 35.0, 45.0] >>> moving_average([1, 3, 5, 7, 9], 2) [2.0, 4.0, 6.0, 8.0] ``` Notes: 1. Ensure that your solution optimizes performance for large datasets. 2. Validate your input list and window size properly, raising `ValueError` with a relevant message if necessary. 3. Aim for a function that is well-documented and clear, with appropriate handling of edge cases.","solution":"def moving_average(data: list, window_size: int) -> list: Computes the moving average of a list of numbers over a specified window size. Args: data (list): A list of numerical values representing the dataset. window_size (int): The size of the window over which to compute the moving average. Returns: list: A list of floats representing the moving averages. Raises: ValueError: If the window size is greater than the length of the data. if not data: raise ValueError(\\"The data list should not be empty.\\") if window_size <= 0: raise ValueError(\\"The window size should be a positive integer.\\") if window_size > len(data): raise ValueError(\\"The window size should not be greater than the length of data.\\") moving_averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] window_average = sum(window) / window_size moving_averages.append(window_average) return moving_averages"},{"question":"# Coding Assessment Question Context: Database indexing is a fundamental technique to enhance the speed of data retrieval. A common practice is to create indices on columns frequently used in search operations. Understanding how to simulate the creation of such indices programmatically can provide deep insight into how databases achieve their performance gains. Task: Implement a function `simple_index` that simulates the creation of an index for a column in a dataset. The function should return a dictionary where the keys are the unique values from the column, and the values are lists of row indices where these unique values occur. Specification: * **Function**: ```python def simple_index(dataset: List[List[any]], column: int) -> Dict[any, List[int]]: ``` * **Input**: * `dataset` - A list of lists representing the dataset, where each internal list corresponds to a row (non-empty list). * `column` - The index of the column to be indexed (integer, 0 ≤ column < number of columns). * **Output**: * Return a dictionary where each key is a unique value from the specified column and each value is a list of integers representing the row indices where this value is found. * **Constraints**: * The dataset and the column indices will always be valid. Examples: ```python >>> dataset = [ ... [1, \\"Alice\\", 3.4], ... [2, \\"Bob\\", 3.8], ... [3, \\"Alice\\", 2.4], ... [4, \\"Dana\\", 3.9] ... ] >>> simple_index(dataset, 1) {\'Alice\': [0, 2], \'Bob\': [1], \'Dana\': [3]} >>> simple_index(dataset, 2) {3.4: [0], 3.8: [1], 2.4: [2], 3.9: [3]} >>> simple_index(dataset, 0) {1: [0], 2: [1], 3: [2], 4: [3]} ```","solution":"from typing import List, Dict, Any def simple_index(dataset: List[List[Any]], column: int) -> Dict[Any, List[int]]: Create an index for a column in a dataset. Parameters: dataset (List[List[Any]]): the dataset as a list of lists. column (int): the index of the column to be indexed. Returns: Dict[Any, List[int]]: a dictionary with keys as unique column values and values as lists of row indices. index = {} for row_idx, row in enumerate(dataset): value = row[column] if value not in index: index[value] = [] index[value].append(row_idx) return index"},{"question":"# Unique Occurrences in Array You need to implement a function that checks whether the number of occurrences of each value in the input array is unique. Function Signature ```python def unique_occurrences(arr: List[int]) -> bool: pass ``` Objective Write a function `unique_occurrences` that takes an array of integers (`arr`) and returns a boolean indicating whether the number of occurrences of each value in the array is unique. Input * `arr` (List[int]): An array of integers. (1 <= len(arr) <= 10^4, -10^9 <= arr[i] <= 10^9) Output * `bool`: True if the number of occurrences of each value in `arr` is unique, otherwise False. Constraints * The input array can contain both positive and negative integers and zero. * Optimize for both time and space complexity. Examples ```python assert unique_occurrences([1, 2, 2, 1, 1, 3]) == True assert unique_occurrences([1, 2]) == False assert unique_occurrences([-3, 0, 1, -1, -1, 1, 1, 2, 2]) == False assert unique_occurrences([1, 1, 1, 1, 1]) == True ``` Notes: * A unique occurrence means that no two different integers have the same count of occurrences. * If every value\'s count of occurrences is different from others, return True. Otherwise, return False. Good luck!","solution":"from typing import List def unique_occurrences(arr: List[int]) -> bool: This function checks whether the number of occurrences of each value in the input array is unique. from collections import Counter count = Counter(arr) occurrences = list(count.values()) return len(occurrences) == len(set(occurrences))"},{"question":"# Longest Increasing Subsequence Coding Challenge # Problem Statement Write a function `longest_increasing_subsequence` that receives a list of integers and returns the length of the longest increasing subsequence (LIS). The subsequence consists of elements that are in strictly increasing order but not necessarily contiguous in the original list. # Detailed Requirements - **Function Signature**: `def longest_increasing_subsequence(numbers: list[int]) -> int:` - The input list `numbers` may contain positive, negative, and zero values. - If the input is empty, return `0`. - Raise a `ValueError` with a meaningful error message if the input is not a list or tuple of integers. # Example Test Cases ```python def test_longest_increasing_subsequence(): assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4, \\"Test case 1 failed\\" assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4, \\"Test case 2 failed\\" assert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1, \\"Test case 3 failed\\" assert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6, \\"Test case 4 failed\\" assert longest_increasing_subsequence([]) == 0, \\"Test case 5 failed\\" try: longest_increasing_subsequence([3, 5, \\"a\\", 9]) except ValueError as e: assert str(e) == \\"numbers must be an iterable of integers\\", \\"Test case 6 failed\\" try: longest_increasing_subsequence(\\"ABC\\") except ValueError as e: assert str(e) == \\"numbers must be an iterable of integers\\", \\"Test case 7 failed\\" try: longest_increasing_subsequence(None) except ValueError as e: assert str(e) == \\"numbers must be an iterable of integers\\", \\"Test case 8 failed\\" print(\\"All test cases pass\\") ``` # Constraints * You may assume that all elements in the input list are unique and that the list length does not exceed 2500 elements. * Develop a dynamic programming solution or utilize a binary search approach for optimized performance. # Guidelines * Ensure your code handles edge cases such as empty input, repeated elements, and invalid inputs gracefully. * Aim for an efficient solution with a time complexity of O(n log n) if possible for larger inputs.","solution":"from bisect import bisect_left def longest_increasing_subsequence(numbers): Returns the length of the longest increasing subsequence in the given list of numbers. if not isinstance(numbers, (list, tuple)): raise ValueError(\\"numbers must be an iterable of integers\\") if any(not isinstance(i, int) for i in numbers): raise ValueError(\\"numbers must be an iterable of integers\\") if not numbers: return 0 # Dynamic programming with binary search approach sub = [] for num in numbers: pos = bisect_left(sub, num) if pos < len(sub): sub[pos] = num else: sub.append(num) return len(sub)"},{"question":"# Coding Question **Problem Statement**: You are given a list of non-negative integers representing the amount of rain at various points in time, where each integer represents the height of a bar at that point. Visualize this as a histogram where each bar\'s width is the same, and you can store water between the bars under certain conditions. Your task is to compute the total amount of rainwater that can be trapped in this histogram. **Objective**: Write a function `trap_rain_water(heights: List[int]) -> int` that returns the total amount of rainwater trapped between the bars. # Function Signature ```python def trap_rain_water(heights: List[int]) -> int: ``` # Input * A list of non-negative integers `heights` representing the height of bars where the length of the list is `n` (0 <= n <= 10^5). # Output * Return an integer representing the total units of rainwater trapped. # Performance Requirements * Your function should run efficiently even for the upper limit of `n = 10^5`. # Example ```python >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rain_water([4,2,0,3,2,5]) 9 >>> trap_rain_water([2,0,2]) 2 >>> trap_rain_water([3,0,1,3,0,5]) 8 ``` # Constraints * Ensure the function handles values of `heights` efficiently, particularly for the upper length limits. * Consider using a two-pointer technique to optimize the time complexity rather than a brute force approach. # Scenario An urban planning team monitors rain levels in a city and needs to model potential flood impacts based on historical rainfall data. Your function will help them estimate the volume of water that could be trapped by the city\'s terrain, assisting in efficient water management and urban planning decisions. Your goal is to develop an accurate and efficient solution for analyzing these scenarios.","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) trapped_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += max(0, right_max - heights[right]) return trapped_water"},{"question":"# Problem Statement You are developing a text editor that supports efficient text manipulation operations. One of the key features required is a data structure that can handle the following operations: 1. **Insert**: Insert a substring `S` at a specified position `pos` in the main text. 2. **Delete**: Delete a substring of specified length `len` starting from a specified position `pos` in the main text. 3. **Find**: Find and return the substring of specified length `len` starting from a specified position `pos` in the main text. Design and implement a class `TextEditor` that supports these operations efficiently. # Function Specifications 1. **`__init__(self) -> None`**: Initialize the TextEditor with an empty string. 2. **`insert(self, pos: int, S: str) -> None`**: Insert the substring `S` at position `pos` in the main text. 3. **`delete(self, pos: int, length: int) -> str`**: Delete the substring from position `pos` with the given length `length`. Return the deleted substring. 4. **`find(self, pos: int, length: int) -> str`**: Return the substring from position `pos` with the given length `length`. # Input/Output Specifications - Input: - Text modification operations along with their parameters. - Output: - For insert and delete operations, there is no output. - For find operations, return the requested substring. # Constraints - ( 0 leq pos < text{{length of main text}} ) - The length of the string `S` and `length` are manageable within the context of a text editor (practically up to few thousand characters). - Text edit operations can be frequent and need to be handled efficiently. # Example ```python editor = TextEditor() editor.insert(0, \\"Hello\\") editor.insert(5, \\" World\\") print(editor.find(0, 11)) # Output: \\"Hello World\\" deleted_text = editor.delete(5, 1) print(deleted_text) # Output: \\" \\" print(editor.find(0, 10)) # Output: \\"HelloWorld\\" editor.insert(5, \\" Beautiful\\") print(editor.find(0, 19)) # Output: \\"Hello BeautifulWorld\\" ``` # Task Your task is to implement the `TextEditor` class with the above-specified functionality, ensuring efficient handling of text manipulation operations.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" def insert(self, pos: int, S: str) -> None: if pos < 0 or pos > len(self.text): raise ValueError(\\"Position out of range.\\") self.text = self.text[:pos] + S + self.text[pos:] def delete(self, pos: int, length: int) -> str: if pos < 0 or pos >= len(self.text): raise ValueError(\\"Position out of range.\\") if length < 0 or pos + length > len(self.text): raise ValueError(\\"Length out of range.\\") deleted_substring = self.text[pos:pos+length] self.text = self.text[:pos] + self.text[pos+length:] return deleted_substring def find(self, pos: int, length: int) -> str: if pos < 0 or pos >= len(self.text): raise ValueError(\\"Position out of range.\\") if length < 0 or pos + length > len(self.text): raise ValueError(\\"Length out of range.\\") return self.text[pos:pos+length]"},{"question":"Question You are given an array of integers. Your task is to implement a function that finds all unique triplets in the array which give the sum of zero. The solution set must not contain duplicate triplets. # Function Signature ```python def three_sum(nums: List[int]) -> List[List[int]]: ... ``` # Input * `nums`: A list of integers. # Output * Returns a list of lists, where each list contains three integers that sum up to zero. # Constraints * The length of the array `nums` will be between 3 and 1000. * Elements in the array `nums` will be between -10^5 and 10^5. # Example Find all unique triplets in the array which gives the sum of zero: ```python # Example 1 nums = [-1, 0, 1, 2, -1, -4] assert three_sum(nums) == [[-1, -1, 2], [-1, 0, 1]], \\"Test Case 1 Failed\\" # Example 2 nums = [0, 0, 0] assert three_sum(nums) == [[0, 0, 0]], \\"Test Case 2 Failed\\" print(\\"All test cases passed!\\") ``` # Notes - **Edge Cases**: Be sure to handle arrays with no triplets summing to zero and arrays with duplicate triplets appropriately. - **Efficiency Consideration**: Avoid solutions with time complexity greater than O(n^2), where n is the length of the array. # Approach Consider sorting the array first and then using a two-pointer technique to find the triplets efficiently.","solution":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Find all unique triplets in the array which gives the sum of zero. nums.sort() result = [] n = len(nums) for i in range(n - 2): # Avoid duplicates for the first element if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) # Skip duplicates for the second and third element while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"# Question: Design and implement a function `find_distinct_subarrays` that returns the number of distinct contiguous subarrays that can be formed from a given list of integers `arr` where the sum of the subarray is equal to `k`. Function Signature: ```python def find_distinct_subarrays(arr: list[int], k: int) -> int: # your implementation here ``` Input: - `arr`: A list of integers. - `k`: An integer. Output: - An integer representing the number of distinct contiguous subarrays whose sum is equal to `k`. Examples: ```python >>> find_distinct_subarrays([1, 2, 1, 2, 1], 3) 4 >>> find_distinct_subarrays([1, -1, 1, -1], 0) 4 >>> find_distinct_subarrays([1, 2, 3, 4, 5], 15) 1 >>> find_distinct_subarrays([1, 2, 3, 7, 5], 12) 2 >>> find_distinct_subarrays([1, 1, 1, 1], 2) 3 ``` Constraints: - The input list `arr` will contain at most 10^5 elements. - The elements in `arr` can be negative, zero, or positive integers. - The sum `k` can be any integer. Edge Cases to Consider: - If `arr` is empty, return 0 since no subarrays can be formed. - If k is 0, any subarray whose sum is exactly 0 should be counted. - If multiple subarrays with the same sum are overlapping but have different starting or ending indices, they should be considered distinct. # Performance Requirements: - Your solution should aim for optimal performance to handle large inputs efficiently.","solution":"def find_distinct_subarrays(arr: list[int], k: int) -> int: prefix_sum_counts = {0: 1} current_prefix_sum = 0 count = 0 for num in arr: current_prefix_sum += num target_prefix_sum = current_prefix_sum - k if target_prefix_sum in prefix_sum_counts: count += prefix_sum_counts[target_prefix_sum] if current_prefix_sum in prefix_sum_counts: prefix_sum_counts[current_prefix_sum] += 1 else: prefix_sum_counts[current_prefix_sum] = 1 return count"},{"question":"# Question: Transforming DNA Sequences **Context:** Bioinformatics is an interdisciplinary field that combines biology, computer science, and statistics to analyze and interpret biological data. One common task is to process DNA sequences for various analyses, such as identifying genes, predicting protein structures, and more. **Problem Statement:** Write a Python function `transform_dna_sequence(dna: str, mode: str) -> str` that transforms a given DNA sequence based on the specified mode. * If the mode is `\\"reverse\\"`, return the reverse of the DNA sequence. * If the mode is `\\"complementary\\"`, return the complementary DNA sequence. **Requirements:** 1. The function should handle invalid DNA sequences by raising a `ValueError` with an appropriate error message. 2. The function should be efficient, considering it might be used on sequences that are hundreds of thousands of nucleotides long. **Function Signature:** ```python def transform_dna_sequence(dna: str, mode: str) -> str: pass ``` **Input:** * `dna`: A string representing the DNA sequence composed of the characters \'A\', \'T\', \'C\', and \'G\'. * `mode`: A string that specifies the transformation mode. It can be either `\\"reverse\\"` or `\\"complementary\\"`. **Output:** * A string representing the transformed DNA sequence. **Constraints:** * The input `dna` must be a non-empty string composed only of \'A\', \'T\', \'C\', and \'G\'. * The `mode` must be either `\\"reverse\\"` or `\\"complementary\\"`. **Examples:** ```python # Example 1: transform_dna_sequence(\\"ATCG\\", \\"reverse\\") # Expected output: \\"GCTA\\" # Example 2: transform_dna_sequence(\\"ATCG\\", \\"complementary\\") # Expected output: \\"TAGC\\" # Example 3: transform_dna_sequence(\\"ATCG1\\", \\"complementary\\") # Expected output: ValueError: Invalid DNA sequence. # Example 4: transform_dna_sequence(\\"ATCG\\", \\"unknown_mode\\") # Expected output: ValueError: Unknown transformation mode. ``` Ensure that your implementation is efficient and handles erroneous inputs gracefully.","solution":"def transform_dna_sequence(dna: str, mode: str) -> str: Transforms a given DNA sequence based on the specified mode. Args: dna (str): A string representing the DNA sequence composed of \'A\', \'T\', \'C\', and \'G\'. mode (str): A string that specifies the transformation mode. It can be either \'reverse\' or \'complementary\'. Returns: str: The transformed DNA sequence. Raises: ValueError: If the DNA sequence contains invalid characters or if the mode is not recognized. valid_nucleotides = set(\'ATCG\') # Check if the DNA sequence is valid if not set(dna).issubset(valid_nucleotides): raise ValueError(\\"Invalid DNA sequence.\\") if mode == \'reverse\': return dna[::-1] elif mode == \'complementary\': complement = {\'A\': \'T\', \'T\': \'A\', \'C\': \'G\', \'G\': \'C\'} return \'\'.join(complement[n] for n in dna) else: raise ValueError(\\"Unknown transformation mode.\\")"},{"question":"# Question Scenario: You are given a problem to find the minimum number of swaps required to sort an array in ascending order. A swap is defined as swapping the elements at any two indices in the array. Task: Write a function `min_swaps_to_sort(arr: List[int]) -> int` that calculates the minimum number of swaps needed to sort the array in ascending order. **Input:** - `arr` (List[int]): A list of integers that needs to be sorted. **Output:** - `int`: The minimum number of swaps required to sort the array in ascending order. **Constraints:** - `1 <= len(arr) <= 10^5` - `-10^9 <= arr[i] <= 10^9` for each element in `arr` **Performance Requirement:** - Your solution should be optimized to work efficiently for the given constraints with a linear time complexity O(n log n). Example: ```python assert min_swaps_to_sort([4, 3, 2, 1]) == 2 assert min_swaps_to_sort([1, 5, 4, 3, 2]) == 2 assert min_swaps_to_sort([1, 3, 5, 2, 4, 6, 7]) == 3 ```","solution":"from typing import List def min_swaps_to_sort(arr: List[int]) -> int: n = len(arr) # Create an array of tuples where each tuple is (value, index) arrpos = [(value, i) for i, value in enumerate(arr)] # Sort the array by the values arrpos.sort(key=lambda it: it[0]) # Initialize visited array visited = [False] * n # Initialize result swaps = 0 for i in range(n): # If the element is already visited or already at the correct position if visited[i] or arrpos[i][1] == i: continue # Initialize a cycle length cycle_size = 0 x = i while not visited[x]: # Mark the current element as visited visited[x] = True # Move to the next index x = arrpos[x][1] cycle_size += 1 # Add the number of swaps needed for this cycle if cycle_size > 1: swaps += (cycle_size - 1) return swaps"},{"question":"# Question: Inventory Management System for a Retail Store You are tasked with developing a simple inventory management system for a retail store in Python. The system should allow for the addition, updating, and querying of product information. Class: `InventoryManagement` **Attributes**: - `inventory`: A dictionary to store product details, where the key is the product ID, and the value is another dictionary with keys `\'name\'`, `\'quantity\'`, and `\'price\'`. **Methods**: 1. `add_product(product_id: int, name: str, quantity: int, price: float) -> None`: - Adds a new product to the inventory. If the product ID already exists, it should not change the existing product and should return an error message. 2. `update_product(product_id: int, quantity: int, price: float) -> str`: - Updates the product\'s quantity and price. If the product ID does not exist, it should return an error message. 3. `get_product(product_id: int) -> dict`: - Returns the product details for the given product ID. If the product ID does not exist, it should return an error message. 4. `inventory_value() -> float`: - Returns the total value of the inventory, calculated as the sum of each product\'s quantity multiplied by its price. **Constraints**: - Product IDs are unique integers. - Product quantities are non-negative integers. - Product prices are positive floats. Example Usage ```python # Example usage inventory = InventoryManagement() # Add new products inventory.add_product(101, \\"Laptop\\", 5, 800.00) inventory.add_product(102, \\"Smartphone\\", 10, 500.00) # Update a product\'s information inventory.update_product(101, 7, 820.00) # Get product details product = inventory.get_product(101) # Calculate the inventory value total_value = inventory.inventory_value() ``` Expected Output ```python # Adding a product None # Product added successfully # Updating a product \'Product 101 updated successfully\' # Getting a product details {\'name\': \'Laptop\', \'quantity\': 7, \'price\': 820.0} # Total inventory value 11400.00 ``` **Hints**: - Use Python dictionary methods to add, update, and retrieve data. - Ensure your methods handle edge cases, such as invalid product IDs or negative quantities and prices.","solution":"class InventoryManagement: def __init__(self): self.inventory = {} def add_product(self, product_id: int, name: str, quantity: int, price: float) -> None: if product_id in self.inventory: return \\"Error: Product ID already exists.\\" self.inventory[product_id] = { \'name\': name, \'quantity\': quantity, \'price\': price } def update_product(self, product_id: int, quantity: int, price: float) -> str: if product_id not in self.inventory: return \\"Error: Product ID does not exist.\\" self.inventory[product_id][\'quantity\'] = quantity self.inventory[product_id][\'price\'] = price return f\\"Product {product_id} updated successfully.\\" def get_product(self, product_id: int) -> dict: if product_id not in self.inventory: return \\"Error: Product ID does not exist.\\" return self.inventory[product_id] def inventory_value(self) -> float: total_value = 0.0 for product in self.inventory.values(): total_value += product[\'quantity\'] * product[\'price\'] return total_value"},{"question":"# Context: In data structures, especially in binary trees, traversals are fundamental operations for exploring or modifying tree data. One of the common traversals is the in-order traversal where nodes are visited in a specific order: left subtree, root, and then the right subtree. # Problem Statement: You need to implement an in-order traversal of a binary tree and return a list of values representing the in-order traversal sequence. Write a function `in_order_traversal` that takes the root of the binary tree and returns the list of node values in in-order sequence. # Function Signature: ```python def in_order_traversal(root: Optional[TreeNode]) -> List[int]: ``` # Input: - `root`: a TreeNode representing the root of the binary tree or `None` if the tree is empty. # Output: - Returns a list of integers representing the node values in in-order sequence. # Constraints: - The number of nodes in the tree will not exceed 1000. - Node values are unique integers. # Example: Consider the binary tree shown below: ```plaintext 1 / 2 3 / 4 5 ``` The in-order traversal of this tree should return `[4, 2, 5, 1, 3]`. ```python # Define the tree nodes. root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) # The function call: >>> in_order_traversal(root) [4, 2, 5, 1, 3] ``` # Additional Information: Use the following TreeNode class for tree construction: ```python class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def in_order_traversal(root: Optional[TreeNode]) -> List[int]: Performs an in-order traversal of a binary tree. Args: root (Optional[TreeNode]): The root of the binary tree. Returns: List[int]: List of node values in in-order sequence. def traverse(node: Optional[TreeNode], inorder: List[int]): if node: traverse(node.left, inorder) inorder.append(node.val) traverse(node.right, inorder) result = [] traverse(root, result) return result"},{"question":"# Coding Assessment Question **Scenario**: Algorithms often rely on certain mathematical properties or operations to solve problems efficiently. One such commonly used operation is determining the greatest common divisor (GCD) of two numbers, which finds the largest number that divides both numbers without leaving a remainder. This operation is fundamental in problems involving fractions, modular arithmetic, and more. **Problem Statement**: You are required to implement a few functions related to the greatest common divisor (GCD) and least common multiple (LCM) in Python. Design the following functions: 1. `gcd(a: int, b: int) -> int`: This function finds the greatest common divisor of `a` and `b` using the Euclidean algorithm. 2. `lcm(a: int, b: int) -> int`: This function finds the least common multiple of `a` and `b` using the relationship between GCD and LCM. 3. `gcd_of_list(numbers: List[int]) -> int`: This function finds the GCD of a list of integers. 4. `lcm_of_list(numbers: List[int]) -> int`: This function finds the LCM of a list of integers. # Function Signatures ```python from typing import List def gcd(a: int, b: int) -> int: pass def lcm(a: int, b: int) -> int: pass def gcd_of_list(numbers: List[int]) -> int: pass def lcm_of_list(numbers: List[int]) -> int: pass ``` # Input and Output Format * **Input**: * For `gcd` and `lcm`: `a` and `b` are two non-negative integers. * For `gcd_of_list` and `lcm_of_list`: `numbers` is a list of non-negative integers. * **Output**: * `gcd` returns an integer representing the greatest common divisor of `a` and `b`. * `lcm` returns an integer representing the least common multiple of `a` and `b`. * `gcd_of_list` returns an integer representing the GCD of all the integers in `numbers`. * `lcm_of_list` returns an integer representing the LCM of all the integers in `numbers`. # Constraints * 0 ≤ `a`, `b` ≤ 10^9 * The length of `numbers` list, `len(numbers)`, is between 1 and 10^6. * Each element in the `numbers` list is between 0 and 10^9. # Example ```python assert gcd(48, 18) == 6 assert lcm(4, 5) == 20 assert gcd_of_list([32, 96, 128]) == 32 assert lcm_of_list([4, 6, 8]) == 24 ``` Implement these functions as specified while handling large inputs efficiently.","solution":"from typing import List from functools import reduce import math def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of a and b using the Euclidean algorithm. while b: a, b = b, a % b return a def lcm(a: int, b: int) -> int: Returns the least common multiple (LCM) of a and b using the relationship between GCD and LCM. if a == 0 or b == 0: return 0 return abs(a * b) // gcd(a, b) def gcd_of_list(numbers: List[int]) -> int: Returns the GCD of a list of integers. return reduce(gcd, numbers) def lcm_of_list(numbers: List[int]) -> int: Returns the LCM of a list of integers. return reduce(lcm, numbers)"},{"question":"# Prime Factors Product Calculation Problem Statement: A number is defined as **prime-power** if it can be represented as ( p^k ) where ( p ) is a prime number and ( k ) is a positive integer. Your task is to implement a function that calculates the product of all distinct prime factors of a given integer. Input: - A single integer `n` (2 <= n <= 10^6). Output: - Return the product of all distinct prime factors of `n`. Example: ```python prime_factors_product(12) # Output: 6 (since 12 = 2^2 * 3, and 2 * 3 = 6) prime_factors_product(18) # Output: 6 (since 18 = 2 * 3^2, and 2 * 3 = 6) prime_factors_product(7) # Output: 7 (since 7 is a prime number) ``` Constraints: - Focus on minimizing the time complexity, using efficient algorithms to determine prime factors. Implementation Requirements: - Implement an optimized prime factorization method. - Ensure the function handles edge cases such as when the number is prime. Starter Code: ```python def prime_factors_product(n: int) -> int: Calculate the product of all distinct prime factors of a given integer. :param n: int: the number to find the product of prime factors for :return: int: product of distinct prime factors def sieve(n): primes = [True] * (n + 1) p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 return [p for p in range(2, n + 1) if primes[p]] primes = sieve(int(n**0.5) + 1) product = 1 original_n = n for prime in primes: if n % prime == 0: product *= prime while n % prime == 0: n //= prime if n > 1: product *= n return product # Example usage: if __name__ == \\"__main__\\": number = int(input(\\"Enter number: \\").strip()) result = prime_factors_product(number) print(f\\"The product of all distinct prime factors of {number} is {result}.\\") ```","solution":"def prime_factors_product(n: int) -> int: Calculate the product of all distinct prime factors of a given integer. :param n: int: the number to find the product of prime factors for :return: int: product of distinct prime factors def sieve(n): primes = [True] * (n + 1) p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 return [p for p in range(2, n + 1) if primes[p]] primes = sieve(int(n**0.5) + 1) product = 1 for prime in primes: if n % prime == 0: product *= prime while n % prime == 0: n //= prime if n > 1: product *= n return product"},{"question":"# Context: In this task, you will be required to implement a function that generates a Mandelbrot set image. The Mandelbrot set is a set of complex numbers for which the function does not diverge when iterated. # Function Specification: Implement a function `generate_mandelbrot_set(width: int, height: int, x_min: float, x_max: float, y_min: float, y_max: float, max_iterations: int) -> np.ndarray` that: * Takes as input: - `width`: an integer specifying the width of the output image. - `height`: an integer specifying the height of the output image. - `x_min`, `x_max`: floats specifying the range of x-coordinates (real part). - `y_min`, `y_max`: floats specifying the range of y-coordinates (imaginary part). - `max_iterations`: an integer specifying the maximum number of iterations to determine if a point is in the Mandelbrot set. * Returns: - A 2D numpy array of shape (height, width) where each element represents the number of iterations before escaping the Mandelbrot set. Examples: ```python >>> width = 800 >>> height = 600 >>> x_min = -2.0 >>> x_max = 1.0 >>> y_min = -1.5 >>> y_max = 1.5 >>> max_iterations = 1000 >>> mandelbrot_set = generate_mandelbrot_set(width, height, x_min, x_max, y_min, y_max, max_iterations) >>> mandelbrot_set.shape (600, 800) ``` Requirements: 1. Map each pixel (i, j) to the corresponding complex number. 2. Initialize each pixel\'s iteration count to zero. 3. For each pixel, iterate the function zn+1 = zn^2 + c where `c` is the complex number corresponding to the pixel. 4. Track the number of iterations until the absolute value of `zn` exceeds 2. 5. If the maximum number of iterations is reached without `zn` exceeding 2, mark that pixel as part of the Mandelbrot set. 6. Return the iteration counts as a 2D numpy array. # Implementation: Write your solution within the function signature provided below: ```python import numpy as np def generate_mandelbrot_set(width: int, height: int, x_min: float, x_max: float, y_min: float, y_max: float, max_iterations: int) -> np.ndarray: Generate Mandelbrot set and return a matrix of iteration counts. Args: width: Width of the output image. height: Height of the output image. x_min: Minimum x-coordinate (real part). x_max: Maximum x-coordinate (real part). y_min: Minimum y-coordinate (imaginary part). y_max: Maximum y-coordinate (imaginary part). max_iterations: Maximum number of iterations. Returns: A matrix where each element represents the iteration count for the corresponding pixel. # Your implementation here ```","solution":"import numpy as np def generate_mandelbrot_set(width: int, height: int, x_min: float, x_max: float, y_min: float, y_max: float, max_iterations: int) -> np.ndarray: Generate Mandelbrot set and return a matrix of iteration counts. Args: width: Width of the output image. height: Height of the output image. x_min: Minimum x-coordinate (real part). x_max: Maximum x-coordinate (real part). y_min: Minimum y-coordinate (imaginary part). y_max: Maximum y-coordinate (imaginary part). max_iterations: Maximum number of iterations. Returns: A matrix where each element represents the iteration count for the corresponding pixel. mandelbrot_set = np.zeros((height, width), dtype=int) for row in range(height): for col in range(width): x = x_min + (x_max - x_min) * col / (width - 1) y = y_min + (y_max - y_min) * row / (height - 1) c = complex(x, y) z = 0j iteration = 0 while abs(z) <= 2 and iteration < max_iterations: z = z * z + c iteration += 1 mandelbrot_set[row, col] = iteration return mandelbrot_set"},{"question":"# Coding Assessment Question Problem Statement Given two integers, `m` and `n`, write a function to determine if it is possible to cut a chocolate bar of size `m x n` into exactly `k` pieces using the minimum number of cuts. A cut is defined as a single straight line cut that goes through the entire bar either horizontally or vertically. Return the minimum number of cuts required if it is possible to achieve exactly `k` pieces, otherwise return -1. Function Signature ```python def min_cuts(m, n, k): Determines the minimum number of cuts required to get exactly k pieces of a chocolate bar. Parameters: m (int): Number of rows of the chocolate bar. n (int): Number of columns of the chocolate bar. k (int): Number of pieces to be cut from the chocolate bar. Returns: int: The minimum number of cuts required to get exactly k pieces, or -1 if it\'s not possible. # your code here ``` Input Format - `m`: An integer representing the number of rows in the chocolate bar. `(1 <= m <= 100)` - `n`: An integer representing the number of columns in the chocolate bar. `(1 <= n <= 100)` - `k`: An integer representing the number of pieces desired after cutting the chocolate bar. `(1 <= k <= m * n)` Output Format - An integer representing the minimum number of cuts required to get exactly `k` pieces, or -1 if it is not possible to achieve exactly `k` pieces. Example ```python print(min_cuts(2, 2, 3)) # Output: 2 print(min_cuts(2, 2, 5)) # Output: -1 ``` # Requirements 1. The function must efficiently determine if exactly `k` pieces can be obtained. 2. It should calculate the minimum number of cuts needed if it\'s possible. 3. Return -1 if it\'s not possible to achieve exactly `k` pieces.","solution":"def min_cuts(m, n, k): Determines the minimum number of cuts required to get exactly k pieces of a chocolate bar. Parameters: m (int): Number of rows of the chocolate bar. n (int): Number of columns of the chocolate bar. k (int): Number of pieces to be cut from the chocolate bar. Returns: int: The minimum number of cuts required to get exactly k pieces, or -1 if it\'s not possible. if k > m * n: return -1 if k == m * n: return m * n - 1 return k - 1"},{"question":"# Word Search in Grid You are provided with a grid of characters and a word. Your task is to determine if the word exists in the grid by constructing it from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. # Problem Statement Given an `m x n` grid of characters and a string word, check if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. # Task 1. **Function Implementation**: Implement a function `exist(grid: List[List[str]], word: str) -> bool` that checks if the word exists in the given grid. 2. The function should: - **Input**: - `grid`: A list of lists of characters representing the character grid. - `word`: A string which needs to be searched in the grid. - **Output**: - A boolean value indicating True if the word exists in the grid, and False otherwise. 3. Use Depth-First Search (DFS) for traversing the grid. ```python def exist(grid: List[List[str]], word: str) -> bool: if not grid: return False rows, cols = len(grid), len(grid[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or c < 0 or r >= rows or c >= cols or word[i] != grid[r][c]: return False temp = grid[r][c] grid[r][c] = \'#\' found = dfs(r + 1, c, i + 1) or dfs(r - 1, c, i + 1) or dfs(r, c + 1, i + 1) or dfs(r, c - 1, i + 1) grid[r][c] = temp return found for row in range(rows): for col in range(cols): if grid[row][col] == word[0] and dfs(row, col, 0): return True return False ``` # Example ```python grid = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] word = \\"ABCCED\\" result = exist(grid, word) print(result) # Output: True ``` # Constraints - The grid and the word contain only uppercase and lowercase English letters. - `1 <= m, n <= 200` where `m` is the number of rows and `n` is the number of columns in the grid. - `1 <= len(word) <= 10^3`. Ensure the implementation is efficient and handles the input size within acceptable limits. Utilize the DFS approach effectively to solve the problem.","solution":"from typing import List def exist(grid: List[List[str]], word: str) -> bool: if not grid or not word: return False rows, cols = len(grid), len(grid[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[i]: return False temp = grid[r][c] grid[r][c] = \'#\' # Mark this cell as visited # Explore all four possible directions found = (dfs(r + 1, c, i + 1) or dfs(r - 1, c, i + 1) or dfs(r, c + 1, i + 1) or dfs(r, c - 1, i + 1)) grid[r][c] = temp # Restore the cell after exploration return found for row in range(rows): for col in range(cols): if grid[row][col] == word[0] and dfs(row, col, 0): return True return False"},{"question":"# Scenario You are tasked with developing a system to efficiently manage employee records within a company. One aspect of this system involves creating an employee search functionality that allows querying employees by their unique ID. You need to ensure that the system can quickly return employee details even as the number of records grows significantly. # Challenge Implement a custom Binary Search Tree (BST) to store and retrieve employee records based on their unique IDs. The BST should support insertion of new employee records and querying by ID. # Task 1. Implement the `EmployeeBST` class with the following methods: - `insert(self, emp_id, emp_name)`: Inserts a new employee record into the BST. Each node in the tree should store the employee ID and name. - `find(self, emp_id)`: Searches for an employee in the BST by their ID and returns their name if found, or `None` if not found. 2. Ensure the BST maintains the properties of a binary search tree during insertions. 3. Provide an efficient way to report the height of the BST at any given time. # Requirements - Implement the methods as specified. - Ensure the BST properly handles insertion and querying. - Optimize for average-case performance while considering potential worst-case scenarios. # Input and Output - Input: A series of employee records to be inserted into the BST, followed by queries for specific employee IDs. - Output: For each query, return the corresponding employee name or `None` if the employee does not exist in the BST. # Example Suppose you have the following sequence of operations: ```python bst = EmployeeBST() bst.insert(1001, \\"John Smith\\") bst.insert(1002, \\"Jane Doe\\") print(bst.find(1001)) # Output: \\"John Smith\\" print(bst.find(1003)) # Output: None print(bst.height()) # Output: Relevant height of the tree ``` # Constraints - Employee IDs are unique integers. - Employee names are strings. - The BST must handle up to 100,000 employee records efficiently. Implement the `EmployeeBST` with the required methods and ensure it correctly manages insertions, queries, and height reporting.","solution":"class EmployeeBST: class Node: def __init__(self, emp_id, emp_name): self.emp_id = emp_id self.emp_name = emp_name self.left = None self.right = None def __init__(self): self.root = None def insert(self, emp_id, emp_name): if self.root is None: self.root = self.Node(emp_id, emp_name) else: self._insert(self.root, emp_id, emp_name) def _insert(self, node, emp_id, emp_name): if emp_id < node.emp_id: if node.left is None: node.left = self.Node(emp_id, emp_name) else: self._insert(node.left, emp_id, emp_name) elif emp_id > node.emp_id: if node.right is None: node.right = self.Node(emp_id, emp_name) else: self._insert(node.right, emp_id, emp_name) # Duplicate emp_id is ignored; assumption based on unique IDs in constraints def find(self, emp_id): return self._find(self.root, emp_id) def _find(self, node, emp_id): if node is None: return None if emp_id == node.emp_id: return node.emp_name elif emp_id < node.emp_id: return self._find(node.left, emp_id) else: return self._find(node.right, emp_id) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) # Example usage: # bst = EmployeeBST() # bst.insert(1001, \\"John Smith\\") # bst.insert(1002, \\"Jane Doe\\") # print(bst.find(1001)) # Output: \\"John Smith\\" # print(bst.find(1003)) # Output: None # print(bst.height()) # Output: Relevant height of the tree"},{"question":"# Problem Statement You are given a list of tasks, each represented by a tuple of start and end times. Your goal is to determine the minimum number of meeting rooms required to host all the tasks such that no two tasks overlap in the same room. Each task must be assigned to one room. Write a Python function `min_meeting_rooms(tasks)` that accepts a list of tasks and returns the minimum number of meeting rooms required. # Input - `tasks`: A list of tuples where each tuple represents a task. Each tuple contains two integers - start time and end time. - ( 0 leq text{start time} < text{end time} leq 10^4 ) # Output - An integer representing the minimum number of meeting rooms required. # Constraints - The number of tasks ( 1 leq text{len(tasks)} leq 10^4 ) - Start and end times are integers. # Example ```python def min_meeting_rooms(tasks): intervals = sorted(tasks, key=lambda x: x[0]) end_times = [] for interval in intervals: if end_times and end_times[0] <= interval[0]: heapq.heapreplace(end_times, interval[1]) else: heapq.heappush(end_times, interval[1]) return len(end_times) # Example usage tasks = [(30, 75), (0, 50), (60, 150)] print(min_meeting_rooms(tasks)) # Output: 2 tasks = [(10, 20), (20, 30), (15, 25)] print(min_meeting_rooms(tasks)) # Output: 2 tasks = [(1, 4), (2, 5), (7, 9)] print(min_meeting_rooms(tasks)) # Output: 2 tasks = [(0, 30), (5, 10), (15, 20)] print(min_meeting_rooms(tasks)) # Output: 2 tasks = [(5, 10), (10, 15)] print(min_meeting_rooms(tasks)) # Output: 1 ``` # Note - Each task is represented by (start_time, end_time) where start_time < end_time. - Ensure your solution is optimal and can handle up to 10^4 tasks efficiently.","solution":"import heapq def min_meeting_rooms(tasks): Determines the minimum number of meeting rooms required to accommodate all tasks without any overlap in the same room. Args: tasks (list of tuples): List of tasks represented by (start, end) times. Returns: int: Minimum number of meeting rooms required. if not tasks: return 0 # Sort tasks by start time tasks.sort(key=lambda x: x[0]) # Initialize a min heap to keep track of end times end_times = [] # Iterate through the sorted tasks for task in tasks: # If the earliest end time is less than or equal to the start of the current task if end_times and end_times[0] <= task[0]: # Reuse the room and update the end time heapq.heapreplace(end_times, task[1]) else: # Otherwise, allocate a new room heapq.heappush(end_times, task[1]) # The size of the heap is the number of rooms required return len(end_times)"},{"question":"# Implement a Linked List Intersection Function Write a function `find_intersection` that determines if two singly linked lists intersect, and returns the intersecting node. If the linked lists do not intersect, the function should return `None`. Function Signature ```python def find_intersection(ll_one: LinkedList, ll_two: LinkedList) -> Optional[Node]: pass ``` # Input - Two linked lists `ll_one` and `ll_two` of type `LinkedList`. # Output - The intersecting node of type `Node` if the linked lists intersect, otherwise `None`. # Constraints - Assume the linked lists do not contain cycles. - The lists consist of nodes with integer values. - The intersection is defined based on reference, not value. Two nodes intersect if they are the exact same node, meaning they share the same memory address. # Example ```python # Example inputs class Node: def __init__(self, value): self.value = value self.next = None # Create intersecting linked lists intersect_node = Node(8) ll_one = LinkedList() ll_one.append(3) ll_one.append(7) ll_one.append_node(intersect_node) ll_one.append(10) ll_two = LinkedList() ll_two.append(99) ll_two.append(1) ll_two.append_node(intersect_node) # Example output result = find_intersection(ll_one, ll_two) print(result.value if result else \\"No intersection\\") # Output: \'8\' ``` # Additional Requirements - Handle edge cases such as empty linked lists. - Ensure that the function is efficient in terms of time complexity. - Provide an additional utility function to append a node by reference. - Error handling for inputs that are not properly structured should be considered.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def append_node(self, node): if not self.head: self.head = node return current = self.head while current.next: current = current.next current.next = node def find_intersection(ll_one: LinkedList, ll_two: LinkedList) -> Node: if ll_one.head is None or ll_two.head is None: return None def get_length_and_tail(ll): length = 0 current = ll.head while current: length += 1 if current.next is None: return length, current current = current.next len_one, tail_one = get_length_and_tail(ll_one) len_two, tail_two = get_length_and_tail(ll_two) if tail_one != tail_two: return None longer = ll_one.head if len_one > len_two else ll_two.head shorter = ll_one.head if len_one <= len_two else ll_two.head for _ in range(abs(len_one - len_two)): longer = longer.next while longer != shorter: longer = longer.next shorter = shorter.next return longer"},{"question":"# Coding Assessment Question: Advanced Data Processing Objective Implement functions for calculating correlation coefficient (Pearson) and identifying outliers using the IQR method. Problem Statement You are given two lists of numerical data points, representing paired observations. Your task is to: 1. Write a function `calculate_pearson_correlation(data_x: list, data_y: list, ndigits: int = 3) -> float` that calculates the Pearson correlation coefficient between two lists and handles edge cases. 2. Write a function `detect_outliers_iqr(data: list, ndigits: int = 3) -> list` that identifies outliers using the Interquartile Range (IQR) method. Requirements 1. **calculate_pearson_correlation**: * If either list is empty or the lengths of `data_x` and `data_y` do not match, return `None`. * For valid data, use the formula for Pearson correlation coefficient: [ r = frac{sum{(x - overline{x})(y - overline{y})}}{sqrt{sum{(x - overline{x})^2} sum{(y - overline{y})^2}}} ] * Round the result to `ndigits` decimal places. 2. **detect_outliers_iqr**: * Identify outliers using the IQR method: [ text{outliers} = { x in text{data} | x < Q1 - 1.5 times IQR text{ or } x > Q3 + 1.5 times IQR } ] * Return the list of outliers, rounded to `ndigits` decimal places. Example ```python def calculate_pearson_correlation(data_x: list, data_y: list, ndigits: int = 3) -> float: # Your implementation here def detect_outliers_iqr(data: list, ndigits: int = 3) -> list: # Your implementation here # Example usage: data_x = [10, 20, 30, 40, 50] data_y = [12, 22, 32, 42, 52] data_outliers = [10, 12, 18, 19, 30, 33, 40, 45, 55, 100] print(calculate_pearson_correlation(data_x, data_y)) # Output: 1.0 print(calculate_pearson_correlation([], data_y)) # Output: None print(calculate_pearson_correlation(data_x, [20, 30])) # Output: None print(detect_outliers_iqr(data_outliers)) # Output: [100.0] ``` Constraints * The length of the input lists `data_x` and `data_y` will be at least 2 and at most (10^6). * Each value in the input lists will be a floating-point number or integer within the range [-10^6, 10^6]. * The output should be rounded to `ndigits` decimal places.","solution":"def calculate_pearson_correlation(data_x, data_y, ndigits=3): if not data_x or not data_y or len(data_x) != len(data_y): return None n = len(data_x) mean_x = sum(data_x) / n mean_y = sum(data_y) / n sum_xy = sum((x - mean_x) * (y - mean_y) for x, y in zip(data_x, data_y)) sum_x2 = sum((x - mean_x) ** 2 for x in data_x) sum_y2 = sum((y - mean_y) ** 2 for y in data_y) denominator = (sum_x2 * sum_y2) ** 0.5 if denominator == 0: return None correlation = sum_xy / denominator return round(correlation, ndigits) def detect_outliers_iqr(data, ndigits=3): if not data: return [] sorted_data = sorted(data) n = len(data) q1 = sorted_data[n // 4] q3 = sorted_data[3 * n // 4] iqr = q3 - q1 lower_bound = q1 - 1.5 * iqr upper_bound = q3 + 1.5 * iqr outliers = [x for x in data if x < lower_bound or x > upper_bound] return [round(out, ndigits) for out in outliers]"},{"question":"Coding Assessment Question **Context**: Given two sorted arrays `arr1` and `arr2` of potentially different lengths, the task is to merge them into a single sorted array without using Python’s inbuilt sorting functions. Instead, the elements must be merged using their pre-existing order to form a new sorted array. **Objective**: Implement a function that merges two sorted arrays into one sorted array. **Function Signature**: ```python def merge_sorted_arrays(arr1: list, arr2: list) -> list: ``` **Input**: * `arr1` (list): A list of integers sorted in non-decreasing order. * `arr2` (list): Another list of integers sorted in non-decreasing order. **Output**: * `list`: A list containing integers from both input lists, sorted in non-decreasing order. **Constraints**: * Both `arr1` and `arr2` can each have a length from 0 to 1000. * The integers in `arr1` and `arr2` are in the range of `-10^6` to `10^6`. **Examples**: ```python merge_sorted_arrays([1, 3, 5], [2, 4, 6]) # Output: [1, 2, 3, 4, 5, 6] merge_sorted_arrays([0, 10, 20], []) # Output: [0, 10, 20] merge_sorted_arrays([], [-3, -2, -1]) # Output: [-3, -2, -1] merge_sorted_arrays([1, 2], [1, 2]) # Output: [1, 1, 2, 2] ``` **Requirements**: 1. Your function should not use any built-in sorting library or method. 2. The function should efficiently handle the edge cases where one or both arrays might be empty. --- **Notes**: - Use two pointers technique, which entails maintaining two indices and iterating through both input arrays simultaneously to achieve optimal performance. - While traversing, pick the smallest current element from either array and append it to the result list.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged sorted array. merged_array = [] i, j = 0, 0 # Traverse both arrays and merge them while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # If there are remaining elements in arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # If there are remaining elements in arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"# Odd-Even Sorting Algorithm You are tasked with implementing a function that sorts an array such that all odd numbers come before all even numbers. Within their respective groups, odd numbers and even numbers should maintain their original relative order (i.e., the sorting should be stable). Function Signature ```python def odd_even_sort(arr: list) -> list: pass ``` Input and Output * **Input** * `arr` (list): A list of non-negative integers to be sorted. (0 <= len(arr) <= 10^5) * **Output** * (list): Returns a new list where all odd numbers precede all even numbers, while maintaining the original relative order within the odd and even groups. Constraints * The function should raise a `TypeError` if the input `arr` is not a list. * The function should raise a `ValueError` if elements of `arr` are not non-negative integers. Example ```python >>> odd_even_sort([3, 1, 4, 2, 5]) [3, 1, 5, 4, 2] >>> odd_even_sort([6, 7, 2, 8, 1, 3]) [7, 1, 3, 6, 2, 8] >>> odd_even_sort([0, 2, 4]) [0, 2, 4] >>> odd_even_sort([1]) [1] >>> odd_even_sort([]) [] ``` Notes * Make sure to optimize the function for large inputs to handle the maximum constraint efficiently. * Ensure the function is stable, maintaining the input order within odd and even groups.","solution":"def odd_even_sort(arr): This function sorts an array such that all odd numbers come before all even numbers, while maintaining the relative order of odd and even numbers within their groups. :param arr: list of non-negative integers :return: list of integers sorted by odd numbers first, then even numbers :raises TypeError: if input arr is not a list :raises ValueError: if any element of arr is not a non-negative integer if not isinstance(arr, list): raise TypeError(\\"Input should be a list\\") if not all(isinstance(x, int) and x >= 0 for x in arr): raise ValueError(\\"All elements in the list should be non-negative integers\\") odds = [] evens = [] for number in arr: if number % 2 != 0: odds.append(number) else: evens.append(number) return odds + evens"},{"question":"# Question Context A common task in various algorithms and data structures is to find the shortest path in an unweighted graph. One widely used algorithm for this purpose is Breadth-First Search (BFS). BFS explores the graph level by level, starting from a given source node. Imagine you are implementing a function to find the shortest path between two nodes in an unweighted graph represented as an adjacency list. Problem Statement Implement a function `shortest_path_unweighted` to compute the shortest path between a source node and a target node. 1. **shortest_path_unweighted(graph: dict[int, list[int]], source: int, target: int) -> int** - **Input**: - `graph`: A dictionary where keys are node indices and values are lists of adjacent nodes. - `source`: An integer representing the source node. - `target`: An integer representing the target node. - **Output**: - An integer representing the number of edges in the shortest path from `source` to `target`. If there is no path, return -1. - **Example**: ```python >>> graph = { ... 0: [1, 2], ... 1: [0, 3], ... 2: [0, 3], ... 3: [1, 2] ... } >>> shortest_path_unweighted(graph, 0, 3) 2 ``` 2. **Constraints**: - `1 <= len(graph) <= 10^4` - All edges are undirected and the graph is connected. Additional Requirements - Your implementation should handle edge cases such as: - Source and target being the same node. - Large graphs with multiple paths of varying lengths. - Consider using an optimized algorithm (e.g., BFS) to handle larger graphs efficiently.","solution":"from collections import deque def shortest_path_unweighted(graph, source, target): Compute shortest path between source and target in an unweighted graph using BFS. :param graph: Dict[int, List[int]] -- adjacency list representation of the graph. :param source: int -- the source node. :param target: int -- the target node. :return: int -- the number of edges in the shortest path from source to target. Return -1 if no path exists. if source == target: return 0 visited = set() queue = deque([(source, 0)]) # (node, distance) while queue: current_node, current_distance = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph[current_node]: if neighbor == target: return current_distance + 1 if neighbor not in visited: queue.append((neighbor, current_distance + 1)) return -1"},{"question":"# Question: Implement an Optimized Matrix Multiplication Using Strassen\'s Algorithm Matrix multiplication is a fundamental operation in many scientific and engineering applications. Strassen\'s algorithm provides an efficient way to multiply two matrices by reducing the computational complexity. Description: You are required to implement Strassen\'s algorithm for matrix multiplication in Python. This algorithm divides each matrix into submatrices and recursively multiplies them, significantly reducing the number of multiplications necessary compared to the standard matrix multiplication method. Function Signature: ```python import numpy as np def strassen_matrix_multiply(A: np.ndarray, B: np.ndarray) -> np.ndarray: Multiplies two square matrices using Strassen\'s algorithm. Parameters: A (ndarray): The first square matrix. B (ndarray): The second square matrix. Returns: C (ndarray): The resulting matrix product. ``` Input: * `A`: A numpy array representing the first matrix. * `B`: A numpy array representing the second matrix. Output: * A numpy array representing the matrix product of A and B. Constraints: * Both `A` and `B` will be square matrices of size 2^n x 2^n (e.g., 2x2, 4x4, 8x8). * Implement the algorithm recursively, utilizing the divide and conquer strategy inherent to Strassen\'s approach. Example: ```python >>> import numpy as np >>> A = np.array([[1, 2], [3, 4]]) >>> B = np.array([[5, 6], [7, 8]]) >>> strassen_matrix_multiply(A, B) array([[19, 22], [43, 50]]) ``` Implement the `strassen_matrix_multiply` function according to the above specifications.","solution":"import numpy as np def strassen_matrix_multiply(A: np.ndarray, B: np.ndarray) -> np.ndarray: Multiplies two square matrices using Strassen\'s algorithm. Parameters: A (ndarray): The first square matrix. B (ndarray): The second square matrix. Returns: C (ndarray): The resulting matrix product. if A.shape[0] == 1: return A * B else: mid = A.shape[0] // 2 A11 = A[:mid, :mid] A12 = A[:mid, mid:] A21 = A[mid:, :mid] A22 = A[mid:, mid:] B11 = B[:mid, :mid] B12 = B[:mid, mid:] B21 = B[mid:, :mid] B22 = B[mid:, mid:] M1 = strassen_matrix_multiply(A11 + A22, B11 + B22) M2 = strassen_matrix_multiply(A21 + A22, B11) M3 = strassen_matrix_multiply(A11, B12 - B22) M4 = strassen_matrix_multiply(A22, B21 - B11) M5 = strassen_matrix_multiply(A11 + A12, B22) M6 = strassen_matrix_multiply(A21 - A11, B11 + B12) M7 = strassen_matrix_multiply(A12 - A22, B21 + B22) C11 = M1 + M4 - M5 + M7 C12 = M3 + M5 C21 = M2 + M4 C22 = M1 + M3 - M2 + M6 C = np.zeros((A.shape[0], A.shape[1])) C[:mid, :mid] = C11 C[:mid, mid:] = C12 C[mid:, :mid] = C21 C[mid:, mid:] = C22 return C"},{"question":"# Coding Assessment Question A company needs to efficiently track and manage frequently changing prices for a large number of products. To help with this, they want to implement a system with a list of products where each product has a unique identifier and a price. Your task is to write a function that processes a series of operations on this product list. Each operation can either update a price, query the current price of a product, or retrieve the product with the maximum price. # Function Signature ```python def manage_prices(operations: List[str]) -> List[Union[int, None]]: Process a list of operations to manage product prices. :param operations: A list of operations to be performed. Each operation is a string where: - \\"Update <product_id> <new_price>\\": sets the price of the product with the given id to new_price. - \\"Price <product_id>\\": queries the current price of the product with the given id. - \\"MaxPrice\\": retrieves the maximum price among all products. :return: A list of results for Price and MaxPrice operations, in the order they appear in the operations list. Return None for Update operations. ``` # Example ```python >>> manage_prices([ \\"Update 1 200\\", \\"Update 2 300\\", \\"Price 1\\", \\"Update 1 500\\", \\"MaxPrice\\", \\"Price 2\\" ]) [200, 500, 300] >>> manage_prices([ \\"Update 1 150\\", \\"Update 2 250\\", \\"Update 3 100\\", \\"MaxPrice\\", \\"Price 3\\", \\"Update 2 50\\", \\"MaxPrice\\" ]) [250, 100, 150] ``` # Input Constraints * The `product_id` will be a positive integer. * The `new_price` will be a non-negative integer. * The number of operations will be between 1 and 100,000. * Each string in `operations` will be correctly formatted as described. # Requirements * Update operations should change the price for the specified `product_id`. * Price operations should return the current price associated with the specified `product_id`. * MaxPrice operations should return the highest price among all products at that time. * Your solution should be efficient, capable of handling up to 100,000 operations quickly. # Edge Cases * Handle the scenario where MaxPrice is called with no prior updates. * Ensure that querying a price for a `product_id` that has not been updated appropriately handles or returns a default case.","solution":"def manage_prices(operations): Process a list of operations to manage product prices. :param operations: A list of operations to be performed. Each operation is a string where: - \\"Update <product_id> <new_price>\\": sets the price of the product with the given id to new_price. - \\"Price <product_id>\\": queries the current price of the product with the given id. - \\"MaxPrice\\": retrieves the maximum price among all products. :return: A list of results for Price and MaxPrice operations, in the order they appear in the operations list. Return None for Update operations. prices = {} max_price = None result = [] for operation in operations: parts = operation.split() op = parts[0] if op == \\"Update\\": product_id = int(parts[1]) new_price = int(parts[2]) prices[product_id] = new_price if max_price is None or new_price > max_price: max_price = new_price elif op == \\"Price\\": product_id = int(parts[1]) result.append(prices.get(product_id, None)) elif op == \\"MaxPrice\\": if prices: max_price = max(prices.values()) else: max_price = None result.append(max_price) return result"},{"question":"Trie Construction and Word Search You are tasked with implementing a Trie (prefix tree) and performing word searches within the tree. A Trie is useful for efficiently storing and searching a dynamic set of strings. Task 1: Trie Construction Write a class `Trie` with methods to construct a Trie from a list of words. The Trie should support insertion of words and checking if a word or prefix exists in the Trie. Task 2: Word Search Additionally, implement a method to search for words that match a given prefix. This will involve finding all words in the Trie that start with a given prefix. Input: 1. A list of `n` words, `words: list[str]`. 2. A query `prefix: str`. Output: 1. A list of words from the Trie that start with the given prefix. Example: ```python # Given words words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"ball\\"] # Construct the Trie trie = Trie() for word in words: trie.insert(word) # Search for words starting with the prefix \\"ap\\" matching_words = trie.starts_with(\\"ap\\") # Output: List of matching words, e.g., [\\"apple\\", \\"app\\", \\"apricot\\"] ``` Constraints: - The number of words `n` will be such that `1 ≤ n ≤ 10000`. - The length of each word will be such that `1 ≤ length(word) ≤ 100`. Performance Requirements: - Trie operations (insertion, search) should aim for an average time complexity of `O(m)` where `m` is the length of the word. ```python class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix): results = [] node = self.root for char in prefix: if char not in node.children: return results node = node.children[char] self._find_words(node, prefix, results) return results def _find_words(self, node, prefix, results): if node.end_of_word: results.append(prefix) for char, next_node in node.children.items(): self._find_words(next_node, prefix + char, results) ```","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix): results = [] node = self.root for char in prefix: if char not in node.children: return results node = node.children[char] self._find_words(node, prefix, results) return results def _find_words(self, node, prefix, results): if node.end_of_word: results.append(prefix) for char, next_node in node.children.items(): self._find_words(next_node, prefix + char, results)"},{"question":"# Unique String Identification Background You are given a list of strings, where each string contains lowercase alphabetic characters. Your task is to identify and return a list of unique strings based on their character composition, regardless of the order of characters in the strings. In other words, two strings are considered the same if they consist of the same characters, ignoring the order. Task Implement a function `unique_strings(strings: list) -> list` that takes a list of strings and returns a list of unique strings based on the described criteria. Details: - The input list can contain up to 10^5 strings. - Each string can contain up to 100 lowercase alphabetic characters. Input - `strings`: A list of strings containing lowercase alphabetic characters. Output - A list of strings that contains one representative string for each unique set of characters found in the input list. Examples ```python assert unique_strings([\'abc\', \'bca\', \'cab\', \'xyz\', \'zyx\', \'yxz\', \'123\']) == [\'abc\', \'xyz\', \'123\'] assert unique_strings([\'hello\', \'ohlle\', \'world\', \'dlrow\', \'test\']) == [\'hello\', \'world\', \'test\'] ``` Requirements - Implement the function `unique_strings` to identify and return unique strings based on character composition. - Order of the output strings does not matter. Constraints - 1 ≤ number of strings in the input list ≤ 10^5 - 1 ≤ length of each string ≤ 100","solution":"def unique_strings(strings: list) -> list: Return a list of unique strings based on character composition. unique_set = set() result = [] for s in strings: # Create a sorted tuple of characters to disregard the order sorted_s = tuple(sorted(s)) if sorted_s not in unique_set: unique_set.add(sorted_s) result.append(s) return result"},{"question":"# Task: Implement a Function to Analyze Word Frequencies Problem Statement: You are tasked with implementing a function `analyze_word_frequencies(text: str) -> dict` that calculates the frequency of each unique word in a given string. The function should return a dictionary where the keys are the words and the values are the corresponding frequencies. Details: - **Input**: - `text (str)` : A string containing multiple words. - **Output**: - `dict` : A dictionary with words as keys and their frequencies as values. Constraints: - Words are separated by whitespace, and punctuation should be treated as part of the word. - The function is case-sensitive, meaning \\"Word\\" and \\"word\\" are considered different. - The text may contain any valid ASCII characters. - The input string may be empty, in which case the returned dictionary should also be empty. Performance Requirements: - The function should efficiently handle large input strings up to 10 MB in size. - The function should avoid unnecessary processing and utilize efficient data structures. Scenario: Imagine an application where users submit reviews, and you need to generate insights about frequently mentioned keywords. This function could be part of the backend analysis to identify common topics and trends in user feedback. Edge Cases: - The input string is empty. - The input string contains only whitespace. - All words in the input string are unique. - The input string contains a mix of upper and lower case characters. Skeleton Code: ```python def analyze_word_frequencies(text: str) -> dict: word_frequencies = {} words = text.split() for word in words: if word in word_frequencies: word_frequencies[word] += 1 else: word_frequencies[word] = 1 return word_frequencies ``` Hints: 1. Use the `split()` method to break the string into individual words. 2. A dictionary is an efficient way to store and update word frequencies. 3. Ensure to cover edge cases by writing comprehensive test cases. Implement `analyze_word_frequencies` function and write corresponding test cases to verify its correctness, including handling various edge cases as described.","solution":"def analyze_word_frequencies(text: str) -> dict: Calculate the frequency of each unique word in a given string. Args: text (str): A string containing multiple words. Returns: dict: A dictionary with words as keys and their frequencies as values. word_frequencies = {} words = text.split() for word in words: if word in word_frequencies: word_frequencies[word] += 1 else: word_frequencies[word] = 1 return word_frequencies"},{"question":"# Programming Question: Unique Binary Search Trees Given an integer `n`, write a function to determine how many structurally unique binary search trees (BSTs) that store values from 1 to `n`. A binary search tree is a binary tree in which for every node, the left subtree of the node contains only nodes with keys less than the node\'s key, and the right subtree contains only nodes with keys greater than the node\'s key. Write a Python function: ```python def num_trees(n: int) -> int: pass ``` # Input * An integer `n` (1 <= n <= 19), representing the number of nodes. # Output * Return the number of structurally unique BSTs that store values from 1 to `n`. # Example ```python >>> num_trees(3) 5 >>> num_trees(1) 1 >>> num_trees(4) 14 ``` # Explanation: * For `n = 3`, there are a total of 5 unique BSTs: * 1 as the root: 2 as the right child with 3 as the right child of 2. * 1 as the root: 3 as the right child with 2 as the left child of 3. * 2 as the root: 1 as the left child, 3 as the right child. * 3 as the root: 1 as the left child with 2 as the right child of 1. * 3 as the root: 2 as the left child with 1 as the left child of 2. # Notes: * Use dynamic programming to derive the number of unique BSTs. * Optimize the implementation to handle the upper constraints efficiently.","solution":"def num_trees(n: int) -> int: Calculate number of unique binary search trees (BSTs) that store values from 1 to n. if n == 0 or n == 1: return 1 # Initialize the dp array where dp[i] represents the number of unique BSTs with i nodes. dp = [0] * (n + 1) dp[0] = 1 # there\'s one unique BST with 0 nodes (an empty tree) dp[1] = 1 # there\'s one unique BST with 1 node # Fill the dp array using the recursive formula for nodes in range(2, n + 1): for root in range(1, nodes + 1): left = root - 1 # Number of nodes in the left subtree right = nodes - root # Number of nodes in the right subtree dp[nodes] += dp[left] * dp[right] return dp[n]"},{"question":"# Checking Palindromic Strings You are working as a software developer in a tech company that processes a large number of messages each day. Sometimes it\'s crucial to determine if a message is a palindrome after cleaning up spaces and ignoring letter casing. Your task is to evaluate whether each message satisfies this condition. Task: Write a Python function `check_palindromic_messages` that takes a list of strings representing the messages and returns a list of booleans indicating whether each message is a palindrome considering only alphanumeric characters and ignoring cases. Function Signature: ```python def check_palindromic_messages(messages: List[str]) -> List[bool]: ``` Input: * `messages` - A list of strings representing the messages (0 <= len(messages) <= 10^5). * Each message string length (0 <= len(message) <= 10^4). Output: * A list of booleans where each boolean corresponds to whether the respective message in the input list is a palindrome. Constraints: * Handle up to 10^5 messages efficiently. * Each message should be evaluated independently. * Ignore non-alphanumeric characters and cases. Example: ```python >>> check_palindromic_messages([\\"A man, a plan, a canal, Panama\\", \\"Hello, World!\\", \\"racecar\\", \\"Was it a car or a cat I saw?\\"]) [True, False, True, True] >>> check_palindromic_messages([\\"No \'x\' in Nixon\\", \\"12321\\", \\"abccba\\", \\"Python\\"]) [True, True, True, False] ``` # Scenario: You are tasked with integrating this function into a messaging service that needs to identify certain messages that are palindromic for potential special handling. Efficiency and accuracy are crucial since the service deals with a high volume of messages.","solution":"from typing import List def check_palindromic_messages(messages: List[str]) -> List[bool]: def is_palindrome(s: str) -> bool: filtered_chars = [char.lower() for char in s if char.isalnum()] return filtered_chars == filtered_chars[::-1] return [is_palindrome(message) for message in messages]"},{"question":"# String Reverser Imagine you are creating a simple utility that reverses words in a given sentence to better understand string manipulation and iteration concepts. **Problem Statement**: Write a function `reverse_words(sentence: str) -> str` that takes a single argument: - `sentence`: A string representing a sentence where words are separated by spaces. The function should return a string in which the order of the words is reversed. Note that the function should preserve the exact punctuation and capitalization of the original sentence as well as any leading or trailing whitespaces. **Input Constraints**: - `sentence` is a non-empty string consisting of alphabetic characters, spaces, punctuation marks (such as commas, periods, exclamation marks), and can include leading or trailing whitespaces. **Requirements**: 1. The function should handle multiple spaces between words. 2. Preserve spaces at the start and end of the sentence. 3. Punctuation marks should remain attached to their respective words in their reversed position. 4. Manage typical input lengths efficiently while preserving the string content accurately. **Example**: ```python >>> print(reverse_words(\\"Hello, world!\\") ) \\"world! Hello,\\" >>> print(reverse_words(\\" Python is fun! \\") ) \\" fun! is Python \\" >>> print(reverse_words(\\"Good morning, everyone.\\") ) \\"everyone. morning, Good\\" >>> print(reverse_words(\\"Amazing! Code in Python,\\") ) \\"Python, in Code Amazing!\\" ``` **Instructions**: - Implement the function by considering edge cases, such as multiple spaces or sentences with punctuation marks. - Ensure the function\'s performance is optimal for typical input lengths. - Test the function thoroughly with various types of input to validate its robustness.","solution":"def reverse_words(sentence: str) -> str: Return the sentence with the words in reverse order. :param sentence: A string representing a sentence where words are separated by spaces. :return: A string with the order of the words reversed. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Count Unique Characters in a Substring Objective Write a function that returns the number of unique characters in the longest substring without repeating characters. Implement an efficient solution that can handle large strings and optimize both time and space complexity. Input * A string `s` where `1 <= len(s) <= 10^6`, consisting of ASCII characters. Output * An integer representing the length of the longest substring with all unique characters. Constraints * The function should be capable of handling strings up to a length of 1,000,000. * The solution should be efficient in terms of both time and space complexities. Example ```python assert longest_unique_substring(\\"abcabcbb\\") == 3 # The answer is \\"abc\\" with length 3. assert longest_unique_substring(\\"bbbbb\\") == 1 # The answer is \\"b\\" with length 1. assert longest_unique_substring(\\"pwwkew\\") == 3 # The answer is \\"wke\\" with length 3. assert longest_unique_substring(\\"\\") == 0 # The answer is 0 for an empty string. ``` Implementation details 1. Use a sliding window technique to traverse the string. 2. Maintain a set to keep track of unique characters within the current window. 3. Adjust the window size dynamically to ensure all characters within the window remain unique. 4. Keep track of the maximum length of all such windows.","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_set = set() left = 0 max_len = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"# Question: Implement an Optimized Bubble Sort with Early Termination Context: You are tasked with improving the efficiency of sorting algorithms used in a legacy system. One approach you\'re exploring is optimizing the Bubble Sort algorithm by incorporating an early termination feature when the list becomes sorted before completing all passes. Task: Write a function `optimized_bubble_sort(arr)` that enhances the standard Bubble Sort algorithm with early termination. If during any full pass of the array no elements are swapped, the function should terminate early as the array is already sorted. Input: * `arr`: A list of integers to be sorted. Output: * The sorted list of integers. Description: The function should: 1. Traverse the list multiple times and swap any two adjacent elements that are in the wrong order. 2. Include an early termination mechanism: if no swaps are made during a full traversal of the list, the function should stop and return the sorted list. 3. Nevertheless, if swaps were made in any traversal, continue the sorting process until the list is sorted. Examples: ```python >>> optimized_bubble_sort([4, 2, 7, 1, 3]) [1, 2, 3, 4, 7] >>> optimized_bubble_sort([10, 8, 5, 2, 1]) [1, 2, 5, 8, 10] >>> optimized_bubble_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> optimized_bubble_sort([]) [] ``` Constraints: * Do not use built-in sorting functions or methods such as `sorted()` or `sort()`. * Ensure the function is efficient and the early termination mechanism is active. * Consider the performance for different input sizes and states (e.g., already sorted, reverse sorted).","solution":"def optimized_bubble_sort(arr): Optimized Bubble Sort algorithm with early termination. This function sorts a list of integers in ascending order using the Bubble Sort algorithm, enhanced with an early termination feature. Parameters: arr (list of int): The list of integers to sort. Returns: list of int: The sorted list of integers. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Problem Statement **Unmanned Moon Rover Pathfinding** A lunar moon rover is navigating a grid system on the moon’s surface. The rover starts at position (0, 0) and aims to reach a target position (n, m). The grid has certain obstacles that the rover must navigate around. The rover can move up, down, left, or right, one step at a time. Write a function `find_shortest_path(n: int, m: int, obstacles: List[Tuple[int, int]]) -> int` that calculates the shortest path from the start position to the target position. The grid\'s size is determined by the target position, and the obstacles are provided as a list of tuples of (x, y) coordinates. If the target position is unreachable due to obstacles, return -1. **Constraints**: - `0 <= n, m <= 50` - `0 <= len(obstacles) <= 100` - Grid cells and obstacles are defined within the range [0, max(n, m)] Input - `n` (int): x-coordinate of the target position. - `m` (int): y-coordinate of the target position. - `obstacles` (List[Tuple[int, int]]): List of (x, y) tuples representing obstacles. Output - `int`: The length of the shortest path from (0, 0) to (n, m), or -1 if the target is unreachable. Example ```python def find_shortest_path(n: int, m: int, obstacles: List[Tuple[int, int]]) -> int: # Implementation here… print(find_shortest_path(5, 5, [(1, 2), (3, 4), (2, 2)])) # Expected output: length of the shortest path or -1 ``` Notes - The rover cannot move diagonally, only up, down, left, or right. - The position (0, 0) is always free of obstacles and the starting position. - Assume the input is always valid and the grid cells are non-negative. Performance Requirements - The function should run efficiently for grid sizes up to 50x50 and handle up to 100 obstacles within reasonable time limits.","solution":"from collections import deque from typing import List, Tuple def find_shortest_path(n: int, m: int, obstacles: List[Tuple[int, int]]) -> int: if (n, m) == (0, 0): return 0 grid = set(obstacles) if (0, 0) in grid or (n, m) in grid: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == (n, m): return dist + 1 if 0 <= nx <= max(n, m) and 0 <= ny <= max(n, m) and (nx, ny) not in grid and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Counting Unique Numbers with Limit Given an array of integers, you are required to count the unique numbers in the array but limit your result to include only numbers that appear up to a given count. If no such numbers exist, return 0. # Task Write a function `count_unique_with_limit(arr: list[int], k: int) -> int` that returns the count of unique numbers in the list `arr` that appear `k` times or fewer. # Details - **Input**: - A list of integers `arr` where ( -10^9 leq arr[i] leq 10^9 ). - An integer `k` where ( 0 leq k leq 10^3 ). - **Output**: An integer representing the count of unique numbers that appear `k` times or fewer. - **Constraints**: The function should handle erroneous inputs gracefully (e.g., non-integer, negative). # Performance Requirements - The function should be optimized to handle large arrays efficiently. # Example ```python def count_unique_with_limit(arr: list[int], k: int) -> int: pass # Your implementation here # Example usages and expected outputs print(count_unique_with_limit([1, 2, 2, 3, 3, 3, 4], 1)) # Expected output: 1 (number 1 appears once) print(count_unique_with_limit([1, 2, 2, 3, 3, 3, 4, 4], 2)) # Expected output: 3 (numbers 1, 2 and 4 appear at most twice) print(count_unique_with_limit([1, 1, 1, 1, 2, 2, 3, 3, 3], 2)) # Expected output: 1 (number 2 appears twice) ``` # Explanation 1. **Unique Counts**: Use a helper function or data structure to count occurrences of each number. 2. **Limit Enforcement**: Filter the counts to only include those that appear `k` times or fewer. 3. **Result Calculation**: Count the filtered numbers and return the result. 4. **Edge Cases**: Ensure to handle empty arrays, arrays with all elements being the same, and arrays where no number meets the `k` appearance criteria.","solution":"from collections import Counter def count_unique_with_limit(arr: list[int], k: int) -> int: Returns the count of unique numbers in the `arr` that appear `k` times or fewer. if not isinstance(arr, list) or not isinstance(k, int) or k < 0: raise ValueError(\\"Invalid input\\") count = Counter(arr) limited_count_numbers = [num for num, freq in count.items() if 0 < freq <= k] return len(limited_count_numbers)"},{"question":"# Context Natural language processing (NLP) often involves the handling and manipulation of large text corpus. Tokenizing text into sentences and words is a foundational step in many NLP tasks. Efficient and accurate tokenization helps in preparing the text for more advanced processing such as sentiment analysis, text classification, and named entity recognition. # Problem Statement Write a function, `tokenize_text(text)`, that takes a string representing multiple sentences as input and returns a list of words in the order they appear in the text. You should use regular expressions to split the text into sentences and then further into words. Punctuation should be removed from the words. # Function Signature ```python def tokenize_text(text: str) -> List[str]: pass ``` # Input * `text`: A string containing multiple sentences. # Output * A list of strings where each string is a word from the input text, in the order they appear. # Constraints * The input `text` will contain at least one word. * Sentences in the input `text` will be separated by spaces and punctuation marks (periods, commas, exclamation marks, question marks). * Words in sentences are separated by spaces and may be followed by punctuation marks. * Punctuation marks should be removed. # Example ```python text = \\"Hello, world! This is a sample text. Let\'s tokenize it, shall we?\\" words = tokenize_text(text) print(words) ``` # Expected Output ```python [\'Hello\', \'world\', \'This\', \'is\', \'a\', \'sample\', \'text\', \'Lets\', \'tokenize\', \'it\', \'shall\', \'we\'] ``` # Explanation In this example, the `tokenize_text` function splits the input text into sentences and then into individual words, removing any punctuation marks. The resulting list contains words in the same order they appear in the text, but without punctuation.","solution":"import re from typing import List def tokenize_text(text: str) -> List[str]: Tokenizes the input text into words and removes punctuation. Args: - text (str): The input text string containing multiple sentences. Returns: - List[str]: A list of words from the text in the order they appear, with punctuation removed. # Use a regular expression to split the text into words, removing punctuation words = re.findall(r\'bw+b\', text) return words"},{"question":"# Objective Implement a function to find the length of the shortest path in an unweighted graph from a given start node to an end node. # Problem Description Given an unweighted graph represented as an adjacency list and two nodes `start` and `end`, write a function `shortest_path_length(graph: List[List[int]], start: int, end: int) -> int` to determine the length of the shortest path from the `start` node to the `end` node. If there is no path, return `-1`. # Input and Output Formats * **Input**: * A list of lists of integers where `graph[i]` contains the nodes that are directly connected to node `i`. * Two integers `start` and `end` representing the starting and ending nodes respectively. ```python from typing import List ``` * **Output**: An integer representing the length of the shortest path from `start` to `end`. If no such path exists, return `-1`. # Constraints 1. The number of nodes `n` in the graph is in the range `[1, 1000]`. 2. The total number of edges is at most `10000`. 3. There are no self-loops or multiple edges. 4. `0 <= start, end < n` 5. The graph nodes are indexed from `0` to `n-1`. # Performance Requirements * The function should perform breadth-first search (BFS) to find the shortest path efficiently in O(n + m) time complexity where `n` is the number of nodes and `m` is the number of edges. # Function Signature Example ```python def shortest_path_length(graph: List[List[int]], start: int, end: int) -> int: # Your code here pass ``` # Example ```python graph = [ [1, 2], [0, 3], [0, 3], [1, 2], ] print(shortest_path_length(graph, 0, 3)) # Output: 2 ``` # Edge Cases 1. The graph is a single node. 2. The start and end nodes are the same. 3. There is no path between the start and end nodes. 4. The graph is fully connected vs. sparsely connected.","solution":"from typing import List from collections import deque def shortest_path_length(graph: List[List[int]], start: int, end: int) -> int: Determines the length of the shortest path from start node to end node in an unweighted graph represented as an adjacency list. If no such path exists, returns -1. :param graph: List of lists, where graph[i] contains the nodes that are directly connected to node i. :param start: The starting node. :param end: The ending node. :return: Length of the shortest path from start to end, or -1 if no such path exists. if start == end: return 0 # BFS initialization queue = deque([(start, 0)]) # (current_node, current_distance) visited = set() visited.add(start) while queue: current_node, current_distance = queue.popleft() for neighbor in graph[current_node]: if neighbor == end: return current_distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_distance + 1)) return -1"},{"question":"# Coding Assessment Question Problem Statement You are tasked with writing a function to evaluate the validity of a Sudoku puzzle. A Sudoku puzzle is a 9x9 grid, partially filled with numbers from 1 to 9, such that each row, column, and 3x3 sub-grid contains each number from 1 to 9 at most once. The function should determine if the puzzle is valid according to these rules but does not need to solve it. Input Format - A 2D list `board` of size 9x9 where each cell contains an integer from 1 to 9 or 0 (where 0 represents an empty cell). Output Format - A boolean value `True` if the Sudoku puzzle is valid, otherwise `False`. Constraints - The input board will always be a 9x9 grid. - The values in the board will be integers from 0 to 9. - Solve the problem with a time complexity of O(1), considering only a fixed 9x9 grid. Example ```python board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] print(is_valid_sudoku(board)) # Expected Output: True ``` Function Signature ```python def is_valid_sudoku(board: list[list[int]]) -> bool: pass ``` Requirements 1. Implement the `is_valid_sudoku` function that follows the above description. 2. Ensure the function checks for duplicates in rows, columns, and 3x3 sub-grids. 3. Optimize the solution for a fixed 9x9 Sudoku board.","solution":"def is_valid_sudoku(board): Determine if the given 9x9 Sudoku board is valid. def is_valid_unit(unit): Check if a row/column/3x3 grid contains no duplicates excluding zeros. unit = [num for num in unit if num != 0] return len(unit) == len(set(unit)) # Check rows for row in board: if not is_valid_unit(row): return False # Check columns for col_idx in range(9): column = [board[row_idx][col_idx] for row_idx in range(9)] if not is_valid_unit(column): return False # Check 3x3 sub-grids for box_row in range(3): for box_col in range(3): sub_grid = [] for row in range(box_row * 3, (box_row + 1) * 3): for col in range(box_col * 3, (box_col + 1) * 3): sub_grid.append(board[row][col]) if not is_valid_unit(sub_grid): return False return True"},{"question":"# Question: Validate and Extract Numbers from String **Problem Description**: Write a function `extract_numbers(input_string: str) -> List[int]` that scans through the given input string, validates it, and extracts all numeric values present in it. The function should ignore any non-numeric characters and return the numbers as a list of integers. Constraints to handle include empty strings, strings with no numeric characters, and strings with mixed content. Leading zeros in the numbers should be ignored in the conversion. **Input Format**: - A string `input_string` that might contain a mix of numeric and non-numeric characters, potentially including spaces. **Output Format**: - A list of integers extracted from the input string. Return an empty list if there are no valid numeric values in the input string. **Constraints**: - The input string can be of any length but should not exceed 10,000 characters. - The function should correctly handle negative numbers and discard leading zeros in extracted numbers. **Function Signature**: ```python def extract_numbers(input_string: str) -> List[int]: ``` **Examples**: ```python >>> extract_numbers(\\"\\") [] >>> extract_numbers(\\"no_numbers\\") [] >>> extract_numbers(\\"123abc456\\") [123, 456] >>> extract_numbers(\\"-00120 an apple 99 dollars\\") [-120, 99] >>> extract_numbers(\\" 0 1024 030 \\") [0, 1024, 30] >>> extract_numbers(\\"multiple -987 mixed -03 007 -300 values\\") [-987, -3, 7, -300] ``` **Performance Requirement**: - The function should operate in linear time relative to the length of the input string.","solution":"import re from typing import List def extract_numbers(input_string: str) -> List[int]: Extracts all numeric values from the given input string and returns them as a list of integers. # Regular expression to capture numbers with possible leading sign pattern = r\'-?d+\' # Find all matches based on the pattern matches = re.findall(pattern, input_string) # Convert the matches to integers, handling the removal of leading zeros return [int(match) for match in matches]"},{"question":"**Scenario**: As part of developing a new application, you need to monitor the performance of various functions over time. This involves collecting, storing, and retrieving time-tagged numerical data. Implement a feature within your application for efficient insertion and retrieval of numeric data based on timestamps. **Task**: Implement the class `TimeSeriesData` which supports efficient insertion of data points and retrieval of the average value within a specified time range. The class should maintain an ordered collection of timestamped data points and support the following methods: `add_data_point`, `get_average`. # Class and Method Definitions: - `TimeSeriesData`: The main class for handling the time series data. - `add_data_point(timestamp: int, value: float) -> None`: Adds a data point to the time series. - `timestamp` (int): The timestamp of the data point (in seconds since epoch). - `value` (float): The numeric value associated with this timestamp. - `get_average(start_time: int, end_time: int) -> float`: Returns the average of values within the given time range, inclusive. - `start_time` (int): Start time of the range (in seconds since epoch). - `end_time` (int): End time of the range (in seconds since epoch). # Constraints: - All timestamps will be unique and given in non-decreasing order. - `start_time` and `end_time` will be valid and `start_time` will be less than or equal to `end_time`. - If there are no data points within the given range, return 0.0. # Example: ```python from collections import defaultdict class TimeSeriesData: def __init__(self): self.data = [] def add_data_point(self, timestamp: int, value: float) -> None: Adds a timestamp-value pair to the data collection. >>> ts = TimeSeriesData() >>> ts.add_data_point(1609459200, 10.0) >>> ts.add_data_point(1609459260, 12.0) >>> ts.data [(1609459200, 10.0), (1609459260, 12.0)] self.data.append((timestamp, value)) def get_average(self, start_time: int, end_time: int) -> float: Computes the average of values within the specified time range. >>> ts = TimeSeriesData() >>> ts.add_data_point(1609459200, 10.0) >>> ts.add_data_point(1609459260, 12.0) >>> ts.get_average(1609459200, 1609459260) 11.0 >>> ts.get_average(1609459300, 1609460000) 0.0 total, count = 0.0, 0 for timestamp, value in self.data: if start_time <= timestamp <= end_time: total += value count += 1 return round(total / count, 2) if count > 0 else 0.0 if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Notes**: - The `add_data_point` method ensures that data points are added in chronological order. - The `get_average` method calculates the average for data points within the specified range, taking careful note of boundary conditions. This question tests your ability to manage and retrieve data from a real-time series efficiently, a common task in performance monitoring and data analysis systems.","solution":"class TimeSeriesData: def __init__(self): self.data = [] def add_data_point(self, timestamp: int, value: float) -> None: Adds a timestamp-value pair to the data collection. >>> ts = TimeSeriesData() >>> ts.add_data_point(1609459200, 10.0) >>> ts.add_data_point(1609459260, 12.0) >>> ts.data [(1609459200, 10.0), (1609459260, 12.0)] self.data.append((timestamp, value)) def get_average(self, start_time: int, end_time: int) -> float: Computes the average of values within the specified time range. >>> ts = TimeSeriesData() >>> ts.add_data_point(1609459200, 10.0) >>> ts.add_data_point(1609459260, 12.0) >>> ts.get_average(1609459200, 1609459260) 11.0 >>> ts.get_average(1609459300, 1609460000) 0.0 total, count = 0.0, 0 for timestamp, value in self.data: if start_time <= timestamp <= end_time: total += value count += 1 return round(total / count, 2) if count > 0 else 0.0"},{"question":"# Problem Statement Write a function `find_rotated_index(nums: list[int], target: int) -> int` that takes a rotated sorted array `nums` and a target value `target`, and returns the index of `target` in `nums`. If `target` is not present in `nums`, return -1. A rotated array means that some leading elements have been moved to the end of the array. For example, the array `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`. # Function Signature ```python def find_rotated_index(nums: list[int], target: int) -> int: ``` # Input * `nums` (list of int): A list of integers representing the rotated sorted array. * `target` (int): The target value to search for in the array. # Output * (int): The index of the `target` in `nums` or -1 if `target` is not found. # Constraints * The array `nums` will have a length between 1 and 5000. * Each element in `nums` will be an integer in the range `-10^4` to `10^4`. * The array `nums` does not contain duplicates. # Examples ```python >>> find_rotated_index([4,5,6,7,0,1,2], 0) 4 >>> find_rotated_index([4,5,6,7,0,1,2], 3) -1 >>> find_rotated_index([1], 0) -1 >>> find_rotated_index([1,3,5], 1) 0 >>> find_rotated_index([1,2,3], 3) 2 ``` # Implementation Requirements * The solution should have a time complexity of O(log n) using binary search. * Ensure the function handles cases where the array is not rotated (i.e., it is completely sorted).","solution":"def find_rotated_index(nums, target): This function takes a rotated sorted array and a target value, and returns the index of the target in the array. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Determine the sorted part if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement You are given a directed graph represented by an adjacency matrix, where the element at index (i, j) is 1 if there is a direct edge from node (i) to node (j), and 0 otherwise. Your task is to determine if the graph contains a cycle. # Context In graph theory, detecting cycles in a directed graph is a crucial problem with applications in various fields such as scheduling, electronic circuit design, and deadlock detection in operating systems. Given an adjacency matrix of a directed graph, determine if the graph contains any cycles. # Function Signature ```python def contains_cycle(adj_matrix: List[List[int]]) -> bool: ``` # Input - `adj_matrix`: A 2D list where `adj_matrix[i][j]` is 1 if there is a direct edge from node `i` to node `j`, and 0 otherwise. # Output - A boolean value indicating whether the graph contains a cycle (`True`) or not (`False`). # Constraints - The adjacency matrix is square, meaning the number of rows equals the number of columns. - The graph does not contain self-loops (i.e., `adj_matrix[i][i]` is always 0). # Example ```python adj_matrix_1 = [ [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0] ] adj_matrix_2 = [ [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0] ] result_1 = contains_cycle(adj_matrix_1) print(result_1) # Should output: True, because there is a cycle: 0->1->2->3->0 result_2 = contains_cycle(adj_matrix_2) print(result_2) # Should output: False, because there is no cycle ``` # Specifications 1. Convert the adjacency matrix into a graph representation where each node points to its neighbors. 2. Use an algorithm such as Depth-First Search (DFS) to detect cycles in the graph. 3. Implement error handling for any input anomalies, such as non-square matrices, although such inputs are not expected based on the constraints. 4. Optimize for clarity and efficiency to ensure the function performs well on larger graphs.","solution":"from typing import List def contains_cycle(adj_matrix: List[List[int]]) -> bool: def dfs(node: int, visiting: List[bool], visited: List[bool]) -> bool: visiting[node] = True for neighbor, has_edge in enumerate(adj_matrix[node]): if has_edge: if not visited[neighbor]: # If not fully processed if visiting[neighbor]: # If visiting again, cycle detected return True if dfs(neighbor, visiting, visited): # DFS the neighbor return True visiting[node] = False visited[node] = True return False n = len(adj_matrix) if n == 0: return False visiting = [False] * n visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, visiting, visited): # Start DFS from the current node return True return False"},{"question":"# Implementing a Queue using Two Stacks **Problem Statement**: You need to implement a queue using two stacks. The queue should support the standard operations: enqueue (adding an element to the end of the queue) and dequeue (removing the first element from the queue). Assume stack operations (push and pop) are already available to you. # Function Signature ```python class QueueUsingStacks: def __init__(self): pass def enqueue(self, x: int) -> None: pass def dequeue(self) -> int: pass ``` # Requirements - You must use two stacks to implement the queue. - Implement the `enqueue(x)` method to add an element `x` to the end of the queue. - Implement the `dequeue()` method to remove and return the first element of the queue. - If the queue is empty when dequeuing, return `None` or raise an appropriate exception. # Example Usage ```python queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 1 queue.enqueue(4) assert queue.dequeue() == 2 assert queue.dequeue() == 3 assert queue.dequeue() == 4 assert queue.dequeue() is None # Or raises an exception ``` # Detailed Explanation 1. **Stack Operations**: Assume you have two operations available for stacks: - `push(x)`: Adds element `x` to the top of the stack. - `pop()`: Removes and returns the top element of the stack. If the stack is empty, it should return `None`. 2. **Enqueue Operation**: When an element is enqueued, push it onto the first stack. 3. **Dequeue Operation**: When an element is dequeued, if the second stack is empty, pop all elements from the first stack and push them onto the second stack. Then, pop the top element from the second stack. 4. **Internal State**: Maintain two stacks to function correctly: - `stack1` for enqueue operations. - `stack2` for dequeue operations when `stack2` is empty. 5. **Edge Cases**: Handle edge cases where dequeue operations are attempted on an empty queue by returning `None` or raising an exception. # Constraints - All operations (enqueue and dequeue) should have an average time complexity of O(1). By designing your queue in this manner with two stacks, you utilize stack operations to simulate the behavior of a queue, maintaining appropriate order for enqueue and dequeue operations seamlessly.","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: self.stack1.append(x) def dequeue(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() if self.stack2 else None"},{"question":"# Task: Implement a Thread-Safe Bounded Blocking Queue Context: A system requirement involves handling concurrent operations involving a bounded blocking queue in a thread-safe manner. This is essential for managing producer-consumer problems efficiently, ensuring threads are properly synchronized. Problem: Implement a `BoundedBlockingQueue` class with the proper synchronization mechanisms to support operations in a multi-threaded environment. Requirements: - **Key Functionality**: - Implement the `BoundedBlockingQueue` class that supports standard queue operations. - Ensure thread safety for concurrent put and take operations. - **Input/Output**: ```python import threading class BoundedBlockingQueue: def __init__(self, capacity: int) -> None def enqueue(self, item: int) -> None # adds item to the queue def dequeue(self) -> int # removes and returns the item from the queue ``` - **Constraints**: - The queue should have a fixed size specified at initialization. - If the queue is full, `enqueue` should block until space is available. - If the queue is empty, `dequeue` should block until an item is available. - Use appropriate synchronization primitives from the `threading` module. - **Performance Expectations**: - Ensure that operations maintain a time complexity of O(1) in most scenarios under concurrent access. Function Signatures: You need to define the following: ```python def enqueue(self, item: int) -> None: # adds item to the queue pass def dequeue(self) -> int: # removes and returns the item from the queue pass ``` Example: ```python bbq = BoundedBlockingQueue(2) producer_thread1 = threading.Thread(target=lambda: bbq.enqueue(1)) producer_thread2 = threading.Thread(target=lambda: bbq.enqueue(2)) producer_thread3 = threading.Thread(target=lambda: bbq.enqueue(3)) # Blocks until dequeue occurs consumer_thread1 = threading.Thread(target=lambda: print(bbq.dequeue())) # Output: 1 consumer_thread2 = threading.Thread(target=lambda: print(bbq.dequeue())) # Output: 2 producer_thread1.start() producer_thread2.start() producer_thread3.start() consumer_thread1.start() consumer_thread2.start() ``` Implement the `BoundedBlockingQueue` class to handle operations in a highly concurrent environment using appropriate synchronization mechanisms.","solution":"import threading from collections import deque class BoundedBlockingQueue: def __init__(self, capacity: int) -> None: self.capacity = capacity self.queue = deque() self.lock = threading.Lock() self.not_full = threading.Condition(self.lock) self.not_empty = threading.Condition(self.lock) def enqueue(self, item: int) -> None: with self.not_full: while len(self.queue) == self.capacity: self.not_full.wait() self.queue.append(item) self.not_empty.notify() def dequeue(self) -> int: with self.not_empty: while not self.queue: self.not_empty.wait() item = self.queue.popleft() self.not_full.notify() return item"},{"question":"**Objective**: To design and implement a basic HTTP server in Python that can handle GET and POST requests, serve static files, and manage a simple key-value store. **HTTP Server Implementation**: Implement a Python class `SimpleHTTPServer` that handles HTTP requests, specifically GET and POST, to serve static files and store/retrieve key-value pairs. # Tasks 1. **start_server**: Initialize and start the server, specifying the host and port to listen on. Ensure the server runs in a loop to handle multiple requests. - **Parameters:** `host` (string) and `port` (integer). - **Return:** `None`. 2. **handle_get**: Handle GET requests. Serve a static file if the path corresponds to an existing file in the server\'s directory. If the request targets a key-value pair, return the value corresponding to the key. - **Parameters:** `path` (string). - **Return:** HTTP response with the appropriate content. 3. **handle_post**: Handle POST requests to store a key-value pair. The request body will contain JSON data with a `key` and `value`. - **Parameters:** `path` (string), `body` (JSON formatted string). - **Return:** HTTP response indicating success or failure. 4. **serve_file**: A helper method to serve static files. - **Parameters:** `file_path` (string). - **Return:** Content of the file or HTTP 404 if not found. 5. **store_key_value**: A helper method to store a key-value pair in memory. - **Parameters:** `key` (string), `value` (string). - **Return:** None. 6. **retrieve_value**: A helper method to retrieve a value for a given key. - **Parameters:** `key` (string). - **Return:** The value corresponding to the key or HTTP 404 if the key doesn\'t exist. # Specifications - Use standard Python libraries such as `http.server` and `json`. - The server should be able to handle multiple requests in a single run. - Implement basic error handling for invalid requests and server errors. # Example ```python from SimpleHTTPServer import SimpleHTTPServer # Example usage server = SimpleHTTPServer() server.start_server(\\"127.0.0.1\\", 8080) ``` # Running the Server 1. Start the server using `start_server` method. 2. Use a browser or tools like `curl` to interact with the server. **Example Interactions:** - **GET request to serve a file**: ``` curl http://127.0.0.1:8080/index.html # Should return the content of \\"index.html\\" if it exists ``` - **POST request to store a key-value pair**: ``` curl -X POST http://127.0.0.1:8080/store -d \'{\\"key\\": \\"name\\", \\"value\\": \\"Alice\\"}\' ``` - **GET request to retrieve a key-value pair**: ``` curl http://127.0.0.1:8080/name # Should return \\"Alice\\" if the pair was stored ``` # Constraints: - The server should be able to handle up to 100 concurrent connections. - Keys and values in the key-value store should be strings with a maximum length of 256 characters. - The size of a static file served by the server should not exceed 5MB. **Note**: Focus on handling HTTP request parsing, serving files efficiently, and managing the in-memory store for key-value pairs.","solution":"from http.server import BaseHTTPRequestHandler, HTTPServer import json import os class SimpleHTTPServer(BaseHTTPRequestHandler): key_value_store = {} def do_GET(self): if self.path.startswith(\'/store/\'): key = self.path[len(\'/store/\'):] self.retrieve_value(key) else: self.serve_file(self.path[1:]) def do_POST(self): if self.path == \'/store\': content_length = int(self.headers[\'Content-Length\']) post_data = self.rfile.read(content_length) self.store_key_value(post_data) else: self.send_error(404, \\"Endpoint not found\\") def serve_file(self, file_path): if os.path.isfile(file_path): with open(file_path, \'rb\') as file: content = file.read() self.send_response(200) self.send_header(\'Content-type\', \'text/html\') self.end_headers() self.wfile.write(content) else: self.send_error(404, \\"File not found\\") def store_key_value(self, post_data): try: data = json.loads(post_data) key = data.get(\'key\') value = data.get(\'value\') if key and value: self.key_value_store[key] = value self.send_response(200) self.end_headers() self.wfile.write(b\\"Stored successfully\\") else: self.send_error(400, \\"Invalid data format\\") except json.JSONDecodeError: self.send_error(400, \\"Invalid JSON format\\") def retrieve_value(self, key): if key in self.key_value_store: self.send_response(200) self.send_header(\'Content-type\', \'text/plain\') self.end_headers() self.wfile.write(self.key_value_store[key].encode()) else: self.send_error(404, \\"Key not found\\") def start_server(host, port): server_address = (host, port) httpd = HTTPServer(server_address, SimpleHTTPServer) httpd.serve_forever()"},{"question":"# Array Transformation with Function Application Background You are given an array of integers. Your task is to apply a given mathematical function to each element of the array and return the transformed array. Task Write a function `transform_array(arr: List[int], func: Callable[[int], int]) -> List[int]` that takes an array of integers `arr` and a function `func` that takes an integer as input and returns an integer. Your function should return a new array where each element is the result of applying `func` to the corresponding element of `arr`. Input * A list of integers `arr`. * A function `func` which accepts an integer and returns an integer. Output * A list of integers representing the transformed array. Constraints * The input list can have between 0 and 1000 elements. * Each element in the input list is between `-10^9` and `10^9`. * The function will be provided and does not need to be implemented by you. Example ```python def square(x): return x * x assert transform_array([1, 2, 3, 4], square) == [1, 4, 9, 16] def increment(x): return x + 1 assert transform_array([1, 2, 3], increment) == [2, 3, 4] def negate(x): return -x assert transform_array([-1, -2, -3], negate) == [1, 2, 3] ``` Notes * You do not need to handle function implementation; assume that `func` will always be a valid callable. * Ensure to validate edge cases where the input list is empty or contains only negative numbers.","solution":"from typing import List, Callable def transform_array(arr: List[int], func: Callable[[int], int]) -> List[int]: Transforms each element in the input array using the provided function. Parameters: arr (List[int]): The input list of integers. func (Callable[[int], int]): The function to apply to each element. Returns: List[int]: The transformed list of integers. return [func(x) for x in arr]"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},L={class:"card-container"},F={key:0,class:"empty-state"},R=["disabled"],z={key:0},D={key:1};function P(r,e,l,m,s,a){const p=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const Y=h(N,[["render",P],["__scopeId","data-v-1142dc29"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/30.md","filePath":"drive/30.md"}'),j={name:"drive/30.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,U as default};
